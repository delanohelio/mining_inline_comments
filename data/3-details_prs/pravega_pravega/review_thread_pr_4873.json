{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM0OTA4MzUy", "number": 4873, "reviewThreads": {"totalCount": 65, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwNzoyMjo1NFrOEHdIzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMDozMTozOVrOEPe-_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2MjUyODc4OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/connection/impl/AppendBatchSizeTrackerImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwNzoyMjo1NFrOGm0tFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQyMzo0ODoyMFrOGnUjAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM2MjU4Mg==", "bodyText": "Please, revert this change as it may be inducing artifacts on the client latency and makes it difficult to compare with the master version. It would be great to have the batching-related changes on a separate PR.", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r443362582", "createdAt": "2020-06-22T07:22:54Z", "author": {"login": "RaulGracia"}, "path": "client/src/main/java/io/pravega/client/connection/impl/AppendBatchSizeTrackerImpl.java", "diffHunk": "@@ -27,19 +27,24 @@\n  * synchronous writers. Otherwise the batch size is set to the amount of data that will be written in the next\n  * {@link #MAX_BATCH_TIME_MILLIS} or half the server round trip time (whichever is less)\n  */\n-class AppendBatchSizeTrackerImpl implements AppendBatchSizeTracker {\n-    private static final int MAX_BATCH_TIME_MILLIS = 100;\n-\n+public class AppendBatchSizeTrackerImpl implements AppendBatchSizeTracker {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef406056653ea87101f3d79e245791ebcfd46217"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzg4NDI5MA==", "bodyText": "I don't think the changes here are function in nature. Please feel free to verify this.", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r443884290", "createdAt": "2020-06-22T23:48:20Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/connection/impl/AppendBatchSizeTrackerImpl.java", "diffHunk": "@@ -27,19 +27,24 @@\n  * synchronous writers. Otherwise the batch size is set to the amount of data that will be written in the next\n  * {@link #MAX_BATCH_TIME_MILLIS} or half the server round trip time (whichever is less)\n  */\n-class AppendBatchSizeTrackerImpl implements AppendBatchSizeTracker {\n-    private static final int MAX_BATCH_TIME_MILLIS = 100;\n-\n+public class AppendBatchSizeTrackerImpl implements AppendBatchSizeTracker {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM2MjU4Mg=="}, "originalCommit": {"oid": "ef406056653ea87101f3d79e245791ebcfd46217"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2MzEyNzMwOnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/connection/impl/IoBuffer.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMDoxODowOVrOGm6k2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMDo1ODo0M1rOGrOOxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ1ODc3OQ==", "bodyText": "Should this class be in package common along with all the other Byte-related classes?", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r443458779", "createdAt": "2020-06-22T10:18:09Z", "author": {"login": "RaulGracia"}, "path": "client/src/main/java/io/pravega/client/connection/impl/IoBuffer.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.connection.impl;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.pravega.common.MathHelpers;\n+import io.pravega.shared.protocol.netty.WireCommands;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+\n+class IoBuffer {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef406056653ea87101f3d79e245791ebcfd46217"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3NDUzOA==", "bodyText": "No. It uses Netty ByteBuf so it cannot go in common.", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r447974538", "createdAt": "2020-06-30T20:57:43Z", "author": {"login": "andreipaduroiu"}, "path": "client/src/main/java/io/pravega/client/connection/impl/IoBuffer.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.connection.impl;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.pravega.common.MathHelpers;\n+import io.pravega.shared.protocol.netty.WireCommands;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+\n+class IoBuffer {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ1ODc3OQ=="}, "originalCommit": {"oid": "ef406056653ea87101f3d79e245791ebcfd46217"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3NTEwOA==", "bodyText": "@tkaitchuck Can you write some Javadoc on this class to explain what it does?", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r447975108", "createdAt": "2020-06-30T20:58:43Z", "author": {"login": "andreipaduroiu"}, "path": "client/src/main/java/io/pravega/client/connection/impl/IoBuffer.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.connection.impl;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.pravega.common.MathHelpers;\n+import io.pravega.shared.protocol.netty.WireCommands;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+\n+class IoBuffer {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ1ODc3OQ=="}, "originalCommit": {"oid": "ef406056653ea87101f3d79e245791ebcfd46217"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2MzEzNTc4OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/segment/impl/SegmentInputStreamImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMDoyMDo1NVrOGm6qSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwMDowOTozNFrOGqm0mA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ2MDE2OA==", "bodyText": "Is this faster compared to what it was?", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r443460168", "createdAt": "2020-06-22T10:20:55Z", "author": {"login": "RaulGracia"}, "path": "client/src/main/java/io/pravega/client/segment/impl/SegmentInputStreamImpl.java", "diffHunk": "@@ -178,7 +178,9 @@ private void issueRequestIfNeeded() {\n         //compute read length based on current offset up to which the events are read.\n         int updatedReadLength = computeReadLength(offset + buffer.dataAvailable());\n         if (!receivedEndOfSegment && !receivedTruncated && updatedReadLength > 0 && outstandingRequest == null) {\n-            log.trace(\"Issuing read request for segment {} of {} bytes\", getSegmentId(), updatedReadLength);\n+            if (log.isTraceEnabled()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef406056653ea87101f3d79e245791ebcfd46217"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMyOTQzMg==", "bodyText": "It showed up in the flamegraph before, so yes.", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r447329432", "createdAt": "2020-06-30T00:09:34Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/segment/impl/SegmentInputStreamImpl.java", "diffHunk": "@@ -178,7 +178,9 @@ private void issueRequestIfNeeded() {\n         //compute read length based on current offset up to which the events are read.\n         int updatedReadLength = computeReadLength(offset + buffer.dataAvailable());\n         if (!receivedEndOfSegment && !receivedTruncated && updatedReadLength > 0 && outstandingRequest == null) {\n-            log.trace(\"Issuing read request for segment {} of {} bytes\", getSegmentId(), updatedReadLength);\n+            if (log.isTraceEnabled()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ2MDE2OA=="}, "originalCommit": {"oid": "ef406056653ea87101f3d79e245791ebcfd46217"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2MzM0MzA5OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/connection/impl/IoBuffer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMToyOTo1NFrOGm8sTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQyMzo1MzoxNVrOGnUojA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ5MzQ1Mg==", "bodyText": "we should have a similar range check as in line 39 .", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r443493452", "createdAt": "2020-06-22T11:29:54Z", "author": {"login": "shrids"}, "path": "client/src/main/java/io/pravega/client/connection/impl/IoBuffer.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.connection.impl;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.pravega.common.MathHelpers;\n+import io.pravega.shared.protocol.netty.WireCommands;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+\n+class IoBuffer {\n+    private int maxBufferSize = WireCommands.MAX_WIRECOMMAND_SIZE;\n+    private ByteBuffer buffer = null;\n+    \n+    private ByteBuf sliceOut(int size) {\n+        ByteBuf result = Unpooled.wrappedBuffer(buffer.array(), buffer.arrayOffset() + buffer.position(), size);\n+        buffer.position(buffer.position() + size);\n+        if (!buffer.hasRemaining()) {\n+            buffer = null;\n+        }\n+        return result;\n+    }\n+    \n+    public ByteBuf getBuffOfSize(InputStream in, int size) throws IOException {\n+        if (size > maxBufferSize) {\n+            throw new IllegalArgumentException(\"Requested buffer size \" + size + \" is larger than maximum allowed\"\n+                    + maxBufferSize);\n+        }\n+        if (buffer == null) {\n+            int bufferSize = MathHelpers.minMax(in.available(), size, maxBufferSize);\n+            byte[] newBuffer = new byte[bufferSize];\n+            int read = in.read(newBuffer);\n+            buffer = ByteBuffer.wrap(newBuffer, 0, read); \n+        } \n+\n+        if (buffer.remaining() >= size) {\n+            return sliceOut(size);\n+        } else {\n+            int firstSize = buffer.remaining();\n+            ByteBuf first = sliceOut(firstSize);\n+            assert buffer == null; //Should have been fully sliced out\n+            byte[] remaining = new byte[size - firstSize];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef406056653ea87101f3d79e245791ebcfd46217"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzg4NTcwOA==", "bodyText": "Size is bounded by the check on line 35. firstSize is always a positive number, so remaining is always smaller than maxBufferSize", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r443885708", "createdAt": "2020-06-22T23:53:15Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/connection/impl/IoBuffer.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.connection.impl;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.pravega.common.MathHelpers;\n+import io.pravega.shared.protocol.netty.WireCommands;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+\n+class IoBuffer {\n+    private int maxBufferSize = WireCommands.MAX_WIRECOMMAND_SIZE;\n+    private ByteBuffer buffer = null;\n+    \n+    private ByteBuf sliceOut(int size) {\n+        ByteBuf result = Unpooled.wrappedBuffer(buffer.array(), buffer.arrayOffset() + buffer.position(), size);\n+        buffer.position(buffer.position() + size);\n+        if (!buffer.hasRemaining()) {\n+            buffer = null;\n+        }\n+        return result;\n+    }\n+    \n+    public ByteBuf getBuffOfSize(InputStream in, int size) throws IOException {\n+        if (size > maxBufferSize) {\n+            throw new IllegalArgumentException(\"Requested buffer size \" + size + \" is larger than maximum allowed\"\n+                    + maxBufferSize);\n+        }\n+        if (buffer == null) {\n+            int bufferSize = MathHelpers.minMax(in.available(), size, maxBufferSize);\n+            byte[] newBuffer = new byte[bufferSize];\n+            int read = in.read(newBuffer);\n+            buffer = ByteBuffer.wrap(newBuffer, 0, read); \n+        } \n+\n+        if (buffer.remaining() >= size) {\n+            return sliceOut(size);\n+        } else {\n+            int firstSize = buffer.remaining();\n+            ByteBuf first = sliceOut(firstSize);\n+            assert buffer == null; //Should have been fully sliced out\n+            byte[] remaining = new byte[size - firstSize];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ5MzQ1Mg=="}, "originalCommit": {"oid": "ef406056653ea87101f3d79e245791ebcfd46217"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2MzM1MTA0OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/connection/impl/IoBuffer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMTozMjo0NVrOGm8xdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQyMzo1MDozMFrOGnUljQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ5NDc3NQ==", "bodyText": "The variable read can be less than size right ?\nIf yes, we would need to handle that scenario too.", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r443494775", "createdAt": "2020-06-22T11:32:45Z", "author": {"login": "shrids"}, "path": "client/src/main/java/io/pravega/client/connection/impl/IoBuffer.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.connection.impl;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.pravega.common.MathHelpers;\n+import io.pravega.shared.protocol.netty.WireCommands;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+\n+class IoBuffer {\n+    private int maxBufferSize = WireCommands.MAX_WIRECOMMAND_SIZE;\n+    private ByteBuffer buffer = null;\n+    \n+    private ByteBuf sliceOut(int size) {\n+        ByteBuf result = Unpooled.wrappedBuffer(buffer.array(), buffer.arrayOffset() + buffer.position(), size);\n+        buffer.position(buffer.position() + size);\n+        if (!buffer.hasRemaining()) {\n+            buffer = null;\n+        }\n+        return result;\n+    }\n+    \n+    public ByteBuf getBuffOfSize(InputStream in, int size) throws IOException {\n+        if (size > maxBufferSize) {\n+            throw new IllegalArgumentException(\"Requested buffer size \" + size + \" is larger than maximum allowed\"\n+                    + maxBufferSize);\n+        }\n+        if (buffer == null) {\n+            int bufferSize = MathHelpers.minMax(in.available(), size, maxBufferSize);\n+            byte[] newBuffer = new byte[bufferSize];\n+            int read = in.read(newBuffer);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef406056653ea87101f3d79e245791ebcfd46217"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzg4NDk0MQ==", "bodyText": "Yes. It can. I believe this is handled. Notice line 46.", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r443884941", "createdAt": "2020-06-22T23:50:30Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/connection/impl/IoBuffer.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.connection.impl;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.pravega.common.MathHelpers;\n+import io.pravega.shared.protocol.netty.WireCommands;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+\n+class IoBuffer {\n+    private int maxBufferSize = WireCommands.MAX_WIRECOMMAND_SIZE;\n+    private ByteBuffer buffer = null;\n+    \n+    private ByteBuf sliceOut(int size) {\n+        ByteBuf result = Unpooled.wrappedBuffer(buffer.array(), buffer.arrayOffset() + buffer.position(), size);\n+        buffer.position(buffer.position() + size);\n+        if (!buffer.hasRemaining()) {\n+            buffer = null;\n+        }\n+        return result;\n+    }\n+    \n+    public ByteBuf getBuffOfSize(InputStream in, int size) throws IOException {\n+        if (size > maxBufferSize) {\n+            throw new IllegalArgumentException(\"Requested buffer size \" + size + \" is larger than maximum allowed\"\n+                    + maxBufferSize);\n+        }\n+        if (buffer == null) {\n+            int bufferSize = MathHelpers.minMax(in.available(), size, maxBufferSize);\n+            byte[] newBuffer = new byte[bufferSize];\n+            int read = in.read(newBuffer);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ5NDc3NQ=="}, "originalCommit": {"oid": "ef406056653ea87101f3d79e245791ebcfd46217"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2MzM1NjA3OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/connection/impl/IoBuffer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMTozNDo0M1rOGm80xQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxOTo1Nzo1OVrOGw3ptA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ5NTYyMQ==", "bodyText": "Should we include a timeout mechanism similar to the one we have in the current client?", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r443495621", "createdAt": "2020-06-22T11:34:43Z", "author": {"login": "shrids"}, "path": "client/src/main/java/io/pravega/client/connection/impl/IoBuffer.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.connection.impl;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.pravega.common.MathHelpers;\n+import io.pravega.shared.protocol.netty.WireCommands;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+\n+class IoBuffer {\n+    private int maxBufferSize = WireCommands.MAX_WIRECOMMAND_SIZE;\n+    private ByteBuffer buffer = null;\n+    \n+    private ByteBuf sliceOut(int size) {\n+        ByteBuf result = Unpooled.wrappedBuffer(buffer.array(), buffer.arrayOffset() + buffer.position(), size);\n+        buffer.position(buffer.position() + size);\n+        if (!buffer.hasRemaining()) {\n+            buffer = null;\n+        }\n+        return result;\n+    }\n+    \n+    public ByteBuf getBuffOfSize(InputStream in, int size) throws IOException {\n+        if (size > maxBufferSize) {\n+            throw new IllegalArgumentException(\"Requested buffer size \" + size + \" is larger than maximum allowed\"\n+                    + maxBufferSize);\n+        }\n+        if (buffer == null) {\n+            int bufferSize = MathHelpers.minMax(in.available(), size, maxBufferSize);\n+            byte[] newBuffer = new byte[bufferSize];\n+            int read = in.read(newBuffer);\n+            buffer = ByteBuffer.wrap(newBuffer, 0, read); \n+        } \n+\n+        if (buffer.remaining() >= size) {\n+            return sliceOut(size);\n+        } else {\n+            int firstSize = buffer.remaining();\n+            ByteBuf first = sliceOut(firstSize);\n+            assert buffer == null; //Should have been fully sliced out\n+            byte[] remaining = new byte[size - firstSize];\n+            for (int offset = 0; offset < remaining.length;) {\n+                offset += in.read(remaining, offset, remaining.length - offset);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef406056653ea87101f3d79e245791ebcfd46217"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg5NjYyOA==", "bodyText": "Unfortunately timeouts are not available on InputStream. I have filed: #4943\nOnce that is fixed we should be able to add one easily.\n(We do however have keep alive still, it's just not located here)", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r453896628", "createdAt": "2020-07-13T19:57:59Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/connection/impl/IoBuffer.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.connection.impl;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.pravega.common.MathHelpers;\n+import io.pravega.shared.protocol.netty.WireCommands;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+\n+class IoBuffer {\n+    private int maxBufferSize = WireCommands.MAX_WIRECOMMAND_SIZE;\n+    private ByteBuffer buffer = null;\n+    \n+    private ByteBuf sliceOut(int size) {\n+        ByteBuf result = Unpooled.wrappedBuffer(buffer.array(), buffer.arrayOffset() + buffer.position(), size);\n+        buffer.position(buffer.position() + size);\n+        if (!buffer.hasRemaining()) {\n+            buffer = null;\n+        }\n+        return result;\n+    }\n+    \n+    public ByteBuf getBuffOfSize(InputStream in, int size) throws IOException {\n+        if (size > maxBufferSize) {\n+            throw new IllegalArgumentException(\"Requested buffer size \" + size + \" is larger than maximum allowed\"\n+                    + maxBufferSize);\n+        }\n+        if (buffer == null) {\n+            int bufferSize = MathHelpers.minMax(in.available(), size, maxBufferSize);\n+            byte[] newBuffer = new byte[bufferSize];\n+            int read = in.read(newBuffer);\n+            buffer = ByteBuffer.wrap(newBuffer, 0, read); \n+        } \n+\n+        if (buffer.remaining() >= size) {\n+            return sliceOut(size);\n+        } else {\n+            int firstSize = buffer.remaining();\n+            ByteBuf first = sliceOut(firstSize);\n+            assert buffer == null; //Should have been fully sliced out\n+            byte[] remaining = new byte[size - firstSize];\n+            for (int offset = 0; offset < remaining.length;) {\n+                offset += in.read(remaining, offset, remaining.length - offset);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ5NTYyMQ=="}, "originalCommit": {"oid": "ef406056653ea87101f3d79e245791ebcfd46217"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MjAwNTkzOnYy", "diffSide": "RIGHT", "path": "bindings/src/test/java/io/pravega/storage/extendeds3/S3ProxyImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMDozMzoyMlrOGrNa3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMzowNDozMFrOGuSjhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk2MTgyMw==", "bodyText": "This looks unrelated.", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r447961823", "createdAt": "2020-06-30T20:33:22Z", "author": {"login": "andreipaduroiu"}, "path": "bindings/src/test/java/io/pravega/storage/extendeds3/S3ProxyImpl.java", "diffHunk": "@@ -177,7 +177,7 @@ public void deleteObject(String bucketName, String key) {\n \n     @Override\n     public DeleteObjectsResult deleteObjects(DeleteObjectsRequest request) {\n-        request.getDeleteObjects().getKeys().forEach(key -> aclMap.remove(key));\n+        request.getDeleteObjects().getKeys().forEach(key -> aclMap.remove(key.getKey()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE5MTY4Nw==", "bodyText": "It is.", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r451191687", "createdAt": "2020-07-07T23:04:30Z", "author": {"login": "tkaitchuck"}, "path": "bindings/src/test/java/io/pravega/storage/extendeds3/S3ProxyImpl.java", "diffHunk": "@@ -177,7 +177,7 @@ public void deleteObject(String bucketName, String key) {\n \n     @Override\n     public DeleteObjectsResult deleteObjects(DeleteObjectsRequest request) {\n-        request.getDeleteObjects().getKeys().forEach(key -> aclMap.remove(key));\n+        request.getDeleteObjects().getKeys().forEach(key -> aclMap.remove(key.getKey()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk2MTgyMw=="}, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MjAxODUwOnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/admin/impl/ReaderGroupManagerImpl.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMDozNzoyN1rOGrNipQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMjozMDozNVrOGw83uA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk2MzgxMw==", "bodyText": "You should be closing the connection pool upon closing this ReaderGroupManagerImpl object.\nHowever, you should only do it if you own that object (i.e., via this constructor); the other constructor accepts an external instance.", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r447963813", "createdAt": "2020-06-30T20:37:27Z", "author": {"login": "andreipaduroiu"}, "path": "client/src/main/java/io/pravega/client/admin/impl/ReaderGroupManagerImpl.java", "diffHunk": "@@ -57,22 +59,22 @@\n     private final String scope;\n     private final SynchronizerClientFactory clientFactory;\n     private final Controller controller;\n-    private final ConnectionFactory connectionFactory;\n+    private final ConnectionPool connectionPool;\n \n     public ReaderGroupManagerImpl(String scope, ClientConfig config, ConnectionFactory connectionFactory) {\n         this.scope = scope;\n         this.controller = new ControllerImpl(ControllerImplConfig.builder().clientConfig(config).build(),\n                 connectionFactory.getInternalExecutor());\n \n-        this.connectionFactory = connectionFactory;\n+        this.connectionPool = new ConnectionPoolImpl(config, connectionFactory);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE5MTc5NQ==", "bodyText": "Fixed", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r451191795", "createdAt": "2020-07-07T23:04:51Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/admin/impl/ReaderGroupManagerImpl.java", "diffHunk": "@@ -57,22 +59,22 @@\n     private final String scope;\n     private final SynchronizerClientFactory clientFactory;\n     private final Controller controller;\n-    private final ConnectionFactory connectionFactory;\n+    private final ConnectionPool connectionPool;\n \n     public ReaderGroupManagerImpl(String scope, ClientConfig config, ConnectionFactory connectionFactory) {\n         this.scope = scope;\n         this.controller = new ControllerImpl(ControllerImplConfig.builder().clientConfig(config).build(),\n                 connectionFactory.getInternalExecutor());\n \n-        this.connectionFactory = connectionFactory;\n+        this.connectionPool = new ConnectionPoolImpl(config, connectionFactory);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk2MzgxMw=="}, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzkzNDAzNg==", "bodyText": "I don't see any changes in close. Am I missing something?", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r453934036", "createdAt": "2020-07-13T21:08:47Z", "author": {"login": "andreipaduroiu"}, "path": "client/src/main/java/io/pravega/client/admin/impl/ReaderGroupManagerImpl.java", "diffHunk": "@@ -57,22 +59,22 @@\n     private final String scope;\n     private final SynchronizerClientFactory clientFactory;\n     private final Controller controller;\n-    private final ConnectionFactory connectionFactory;\n+    private final ConnectionPool connectionPool;\n \n     public ReaderGroupManagerImpl(String scope, ClientConfig config, ConnectionFactory connectionFactory) {\n         this.scope = scope;\n         this.controller = new ControllerImpl(ControllerImplConfig.builder().clientConfig(config).build(),\n                 connectionFactory.getInternalExecutor());\n \n-        this.connectionFactory = connectionFactory;\n+        this.connectionPool = new ConnectionPoolImpl(config, connectionFactory);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk2MzgxMw=="}, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk4MjEzNg==", "bodyText": "I changed it so that the clientFactory owns the pool and hence is responsible for it.\nI have made that more explicit by dropping the member variable.", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r453982136", "createdAt": "2020-07-13T22:30:35Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/admin/impl/ReaderGroupManagerImpl.java", "diffHunk": "@@ -57,22 +59,22 @@\n     private final String scope;\n     private final SynchronizerClientFactory clientFactory;\n     private final Controller controller;\n-    private final ConnectionFactory connectionFactory;\n+    private final ConnectionPool connectionPool;\n \n     public ReaderGroupManagerImpl(String scope, ClientConfig config, ConnectionFactory connectionFactory) {\n         this.scope = scope;\n         this.controller = new ControllerImpl(ControllerImplConfig.builder().clientConfig(config).build(),\n                 connectionFactory.getInternalExecutor());\n \n-        this.connectionFactory = connectionFactory;\n+        this.connectionPool = new ConnectionPoolImpl(config, connectionFactory);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk2MzgxMw=="}, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MjAyMDg1OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/admin/impl/StreamManagerImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMDozODoxM1rOGrNkFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMzowNTo0NlrOGuSlIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk2NDE4Mg==", "bodyText": "How can this be null? You are setting it in the constructor.", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r447964182", "createdAt": "2020-06-30T20:38:13Z", "author": {"login": "andreipaduroiu"}, "path": "client/src/main/java/io/pravega/client/admin/impl/StreamManagerImpl.java", "diffHunk": "@@ -164,8 +164,8 @@ public void close() {\n         if (this.executor != null) {\n             ExecutorServiceHelpers.shutdown(this.executor);\n         }\n-        if (this.connectionFactory != null) {\n-            this.connectionFactory.close();\n+        if (this.connectionPool != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE5MjA5OQ==", "bodyText": "It is being set, but it's not actually null checked in the constructor, so technically it could be null. (In practice it only ever is in one test)", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r451192099", "createdAt": "2020-07-07T23:05:46Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/admin/impl/StreamManagerImpl.java", "diffHunk": "@@ -164,8 +164,8 @@ public void close() {\n         if (this.executor != null) {\n             ExecutorServiceHelpers.shutdown(this.executor);\n         }\n-        if (this.connectionFactory != null) {\n-            this.connectionFactory.close();\n+        if (this.connectionPool != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk2NDE4Mg=="}, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MjAyNTIzOnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/byteStream/impl/ByteStreamClientImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMDozOTozOFrOGrNmvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMzoxMDo1NFrOGuSrVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk2NDg2Mw==", "bodyText": "This looks a bit dangerous. You are accepting this pool via the AllArgsConstructor, yet you are closing it when you close this object. It may be shared with other components so you could be closing it prematurely.", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r447964863", "createdAt": "2020-06-30T20:39:38Z", "author": {"login": "andreipaduroiu"}, "path": "client/src/main/java/io/pravega/client/byteStream/impl/ByteStreamClientImpl.java", "diffHunk": "@@ -89,6 +77,6 @@ public ByteStreamWriter createByteStreamWriter(String streamName) {\n     @Override\n     public void close() {\n         controller.close();\n-        connectionFactory.close();\n+        connectionPool.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE5MzY4NQ==", "bodyText": "Looking at the constructor and how it it called, for this alone with all of the arguments have their ownership transferred to this class. So it is consistent with both the prior behavior and the behavior of the other fields. I'll add a javadoc.", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r451193685", "createdAt": "2020-07-07T23:10:54Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/byteStream/impl/ByteStreamClientImpl.java", "diffHunk": "@@ -89,6 +77,6 @@ public ByteStreamWriter createByteStreamWriter(String streamName) {\n     @Override\n     public void close() {\n         controller.close();\n-        connectionFactory.close();\n+        connectionPool.close();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk2NDg2Mw=="}, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MjAyODg0OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/connection/impl/AppendBatchSizeTrackerImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMDo0MDo0M1rOGrNpCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMDo0MDo0M1rOGrNpCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk2NTQ1MA==", "bodyText": "AbstractTimer.NANOS_TO_MILLIS", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r447965450", "createdAt": "2020-06-30T20:40:43Z", "author": {"login": "andreipaduroiu"}, "path": "client/src/main/java/io/pravega/client/connection/impl/AppendBatchSizeTrackerImpl.java", "diffHunk": "@@ -27,19 +27,26 @@\n  * synchronous writers. Otherwise the batch size is set to the amount of data that will be written in the next\n  * {@link #MAX_BATCH_TIME_MILLIS} or half the server round trip time (whichever is less)\n  */\n-class AppendBatchSizeTrackerImpl implements AppendBatchSizeTracker {\n-    private static final int MAX_BATCH_TIME_MILLIS = 100;\n-\n+public class AppendBatchSizeTrackerImpl implements AppendBatchSizeTracker {\n+    private static final double NANOS_PER_MILLI = 1000000;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MjAzMDI4OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/connection/impl/AppendBatchSizeTrackerImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMDo0MTowNVrOGrNp5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMDo0MTowNVrOGrNp5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk2NTY2OQ==", "bodyText": "Make use of the above constant?", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r447965669", "createdAt": "2020-06-30T20:41:05Z", "author": {"login": "andreipaduroiu"}, "path": "client/src/main/java/io/pravega/client/connection/impl/AppendBatchSizeTrackerImpl.java", "diffHunk": "@@ -27,19 +27,26 @@\n  * synchronous writers. Otherwise the batch size is set to the amount of data that will be written in the next\n  * {@link #MAX_BATCH_TIME_MILLIS} or half the server round trip time (whichever is less)\n  */\n-class AppendBatchSizeTrackerImpl implements AppendBatchSizeTracker {\n-    private static final int MAX_BATCH_TIME_MILLIS = 100;\n-\n+public class AppendBatchSizeTrackerImpl implements AppendBatchSizeTracker {\n+    private static final double NANOS_PER_MILLI = 1000000;\n+    \n+    // This must be less than WireCommands.MAX_WIRECOMMAND_SIZE / 2;\n+    private static final int MAX_BATCH_SIZE = initializeConstant(\"PRAVEGA_MAX_BATCH_SIZE\",\n+                                                                 2 * TcpClientConnection.TCP_BUFFER_SIZE - 1024);\n+    private static final int BASE_TIME_NANOS = initializeConstant(\"PRAVEGA_BATCH_BASE_TIME_NANOS\", 500000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MjAzNTAxOnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/connection/impl/AppendBatchSizeTrackerImpl.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMDo0MjozMFrOGrNs1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMzoxNDo0MlrOGuSvvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk2NjQyMA==", "bodyText": "Would it be wise to log a warning if you get some bad number? We could at least explain why our supposed passed-in value wouldn't take effect.", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r447966420", "createdAt": "2020-06-30T20:42:30Z", "author": {"login": "andreipaduroiu"}, "path": "client/src/main/java/io/pravega/client/connection/impl/AppendBatchSizeTrackerImpl.java", "diffHunk": "@@ -73,15 +79,28 @@ public int getAppendBlockSize() {\n         if (numInflight <= 1) {\n             return 0;\n         }\n-        double appendsInMaxBatch = Math.max(1.0, MAX_BATCH_TIME_MILLIS / millisBetweenAppends.getCurrentValue());\n-        double targetAppendsOutstanding = MathHelpers.minMax(appendsOutstanding.getCurrentValue() * 0.5, 1.0,\n-                                                             appendsInMaxBatch);\n-        return (int) MathHelpers.minMax((long) (targetAppendsOutstanding * eventSize.getCurrentValue()), 0,\n-                                        MAX_BATCH_SIZE);\n+        double nanosPerAppend = nanosBetweenAppends.getCurrentValue();\n+        double appendsInMaxBatchTime = (MAX_BATCH_TIME_MILLIS * NANOS_PER_MILLI) / nanosPerAppend;\n+        double appendsInTime = Math.max(1.0, BASE_TIME_NANOS / nanosPerAppend);\n+        double appendsInBatch = MathHelpers.minMax(appendsOutstanding.getCurrentValue() * OUTSTANDING_FRACTION, appendsInTime, appendsInMaxBatchTime);\n+        int size = (int) (appendsInBatch * eventSize.getCurrentValue()) + BASE_SIZE;\n+        return MathHelpers.minMax(size, 0, MAX_BATCH_SIZE);\n     }\n \n     @Override\n     public int getBatchTimeout() {\n         return MAX_BATCH_TIME_MILLIS;\n     }\n+    \n+    private static int initializeConstant(String name, int defaultValue) {\n+        String val = System.getenv(name);\n+        if (val != null) {\n+            try {\n+                return Integer.parseInt(val);\n+            } catch (NumberFormatException e) {\n+                //Use default", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODE5OTIwOA==", "bodyText": "IMHO I would throw an exception, otherwise the user has no way to check that the configured value is in use.\nI think that not everyone checks the log, you usually check logs only when you have a problem.", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r448199208", "createdAt": "2020-07-01T08:22:46Z", "author": {"login": "eolivelli"}, "path": "client/src/main/java/io/pravega/client/connection/impl/AppendBatchSizeTrackerImpl.java", "diffHunk": "@@ -73,15 +79,28 @@ public int getAppendBlockSize() {\n         if (numInflight <= 1) {\n             return 0;\n         }\n-        double appendsInMaxBatch = Math.max(1.0, MAX_BATCH_TIME_MILLIS / millisBetweenAppends.getCurrentValue());\n-        double targetAppendsOutstanding = MathHelpers.minMax(appendsOutstanding.getCurrentValue() * 0.5, 1.0,\n-                                                             appendsInMaxBatch);\n-        return (int) MathHelpers.minMax((long) (targetAppendsOutstanding * eventSize.getCurrentValue()), 0,\n-                                        MAX_BATCH_SIZE);\n+        double nanosPerAppend = nanosBetweenAppends.getCurrentValue();\n+        double appendsInMaxBatchTime = (MAX_BATCH_TIME_MILLIS * NANOS_PER_MILLI) / nanosPerAppend;\n+        double appendsInTime = Math.max(1.0, BASE_TIME_NANOS / nanosPerAppend);\n+        double appendsInBatch = MathHelpers.minMax(appendsOutstanding.getCurrentValue() * OUTSTANDING_FRACTION, appendsInTime, appendsInMaxBatchTime);\n+        int size = (int) (appendsInBatch * eventSize.getCurrentValue()) + BASE_SIZE;\n+        return MathHelpers.minMax(size, 0, MAX_BATCH_SIZE);\n     }\n \n     @Override\n     public int getBatchTimeout() {\n         return MAX_BATCH_TIME_MILLIS;\n     }\n+    \n+    private static int initializeConstant(String name, int defaultValue) {\n+        String val = System.getenv(name);\n+        if (val != null) {\n+            try {\n+                return Integer.parseInt(val);\n+            } catch (NumberFormatException e) {\n+                //Use default", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk2NjQyMA=="}, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE5NDgxMg==", "bodyText": "Done", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r451194812", "createdAt": "2020-07-07T23:14:42Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/connection/impl/AppendBatchSizeTrackerImpl.java", "diffHunk": "@@ -73,15 +79,28 @@ public int getAppendBlockSize() {\n         if (numInflight <= 1) {\n             return 0;\n         }\n-        double appendsInMaxBatch = Math.max(1.0, MAX_BATCH_TIME_MILLIS / millisBetweenAppends.getCurrentValue());\n-        double targetAppendsOutstanding = MathHelpers.minMax(appendsOutstanding.getCurrentValue() * 0.5, 1.0,\n-                                                             appendsInMaxBatch);\n-        return (int) MathHelpers.minMax((long) (targetAppendsOutstanding * eventSize.getCurrentValue()), 0,\n-                                        MAX_BATCH_SIZE);\n+        double nanosPerAppend = nanosBetweenAppends.getCurrentValue();\n+        double appendsInMaxBatchTime = (MAX_BATCH_TIME_MILLIS * NANOS_PER_MILLI) / nanosPerAppend;\n+        double appendsInTime = Math.max(1.0, BASE_TIME_NANOS / nanosPerAppend);\n+        double appendsInBatch = MathHelpers.minMax(appendsOutstanding.getCurrentValue() * OUTSTANDING_FRACTION, appendsInTime, appendsInMaxBatchTime);\n+        int size = (int) (appendsInBatch * eventSize.getCurrentValue()) + BASE_SIZE;\n+        return MathHelpers.minMax(size, 0, MAX_BATCH_SIZE);\n     }\n \n     @Override\n     public int getBatchTimeout() {\n         return MAX_BATCH_TIME_MILLIS;\n     }\n+    \n+    private static int initializeConstant(String name, int defaultValue) {\n+        String val = System.getenv(name);\n+        if (val != null) {\n+            try {\n+                return Integer.parseInt(val);\n+            } catch (NumberFormatException e) {\n+                //Use default", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk2NjQyMA=="}, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MjA0MDk5OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/connection/impl/CommandEncoder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMDo0NDoyNVrOGrNwkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMzoxNDo1MVrOGuSv6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk2NzM3Nw==", "bodyText": "Nit: extra space.", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r447967377", "createdAt": "2020-06-30T20:44:25Z", "author": {"login": "andreipaduroiu"}, "path": "client/src/main/java/io/pravega/client/connection/impl/CommandEncoder.java", "diffHunk": "@@ -0,0 +1,419 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.connection.impl;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufOutputStream;\n+import io.netty.buffer.Unpooled;\n+import io.pravega.shared.metrics.MetricNotifier;\n+import io.pravega.shared.protocol.netty.Append;\n+import io.pravega.shared.protocol.netty.AppendBatchSizeTracker;\n+import io.pravega.shared.protocol.netty.InvalidMessageException;\n+import io.pravega.shared.protocol.netty.WireCommand;\n+import io.pravega.shared.protocol.netty.WireCommandType;\n+import io.pravega.shared.protocol.netty.WireCommands.AppendBlock;\n+import io.pravega.shared.protocol.netty.WireCommands.AppendBlockEnd;\n+import io.pravega.shared.protocol.netty.WireCommands.Hello;\n+import io.pravega.shared.protocol.netty.WireCommands.PartialEvent;\n+import io.pravega.shared.protocol.netty.WireCommands.SetupAppend;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.util.AbstractMap.SimpleImmutableEntry;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Function;\n+import javax.annotation.concurrent.GuardedBy;\n+import lombok.RequiredArgsConstructor;\n+import lombok.SneakyThrows;\n+import lombok.Synchronized;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import static io.pravega.shared.NameUtils.segmentTags;\n+import static io.pravega.shared.metrics.ClientMetricKeys.CLIENT_APPEND_BLOCK_SIZE;\n+import static io.pravega.shared.protocol.netty.WireCommands.TYPE_PLUS_LENGTH_SIZE;\n+import static io.pravega.shared.protocol.netty.WireCommands.TYPE_SIZE;\n+\n+@Slf4j\n+@RequiredArgsConstructor\n+public class CommandEncoder {\n+    \n+    private static final byte[] LENGTH_PLACEHOLDER = new byte[4];\n+    private final Function<Long, AppendBatchSizeTracker> appendTracker;\n+    private final MetricNotifier metricNotifier;\n+    @GuardedBy(\"$lock\")\n+    private final Map<Map.Entry<String, UUID>, Session> setupSegments = new HashMap<>();\n+    private final AtomicLong tokenCounter = new AtomicLong(0);\n+    @GuardedBy(\"$lock\")\n+    private String segmentBeingAppendedTo;\n+    @GuardedBy(\"$lock\")\n+    private UUID writerIdPerformingAppends;\n+    @GuardedBy(\"$lock\")\n+    private int currentBlockSize;\n+    @GuardedBy(\"$lock\")\n+    private int bytesLeftInBlock;\n+    @GuardedBy(\"$lock\")\n+    private final Map<UUID, Session> pendingWrites = new HashMap<>();\n+\n+    private final OutputStream output;\n+    private final ByteBuf buffer = Unpooled.buffer(1024 * 1024);\n+\n+    @RequiredArgsConstructor\n+    private final class Session {\n+        private static final int MAX_EVENTS = 500;\n+        private static final int MAX_DATA_SIZE = 1024 * 1024; // 1MB\n+        private final UUID id;\n+        private final long requestId;\n+        private final List<ByteBuf> pendingList = new ArrayList<>();\n+        private int  pendingBytes = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE5NDg1OQ==", "bodyText": "DOne", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r451194859", "createdAt": "2020-07-07T23:14:51Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/connection/impl/CommandEncoder.java", "diffHunk": "@@ -0,0 +1,419 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.connection.impl;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufOutputStream;\n+import io.netty.buffer.Unpooled;\n+import io.pravega.shared.metrics.MetricNotifier;\n+import io.pravega.shared.protocol.netty.Append;\n+import io.pravega.shared.protocol.netty.AppendBatchSizeTracker;\n+import io.pravega.shared.protocol.netty.InvalidMessageException;\n+import io.pravega.shared.protocol.netty.WireCommand;\n+import io.pravega.shared.protocol.netty.WireCommandType;\n+import io.pravega.shared.protocol.netty.WireCommands.AppendBlock;\n+import io.pravega.shared.protocol.netty.WireCommands.AppendBlockEnd;\n+import io.pravega.shared.protocol.netty.WireCommands.Hello;\n+import io.pravega.shared.protocol.netty.WireCommands.PartialEvent;\n+import io.pravega.shared.protocol.netty.WireCommands.SetupAppend;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.util.AbstractMap.SimpleImmutableEntry;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Function;\n+import javax.annotation.concurrent.GuardedBy;\n+import lombok.RequiredArgsConstructor;\n+import lombok.SneakyThrows;\n+import lombok.Synchronized;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import static io.pravega.shared.NameUtils.segmentTags;\n+import static io.pravega.shared.metrics.ClientMetricKeys.CLIENT_APPEND_BLOCK_SIZE;\n+import static io.pravega.shared.protocol.netty.WireCommands.TYPE_PLUS_LENGTH_SIZE;\n+import static io.pravega.shared.protocol.netty.WireCommands.TYPE_SIZE;\n+\n+@Slf4j\n+@RequiredArgsConstructor\n+public class CommandEncoder {\n+    \n+    private static final byte[] LENGTH_PLACEHOLDER = new byte[4];\n+    private final Function<Long, AppendBatchSizeTracker> appendTracker;\n+    private final MetricNotifier metricNotifier;\n+    @GuardedBy(\"$lock\")\n+    private final Map<Map.Entry<String, UUID>, Session> setupSegments = new HashMap<>();\n+    private final AtomicLong tokenCounter = new AtomicLong(0);\n+    @GuardedBy(\"$lock\")\n+    private String segmentBeingAppendedTo;\n+    @GuardedBy(\"$lock\")\n+    private UUID writerIdPerformingAppends;\n+    @GuardedBy(\"$lock\")\n+    private int currentBlockSize;\n+    @GuardedBy(\"$lock\")\n+    private int bytesLeftInBlock;\n+    @GuardedBy(\"$lock\")\n+    private final Map<UUID, Session> pendingWrites = new HashMap<>();\n+\n+    private final OutputStream output;\n+    private final ByteBuf buffer = Unpooled.buffer(1024 * 1024);\n+\n+    @RequiredArgsConstructor\n+    private final class Session {\n+        private static final int MAX_EVENTS = 500;\n+        private static final int MAX_DATA_SIZE = 1024 * 1024; // 1MB\n+        private final UUID id;\n+        private final long requestId;\n+        private final List<ByteBuf> pendingList = new ArrayList<>();\n+        private int  pendingBytes = 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk2NzM3Nw=="}, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MjA0MzgxOnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/connection/impl/CommandEncoder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMDo0NToxN1rOGrNyaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwMDozNToxMFrOGuUIYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk2Nzg0OA==", "bodyText": "Do we care if the buffer is empty? Should we just ignore it in that case?", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r447967848", "createdAt": "2020-06-30T20:45:17Z", "author": {"login": "andreipaduroiu"}, "path": "client/src/main/java/io/pravega/client/connection/impl/CommandEncoder.java", "diffHunk": "@@ -0,0 +1,419 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.connection.impl;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufOutputStream;\n+import io.netty.buffer.Unpooled;\n+import io.pravega.shared.metrics.MetricNotifier;\n+import io.pravega.shared.protocol.netty.Append;\n+import io.pravega.shared.protocol.netty.AppendBatchSizeTracker;\n+import io.pravega.shared.protocol.netty.InvalidMessageException;\n+import io.pravega.shared.protocol.netty.WireCommand;\n+import io.pravega.shared.protocol.netty.WireCommandType;\n+import io.pravega.shared.protocol.netty.WireCommands.AppendBlock;\n+import io.pravega.shared.protocol.netty.WireCommands.AppendBlockEnd;\n+import io.pravega.shared.protocol.netty.WireCommands.Hello;\n+import io.pravega.shared.protocol.netty.WireCommands.PartialEvent;\n+import io.pravega.shared.protocol.netty.WireCommands.SetupAppend;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.util.AbstractMap.SimpleImmutableEntry;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Function;\n+import javax.annotation.concurrent.GuardedBy;\n+import lombok.RequiredArgsConstructor;\n+import lombok.SneakyThrows;\n+import lombok.Synchronized;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import static io.pravega.shared.NameUtils.segmentTags;\n+import static io.pravega.shared.metrics.ClientMetricKeys.CLIENT_APPEND_BLOCK_SIZE;\n+import static io.pravega.shared.protocol.netty.WireCommands.TYPE_PLUS_LENGTH_SIZE;\n+import static io.pravega.shared.protocol.netty.WireCommands.TYPE_SIZE;\n+\n+@Slf4j\n+@RequiredArgsConstructor\n+public class CommandEncoder {\n+    \n+    private static final byte[] LENGTH_PLACEHOLDER = new byte[4];\n+    private final Function<Long, AppendBatchSizeTracker> appendTracker;\n+    private final MetricNotifier metricNotifier;\n+    @GuardedBy(\"$lock\")\n+    private final Map<Map.Entry<String, UUID>, Session> setupSegments = new HashMap<>();\n+    private final AtomicLong tokenCounter = new AtomicLong(0);\n+    @GuardedBy(\"$lock\")\n+    private String segmentBeingAppendedTo;\n+    @GuardedBy(\"$lock\")\n+    private UUID writerIdPerformingAppends;\n+    @GuardedBy(\"$lock\")\n+    private int currentBlockSize;\n+    @GuardedBy(\"$lock\")\n+    private int bytesLeftInBlock;\n+    @GuardedBy(\"$lock\")\n+    private final Map<UUID, Session> pendingWrites = new HashMap<>();\n+\n+    private final OutputStream output;\n+    private final ByteBuf buffer = Unpooled.buffer(1024 * 1024);\n+\n+    @RequiredArgsConstructor\n+    private final class Session {\n+        private static final int MAX_EVENTS = 500;\n+        private static final int MAX_DATA_SIZE = 1024 * 1024; // 1MB\n+        private final UUID id;\n+        private final long requestId;\n+        private final List<ByteBuf> pendingList = new ArrayList<>();\n+        private int  pendingBytes = 0;\n+        private long lastEventNumber = -1L;\n+        private int eventCount = 0;\n+\n+        /**\n+         * Record the given Append to Session by tracking the last event number and number of events to write.\n+         */\n+        private void record(Append append) {\n+            lastEventNumber = append.getEventNumber();\n+            eventCount += append.getEventCount();\n+        }\n+\n+        /**\n+         * Check if session is empty or not.\n+         * @return true if there are any pending events; false otherwise.\n+         */\n+        private boolean isFree() {\n+            return eventCount == 0;\n+        }\n+\n+        /**\n+         * Queue the Append data to Session' list.\n+         *\n+         * @param data  data bytes.\n+         * @param out   Network channel buffer.\n+         */\n+        private void write(ByteBuf data) {\n+            pendingWrites.putIfAbsent(id, this);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIxNzUwNg==", "bodyText": "I don't want to special case that too much. It is not outlawed by the wireprotocol to append zero bytes. (I don't have a reason we should, but we did and the wire command encoding layer is 'smart' and optimizes out the write it might be confusing)", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r451217506", "createdAt": "2020-07-08T00:35:10Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/connection/impl/CommandEncoder.java", "diffHunk": "@@ -0,0 +1,419 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.connection.impl;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufOutputStream;\n+import io.netty.buffer.Unpooled;\n+import io.pravega.shared.metrics.MetricNotifier;\n+import io.pravega.shared.protocol.netty.Append;\n+import io.pravega.shared.protocol.netty.AppendBatchSizeTracker;\n+import io.pravega.shared.protocol.netty.InvalidMessageException;\n+import io.pravega.shared.protocol.netty.WireCommand;\n+import io.pravega.shared.protocol.netty.WireCommandType;\n+import io.pravega.shared.protocol.netty.WireCommands.AppendBlock;\n+import io.pravega.shared.protocol.netty.WireCommands.AppendBlockEnd;\n+import io.pravega.shared.protocol.netty.WireCommands.Hello;\n+import io.pravega.shared.protocol.netty.WireCommands.PartialEvent;\n+import io.pravega.shared.protocol.netty.WireCommands.SetupAppend;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.util.AbstractMap.SimpleImmutableEntry;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Function;\n+import javax.annotation.concurrent.GuardedBy;\n+import lombok.RequiredArgsConstructor;\n+import lombok.SneakyThrows;\n+import lombok.Synchronized;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import static io.pravega.shared.NameUtils.segmentTags;\n+import static io.pravega.shared.metrics.ClientMetricKeys.CLIENT_APPEND_BLOCK_SIZE;\n+import static io.pravega.shared.protocol.netty.WireCommands.TYPE_PLUS_LENGTH_SIZE;\n+import static io.pravega.shared.protocol.netty.WireCommands.TYPE_SIZE;\n+\n+@Slf4j\n+@RequiredArgsConstructor\n+public class CommandEncoder {\n+    \n+    private static final byte[] LENGTH_PLACEHOLDER = new byte[4];\n+    private final Function<Long, AppendBatchSizeTracker> appendTracker;\n+    private final MetricNotifier metricNotifier;\n+    @GuardedBy(\"$lock\")\n+    private final Map<Map.Entry<String, UUID>, Session> setupSegments = new HashMap<>();\n+    private final AtomicLong tokenCounter = new AtomicLong(0);\n+    @GuardedBy(\"$lock\")\n+    private String segmentBeingAppendedTo;\n+    @GuardedBy(\"$lock\")\n+    private UUID writerIdPerformingAppends;\n+    @GuardedBy(\"$lock\")\n+    private int currentBlockSize;\n+    @GuardedBy(\"$lock\")\n+    private int bytesLeftInBlock;\n+    @GuardedBy(\"$lock\")\n+    private final Map<UUID, Session> pendingWrites = new HashMap<>();\n+\n+    private final OutputStream output;\n+    private final ByteBuf buffer = Unpooled.buffer(1024 * 1024);\n+\n+    @RequiredArgsConstructor\n+    private final class Session {\n+        private static final int MAX_EVENTS = 500;\n+        private static final int MAX_DATA_SIZE = 1024 * 1024; // 1MB\n+        private final UUID id;\n+        private final long requestId;\n+        private final List<ByteBuf> pendingList = new ArrayList<>();\n+        private int  pendingBytes = 0;\n+        private long lastEventNumber = -1L;\n+        private int eventCount = 0;\n+\n+        /**\n+         * Record the given Append to Session by tracking the last event number and number of events to write.\n+         */\n+        private void record(Append append) {\n+            lastEventNumber = append.getEventNumber();\n+            eventCount += append.getEventCount();\n+        }\n+\n+        /**\n+         * Check if session is empty or not.\n+         * @return true if there are any pending events; false otherwise.\n+         */\n+        private boolean isFree() {\n+            return eventCount == 0;\n+        }\n+\n+        /**\n+         * Queue the Append data to Session' list.\n+         *\n+         * @param data  data bytes.\n+         * @param out   Network channel buffer.\n+         */\n+        private void write(ByteBuf data) {\n+            pendingWrites.putIfAbsent(id, this);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk2Nzg0OA=="}, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MjA2NTkxOnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/connection/impl/ConnectionFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMDo1MTo0NVrOGrN_yw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMzoxNToyOFrOGuSwxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3MTI3NQ==", "bodyText": "Please preserve the Javadoc.", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r447971275", "createdAt": "2020-06-30T20:51:45Z", "author": {"login": "andreipaduroiu"}, "path": "client/src/main/java/io/pravega/client/connection/impl/ConnectionFactory.java", "diffHunk": "@@ -30,23 +30,9 @@\n      */\n     CompletableFuture<ClientConnection> establishConnection(PravegaNodeUri endpoint, ReplyProcessor rp);\n \n-    /**\n-     * This method is used to establish a client connection using a {@link Flow} on the underlying Connection\n-     * pool.\n-     * @param flow  Flow to be used to create a client connection.\n-     * @param endpoint The Pravega Node URI.\n-     * @param rp Reply Processor instance.\n-     * @return An instance of client connection.\n-     */\n-    CompletableFuture<ClientConnection> establishConnection(Flow flow, PravegaNodeUri endpoint, ReplyProcessor rp);\n-\n-    /**\n-     * Get the internal executor which is used by the client.\n-     * @return A ScheduledExecutorService.\n-     */\n-    ScheduledExecutorService getInternalExecutor();\n-\n     @Override\n     void close();\n \n+    ScheduledExecutorService getInternalExecutor();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE5NTA3OA==", "bodyText": "Done", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r451195078", "createdAt": "2020-07-07T23:15:28Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/connection/impl/ConnectionFactory.java", "diffHunk": "@@ -30,23 +30,9 @@\n      */\n     CompletableFuture<ClientConnection> establishConnection(PravegaNodeUri endpoint, ReplyProcessor rp);\n \n-    /**\n-     * This method is used to establish a client connection using a {@link Flow} on the underlying Connection\n-     * pool.\n-     * @param flow  Flow to be used to create a client connection.\n-     * @param endpoint The Pravega Node URI.\n-     * @param rp Reply Processor instance.\n-     * @return An instance of client connection.\n-     */\n-    CompletableFuture<ClientConnection> establishConnection(Flow flow, PravegaNodeUri endpoint, ReplyProcessor rp);\n-\n-    /**\n-     * Get the internal executor which is used by the client.\n-     * @return A ScheduledExecutorService.\n-     */\n-    ScheduledExecutorService getInternalExecutor();\n-\n     @Override\n     void close();\n \n+    ScheduledExecutorService getInternalExecutor();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3MTI3NQ=="}, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MjA3MjE4OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/connection/impl/ConnectionPoolImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMDo1Mzo0N1rOGrODwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMzoxNTozOVrOGuSw-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3MjI4OQ==", "bodyText": "final?", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r447972289", "createdAt": "2020-06-30T20:53:47Z", "author": {"login": "andreipaduroiu"}, "path": "client/src/main/java/io/pravega/client/connection/impl/ConnectionPoolImpl.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+\n+package io.pravega.client.connection.impl;\n+\n+import static io.pravega.shared.metrics.MetricNotifier.NO_OP_METRIC_NOTIFIER;\n+\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.concurrent.GuardedBy;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+\n+import io.pravega.client.ClientConfig;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.shared.metrics.ClientMetricUpdater;\n+import io.pravega.shared.metrics.MetricListener;\n+import io.pravega.shared.metrics.MetricNotifier;\n+import io.pravega.shared.protocol.netty.PravegaNodeUri;\n+import io.pravega.shared.protocol.netty.ReplyProcessor;\n+import lombok.Data;\n+import lombok.Synchronized;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public class ConnectionPoolImpl implements ConnectionPool {\n+\n+    /**\n+     * This class represents a Connection that is established with a Segment Store instance and its\n+     * attributes. (e.g: FlowCount, WriterCount)\n+     */\n+    @Data\n+    private class Connection implements Comparable<Connection>, AutoCloseable {\n+        private final PravegaNodeUri uri;\n+        /**\n+         * A future that completes when the connection is first established.\n+         */\n+        private final CompletableFuture<FlowHandler> flowHandler;\n+\n+        int getFlowCount() {\n+            return Futures.isSuccessful(flowHandler) ? flowHandler.join().getOpenFlowCount() : 0;\n+        }\n+\n+        boolean isConnected() {\n+            if (!Futures.isSuccessful(flowHandler)) {\n+                return false;\n+            }\n+            return !flowHandler.join().isClosed();\n+        }\n+\n+        @Override\n+        public int compareTo(Connection o) {\n+            int v1 = Futures.isSuccessful(this.getFlowHandler()) ? this.getFlowCount() : Integer.MAX_VALUE;\n+            int v2 = Futures.isSuccessful(o.getFlowHandler()) ? o.getFlowCount() : Integer.MAX_VALUE;\n+            return Integer.compare(v1, v2);\n+        }\n+        \n+        @Override\n+        public void close() {\n+            if (Futures.isSuccessful(flowHandler)) {\n+                flowHandler.join().close();\n+            }\n+        }\n+    }\n+    \n+    private final ClientConfig clientConfig;\n+    private final MetricNotifier metricNotifier;\n+    private final AtomicBoolean closed = new AtomicBoolean(false);\n+    @GuardedBy(\"$lock\")\n+    private final Map<PravegaNodeUri, List<Connection>> connectionMap = new HashMap<>();\n+    private ConnectionFactory connectionFactory;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE5NTEzMQ==", "bodyText": "Done", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r451195131", "createdAt": "2020-07-07T23:15:39Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/connection/impl/ConnectionPoolImpl.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+\n+package io.pravega.client.connection.impl;\n+\n+import static io.pravega.shared.metrics.MetricNotifier.NO_OP_METRIC_NOTIFIER;\n+\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.concurrent.GuardedBy;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+\n+import io.pravega.client.ClientConfig;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.shared.metrics.ClientMetricUpdater;\n+import io.pravega.shared.metrics.MetricListener;\n+import io.pravega.shared.metrics.MetricNotifier;\n+import io.pravega.shared.protocol.netty.PravegaNodeUri;\n+import io.pravega.shared.protocol.netty.ReplyProcessor;\n+import lombok.Data;\n+import lombok.Synchronized;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public class ConnectionPoolImpl implements ConnectionPool {\n+\n+    /**\n+     * This class represents a Connection that is established with a Segment Store instance and its\n+     * attributes. (e.g: FlowCount, WriterCount)\n+     */\n+    @Data\n+    private class Connection implements Comparable<Connection>, AutoCloseable {\n+        private final PravegaNodeUri uri;\n+        /**\n+         * A future that completes when the connection is first established.\n+         */\n+        private final CompletableFuture<FlowHandler> flowHandler;\n+\n+        int getFlowCount() {\n+            return Futures.isSuccessful(flowHandler) ? flowHandler.join().getOpenFlowCount() : 0;\n+        }\n+\n+        boolean isConnected() {\n+            if (!Futures.isSuccessful(flowHandler)) {\n+                return false;\n+            }\n+            return !flowHandler.join().isClosed();\n+        }\n+\n+        @Override\n+        public int compareTo(Connection o) {\n+            int v1 = Futures.isSuccessful(this.getFlowHandler()) ? this.getFlowCount() : Integer.MAX_VALUE;\n+            int v2 = Futures.isSuccessful(o.getFlowHandler()) ? o.getFlowCount() : Integer.MAX_VALUE;\n+            return Integer.compare(v1, v2);\n+        }\n+        \n+        @Override\n+        public void close() {\n+            if (Futures.isSuccessful(flowHandler)) {\n+                flowHandler.join().close();\n+            }\n+        }\n+    }\n+    \n+    private final ClientConfig clientConfig;\n+    private final MetricNotifier metricNotifier;\n+    private final AtomicBoolean closed = new AtomicBoolean(false);\n+    @GuardedBy(\"$lock\")\n+    private final Map<PravegaNodeUri, List<Connection>> connectionMap = new HashMap<>();\n+    private ConnectionFactory connectionFactory;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3MjI4OQ=="}, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MjA4OTU1OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/connection/impl/IoBuffer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMDo1ODoyNlrOGrOOJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMzoxNTo1N1rOGuSxXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3NDk0OA==", "bodyText": "final", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r447974948", "createdAt": "2020-06-30T20:58:26Z", "author": {"login": "andreipaduroiu"}, "path": "client/src/main/java/io/pravega/client/connection/impl/IoBuffer.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.connection.impl;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.pravega.common.MathHelpers;\n+import io.pravega.shared.protocol.netty.WireCommands;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+\n+class IoBuffer {\n+    private int maxBufferSize = WireCommands.MAX_WIRECOMMAND_SIZE;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE5NTIyOA==", "bodyText": "Done", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r451195228", "createdAt": "2020-07-07T23:15:57Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/connection/impl/IoBuffer.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.connection.impl;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.pravega.common.MathHelpers;\n+import io.pravega.shared.protocol.netty.WireCommands;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+\n+class IoBuffer {\n+    private int maxBufferSize = WireCommands.MAX_WIRECOMMAND_SIZE;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3NDk0OA=="}, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MjEwNTczOnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/connection/impl/TcpClientConnection.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMTowMzozMFrOGrOYRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMzoxNjowOFrOGuSxmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3NzU0Mg==", "bodyText": "We should find a better thread pool name.", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r447977542", "createdAt": "2020-06-30T21:03:30Z", "author": {"login": "andreipaduroiu"}, "path": "client/src/main/java/io/pravega/client/connection/impl/TcpClientConnection.java", "diffHunk": "@@ -0,0 +1,306 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.connection.impl;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import io.netty.buffer.ByteBuf;\n+import io.pravega.client.ClientConfig;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import io.pravega.common.util.CertificateUtils;\n+import io.pravega.shared.protocol.netty.Append;\n+import io.pravega.shared.protocol.netty.AppendBatchSizeTracker;\n+import io.pravega.shared.protocol.netty.ConnectionFailedException;\n+import io.pravega.shared.protocol.netty.EnhancedByteBufInputStream;\n+import io.pravega.shared.protocol.netty.InvalidMessageException;\n+import io.pravega.shared.protocol.netty.PravegaNodeUri;\n+import io.pravega.shared.protocol.netty.Reply;\n+import io.pravega.shared.protocol.netty.ReplyProcessor;\n+import io.pravega.shared.protocol.netty.WireCommand;\n+import io.pravega.shared.protocol.netty.WireCommandType;\n+import io.pravega.shared.protocol.netty.WireCommands;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.SocketException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.CertificateException;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLParameters;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.TrustManagerFactory;\n+import lombok.RequiredArgsConstructor;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.pravega.shared.protocol.netty.AppendBatchSizeTracker.MAX_BATCH_TIME_MILLIS;\n+\n+@Slf4j\n+public class TcpClientConnection implements ClientConnection {\n+\n+    static final int TCP_BUFFER_SIZE = 256 * 1024;\n+    \n+    private final Socket socket;\n+    private final CommandEncoder encoder;\n+    private final ConnectionReader reader;\n+    private final AtomicBoolean closed = new AtomicBoolean(false);\n+    private final PravegaNodeUri location;\n+    private final Runnable onClose;\n+    private final ScheduledFuture<?> timeoutFuture;\n+   \n+    private TcpClientConnection(Socket socket, CommandEncoder encoder, ConnectionReader reader, PravegaNodeUri location,\n+                                Runnable onClose, ScheduledExecutorService executor) {\n+        this.socket = checkNotNull(socket);\n+        this.encoder = checkNotNull(encoder);\n+        this.reader = checkNotNull(reader);\n+        this.location = checkNotNull(location);\n+        this.onClose = onClose;\n+        this.timeoutFuture = executor.scheduleWithFixedDelay(new TimeoutBatch(encoder),\n+                                                             MAX_BATCH_TIME_MILLIS,\n+                                                             MAX_BATCH_TIME_MILLIS,\n+                                                             TimeUnit.MILLISECONDS);\n+    }\n+\n+    @VisibleForTesting\n+    static class ConnectionReader {\n+        \n+        private final String name;\n+        private final InputStream in;\n+        private final ReplyProcessor callback;\n+        private final ScheduledExecutorService thread;\n+        private final AppendBatchSizeTracker batchSizeTracker;\n+        private final AtomicBoolean stop = new AtomicBoolean(false);\n+\n+        public ConnectionReader(String name, InputStream in, ReplyProcessor callback,\n+                                AppendBatchSizeTracker batchSizeTracker) {\n+            this.name = name;\n+            this.in = in;\n+            this.callback = callback;\n+            this.thread = ExecutorServiceHelpers.newScheduledThreadPool(1, \"Reading from \" + name);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3Nzc5NA==", "bodyText": "And name it \"executor\" or \"threadPool\" since it's not really a thread. Or If you really want a single thread, then just create a thread, not a pool.", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r447977794", "createdAt": "2020-06-30T21:03:58Z", "author": {"login": "andreipaduroiu"}, "path": "client/src/main/java/io/pravega/client/connection/impl/TcpClientConnection.java", "diffHunk": "@@ -0,0 +1,306 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.connection.impl;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import io.netty.buffer.ByteBuf;\n+import io.pravega.client.ClientConfig;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import io.pravega.common.util.CertificateUtils;\n+import io.pravega.shared.protocol.netty.Append;\n+import io.pravega.shared.protocol.netty.AppendBatchSizeTracker;\n+import io.pravega.shared.protocol.netty.ConnectionFailedException;\n+import io.pravega.shared.protocol.netty.EnhancedByteBufInputStream;\n+import io.pravega.shared.protocol.netty.InvalidMessageException;\n+import io.pravega.shared.protocol.netty.PravegaNodeUri;\n+import io.pravega.shared.protocol.netty.Reply;\n+import io.pravega.shared.protocol.netty.ReplyProcessor;\n+import io.pravega.shared.protocol.netty.WireCommand;\n+import io.pravega.shared.protocol.netty.WireCommandType;\n+import io.pravega.shared.protocol.netty.WireCommands;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.SocketException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.CertificateException;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLParameters;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.TrustManagerFactory;\n+import lombok.RequiredArgsConstructor;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.pravega.shared.protocol.netty.AppendBatchSizeTracker.MAX_BATCH_TIME_MILLIS;\n+\n+@Slf4j\n+public class TcpClientConnection implements ClientConnection {\n+\n+    static final int TCP_BUFFER_SIZE = 256 * 1024;\n+    \n+    private final Socket socket;\n+    private final CommandEncoder encoder;\n+    private final ConnectionReader reader;\n+    private final AtomicBoolean closed = new AtomicBoolean(false);\n+    private final PravegaNodeUri location;\n+    private final Runnable onClose;\n+    private final ScheduledFuture<?> timeoutFuture;\n+   \n+    private TcpClientConnection(Socket socket, CommandEncoder encoder, ConnectionReader reader, PravegaNodeUri location,\n+                                Runnable onClose, ScheduledExecutorService executor) {\n+        this.socket = checkNotNull(socket);\n+        this.encoder = checkNotNull(encoder);\n+        this.reader = checkNotNull(reader);\n+        this.location = checkNotNull(location);\n+        this.onClose = onClose;\n+        this.timeoutFuture = executor.scheduleWithFixedDelay(new TimeoutBatch(encoder),\n+                                                             MAX_BATCH_TIME_MILLIS,\n+                                                             MAX_BATCH_TIME_MILLIS,\n+                                                             TimeUnit.MILLISECONDS);\n+    }\n+\n+    @VisibleForTesting\n+    static class ConnectionReader {\n+        \n+        private final String name;\n+        private final InputStream in;\n+        private final ReplyProcessor callback;\n+        private final ScheduledExecutorService thread;\n+        private final AppendBatchSizeTracker batchSizeTracker;\n+        private final AtomicBoolean stop = new AtomicBoolean(false);\n+\n+        public ConnectionReader(String name, InputStream in, ReplyProcessor callback,\n+                                AppendBatchSizeTracker batchSizeTracker) {\n+            this.name = name;\n+            this.in = in;\n+            this.callback = callback;\n+            this.thread = ExecutorServiceHelpers.newScheduledThreadPool(1, \"Reading from \" + name);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3NzU0Mg=="}, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE5NTI5MA==", "bodyText": "Done", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r451195290", "createdAt": "2020-07-07T23:16:08Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/connection/impl/TcpClientConnection.java", "diffHunk": "@@ -0,0 +1,306 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.connection.impl;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import io.netty.buffer.ByteBuf;\n+import io.pravega.client.ClientConfig;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import io.pravega.common.util.CertificateUtils;\n+import io.pravega.shared.protocol.netty.Append;\n+import io.pravega.shared.protocol.netty.AppendBatchSizeTracker;\n+import io.pravega.shared.protocol.netty.ConnectionFailedException;\n+import io.pravega.shared.protocol.netty.EnhancedByteBufInputStream;\n+import io.pravega.shared.protocol.netty.InvalidMessageException;\n+import io.pravega.shared.protocol.netty.PravegaNodeUri;\n+import io.pravega.shared.protocol.netty.Reply;\n+import io.pravega.shared.protocol.netty.ReplyProcessor;\n+import io.pravega.shared.protocol.netty.WireCommand;\n+import io.pravega.shared.protocol.netty.WireCommandType;\n+import io.pravega.shared.protocol.netty.WireCommands;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.SocketException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.CertificateException;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLParameters;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.TrustManagerFactory;\n+import lombok.RequiredArgsConstructor;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.pravega.shared.protocol.netty.AppendBatchSizeTracker.MAX_BATCH_TIME_MILLIS;\n+\n+@Slf4j\n+public class TcpClientConnection implements ClientConnection {\n+\n+    static final int TCP_BUFFER_SIZE = 256 * 1024;\n+    \n+    private final Socket socket;\n+    private final CommandEncoder encoder;\n+    private final ConnectionReader reader;\n+    private final AtomicBoolean closed = new AtomicBoolean(false);\n+    private final PravegaNodeUri location;\n+    private final Runnable onClose;\n+    private final ScheduledFuture<?> timeoutFuture;\n+   \n+    private TcpClientConnection(Socket socket, CommandEncoder encoder, ConnectionReader reader, PravegaNodeUri location,\n+                                Runnable onClose, ScheduledExecutorService executor) {\n+        this.socket = checkNotNull(socket);\n+        this.encoder = checkNotNull(encoder);\n+        this.reader = checkNotNull(reader);\n+        this.location = checkNotNull(location);\n+        this.onClose = onClose;\n+        this.timeoutFuture = executor.scheduleWithFixedDelay(new TimeoutBatch(encoder),\n+                                                             MAX_BATCH_TIME_MILLIS,\n+                                                             MAX_BATCH_TIME_MILLIS,\n+                                                             TimeUnit.MILLISECONDS);\n+    }\n+\n+    @VisibleForTesting\n+    static class ConnectionReader {\n+        \n+        private final String name;\n+        private final InputStream in;\n+        private final ReplyProcessor callback;\n+        private final ScheduledExecutorService thread;\n+        private final AppendBatchSizeTracker batchSizeTracker;\n+        private final AtomicBoolean stop = new AtomicBoolean(false);\n+\n+        public ConnectionReader(String name, InputStream in, ReplyProcessor callback,\n+                                AppendBatchSizeTracker batchSizeTracker) {\n+            this.name = name;\n+            this.in = in;\n+            this.callback = callback;\n+            this.thread = ExecutorServiceHelpers.newScheduledThreadPool(1, \"Reading from \" + name);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3NzU0Mg=="}, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 98}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MjExMTI0OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/connection/impl/TcpClientConnection.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMTowNTowNFrOGrObiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwMDozNTo1NVrOGuUJPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3ODM3Nw==", "bodyText": "shutdownNow or ExecutorServiceHelpers.shutdown; otherwise there's no guarantee that its threads are properly interrupted.", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r447978377", "createdAt": "2020-06-30T21:05:04Z", "author": {"login": "andreipaduroiu"}, "path": "client/src/main/java/io/pravega/client/connection/impl/TcpClientConnection.java", "diffHunk": "@@ -0,0 +1,306 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.connection.impl;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import io.netty.buffer.ByteBuf;\n+import io.pravega.client.ClientConfig;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import io.pravega.common.util.CertificateUtils;\n+import io.pravega.shared.protocol.netty.Append;\n+import io.pravega.shared.protocol.netty.AppendBatchSizeTracker;\n+import io.pravega.shared.protocol.netty.ConnectionFailedException;\n+import io.pravega.shared.protocol.netty.EnhancedByteBufInputStream;\n+import io.pravega.shared.protocol.netty.InvalidMessageException;\n+import io.pravega.shared.protocol.netty.PravegaNodeUri;\n+import io.pravega.shared.protocol.netty.Reply;\n+import io.pravega.shared.protocol.netty.ReplyProcessor;\n+import io.pravega.shared.protocol.netty.WireCommand;\n+import io.pravega.shared.protocol.netty.WireCommandType;\n+import io.pravega.shared.protocol.netty.WireCommands;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.SocketException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.CertificateException;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLParameters;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.TrustManagerFactory;\n+import lombok.RequiredArgsConstructor;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.pravega.shared.protocol.netty.AppendBatchSizeTracker.MAX_BATCH_TIME_MILLIS;\n+\n+@Slf4j\n+public class TcpClientConnection implements ClientConnection {\n+\n+    static final int TCP_BUFFER_SIZE = 256 * 1024;\n+    \n+    private final Socket socket;\n+    private final CommandEncoder encoder;\n+    private final ConnectionReader reader;\n+    private final AtomicBoolean closed = new AtomicBoolean(false);\n+    private final PravegaNodeUri location;\n+    private final Runnable onClose;\n+    private final ScheduledFuture<?> timeoutFuture;\n+   \n+    private TcpClientConnection(Socket socket, CommandEncoder encoder, ConnectionReader reader, PravegaNodeUri location,\n+                                Runnable onClose, ScheduledExecutorService executor) {\n+        this.socket = checkNotNull(socket);\n+        this.encoder = checkNotNull(encoder);\n+        this.reader = checkNotNull(reader);\n+        this.location = checkNotNull(location);\n+        this.onClose = onClose;\n+        this.timeoutFuture = executor.scheduleWithFixedDelay(new TimeoutBatch(encoder),\n+                                                             MAX_BATCH_TIME_MILLIS,\n+                                                             MAX_BATCH_TIME_MILLIS,\n+                                                             TimeUnit.MILLISECONDS);\n+    }\n+\n+    @VisibleForTesting\n+    static class ConnectionReader {\n+        \n+        private final String name;\n+        private final InputStream in;\n+        private final ReplyProcessor callback;\n+        private final ScheduledExecutorService thread;\n+        private final AppendBatchSizeTracker batchSizeTracker;\n+        private final AtomicBoolean stop = new AtomicBoolean(false);\n+\n+        public ConnectionReader(String name, InputStream in, ReplyProcessor callback,\n+                                AppendBatchSizeTracker batchSizeTracker) {\n+            this.name = name;\n+            this.in = in;\n+            this.callback = callback;\n+            this.thread = ExecutorServiceHelpers.newScheduledThreadPool(1, \"Reading from \" + name);\n+            this.batchSizeTracker = batchSizeTracker;\n+        }\n+        \n+        public void start() {\n+            thread.submit(() -> {\n+                IoBuffer buffer = new IoBuffer();\n+                while (!stop.get()) {\n+                    try {\n+                        WireCommand command = readCommand(in, buffer);\n+                        if (command instanceof WireCommands.DataAppended) {\n+                            WireCommands.DataAppended dataAppended = (WireCommands.DataAppended) command;\n+                            batchSizeTracker.recordAck(dataAppended.getEventNumber());\n+                        }\n+                        try {\n+                            callback.process((Reply) command);\n+                        } catch (Exception e) {\n+                            callback.processingFailure(e);\n+                        }\n+                    } catch (SocketException e) {\n+                        if (e.getMessage().equals(\"Socket closed\")) {\n+                            log.info(\"Closing TcpConnection.Reader because socket is closed.\");\n+                        } else {\n+                            log.warn(\"Error in reading from socket.\", e);\n+                        }\n+                        stop();\n+                    } catch (EOFException e) {\n+                        log.info(\"Closing TcpConnection.Reader because end of input readched.\");\n+                        stop();\n+                    } catch (Exception e) {\n+                        log.warn(\"Error processing data from from server \" + name, e);\n+                        stop();\n+                    }\n+                }\n+            });\n+        }\n+\n+        @VisibleForTesting\n+        static WireCommand readCommand(InputStream in, IoBuffer buffer) throws IOException {\n+            ByteBuf header = buffer.getBuffOfSize(in, 8);\n+\n+            int t = header.getInt(0);\n+            WireCommandType type = WireCommands.getType(t);\n+            if (type == null) {\n+                throw new InvalidMessageException(\"Unknown wire command: \" + t);\n+            }\n+\n+            int length = header.getInt(4);\n+            if (length < 0 || length > WireCommands.MAX_WIRECOMMAND_SIZE) {\n+                throw new InvalidMessageException(\"Event of invalid length: \" + length);\n+            }\n+\n+            ByteBuf payload = buffer.getBuffOfSize(in, length);\n+            \n+            return type.readFrom(new EnhancedByteBufInputStream(payload), length);\n+        }\n+        \n+        public void stop() {\n+            stop.set(true);\n+            thread.shutdown();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODIwNTA3Nw==", "bodyText": "shall we wait for the threadPool to terminate execution ?", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r448205077", "createdAt": "2020-07-01T08:32:06Z", "author": {"login": "eolivelli"}, "path": "client/src/main/java/io/pravega/client/connection/impl/TcpClientConnection.java", "diffHunk": "@@ -0,0 +1,306 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.connection.impl;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import io.netty.buffer.ByteBuf;\n+import io.pravega.client.ClientConfig;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import io.pravega.common.util.CertificateUtils;\n+import io.pravega.shared.protocol.netty.Append;\n+import io.pravega.shared.protocol.netty.AppendBatchSizeTracker;\n+import io.pravega.shared.protocol.netty.ConnectionFailedException;\n+import io.pravega.shared.protocol.netty.EnhancedByteBufInputStream;\n+import io.pravega.shared.protocol.netty.InvalidMessageException;\n+import io.pravega.shared.protocol.netty.PravegaNodeUri;\n+import io.pravega.shared.protocol.netty.Reply;\n+import io.pravega.shared.protocol.netty.ReplyProcessor;\n+import io.pravega.shared.protocol.netty.WireCommand;\n+import io.pravega.shared.protocol.netty.WireCommandType;\n+import io.pravega.shared.protocol.netty.WireCommands;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.SocketException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.CertificateException;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLParameters;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.TrustManagerFactory;\n+import lombok.RequiredArgsConstructor;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.pravega.shared.protocol.netty.AppendBatchSizeTracker.MAX_BATCH_TIME_MILLIS;\n+\n+@Slf4j\n+public class TcpClientConnection implements ClientConnection {\n+\n+    static final int TCP_BUFFER_SIZE = 256 * 1024;\n+    \n+    private final Socket socket;\n+    private final CommandEncoder encoder;\n+    private final ConnectionReader reader;\n+    private final AtomicBoolean closed = new AtomicBoolean(false);\n+    private final PravegaNodeUri location;\n+    private final Runnable onClose;\n+    private final ScheduledFuture<?> timeoutFuture;\n+   \n+    private TcpClientConnection(Socket socket, CommandEncoder encoder, ConnectionReader reader, PravegaNodeUri location,\n+                                Runnable onClose, ScheduledExecutorService executor) {\n+        this.socket = checkNotNull(socket);\n+        this.encoder = checkNotNull(encoder);\n+        this.reader = checkNotNull(reader);\n+        this.location = checkNotNull(location);\n+        this.onClose = onClose;\n+        this.timeoutFuture = executor.scheduleWithFixedDelay(new TimeoutBatch(encoder),\n+                                                             MAX_BATCH_TIME_MILLIS,\n+                                                             MAX_BATCH_TIME_MILLIS,\n+                                                             TimeUnit.MILLISECONDS);\n+    }\n+\n+    @VisibleForTesting\n+    static class ConnectionReader {\n+        \n+        private final String name;\n+        private final InputStream in;\n+        private final ReplyProcessor callback;\n+        private final ScheduledExecutorService thread;\n+        private final AppendBatchSizeTracker batchSizeTracker;\n+        private final AtomicBoolean stop = new AtomicBoolean(false);\n+\n+        public ConnectionReader(String name, InputStream in, ReplyProcessor callback,\n+                                AppendBatchSizeTracker batchSizeTracker) {\n+            this.name = name;\n+            this.in = in;\n+            this.callback = callback;\n+            this.thread = ExecutorServiceHelpers.newScheduledThreadPool(1, \"Reading from \" + name);\n+            this.batchSizeTracker = batchSizeTracker;\n+        }\n+        \n+        public void start() {\n+            thread.submit(() -> {\n+                IoBuffer buffer = new IoBuffer();\n+                while (!stop.get()) {\n+                    try {\n+                        WireCommand command = readCommand(in, buffer);\n+                        if (command instanceof WireCommands.DataAppended) {\n+                            WireCommands.DataAppended dataAppended = (WireCommands.DataAppended) command;\n+                            batchSizeTracker.recordAck(dataAppended.getEventNumber());\n+                        }\n+                        try {\n+                            callback.process((Reply) command);\n+                        } catch (Exception e) {\n+                            callback.processingFailure(e);\n+                        }\n+                    } catch (SocketException e) {\n+                        if (e.getMessage().equals(\"Socket closed\")) {\n+                            log.info(\"Closing TcpConnection.Reader because socket is closed.\");\n+                        } else {\n+                            log.warn(\"Error in reading from socket.\", e);\n+                        }\n+                        stop();\n+                    } catch (EOFException e) {\n+                        log.info(\"Closing TcpConnection.Reader because end of input readched.\");\n+                        stop();\n+                    } catch (Exception e) {\n+                        log.warn(\"Error processing data from from server \" + name, e);\n+                        stop();\n+                    }\n+                }\n+            });\n+        }\n+\n+        @VisibleForTesting\n+        static WireCommand readCommand(InputStream in, IoBuffer buffer) throws IOException {\n+            ByteBuf header = buffer.getBuffOfSize(in, 8);\n+\n+            int t = header.getInt(0);\n+            WireCommandType type = WireCommands.getType(t);\n+            if (type == null) {\n+                throw new InvalidMessageException(\"Unknown wire command: \" + t);\n+            }\n+\n+            int length = header.getInt(4);\n+            if (length < 0 || length > WireCommands.MAX_WIRECOMMAND_SIZE) {\n+                throw new InvalidMessageException(\"Event of invalid length: \" + length);\n+            }\n+\n+            ByteBuf payload = buffer.getBuffOfSize(in, length);\n+            \n+            return type.readFrom(new EnhancedByteBufInputStream(payload), length);\n+        }\n+        \n+        public void stop() {\n+            stop.set(true);\n+            thread.shutdown();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3ODM3Nw=="}, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIxNzcyNA==", "bodyText": "Removed the pool", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r451217724", "createdAt": "2020-07-08T00:35:55Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/connection/impl/TcpClientConnection.java", "diffHunk": "@@ -0,0 +1,306 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.connection.impl;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import io.netty.buffer.ByteBuf;\n+import io.pravega.client.ClientConfig;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import io.pravega.common.util.CertificateUtils;\n+import io.pravega.shared.protocol.netty.Append;\n+import io.pravega.shared.protocol.netty.AppendBatchSizeTracker;\n+import io.pravega.shared.protocol.netty.ConnectionFailedException;\n+import io.pravega.shared.protocol.netty.EnhancedByteBufInputStream;\n+import io.pravega.shared.protocol.netty.InvalidMessageException;\n+import io.pravega.shared.protocol.netty.PravegaNodeUri;\n+import io.pravega.shared.protocol.netty.Reply;\n+import io.pravega.shared.protocol.netty.ReplyProcessor;\n+import io.pravega.shared.protocol.netty.WireCommand;\n+import io.pravega.shared.protocol.netty.WireCommandType;\n+import io.pravega.shared.protocol.netty.WireCommands;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.SocketException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.CertificateException;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLParameters;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.TrustManagerFactory;\n+import lombok.RequiredArgsConstructor;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.pravega.shared.protocol.netty.AppendBatchSizeTracker.MAX_BATCH_TIME_MILLIS;\n+\n+@Slf4j\n+public class TcpClientConnection implements ClientConnection {\n+\n+    static final int TCP_BUFFER_SIZE = 256 * 1024;\n+    \n+    private final Socket socket;\n+    private final CommandEncoder encoder;\n+    private final ConnectionReader reader;\n+    private final AtomicBoolean closed = new AtomicBoolean(false);\n+    private final PravegaNodeUri location;\n+    private final Runnable onClose;\n+    private final ScheduledFuture<?> timeoutFuture;\n+   \n+    private TcpClientConnection(Socket socket, CommandEncoder encoder, ConnectionReader reader, PravegaNodeUri location,\n+                                Runnable onClose, ScheduledExecutorService executor) {\n+        this.socket = checkNotNull(socket);\n+        this.encoder = checkNotNull(encoder);\n+        this.reader = checkNotNull(reader);\n+        this.location = checkNotNull(location);\n+        this.onClose = onClose;\n+        this.timeoutFuture = executor.scheduleWithFixedDelay(new TimeoutBatch(encoder),\n+                                                             MAX_BATCH_TIME_MILLIS,\n+                                                             MAX_BATCH_TIME_MILLIS,\n+                                                             TimeUnit.MILLISECONDS);\n+    }\n+\n+    @VisibleForTesting\n+    static class ConnectionReader {\n+        \n+        private final String name;\n+        private final InputStream in;\n+        private final ReplyProcessor callback;\n+        private final ScheduledExecutorService thread;\n+        private final AppendBatchSizeTracker batchSizeTracker;\n+        private final AtomicBoolean stop = new AtomicBoolean(false);\n+\n+        public ConnectionReader(String name, InputStream in, ReplyProcessor callback,\n+                                AppendBatchSizeTracker batchSizeTracker) {\n+            this.name = name;\n+            this.in = in;\n+            this.callback = callback;\n+            this.thread = ExecutorServiceHelpers.newScheduledThreadPool(1, \"Reading from \" + name);\n+            this.batchSizeTracker = batchSizeTracker;\n+        }\n+        \n+        public void start() {\n+            thread.submit(() -> {\n+                IoBuffer buffer = new IoBuffer();\n+                while (!stop.get()) {\n+                    try {\n+                        WireCommand command = readCommand(in, buffer);\n+                        if (command instanceof WireCommands.DataAppended) {\n+                            WireCommands.DataAppended dataAppended = (WireCommands.DataAppended) command;\n+                            batchSizeTracker.recordAck(dataAppended.getEventNumber());\n+                        }\n+                        try {\n+                            callback.process((Reply) command);\n+                        } catch (Exception e) {\n+                            callback.processingFailure(e);\n+                        }\n+                    } catch (SocketException e) {\n+                        if (e.getMessage().equals(\"Socket closed\")) {\n+                            log.info(\"Closing TcpConnection.Reader because socket is closed.\");\n+                        } else {\n+                            log.warn(\"Error in reading from socket.\", e);\n+                        }\n+                        stop();\n+                    } catch (EOFException e) {\n+                        log.info(\"Closing TcpConnection.Reader because end of input readched.\");\n+                        stop();\n+                    } catch (Exception e) {\n+                        log.warn(\"Error processing data from from server \" + name, e);\n+                        stop();\n+                    }\n+                }\n+            });\n+        }\n+\n+        @VisibleForTesting\n+        static WireCommand readCommand(InputStream in, IoBuffer buffer) throws IOException {\n+            ByteBuf header = buffer.getBuffOfSize(in, 8);\n+\n+            int t = header.getInt(0);\n+            WireCommandType type = WireCommands.getType(t);\n+            if (type == null) {\n+                throw new InvalidMessageException(\"Unknown wire command: \" + t);\n+            }\n+\n+            int length = header.getInt(4);\n+            if (length < 0 || length > WireCommands.MAX_WIRECOMMAND_SIZE) {\n+                throw new InvalidMessageException(\"Event of invalid length: \" + length);\n+            }\n+\n+            ByteBuf payload = buffer.getBuffOfSize(in, length);\n+            \n+            return type.readFrom(new EnhancedByteBufInputStream(payload), length);\n+        }\n+        \n+        public void stop() {\n+            stop.set(true);\n+            thread.shutdown();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3ODM3Nw=="}, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 157}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MjExODg2OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/connection/impl/TcpClientConnection.java", "isResolved": true, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMTowNzoyMlrOGrOgLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMjoyODo0OVrOGw8yeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3OTU2NQ==", "bodyText": "Should we ensure that the socket is closed before invoking onClose (as it may itself throw an exception)?", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r447979565", "createdAt": "2020-06-30T21:07:22Z", "author": {"login": "andreipaduroiu"}, "path": "client/src/main/java/io/pravega/client/connection/impl/TcpClientConnection.java", "diffHunk": "@@ -0,0 +1,306 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.connection.impl;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import io.netty.buffer.ByteBuf;\n+import io.pravega.client.ClientConfig;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import io.pravega.common.util.CertificateUtils;\n+import io.pravega.shared.protocol.netty.Append;\n+import io.pravega.shared.protocol.netty.AppendBatchSizeTracker;\n+import io.pravega.shared.protocol.netty.ConnectionFailedException;\n+import io.pravega.shared.protocol.netty.EnhancedByteBufInputStream;\n+import io.pravega.shared.protocol.netty.InvalidMessageException;\n+import io.pravega.shared.protocol.netty.PravegaNodeUri;\n+import io.pravega.shared.protocol.netty.Reply;\n+import io.pravega.shared.protocol.netty.ReplyProcessor;\n+import io.pravega.shared.protocol.netty.WireCommand;\n+import io.pravega.shared.protocol.netty.WireCommandType;\n+import io.pravega.shared.protocol.netty.WireCommands;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.SocketException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.CertificateException;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLParameters;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.TrustManagerFactory;\n+import lombok.RequiredArgsConstructor;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.pravega.shared.protocol.netty.AppendBatchSizeTracker.MAX_BATCH_TIME_MILLIS;\n+\n+@Slf4j\n+public class TcpClientConnection implements ClientConnection {\n+\n+    static final int TCP_BUFFER_SIZE = 256 * 1024;\n+    \n+    private final Socket socket;\n+    private final CommandEncoder encoder;\n+    private final ConnectionReader reader;\n+    private final AtomicBoolean closed = new AtomicBoolean(false);\n+    private final PravegaNodeUri location;\n+    private final Runnable onClose;\n+    private final ScheduledFuture<?> timeoutFuture;\n+   \n+    private TcpClientConnection(Socket socket, CommandEncoder encoder, ConnectionReader reader, PravegaNodeUri location,\n+                                Runnable onClose, ScheduledExecutorService executor) {\n+        this.socket = checkNotNull(socket);\n+        this.encoder = checkNotNull(encoder);\n+        this.reader = checkNotNull(reader);\n+        this.location = checkNotNull(location);\n+        this.onClose = onClose;\n+        this.timeoutFuture = executor.scheduleWithFixedDelay(new TimeoutBatch(encoder),\n+                                                             MAX_BATCH_TIME_MILLIS,\n+                                                             MAX_BATCH_TIME_MILLIS,\n+                                                             TimeUnit.MILLISECONDS);\n+    }\n+\n+    @VisibleForTesting\n+    static class ConnectionReader {\n+        \n+        private final String name;\n+        private final InputStream in;\n+        private final ReplyProcessor callback;\n+        private final ScheduledExecutorService thread;\n+        private final AppendBatchSizeTracker batchSizeTracker;\n+        private final AtomicBoolean stop = new AtomicBoolean(false);\n+\n+        public ConnectionReader(String name, InputStream in, ReplyProcessor callback,\n+                                AppendBatchSizeTracker batchSizeTracker) {\n+            this.name = name;\n+            this.in = in;\n+            this.callback = callback;\n+            this.thread = ExecutorServiceHelpers.newScheduledThreadPool(1, \"Reading from \" + name);\n+            this.batchSizeTracker = batchSizeTracker;\n+        }\n+        \n+        public void start() {\n+            thread.submit(() -> {\n+                IoBuffer buffer = new IoBuffer();\n+                while (!stop.get()) {\n+                    try {\n+                        WireCommand command = readCommand(in, buffer);\n+                        if (command instanceof WireCommands.DataAppended) {\n+                            WireCommands.DataAppended dataAppended = (WireCommands.DataAppended) command;\n+                            batchSizeTracker.recordAck(dataAppended.getEventNumber());\n+                        }\n+                        try {\n+                            callback.process((Reply) command);\n+                        } catch (Exception e) {\n+                            callback.processingFailure(e);\n+                        }\n+                    } catch (SocketException e) {\n+                        if (e.getMessage().equals(\"Socket closed\")) {\n+                            log.info(\"Closing TcpConnection.Reader because socket is closed.\");\n+                        } else {\n+                            log.warn(\"Error in reading from socket.\", e);\n+                        }\n+                        stop();\n+                    } catch (EOFException e) {\n+                        log.info(\"Closing TcpConnection.Reader because end of input readched.\");\n+                        stop();\n+                    } catch (Exception e) {\n+                        log.warn(\"Error processing data from from server \" + name, e);\n+                        stop();\n+                    }\n+                }\n+            });\n+        }\n+\n+        @VisibleForTesting\n+        static WireCommand readCommand(InputStream in, IoBuffer buffer) throws IOException {\n+            ByteBuf header = buffer.getBuffOfSize(in, 8);\n+\n+            int t = header.getInt(0);\n+            WireCommandType type = WireCommands.getType(t);\n+            if (type == null) {\n+                throw new InvalidMessageException(\"Unknown wire command: \" + t);\n+            }\n+\n+            int length = header.getInt(4);\n+            if (length < 0 || length > WireCommands.MAX_WIRECOMMAND_SIZE) {\n+                throw new InvalidMessageException(\"Event of invalid length: \" + length);\n+            }\n+\n+            ByteBuf payload = buffer.getBuffOfSize(in, length);\n+            \n+            return type.readFrom(new EnhancedByteBufInputStream(payload), length);\n+        }\n+        \n+        public void stop() {\n+            stop.set(true);\n+            thread.shutdown();\n+            callback.connectionDropped();\n+        }\n+    }\n+    \n+    @RequiredArgsConstructor\n+    private static final class TimeoutBatch implements Runnable {\n+        private final AtomicLong token = new AtomicLong(-1);\n+        private final CommandEncoder encoder;\n+        @Override\n+        public void run() {\n+            token.set(encoder.batchTimeout(token.get()));\n+        }    \n+    }\n+\n+    public static CompletableFuture<TcpClientConnection> connect(PravegaNodeUri location, ClientConfig clientConfig, ReplyProcessor callback,\n+                                              ScheduledExecutorService executor, Runnable onClose) {\n+        return CompletableFuture.supplyAsync(() -> {\n+            Socket socket = createClientSocket(location, clientConfig); \n+            try {\n+                InputStream inputStream = socket.getInputStream();\n+                AppendBatchSizeTrackerImpl batchSizeTracker = new AppendBatchSizeTrackerImpl();\n+                ConnectionReader reader = new ConnectionReader(location.toString(), inputStream, callback, batchSizeTracker);\n+                reader.start();\n+                CommandEncoder encoder = new CommandEncoder(l -> batchSizeTracker, null, socket.getOutputStream());\n+                return new TcpClientConnection(socket, encoder, reader, location, onClose, executor);\n+            } catch (IOException e) {\n+                try {\n+                    onClose.run();\n+                    socket.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 186}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3OTgxMA==", "bodyText": "I would close the socket on any exception that comes out of this code, not just IOException.", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r447979810", "createdAt": "2020-06-30T21:07:54Z", "author": {"login": "andreipaduroiu"}, "path": "client/src/main/java/io/pravega/client/connection/impl/TcpClientConnection.java", "diffHunk": "@@ -0,0 +1,306 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.connection.impl;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import io.netty.buffer.ByteBuf;\n+import io.pravega.client.ClientConfig;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import io.pravega.common.util.CertificateUtils;\n+import io.pravega.shared.protocol.netty.Append;\n+import io.pravega.shared.protocol.netty.AppendBatchSizeTracker;\n+import io.pravega.shared.protocol.netty.ConnectionFailedException;\n+import io.pravega.shared.protocol.netty.EnhancedByteBufInputStream;\n+import io.pravega.shared.protocol.netty.InvalidMessageException;\n+import io.pravega.shared.protocol.netty.PravegaNodeUri;\n+import io.pravega.shared.protocol.netty.Reply;\n+import io.pravega.shared.protocol.netty.ReplyProcessor;\n+import io.pravega.shared.protocol.netty.WireCommand;\n+import io.pravega.shared.protocol.netty.WireCommandType;\n+import io.pravega.shared.protocol.netty.WireCommands;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.SocketException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.CertificateException;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLParameters;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.TrustManagerFactory;\n+import lombok.RequiredArgsConstructor;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.pravega.shared.protocol.netty.AppendBatchSizeTracker.MAX_BATCH_TIME_MILLIS;\n+\n+@Slf4j\n+public class TcpClientConnection implements ClientConnection {\n+\n+    static final int TCP_BUFFER_SIZE = 256 * 1024;\n+    \n+    private final Socket socket;\n+    private final CommandEncoder encoder;\n+    private final ConnectionReader reader;\n+    private final AtomicBoolean closed = new AtomicBoolean(false);\n+    private final PravegaNodeUri location;\n+    private final Runnable onClose;\n+    private final ScheduledFuture<?> timeoutFuture;\n+   \n+    private TcpClientConnection(Socket socket, CommandEncoder encoder, ConnectionReader reader, PravegaNodeUri location,\n+                                Runnable onClose, ScheduledExecutorService executor) {\n+        this.socket = checkNotNull(socket);\n+        this.encoder = checkNotNull(encoder);\n+        this.reader = checkNotNull(reader);\n+        this.location = checkNotNull(location);\n+        this.onClose = onClose;\n+        this.timeoutFuture = executor.scheduleWithFixedDelay(new TimeoutBatch(encoder),\n+                                                             MAX_BATCH_TIME_MILLIS,\n+                                                             MAX_BATCH_TIME_MILLIS,\n+                                                             TimeUnit.MILLISECONDS);\n+    }\n+\n+    @VisibleForTesting\n+    static class ConnectionReader {\n+        \n+        private final String name;\n+        private final InputStream in;\n+        private final ReplyProcessor callback;\n+        private final ScheduledExecutorService thread;\n+        private final AppendBatchSizeTracker batchSizeTracker;\n+        private final AtomicBoolean stop = new AtomicBoolean(false);\n+\n+        public ConnectionReader(String name, InputStream in, ReplyProcessor callback,\n+                                AppendBatchSizeTracker batchSizeTracker) {\n+            this.name = name;\n+            this.in = in;\n+            this.callback = callback;\n+            this.thread = ExecutorServiceHelpers.newScheduledThreadPool(1, \"Reading from \" + name);\n+            this.batchSizeTracker = batchSizeTracker;\n+        }\n+        \n+        public void start() {\n+            thread.submit(() -> {\n+                IoBuffer buffer = new IoBuffer();\n+                while (!stop.get()) {\n+                    try {\n+                        WireCommand command = readCommand(in, buffer);\n+                        if (command instanceof WireCommands.DataAppended) {\n+                            WireCommands.DataAppended dataAppended = (WireCommands.DataAppended) command;\n+                            batchSizeTracker.recordAck(dataAppended.getEventNumber());\n+                        }\n+                        try {\n+                            callback.process((Reply) command);\n+                        } catch (Exception e) {\n+                            callback.processingFailure(e);\n+                        }\n+                    } catch (SocketException e) {\n+                        if (e.getMessage().equals(\"Socket closed\")) {\n+                            log.info(\"Closing TcpConnection.Reader because socket is closed.\");\n+                        } else {\n+                            log.warn(\"Error in reading from socket.\", e);\n+                        }\n+                        stop();\n+                    } catch (EOFException e) {\n+                        log.info(\"Closing TcpConnection.Reader because end of input readched.\");\n+                        stop();\n+                    } catch (Exception e) {\n+                        log.warn(\"Error processing data from from server \" + name, e);\n+                        stop();\n+                    }\n+                }\n+            });\n+        }\n+\n+        @VisibleForTesting\n+        static WireCommand readCommand(InputStream in, IoBuffer buffer) throws IOException {\n+            ByteBuf header = buffer.getBuffOfSize(in, 8);\n+\n+            int t = header.getInt(0);\n+            WireCommandType type = WireCommands.getType(t);\n+            if (type == null) {\n+                throw new InvalidMessageException(\"Unknown wire command: \" + t);\n+            }\n+\n+            int length = header.getInt(4);\n+            if (length < 0 || length > WireCommands.MAX_WIRECOMMAND_SIZE) {\n+                throw new InvalidMessageException(\"Event of invalid length: \" + length);\n+            }\n+\n+            ByteBuf payload = buffer.getBuffOfSize(in, length);\n+            \n+            return type.readFrom(new EnhancedByteBufInputStream(payload), length);\n+        }\n+        \n+        public void stop() {\n+            stop.set(true);\n+            thread.shutdown();\n+            callback.connectionDropped();\n+        }\n+    }\n+    \n+    @RequiredArgsConstructor\n+    private static final class TimeoutBatch implements Runnable {\n+        private final AtomicLong token = new AtomicLong(-1);\n+        private final CommandEncoder encoder;\n+        @Override\n+        public void run() {\n+            token.set(encoder.batchTimeout(token.get()));\n+        }    \n+    }\n+\n+    public static CompletableFuture<TcpClientConnection> connect(PravegaNodeUri location, ClientConfig clientConfig, ReplyProcessor callback,\n+                                              ScheduledExecutorService executor, Runnable onClose) {\n+        return CompletableFuture.supplyAsync(() -> {\n+            Socket socket = createClientSocket(location, clientConfig); \n+            try {\n+                InputStream inputStream = socket.getInputStream();\n+                AppendBatchSizeTrackerImpl batchSizeTracker = new AppendBatchSizeTrackerImpl();\n+                ConnectionReader reader = new ConnectionReader(location.toString(), inputStream, callback, batchSizeTracker);\n+                reader.start();\n+                CommandEncoder encoder = new CommandEncoder(l -> batchSizeTracker, null, socket.getOutputStream());\n+                return new TcpClientConnection(socket, encoder, reader, location, onClose, executor);\n+            } catch (IOException e) {\n+                try {\n+                    onClose.run();\n+                    socket.close();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3OTU2NQ=="}, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 186}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE5NTM2Mg==", "bodyText": "Done", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r451195362", "createdAt": "2020-07-07T23:16:24Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/connection/impl/TcpClientConnection.java", "diffHunk": "@@ -0,0 +1,306 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.connection.impl;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import io.netty.buffer.ByteBuf;\n+import io.pravega.client.ClientConfig;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import io.pravega.common.util.CertificateUtils;\n+import io.pravega.shared.protocol.netty.Append;\n+import io.pravega.shared.protocol.netty.AppendBatchSizeTracker;\n+import io.pravega.shared.protocol.netty.ConnectionFailedException;\n+import io.pravega.shared.protocol.netty.EnhancedByteBufInputStream;\n+import io.pravega.shared.protocol.netty.InvalidMessageException;\n+import io.pravega.shared.protocol.netty.PravegaNodeUri;\n+import io.pravega.shared.protocol.netty.Reply;\n+import io.pravega.shared.protocol.netty.ReplyProcessor;\n+import io.pravega.shared.protocol.netty.WireCommand;\n+import io.pravega.shared.protocol.netty.WireCommandType;\n+import io.pravega.shared.protocol.netty.WireCommands;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.SocketException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.CertificateException;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLParameters;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.TrustManagerFactory;\n+import lombok.RequiredArgsConstructor;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.pravega.shared.protocol.netty.AppendBatchSizeTracker.MAX_BATCH_TIME_MILLIS;\n+\n+@Slf4j\n+public class TcpClientConnection implements ClientConnection {\n+\n+    static final int TCP_BUFFER_SIZE = 256 * 1024;\n+    \n+    private final Socket socket;\n+    private final CommandEncoder encoder;\n+    private final ConnectionReader reader;\n+    private final AtomicBoolean closed = new AtomicBoolean(false);\n+    private final PravegaNodeUri location;\n+    private final Runnable onClose;\n+    private final ScheduledFuture<?> timeoutFuture;\n+   \n+    private TcpClientConnection(Socket socket, CommandEncoder encoder, ConnectionReader reader, PravegaNodeUri location,\n+                                Runnable onClose, ScheduledExecutorService executor) {\n+        this.socket = checkNotNull(socket);\n+        this.encoder = checkNotNull(encoder);\n+        this.reader = checkNotNull(reader);\n+        this.location = checkNotNull(location);\n+        this.onClose = onClose;\n+        this.timeoutFuture = executor.scheduleWithFixedDelay(new TimeoutBatch(encoder),\n+                                                             MAX_BATCH_TIME_MILLIS,\n+                                                             MAX_BATCH_TIME_MILLIS,\n+                                                             TimeUnit.MILLISECONDS);\n+    }\n+\n+    @VisibleForTesting\n+    static class ConnectionReader {\n+        \n+        private final String name;\n+        private final InputStream in;\n+        private final ReplyProcessor callback;\n+        private final ScheduledExecutorService thread;\n+        private final AppendBatchSizeTracker batchSizeTracker;\n+        private final AtomicBoolean stop = new AtomicBoolean(false);\n+\n+        public ConnectionReader(String name, InputStream in, ReplyProcessor callback,\n+                                AppendBatchSizeTracker batchSizeTracker) {\n+            this.name = name;\n+            this.in = in;\n+            this.callback = callback;\n+            this.thread = ExecutorServiceHelpers.newScheduledThreadPool(1, \"Reading from \" + name);\n+            this.batchSizeTracker = batchSizeTracker;\n+        }\n+        \n+        public void start() {\n+            thread.submit(() -> {\n+                IoBuffer buffer = new IoBuffer();\n+                while (!stop.get()) {\n+                    try {\n+                        WireCommand command = readCommand(in, buffer);\n+                        if (command instanceof WireCommands.DataAppended) {\n+                            WireCommands.DataAppended dataAppended = (WireCommands.DataAppended) command;\n+                            batchSizeTracker.recordAck(dataAppended.getEventNumber());\n+                        }\n+                        try {\n+                            callback.process((Reply) command);\n+                        } catch (Exception e) {\n+                            callback.processingFailure(e);\n+                        }\n+                    } catch (SocketException e) {\n+                        if (e.getMessage().equals(\"Socket closed\")) {\n+                            log.info(\"Closing TcpConnection.Reader because socket is closed.\");\n+                        } else {\n+                            log.warn(\"Error in reading from socket.\", e);\n+                        }\n+                        stop();\n+                    } catch (EOFException e) {\n+                        log.info(\"Closing TcpConnection.Reader because end of input readched.\");\n+                        stop();\n+                    } catch (Exception e) {\n+                        log.warn(\"Error processing data from from server \" + name, e);\n+                        stop();\n+                    }\n+                }\n+            });\n+        }\n+\n+        @VisibleForTesting\n+        static WireCommand readCommand(InputStream in, IoBuffer buffer) throws IOException {\n+            ByteBuf header = buffer.getBuffOfSize(in, 8);\n+\n+            int t = header.getInt(0);\n+            WireCommandType type = WireCommands.getType(t);\n+            if (type == null) {\n+                throw new InvalidMessageException(\"Unknown wire command: \" + t);\n+            }\n+\n+            int length = header.getInt(4);\n+            if (length < 0 || length > WireCommands.MAX_WIRECOMMAND_SIZE) {\n+                throw new InvalidMessageException(\"Event of invalid length: \" + length);\n+            }\n+\n+            ByteBuf payload = buffer.getBuffOfSize(in, length);\n+            \n+            return type.readFrom(new EnhancedByteBufInputStream(payload), length);\n+        }\n+        \n+        public void stop() {\n+            stop.set(true);\n+            thread.shutdown();\n+            callback.connectionDropped();\n+        }\n+    }\n+    \n+    @RequiredArgsConstructor\n+    private static final class TimeoutBatch implements Runnable {\n+        private final AtomicLong token = new AtomicLong(-1);\n+        private final CommandEncoder encoder;\n+        @Override\n+        public void run() {\n+            token.set(encoder.batchTimeout(token.get()));\n+        }    \n+    }\n+\n+    public static CompletableFuture<TcpClientConnection> connect(PravegaNodeUri location, ClientConfig clientConfig, ReplyProcessor callback,\n+                                              ScheduledExecutorService executor, Runnable onClose) {\n+        return CompletableFuture.supplyAsync(() -> {\n+            Socket socket = createClientSocket(location, clientConfig); \n+            try {\n+                InputStream inputStream = socket.getInputStream();\n+                AppendBatchSizeTrackerImpl batchSizeTracker = new AppendBatchSizeTrackerImpl();\n+                ConnectionReader reader = new ConnectionReader(location.toString(), inputStream, callback, batchSizeTracker);\n+                reader.start();\n+                CommandEncoder encoder = new CommandEncoder(l -> batchSizeTracker, null, socket.getOutputStream());\n+                return new TcpClientConnection(socket, encoder, reader, location, onClose, executor);\n+            } catch (IOException e) {\n+                try {\n+                    onClose.run();\n+                    socket.close();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3OTU2NQ=="}, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 186}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzYwMzYxOA==", "bodyText": "It looks like that if onClose throws a RuntimeException we are still not calling close", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r453603618", "createdAt": "2020-07-13T12:09:57Z", "author": {"login": "eolivelli"}, "path": "client/src/main/java/io/pravega/client/connection/impl/TcpClientConnection.java", "diffHunk": "@@ -0,0 +1,306 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.connection.impl;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import io.netty.buffer.ByteBuf;\n+import io.pravega.client.ClientConfig;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import io.pravega.common.util.CertificateUtils;\n+import io.pravega.shared.protocol.netty.Append;\n+import io.pravega.shared.protocol.netty.AppendBatchSizeTracker;\n+import io.pravega.shared.protocol.netty.ConnectionFailedException;\n+import io.pravega.shared.protocol.netty.EnhancedByteBufInputStream;\n+import io.pravega.shared.protocol.netty.InvalidMessageException;\n+import io.pravega.shared.protocol.netty.PravegaNodeUri;\n+import io.pravega.shared.protocol.netty.Reply;\n+import io.pravega.shared.protocol.netty.ReplyProcessor;\n+import io.pravega.shared.protocol.netty.WireCommand;\n+import io.pravega.shared.protocol.netty.WireCommandType;\n+import io.pravega.shared.protocol.netty.WireCommands;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.SocketException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.CertificateException;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLParameters;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.TrustManagerFactory;\n+import lombok.RequiredArgsConstructor;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.pravega.shared.protocol.netty.AppendBatchSizeTracker.MAX_BATCH_TIME_MILLIS;\n+\n+@Slf4j\n+public class TcpClientConnection implements ClientConnection {\n+\n+    static final int TCP_BUFFER_SIZE = 256 * 1024;\n+    \n+    private final Socket socket;\n+    private final CommandEncoder encoder;\n+    private final ConnectionReader reader;\n+    private final AtomicBoolean closed = new AtomicBoolean(false);\n+    private final PravegaNodeUri location;\n+    private final Runnable onClose;\n+    private final ScheduledFuture<?> timeoutFuture;\n+   \n+    private TcpClientConnection(Socket socket, CommandEncoder encoder, ConnectionReader reader, PravegaNodeUri location,\n+                                Runnable onClose, ScheduledExecutorService executor) {\n+        this.socket = checkNotNull(socket);\n+        this.encoder = checkNotNull(encoder);\n+        this.reader = checkNotNull(reader);\n+        this.location = checkNotNull(location);\n+        this.onClose = onClose;\n+        this.timeoutFuture = executor.scheduleWithFixedDelay(new TimeoutBatch(encoder),\n+                                                             MAX_BATCH_TIME_MILLIS,\n+                                                             MAX_BATCH_TIME_MILLIS,\n+                                                             TimeUnit.MILLISECONDS);\n+    }\n+\n+    @VisibleForTesting\n+    static class ConnectionReader {\n+        \n+        private final String name;\n+        private final InputStream in;\n+        private final ReplyProcessor callback;\n+        private final ScheduledExecutorService thread;\n+        private final AppendBatchSizeTracker batchSizeTracker;\n+        private final AtomicBoolean stop = new AtomicBoolean(false);\n+\n+        public ConnectionReader(String name, InputStream in, ReplyProcessor callback,\n+                                AppendBatchSizeTracker batchSizeTracker) {\n+            this.name = name;\n+            this.in = in;\n+            this.callback = callback;\n+            this.thread = ExecutorServiceHelpers.newScheduledThreadPool(1, \"Reading from \" + name);\n+            this.batchSizeTracker = batchSizeTracker;\n+        }\n+        \n+        public void start() {\n+            thread.submit(() -> {\n+                IoBuffer buffer = new IoBuffer();\n+                while (!stop.get()) {\n+                    try {\n+                        WireCommand command = readCommand(in, buffer);\n+                        if (command instanceof WireCommands.DataAppended) {\n+                            WireCommands.DataAppended dataAppended = (WireCommands.DataAppended) command;\n+                            batchSizeTracker.recordAck(dataAppended.getEventNumber());\n+                        }\n+                        try {\n+                            callback.process((Reply) command);\n+                        } catch (Exception e) {\n+                            callback.processingFailure(e);\n+                        }\n+                    } catch (SocketException e) {\n+                        if (e.getMessage().equals(\"Socket closed\")) {\n+                            log.info(\"Closing TcpConnection.Reader because socket is closed.\");\n+                        } else {\n+                            log.warn(\"Error in reading from socket.\", e);\n+                        }\n+                        stop();\n+                    } catch (EOFException e) {\n+                        log.info(\"Closing TcpConnection.Reader because end of input readched.\");\n+                        stop();\n+                    } catch (Exception e) {\n+                        log.warn(\"Error processing data from from server \" + name, e);\n+                        stop();\n+                    }\n+                }\n+            });\n+        }\n+\n+        @VisibleForTesting\n+        static WireCommand readCommand(InputStream in, IoBuffer buffer) throws IOException {\n+            ByteBuf header = buffer.getBuffOfSize(in, 8);\n+\n+            int t = header.getInt(0);\n+            WireCommandType type = WireCommands.getType(t);\n+            if (type == null) {\n+                throw new InvalidMessageException(\"Unknown wire command: \" + t);\n+            }\n+\n+            int length = header.getInt(4);\n+            if (length < 0 || length > WireCommands.MAX_WIRECOMMAND_SIZE) {\n+                throw new InvalidMessageException(\"Event of invalid length: \" + length);\n+            }\n+\n+            ByteBuf payload = buffer.getBuffOfSize(in, length);\n+            \n+            return type.readFrom(new EnhancedByteBufInputStream(payload), length);\n+        }\n+        \n+        public void stop() {\n+            stop.set(true);\n+            thread.shutdown();\n+            callback.connectionDropped();\n+        }\n+    }\n+    \n+    @RequiredArgsConstructor\n+    private static final class TimeoutBatch implements Runnable {\n+        private final AtomicLong token = new AtomicLong(-1);\n+        private final CommandEncoder encoder;\n+        @Override\n+        public void run() {\n+            token.set(encoder.batchTimeout(token.get()));\n+        }    \n+    }\n+\n+    public static CompletableFuture<TcpClientConnection> connect(PravegaNodeUri location, ClientConfig clientConfig, ReplyProcessor callback,\n+                                              ScheduledExecutorService executor, Runnable onClose) {\n+        return CompletableFuture.supplyAsync(() -> {\n+            Socket socket = createClientSocket(location, clientConfig); \n+            try {\n+                InputStream inputStream = socket.getInputStream();\n+                AppendBatchSizeTrackerImpl batchSizeTracker = new AppendBatchSizeTrackerImpl();\n+                ConnectionReader reader = new ConnectionReader(location.toString(), inputStream, callback, batchSizeTracker);\n+                reader.start();\n+                CommandEncoder encoder = new CommandEncoder(l -> batchSizeTracker, null, socket.getOutputStream());\n+                return new TcpClientConnection(socket, encoder, reader, location, onClose, executor);\n+            } catch (IOException e) {\n+                try {\n+                    onClose.run();\n+                    socket.close();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3OTU2NQ=="}, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 186}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg5NzY0OQ==", "bodyText": "@eolivelli I think you need to refresh. close is now called first.", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r453897649", "createdAt": "2020-07-13T19:59:54Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/connection/impl/TcpClientConnection.java", "diffHunk": "@@ -0,0 +1,306 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.connection.impl;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import io.netty.buffer.ByteBuf;\n+import io.pravega.client.ClientConfig;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import io.pravega.common.util.CertificateUtils;\n+import io.pravega.shared.protocol.netty.Append;\n+import io.pravega.shared.protocol.netty.AppendBatchSizeTracker;\n+import io.pravega.shared.protocol.netty.ConnectionFailedException;\n+import io.pravega.shared.protocol.netty.EnhancedByteBufInputStream;\n+import io.pravega.shared.protocol.netty.InvalidMessageException;\n+import io.pravega.shared.protocol.netty.PravegaNodeUri;\n+import io.pravega.shared.protocol.netty.Reply;\n+import io.pravega.shared.protocol.netty.ReplyProcessor;\n+import io.pravega.shared.protocol.netty.WireCommand;\n+import io.pravega.shared.protocol.netty.WireCommandType;\n+import io.pravega.shared.protocol.netty.WireCommands;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.SocketException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.CertificateException;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLParameters;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.TrustManagerFactory;\n+import lombok.RequiredArgsConstructor;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.pravega.shared.protocol.netty.AppendBatchSizeTracker.MAX_BATCH_TIME_MILLIS;\n+\n+@Slf4j\n+public class TcpClientConnection implements ClientConnection {\n+\n+    static final int TCP_BUFFER_SIZE = 256 * 1024;\n+    \n+    private final Socket socket;\n+    private final CommandEncoder encoder;\n+    private final ConnectionReader reader;\n+    private final AtomicBoolean closed = new AtomicBoolean(false);\n+    private final PravegaNodeUri location;\n+    private final Runnable onClose;\n+    private final ScheduledFuture<?> timeoutFuture;\n+   \n+    private TcpClientConnection(Socket socket, CommandEncoder encoder, ConnectionReader reader, PravegaNodeUri location,\n+                                Runnable onClose, ScheduledExecutorService executor) {\n+        this.socket = checkNotNull(socket);\n+        this.encoder = checkNotNull(encoder);\n+        this.reader = checkNotNull(reader);\n+        this.location = checkNotNull(location);\n+        this.onClose = onClose;\n+        this.timeoutFuture = executor.scheduleWithFixedDelay(new TimeoutBatch(encoder),\n+                                                             MAX_BATCH_TIME_MILLIS,\n+                                                             MAX_BATCH_TIME_MILLIS,\n+                                                             TimeUnit.MILLISECONDS);\n+    }\n+\n+    @VisibleForTesting\n+    static class ConnectionReader {\n+        \n+        private final String name;\n+        private final InputStream in;\n+        private final ReplyProcessor callback;\n+        private final ScheduledExecutorService thread;\n+        private final AppendBatchSizeTracker batchSizeTracker;\n+        private final AtomicBoolean stop = new AtomicBoolean(false);\n+\n+        public ConnectionReader(String name, InputStream in, ReplyProcessor callback,\n+                                AppendBatchSizeTracker batchSizeTracker) {\n+            this.name = name;\n+            this.in = in;\n+            this.callback = callback;\n+            this.thread = ExecutorServiceHelpers.newScheduledThreadPool(1, \"Reading from \" + name);\n+            this.batchSizeTracker = batchSizeTracker;\n+        }\n+        \n+        public void start() {\n+            thread.submit(() -> {\n+                IoBuffer buffer = new IoBuffer();\n+                while (!stop.get()) {\n+                    try {\n+                        WireCommand command = readCommand(in, buffer);\n+                        if (command instanceof WireCommands.DataAppended) {\n+                            WireCommands.DataAppended dataAppended = (WireCommands.DataAppended) command;\n+                            batchSizeTracker.recordAck(dataAppended.getEventNumber());\n+                        }\n+                        try {\n+                            callback.process((Reply) command);\n+                        } catch (Exception e) {\n+                            callback.processingFailure(e);\n+                        }\n+                    } catch (SocketException e) {\n+                        if (e.getMessage().equals(\"Socket closed\")) {\n+                            log.info(\"Closing TcpConnection.Reader because socket is closed.\");\n+                        } else {\n+                            log.warn(\"Error in reading from socket.\", e);\n+                        }\n+                        stop();\n+                    } catch (EOFException e) {\n+                        log.info(\"Closing TcpConnection.Reader because end of input readched.\");\n+                        stop();\n+                    } catch (Exception e) {\n+                        log.warn(\"Error processing data from from server \" + name, e);\n+                        stop();\n+                    }\n+                }\n+            });\n+        }\n+\n+        @VisibleForTesting\n+        static WireCommand readCommand(InputStream in, IoBuffer buffer) throws IOException {\n+            ByteBuf header = buffer.getBuffOfSize(in, 8);\n+\n+            int t = header.getInt(0);\n+            WireCommandType type = WireCommands.getType(t);\n+            if (type == null) {\n+                throw new InvalidMessageException(\"Unknown wire command: \" + t);\n+            }\n+\n+            int length = header.getInt(4);\n+            if (length < 0 || length > WireCommands.MAX_WIRECOMMAND_SIZE) {\n+                throw new InvalidMessageException(\"Event of invalid length: \" + length);\n+            }\n+\n+            ByteBuf payload = buffer.getBuffOfSize(in, length);\n+            \n+            return type.readFrom(new EnhancedByteBufInputStream(payload), length);\n+        }\n+        \n+        public void stop() {\n+            stop.set(true);\n+            thread.shutdown();\n+            callback.connectionDropped();\n+        }\n+    }\n+    \n+    @RequiredArgsConstructor\n+    private static final class TimeoutBatch implements Runnable {\n+        private final AtomicLong token = new AtomicLong(-1);\n+        private final CommandEncoder encoder;\n+        @Override\n+        public void run() {\n+            token.set(encoder.batchTimeout(token.get()));\n+        }    \n+    }\n+\n+    public static CompletableFuture<TcpClientConnection> connect(PravegaNodeUri location, ClientConfig clientConfig, ReplyProcessor callback,\n+                                              ScheduledExecutorService executor, Runnable onClose) {\n+        return CompletableFuture.supplyAsync(() -> {\n+            Socket socket = createClientSocket(location, clientConfig); \n+            try {\n+                InputStream inputStream = socket.getInputStream();\n+                AppendBatchSizeTrackerImpl batchSizeTracker = new AppendBatchSizeTrackerImpl();\n+                ConnectionReader reader = new ConnectionReader(location.toString(), inputStream, callback, batchSizeTracker);\n+                reader.start();\n+                CommandEncoder encoder = new CommandEncoder(l -> batchSizeTracker, null, socket.getOutputStream());\n+                return new TcpClientConnection(socket, encoder, reader, location, onClose, executor);\n+            } catch (IOException e) {\n+                try {\n+                    onClose.run();\n+                    socket.close();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3OTU2NQ=="}, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 186}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk0MDM2OQ==", "bodyText": "I still see\n                    onClose.run();\n                    socket.close();", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r453940369", "createdAt": "2020-07-13T21:21:29Z", "author": {"login": "andreipaduroiu"}, "path": "client/src/main/java/io/pravega/client/connection/impl/TcpClientConnection.java", "diffHunk": "@@ -0,0 +1,306 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.connection.impl;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import io.netty.buffer.ByteBuf;\n+import io.pravega.client.ClientConfig;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import io.pravega.common.util.CertificateUtils;\n+import io.pravega.shared.protocol.netty.Append;\n+import io.pravega.shared.protocol.netty.AppendBatchSizeTracker;\n+import io.pravega.shared.protocol.netty.ConnectionFailedException;\n+import io.pravega.shared.protocol.netty.EnhancedByteBufInputStream;\n+import io.pravega.shared.protocol.netty.InvalidMessageException;\n+import io.pravega.shared.protocol.netty.PravegaNodeUri;\n+import io.pravega.shared.protocol.netty.Reply;\n+import io.pravega.shared.protocol.netty.ReplyProcessor;\n+import io.pravega.shared.protocol.netty.WireCommand;\n+import io.pravega.shared.protocol.netty.WireCommandType;\n+import io.pravega.shared.protocol.netty.WireCommands;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.SocketException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.CertificateException;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLParameters;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.TrustManagerFactory;\n+import lombok.RequiredArgsConstructor;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.pravega.shared.protocol.netty.AppendBatchSizeTracker.MAX_BATCH_TIME_MILLIS;\n+\n+@Slf4j\n+public class TcpClientConnection implements ClientConnection {\n+\n+    static final int TCP_BUFFER_SIZE = 256 * 1024;\n+    \n+    private final Socket socket;\n+    private final CommandEncoder encoder;\n+    private final ConnectionReader reader;\n+    private final AtomicBoolean closed = new AtomicBoolean(false);\n+    private final PravegaNodeUri location;\n+    private final Runnable onClose;\n+    private final ScheduledFuture<?> timeoutFuture;\n+   \n+    private TcpClientConnection(Socket socket, CommandEncoder encoder, ConnectionReader reader, PravegaNodeUri location,\n+                                Runnable onClose, ScheduledExecutorService executor) {\n+        this.socket = checkNotNull(socket);\n+        this.encoder = checkNotNull(encoder);\n+        this.reader = checkNotNull(reader);\n+        this.location = checkNotNull(location);\n+        this.onClose = onClose;\n+        this.timeoutFuture = executor.scheduleWithFixedDelay(new TimeoutBatch(encoder),\n+                                                             MAX_BATCH_TIME_MILLIS,\n+                                                             MAX_BATCH_TIME_MILLIS,\n+                                                             TimeUnit.MILLISECONDS);\n+    }\n+\n+    @VisibleForTesting\n+    static class ConnectionReader {\n+        \n+        private final String name;\n+        private final InputStream in;\n+        private final ReplyProcessor callback;\n+        private final ScheduledExecutorService thread;\n+        private final AppendBatchSizeTracker batchSizeTracker;\n+        private final AtomicBoolean stop = new AtomicBoolean(false);\n+\n+        public ConnectionReader(String name, InputStream in, ReplyProcessor callback,\n+                                AppendBatchSizeTracker batchSizeTracker) {\n+            this.name = name;\n+            this.in = in;\n+            this.callback = callback;\n+            this.thread = ExecutorServiceHelpers.newScheduledThreadPool(1, \"Reading from \" + name);\n+            this.batchSizeTracker = batchSizeTracker;\n+        }\n+        \n+        public void start() {\n+            thread.submit(() -> {\n+                IoBuffer buffer = new IoBuffer();\n+                while (!stop.get()) {\n+                    try {\n+                        WireCommand command = readCommand(in, buffer);\n+                        if (command instanceof WireCommands.DataAppended) {\n+                            WireCommands.DataAppended dataAppended = (WireCommands.DataAppended) command;\n+                            batchSizeTracker.recordAck(dataAppended.getEventNumber());\n+                        }\n+                        try {\n+                            callback.process((Reply) command);\n+                        } catch (Exception e) {\n+                            callback.processingFailure(e);\n+                        }\n+                    } catch (SocketException e) {\n+                        if (e.getMessage().equals(\"Socket closed\")) {\n+                            log.info(\"Closing TcpConnection.Reader because socket is closed.\");\n+                        } else {\n+                            log.warn(\"Error in reading from socket.\", e);\n+                        }\n+                        stop();\n+                    } catch (EOFException e) {\n+                        log.info(\"Closing TcpConnection.Reader because end of input readched.\");\n+                        stop();\n+                    } catch (Exception e) {\n+                        log.warn(\"Error processing data from from server \" + name, e);\n+                        stop();\n+                    }\n+                }\n+            });\n+        }\n+\n+        @VisibleForTesting\n+        static WireCommand readCommand(InputStream in, IoBuffer buffer) throws IOException {\n+            ByteBuf header = buffer.getBuffOfSize(in, 8);\n+\n+            int t = header.getInt(0);\n+            WireCommandType type = WireCommands.getType(t);\n+            if (type == null) {\n+                throw new InvalidMessageException(\"Unknown wire command: \" + t);\n+            }\n+\n+            int length = header.getInt(4);\n+            if (length < 0 || length > WireCommands.MAX_WIRECOMMAND_SIZE) {\n+                throw new InvalidMessageException(\"Event of invalid length: \" + length);\n+            }\n+\n+            ByteBuf payload = buffer.getBuffOfSize(in, length);\n+            \n+            return type.readFrom(new EnhancedByteBufInputStream(payload), length);\n+        }\n+        \n+        public void stop() {\n+            stop.set(true);\n+            thread.shutdown();\n+            callback.connectionDropped();\n+        }\n+    }\n+    \n+    @RequiredArgsConstructor\n+    private static final class TimeoutBatch implements Runnable {\n+        private final AtomicLong token = new AtomicLong(-1);\n+        private final CommandEncoder encoder;\n+        @Override\n+        public void run() {\n+            token.set(encoder.batchTimeout(token.get()));\n+        }    \n+    }\n+\n+    public static CompletableFuture<TcpClientConnection> connect(PravegaNodeUri location, ClientConfig clientConfig, ReplyProcessor callback,\n+                                              ScheduledExecutorService executor, Runnable onClose) {\n+        return CompletableFuture.supplyAsync(() -> {\n+            Socket socket = createClientSocket(location, clientConfig); \n+            try {\n+                InputStream inputStream = socket.getInputStream();\n+                AppendBatchSizeTrackerImpl batchSizeTracker = new AppendBatchSizeTrackerImpl();\n+                ConnectionReader reader = new ConnectionReader(location.toString(), inputStream, callback, batchSizeTracker);\n+                reader.start();\n+                CommandEncoder encoder = new CommandEncoder(l -> batchSizeTracker, null, socket.getOutputStream());\n+                return new TcpClientConnection(socket, encoder, reader, location, onClose, executor);\n+            } catch (IOException e) {\n+                try {\n+                    onClose.run();\n+                    socket.close();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3OTU2NQ=="}, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 186}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk4MDc5Mg==", "bodyText": "My mistake. I was looking in the wrong place.\nfixed.", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r453980792", "createdAt": "2020-07-13T22:28:49Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/connection/impl/TcpClientConnection.java", "diffHunk": "@@ -0,0 +1,306 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.connection.impl;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import io.netty.buffer.ByteBuf;\n+import io.pravega.client.ClientConfig;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import io.pravega.common.util.CertificateUtils;\n+import io.pravega.shared.protocol.netty.Append;\n+import io.pravega.shared.protocol.netty.AppendBatchSizeTracker;\n+import io.pravega.shared.protocol.netty.ConnectionFailedException;\n+import io.pravega.shared.protocol.netty.EnhancedByteBufInputStream;\n+import io.pravega.shared.protocol.netty.InvalidMessageException;\n+import io.pravega.shared.protocol.netty.PravegaNodeUri;\n+import io.pravega.shared.protocol.netty.Reply;\n+import io.pravega.shared.protocol.netty.ReplyProcessor;\n+import io.pravega.shared.protocol.netty.WireCommand;\n+import io.pravega.shared.protocol.netty.WireCommandType;\n+import io.pravega.shared.protocol.netty.WireCommands;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.SocketException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.CertificateException;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLParameters;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.TrustManagerFactory;\n+import lombok.RequiredArgsConstructor;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.pravega.shared.protocol.netty.AppendBatchSizeTracker.MAX_BATCH_TIME_MILLIS;\n+\n+@Slf4j\n+public class TcpClientConnection implements ClientConnection {\n+\n+    static final int TCP_BUFFER_SIZE = 256 * 1024;\n+    \n+    private final Socket socket;\n+    private final CommandEncoder encoder;\n+    private final ConnectionReader reader;\n+    private final AtomicBoolean closed = new AtomicBoolean(false);\n+    private final PravegaNodeUri location;\n+    private final Runnable onClose;\n+    private final ScheduledFuture<?> timeoutFuture;\n+   \n+    private TcpClientConnection(Socket socket, CommandEncoder encoder, ConnectionReader reader, PravegaNodeUri location,\n+                                Runnable onClose, ScheduledExecutorService executor) {\n+        this.socket = checkNotNull(socket);\n+        this.encoder = checkNotNull(encoder);\n+        this.reader = checkNotNull(reader);\n+        this.location = checkNotNull(location);\n+        this.onClose = onClose;\n+        this.timeoutFuture = executor.scheduleWithFixedDelay(new TimeoutBatch(encoder),\n+                                                             MAX_BATCH_TIME_MILLIS,\n+                                                             MAX_BATCH_TIME_MILLIS,\n+                                                             TimeUnit.MILLISECONDS);\n+    }\n+\n+    @VisibleForTesting\n+    static class ConnectionReader {\n+        \n+        private final String name;\n+        private final InputStream in;\n+        private final ReplyProcessor callback;\n+        private final ScheduledExecutorService thread;\n+        private final AppendBatchSizeTracker batchSizeTracker;\n+        private final AtomicBoolean stop = new AtomicBoolean(false);\n+\n+        public ConnectionReader(String name, InputStream in, ReplyProcessor callback,\n+                                AppendBatchSizeTracker batchSizeTracker) {\n+            this.name = name;\n+            this.in = in;\n+            this.callback = callback;\n+            this.thread = ExecutorServiceHelpers.newScheduledThreadPool(1, \"Reading from \" + name);\n+            this.batchSizeTracker = batchSizeTracker;\n+        }\n+        \n+        public void start() {\n+            thread.submit(() -> {\n+                IoBuffer buffer = new IoBuffer();\n+                while (!stop.get()) {\n+                    try {\n+                        WireCommand command = readCommand(in, buffer);\n+                        if (command instanceof WireCommands.DataAppended) {\n+                            WireCommands.DataAppended dataAppended = (WireCommands.DataAppended) command;\n+                            batchSizeTracker.recordAck(dataAppended.getEventNumber());\n+                        }\n+                        try {\n+                            callback.process((Reply) command);\n+                        } catch (Exception e) {\n+                            callback.processingFailure(e);\n+                        }\n+                    } catch (SocketException e) {\n+                        if (e.getMessage().equals(\"Socket closed\")) {\n+                            log.info(\"Closing TcpConnection.Reader because socket is closed.\");\n+                        } else {\n+                            log.warn(\"Error in reading from socket.\", e);\n+                        }\n+                        stop();\n+                    } catch (EOFException e) {\n+                        log.info(\"Closing TcpConnection.Reader because end of input readched.\");\n+                        stop();\n+                    } catch (Exception e) {\n+                        log.warn(\"Error processing data from from server \" + name, e);\n+                        stop();\n+                    }\n+                }\n+            });\n+        }\n+\n+        @VisibleForTesting\n+        static WireCommand readCommand(InputStream in, IoBuffer buffer) throws IOException {\n+            ByteBuf header = buffer.getBuffOfSize(in, 8);\n+\n+            int t = header.getInt(0);\n+            WireCommandType type = WireCommands.getType(t);\n+            if (type == null) {\n+                throw new InvalidMessageException(\"Unknown wire command: \" + t);\n+            }\n+\n+            int length = header.getInt(4);\n+            if (length < 0 || length > WireCommands.MAX_WIRECOMMAND_SIZE) {\n+                throw new InvalidMessageException(\"Event of invalid length: \" + length);\n+            }\n+\n+            ByteBuf payload = buffer.getBuffOfSize(in, length);\n+            \n+            return type.readFrom(new EnhancedByteBufInputStream(payload), length);\n+        }\n+        \n+        public void stop() {\n+            stop.set(true);\n+            thread.shutdown();\n+            callback.connectionDropped();\n+        }\n+    }\n+    \n+    @RequiredArgsConstructor\n+    private static final class TimeoutBatch implements Runnable {\n+        private final AtomicLong token = new AtomicLong(-1);\n+        private final CommandEncoder encoder;\n+        @Override\n+        public void run() {\n+            token.set(encoder.batchTimeout(token.get()));\n+        }    \n+    }\n+\n+    public static CompletableFuture<TcpClientConnection> connect(PravegaNodeUri location, ClientConfig clientConfig, ReplyProcessor callback,\n+                                              ScheduledExecutorService executor, Runnable onClose) {\n+        return CompletableFuture.supplyAsync(() -> {\n+            Socket socket = createClientSocket(location, clientConfig); \n+            try {\n+                InputStream inputStream = socket.getInputStream();\n+                AppendBatchSizeTrackerImpl batchSizeTracker = new AppendBatchSizeTrackerImpl();\n+                ConnectionReader reader = new ConnectionReader(location.toString(), inputStream, callback, batchSizeTracker);\n+                reader.start();\n+                CommandEncoder encoder = new CommandEncoder(l -> batchSizeTracker, null, socket.getOutputStream());\n+                return new TcpClientConnection(socket, encoder, reader, location, onClose, executor);\n+            } catch (IOException e) {\n+                try {\n+                    onClose.run();\n+                    socket.close();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk3OTU2NQ=="}, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 186}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MjEyNDc5OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/connection/impl/TcpClientConnection.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMTowOToyNlrOGrOkAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwMDoxNjoyOFrOGtq_yA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk4MDU0NA==", "bodyText": "You should put a try-catch around all this code and ensure the socket is closed if it has been created and some exception happens after that and until you return.", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r447980544", "createdAt": "2020-06-30T21:09:26Z", "author": {"login": "andreipaduroiu"}, "path": "client/src/main/java/io/pravega/client/connection/impl/TcpClientConnection.java", "diffHunk": "@@ -0,0 +1,306 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.connection.impl;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import io.netty.buffer.ByteBuf;\n+import io.pravega.client.ClientConfig;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import io.pravega.common.util.CertificateUtils;\n+import io.pravega.shared.protocol.netty.Append;\n+import io.pravega.shared.protocol.netty.AppendBatchSizeTracker;\n+import io.pravega.shared.protocol.netty.ConnectionFailedException;\n+import io.pravega.shared.protocol.netty.EnhancedByteBufInputStream;\n+import io.pravega.shared.protocol.netty.InvalidMessageException;\n+import io.pravega.shared.protocol.netty.PravegaNodeUri;\n+import io.pravega.shared.protocol.netty.Reply;\n+import io.pravega.shared.protocol.netty.ReplyProcessor;\n+import io.pravega.shared.protocol.netty.WireCommand;\n+import io.pravega.shared.protocol.netty.WireCommandType;\n+import io.pravega.shared.protocol.netty.WireCommands;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.SocketException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.CertificateException;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLParameters;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.TrustManagerFactory;\n+import lombok.RequiredArgsConstructor;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.pravega.shared.protocol.netty.AppendBatchSizeTracker.MAX_BATCH_TIME_MILLIS;\n+\n+@Slf4j\n+public class TcpClientConnection implements ClientConnection {\n+\n+    static final int TCP_BUFFER_SIZE = 256 * 1024;\n+    \n+    private final Socket socket;\n+    private final CommandEncoder encoder;\n+    private final ConnectionReader reader;\n+    private final AtomicBoolean closed = new AtomicBoolean(false);\n+    private final PravegaNodeUri location;\n+    private final Runnable onClose;\n+    private final ScheduledFuture<?> timeoutFuture;\n+   \n+    private TcpClientConnection(Socket socket, CommandEncoder encoder, ConnectionReader reader, PravegaNodeUri location,\n+                                Runnable onClose, ScheduledExecutorService executor) {\n+        this.socket = checkNotNull(socket);\n+        this.encoder = checkNotNull(encoder);\n+        this.reader = checkNotNull(reader);\n+        this.location = checkNotNull(location);\n+        this.onClose = onClose;\n+        this.timeoutFuture = executor.scheduleWithFixedDelay(new TimeoutBatch(encoder),\n+                                                             MAX_BATCH_TIME_MILLIS,\n+                                                             MAX_BATCH_TIME_MILLIS,\n+                                                             TimeUnit.MILLISECONDS);\n+    }\n+\n+    @VisibleForTesting\n+    static class ConnectionReader {\n+        \n+        private final String name;\n+        private final InputStream in;\n+        private final ReplyProcessor callback;\n+        private final ScheduledExecutorService thread;\n+        private final AppendBatchSizeTracker batchSizeTracker;\n+        private final AtomicBoolean stop = new AtomicBoolean(false);\n+\n+        public ConnectionReader(String name, InputStream in, ReplyProcessor callback,\n+                                AppendBatchSizeTracker batchSizeTracker) {\n+            this.name = name;\n+            this.in = in;\n+            this.callback = callback;\n+            this.thread = ExecutorServiceHelpers.newScheduledThreadPool(1, \"Reading from \" + name);\n+            this.batchSizeTracker = batchSizeTracker;\n+        }\n+        \n+        public void start() {\n+            thread.submit(() -> {\n+                IoBuffer buffer = new IoBuffer();\n+                while (!stop.get()) {\n+                    try {\n+                        WireCommand command = readCommand(in, buffer);\n+                        if (command instanceof WireCommands.DataAppended) {\n+                            WireCommands.DataAppended dataAppended = (WireCommands.DataAppended) command;\n+                            batchSizeTracker.recordAck(dataAppended.getEventNumber());\n+                        }\n+                        try {\n+                            callback.process((Reply) command);\n+                        } catch (Exception e) {\n+                            callback.processingFailure(e);\n+                        }\n+                    } catch (SocketException e) {\n+                        if (e.getMessage().equals(\"Socket closed\")) {\n+                            log.info(\"Closing TcpConnection.Reader because socket is closed.\");\n+                        } else {\n+                            log.warn(\"Error in reading from socket.\", e);\n+                        }\n+                        stop();\n+                    } catch (EOFException e) {\n+                        log.info(\"Closing TcpConnection.Reader because end of input readched.\");\n+                        stop();\n+                    } catch (Exception e) {\n+                        log.warn(\"Error processing data from from server \" + name, e);\n+                        stop();\n+                    }\n+                }\n+            });\n+        }\n+\n+        @VisibleForTesting\n+        static WireCommand readCommand(InputStream in, IoBuffer buffer) throws IOException {\n+            ByteBuf header = buffer.getBuffOfSize(in, 8);\n+\n+            int t = header.getInt(0);\n+            WireCommandType type = WireCommands.getType(t);\n+            if (type == null) {\n+                throw new InvalidMessageException(\"Unknown wire command: \" + t);\n+            }\n+\n+            int length = header.getInt(4);\n+            if (length < 0 || length > WireCommands.MAX_WIRECOMMAND_SIZE) {\n+                throw new InvalidMessageException(\"Event of invalid length: \" + length);\n+            }\n+\n+            ByteBuf payload = buffer.getBuffOfSize(in, length);\n+            \n+            return type.readFrom(new EnhancedByteBufInputStream(payload), length);\n+        }\n+        \n+        public void stop() {\n+            stop.set(true);\n+            thread.shutdown();\n+            callback.connectionDropped();\n+        }\n+    }\n+    \n+    @RequiredArgsConstructor\n+    private static final class TimeoutBatch implements Runnable {\n+        private final AtomicLong token = new AtomicLong(-1);\n+        private final CommandEncoder encoder;\n+        @Override\n+        public void run() {\n+            token.set(encoder.batchTimeout(token.get()));\n+        }    \n+    }\n+\n+    public static CompletableFuture<TcpClientConnection> connect(PravegaNodeUri location, ClientConfig clientConfig, ReplyProcessor callback,\n+                                              ScheduledExecutorService executor, Runnable onClose) {\n+        return CompletableFuture.supplyAsync(() -> {\n+            Socket socket = createClientSocket(location, clientConfig); \n+            try {\n+                InputStream inputStream = socket.getInputStream();\n+                AppendBatchSizeTrackerImpl batchSizeTracker = new AppendBatchSizeTrackerImpl();\n+                ConnectionReader reader = new ConnectionReader(location.toString(), inputStream, callback, batchSizeTracker);\n+                reader.start();\n+                CommandEncoder encoder = new CommandEncoder(l -> batchSizeTracker, null, socket.getOutputStream());\n+                return new TcpClientConnection(socket, encoder, reader, location, onClose, executor);\n+            } catch (IOException e) {\n+                try {\n+                    onClose.run();\n+                    socket.close();\n+                } catch (IOException e1) {\n+                    log.warn(\"Failed to close socket while failing.\", e1);\n+                }\n+                throw Exceptions.sneakyThrow(e);\n+            }\n+        }, executor);\n+    }\n+\n+    private static TrustManagerFactory createFromCert(String trustStoreFilePath)\n+            throws CertificateException, IOException, NoSuchAlgorithmException, KeyStoreException {\n+        TrustManagerFactory factory = null;\n+        if (!Strings.isNullOrEmpty(trustStoreFilePath)) {\n+            KeyStore trustStore = CertificateUtils.createTrustStore(trustStoreFilePath);\n+\n+            factory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n+            factory.init(trustStore);\n+        }\n+        return factory;\n+    }\n+\n+    /**\n+     * Creates a socket connected to the provided endpoint. \n+     * Note that this is a sync call even though it is called in an async context. \n+     * While this is normally frowned upon, it is simply not possible to construct an SSL socket asynchronously in Java.\n+     */\n+    @SneakyThrows //Is called inside a completable future.\n+    private static Socket createClientSocket(PravegaNodeUri location, ClientConfig clientConfig) {        \n+        Socket result;\n+        if (clientConfig.isEnableTlsToSegmentStore()) {\n+            TrustManagerFactory trustMgrFactory = createFromCert(clientConfig.getTrustStore());\n+\n+            // Prepare a TLS context that uses the trust manager\n+            SSLContext tlsContext = SSLContext.getInstance(\"TLS\");\n+            tlsContext.init(null,\n+                    trustMgrFactory != null ? trustMgrFactory.getTrustManagers() : null,\n+                    null);\n+\n+            SSLSocket s = (SSLSocket) tlsContext.getSocketFactory().createSocket();\n+            // SSLSocket does not perform hostname verification by default. So, we must explicitly enable it.\n+            if (clientConfig.isValidateHostName()) {\n+                SSLParameters tlsParams = new SSLParameters();\n+                tlsParams.setEndpointIdentificationAlgorithm(\"HTTPS\");\n+                s.setSSLParameters(tlsParams);\n+            }\n+            result = s;\n+\n+        } else {\n+            result = new Socket();\n+        }\n+        result.setSendBufferSize(TCP_BUFFER_SIZE);\n+        result.setReceiveBufferSize(TCP_BUFFER_SIZE);\n+        result.setTcpNoDelay(true);\n+        result.connect(new InetSocketAddress(location.getEndpoint(), location.getPort()));\n+        return result;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 240}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU0MzU2MA==", "bodyText": "Connect is the very last line of this block, if it fails anywhere prior to that there is nothing to close, if it fails on that it never opened.", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r450543560", "createdAt": "2020-07-07T00:16:28Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/connection/impl/TcpClientConnection.java", "diffHunk": "@@ -0,0 +1,306 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.connection.impl;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import io.netty.buffer.ByteBuf;\n+import io.pravega.client.ClientConfig;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import io.pravega.common.util.CertificateUtils;\n+import io.pravega.shared.protocol.netty.Append;\n+import io.pravega.shared.protocol.netty.AppendBatchSizeTracker;\n+import io.pravega.shared.protocol.netty.ConnectionFailedException;\n+import io.pravega.shared.protocol.netty.EnhancedByteBufInputStream;\n+import io.pravega.shared.protocol.netty.InvalidMessageException;\n+import io.pravega.shared.protocol.netty.PravegaNodeUri;\n+import io.pravega.shared.protocol.netty.Reply;\n+import io.pravega.shared.protocol.netty.ReplyProcessor;\n+import io.pravega.shared.protocol.netty.WireCommand;\n+import io.pravega.shared.protocol.netty.WireCommandType;\n+import io.pravega.shared.protocol.netty.WireCommands;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.SocketException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.CertificateException;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLParameters;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.TrustManagerFactory;\n+import lombok.RequiredArgsConstructor;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.pravega.shared.protocol.netty.AppendBatchSizeTracker.MAX_BATCH_TIME_MILLIS;\n+\n+@Slf4j\n+public class TcpClientConnection implements ClientConnection {\n+\n+    static final int TCP_BUFFER_SIZE = 256 * 1024;\n+    \n+    private final Socket socket;\n+    private final CommandEncoder encoder;\n+    private final ConnectionReader reader;\n+    private final AtomicBoolean closed = new AtomicBoolean(false);\n+    private final PravegaNodeUri location;\n+    private final Runnable onClose;\n+    private final ScheduledFuture<?> timeoutFuture;\n+   \n+    private TcpClientConnection(Socket socket, CommandEncoder encoder, ConnectionReader reader, PravegaNodeUri location,\n+                                Runnable onClose, ScheduledExecutorService executor) {\n+        this.socket = checkNotNull(socket);\n+        this.encoder = checkNotNull(encoder);\n+        this.reader = checkNotNull(reader);\n+        this.location = checkNotNull(location);\n+        this.onClose = onClose;\n+        this.timeoutFuture = executor.scheduleWithFixedDelay(new TimeoutBatch(encoder),\n+                                                             MAX_BATCH_TIME_MILLIS,\n+                                                             MAX_BATCH_TIME_MILLIS,\n+                                                             TimeUnit.MILLISECONDS);\n+    }\n+\n+    @VisibleForTesting\n+    static class ConnectionReader {\n+        \n+        private final String name;\n+        private final InputStream in;\n+        private final ReplyProcessor callback;\n+        private final ScheduledExecutorService thread;\n+        private final AppendBatchSizeTracker batchSizeTracker;\n+        private final AtomicBoolean stop = new AtomicBoolean(false);\n+\n+        public ConnectionReader(String name, InputStream in, ReplyProcessor callback,\n+                                AppendBatchSizeTracker batchSizeTracker) {\n+            this.name = name;\n+            this.in = in;\n+            this.callback = callback;\n+            this.thread = ExecutorServiceHelpers.newScheduledThreadPool(1, \"Reading from \" + name);\n+            this.batchSizeTracker = batchSizeTracker;\n+        }\n+        \n+        public void start() {\n+            thread.submit(() -> {\n+                IoBuffer buffer = new IoBuffer();\n+                while (!stop.get()) {\n+                    try {\n+                        WireCommand command = readCommand(in, buffer);\n+                        if (command instanceof WireCommands.DataAppended) {\n+                            WireCommands.DataAppended dataAppended = (WireCommands.DataAppended) command;\n+                            batchSizeTracker.recordAck(dataAppended.getEventNumber());\n+                        }\n+                        try {\n+                            callback.process((Reply) command);\n+                        } catch (Exception e) {\n+                            callback.processingFailure(e);\n+                        }\n+                    } catch (SocketException e) {\n+                        if (e.getMessage().equals(\"Socket closed\")) {\n+                            log.info(\"Closing TcpConnection.Reader because socket is closed.\");\n+                        } else {\n+                            log.warn(\"Error in reading from socket.\", e);\n+                        }\n+                        stop();\n+                    } catch (EOFException e) {\n+                        log.info(\"Closing TcpConnection.Reader because end of input readched.\");\n+                        stop();\n+                    } catch (Exception e) {\n+                        log.warn(\"Error processing data from from server \" + name, e);\n+                        stop();\n+                    }\n+                }\n+            });\n+        }\n+\n+        @VisibleForTesting\n+        static WireCommand readCommand(InputStream in, IoBuffer buffer) throws IOException {\n+            ByteBuf header = buffer.getBuffOfSize(in, 8);\n+\n+            int t = header.getInt(0);\n+            WireCommandType type = WireCommands.getType(t);\n+            if (type == null) {\n+                throw new InvalidMessageException(\"Unknown wire command: \" + t);\n+            }\n+\n+            int length = header.getInt(4);\n+            if (length < 0 || length > WireCommands.MAX_WIRECOMMAND_SIZE) {\n+                throw new InvalidMessageException(\"Event of invalid length: \" + length);\n+            }\n+\n+            ByteBuf payload = buffer.getBuffOfSize(in, length);\n+            \n+            return type.readFrom(new EnhancedByteBufInputStream(payload), length);\n+        }\n+        \n+        public void stop() {\n+            stop.set(true);\n+            thread.shutdown();\n+            callback.connectionDropped();\n+        }\n+    }\n+    \n+    @RequiredArgsConstructor\n+    private static final class TimeoutBatch implements Runnable {\n+        private final AtomicLong token = new AtomicLong(-1);\n+        private final CommandEncoder encoder;\n+        @Override\n+        public void run() {\n+            token.set(encoder.batchTimeout(token.get()));\n+        }    \n+    }\n+\n+    public static CompletableFuture<TcpClientConnection> connect(PravegaNodeUri location, ClientConfig clientConfig, ReplyProcessor callback,\n+                                              ScheduledExecutorService executor, Runnable onClose) {\n+        return CompletableFuture.supplyAsync(() -> {\n+            Socket socket = createClientSocket(location, clientConfig); \n+            try {\n+                InputStream inputStream = socket.getInputStream();\n+                AppendBatchSizeTrackerImpl batchSizeTracker = new AppendBatchSizeTrackerImpl();\n+                ConnectionReader reader = new ConnectionReader(location.toString(), inputStream, callback, batchSizeTracker);\n+                reader.start();\n+                CommandEncoder encoder = new CommandEncoder(l -> batchSizeTracker, null, socket.getOutputStream());\n+                return new TcpClientConnection(socket, encoder, reader, location, onClose, executor);\n+            } catch (IOException e) {\n+                try {\n+                    onClose.run();\n+                    socket.close();\n+                } catch (IOException e1) {\n+                    log.warn(\"Failed to close socket while failing.\", e1);\n+                }\n+                throw Exceptions.sneakyThrow(e);\n+            }\n+        }, executor);\n+    }\n+\n+    private static TrustManagerFactory createFromCert(String trustStoreFilePath)\n+            throws CertificateException, IOException, NoSuchAlgorithmException, KeyStoreException {\n+        TrustManagerFactory factory = null;\n+        if (!Strings.isNullOrEmpty(trustStoreFilePath)) {\n+            KeyStore trustStore = CertificateUtils.createTrustStore(trustStoreFilePath);\n+\n+            factory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n+            factory.init(trustStore);\n+        }\n+        return factory;\n+    }\n+\n+    /**\n+     * Creates a socket connected to the provided endpoint. \n+     * Note that this is a sync call even though it is called in an async context. \n+     * While this is normally frowned upon, it is simply not possible to construct an SSL socket asynchronously in Java.\n+     */\n+    @SneakyThrows //Is called inside a completable future.\n+    private static Socket createClientSocket(PravegaNodeUri location, ClientConfig clientConfig) {        \n+        Socket result;\n+        if (clientConfig.isEnableTlsToSegmentStore()) {\n+            TrustManagerFactory trustMgrFactory = createFromCert(clientConfig.getTrustStore());\n+\n+            // Prepare a TLS context that uses the trust manager\n+            SSLContext tlsContext = SSLContext.getInstance(\"TLS\");\n+            tlsContext.init(null,\n+                    trustMgrFactory != null ? trustMgrFactory.getTrustManagers() : null,\n+                    null);\n+\n+            SSLSocket s = (SSLSocket) tlsContext.getSocketFactory().createSocket();\n+            // SSLSocket does not perform hostname verification by default. So, we must explicitly enable it.\n+            if (clientConfig.isValidateHostName()) {\n+                SSLParameters tlsParams = new SSLParameters();\n+                tlsParams.setEndpointIdentificationAlgorithm(\"HTTPS\");\n+                s.setSSLParameters(tlsParams);\n+            }\n+            result = s;\n+\n+        } else {\n+            result = new Socket();\n+        }\n+        result.setSendBufferSize(TCP_BUFFER_SIZE);\n+        result.setReceiveBufferSize(TCP_BUFFER_SIZE);\n+        result.setTcpNoDelay(true);\n+        result.connect(new InetSocketAddress(location.getEndpoint(), location.getPort()));\n+        return result;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk4MDU0NA=="}, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 240}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MjEyNjk2OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/connection/impl/TcpClientConnection.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMToxMDoxMVrOGrOlYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMzoxNjo0OVrOGuSyVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk4MDg5OA==", "bodyText": "We should at least log the message of this exception (i.e. e.toString()) so that we know a bit more about why it failed.\nBelow too.", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r447980898", "createdAt": "2020-06-30T21:10:11Z", "author": {"login": "andreipaduroiu"}, "path": "client/src/main/java/io/pravega/client/connection/impl/TcpClientConnection.java", "diffHunk": "@@ -0,0 +1,306 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.connection.impl;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import io.netty.buffer.ByteBuf;\n+import io.pravega.client.ClientConfig;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import io.pravega.common.util.CertificateUtils;\n+import io.pravega.shared.protocol.netty.Append;\n+import io.pravega.shared.protocol.netty.AppendBatchSizeTracker;\n+import io.pravega.shared.protocol.netty.ConnectionFailedException;\n+import io.pravega.shared.protocol.netty.EnhancedByteBufInputStream;\n+import io.pravega.shared.protocol.netty.InvalidMessageException;\n+import io.pravega.shared.protocol.netty.PravegaNodeUri;\n+import io.pravega.shared.protocol.netty.Reply;\n+import io.pravega.shared.protocol.netty.ReplyProcessor;\n+import io.pravega.shared.protocol.netty.WireCommand;\n+import io.pravega.shared.protocol.netty.WireCommandType;\n+import io.pravega.shared.protocol.netty.WireCommands;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.SocketException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.CertificateException;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLParameters;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.TrustManagerFactory;\n+import lombok.RequiredArgsConstructor;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.pravega.shared.protocol.netty.AppendBatchSizeTracker.MAX_BATCH_TIME_MILLIS;\n+\n+@Slf4j\n+public class TcpClientConnection implements ClientConnection {\n+\n+    static final int TCP_BUFFER_SIZE = 256 * 1024;\n+    \n+    private final Socket socket;\n+    private final CommandEncoder encoder;\n+    private final ConnectionReader reader;\n+    private final AtomicBoolean closed = new AtomicBoolean(false);\n+    private final PravegaNodeUri location;\n+    private final Runnable onClose;\n+    private final ScheduledFuture<?> timeoutFuture;\n+   \n+    private TcpClientConnection(Socket socket, CommandEncoder encoder, ConnectionReader reader, PravegaNodeUri location,\n+                                Runnable onClose, ScheduledExecutorService executor) {\n+        this.socket = checkNotNull(socket);\n+        this.encoder = checkNotNull(encoder);\n+        this.reader = checkNotNull(reader);\n+        this.location = checkNotNull(location);\n+        this.onClose = onClose;\n+        this.timeoutFuture = executor.scheduleWithFixedDelay(new TimeoutBatch(encoder),\n+                                                             MAX_BATCH_TIME_MILLIS,\n+                                                             MAX_BATCH_TIME_MILLIS,\n+                                                             TimeUnit.MILLISECONDS);\n+    }\n+\n+    @VisibleForTesting\n+    static class ConnectionReader {\n+        \n+        private final String name;\n+        private final InputStream in;\n+        private final ReplyProcessor callback;\n+        private final ScheduledExecutorService thread;\n+        private final AppendBatchSizeTracker batchSizeTracker;\n+        private final AtomicBoolean stop = new AtomicBoolean(false);\n+\n+        public ConnectionReader(String name, InputStream in, ReplyProcessor callback,\n+                                AppendBatchSizeTracker batchSizeTracker) {\n+            this.name = name;\n+            this.in = in;\n+            this.callback = callback;\n+            this.thread = ExecutorServiceHelpers.newScheduledThreadPool(1, \"Reading from \" + name);\n+            this.batchSizeTracker = batchSizeTracker;\n+        }\n+        \n+        public void start() {\n+            thread.submit(() -> {\n+                IoBuffer buffer = new IoBuffer();\n+                while (!stop.get()) {\n+                    try {\n+                        WireCommand command = readCommand(in, buffer);\n+                        if (command instanceof WireCommands.DataAppended) {\n+                            WireCommands.DataAppended dataAppended = (WireCommands.DataAppended) command;\n+                            batchSizeTracker.recordAck(dataAppended.getEventNumber());\n+                        }\n+                        try {\n+                            callback.process((Reply) command);\n+                        } catch (Exception e) {\n+                            callback.processingFailure(e);\n+                        }\n+                    } catch (SocketException e) {\n+                        if (e.getMessage().equals(\"Socket closed\")) {\n+                            log.info(\"Closing TcpConnection.Reader because socket is closed.\");\n+                        } else {\n+                            log.warn(\"Error in reading from socket.\", e);\n+                        }\n+                        stop();\n+                    } catch (EOFException e) {\n+                        log.info(\"Closing TcpConnection.Reader because end of input readched.\");\n+                        stop();\n+                    } catch (Exception e) {\n+                        log.warn(\"Error processing data from from server \" + name, e);\n+                        stop();\n+                    }\n+                }\n+            });\n+        }\n+\n+        @VisibleForTesting\n+        static WireCommand readCommand(InputStream in, IoBuffer buffer) throws IOException {\n+            ByteBuf header = buffer.getBuffOfSize(in, 8);\n+\n+            int t = header.getInt(0);\n+            WireCommandType type = WireCommands.getType(t);\n+            if (type == null) {\n+                throw new InvalidMessageException(\"Unknown wire command: \" + t);\n+            }\n+\n+            int length = header.getInt(4);\n+            if (length < 0 || length > WireCommands.MAX_WIRECOMMAND_SIZE) {\n+                throw new InvalidMessageException(\"Event of invalid length: \" + length);\n+            }\n+\n+            ByteBuf payload = buffer.getBuffOfSize(in, length);\n+            \n+            return type.readFrom(new EnhancedByteBufInputStream(payload), length);\n+        }\n+        \n+        public void stop() {\n+            stop.set(true);\n+            thread.shutdown();\n+            callback.connectionDropped();\n+        }\n+    }\n+    \n+    @RequiredArgsConstructor\n+    private static final class TimeoutBatch implements Runnable {\n+        private final AtomicLong token = new AtomicLong(-1);\n+        private final CommandEncoder encoder;\n+        @Override\n+        public void run() {\n+            token.set(encoder.batchTimeout(token.get()));\n+        }    \n+    }\n+\n+    public static CompletableFuture<TcpClientConnection> connect(PravegaNodeUri location, ClientConfig clientConfig, ReplyProcessor callback,\n+                                              ScheduledExecutorService executor, Runnable onClose) {\n+        return CompletableFuture.supplyAsync(() -> {\n+            Socket socket = createClientSocket(location, clientConfig); \n+            try {\n+                InputStream inputStream = socket.getInputStream();\n+                AppendBatchSizeTrackerImpl batchSizeTracker = new AppendBatchSizeTrackerImpl();\n+                ConnectionReader reader = new ConnectionReader(location.toString(), inputStream, callback, batchSizeTracker);\n+                reader.start();\n+                CommandEncoder encoder = new CommandEncoder(l -> batchSizeTracker, null, socket.getOutputStream());\n+                return new TcpClientConnection(socket, encoder, reader, location, onClose, executor);\n+            } catch (IOException e) {\n+                try {\n+                    onClose.run();\n+                    socket.close();\n+                } catch (IOException e1) {\n+                    log.warn(\"Failed to close socket while failing.\", e1);\n+                }\n+                throw Exceptions.sneakyThrow(e);\n+            }\n+        }, executor);\n+    }\n+\n+    private static TrustManagerFactory createFromCert(String trustStoreFilePath)\n+            throws CertificateException, IOException, NoSuchAlgorithmException, KeyStoreException {\n+        TrustManagerFactory factory = null;\n+        if (!Strings.isNullOrEmpty(trustStoreFilePath)) {\n+            KeyStore trustStore = CertificateUtils.createTrustStore(trustStoreFilePath);\n+\n+            factory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n+            factory.init(trustStore);\n+        }\n+        return factory;\n+    }\n+\n+    /**\n+     * Creates a socket connected to the provided endpoint. \n+     * Note that this is a sync call even though it is called in an async context. \n+     * While this is normally frowned upon, it is simply not possible to construct an SSL socket asynchronously in Java.\n+     */\n+    @SneakyThrows //Is called inside a completable future.\n+    private static Socket createClientSocket(PravegaNodeUri location, ClientConfig clientConfig) {        \n+        Socket result;\n+        if (clientConfig.isEnableTlsToSegmentStore()) {\n+            TrustManagerFactory trustMgrFactory = createFromCert(clientConfig.getTrustStore());\n+\n+            // Prepare a TLS context that uses the trust manager\n+            SSLContext tlsContext = SSLContext.getInstance(\"TLS\");\n+            tlsContext.init(null,\n+                    trustMgrFactory != null ? trustMgrFactory.getTrustManagers() : null,\n+                    null);\n+\n+            SSLSocket s = (SSLSocket) tlsContext.getSocketFactory().createSocket();\n+            // SSLSocket does not perform hostname verification by default. So, we must explicitly enable it.\n+            if (clientConfig.isValidateHostName()) {\n+                SSLParameters tlsParams = new SSLParameters();\n+                tlsParams.setEndpointIdentificationAlgorithm(\"HTTPS\");\n+                s.setSSLParameters(tlsParams);\n+            }\n+            result = s;\n+\n+        } else {\n+            result = new Socket();\n+        }\n+        result.setSendBufferSize(TCP_BUFFER_SIZE);\n+        result.setReceiveBufferSize(TCP_BUFFER_SIZE);\n+        result.setTcpNoDelay(true);\n+        result.connect(new InetSocketAddress(location.getEndpoint(), location.getPort()));\n+        return result;\n+    }\n+\n+    @Override\n+    public void send(WireCommand cmd) throws ConnectionFailedException {\n+        if (closed.get()) {\n+            throw new ConnectionFailedException(\"Connection is closed\");\n+        }\n+        try {\n+            encoder.write(cmd);\n+        } catch (IOException e) {\n+            log.warn(\"Error writing to connection\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 251}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE5NTQ3Ng==", "bodyText": "Done", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r451195476", "createdAt": "2020-07-07T23:16:49Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/connection/impl/TcpClientConnection.java", "diffHunk": "@@ -0,0 +1,306 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.connection.impl;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import io.netty.buffer.ByteBuf;\n+import io.pravega.client.ClientConfig;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import io.pravega.common.util.CertificateUtils;\n+import io.pravega.shared.protocol.netty.Append;\n+import io.pravega.shared.protocol.netty.AppendBatchSizeTracker;\n+import io.pravega.shared.protocol.netty.ConnectionFailedException;\n+import io.pravega.shared.protocol.netty.EnhancedByteBufInputStream;\n+import io.pravega.shared.protocol.netty.InvalidMessageException;\n+import io.pravega.shared.protocol.netty.PravegaNodeUri;\n+import io.pravega.shared.protocol.netty.Reply;\n+import io.pravega.shared.protocol.netty.ReplyProcessor;\n+import io.pravega.shared.protocol.netty.WireCommand;\n+import io.pravega.shared.protocol.netty.WireCommandType;\n+import io.pravega.shared.protocol.netty.WireCommands;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.SocketException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.CertificateException;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLParameters;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.TrustManagerFactory;\n+import lombok.RequiredArgsConstructor;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.pravega.shared.protocol.netty.AppendBatchSizeTracker.MAX_BATCH_TIME_MILLIS;\n+\n+@Slf4j\n+public class TcpClientConnection implements ClientConnection {\n+\n+    static final int TCP_BUFFER_SIZE = 256 * 1024;\n+    \n+    private final Socket socket;\n+    private final CommandEncoder encoder;\n+    private final ConnectionReader reader;\n+    private final AtomicBoolean closed = new AtomicBoolean(false);\n+    private final PravegaNodeUri location;\n+    private final Runnable onClose;\n+    private final ScheduledFuture<?> timeoutFuture;\n+   \n+    private TcpClientConnection(Socket socket, CommandEncoder encoder, ConnectionReader reader, PravegaNodeUri location,\n+                                Runnable onClose, ScheduledExecutorService executor) {\n+        this.socket = checkNotNull(socket);\n+        this.encoder = checkNotNull(encoder);\n+        this.reader = checkNotNull(reader);\n+        this.location = checkNotNull(location);\n+        this.onClose = onClose;\n+        this.timeoutFuture = executor.scheduleWithFixedDelay(new TimeoutBatch(encoder),\n+                                                             MAX_BATCH_TIME_MILLIS,\n+                                                             MAX_BATCH_TIME_MILLIS,\n+                                                             TimeUnit.MILLISECONDS);\n+    }\n+\n+    @VisibleForTesting\n+    static class ConnectionReader {\n+        \n+        private final String name;\n+        private final InputStream in;\n+        private final ReplyProcessor callback;\n+        private final ScheduledExecutorService thread;\n+        private final AppendBatchSizeTracker batchSizeTracker;\n+        private final AtomicBoolean stop = new AtomicBoolean(false);\n+\n+        public ConnectionReader(String name, InputStream in, ReplyProcessor callback,\n+                                AppendBatchSizeTracker batchSizeTracker) {\n+            this.name = name;\n+            this.in = in;\n+            this.callback = callback;\n+            this.thread = ExecutorServiceHelpers.newScheduledThreadPool(1, \"Reading from \" + name);\n+            this.batchSizeTracker = batchSizeTracker;\n+        }\n+        \n+        public void start() {\n+            thread.submit(() -> {\n+                IoBuffer buffer = new IoBuffer();\n+                while (!stop.get()) {\n+                    try {\n+                        WireCommand command = readCommand(in, buffer);\n+                        if (command instanceof WireCommands.DataAppended) {\n+                            WireCommands.DataAppended dataAppended = (WireCommands.DataAppended) command;\n+                            batchSizeTracker.recordAck(dataAppended.getEventNumber());\n+                        }\n+                        try {\n+                            callback.process((Reply) command);\n+                        } catch (Exception e) {\n+                            callback.processingFailure(e);\n+                        }\n+                    } catch (SocketException e) {\n+                        if (e.getMessage().equals(\"Socket closed\")) {\n+                            log.info(\"Closing TcpConnection.Reader because socket is closed.\");\n+                        } else {\n+                            log.warn(\"Error in reading from socket.\", e);\n+                        }\n+                        stop();\n+                    } catch (EOFException e) {\n+                        log.info(\"Closing TcpConnection.Reader because end of input readched.\");\n+                        stop();\n+                    } catch (Exception e) {\n+                        log.warn(\"Error processing data from from server \" + name, e);\n+                        stop();\n+                    }\n+                }\n+            });\n+        }\n+\n+        @VisibleForTesting\n+        static WireCommand readCommand(InputStream in, IoBuffer buffer) throws IOException {\n+            ByteBuf header = buffer.getBuffOfSize(in, 8);\n+\n+            int t = header.getInt(0);\n+            WireCommandType type = WireCommands.getType(t);\n+            if (type == null) {\n+                throw new InvalidMessageException(\"Unknown wire command: \" + t);\n+            }\n+\n+            int length = header.getInt(4);\n+            if (length < 0 || length > WireCommands.MAX_WIRECOMMAND_SIZE) {\n+                throw new InvalidMessageException(\"Event of invalid length: \" + length);\n+            }\n+\n+            ByteBuf payload = buffer.getBuffOfSize(in, length);\n+            \n+            return type.readFrom(new EnhancedByteBufInputStream(payload), length);\n+        }\n+        \n+        public void stop() {\n+            stop.set(true);\n+            thread.shutdown();\n+            callback.connectionDropped();\n+        }\n+    }\n+    \n+    @RequiredArgsConstructor\n+    private static final class TimeoutBatch implements Runnable {\n+        private final AtomicLong token = new AtomicLong(-1);\n+        private final CommandEncoder encoder;\n+        @Override\n+        public void run() {\n+            token.set(encoder.batchTimeout(token.get()));\n+        }    \n+    }\n+\n+    public static CompletableFuture<TcpClientConnection> connect(PravegaNodeUri location, ClientConfig clientConfig, ReplyProcessor callback,\n+                                              ScheduledExecutorService executor, Runnable onClose) {\n+        return CompletableFuture.supplyAsync(() -> {\n+            Socket socket = createClientSocket(location, clientConfig); \n+            try {\n+                InputStream inputStream = socket.getInputStream();\n+                AppendBatchSizeTrackerImpl batchSizeTracker = new AppendBatchSizeTrackerImpl();\n+                ConnectionReader reader = new ConnectionReader(location.toString(), inputStream, callback, batchSizeTracker);\n+                reader.start();\n+                CommandEncoder encoder = new CommandEncoder(l -> batchSizeTracker, null, socket.getOutputStream());\n+                return new TcpClientConnection(socket, encoder, reader, location, onClose, executor);\n+            } catch (IOException e) {\n+                try {\n+                    onClose.run();\n+                    socket.close();\n+                } catch (IOException e1) {\n+                    log.warn(\"Failed to close socket while failing.\", e1);\n+                }\n+                throw Exceptions.sneakyThrow(e);\n+            }\n+        }, executor);\n+    }\n+\n+    private static TrustManagerFactory createFromCert(String trustStoreFilePath)\n+            throws CertificateException, IOException, NoSuchAlgorithmException, KeyStoreException {\n+        TrustManagerFactory factory = null;\n+        if (!Strings.isNullOrEmpty(trustStoreFilePath)) {\n+            KeyStore trustStore = CertificateUtils.createTrustStore(trustStoreFilePath);\n+\n+            factory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n+            factory.init(trustStore);\n+        }\n+        return factory;\n+    }\n+\n+    /**\n+     * Creates a socket connected to the provided endpoint. \n+     * Note that this is a sync call even though it is called in an async context. \n+     * While this is normally frowned upon, it is simply not possible to construct an SSL socket asynchronously in Java.\n+     */\n+    @SneakyThrows //Is called inside a completable future.\n+    private static Socket createClientSocket(PravegaNodeUri location, ClientConfig clientConfig) {        \n+        Socket result;\n+        if (clientConfig.isEnableTlsToSegmentStore()) {\n+            TrustManagerFactory trustMgrFactory = createFromCert(clientConfig.getTrustStore());\n+\n+            // Prepare a TLS context that uses the trust manager\n+            SSLContext tlsContext = SSLContext.getInstance(\"TLS\");\n+            tlsContext.init(null,\n+                    trustMgrFactory != null ? trustMgrFactory.getTrustManagers() : null,\n+                    null);\n+\n+            SSLSocket s = (SSLSocket) tlsContext.getSocketFactory().createSocket();\n+            // SSLSocket does not perform hostname verification by default. So, we must explicitly enable it.\n+            if (clientConfig.isValidateHostName()) {\n+                SSLParameters tlsParams = new SSLParameters();\n+                tlsParams.setEndpointIdentificationAlgorithm(\"HTTPS\");\n+                s.setSSLParameters(tlsParams);\n+            }\n+            result = s;\n+\n+        } else {\n+            result = new Socket();\n+        }\n+        result.setSendBufferSize(TCP_BUFFER_SIZE);\n+        result.setReceiveBufferSize(TCP_BUFFER_SIZE);\n+        result.setTcpNoDelay(true);\n+        result.connect(new InetSocketAddress(location.getEndpoint(), location.getPort()));\n+        return result;\n+    }\n+\n+    @Override\n+    public void send(WireCommand cmd) throws ConnectionFailedException {\n+        if (closed.get()) {\n+            throw new ConnectionFailedException(\"Connection is closed\");\n+        }\n+        try {\n+            encoder.write(cmd);\n+        } catch (IOException e) {\n+            log.warn(\"Error writing to connection\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk4MDg5OA=="}, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 251}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MjEyNzk3OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/connection/impl/TcpClientConnection.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMToxMDoyN1rOGrOl-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwMDozNjoyNFrOGuUJng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk4MTA0OA==", "bodyText": "Close before invoking onClose?", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r447981048", "createdAt": "2020-06-30T21:10:27Z", "author": {"login": "andreipaduroiu"}, "path": "client/src/main/java/io/pravega/client/connection/impl/TcpClientConnection.java", "diffHunk": "@@ -0,0 +1,306 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.connection.impl;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import io.netty.buffer.ByteBuf;\n+import io.pravega.client.ClientConfig;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import io.pravega.common.util.CertificateUtils;\n+import io.pravega.shared.protocol.netty.Append;\n+import io.pravega.shared.protocol.netty.AppendBatchSizeTracker;\n+import io.pravega.shared.protocol.netty.ConnectionFailedException;\n+import io.pravega.shared.protocol.netty.EnhancedByteBufInputStream;\n+import io.pravega.shared.protocol.netty.InvalidMessageException;\n+import io.pravega.shared.protocol.netty.PravegaNodeUri;\n+import io.pravega.shared.protocol.netty.Reply;\n+import io.pravega.shared.protocol.netty.ReplyProcessor;\n+import io.pravega.shared.protocol.netty.WireCommand;\n+import io.pravega.shared.protocol.netty.WireCommandType;\n+import io.pravega.shared.protocol.netty.WireCommands;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.SocketException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.CertificateException;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLParameters;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.TrustManagerFactory;\n+import lombok.RequiredArgsConstructor;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.pravega.shared.protocol.netty.AppendBatchSizeTracker.MAX_BATCH_TIME_MILLIS;\n+\n+@Slf4j\n+public class TcpClientConnection implements ClientConnection {\n+\n+    static final int TCP_BUFFER_SIZE = 256 * 1024;\n+    \n+    private final Socket socket;\n+    private final CommandEncoder encoder;\n+    private final ConnectionReader reader;\n+    private final AtomicBoolean closed = new AtomicBoolean(false);\n+    private final PravegaNodeUri location;\n+    private final Runnable onClose;\n+    private final ScheduledFuture<?> timeoutFuture;\n+   \n+    private TcpClientConnection(Socket socket, CommandEncoder encoder, ConnectionReader reader, PravegaNodeUri location,\n+                                Runnable onClose, ScheduledExecutorService executor) {\n+        this.socket = checkNotNull(socket);\n+        this.encoder = checkNotNull(encoder);\n+        this.reader = checkNotNull(reader);\n+        this.location = checkNotNull(location);\n+        this.onClose = onClose;\n+        this.timeoutFuture = executor.scheduleWithFixedDelay(new TimeoutBatch(encoder),\n+                                                             MAX_BATCH_TIME_MILLIS,\n+                                                             MAX_BATCH_TIME_MILLIS,\n+                                                             TimeUnit.MILLISECONDS);\n+    }\n+\n+    @VisibleForTesting\n+    static class ConnectionReader {\n+        \n+        private final String name;\n+        private final InputStream in;\n+        private final ReplyProcessor callback;\n+        private final ScheduledExecutorService thread;\n+        private final AppendBatchSizeTracker batchSizeTracker;\n+        private final AtomicBoolean stop = new AtomicBoolean(false);\n+\n+        public ConnectionReader(String name, InputStream in, ReplyProcessor callback,\n+                                AppendBatchSizeTracker batchSizeTracker) {\n+            this.name = name;\n+            this.in = in;\n+            this.callback = callback;\n+            this.thread = ExecutorServiceHelpers.newScheduledThreadPool(1, \"Reading from \" + name);\n+            this.batchSizeTracker = batchSizeTracker;\n+        }\n+        \n+        public void start() {\n+            thread.submit(() -> {\n+                IoBuffer buffer = new IoBuffer();\n+                while (!stop.get()) {\n+                    try {\n+                        WireCommand command = readCommand(in, buffer);\n+                        if (command instanceof WireCommands.DataAppended) {\n+                            WireCommands.DataAppended dataAppended = (WireCommands.DataAppended) command;\n+                            batchSizeTracker.recordAck(dataAppended.getEventNumber());\n+                        }\n+                        try {\n+                            callback.process((Reply) command);\n+                        } catch (Exception e) {\n+                            callback.processingFailure(e);\n+                        }\n+                    } catch (SocketException e) {\n+                        if (e.getMessage().equals(\"Socket closed\")) {\n+                            log.info(\"Closing TcpConnection.Reader because socket is closed.\");\n+                        } else {\n+                            log.warn(\"Error in reading from socket.\", e);\n+                        }\n+                        stop();\n+                    } catch (EOFException e) {\n+                        log.info(\"Closing TcpConnection.Reader because end of input readched.\");\n+                        stop();\n+                    } catch (Exception e) {\n+                        log.warn(\"Error processing data from from server \" + name, e);\n+                        stop();\n+                    }\n+                }\n+            });\n+        }\n+\n+        @VisibleForTesting\n+        static WireCommand readCommand(InputStream in, IoBuffer buffer) throws IOException {\n+            ByteBuf header = buffer.getBuffOfSize(in, 8);\n+\n+            int t = header.getInt(0);\n+            WireCommandType type = WireCommands.getType(t);\n+            if (type == null) {\n+                throw new InvalidMessageException(\"Unknown wire command: \" + t);\n+            }\n+\n+            int length = header.getInt(4);\n+            if (length < 0 || length > WireCommands.MAX_WIRECOMMAND_SIZE) {\n+                throw new InvalidMessageException(\"Event of invalid length: \" + length);\n+            }\n+\n+            ByteBuf payload = buffer.getBuffOfSize(in, length);\n+            \n+            return type.readFrom(new EnhancedByteBufInputStream(payload), length);\n+        }\n+        \n+        public void stop() {\n+            stop.set(true);\n+            thread.shutdown();\n+            callback.connectionDropped();\n+        }\n+    }\n+    \n+    @RequiredArgsConstructor\n+    private static final class TimeoutBatch implements Runnable {\n+        private final AtomicLong token = new AtomicLong(-1);\n+        private final CommandEncoder encoder;\n+        @Override\n+        public void run() {\n+            token.set(encoder.batchTimeout(token.get()));\n+        }    \n+    }\n+\n+    public static CompletableFuture<TcpClientConnection> connect(PravegaNodeUri location, ClientConfig clientConfig, ReplyProcessor callback,\n+                                              ScheduledExecutorService executor, Runnable onClose) {\n+        return CompletableFuture.supplyAsync(() -> {\n+            Socket socket = createClientSocket(location, clientConfig); \n+            try {\n+                InputStream inputStream = socket.getInputStream();\n+                AppendBatchSizeTrackerImpl batchSizeTracker = new AppendBatchSizeTrackerImpl();\n+                ConnectionReader reader = new ConnectionReader(location.toString(), inputStream, callback, batchSizeTracker);\n+                reader.start();\n+                CommandEncoder encoder = new CommandEncoder(l -> batchSizeTracker, null, socket.getOutputStream());\n+                return new TcpClientConnection(socket, encoder, reader, location, onClose, executor);\n+            } catch (IOException e) {\n+                try {\n+                    onClose.run();\n+                    socket.close();\n+                } catch (IOException e1) {\n+                    log.warn(\"Failed to close socket while failing.\", e1);\n+                }\n+                throw Exceptions.sneakyThrow(e);\n+            }\n+        }, executor);\n+    }\n+\n+    private static TrustManagerFactory createFromCert(String trustStoreFilePath)\n+            throws CertificateException, IOException, NoSuchAlgorithmException, KeyStoreException {\n+        TrustManagerFactory factory = null;\n+        if (!Strings.isNullOrEmpty(trustStoreFilePath)) {\n+            KeyStore trustStore = CertificateUtils.createTrustStore(trustStoreFilePath);\n+\n+            factory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n+            factory.init(trustStore);\n+        }\n+        return factory;\n+    }\n+\n+    /**\n+     * Creates a socket connected to the provided endpoint. \n+     * Note that this is a sync call even though it is called in an async context. \n+     * While this is normally frowned upon, it is simply not possible to construct an SSL socket asynchronously in Java.\n+     */\n+    @SneakyThrows //Is called inside a completable future.\n+    private static Socket createClientSocket(PravegaNodeUri location, ClientConfig clientConfig) {        \n+        Socket result;\n+        if (clientConfig.isEnableTlsToSegmentStore()) {\n+            TrustManagerFactory trustMgrFactory = createFromCert(clientConfig.getTrustStore());\n+\n+            // Prepare a TLS context that uses the trust manager\n+            SSLContext tlsContext = SSLContext.getInstance(\"TLS\");\n+            tlsContext.init(null,\n+                    trustMgrFactory != null ? trustMgrFactory.getTrustManagers() : null,\n+                    null);\n+\n+            SSLSocket s = (SSLSocket) tlsContext.getSocketFactory().createSocket();\n+            // SSLSocket does not perform hostname verification by default. So, we must explicitly enable it.\n+            if (clientConfig.isValidateHostName()) {\n+                SSLParameters tlsParams = new SSLParameters();\n+                tlsParams.setEndpointIdentificationAlgorithm(\"HTTPS\");\n+                s.setSSLParameters(tlsParams);\n+            }\n+            result = s;\n+\n+        } else {\n+            result = new Socket();\n+        }\n+        result.setSendBufferSize(TCP_BUFFER_SIZE);\n+        result.setReceiveBufferSize(TCP_BUFFER_SIZE);\n+        result.setTcpNoDelay(true);\n+        result.connect(new InetSocketAddress(location.getEndpoint(), location.getPort()));\n+        return result;\n+    }\n+\n+    @Override\n+    public void send(WireCommand cmd) throws ConnectionFailedException {\n+        if (closed.get()) {\n+            throw new ConnectionFailedException(\"Connection is closed\");\n+        }\n+        try {\n+            encoder.write(cmd);\n+        } catch (IOException e) {\n+            log.warn(\"Error writing to connection\");\n+            close();\n+            throw new ConnectionFailedException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void send(Append append) throws ConnectionFailedException {\n+        if (closed.get()) {\n+            throw new ConnectionFailedException(\"Connection is closed\");\n+        }\n+        try {\n+            encoder.write(append);\n+        } catch (IOException e) {\n+            log.warn(\"Error writing to connection\");\n+            close();\n+            throw new ConnectionFailedException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void close() {\n+        if (closed.compareAndSet(false, true)) {\n+            reader.stop();\n+            timeoutFuture.cancel(false);\n+            try {\n+                if (onClose != null) {\n+                    onClose.run();\n+                }\n+                socket.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 280}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIxNzgyMg==", "bodyText": "Changed", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r451217822", "createdAt": "2020-07-08T00:36:24Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/connection/impl/TcpClientConnection.java", "diffHunk": "@@ -0,0 +1,306 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.connection.impl;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import io.netty.buffer.ByteBuf;\n+import io.pravega.client.ClientConfig;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import io.pravega.common.util.CertificateUtils;\n+import io.pravega.shared.protocol.netty.Append;\n+import io.pravega.shared.protocol.netty.AppendBatchSizeTracker;\n+import io.pravega.shared.protocol.netty.ConnectionFailedException;\n+import io.pravega.shared.protocol.netty.EnhancedByteBufInputStream;\n+import io.pravega.shared.protocol.netty.InvalidMessageException;\n+import io.pravega.shared.protocol.netty.PravegaNodeUri;\n+import io.pravega.shared.protocol.netty.Reply;\n+import io.pravega.shared.protocol.netty.ReplyProcessor;\n+import io.pravega.shared.protocol.netty.WireCommand;\n+import io.pravega.shared.protocol.netty.WireCommandType;\n+import io.pravega.shared.protocol.netty.WireCommands;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.SocketException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.CertificateException;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLParameters;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.TrustManagerFactory;\n+import lombok.RequiredArgsConstructor;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.pravega.shared.protocol.netty.AppendBatchSizeTracker.MAX_BATCH_TIME_MILLIS;\n+\n+@Slf4j\n+public class TcpClientConnection implements ClientConnection {\n+\n+    static final int TCP_BUFFER_SIZE = 256 * 1024;\n+    \n+    private final Socket socket;\n+    private final CommandEncoder encoder;\n+    private final ConnectionReader reader;\n+    private final AtomicBoolean closed = new AtomicBoolean(false);\n+    private final PravegaNodeUri location;\n+    private final Runnable onClose;\n+    private final ScheduledFuture<?> timeoutFuture;\n+   \n+    private TcpClientConnection(Socket socket, CommandEncoder encoder, ConnectionReader reader, PravegaNodeUri location,\n+                                Runnable onClose, ScheduledExecutorService executor) {\n+        this.socket = checkNotNull(socket);\n+        this.encoder = checkNotNull(encoder);\n+        this.reader = checkNotNull(reader);\n+        this.location = checkNotNull(location);\n+        this.onClose = onClose;\n+        this.timeoutFuture = executor.scheduleWithFixedDelay(new TimeoutBatch(encoder),\n+                                                             MAX_BATCH_TIME_MILLIS,\n+                                                             MAX_BATCH_TIME_MILLIS,\n+                                                             TimeUnit.MILLISECONDS);\n+    }\n+\n+    @VisibleForTesting\n+    static class ConnectionReader {\n+        \n+        private final String name;\n+        private final InputStream in;\n+        private final ReplyProcessor callback;\n+        private final ScheduledExecutorService thread;\n+        private final AppendBatchSizeTracker batchSizeTracker;\n+        private final AtomicBoolean stop = new AtomicBoolean(false);\n+\n+        public ConnectionReader(String name, InputStream in, ReplyProcessor callback,\n+                                AppendBatchSizeTracker batchSizeTracker) {\n+            this.name = name;\n+            this.in = in;\n+            this.callback = callback;\n+            this.thread = ExecutorServiceHelpers.newScheduledThreadPool(1, \"Reading from \" + name);\n+            this.batchSizeTracker = batchSizeTracker;\n+        }\n+        \n+        public void start() {\n+            thread.submit(() -> {\n+                IoBuffer buffer = new IoBuffer();\n+                while (!stop.get()) {\n+                    try {\n+                        WireCommand command = readCommand(in, buffer);\n+                        if (command instanceof WireCommands.DataAppended) {\n+                            WireCommands.DataAppended dataAppended = (WireCommands.DataAppended) command;\n+                            batchSizeTracker.recordAck(dataAppended.getEventNumber());\n+                        }\n+                        try {\n+                            callback.process((Reply) command);\n+                        } catch (Exception e) {\n+                            callback.processingFailure(e);\n+                        }\n+                    } catch (SocketException e) {\n+                        if (e.getMessage().equals(\"Socket closed\")) {\n+                            log.info(\"Closing TcpConnection.Reader because socket is closed.\");\n+                        } else {\n+                            log.warn(\"Error in reading from socket.\", e);\n+                        }\n+                        stop();\n+                    } catch (EOFException e) {\n+                        log.info(\"Closing TcpConnection.Reader because end of input readched.\");\n+                        stop();\n+                    } catch (Exception e) {\n+                        log.warn(\"Error processing data from from server \" + name, e);\n+                        stop();\n+                    }\n+                }\n+            });\n+        }\n+\n+        @VisibleForTesting\n+        static WireCommand readCommand(InputStream in, IoBuffer buffer) throws IOException {\n+            ByteBuf header = buffer.getBuffOfSize(in, 8);\n+\n+            int t = header.getInt(0);\n+            WireCommandType type = WireCommands.getType(t);\n+            if (type == null) {\n+                throw new InvalidMessageException(\"Unknown wire command: \" + t);\n+            }\n+\n+            int length = header.getInt(4);\n+            if (length < 0 || length > WireCommands.MAX_WIRECOMMAND_SIZE) {\n+                throw new InvalidMessageException(\"Event of invalid length: \" + length);\n+            }\n+\n+            ByteBuf payload = buffer.getBuffOfSize(in, length);\n+            \n+            return type.readFrom(new EnhancedByteBufInputStream(payload), length);\n+        }\n+        \n+        public void stop() {\n+            stop.set(true);\n+            thread.shutdown();\n+            callback.connectionDropped();\n+        }\n+    }\n+    \n+    @RequiredArgsConstructor\n+    private static final class TimeoutBatch implements Runnable {\n+        private final AtomicLong token = new AtomicLong(-1);\n+        private final CommandEncoder encoder;\n+        @Override\n+        public void run() {\n+            token.set(encoder.batchTimeout(token.get()));\n+        }    \n+    }\n+\n+    public static CompletableFuture<TcpClientConnection> connect(PravegaNodeUri location, ClientConfig clientConfig, ReplyProcessor callback,\n+                                              ScheduledExecutorService executor, Runnable onClose) {\n+        return CompletableFuture.supplyAsync(() -> {\n+            Socket socket = createClientSocket(location, clientConfig); \n+            try {\n+                InputStream inputStream = socket.getInputStream();\n+                AppendBatchSizeTrackerImpl batchSizeTracker = new AppendBatchSizeTrackerImpl();\n+                ConnectionReader reader = new ConnectionReader(location.toString(), inputStream, callback, batchSizeTracker);\n+                reader.start();\n+                CommandEncoder encoder = new CommandEncoder(l -> batchSizeTracker, null, socket.getOutputStream());\n+                return new TcpClientConnection(socket, encoder, reader, location, onClose, executor);\n+            } catch (IOException e) {\n+                try {\n+                    onClose.run();\n+                    socket.close();\n+                } catch (IOException e1) {\n+                    log.warn(\"Failed to close socket while failing.\", e1);\n+                }\n+                throw Exceptions.sneakyThrow(e);\n+            }\n+        }, executor);\n+    }\n+\n+    private static TrustManagerFactory createFromCert(String trustStoreFilePath)\n+            throws CertificateException, IOException, NoSuchAlgorithmException, KeyStoreException {\n+        TrustManagerFactory factory = null;\n+        if (!Strings.isNullOrEmpty(trustStoreFilePath)) {\n+            KeyStore trustStore = CertificateUtils.createTrustStore(trustStoreFilePath);\n+\n+            factory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n+            factory.init(trustStore);\n+        }\n+        return factory;\n+    }\n+\n+    /**\n+     * Creates a socket connected to the provided endpoint. \n+     * Note that this is a sync call even though it is called in an async context. \n+     * While this is normally frowned upon, it is simply not possible to construct an SSL socket asynchronously in Java.\n+     */\n+    @SneakyThrows //Is called inside a completable future.\n+    private static Socket createClientSocket(PravegaNodeUri location, ClientConfig clientConfig) {        \n+        Socket result;\n+        if (clientConfig.isEnableTlsToSegmentStore()) {\n+            TrustManagerFactory trustMgrFactory = createFromCert(clientConfig.getTrustStore());\n+\n+            // Prepare a TLS context that uses the trust manager\n+            SSLContext tlsContext = SSLContext.getInstance(\"TLS\");\n+            tlsContext.init(null,\n+                    trustMgrFactory != null ? trustMgrFactory.getTrustManagers() : null,\n+                    null);\n+\n+            SSLSocket s = (SSLSocket) tlsContext.getSocketFactory().createSocket();\n+            // SSLSocket does not perform hostname verification by default. So, we must explicitly enable it.\n+            if (clientConfig.isValidateHostName()) {\n+                SSLParameters tlsParams = new SSLParameters();\n+                tlsParams.setEndpointIdentificationAlgorithm(\"HTTPS\");\n+                s.setSSLParameters(tlsParams);\n+            }\n+            result = s;\n+\n+        } else {\n+            result = new Socket();\n+        }\n+        result.setSendBufferSize(TCP_BUFFER_SIZE);\n+        result.setReceiveBufferSize(TCP_BUFFER_SIZE);\n+        result.setTcpNoDelay(true);\n+        result.connect(new InetSocketAddress(location.getEndpoint(), location.getPort()));\n+        return result;\n+    }\n+\n+    @Override\n+    public void send(WireCommand cmd) throws ConnectionFailedException {\n+        if (closed.get()) {\n+            throw new ConnectionFailedException(\"Connection is closed\");\n+        }\n+        try {\n+            encoder.write(cmd);\n+        } catch (IOException e) {\n+            log.warn(\"Error writing to connection\");\n+            close();\n+            throw new ConnectionFailedException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void send(Append append) throws ConnectionFailedException {\n+        if (closed.get()) {\n+            throw new ConnectionFailedException(\"Connection is closed\");\n+        }\n+        try {\n+            encoder.write(append);\n+        } catch (IOException e) {\n+            log.warn(\"Error writing to connection\");\n+            close();\n+            throw new ConnectionFailedException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void close() {\n+        if (closed.compareAndSet(false, true)) {\n+            reader.stop();\n+            timeoutFuture.cancel(false);\n+            try {\n+                if (onClose != null) {\n+                    onClose.run();\n+                }\n+                socket.close();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk4MTA0OA=="}, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 280}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MjE0MDQ1OnYy", "diffSide": "RIGHT", "path": "shared/protocol/src/main/java/io/pravega/shared/protocol/netty/Append.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMToxNDoyOFrOGrOt6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMzoxNzowNlrOGuSyrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk4MzA4MA==", "bodyText": "Why did you make these public when there are getters for them?", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r447983080", "createdAt": "2020-06-30T21:14:28Z", "author": {"login": "andreipaduroiu"}, "path": "shared/protocol/src/main/java/io/pravega/shared/protocol/netty/Append.java", "diffHunk": "@@ -18,8 +18,8 @@\n @Data\n @RequiredArgsConstructor\n public class Append implements Request, Comparable<Append> {\n-    final String segment;\n-    final UUID writerId;\n+    public final String segment;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE5NTU2Nw==", "bodyText": "Fixed. (Automated tool did this)", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r451195567", "createdAt": "2020-07-07T23:17:06Z", "author": {"login": "tkaitchuck"}, "path": "shared/protocol/src/main/java/io/pravega/shared/protocol/netty/Append.java", "diffHunk": "@@ -18,8 +18,8 @@\n @Data\n @RequiredArgsConstructor\n public class Append implements Request, Comparable<Append> {\n-    final String segment;\n-    final UUID writerId;\n+    public final String segment;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk4MzA4MA=="}, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MjE3NjI5OnYy", "diffSide": "RIGHT", "path": "client/src/test/java/io/pravega/client/connection/impl/ClientConnectionTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMToyNjowMlrOGrPEFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMzoxNzoxNFrOGuSy3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk4ODc1OA==", "bodyText": "Why is this commented out?", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r447988758", "createdAt": "2020-06-30T21:26:02Z", "author": {"login": "andreipaduroiu"}, "path": "client/src/test/java/io/pravega/client/connection/impl/ClientConnectionTest.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.connection.impl;\n+\n+import io.netty.buffer.Unpooled;\n+import io.pravega.client.ClientConfig;\n+import io.pravega.shared.protocol.netty.Append;\n+import io.pravega.shared.protocol.netty.FailingReplyProcessor;\n+import io.pravega.shared.protocol.netty.WireCommand;\n+import io.pravega.shared.protocol.netty.WireCommandType;\n+import io.pravega.shared.protocol.netty.WireCommands;\n+import io.pravega.shared.protocol.netty.WireCommands.AuthTokenCheckFailed;\n+import io.pravega.shared.protocol.netty.WireCommands.Event;\n+import io.pravega.test.common.InlineExecutor;\n+import java.util.UUID;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import lombok.Cleanup;\n+import org.junit.Test;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNull;\n+\n+public class ClientConnectionTest {\n+\n+    private static class ReplyProcessor extends FailingReplyProcessor {\n+        AtomicBoolean falure = new AtomicBoolean(false);\n+\n+        @Override\n+        public void processingFailure(Exception error) {\n+            falure.set(true);\n+        }\n+\n+        @Override\n+        public void connectionDropped() {\n+            falure.set(true);\n+        }\n+\n+        @Override\n+        public void authTokenCheckFailed(AuthTokenCheckFailed authTokenCheckFailed) {\n+            falure.set(true);\n+        }\n+    }\n+\n+    @Test(timeout = 10000)\n+    public void testConnectionSetup() throws Exception {\n+        ReplyProcessor processor = new ReplyProcessor();\n+        @Cleanup\n+        MockServer server = new MockServer();\n+        server.start();\n+        @Cleanup\n+        InlineExecutor executor = new InlineExecutor();\n+        @Cleanup\n+        ClientConnection clientConnection = TcpClientConnection\n+            .connect(server.getUri(), ClientConfig.builder().build(), processor, executor, null)\n+            .join();\n+        clientConnection.send(new WireCommands.Hello(0, 1));\n+        LinkedBlockingQueue<WireCommand> messages = server.getReadCommands();\n+        WireCommand wireCommand = messages.take();\n+        assertEquals(WireCommandType.HELLO, wireCommand.getType());\n+        assertNull(messages.poll());\n+        clientConnection.send(new WireCommands.SetupAppend(1, new UUID(1, 2), \"segment\", \"\"));\n+        wireCommand = messages.take();\n+        assertEquals(WireCommandType.SETUP_APPEND, wireCommand.getType());\n+        assertNull(messages.poll());\n+        clientConnection.send(new Append(\"segment\", new UUID(1, 2), 1, new Event(Unpooled.EMPTY_BUFFER), 2));\n+        wireCommand = messages.take();\n+        assertEquals(WireCommandType.APPEND_BLOCK, wireCommand.getType());\n+        assertFalse(processor.falure.get());\n+    }\n+\n+    //    @Test", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE5NTYxNA==", "bodyText": "Fixed", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r451195614", "createdAt": "2020-07-07T23:17:14Z", "author": {"login": "tkaitchuck"}, "path": "client/src/test/java/io/pravega/client/connection/impl/ClientConnectionTest.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.connection.impl;\n+\n+import io.netty.buffer.Unpooled;\n+import io.pravega.client.ClientConfig;\n+import io.pravega.shared.protocol.netty.Append;\n+import io.pravega.shared.protocol.netty.FailingReplyProcessor;\n+import io.pravega.shared.protocol.netty.WireCommand;\n+import io.pravega.shared.protocol.netty.WireCommandType;\n+import io.pravega.shared.protocol.netty.WireCommands;\n+import io.pravega.shared.protocol.netty.WireCommands.AuthTokenCheckFailed;\n+import io.pravega.shared.protocol.netty.WireCommands.Event;\n+import io.pravega.test.common.InlineExecutor;\n+import java.util.UUID;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import lombok.Cleanup;\n+import org.junit.Test;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNull;\n+\n+public class ClientConnectionTest {\n+\n+    private static class ReplyProcessor extends FailingReplyProcessor {\n+        AtomicBoolean falure = new AtomicBoolean(false);\n+\n+        @Override\n+        public void processingFailure(Exception error) {\n+            falure.set(true);\n+        }\n+\n+        @Override\n+        public void connectionDropped() {\n+            falure.set(true);\n+        }\n+\n+        @Override\n+        public void authTokenCheckFailed(AuthTokenCheckFailed authTokenCheckFailed) {\n+            falure.set(true);\n+        }\n+    }\n+\n+    @Test(timeout = 10000)\n+    public void testConnectionSetup() throws Exception {\n+        ReplyProcessor processor = new ReplyProcessor();\n+        @Cleanup\n+        MockServer server = new MockServer();\n+        server.start();\n+        @Cleanup\n+        InlineExecutor executor = new InlineExecutor();\n+        @Cleanup\n+        ClientConnection clientConnection = TcpClientConnection\n+            .connect(server.getUri(), ClientConfig.builder().build(), processor, executor, null)\n+            .join();\n+        clientConnection.send(new WireCommands.Hello(0, 1));\n+        LinkedBlockingQueue<WireCommand> messages = server.getReadCommands();\n+        WireCommand wireCommand = messages.take();\n+        assertEquals(WireCommandType.HELLO, wireCommand.getType());\n+        assertNull(messages.poll());\n+        clientConnection.send(new WireCommands.SetupAppend(1, new UUID(1, 2), \"segment\", \"\"));\n+        wireCommand = messages.take();\n+        assertEquals(WireCommandType.SETUP_APPEND, wireCommand.getType());\n+        assertNull(messages.poll());\n+        clientConnection.send(new Append(\"segment\", new UUID(1, 2), 1, new Event(Unpooled.EMPTY_BUFFER), 2));\n+        wireCommand = messages.take();\n+        assertEquals(WireCommandType.APPEND_BLOCK, wireCommand.getType());\n+        assertFalse(processor.falure.get());\n+    }\n+\n+    //    @Test", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk4ODc1OA=="}, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MjE3NjkzOnYy", "diffSide": "RIGHT", "path": "client/src/test/java/io/pravega/client/connection/impl/ConnectionFactoryImplTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMToyNjoxOVrOGrPEjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMzoxNzoyNFrOGuSzFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk4ODg3OA==", "bodyText": "Should we delete this file?", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r447988878", "createdAt": "2020-06-30T21:26:19Z", "author": {"login": "andreipaduroiu"}, "path": "client/src/test/java/io/pravega/client/connection/impl/ConnectionFactoryImplTest.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.connection.impl;\n+//", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE5NTY3MA==", "bodyText": "Fixed", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r451195670", "createdAt": "2020-07-07T23:17:24Z", "author": {"login": "tkaitchuck"}, "path": "client/src/test/java/io/pravega/client/connection/impl/ConnectionFactoryImplTest.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.connection.impl;\n+//", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk4ODg3OA=="}, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MjE3ODIxOnYy", "diffSide": "RIGHT", "path": "client/src/test/java/io/pravega/client/connection/impl/ConnectionPoolImplTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMToyNjo0N1rOGrPFcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMzoxNzozNVrOGuSzWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk4OTEwNQ==", "bodyText": "Should we uncomment this?", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r447989105", "createdAt": "2020-06-30T21:26:47Z", "author": {"login": "andreipaduroiu"}, "path": "client/src/test/java/io/pravega/client/connection/impl/ConnectionPoolImplTest.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.connection.impl;\n+//\n+//import io.netty.handler.ssl.SslContext;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE5NTczOA==", "bodyText": "DOne", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r451195738", "createdAt": "2020-07-07T23:17:35Z", "author": {"login": "tkaitchuck"}, "path": "client/src/test/java/io/pravega/client/connection/impl/ConnectionPoolImplTest.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.connection.impl;\n+//\n+//import io.netty.handler.ssl.SslContext;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk4OTEwNQ=="}, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MjE3OTA1OnYy", "diffSide": "RIGHT", "path": "client/src/test/java/io/pravega/client/connection/impl/ConnectionPoolingTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMToyNjo1OVrOGrPF5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMzoxNzozMVrOGuSzRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk4OTIyMw==", "bodyText": "Uncomment", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r447989223", "createdAt": "2020-06-30T21:26:59Z", "author": {"login": "andreipaduroiu"}, "path": "client/src/test/java/io/pravega/client/connection/impl/ConnectionPoolingTest.java", "diffHunk": "@@ -0,0 +1,306 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.connection.impl;\n+//\n+//import io.netty.bootstrap.ServerBootstrap;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE5NTcxOA==", "bodyText": "Done", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r451195718", "createdAt": "2020-07-07T23:17:31Z", "author": {"login": "tkaitchuck"}, "path": "client/src/test/java/io/pravega/client/connection/impl/ConnectionPoolingTest.java", "diffHunk": "@@ -0,0 +1,306 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.connection.impl;\n+//\n+//import io.netty.bootstrap.ServerBootstrap;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk4OTIyMw=="}, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MjE3OTQ0OnYy", "diffSide": "RIGHT", "path": "client/src/test/java/io/pravega/client/connection/impl/FlowHandlerTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMToyNzoxMFrOGrPGKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMToyNzoxMFrOGrPGKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk4OTI4OQ==", "bodyText": "Uncomment", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r447989289", "createdAt": "2020-06-30T21:27:10Z", "author": {"login": "andreipaduroiu"}, "path": "client/src/test/java/io/pravega/client/connection/impl/FlowHandlerTest.java", "diffHunk": "@@ -0,0 +1,436 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.connection.impl;\n+\n+//", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MjE4MDczOnYy", "diffSide": "RIGHT", "path": "client/src/test/java/io/pravega/client/connection/impl/RawClientTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMToyNzozNlrOGrPG8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMzoxNzo0NVrOGuSzhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk4OTQ4OQ==", "bodyText": "uncomment", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r447989489", "createdAt": "2020-06-30T21:27:36Z", "author": {"login": "andreipaduroiu"}, "path": "client/src/test/java/io/pravega/client/connection/impl/RawClientTest.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.connection.impl;\n+\n+//import io.netty.buffer.Unpooled;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE5NTc4MQ==", "bodyText": "Done", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r451195781", "createdAt": "2020-07-07T23:17:45Z", "author": {"login": "tkaitchuck"}, "path": "client/src/test/java/io/pravega/client/connection/impl/RawClientTest.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.connection.impl;\n+\n+//import io.netty.buffer.Unpooled;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk4OTQ4OQ=="}, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MjE4MTQxOnYy", "diffSide": "RIGHT", "path": "client/src/test/java/io/pravega/client/connection/impl/SecureConnectionFactoryImplTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMToyNzo1MFrOGrPHXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMzoxNzo1MlrOGuSzrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk4OTU5OQ==", "bodyText": "Uncomment", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r447989599", "createdAt": "2020-06-30T21:27:50Z", "author": {"login": "andreipaduroiu"}, "path": "client/src/test/java/io/pravega/client/connection/impl/SecureConnectionFactoryImplTest.java", "diffHunk": "@@ -7,16 +7,16 @@\n  *\n  *     http://www.apache.org/licenses/LICENSE-2.0\n  */\n-package io.pravega.client.netty.impl;\n+package io.pravega.client.connection.impl;\n \n-import org.junit.Before;\n-\n-public class SecureConnectionFactoryImplTest extends ConnectionFactoryImplTest {\n-\n-    @Override\n-    @Before\n-    public void setUp() throws Exception {\n-        this.ssl = true;\n-        super.setUp();\n-    }\n-}\n+//import org.junit.Before;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE5NTgyMg==", "bodyText": "Done", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r451195822", "createdAt": "2020-07-07T23:17:52Z", "author": {"login": "tkaitchuck"}, "path": "client/src/test/java/io/pravega/client/connection/impl/SecureConnectionFactoryImplTest.java", "diffHunk": "@@ -7,16 +7,16 @@\n  *\n  *     http://www.apache.org/licenses/LICENSE-2.0\n  */\n-package io.pravega.client.netty.impl;\n+package io.pravega.client.connection.impl;\n \n-import org.junit.Before;\n-\n-public class SecureConnectionFactoryImplTest extends ConnectionFactoryImplTest {\n-\n-    @Override\n-    @Before\n-    public void setUp() throws Exception {\n-        this.ssl = true;\n-        super.setUp();\n-    }\n-}\n+//import org.junit.Before;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk4OTU5OQ=="}, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MjE4NDE2OnYy", "diffSide": "RIGHT", "path": "client/src/test/java/io/pravega/client/security/auth/JwtTestUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMToyODo1MlrOGrPJOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMzoxODowM1rOGuSz7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk5MDA3Mw==", "bodyText": "There is a class by this name in io.pravega.common. May I suggest merging these methods in that one?", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r447990073", "createdAt": "2020-06-30T21:28:52Z", "author": {"login": "andreipaduroiu"}, "path": "client/src/test/java/io/pravega/client/security/auth/JwtTestUtils.java", "diffHunk": "@@ -0,0 +1,27 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.security.auth;\n+\n+import com.google.gson.Gson;\n+import io.pravega.test.common.JwtBody;\n+import java.util.Base64;\n+\n+public class JwtTestUtils {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE5NTg4Ng==", "bodyText": "Deleted this one. (This copy was a duplicate that came from a bad merge)", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r451195886", "createdAt": "2020-07-07T23:18:03Z", "author": {"login": "tkaitchuck"}, "path": "client/src/test/java/io/pravega/client/security/auth/JwtTestUtils.java", "diffHunk": "@@ -0,0 +1,27 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.security.auth;\n+\n+import com.google.gson.Gson;\n+import io.pravega.test.common.JwtBody;\n+import java.util.Base64;\n+\n+public class JwtTestUtils {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk5MDA3Mw=="}, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MjE5Njc3OnYy", "diffSide": "RIGHT", "path": "common/src/main/java/io/pravega/common/util/TypedProperties.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMTozMzoyMlrOGrPRSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMzoxODozOVrOGuS0mQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk5MjEzNg==", "bodyText": "Need unit tests for this one.", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r447992136", "createdAt": "2020-06-30T21:33:22Z", "author": {"login": "andreipaduroiu"}, "path": "common/src/main/java/io/pravega/common/util/TypedProperties.java", "diffHunk": "@@ -95,6 +95,18 @@ public long getLong(Property<Long> property) throws ConfigurationException {\n         return tryGet(property, Long::parseLong);\n     }\n \n+    /**\n+     * Gets the value of a Double property.\n+     *\n+     * @param property The Property to get.\n+     * @return The property value or default value, if no such is defined in the base Properties.\n+     * @throws ConfigurationException When the given property name does not exist within the current component and the property\n+     *                                does not have a default value set, or when the property cannot be parsed as a Double.\n+     */\n+    public double getDouble(Property<Double> property) throws ConfigurationException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE5NjA1Nw==", "bodyText": "Added", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r451196057", "createdAt": "2020-07-07T23:18:39Z", "author": {"login": "tkaitchuck"}, "path": "common/src/main/java/io/pravega/common/util/TypedProperties.java", "diffHunk": "@@ -95,6 +95,18 @@ public long getLong(Property<Long> property) throws ConfigurationException {\n         return tryGet(property, Long::parseLong);\n     }\n \n+    /**\n+     * Gets the value of a Double property.\n+     *\n+     * @param property The Property to get.\n+     * @return The property value or default value, if no such is defined in the base Properties.\n+     * @throws ConfigurationException When the given property name does not exist within the current component and the property\n+     *                                does not have a default value set, or when the property cannot be parsed as a Double.\n+     */\n+    public double getDouble(Property<Double> property) throws ConfigurationException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk5MjEzNg=="}, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MzU0MDE1OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/connection/impl/AppendBatchSizeTrackerImpl.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwODoyMDo1OFrOGrb15Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxMTo0NjowOVrOGwlEMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODE5ODExNw==", "bodyText": "This switch from millis to nanos seems unrelated to the removal of Netty.\nIt is required for this patch to work ?", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r448198117", "createdAt": "2020-07-01T08:20:58Z", "author": {"login": "eolivelli"}, "path": "client/src/main/java/io/pravega/client/connection/impl/AppendBatchSizeTrackerImpl.java", "diffHunk": "@@ -27,19 +27,26 @@\n  * synchronous writers. Otherwise the batch size is set to the amount of data that will be written in the next\n  * {@link #MAX_BATCH_TIME_MILLIS} or half the server round trip time (whichever is less)\n  */\n-class AppendBatchSizeTrackerImpl implements AppendBatchSizeTracker {\n-    private static final int MAX_BATCH_TIME_MILLIS = 100;\n-\n+public class AppendBatchSizeTrackerImpl implements AppendBatchSizeTracker {\n+    private static final double NANOS_PER_MILLI = 1000000;\n+    \n+    // This must be less than WireCommands.MAX_WIRECOMMAND_SIZE / 2;\n+    private static final int MAX_BATCH_SIZE = initializeConstant(\"PRAVEGA_MAX_BATCH_SIZE\",\n+                                                                 2 * TcpClientConnection.TCP_BUFFER_SIZE - 1024);\n+    private static final int BASE_TIME_NANOS = initializeConstant(\"PRAVEGA_BATCH_BASE_TIME_NANOS\", 500000);\n+    private static final int BASE_SIZE = initializeConstant(\"PRAVEGA_BATCH_BASE_SIZE\", 0);\n+    private static final double OUTSTANDING_FRACTION = 1.0 / initializeConstant(\"PRAVEGA_BATCH_OUTSTANDING_DENOMINATOR\", 2);\n+    \n     private final Supplier<Long> clock;\n     private final AtomicLong lastAppendNumber;\n     private final AtomicLong lastAppendTime;\n     private final AtomicLong lastAckNumber;\n-    private final ExponentialMovingAverage eventSize = new ExponentialMovingAverage(1024, 0.1, true);\n-    private final ExponentialMovingAverage millisBetweenAppends = new ExponentialMovingAverage(10, 0.1, false);\n-    private final ExponentialMovingAverage appendsOutstanding = new ExponentialMovingAverage(2, 0.05, false);\n+    private final ExponentialMovingAverage eventSize = new ExponentialMovingAverage(1024, 0.01, true);\n+    private final ExponentialMovingAverage nanosBetweenAppends = new ExponentialMovingAverage(10 * NANOS_PER_MILLI, 0.001, true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE5NjM2NQ==", "bodyText": "Nanos vs millis is not requred, but it did give bad results which interfered with testing. (It turns out it's fairly common for the difference in time in millis to be \"0\".)", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r451196365", "createdAt": "2020-07-07T23:19:37Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/connection/impl/AppendBatchSizeTrackerImpl.java", "diffHunk": "@@ -27,19 +27,26 @@\n  * synchronous writers. Otherwise the batch size is set to the amount of data that will be written in the next\n  * {@link #MAX_BATCH_TIME_MILLIS} or half the server round trip time (whichever is less)\n  */\n-class AppendBatchSizeTrackerImpl implements AppendBatchSizeTracker {\n-    private static final int MAX_BATCH_TIME_MILLIS = 100;\n-\n+public class AppendBatchSizeTrackerImpl implements AppendBatchSizeTracker {\n+    private static final double NANOS_PER_MILLI = 1000000;\n+    \n+    // This must be less than WireCommands.MAX_WIRECOMMAND_SIZE / 2;\n+    private static final int MAX_BATCH_SIZE = initializeConstant(\"PRAVEGA_MAX_BATCH_SIZE\",\n+                                                                 2 * TcpClientConnection.TCP_BUFFER_SIZE - 1024);\n+    private static final int BASE_TIME_NANOS = initializeConstant(\"PRAVEGA_BATCH_BASE_TIME_NANOS\", 500000);\n+    private static final int BASE_SIZE = initializeConstant(\"PRAVEGA_BATCH_BASE_SIZE\", 0);\n+    private static final double OUTSTANDING_FRACTION = 1.0 / initializeConstant(\"PRAVEGA_BATCH_OUTSTANDING_DENOMINATOR\", 2);\n+    \n     private final Supplier<Long> clock;\n     private final AtomicLong lastAppendNumber;\n     private final AtomicLong lastAppendTime;\n     private final AtomicLong lastAckNumber;\n-    private final ExponentialMovingAverage eventSize = new ExponentialMovingAverage(1024, 0.1, true);\n-    private final ExponentialMovingAverage millisBetweenAppends = new ExponentialMovingAverage(10, 0.1, false);\n-    private final ExponentialMovingAverage appendsOutstanding = new ExponentialMovingAverage(2, 0.05, false);\n+    private final ExponentialMovingAverage eventSize = new ExponentialMovingAverage(1024, 0.01, true);\n+    private final ExponentialMovingAverage nanosBetweenAppends = new ExponentialMovingAverage(10 * NANOS_PER_MILLI, 0.001, true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODE5ODExNw=="}, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU5MjExNA==", "bodyText": "I see. Fine to me", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r453592114", "createdAt": "2020-07-13T11:46:09Z", "author": {"login": "eolivelli"}, "path": "client/src/main/java/io/pravega/client/connection/impl/AppendBatchSizeTrackerImpl.java", "diffHunk": "@@ -27,19 +27,26 @@\n  * synchronous writers. Otherwise the batch size is set to the amount of data that will be written in the next\n  * {@link #MAX_BATCH_TIME_MILLIS} or half the server round trip time (whichever is less)\n  */\n-class AppendBatchSizeTrackerImpl implements AppendBatchSizeTracker {\n-    private static final int MAX_BATCH_TIME_MILLIS = 100;\n-\n+public class AppendBatchSizeTrackerImpl implements AppendBatchSizeTracker {\n+    private static final double NANOS_PER_MILLI = 1000000;\n+    \n+    // This must be less than WireCommands.MAX_WIRECOMMAND_SIZE / 2;\n+    private static final int MAX_BATCH_SIZE = initializeConstant(\"PRAVEGA_MAX_BATCH_SIZE\",\n+                                                                 2 * TcpClientConnection.TCP_BUFFER_SIZE - 1024);\n+    private static final int BASE_TIME_NANOS = initializeConstant(\"PRAVEGA_BATCH_BASE_TIME_NANOS\", 500000);\n+    private static final int BASE_SIZE = initializeConstant(\"PRAVEGA_BATCH_BASE_SIZE\", 0);\n+    private static final double OUTSTANDING_FRACTION = 1.0 / initializeConstant(\"PRAVEGA_BATCH_OUTSTANDING_DENOMINATOR\", 2);\n+    \n     private final Supplier<Long> clock;\n     private final AtomicLong lastAppendNumber;\n     private final AtomicLong lastAppendTime;\n     private final AtomicLong lastAckNumber;\n-    private final ExponentialMovingAverage eventSize = new ExponentialMovingAverage(1024, 0.1, true);\n-    private final ExponentialMovingAverage millisBetweenAppends = new ExponentialMovingAverage(10, 0.1, false);\n-    private final ExponentialMovingAverage appendsOutstanding = new ExponentialMovingAverage(2, 0.05, false);\n+    private final ExponentialMovingAverage eventSize = new ExponentialMovingAverage(1024, 0.01, true);\n+    private final ExponentialMovingAverage nanosBetweenAppends = new ExponentialMovingAverage(10 * NANOS_PER_MILLI, 0.001, true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODE5ODExNw=="}, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MzU0Nzk5OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/connection/impl/AppendBatchSizeTrackerImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwODoyMzowNlrOGrb68A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwMDo0NzowNVrOGuUUGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODE5OTQwOA==", "bodyText": "is it better to move this function to a common utility class ?", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r448199408", "createdAt": "2020-07-01T08:23:06Z", "author": {"login": "eolivelli"}, "path": "client/src/main/java/io/pravega/client/connection/impl/AppendBatchSizeTrackerImpl.java", "diffHunk": "@@ -73,15 +79,28 @@ public int getAppendBlockSize() {\n         if (numInflight <= 1) {\n             return 0;\n         }\n-        double appendsInMaxBatch = Math.max(1.0, MAX_BATCH_TIME_MILLIS / millisBetweenAppends.getCurrentValue());\n-        double targetAppendsOutstanding = MathHelpers.minMax(appendsOutstanding.getCurrentValue() * 0.5, 1.0,\n-                                                             appendsInMaxBatch);\n-        return (int) MathHelpers.minMax((long) (targetAppendsOutstanding * eventSize.getCurrentValue()), 0,\n-                                        MAX_BATCH_SIZE);\n+        double nanosPerAppend = nanosBetweenAppends.getCurrentValue();\n+        double appendsInMaxBatchTime = (MAX_BATCH_TIME_MILLIS * NANOS_PER_MILLI) / nanosPerAppend;\n+        double appendsInTime = Math.max(1.0, BASE_TIME_NANOS / nanosPerAppend);\n+        double appendsInBatch = MathHelpers.minMax(appendsOutstanding.getCurrentValue() * OUTSTANDING_FRACTION, appendsInTime, appendsInMaxBatchTime);\n+        int size = (int) (appendsInBatch * eventSize.getCurrentValue()) + BASE_SIZE;\n+        return MathHelpers.minMax(size, 0, MAX_BATCH_SIZE);\n     }\n \n     @Override\n     public int getBatchTimeout() {\n         return MAX_BATCH_TIME_MILLIS;\n     }\n+    \n+    private static int initializeConstant(String name, int defaultValue) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIyMDUwNg==", "bodyText": "Done", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r451220506", "createdAt": "2020-07-08T00:47:05Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/connection/impl/AppendBatchSizeTrackerImpl.java", "diffHunk": "@@ -73,15 +79,28 @@ public int getAppendBlockSize() {\n         if (numInflight <= 1) {\n             return 0;\n         }\n-        double appendsInMaxBatch = Math.max(1.0, MAX_BATCH_TIME_MILLIS / millisBetweenAppends.getCurrentValue());\n-        double targetAppendsOutstanding = MathHelpers.minMax(appendsOutstanding.getCurrentValue() * 0.5, 1.0,\n-                                                             appendsInMaxBatch);\n-        return (int) MathHelpers.minMax((long) (targetAppendsOutstanding * eventSize.getCurrentValue()), 0,\n-                                        MAX_BATCH_SIZE);\n+        double nanosPerAppend = nanosBetweenAppends.getCurrentValue();\n+        double appendsInMaxBatchTime = (MAX_BATCH_TIME_MILLIS * NANOS_PER_MILLI) / nanosPerAppend;\n+        double appendsInTime = Math.max(1.0, BASE_TIME_NANOS / nanosPerAppend);\n+        double appendsInBatch = MathHelpers.minMax(appendsOutstanding.getCurrentValue() * OUTSTANDING_FRACTION, appendsInTime, appendsInMaxBatchTime);\n+        int size = (int) (appendsInBatch * eventSize.getCurrentValue()) + BASE_SIZE;\n+        return MathHelpers.minMax(size, 0, MAX_BATCH_SIZE);\n     }\n \n     @Override\n     public int getBatchTimeout() {\n         return MAX_BATCH_TIME_MILLIS;\n     }\n+    \n+    private static int initializeConstant(String name, int defaultValue) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODE5OTQwOA=="}, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MzU1OTkxOnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/connection/impl/AppendBatchSizeTrackerImpl.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwODoyNjowM1rOGrcCPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwMDo1MjoyNVrOGuUZlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODIwMTI3OQ==", "bodyText": "is is a common practice in Pravega to use System env for the client ?\nHere we are in the client, we don't know much about the running environment of the client application.\nAdditionally using ENV may be seen as a security issue, as the application is going to use parameters configured outside the configuration files of the application itself, without even noticing it.\nWe should at least log a line telling that we picked up a value from system ENV", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r448201279", "createdAt": "2020-07-01T08:26:03Z", "author": {"login": "eolivelli"}, "path": "client/src/main/java/io/pravega/client/connection/impl/AppendBatchSizeTrackerImpl.java", "diffHunk": "@@ -73,15 +79,28 @@ public int getAppendBlockSize() {\n         if (numInflight <= 1) {\n             return 0;\n         }\n-        double appendsInMaxBatch = Math.max(1.0, MAX_BATCH_TIME_MILLIS / millisBetweenAppends.getCurrentValue());\n-        double targetAppendsOutstanding = MathHelpers.minMax(appendsOutstanding.getCurrentValue() * 0.5, 1.0,\n-                                                             appendsInMaxBatch);\n-        return (int) MathHelpers.minMax((long) (targetAppendsOutstanding * eventSize.getCurrentValue()), 0,\n-                                        MAX_BATCH_SIZE);\n+        double nanosPerAppend = nanosBetweenAppends.getCurrentValue();\n+        double appendsInMaxBatchTime = (MAX_BATCH_TIME_MILLIS * NANOS_PER_MILLI) / nanosPerAppend;\n+        double appendsInTime = Math.max(1.0, BASE_TIME_NANOS / nanosPerAppend);\n+        double appendsInBatch = MathHelpers.minMax(appendsOutstanding.getCurrentValue() * OUTSTANDING_FRACTION, appendsInTime, appendsInMaxBatchTime);\n+        int size = (int) (appendsInBatch * eventSize.getCurrentValue()) + BASE_SIZE;\n+        return MathHelpers.minMax(size, 0, MAX_BATCH_SIZE);\n     }\n \n     @Override\n     public int getBatchTimeout() {\n         return MAX_BATCH_TIME_MILLIS;\n     }\n+    \n+    private static int initializeConstant(String name, int defaultValue) {\n+        String val = System.getenv(name);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQzMTIxNA==", "bodyText": "These are \"hardcoded\" constants which we do not want users to set (we will not document them). The point of making them ENV vars is because we want to try out various combinations in our perf tests without having to do a full rebuild.", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r448431214", "createdAt": "2020-07-01T15:09:34Z", "author": {"login": "andreipaduroiu"}, "path": "client/src/main/java/io/pravega/client/connection/impl/AppendBatchSizeTrackerImpl.java", "diffHunk": "@@ -73,15 +79,28 @@ public int getAppendBlockSize() {\n         if (numInflight <= 1) {\n             return 0;\n         }\n-        double appendsInMaxBatch = Math.max(1.0, MAX_BATCH_TIME_MILLIS / millisBetweenAppends.getCurrentValue());\n-        double targetAppendsOutstanding = MathHelpers.minMax(appendsOutstanding.getCurrentValue() * 0.5, 1.0,\n-                                                             appendsInMaxBatch);\n-        return (int) MathHelpers.minMax((long) (targetAppendsOutstanding * eventSize.getCurrentValue()), 0,\n-                                        MAX_BATCH_SIZE);\n+        double nanosPerAppend = nanosBetweenAppends.getCurrentValue();\n+        double appendsInMaxBatchTime = (MAX_BATCH_TIME_MILLIS * NANOS_PER_MILLI) / nanosPerAppend;\n+        double appendsInTime = Math.max(1.0, BASE_TIME_NANOS / nanosPerAppend);\n+        double appendsInBatch = MathHelpers.minMax(appendsOutstanding.getCurrentValue() * OUTSTANDING_FRACTION, appendsInTime, appendsInMaxBatchTime);\n+        int size = (int) (appendsInBatch * eventSize.getCurrentValue()) + BASE_SIZE;\n+        return MathHelpers.minMax(size, 0, MAX_BATCH_SIZE);\n     }\n \n     @Override\n     public int getBatchTimeout() {\n         return MAX_BATCH_TIME_MILLIS;\n     }\n+    \n+    private static int initializeConstant(String name, int defaultValue) {\n+        String val = System.getenv(name);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODIwMTI3OQ=="}, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQ0OTg2OA==", "bodyText": "@andreipaduroiu\nWhat about adding a system property to enable this behaviour ?\n-Dpravega.allowreadconstantsfromenv=true\nThis way we will protect clients from running into (security) issues.\nSystem properties are not read automatically from the ENV or by the JVM, so you have to explicitly opt-in to this way of configuring these parameters.", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r448449868", "createdAt": "2020-07-01T15:37:44Z", "author": {"login": "eolivelli"}, "path": "client/src/main/java/io/pravega/client/connection/impl/AppendBatchSizeTrackerImpl.java", "diffHunk": "@@ -73,15 +79,28 @@ public int getAppendBlockSize() {\n         if (numInflight <= 1) {\n             return 0;\n         }\n-        double appendsInMaxBatch = Math.max(1.0, MAX_BATCH_TIME_MILLIS / millisBetweenAppends.getCurrentValue());\n-        double targetAppendsOutstanding = MathHelpers.minMax(appendsOutstanding.getCurrentValue() * 0.5, 1.0,\n-                                                             appendsInMaxBatch);\n-        return (int) MathHelpers.minMax((long) (targetAppendsOutstanding * eventSize.getCurrentValue()), 0,\n-                                        MAX_BATCH_SIZE);\n+        double nanosPerAppend = nanosBetweenAppends.getCurrentValue();\n+        double appendsInMaxBatchTime = (MAX_BATCH_TIME_MILLIS * NANOS_PER_MILLI) / nanosPerAppend;\n+        double appendsInTime = Math.max(1.0, BASE_TIME_NANOS / nanosPerAppend);\n+        double appendsInBatch = MathHelpers.minMax(appendsOutstanding.getCurrentValue() * OUTSTANDING_FRACTION, appendsInTime, appendsInMaxBatchTime);\n+        int size = (int) (appendsInBatch * eventSize.getCurrentValue()) + BASE_SIZE;\n+        return MathHelpers.minMax(size, 0, MAX_BATCH_SIZE);\n     }\n \n     @Override\n     public int getBatchTimeout() {\n         return MAX_BATCH_TIME_MILLIS;\n     }\n+    \n+    private static int initializeConstant(String name, int defaultValue) {\n+        String val = System.getenv(name);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODIwMTI3OQ=="}, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTUzNDIzMQ==", "bodyText": "a system property approached is used here. ref: https://github.com/pravega/pravega/pull/4873/files#diff-642bfb8d9badad7de4a71c8d06a9a9baR67 io.pravega.client.connection.impl.SocketConnectionFactoryImpl#getThreadPoolSize", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r449534231", "createdAt": "2020-07-03T11:28:50Z", "author": {"login": "shrids"}, "path": "client/src/main/java/io/pravega/client/connection/impl/AppendBatchSizeTrackerImpl.java", "diffHunk": "@@ -73,15 +79,28 @@ public int getAppendBlockSize() {\n         if (numInflight <= 1) {\n             return 0;\n         }\n-        double appendsInMaxBatch = Math.max(1.0, MAX_BATCH_TIME_MILLIS / millisBetweenAppends.getCurrentValue());\n-        double targetAppendsOutstanding = MathHelpers.minMax(appendsOutstanding.getCurrentValue() * 0.5, 1.0,\n-                                                             appendsInMaxBatch);\n-        return (int) MathHelpers.minMax((long) (targetAppendsOutstanding * eventSize.getCurrentValue()), 0,\n-                                        MAX_BATCH_SIZE);\n+        double nanosPerAppend = nanosBetweenAppends.getCurrentValue();\n+        double appendsInMaxBatchTime = (MAX_BATCH_TIME_MILLIS * NANOS_PER_MILLI) / nanosPerAppend;\n+        double appendsInTime = Math.max(1.0, BASE_TIME_NANOS / nanosPerAppend);\n+        double appendsInBatch = MathHelpers.minMax(appendsOutstanding.getCurrentValue() * OUTSTANDING_FRACTION, appendsInTime, appendsInMaxBatchTime);\n+        int size = (int) (appendsInBatch * eventSize.getCurrentValue()) + BASE_SIZE;\n+        return MathHelpers.minMax(size, 0, MAX_BATCH_SIZE);\n     }\n \n     @Override\n     public int getBatchTimeout() {\n         return MAX_BATCH_TIME_MILLIS;\n     }\n+    \n+    private static int initializeConstant(String name, int defaultValue) {\n+        String val = System.getenv(name);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODIwMTI3OQ=="}, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIyMTkwOA==", "bodyText": "@RaulGracia Would you prefer prefer these to: a) stay as-is. b) change into system properties\nor are we done with testing these and we can go back to hardcoding them?", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r451221908", "createdAt": "2020-07-08T00:52:25Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/connection/impl/AppendBatchSizeTrackerImpl.java", "diffHunk": "@@ -73,15 +79,28 @@ public int getAppendBlockSize() {\n         if (numInflight <= 1) {\n             return 0;\n         }\n-        double appendsInMaxBatch = Math.max(1.0, MAX_BATCH_TIME_MILLIS / millisBetweenAppends.getCurrentValue());\n-        double targetAppendsOutstanding = MathHelpers.minMax(appendsOutstanding.getCurrentValue() * 0.5, 1.0,\n-                                                             appendsInMaxBatch);\n-        return (int) MathHelpers.minMax((long) (targetAppendsOutstanding * eventSize.getCurrentValue()), 0,\n-                                        MAX_BATCH_SIZE);\n+        double nanosPerAppend = nanosBetweenAppends.getCurrentValue();\n+        double appendsInMaxBatchTime = (MAX_BATCH_TIME_MILLIS * NANOS_PER_MILLI) / nanosPerAppend;\n+        double appendsInTime = Math.max(1.0, BASE_TIME_NANOS / nanosPerAppend);\n+        double appendsInBatch = MathHelpers.minMax(appendsOutstanding.getCurrentValue() * OUTSTANDING_FRACTION, appendsInTime, appendsInMaxBatchTime);\n+        int size = (int) (appendsInBatch * eventSize.getCurrentValue()) + BASE_SIZE;\n+        return MathHelpers.minMax(size, 0, MAX_BATCH_SIZE);\n     }\n \n     @Override\n     public int getBatchTimeout() {\n         return MAX_BATCH_TIME_MILLIS;\n     }\n+    \n+    private static int initializeConstant(String name, int defaultValue) {\n+        String val = System.getenv(name);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODIwMTI3OQ=="}, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MzU2MzU2OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/connection/impl/ConnectionPoolImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwODoyNjo1N1rOGrcEfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QyMzoyMDoxMlrOGuS2jQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODIwMTg1Mw==", "bodyText": "nit: static ?", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r448201853", "createdAt": "2020-07-01T08:26:57Z", "author": {"login": "eolivelli"}, "path": "client/src/main/java/io/pravega/client/connection/impl/ConnectionPoolImpl.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+\n+package io.pravega.client.connection.impl;\n+\n+import static io.pravega.shared.metrics.MetricNotifier.NO_OP_METRIC_NOTIFIER;\n+\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.concurrent.GuardedBy;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+\n+import io.pravega.client.ClientConfig;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.shared.metrics.ClientMetricUpdater;\n+import io.pravega.shared.metrics.MetricListener;\n+import io.pravega.shared.metrics.MetricNotifier;\n+import io.pravega.shared.protocol.netty.PravegaNodeUri;\n+import io.pravega.shared.protocol.netty.ReplyProcessor;\n+import lombok.Data;\n+import lombok.Synchronized;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public class ConnectionPoolImpl implements ConnectionPool {\n+\n+    /**\n+     * This class represents a Connection that is established with a Segment Store instance and its\n+     * attributes. (e.g: FlowCount, WriterCount)\n+     */\n+    @Data\n+    private class Connection implements Comparable<Connection>, AutoCloseable {\n+        private final PravegaNodeUri uri;\n+        /**\n+         * A future that completes when the connection is first established.\n+         */\n+        private final CompletableFuture<FlowHandler> flowHandler;\n+\n+        int getFlowCount() {\n+            return Futures.isSuccessful(flowHandler) ? flowHandler.join().getOpenFlowCount() : 0;\n+        }\n+\n+        boolean isConnected() {\n+            if (!Futures.isSuccessful(flowHandler)) {\n+                return false;\n+            }\n+            return !flowHandler.join().isClosed();\n+        }\n+\n+        @Override\n+        public int compareTo(Connection o) {\n+            int v1 = Futures.isSuccessful(this.getFlowHandler()) ? this.getFlowCount() : Integer.MAX_VALUE;\n+            int v2 = Futures.isSuccessful(o.getFlowHandler()) ? o.getFlowCount() : Integer.MAX_VALUE;\n+            return Integer.compare(v1, v2);\n+        }\n+        \n+        @Override\n+        public void close() {\n+            if (Futures.isSuccessful(flowHandler)) {\n+                flowHandler.join().close();\n+            }\n+        }\n+    }\n+    \n+    private final ClientConfig clientConfig;\n+    private final MetricNotifier metricNotifier;\n+    private final AtomicBoolean closed = new AtomicBoolean(false);\n+    @GuardedBy(\"$lock\")\n+    private final Map<PravegaNodeUri, List<Connection>> connectionMap = new HashMap<>();\n+    private ConnectionFactory connectionFactory;\n+\n+    public ConnectionPoolImpl(ClientConfig clientConfig, ConnectionFactory connectionFactory) {\n+        this.clientConfig = clientConfig;\n+        this.connectionFactory = connectionFactory;\n+        MetricListener metricListener = clientConfig.getMetricListener();\n+        this.metricNotifier = metricListener == null ? NO_OP_METRIC_NOTIFIER : new ClientMetricUpdater(metricListener);\n+    }\n+\n+    @Override\n+    @Synchronized\n+    public CompletableFuture<ClientConnection> getClientConnection(Flow flow, PravegaNodeUri location, ReplyProcessor rp) {\n+        Preconditions.checkNotNull(flow, \"Flow\");\n+        Preconditions.checkNotNull(location, \"Location\");\n+        Preconditions.checkNotNull(rp, \"ReplyProcessor\");\n+        Exceptions.checkNotClosed(closed.get(), this);\n+\n+        final List<Connection> connectionList = connectionMap.getOrDefault(location, new ArrayList<>());\n+\n+        // remove connections for which the underlying network connection is disconnected.\n+        List<Connection> prunedConnectionList = connectionList.stream().filter(connection -> {\n+            // Filter out Connection objects which have been completed exceptionally or have been disconnected.\n+            return !connection.getFlowHandler().isDone() || connection.isConnected();\n+        }).collect(Collectors.toList());\n+        log.debug(\"List of connections to {} that can be used: {}\", location, prunedConnectionList);\n+\n+        // Choose the connection with the least number of flows.\n+        Optional<Connection> suggestedConnection = prunedConnectionList.stream().min(Comparator.naturalOrder());\n+\n+        final Connection connection;\n+        if (suggestedConnection.isPresent() && (prunedConnectionList.size() >= clientConfig.getMaxConnectionsPerSegmentStore() || isUnused(suggestedConnection.get()))) {\n+            log.info(\"Reusing connection: {}\", suggestedConnection.get());\n+            connection = suggestedConnection.get();\n+        } else {\n+            // create a new connection.\n+            log.info(\"Creating a new connection to {}\", location);\n+            CompletableFuture<FlowHandler> establishedFuture = establishConnection(location);\n+            connection = new Connection(location, establishedFuture);\n+            prunedConnectionList.add(connection);\n+        }\n+        connectionMap.put(location, prunedConnectionList);\n+        return connection.getFlowHandler().thenApply(flowHandler -> flowHandler.createFlow(flow, rp));\n+    }\n+\n+    @Override\n+    @Synchronized\n+    public CompletableFuture<ClientConnection> getClientConnection(PravegaNodeUri location, ReplyProcessor rp) {\n+        Preconditions.checkNotNull(location, \"Location\");\n+        Preconditions.checkNotNull(rp, \"ReplyProcessor\");\n+        Exceptions.checkNotClosed(closed.get(), this);\n+\n+        // create a new connection.\n+        CompletableFuture<FlowHandler> handler = establishConnection(location);\n+        Connection connection = new Connection(location, handler);\n+        return connection.getFlowHandler().thenApply(h -> h.createConnectionWithFlowDisabled(rp));\n+    }\n+\n+    private boolean isUnused(Connection connection) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE5NjU1Nw==", "bodyText": "done", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r451196557", "createdAt": "2020-07-07T23:20:12Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/connection/impl/ConnectionPoolImpl.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+\n+package io.pravega.client.connection.impl;\n+\n+import static io.pravega.shared.metrics.MetricNotifier.NO_OP_METRIC_NOTIFIER;\n+\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.concurrent.GuardedBy;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+\n+import io.pravega.client.ClientConfig;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.shared.metrics.ClientMetricUpdater;\n+import io.pravega.shared.metrics.MetricListener;\n+import io.pravega.shared.metrics.MetricNotifier;\n+import io.pravega.shared.protocol.netty.PravegaNodeUri;\n+import io.pravega.shared.protocol.netty.ReplyProcessor;\n+import lombok.Data;\n+import lombok.Synchronized;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public class ConnectionPoolImpl implements ConnectionPool {\n+\n+    /**\n+     * This class represents a Connection that is established with a Segment Store instance and its\n+     * attributes. (e.g: FlowCount, WriterCount)\n+     */\n+    @Data\n+    private class Connection implements Comparable<Connection>, AutoCloseable {\n+        private final PravegaNodeUri uri;\n+        /**\n+         * A future that completes when the connection is first established.\n+         */\n+        private final CompletableFuture<FlowHandler> flowHandler;\n+\n+        int getFlowCount() {\n+            return Futures.isSuccessful(flowHandler) ? flowHandler.join().getOpenFlowCount() : 0;\n+        }\n+\n+        boolean isConnected() {\n+            if (!Futures.isSuccessful(flowHandler)) {\n+                return false;\n+            }\n+            return !flowHandler.join().isClosed();\n+        }\n+\n+        @Override\n+        public int compareTo(Connection o) {\n+            int v1 = Futures.isSuccessful(this.getFlowHandler()) ? this.getFlowCount() : Integer.MAX_VALUE;\n+            int v2 = Futures.isSuccessful(o.getFlowHandler()) ? o.getFlowCount() : Integer.MAX_VALUE;\n+            return Integer.compare(v1, v2);\n+        }\n+        \n+        @Override\n+        public void close() {\n+            if (Futures.isSuccessful(flowHandler)) {\n+                flowHandler.join().close();\n+            }\n+        }\n+    }\n+    \n+    private final ClientConfig clientConfig;\n+    private final MetricNotifier metricNotifier;\n+    private final AtomicBoolean closed = new AtomicBoolean(false);\n+    @GuardedBy(\"$lock\")\n+    private final Map<PravegaNodeUri, List<Connection>> connectionMap = new HashMap<>();\n+    private ConnectionFactory connectionFactory;\n+\n+    public ConnectionPoolImpl(ClientConfig clientConfig, ConnectionFactory connectionFactory) {\n+        this.clientConfig = clientConfig;\n+        this.connectionFactory = connectionFactory;\n+        MetricListener metricListener = clientConfig.getMetricListener();\n+        this.metricNotifier = metricListener == null ? NO_OP_METRIC_NOTIFIER : new ClientMetricUpdater(metricListener);\n+    }\n+\n+    @Override\n+    @Synchronized\n+    public CompletableFuture<ClientConnection> getClientConnection(Flow flow, PravegaNodeUri location, ReplyProcessor rp) {\n+        Preconditions.checkNotNull(flow, \"Flow\");\n+        Preconditions.checkNotNull(location, \"Location\");\n+        Preconditions.checkNotNull(rp, \"ReplyProcessor\");\n+        Exceptions.checkNotClosed(closed.get(), this);\n+\n+        final List<Connection> connectionList = connectionMap.getOrDefault(location, new ArrayList<>());\n+\n+        // remove connections for which the underlying network connection is disconnected.\n+        List<Connection> prunedConnectionList = connectionList.stream().filter(connection -> {\n+            // Filter out Connection objects which have been completed exceptionally or have been disconnected.\n+            return !connection.getFlowHandler().isDone() || connection.isConnected();\n+        }).collect(Collectors.toList());\n+        log.debug(\"List of connections to {} that can be used: {}\", location, prunedConnectionList);\n+\n+        // Choose the connection with the least number of flows.\n+        Optional<Connection> suggestedConnection = prunedConnectionList.stream().min(Comparator.naturalOrder());\n+\n+        final Connection connection;\n+        if (suggestedConnection.isPresent() && (prunedConnectionList.size() >= clientConfig.getMaxConnectionsPerSegmentStore() || isUnused(suggestedConnection.get()))) {\n+            log.info(\"Reusing connection: {}\", suggestedConnection.get());\n+            connection = suggestedConnection.get();\n+        } else {\n+            // create a new connection.\n+            log.info(\"Creating a new connection to {}\", location);\n+            CompletableFuture<FlowHandler> establishedFuture = establishConnection(location);\n+            connection = new Connection(location, establishedFuture);\n+            prunedConnectionList.add(connection);\n+        }\n+        connectionMap.put(location, prunedConnectionList);\n+        return connection.getFlowHandler().thenApply(flowHandler -> flowHandler.createFlow(flow, rp));\n+    }\n+\n+    @Override\n+    @Synchronized\n+    public CompletableFuture<ClientConnection> getClientConnection(PravegaNodeUri location, ReplyProcessor rp) {\n+        Preconditions.checkNotNull(location, \"Location\");\n+        Preconditions.checkNotNull(rp, \"ReplyProcessor\");\n+        Exceptions.checkNotClosed(closed.get(), this);\n+\n+        // create a new connection.\n+        CompletableFuture<FlowHandler> handler = establishConnection(location);\n+        Connection connection = new Connection(location, handler);\n+        return connection.getFlowHandler().thenApply(h -> h.createConnectionWithFlowDisabled(rp));\n+    }\n+\n+    private boolean isUnused(Connection connection) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODIwMTg1Mw=="}, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 147}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MzU2Nzc1OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/connection/impl/ConnectionPoolImpl.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwODoyODowOFrOGrcHTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxMTo0NzoyOVrOGwlGpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODIwMjU3Mw==", "bodyText": "should we log a line ?\nthis .join() may take time to complete, if there is something stuck.", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r448202573", "createdAt": "2020-07-01T08:28:08Z", "author": {"login": "eolivelli"}, "path": "client/src/main/java/io/pravega/client/connection/impl/ConnectionPoolImpl.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+\n+package io.pravega.client.connection.impl;\n+\n+import static io.pravega.shared.metrics.MetricNotifier.NO_OP_METRIC_NOTIFIER;\n+\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.concurrent.GuardedBy;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+\n+import io.pravega.client.ClientConfig;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.shared.metrics.ClientMetricUpdater;\n+import io.pravega.shared.metrics.MetricListener;\n+import io.pravega.shared.metrics.MetricNotifier;\n+import io.pravega.shared.protocol.netty.PravegaNodeUri;\n+import io.pravega.shared.protocol.netty.ReplyProcessor;\n+import lombok.Data;\n+import lombok.Synchronized;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public class ConnectionPoolImpl implements ConnectionPool {\n+\n+    /**\n+     * This class represents a Connection that is established with a Segment Store instance and its\n+     * attributes. (e.g: FlowCount, WriterCount)\n+     */\n+    @Data\n+    private class Connection implements Comparable<Connection>, AutoCloseable {\n+        private final PravegaNodeUri uri;\n+        /**\n+         * A future that completes when the connection is first established.\n+         */\n+        private final CompletableFuture<FlowHandler> flowHandler;\n+\n+        int getFlowCount() {\n+            return Futures.isSuccessful(flowHandler) ? flowHandler.join().getOpenFlowCount() : 0;\n+        }\n+\n+        boolean isConnected() {\n+            if (!Futures.isSuccessful(flowHandler)) {\n+                return false;\n+            }\n+            return !flowHandler.join().isClosed();\n+        }\n+\n+        @Override\n+        public int compareTo(Connection o) {\n+            int v1 = Futures.isSuccessful(this.getFlowHandler()) ? this.getFlowCount() : Integer.MAX_VALUE;\n+            int v2 = Futures.isSuccessful(o.getFlowHandler()) ? o.getFlowCount() : Integer.MAX_VALUE;\n+            return Integer.compare(v1, v2);\n+        }\n+        \n+        @Override\n+        public void close() {\n+            if (Futures.isSuccessful(flowHandler)) {\n+                flowHandler.join().close();\n+            }\n+        }\n+    }\n+    \n+    private final ClientConfig clientConfig;\n+    private final MetricNotifier metricNotifier;\n+    private final AtomicBoolean closed = new AtomicBoolean(false);\n+    @GuardedBy(\"$lock\")\n+    private final Map<PravegaNodeUri, List<Connection>> connectionMap = new HashMap<>();\n+    private ConnectionFactory connectionFactory;\n+\n+    public ConnectionPoolImpl(ClientConfig clientConfig, ConnectionFactory connectionFactory) {\n+        this.clientConfig = clientConfig;\n+        this.connectionFactory = connectionFactory;\n+        MetricListener metricListener = clientConfig.getMetricListener();\n+        this.metricNotifier = metricListener == null ? NO_OP_METRIC_NOTIFIER : new ClientMetricUpdater(metricListener);\n+    }\n+\n+    @Override\n+    @Synchronized\n+    public CompletableFuture<ClientConnection> getClientConnection(Flow flow, PravegaNodeUri location, ReplyProcessor rp) {\n+        Preconditions.checkNotNull(flow, \"Flow\");\n+        Preconditions.checkNotNull(location, \"Location\");\n+        Preconditions.checkNotNull(rp, \"ReplyProcessor\");\n+        Exceptions.checkNotClosed(closed.get(), this);\n+\n+        final List<Connection> connectionList = connectionMap.getOrDefault(location, new ArrayList<>());\n+\n+        // remove connections for which the underlying network connection is disconnected.\n+        List<Connection> prunedConnectionList = connectionList.stream().filter(connection -> {\n+            // Filter out Connection objects which have been completed exceptionally or have been disconnected.\n+            return !connection.getFlowHandler().isDone() || connection.isConnected();\n+        }).collect(Collectors.toList());\n+        log.debug(\"List of connections to {} that can be used: {}\", location, prunedConnectionList);\n+\n+        // Choose the connection with the least number of flows.\n+        Optional<Connection> suggestedConnection = prunedConnectionList.stream().min(Comparator.naturalOrder());\n+\n+        final Connection connection;\n+        if (suggestedConnection.isPresent() && (prunedConnectionList.size() >= clientConfig.getMaxConnectionsPerSegmentStore() || isUnused(suggestedConnection.get()))) {\n+            log.info(\"Reusing connection: {}\", suggestedConnection.get());\n+            connection = suggestedConnection.get();\n+        } else {\n+            // create a new connection.\n+            log.info(\"Creating a new connection to {}\", location);\n+            CompletableFuture<FlowHandler> establishedFuture = establishConnection(location);\n+            connection = new Connection(location, establishedFuture);\n+            prunedConnectionList.add(connection);\n+        }\n+        connectionMap.put(location, prunedConnectionList);\n+        return connection.getFlowHandler().thenApply(flowHandler -> flowHandler.createFlow(flow, rp));\n+    }\n+\n+    @Override\n+    @Synchronized\n+    public CompletableFuture<ClientConnection> getClientConnection(PravegaNodeUri location, ReplyProcessor rp) {\n+        Preconditions.checkNotNull(location, \"Location\");\n+        Preconditions.checkNotNull(rp, \"ReplyProcessor\");\n+        Exceptions.checkNotClosed(closed.get(), this);\n+\n+        // create a new connection.\n+        CompletableFuture<FlowHandler> handler = establishConnection(location);\n+        Connection connection = new Connection(location, handler);\n+        return connection.getFlowHandler().thenApply(h -> h.createConnectionWithFlowDisabled(rp));\n+    }\n+\n+    private boolean isUnused(Connection connection) {\n+        return Futures.isSuccessful(connection.getFlowHandler()) && connection.getFlowCount() == 0;\n+    }\n+\n+    /**\n+     * Used only for testing.\n+     */\n+    @VisibleForTesting\n+    @Synchronized\n+    public void pruneUnusedConnections() {\n+        for (List<Connection> connections : connectionMap.values()) {\n+            for (Iterator<Connection> iterator = connections.iterator(); iterator.hasNext();) {\n+                Connection connection = iterator.next();\n+                if (isUnused(connection)) {\n+                    connection.getFlowHandler().join().close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIwNzUxNA==", "bodyText": "If the isUnused function first checks Futures.isSuccessful so if it is considered unused the join should be instant.", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r451207514", "createdAt": "2020-07-07T23:56:41Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/connection/impl/ConnectionPoolImpl.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+\n+package io.pravega.client.connection.impl;\n+\n+import static io.pravega.shared.metrics.MetricNotifier.NO_OP_METRIC_NOTIFIER;\n+\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.concurrent.GuardedBy;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+\n+import io.pravega.client.ClientConfig;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.shared.metrics.ClientMetricUpdater;\n+import io.pravega.shared.metrics.MetricListener;\n+import io.pravega.shared.metrics.MetricNotifier;\n+import io.pravega.shared.protocol.netty.PravegaNodeUri;\n+import io.pravega.shared.protocol.netty.ReplyProcessor;\n+import lombok.Data;\n+import lombok.Synchronized;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public class ConnectionPoolImpl implements ConnectionPool {\n+\n+    /**\n+     * This class represents a Connection that is established with a Segment Store instance and its\n+     * attributes. (e.g: FlowCount, WriterCount)\n+     */\n+    @Data\n+    private class Connection implements Comparable<Connection>, AutoCloseable {\n+        private final PravegaNodeUri uri;\n+        /**\n+         * A future that completes when the connection is first established.\n+         */\n+        private final CompletableFuture<FlowHandler> flowHandler;\n+\n+        int getFlowCount() {\n+            return Futures.isSuccessful(flowHandler) ? flowHandler.join().getOpenFlowCount() : 0;\n+        }\n+\n+        boolean isConnected() {\n+            if (!Futures.isSuccessful(flowHandler)) {\n+                return false;\n+            }\n+            return !flowHandler.join().isClosed();\n+        }\n+\n+        @Override\n+        public int compareTo(Connection o) {\n+            int v1 = Futures.isSuccessful(this.getFlowHandler()) ? this.getFlowCount() : Integer.MAX_VALUE;\n+            int v2 = Futures.isSuccessful(o.getFlowHandler()) ? o.getFlowCount() : Integer.MAX_VALUE;\n+            return Integer.compare(v1, v2);\n+        }\n+        \n+        @Override\n+        public void close() {\n+            if (Futures.isSuccessful(flowHandler)) {\n+                flowHandler.join().close();\n+            }\n+        }\n+    }\n+    \n+    private final ClientConfig clientConfig;\n+    private final MetricNotifier metricNotifier;\n+    private final AtomicBoolean closed = new AtomicBoolean(false);\n+    @GuardedBy(\"$lock\")\n+    private final Map<PravegaNodeUri, List<Connection>> connectionMap = new HashMap<>();\n+    private ConnectionFactory connectionFactory;\n+\n+    public ConnectionPoolImpl(ClientConfig clientConfig, ConnectionFactory connectionFactory) {\n+        this.clientConfig = clientConfig;\n+        this.connectionFactory = connectionFactory;\n+        MetricListener metricListener = clientConfig.getMetricListener();\n+        this.metricNotifier = metricListener == null ? NO_OP_METRIC_NOTIFIER : new ClientMetricUpdater(metricListener);\n+    }\n+\n+    @Override\n+    @Synchronized\n+    public CompletableFuture<ClientConnection> getClientConnection(Flow flow, PravegaNodeUri location, ReplyProcessor rp) {\n+        Preconditions.checkNotNull(flow, \"Flow\");\n+        Preconditions.checkNotNull(location, \"Location\");\n+        Preconditions.checkNotNull(rp, \"ReplyProcessor\");\n+        Exceptions.checkNotClosed(closed.get(), this);\n+\n+        final List<Connection> connectionList = connectionMap.getOrDefault(location, new ArrayList<>());\n+\n+        // remove connections for which the underlying network connection is disconnected.\n+        List<Connection> prunedConnectionList = connectionList.stream().filter(connection -> {\n+            // Filter out Connection objects which have been completed exceptionally or have been disconnected.\n+            return !connection.getFlowHandler().isDone() || connection.isConnected();\n+        }).collect(Collectors.toList());\n+        log.debug(\"List of connections to {} that can be used: {}\", location, prunedConnectionList);\n+\n+        // Choose the connection with the least number of flows.\n+        Optional<Connection> suggestedConnection = prunedConnectionList.stream().min(Comparator.naturalOrder());\n+\n+        final Connection connection;\n+        if (suggestedConnection.isPresent() && (prunedConnectionList.size() >= clientConfig.getMaxConnectionsPerSegmentStore() || isUnused(suggestedConnection.get()))) {\n+            log.info(\"Reusing connection: {}\", suggestedConnection.get());\n+            connection = suggestedConnection.get();\n+        } else {\n+            // create a new connection.\n+            log.info(\"Creating a new connection to {}\", location);\n+            CompletableFuture<FlowHandler> establishedFuture = establishConnection(location);\n+            connection = new Connection(location, establishedFuture);\n+            prunedConnectionList.add(connection);\n+        }\n+        connectionMap.put(location, prunedConnectionList);\n+        return connection.getFlowHandler().thenApply(flowHandler -> flowHandler.createFlow(flow, rp));\n+    }\n+\n+    @Override\n+    @Synchronized\n+    public CompletableFuture<ClientConnection> getClientConnection(PravegaNodeUri location, ReplyProcessor rp) {\n+        Preconditions.checkNotNull(location, \"Location\");\n+        Preconditions.checkNotNull(rp, \"ReplyProcessor\");\n+        Exceptions.checkNotClosed(closed.get(), this);\n+\n+        // create a new connection.\n+        CompletableFuture<FlowHandler> handler = establishConnection(location);\n+        Connection connection = new Connection(location, handler);\n+        return connection.getFlowHandler().thenApply(h -> h.createConnectionWithFlowDisabled(rp));\n+    }\n+\n+    private boolean isUnused(Connection connection) {\n+        return Futures.isSuccessful(connection.getFlowHandler()) && connection.getFlowCount() == 0;\n+    }\n+\n+    /**\n+     * Used only for testing.\n+     */\n+    @VisibleForTesting\n+    @Synchronized\n+    public void pruneUnusedConnections() {\n+        for (List<Connection> connections : connectionMap.values()) {\n+            for (Iterator<Connection> iterator = connections.iterator(); iterator.hasNext();) {\n+                Connection connection = iterator.next();\n+                if (isUnused(connection)) {\n+                    connection.getFlowHandler().join().close();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODIwMjU3Mw=="}, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU5Mjc0MQ==", "bodyText": "okay", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r453592741", "createdAt": "2020-07-13T11:47:29Z", "author": {"login": "eolivelli"}, "path": "client/src/main/java/io/pravega/client/connection/impl/ConnectionPoolImpl.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+\n+package io.pravega.client.connection.impl;\n+\n+import static io.pravega.shared.metrics.MetricNotifier.NO_OP_METRIC_NOTIFIER;\n+\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.concurrent.GuardedBy;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+\n+import io.pravega.client.ClientConfig;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.shared.metrics.ClientMetricUpdater;\n+import io.pravega.shared.metrics.MetricListener;\n+import io.pravega.shared.metrics.MetricNotifier;\n+import io.pravega.shared.protocol.netty.PravegaNodeUri;\n+import io.pravega.shared.protocol.netty.ReplyProcessor;\n+import lombok.Data;\n+import lombok.Synchronized;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public class ConnectionPoolImpl implements ConnectionPool {\n+\n+    /**\n+     * This class represents a Connection that is established with a Segment Store instance and its\n+     * attributes. (e.g: FlowCount, WriterCount)\n+     */\n+    @Data\n+    private class Connection implements Comparable<Connection>, AutoCloseable {\n+        private final PravegaNodeUri uri;\n+        /**\n+         * A future that completes when the connection is first established.\n+         */\n+        private final CompletableFuture<FlowHandler> flowHandler;\n+\n+        int getFlowCount() {\n+            return Futures.isSuccessful(flowHandler) ? flowHandler.join().getOpenFlowCount() : 0;\n+        }\n+\n+        boolean isConnected() {\n+            if (!Futures.isSuccessful(flowHandler)) {\n+                return false;\n+            }\n+            return !flowHandler.join().isClosed();\n+        }\n+\n+        @Override\n+        public int compareTo(Connection o) {\n+            int v1 = Futures.isSuccessful(this.getFlowHandler()) ? this.getFlowCount() : Integer.MAX_VALUE;\n+            int v2 = Futures.isSuccessful(o.getFlowHandler()) ? o.getFlowCount() : Integer.MAX_VALUE;\n+            return Integer.compare(v1, v2);\n+        }\n+        \n+        @Override\n+        public void close() {\n+            if (Futures.isSuccessful(flowHandler)) {\n+                flowHandler.join().close();\n+            }\n+        }\n+    }\n+    \n+    private final ClientConfig clientConfig;\n+    private final MetricNotifier metricNotifier;\n+    private final AtomicBoolean closed = new AtomicBoolean(false);\n+    @GuardedBy(\"$lock\")\n+    private final Map<PravegaNodeUri, List<Connection>> connectionMap = new HashMap<>();\n+    private ConnectionFactory connectionFactory;\n+\n+    public ConnectionPoolImpl(ClientConfig clientConfig, ConnectionFactory connectionFactory) {\n+        this.clientConfig = clientConfig;\n+        this.connectionFactory = connectionFactory;\n+        MetricListener metricListener = clientConfig.getMetricListener();\n+        this.metricNotifier = metricListener == null ? NO_OP_METRIC_NOTIFIER : new ClientMetricUpdater(metricListener);\n+    }\n+\n+    @Override\n+    @Synchronized\n+    public CompletableFuture<ClientConnection> getClientConnection(Flow flow, PravegaNodeUri location, ReplyProcessor rp) {\n+        Preconditions.checkNotNull(flow, \"Flow\");\n+        Preconditions.checkNotNull(location, \"Location\");\n+        Preconditions.checkNotNull(rp, \"ReplyProcessor\");\n+        Exceptions.checkNotClosed(closed.get(), this);\n+\n+        final List<Connection> connectionList = connectionMap.getOrDefault(location, new ArrayList<>());\n+\n+        // remove connections for which the underlying network connection is disconnected.\n+        List<Connection> prunedConnectionList = connectionList.stream().filter(connection -> {\n+            // Filter out Connection objects which have been completed exceptionally or have been disconnected.\n+            return !connection.getFlowHandler().isDone() || connection.isConnected();\n+        }).collect(Collectors.toList());\n+        log.debug(\"List of connections to {} that can be used: {}\", location, prunedConnectionList);\n+\n+        // Choose the connection with the least number of flows.\n+        Optional<Connection> suggestedConnection = prunedConnectionList.stream().min(Comparator.naturalOrder());\n+\n+        final Connection connection;\n+        if (suggestedConnection.isPresent() && (prunedConnectionList.size() >= clientConfig.getMaxConnectionsPerSegmentStore() || isUnused(suggestedConnection.get()))) {\n+            log.info(\"Reusing connection: {}\", suggestedConnection.get());\n+            connection = suggestedConnection.get();\n+        } else {\n+            // create a new connection.\n+            log.info(\"Creating a new connection to {}\", location);\n+            CompletableFuture<FlowHandler> establishedFuture = establishConnection(location);\n+            connection = new Connection(location, establishedFuture);\n+            prunedConnectionList.add(connection);\n+        }\n+        connectionMap.put(location, prunedConnectionList);\n+        return connection.getFlowHandler().thenApply(flowHandler -> flowHandler.createFlow(flow, rp));\n+    }\n+\n+    @Override\n+    @Synchronized\n+    public CompletableFuture<ClientConnection> getClientConnection(PravegaNodeUri location, ReplyProcessor rp) {\n+        Preconditions.checkNotNull(location, \"Location\");\n+        Preconditions.checkNotNull(rp, \"ReplyProcessor\");\n+        Exceptions.checkNotClosed(closed.get(), this);\n+\n+        // create a new connection.\n+        CompletableFuture<FlowHandler> handler = establishConnection(location);\n+        Connection connection = new Connection(location, handler);\n+        return connection.getFlowHandler().thenApply(h -> h.createConnectionWithFlowDisabled(rp));\n+    }\n+\n+    private boolean isUnused(Connection connection) {\n+        return Futures.isSuccessful(connection.getFlowHandler()) && connection.getFlowCount() == 0;\n+    }\n+\n+    /**\n+     * Used only for testing.\n+     */\n+    @VisibleForTesting\n+    @Synchronized\n+    public void pruneUnusedConnections() {\n+        for (List<Connection> connections : connectionMap.values()) {\n+            for (Iterator<Connection> iterator = connections.iterator(); iterator.hasNext();) {\n+                Connection connection = iterator.next();\n+                if (isUnused(connection)) {\n+                    connection.getFlowHandler().join().close();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODIwMjU3Mw=="}, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 161}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MzU3NzUzOnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/connection/impl/IoBuffer.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwODozMDozMVrOGrcNUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxMTo1ODo0MVrOGwlbZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODIwNDExMw==", "bodyText": "Are we assuming that this is only a Heap ByteBuffer ?\nbuffer.array() won't work with a Direct Buffer", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r448204113", "createdAt": "2020-07-01T08:30:31Z", "author": {"login": "eolivelli"}, "path": "client/src/main/java/io/pravega/client/connection/impl/IoBuffer.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.connection.impl;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.pravega.common.MathHelpers;\n+import io.pravega.shared.protocol.netty.WireCommands;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+\n+class IoBuffer {\n+    private int maxBufferSize = WireCommands.MAX_WIRECOMMAND_SIZE;\n+    private ByteBuffer buffer = null;\n+    \n+    private ByteBuf sliceOut(int size) {\n+        ByteBuf result = Unpooled.wrappedBuffer(buffer.array(), buffer.arrayOffset() + buffer.position(), size);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIwNzgyMw==", "bodyText": "The buffer is allocated locally in this class by wrapping an array. (And all accesses to it are private) So there is no way for it to be a heap byteBuffer.", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r451207823", "createdAt": "2020-07-07T23:57:47Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/connection/impl/IoBuffer.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.connection.impl;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.pravega.common.MathHelpers;\n+import io.pravega.shared.protocol.netty.WireCommands;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+\n+class IoBuffer {\n+    private int maxBufferSize = WireCommands.MAX_WIRECOMMAND_SIZE;\n+    private ByteBuffer buffer = null;\n+    \n+    private ByteBuf sliceOut(int size) {\n+        ByteBuf result = Unpooled.wrappedBuffer(buffer.array(), buffer.arrayOffset() + buffer.position(), size);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODIwNDExMw=="}, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU5ODA1Mw==", "bodyText": "I see you are only allocating an heap buffer, so this is fine.\n\n  \n    \n      pravega/client/src/main/java/io/pravega/client/connection/impl/IoBuffer.java\n    \n    \n         Line 66\n      in\n      2776ea5\n    \n    \n    \n    \n\n        \n          \n           buffer = ByteBuffer.wrap(newBuffer, 0, read);  \n        \n    \n  \n\n\nA couple of questions:\n\nDid you consider using a direct buffer ?\nDid you consider using Netty pooling capabilities ? instead of doing our own buffer manager ? (it will require calling release.\nWe are going to return references to small parts of a larger buffer, and the caller will implicitly hold references and prevent collection. Will this impact performances someway ?\nfrom the comment at \n  \n    \n      pravega/client/src/main/java/io/pravega/client/connection/impl/IoBuffer.java\n    \n    \n         Line 66\n      in\n      2776ea5\n    \n    \n    \n    \n\n        \n          \n           buffer = ByteBuffer.wrap(newBuffer, 0, read);  \n        \n    \n  \n\n It looks like this is not a problem.\nand your answer at\n\n  \n    \n      pravega/client/src/main/java/io/pravega/client/connection/impl/IoBuffer.java\n    \n    \n         Line 66\n      in\n      2776ea5\n    \n    \n    \n    \n\n        \n          \n           buffer = ByteBuffer.wrap(newBuffer, 0, read);  \n        \n    \n  \n\n\nso the answer is already there", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r453598053", "createdAt": "2020-07-13T11:58:41Z", "author": {"login": "eolivelli"}, "path": "client/src/main/java/io/pravega/client/connection/impl/IoBuffer.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.connection.impl;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.pravega.common.MathHelpers;\n+import io.pravega.shared.protocol.netty.WireCommands;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+\n+class IoBuffer {\n+    private int maxBufferSize = WireCommands.MAX_WIRECOMMAND_SIZE;\n+    private ByteBuffer buffer = null;\n+    \n+    private ByteBuf sliceOut(int size) {\n+        ByteBuf result = Unpooled.wrappedBuffer(buffer.array(), buffer.arrayOffset() + buffer.position(), size);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODIwNDExMw=="}, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MzU4NjY0OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/connection/impl/TcpClientConnection.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwODozMjo1OFrOGrcTBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QwNzoyMDo1OVrOGsmWWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODIwNTU3Mg==", "bodyText": "HTTPS ?", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r448205572", "createdAt": "2020-07-01T08:32:58Z", "author": {"login": "eolivelli"}, "path": "client/src/main/java/io/pravega/client/connection/impl/TcpClientConnection.java", "diffHunk": "@@ -0,0 +1,306 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.connection.impl;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import io.netty.buffer.ByteBuf;\n+import io.pravega.client.ClientConfig;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import io.pravega.common.util.CertificateUtils;\n+import io.pravega.shared.protocol.netty.Append;\n+import io.pravega.shared.protocol.netty.AppendBatchSizeTracker;\n+import io.pravega.shared.protocol.netty.ConnectionFailedException;\n+import io.pravega.shared.protocol.netty.EnhancedByteBufInputStream;\n+import io.pravega.shared.protocol.netty.InvalidMessageException;\n+import io.pravega.shared.protocol.netty.PravegaNodeUri;\n+import io.pravega.shared.protocol.netty.Reply;\n+import io.pravega.shared.protocol.netty.ReplyProcessor;\n+import io.pravega.shared.protocol.netty.WireCommand;\n+import io.pravega.shared.protocol.netty.WireCommandType;\n+import io.pravega.shared.protocol.netty.WireCommands;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.SocketException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.CertificateException;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLParameters;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.TrustManagerFactory;\n+import lombok.RequiredArgsConstructor;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.pravega.shared.protocol.netty.AppendBatchSizeTracker.MAX_BATCH_TIME_MILLIS;\n+\n+@Slf4j\n+public class TcpClientConnection implements ClientConnection {\n+\n+    static final int TCP_BUFFER_SIZE = 256 * 1024;\n+    \n+    private final Socket socket;\n+    private final CommandEncoder encoder;\n+    private final ConnectionReader reader;\n+    private final AtomicBoolean closed = new AtomicBoolean(false);\n+    private final PravegaNodeUri location;\n+    private final Runnable onClose;\n+    private final ScheduledFuture<?> timeoutFuture;\n+   \n+    private TcpClientConnection(Socket socket, CommandEncoder encoder, ConnectionReader reader, PravegaNodeUri location,\n+                                Runnable onClose, ScheduledExecutorService executor) {\n+        this.socket = checkNotNull(socket);\n+        this.encoder = checkNotNull(encoder);\n+        this.reader = checkNotNull(reader);\n+        this.location = checkNotNull(location);\n+        this.onClose = onClose;\n+        this.timeoutFuture = executor.scheduleWithFixedDelay(new TimeoutBatch(encoder),\n+                                                             MAX_BATCH_TIME_MILLIS,\n+                                                             MAX_BATCH_TIME_MILLIS,\n+                                                             TimeUnit.MILLISECONDS);\n+    }\n+\n+    @VisibleForTesting\n+    static class ConnectionReader {\n+        \n+        private final String name;\n+        private final InputStream in;\n+        private final ReplyProcessor callback;\n+        private final ScheduledExecutorService thread;\n+        private final AppendBatchSizeTracker batchSizeTracker;\n+        private final AtomicBoolean stop = new AtomicBoolean(false);\n+\n+        public ConnectionReader(String name, InputStream in, ReplyProcessor callback,\n+                                AppendBatchSizeTracker batchSizeTracker) {\n+            this.name = name;\n+            this.in = in;\n+            this.callback = callback;\n+            this.thread = ExecutorServiceHelpers.newScheduledThreadPool(1, \"Reading from \" + name);\n+            this.batchSizeTracker = batchSizeTracker;\n+        }\n+        \n+        public void start() {\n+            thread.submit(() -> {\n+                IoBuffer buffer = new IoBuffer();\n+                while (!stop.get()) {\n+                    try {\n+                        WireCommand command = readCommand(in, buffer);\n+                        if (command instanceof WireCommands.DataAppended) {\n+                            WireCommands.DataAppended dataAppended = (WireCommands.DataAppended) command;\n+                            batchSizeTracker.recordAck(dataAppended.getEventNumber());\n+                        }\n+                        try {\n+                            callback.process((Reply) command);\n+                        } catch (Exception e) {\n+                            callback.processingFailure(e);\n+                        }\n+                    } catch (SocketException e) {\n+                        if (e.getMessage().equals(\"Socket closed\")) {\n+                            log.info(\"Closing TcpConnection.Reader because socket is closed.\");\n+                        } else {\n+                            log.warn(\"Error in reading from socket.\", e);\n+                        }\n+                        stop();\n+                    } catch (EOFException e) {\n+                        log.info(\"Closing TcpConnection.Reader because end of input readched.\");\n+                        stop();\n+                    } catch (Exception e) {\n+                        log.warn(\"Error processing data from from server \" + name, e);\n+                        stop();\n+                    }\n+                }\n+            });\n+        }\n+\n+        @VisibleForTesting\n+        static WireCommand readCommand(InputStream in, IoBuffer buffer) throws IOException {\n+            ByteBuf header = buffer.getBuffOfSize(in, 8);\n+\n+            int t = header.getInt(0);\n+            WireCommandType type = WireCommands.getType(t);\n+            if (type == null) {\n+                throw new InvalidMessageException(\"Unknown wire command: \" + t);\n+            }\n+\n+            int length = header.getInt(4);\n+            if (length < 0 || length > WireCommands.MAX_WIRECOMMAND_SIZE) {\n+                throw new InvalidMessageException(\"Event of invalid length: \" + length);\n+            }\n+\n+            ByteBuf payload = buffer.getBuffOfSize(in, length);\n+            \n+            return type.readFrom(new EnhancedByteBufInputStream(payload), length);\n+        }\n+        \n+        public void stop() {\n+            stop.set(true);\n+            thread.shutdown();\n+            callback.connectionDropped();\n+        }\n+    }\n+    \n+    @RequiredArgsConstructor\n+    private static final class TimeoutBatch implements Runnable {\n+        private final AtomicLong token = new AtomicLong(-1);\n+        private final CommandEncoder encoder;\n+        @Override\n+        public void run() {\n+            token.set(encoder.batchTimeout(token.get()));\n+        }    \n+    }\n+\n+    public static CompletableFuture<TcpClientConnection> connect(PravegaNodeUri location, ClientConfig clientConfig, ReplyProcessor callback,\n+                                              ScheduledExecutorService executor, Runnable onClose) {\n+        return CompletableFuture.supplyAsync(() -> {\n+            Socket socket = createClientSocket(location, clientConfig); \n+            try {\n+                InputStream inputStream = socket.getInputStream();\n+                AppendBatchSizeTrackerImpl batchSizeTracker = new AppendBatchSizeTrackerImpl();\n+                ConnectionReader reader = new ConnectionReader(location.toString(), inputStream, callback, batchSizeTracker);\n+                reader.start();\n+                CommandEncoder encoder = new CommandEncoder(l -> batchSizeTracker, null, socket.getOutputStream());\n+                return new TcpClientConnection(socket, encoder, reader, location, onClose, executor);\n+            } catch (IOException e) {\n+                try {\n+                    onClose.run();\n+                    socket.close();\n+                } catch (IOException e1) {\n+                    log.warn(\"Failed to close socket while failing.\", e1);\n+                }\n+                throw Exceptions.sneakyThrow(e);\n+            }\n+        }, executor);\n+    }\n+\n+    private static TrustManagerFactory createFromCert(String trustStoreFilePath)\n+            throws CertificateException, IOException, NoSuchAlgorithmException, KeyStoreException {\n+        TrustManagerFactory factory = null;\n+        if (!Strings.isNullOrEmpty(trustStoreFilePath)) {\n+            KeyStore trustStore = CertificateUtils.createTrustStore(trustStoreFilePath);\n+\n+            factory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n+            factory.init(trustStore);\n+        }\n+        return factory;\n+    }\n+\n+    /**\n+     * Creates a socket connected to the provided endpoint. \n+     * Note that this is a sync call even though it is called in an async context. \n+     * While this is normally frowned upon, it is simply not possible to construct an SSL socket asynchronously in Java.\n+     */\n+    @SneakyThrows //Is called inside a completable future.\n+    private static Socket createClientSocket(PravegaNodeUri location, ClientConfig clientConfig) {        \n+        Socket result;\n+        if (clientConfig.isEnableTlsToSegmentStore()) {\n+            TrustManagerFactory trustMgrFactory = createFromCert(clientConfig.getTrustStore());\n+\n+            // Prepare a TLS context that uses the trust manager\n+            SSLContext tlsContext = SSLContext.getInstance(\"TLS\");\n+            tlsContext.init(null,\n+                    trustMgrFactory != null ? trustMgrFactory.getTrustManagers() : null,\n+                    null);\n+\n+            SSLSocket s = (SSLSocket) tlsContext.getSocketFactory().createSocket();\n+            // SSLSocket does not perform hostname verification by default. So, we must explicitly enable it.\n+            if (clientConfig.isValidateHostName()) {\n+                SSLParameters tlsParams = new SSLParameters();\n+                tlsParams.setEndpointIdentificationAlgorithm(\"HTTPS\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 228}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODg1MjE1NA==", "bodyText": "@ravisharda is HTTPS right in this context?", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r448852154", "createdAt": "2020-07-02T08:55:22Z", "author": {"login": "RaulGracia"}, "path": "client/src/main/java/io/pravega/client/connection/impl/TcpClientConnection.java", "diffHunk": "@@ -0,0 +1,306 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.connection.impl;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import io.netty.buffer.ByteBuf;\n+import io.pravega.client.ClientConfig;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import io.pravega.common.util.CertificateUtils;\n+import io.pravega.shared.protocol.netty.Append;\n+import io.pravega.shared.protocol.netty.AppendBatchSizeTracker;\n+import io.pravega.shared.protocol.netty.ConnectionFailedException;\n+import io.pravega.shared.protocol.netty.EnhancedByteBufInputStream;\n+import io.pravega.shared.protocol.netty.InvalidMessageException;\n+import io.pravega.shared.protocol.netty.PravegaNodeUri;\n+import io.pravega.shared.protocol.netty.Reply;\n+import io.pravega.shared.protocol.netty.ReplyProcessor;\n+import io.pravega.shared.protocol.netty.WireCommand;\n+import io.pravega.shared.protocol.netty.WireCommandType;\n+import io.pravega.shared.protocol.netty.WireCommands;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.SocketException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.CertificateException;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLParameters;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.TrustManagerFactory;\n+import lombok.RequiredArgsConstructor;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.pravega.shared.protocol.netty.AppendBatchSizeTracker.MAX_BATCH_TIME_MILLIS;\n+\n+@Slf4j\n+public class TcpClientConnection implements ClientConnection {\n+\n+    static final int TCP_BUFFER_SIZE = 256 * 1024;\n+    \n+    private final Socket socket;\n+    private final CommandEncoder encoder;\n+    private final ConnectionReader reader;\n+    private final AtomicBoolean closed = new AtomicBoolean(false);\n+    private final PravegaNodeUri location;\n+    private final Runnable onClose;\n+    private final ScheduledFuture<?> timeoutFuture;\n+   \n+    private TcpClientConnection(Socket socket, CommandEncoder encoder, ConnectionReader reader, PravegaNodeUri location,\n+                                Runnable onClose, ScheduledExecutorService executor) {\n+        this.socket = checkNotNull(socket);\n+        this.encoder = checkNotNull(encoder);\n+        this.reader = checkNotNull(reader);\n+        this.location = checkNotNull(location);\n+        this.onClose = onClose;\n+        this.timeoutFuture = executor.scheduleWithFixedDelay(new TimeoutBatch(encoder),\n+                                                             MAX_BATCH_TIME_MILLIS,\n+                                                             MAX_BATCH_TIME_MILLIS,\n+                                                             TimeUnit.MILLISECONDS);\n+    }\n+\n+    @VisibleForTesting\n+    static class ConnectionReader {\n+        \n+        private final String name;\n+        private final InputStream in;\n+        private final ReplyProcessor callback;\n+        private final ScheduledExecutorService thread;\n+        private final AppendBatchSizeTracker batchSizeTracker;\n+        private final AtomicBoolean stop = new AtomicBoolean(false);\n+\n+        public ConnectionReader(String name, InputStream in, ReplyProcessor callback,\n+                                AppendBatchSizeTracker batchSizeTracker) {\n+            this.name = name;\n+            this.in = in;\n+            this.callback = callback;\n+            this.thread = ExecutorServiceHelpers.newScheduledThreadPool(1, \"Reading from \" + name);\n+            this.batchSizeTracker = batchSizeTracker;\n+        }\n+        \n+        public void start() {\n+            thread.submit(() -> {\n+                IoBuffer buffer = new IoBuffer();\n+                while (!stop.get()) {\n+                    try {\n+                        WireCommand command = readCommand(in, buffer);\n+                        if (command instanceof WireCommands.DataAppended) {\n+                            WireCommands.DataAppended dataAppended = (WireCommands.DataAppended) command;\n+                            batchSizeTracker.recordAck(dataAppended.getEventNumber());\n+                        }\n+                        try {\n+                            callback.process((Reply) command);\n+                        } catch (Exception e) {\n+                            callback.processingFailure(e);\n+                        }\n+                    } catch (SocketException e) {\n+                        if (e.getMessage().equals(\"Socket closed\")) {\n+                            log.info(\"Closing TcpConnection.Reader because socket is closed.\");\n+                        } else {\n+                            log.warn(\"Error in reading from socket.\", e);\n+                        }\n+                        stop();\n+                    } catch (EOFException e) {\n+                        log.info(\"Closing TcpConnection.Reader because end of input readched.\");\n+                        stop();\n+                    } catch (Exception e) {\n+                        log.warn(\"Error processing data from from server \" + name, e);\n+                        stop();\n+                    }\n+                }\n+            });\n+        }\n+\n+        @VisibleForTesting\n+        static WireCommand readCommand(InputStream in, IoBuffer buffer) throws IOException {\n+            ByteBuf header = buffer.getBuffOfSize(in, 8);\n+\n+            int t = header.getInt(0);\n+            WireCommandType type = WireCommands.getType(t);\n+            if (type == null) {\n+                throw new InvalidMessageException(\"Unknown wire command: \" + t);\n+            }\n+\n+            int length = header.getInt(4);\n+            if (length < 0 || length > WireCommands.MAX_WIRECOMMAND_SIZE) {\n+                throw new InvalidMessageException(\"Event of invalid length: \" + length);\n+            }\n+\n+            ByteBuf payload = buffer.getBuffOfSize(in, length);\n+            \n+            return type.readFrom(new EnhancedByteBufInputStream(payload), length);\n+        }\n+        \n+        public void stop() {\n+            stop.set(true);\n+            thread.shutdown();\n+            callback.connectionDropped();\n+        }\n+    }\n+    \n+    @RequiredArgsConstructor\n+    private static final class TimeoutBatch implements Runnable {\n+        private final AtomicLong token = new AtomicLong(-1);\n+        private final CommandEncoder encoder;\n+        @Override\n+        public void run() {\n+            token.set(encoder.batchTimeout(token.get()));\n+        }    \n+    }\n+\n+    public static CompletableFuture<TcpClientConnection> connect(PravegaNodeUri location, ClientConfig clientConfig, ReplyProcessor callback,\n+                                              ScheduledExecutorService executor, Runnable onClose) {\n+        return CompletableFuture.supplyAsync(() -> {\n+            Socket socket = createClientSocket(location, clientConfig); \n+            try {\n+                InputStream inputStream = socket.getInputStream();\n+                AppendBatchSizeTrackerImpl batchSizeTracker = new AppendBatchSizeTrackerImpl();\n+                ConnectionReader reader = new ConnectionReader(location.toString(), inputStream, callback, batchSizeTracker);\n+                reader.start();\n+                CommandEncoder encoder = new CommandEncoder(l -> batchSizeTracker, null, socket.getOutputStream());\n+                return new TcpClientConnection(socket, encoder, reader, location, onClose, executor);\n+            } catch (IOException e) {\n+                try {\n+                    onClose.run();\n+                    socket.close();\n+                } catch (IOException e1) {\n+                    log.warn(\"Failed to close socket while failing.\", e1);\n+                }\n+                throw Exceptions.sneakyThrow(e);\n+            }\n+        }, executor);\n+    }\n+\n+    private static TrustManagerFactory createFromCert(String trustStoreFilePath)\n+            throws CertificateException, IOException, NoSuchAlgorithmException, KeyStoreException {\n+        TrustManagerFactory factory = null;\n+        if (!Strings.isNullOrEmpty(trustStoreFilePath)) {\n+            KeyStore trustStore = CertificateUtils.createTrustStore(trustStoreFilePath);\n+\n+            factory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n+            factory.init(trustStore);\n+        }\n+        return factory;\n+    }\n+\n+    /**\n+     * Creates a socket connected to the provided endpoint. \n+     * Note that this is a sync call even though it is called in an async context. \n+     * While this is normally frowned upon, it is simply not possible to construct an SSL socket asynchronously in Java.\n+     */\n+    @SneakyThrows //Is called inside a completable future.\n+    private static Socket createClientSocket(PravegaNodeUri location, ClientConfig clientConfig) {        \n+        Socket result;\n+        if (clientConfig.isEnableTlsToSegmentStore()) {\n+            TrustManagerFactory trustMgrFactory = createFromCert(clientConfig.getTrustStore());\n+\n+            // Prepare a TLS context that uses the trust manager\n+            SSLContext tlsContext = SSLContext.getInstance(\"TLS\");\n+            tlsContext.init(null,\n+                    trustMgrFactory != null ? trustMgrFactory.getTrustManagers() : null,\n+                    null);\n+\n+            SSLSocket s = (SSLSocket) tlsContext.getSocketFactory().createSocket();\n+            // SSLSocket does not perform hostname verification by default. So, we must explicitly enable it.\n+            if (clientConfig.isValidateHostName()) {\n+                SSLParameters tlsParams = new SSLParameters();\n+                tlsParams.setEndpointIdentificationAlgorithm(\"HTTPS\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODIwNTU3Mg=="}, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 228}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTM2MDEzMQ==", "bodyText": "Yeah, it does look strange as the client is connecting to a TCP (transport-layer) service exposed by Segment Store, and not to an HTTP (application-layer) server.\nHowever, note that SSLSocket does not perform TLS hostname verification by default and this is a common way of turning it on regardless of the application protocol. We were using the same mechanism elsewhere too:\n\n  \n    \n      pravega/client/src/main/java/io/pravega/client/netty/impl/ConnectionPoolImpl.java\n    \n    \n         Line 249\n      in\n      c7ac009\n    \n    \n    \n    \n\n        \n          \n           sslParameters.setEndpointIdentificationAlgorithm(\"HTTPS\"); \n        \n    \n  \n\n\nSo, this code is alright.", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r449360131", "createdAt": "2020-07-03T03:38:50Z", "author": {"login": "ravisharda"}, "path": "client/src/main/java/io/pravega/client/connection/impl/TcpClientConnection.java", "diffHunk": "@@ -0,0 +1,306 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.connection.impl;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import io.netty.buffer.ByteBuf;\n+import io.pravega.client.ClientConfig;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import io.pravega.common.util.CertificateUtils;\n+import io.pravega.shared.protocol.netty.Append;\n+import io.pravega.shared.protocol.netty.AppendBatchSizeTracker;\n+import io.pravega.shared.protocol.netty.ConnectionFailedException;\n+import io.pravega.shared.protocol.netty.EnhancedByteBufInputStream;\n+import io.pravega.shared.protocol.netty.InvalidMessageException;\n+import io.pravega.shared.protocol.netty.PravegaNodeUri;\n+import io.pravega.shared.protocol.netty.Reply;\n+import io.pravega.shared.protocol.netty.ReplyProcessor;\n+import io.pravega.shared.protocol.netty.WireCommand;\n+import io.pravega.shared.protocol.netty.WireCommandType;\n+import io.pravega.shared.protocol.netty.WireCommands;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.SocketException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.CertificateException;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLParameters;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.TrustManagerFactory;\n+import lombok.RequiredArgsConstructor;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.pravega.shared.protocol.netty.AppendBatchSizeTracker.MAX_BATCH_TIME_MILLIS;\n+\n+@Slf4j\n+public class TcpClientConnection implements ClientConnection {\n+\n+    static final int TCP_BUFFER_SIZE = 256 * 1024;\n+    \n+    private final Socket socket;\n+    private final CommandEncoder encoder;\n+    private final ConnectionReader reader;\n+    private final AtomicBoolean closed = new AtomicBoolean(false);\n+    private final PravegaNodeUri location;\n+    private final Runnable onClose;\n+    private final ScheduledFuture<?> timeoutFuture;\n+   \n+    private TcpClientConnection(Socket socket, CommandEncoder encoder, ConnectionReader reader, PravegaNodeUri location,\n+                                Runnable onClose, ScheduledExecutorService executor) {\n+        this.socket = checkNotNull(socket);\n+        this.encoder = checkNotNull(encoder);\n+        this.reader = checkNotNull(reader);\n+        this.location = checkNotNull(location);\n+        this.onClose = onClose;\n+        this.timeoutFuture = executor.scheduleWithFixedDelay(new TimeoutBatch(encoder),\n+                                                             MAX_BATCH_TIME_MILLIS,\n+                                                             MAX_BATCH_TIME_MILLIS,\n+                                                             TimeUnit.MILLISECONDS);\n+    }\n+\n+    @VisibleForTesting\n+    static class ConnectionReader {\n+        \n+        private final String name;\n+        private final InputStream in;\n+        private final ReplyProcessor callback;\n+        private final ScheduledExecutorService thread;\n+        private final AppendBatchSizeTracker batchSizeTracker;\n+        private final AtomicBoolean stop = new AtomicBoolean(false);\n+\n+        public ConnectionReader(String name, InputStream in, ReplyProcessor callback,\n+                                AppendBatchSizeTracker batchSizeTracker) {\n+            this.name = name;\n+            this.in = in;\n+            this.callback = callback;\n+            this.thread = ExecutorServiceHelpers.newScheduledThreadPool(1, \"Reading from \" + name);\n+            this.batchSizeTracker = batchSizeTracker;\n+        }\n+        \n+        public void start() {\n+            thread.submit(() -> {\n+                IoBuffer buffer = new IoBuffer();\n+                while (!stop.get()) {\n+                    try {\n+                        WireCommand command = readCommand(in, buffer);\n+                        if (command instanceof WireCommands.DataAppended) {\n+                            WireCommands.DataAppended dataAppended = (WireCommands.DataAppended) command;\n+                            batchSizeTracker.recordAck(dataAppended.getEventNumber());\n+                        }\n+                        try {\n+                            callback.process((Reply) command);\n+                        } catch (Exception e) {\n+                            callback.processingFailure(e);\n+                        }\n+                    } catch (SocketException e) {\n+                        if (e.getMessage().equals(\"Socket closed\")) {\n+                            log.info(\"Closing TcpConnection.Reader because socket is closed.\");\n+                        } else {\n+                            log.warn(\"Error in reading from socket.\", e);\n+                        }\n+                        stop();\n+                    } catch (EOFException e) {\n+                        log.info(\"Closing TcpConnection.Reader because end of input readched.\");\n+                        stop();\n+                    } catch (Exception e) {\n+                        log.warn(\"Error processing data from from server \" + name, e);\n+                        stop();\n+                    }\n+                }\n+            });\n+        }\n+\n+        @VisibleForTesting\n+        static WireCommand readCommand(InputStream in, IoBuffer buffer) throws IOException {\n+            ByteBuf header = buffer.getBuffOfSize(in, 8);\n+\n+            int t = header.getInt(0);\n+            WireCommandType type = WireCommands.getType(t);\n+            if (type == null) {\n+                throw new InvalidMessageException(\"Unknown wire command: \" + t);\n+            }\n+\n+            int length = header.getInt(4);\n+            if (length < 0 || length > WireCommands.MAX_WIRECOMMAND_SIZE) {\n+                throw new InvalidMessageException(\"Event of invalid length: \" + length);\n+            }\n+\n+            ByteBuf payload = buffer.getBuffOfSize(in, length);\n+            \n+            return type.readFrom(new EnhancedByteBufInputStream(payload), length);\n+        }\n+        \n+        public void stop() {\n+            stop.set(true);\n+            thread.shutdown();\n+            callback.connectionDropped();\n+        }\n+    }\n+    \n+    @RequiredArgsConstructor\n+    private static final class TimeoutBatch implements Runnable {\n+        private final AtomicLong token = new AtomicLong(-1);\n+        private final CommandEncoder encoder;\n+        @Override\n+        public void run() {\n+            token.set(encoder.batchTimeout(token.get()));\n+        }    \n+    }\n+\n+    public static CompletableFuture<TcpClientConnection> connect(PravegaNodeUri location, ClientConfig clientConfig, ReplyProcessor callback,\n+                                              ScheduledExecutorService executor, Runnable onClose) {\n+        return CompletableFuture.supplyAsync(() -> {\n+            Socket socket = createClientSocket(location, clientConfig); \n+            try {\n+                InputStream inputStream = socket.getInputStream();\n+                AppendBatchSizeTrackerImpl batchSizeTracker = new AppendBatchSizeTrackerImpl();\n+                ConnectionReader reader = new ConnectionReader(location.toString(), inputStream, callback, batchSizeTracker);\n+                reader.start();\n+                CommandEncoder encoder = new CommandEncoder(l -> batchSizeTracker, null, socket.getOutputStream());\n+                return new TcpClientConnection(socket, encoder, reader, location, onClose, executor);\n+            } catch (IOException e) {\n+                try {\n+                    onClose.run();\n+                    socket.close();\n+                } catch (IOException e1) {\n+                    log.warn(\"Failed to close socket while failing.\", e1);\n+                }\n+                throw Exceptions.sneakyThrow(e);\n+            }\n+        }, executor);\n+    }\n+\n+    private static TrustManagerFactory createFromCert(String trustStoreFilePath)\n+            throws CertificateException, IOException, NoSuchAlgorithmException, KeyStoreException {\n+        TrustManagerFactory factory = null;\n+        if (!Strings.isNullOrEmpty(trustStoreFilePath)) {\n+            KeyStore trustStore = CertificateUtils.createTrustStore(trustStoreFilePath);\n+\n+            factory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n+            factory.init(trustStore);\n+        }\n+        return factory;\n+    }\n+\n+    /**\n+     * Creates a socket connected to the provided endpoint. \n+     * Note that this is a sync call even though it is called in an async context. \n+     * While this is normally frowned upon, it is simply not possible to construct an SSL socket asynchronously in Java.\n+     */\n+    @SneakyThrows //Is called inside a completable future.\n+    private static Socket createClientSocket(PravegaNodeUri location, ClientConfig clientConfig) {        \n+        Socket result;\n+        if (clientConfig.isEnableTlsToSegmentStore()) {\n+            TrustManagerFactory trustMgrFactory = createFromCert(clientConfig.getTrustStore());\n+\n+            // Prepare a TLS context that uses the trust manager\n+            SSLContext tlsContext = SSLContext.getInstance(\"TLS\");\n+            tlsContext.init(null,\n+                    trustMgrFactory != null ? trustMgrFactory.getTrustManagers() : null,\n+                    null);\n+\n+            SSLSocket s = (SSLSocket) tlsContext.getSocketFactory().createSocket();\n+            // SSLSocket does not perform hostname verification by default. So, we must explicitly enable it.\n+            if (clientConfig.isValidateHostName()) {\n+                SSLParameters tlsParams = new SSLParameters();\n+                tlsParams.setEndpointIdentificationAlgorithm(\"HTTPS\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODIwNTU3Mg=="}, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 228}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTM5MzE3Mw==", "bodyText": "Thanks for the explanation.\nWhat about adding a little comment?\nThis way who will read this code won't be worried", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r449393173", "createdAt": "2020-07-03T06:10:15Z", "author": {"login": "eolivelli"}, "path": "client/src/main/java/io/pravega/client/connection/impl/TcpClientConnection.java", "diffHunk": "@@ -0,0 +1,306 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.connection.impl;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import io.netty.buffer.ByteBuf;\n+import io.pravega.client.ClientConfig;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import io.pravega.common.util.CertificateUtils;\n+import io.pravega.shared.protocol.netty.Append;\n+import io.pravega.shared.protocol.netty.AppendBatchSizeTracker;\n+import io.pravega.shared.protocol.netty.ConnectionFailedException;\n+import io.pravega.shared.protocol.netty.EnhancedByteBufInputStream;\n+import io.pravega.shared.protocol.netty.InvalidMessageException;\n+import io.pravega.shared.protocol.netty.PravegaNodeUri;\n+import io.pravega.shared.protocol.netty.Reply;\n+import io.pravega.shared.protocol.netty.ReplyProcessor;\n+import io.pravega.shared.protocol.netty.WireCommand;\n+import io.pravega.shared.protocol.netty.WireCommandType;\n+import io.pravega.shared.protocol.netty.WireCommands;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.SocketException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.CertificateException;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLParameters;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.TrustManagerFactory;\n+import lombok.RequiredArgsConstructor;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.pravega.shared.protocol.netty.AppendBatchSizeTracker.MAX_BATCH_TIME_MILLIS;\n+\n+@Slf4j\n+public class TcpClientConnection implements ClientConnection {\n+\n+    static final int TCP_BUFFER_SIZE = 256 * 1024;\n+    \n+    private final Socket socket;\n+    private final CommandEncoder encoder;\n+    private final ConnectionReader reader;\n+    private final AtomicBoolean closed = new AtomicBoolean(false);\n+    private final PravegaNodeUri location;\n+    private final Runnable onClose;\n+    private final ScheduledFuture<?> timeoutFuture;\n+   \n+    private TcpClientConnection(Socket socket, CommandEncoder encoder, ConnectionReader reader, PravegaNodeUri location,\n+                                Runnable onClose, ScheduledExecutorService executor) {\n+        this.socket = checkNotNull(socket);\n+        this.encoder = checkNotNull(encoder);\n+        this.reader = checkNotNull(reader);\n+        this.location = checkNotNull(location);\n+        this.onClose = onClose;\n+        this.timeoutFuture = executor.scheduleWithFixedDelay(new TimeoutBatch(encoder),\n+                                                             MAX_BATCH_TIME_MILLIS,\n+                                                             MAX_BATCH_TIME_MILLIS,\n+                                                             TimeUnit.MILLISECONDS);\n+    }\n+\n+    @VisibleForTesting\n+    static class ConnectionReader {\n+        \n+        private final String name;\n+        private final InputStream in;\n+        private final ReplyProcessor callback;\n+        private final ScheduledExecutorService thread;\n+        private final AppendBatchSizeTracker batchSizeTracker;\n+        private final AtomicBoolean stop = new AtomicBoolean(false);\n+\n+        public ConnectionReader(String name, InputStream in, ReplyProcessor callback,\n+                                AppendBatchSizeTracker batchSizeTracker) {\n+            this.name = name;\n+            this.in = in;\n+            this.callback = callback;\n+            this.thread = ExecutorServiceHelpers.newScheduledThreadPool(1, \"Reading from \" + name);\n+            this.batchSizeTracker = batchSizeTracker;\n+        }\n+        \n+        public void start() {\n+            thread.submit(() -> {\n+                IoBuffer buffer = new IoBuffer();\n+                while (!stop.get()) {\n+                    try {\n+                        WireCommand command = readCommand(in, buffer);\n+                        if (command instanceof WireCommands.DataAppended) {\n+                            WireCommands.DataAppended dataAppended = (WireCommands.DataAppended) command;\n+                            batchSizeTracker.recordAck(dataAppended.getEventNumber());\n+                        }\n+                        try {\n+                            callback.process((Reply) command);\n+                        } catch (Exception e) {\n+                            callback.processingFailure(e);\n+                        }\n+                    } catch (SocketException e) {\n+                        if (e.getMessage().equals(\"Socket closed\")) {\n+                            log.info(\"Closing TcpConnection.Reader because socket is closed.\");\n+                        } else {\n+                            log.warn(\"Error in reading from socket.\", e);\n+                        }\n+                        stop();\n+                    } catch (EOFException e) {\n+                        log.info(\"Closing TcpConnection.Reader because end of input readched.\");\n+                        stop();\n+                    } catch (Exception e) {\n+                        log.warn(\"Error processing data from from server \" + name, e);\n+                        stop();\n+                    }\n+                }\n+            });\n+        }\n+\n+        @VisibleForTesting\n+        static WireCommand readCommand(InputStream in, IoBuffer buffer) throws IOException {\n+            ByteBuf header = buffer.getBuffOfSize(in, 8);\n+\n+            int t = header.getInt(0);\n+            WireCommandType type = WireCommands.getType(t);\n+            if (type == null) {\n+                throw new InvalidMessageException(\"Unknown wire command: \" + t);\n+            }\n+\n+            int length = header.getInt(4);\n+            if (length < 0 || length > WireCommands.MAX_WIRECOMMAND_SIZE) {\n+                throw new InvalidMessageException(\"Event of invalid length: \" + length);\n+            }\n+\n+            ByteBuf payload = buffer.getBuffOfSize(in, length);\n+            \n+            return type.readFrom(new EnhancedByteBufInputStream(payload), length);\n+        }\n+        \n+        public void stop() {\n+            stop.set(true);\n+            thread.shutdown();\n+            callback.connectionDropped();\n+        }\n+    }\n+    \n+    @RequiredArgsConstructor\n+    private static final class TimeoutBatch implements Runnable {\n+        private final AtomicLong token = new AtomicLong(-1);\n+        private final CommandEncoder encoder;\n+        @Override\n+        public void run() {\n+            token.set(encoder.batchTimeout(token.get()));\n+        }    \n+    }\n+\n+    public static CompletableFuture<TcpClientConnection> connect(PravegaNodeUri location, ClientConfig clientConfig, ReplyProcessor callback,\n+                                              ScheduledExecutorService executor, Runnable onClose) {\n+        return CompletableFuture.supplyAsync(() -> {\n+            Socket socket = createClientSocket(location, clientConfig); \n+            try {\n+                InputStream inputStream = socket.getInputStream();\n+                AppendBatchSizeTrackerImpl batchSizeTracker = new AppendBatchSizeTrackerImpl();\n+                ConnectionReader reader = new ConnectionReader(location.toString(), inputStream, callback, batchSizeTracker);\n+                reader.start();\n+                CommandEncoder encoder = new CommandEncoder(l -> batchSizeTracker, null, socket.getOutputStream());\n+                return new TcpClientConnection(socket, encoder, reader, location, onClose, executor);\n+            } catch (IOException e) {\n+                try {\n+                    onClose.run();\n+                    socket.close();\n+                } catch (IOException e1) {\n+                    log.warn(\"Failed to close socket while failing.\", e1);\n+                }\n+                throw Exceptions.sneakyThrow(e);\n+            }\n+        }, executor);\n+    }\n+\n+    private static TrustManagerFactory createFromCert(String trustStoreFilePath)\n+            throws CertificateException, IOException, NoSuchAlgorithmException, KeyStoreException {\n+        TrustManagerFactory factory = null;\n+        if (!Strings.isNullOrEmpty(trustStoreFilePath)) {\n+            KeyStore trustStore = CertificateUtils.createTrustStore(trustStoreFilePath);\n+\n+            factory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n+            factory.init(trustStore);\n+        }\n+        return factory;\n+    }\n+\n+    /**\n+     * Creates a socket connected to the provided endpoint. \n+     * Note that this is a sync call even though it is called in an async context. \n+     * While this is normally frowned upon, it is simply not possible to construct an SSL socket asynchronously in Java.\n+     */\n+    @SneakyThrows //Is called inside a completable future.\n+    private static Socket createClientSocket(PravegaNodeUri location, ClientConfig clientConfig) {        \n+        Socket result;\n+        if (clientConfig.isEnableTlsToSegmentStore()) {\n+            TrustManagerFactory trustMgrFactory = createFromCert(clientConfig.getTrustStore());\n+\n+            // Prepare a TLS context that uses the trust manager\n+            SSLContext tlsContext = SSLContext.getInstance(\"TLS\");\n+            tlsContext.init(null,\n+                    trustMgrFactory != null ? trustMgrFactory.getTrustManagers() : null,\n+                    null);\n+\n+            SSLSocket s = (SSLSocket) tlsContext.getSocketFactory().createSocket();\n+            // SSLSocket does not perform hostname verification by default. So, we must explicitly enable it.\n+            if (clientConfig.isValidateHostName()) {\n+                SSLParameters tlsParams = new SSLParameters();\n+                tlsParams.setEndpointIdentificationAlgorithm(\"HTTPS\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODIwNTU3Mg=="}, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 228}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTQxODg0MQ==", "bodyText": "I've added the comment in the latest commit I just pushed.", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r449418841", "createdAt": "2020-07-03T07:20:59Z", "author": {"login": "ravisharda"}, "path": "client/src/main/java/io/pravega/client/connection/impl/TcpClientConnection.java", "diffHunk": "@@ -0,0 +1,306 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.connection.impl;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import io.netty.buffer.ByteBuf;\n+import io.pravega.client.ClientConfig;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import io.pravega.common.util.CertificateUtils;\n+import io.pravega.shared.protocol.netty.Append;\n+import io.pravega.shared.protocol.netty.AppendBatchSizeTracker;\n+import io.pravega.shared.protocol.netty.ConnectionFailedException;\n+import io.pravega.shared.protocol.netty.EnhancedByteBufInputStream;\n+import io.pravega.shared.protocol.netty.InvalidMessageException;\n+import io.pravega.shared.protocol.netty.PravegaNodeUri;\n+import io.pravega.shared.protocol.netty.Reply;\n+import io.pravega.shared.protocol.netty.ReplyProcessor;\n+import io.pravega.shared.protocol.netty.WireCommand;\n+import io.pravega.shared.protocol.netty.WireCommandType;\n+import io.pravega.shared.protocol.netty.WireCommands;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.SocketException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.CertificateException;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLParameters;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.TrustManagerFactory;\n+import lombok.RequiredArgsConstructor;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.pravega.shared.protocol.netty.AppendBatchSizeTracker.MAX_BATCH_TIME_MILLIS;\n+\n+@Slf4j\n+public class TcpClientConnection implements ClientConnection {\n+\n+    static final int TCP_BUFFER_SIZE = 256 * 1024;\n+    \n+    private final Socket socket;\n+    private final CommandEncoder encoder;\n+    private final ConnectionReader reader;\n+    private final AtomicBoolean closed = new AtomicBoolean(false);\n+    private final PravegaNodeUri location;\n+    private final Runnable onClose;\n+    private final ScheduledFuture<?> timeoutFuture;\n+   \n+    private TcpClientConnection(Socket socket, CommandEncoder encoder, ConnectionReader reader, PravegaNodeUri location,\n+                                Runnable onClose, ScheduledExecutorService executor) {\n+        this.socket = checkNotNull(socket);\n+        this.encoder = checkNotNull(encoder);\n+        this.reader = checkNotNull(reader);\n+        this.location = checkNotNull(location);\n+        this.onClose = onClose;\n+        this.timeoutFuture = executor.scheduleWithFixedDelay(new TimeoutBatch(encoder),\n+                                                             MAX_BATCH_TIME_MILLIS,\n+                                                             MAX_BATCH_TIME_MILLIS,\n+                                                             TimeUnit.MILLISECONDS);\n+    }\n+\n+    @VisibleForTesting\n+    static class ConnectionReader {\n+        \n+        private final String name;\n+        private final InputStream in;\n+        private final ReplyProcessor callback;\n+        private final ScheduledExecutorService thread;\n+        private final AppendBatchSizeTracker batchSizeTracker;\n+        private final AtomicBoolean stop = new AtomicBoolean(false);\n+\n+        public ConnectionReader(String name, InputStream in, ReplyProcessor callback,\n+                                AppendBatchSizeTracker batchSizeTracker) {\n+            this.name = name;\n+            this.in = in;\n+            this.callback = callback;\n+            this.thread = ExecutorServiceHelpers.newScheduledThreadPool(1, \"Reading from \" + name);\n+            this.batchSizeTracker = batchSizeTracker;\n+        }\n+        \n+        public void start() {\n+            thread.submit(() -> {\n+                IoBuffer buffer = new IoBuffer();\n+                while (!stop.get()) {\n+                    try {\n+                        WireCommand command = readCommand(in, buffer);\n+                        if (command instanceof WireCommands.DataAppended) {\n+                            WireCommands.DataAppended dataAppended = (WireCommands.DataAppended) command;\n+                            batchSizeTracker.recordAck(dataAppended.getEventNumber());\n+                        }\n+                        try {\n+                            callback.process((Reply) command);\n+                        } catch (Exception e) {\n+                            callback.processingFailure(e);\n+                        }\n+                    } catch (SocketException e) {\n+                        if (e.getMessage().equals(\"Socket closed\")) {\n+                            log.info(\"Closing TcpConnection.Reader because socket is closed.\");\n+                        } else {\n+                            log.warn(\"Error in reading from socket.\", e);\n+                        }\n+                        stop();\n+                    } catch (EOFException e) {\n+                        log.info(\"Closing TcpConnection.Reader because end of input readched.\");\n+                        stop();\n+                    } catch (Exception e) {\n+                        log.warn(\"Error processing data from from server \" + name, e);\n+                        stop();\n+                    }\n+                }\n+            });\n+        }\n+\n+        @VisibleForTesting\n+        static WireCommand readCommand(InputStream in, IoBuffer buffer) throws IOException {\n+            ByteBuf header = buffer.getBuffOfSize(in, 8);\n+\n+            int t = header.getInt(0);\n+            WireCommandType type = WireCommands.getType(t);\n+            if (type == null) {\n+                throw new InvalidMessageException(\"Unknown wire command: \" + t);\n+            }\n+\n+            int length = header.getInt(4);\n+            if (length < 0 || length > WireCommands.MAX_WIRECOMMAND_SIZE) {\n+                throw new InvalidMessageException(\"Event of invalid length: \" + length);\n+            }\n+\n+            ByteBuf payload = buffer.getBuffOfSize(in, length);\n+            \n+            return type.readFrom(new EnhancedByteBufInputStream(payload), length);\n+        }\n+        \n+        public void stop() {\n+            stop.set(true);\n+            thread.shutdown();\n+            callback.connectionDropped();\n+        }\n+    }\n+    \n+    @RequiredArgsConstructor\n+    private static final class TimeoutBatch implements Runnable {\n+        private final AtomicLong token = new AtomicLong(-1);\n+        private final CommandEncoder encoder;\n+        @Override\n+        public void run() {\n+            token.set(encoder.batchTimeout(token.get()));\n+        }    \n+    }\n+\n+    public static CompletableFuture<TcpClientConnection> connect(PravegaNodeUri location, ClientConfig clientConfig, ReplyProcessor callback,\n+                                              ScheduledExecutorService executor, Runnable onClose) {\n+        return CompletableFuture.supplyAsync(() -> {\n+            Socket socket = createClientSocket(location, clientConfig); \n+            try {\n+                InputStream inputStream = socket.getInputStream();\n+                AppendBatchSizeTrackerImpl batchSizeTracker = new AppendBatchSizeTrackerImpl();\n+                ConnectionReader reader = new ConnectionReader(location.toString(), inputStream, callback, batchSizeTracker);\n+                reader.start();\n+                CommandEncoder encoder = new CommandEncoder(l -> batchSizeTracker, null, socket.getOutputStream());\n+                return new TcpClientConnection(socket, encoder, reader, location, onClose, executor);\n+            } catch (IOException e) {\n+                try {\n+                    onClose.run();\n+                    socket.close();\n+                } catch (IOException e1) {\n+                    log.warn(\"Failed to close socket while failing.\", e1);\n+                }\n+                throw Exceptions.sneakyThrow(e);\n+            }\n+        }, executor);\n+    }\n+\n+    private static TrustManagerFactory createFromCert(String trustStoreFilePath)\n+            throws CertificateException, IOException, NoSuchAlgorithmException, KeyStoreException {\n+        TrustManagerFactory factory = null;\n+        if (!Strings.isNullOrEmpty(trustStoreFilePath)) {\n+            KeyStore trustStore = CertificateUtils.createTrustStore(trustStoreFilePath);\n+\n+            factory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n+            factory.init(trustStore);\n+        }\n+        return factory;\n+    }\n+\n+    /**\n+     * Creates a socket connected to the provided endpoint. \n+     * Note that this is a sync call even though it is called in an async context. \n+     * While this is normally frowned upon, it is simply not possible to construct an SSL socket asynchronously in Java.\n+     */\n+    @SneakyThrows //Is called inside a completable future.\n+    private static Socket createClientSocket(PravegaNodeUri location, ClientConfig clientConfig) {        \n+        Socket result;\n+        if (clientConfig.isEnableTlsToSegmentStore()) {\n+            TrustManagerFactory trustMgrFactory = createFromCert(clientConfig.getTrustStore());\n+\n+            // Prepare a TLS context that uses the trust manager\n+            SSLContext tlsContext = SSLContext.getInstance(\"TLS\");\n+            tlsContext.init(null,\n+                    trustMgrFactory != null ? trustMgrFactory.getTrustManagers() : null,\n+                    null);\n+\n+            SSLSocket s = (SSLSocket) tlsContext.getSocketFactory().createSocket();\n+            // SSLSocket does not perform hostname verification by default. So, we must explicitly enable it.\n+            if (clientConfig.isValidateHostName()) {\n+                SSLParameters tlsParams = new SSLParameters();\n+                tlsParams.setEndpointIdentificationAlgorithm(\"HTTPS\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODIwNTU3Mg=="}, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 228}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MzU5MzIzOnYy", "diffSide": "RIGHT", "path": "common/src/main/java/io/pravega/common/util/CertificateUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwODozNDo1NVrOGrcXRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwMDowNTo1NlrOGuTrWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODIwNjY2Mg==", "bodyText": "Are we using lombok @UtilityClass  ?\nhttps://projectlombok.org/features/experimental/UtilityClass", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r448206662", "createdAt": "2020-07-01T08:34:55Z", "author": {"login": "eolivelli"}, "path": "common/src/main/java/io/pravega/common/util/CertificateUtils.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.util;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.pravega.common.Exceptions;\n+import lombok.NonNull;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.X509Certificate;\n+import java.util.Collection;\n+\n+public class CertificateUtils {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIxMDA3NQ==", "bodyText": "Done", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r451210075", "createdAt": "2020-07-08T00:05:56Z", "author": {"login": "tkaitchuck"}, "path": "common/src/main/java/io/pravega/common/util/CertificateUtils.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.util;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.pravega.common.Exceptions;\n+import lombok.NonNull;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.X509Certificate;\n+import java.util.Collection;\n+\n+public class CertificateUtils {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODIwNjY2Mg=="}, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5NzYwNTk3OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/connection/impl/AppendBatchSizeTrackerImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQwODozNToyNFrOGsC_3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwMDowNjowOVrOGuTrqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODgzOTY0Nw==", "bodyText": "For low throughput rates (like 100 e/s), this can throw IllegalArgumentException due to setting as input a min value larger than the max value. We need a way to test this algorithm in isolation for a rage of values that ensures its correct operation in any situation that the client may encounter. Otherwise, we can find on client applications unexpected crashes as the ones we have seen in the benchmarks for 100 e/s.", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r448839647", "createdAt": "2020-07-02T08:35:24Z", "author": {"login": "RaulGracia"}, "path": "client/src/main/java/io/pravega/client/connection/impl/AppendBatchSizeTrackerImpl.java", "diffHunk": "@@ -73,15 +79,28 @@ public int getAppendBlockSize() {\n         if (numInflight <= 1) {\n             return 0;\n         }\n-        double appendsInMaxBatch = Math.max(1.0, MAX_BATCH_TIME_MILLIS / millisBetweenAppends.getCurrentValue());\n-        double targetAppendsOutstanding = MathHelpers.minMax(appendsOutstanding.getCurrentValue() * 0.5, 1.0,\n-                                                             appendsInMaxBatch);\n-        return (int) MathHelpers.minMax((long) (targetAppendsOutstanding * eventSize.getCurrentValue()), 0,\n-                                        MAX_BATCH_SIZE);\n+        double nanosPerAppend = nanosBetweenAppends.getCurrentValue();\n+        double appendsInMaxBatchTime = (MAX_BATCH_TIME_MILLIS * NANOS_PER_MILLI) / nanosPerAppend;\n+        double appendsInTime = Math.max(1.0, BASE_TIME_NANOS / nanosPerAppend);\n+        double appendsInBatch = MathHelpers.minMax(appendsOutstanding.getCurrentValue() * OUTSTANDING_FRACTION, appendsInTime, appendsInMaxBatchTime);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIxMDE1NA==", "bodyText": "Fixed", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r451210154", "createdAt": "2020-07-08T00:06:09Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/connection/impl/AppendBatchSizeTrackerImpl.java", "diffHunk": "@@ -73,15 +79,28 @@ public int getAppendBlockSize() {\n         if (numInflight <= 1) {\n             return 0;\n         }\n-        double appendsInMaxBatch = Math.max(1.0, MAX_BATCH_TIME_MILLIS / millisBetweenAppends.getCurrentValue());\n-        double targetAppendsOutstanding = MathHelpers.minMax(appendsOutstanding.getCurrentValue() * 0.5, 1.0,\n-                                                             appendsInMaxBatch);\n-        return (int) MathHelpers.minMax((long) (targetAppendsOutstanding * eventSize.getCurrentValue()), 0,\n-                                        MAX_BATCH_SIZE);\n+        double nanosPerAppend = nanosBetweenAppends.getCurrentValue();\n+        double appendsInMaxBatchTime = (MAX_BATCH_TIME_MILLIS * NANOS_PER_MILLI) / nanosPerAppend;\n+        double appendsInTime = Math.max(1.0, BASE_TIME_NANOS / nanosPerAppend);\n+        double appendsInBatch = MathHelpers.minMax(appendsOutstanding.getCurrentValue() * OUTSTANDING_FRACTION, appendsInTime, appendsInMaxBatchTime);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODgzOTY0Nw=="}, "originalCommit": {"oid": "d157d43e932dc0c7b85cd16ecaadc57dcf8550fd"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwMTg3MzkxOnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/connection/impl/IoBuffer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wM1QxMDozNjoxM1rOGssHDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOFQwMDoxOTozOFrOGuT5Iw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTUxMzIzMA==", "bodyText": "Can we add java docs to this method?\nAlso, does the below understanding convey how the internal heap byte arrays are eligible for GC.\nByteBuf returned can have a reference to two byte-arrays (at max) where the size of each byte-array can be at max 16MB. Both the byte arrays will be freed only when the ByteBuf.release is invoked. And in case of small \"size\" params all the byteBufs should invoke release before the byte arrays are freed.", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r449513230", "createdAt": "2020-07-03T10:36:13Z", "author": {"login": "shrids"}, "path": "client/src/main/java/io/pravega/client/connection/impl/IoBuffer.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.connection.impl;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.pravega.common.MathHelpers;\n+import io.pravega.shared.protocol.netty.WireCommands;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+\n+class IoBuffer {\n+    private int maxBufferSize = WireCommands.MAX_WIRECOMMAND_SIZE;\n+    private ByteBuffer buffer = null;\n+    \n+    private ByteBuf sliceOut(int size) {\n+        ByteBuf result = Unpooled.wrappedBuffer(buffer.array(), buffer.arrayOffset() + buffer.position(), size);\n+        buffer.position(buffer.position() + size);\n+        if (!buffer.hasRemaining()) {\n+            buffer = null;\n+        }\n+        return result;\n+    }\n+    \n+    public ByteBuf getBuffOfSize(InputStream in, int size) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "517357c54a92ae74406abef1b6708e3b86ccd4ee"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIxMzYwMw==", "bodyText": "Added a comment.\n\nByteBuf returned can have a reference to two byte-arrays (at max) where the size of each byte-array can be at max 16MB\n\nEach can be at most 8MB. In practice however one is going to be small and the other big. Because they are allocated according to what is available (which is bounded by TcpClientConnection.TCP_BUFFER_SIZE = 256kb ) and then what is requested. Because the request is bounded by 8mb this means that the 'tail' of the first buffer plus the whole of the second buffer is <= 8mb.\n\nBoth the byte arrays will be freed only when the ByteBuf.release is invoked. And in case of small \"size\" params all the byteBufs should invoke release before the byte arrays are freed.\n\nIt's actually different depending on how much data is read. If the amount read out is smaller than the size of the buffer a view of it is returned and the array is still held by this class. This means that even once release is called the buffer will not be freed. (Which is good because it still has unread data)\nIn the event that the read is larger than the buffer the whole of the buffer is passed into the returned buffer and the IoBuffer class does not hold onto it. Similarly the remaining bytes are passed in the returned buffer and not held elsewhere. In this case because the only reference to the data is inside the ByteBuf, it actually does not matter if free is called or not, because once the ByteBuf is dropped there will be no references to the data anywhere and it can be garbage collected normally.\nSo while ByteBuf is designed to let you pool and re-use memory by using reference counting, this code is not actually taking advantage of that feature and is just relying on normal garbage collection. If that were to change in the future, the code would still be correct because the code that receives the ByteBufs still calls release (according to our unit tests) so it would be OK to add such functionality.", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r451213603", "createdAt": "2020-07-08T00:19:38Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/connection/impl/IoBuffer.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.connection.impl;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.pravega.common.MathHelpers;\n+import io.pravega.shared.protocol.netty.WireCommands;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.ByteBuffer;\n+\n+class IoBuffer {\n+    private int maxBufferSize = WireCommands.MAX_WIRECOMMAND_SIZE;\n+    private ByteBuffer buffer = null;\n+    \n+    private ByteBuf sliceOut(int size) {\n+        ByteBuf result = Unpooled.wrappedBuffer(buffer.array(), buffer.arrayOffset() + buffer.position(), size);\n+        buffer.position(buffer.position() + size);\n+        if (!buffer.hasRemaining()) {\n+            buffer = null;\n+        }\n+        return result;\n+    }\n+    \n+    public ByteBuf getBuffOfSize(InputStream in, int size) throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTUxMzIzMA=="}, "originalCommit": {"oid": "517357c54a92ae74406abef1b6708e3b86ccd4ee"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyODYwNzEwOnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/connection/impl/AppendBatchSizeTrackerImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxMDoyNDo1MlrOGwiiSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxMDoyNDo1MlrOGwiiSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU1MDY2Ng==", "bodyText": "I have done a new iteration on this branch. The results are much better than before. The only point that needs to be addressed is for small events and 1 segment. In that scenario, for throughput rates between 5K and 300K events per second, the write latency seems few milliseconds higher compared to the PoC. Note that for throughput rates lower and higher than this interval, this branch has a performance equal or better compared to the PoC, which may indicate that this is related to the changes in client batching and not related to any other performance bottleneck.", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r453550666", "createdAt": "2020-07-13T10:24:52Z", "author": {"login": "RaulGracia"}, "path": "client/src/main/java/io/pravega/client/connection/impl/AppendBatchSizeTrackerImpl.java", "diffHunk": "@@ -27,19 +30,31 @@\n  * synchronous writers. Otherwise the batch size is set to the amount of data that will be written in the next\n  * {@link #MAX_BATCH_TIME_MILLIS} or half the server round trip time (whichever is less)\n  */\n-class AppendBatchSizeTrackerImpl implements AppendBatchSizeTracker {\n-    private static final int MAX_BATCH_TIME_MILLIS = 100;\n-\n+public class AppendBatchSizeTrackerImpl implements AppendBatchSizeTracker {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2776ea569a9621aeae74042841e93c76c5fcfdfb"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyODYyMDA5OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/connection/impl/CommandEncoder.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxMDoyODozMFrOGwiqEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxMDoyODozMFrOGwiqEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU1MjY1Ng==", "bodyText": "Nit: Multi -> multi. Extra space at the end.", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r453552656", "createdAt": "2020-07-13T10:28:30Z", "author": {"login": "RaulGracia"}, "path": "client/src/main/java/io/pravega/client/connection/impl/CommandEncoder.java", "diffHunk": "@@ -0,0 +1,419 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.connection.impl;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufOutputStream;\n+import io.netty.buffer.Unpooled;\n+import io.pravega.shared.metrics.MetricNotifier;\n+import io.pravega.shared.protocol.netty.Append;\n+import io.pravega.shared.protocol.netty.AppendBatchSizeTracker;\n+import io.pravega.shared.protocol.netty.InvalidMessageException;\n+import io.pravega.shared.protocol.netty.WireCommand;\n+import io.pravega.shared.protocol.netty.WireCommandType;\n+import io.pravega.shared.protocol.netty.WireCommands.AppendBlock;\n+import io.pravega.shared.protocol.netty.WireCommands.AppendBlockEnd;\n+import io.pravega.shared.protocol.netty.WireCommands.Hello;\n+import io.pravega.shared.protocol.netty.WireCommands.PartialEvent;\n+import io.pravega.shared.protocol.netty.WireCommands.SetupAppend;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.util.AbstractMap.SimpleImmutableEntry;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Function;\n+import javax.annotation.concurrent.GuardedBy;\n+import lombok.RequiredArgsConstructor;\n+import lombok.SneakyThrows;\n+import lombok.Synchronized;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import static io.pravega.shared.NameUtils.segmentTags;\n+import static io.pravega.shared.metrics.ClientMetricKeys.CLIENT_APPEND_BLOCK_SIZE;\n+import static io.pravega.shared.protocol.netty.WireCommands.TYPE_PLUS_LENGTH_SIZE;\n+import static io.pravega.shared.protocol.netty.WireCommands.TYPE_SIZE;\n+\n+@Slf4j\n+@RequiredArgsConstructor\n+public class CommandEncoder {\n+    \n+    private static final byte[] LENGTH_PLACEHOLDER = new byte[4];\n+    private final Function<Long, AppendBatchSizeTracker> appendTracker;\n+    private final MetricNotifier metricNotifier;\n+    @GuardedBy(\"$lock\")\n+    private final Map<Map.Entry<String, UUID>, Session> setupSegments = new HashMap<>();\n+    private final AtomicLong tokenCounter = new AtomicLong(0);\n+    @GuardedBy(\"$lock\")\n+    private String segmentBeingAppendedTo;\n+    @GuardedBy(\"$lock\")\n+    private UUID writerIdPerformingAppends;\n+    @GuardedBy(\"$lock\")\n+    private int currentBlockSize;\n+    @GuardedBy(\"$lock\")\n+    private int bytesLeftInBlock;\n+    @GuardedBy(\"$lock\")\n+    private final Map<UUID, Session> pendingWrites = new HashMap<>();\n+\n+    private final OutputStream output;\n+    private final ByteBuf buffer = Unpooled.buffer(1024 * 1024);\n+\n+    @RequiredArgsConstructor\n+    private final class Session {\n+        private static final int MAX_EVENTS = 500;\n+        private static final int MAX_DATA_SIZE = 1024 * 1024; // 1MB\n+        private final UUID id;\n+        private final long requestId;\n+        private final List<ByteBuf> pendingList = new ArrayList<>();\n+        private int pendingBytes = 0;\n+        private long lastEventNumber = -1L;\n+        private int eventCount = 0;\n+\n+        /**\n+         * Record the given Append to Session by tracking the last event number and number of events to write.\n+         */\n+        private void record(Append append) {\n+            lastEventNumber = append.getEventNumber();\n+            eventCount += append.getEventCount();\n+        }\n+\n+        /**\n+         * Check if session is empty or not.\n+         * @return true if there are any pending events; false otherwise.\n+         */\n+        private boolean isFree() {\n+            return eventCount == 0;\n+        }\n+\n+        /**\n+         * Queue the Append data to Session' list.\n+         *\n+         * @param data  data bytes.\n+         * @param out   Network channel buffer.\n+         */\n+        private void write(ByteBuf data) {\n+            pendingWrites.putIfAbsent(id, this);\n+            if (data.readableBytes() > 0) {\n+                pendingBytes += data.readableBytes();\n+                pendingList.add(data);\n+            }\n+            conditionalFlush();\n+        }\n+\n+        /**\n+         * Check the overflow condition and flush if required.\n+         *\n+         * @param out   Network channel buffer.\n+         */\n+        private void conditionalFlush() {\n+            if ((pendingBytes > MAX_DATA_SIZE) || (eventCount > MAX_EVENTS)) {\n+                breakCurrentAppend();\n+                flushToBuffer();\n+            }\n+        }\n+\n+       /**\n+        * Write/flush session's data to network channel.\n+        *\n+        * @param out   Network channel buffer.\n+        */\n+       private void flushToBuffer() {\n+            if (!isFree()) {\n+                pendingWrites.remove(id);\n+                writeMessage(new AppendBlock(id), pendingBytes);\n+                if (pendingBytes > 0) {\n+                    pendingList.forEach(buffer::writeBytes);\n+                    pendingList.clear();\n+                }\n+                flushToBuffer(pendingBytes, null);\n+                pendingBytes = 0;\n+            }\n+        }\n+\n+        /**\n+         * Write/flush given data to network channel by writing the Append block End containing the given/input data\n+         * and indicating the size of previous append block data.\n+         *\n+         * @param sizeOfWholeEvents Size of data followed by this append block end.\n+         * @param data              Remaining data\n+         */\n+        private void flushToBuffer(int sizeOfWholeEvents, ByteBuf data) {\n+            writeMessage(new AppendBlockEnd(id, sizeOfWholeEvents, data, eventCount, lastEventNumber, requestId), buffer);\n+            eventCount = 0;\n+        }\n+    }\n+    \n+    /**\n+     * Write/flush Multi session's buffered data to network channel buffer by iterating over all the pending sessions .", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2776ea569a9621aeae74042841e93c76c5fcfdfb"}, "originalPosition": 159}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyODkyODg5OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/connection/impl/TcpClientConnection.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxMjowMzo0N1rOGwllRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNzoyMDoxOVrOGwyL2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzYwMDU4Mg==", "bodyText": "here we can use ByteBuf and recycle it.\nUsing the ByteBufAllocator is the simpler way.\nit will make code simpler, without the need of the IoBuffer class", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r453600582", "createdAt": "2020-07-13T12:03:47Z", "author": {"login": "eolivelli"}, "path": "client/src/main/java/io/pravega/client/connection/impl/TcpClientConnection.java", "diffHunk": "@@ -0,0 +1,320 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.connection.impl;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import io.netty.buffer.ByteBuf;\n+import io.pravega.client.ClientConfig;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import io.pravega.common.util.CertificateUtils;\n+import io.pravega.shared.protocol.netty.Append;\n+import io.pravega.shared.protocol.netty.AppendBatchSizeTracker;\n+import io.pravega.shared.protocol.netty.ConnectionFailedException;\n+import io.pravega.shared.protocol.netty.EnhancedByteBufInputStream;\n+import io.pravega.shared.protocol.netty.InvalidMessageException;\n+import io.pravega.shared.protocol.netty.PravegaNodeUri;\n+import io.pravega.shared.protocol.netty.Reply;\n+import io.pravega.shared.protocol.netty.ReplyProcessor;\n+import io.pravega.shared.protocol.netty.WireCommand;\n+import io.pravega.shared.protocol.netty.WireCommandType;\n+import io.pravega.shared.protocol.netty.WireCommands;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.SocketException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.CertificateException;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLParameters;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.TrustManagerFactory;\n+import lombok.RequiredArgsConstructor;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.pravega.shared.protocol.netty.AppendBatchSizeTracker.MAX_BATCH_TIME_MILLIS;\n+\n+@Slf4j\n+public class TcpClientConnection implements ClientConnection {\n+\n+    static final int TCP_BUFFER_SIZE = 256 * 1024;\n+    \n+    private final Socket socket;\n+    private final CommandEncoder encoder;\n+    private final ConnectionReader reader;\n+    private final AtomicBoolean closed = new AtomicBoolean(false);\n+    private final PravegaNodeUri location;\n+    private final Runnable onClose;\n+    private final ScheduledFuture<?> timeoutFuture;\n+   \n+    private TcpClientConnection(Socket socket, CommandEncoder encoder, ConnectionReader reader, PravegaNodeUri location,\n+                                Runnable onClose, ScheduledExecutorService executor) {\n+        this.socket = checkNotNull(socket);\n+        this.encoder = checkNotNull(encoder);\n+        this.reader = checkNotNull(reader);\n+        this.location = checkNotNull(location);\n+        this.onClose = onClose;\n+        this.timeoutFuture = executor.scheduleWithFixedDelay(new TimeoutBatch(encoder),\n+                                                             MAX_BATCH_TIME_MILLIS,\n+                                                             MAX_BATCH_TIME_MILLIS,\n+                                                             TimeUnit.MILLISECONDS);\n+    }\n+\n+    @VisibleForTesting\n+    static class ConnectionReader implements Runnable {\n+        static final ThreadFactory THREAD_FACTORY = ExecutorServiceHelpers.getThreadFactory(\"ClientSocketReaders\", (Thread.NORM_PRIORITY + Thread.MAX_PRIORITY) / 2);\n+        \n+        private final String name;\n+        private final InputStream in;\n+        private final ReplyProcessor callback;\n+        private final Thread thread;\n+        private final AppendBatchSizeTracker batchSizeTracker;\n+        private final AtomicBoolean stop = new AtomicBoolean(false);\n+\n+        public ConnectionReader(String name, InputStream in, ReplyProcessor callback,\n+                                AppendBatchSizeTracker batchSizeTracker) {\n+            this.name = name;\n+            this.in = in;\n+            this.callback = callback;\n+            this.thread = THREAD_FACTORY.newThread(this);\n+            this.batchSizeTracker = batchSizeTracker;\n+        }\n+        \n+        public void start() {\n+            thread.start();\n+        }\n+        \n+        public void run() {\n+            IoBuffer buffer = new IoBuffer();\n+            while (!stop.get()) {\n+                try {\n+                    WireCommand command = readCommand(in, buffer);\n+                    if (command instanceof WireCommands.DataAppended) {\n+                        WireCommands.DataAppended dataAppended = (WireCommands.DataAppended) command;\n+                        batchSizeTracker.recordAck(dataAppended.getEventNumber());\n+                    }\n+                    try {\n+                        callback.process((Reply) command);\n+                    } catch (Exception e) {\n+                        callback.processingFailure(e);\n+                    }\n+                } catch (SocketException e) {\n+                    if (e.getMessage().equals(\"Socket closed\")) {\n+                        log.info(\"Closing TcpConnection.Reader because socket is closed.\");\n+                    } else {\n+                        log.warn(\"Error in reading from socket.\", e);\n+                    }\n+                    stop();\n+                } catch (EOFException e) {\n+                    log.info(\"Closing TcpConnection.Reader because end of input readched.\");\n+                    stop();\n+                } catch (Exception e) {\n+                    log.warn(\"Error processing data from from server \" + name, e);\n+                    stop();\n+                }\n+            }\n+        }\n+\n+        @VisibleForTesting\n+        static WireCommand readCommand(InputStream in, IoBuffer buffer) throws IOException {\n+            ByteBuf header = buffer.getBuffOfSize(in, 8);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2776ea569a9621aeae74042841e93c76c5fcfdfb"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzgwNDQ5Nw==", "bodyText": "My benchmarks showed that doing that was slower.", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r453804497", "createdAt": "2020-07-13T17:16:05Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/connection/impl/TcpClientConnection.java", "diffHunk": "@@ -0,0 +1,320 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.connection.impl;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import io.netty.buffer.ByteBuf;\n+import io.pravega.client.ClientConfig;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import io.pravega.common.util.CertificateUtils;\n+import io.pravega.shared.protocol.netty.Append;\n+import io.pravega.shared.protocol.netty.AppendBatchSizeTracker;\n+import io.pravega.shared.protocol.netty.ConnectionFailedException;\n+import io.pravega.shared.protocol.netty.EnhancedByteBufInputStream;\n+import io.pravega.shared.protocol.netty.InvalidMessageException;\n+import io.pravega.shared.protocol.netty.PravegaNodeUri;\n+import io.pravega.shared.protocol.netty.Reply;\n+import io.pravega.shared.protocol.netty.ReplyProcessor;\n+import io.pravega.shared.protocol.netty.WireCommand;\n+import io.pravega.shared.protocol.netty.WireCommandType;\n+import io.pravega.shared.protocol.netty.WireCommands;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.SocketException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.CertificateException;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLParameters;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.TrustManagerFactory;\n+import lombok.RequiredArgsConstructor;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.pravega.shared.protocol.netty.AppendBatchSizeTracker.MAX_BATCH_TIME_MILLIS;\n+\n+@Slf4j\n+public class TcpClientConnection implements ClientConnection {\n+\n+    static final int TCP_BUFFER_SIZE = 256 * 1024;\n+    \n+    private final Socket socket;\n+    private final CommandEncoder encoder;\n+    private final ConnectionReader reader;\n+    private final AtomicBoolean closed = new AtomicBoolean(false);\n+    private final PravegaNodeUri location;\n+    private final Runnable onClose;\n+    private final ScheduledFuture<?> timeoutFuture;\n+   \n+    private TcpClientConnection(Socket socket, CommandEncoder encoder, ConnectionReader reader, PravegaNodeUri location,\n+                                Runnable onClose, ScheduledExecutorService executor) {\n+        this.socket = checkNotNull(socket);\n+        this.encoder = checkNotNull(encoder);\n+        this.reader = checkNotNull(reader);\n+        this.location = checkNotNull(location);\n+        this.onClose = onClose;\n+        this.timeoutFuture = executor.scheduleWithFixedDelay(new TimeoutBatch(encoder),\n+                                                             MAX_BATCH_TIME_MILLIS,\n+                                                             MAX_BATCH_TIME_MILLIS,\n+                                                             TimeUnit.MILLISECONDS);\n+    }\n+\n+    @VisibleForTesting\n+    static class ConnectionReader implements Runnable {\n+        static final ThreadFactory THREAD_FACTORY = ExecutorServiceHelpers.getThreadFactory(\"ClientSocketReaders\", (Thread.NORM_PRIORITY + Thread.MAX_PRIORITY) / 2);\n+        \n+        private final String name;\n+        private final InputStream in;\n+        private final ReplyProcessor callback;\n+        private final Thread thread;\n+        private final AppendBatchSizeTracker batchSizeTracker;\n+        private final AtomicBoolean stop = new AtomicBoolean(false);\n+\n+        public ConnectionReader(String name, InputStream in, ReplyProcessor callback,\n+                                AppendBatchSizeTracker batchSizeTracker) {\n+            this.name = name;\n+            this.in = in;\n+            this.callback = callback;\n+            this.thread = THREAD_FACTORY.newThread(this);\n+            this.batchSizeTracker = batchSizeTracker;\n+        }\n+        \n+        public void start() {\n+            thread.start();\n+        }\n+        \n+        public void run() {\n+            IoBuffer buffer = new IoBuffer();\n+            while (!stop.get()) {\n+                try {\n+                    WireCommand command = readCommand(in, buffer);\n+                    if (command instanceof WireCommands.DataAppended) {\n+                        WireCommands.DataAppended dataAppended = (WireCommands.DataAppended) command;\n+                        batchSizeTracker.recordAck(dataAppended.getEventNumber());\n+                    }\n+                    try {\n+                        callback.process((Reply) command);\n+                    } catch (Exception e) {\n+                        callback.processingFailure(e);\n+                    }\n+                } catch (SocketException e) {\n+                    if (e.getMessage().equals(\"Socket closed\")) {\n+                        log.info(\"Closing TcpConnection.Reader because socket is closed.\");\n+                    } else {\n+                        log.warn(\"Error in reading from socket.\", e);\n+                    }\n+                    stop();\n+                } catch (EOFException e) {\n+                    log.info(\"Closing TcpConnection.Reader because end of input readched.\");\n+                    stop();\n+                } catch (Exception e) {\n+                    log.warn(\"Error processing data from from server \" + name, e);\n+                    stop();\n+                }\n+            }\n+        }\n+\n+        @VisibleForTesting\n+        static WireCommand readCommand(InputStream in, IoBuffer buffer) throws IOException {\n+            ByteBuf header = buffer.getBuffOfSize(in, 8);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzYwMDU4Mg=="}, "originalCommit": {"oid": "2776ea569a9621aeae74042841e93c76c5fcfdfb"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzgwNzA2Nw==", "bodyText": "Interesting.\nMaybe the problem for netty is that we passing thru a generic InputStream and probably we can't leverage zero copy features.\nIf we had access to the SocketChannel maybe we could skip the copies to the heap.\nBtw it is something we can do in some follow up work.\nI am fine with this approach currently", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r453807067", "createdAt": "2020-07-13T17:20:19Z", "author": {"login": "eolivelli"}, "path": "client/src/main/java/io/pravega/client/connection/impl/TcpClientConnection.java", "diffHunk": "@@ -0,0 +1,320 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.connection.impl;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import io.netty.buffer.ByteBuf;\n+import io.pravega.client.ClientConfig;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import io.pravega.common.util.CertificateUtils;\n+import io.pravega.shared.protocol.netty.Append;\n+import io.pravega.shared.protocol.netty.AppendBatchSizeTracker;\n+import io.pravega.shared.protocol.netty.ConnectionFailedException;\n+import io.pravega.shared.protocol.netty.EnhancedByteBufInputStream;\n+import io.pravega.shared.protocol.netty.InvalidMessageException;\n+import io.pravega.shared.protocol.netty.PravegaNodeUri;\n+import io.pravega.shared.protocol.netty.Reply;\n+import io.pravega.shared.protocol.netty.ReplyProcessor;\n+import io.pravega.shared.protocol.netty.WireCommand;\n+import io.pravega.shared.protocol.netty.WireCommandType;\n+import io.pravega.shared.protocol.netty.WireCommands;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.SocketException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.CertificateException;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLParameters;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.TrustManagerFactory;\n+import lombok.RequiredArgsConstructor;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.pravega.shared.protocol.netty.AppendBatchSizeTracker.MAX_BATCH_TIME_MILLIS;\n+\n+@Slf4j\n+public class TcpClientConnection implements ClientConnection {\n+\n+    static final int TCP_BUFFER_SIZE = 256 * 1024;\n+    \n+    private final Socket socket;\n+    private final CommandEncoder encoder;\n+    private final ConnectionReader reader;\n+    private final AtomicBoolean closed = new AtomicBoolean(false);\n+    private final PravegaNodeUri location;\n+    private final Runnable onClose;\n+    private final ScheduledFuture<?> timeoutFuture;\n+   \n+    private TcpClientConnection(Socket socket, CommandEncoder encoder, ConnectionReader reader, PravegaNodeUri location,\n+                                Runnable onClose, ScheduledExecutorService executor) {\n+        this.socket = checkNotNull(socket);\n+        this.encoder = checkNotNull(encoder);\n+        this.reader = checkNotNull(reader);\n+        this.location = checkNotNull(location);\n+        this.onClose = onClose;\n+        this.timeoutFuture = executor.scheduleWithFixedDelay(new TimeoutBatch(encoder),\n+                                                             MAX_BATCH_TIME_MILLIS,\n+                                                             MAX_BATCH_TIME_MILLIS,\n+                                                             TimeUnit.MILLISECONDS);\n+    }\n+\n+    @VisibleForTesting\n+    static class ConnectionReader implements Runnable {\n+        static final ThreadFactory THREAD_FACTORY = ExecutorServiceHelpers.getThreadFactory(\"ClientSocketReaders\", (Thread.NORM_PRIORITY + Thread.MAX_PRIORITY) / 2);\n+        \n+        private final String name;\n+        private final InputStream in;\n+        private final ReplyProcessor callback;\n+        private final Thread thread;\n+        private final AppendBatchSizeTracker batchSizeTracker;\n+        private final AtomicBoolean stop = new AtomicBoolean(false);\n+\n+        public ConnectionReader(String name, InputStream in, ReplyProcessor callback,\n+                                AppendBatchSizeTracker batchSizeTracker) {\n+            this.name = name;\n+            this.in = in;\n+            this.callback = callback;\n+            this.thread = THREAD_FACTORY.newThread(this);\n+            this.batchSizeTracker = batchSizeTracker;\n+        }\n+        \n+        public void start() {\n+            thread.start();\n+        }\n+        \n+        public void run() {\n+            IoBuffer buffer = new IoBuffer();\n+            while (!stop.get()) {\n+                try {\n+                    WireCommand command = readCommand(in, buffer);\n+                    if (command instanceof WireCommands.DataAppended) {\n+                        WireCommands.DataAppended dataAppended = (WireCommands.DataAppended) command;\n+                        batchSizeTracker.recordAck(dataAppended.getEventNumber());\n+                    }\n+                    try {\n+                        callback.process((Reply) command);\n+                    } catch (Exception e) {\n+                        callback.processingFailure(e);\n+                    }\n+                } catch (SocketException e) {\n+                    if (e.getMessage().equals(\"Socket closed\")) {\n+                        log.info(\"Closing TcpConnection.Reader because socket is closed.\");\n+                    } else {\n+                        log.warn(\"Error in reading from socket.\", e);\n+                    }\n+                    stop();\n+                } catch (EOFException e) {\n+                    log.info(\"Closing TcpConnection.Reader because end of input readched.\");\n+                    stop();\n+                } catch (Exception e) {\n+                    log.warn(\"Error processing data from from server \" + name, e);\n+                    stop();\n+                }\n+            }\n+        }\n+\n+        @VisibleForTesting\n+        static WireCommand readCommand(InputStream in, IoBuffer buffer) throws IOException {\n+            ByteBuf header = buffer.getBuffOfSize(in, 8);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzYwMDU4Mg=="}, "originalCommit": {"oid": "2776ea569a9621aeae74042841e93c76c5fcfdfb"}, "originalPosition": 141}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgyODkzMjE4OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/connection/impl/TcpClientConnection.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxMjowNDo1MlrOGwlnXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNzoyMToxNFrOGwyOOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzYwMTExNw==", "bodyText": "the same here.\nwe can ask Netty to take the buffer from its pool (as we already know the length we also won't fall into buffer reallocations).\nNetty will be able to manage direct memory for us.\nand EnhancedByteBufInputStream will call release on \"close()\" so Netty will be able to recycle the buffer/memory.\nIt would be nice to make EnhancedByteBufInputStream recyclable in order to save another object allocation at every command unmashalling.", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r453601117", "createdAt": "2020-07-13T12:04:52Z", "author": {"login": "eolivelli"}, "path": "client/src/main/java/io/pravega/client/connection/impl/TcpClientConnection.java", "diffHunk": "@@ -0,0 +1,320 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.connection.impl;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import io.netty.buffer.ByteBuf;\n+import io.pravega.client.ClientConfig;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import io.pravega.common.util.CertificateUtils;\n+import io.pravega.shared.protocol.netty.Append;\n+import io.pravega.shared.protocol.netty.AppendBatchSizeTracker;\n+import io.pravega.shared.protocol.netty.ConnectionFailedException;\n+import io.pravega.shared.protocol.netty.EnhancedByteBufInputStream;\n+import io.pravega.shared.protocol.netty.InvalidMessageException;\n+import io.pravega.shared.protocol.netty.PravegaNodeUri;\n+import io.pravega.shared.protocol.netty.Reply;\n+import io.pravega.shared.protocol.netty.ReplyProcessor;\n+import io.pravega.shared.protocol.netty.WireCommand;\n+import io.pravega.shared.protocol.netty.WireCommandType;\n+import io.pravega.shared.protocol.netty.WireCommands;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.SocketException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.CertificateException;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLParameters;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.TrustManagerFactory;\n+import lombok.RequiredArgsConstructor;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.pravega.shared.protocol.netty.AppendBatchSizeTracker.MAX_BATCH_TIME_MILLIS;\n+\n+@Slf4j\n+public class TcpClientConnection implements ClientConnection {\n+\n+    static final int TCP_BUFFER_SIZE = 256 * 1024;\n+    \n+    private final Socket socket;\n+    private final CommandEncoder encoder;\n+    private final ConnectionReader reader;\n+    private final AtomicBoolean closed = new AtomicBoolean(false);\n+    private final PravegaNodeUri location;\n+    private final Runnable onClose;\n+    private final ScheduledFuture<?> timeoutFuture;\n+   \n+    private TcpClientConnection(Socket socket, CommandEncoder encoder, ConnectionReader reader, PravegaNodeUri location,\n+                                Runnable onClose, ScheduledExecutorService executor) {\n+        this.socket = checkNotNull(socket);\n+        this.encoder = checkNotNull(encoder);\n+        this.reader = checkNotNull(reader);\n+        this.location = checkNotNull(location);\n+        this.onClose = onClose;\n+        this.timeoutFuture = executor.scheduleWithFixedDelay(new TimeoutBatch(encoder),\n+                                                             MAX_BATCH_TIME_MILLIS,\n+                                                             MAX_BATCH_TIME_MILLIS,\n+                                                             TimeUnit.MILLISECONDS);\n+    }\n+\n+    @VisibleForTesting\n+    static class ConnectionReader implements Runnable {\n+        static final ThreadFactory THREAD_FACTORY = ExecutorServiceHelpers.getThreadFactory(\"ClientSocketReaders\", (Thread.NORM_PRIORITY + Thread.MAX_PRIORITY) / 2);\n+        \n+        private final String name;\n+        private final InputStream in;\n+        private final ReplyProcessor callback;\n+        private final Thread thread;\n+        private final AppendBatchSizeTracker batchSizeTracker;\n+        private final AtomicBoolean stop = new AtomicBoolean(false);\n+\n+        public ConnectionReader(String name, InputStream in, ReplyProcessor callback,\n+                                AppendBatchSizeTracker batchSizeTracker) {\n+            this.name = name;\n+            this.in = in;\n+            this.callback = callback;\n+            this.thread = THREAD_FACTORY.newThread(this);\n+            this.batchSizeTracker = batchSizeTracker;\n+        }\n+        \n+        public void start() {\n+            thread.start();\n+        }\n+        \n+        public void run() {\n+            IoBuffer buffer = new IoBuffer();\n+            while (!stop.get()) {\n+                try {\n+                    WireCommand command = readCommand(in, buffer);\n+                    if (command instanceof WireCommands.DataAppended) {\n+                        WireCommands.DataAppended dataAppended = (WireCommands.DataAppended) command;\n+                        batchSizeTracker.recordAck(dataAppended.getEventNumber());\n+                    }\n+                    try {\n+                        callback.process((Reply) command);\n+                    } catch (Exception e) {\n+                        callback.processingFailure(e);\n+                    }\n+                } catch (SocketException e) {\n+                    if (e.getMessage().equals(\"Socket closed\")) {\n+                        log.info(\"Closing TcpConnection.Reader because socket is closed.\");\n+                    } else {\n+                        log.warn(\"Error in reading from socket.\", e);\n+                    }\n+                    stop();\n+                } catch (EOFException e) {\n+                    log.info(\"Closing TcpConnection.Reader because end of input readched.\");\n+                    stop();\n+                } catch (Exception e) {\n+                    log.warn(\"Error processing data from from server \" + name, e);\n+                    stop();\n+                }\n+            }\n+        }\n+\n+        @VisibleForTesting\n+        static WireCommand readCommand(InputStream in, IoBuffer buffer) throws IOException {\n+            ByteBuf header = buffer.getBuffOfSize(in, 8);\n+\n+            int t = header.getInt(0);\n+            WireCommandType type = WireCommands.getType(t);\n+            if (type == null) {\n+                throw new InvalidMessageException(\"Unknown wire command: \" + t);\n+            }\n+\n+            int length = header.getInt(4);\n+            if (length < 0 || length > WireCommands.MAX_WIRECOMMAND_SIZE) {\n+                throw new InvalidMessageException(\"Event of invalid length: \" + length);\n+            }\n+\n+            ByteBuf payload = buffer.getBuffOfSize(in, length);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2776ea569a9621aeae74042841e93c76c5fcfdfb"}, "originalPosition": 154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzgwNjc3Mw==", "bodyText": "I don't want to add further dependency on netty functionality here given that I am trying to remove it all together: #4923\nIt may make sense to add a dependency on the same buffer manager we use on the server side which we benchmarked as being faster than netty's version. That change however is large enough in it's own right that I don't want to lump it into this PR which is already quite large. I agree the above is not perfect it shows large perf improvements over the current master.", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r453806773", "createdAt": "2020-07-13T17:19:51Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/connection/impl/TcpClientConnection.java", "diffHunk": "@@ -0,0 +1,320 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.connection.impl;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import io.netty.buffer.ByteBuf;\n+import io.pravega.client.ClientConfig;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import io.pravega.common.util.CertificateUtils;\n+import io.pravega.shared.protocol.netty.Append;\n+import io.pravega.shared.protocol.netty.AppendBatchSizeTracker;\n+import io.pravega.shared.protocol.netty.ConnectionFailedException;\n+import io.pravega.shared.protocol.netty.EnhancedByteBufInputStream;\n+import io.pravega.shared.protocol.netty.InvalidMessageException;\n+import io.pravega.shared.protocol.netty.PravegaNodeUri;\n+import io.pravega.shared.protocol.netty.Reply;\n+import io.pravega.shared.protocol.netty.ReplyProcessor;\n+import io.pravega.shared.protocol.netty.WireCommand;\n+import io.pravega.shared.protocol.netty.WireCommandType;\n+import io.pravega.shared.protocol.netty.WireCommands;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.SocketException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.CertificateException;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLParameters;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.TrustManagerFactory;\n+import lombok.RequiredArgsConstructor;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.pravega.shared.protocol.netty.AppendBatchSizeTracker.MAX_BATCH_TIME_MILLIS;\n+\n+@Slf4j\n+public class TcpClientConnection implements ClientConnection {\n+\n+    static final int TCP_BUFFER_SIZE = 256 * 1024;\n+    \n+    private final Socket socket;\n+    private final CommandEncoder encoder;\n+    private final ConnectionReader reader;\n+    private final AtomicBoolean closed = new AtomicBoolean(false);\n+    private final PravegaNodeUri location;\n+    private final Runnable onClose;\n+    private final ScheduledFuture<?> timeoutFuture;\n+   \n+    private TcpClientConnection(Socket socket, CommandEncoder encoder, ConnectionReader reader, PravegaNodeUri location,\n+                                Runnable onClose, ScheduledExecutorService executor) {\n+        this.socket = checkNotNull(socket);\n+        this.encoder = checkNotNull(encoder);\n+        this.reader = checkNotNull(reader);\n+        this.location = checkNotNull(location);\n+        this.onClose = onClose;\n+        this.timeoutFuture = executor.scheduleWithFixedDelay(new TimeoutBatch(encoder),\n+                                                             MAX_BATCH_TIME_MILLIS,\n+                                                             MAX_BATCH_TIME_MILLIS,\n+                                                             TimeUnit.MILLISECONDS);\n+    }\n+\n+    @VisibleForTesting\n+    static class ConnectionReader implements Runnable {\n+        static final ThreadFactory THREAD_FACTORY = ExecutorServiceHelpers.getThreadFactory(\"ClientSocketReaders\", (Thread.NORM_PRIORITY + Thread.MAX_PRIORITY) / 2);\n+        \n+        private final String name;\n+        private final InputStream in;\n+        private final ReplyProcessor callback;\n+        private final Thread thread;\n+        private final AppendBatchSizeTracker batchSizeTracker;\n+        private final AtomicBoolean stop = new AtomicBoolean(false);\n+\n+        public ConnectionReader(String name, InputStream in, ReplyProcessor callback,\n+                                AppendBatchSizeTracker batchSizeTracker) {\n+            this.name = name;\n+            this.in = in;\n+            this.callback = callback;\n+            this.thread = THREAD_FACTORY.newThread(this);\n+            this.batchSizeTracker = batchSizeTracker;\n+        }\n+        \n+        public void start() {\n+            thread.start();\n+        }\n+        \n+        public void run() {\n+            IoBuffer buffer = new IoBuffer();\n+            while (!stop.get()) {\n+                try {\n+                    WireCommand command = readCommand(in, buffer);\n+                    if (command instanceof WireCommands.DataAppended) {\n+                        WireCommands.DataAppended dataAppended = (WireCommands.DataAppended) command;\n+                        batchSizeTracker.recordAck(dataAppended.getEventNumber());\n+                    }\n+                    try {\n+                        callback.process((Reply) command);\n+                    } catch (Exception e) {\n+                        callback.processingFailure(e);\n+                    }\n+                } catch (SocketException e) {\n+                    if (e.getMessage().equals(\"Socket closed\")) {\n+                        log.info(\"Closing TcpConnection.Reader because socket is closed.\");\n+                    } else {\n+                        log.warn(\"Error in reading from socket.\", e);\n+                    }\n+                    stop();\n+                } catch (EOFException e) {\n+                    log.info(\"Closing TcpConnection.Reader because end of input readched.\");\n+                    stop();\n+                } catch (Exception e) {\n+                    log.warn(\"Error processing data from from server \" + name, e);\n+                    stop();\n+                }\n+            }\n+        }\n+\n+        @VisibleForTesting\n+        static WireCommand readCommand(InputStream in, IoBuffer buffer) throws IOException {\n+            ByteBuf header = buffer.getBuffOfSize(in, 8);\n+\n+            int t = header.getInt(0);\n+            WireCommandType type = WireCommands.getType(t);\n+            if (type == null) {\n+                throw new InvalidMessageException(\"Unknown wire command: \" + t);\n+            }\n+\n+            int length = header.getInt(4);\n+            if (length < 0 || length > WireCommands.MAX_WIRECOMMAND_SIZE) {\n+                throw new InvalidMessageException(\"Event of invalid length: \" + length);\n+            }\n+\n+            ByteBuf payload = buffer.getBuffOfSize(in, length);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzYwMTExNw=="}, "originalCommit": {"oid": "2776ea569a9621aeae74042841e93c76c5fcfdfb"}, "originalPosition": 154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzgwNzY3Mg==", "bodyText": "Agreed", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r453807672", "createdAt": "2020-07-13T17:21:14Z", "author": {"login": "eolivelli"}, "path": "client/src/main/java/io/pravega/client/connection/impl/TcpClientConnection.java", "diffHunk": "@@ -0,0 +1,320 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.connection.impl;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import io.netty.buffer.ByteBuf;\n+import io.pravega.client.ClientConfig;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import io.pravega.common.util.CertificateUtils;\n+import io.pravega.shared.protocol.netty.Append;\n+import io.pravega.shared.protocol.netty.AppendBatchSizeTracker;\n+import io.pravega.shared.protocol.netty.ConnectionFailedException;\n+import io.pravega.shared.protocol.netty.EnhancedByteBufInputStream;\n+import io.pravega.shared.protocol.netty.InvalidMessageException;\n+import io.pravega.shared.protocol.netty.PravegaNodeUri;\n+import io.pravega.shared.protocol.netty.Reply;\n+import io.pravega.shared.protocol.netty.ReplyProcessor;\n+import io.pravega.shared.protocol.netty.WireCommand;\n+import io.pravega.shared.protocol.netty.WireCommandType;\n+import io.pravega.shared.protocol.netty.WireCommands;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.SocketException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.CertificateException;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLParameters;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.TrustManagerFactory;\n+import lombok.RequiredArgsConstructor;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.pravega.shared.protocol.netty.AppendBatchSizeTracker.MAX_BATCH_TIME_MILLIS;\n+\n+@Slf4j\n+public class TcpClientConnection implements ClientConnection {\n+\n+    static final int TCP_BUFFER_SIZE = 256 * 1024;\n+    \n+    private final Socket socket;\n+    private final CommandEncoder encoder;\n+    private final ConnectionReader reader;\n+    private final AtomicBoolean closed = new AtomicBoolean(false);\n+    private final PravegaNodeUri location;\n+    private final Runnable onClose;\n+    private final ScheduledFuture<?> timeoutFuture;\n+   \n+    private TcpClientConnection(Socket socket, CommandEncoder encoder, ConnectionReader reader, PravegaNodeUri location,\n+                                Runnable onClose, ScheduledExecutorService executor) {\n+        this.socket = checkNotNull(socket);\n+        this.encoder = checkNotNull(encoder);\n+        this.reader = checkNotNull(reader);\n+        this.location = checkNotNull(location);\n+        this.onClose = onClose;\n+        this.timeoutFuture = executor.scheduleWithFixedDelay(new TimeoutBatch(encoder),\n+                                                             MAX_BATCH_TIME_MILLIS,\n+                                                             MAX_BATCH_TIME_MILLIS,\n+                                                             TimeUnit.MILLISECONDS);\n+    }\n+\n+    @VisibleForTesting\n+    static class ConnectionReader implements Runnable {\n+        static final ThreadFactory THREAD_FACTORY = ExecutorServiceHelpers.getThreadFactory(\"ClientSocketReaders\", (Thread.NORM_PRIORITY + Thread.MAX_PRIORITY) / 2);\n+        \n+        private final String name;\n+        private final InputStream in;\n+        private final ReplyProcessor callback;\n+        private final Thread thread;\n+        private final AppendBatchSizeTracker batchSizeTracker;\n+        private final AtomicBoolean stop = new AtomicBoolean(false);\n+\n+        public ConnectionReader(String name, InputStream in, ReplyProcessor callback,\n+                                AppendBatchSizeTracker batchSizeTracker) {\n+            this.name = name;\n+            this.in = in;\n+            this.callback = callback;\n+            this.thread = THREAD_FACTORY.newThread(this);\n+            this.batchSizeTracker = batchSizeTracker;\n+        }\n+        \n+        public void start() {\n+            thread.start();\n+        }\n+        \n+        public void run() {\n+            IoBuffer buffer = new IoBuffer();\n+            while (!stop.get()) {\n+                try {\n+                    WireCommand command = readCommand(in, buffer);\n+                    if (command instanceof WireCommands.DataAppended) {\n+                        WireCommands.DataAppended dataAppended = (WireCommands.DataAppended) command;\n+                        batchSizeTracker.recordAck(dataAppended.getEventNumber());\n+                    }\n+                    try {\n+                        callback.process((Reply) command);\n+                    } catch (Exception e) {\n+                        callback.processingFailure(e);\n+                    }\n+                } catch (SocketException e) {\n+                    if (e.getMessage().equals(\"Socket closed\")) {\n+                        log.info(\"Closing TcpConnection.Reader because socket is closed.\");\n+                    } else {\n+                        log.warn(\"Error in reading from socket.\", e);\n+                    }\n+                    stop();\n+                } catch (EOFException e) {\n+                    log.info(\"Closing TcpConnection.Reader because end of input readched.\");\n+                    stop();\n+                } catch (Exception e) {\n+                    log.warn(\"Error processing data from from server \" + name, e);\n+                    stop();\n+                }\n+            }\n+        }\n+\n+        @VisibleForTesting\n+        static WireCommand readCommand(InputStream in, IoBuffer buffer) throws IOException {\n+            ByteBuf header = buffer.getBuffOfSize(in, 8);\n+\n+            int t = header.getInt(0);\n+            WireCommandType type = WireCommands.getType(t);\n+            if (type == null) {\n+                throw new InvalidMessageException(\"Unknown wire command: \" + t);\n+            }\n+\n+            int length = header.getInt(4);\n+            if (length < 0 || length > WireCommands.MAX_WIRECOMMAND_SIZE) {\n+                throw new InvalidMessageException(\"Event of invalid length: \" + length);\n+            }\n+\n+            ByteBuf payload = buffer.getBuffOfSize(in, length);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzYwMTExNw=="}, "originalCommit": {"oid": "2776ea569a9621aeae74042841e93c76c5fcfdfb"}, "originalPosition": 154}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMDM4Mjc1OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/connection/impl/CommandEncoder.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNzo1NToxN1rOGwzcsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNzo1NToxN1rOGwzcsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzgyNzc2MA==", "bodyText": "I'm not sure this line is actually reachable.\nSee discussion here: #4121 (comment)\nfrom when it was added.\nThere is no code coverage for this line in master:\nhttps://codecov.io/gh/pravega/pravega/src/master/shared/protocol/src/main/java/io/pravega/shared/protocol/netty/CommandEncoder.java", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r453827760", "createdAt": "2020-07-13T17:55:17Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/connection/impl/CommandEncoder.java", "diffHunk": "@@ -0,0 +1,419 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.connection.impl;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufOutputStream;\n+import io.netty.buffer.Unpooled;\n+import io.pravega.shared.metrics.MetricNotifier;\n+import io.pravega.shared.protocol.netty.Append;\n+import io.pravega.shared.protocol.netty.AppendBatchSizeTracker;\n+import io.pravega.shared.protocol.netty.InvalidMessageException;\n+import io.pravega.shared.protocol.netty.WireCommand;\n+import io.pravega.shared.protocol.netty.WireCommandType;\n+import io.pravega.shared.protocol.netty.WireCommands.AppendBlock;\n+import io.pravega.shared.protocol.netty.WireCommands.AppendBlockEnd;\n+import io.pravega.shared.protocol.netty.WireCommands.Hello;\n+import io.pravega.shared.protocol.netty.WireCommands.PartialEvent;\n+import io.pravega.shared.protocol.netty.WireCommands.SetupAppend;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.util.AbstractMap.SimpleImmutableEntry;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Function;\n+import javax.annotation.concurrent.GuardedBy;\n+import lombok.RequiredArgsConstructor;\n+import lombok.SneakyThrows;\n+import lombok.Synchronized;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import static io.pravega.shared.NameUtils.segmentTags;\n+import static io.pravega.shared.metrics.ClientMetricKeys.CLIENT_APPEND_BLOCK_SIZE;\n+import static io.pravega.shared.protocol.netty.WireCommands.TYPE_PLUS_LENGTH_SIZE;\n+import static io.pravega.shared.protocol.netty.WireCommands.TYPE_SIZE;\n+\n+@Slf4j\n+@RequiredArgsConstructor\n+public class CommandEncoder {\n+    \n+    private static final byte[] LENGTH_PLACEHOLDER = new byte[4];\n+    private final Function<Long, AppendBatchSizeTracker> appendTracker;\n+    private final MetricNotifier metricNotifier;\n+    @GuardedBy(\"$lock\")\n+    private final Map<Map.Entry<String, UUID>, Session> setupSegments = new HashMap<>();\n+    private final AtomicLong tokenCounter = new AtomicLong(0);\n+    @GuardedBy(\"$lock\")\n+    private String segmentBeingAppendedTo;\n+    @GuardedBy(\"$lock\")\n+    private UUID writerIdPerformingAppends;\n+    @GuardedBy(\"$lock\")\n+    private int currentBlockSize;\n+    @GuardedBy(\"$lock\")\n+    private int bytesLeftInBlock;\n+    @GuardedBy(\"$lock\")\n+    private final Map<UUID, Session> pendingWrites = new HashMap<>();\n+\n+    private final OutputStream output;\n+    private final ByteBuf buffer = Unpooled.buffer(1024 * 1024);\n+\n+    @RequiredArgsConstructor\n+    private final class Session {\n+        private static final int MAX_EVENTS = 500;\n+        private static final int MAX_DATA_SIZE = 1024 * 1024; // 1MB\n+        private final UUID id;\n+        private final long requestId;\n+        private final List<ByteBuf> pendingList = new ArrayList<>();\n+        private int pendingBytes = 0;\n+        private long lastEventNumber = -1L;\n+        private int eventCount = 0;\n+\n+        /**\n+         * Record the given Append to Session by tracking the last event number and number of events to write.\n+         */\n+        private void record(Append append) {\n+            lastEventNumber = append.getEventNumber();\n+            eventCount += append.getEventCount();\n+        }\n+\n+        /**\n+         * Check if session is empty or not.\n+         * @return true if there are any pending events; false otherwise.\n+         */\n+        private boolean isFree() {\n+            return eventCount == 0;\n+        }\n+\n+        /**\n+         * Queue the Append data to Session' list.\n+         *\n+         * @param data  data bytes.\n+         * @param out   Network channel buffer.\n+         */\n+        private void write(ByteBuf data) {\n+            pendingWrites.putIfAbsent(id, this);\n+            if (data.readableBytes() > 0) {\n+                pendingBytes += data.readableBytes();\n+                pendingList.add(data);\n+            }\n+            conditionalFlush();\n+        }\n+\n+        /**\n+         * Check the overflow condition and flush if required.\n+         *\n+         * @param out   Network channel buffer.\n+         */\n+        private void conditionalFlush() {\n+            if ((pendingBytes > MAX_DATA_SIZE) || (eventCount > MAX_EVENTS)) {\n+                breakCurrentAppend();\n+                flushToBuffer();\n+            }\n+        }\n+\n+       /**\n+        * Write/flush session's data to network channel.\n+        *\n+        * @param out   Network channel buffer.\n+        */\n+       private void flushToBuffer() {\n+            if (!isFree()) {\n+                pendingWrites.remove(id);\n+                writeMessage(new AppendBlock(id), pendingBytes);\n+                if (pendingBytes > 0) {\n+                    pendingList.forEach(buffer::writeBytes);\n+                    pendingList.clear();\n+                }\n+                flushToBuffer(pendingBytes, null);\n+                pendingBytes = 0;\n+            }\n+        }\n+\n+        /**\n+         * Write/flush given data to network channel by writing the Append block End containing the given/input data\n+         * and indicating the size of previous append block data.\n+         *\n+         * @param sizeOfWholeEvents Size of data followed by this append block end.\n+         * @param data              Remaining data\n+         */\n+        private void flushToBuffer(int sizeOfWholeEvents, ByteBuf data) {\n+            writeMessage(new AppendBlockEnd(id, sizeOfWholeEvents, data, eventCount, lastEventNumber, requestId), buffer);\n+            eventCount = 0;\n+        }\n+    }\n+    \n+    /**\n+     * Write/flush Multi session's buffered data to network channel buffer by iterating over all the pending sessions .\n+     */\n+    private void flushAllToBuffer() {\n+        if (!pendingWrites.isEmpty()) {\n+            ArrayList<Session> sessions = new ArrayList<>(pendingWrites.values());\n+            sessions.forEach(session -> session.flushToBuffer());\n+        }\n+    }\n+    \n+    @Synchronized\n+    public void write(WireCommand msg) throws IOException {\n+        if (msg instanceof SetupAppend) {\n+            breakCurrentAppend();\n+            flushAllToBuffer();\n+            writeMessage((SetupAppend) msg, buffer);\n+            SetupAppend setup = (SetupAppend) msg;\n+            setupSegments.put(new SimpleImmutableEntry<>(setup.getSegment(), setup.getWriterId()),\n+                              new Session(setup.getWriterId(), setup.getRequestId()));\n+            flushBuffer();\n+        } else if (msg instanceof Hello) {\n+            Preconditions.checkState(isChannelFree());\n+            Preconditions.checkState(pendingWrites.isEmpty());\n+            writeMessage((WireCommand) msg, buffer);\n+            flushBuffer();\n+        } else {\n+            breakCurrentAppend();\n+            flushAllToBuffer();\n+            writeMessage((WireCommand) msg, buffer);\n+            flushBuffer();\n+        }\n+    }\n+    \n+    @Synchronized\n+    public void write(Append append) throws IOException {\n+        Session session = setupSegments.get(new SimpleImmutableEntry<>(append.getSegment(), append.getWriterId()));\n+        validateAppend(append, session);\n+        final ByteBuf data = append.getData().slice();\n+        final AppendBatchSizeTracker blockSizeSupplier = (appendTracker == null) ? null :\n+                appendTracker.apply(append.getFlowId());\n+\n+        if (blockSizeSupplier != null) {\n+            blockSizeSupplier.recordAppend(append.getEventNumber(), data.readableBytes());\n+        }\n+        if (isChannelFree()) {\n+            if (session.isFree()) {\n+                session.record(append);\n+                startAppend(blockSizeSupplier, append);\n+                continueAppend(data);\n+                if (bytesLeftInBlock == 0) {\n+                    completeAppend(null);\n+                    flushBuffer();\n+                }\n+            } else {\n+                session.record(append);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2776ea569a9621aeae74042841e93c76c5fcfdfb"}, "originalPosition": 212}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzMTA4NjQ5OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/connection/impl/FlowHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMToxNDo0NlrOGw6Hcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QyMjoyNzoxNVrOGw8upw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzkzNzAxMA==", "bodyText": "What does Flow.from do? Most of the time we won't have debug logs enabled, but this will be evaluated each time. Is this something we could optimize by checking log.isDebugEnabled() beforehand?", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r453937010", "createdAt": "2020-07-13T21:14:46Z", "author": {"login": "andreipaduroiu"}, "path": "client/src/main/java/io/pravega/client/connection/impl/FlowHandler.java", "diffHunk": "@@ -157,96 +160,18 @@ public AppendBatchSizeTracker getAppendBatchSizeTracker(final long requestID) {\n     public int getOpenFlowCount() {\n         return flowIdReplyProcessorMap.size();\n     }\n-    \n-    /**\n-     * Check the current status of Connection.\n-     * @return True if the connection is established.\n-     */\n-    public boolean isConnectionEstablished() {\n-        return channel.get() != null;\n-    }\n-\n-    /**\n-     * Fetch the netty channel. If {@link Channel} is null then throw a ConnectionFailedException.\n-     * @return  The current {@link Channel}\n-     * @throws ConnectionFailedException Throw if connection is not established.\n-     */\n-    Channel getChannel() throws ConnectionFailedException {\n-        Channel ch = channel.get();\n-        if (ch == null) {\n-            throw new ConnectionFailedException(\"Connection to \" + connectionName + \" is not established.\");\n-        }\n-        return ch;\n-    }\n \n     /**\n-     * Set the Recent Message flag. This is used to detect connection timeouts.\n+     * Set the Recent Message flag. This is used to avoid sending redundant KeepAlives over the connection.\n      */\n     void setRecentMessage() {\n         recentMessage.set(true);\n     }\n \n-    /**\n-     * This function completes the input future when the channel is ready.\n-     *\n-     * @param future CompletableFuture which will be completed once the channel is ready.\n-     */\n-    void completeWhenReady(final CompletableFuture<Void> future) {\n-        Preconditions.checkNotNull(future, \"future\");\n-        registeredFutureLatch.register(future);\n-    }\n-\n     @Override\n-    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n-        super.channelActive(ctx);\n-        Channel ch = ctx.channel();\n-        channel.set(ch);\n-        log.info(\"Connection established with endpoint {} on channel {}\", connectionName, ch);\n-        ch.writeAndFlush(new WireCommands.Hello(WireCommands.WIRE_VERSION, WireCommands.OLDEST_COMPATIBLE_VERSION), ch.voidPromise());\n-        registeredFutureLatch.release(null); //release all futures waiting for channel registration to complete.\n-        // WireCommands.KeepAlive messages are sent for every network connection to a SegmentStore.\n-        ScheduledFuture<?> old = keepAliveFuture.getAndSet(ch.eventLoop()\n-                                                             .scheduleWithFixedDelay(keepAlive,\n-                                                                                     KEEP_ALIVE_TIMEOUT_SECONDS,\n-                                                                                     KEEP_ALIVE_TIMEOUT_SECONDS,\n-                                                                                     TimeUnit.SECONDS));\n-        if (old != null) {\n-            old.cancel(false);\n-        }\n-    }\n-\n-    /**\n-     * Invoke all the {@link ReplyProcessor#connectionDropped()} for all the registered flows once the\n-     * connection is disconnected.\n-     *\n-     * @see io.netty.channel.ChannelInboundHandler#channelUnregistered(ChannelHandlerContext)\n-     */\n-    @Override\n-    public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {\n-        ScheduledFuture<?> future = keepAliveFuture.get();\n-        if (future != null) {\n-            future.cancel(false);\n-        }\n-        channel.set(null);\n-        log.info(\"Connection drop observed with endpoint {}\", connectionName);\n-        flowIdReplyProcessorMap.forEach((flowId, rp) -> {\n-            try {\n-                log.debug(\"Connection dropped for flow id {}\", flowId);\n-                rp.connectionDropped();\n-            } catch (Exception e) {\n-                // Suppressing exception which prevents all ReplyProcessor.connectionDropped from being invoked.\n-                log.warn(\"Encountered exception invoking ReplyProcessor for flow id {}\", flowId, e);\n-            }\n-        });\n-        registeredFutureLatch.releaseExceptionally(new ConnectionClosedException());\n-        super.channelUnregistered(ctx);\n-    }\n-\n-    @Override\n-    public void channelRead(ChannelHandlerContext ctx, Object msg) {\n-        Reply cmd = (Reply) msg;\n-        log.debug(connectionName + \" processing reply {} with flow {}\", cmd, Flow.from(cmd.getRequestId()));\n-        recentMessage.set(true);\n+    public void process(Reply cmd) {\n+        log.debug(\"{} processing reply {} with flow {}\", location, cmd, Flow.from(cmd.getRequestId()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2776ea569a9621aeae74042841e93c76c5fcfdfb"}, "originalPosition": 239}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk3OTgxNQ==", "bodyText": "It is not expensive, but I added the check.", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r453979815", "createdAt": "2020-07-13T22:27:15Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/connection/impl/FlowHandler.java", "diffHunk": "@@ -157,96 +160,18 @@ public AppendBatchSizeTracker getAppendBatchSizeTracker(final long requestID) {\n     public int getOpenFlowCount() {\n         return flowIdReplyProcessorMap.size();\n     }\n-    \n-    /**\n-     * Check the current status of Connection.\n-     * @return True if the connection is established.\n-     */\n-    public boolean isConnectionEstablished() {\n-        return channel.get() != null;\n-    }\n-\n-    /**\n-     * Fetch the netty channel. If {@link Channel} is null then throw a ConnectionFailedException.\n-     * @return  The current {@link Channel}\n-     * @throws ConnectionFailedException Throw if connection is not established.\n-     */\n-    Channel getChannel() throws ConnectionFailedException {\n-        Channel ch = channel.get();\n-        if (ch == null) {\n-            throw new ConnectionFailedException(\"Connection to \" + connectionName + \" is not established.\");\n-        }\n-        return ch;\n-    }\n \n     /**\n-     * Set the Recent Message flag. This is used to detect connection timeouts.\n+     * Set the Recent Message flag. This is used to avoid sending redundant KeepAlives over the connection.\n      */\n     void setRecentMessage() {\n         recentMessage.set(true);\n     }\n \n-    /**\n-     * This function completes the input future when the channel is ready.\n-     *\n-     * @param future CompletableFuture which will be completed once the channel is ready.\n-     */\n-    void completeWhenReady(final CompletableFuture<Void> future) {\n-        Preconditions.checkNotNull(future, \"future\");\n-        registeredFutureLatch.register(future);\n-    }\n-\n     @Override\n-    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n-        super.channelActive(ctx);\n-        Channel ch = ctx.channel();\n-        channel.set(ch);\n-        log.info(\"Connection established with endpoint {} on channel {}\", connectionName, ch);\n-        ch.writeAndFlush(new WireCommands.Hello(WireCommands.WIRE_VERSION, WireCommands.OLDEST_COMPATIBLE_VERSION), ch.voidPromise());\n-        registeredFutureLatch.release(null); //release all futures waiting for channel registration to complete.\n-        // WireCommands.KeepAlive messages are sent for every network connection to a SegmentStore.\n-        ScheduledFuture<?> old = keepAliveFuture.getAndSet(ch.eventLoop()\n-                                                             .scheduleWithFixedDelay(keepAlive,\n-                                                                                     KEEP_ALIVE_TIMEOUT_SECONDS,\n-                                                                                     KEEP_ALIVE_TIMEOUT_SECONDS,\n-                                                                                     TimeUnit.SECONDS));\n-        if (old != null) {\n-            old.cancel(false);\n-        }\n-    }\n-\n-    /**\n-     * Invoke all the {@link ReplyProcessor#connectionDropped()} for all the registered flows once the\n-     * connection is disconnected.\n-     *\n-     * @see io.netty.channel.ChannelInboundHandler#channelUnregistered(ChannelHandlerContext)\n-     */\n-    @Override\n-    public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {\n-        ScheduledFuture<?> future = keepAliveFuture.get();\n-        if (future != null) {\n-            future.cancel(false);\n-        }\n-        channel.set(null);\n-        log.info(\"Connection drop observed with endpoint {}\", connectionName);\n-        flowIdReplyProcessorMap.forEach((flowId, rp) -> {\n-            try {\n-                log.debug(\"Connection dropped for flow id {}\", flowId);\n-                rp.connectionDropped();\n-            } catch (Exception e) {\n-                // Suppressing exception which prevents all ReplyProcessor.connectionDropped from being invoked.\n-                log.warn(\"Encountered exception invoking ReplyProcessor for flow id {}\", flowId, e);\n-            }\n-        });\n-        registeredFutureLatch.releaseExceptionally(new ConnectionClosedException());\n-        super.channelUnregistered(ctx);\n-    }\n-\n-    @Override\n-    public void channelRead(ChannelHandlerContext ctx, Object msg) {\n-        Reply cmd = (Reply) msg;\n-        log.debug(connectionName + \" processing reply {} with flow {}\", cmd, Flow.from(cmd.getRequestId()));\n-        recentMessage.set(true);\n+    public void process(Reply cmd) {\n+        log.debug(\"{} processing reply {} with flow {}\", location, cmd, Flow.from(cmd.getRequestId()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzkzNzAxMA=="}, "originalCommit": {"oid": "2776ea569a9621aeae74042841e93c76c5fcfdfb"}, "originalPosition": 239}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNDAyNzYxOnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/connection/impl/FlowHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxNDowNjoyMlrOGxVSUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMTo0NzoyM1rOGxmjNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDM4MjE2MQ==", "bodyText": "nit:updated comment in line 121", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r454382161", "createdAt": "2020-07-14T14:06:22Z", "author": {"login": "shrids"}, "path": "client/src/main/java/io/pravega/client/connection/impl/FlowHandler.java", "diffHunk": "@@ -98,20 +102,19 @@ public ClientConnection createFlow(final Flow flow, final ReplyProcessor rp) {\n     public ClientConnection createConnectionWithFlowDisabled(final ReplyProcessor rp) {\n         Exceptions.checkNotClosed(closed.get(), this);\n         Preconditions.checkState(!disableFlow.getAndSet(true), \"Flows are disabled, incorrect usage pattern.\");\n-        log.info(\"Creating a new connection with flow disabled for endpoint {}. The current Channel is {}.\", connectionName, channel.get());\n+        log.info(\"Creating a new connection with flow disabled for endpoint {}.\", location);\n         flowIdReplyProcessorMap.put(FLOW_DISABLED, rp);\n         createAppendBatchSizeTrackerIfNeeded(FLOW_DISABLED);\n-        return new ClientConnectionImpl(connectionName, FLOW_DISABLED, this);\n+        return new FlowClientConnection(location.toString(), channel, FLOW_DISABLED, this);\n     }\n \n     /**\n      * Close a flow. This is invoked when the ClientConnection is closed.\n      * @param clientConnection Client Connection.\n      */\n-    public void closeFlow(ClientConnection clientConnection) {\n-        final ClientConnectionImpl clientConnectionImpl = (ClientConnectionImpl) clientConnection;\n-        int flow = clientConnectionImpl.getFlowId();\n-        log.info(\"Closing Flow {} for endpoint {}\", flow, clientConnectionImpl.getConnectionName());\n+    void closeFlow(FlowClientConnection clientConnection) {\n+        int flow = clientConnection.getFlowId();\n+        log.info(\"Closing Flow {} for endpoint {}\", flow, clientConnection.getConnectionName());\n         flowIdReplyProcessorMap.remove(flow);\n         flowIDBatchSizeTrackerMap.remove(flow);\n         if (flow == FLOW_DISABLED) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c76edd8affdbba70c9e5767a4c8f93c09c51fce"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY2NTAxNQ==", "bodyText": "DOne", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r454665015", "createdAt": "2020-07-14T21:47:23Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/connection/impl/FlowHandler.java", "diffHunk": "@@ -98,20 +102,19 @@ public ClientConnection createFlow(final Flow flow, final ReplyProcessor rp) {\n     public ClientConnection createConnectionWithFlowDisabled(final ReplyProcessor rp) {\n         Exceptions.checkNotClosed(closed.get(), this);\n         Preconditions.checkState(!disableFlow.getAndSet(true), \"Flows are disabled, incorrect usage pattern.\");\n-        log.info(\"Creating a new connection with flow disabled for endpoint {}. The current Channel is {}.\", connectionName, channel.get());\n+        log.info(\"Creating a new connection with flow disabled for endpoint {}.\", location);\n         flowIdReplyProcessorMap.put(FLOW_DISABLED, rp);\n         createAppendBatchSizeTrackerIfNeeded(FLOW_DISABLED);\n-        return new ClientConnectionImpl(connectionName, FLOW_DISABLED, this);\n+        return new FlowClientConnection(location.toString(), channel, FLOW_DISABLED, this);\n     }\n \n     /**\n      * Close a flow. This is invoked when the ClientConnection is closed.\n      * @param clientConnection Client Connection.\n      */\n-    public void closeFlow(ClientConnection clientConnection) {\n-        final ClientConnectionImpl clientConnectionImpl = (ClientConnectionImpl) clientConnection;\n-        int flow = clientConnectionImpl.getFlowId();\n-        log.info(\"Closing Flow {} for endpoint {}\", flow, clientConnectionImpl.getConnectionName());\n+    void closeFlow(FlowClientConnection clientConnection) {\n+        int flow = clientConnection.getFlowId();\n+        log.info(\"Closing Flow {} for endpoint {}\", flow, clientConnection.getConnectionName());\n         flowIdReplyProcessorMap.remove(flow);\n         flowIDBatchSizeTrackerMap.remove(flow);\n         if (flow == FLOW_DISABLED) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDM4MjE2MQ=="}, "originalCommit": {"oid": "6c76edd8affdbba70c9e5767a4c8f93c09c51fce"}, "originalPosition": 142}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNDA0NjA2OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/connection/impl/FlowHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxNDoxMDo1MVrOGxVeZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMTo0NzozMVrOGxmjdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDM4NTI1NQ==", "bodyText": "clinetConfig is unused.", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r454385255", "createdAt": "2020-07-14T14:10:51Z", "author": {"login": "shrids"}, "path": "client/src/main/java/io/pravega/client/connection/impl/FlowHandler.java", "diffHunk": "@@ -40,37 +36,45 @@\n import static io.pravega.shared.metrics.ClientMetricKeys.CLIENT_OUTSTANDING_APPEND_COUNT;\n \n @Slf4j\n-public class FlowHandler extends ChannelInboundHandlerAdapter implements AutoCloseable {\n-    private static final int KEEP_ALIVE_TIMEOUT_SECONDS = 20;\n+public class FlowHandler extends FailingReplyProcessor implements AutoCloseable {\n+\n     private static final int FLOW_DISABLED = 0;\n-    private final String connectionName;\n+    private final PravegaNodeUri location;\n+    private ClientConnection channel; //Final (set in factory after construction)\n     @Getter\n     private final MetricNotifier metricNotifier;\n-    private final AtomicReference<Channel> channel = new AtomicReference<>();\n-    private final AtomicReference<ScheduledFuture<?>> keepAliveFuture = new AtomicReference<>();\n-    private final AtomicBoolean recentMessage = new AtomicBoolean(true);\n-    private final AtomicBoolean closed = new AtomicBoolean(false);\n     @VisibleForTesting\n     @Getter(AccessLevel.PACKAGE)\n-    private final KeepAliveTask keepAlive = new KeepAliveTask();\n-    @Getter\n-    private final ReusableFutureLatch<Void> registeredFutureLatch = new ReusableFutureLatch<>();\n+    private final KeepAliveTask keepAliveTask = new KeepAliveTask();\n+    private ScheduledFuture<?> keepAliveFuture; //Final (set in factory after construction)\n+    private final AtomicBoolean recentMessage = new AtomicBoolean(false);\n+    private final AtomicBoolean closed = new AtomicBoolean(false);\n+\n     @VisibleForTesting\n     @Getter(AccessLevel.PACKAGE)\n     private final ConcurrentHashMap<Integer, ReplyProcessor> flowIdReplyProcessorMap = new ConcurrentHashMap<>();\n     private final ConcurrentHashMap<Integer, AppendBatchSizeTracker> flowIDBatchSizeTrackerMap = new ConcurrentHashMap<>();\n-\n     private final AtomicBoolean disableFlow = new AtomicBoolean(false);\n \n-    public FlowHandler(String connectionName) {\n-        this(connectionName, MetricNotifier.NO_OP_METRIC_NOTIFIER);\n-    }\n-\n-    public FlowHandler(String connectionName, MetricNotifier updateMetric) {\n-        this.connectionName = connectionName;\n+    private FlowHandler(PravegaNodeUri location, MetricNotifier updateMetric) {\n+        this.location = location;\n         this.metricNotifier = updateMetric;\n     }\n \n+    static CompletableFuture<FlowHandler> openConnection(PravegaNodeUri location, ClientConfig clientConfig, MetricNotifier updateMetric, ConnectionFactory connectionFactory) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c76edd8affdbba70c9e5767a4c8f93c09c51fce"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY2NTA3Ng==", "bodyText": "Removed", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r454665076", "createdAt": "2020-07-14T21:47:31Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/connection/impl/FlowHandler.java", "diffHunk": "@@ -40,37 +36,45 @@\n import static io.pravega.shared.metrics.ClientMetricKeys.CLIENT_OUTSTANDING_APPEND_COUNT;\n \n @Slf4j\n-public class FlowHandler extends ChannelInboundHandlerAdapter implements AutoCloseable {\n-    private static final int KEEP_ALIVE_TIMEOUT_SECONDS = 20;\n+public class FlowHandler extends FailingReplyProcessor implements AutoCloseable {\n+\n     private static final int FLOW_DISABLED = 0;\n-    private final String connectionName;\n+    private final PravegaNodeUri location;\n+    private ClientConnection channel; //Final (set in factory after construction)\n     @Getter\n     private final MetricNotifier metricNotifier;\n-    private final AtomicReference<Channel> channel = new AtomicReference<>();\n-    private final AtomicReference<ScheduledFuture<?>> keepAliveFuture = new AtomicReference<>();\n-    private final AtomicBoolean recentMessage = new AtomicBoolean(true);\n-    private final AtomicBoolean closed = new AtomicBoolean(false);\n     @VisibleForTesting\n     @Getter(AccessLevel.PACKAGE)\n-    private final KeepAliveTask keepAlive = new KeepAliveTask();\n-    @Getter\n-    private final ReusableFutureLatch<Void> registeredFutureLatch = new ReusableFutureLatch<>();\n+    private final KeepAliveTask keepAliveTask = new KeepAliveTask();\n+    private ScheduledFuture<?> keepAliveFuture; //Final (set in factory after construction)\n+    private final AtomicBoolean recentMessage = new AtomicBoolean(false);\n+    private final AtomicBoolean closed = new AtomicBoolean(false);\n+\n     @VisibleForTesting\n     @Getter(AccessLevel.PACKAGE)\n     private final ConcurrentHashMap<Integer, ReplyProcessor> flowIdReplyProcessorMap = new ConcurrentHashMap<>();\n     private final ConcurrentHashMap<Integer, AppendBatchSizeTracker> flowIDBatchSizeTrackerMap = new ConcurrentHashMap<>();\n-\n     private final AtomicBoolean disableFlow = new AtomicBoolean(false);\n \n-    public FlowHandler(String connectionName) {\n-        this(connectionName, MetricNotifier.NO_OP_METRIC_NOTIFIER);\n-    }\n-\n-    public FlowHandler(String connectionName, MetricNotifier updateMetric) {\n-        this.connectionName = connectionName;\n+    private FlowHandler(PravegaNodeUri location, MetricNotifier updateMetric) {\n+        this.location = location;\n         this.metricNotifier = updateMetric;\n     }\n \n+    static CompletableFuture<FlowHandler> openConnection(PravegaNodeUri location, ClientConfig clientConfig, MetricNotifier updateMetric, ConnectionFactory connectionFactory) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDM4NTI1NQ=="}, "originalCommit": {"oid": "6c76edd8affdbba70c9e5767a4c8f93c09c51fce"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNDA1ODU1OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/connection/impl/FlowHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxNDoxMzo0MVrOGxVmbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMTo0ODo0MVrOGxmljQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDM4NzMxMA==", "bodyText": "Q: Is there a reason why true is not used ?", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r454387310", "createdAt": "2020-07-14T14:13:41Z", "author": {"login": "shrids"}, "path": "client/src/main/java/io/pravega/client/connection/impl/FlowHandler.java", "diffHunk": "@@ -299,58 +231,67 @@ private void invokeProcessingFailureForAllFlows(Throwable cause) {\n         });\n     }\n \n+    @Override\n+    public void connectionDropped() {\n+        close();\n+    }\n+\n     @Override\n     public void close() {\n         if (closed.compareAndSet(false, true)) {\n-            Channel ch = channel.getAndSet(null);\n-            if (ch != null) {\n-                log.info(\"Closing connection with endpoint {} on channel {}\", connectionName, ch);\n-                final int openFlowCount = flowIdReplyProcessorMap.size();\n-                if (openFlowCount != 0) {\n-                    log.debug(\"{} flows are not closed\", openFlowCount);\n-                    // ensure all the ReplyProcessors are informed immediately about the channel being closed.\n-                    invokeProcessingFailureForAllFlows(new ConnectionClosedException());\n-                }\n-                final int appendTrackerCount = flowIDBatchSizeTrackerMap.size();\n-                if (appendTrackerCount != 0) {\n-                    log.warn(\"{} AppendBatchSizeTrackers are not closed\", appendTrackerCount);\n+            if (keepAliveFuture != null) {\n+                keepAliveFuture.cancel(false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c76edd8affdbba70c9e5767a4c8f93c09c51fce"}, "originalPosition": 299}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY2NTYxMw==", "bodyText": "It is more noisy, and not needed because closing a stream will unblock any read/write calls blocked on it.", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r454665613", "createdAt": "2020-07-14T21:48:41Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/connection/impl/FlowHandler.java", "diffHunk": "@@ -299,58 +231,67 @@ private void invokeProcessingFailureForAllFlows(Throwable cause) {\n         });\n     }\n \n+    @Override\n+    public void connectionDropped() {\n+        close();\n+    }\n+\n     @Override\n     public void close() {\n         if (closed.compareAndSet(false, true)) {\n-            Channel ch = channel.getAndSet(null);\n-            if (ch != null) {\n-                log.info(\"Closing connection with endpoint {} on channel {}\", connectionName, ch);\n-                final int openFlowCount = flowIdReplyProcessorMap.size();\n-                if (openFlowCount != 0) {\n-                    log.debug(\"{} flows are not closed\", openFlowCount);\n-                    // ensure all the ReplyProcessors are informed immediately about the channel being closed.\n-                    invokeProcessingFailureForAllFlows(new ConnectionClosedException());\n-                }\n-                final int appendTrackerCount = flowIDBatchSizeTrackerMap.size();\n-                if (appendTrackerCount != 0) {\n-                    log.warn(\"{} AppendBatchSizeTrackers are not closed\", appendTrackerCount);\n+            if (keepAliveFuture != null) {\n+                keepAliveFuture.cancel(false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDM4NzMxMA=="}, "originalCommit": {"oid": "6c76edd8affdbba70c9e5767a4c8f93c09c51fce"}, "originalPosition": 299}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNDA2NzEyOnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/connection/impl/FlowHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxNDoxNTozMlrOGxVrpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMTo0Nzo0MVrOGxmjwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDM4ODY0NQ==", "bodyText": "final", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r454388645", "createdAt": "2020-07-14T14:15:32Z", "author": {"login": "shrids"}, "path": "client/src/main/java/io/pravega/client/connection/impl/FlowHandler.java", "diffHunk": "@@ -299,58 +231,67 @@ private void invokeProcessingFailureForAllFlows(Throwable cause) {\n         });\n     }\n \n+    @Override\n+    public void connectionDropped() {\n+        close();\n+    }\n+\n     @Override\n     public void close() {\n         if (closed.compareAndSet(false, true)) {\n-            Channel ch = channel.getAndSet(null);\n-            if (ch != null) {\n-                log.info(\"Closing connection with endpoint {} on channel {}\", connectionName, ch);\n-                final int openFlowCount = flowIdReplyProcessorMap.size();\n-                if (openFlowCount != 0) {\n-                    log.debug(\"{} flows are not closed\", openFlowCount);\n-                    // ensure all the ReplyProcessors are informed immediately about the channel being closed.\n-                    invokeProcessingFailureForAllFlows(new ConnectionClosedException());\n-                }\n-                final int appendTrackerCount = flowIDBatchSizeTrackerMap.size();\n-                if (appendTrackerCount != 0) {\n-                    log.warn(\"{} AppendBatchSizeTrackers are not closed\", appendTrackerCount);\n+            if (keepAliveFuture != null) {\n+                keepAliveFuture.cancel(false);\n+            }\n+            log.info(\"Connection closed observed with endpoint {}\", location);\n+            flowIdReplyProcessorMap.forEach((flowId, rp) -> {\n+                try {\n+                    log.debug(\"Connection dropped for flow id {}\", flowId);\n+                    rp.connectionDropped();\n+                } catch (Exception e) {\n+                    // Suppressing exception which prevents all ReplyProcessor.connectionDropped\n+                    // from being invoked.\n+                    log.warn(\"Encountered exception invoking ReplyProcessor for flow id {}\", flowId, e);\n                 }\n-                ch.close();\n+            });\n+            final int appendTrackerCount = flowIDBatchSizeTrackerMap.size();\n+            if (appendTrackerCount != 0) {\n+                log.warn(\"{} AppendBatchSizeTrackers are not closed\", appendTrackerCount);\n             }\n+            channel.close();\n         }\n     }\n+    \n+    public final boolean isClosed() {\n+        return closed.get();\n+    }\n \n+    @VisibleForTesting\n     final class KeepAliveTask implements Runnable {\n-        @VisibleForTesting\n-        @Getter(AccessLevel.PACKAGE)\n-        private final ChannelFutureListener listener = new ChannelFutureListener() {\n-            @Override\n-            public void operationComplete(ChannelFuture future) throws Exception {\n-                recentMessage.set(true);\n-                if (!future.isSuccess()) {\n-                    log.warn(\"Keepalive failed for connection {}\", connectionName);\n-                    close();\n-                }\n-            }\n-        };\n-        \n+        private AtomicInteger concurrentlyRunning = new AtomicInteger(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c76edd8affdbba70c9e5767a4c8f93c09c51fce"}, "originalPosition": 340}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY2NTE1Mw==", "bodyText": "done", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r454665153", "createdAt": "2020-07-14T21:47:41Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/connection/impl/FlowHandler.java", "diffHunk": "@@ -299,58 +231,67 @@ private void invokeProcessingFailureForAllFlows(Throwable cause) {\n         });\n     }\n \n+    @Override\n+    public void connectionDropped() {\n+        close();\n+    }\n+\n     @Override\n     public void close() {\n         if (closed.compareAndSet(false, true)) {\n-            Channel ch = channel.getAndSet(null);\n-            if (ch != null) {\n-                log.info(\"Closing connection with endpoint {} on channel {}\", connectionName, ch);\n-                final int openFlowCount = flowIdReplyProcessorMap.size();\n-                if (openFlowCount != 0) {\n-                    log.debug(\"{} flows are not closed\", openFlowCount);\n-                    // ensure all the ReplyProcessors are informed immediately about the channel being closed.\n-                    invokeProcessingFailureForAllFlows(new ConnectionClosedException());\n-                }\n-                final int appendTrackerCount = flowIDBatchSizeTrackerMap.size();\n-                if (appendTrackerCount != 0) {\n-                    log.warn(\"{} AppendBatchSizeTrackers are not closed\", appendTrackerCount);\n+            if (keepAliveFuture != null) {\n+                keepAliveFuture.cancel(false);\n+            }\n+            log.info(\"Connection closed observed with endpoint {}\", location);\n+            flowIdReplyProcessorMap.forEach((flowId, rp) -> {\n+                try {\n+                    log.debug(\"Connection dropped for flow id {}\", flowId);\n+                    rp.connectionDropped();\n+                } catch (Exception e) {\n+                    // Suppressing exception which prevents all ReplyProcessor.connectionDropped\n+                    // from being invoked.\n+                    log.warn(\"Encountered exception invoking ReplyProcessor for flow id {}\", flowId, e);\n                 }\n-                ch.close();\n+            });\n+            final int appendTrackerCount = flowIDBatchSizeTrackerMap.size();\n+            if (appendTrackerCount != 0) {\n+                log.warn(\"{} AppendBatchSizeTrackers are not closed\", appendTrackerCount);\n             }\n+            channel.close();\n         }\n     }\n+    \n+    public final boolean isClosed() {\n+        return closed.get();\n+    }\n \n+    @VisibleForTesting\n     final class KeepAliveTask implements Runnable {\n-        @VisibleForTesting\n-        @Getter(AccessLevel.PACKAGE)\n-        private final ChannelFutureListener listener = new ChannelFutureListener() {\n-            @Override\n-            public void operationComplete(ChannelFuture future) throws Exception {\n-                recentMessage.set(true);\n-                if (!future.isSuccess()) {\n-                    log.warn(\"Keepalive failed for connection {}\", connectionName);\n-                    close();\n-                }\n-            }\n-        };\n-        \n+        private AtomicInteger concurrentlyRunning = new AtomicInteger(0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDM4ODY0NQ=="}, "originalCommit": {"oid": "6c76edd8affdbba70c9e5767a4c8f93c09c51fce"}, "originalPosition": 340}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNDA5NTk5OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/connection/impl/FlowClientConnection.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxNDoyMjowMlrOGxV9pQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMTo0Nzo0OVrOGxmj9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDM5MzI1Mw==", "bodyText": "If it channel is closed we should not invoke sendAsync.", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r454393253", "createdAt": "2020-07-14T14:22:02Z", "author": {"login": "shrids"}, "path": "client/src/main/java/io/pravega/client/connection/impl/FlowClientConnection.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.connection.impl;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.pravega.shared.protocol.netty.Append;\n+import io.pravega.shared.protocol.netty.ConnectionFailedException;\n+import io.pravega.shared.protocol.netty.WireCommand;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+\n+@RequiredArgsConstructor\n+public class FlowClientConnection implements ClientConnection {\n+\n+    @Getter\n+    private final String connectionName;\n+    @VisibleForTesting\n+    @Getter(AccessLevel.PACKAGE)\n+    private final ClientConnection channel;\n+    @Getter\n+    private final int flowId;\n+    private final FlowHandler handler;\n+    private final AtomicBoolean closed = new AtomicBoolean(false);\n+\n+    @Override\n+    public void send(WireCommand cmd) throws ConnectionFailedException {\n+        if (closed.get()) {\n+            throw new ConnectionFailedException(\"Connection is closed\");\n+        }\n+        channel.send(cmd);\n+    }\n+\n+    @Override\n+    public void send(Append append) throws ConnectionFailedException {\n+        if (closed.get()) {\n+            throw new ConnectionFailedException(\"Connection is closed\");\n+        }\n+        channel.send(append);\n+    }\n+\n+    @Override\n+    public void sendAsync(List<Append> appends, CompletedCallback callback) {\n+        if (closed.get()) {\n+            callback.complete(new ConnectionFailedException(\"Connection is closed\"));\n+        }\n+        channel.sendAsync(appends, callback);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c76edd8affdbba70c9e5767a4c8f93c09c51fce"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY2NTIwNw==", "bodyText": "done", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r454665207", "createdAt": "2020-07-14T21:47:49Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/connection/impl/FlowClientConnection.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.connection.impl;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.pravega.shared.protocol.netty.Append;\n+import io.pravega.shared.protocol.netty.ConnectionFailedException;\n+import io.pravega.shared.protocol.netty.WireCommand;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import lombok.AccessLevel;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+\n+@RequiredArgsConstructor\n+public class FlowClientConnection implements ClientConnection {\n+\n+    @Getter\n+    private final String connectionName;\n+    @VisibleForTesting\n+    @Getter(AccessLevel.PACKAGE)\n+    private final ClientConnection channel;\n+    @Getter\n+    private final int flowId;\n+    private final FlowHandler handler;\n+    private final AtomicBoolean closed = new AtomicBoolean(false);\n+\n+    @Override\n+    public void send(WireCommand cmd) throws ConnectionFailedException {\n+        if (closed.get()) {\n+            throw new ConnectionFailedException(\"Connection is closed\");\n+        }\n+        channel.send(cmd);\n+    }\n+\n+    @Override\n+    public void send(Append append) throws ConnectionFailedException {\n+        if (closed.get()) {\n+            throw new ConnectionFailedException(\"Connection is closed\");\n+        }\n+        channel.send(append);\n+    }\n+\n+    @Override\n+    public void sendAsync(List<Append> appends, CompletedCallback callback) {\n+        if (closed.get()) {\n+            callback.complete(new ConnectionFailedException(\"Connection is closed\"));\n+        }\n+        channel.sendAsync(appends, callback);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDM5MzI1Mw=="}, "originalCommit": {"oid": "6c76edd8affdbba70c9e5767a4c8f93c09c51fce"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNDIzNTMyOnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/connection/impl/ConnectionPoolImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxNDo1MDowMlrOGxXR3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMTowNjoyMFrOGxlV4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQxNDgxMg==", "bodyText": "getClientConnection() when close() is invoked can cause a connection leak, right ?", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r454414812", "createdAt": "2020-07-14T14:50:02Z", "author": {"login": "shrids"}, "path": "client/src/main/java/io/pravega/client/connection/impl/ConnectionPoolImpl.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+\n+package io.pravega.client.connection.impl;\n+\n+import static io.pravega.shared.metrics.MetricNotifier.NO_OP_METRIC_NOTIFIER;\n+\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.concurrent.GuardedBy;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+\n+import io.pravega.client.ClientConfig;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.shared.metrics.ClientMetricUpdater;\n+import io.pravega.shared.metrics.MetricListener;\n+import io.pravega.shared.metrics.MetricNotifier;\n+import io.pravega.shared.protocol.netty.PravegaNodeUri;\n+import io.pravega.shared.protocol.netty.ReplyProcessor;\n+import lombok.Data;\n+import lombok.Synchronized;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public class ConnectionPoolImpl implements ConnectionPool {\n+\n+    /**\n+     * This class represents a Connection that is established with a Segment Store instance and its\n+     * attributes. (e.g: FlowCount, WriterCount)\n+     */\n+    @Data\n+    private class Connection implements Comparable<Connection>, AutoCloseable {\n+        private final PravegaNodeUri uri;\n+        /**\n+         * A future that completes when the connection is first established.\n+         */\n+        private final CompletableFuture<FlowHandler> flowHandler;\n+\n+        int getFlowCount() {\n+            return Futures.isSuccessful(flowHandler) ? flowHandler.join().getOpenFlowCount() : 0;\n+        }\n+\n+        boolean isConnected() {\n+            if (!Futures.isSuccessful(flowHandler)) {\n+                return false;\n+            }\n+            return !flowHandler.join().isClosed();\n+        }\n+\n+        @Override\n+        public int compareTo(Connection o) {\n+            int v1 = Futures.isSuccessful(this.getFlowHandler()) ? this.getFlowCount() : Integer.MAX_VALUE;\n+            int v2 = Futures.isSuccessful(o.getFlowHandler()) ? o.getFlowCount() : Integer.MAX_VALUE;\n+            return Integer.compare(v1, v2);\n+        }\n+        \n+        @Override\n+        public void close() {\n+            if (Futures.isSuccessful(flowHandler)) {\n+                flowHandler.join().close();\n+            }\n+        }\n+    }\n+    \n+    private final ClientConfig clientConfig;\n+    private final MetricNotifier metricNotifier;\n+    private final AtomicBoolean closed = new AtomicBoolean(false);\n+    @GuardedBy(\"$lock\")\n+    private final Map<PravegaNodeUri, List<Connection>> connectionMap = new HashMap<>();\n+    private final ConnectionFactory connectionFactory;\n+\n+    public ConnectionPoolImpl(ClientConfig clientConfig, ConnectionFactory connectionFactory) {\n+        this.clientConfig = clientConfig;\n+        this.connectionFactory = connectionFactory;\n+        MetricListener metricListener = clientConfig.getMetricListener();\n+        this.metricNotifier = metricListener == null ? NO_OP_METRIC_NOTIFIER : new ClientMetricUpdater(metricListener);\n+    }\n+\n+    @Override\n+    @Synchronized\n+    public CompletableFuture<ClientConnection> getClientConnection(Flow flow, PravegaNodeUri location, ReplyProcessor rp) {\n+        Preconditions.checkNotNull(flow, \"Flow\");\n+        Preconditions.checkNotNull(location, \"Location\");\n+        Preconditions.checkNotNull(rp, \"ReplyProcessor\");\n+        Exceptions.checkNotClosed(closed.get(), this);\n+\n+        final List<Connection> connectionList = connectionMap.getOrDefault(location, new ArrayList<>());\n+\n+        // remove connections for which the underlying network connection is disconnected.\n+        List<Connection> prunedConnectionList = connectionList.stream().filter(connection -> {\n+            // Filter out Connection objects which have been completed exceptionally or have been disconnected.\n+            return !connection.getFlowHandler().isDone() || connection.isConnected();\n+        }).collect(Collectors.toList());\n+        log.debug(\"List of connections to {} that can be used: {}\", location, prunedConnectionList);\n+\n+        // Choose the connection with the least number of flows.\n+        Optional<Connection> suggestedConnection = prunedConnectionList.stream().min(Comparator.naturalOrder());\n+\n+        final Connection connection;\n+        if (suggestedConnection.isPresent() && (prunedConnectionList.size() >= clientConfig.getMaxConnectionsPerSegmentStore() || isUnused(suggestedConnection.get()))) {\n+            log.info(\"Reusing connection: {}\", suggestedConnection.get());\n+            connection = suggestedConnection.get();\n+        } else {\n+            // create a new connection.\n+            log.info(\"Creating a new connection to {}\", location);\n+            CompletableFuture<FlowHandler> establishedFuture = establishConnection(location);\n+            connection = new Connection(location, establishedFuture);\n+            prunedConnectionList.add(connection);\n+        }\n+        connectionMap.put(location, prunedConnectionList);\n+        return connection.getFlowHandler().thenApply(flowHandler -> flowHandler.createFlow(flow, rp));\n+    }\n+\n+    @Override\n+    @Synchronized\n+    public CompletableFuture<ClientConnection> getClientConnection(PravegaNodeUri location, ReplyProcessor rp) {\n+        Preconditions.checkNotNull(location, \"Location\");\n+        Preconditions.checkNotNull(rp, \"ReplyProcessor\");\n+        Exceptions.checkNotClosed(closed.get(), this);\n+\n+        // create a new connection.\n+        CompletableFuture<FlowHandler> handler = establishConnection(location);\n+        Connection connection = new Connection(location, handler);\n+        return connection.getFlowHandler().thenApply(h -> h.createConnectionWithFlowDisabled(rp));\n+    }\n+\n+    private static boolean isUnused(Connection connection) {\n+        return Futures.isSuccessful(connection.getFlowHandler()) && connection.getFlowCount() == 0;\n+    }\n+\n+    /**\n+     * Used only for testing.\n+     */\n+    @VisibleForTesting\n+    @Synchronized\n+    public void pruneUnusedConnections() {\n+        for (List<Connection> connections : connectionMap.values()) {\n+            for (Iterator<Connection> iterator = connections.iterator(); iterator.hasNext();) {\n+                Connection connection = iterator.next();\n+                if (isUnused(connection)) {\n+                    connection.getFlowHandler().join().close();\n+                    iterator.remove();\n+                }\n+            }\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    @Synchronized\n+    public List<Connection> getActiveChannels() {\n+        ArrayList<Connection> result = new ArrayList<Connection>();\n+        for (List<Connection> connection : this.connectionMap.values()) {\n+            result.addAll(connection);\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Establish a new connection to the Pravega Node.\n+     * @param location The Pravega Node Uri\n+     * @return A future, which completes once the connection has been established, returning a FlowHandler that can be used to create\n+     * flows on the connection.\n+     */\n+    private CompletableFuture<FlowHandler> establishConnection(PravegaNodeUri location) {\n+        return FlowHandler.openConnection(location, clientConfig, metricNotifier, connectionFactory);\n+    }\n+\n+    @Override\n+    public void close() {\n+        log.info(\"Shutting down connection pool\");\n+        if (closed.compareAndSet(false, true)) {\n+            metricNotifier.close();\n+            connectionFactory.close();\n+            for (List<Connection> connections : connectionMap.values()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c76edd8affdbba70c9e5767a4c8f93c09c51fce"}, "originalPosition": 194}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY0NTIxNw==", "bodyText": "I am not sure I understand the question.\ngetClientConnection() and close() are both synchronized so they can't be called in parallel, and getClientConnection() checks if the closed flag has been set so if it is called after close it will just throw.", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r454645217", "createdAt": "2020-07-14T21:06:20Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/connection/impl/ConnectionPoolImpl.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+\n+package io.pravega.client.connection.impl;\n+\n+import static io.pravega.shared.metrics.MetricNotifier.NO_OP_METRIC_NOTIFIER;\n+\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+\n+import javax.annotation.concurrent.GuardedBy;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+\n+import io.pravega.client.ClientConfig;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.Futures;\n+import io.pravega.shared.metrics.ClientMetricUpdater;\n+import io.pravega.shared.metrics.MetricListener;\n+import io.pravega.shared.metrics.MetricNotifier;\n+import io.pravega.shared.protocol.netty.PravegaNodeUri;\n+import io.pravega.shared.protocol.netty.ReplyProcessor;\n+import lombok.Data;\n+import lombok.Synchronized;\n+import lombok.extern.slf4j.Slf4j;\n+\n+@Slf4j\n+public class ConnectionPoolImpl implements ConnectionPool {\n+\n+    /**\n+     * This class represents a Connection that is established with a Segment Store instance and its\n+     * attributes. (e.g: FlowCount, WriterCount)\n+     */\n+    @Data\n+    private class Connection implements Comparable<Connection>, AutoCloseable {\n+        private final PravegaNodeUri uri;\n+        /**\n+         * A future that completes when the connection is first established.\n+         */\n+        private final CompletableFuture<FlowHandler> flowHandler;\n+\n+        int getFlowCount() {\n+            return Futures.isSuccessful(flowHandler) ? flowHandler.join().getOpenFlowCount() : 0;\n+        }\n+\n+        boolean isConnected() {\n+            if (!Futures.isSuccessful(flowHandler)) {\n+                return false;\n+            }\n+            return !flowHandler.join().isClosed();\n+        }\n+\n+        @Override\n+        public int compareTo(Connection o) {\n+            int v1 = Futures.isSuccessful(this.getFlowHandler()) ? this.getFlowCount() : Integer.MAX_VALUE;\n+            int v2 = Futures.isSuccessful(o.getFlowHandler()) ? o.getFlowCount() : Integer.MAX_VALUE;\n+            return Integer.compare(v1, v2);\n+        }\n+        \n+        @Override\n+        public void close() {\n+            if (Futures.isSuccessful(flowHandler)) {\n+                flowHandler.join().close();\n+            }\n+        }\n+    }\n+    \n+    private final ClientConfig clientConfig;\n+    private final MetricNotifier metricNotifier;\n+    private final AtomicBoolean closed = new AtomicBoolean(false);\n+    @GuardedBy(\"$lock\")\n+    private final Map<PravegaNodeUri, List<Connection>> connectionMap = new HashMap<>();\n+    private final ConnectionFactory connectionFactory;\n+\n+    public ConnectionPoolImpl(ClientConfig clientConfig, ConnectionFactory connectionFactory) {\n+        this.clientConfig = clientConfig;\n+        this.connectionFactory = connectionFactory;\n+        MetricListener metricListener = clientConfig.getMetricListener();\n+        this.metricNotifier = metricListener == null ? NO_OP_METRIC_NOTIFIER : new ClientMetricUpdater(metricListener);\n+    }\n+\n+    @Override\n+    @Synchronized\n+    public CompletableFuture<ClientConnection> getClientConnection(Flow flow, PravegaNodeUri location, ReplyProcessor rp) {\n+        Preconditions.checkNotNull(flow, \"Flow\");\n+        Preconditions.checkNotNull(location, \"Location\");\n+        Preconditions.checkNotNull(rp, \"ReplyProcessor\");\n+        Exceptions.checkNotClosed(closed.get(), this);\n+\n+        final List<Connection> connectionList = connectionMap.getOrDefault(location, new ArrayList<>());\n+\n+        // remove connections for which the underlying network connection is disconnected.\n+        List<Connection> prunedConnectionList = connectionList.stream().filter(connection -> {\n+            // Filter out Connection objects which have been completed exceptionally or have been disconnected.\n+            return !connection.getFlowHandler().isDone() || connection.isConnected();\n+        }).collect(Collectors.toList());\n+        log.debug(\"List of connections to {} that can be used: {}\", location, prunedConnectionList);\n+\n+        // Choose the connection with the least number of flows.\n+        Optional<Connection> suggestedConnection = prunedConnectionList.stream().min(Comparator.naturalOrder());\n+\n+        final Connection connection;\n+        if (suggestedConnection.isPresent() && (prunedConnectionList.size() >= clientConfig.getMaxConnectionsPerSegmentStore() || isUnused(suggestedConnection.get()))) {\n+            log.info(\"Reusing connection: {}\", suggestedConnection.get());\n+            connection = suggestedConnection.get();\n+        } else {\n+            // create a new connection.\n+            log.info(\"Creating a new connection to {}\", location);\n+            CompletableFuture<FlowHandler> establishedFuture = establishConnection(location);\n+            connection = new Connection(location, establishedFuture);\n+            prunedConnectionList.add(connection);\n+        }\n+        connectionMap.put(location, prunedConnectionList);\n+        return connection.getFlowHandler().thenApply(flowHandler -> flowHandler.createFlow(flow, rp));\n+    }\n+\n+    @Override\n+    @Synchronized\n+    public CompletableFuture<ClientConnection> getClientConnection(PravegaNodeUri location, ReplyProcessor rp) {\n+        Preconditions.checkNotNull(location, \"Location\");\n+        Preconditions.checkNotNull(rp, \"ReplyProcessor\");\n+        Exceptions.checkNotClosed(closed.get(), this);\n+\n+        // create a new connection.\n+        CompletableFuture<FlowHandler> handler = establishConnection(location);\n+        Connection connection = new Connection(location, handler);\n+        return connection.getFlowHandler().thenApply(h -> h.createConnectionWithFlowDisabled(rp));\n+    }\n+\n+    private static boolean isUnused(Connection connection) {\n+        return Futures.isSuccessful(connection.getFlowHandler()) && connection.getFlowCount() == 0;\n+    }\n+\n+    /**\n+     * Used only for testing.\n+     */\n+    @VisibleForTesting\n+    @Synchronized\n+    public void pruneUnusedConnections() {\n+        for (List<Connection> connections : connectionMap.values()) {\n+            for (Iterator<Connection> iterator = connections.iterator(); iterator.hasNext();) {\n+                Connection connection = iterator.next();\n+                if (isUnused(connection)) {\n+                    connection.getFlowHandler().join().close();\n+                    iterator.remove();\n+                }\n+            }\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    @Synchronized\n+    public List<Connection> getActiveChannels() {\n+        ArrayList<Connection> result = new ArrayList<Connection>();\n+        for (List<Connection> connection : this.connectionMap.values()) {\n+            result.addAll(connection);\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Establish a new connection to the Pravega Node.\n+     * @param location The Pravega Node Uri\n+     * @return A future, which completes once the connection has been established, returning a FlowHandler that can be used to create\n+     * flows on the connection.\n+     */\n+    private CompletableFuture<FlowHandler> establishConnection(PravegaNodeUri location) {\n+        return FlowHandler.openConnection(location, clientConfig, metricNotifier, connectionFactory);\n+    }\n+\n+    @Override\n+    public void close() {\n+        log.info(\"Shutting down connection pool\");\n+        if (closed.compareAndSet(false, true)) {\n+            metricNotifier.close();\n+            connectionFactory.close();\n+            for (List<Connection> connections : connectionMap.values()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQxNDgxMg=="}, "originalCommit": {"oid": "6c76edd8affdbba70c9e5767a4c8f93c09c51fce"}, "originalPosition": 194}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNDI4MDc4OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/connection/impl/TcpClientConnection.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxNDo1OTowMlrOGxXtlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxNDo1OTowMlrOGxXtlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQyMTkxMQ==", "bodyText": "nit:typo", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r454421911", "createdAt": "2020-07-14T14:59:02Z", "author": {"login": "shrids"}, "path": "client/src/main/java/io/pravega/client/connection/impl/TcpClientConnection.java", "diffHunk": "@@ -0,0 +1,320 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.connection.impl;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import io.netty.buffer.ByteBuf;\n+import io.pravega.client.ClientConfig;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import io.pravega.common.util.CertificateUtils;\n+import io.pravega.shared.protocol.netty.Append;\n+import io.pravega.shared.protocol.netty.AppendBatchSizeTracker;\n+import io.pravega.shared.protocol.netty.ConnectionFailedException;\n+import io.pravega.shared.protocol.netty.EnhancedByteBufInputStream;\n+import io.pravega.shared.protocol.netty.InvalidMessageException;\n+import io.pravega.shared.protocol.netty.PravegaNodeUri;\n+import io.pravega.shared.protocol.netty.Reply;\n+import io.pravega.shared.protocol.netty.ReplyProcessor;\n+import io.pravega.shared.protocol.netty.WireCommand;\n+import io.pravega.shared.protocol.netty.WireCommandType;\n+import io.pravega.shared.protocol.netty.WireCommands;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.SocketException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.CertificateException;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLParameters;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.TrustManagerFactory;\n+import lombok.RequiredArgsConstructor;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.pravega.shared.protocol.netty.AppendBatchSizeTracker.MAX_BATCH_TIME_MILLIS;\n+\n+@Slf4j\n+public class TcpClientConnection implements ClientConnection {\n+\n+    static final int TCP_BUFFER_SIZE = 256 * 1024;\n+    \n+    private final Socket socket;\n+    private final CommandEncoder encoder;\n+    private final ConnectionReader reader;\n+    private final AtomicBoolean closed = new AtomicBoolean(false);\n+    private final PravegaNodeUri location;\n+    private final Runnable onClose;\n+    private final ScheduledFuture<?> timeoutFuture;\n+   \n+    private TcpClientConnection(Socket socket, CommandEncoder encoder, ConnectionReader reader, PravegaNodeUri location,\n+                                Runnable onClose, ScheduledExecutorService executor) {\n+        this.socket = checkNotNull(socket);\n+        this.encoder = checkNotNull(encoder);\n+        this.reader = checkNotNull(reader);\n+        this.location = checkNotNull(location);\n+        this.onClose = onClose;\n+        this.timeoutFuture = executor.scheduleWithFixedDelay(new TimeoutBatch(encoder),\n+                                                             MAX_BATCH_TIME_MILLIS,\n+                                                             MAX_BATCH_TIME_MILLIS,\n+                                                             TimeUnit.MILLISECONDS);\n+    }\n+\n+    @VisibleForTesting\n+    static class ConnectionReader implements Runnable {\n+        static final ThreadFactory THREAD_FACTORY = ExecutorServiceHelpers.getThreadFactory(\"ClientSocketReaders\", (Thread.NORM_PRIORITY + Thread.MAX_PRIORITY) / 2);\n+        \n+        private final String name;\n+        private final InputStream in;\n+        private final ReplyProcessor callback;\n+        private final Thread thread;\n+        private final AppendBatchSizeTracker batchSizeTracker;\n+        private final AtomicBoolean stop = new AtomicBoolean(false);\n+\n+        public ConnectionReader(String name, InputStream in, ReplyProcessor callback,\n+                                AppendBatchSizeTracker batchSizeTracker) {\n+            this.name = name;\n+            this.in = in;\n+            this.callback = callback;\n+            this.thread = THREAD_FACTORY.newThread(this);\n+            this.batchSizeTracker = batchSizeTracker;\n+        }\n+        \n+        public void start() {\n+            thread.start();\n+        }\n+        \n+        public void run() {\n+            IoBuffer buffer = new IoBuffer();\n+            while (!stop.get()) {\n+                try {\n+                    WireCommand command = readCommand(in, buffer);\n+                    if (command instanceof WireCommands.DataAppended) {\n+                        WireCommands.DataAppended dataAppended = (WireCommands.DataAppended) command;\n+                        batchSizeTracker.recordAck(dataAppended.getEventNumber());\n+                    }\n+                    try {\n+                        callback.process((Reply) command);\n+                    } catch (Exception e) {\n+                        callback.processingFailure(e);\n+                    }\n+                } catch (SocketException e) {\n+                    if (e.getMessage().equals(\"Socket closed\")) {\n+                        log.info(\"Closing TcpConnection.Reader because socket is closed.\");\n+                    } else {\n+                        log.warn(\"Error in reading from socket.\", e);\n+                    }\n+                    stop();\n+                } catch (EOFException e) {\n+                    log.info(\"Closing TcpConnection.Reader because end of input readched.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c76edd8affdbba70c9e5767a4c8f93c09c51fce"}, "originalPosition": 130}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNDM0Mjk5OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/connection/impl/TcpClientConnection.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxNToxMjoyN1rOGxYUmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQyMToxMDo1M1rOGxle1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQzMTg5OA==", "bodyText": "This can throw an exception during socket.connect(...) causing the thread to silently fail.", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r454431898", "createdAt": "2020-07-14T15:12:27Z", "author": {"login": "shrids"}, "path": "client/src/main/java/io/pravega/client/connection/impl/TcpClientConnection.java", "diffHunk": "@@ -0,0 +1,320 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.connection.impl;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import io.netty.buffer.ByteBuf;\n+import io.pravega.client.ClientConfig;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import io.pravega.common.util.CertificateUtils;\n+import io.pravega.shared.protocol.netty.Append;\n+import io.pravega.shared.protocol.netty.AppendBatchSizeTracker;\n+import io.pravega.shared.protocol.netty.ConnectionFailedException;\n+import io.pravega.shared.protocol.netty.EnhancedByteBufInputStream;\n+import io.pravega.shared.protocol.netty.InvalidMessageException;\n+import io.pravega.shared.protocol.netty.PravegaNodeUri;\n+import io.pravega.shared.protocol.netty.Reply;\n+import io.pravega.shared.protocol.netty.ReplyProcessor;\n+import io.pravega.shared.protocol.netty.WireCommand;\n+import io.pravega.shared.protocol.netty.WireCommandType;\n+import io.pravega.shared.protocol.netty.WireCommands;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.SocketException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.CertificateException;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLParameters;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.TrustManagerFactory;\n+import lombok.RequiredArgsConstructor;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.pravega.shared.protocol.netty.AppendBatchSizeTracker.MAX_BATCH_TIME_MILLIS;\n+\n+@Slf4j\n+public class TcpClientConnection implements ClientConnection {\n+\n+    static final int TCP_BUFFER_SIZE = 256 * 1024;\n+    \n+    private final Socket socket;\n+    private final CommandEncoder encoder;\n+    private final ConnectionReader reader;\n+    private final AtomicBoolean closed = new AtomicBoolean(false);\n+    private final PravegaNodeUri location;\n+    private final Runnable onClose;\n+    private final ScheduledFuture<?> timeoutFuture;\n+   \n+    private TcpClientConnection(Socket socket, CommandEncoder encoder, ConnectionReader reader, PravegaNodeUri location,\n+                                Runnable onClose, ScheduledExecutorService executor) {\n+        this.socket = checkNotNull(socket);\n+        this.encoder = checkNotNull(encoder);\n+        this.reader = checkNotNull(reader);\n+        this.location = checkNotNull(location);\n+        this.onClose = onClose;\n+        this.timeoutFuture = executor.scheduleWithFixedDelay(new TimeoutBatch(encoder),\n+                                                             MAX_BATCH_TIME_MILLIS,\n+                                                             MAX_BATCH_TIME_MILLIS,\n+                                                             TimeUnit.MILLISECONDS);\n+    }\n+\n+    @VisibleForTesting\n+    static class ConnectionReader implements Runnable {\n+        static final ThreadFactory THREAD_FACTORY = ExecutorServiceHelpers.getThreadFactory(\"ClientSocketReaders\", (Thread.NORM_PRIORITY + Thread.MAX_PRIORITY) / 2);\n+        \n+        private final String name;\n+        private final InputStream in;\n+        private final ReplyProcessor callback;\n+        private final Thread thread;\n+        private final AppendBatchSizeTracker batchSizeTracker;\n+        private final AtomicBoolean stop = new AtomicBoolean(false);\n+\n+        public ConnectionReader(String name, InputStream in, ReplyProcessor callback,\n+                                AppendBatchSizeTracker batchSizeTracker) {\n+            this.name = name;\n+            this.in = in;\n+            this.callback = callback;\n+            this.thread = THREAD_FACTORY.newThread(this);\n+            this.batchSizeTracker = batchSizeTracker;\n+        }\n+        \n+        public void start() {\n+            thread.start();\n+        }\n+        \n+        public void run() {\n+            IoBuffer buffer = new IoBuffer();\n+            while (!stop.get()) {\n+                try {\n+                    WireCommand command = readCommand(in, buffer);\n+                    if (command instanceof WireCommands.DataAppended) {\n+                        WireCommands.DataAppended dataAppended = (WireCommands.DataAppended) command;\n+                        batchSizeTracker.recordAck(dataAppended.getEventNumber());\n+                    }\n+                    try {\n+                        callback.process((Reply) command);\n+                    } catch (Exception e) {\n+                        callback.processingFailure(e);\n+                    }\n+                } catch (SocketException e) {\n+                    if (e.getMessage().equals(\"Socket closed\")) {\n+                        log.info(\"Closing TcpConnection.Reader because socket is closed.\");\n+                    } else {\n+                        log.warn(\"Error in reading from socket.\", e);\n+                    }\n+                    stop();\n+                } catch (EOFException e) {\n+                    log.info(\"Closing TcpConnection.Reader because end of input readched.\");\n+                    stop();\n+                } catch (Exception e) {\n+                    log.warn(\"Error processing data from from server \" + name, e);\n+                    stop();\n+                }\n+            }\n+        }\n+\n+        @VisibleForTesting\n+        static WireCommand readCommand(InputStream in, IoBuffer buffer) throws IOException {\n+            ByteBuf header = buffer.getBuffOfSize(in, 8);\n+\n+            int t = header.getInt(0);\n+            WireCommandType type = WireCommands.getType(t);\n+            if (type == null) {\n+                throw new InvalidMessageException(\"Unknown wire command: \" + t);\n+            }\n+\n+            int length = header.getInt(4);\n+            if (length < 0 || length > WireCommands.MAX_WIRECOMMAND_SIZE) {\n+                throw new InvalidMessageException(\"Event of invalid length: \" + length);\n+            }\n+\n+            ByteBuf payload = buffer.getBuffOfSize(in, length);\n+            \n+            return type.readFrom(new EnhancedByteBufInputStream(payload), length);\n+        }\n+        \n+        public void stop() {\n+            stop.set(true);\n+            try {\n+                in.close();\n+            } catch (Exception e) {\n+                log.warn(\"Got error while shutting down reader {}. \", name, e);\n+            }\n+            callback.connectionDropped();\n+        }\n+    }\n+    \n+    @RequiredArgsConstructor\n+    private static final class TimeoutBatch implements Runnable {\n+        private final AtomicLong token = new AtomicLong(-1);\n+        private final CommandEncoder encoder;\n+        @Override\n+        public void run() {\n+            token.set(encoder.batchTimeout(token.get()));\n+        }    \n+    }\n+\n+    public static CompletableFuture<TcpClientConnection> connect(PravegaNodeUri location, ClientConfig clientConfig, ReplyProcessor callback,\n+                                              ScheduledExecutorService executor, Runnable onClose) {\n+        return CompletableFuture.supplyAsync(() -> {\n+            Socket socket = createClientSocket(location, clientConfig); ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c76edd8affdbba70c9e5767a4c8f93c09c51fce"}, "originalPosition": 183}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY0NzUwOA==", "bodyText": "If socket.connect throws the Runnable supplied to supplyAsync will fail, which will cause the future returned from connect to fail with the exception. It would only be silent if the caller does not join on the future returned from connect(). (Which is unlikely as they need the connection)", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r454647508", "createdAt": "2020-07-14T21:10:53Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/connection/impl/TcpClientConnection.java", "diffHunk": "@@ -0,0 +1,320 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.connection.impl;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import io.netty.buffer.ByteBuf;\n+import io.pravega.client.ClientConfig;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import io.pravega.common.util.CertificateUtils;\n+import io.pravega.shared.protocol.netty.Append;\n+import io.pravega.shared.protocol.netty.AppendBatchSizeTracker;\n+import io.pravega.shared.protocol.netty.ConnectionFailedException;\n+import io.pravega.shared.protocol.netty.EnhancedByteBufInputStream;\n+import io.pravega.shared.protocol.netty.InvalidMessageException;\n+import io.pravega.shared.protocol.netty.PravegaNodeUri;\n+import io.pravega.shared.protocol.netty.Reply;\n+import io.pravega.shared.protocol.netty.ReplyProcessor;\n+import io.pravega.shared.protocol.netty.WireCommand;\n+import io.pravega.shared.protocol.netty.WireCommandType;\n+import io.pravega.shared.protocol.netty.WireCommands;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.SocketException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.CertificateException;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLParameters;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.TrustManagerFactory;\n+import lombok.RequiredArgsConstructor;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.pravega.shared.protocol.netty.AppendBatchSizeTracker.MAX_BATCH_TIME_MILLIS;\n+\n+@Slf4j\n+public class TcpClientConnection implements ClientConnection {\n+\n+    static final int TCP_BUFFER_SIZE = 256 * 1024;\n+    \n+    private final Socket socket;\n+    private final CommandEncoder encoder;\n+    private final ConnectionReader reader;\n+    private final AtomicBoolean closed = new AtomicBoolean(false);\n+    private final PravegaNodeUri location;\n+    private final Runnable onClose;\n+    private final ScheduledFuture<?> timeoutFuture;\n+   \n+    private TcpClientConnection(Socket socket, CommandEncoder encoder, ConnectionReader reader, PravegaNodeUri location,\n+                                Runnable onClose, ScheduledExecutorService executor) {\n+        this.socket = checkNotNull(socket);\n+        this.encoder = checkNotNull(encoder);\n+        this.reader = checkNotNull(reader);\n+        this.location = checkNotNull(location);\n+        this.onClose = onClose;\n+        this.timeoutFuture = executor.scheduleWithFixedDelay(new TimeoutBatch(encoder),\n+                                                             MAX_BATCH_TIME_MILLIS,\n+                                                             MAX_BATCH_TIME_MILLIS,\n+                                                             TimeUnit.MILLISECONDS);\n+    }\n+\n+    @VisibleForTesting\n+    static class ConnectionReader implements Runnable {\n+        static final ThreadFactory THREAD_FACTORY = ExecutorServiceHelpers.getThreadFactory(\"ClientSocketReaders\", (Thread.NORM_PRIORITY + Thread.MAX_PRIORITY) / 2);\n+        \n+        private final String name;\n+        private final InputStream in;\n+        private final ReplyProcessor callback;\n+        private final Thread thread;\n+        private final AppendBatchSizeTracker batchSizeTracker;\n+        private final AtomicBoolean stop = new AtomicBoolean(false);\n+\n+        public ConnectionReader(String name, InputStream in, ReplyProcessor callback,\n+                                AppendBatchSizeTracker batchSizeTracker) {\n+            this.name = name;\n+            this.in = in;\n+            this.callback = callback;\n+            this.thread = THREAD_FACTORY.newThread(this);\n+            this.batchSizeTracker = batchSizeTracker;\n+        }\n+        \n+        public void start() {\n+            thread.start();\n+        }\n+        \n+        public void run() {\n+            IoBuffer buffer = new IoBuffer();\n+            while (!stop.get()) {\n+                try {\n+                    WireCommand command = readCommand(in, buffer);\n+                    if (command instanceof WireCommands.DataAppended) {\n+                        WireCommands.DataAppended dataAppended = (WireCommands.DataAppended) command;\n+                        batchSizeTracker.recordAck(dataAppended.getEventNumber());\n+                    }\n+                    try {\n+                        callback.process((Reply) command);\n+                    } catch (Exception e) {\n+                        callback.processingFailure(e);\n+                    }\n+                } catch (SocketException e) {\n+                    if (e.getMessage().equals(\"Socket closed\")) {\n+                        log.info(\"Closing TcpConnection.Reader because socket is closed.\");\n+                    } else {\n+                        log.warn(\"Error in reading from socket.\", e);\n+                    }\n+                    stop();\n+                } catch (EOFException e) {\n+                    log.info(\"Closing TcpConnection.Reader because end of input readched.\");\n+                    stop();\n+                } catch (Exception e) {\n+                    log.warn(\"Error processing data from from server \" + name, e);\n+                    stop();\n+                }\n+            }\n+        }\n+\n+        @VisibleForTesting\n+        static WireCommand readCommand(InputStream in, IoBuffer buffer) throws IOException {\n+            ByteBuf header = buffer.getBuffOfSize(in, 8);\n+\n+            int t = header.getInt(0);\n+            WireCommandType type = WireCommands.getType(t);\n+            if (type == null) {\n+                throw new InvalidMessageException(\"Unknown wire command: \" + t);\n+            }\n+\n+            int length = header.getInt(4);\n+            if (length < 0 || length > WireCommands.MAX_WIRECOMMAND_SIZE) {\n+                throw new InvalidMessageException(\"Event of invalid length: \" + length);\n+            }\n+\n+            ByteBuf payload = buffer.getBuffOfSize(in, length);\n+            \n+            return type.readFrom(new EnhancedByteBufInputStream(payload), length);\n+        }\n+        \n+        public void stop() {\n+            stop.set(true);\n+            try {\n+                in.close();\n+            } catch (Exception e) {\n+                log.warn(\"Got error while shutting down reader {}. \", name, e);\n+            }\n+            callback.connectionDropped();\n+        }\n+    }\n+    \n+    @RequiredArgsConstructor\n+    private static final class TimeoutBatch implements Runnable {\n+        private final AtomicLong token = new AtomicLong(-1);\n+        private final CommandEncoder encoder;\n+        @Override\n+        public void run() {\n+            token.set(encoder.batchTimeout(token.get()));\n+        }    \n+    }\n+\n+    public static CompletableFuture<TcpClientConnection> connect(PravegaNodeUri location, ClientConfig clientConfig, ReplyProcessor callback,\n+                                              ScheduledExecutorService executor, Runnable onClose) {\n+        return CompletableFuture.supplyAsync(() -> {\n+            Socket socket = createClientSocket(location, clientConfig); ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQzMTg5OA=="}, "originalCommit": {"oid": "6c76edd8affdbba70c9e5767a4c8f93c09c51fce"}, "originalPosition": 183}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNDM2MDU4OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/connection/impl/TcpClientConnection.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxNToxNjoxOFrOGxYfgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxNToxNjoxOFrOGxYfgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQzNDY4OA==", "bodyText": "nit: { } in the log .warn?", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r454434688", "createdAt": "2020-07-14T15:16:18Z", "author": {"login": "shrids"}, "path": "client/src/main/java/io/pravega/client/connection/impl/TcpClientConnection.java", "diffHunk": "@@ -0,0 +1,320 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.connection.impl;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import io.netty.buffer.ByteBuf;\n+import io.pravega.client.ClientConfig;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import io.pravega.common.util.CertificateUtils;\n+import io.pravega.shared.protocol.netty.Append;\n+import io.pravega.shared.protocol.netty.AppendBatchSizeTracker;\n+import io.pravega.shared.protocol.netty.ConnectionFailedException;\n+import io.pravega.shared.protocol.netty.EnhancedByteBufInputStream;\n+import io.pravega.shared.protocol.netty.InvalidMessageException;\n+import io.pravega.shared.protocol.netty.PravegaNodeUri;\n+import io.pravega.shared.protocol.netty.Reply;\n+import io.pravega.shared.protocol.netty.ReplyProcessor;\n+import io.pravega.shared.protocol.netty.WireCommand;\n+import io.pravega.shared.protocol.netty.WireCommandType;\n+import io.pravega.shared.protocol.netty.WireCommands;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.SocketException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.CertificateException;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLParameters;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.TrustManagerFactory;\n+import lombok.RequiredArgsConstructor;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.pravega.shared.protocol.netty.AppendBatchSizeTracker.MAX_BATCH_TIME_MILLIS;\n+\n+@Slf4j\n+public class TcpClientConnection implements ClientConnection {\n+\n+    static final int TCP_BUFFER_SIZE = 256 * 1024;\n+    \n+    private final Socket socket;\n+    private final CommandEncoder encoder;\n+    private final ConnectionReader reader;\n+    private final AtomicBoolean closed = new AtomicBoolean(false);\n+    private final PravegaNodeUri location;\n+    private final Runnable onClose;\n+    private final ScheduledFuture<?> timeoutFuture;\n+   \n+    private TcpClientConnection(Socket socket, CommandEncoder encoder, ConnectionReader reader, PravegaNodeUri location,\n+                                Runnable onClose, ScheduledExecutorService executor) {\n+        this.socket = checkNotNull(socket);\n+        this.encoder = checkNotNull(encoder);\n+        this.reader = checkNotNull(reader);\n+        this.location = checkNotNull(location);\n+        this.onClose = onClose;\n+        this.timeoutFuture = executor.scheduleWithFixedDelay(new TimeoutBatch(encoder),\n+                                                             MAX_BATCH_TIME_MILLIS,\n+                                                             MAX_BATCH_TIME_MILLIS,\n+                                                             TimeUnit.MILLISECONDS);\n+    }\n+\n+    @VisibleForTesting\n+    static class ConnectionReader implements Runnable {\n+        static final ThreadFactory THREAD_FACTORY = ExecutorServiceHelpers.getThreadFactory(\"ClientSocketReaders\", (Thread.NORM_PRIORITY + Thread.MAX_PRIORITY) / 2);\n+        \n+        private final String name;\n+        private final InputStream in;\n+        private final ReplyProcessor callback;\n+        private final Thread thread;\n+        private final AppendBatchSizeTracker batchSizeTracker;\n+        private final AtomicBoolean stop = new AtomicBoolean(false);\n+\n+        public ConnectionReader(String name, InputStream in, ReplyProcessor callback,\n+                                AppendBatchSizeTracker batchSizeTracker) {\n+            this.name = name;\n+            this.in = in;\n+            this.callback = callback;\n+            this.thread = THREAD_FACTORY.newThread(this);\n+            this.batchSizeTracker = batchSizeTracker;\n+        }\n+        \n+        public void start() {\n+            thread.start();\n+        }\n+        \n+        public void run() {\n+            IoBuffer buffer = new IoBuffer();\n+            while (!stop.get()) {\n+                try {\n+                    WireCommand command = readCommand(in, buffer);\n+                    if (command instanceof WireCommands.DataAppended) {\n+                        WireCommands.DataAppended dataAppended = (WireCommands.DataAppended) command;\n+                        batchSizeTracker.recordAck(dataAppended.getEventNumber());\n+                    }\n+                    try {\n+                        callback.process((Reply) command);\n+                    } catch (Exception e) {\n+                        callback.processingFailure(e);\n+                    }\n+                } catch (SocketException e) {\n+                    if (e.getMessage().equals(\"Socket closed\")) {\n+                        log.info(\"Closing TcpConnection.Reader because socket is closed.\");\n+                    } else {\n+                        log.warn(\"Error in reading from socket.\", e);\n+                    }\n+                    stop();\n+                } catch (EOFException e) {\n+                    log.info(\"Closing TcpConnection.Reader because end of input readched.\");\n+                    stop();\n+                } catch (Exception e) {\n+                    log.warn(\"Error processing data from from server \" + name, e);\n+                    stop();\n+                }\n+            }\n+        }\n+\n+        @VisibleForTesting\n+        static WireCommand readCommand(InputStream in, IoBuffer buffer) throws IOException {\n+            ByteBuf header = buffer.getBuffOfSize(in, 8);\n+\n+            int t = header.getInt(0);\n+            WireCommandType type = WireCommands.getType(t);\n+            if (type == null) {\n+                throw new InvalidMessageException(\"Unknown wire command: \" + t);\n+            }\n+\n+            int length = header.getInt(4);\n+            if (length < 0 || length > WireCommands.MAX_WIRECOMMAND_SIZE) {\n+                throw new InvalidMessageException(\"Event of invalid length: \" + length);\n+            }\n+\n+            ByteBuf payload = buffer.getBuffOfSize(in, length);\n+            \n+            return type.readFrom(new EnhancedByteBufInputStream(payload), length);\n+        }\n+        \n+        public void stop() {\n+            stop.set(true);\n+            try {\n+                in.close();\n+            } catch (Exception e) {\n+                log.warn(\"Got error while shutting down reader {}. \", name, e);\n+            }\n+            callback.connectionDropped();\n+        }\n+    }\n+    \n+    @RequiredArgsConstructor\n+    private static final class TimeoutBatch implements Runnable {\n+        private final AtomicLong token = new AtomicLong(-1);\n+        private final CommandEncoder encoder;\n+        @Override\n+        public void run() {\n+            token.set(encoder.batchTimeout(token.get()));\n+        }    \n+    }\n+\n+    public static CompletableFuture<TcpClientConnection> connect(PravegaNodeUri location, ClientConfig clientConfig, ReplyProcessor callback,\n+                                              ScheduledExecutorService executor, Runnable onClose) {\n+        return CompletableFuture.supplyAsync(() -> {\n+            Socket socket = createClientSocket(location, clientConfig); \n+            try {\n+                InputStream inputStream = socket.getInputStream();\n+                AppendBatchSizeTrackerImpl batchSizeTracker = new AppendBatchSizeTrackerImpl();\n+                ConnectionReader reader = new ConnectionReader(location.toString(), inputStream, callback, batchSizeTracker);\n+                reader.start();\n+                CommandEncoder encoder = new CommandEncoder(l -> batchSizeTracker, null, socket.getOutputStream());\n+                return new TcpClientConnection(socket, encoder, reader, location, onClose, executor);\n+            } catch (Exception e) {\n+                try {\n+                    socket.close();\n+                } catch (IOException e1) {\n+                    log.warn(\"Failed to close socket while failing.\", e1);\n+                }\n+                onClose.run();\n+                throw Exceptions.sneakyThrow(e);\n+            }\n+        }, executor);\n+    }\n+\n+    private static TrustManagerFactory createFromCert(String trustStoreFilePath)\n+            throws CertificateException, IOException, NoSuchAlgorithmException, KeyStoreException {\n+        TrustManagerFactory factory = null;\n+        if (!Strings.isNullOrEmpty(trustStoreFilePath)) {\n+            KeyStore trustStore = CertificateUtils.createTrustStore(trustStoreFilePath);\n+\n+            factory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n+            factory.init(trustStore);\n+        }\n+        return factory;\n+    }\n+\n+    /**\n+     * Creates a socket connected to the provided endpoint. \n+     * Note that this is a sync call even though it is called in an async context. \n+     * While this is normally frowned upon, it is simply not possible to construct an SSL socket asynchronously in Java.\n+     */\n+    @SneakyThrows //Is called inside a completable future.\n+    private static Socket createClientSocket(PravegaNodeUri location, ClientConfig clientConfig) {        \n+        Socket result;\n+        if (clientConfig.isEnableTlsToSegmentStore()) {\n+            TrustManagerFactory trustMgrFactory = createFromCert(clientConfig.getTrustStore());\n+\n+            // Prepare a TLS context that uses the trust manager\n+            SSLContext tlsContext = SSLContext.getInstance(\"TLS\");\n+            tlsContext.init(null,\n+                    trustMgrFactory != null ? trustMgrFactory.getTrustManagers() : null,\n+                    null);\n+\n+            SSLSocket tlsClientSocket = (SSLSocket) tlsContext.getSocketFactory().createSocket();\n+\n+            // SSLSocket does not perform hostname verification by default. So, we must explicitly enable it.\n+            if (clientConfig.isValidateHostName()) {\n+                SSLParameters tlsParams = new SSLParameters();\n+\n+                // While the connection is to a TCP service and not an HTTP server, we use `HTTPS` as the endpoint\n+                // identification algorithm, which in turn ensures that the SSLSocket will verify the server's host\n+                // name during TLS handshake. This is a commonly used way of enabling hostname verification\n+                // regardless of whether the service itself is HTTP (no in this case).\n+                tlsParams.setEndpointIdentificationAlgorithm(\"HTTPS\");\n+                tlsClientSocket.setSSLParameters(tlsParams);\n+            }\n+            result = tlsClientSocket;\n+\n+        } else {\n+            result = new Socket();\n+        }\n+        result.setSendBufferSize(TCP_BUFFER_SIZE);\n+        result.setReceiveBufferSize(TCP_BUFFER_SIZE);\n+        result.setTcpNoDelay(true);\n+        result.connect(new InetSocketAddress(location.getEndpoint(), location.getPort()));\n+        return result;\n+    }\n+\n+    @Override\n+    public void send(WireCommand cmd) throws ConnectionFailedException {\n+        if (closed.get()) {\n+            throw new ConnectionFailedException(\"Connection is closed\");\n+        }\n+        try {\n+            encoder.write(cmd);\n+        } catch (IOException e) {\n+            log.warn(\"Error writing to connection\", e.toString());\n+            close();\n+            throw new ConnectionFailedException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void send(Append append) throws ConnectionFailedException {\n+        if (closed.get()) {\n+            throw new ConnectionFailedException(\"Connection is closed\");\n+        }\n+        try {\n+            encoder.write(append);\n+        } catch (IOException e) {\n+            log.warn(\"Error writing to connection\", e.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c76edd8affdbba70c9e5767a4c8f93c09c51fce"}, "originalPosition": 279}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNDM2MTg5OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/connection/impl/TcpClientConnection.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxNToxNjozNlrOGxYgZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxNToxNjozNlrOGxYgZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQzNDkxOQ==", "bodyText": "nit: { } in the log statement ?", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r454434919", "createdAt": "2020-07-14T15:16:36Z", "author": {"login": "shrids"}, "path": "client/src/main/java/io/pravega/client/connection/impl/TcpClientConnection.java", "diffHunk": "@@ -0,0 +1,320 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.connection.impl;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import io.netty.buffer.ByteBuf;\n+import io.pravega.client.ClientConfig;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import io.pravega.common.util.CertificateUtils;\n+import io.pravega.shared.protocol.netty.Append;\n+import io.pravega.shared.protocol.netty.AppendBatchSizeTracker;\n+import io.pravega.shared.protocol.netty.ConnectionFailedException;\n+import io.pravega.shared.protocol.netty.EnhancedByteBufInputStream;\n+import io.pravega.shared.protocol.netty.InvalidMessageException;\n+import io.pravega.shared.protocol.netty.PravegaNodeUri;\n+import io.pravega.shared.protocol.netty.Reply;\n+import io.pravega.shared.protocol.netty.ReplyProcessor;\n+import io.pravega.shared.protocol.netty.WireCommand;\n+import io.pravega.shared.protocol.netty.WireCommandType;\n+import io.pravega.shared.protocol.netty.WireCommands;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.SocketException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.CertificateException;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLParameters;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.TrustManagerFactory;\n+import lombok.RequiredArgsConstructor;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.pravega.shared.protocol.netty.AppendBatchSizeTracker.MAX_BATCH_TIME_MILLIS;\n+\n+@Slf4j\n+public class TcpClientConnection implements ClientConnection {\n+\n+    static final int TCP_BUFFER_SIZE = 256 * 1024;\n+    \n+    private final Socket socket;\n+    private final CommandEncoder encoder;\n+    private final ConnectionReader reader;\n+    private final AtomicBoolean closed = new AtomicBoolean(false);\n+    private final PravegaNodeUri location;\n+    private final Runnable onClose;\n+    private final ScheduledFuture<?> timeoutFuture;\n+   \n+    private TcpClientConnection(Socket socket, CommandEncoder encoder, ConnectionReader reader, PravegaNodeUri location,\n+                                Runnable onClose, ScheduledExecutorService executor) {\n+        this.socket = checkNotNull(socket);\n+        this.encoder = checkNotNull(encoder);\n+        this.reader = checkNotNull(reader);\n+        this.location = checkNotNull(location);\n+        this.onClose = onClose;\n+        this.timeoutFuture = executor.scheduleWithFixedDelay(new TimeoutBatch(encoder),\n+                                                             MAX_BATCH_TIME_MILLIS,\n+                                                             MAX_BATCH_TIME_MILLIS,\n+                                                             TimeUnit.MILLISECONDS);\n+    }\n+\n+    @VisibleForTesting\n+    static class ConnectionReader implements Runnable {\n+        static final ThreadFactory THREAD_FACTORY = ExecutorServiceHelpers.getThreadFactory(\"ClientSocketReaders\", (Thread.NORM_PRIORITY + Thread.MAX_PRIORITY) / 2);\n+        \n+        private final String name;\n+        private final InputStream in;\n+        private final ReplyProcessor callback;\n+        private final Thread thread;\n+        private final AppendBatchSizeTracker batchSizeTracker;\n+        private final AtomicBoolean stop = new AtomicBoolean(false);\n+\n+        public ConnectionReader(String name, InputStream in, ReplyProcessor callback,\n+                                AppendBatchSizeTracker batchSizeTracker) {\n+            this.name = name;\n+            this.in = in;\n+            this.callback = callback;\n+            this.thread = THREAD_FACTORY.newThread(this);\n+            this.batchSizeTracker = batchSizeTracker;\n+        }\n+        \n+        public void start() {\n+            thread.start();\n+        }\n+        \n+        public void run() {\n+            IoBuffer buffer = new IoBuffer();\n+            while (!stop.get()) {\n+                try {\n+                    WireCommand command = readCommand(in, buffer);\n+                    if (command instanceof WireCommands.DataAppended) {\n+                        WireCommands.DataAppended dataAppended = (WireCommands.DataAppended) command;\n+                        batchSizeTracker.recordAck(dataAppended.getEventNumber());\n+                    }\n+                    try {\n+                        callback.process((Reply) command);\n+                    } catch (Exception e) {\n+                        callback.processingFailure(e);\n+                    }\n+                } catch (SocketException e) {\n+                    if (e.getMessage().equals(\"Socket closed\")) {\n+                        log.info(\"Closing TcpConnection.Reader because socket is closed.\");\n+                    } else {\n+                        log.warn(\"Error in reading from socket.\", e);\n+                    }\n+                    stop();\n+                } catch (EOFException e) {\n+                    log.info(\"Closing TcpConnection.Reader because end of input readched.\");\n+                    stop();\n+                } catch (Exception e) {\n+                    log.warn(\"Error processing data from from server \" + name, e);\n+                    stop();\n+                }\n+            }\n+        }\n+\n+        @VisibleForTesting\n+        static WireCommand readCommand(InputStream in, IoBuffer buffer) throws IOException {\n+            ByteBuf header = buffer.getBuffOfSize(in, 8);\n+\n+            int t = header.getInt(0);\n+            WireCommandType type = WireCommands.getType(t);\n+            if (type == null) {\n+                throw new InvalidMessageException(\"Unknown wire command: \" + t);\n+            }\n+\n+            int length = header.getInt(4);\n+            if (length < 0 || length > WireCommands.MAX_WIRECOMMAND_SIZE) {\n+                throw new InvalidMessageException(\"Event of invalid length: \" + length);\n+            }\n+\n+            ByteBuf payload = buffer.getBuffOfSize(in, length);\n+            \n+            return type.readFrom(new EnhancedByteBufInputStream(payload), length);\n+        }\n+        \n+        public void stop() {\n+            stop.set(true);\n+            try {\n+                in.close();\n+            } catch (Exception e) {\n+                log.warn(\"Got error while shutting down reader {}. \", name, e);\n+            }\n+            callback.connectionDropped();\n+        }\n+    }\n+    \n+    @RequiredArgsConstructor\n+    private static final class TimeoutBatch implements Runnable {\n+        private final AtomicLong token = new AtomicLong(-1);\n+        private final CommandEncoder encoder;\n+        @Override\n+        public void run() {\n+            token.set(encoder.batchTimeout(token.get()));\n+        }    \n+    }\n+\n+    public static CompletableFuture<TcpClientConnection> connect(PravegaNodeUri location, ClientConfig clientConfig, ReplyProcessor callback,\n+                                              ScheduledExecutorService executor, Runnable onClose) {\n+        return CompletableFuture.supplyAsync(() -> {\n+            Socket socket = createClientSocket(location, clientConfig); \n+            try {\n+                InputStream inputStream = socket.getInputStream();\n+                AppendBatchSizeTrackerImpl batchSizeTracker = new AppendBatchSizeTrackerImpl();\n+                ConnectionReader reader = new ConnectionReader(location.toString(), inputStream, callback, batchSizeTracker);\n+                reader.start();\n+                CommandEncoder encoder = new CommandEncoder(l -> batchSizeTracker, null, socket.getOutputStream());\n+                return new TcpClientConnection(socket, encoder, reader, location, onClose, executor);\n+            } catch (Exception e) {\n+                try {\n+                    socket.close();\n+                } catch (IOException e1) {\n+                    log.warn(\"Failed to close socket while failing.\", e1);\n+                }\n+                onClose.run();\n+                throw Exceptions.sneakyThrow(e);\n+            }\n+        }, executor);\n+    }\n+\n+    private static TrustManagerFactory createFromCert(String trustStoreFilePath)\n+            throws CertificateException, IOException, NoSuchAlgorithmException, KeyStoreException {\n+        TrustManagerFactory factory = null;\n+        if (!Strings.isNullOrEmpty(trustStoreFilePath)) {\n+            KeyStore trustStore = CertificateUtils.createTrustStore(trustStoreFilePath);\n+\n+            factory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n+            factory.init(trustStore);\n+        }\n+        return factory;\n+    }\n+\n+    /**\n+     * Creates a socket connected to the provided endpoint. \n+     * Note that this is a sync call even though it is called in an async context. \n+     * While this is normally frowned upon, it is simply not possible to construct an SSL socket asynchronously in Java.\n+     */\n+    @SneakyThrows //Is called inside a completable future.\n+    private static Socket createClientSocket(PravegaNodeUri location, ClientConfig clientConfig) {        \n+        Socket result;\n+        if (clientConfig.isEnableTlsToSegmentStore()) {\n+            TrustManagerFactory trustMgrFactory = createFromCert(clientConfig.getTrustStore());\n+\n+            // Prepare a TLS context that uses the trust manager\n+            SSLContext tlsContext = SSLContext.getInstance(\"TLS\");\n+            tlsContext.init(null,\n+                    trustMgrFactory != null ? trustMgrFactory.getTrustManagers() : null,\n+                    null);\n+\n+            SSLSocket tlsClientSocket = (SSLSocket) tlsContext.getSocketFactory().createSocket();\n+\n+            // SSLSocket does not perform hostname verification by default. So, we must explicitly enable it.\n+            if (clientConfig.isValidateHostName()) {\n+                SSLParameters tlsParams = new SSLParameters();\n+\n+                // While the connection is to a TCP service and not an HTTP server, we use `HTTPS` as the endpoint\n+                // identification algorithm, which in turn ensures that the SSLSocket will verify the server's host\n+                // name during TLS handshake. This is a commonly used way of enabling hostname verification\n+                // regardless of whether the service itself is HTTP (no in this case).\n+                tlsParams.setEndpointIdentificationAlgorithm(\"HTTPS\");\n+                tlsClientSocket.setSSLParameters(tlsParams);\n+            }\n+            result = tlsClientSocket;\n+\n+        } else {\n+            result = new Socket();\n+        }\n+        result.setSendBufferSize(TCP_BUFFER_SIZE);\n+        result.setReceiveBufferSize(TCP_BUFFER_SIZE);\n+        result.setTcpNoDelay(true);\n+        result.connect(new InetSocketAddress(location.getEndpoint(), location.getPort()));\n+        return result;\n+    }\n+\n+    @Override\n+    public void send(WireCommand cmd) throws ConnectionFailedException {\n+        if (closed.get()) {\n+            throw new ConnectionFailedException(\"Connection is closed\");\n+        }\n+        try {\n+            encoder.write(cmd);\n+        } catch (IOException e) {\n+            log.warn(\"Error writing to connection\", e.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c76edd8affdbba70c9e5767a4c8f93c09c51fce"}, "originalPosition": 265}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNDM2ODM3OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/connection/impl/TcpClientConnection.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxNToxODowN1rOGxYkiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxNToxODowN1rOGxYkiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQzNTk3Ng==", "bodyText": "nit: {} log .", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r454435976", "createdAt": "2020-07-14T15:18:07Z", "author": {"login": "shrids"}, "path": "client/src/main/java/io/pravega/client/connection/impl/TcpClientConnection.java", "diffHunk": "@@ -0,0 +1,320 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.client.connection.impl;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+import io.netty.buffer.ByteBuf;\n+import io.pravega.client.ClientConfig;\n+import io.pravega.common.Exceptions;\n+import io.pravega.common.concurrent.ExecutorServiceHelpers;\n+import io.pravega.common.util.CertificateUtils;\n+import io.pravega.shared.protocol.netty.Append;\n+import io.pravega.shared.protocol.netty.AppendBatchSizeTracker;\n+import io.pravega.shared.protocol.netty.ConnectionFailedException;\n+import io.pravega.shared.protocol.netty.EnhancedByteBufInputStream;\n+import io.pravega.shared.protocol.netty.InvalidMessageException;\n+import io.pravega.shared.protocol.netty.PravegaNodeUri;\n+import io.pravega.shared.protocol.netty.Reply;\n+import io.pravega.shared.protocol.netty.ReplyProcessor;\n+import io.pravega.shared.protocol.netty.WireCommand;\n+import io.pravega.shared.protocol.netty.WireCommandType;\n+import io.pravega.shared.protocol.netty.WireCommands;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.SocketException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.CertificateException;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLParameters;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.TrustManagerFactory;\n+import lombok.RequiredArgsConstructor;\n+import lombok.SneakyThrows;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static io.pravega.shared.protocol.netty.AppendBatchSizeTracker.MAX_BATCH_TIME_MILLIS;\n+\n+@Slf4j\n+public class TcpClientConnection implements ClientConnection {\n+\n+    static final int TCP_BUFFER_SIZE = 256 * 1024;\n+    \n+    private final Socket socket;\n+    private final CommandEncoder encoder;\n+    private final ConnectionReader reader;\n+    private final AtomicBoolean closed = new AtomicBoolean(false);\n+    private final PravegaNodeUri location;\n+    private final Runnable onClose;\n+    private final ScheduledFuture<?> timeoutFuture;\n+   \n+    private TcpClientConnection(Socket socket, CommandEncoder encoder, ConnectionReader reader, PravegaNodeUri location,\n+                                Runnable onClose, ScheduledExecutorService executor) {\n+        this.socket = checkNotNull(socket);\n+        this.encoder = checkNotNull(encoder);\n+        this.reader = checkNotNull(reader);\n+        this.location = checkNotNull(location);\n+        this.onClose = onClose;\n+        this.timeoutFuture = executor.scheduleWithFixedDelay(new TimeoutBatch(encoder),\n+                                                             MAX_BATCH_TIME_MILLIS,\n+                                                             MAX_BATCH_TIME_MILLIS,\n+                                                             TimeUnit.MILLISECONDS);\n+    }\n+\n+    @VisibleForTesting\n+    static class ConnectionReader implements Runnable {\n+        static final ThreadFactory THREAD_FACTORY = ExecutorServiceHelpers.getThreadFactory(\"ClientSocketReaders\", (Thread.NORM_PRIORITY + Thread.MAX_PRIORITY) / 2);\n+        \n+        private final String name;\n+        private final InputStream in;\n+        private final ReplyProcessor callback;\n+        private final Thread thread;\n+        private final AppendBatchSizeTracker batchSizeTracker;\n+        private final AtomicBoolean stop = new AtomicBoolean(false);\n+\n+        public ConnectionReader(String name, InputStream in, ReplyProcessor callback,\n+                                AppendBatchSizeTracker batchSizeTracker) {\n+            this.name = name;\n+            this.in = in;\n+            this.callback = callback;\n+            this.thread = THREAD_FACTORY.newThread(this);\n+            this.batchSizeTracker = batchSizeTracker;\n+        }\n+        \n+        public void start() {\n+            thread.start();\n+        }\n+        \n+        public void run() {\n+            IoBuffer buffer = new IoBuffer();\n+            while (!stop.get()) {\n+                try {\n+                    WireCommand command = readCommand(in, buffer);\n+                    if (command instanceof WireCommands.DataAppended) {\n+                        WireCommands.DataAppended dataAppended = (WireCommands.DataAppended) command;\n+                        batchSizeTracker.recordAck(dataAppended.getEventNumber());\n+                    }\n+                    try {\n+                        callback.process((Reply) command);\n+                    } catch (Exception e) {\n+                        callback.processingFailure(e);\n+                    }\n+                } catch (SocketException e) {\n+                    if (e.getMessage().equals(\"Socket closed\")) {\n+                        log.info(\"Closing TcpConnection.Reader because socket is closed.\");\n+                    } else {\n+                        log.warn(\"Error in reading from socket.\", e);\n+                    }\n+                    stop();\n+                } catch (EOFException e) {\n+                    log.info(\"Closing TcpConnection.Reader because end of input readched.\");\n+                    stop();\n+                } catch (Exception e) {\n+                    log.warn(\"Error processing data from from server \" + name, e);\n+                    stop();\n+                }\n+            }\n+        }\n+\n+        @VisibleForTesting\n+        static WireCommand readCommand(InputStream in, IoBuffer buffer) throws IOException {\n+            ByteBuf header = buffer.getBuffOfSize(in, 8);\n+\n+            int t = header.getInt(0);\n+            WireCommandType type = WireCommands.getType(t);\n+            if (type == null) {\n+                throw new InvalidMessageException(\"Unknown wire command: \" + t);\n+            }\n+\n+            int length = header.getInt(4);\n+            if (length < 0 || length > WireCommands.MAX_WIRECOMMAND_SIZE) {\n+                throw new InvalidMessageException(\"Event of invalid length: \" + length);\n+            }\n+\n+            ByteBuf payload = buffer.getBuffOfSize(in, length);\n+            \n+            return type.readFrom(new EnhancedByteBufInputStream(payload), length);\n+        }\n+        \n+        public void stop() {\n+            stop.set(true);\n+            try {\n+                in.close();\n+            } catch (Exception e) {\n+                log.warn(\"Got error while shutting down reader {}. \", name, e);\n+            }\n+            callback.connectionDropped();\n+        }\n+    }\n+    \n+    @RequiredArgsConstructor\n+    private static final class TimeoutBatch implements Runnable {\n+        private final AtomicLong token = new AtomicLong(-1);\n+        private final CommandEncoder encoder;\n+        @Override\n+        public void run() {\n+            token.set(encoder.batchTimeout(token.get()));\n+        }    \n+    }\n+\n+    public static CompletableFuture<TcpClientConnection> connect(PravegaNodeUri location, ClientConfig clientConfig, ReplyProcessor callback,\n+                                              ScheduledExecutorService executor, Runnable onClose) {\n+        return CompletableFuture.supplyAsync(() -> {\n+            Socket socket = createClientSocket(location, clientConfig); \n+            try {\n+                InputStream inputStream = socket.getInputStream();\n+                AppendBatchSizeTrackerImpl batchSizeTracker = new AppendBatchSizeTrackerImpl();\n+                ConnectionReader reader = new ConnectionReader(location.toString(), inputStream, callback, batchSizeTracker);\n+                reader.start();\n+                CommandEncoder encoder = new CommandEncoder(l -> batchSizeTracker, null, socket.getOutputStream());\n+                return new TcpClientConnection(socket, encoder, reader, location, onClose, executor);\n+            } catch (Exception e) {\n+                try {\n+                    socket.close();\n+                } catch (IOException e1) {\n+                    log.warn(\"Failed to close socket while failing.\", e1);\n+                }\n+                onClose.run();\n+                throw Exceptions.sneakyThrow(e);\n+            }\n+        }, executor);\n+    }\n+\n+    private static TrustManagerFactory createFromCert(String trustStoreFilePath)\n+            throws CertificateException, IOException, NoSuchAlgorithmException, KeyStoreException {\n+        TrustManagerFactory factory = null;\n+        if (!Strings.isNullOrEmpty(trustStoreFilePath)) {\n+            KeyStore trustStore = CertificateUtils.createTrustStore(trustStoreFilePath);\n+\n+            factory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());\n+            factory.init(trustStore);\n+        }\n+        return factory;\n+    }\n+\n+    /**\n+     * Creates a socket connected to the provided endpoint. \n+     * Note that this is a sync call even though it is called in an async context. \n+     * While this is normally frowned upon, it is simply not possible to construct an SSL socket asynchronously in Java.\n+     */\n+    @SneakyThrows //Is called inside a completable future.\n+    private static Socket createClientSocket(PravegaNodeUri location, ClientConfig clientConfig) {        \n+        Socket result;\n+        if (clientConfig.isEnableTlsToSegmentStore()) {\n+            TrustManagerFactory trustMgrFactory = createFromCert(clientConfig.getTrustStore());\n+\n+            // Prepare a TLS context that uses the trust manager\n+            SSLContext tlsContext = SSLContext.getInstance(\"TLS\");\n+            tlsContext.init(null,\n+                    trustMgrFactory != null ? trustMgrFactory.getTrustManagers() : null,\n+                    null);\n+\n+            SSLSocket tlsClientSocket = (SSLSocket) tlsContext.getSocketFactory().createSocket();\n+\n+            // SSLSocket does not perform hostname verification by default. So, we must explicitly enable it.\n+            if (clientConfig.isValidateHostName()) {\n+                SSLParameters tlsParams = new SSLParameters();\n+\n+                // While the connection is to a TCP service and not an HTTP server, we use `HTTPS` as the endpoint\n+                // identification algorithm, which in turn ensures that the SSLSocket will verify the server's host\n+                // name during TLS handshake. This is a commonly used way of enabling hostname verification\n+                // regardless of whether the service itself is HTTP (no in this case).\n+                tlsParams.setEndpointIdentificationAlgorithm(\"HTTPS\");\n+                tlsClientSocket.setSSLParameters(tlsParams);\n+            }\n+            result = tlsClientSocket;\n+\n+        } else {\n+            result = new Socket();\n+        }\n+        result.setSendBufferSize(TCP_BUFFER_SIZE);\n+        result.setReceiveBufferSize(TCP_BUFFER_SIZE);\n+        result.setTcpNoDelay(true);\n+        result.connect(new InetSocketAddress(location.getEndpoint(), location.getPort()));\n+        return result;\n+    }\n+\n+    @Override\n+    public void send(WireCommand cmd) throws ConnectionFailedException {\n+        if (closed.get()) {\n+            throw new ConnectionFailedException(\"Connection is closed\");\n+        }\n+        try {\n+            encoder.write(cmd);\n+        } catch (IOException e) {\n+            log.warn(\"Error writing to connection\", e.toString());\n+            close();\n+            throw new ConnectionFailedException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void send(Append append) throws ConnectionFailedException {\n+        if (closed.get()) {\n+            throw new ConnectionFailedException(\"Connection is closed\");\n+        }\n+        try {\n+            encoder.write(append);\n+        } catch (IOException e) {\n+            log.warn(\"Error writing to connection\", e.toString());\n+            close();\n+            throw new ConnectionFailedException(e);\n+        }\n+    }\n+\n+    @Override\n+    public void close() {\n+        if (closed.compareAndSet(false, true)) {\n+            reader.stop();\n+            timeoutFuture.cancel(false);\n+            try {\n+                socket.close();\n+            } catch (IOException e) {\n+                log.warn(\"Error closing socket\", e);\n+            }\n+            if (onClose != null) {\n+                onClose.run();\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void sendAsync(List<Append> appends, CompletedCallback callback) {\n+        try {\n+            for (Append append : appends) {\n+                encoder.write(append);\n+            }\n+            callback.complete(null);\n+        } catch (IOException e) {\n+            log.warn(\"Error writing to connection\", e.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c76edd8affdbba70c9e5767a4c8f93c09c51fce"}, "originalPosition": 309}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNjc1Nzg1OnYy", "diffSide": "RIGHT", "path": "common/src/main/java/io/pravega/common/util/CertificateUtils.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwNTo0Mjo1OFrOGxvGAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwNjozNTo0NlrOGxwOVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDgwNDk5NA==", "bodyText": "Redundant + \"\" , perhaps we can use String.valueOf()", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r454804994", "createdAt": "2020-07-15T05:42:58Z", "author": {"login": "shrids"}, "path": "common/src/main/java/io/pravega/common/util/CertificateUtils.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.util;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.pravega.common.Exceptions;\n+import lombok.NonNull;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.X509Certificate;\n+import java.util.Collection;\n+\n+public class CertificateUtils {\n+\n+    /**\n+     * Retrieves certificates from PEM-encoded (ASCII) or DER-encoded (binary) file at the specified\n+     * {@code certFilePath}.\n+     *\n+     * @param certFilePath the path of the file containing a certificate(s).\n+     * @return a sequence of X509Certificate certificates found in the file.\n+     * @throws CertificateException if parsing of the certificate fails\n+     * @throws IOException if a file in not found at the specified {@code certFilePath} or some other IO error occurs.\n+     * @throws NullPointerException if {@code certFilePath} is null\n+     * @throws IllegalArgumentException if {@code certFilePath} is empty\n+     */\n+    public static X509Certificate[] extractCerts(String certFilePath)\n+            throws CertificateException, IOException {\n+        Exceptions.checkNotNullOrEmpty(certFilePath, \"certFilePath\");\n+\n+        try (FileInputStream is = new FileInputStream(new File(certFilePath))) {\n+            return extractCerts(is);\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static X509Certificate[] extractCerts(@NonNull InputStream certificateInputStream) throws CertificateException {\n+        Collection<? extends Certificate> certificates = CertificateFactory.getInstance(\"X.509\")\n+                .generateCertificates(certificateInputStream);\n+        final X509Certificate[] result = new X509Certificate[certificates.size()];\n+\n+        int i = 0;\n+        for (Certificate cert: certificates) {\n+            result[i++] = (X509Certificate) cert;\n+        }\n+        return result;\n+    }\n+\n+    public static String toString(X509Certificate[] certificateChain) {\n+        StringBuilder builder = new StringBuilder();\n+        for (int i = 0; i < certificateChain.length; i++) {\n+            X509Certificate certificate = certificateChain[i];\n+            builder.append(\" -> {\");\n+            builder.append(\"type=[\" + certificate.getType() + \"], \");\n+            builder.append(\"subject=[\" + certificate.getSubjectX500Principal() + \"], \");\n+            builder.append(\"issuer=[\" +\n+                    ((certificate.getIssuerDN() != null ? certificate.getIssuerDN().getName() : \"None\")) + \"]\");\n+            builder.append(\"}\");\n+        }\n+        return builder.toString();\n+    }\n+\n+    /**\n+     * Creates a truststore with certificates from PEM-encoded (ASCII) or DER-encoded (binary) file at\n+     * the specified {@code certFilePath}.\n+     *\n+     * @param certFilePath the path of the file containing a certificate chain.\n+     * @return a truststore loaded with the certificate chain present in the specified {@code certFilePath}\n+     * @throws CertificateException if parsing of the certificate fails\n+     * @throws IOException if a file in not found at the specified {@code certFilePath}, or some other IO error occurs\n+     * @throws KeyStoreException if creating an instance of the truststore fails for some reason.\n+     * @throws NoSuchAlgorithmException if the algorithm used for verifying rhe truststore's integrity is missing\n+     * @throws NullPointerException if {@code certFilePath} is null\n+     * @throws IllegalArgumentException if {@code certFilePath} is empty\n+     */\n+    public static KeyStore createTrustStore(String certFilePath)\n+            throws CertificateException, IOException, KeyStoreException, NoSuchAlgorithmException {\n+        Exceptions.checkNotNullOrEmpty(certFilePath, \"certFilePath\");\n+        return createTrustStore(extractCerts(certFilePath));\n+    }\n+\n+    @VisibleForTesting\n+    static KeyStore createTrustStore(X509Certificate[] certificateChain)\n+            throws KeyStoreException, IOException, NoSuchAlgorithmException, CertificateException {\n+\n+        final KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n+        trustStore.load(null, null);\n+\n+        int i = 0;\n+        for (X509Certificate cert: certificateChain) {\n+            String alias = i++ + \"\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "686117cfd87418c094e1b49baf27531b081a6f25"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDgxNjIyNA==", "bodyText": "Sure, have modified the code and pushed the change.", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r454816224", "createdAt": "2020-07-15T06:16:37Z", "author": {"login": "ravisharda"}, "path": "common/src/main/java/io/pravega/common/util/CertificateUtils.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.util;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.pravega.common.Exceptions;\n+import lombok.NonNull;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.X509Certificate;\n+import java.util.Collection;\n+\n+public class CertificateUtils {\n+\n+    /**\n+     * Retrieves certificates from PEM-encoded (ASCII) or DER-encoded (binary) file at the specified\n+     * {@code certFilePath}.\n+     *\n+     * @param certFilePath the path of the file containing a certificate(s).\n+     * @return a sequence of X509Certificate certificates found in the file.\n+     * @throws CertificateException if parsing of the certificate fails\n+     * @throws IOException if a file in not found at the specified {@code certFilePath} or some other IO error occurs.\n+     * @throws NullPointerException if {@code certFilePath} is null\n+     * @throws IllegalArgumentException if {@code certFilePath} is empty\n+     */\n+    public static X509Certificate[] extractCerts(String certFilePath)\n+            throws CertificateException, IOException {\n+        Exceptions.checkNotNullOrEmpty(certFilePath, \"certFilePath\");\n+\n+        try (FileInputStream is = new FileInputStream(new File(certFilePath))) {\n+            return extractCerts(is);\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static X509Certificate[] extractCerts(@NonNull InputStream certificateInputStream) throws CertificateException {\n+        Collection<? extends Certificate> certificates = CertificateFactory.getInstance(\"X.509\")\n+                .generateCertificates(certificateInputStream);\n+        final X509Certificate[] result = new X509Certificate[certificates.size()];\n+\n+        int i = 0;\n+        for (Certificate cert: certificates) {\n+            result[i++] = (X509Certificate) cert;\n+        }\n+        return result;\n+    }\n+\n+    public static String toString(X509Certificate[] certificateChain) {\n+        StringBuilder builder = new StringBuilder();\n+        for (int i = 0; i < certificateChain.length; i++) {\n+            X509Certificate certificate = certificateChain[i];\n+            builder.append(\" -> {\");\n+            builder.append(\"type=[\" + certificate.getType() + \"], \");\n+            builder.append(\"subject=[\" + certificate.getSubjectX500Principal() + \"], \");\n+            builder.append(\"issuer=[\" +\n+                    ((certificate.getIssuerDN() != null ? certificate.getIssuerDN().getName() : \"None\")) + \"]\");\n+            builder.append(\"}\");\n+        }\n+        return builder.toString();\n+    }\n+\n+    /**\n+     * Creates a truststore with certificates from PEM-encoded (ASCII) or DER-encoded (binary) file at\n+     * the specified {@code certFilePath}.\n+     *\n+     * @param certFilePath the path of the file containing a certificate chain.\n+     * @return a truststore loaded with the certificate chain present in the specified {@code certFilePath}\n+     * @throws CertificateException if parsing of the certificate fails\n+     * @throws IOException if a file in not found at the specified {@code certFilePath}, or some other IO error occurs\n+     * @throws KeyStoreException if creating an instance of the truststore fails for some reason.\n+     * @throws NoSuchAlgorithmException if the algorithm used for verifying rhe truststore's integrity is missing\n+     * @throws NullPointerException if {@code certFilePath} is null\n+     * @throws IllegalArgumentException if {@code certFilePath} is empty\n+     */\n+    public static KeyStore createTrustStore(String certFilePath)\n+            throws CertificateException, IOException, KeyStoreException, NoSuchAlgorithmException {\n+        Exceptions.checkNotNullOrEmpty(certFilePath, \"certFilePath\");\n+        return createTrustStore(extractCerts(certFilePath));\n+    }\n+\n+    @VisibleForTesting\n+    static KeyStore createTrustStore(X509Certificate[] certificateChain)\n+            throws KeyStoreException, IOException, NoSuchAlgorithmException, CertificateException {\n+\n+        final KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n+        trustStore.load(null, null);\n+\n+        int i = 0;\n+        for (X509Certificate cert: certificateChain) {\n+            String alias = i++ + \"\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDgwNDk5NA=="}, "originalCommit": {"oid": "686117cfd87418c094e1b49baf27531b081a6f25"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDgxNzM3Nw==", "bodyText": "Thanks @ravisharda This pattern is also present @ io.pravega.common.util.ConfigurationOptionsExtractor#extractInt", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r454817377", "createdAt": "2020-07-15T06:20:00Z", "author": {"login": "shrids"}, "path": "common/src/main/java/io/pravega/common/util/CertificateUtils.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.util;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.pravega.common.Exceptions;\n+import lombok.NonNull;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.X509Certificate;\n+import java.util.Collection;\n+\n+public class CertificateUtils {\n+\n+    /**\n+     * Retrieves certificates from PEM-encoded (ASCII) or DER-encoded (binary) file at the specified\n+     * {@code certFilePath}.\n+     *\n+     * @param certFilePath the path of the file containing a certificate(s).\n+     * @return a sequence of X509Certificate certificates found in the file.\n+     * @throws CertificateException if parsing of the certificate fails\n+     * @throws IOException if a file in not found at the specified {@code certFilePath} or some other IO error occurs.\n+     * @throws NullPointerException if {@code certFilePath} is null\n+     * @throws IllegalArgumentException if {@code certFilePath} is empty\n+     */\n+    public static X509Certificate[] extractCerts(String certFilePath)\n+            throws CertificateException, IOException {\n+        Exceptions.checkNotNullOrEmpty(certFilePath, \"certFilePath\");\n+\n+        try (FileInputStream is = new FileInputStream(new File(certFilePath))) {\n+            return extractCerts(is);\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static X509Certificate[] extractCerts(@NonNull InputStream certificateInputStream) throws CertificateException {\n+        Collection<? extends Certificate> certificates = CertificateFactory.getInstance(\"X.509\")\n+                .generateCertificates(certificateInputStream);\n+        final X509Certificate[] result = new X509Certificate[certificates.size()];\n+\n+        int i = 0;\n+        for (Certificate cert: certificates) {\n+            result[i++] = (X509Certificate) cert;\n+        }\n+        return result;\n+    }\n+\n+    public static String toString(X509Certificate[] certificateChain) {\n+        StringBuilder builder = new StringBuilder();\n+        for (int i = 0; i < certificateChain.length; i++) {\n+            X509Certificate certificate = certificateChain[i];\n+            builder.append(\" -> {\");\n+            builder.append(\"type=[\" + certificate.getType() + \"], \");\n+            builder.append(\"subject=[\" + certificate.getSubjectX500Principal() + \"], \");\n+            builder.append(\"issuer=[\" +\n+                    ((certificate.getIssuerDN() != null ? certificate.getIssuerDN().getName() : \"None\")) + \"]\");\n+            builder.append(\"}\");\n+        }\n+        return builder.toString();\n+    }\n+\n+    /**\n+     * Creates a truststore with certificates from PEM-encoded (ASCII) or DER-encoded (binary) file at\n+     * the specified {@code certFilePath}.\n+     *\n+     * @param certFilePath the path of the file containing a certificate chain.\n+     * @return a truststore loaded with the certificate chain present in the specified {@code certFilePath}\n+     * @throws CertificateException if parsing of the certificate fails\n+     * @throws IOException if a file in not found at the specified {@code certFilePath}, or some other IO error occurs\n+     * @throws KeyStoreException if creating an instance of the truststore fails for some reason.\n+     * @throws NoSuchAlgorithmException if the algorithm used for verifying rhe truststore's integrity is missing\n+     * @throws NullPointerException if {@code certFilePath} is null\n+     * @throws IllegalArgumentException if {@code certFilePath} is empty\n+     */\n+    public static KeyStore createTrustStore(String certFilePath)\n+            throws CertificateException, IOException, KeyStoreException, NoSuchAlgorithmException {\n+        Exceptions.checkNotNullOrEmpty(certFilePath, \"certFilePath\");\n+        return createTrustStore(extractCerts(certFilePath));\n+    }\n+\n+    @VisibleForTesting\n+    static KeyStore createTrustStore(X509Certificate[] certificateChain)\n+            throws KeyStoreException, IOException, NoSuchAlgorithmException, CertificateException {\n+\n+        final KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n+        trustStore.load(null, null);\n+\n+        int i = 0;\n+        for (X509Certificate cert: certificateChain) {\n+            String alias = i++ + \"\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDgwNDk5NA=="}, "originalCommit": {"oid": "686117cfd87418c094e1b49baf27531b081a6f25"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDgyMzUxMQ==", "bodyText": "Sure, thanks for spotting it. Fixed that one too.", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r454823511", "createdAt": "2020-07-15T06:35:46Z", "author": {"login": "ravisharda"}, "path": "common/src/main/java/io/pravega/common/util/CertificateUtils.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.util;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import io.pravega.common.Exceptions;\n+import lombok.NonNull;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.Certificate;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.X509Certificate;\n+import java.util.Collection;\n+\n+public class CertificateUtils {\n+\n+    /**\n+     * Retrieves certificates from PEM-encoded (ASCII) or DER-encoded (binary) file at the specified\n+     * {@code certFilePath}.\n+     *\n+     * @param certFilePath the path of the file containing a certificate(s).\n+     * @return a sequence of X509Certificate certificates found in the file.\n+     * @throws CertificateException if parsing of the certificate fails\n+     * @throws IOException if a file in not found at the specified {@code certFilePath} or some other IO error occurs.\n+     * @throws NullPointerException if {@code certFilePath} is null\n+     * @throws IllegalArgumentException if {@code certFilePath} is empty\n+     */\n+    public static X509Certificate[] extractCerts(String certFilePath)\n+            throws CertificateException, IOException {\n+        Exceptions.checkNotNullOrEmpty(certFilePath, \"certFilePath\");\n+\n+        try (FileInputStream is = new FileInputStream(new File(certFilePath))) {\n+            return extractCerts(is);\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    static X509Certificate[] extractCerts(@NonNull InputStream certificateInputStream) throws CertificateException {\n+        Collection<? extends Certificate> certificates = CertificateFactory.getInstance(\"X.509\")\n+                .generateCertificates(certificateInputStream);\n+        final X509Certificate[] result = new X509Certificate[certificates.size()];\n+\n+        int i = 0;\n+        for (Certificate cert: certificates) {\n+            result[i++] = (X509Certificate) cert;\n+        }\n+        return result;\n+    }\n+\n+    public static String toString(X509Certificate[] certificateChain) {\n+        StringBuilder builder = new StringBuilder();\n+        for (int i = 0; i < certificateChain.length; i++) {\n+            X509Certificate certificate = certificateChain[i];\n+            builder.append(\" -> {\");\n+            builder.append(\"type=[\" + certificate.getType() + \"], \");\n+            builder.append(\"subject=[\" + certificate.getSubjectX500Principal() + \"], \");\n+            builder.append(\"issuer=[\" +\n+                    ((certificate.getIssuerDN() != null ? certificate.getIssuerDN().getName() : \"None\")) + \"]\");\n+            builder.append(\"}\");\n+        }\n+        return builder.toString();\n+    }\n+\n+    /**\n+     * Creates a truststore with certificates from PEM-encoded (ASCII) or DER-encoded (binary) file at\n+     * the specified {@code certFilePath}.\n+     *\n+     * @param certFilePath the path of the file containing a certificate chain.\n+     * @return a truststore loaded with the certificate chain present in the specified {@code certFilePath}\n+     * @throws CertificateException if parsing of the certificate fails\n+     * @throws IOException if a file in not found at the specified {@code certFilePath}, or some other IO error occurs\n+     * @throws KeyStoreException if creating an instance of the truststore fails for some reason.\n+     * @throws NoSuchAlgorithmException if the algorithm used for verifying rhe truststore's integrity is missing\n+     * @throws NullPointerException if {@code certFilePath} is null\n+     * @throws IllegalArgumentException if {@code certFilePath} is empty\n+     */\n+    public static KeyStore createTrustStore(String certFilePath)\n+            throws CertificateException, IOException, KeyStoreException, NoSuchAlgorithmException {\n+        Exceptions.checkNotNullOrEmpty(certFilePath, \"certFilePath\");\n+        return createTrustStore(extractCerts(certFilePath));\n+    }\n+\n+    @VisibleForTesting\n+    static KeyStore createTrustStore(X509Certificate[] certificateChain)\n+            throws KeyStoreException, IOException, NoSuchAlgorithmException, CertificateException {\n+\n+        final KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());\n+        trustStore.load(null, null);\n+\n+        int i = 0;\n+        for (X509Certificate cert: certificateChain) {\n+            String alias = i++ + \"\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDgwNDk5NA=="}, "originalCommit": {"oid": "686117cfd87418c094e1b49baf27531b081a6f25"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MzQ4OTYyOnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/connection/impl/AppendBatchSizeTrackerImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNToxMTo1M1rOGyvpDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQyMzowMDowNFrOGy_oHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg2MjU0MA==", "bodyText": "Why are we dropping appendsOutstanding.addNewSample(eventNumber - lastAckNumber.get()); from this method? Why this was before?", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r455862540", "createdAt": "2020-07-16T15:11:53Z", "author": {"login": "RaulGracia"}, "path": "client/src/main/java/io/pravega/client/connection/impl/AppendBatchSizeTrackerImpl.java", "diffHunk": "@@ -50,8 +65,7 @@ public void recordAppend(long eventNumber, int size) {\n         long now = Math.max(lastAppendTime.get(), clock.get());\n         long last = lastAppendTime.getAndSet(now);\n         lastAppendNumber.set(eventNumber);\n-        millisBetweenAppends.addNewSample(now - last);\n-        appendsOutstanding.addNewSample(eventNumber - lastAckNumber.get());\n+        nanosBetweenAppends.addNewSample(now - last);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d3d4ce2be4325f22c6d68d2fcda06b1f45e1c3a"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjEyNDQ0NQ==", "bodyText": "It performs better (in terms of cpu use, this showed up on a flamegraph) and provides a more consistent value if 'appendsOutstanding' is defined in a uniform way as opposed to being an mixture of two different ways of measuring.\nBefore this method was called from the netty thread after the handoff had occurred. Now there is no netty thread so this is being called in-line in the write path. So the meaning of the 'outstanding' is subtly different. So I decided to simplify things and remove it from the hot path, by only sampling the value after an ack.\nThis has the effect that rather than attempting to average a sawtooth distribution we are just sampling the low points. Hence this will have the effect of lowering the equivalent batch size to below where it was before. However because we are including more data in the definition of being 'outstanding' by virtue of having eliminated the netty thread, this may end up being a wash.", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r456124445", "createdAt": "2020-07-16T23:00:04Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/connection/impl/AppendBatchSizeTrackerImpl.java", "diffHunk": "@@ -50,8 +65,7 @@ public void recordAppend(long eventNumber, int size) {\n         long now = Math.max(lastAppendTime.get(), clock.get());\n         long last = lastAppendTime.getAndSet(now);\n         lastAppendNumber.set(eventNumber);\n-        millisBetweenAppends.addNewSample(now - last);\n-        appendsOutstanding.addNewSample(eventNumber - lastAckNumber.get());\n+        nanosBetweenAppends.addNewSample(now - last);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTg2MjU0MA=="}, "originalCommit": {"oid": "6d3d4ce2be4325f22c6d68d2fcda06b1f45e1c3a"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NjcwNDQzOnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/connection/impl/AppendBatchSizeTrackerImpl.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMDoyNzozNlrOGzN79Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxODowMzoxOVrOGzcV4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM1ODkwMQ==", "bodyText": "This change is not working well for 16 segments and low throughput rates. What it does work is to use the previous approach to calculate appendsInBatch:\ndouble appendsInBatch = MathHelpers.minMax(appendsOutstanding.getCurrentValue() * OUTSTANDING_FRACTION, 1.0, appendsInMaxBatchTime);\nThis means that you can also delete line 92, as appendsInTime is not used.", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r456358901", "createdAt": "2020-07-17T10:27:36Z", "author": {"login": "RaulGracia"}, "path": "client/src/main/java/io/pravega/client/connection/impl/AppendBatchSizeTrackerImpl.java", "diffHunk": "@@ -73,11 +87,12 @@ public int getAppendBlockSize() {\n         if (numInflight <= 1) {\n             return 0;\n         }\n-        double appendsInMaxBatch = Math.max(1.0, MAX_BATCH_TIME_MILLIS / millisBetweenAppends.getCurrentValue());\n-        double targetAppendsOutstanding = MathHelpers.minMax(appendsOutstanding.getCurrentValue() * 0.5, 1.0,\n-                                                             appendsInMaxBatch);\n-        return (int) MathHelpers.minMax((long) (targetAppendsOutstanding * eventSize.getCurrentValue()), 0,\n-                                        MAX_BATCH_SIZE);\n+        double nanosPerAppend = nanosBetweenAppends.getCurrentValue();\n+        double appendsInMaxBatchTime = Math.max(1.0, (MAX_BATCH_TIME_MILLIS * NANOS_PER_MILLI) / nanosPerAppend);\n+        double appendsInTime = Math.max(1.0, BASE_TIME_NANOS / nanosPerAppend);\n+        double appendsInBatch = MathHelpers.minMax(appendsOutstanding.getCurrentValue() * OUTSTANDING_FRACTION + appendsInTime, 1.0, appendsInMaxBatchTime);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da33978ddf10bbffe2c8f4fad16faa6dc6ecf4ea"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU1ODU5OQ==", "bodyText": "I have set PRAVEGA_BATCH_BASE_TIME_NANOS to zero.", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r456558599", "createdAt": "2020-07-17T16:51:12Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/connection/impl/AppendBatchSizeTrackerImpl.java", "diffHunk": "@@ -73,11 +87,12 @@ public int getAppendBlockSize() {\n         if (numInflight <= 1) {\n             return 0;\n         }\n-        double appendsInMaxBatch = Math.max(1.0, MAX_BATCH_TIME_MILLIS / millisBetweenAppends.getCurrentValue());\n-        double targetAppendsOutstanding = MathHelpers.minMax(appendsOutstanding.getCurrentValue() * 0.5, 1.0,\n-                                                             appendsInMaxBatch);\n-        return (int) MathHelpers.minMax((long) (targetAppendsOutstanding * eventSize.getCurrentValue()), 0,\n-                                        MAX_BATCH_SIZE);\n+        double nanosPerAppend = nanosBetweenAppends.getCurrentValue();\n+        double appendsInMaxBatchTime = Math.max(1.0, (MAX_BATCH_TIME_MILLIS * NANOS_PER_MILLI) / nanosPerAppend);\n+        double appendsInTime = Math.max(1.0, BASE_TIME_NANOS / nanosPerAppend);\n+        double appendsInBatch = MathHelpers.minMax(appendsOutstanding.getCurrentValue() * OUTSTANDING_FRACTION + appendsInTime, 1.0, appendsInMaxBatchTime);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM1ODkwMQ=="}, "originalCommit": {"oid": "da33978ddf10bbffe2c8f4fad16faa6dc6ecf4ea"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU5NDkxNQ==", "bodyText": "The calculation is not exactly the same, right? This is adding by default 1 more append in each batch compared to removing + appendsInTime. If this has any consequence, can be checked after we merge this.", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r456594915", "createdAt": "2020-07-17T18:03:19Z", "author": {"login": "RaulGracia"}, "path": "client/src/main/java/io/pravega/client/connection/impl/AppendBatchSizeTrackerImpl.java", "diffHunk": "@@ -73,11 +87,12 @@ public int getAppendBlockSize() {\n         if (numInflight <= 1) {\n             return 0;\n         }\n-        double appendsInMaxBatch = Math.max(1.0, MAX_BATCH_TIME_MILLIS / millisBetweenAppends.getCurrentValue());\n-        double targetAppendsOutstanding = MathHelpers.minMax(appendsOutstanding.getCurrentValue() * 0.5, 1.0,\n-                                                             appendsInMaxBatch);\n-        return (int) MathHelpers.minMax((long) (targetAppendsOutstanding * eventSize.getCurrentValue()), 0,\n-                                        MAX_BATCH_SIZE);\n+        double nanosPerAppend = nanosBetweenAppends.getCurrentValue();\n+        double appendsInMaxBatchTime = Math.max(1.0, (MAX_BATCH_TIME_MILLIS * NANOS_PER_MILLI) / nanosPerAppend);\n+        double appendsInTime = Math.max(1.0, BASE_TIME_NANOS / nanosPerAppend);\n+        double appendsInBatch = MathHelpers.minMax(appendsOutstanding.getCurrentValue() * OUTSTANDING_FRACTION + appendsInTime, 1.0, appendsInMaxBatchTime);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM1ODkwMQ=="}, "originalCommit": {"oid": "da33978ddf10bbffe2c8f4fad16faa6dc6ecf4ea"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NjcxNzQwOnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/connection/impl/AppendBatchSizeTrackerImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMDozMTozOVrOGzODbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxNjo1MzowMlrOGzaLcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM2MDgxNA==", "bodyText": "I realized that the time it takes for the client to converge to the lowest performance (assuming a stable environment and constant workload) is around 5x-10x longer to what it was. It seems that the changes in the configuration of these ExponentialMovingAverage are the reason for this to happen, so I would suggest to keep the old configuration (i.e., initial value, new sample wight) as they are working fine until we find a better configuration:\nprivate final ExponentialMovingAverage eventSize = new ExponentialMovingAverage(1024, 0.1, true);\nprivate final ExponentialMovingAverage nanosBetweenAppends = new ExponentialMovingAverage(10 * NANOS_PER_MILLI, 0.1, false);\nprivate final ExponentialMovingAverage appendsOutstanding = new ExponentialMovingAverage(2, 0.05, false);", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r456360814", "createdAt": "2020-07-17T10:31:39Z", "author": {"login": "RaulGracia"}, "path": "client/src/main/java/io/pravega/client/connection/impl/AppendBatchSizeTrackerImpl.java", "diffHunk": "@@ -27,19 +30,31 @@\n  * synchronous writers. Otherwise the batch size is set to the amount of data that will be written in the next\n  * {@link #MAX_BATCH_TIME_MILLIS} or half the server round trip time (whichever is less)\n  */\n-class AppendBatchSizeTrackerImpl implements AppendBatchSizeTracker {\n-    private static final int MAX_BATCH_TIME_MILLIS = 100;\n-\n+public class AppendBatchSizeTrackerImpl implements AppendBatchSizeTracker {\n+    \n+    // This must be less than WireCommands.MAX_WIRECOMMAND_SIZE / 2;\n+    @VisibleForTesting\n+    static final int MAX_BATCH_SIZE = EnvVars.readIntegerFromEnvVar(\"PRAVEGA_MAX_BATCH_SIZE\",\n+                                                                 2 * TcpClientConnection.TCP_BUFFER_SIZE - 1024);\n+    @VisibleForTesting\n+    static final int BASE_TIME_NANOS = EnvVars.readIntegerFromEnvVar(\"PRAVEGA_BATCH_BASE_TIME_NANOS\", AbstractTimer.NANOS_TO_MILLIS / 2);\n+    @VisibleForTesting\n+    static final int BASE_SIZE = EnvVars.readIntegerFromEnvVar(\"PRAVEGA_BATCH_BASE_SIZE\", 0);\n+    @VisibleForTesting\n+    static final double OUTSTANDING_FRACTION = 1.0 / EnvVars.readIntegerFromEnvVar(\"PRAVEGA_BATCH_OUTSTANDING_DENOMINATOR\", 2);\n+    \n+    private static final double NANOS_PER_MILLI = AbstractTimer.NANOS_TO_MILLIS;\n+    \n     private final Supplier<Long> clock;\n     private final AtomicLong lastAppendNumber;\n     private final AtomicLong lastAppendTime;\n     private final AtomicLong lastAckNumber;\n-    private final ExponentialMovingAverage eventSize = new ExponentialMovingAverage(1024, 0.1, true);\n-    private final ExponentialMovingAverage millisBetweenAppends = new ExponentialMovingAverage(10, 0.1, false);\n-    private final ExponentialMovingAverage appendsOutstanding = new ExponentialMovingAverage(2, 0.05, false);\n+    private final ExponentialMovingAverage eventSize = new ExponentialMovingAverage(1024, 0.01, true);\n+    private final ExponentialMovingAverage nanosBetweenAppends = new ExponentialMovingAverage(10 * NANOS_PER_MILLI, 0.001, false);\n+    private final ExponentialMovingAverage appendsOutstanding = new ExponentialMovingAverage(20, 0.001, false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da33978ddf10bbffe2c8f4fad16faa6dc6ecf4ea"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU1OTQ3NQ==", "bodyText": "I selected the new values because my local testing showed they greatly improved the max latency.\nPavel's tests confirmed this as they showed much lower tail variance in batch sizes, and with them reverted it doubled the p99 and tripled the p999.\nI think they are better as they are.", "url": "https://github.com/pravega/pravega/pull/4873#discussion_r456559475", "createdAt": "2020-07-17T16:53:02Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/connection/impl/AppendBatchSizeTrackerImpl.java", "diffHunk": "@@ -27,19 +30,31 @@\n  * synchronous writers. Otherwise the batch size is set to the amount of data that will be written in the next\n  * {@link #MAX_BATCH_TIME_MILLIS} or half the server round trip time (whichever is less)\n  */\n-class AppendBatchSizeTrackerImpl implements AppendBatchSizeTracker {\n-    private static final int MAX_BATCH_TIME_MILLIS = 100;\n-\n+public class AppendBatchSizeTrackerImpl implements AppendBatchSizeTracker {\n+    \n+    // This must be less than WireCommands.MAX_WIRECOMMAND_SIZE / 2;\n+    @VisibleForTesting\n+    static final int MAX_BATCH_SIZE = EnvVars.readIntegerFromEnvVar(\"PRAVEGA_MAX_BATCH_SIZE\",\n+                                                                 2 * TcpClientConnection.TCP_BUFFER_SIZE - 1024);\n+    @VisibleForTesting\n+    static final int BASE_TIME_NANOS = EnvVars.readIntegerFromEnvVar(\"PRAVEGA_BATCH_BASE_TIME_NANOS\", AbstractTimer.NANOS_TO_MILLIS / 2);\n+    @VisibleForTesting\n+    static final int BASE_SIZE = EnvVars.readIntegerFromEnvVar(\"PRAVEGA_BATCH_BASE_SIZE\", 0);\n+    @VisibleForTesting\n+    static final double OUTSTANDING_FRACTION = 1.0 / EnvVars.readIntegerFromEnvVar(\"PRAVEGA_BATCH_OUTSTANDING_DENOMINATOR\", 2);\n+    \n+    private static final double NANOS_PER_MILLI = AbstractTimer.NANOS_TO_MILLIS;\n+    \n     private final Supplier<Long> clock;\n     private final AtomicLong lastAppendNumber;\n     private final AtomicLong lastAppendTime;\n     private final AtomicLong lastAckNumber;\n-    private final ExponentialMovingAverage eventSize = new ExponentialMovingAverage(1024, 0.1, true);\n-    private final ExponentialMovingAverage millisBetweenAppends = new ExponentialMovingAverage(10, 0.1, false);\n-    private final ExponentialMovingAverage appendsOutstanding = new ExponentialMovingAverage(2, 0.05, false);\n+    private final ExponentialMovingAverage eventSize = new ExponentialMovingAverage(1024, 0.01, true);\n+    private final ExponentialMovingAverage nanosBetweenAppends = new ExponentialMovingAverage(10 * NANOS_PER_MILLI, 0.001, false);\n+    private final ExponentialMovingAverage appendsOutstanding = new ExponentialMovingAverage(20, 0.001, false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM2MDgxNA=="}, "originalCommit": {"oid": "da33978ddf10bbffe2c8f4fad16faa6dc6ecf4ea"}, "originalPosition": 46}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4762, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}