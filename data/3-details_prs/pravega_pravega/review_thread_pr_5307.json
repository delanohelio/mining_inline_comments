{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE2NjgwODk3", "number": 5307, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwOTowMDowMlrOE3nVSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxODozNjo1NVrOE4S7-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NzUxNTYxOnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/segment/impl/SegmentOutputStreamImpl.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwOTowMDowMlrOHxEJSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxNjoxNToyN1rOHyCZtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTIxMDE4NA==", "bodyText": "what about adding a \"return\" ?\nit won't have effect but it may make the code cleaner", "url": "https://github.com/pravega/pravega/pull/5307#discussion_r521210184", "createdAt": "2020-11-11T09:00:02Z", "author": {"login": "eolivelli"}, "path": "client/src/main/java/io/pravega/client/segment/impl/SegmentOutputStreamImpl.java", "diffHunk": "@@ -557,6 +562,10 @@ public void flush() throws SegmentSealedException {\n                 }\n             } catch (Exception e) {\n                 failConnection(e);\n+                if (e instanceof RetriesExhaustedException) {\n+                    //throw an exception to the external world that the flush failed due to RetriesExhaustedException\n+                    Exceptions.sneakyThrow(e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a0922991689afc674e758d0481124ddfdf2b0b03"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjAzNTM0Mw==", "bodyText": "Thanks @eolivelli\nThe intent here was to ensure the user knows that there was a connectivity issue for this synchronous API. Adding a return with a log message will imply the user will not know that some events were not written due to connectivity issues.\n@tkaitchuck is there a better way to communicate this connectivity issue to the user of Pravega?", "url": "https://github.com/pravega/pravega/pull/5307#discussion_r522035343", "createdAt": "2020-11-12T11:27:19Z", "author": {"login": "shrids"}, "path": "client/src/main/java/io/pravega/client/segment/impl/SegmentOutputStreamImpl.java", "diffHunk": "@@ -557,6 +562,10 @@ public void flush() throws SegmentSealedException {\n                 }\n             } catch (Exception e) {\n                 failConnection(e);\n+                if (e instanceof RetriesExhaustedException) {\n+                    //throw an exception to the external world that the flush failed due to RetriesExhaustedException\n+                    Exceptions.sneakyThrow(e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTIxMDE4NA=="}, "originalCommit": {"oid": "a0922991689afc674e758d0481124ddfdf2b0b03"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA0Mzc3Nw==", "bodyText": "Exceptions.sneakyThrow(e); throws an exception, and the execution of the method is aborted, so basically it is like we had a \"return\" after   Exceptions.sneakyThrow(e);\nmy concern is only about telling explicitly to the reader of the code that the execution is ending up there (also automatic flow execution tools like spotbugs may be happier)\nnot a big deal, we can keep it as it is now", "url": "https://github.com/pravega/pravega/pull/5307#discussion_r522043777", "createdAt": "2020-11-12T11:42:18Z", "author": {"login": "eolivelli"}, "path": "client/src/main/java/io/pravega/client/segment/impl/SegmentOutputStreamImpl.java", "diffHunk": "@@ -557,6 +562,10 @@ public void flush() throws SegmentSealedException {\n                 }\n             } catch (Exception e) {\n                 failConnection(e);\n+                if (e instanceof RetriesExhaustedException) {\n+                    //throw an exception to the external world that the flush failed due to RetriesExhaustedException\n+                    Exceptions.sneakyThrow(e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTIxMDE4NA=="}, "originalCommit": {"oid": "a0922991689afc674e758d0481124ddfdf2b0b03"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjIzMDE5Nw==", "bodyText": "Ok, Thanks for clarifying it.\nI have improved the code.", "url": "https://github.com/pravega/pravega/pull/5307#discussion_r522230197", "createdAt": "2020-11-12T16:15:27Z", "author": {"login": "shrids"}, "path": "client/src/main/java/io/pravega/client/segment/impl/SegmentOutputStreamImpl.java", "diffHunk": "@@ -557,6 +562,10 @@ public void flush() throws SegmentSealedException {\n                 }\n             } catch (Exception e) {\n                 failConnection(e);\n+                if (e instanceof RetriesExhaustedException) {\n+                    //throw an exception to the external world that the flush failed due to RetriesExhaustedException\n+                    Exceptions.sneakyThrow(e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTIxMDE4NA=="}, "originalCommit": {"oid": "a0922991689afc674e758d0481124ddfdf2b0b03"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NDYzNzI5OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/segment/impl/SegmentOutputStreamImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxODozMTozMFrOHyIPWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwNDoyNzoxMlrOHyZz7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMyNTg1MA==", "bodyText": "The typical pattern here is to do:\n throw Exceptions.sneakyThrow(e);\nFor this reason the signature of sneakyThrow returns an exception even though the function never returns. Calling it in this way makes it clear visually that an exception will be thrown from this line and makes static analysis tools like IDEs better able to parse what is going on.", "url": "https://github.com/pravega/pravega/pull/5307#discussion_r522325850", "createdAt": "2020-11-12T18:31:30Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/segment/impl/SegmentOutputStreamImpl.java", "diffHunk": "@@ -557,6 +562,11 @@ public void flush() throws SegmentSealedException {\n                 }\n             } catch (Exception e) {\n                 failConnection(e);\n+                if (e instanceof RetriesExhaustedException) {\n+                    //throw an exception to the external world that the flush failed due to RetriesExhaustedException\n+                    Exceptions.sneakyThrow(e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b0bbff156f79bdcec778df06f55f8668afab91"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjYxMzc0MA==", "bodyText": "fixed it.", "url": "https://github.com/pravega/pravega/pull/5307#discussion_r522613740", "createdAt": "2020-11-13T04:27:12Z", "author": {"login": "shrids"}, "path": "client/src/main/java/io/pravega/client/segment/impl/SegmentOutputStreamImpl.java", "diffHunk": "@@ -557,6 +562,11 @@ public void flush() throws SegmentSealedException {\n                 }\n             } catch (Exception e) {\n                 failConnection(e);\n+                if (e instanceof RetriesExhaustedException) {\n+                    //throw an exception to the external world that the flush failed due to RetriesExhaustedException\n+                    Exceptions.sneakyThrow(e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMyNTg1MA=="}, "originalCommit": {"oid": "c6b0bbff156f79bdcec778df06f55f8668afab91"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NDY0NjM5OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/segment/impl/SegmentOutputStreamImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxODozMzoyNVrOHyIUnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwNDowNzoyM1rOHyY_Bw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMyNzE5Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                             log.error(\"Error will attempting to establish connection\", t);\n          \n          \n            \n                             log.error(\"Error while attempting to establish connection\", t);", "url": "https://github.com/pravega/pravega/pull/5307#discussion_r522327196", "createdAt": "2020-11-12T18:33:25Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/segment/impl/SegmentOutputStreamImpl.java", "diffHunk": "@@ -586,61 +597,64 @@ void reconnect() {\n         }\n         log.debug(\"(Re)connect invoked, Segment: {}, writerID: {}\", segmentName, writerId);\n         state.setupConnection.registerAndRunReleaser(() -> {\n-            Retry.indefinitelyWithExpBackoff(retrySchedule.getInitialMillis(), retrySchedule.getMultiplier(),\n-                                             retrySchedule.getMaxDelay(),\n-                                             t -> log.warn(writerId + \" Failed to connect: \", t))\n-                 .runAsync(() -> {\n-                     log.debug(\"Running reconnect for segment {} writer {}\", segmentName, writerId);\n-\n-                     if (state.isClosed() || state.needSuccessors.get()) {\n-                         // stop reconnect when writer is closed or resend inflight to successors has been triggered.\n-                         return CompletableFuture.completedFuture(null);\n-                     }\n-                     Preconditions.checkState(state.getConnection() == null);\n-                     log.info(\"Fetching endpoint for segment {}, writer {}\", segmentName, writerId);\n-\n-                     return controller.getEndpointForSegment(segmentName)\n-                         // Establish and return a connection to segment store\n-                         .thenComposeAsync((PravegaNodeUri uri) -> {\n-                             log.info(\"Establishing connection to {} for {}, writerID: {}\", uri, segmentName, writerId);\n-                             return establishConnection(uri);\n-                         }, connectionPool.getInternalExecutor())\n-                         .thenCombineAsync(tokenProvider.retrieveToken(),\n-                                           AbstractMap.SimpleEntry<ClientConnection, String>::new,\n-                                           connectionPool.getInternalExecutor())\n-                         .thenComposeAsync(pair -> {\n-                             ClientConnection connection = pair.getKey();\n-                             String token = pair.getValue();\n-\n-                             CompletableFuture<Void> connectionSetupFuture = state.newConnection(connection);\n-                             SetupAppend cmd = new SetupAppend(requestId, writerId, segmentName, token);\n-                             try {\n-                                 connection.send(cmd);\n-                             } catch (ConnectionFailedException e1) {\n-                                 // This needs to be invoked here because call to failConnection from netty may occur before state.newConnection above.\n-                                 state.failConnection(e1);\n-                                 throw Exceptions.sneakyThrow(e1);\n-                             }\n-                             return connectionSetupFuture.exceptionally(t -> {\n-                                 Throwable exception = Exceptions.unwrap(t);\n-                                 if (exception instanceof InvalidTokenException) {\n-                                     log.info(\"Ending reconnect attempts on writer {} to {} because token verification failed due to invalid token\",\n-                                             writerId, segmentName);\n-                                     return null;\n-                                 }\n-                                 if (exception instanceof SegmentSealedException) {\n-                                     log.info(\"Ending reconnect attempts on writer {} to {} because segment is sealed\", writerId, segmentName);\n-                                     return null;\n-                                 }\n-                                 if (exception instanceof NoSuchSegmentException) {\n-                                     log.info(\"Ending reconnect attempts on writer {} to {} because segment is truncated\", writerId, segmentName);\n-                                     return null;\n-                                 }\n-                                 throw Exceptions.sneakyThrow(t);\n-                             });\n-\n-                         }, connectionPool.getInternalExecutor());\n-                 }, connectionPool.getInternalExecutor());\n+            retrySchedule.retryWhen(t -> t instanceof Exception) // retry on all exceptions.\n+              .runAsync(() -> {\n+                  log.debug(\"Running reconnect for segment {} writer {}\", segmentName, writerId);\n+\n+                  if (state.isClosed() || state.needSuccessors.get()) {\n+                      // stop reconnect when writer is closed or resend inflight to successors has been triggered.\n+                      return CompletableFuture.completedFuture(null);\n+                  }\n+                  Preconditions.checkState(state.getConnection() == null);\n+                  log.info(\"Fetching endpoint for segment {}, writer {}\", segmentName, writerId);\n+\n+                  return controller.getEndpointForSegment(segmentName)\n+                      // Establish and return a connection to segment store\n+                      .thenComposeAsync((PravegaNodeUri uri) -> {\n+                          log.info(\"Establishing connection to {} for {}, writerID: {}\", uri, segmentName, writerId);\n+                          return establishConnection(uri);\n+                      }, connectionPool.getInternalExecutor())\n+                      .thenCombineAsync(tokenProvider.retrieveToken(),\n+                                        AbstractMap.SimpleEntry<ClientConnection, String>::new,\n+                                        connectionPool.getInternalExecutor())\n+                      .thenComposeAsync(pair -> {\n+                          ClientConnection connection = pair.getKey();\n+                          String token = pair.getValue();\n+\n+                          CompletableFuture<Void> connectionSetupFuture = state.newConnection(connection);\n+                          SetupAppend cmd = new SetupAppend(requestId, writerId, segmentName, token);\n+                          try {\n+                              connection.send(cmd);\n+                          } catch (ConnectionFailedException e1) {\n+                              // This needs to be invoked here because call to failConnection from netty may occur before state.newConnection above.\n+                              state.failConnection(e1);\n+                              throw Exceptions.sneakyThrow(e1);\n+                          }\n+                          return connectionSetupFuture.exceptionally(t1 -> {\n+                              Throwable exception = Exceptions.unwrap(t1);\n+                              if (exception instanceof InvalidTokenException) {\n+                                  log.info(\"Ending reconnect attempts on writer {} to {} because token verification failed due to invalid token\",\n+                                          writerId, segmentName);\n+                                  return null;\n+                              }\n+                              if (exception instanceof SegmentSealedException) {\n+                                  log.info(\"Ending reconnect attempts on writer {} to {} because segment is sealed\", writerId, segmentName);\n+                                  return null;\n+                              }\n+                              if (exception instanceof NoSuchSegmentException) {\n+                                  log.info(\"Ending reconnect attempts on writer {} to {} because segment is truncated\", writerId, segmentName);\n+                                  return null;\n+                              }\n+                              throw Exceptions.sneakyThrow(t1);\n+                          });\n+\n+                      }, connectionPool.getInternalExecutor());\n+              }, connectionPool.getInternalExecutor()).exceptionally(t -> {\n+                 log.error(\"Error will attempting to establish connection\", t);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b0bbff156f79bdcec778df06f55f8668afab91"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjYwMDE5OQ==", "bodyText": "fixed it.", "url": "https://github.com/pravega/pravega/pull/5307#discussion_r522600199", "createdAt": "2020-11-13T04:07:23Z", "author": {"login": "shrids"}, "path": "client/src/main/java/io/pravega/client/segment/impl/SegmentOutputStreamImpl.java", "diffHunk": "@@ -586,61 +597,64 @@ void reconnect() {\n         }\n         log.debug(\"(Re)connect invoked, Segment: {}, writerID: {}\", segmentName, writerId);\n         state.setupConnection.registerAndRunReleaser(() -> {\n-            Retry.indefinitelyWithExpBackoff(retrySchedule.getInitialMillis(), retrySchedule.getMultiplier(),\n-                                             retrySchedule.getMaxDelay(),\n-                                             t -> log.warn(writerId + \" Failed to connect: \", t))\n-                 .runAsync(() -> {\n-                     log.debug(\"Running reconnect for segment {} writer {}\", segmentName, writerId);\n-\n-                     if (state.isClosed() || state.needSuccessors.get()) {\n-                         // stop reconnect when writer is closed or resend inflight to successors has been triggered.\n-                         return CompletableFuture.completedFuture(null);\n-                     }\n-                     Preconditions.checkState(state.getConnection() == null);\n-                     log.info(\"Fetching endpoint for segment {}, writer {}\", segmentName, writerId);\n-\n-                     return controller.getEndpointForSegment(segmentName)\n-                         // Establish and return a connection to segment store\n-                         .thenComposeAsync((PravegaNodeUri uri) -> {\n-                             log.info(\"Establishing connection to {} for {}, writerID: {}\", uri, segmentName, writerId);\n-                             return establishConnection(uri);\n-                         }, connectionPool.getInternalExecutor())\n-                         .thenCombineAsync(tokenProvider.retrieveToken(),\n-                                           AbstractMap.SimpleEntry<ClientConnection, String>::new,\n-                                           connectionPool.getInternalExecutor())\n-                         .thenComposeAsync(pair -> {\n-                             ClientConnection connection = pair.getKey();\n-                             String token = pair.getValue();\n-\n-                             CompletableFuture<Void> connectionSetupFuture = state.newConnection(connection);\n-                             SetupAppend cmd = new SetupAppend(requestId, writerId, segmentName, token);\n-                             try {\n-                                 connection.send(cmd);\n-                             } catch (ConnectionFailedException e1) {\n-                                 // This needs to be invoked here because call to failConnection from netty may occur before state.newConnection above.\n-                                 state.failConnection(e1);\n-                                 throw Exceptions.sneakyThrow(e1);\n-                             }\n-                             return connectionSetupFuture.exceptionally(t -> {\n-                                 Throwable exception = Exceptions.unwrap(t);\n-                                 if (exception instanceof InvalidTokenException) {\n-                                     log.info(\"Ending reconnect attempts on writer {} to {} because token verification failed due to invalid token\",\n-                                             writerId, segmentName);\n-                                     return null;\n-                                 }\n-                                 if (exception instanceof SegmentSealedException) {\n-                                     log.info(\"Ending reconnect attempts on writer {} to {} because segment is sealed\", writerId, segmentName);\n-                                     return null;\n-                                 }\n-                                 if (exception instanceof NoSuchSegmentException) {\n-                                     log.info(\"Ending reconnect attempts on writer {} to {} because segment is truncated\", writerId, segmentName);\n-                                     return null;\n-                                 }\n-                                 throw Exceptions.sneakyThrow(t);\n-                             });\n-\n-                         }, connectionPool.getInternalExecutor());\n-                 }, connectionPool.getInternalExecutor());\n+            retrySchedule.retryWhen(t -> t instanceof Exception) // retry on all exceptions.\n+              .runAsync(() -> {\n+                  log.debug(\"Running reconnect for segment {} writer {}\", segmentName, writerId);\n+\n+                  if (state.isClosed() || state.needSuccessors.get()) {\n+                      // stop reconnect when writer is closed or resend inflight to successors has been triggered.\n+                      return CompletableFuture.completedFuture(null);\n+                  }\n+                  Preconditions.checkState(state.getConnection() == null);\n+                  log.info(\"Fetching endpoint for segment {}, writer {}\", segmentName, writerId);\n+\n+                  return controller.getEndpointForSegment(segmentName)\n+                      // Establish and return a connection to segment store\n+                      .thenComposeAsync((PravegaNodeUri uri) -> {\n+                          log.info(\"Establishing connection to {} for {}, writerID: {}\", uri, segmentName, writerId);\n+                          return establishConnection(uri);\n+                      }, connectionPool.getInternalExecutor())\n+                      .thenCombineAsync(tokenProvider.retrieveToken(),\n+                                        AbstractMap.SimpleEntry<ClientConnection, String>::new,\n+                                        connectionPool.getInternalExecutor())\n+                      .thenComposeAsync(pair -> {\n+                          ClientConnection connection = pair.getKey();\n+                          String token = pair.getValue();\n+\n+                          CompletableFuture<Void> connectionSetupFuture = state.newConnection(connection);\n+                          SetupAppend cmd = new SetupAppend(requestId, writerId, segmentName, token);\n+                          try {\n+                              connection.send(cmd);\n+                          } catch (ConnectionFailedException e1) {\n+                              // This needs to be invoked here because call to failConnection from netty may occur before state.newConnection above.\n+                              state.failConnection(e1);\n+                              throw Exceptions.sneakyThrow(e1);\n+                          }\n+                          return connectionSetupFuture.exceptionally(t1 -> {\n+                              Throwable exception = Exceptions.unwrap(t1);\n+                              if (exception instanceof InvalidTokenException) {\n+                                  log.info(\"Ending reconnect attempts on writer {} to {} because token verification failed due to invalid token\",\n+                                          writerId, segmentName);\n+                                  return null;\n+                              }\n+                              if (exception instanceof SegmentSealedException) {\n+                                  log.info(\"Ending reconnect attempts on writer {} to {} because segment is sealed\", writerId, segmentName);\n+                                  return null;\n+                              }\n+                              if (exception instanceof NoSuchSegmentException) {\n+                                  log.info(\"Ending reconnect attempts on writer {} to {} because segment is truncated\", writerId, segmentName);\n+                                  return null;\n+                              }\n+                              throw Exceptions.sneakyThrow(t1);\n+                          });\n+\n+                      }, connectionPool.getInternalExecutor());\n+              }, connectionPool.getInternalExecutor()).exceptionally(t -> {\n+                 log.error(\"Error will attempting to establish connection\", t);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMyNzE5Ng=="}, "originalCommit": {"oid": "c6b0bbff156f79bdcec778df06f55f8668afab91"}, "originalPosition": 178}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI3NDY1OTc5OnYy", "diffSide": "RIGHT", "path": "client/src/main/java/io/pravega/client/segment/impl/SegmentOutputStreamImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxODozNjo1NVrOHyIcpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QwNDoyNjoyNlrOHyZxQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMyOTI1NA==", "bodyText": "If they are completed exceptionally they should probably be removed from inflight as they cannot be subsequently be completed successfully.", "url": "https://github.com/pravega/pravega/pull/5307#discussion_r522329254", "createdAt": "2020-11-12T18:36:55Z", "author": {"login": "tkaitchuck"}, "path": "client/src/main/java/io/pravega/client/segment/impl/SegmentOutputStreamImpl.java", "diffHunk": "@@ -652,6 +666,11 @@ void reconnect() {\n         }\n     }\n \n+    private void failUnackedEvents(Throwable t) {\n+        state.getAllInflightEvents().parallelStream().forEach(event -> event.getAckFuture().completeExceptionally(t));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b0bbff156f79bdcec778df06f55f8668afab91"}, "originalPosition": 191}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjYxMzA1OA==", "bodyText": "ok, I have updated the code.", "url": "https://github.com/pravega/pravega/pull/5307#discussion_r522613058", "createdAt": "2020-11-13T04:26:26Z", "author": {"login": "shrids"}, "path": "client/src/main/java/io/pravega/client/segment/impl/SegmentOutputStreamImpl.java", "diffHunk": "@@ -652,6 +666,11 @@ void reconnect() {\n         }\n     }\n \n+    private void failUnackedEvents(Throwable t) {\n+        state.getAllInflightEvents().parallelStream().forEach(event -> event.getAckFuture().completeExceptionally(t));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMyOTI1NA=="}, "originalCommit": {"oid": "c6b0bbff156f79bdcec778df06f55f8668afab91"}, "originalPosition": 191}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4522, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}