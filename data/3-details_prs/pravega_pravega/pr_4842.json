{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI2Njc3MDk3", "number": 4842, "title": "Issue 4808: (SegmentStore) Using BufferViews for Table Segment APIs", "bodyText": "Change log description\n\nChanged TableStore APIs to accept BufferView instead of ArrayView. This helps reduce the number of times we copy key/values both inbound (from 3 to 1) and outbound (from 2 to 1).\nUnified all implementations of BufferView to have a common equals and hashCode.\n\nRemoved HashArray - it was made redundant by the change above.\n\n\nExtended BufferView.Reader with new methods to help reduce number of copies.\n\nPurpose of the change\nFixes #4808.\nWhat the code does\n\nUsing BufferView instead of ArrayView for TableStore APIs, including TableKey and TableValue\n\nThis was necessary to avoid the need for a copy in PravegaRequestProcessor from ByteBuf into a heap byte array.\nDue to the extensive use of TableKey throughout the codebase, this lead to the excessive size of this PR. All files that used TableKey had to be changed from using ArrayView to using BufferView. While most changes are just a repoint from one to another, some places required a bit more work (below).\n\n\nHashHelper has been enhanced to provide hashcodes for\n\nAn ordered list of ByteBuffers. This uses the existing APIs by Guava's HashFunction, and provide identical results to the old method (so there won't be a backwards incompatibility issue).\nA HashCode builder. This is similar to the above, but it doesn't require a list to be pre-built. This accumulates data (in the form of ByteBuffers, until a hashcode is ready to be generated).\n\n\nBufferView and its implementing classes had to be unified in terms of equals and hashcode implementation. Because we can now be abstracting either a heap array (ArrayView), Netty ByteBuf (ByteBufWrapper), a composite (CompositeBufferView) or a zero-copy-growing array (CompositeByteArraySegment) it was very important that these 2 methods be equivalent across these implementations (they should return the same values if the buffers contain the same data, irrespective of form).\n\nAll implementations of this interface have been standardized in terms of functionality.\nAdded a builder method to help create a composite BufferView without the need to pre-allocate a list.\nExtended BufferView.Reader with basic reading APIs that help read 1 byte, 32-bit int or 64-bit Long, as well as a slice of the buffer (zero-copy). These apply to all implementations.\n\n\n\nHow to verify it\nAll existing tests must pass. New tests added where needed.", "createdAt": "2020-06-02T15:52:29Z", "url": "https://github.com/pravega/pravega/pull/4842", "merged": true, "mergeCommit": {"oid": "15b0f5eb9feb04af7937ed203aa027669b5633b1"}, "closed": true, "closedAt": "2020-06-22T21:41:06Z", "author": {"login": "andreipaduroiu"}, "timelineItems": {"totalCount": 30, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcnW7ZXgH2gAyNDI2Njc3MDk3OjY3ZmIyYjVhNWNkNzA2OTE1NWEzMWRjYzFlMGU2NzljNzU5MjMyMzk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABct3Ju4gFqTQzNTI2MjI0NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "67fb2b5a5cd7069155a31dcc1e0e679c75923239", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/67fb2b5a5cd7069155a31dcc1e0e679c75923239", "committedDate": "2020-06-02T15:51:55Z", "message": "Changed TableStore APIs to accept BufferView instead of ArrayView. This helps reduce the number of times we copy key/values both inbound (from 3 to 1) and outbound (from 2 to 1).\nUnified all implementations of BufferView to have a common equals and hashCode.\nRemoved HashArray - it was made redundant by the change above.\nExtended BufferView.Reader with new method to help reduce number of copies.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "961cf2badf95fee49ccda26b0e3f6e146c1adb6a", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/961cf2badf95fee49ccda26b0e3f6e146c1adb6a", "committedDate": "2020-06-02T20:19:25Z", "message": "More unit tests for BufferView.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "88c79715a8004c91233ccdc68ccd191e7b1350d3", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/88c79715a8004c91233ccdc68ccd191e7b1350d3", "committedDate": "2020-06-02T21:30:48Z", "message": "Unit tests for Wire Commands.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "784f45abf8bbf9838e381d75b7e87c36c531f608", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/784f45abf8bbf9838e381d75b7e87c36c531f608", "committedDate": "2020-06-04T15:47:03Z", "message": "Merge branch 'master' into issue-4808-buffer-views"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "91e7ec130f098b2e2feef28916807da74b54ab36", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/91e7ec130f098b2e2feef28916807da74b54ab36", "committedDate": "2020-06-04T15:58:10Z", "message": "Merge branch 'master' into issue-4808-buffer-views"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1MDc4NTU2", "url": "https://github.com/pravega/pravega/pull/4842#pullrequestreview-425078556", "createdAt": "2020-06-05T07:58:41Z", "commit": {"oid": "91e7ec130f098b2e2feef28916807da74b54ab36"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwNzo1ODo0MVrOGfkREQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwODoxODo0NVrOGfk4aA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc1MzIzMw==", "bodyText": "Nit: extra dot at the end of this line.", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r435753233", "createdAt": "2020-06-05T07:58:41Z", "author": {"login": "RaulGracia"}, "path": "common/src/main/java/io/pravega/common/util/BufferViewBuilder.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.util;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.concurrent.NotThreadSafe;\n+import lombok.Getter;\n+import lombok.NonNull;\n+\n+/**\n+ * Builder for {@link BufferView} instances..", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91e7ec130f098b2e2feef28916807da74b54ab36"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc1NTkwMQ==", "bodyText": "From the abstract methods in this class in which this applies, would it make sense to clearly state in the javadoc what of them are expected to be zero-copy and which of them are not? I assume that you have an idea in mind for this, so perhaps this can be written as a guideline for future implementations of this interface. The thing is that, when working with ByteBuffer and ByteBuf, we sometimes have to go to the implementation to see whether an actual copy of the buffer is made or not, which is confusing. It would be great to use in this family of classes (this one and the ones implementing it) an annotation like @ZeroCopy or similar to make users rapidly aware of the costs of the different operations involved in this class.", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r435755901", "createdAt": "2020-06-05T08:03:50Z", "author": {"login": "RaulGracia"}, "path": "common/src/main/java/io/pravega/common/util/BufferView.java", "diffHunk": "@@ -142,14 +154,43 @@ default void release() {\n      */\n     static BufferView wrap(List<BufferView> components) {\n         if (components.size() == 0) {\n-            return new ByteArraySegment(new byte[0]);\n+            return empty();\n         } else if (components.size() == 1) {\n             return components.get(0).slice();\n         } else {\n             return new CompositeBufferView(components);\n         }\n     }\n \n+    /**\n+     * Creates a new {@link BufferViewBuilder} that can be used to construct composite {@link BufferView} instances.\n+     *\n+     * @return A new {@link BufferViewBuilder} with default initial component count.\n+     */\n+    static BufferViewBuilder builder() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91e7ec130f098b2e2feef28916807da74b54ab36"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc2MTA1OQ==", "bodyText": "In our experiments, we normally observe that using stream() heavily is more costly than a plain loop. We need to evaluate whether this change is making any performance difference in this case.", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r435761059", "createdAt": "2020-06-05T08:14:21Z", "author": {"login": "RaulGracia"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/PravegaRequestProcessor.java", "diffHunk": "@@ -314,15 +313,17 @@ private ReadResultEntry collectCachedEntries(long initialOffset, ReadResult read\n     /**\n      * Collect all the data from the given contents into a {@link ByteBuf}.\n      */\n-    private ByteBuf getData(List<BufferView> contents) {\n-        val compositeView = BufferView.wrap(contents);\n-        val rawBuffers = compositeView.getContents();\n-        val result = Unpooled.compositeBuffer(rawBuffers.size());\n-        for (ByteBuffer b : rawBuffers) {\n-            result.addComponent(Unpooled.wrappedBuffer(b));\n-        }\n+    private ByteBuf toByteBuf(List<BufferView> contents) {\n+        val buffers = contents.stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91e7ec130f098b2e2feef28916807da74b54ab36"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc2MjY0MQ==", "bodyText": "Why the synchronization block is not needed anymore here?", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r435762641", "createdAt": "2020-06-05T08:17:32Z", "author": {"login": "RaulGracia"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/PravegaRequestProcessor.java", "diffHunk": "@@ -717,57 +727,49 @@ public void readTableKeys(WireCommands.ReadTableKeys readTableKeys) {\n             return;\n         }\n \n-        log.info(readTableKeys.getRequestId(), \"Fetching keys from {}.\", readTableKeys);\n+        log.debug(readTableKeys.getRequestId(), \"Iterate Table Segment Keys: Segment={}, Count={}.\",\n+                readTableKeys.getSegment(), readTableKeys.getSuggestedKeyCount());\n \n         int suggestedKeyCount = readTableKeys.getSuggestedKeyCount();\n         ByteBuf token = readTableKeys.getContinuationToken();\n \n-        byte[] state = null;\n+        BufferView state = null;\n         if (!token.equals(EMPTY_BUFFER)) {\n-            state = token.array();\n+            state = new ByteBufWrapper(token);\n         }\n \n-        final AtomicInteger msgSize = new AtomicInteger(0);\n-        final AtomicReference<ByteBuf> continuationToken = new AtomicReference<>(EMPTY_BUFFER);\n-        final List<TableKey> keys = new ArrayList<>();\n-\n+        val msgSize = new AtomicInteger(segment.getBytes().length + WireCommands.TableKeysRead.HEADER_BYTES);\n+        val continuationToken = new AtomicReference<>(EMPTY_BUFFER);\n+        val keys = new ArrayList<WireCommands.TableKey>();\n         val timer = new Timer();\n         tableStore.keyIterator(segment, state, TIMEOUT)\n-                  .thenCompose(itr -> itr.collectRemaining(\n-                          e -> {\n-                              synchronized (keys) {\n-                                  if (keys.size() < suggestedKeyCount && msgSize.get() < MAX_READ_SIZE) {\n-                                      Collection<TableKey> tableKeys = e.getEntries();\n-                                      ArrayView lastState = e.getState();\n-\n-                                      // Store all tableKeys.\n-                                      keys.addAll(tableKeys);\n-                                      // update the continuation token.\n-                                      continuationToken.set(wrappedBuffer(lastState.array(), lastState.arrayOffset(), lastState.getLength()));\n-                                      // Update msgSize.\n-                                      msgSize.addAndGet(getTableKeyBytes(segment, tableKeys, lastState.getLength()));\n-                                      return true;\n-                                  } else {\n-                                      return false;\n-                                  }\n-                              }\n-                          }))\n-                  .thenAccept(v -> {\n-                      final List<WireCommands.TableKey> wireCommandKeys;\n-                      synchronized (keys) {\n-                          log.debug(readTableKeys.getRequestId(), \"{} keys obtained for ReadTableKeys request.\", keys.size());\n-                          wireCommandKeys = keys.stream()\n-                                                .map(k -> {\n-                                                    ArrayView keyArray = k.getKey();\n-                                                    return new WireCommands.TableKey(wrappedBuffer(keyArray.array(),\n-                                                                                                   keyArray.arrayOffset(),\n-                                                                                                   keyArray.getLength()), k.getVersion());\n-                                                })\n-                                                .collect(toList());\n-                      }\n-                      connection.send(new WireCommands.TableKeysRead(readTableKeys.getRequestId(), segment, wireCommandKeys, continuationToken.get()));\n-                      this.tableStatsRecorder.iterateKeys(readTableKeys.getSegment(), keys.size(), timer.getElapsed());\n-                  }).exceptionally(e -> handleException(readTableKeys.getRequestId(), segment, operation, e));\n+                .thenCompose(itr -> itr.collectRemaining(\n+                        e -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91e7ec130f098b2e2feef28916807da74b54ab36"}, "originalPosition": 219}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc2MzMwNA==", "bodyText": "Same question here about the sync block.", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r435763304", "createdAt": "2020-06-05T08:18:45Z", "author": {"login": "RaulGracia"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/PravegaRequestProcessor.java", "diffHunk": "@@ -779,115 +781,67 @@ public void readTableEntries(WireCommands.ReadTableEntries readTableEntries) {\n             return;\n         }\n \n-        log.info(readTableEntries.getRequestId(), \"Fetching keys from {}.\", readTableEntries);\n+        log.debug(readTableEntries.getRequestId(), \"Iterate Table Segment Entries: Segment={}, Count={}.\",\n+                readTableEntries.getSegment(), readTableEntries.getSuggestedEntryCount());\n \n         int suggestedEntryCount = readTableEntries.getSuggestedEntryCount();\n         ByteBuf token = readTableEntries.getContinuationToken();\n \n-        byte[] state = null;\n+        BufferView state = null;\n         if (!token.equals(EMPTY_BUFFER)) {\n-            state = token.array();\n+            state = new ByteBufWrapper(token);\n         }\n \n-        final AtomicInteger msgSize = new AtomicInteger(0);\n-        final AtomicReference<ByteBuf> continuationToken = new AtomicReference<>(EMPTY_BUFFER);\n-        final List<TableEntry> entries = new ArrayList<>();\n+        val msgSize = new AtomicInteger(segment.getBytes().length + WireCommands.TableEntriesRead.HEADER_BYTES);\n+        val continuationToken = new AtomicReference<>(EMPTY_BUFFER);\n+        val entries = new ArrayList<Map.Entry<WireCommands.TableKey, WireCommands.TableValue>>();\n         val timer = new Timer();\n         tableStore.entryIterator(segment, state, TIMEOUT)\n-                  .thenCompose(itr -> itr.collectRemaining(\n-                          e -> {\n-                              synchronized (entries) {\n-                                  if (entries.size() < suggestedEntryCount && msgSize.get() < MAX_READ_SIZE) {\n-                                      final Collection<TableEntry> tableEntries = e.getEntries();\n-                                      final ArrayView lastState = e.getState();\n-\n-                                      // Store all TableEntrys.\n-                                      entries.addAll(tableEntries);\n-                                      // Update the continuation token.\n-                                      continuationToken.set(wrappedBuffer(lastState.array(), lastState.arrayOffset(), lastState.getLength()));\n-                                      // Update message size.\n-                                      msgSize.addAndGet(getTableEntryBytes(segment, tableEntries, lastState.getLength()));\n-                                      return true;\n-                                  } else {\n-                                      return false;\n-                                  }\n-                              }\n-                          }))\n-                  .thenAccept(v -> {\n-                      final List<Map.Entry<WireCommands.TableKey, WireCommands.TableValue>> wireCommandEntries;\n-                      synchronized (entries) {\n-                          log.debug(readTableEntries.getRequestId(), \"{} entries obtained for ReadTableEntries request.\", entries.size());\n-                          wireCommandEntries = entries.stream()\n-                                                      .map(e -> {\n-                                                          TableKey k = e.getKey();\n-                                                          val keyWireCommand = new WireCommands.TableKey(wrappedBuffer(k.getKey().array(), k.getKey().arrayOffset(),\n-                                                                                                                       k.getKey().getLength()),\n-                                                                                                         k.getVersion());\n-                                                          ArrayView value = e.getValue();\n-                                                          val valueWireCommand = new WireCommands.TableValue(wrappedBuffer(value.array(), value.arrayOffset(),\n-                                                                                                                           value.getLength()));\n-                                                          return new AbstractMap.SimpleImmutableEntry<>(keyWireCommand, valueWireCommand);\n-                                                      })\n-                                                      .collect(toList());\n-                      }\n-\n-                      connection.send(new WireCommands.TableEntriesRead(readTableEntries.getRequestId(), segment,\n-                                                                        new WireCommands.TableEntries(wireCommandEntries),\n-                                                                        continuationToken.get()));\n-                      this.tableStatsRecorder.iterateEntries(readTableEntries.getSegment(), entries.size(), timer.getElapsed());\n-                  }).exceptionally(e -> handleException(readTableEntries.getRequestId(), segment, operation, e));\n-    }\n-\n-    private int getTableKeyBytes(String segment, Collection<TableKey> keys, int continuationTokenLength) {\n-        int headerLength = WireCommands.TableKeysRead.GET_HEADER_BYTES.apply(keys.size());\n-        int segmentLength = segment.getBytes().length;\n-        int dataLength = keys.stream().mapToInt(value -> value.getKey().getLength() + Long.BYTES).sum();\n-        return continuationTokenLength + headerLength + segmentLength + dataLength;\n-    }\n-\n-    private int getTableEntryBytes(String segment, Collection<TableEntry> items, int continuationTokenLength) {\n-        int headerLength = WireCommands.TableEntriesRead.GET_HEADER_BYTES.apply(items.size());\n-        int segmentLength = segment.getBytes().length;\n-        int dataLength = items.stream().mapToInt(value -> {\n-            return value.getKey().getKey().getLength() // key\n-                    + Long.BYTES // key version\n-                    + value.getValue().getLength(); // value\n-        }).sum();\n-        return headerLength + segmentLength + dataLength + continuationTokenLength;\n-    }\n-\n-    private ArrayView getArrayView(ByteBuf buf) {\n-        final int length = buf.readableBytes();\n-        if (buf.hasArray()) {\n-            return new ByteArraySegment(buf.array(), buf.readerIndex(), length);\n-        } else {\n-            byte[] bytes;\n-            bytes = new byte[length];\n-            buf.getBytes(buf.readerIndex(), bytes);\n-            return new ByteArraySegment(bytes, 0, length);\n-        }\n-    }\n+                .thenCompose(itr -> itr.collectRemaining(\n+                        e -> {\n+                            if (entries.size() >= suggestedEntryCount || msgSize.get() >= MAX_READ_SIZE) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91e7ec130f098b2e2feef28916807da74b54ab36"}, "originalPosition": 349}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e82c83d07ecca77a42dc087519db9f161e357a74", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/e82c83d07ecca77a42dc087519db9f161e357a74", "committedDate": "2020-06-05T15:01:04Z", "message": "Merge remote-tracking branch 'remotes/origin/master' into issue-4808-buffer-views"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "75393f93b7ca4731214dd48856dec9fb1c86ef3f", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/75393f93b7ca4731214dd48856dec9fb1c86ef3f", "committedDate": "2020-06-05T15:15:55Z", "message": "Javadoc for BufferView and BufferViewBuilder.\nSynchronization bugfix for PravegaRequestProcessor.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0fefefb24add30dd3920b2f39b65dd823b6aa9b4", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/0fefefb24add30dd3920b2f39b65dd823b6aa9b4", "committedDate": "2020-06-05T15:16:06Z", "message": "Merge remote-tracking branch 'ap/issue-4808-buffer-views' into issue-4808-buffer-views"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "deb6aec43150f98452ad65c33a1a3f2c2b61cfc5", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/deb6aec43150f98452ad65c33a1a3f2c2b61cfc5", "committedDate": "2020-06-05T23:18:10Z", "message": "Merge branch 'master' into issue-4808-buffer-views"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "42e653d7e7be1f14a47f403cbc83ee7212ee33c9", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/42e653d7e7be1f14a47f403cbc83ee7212ee33c9", "committedDate": "2020-06-08T14:42:09Z", "message": "Merge branch 'master' into issue-4808-buffer-views"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b74cf9e11ebd27d5c59f80adf26a16ff44813ceb", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/b74cf9e11ebd27d5c59f80adf26a16ff44813ceb", "committedDate": "2020-06-08T14:46:52Z", "message": "Merge branch 'master' into issue-4808-buffer-views"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aadda814743123a6ea18dff92495e66dd0623fc0", "author": {"user": {"login": "RaulGracia", "name": "Ra\u00fal Gracia"}}, "url": "https://github.com/pravega/pravega/commit/aadda814743123a6ea18dff92495e66dd0623fc0", "committedDate": "2020-06-09T15:04:57Z", "message": "Merge branch 'master' into issue-4808-buffer-views"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "42c6fbdf1290eeaabcfe13eab14885e82cfd6f6e", "author": {"user": {"login": "RaulGracia", "name": "Ra\u00fal Gracia"}}, "url": "https://github.com/pravega/pravega/commit/42c6fbdf1290eeaabcfe13eab14885e82cfd6f6e", "committedDate": "2020-06-12T14:52:12Z", "message": "Merge branch 'master' into issue-4808-buffer-views"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI5ODExMDEy", "url": "https://github.com/pravega/pravega/pull/4842#pullrequestreview-429811012", "createdAt": "2020-06-12T14:56:32Z", "commit": {"oid": "42c6fbdf1290eeaabcfe13eab14885e82cfd6f6e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a93c87781bcac941ad40dea06380b08d6177c0ea", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/a93c87781bcac941ad40dea06380b08d6177c0ea", "committedDate": "2020-06-15T16:26:26Z", "message": "Merge branch 'master' into issue-4808-buffer-views"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "89844088fe9693657a50ef71fed88155f029375e", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/89844088fe9693657a50ef71fed88155f029375e", "committedDate": "2020-06-16T14:47:39Z", "message": "Merge branch 'master' into issue-4808-buffer-views"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxOTM5MTg0", "url": "https://github.com/pravega/pravega/pull/4842#pullrequestreview-431939184", "createdAt": "2020-06-16T22:36:20Z", "commit": {"oid": "89844088fe9693657a50ef71fed88155f029375e"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 23, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMjozNjoyMFrOGkvgpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QwMDo1MToyOVrOGkx7ew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE4MDMyNA==", "bodyText": "final", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r441180324", "createdAt": "2020-06-16T22:36:20Z", "author": {"login": "tkaitchuck"}, "path": "common/src/main/java/io/pravega/common/hash/HashHelper.java", "diffHunk": "@@ -103,4 +114,21 @@ static double longToDoubleFraction(long value) {\n         long shifted = (value >> 12) & MASK;\n         return Double.longBitsToDouble(LEADING_BITS + shifted) - 1;\n     }\n+\n+    @RequiredArgsConstructor(access = AccessLevel.PRIVATE)\n+    public class HashBuilder {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89844088fe9693657a50ef71fed88155f029375e"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE4MTE5Mw==", "bodyText": "collectBuffer isn't the best name, as it implies it is itself a buffer. Perhaps bufferCollector would be better.", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r441181193", "createdAt": "2020-06-16T22:39:00Z", "author": {"login": "tkaitchuck"}, "path": "common/src/main/java/io/pravega/common/util/BufferView.java", "diffHunk": "@@ -127,29 +129,74 @@ default void release() {\n     }\n \n     /**\n-     * Gets a list of {@link ByteBuffer} that represent the contents of this {@link BufferView}.\n+     * Gets a list of {@link ByteBuffer} that represent the contents of this {@link BufferView}. These buffer point\n+     * directly to the data contained within this buffer (i.e., they are not copies of the data).\n      *\n      * @return A List of {@link ByteBuffer}.\n      */\n     List<ByteBuffer> getContents();\n \n+    /**\n+     * Iterates through each of the buffers that make up this {@link BufferView}, in order, and invokes the given\n+     * {@link Collector} on each.\n+     *\n+     * @param collectBuffer A {@link Collector} function that will be invoked for each component. Each {@link ByteBuffer}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89844088fe9693657a50ef71fed88155f029375e"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE4MjA1OQ==", "bodyText": "10 seems somewhat high on average...", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r441182059", "createdAt": "2020-06-16T22:41:24Z", "author": {"login": "tkaitchuck"}, "path": "common/src/main/java/io/pravega/common/util/BufferView.java", "diffHunk": "@@ -127,29 +129,74 @@ default void release() {\n     }\n \n     /**\n-     * Gets a list of {@link ByteBuffer} that represent the contents of this {@link BufferView}.\n+     * Gets a list of {@link ByteBuffer} that represent the contents of this {@link BufferView}. These buffer point\n+     * directly to the data contained within this buffer (i.e., they are not copies of the data).\n      *\n      * @return A List of {@link ByteBuffer}.\n      */\n     List<ByteBuffer> getContents();\n \n+    /**\n+     * Iterates through each of the buffers that make up this {@link BufferView}, in order, and invokes the given\n+     * {@link Collector} on each.\n+     *\n+     * @param collectBuffer A {@link Collector} function that will be invoked for each component. Each {@link ByteBuffer}\n+     *                      passed as an argument to this function is a direct pointer to the data contained within the\n+     *                      {@link BufferView} (i.e., they are not copies of the data).\n+     * @param <ExceptionT>  Type of exception that the {@link Collector} function throws, if any.\n+     * @throws ExceptionT If the {@link Collector} function throws an exception of this type, the iteration will end\n+     *                    and the exception will be bubbled up.\n+     */\n+    <ExceptionT extends Exception> void collect(Collector<ExceptionT> collectBuffer) throws ExceptionT;\n+\n     /**\n      * Wraps the given {@link BufferView} into a single instance.\n      *\n-     * @param components The components to wrap.\n+     * @param components The components to wrap. These components will be added by reference, without making any data\n+     *                   copies. Any modifications made to these components will be reflected in the returned\n+     *                   {@link BufferView} and vice-versa.\n      * @return An empty {@link BufferView} (if the component list is empty), the first item in the list (if the component\n      * list has 1 element) or a {@link CompositeBufferView} wrapping all the given instances otherwise.\n      */\n     static BufferView wrap(List<BufferView> components) {\n         if (components.size() == 0) {\n-            return new ByteArraySegment(new byte[0]);\n+            return empty();\n         } else if (components.size() == 1) {\n             return components.get(0).slice();\n         } else {\n             return new CompositeBufferView(components);\n         }\n     }\n \n+    /**\n+     * Creates a new {@link BufferViewBuilder} that can be used to construct composite {@link BufferView} instances.\n+     *\n+     * @return A new {@link BufferViewBuilder} with default initial component count.\n+     */\n+    static BufferViewBuilder builder() {\n+        return builder(10);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89844088fe9693657a50ef71fed88155f029375e"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE4MjQ1OQ==", "bodyText": "Why return an int?", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r441182459", "createdAt": "2020-06-16T22:42:33Z", "author": {"login": "tkaitchuck"}, "path": "common/src/main/java/io/pravega/common/util/BufferView.java", "diffHunk": "@@ -173,23 +220,65 @@ static BufferView wrap(List<BufferView> components) {\n         int readBytes(ByteArraySegment segment);\n \n         /**\n-         * Reads all the remaining bytes from this {@link BufferView.Reader} into a new {@link ByteArraySegment}.\n+         * Reads one byte and advances the reader position by 1.\n+         *\n+         * @return The read byte.\n+         * @throws EOFException If {@link #available()} is 0.\n+         */\n+        int readByte() throws EOFException;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89844088fe9693657a50ef71fed88155f029375e"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE4Mjc1Nw==", "bodyText": "It should be clear that this is a copy.", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r441182757", "createdAt": "2020-06-16T22:43:29Z", "author": {"login": "tkaitchuck"}, "path": "common/src/main/java/io/pravega/common/util/BufferView.java", "diffHunk": "@@ -173,23 +220,65 @@ static BufferView wrap(List<BufferView> components) {\n         int readBytes(ByteArraySegment segment);\n \n         /**\n-         * Reads all the remaining bytes from this {@link BufferView.Reader} into a new {@link ByteArraySegment}.\n+         * Reads one byte and advances the reader position by 1.\n+         *\n+         * @return The read byte.\n+         * @throws EOFException If {@link #available()} is 0.\n+         */\n+        int readByte() throws EOFException;\n+\n+        /**\n+         * Reads 4 bytes (and advances the reader position by 4) and composes a 32-bit Integer (Big-Endian).\n+         *\n+         * @return The read int.\n+         * @throws EOFException If {@link #available()} is less than {@link Integer#BYTES}.\n+         */\n+        int readInt() throws EOFException;\n+\n+        /**\n+         * Reads 8 bytes (and advances the reader position by 4) and composes a 64-bit Long (Big-Endian).\n+         *\n+         * @return The read long.\n+         * @throws EOFException If {@link #available()} is less than {@link Long#BYTES}.\n+         */\n+        long readLong() throws EOFException;\n+\n+        /**\n+         * Returns a {@link BufferView} that is a representation of the next bytes starting at the given position. The\n+         * reader position will be advanced by the requested number of bytes.\n+         *\n+         * @param length The number of bytes to slice out.\n+         * @return A {@link BufferView} that represents the given bytes. This {@link BufferView} represents a view into\n+         * the underlying {@link BufferView} and is not a copy of the given range.\n+         * @throws EOFException If {@link #available()} is less than length.\n+         */\n+        BufferView readSlice(int length) throws EOFException;\n+\n+        /**\n+         * Reads all the remaining bytes from this {@link BufferView.Reader} into a new {@link ArrayView}. The reader", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89844088fe9693657a50ef71fed88155f029375e"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE4MzMzMw==", "bodyText": "Do you have specific plans for this? It may be possible to optimize significantly.", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r441183333", "createdAt": "2020-06-16T22:45:14Z", "author": {"login": "tkaitchuck"}, "path": "common/src/main/java/io/pravega/common/util/AbstractBufferView.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.util;\n+\n+import com.google.common.base.Preconditions;\n+import io.pravega.common.hash.HashHelper;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.ByteBuffer;\n+import java.util.Collections;\n+import java.util.List;\n+import lombok.Getter;\n+import lombok.SneakyThrows;\n+\n+/**\n+ * Base implementation of {@link BufferView}, providing common functionality.\n+ * Derived classes may override these methods with more efficient implementations tailored to their data types.\n+ */\n+public abstract class AbstractBufferView implements BufferView {\n+    static final BufferView EMPTY = new EmptyBufferView();\n+    private static final HashHelper HASH = HashHelper.seededWith(AbstractBufferView.class.getName());\n+\n+    @Override\n+    public int hashCode() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89844088fe9693657a50ef71fed88155f029375e"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE4NDkzNQ==", "bodyText": "I don't think this method should be defined here. Both ByteBuffer.equals and Arrays.equals are ~10-100x faster than doing it this way. If we make equals abstract then the child classes are forced to implement it for themselves.", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r441184935", "createdAt": "2020-06-16T22:49:55Z", "author": {"login": "tkaitchuck"}, "path": "common/src/main/java/io/pravega/common/util/AbstractBufferView.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.util;\n+\n+import com.google.common.base.Preconditions;\n+import io.pravega.common.hash.HashHelper;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.ByteBuffer;\n+import java.util.Collections;\n+import java.util.List;\n+import lombok.Getter;\n+import lombok.SneakyThrows;\n+\n+/**\n+ * Base implementation of {@link BufferView}, providing common functionality.\n+ * Derived classes may override these methods with more efficient implementations tailored to their data types.\n+ */\n+public abstract class AbstractBufferView implements BufferView {\n+    static final BufferView EMPTY = new EmptyBufferView();\n+    private static final HashHelper HASH = HashHelper.seededWith(AbstractBufferView.class.getName());\n+\n+    @Override\n+    public int hashCode() {\n+        HashHelper.HashBuilder builder = HASH.newBuilder();\n+        collect(builder::put);\n+        return builder.getAsInt();\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj instanceof BufferView) {\n+            return equals((BufferView) obj);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Checks for equality against another {@link BufferView} instance.\n+     *\n+     * Note: this method provides a general implementation of equality. Derived classes should override this method with\n+     * more efficient implementations if available.\n+     *\n+     * @param other The other {@link BufferView} instance.\n+     * @return True if this instance and the other instance have the same contents.\n+     */\n+    @SneakyThrows(IOException.class)\n+    public boolean equals(BufferView other) {\n+        int l = getLength();\n+        if (l != other.getLength()) {\n+            return false;\n+        }\n+\n+        if (l > 0) {\n+            BufferView.Reader thisReader = getBufferViewReader();\n+            BufferView.Reader otherReader = other.getBufferViewReader();\n+            for (int i = 0; i < l; i++) {\n+                if (thisReader.readByte() != otherReader.readByte()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89844088fe9693657a50ef71fed88155f029375e"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE5NTE4MA==", "bodyText": "Here and in the similar methods copy the structure of:\nUnsafe.getLongUnaligned et alt exactly. (obviously adapting the call to fetch the individual byte)\nthen annotate the method with @HotSpotIntrinsicCandidate\nthis should get the JIT to turn it into a CPU instruction directly.", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r441195180", "createdAt": "2020-06-16T23:21:49Z", "author": {"login": "tkaitchuck"}, "path": "common/src/main/java/io/pravega/common/util/BitConverter.java", "diffHunk": "@@ -176,6 +176,22 @@ public static int readInt(InputStream source) throws IOException {\n         }\n     }\n \n+    /**\n+     * Composes a 32-bit integer from the given byte components (Big-Endian order).\n+     *\n+     * @param b1 Byte #1.\n+     * @param b2 Byte #2.\n+     * @param b3 Byte #3.\n+     * @param b4 Byte #4.\n+     * @return The composed number.\n+     */\n+    public static int makeInt(int b1, int b2, int b3, int b4) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89844088fe9693657a50ef71fed88155f029375e"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIwNzU2NA==", "bodyText": "See my comment above.", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r441207564", "createdAt": "2020-06-17T00:05:01Z", "author": {"login": "tkaitchuck"}, "path": "common/src/main/java/io/pravega/common/util/BitConverter.java", "diffHunk": "@@ -303,17 +319,34 @@ public static long readLong(InputStream source) throws IOException {\n         if ((b1 | b2 | b3 | b4 | b5 | b6 | b7 | b8) < 0) {\n             throw new EOFException();\n         } else {\n-            return ((long) b1 << 56) +\n-                    ((long) (b2 & 255) << 48) +\n-                    ((long) (b3 & 255) << 40) +\n-                    ((long) (b4 & 255) << 32) +\n-                    ((long) (b5 & 255) << 24) +\n-                    (long) ((b6 & 255) << 16) +\n-                    (long) ((b7 & 255) << 8) +\n-                    (long) ((b8 & 255));\n+            return BitConverter.makeLong(b1, b2, b3, b4, b5, b6, b7, b8);\n         }\n     }\n \n+    /**\n+     * Composes 64-bit long from the given byte components (in Big Endian order).\n+     *\n+     * @param b1 Byte #1.\n+     * @param b2 Byte #2.\n+     * @param b3 Byte #3.\n+     * @param b4 Byte #4.\n+     * @param b5 Byte #5.\n+     * @param b6 Byte #6.\n+     * @param b7 Byte #7.\n+     * @param b8 Byte #8.\n+     * @return The composed number.\n+     */\n+    public static long makeLong(int b1, int b2, int b3, int b4, int b5, int b6, int b7, int b8) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89844088fe9693657a50ef71fed88155f029375e"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIwNzg2NQ==", "bodyText": "These really need to be passed as bytes not ints.\nAdditionally I think there may be performance gain in moving the BitConverter metrics here and leaving readByte abstract. See my comments on BItConverter.", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r441207865", "createdAt": "2020-06-17T00:06:02Z", "author": {"login": "tkaitchuck"}, "path": "common/src/main/java/io/pravega/common/util/AbstractBufferView.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.util;\n+\n+import com.google.common.base.Preconditions;\n+import io.pravega.common.hash.HashHelper;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.ByteBuffer;\n+import java.util.Collections;\n+import java.util.List;\n+import lombok.Getter;\n+import lombok.SneakyThrows;\n+\n+/**\n+ * Base implementation of {@link BufferView}, providing common functionality.\n+ * Derived classes may override these methods with more efficient implementations tailored to their data types.\n+ */\n+public abstract class AbstractBufferView implements BufferView {\n+    static final BufferView EMPTY = new EmptyBufferView();\n+    private static final HashHelper HASH = HashHelper.seededWith(AbstractBufferView.class.getName());\n+\n+    @Override\n+    public int hashCode() {\n+        HashHelper.HashBuilder builder = HASH.newBuilder();\n+        collect(builder::put);\n+        return builder.getAsInt();\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj instanceof BufferView) {\n+            return equals((BufferView) obj);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Checks for equality against another {@link BufferView} instance.\n+     *\n+     * Note: this method provides a general implementation of equality. Derived classes should override this method with\n+     * more efficient implementations if available.\n+     *\n+     * @param other The other {@link BufferView} instance.\n+     * @return True if this instance and the other instance have the same contents.\n+     */\n+    @SneakyThrows(IOException.class)\n+    public boolean equals(BufferView other) {\n+        int l = getLength();\n+        if (l != other.getLength()) {\n+            return false;\n+        }\n+\n+        if (l > 0) {\n+            BufferView.Reader thisReader = getBufferViewReader();\n+            BufferView.Reader otherReader = other.getBufferViewReader();\n+            for (int i = 0; i < l; i++) {\n+                if (thisReader.readByte() != otherReader.readByte()) {\n+                    return false;\n+                }\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n+    //region AbstractReader\n+\n+    /**\n+     * Base implementation of {@link BufferView.Reader}. Subclasses of {@link AbstractBufferView} should implement their\n+     * own {@link BufferView.Reader} instances based on this class.\n+     */\n+    protected static abstract class AbstractReader implements BufferView.Reader {\n+        @Override\n+        public int readInt() throws EOFException {\n+            return BitConverter.makeInt(readByte(), readByte(), readByte(), readByte());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89844088fe9693657a50ef71fed88155f029375e"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIwNzkxMg==", "bodyText": "same here", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r441207912", "createdAt": "2020-06-17T00:06:13Z", "author": {"login": "tkaitchuck"}, "path": "common/src/main/java/io/pravega/common/util/AbstractBufferView.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.util;\n+\n+import com.google.common.base.Preconditions;\n+import io.pravega.common.hash.HashHelper;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.ByteBuffer;\n+import java.util.Collections;\n+import java.util.List;\n+import lombok.Getter;\n+import lombok.SneakyThrows;\n+\n+/**\n+ * Base implementation of {@link BufferView}, providing common functionality.\n+ * Derived classes may override these methods with more efficient implementations tailored to their data types.\n+ */\n+public abstract class AbstractBufferView implements BufferView {\n+    static final BufferView EMPTY = new EmptyBufferView();\n+    private static final HashHelper HASH = HashHelper.seededWith(AbstractBufferView.class.getName());\n+\n+    @Override\n+    public int hashCode() {\n+        HashHelper.HashBuilder builder = HASH.newBuilder();\n+        collect(builder::put);\n+        return builder.getAsInt();\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj instanceof BufferView) {\n+            return equals((BufferView) obj);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Checks for equality against another {@link BufferView} instance.\n+     *\n+     * Note: this method provides a general implementation of equality. Derived classes should override this method with\n+     * more efficient implementations if available.\n+     *\n+     * @param other The other {@link BufferView} instance.\n+     * @return True if this instance and the other instance have the same contents.\n+     */\n+    @SneakyThrows(IOException.class)\n+    public boolean equals(BufferView other) {\n+        int l = getLength();\n+        if (l != other.getLength()) {\n+            return false;\n+        }\n+\n+        if (l > 0) {\n+            BufferView.Reader thisReader = getBufferViewReader();\n+            BufferView.Reader otherReader = other.getBufferViewReader();\n+            for (int i = 0; i < l; i++) {\n+                if (thisReader.readByte() != otherReader.readByte()) {\n+                    return false;\n+                }\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n+    //region AbstractReader\n+\n+    /**\n+     * Base implementation of {@link BufferView.Reader}. Subclasses of {@link AbstractBufferView} should implement their\n+     * own {@link BufferView.Reader} instances based on this class.\n+     */\n+    protected static abstract class AbstractReader implements BufferView.Reader {\n+        @Override\n+        public int readInt() throws EOFException {\n+            return BitConverter.makeInt(readByte(), readByte(), readByte(), readByte());\n+        }\n+\n+        @Override\n+        public long readLong() throws EOFException {\n+            return BitConverter.makeLong(readByte(), readByte(), readByte(), readByte(), readByte(), readByte(), readByte(), readByte());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89844088fe9693657a50ef71fed88155f029375e"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIwOTQyNQ==", "bodyText": "This is an unusual semantic by Java standards. Most of the standard library read methods will return a partial 'read' if there is less data. I don't have a strong opinion as to which way is better, but I wanted to call it out.", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r441209425", "createdAt": "2020-06-17T00:11:44Z", "author": {"login": "tkaitchuck"}, "path": "common/src/main/java/io/pravega/common/util/CompositeBufferView.java", "diffHunk": "@@ -185,6 +201,45 @@ public int readBytes(ByteArraySegment segment) {\n             return 0;\n         }\n \n+        @Override\n+        public int readByte() throws EOFException {\n+            BufferView.Reader current = getCurrent();\n+            if (current == null) {\n+                throw new EOFException();\n+            }\n+\n+            int result = current.readByte();\n+            this.available--;\n+            assert this.available >= 0;\n+            return result;\n+        }\n+\n+        @Override\n+        public BufferView readSlice(final int length) throws EOFException {\n+            if (length > available()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89844088fe9693657a50ef71fed88155f029375e"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxMDMyNA==", "bodyText": "This used to cache the hash value, it does not appear to now. Is this intended?", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r441210324", "createdAt": "2020-06-17T00:14:54Z", "author": {"login": "tkaitchuck"}, "path": "segmentstore/contracts/src/main/java/io/pravega/segmentstore/contracts/tables/TableKey.java", "diffHunk": "@@ -96,15 +95,14 @@ public String toString() {\n \n     @Override\n     public int hashCode() {\n-        return HashedArray.hashCode(this.key);\n+        return this.key.hashCode();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89844088fe9693657a50ef71fed88155f029375e"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxMTMwNA==", "bodyText": "If it's idempotent perhaps it can be a try/with resource or just in a finally block.", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r441211304", "createdAt": "2020-06-17T00:18:43Z", "author": {"login": "tkaitchuck"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/ServerConnectionInboundHandler.java", "diffHunk": "@@ -53,7 +53,15 @@ public void channelRead(ChannelHandlerContext ctx, Object msg) {\n         if (requestProcessor == null) {\n             throw new IllegalStateException(\"No command processor set for connection\");\n         }\n-        cmd.process(requestProcessor);\n+        try {\n+            cmd.process(requestProcessor);\n+        } catch (Throwable ex) {\n+            // Release buffers in case of an unhandled exception.\n+            if (cmd instanceof WireCommands.ReleasableCommand) {\n+                ((WireCommands.ReleasableCommand) cmd).release(); // Idempotent. Invoking multiple times has no side effects.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89844088fe9693657a50ef71fed88155f029375e"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxMTgyNQ==", "bodyText": "Hashed array used to cache hashcodes. Is this significant?", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r441211825", "createdAt": "2020-06-17T00:20:32Z", "author": {"login": "tkaitchuck"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/tables/TableBucketReader.java", "diffHunk": "@@ -90,15 +89,14 @@\n      * will exclude all {@link ResultT} items that are marked as deleted.\n      */\n     CompletableFuture<List<ResultT>> findAllExisting(long bucketOffset, TimeoutTimer timer) {\n-        val result = new HashMap<HashedArray, ResultT>();\n+        val result = new HashMap<BufferView, ResultT>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89844088fe9693657a50ef71fed88155f029375e"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxMjk0OA==", "bodyText": "Should this be reverted?", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r441212948", "createdAt": "2020-06-17T00:24:51Z", "author": {"login": "tkaitchuck"}, "path": "segmentstore/server/src/test/java/io/pravega/segmentstore/server/tables/ContainerTableExtensionImplTests.java", "diffHunk": "@@ -90,7 +88,7 @@\n     private static final double REMOVE_FRACTION = 0.3; // 30% of generated operations are removes.\n     private static final int SHORT_TIMEOUT_MILLIS = 20; // To verify a get() is blocked.\n     private static final int DEFAULT_COMPACTION_SIZE = -1; // Inherits from parent.\n-    private static final Duration TIMEOUT = Duration.ofSeconds(30000);\n+    private static final Duration TIMEOUT = Duration.ofSeconds(3000000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89844088fe9693657a50ef71fed88155f029375e"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxNTIzMA==", "bodyText": "This code is unreachable. The readFully above will throw if it can't read dataLength. This was the intention of the if conditional before.", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r441215230", "createdAt": "2020-06-17T00:33:25Z", "author": {"login": "tkaitchuck"}, "path": "shared/protocol/src/main/java/io/pravega/shared/protocol/netty/WireCommands.java", "diffHunk": "@@ -1906,25 +1930,31 @@ public void writeFields(DataOutput out) throws IOException {\n             continuationToken.getBytes(continuationToken.readerIndex(), (OutputStream) out, continuationToken.readableBytes());\n         }\n \n-        public static WireCommand readFrom(ByteBufInputStream in, int length) throws IOException {\n+        public static WireCommand readFrom(EnhancedByteBufInputStream in, int length) throws IOException {\n+            final int initialAvailable = in.available();\n             long requestId = in.readLong();\n             String segment = in.readUTF();\n             int numberOfKeys = in.readInt();\n             List<TableKey> keys = new ArrayList<>(numberOfKeys);\n-            int keyByteCount = 0;\n             for (int i = 0; i < numberOfKeys; i++) {\n                 TableKey k = TableKey.readFrom(in, in.available());\n                 keys.add(k);\n-                keyByteCount += TableKey.HEADER_BYTES + Long.BYTES + k.getData().readableBytes();\n             }\n+\n             int dataLength = in.readInt();\n-            if (length < dataLength + Long.BYTES + segment.getBytes(UTF_8).length + Integer.BYTES + keyByteCount) {\n-                throw new InvalidMessageException(\"Was expecting length: \" + length + \" but found: \" + dataLength);\n-            }\n             byte[] continuationToken = new byte[dataLength];\n             in.readFully(continuationToken);\n \n-            return new TableKeysRead(requestId, segment, keys, wrappedBuffer(continuationToken));\n+            if (initialAvailable - in.available() < length) {\n+                throw new InvalidMessageException(\"Was expecting length \" + length + \" but read \" + (initialAvailable - in.available()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89844088fe9693657a50ef71fed88155f029375e"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxNTQ0MQ==", "bodyText": "same here", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r441215441", "createdAt": "2020-06-17T00:34:17Z", "author": {"login": "tkaitchuck"}, "path": "shared/protocol/src/main/java/io/pravega/shared/protocol/netty/WireCommands.java", "diffHunk": "@@ -2000,27 +2030,30 @@ public void writeFields(DataOutput out) throws IOException {\n             continuationToken.getBytes(continuationToken.readerIndex(), (OutputStream) out, continuationToken.readableBytes());\n         }\n \n-        public static WireCommand readFrom(ByteBufInputStream in, int length) throws IOException {\n+        public static WireCommand readFrom(EnhancedByteBufInputStream in, int length) throws IOException {\n+            final int initialAvailable = in.available();\n             long requestId = in.readLong();\n             String segment = in.readUTF();\n             TableEntries entries = TableEntries.readFrom(in, in.available());\n             int dataLength = in.readInt();\n-\n-            if (length < dataLength + Long.BYTES + segment.getBytes(UTF_8).length + entries.size() + Integer.BYTES ) {\n-                throw new InvalidMessageException(\"Was expecting length: \" + length + \" but found: \" + dataLength);\n-            }\n-\n             byte[] continuationToken = new byte[dataLength];\n             in.readFully(continuationToken);\n \n-            return new TableEntriesRead(requestId, segment, entries, wrappedBuffer(continuationToken));\n+            if (initialAvailable - in.available() < length) {\n+                throw new InvalidMessageException(\"Was expecting length \" + length + \" but read \" + (initialAvailable - in.available()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89844088fe9693657a50ef71fed88155f029375e"}, "originalPosition": 227}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxNTkzNw==", "bodyText": "HashedArray used to cache the hashCode. Please verify this is not a problem.", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r441215937", "createdAt": "2020-06-17T00:36:08Z", "author": {"login": "tkaitchuck"}, "path": "segmentstore/server/src/main/java/io/pravega/segmentstore/server/tables/BucketUpdate.java", "diffHunk": "@@ -92,8 +92,8 @@ boolean hasUpdates() {\n         @NonNull\n         @Getter\n         private final TableBucket bucket;\n-        private final Map<HashedArray, KeyInfo> existingKeys = new HashMap<>();\n-        private final Map<HashedArray, KeyUpdate> updatedKeys = new HashMap<>();\n+        private final Map<BufferView, KeyInfo> existingKeys = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89844088fe9693657a50ef71fed88155f029375e"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxNjUyMA==", "bodyText": "This is expected to be a smallish number of items so it should be OK.", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r441216520", "createdAt": "2020-06-17T00:38:29Z", "author": {"login": "tkaitchuck"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/PravegaRequestProcessor.java", "diffHunk": "@@ -314,15 +313,17 @@ private ReadResultEntry collectCachedEntries(long initialOffset, ReadResult read\n     /**\n      * Collect all the data from the given contents into a {@link ByteBuf}.\n      */\n-    private ByteBuf getData(List<BufferView> contents) {\n-        val compositeView = BufferView.wrap(contents);\n-        val rawBuffers = compositeView.getContents();\n-        val result = Unpooled.compositeBuffer(rawBuffers.size());\n-        for (ByteBuffer b : rawBuffers) {\n-            result.addComponent(Unpooled.wrappedBuffer(b));\n-        }\n+    private ByteBuf toByteBuf(List<BufferView> contents) {\n+        val buffers = contents.stream()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc2MTA1OQ=="}, "originalCommit": {"oid": "91e7ec130f098b2e2feef28916807da74b54ab36"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxNjg0Mg==", "bodyText": "Can you confirm we have test coverage validating there are no leaks on any of these paths?", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r441216842", "createdAt": "2020-06-17T00:39:48Z", "author": {"login": "tkaitchuck"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/PravegaRequestProcessor.java", "diffHunk": "@@ -691,21 +698,24 @@ public void readTable(final WireCommands.ReadTable readTable) {\n         final String operation = \"readTable\";\n \n         if (!verifyToken(segment, readTable.getRequestId(), readTable.getDelegationToken(), operation)) {\n+            readTable.release();\n             return;\n         }\n \n-        log.info(readTable.getRequestId(), \"Reading from table {}.\", readTable);\n+        log.debug(readTable.getRequestId(), \"Get Table Segment Keys: Segment={}, Count={}.\",\n+                readTable.getSegment(), readTable.getKeys());\n \n-        final List<ArrayView> keys = readTable.getKeys().stream()\n-                                              .map(k -> getArrayView(k.getData()))\n-                                              .collect(Collectors.toList());\n+        final List<BufferView> keys = readTable.getKeys().stream()\n+                .map(k -> new ByteBufWrapper(k.getData()))\n+                .collect(Collectors.toList());\n         val timer = new Timer();\n         tableStore.get(segment, keys, TIMEOUT)\n                 .thenAccept(values -> {\n                     connection.send(new WireCommands.TableRead(readTable.getRequestId(), segment, getTableEntriesCommand(keys, values)));\n                     this.tableStatsRecorder.getKeys(readTable.getSegment(), keys.size(), timer.getElapsed());\n                 })\n-                .exceptionally(e -> handleException(readTable.getRequestId(), segment, operation, e));\n+                .exceptionally(e -> handleException(readTable.getRequestId(), segment, operation, e))\n+                .whenComplete((r, ex) -> readTable.release());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "89844088fe9693657a50ef71fed88155f029375e"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxOTc5Mw==", "bodyText": "Notice below that if connection.send calls iterator or stream on keys in can trigger a race. See how Collections.synchronizedList is defined. (I know it's really a bad impl)\nI think there is a neater solution though. Let's modify collectRemaining to have the collector return a generic value. Which can be passed below. This will eliminate the need for the sync and avoid a race with iterator. The collectRemaining method is also currently implemented recursively, which can cause problems on JDK-8. I suggest we turn it into a loop while we are at it.", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r441219793", "createdAt": "2020-06-17T00:50:49Z", "author": {"login": "tkaitchuck"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/PravegaRequestProcessor.java", "diffHunk": "@@ -717,57 +727,49 @@ public void readTableKeys(WireCommands.ReadTableKeys readTableKeys) {\n             return;\n         }\n \n-        log.info(readTableKeys.getRequestId(), \"Fetching keys from {}.\", readTableKeys);\n+        log.debug(readTableKeys.getRequestId(), \"Iterate Table Segment Keys: Segment={}, Count={}.\",\n+                readTableKeys.getSegment(), readTableKeys.getSuggestedKeyCount());\n \n         int suggestedKeyCount = readTableKeys.getSuggestedKeyCount();\n         ByteBuf token = readTableKeys.getContinuationToken();\n \n-        byte[] state = null;\n+        BufferView state = null;\n         if (!token.equals(EMPTY_BUFFER)) {\n-            state = token.array();\n+            state = new ByteBufWrapper(token);\n         }\n \n-        final AtomicInteger msgSize = new AtomicInteger(0);\n-        final AtomicReference<ByteBuf> continuationToken = new AtomicReference<>(EMPTY_BUFFER);\n-        final List<TableKey> keys = new ArrayList<>();\n-\n+        val msgSize = new AtomicInteger(segment.getBytes().length + WireCommands.TableKeysRead.HEADER_BYTES);\n+        val continuationToken = new AtomicReference<>(EMPTY_BUFFER);\n+        val keys = new ArrayList<WireCommands.TableKey>();\n         val timer = new Timer();\n         tableStore.keyIterator(segment, state, TIMEOUT)\n-                  .thenCompose(itr -> itr.collectRemaining(\n-                          e -> {\n-                              synchronized (keys) {\n-                                  if (keys.size() < suggestedKeyCount && msgSize.get() < MAX_READ_SIZE) {\n-                                      Collection<TableKey> tableKeys = e.getEntries();\n-                                      ArrayView lastState = e.getState();\n-\n-                                      // Store all tableKeys.\n-                                      keys.addAll(tableKeys);\n-                                      // update the continuation token.\n-                                      continuationToken.set(wrappedBuffer(lastState.array(), lastState.arrayOffset(), lastState.getLength()));\n-                                      // Update msgSize.\n-                                      msgSize.addAndGet(getTableKeyBytes(segment, tableKeys, lastState.getLength()));\n-                                      return true;\n-                                  } else {\n-                                      return false;\n-                                  }\n-                              }\n-                          }))\n-                  .thenAccept(v -> {\n-                      final List<WireCommands.TableKey> wireCommandKeys;\n-                      synchronized (keys) {\n-                          log.debug(readTableKeys.getRequestId(), \"{} keys obtained for ReadTableKeys request.\", keys.size());\n-                          wireCommandKeys = keys.stream()\n-                                                .map(k -> {\n-                                                    ArrayView keyArray = k.getKey();\n-                                                    return new WireCommands.TableKey(wrappedBuffer(keyArray.array(),\n-                                                                                                   keyArray.arrayOffset(),\n-                                                                                                   keyArray.getLength()), k.getVersion());\n-                                                })\n-                                                .collect(toList());\n-                      }\n-                      connection.send(new WireCommands.TableKeysRead(readTableKeys.getRequestId(), segment, wireCommandKeys, continuationToken.get()));\n-                      this.tableStatsRecorder.iterateKeys(readTableKeys.getSegment(), keys.size(), timer.getElapsed());\n-                  }).exceptionally(e -> handleException(readTableKeys.getRequestId(), segment, operation, e));\n+                .thenCompose(itr -> itr.collectRemaining(\n+                        e -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc2MjY0MQ=="}, "originalCommit": {"oid": "91e7ec130f098b2e2feef28916807da74b54ab36"}, "originalPosition": 219}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIxOTk2Mw==", "bodyText": "See above", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r441219963", "createdAt": "2020-06-17T00:51:29Z", "author": {"login": "tkaitchuck"}, "path": "segmentstore/server/host/src/main/java/io/pravega/segmentstore/server/host/handler/PravegaRequestProcessor.java", "diffHunk": "@@ -779,115 +781,67 @@ public void readTableEntries(WireCommands.ReadTableEntries readTableEntries) {\n             return;\n         }\n \n-        log.info(readTableEntries.getRequestId(), \"Fetching keys from {}.\", readTableEntries);\n+        log.debug(readTableEntries.getRequestId(), \"Iterate Table Segment Entries: Segment={}, Count={}.\",\n+                readTableEntries.getSegment(), readTableEntries.getSuggestedEntryCount());\n \n         int suggestedEntryCount = readTableEntries.getSuggestedEntryCount();\n         ByteBuf token = readTableEntries.getContinuationToken();\n \n-        byte[] state = null;\n+        BufferView state = null;\n         if (!token.equals(EMPTY_BUFFER)) {\n-            state = token.array();\n+            state = new ByteBufWrapper(token);\n         }\n \n-        final AtomicInteger msgSize = new AtomicInteger(0);\n-        final AtomicReference<ByteBuf> continuationToken = new AtomicReference<>(EMPTY_BUFFER);\n-        final List<TableEntry> entries = new ArrayList<>();\n+        val msgSize = new AtomicInteger(segment.getBytes().length + WireCommands.TableEntriesRead.HEADER_BYTES);\n+        val continuationToken = new AtomicReference<>(EMPTY_BUFFER);\n+        val entries = new ArrayList<Map.Entry<WireCommands.TableKey, WireCommands.TableValue>>();\n         val timer = new Timer();\n         tableStore.entryIterator(segment, state, TIMEOUT)\n-                  .thenCompose(itr -> itr.collectRemaining(\n-                          e -> {\n-                              synchronized (entries) {\n-                                  if (entries.size() < suggestedEntryCount && msgSize.get() < MAX_READ_SIZE) {\n-                                      final Collection<TableEntry> tableEntries = e.getEntries();\n-                                      final ArrayView lastState = e.getState();\n-\n-                                      // Store all TableEntrys.\n-                                      entries.addAll(tableEntries);\n-                                      // Update the continuation token.\n-                                      continuationToken.set(wrappedBuffer(lastState.array(), lastState.arrayOffset(), lastState.getLength()));\n-                                      // Update message size.\n-                                      msgSize.addAndGet(getTableEntryBytes(segment, tableEntries, lastState.getLength()));\n-                                      return true;\n-                                  } else {\n-                                      return false;\n-                                  }\n-                              }\n-                          }))\n-                  .thenAccept(v -> {\n-                      final List<Map.Entry<WireCommands.TableKey, WireCommands.TableValue>> wireCommandEntries;\n-                      synchronized (entries) {\n-                          log.debug(readTableEntries.getRequestId(), \"{} entries obtained for ReadTableEntries request.\", entries.size());\n-                          wireCommandEntries = entries.stream()\n-                                                      .map(e -> {\n-                                                          TableKey k = e.getKey();\n-                                                          val keyWireCommand = new WireCommands.TableKey(wrappedBuffer(k.getKey().array(), k.getKey().arrayOffset(),\n-                                                                                                                       k.getKey().getLength()),\n-                                                                                                         k.getVersion());\n-                                                          ArrayView value = e.getValue();\n-                                                          val valueWireCommand = new WireCommands.TableValue(wrappedBuffer(value.array(), value.arrayOffset(),\n-                                                                                                                           value.getLength()));\n-                                                          return new AbstractMap.SimpleImmutableEntry<>(keyWireCommand, valueWireCommand);\n-                                                      })\n-                                                      .collect(toList());\n-                      }\n-\n-                      connection.send(new WireCommands.TableEntriesRead(readTableEntries.getRequestId(), segment,\n-                                                                        new WireCommands.TableEntries(wireCommandEntries),\n-                                                                        continuationToken.get()));\n-                      this.tableStatsRecorder.iterateEntries(readTableEntries.getSegment(), entries.size(), timer.getElapsed());\n-                  }).exceptionally(e -> handleException(readTableEntries.getRequestId(), segment, operation, e));\n-    }\n-\n-    private int getTableKeyBytes(String segment, Collection<TableKey> keys, int continuationTokenLength) {\n-        int headerLength = WireCommands.TableKeysRead.GET_HEADER_BYTES.apply(keys.size());\n-        int segmentLength = segment.getBytes().length;\n-        int dataLength = keys.stream().mapToInt(value -> value.getKey().getLength() + Long.BYTES).sum();\n-        return continuationTokenLength + headerLength + segmentLength + dataLength;\n-    }\n-\n-    private int getTableEntryBytes(String segment, Collection<TableEntry> items, int continuationTokenLength) {\n-        int headerLength = WireCommands.TableEntriesRead.GET_HEADER_BYTES.apply(items.size());\n-        int segmentLength = segment.getBytes().length;\n-        int dataLength = items.stream().mapToInt(value -> {\n-            return value.getKey().getKey().getLength() // key\n-                    + Long.BYTES // key version\n-                    + value.getValue().getLength(); // value\n-        }).sum();\n-        return headerLength + segmentLength + dataLength + continuationTokenLength;\n-    }\n-\n-    private ArrayView getArrayView(ByteBuf buf) {\n-        final int length = buf.readableBytes();\n-        if (buf.hasArray()) {\n-            return new ByteArraySegment(buf.array(), buf.readerIndex(), length);\n-        } else {\n-            byte[] bytes;\n-            bytes = new byte[length];\n-            buf.getBytes(buf.readerIndex(), bytes);\n-            return new ByteArraySegment(bytes, 0, length);\n-        }\n-    }\n+                .thenCompose(itr -> itr.collectRemaining(\n+                        e -> {\n+                            if (entries.size() >= suggestedEntryCount || msgSize.get() >= MAX_READ_SIZE) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc2MzMwNA=="}, "originalCommit": {"oid": "91e7ec130f098b2e2feef28916807da74b54ab36"}, "originalPosition": 349}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9e38f92bd42fc28fa3f55f8ee95ed807a553c14c", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/9e38f92bd42fc28fa3f55f8ee95ed807a553c14c", "committedDate": "2020-06-17T20:52:26Z", "message": "final class HashBuilder\nBufferView.collect -> bufferCollector.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b469bf8486a46ea82bd2036d38b11d6dfa3162bd", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/b469bf8486a46ea82bd2036d38b11d6dfa3162bd", "committedDate": "2020-06-17T21:05:51Z", "message": "BufferView.Reader.readByte returns byte.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b110b6ea39335efaadffdc123d03583523425403", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/b110b6ea39335efaadffdc123d03583523425403", "committedDate": "2020-06-17T22:34:20Z", "message": "Code review feedback.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ee5ce2c2f4bc963b1bdfe9c3210f5cd64bd4ad49", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/ee5ce2c2f4bc963b1bdfe9c3210f5cd64bd4ad49", "committedDate": "2020-06-18T19:58:01Z", "message": "Pushing down the implementation of readInt() and readLong() to actual classes.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjk1NjA0", "url": "https://github.com/pravega/pravega/pull/4842#pullrequestreview-433695604", "createdAt": "2020-06-18T22:45:18Z", "commit": {"oid": "ee5ce2c2f4bc963b1bdfe9c3210f5cd64bd4ad49"}, "state": "COMMENTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMjo0NToxOFrOGmCjfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMzozNjoxNVrOGmDdrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU0MDkyNw==", "bodyText": "If it really is only used for maps, then I could probably port aHash's fallback algorithm to Java. If this is a performance concern, we can open an issue on it.", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r442540927", "createdAt": "2020-06-18T22:45:18Z", "author": {"login": "tkaitchuck"}, "path": "common/src/main/java/io/pravega/common/util/AbstractBufferView.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.util;\n+\n+import com.google.common.base.Preconditions;\n+import io.pravega.common.hash.HashHelper;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.ByteBuffer;\n+import java.util.Collections;\n+import java.util.List;\n+import lombok.Getter;\n+import lombok.SneakyThrows;\n+\n+/**\n+ * Base implementation of {@link BufferView}, providing common functionality.\n+ * Derived classes may override these methods with more efficient implementations tailored to their data types.\n+ */\n+public abstract class AbstractBufferView implements BufferView {\n+    static final BufferView EMPTY = new EmptyBufferView();\n+    private static final HashHelper HASH = HashHelper.seededWith(AbstractBufferView.class.getName());\n+\n+    @Override\n+    public int hashCode() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE4MzMzMw=="}, "originalCommit": {"oid": "89844088fe9693657a50ef71fed88155f029375e"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU0Mjc1NQ==", "bodyText": "Here and on these other methods, it may be better the EOFException to be an Runtime, because as near as I can tell, the caller is expected to call available() and use conditions to avoid the exception. Perhaps IndexOutOfBoundsException ?", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r442542755", "createdAt": "2020-06-18T22:51:11Z", "author": {"login": "tkaitchuck"}, "path": "common/src/main/java/io/pravega/common/util/BufferView.java", "diffHunk": "@@ -173,23 +220,65 @@ static BufferView wrap(List<BufferView> components) {\n         int readBytes(ByteArraySegment segment);\n \n         /**\n-         * Reads all the remaining bytes from this {@link BufferView.Reader} into a new {@link ByteArraySegment}.\n+         * Reads one byte and advances the reader position by 1.\n+         *\n+         * @return The read byte.\n+         * @throws EOFException If {@link #available()} is 0.\n+         */\n+        byte readByte() throws EOFException;\n+\n+        /**\n+         * Reads 4 bytes (and advances the reader position by 4) and composes a 32-bit Integer (Big-Endian).\n+         *\n+         * @return The read int.\n+         * @throws EOFException If {@link #available()} is less than {@link Integer#BYTES}.\n+         */\n+        int readInt() throws EOFException;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee5ce2c2f4bc963b1bdfe9c3210f5cd64bd4ad49"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU0MzA4OA==", "bodyText": "I don't actually see anything throwing IOException below.", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r442543088", "createdAt": "2020-06-18T22:52:21Z", "author": {"login": "tkaitchuck"}, "path": "common/src/main/java/io/pravega/common/util/AbstractBufferView.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.util;\n+\n+import com.google.common.base.Preconditions;\n+import io.pravega.common.hash.HashHelper;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.ByteBuffer;\n+import java.util.Collections;\n+import java.util.List;\n+import lombok.Getter;\n+import lombok.SneakyThrows;\n+\n+/**\n+ * Base implementation of {@link BufferView}, providing common functionality.\n+ * Derived classes may override these methods with more efficient implementations tailored to their data types.\n+ */\n+public abstract class AbstractBufferView implements BufferView {\n+    static final BufferView EMPTY = new EmptyBufferView();\n+    private static final HashHelper HASH = HashHelper.seededWith(AbstractBufferView.class.getName());\n+\n+    @Override\n+    public int hashCode() {\n+        HashHelper.HashBuilder builder = HASH.newBuilder();\n+        collect(builder::put);\n+        return builder.getAsInt();\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj instanceof BufferView) {\n+            return equals((BufferView) obj);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Checks for equality against another {@link BufferView} instance.\n+     *\n+     * Note: this method provides a general implementation of equality. Derived classes should override this method with\n+     * more efficient implementations if available.\n+     *\n+     * @param other The other {@link BufferView} instance.\n+     * @return True if this instance and the other instance have the same contents.\n+     */\n+    @SneakyThrows(IOException.class)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee5ce2c2f4bc963b1bdfe9c3210f5cd64bd4ad49"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU0NTYwNQ==", "bodyText": "um, this assert it really obvious... (like just based on the if condition above)", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r442545605", "createdAt": "2020-06-18T23:00:52Z", "author": {"login": "tkaitchuck"}, "path": "common/src/main/java/io/pravega/common/util/CompositeBufferView.java", "diffHunk": "@@ -185,6 +201,69 @@ public int readBytes(ByteArraySegment segment) {\n             return 0;\n         }\n \n+        @Override\n+        public byte readByte() throws EOFException {\n+            BufferView.Reader current = getCurrent();\n+            if (current == null) {\n+                throw new EOFException();\n+            }\n+\n+            byte result = current.readByte();\n+            this.available--;\n+            assert this.available >= 0;\n+            return result;\n+        }\n+\n+        @Override\n+        public int readInt() throws EOFException {\n+            BufferView.Reader current = getCurrent();\n+            if (current != null && current.available() >= Integer.BYTES) {\n+                this.available -= Integer.BYTES;\n+                assert this.available >= 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee5ce2c2f4bc963b1bdfe9c3210f5cd64bd4ad49"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU0NTc4Ng==", "bodyText": "Should the readInt call go before the update to available?", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r442545786", "createdAt": "2020-06-18T23:01:32Z", "author": {"login": "tkaitchuck"}, "path": "common/src/main/java/io/pravega/common/util/CompositeBufferView.java", "diffHunk": "@@ -185,6 +201,69 @@ public int readBytes(ByteArraySegment segment) {\n             return 0;\n         }\n \n+        @Override\n+        public byte readByte() throws EOFException {\n+            BufferView.Reader current = getCurrent();\n+            if (current == null) {\n+                throw new EOFException();\n+            }\n+\n+            byte result = current.readByte();\n+            this.available--;\n+            assert this.available >= 0;\n+            return result;\n+        }\n+\n+        @Override\n+        public int readInt() throws EOFException {\n+            BufferView.Reader current = getCurrent();\n+            if (current != null && current.available() >= Integer.BYTES) {\n+                this.available -= Integer.BYTES;\n+                assert this.available >= 0;\n+                return current.readInt();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee5ce2c2f4bc963b1bdfe9c3210f5cd64bd4ad49"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU0NTk0OQ==", "bodyText": "Again: Order?", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r442545949", "createdAt": "2020-06-18T23:02:04Z", "author": {"login": "tkaitchuck"}, "path": "common/src/main/java/io/pravega/common/util/CompositeBufferView.java", "diffHunk": "@@ -185,6 +201,69 @@ public int readBytes(ByteArraySegment segment) {\n             return 0;\n         }\n \n+        @Override\n+        public byte readByte() throws EOFException {\n+            BufferView.Reader current = getCurrent();\n+            if (current == null) {\n+                throw new EOFException();\n+            }\n+\n+            byte result = current.readByte();\n+            this.available--;\n+            assert this.available >= 0;\n+            return result;\n+        }\n+\n+        @Override\n+        public int readInt() throws EOFException {\n+            BufferView.Reader current = getCurrent();\n+            if (current != null && current.available() >= Integer.BYTES) {\n+                this.available -= Integer.BYTES;\n+                assert this.available >= 0;\n+                return current.readInt();\n+            }\n+\n+            return super.readInt();\n+        }\n+\n+        @Override\n+        public long readLong() throws EOFException {\n+            BufferView.Reader current = getCurrent();\n+            if (current != null && current.available() >= Long.BYTES) {\n+                this.available -= Long.BYTES;\n+                assert this.available >= 0;\n+                return current.readLong();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee5ce2c2f4bc963b1bdfe9c3210f5cd64bd4ad49"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU0NjA0Nw==", "bodyText": "Ok.", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r442546047", "createdAt": "2020-06-18T23:02:22Z", "author": {"login": "tkaitchuck"}, "path": "common/src/main/java/io/pravega/common/util/CompositeBufferView.java", "diffHunk": "@@ -185,6 +201,45 @@ public int readBytes(ByteArraySegment segment) {\n             return 0;\n         }\n \n+        @Override\n+        public int readByte() throws EOFException {\n+            BufferView.Reader current = getCurrent();\n+            if (current == null) {\n+                throw new EOFException();\n+            }\n+\n+            int result = current.readByte();\n+            this.available--;\n+            assert this.available >= 0;\n+            return result;\n+        }\n+\n+        @Override\n+        public BufferView readSlice(final int length) throws EOFException {\n+            if (length > available()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIwOTQyNQ=="}, "originalCommit": {"oid": "89844088fe9693657a50ef71fed88155f029375e"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU1MjMyNQ==", "bodyText": "Arrays.equals does this (and takes offsets)", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r442552325", "createdAt": "2020-06-18T23:24:27Z", "author": {"login": "tkaitchuck"}, "path": "common/src/main/java/io/pravega/common/util/ByteArraySegment.java", "diffHunk": "@@ -169,6 +171,45 @@ public void copyTo(OutputStream stream) throws IOException {\n         stream.write(this.array, this.startOffset, this.length);\n     }\n \n+    @Override\n+    @SneakyThrows(IOException.class)\n+    public boolean equals(BufferView other) {\n+        if (this.length != other.getLength()) {\n+            return false;\n+        } else if (other instanceof ArrayView) {\n+            return equals((ArrayView) other);\n+        }\n+\n+        InputStream otherReader = other.getReader();\n+        for (int i = 0; i < this.length; i++) {\n+            if ((byte) otherReader.read() != this.array[this.startOffset + i]) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private boolean equals(ArrayView other) {\n+        if (this.length != other.getLength()) {\n+            return false;\n+        }\n+\n+        byte[] otherArray = other.array();\n+        int otherOffset = other.arrayOffset();\n+        for (int i = 0; i < this.length; i++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee5ce2c2f4bc963b1bdfe9c3210f5cd64bd4ad49"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU1MzUxNQ==", "bodyText": "Here and below, if at construction time we create a ByteBuffer view of the array this can be faster.", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r442553515", "createdAt": "2020-06-18T23:28:26Z", "author": {"login": "tkaitchuck"}, "path": "common/src/main/java/io/pravega/common/util/ByteArraySegment.java", "diffHunk": "@@ -291,6 +332,51 @@ public int readBytes(ByteArraySegment segment) {\n             this.position += len;\n             return len;\n         }\n+\n+        @Override\n+        public byte readByte() throws EOFException {\n+            if (position >= ByteArraySegment.this.length) {\n+                throw new EOFException();\n+            }\n+\n+            byte result = ByteArraySegment.this.array[ByteArraySegment.this.startOffset + this.position];\n+            this.position++;\n+            return result;\n+        }\n+\n+        @Override\n+        public int readInt() throws EOFException {\n+            int nextPos = this.position + Integer.BYTES;\n+            if (nextPos > ByteArraySegment.this.length) {\n+                throw new EOFException();\n+            }\n+            int r = BitConverter.readInt(ByteArraySegment.this.array, ByteArraySegment.this.startOffset + this.position);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee5ce2c2f4bc963b1bdfe9c3210f5cd64bd4ad49"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU1NTQyNQ==", "bodyText": "Perhaps there is another way to make this more efficient: Rather than having the impls try to specialize this we could have a protected abstract method for this class that returned: List<ByteBuffer which has the same bytes as what is inside the buffer view. Then that can be used to implement: (equals, hashcode, readInt, etc) in the generic logic here. I am not aware of anything which can't return that sort of view, but it's OK if we want to create an impl that can't, it just has to not extend the abstract class and implement the interface itself.", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r442555425", "createdAt": "2020-06-18T23:34:52Z", "author": {"login": "tkaitchuck"}, "path": "common/src/main/java/io/pravega/common/util/AbstractBufferView.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/**\n+ * Copyright (c) Dell Inc., or its subsidiaries. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ */\n+package io.pravega.common.util;\n+\n+import com.google.common.base.Preconditions;\n+import io.pravega.common.hash.HashHelper;\n+import java.io.EOFException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.ByteBuffer;\n+import java.util.Collections;\n+import java.util.List;\n+import lombok.Getter;\n+import lombok.SneakyThrows;\n+\n+/**\n+ * Base implementation of {@link BufferView}, providing common functionality.\n+ * Derived classes may override these methods with more efficient implementations tailored to their data types.\n+ */\n+public abstract class AbstractBufferView implements BufferView {\n+    static final BufferView EMPTY = new EmptyBufferView();\n+    private static final HashHelper HASH = HashHelper.seededWith(AbstractBufferView.class.getName());\n+\n+    @Override\n+    public int hashCode() {\n+        HashHelper.HashBuilder builder = HASH.newBuilder();\n+        collect(builder::put);\n+        return builder.getAsInt();\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (obj instanceof BufferView) {\n+            return equals((BufferView) obj);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Checks for equality against another {@link BufferView} instance.\n+     *\n+     * Note: this method provides a general implementation of equality. Derived classes should override this method with\n+     * more efficient implementations if available.\n+     *\n+     * @param other The other {@link BufferView} instance.\n+     * @return True if this instance and the other instance have the same contents.\n+     */\n+    @SneakyThrows(IOException.class)\n+    public boolean equals(BufferView other) {\n+        int l = getLength();\n+        if (l != other.getLength()) {\n+            return false;\n+        }\n+\n+        if (l > 0) {\n+            BufferView.Reader thisReader = getBufferViewReader();\n+            BufferView.Reader otherReader = other.getBufferViewReader();\n+            for (int i = 0; i < l; i++) {\n+                if (thisReader.readByte() != otherReader.readByte()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE4NDkzNQ=="}, "originalCommit": {"oid": "89844088fe9693657a50ef71fed88155f029375e"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU1NTgyMg==", "bodyText": "See my comment on AbstractBufferView, (I think we can eliminate the need for this)", "url": "https://github.com/pravega/pravega/pull/4842#discussion_r442555822", "createdAt": "2020-06-18T23:36:15Z", "author": {"login": "tkaitchuck"}, "path": "common/src/main/java/io/pravega/common/util/ByteArraySegment.java", "diffHunk": "@@ -169,6 +171,45 @@ public void copyTo(OutputStream stream) throws IOException {\n         stream.write(this.array, this.startOffset, this.length);\n     }\n \n+    @Override\n+    @SneakyThrows(IOException.class)\n+    public boolean equals(BufferView other) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee5ce2c2f4bc963b1bdfe9c3210f5cd64bd4ad49"}, "originalPosition": 27}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "86b977cba9cea85691a8c81bcf0760bd094a5e0d", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/86b977cba9cea85691a8c81bcf0760bd094a5e0d", "committedDate": "2020-06-19T15:22:52Z", "message": "BitConverter methods make use of makeInt/makeLong internally.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "71cf2854ddc86f7d398a9a5a7b39c9cb63696af8", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/71cf2854ddc86f7d398a9a5a7b39c9cb63696af8", "committedDate": "2020-06-19T15:53:07Z", "message": "BufferView.reader throws OutOfBoundsException.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0493807b8404bfb20d5ba1ba1073ba9c5250843c", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/0493807b8404bfb20d5ba1ba1073ba9c5250843c", "committedDate": "2020-06-22T15:21:46Z", "message": "Merge remote-tracking branch 'remotes/origin/master' into issue-4808-buffer-views"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bc063e92749e64d51a76ab427077dbe55442ab66", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/bc063e92749e64d51a76ab427077dbe55442ab66", "committedDate": "2020-06-22T17:25:13Z", "message": "Bringing back the synchronized block.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cd1901a8f4e7c370567d08717d39a66043a33ef1", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/cd1901a8f4e7c370567d08717d39a66043a33ef1", "committedDate": "2020-06-22T19:15:09Z", "message": "Sending over the wire outside of the lock.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cde2adb8b786edffe162dc3ce068662c0ec107cd", "author": {"user": {"login": "andreipaduroiu", "name": "Andrei Paduroiu"}}, "url": "https://github.com/pravega/pravega/commit/cde2adb8b786edffe162dc3ce068662c0ec107cd", "committedDate": "2020-06-22T20:26:48Z", "message": "Unified iterator collection into a single class.\n\nSigned-off-by: Andrei Paduroiu <andrei.paduroiu@emc.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM1MjYyMjQ0", "url": "https://github.com/pravega/pravega/pull/4842#pullrequestreview-435262244", "createdAt": "2020-06-22T20:48:06Z", "commit": {"oid": "cde2adb8b786edffe162dc3ce068662c0ec107cd"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3516, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}