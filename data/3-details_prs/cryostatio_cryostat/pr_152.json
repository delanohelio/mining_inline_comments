{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA3NTQ2MTQy", "number": 152, "title": "Replace Service discovery with Endpoint discovery", "bodyText": "Fixes #151", "createdAt": "2020-04-22T21:01:35Z", "url": "https://github.com/cryostatio/cryostat/pull/152", "merged": true, "mergeCommit": {"oid": "a28ae0173e195ffed5147fc3f5ed213b57c36069"}, "closed": true, "closedAt": "2020-04-23T13:43:04Z", "author": {"login": "andrewazores"}, "timelineItems": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcaMBgQgH2gAyNDA3NTQ2MTQyOjFmNmRjYWFjODNiOTAwY2I3Y2E0MTYxYWFlMjFjMjhhMDZhZTZkOGY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcaQCoUAFqTM5ODYzNDkxNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "1f6dcaac83b900cb7ca4161aae21c28a06ae6d8f", "author": {"user": {"login": "andrewazores", "name": "Andrew Azores"}}, "url": "https://github.com/cryostatio/cryostat/commit/1f6dcaac83b900cb7ca4161aae21c28a06ae6d8f", "committedDate": "2020-04-22T17:48:37Z", "message": "Replace Service discovery with Endpoint discovery\n\nUsing OpenShift Endpoints for discovery allows ContainerJFR to bypass\nService load-balancing, enabling connections directly to specific pod\nreplicas, rather than being load-balanced across replicas for the pod\nbacking the service\n\nFixes #151"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ca19b2ccf9375f64d5551b55342338c9442bf2aa", "author": {"user": {"login": "andrewazores", "name": "Andrew Azores"}}, "url": "https://github.com/cryostatio/cryostat/commit/ca19b2ccf9375f64d5551b55342338c9442bf2aa", "committedDate": "2020-04-22T21:02:16Z", "message": "Add OpenShiftPlatformClientTest"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a9b1a0c570e4c1f63cb0332901c5644e20720498", "author": {"user": {"login": "andrewazores", "name": "Andrew Azores"}}, "url": "https://github.com/cryostatio/cryostat/commit/a9b1a0c570e4c1f63cb0332901c5644e20720498", "committedDate": "2020-04-22T21:01:17Z", "message": "Add OpenShiftPlatformClientTest"}, "afterCommit": {"oid": "ca19b2ccf9375f64d5551b55342338c9442bf2aa", "author": {"user": {"login": "andrewazores", "name": "Andrew Azores"}}, "url": "https://github.com/cryostatio/cryostat/commit/ca19b2ccf9375f64d5551b55342338c9442bf2aa", "committedDate": "2020-04-22T21:02:16Z", "message": "Add OpenShiftPlatformClientTest"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4NjM0NDA1", "url": "https://github.com/cryostatio/cryostat/pull/152#pullrequestreview-398634405", "createdAt": "2020-04-22T22:28:15Z", "commit": {"oid": "ca19b2ccf9375f64d5551b55342338c9442bf2aa"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4NjM0OTE3", "url": "https://github.com/cryostatio/cryostat/pull/152#pullrequestreview-398634917", "createdAt": "2020-04-22T22:29:27Z", "commit": {"oid": "ca19b2ccf9375f64d5551b55342338c9442bf2aa"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMjoyOToyN1rOGKOexQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMjoyOToyN1rOGKOexQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM3NjE5Nw==", "bodyText": "Are these commented-out lines meant to be kept?", "url": "https://github.com/cryostatio/cryostat/pull/152#discussion_r413376197", "createdAt": "2020-04-22T22:29:27Z", "author": {"login": "ebaron"}, "path": "src/test/java/com/redhat/rhjmc/containerjfr/platform/openshift/OpenShiftPlatformClientTest.java", "diffHunk": "@@ -0,0 +1,159 @@\n+package com.redhat.rhjmc.containerjfr.platform.openshift;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.hamcrest.MatcherAssert;\n+import org.hamcrest.Matchers;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import com.redhat.rhjmc.containerjfr.core.log.Logger;\n+import com.redhat.rhjmc.containerjfr.core.sys.FileSystem;\n+import com.redhat.rhjmc.containerjfr.platform.ServiceRef;\n+\n+import io.fabric8.kubernetes.api.model.EndpointAddress;\n+import io.fabric8.kubernetes.api.model.EndpointPort;\n+import io.fabric8.kubernetes.api.model.EndpointSubset;\n+import io.fabric8.kubernetes.api.model.Endpoints;\n+import io.fabric8.kubernetes.api.model.EndpointsList;\n+import io.fabric8.kubernetes.api.model.ObjectReference;\n+import io.fabric8.kubernetes.client.dsl.MixedOperation;\n+import io.fabric8.kubernetes.client.dsl.NonNamespaceOperation;\n+import io.fabric8.openshift.client.OpenShiftClient;\n+\n+@ExtendWith(MockitoExtension.class)\n+class OpenShiftPlatformClientTest {\n+\n+    @Mock Logger logger;\n+    @Mock OpenShiftClient osClient;\n+    @Mock FileSystem fs;\n+    OpenShiftPlatformClient platformClient;\n+\n+    @BeforeEach\n+    void setup() {\n+        this.platformClient = new OpenShiftPlatformClient(logger, osClient, fs);\n+    }\n+\n+    @Test\n+    void shouldReturnEmptyListIfNoEndpointsFound() throws Exception {\n+        String namespace = \"foo-namespace\";\n+        setMockNamespace(namespace);\n+\n+        MixedOperation mockNamespaceOperation = Mockito.mock(MixedOperation.class);\n+        Mockito.when(osClient.endpoints()).thenReturn(mockNamespaceOperation);\n+\n+        ArgumentCaptor<String> namespaceCaptor = ArgumentCaptor.forClass(String.class);\n+        NonNamespaceOperation mockOperation = Mockito.mock(NonNamespaceOperation.class);\n+        Mockito.when(mockNamespaceOperation.inNamespace(namespaceCaptor.capture()))\n+                .thenReturn(mockOperation);\n+\n+        EndpointsList mockListable = Mockito.mock(EndpointsList.class);\n+        Mockito.when(mockOperation.list()).thenReturn(mockListable);\n+\n+        List<Endpoints> mockEndpoints = Collections.emptyList();\n+        Mockito.when(mockListable.getItems()).thenReturn(mockEndpoints);\n+\n+        List<ServiceRef> result = platformClient.listDiscoverableServices();\n+        MatcherAssert.assertThat(namespaceCaptor.getValue(), Matchers.equalTo(namespace));\n+        MatcherAssert.assertThat(result, Matchers.equalTo(Collections.emptyList()));\n+    }\n+\n+    @Test\n+    void shouldReturnListOfMatchingEndpointRefs() throws Exception {\n+        String namespace = \"foo-namespace\";\n+        setMockNamespace(namespace);\n+\n+        MixedOperation mockNamespaceOperation = Mockito.mock(MixedOperation.class);\n+        Mockito.when(osClient.endpoints()).thenReturn(mockNamespaceOperation);\n+\n+        ArgumentCaptor<String> namespaceCaptor = ArgumentCaptor.forClass(String.class);\n+        NonNamespaceOperation mockOperation = Mockito.mock(NonNamespaceOperation.class);\n+        Mockito.when(mockNamespaceOperation.inNamespace(namespaceCaptor.capture()))\n+                .thenReturn(mockOperation);\n+\n+        EndpointsList mockListable = Mockito.mock(EndpointsList.class);\n+        Mockito.when(mockOperation.list()).thenReturn(mockListable);\n+\n+        ObjectReference objRef1 = Mockito.mock(ObjectReference.class);\n+        // Mockito.when(objRef1.getName()).thenReturn(\"targetA\");\n+        ObjectReference objRef2 = Mockito.mock(ObjectReference.class);\n+        Mockito.when(objRef2.getName()).thenReturn(\"targetB\");\n+        ObjectReference objRef3 = Mockito.mock(ObjectReference.class);\n+        Mockito.when(objRef3.getName()).thenReturn(\"targetC\");\n+        ObjectReference objRef4 = Mockito.mock(ObjectReference.class);\n+        Mockito.when(objRef4.getName()).thenReturn(\"targetD\");\n+\n+        EndpointAddress address1 = Mockito.mock(EndpointAddress.class);\n+        // Mockito.when(address1.getIp()).thenReturn(\"127.0.0.1\");\n+        // Mockito.when(address1.getTargetRef()).thenReturn(objRef1);\n+        EndpointAddress address2 = Mockito.mock(EndpointAddress.class);\n+        Mockito.when(address2.getIp()).thenReturn(\"127.0.0.2\");\n+        Mockito.when(address2.getTargetRef()).thenReturn(objRef2);\n+        EndpointAddress address3 = Mockito.mock(EndpointAddress.class);\n+        Mockito.when(address3.getIp()).thenReturn(\"127.0.0.3\");\n+        Mockito.when(address3.getTargetRef()).thenReturn(objRef3);\n+        EndpointAddress address4 = Mockito.mock(EndpointAddress.class);\n+        Mockito.when(address4.getIp()).thenReturn(\"127.0.0.4\");\n+        Mockito.when(address4.getTargetRef()).thenReturn(objRef4);\n+\n+        EndpointPort port1 = Mockito.mock(EndpointPort.class);\n+        Mockito.when(port1.getPort()).thenReturn(80);\n+        Mockito.when(port1.getName()).thenReturn(\"tcp-80\");\n+        EndpointPort port2 = Mockito.mock(EndpointPort.class);\n+        Mockito.when(port2.getPort()).thenReturn(9999);\n+        Mockito.when(port2.getName()).thenReturn(\"jfr-jmx\");\n+        EndpointPort port3 = Mockito.mock(EndpointPort.class);\n+        Mockito.when(port3.getPort()).thenReturn(9091);\n+        Mockito.when(port3.getName()).thenReturn(\"tcp-9091\");\n+\n+        EndpointSubset subset1 = Mockito.mock(EndpointSubset.class);\n+        // Mockito.when(subset1.getAddresses()).thenReturn(Collections.singletonList(address1));\n+        Mockito.when(subset1.getPorts()).thenReturn(Collections.singletonList(port1));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca19b2ccf9375f64d5551b55342338c9442bf2aa"}, "originalPosition": 121}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3136, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}