{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIwMTI3MTM5", "number": 161, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQyMTowODo0OFrOD_EgOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQyMTowODo0OFrOD_EgOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NDYwNjY2OnYy", "diffSide": "RIGHT", "path": "src/main/java/com/redhat/rhjmc/containerjfr/net/TargetConnectionManager.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQyMTowODo0OFrOGZjqzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQxMzoyNDowNFrOGaBBZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ1MTk4MA==", "bodyText": "Is this new argument to connect methods a list of cleanup functions to invoke? I suppose there will be a corresponding container-jfr-core PR?", "url": "https://github.com/cryostatio/cryostat/pull/161#discussion_r429451980", "createdAt": "2020-05-22T21:08:48Z", "author": {"login": "ebaron"}, "path": "src/main/java/com/redhat/rhjmc/containerjfr/net/TargetConnectionManager.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*-\n+ * #%L\n+ * Container JFR\n+ * %%\n+ * Copyright (C) 2020 Red Hat, Inc.\n+ * %%\n+ * The Universal Permissive License (UPL), Version 1.0\n+ *\n+ * Subject to the condition set forth below, permission is hereby granted to any\n+ * person obtaining a copy of this software, associated documentation and/or data\n+ * (collectively the \"Software\"), free of charge and under any and all copyright\n+ * rights in the Software, and any and all patent rights owned or freely\n+ * licensable by each licensor hereunder covering either (i) the unmodified\n+ * Software as contributed to or provided by such licensor, or (ii) the Larger\n+ * Works (as defined below), to deal in both\n+ *\n+ * (a) the Software, and\n+ * (b) any piece of software and/or hardware listed in the lrgrwrks.txt file if\n+ * one is included with the Software (each a \"Larger Work\" to which the Software\n+ * is contributed by such licensors),\n+ *\n+ * without restriction, including without limitation the rights to copy, create\n+ * derivative works of, display, perform, and distribute the Software and make,\n+ * use, sell, offer for sale, import, export, have made, and have sold the\n+ * Software and the Larger Work(s), and to sublicense the foregoing rights on\n+ * either these or other terms.\n+ *\n+ * This license is subject to the following condition:\n+ * The above copyright notice and either this complete permission notice or at\n+ * a minimum a reference to the UPL must be included in all copies or\n+ * substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ * #L%\n+ */\n+package com.redhat.rhjmc.containerjfr.net;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.management.remote.JMXServiceURL;\n+\n+import com.redhat.rhjmc.containerjfr.core.log.Logger;\n+import com.redhat.rhjmc.containerjfr.core.net.JFRConnection;\n+import com.redhat.rhjmc.containerjfr.core.net.JFRConnectionToolkit;\n+\n+public class TargetConnectionManager {\n+\n+    public static final Pattern HOST_PORT_PAIR_PATTERN =\n+            Pattern.compile(\"^([^:\\\\s]+)(?::(\\\\d{1,5}))?$\");\n+\n+    private final Logger logger;\n+    // FIXME verify concurrent connection safety and remove locking\n+    private final ReentrantLock lock = new ReentrantLock();\n+    // maintain a short-lived cache of connections to allow nested ConnectedTasks\n+    // without having to manage connection reuse\n+    private final Map<String, JFRConnection> activeConnections = new HashMap<>();\n+    private final JFRConnectionToolkit jfrConnectionToolkit;\n+\n+    TargetConnectionManager(Logger logger, JFRConnectionToolkit jfrConnectionToolkit) {\n+        this.logger = logger;\n+        this.jfrConnectionToolkit = jfrConnectionToolkit;\n+    }\n+\n+    public <T> T executeConnectedTask(String targetId, ConnectedTask<T> task) throws Exception {\n+        try {\n+            if (activeConnections.containsKey(targetId)) {\n+                return task.execute(activeConnections.get(targetId));\n+            } else {\n+                try (JFRConnection connection = connect(targetId)) {\n+                    activeConnections.put(targetId, connection);\n+                    return task.execute(connection);\n+                }\n+            }\n+        } finally {\n+            activeConnections.remove(targetId);\n+        }\n+    }\n+\n+    /**\n+     * Returns a new JFRConnection to the specified Target. This does not do any connection reuse or\n+     * other management, so clients are responsible for cleaning up the connection when they are\n+     * finished with it. When possible, clients should use executeConnectedTask instead, which does\n+     * perform automatic cleanup when the provided task has been completed.\n+     */\n+    public JFRConnection connect(String targetId) throws Exception {\n+        try {\n+            return attemptConnectAsJMXServiceURL(targetId);\n+        } catch (Exception e) {\n+            return attemptConnectAsHostPortPair(targetId);\n+        }\n+    }\n+\n+    private JFRConnection attemptConnectAsJMXServiceURL(String url) throws Exception {\n+        return connect(new JMXServiceURL(url));\n+    }\n+\n+    private JFRConnection attemptConnectAsHostPortPair(String s) throws Exception {\n+        Matcher m = HOST_PORT_PAIR_PATTERN.matcher(s);\n+        if (!m.find()) {\n+            return null;\n+        }\n+        String host = m.group(1);\n+        String port = m.group(2);\n+        if (port == null) {\n+            port = \"9091\";\n+        }\n+        return connect(host, Integer.parseInt(port));\n+    }\n+\n+    private JFRConnection connect(JMXServiceURL url) throws Exception {\n+        logger.trace(String.format(\"Locking connection %s\", url.toString()));\n+        lock.lockInterruptibly();\n+        return jfrConnectionToolkit.connect(\n+                url,\n+                List.of(\n+                        lock::unlock,\n+                        () ->\n+                                logger.trace(\n+                                        String.format(\"Unlocking connection %s\", url.toString()))));\n+    }\n+\n+    private JFRConnection connect(String host, int port) throws Exception {\n+        logger.trace(String.format(\"Locking connection %s:%d\", host, port));\n+        lock.lockInterruptibly();\n+        return jfrConnectionToolkit.connect(\n+                host,\n+                port,\n+                List.of(\n+                        lock::unlock,\n+                        () ->\n+                                logger.trace(\n+                                        String.format(\"Unlocking connection %s:%d\", host, port))));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2d6d5349cde92efa794ad5b0e0d0e14ebe7ca90"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ4ODg4MQ==", "bodyText": "Yes exactly, it's a list of functions to be invoked when the underlying connection is closed. I already went ahead and pushed these additions in container-jfr-core (v0.12.x), since they were relatively trivial - the actual connection close detection and cleanup handling is done by the JMC classes we're using behind the scenes, but -core used to just pass in an empty list of cleanup functions every time.", "url": "https://github.com/cryostatio/cryostat/pull/161#discussion_r429488881", "createdAt": "2020-05-22T23:32:05Z", "author": {"login": "andrewazores"}, "path": "src/main/java/com/redhat/rhjmc/containerjfr/net/TargetConnectionManager.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*-\n+ * #%L\n+ * Container JFR\n+ * %%\n+ * Copyright (C) 2020 Red Hat, Inc.\n+ * %%\n+ * The Universal Permissive License (UPL), Version 1.0\n+ *\n+ * Subject to the condition set forth below, permission is hereby granted to any\n+ * person obtaining a copy of this software, associated documentation and/or data\n+ * (collectively the \"Software\"), free of charge and under any and all copyright\n+ * rights in the Software, and any and all patent rights owned or freely\n+ * licensable by each licensor hereunder covering either (i) the unmodified\n+ * Software as contributed to or provided by such licensor, or (ii) the Larger\n+ * Works (as defined below), to deal in both\n+ *\n+ * (a) the Software, and\n+ * (b) any piece of software and/or hardware listed in the lrgrwrks.txt file if\n+ * one is included with the Software (each a \"Larger Work\" to which the Software\n+ * is contributed by such licensors),\n+ *\n+ * without restriction, including without limitation the rights to copy, create\n+ * derivative works of, display, perform, and distribute the Software and make,\n+ * use, sell, offer for sale, import, export, have made, and have sold the\n+ * Software and the Larger Work(s), and to sublicense the foregoing rights on\n+ * either these or other terms.\n+ *\n+ * This license is subject to the following condition:\n+ * The above copyright notice and either this complete permission notice or at\n+ * a minimum a reference to the UPL must be included in all copies or\n+ * substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ * #L%\n+ */\n+package com.redhat.rhjmc.containerjfr.net;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.management.remote.JMXServiceURL;\n+\n+import com.redhat.rhjmc.containerjfr.core.log.Logger;\n+import com.redhat.rhjmc.containerjfr.core.net.JFRConnection;\n+import com.redhat.rhjmc.containerjfr.core.net.JFRConnectionToolkit;\n+\n+public class TargetConnectionManager {\n+\n+    public static final Pattern HOST_PORT_PAIR_PATTERN =\n+            Pattern.compile(\"^([^:\\\\s]+)(?::(\\\\d{1,5}))?$\");\n+\n+    private final Logger logger;\n+    // FIXME verify concurrent connection safety and remove locking\n+    private final ReentrantLock lock = new ReentrantLock();\n+    // maintain a short-lived cache of connections to allow nested ConnectedTasks\n+    // without having to manage connection reuse\n+    private final Map<String, JFRConnection> activeConnections = new HashMap<>();\n+    private final JFRConnectionToolkit jfrConnectionToolkit;\n+\n+    TargetConnectionManager(Logger logger, JFRConnectionToolkit jfrConnectionToolkit) {\n+        this.logger = logger;\n+        this.jfrConnectionToolkit = jfrConnectionToolkit;\n+    }\n+\n+    public <T> T executeConnectedTask(String targetId, ConnectedTask<T> task) throws Exception {\n+        try {\n+            if (activeConnections.containsKey(targetId)) {\n+                return task.execute(activeConnections.get(targetId));\n+            } else {\n+                try (JFRConnection connection = connect(targetId)) {\n+                    activeConnections.put(targetId, connection);\n+                    return task.execute(connection);\n+                }\n+            }\n+        } finally {\n+            activeConnections.remove(targetId);\n+        }\n+    }\n+\n+    /**\n+     * Returns a new JFRConnection to the specified Target. This does not do any connection reuse or\n+     * other management, so clients are responsible for cleaning up the connection when they are\n+     * finished with it. When possible, clients should use executeConnectedTask instead, which does\n+     * perform automatic cleanup when the provided task has been completed.\n+     */\n+    public JFRConnection connect(String targetId) throws Exception {\n+        try {\n+            return attemptConnectAsJMXServiceURL(targetId);\n+        } catch (Exception e) {\n+            return attemptConnectAsHostPortPair(targetId);\n+        }\n+    }\n+\n+    private JFRConnection attemptConnectAsJMXServiceURL(String url) throws Exception {\n+        return connect(new JMXServiceURL(url));\n+    }\n+\n+    private JFRConnection attemptConnectAsHostPortPair(String s) throws Exception {\n+        Matcher m = HOST_PORT_PAIR_PATTERN.matcher(s);\n+        if (!m.find()) {\n+            return null;\n+        }\n+        String host = m.group(1);\n+        String port = m.group(2);\n+        if (port == null) {\n+            port = \"9091\";\n+        }\n+        return connect(host, Integer.parseInt(port));\n+    }\n+\n+    private JFRConnection connect(JMXServiceURL url) throws Exception {\n+        logger.trace(String.format(\"Locking connection %s\", url.toString()));\n+        lock.lockInterruptibly();\n+        return jfrConnectionToolkit.connect(\n+                url,\n+                List.of(\n+                        lock::unlock,\n+                        () ->\n+                                logger.trace(\n+                                        String.format(\"Unlocking connection %s\", url.toString()))));\n+    }\n+\n+    private JFRConnection connect(String host, int port) throws Exception {\n+        logger.trace(String.format(\"Locking connection %s:%d\", host, port));\n+        lock.lockInterruptibly();\n+        return jfrConnectionToolkit.connect(\n+                host,\n+                port,\n+                List.of(\n+                        lock::unlock,\n+                        () ->\n+                                logger.trace(\n+                                        String.format(\"Unlocking connection %s:%d\", host, port))));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ1MTk4MA=="}, "originalCommit": {"oid": "d2d6d5349cde92efa794ad5b0e0d0e14ebe7ca90"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTkzMjkwMA==", "bodyText": "Oh cool, thanks for the explanation. I was looking in master for the changes, I see them now in 0.12.3.", "url": "https://github.com/cryostatio/cryostat/pull/161#discussion_r429932900", "createdAt": "2020-05-25T13:24:04Z", "author": {"login": "ebaron"}, "path": "src/main/java/com/redhat/rhjmc/containerjfr/net/TargetConnectionManager.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*-\n+ * #%L\n+ * Container JFR\n+ * %%\n+ * Copyright (C) 2020 Red Hat, Inc.\n+ * %%\n+ * The Universal Permissive License (UPL), Version 1.0\n+ *\n+ * Subject to the condition set forth below, permission is hereby granted to any\n+ * person obtaining a copy of this software, associated documentation and/or data\n+ * (collectively the \"Software\"), free of charge and under any and all copyright\n+ * rights in the Software, and any and all patent rights owned or freely\n+ * licensable by each licensor hereunder covering either (i) the unmodified\n+ * Software as contributed to or provided by such licensor, or (ii) the Larger\n+ * Works (as defined below), to deal in both\n+ *\n+ * (a) the Software, and\n+ * (b) any piece of software and/or hardware listed in the lrgrwrks.txt file if\n+ * one is included with the Software (each a \"Larger Work\" to which the Software\n+ * is contributed by such licensors),\n+ *\n+ * without restriction, including without limitation the rights to copy, create\n+ * derivative works of, display, perform, and distribute the Software and make,\n+ * use, sell, offer for sale, import, export, have made, and have sold the\n+ * Software and the Larger Work(s), and to sublicense the foregoing rights on\n+ * either these or other terms.\n+ *\n+ * This license is subject to the following condition:\n+ * The above copyright notice and either this complete permission notice or at\n+ * a minimum a reference to the UPL must be included in all copies or\n+ * substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ * #L%\n+ */\n+package com.redhat.rhjmc.containerjfr.net;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import javax.management.remote.JMXServiceURL;\n+\n+import com.redhat.rhjmc.containerjfr.core.log.Logger;\n+import com.redhat.rhjmc.containerjfr.core.net.JFRConnection;\n+import com.redhat.rhjmc.containerjfr.core.net.JFRConnectionToolkit;\n+\n+public class TargetConnectionManager {\n+\n+    public static final Pattern HOST_PORT_PAIR_PATTERN =\n+            Pattern.compile(\"^([^:\\\\s]+)(?::(\\\\d{1,5}))?$\");\n+\n+    private final Logger logger;\n+    // FIXME verify concurrent connection safety and remove locking\n+    private final ReentrantLock lock = new ReentrantLock();\n+    // maintain a short-lived cache of connections to allow nested ConnectedTasks\n+    // without having to manage connection reuse\n+    private final Map<String, JFRConnection> activeConnections = new HashMap<>();\n+    private final JFRConnectionToolkit jfrConnectionToolkit;\n+\n+    TargetConnectionManager(Logger logger, JFRConnectionToolkit jfrConnectionToolkit) {\n+        this.logger = logger;\n+        this.jfrConnectionToolkit = jfrConnectionToolkit;\n+    }\n+\n+    public <T> T executeConnectedTask(String targetId, ConnectedTask<T> task) throws Exception {\n+        try {\n+            if (activeConnections.containsKey(targetId)) {\n+                return task.execute(activeConnections.get(targetId));\n+            } else {\n+                try (JFRConnection connection = connect(targetId)) {\n+                    activeConnections.put(targetId, connection);\n+                    return task.execute(connection);\n+                }\n+            }\n+        } finally {\n+            activeConnections.remove(targetId);\n+        }\n+    }\n+\n+    /**\n+     * Returns a new JFRConnection to the specified Target. This does not do any connection reuse or\n+     * other management, so clients are responsible for cleaning up the connection when they are\n+     * finished with it. When possible, clients should use executeConnectedTask instead, which does\n+     * perform automatic cleanup when the provided task has been completed.\n+     */\n+    public JFRConnection connect(String targetId) throws Exception {\n+        try {\n+            return attemptConnectAsJMXServiceURL(targetId);\n+        } catch (Exception e) {\n+            return attemptConnectAsHostPortPair(targetId);\n+        }\n+    }\n+\n+    private JFRConnection attemptConnectAsJMXServiceURL(String url) throws Exception {\n+        return connect(new JMXServiceURL(url));\n+    }\n+\n+    private JFRConnection attemptConnectAsHostPortPair(String s) throws Exception {\n+        Matcher m = HOST_PORT_PAIR_PATTERN.matcher(s);\n+        if (!m.find()) {\n+            return null;\n+        }\n+        String host = m.group(1);\n+        String port = m.group(2);\n+        if (port == null) {\n+            port = \"9091\";\n+        }\n+        return connect(host, Integer.parseInt(port));\n+    }\n+\n+    private JFRConnection connect(JMXServiceURL url) throws Exception {\n+        logger.trace(String.format(\"Locking connection %s\", url.toString()));\n+        lock.lockInterruptibly();\n+        return jfrConnectionToolkit.connect(\n+                url,\n+                List.of(\n+                        lock::unlock,\n+                        () ->\n+                                logger.trace(\n+                                        String.format(\"Unlocking connection %s\", url.toString()))));\n+    }\n+\n+    private JFRConnection connect(String host, int port) throws Exception {\n+        logger.trace(String.format(\"Locking connection %s:%d\", host, port));\n+        lock.lockInterruptibly();\n+        return jfrConnectionToolkit.connect(\n+                host,\n+                port,\n+                List.of(\n+                        lock::unlock,\n+                        () ->\n+                                logger.trace(\n+                                        String.format(\"Unlocking connection %s:%d\", host, port))));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ1MTk4MA=="}, "originalCommit": {"oid": "d2d6d5349cde92efa794ad5b0e0d0e14ebe7ca90"}, "originalPosition": 143}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 821, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}