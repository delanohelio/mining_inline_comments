{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkwNTY3NjE1", "number": 140, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxODo0Mjo0NlrODpPEXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxNToyNjoxNFrODsHS_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0NTY1MDg1OnYy", "diffSide": "RIGHT", "path": "pom.xml", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxODo0Mjo0NlrOF4SS4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxODo1NjoxNVrOF4SwWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU2NDMyMQ==", "bodyText": "This is from jmc -> jmc-core right? (Edit: Just checking because) I think there are some comments in code below for container-jfr -> container-jfr-core.", "url": "https://github.com/cryostatio/cryostat/pull/140#discussion_r394564321", "createdAt": "2020-03-18T18:42:46Z", "author": {"login": "jiekang"}, "path": "pom.xml", "diffHunk": "@@ -66,6 +65,18 @@\n     <artifactId>containerjfr-core</artifactId>\n     <version>${com.redhat.rhjmc.containerjfr.core.version}</version>\n   </dependency>\n+  <!-- TODO move this into -core -->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3e4cbde0a04fe27b02f6243cac1800d44cb98ee"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU2NTc5OA==", "bodyText": "Well, both. container-jfr shouldn't have any JMC dependencies, they should all be abstracted away into container-jfr-core. But also, a lot of those JMC dependencies are still \"internal\" JMC artifacts, and should be moved into jmc-core so that they can be properly published and consumed by other projects.", "url": "https://github.com/cryostatio/cryostat/pull/140#discussion_r394565798", "createdAt": "2020-03-18T18:45:22Z", "author": {"login": "andrewazores"}, "path": "pom.xml", "diffHunk": "@@ -66,6 +65,18 @@\n     <artifactId>containerjfr-core</artifactId>\n     <version>${com.redhat.rhjmc.containerjfr.core.version}</version>\n   </dependency>\n+  <!-- TODO move this into -core -->", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU2NDMyMQ=="}, "originalCommit": {"oid": "a3e4cbde0a04fe27b02f6243cac1800d44cb98ee"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU3MTg2NQ==", "bodyText": "Ah right you are. Thanks!", "url": "https://github.com/cryostatio/cryostat/pull/140#discussion_r394571865", "createdAt": "2020-03-18T18:56:15Z", "author": {"login": "jiekang"}, "path": "pom.xml", "diffHunk": "@@ -66,6 +65,18 @@\n     <artifactId>containerjfr-core</artifactId>\n     <version>${com.redhat.rhjmc.containerjfr.core.version}</version>\n   </dependency>\n+  <!-- TODO move this into -core -->", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU2NDMyMQ=="}, "originalCommit": {"oid": "a3e4cbde0a04fe27b02f6243cac1800d44cb98ee"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0NTY3NTYzOnYy", "diffSide": "RIGHT", "path": "src/main/java/org/openjdk/jmc/ui/UIPlugin.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQxODo0OTo1MFrOF4SitQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQyMDoxMTo1OVrOF4VKrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU2ODM3Mw==", "bodyText": "@jiekang here's a good RFE for JMC - the JFCXMLValidator currently imports this UIPlugin class from another artifact, which is a subclass of an Eclipse AbstractUIPlugin class. So those UIPlugin classes are actually somehow related to the rendered application components and widgets, but clearly the XML Validator and the rest of the XML processing stuff I'm using here are not. And yet, the JMC code pathway for processing XML calls into UI components simply for the purpose of reusing their static logger instance...\nA fix for this is probably going to take a while to make it into a snapshot release version so I'll have to rely on this hack for a while, but if any portion of this XML stuff can be cleaned up and moved into jmc-core, then it would be really nice and useful for us to use here in container-jfr(-core).", "url": "https://github.com/cryostatio/cryostat/pull/140#discussion_r394568373", "createdAt": "2020-03-18T18:49:50Z", "author": {"login": "andrewazores"}, "path": "src/main/java/org/openjdk/jmc/ui/UIPlugin.java", "diffHunk": "@@ -0,0 +1,18 @@\n+package org.openjdk.jmc.ui;\n+\n+import java.util.logging.Logger;\n+\n+/**\n+ * TODO move this stub into -core This is only used for stubbing out a Logger instance used by JMC's\n+ * JFCXMLValidator !!! This is a major classloading hackaround !!!\n+ */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a3e4cbde0a04fe27b02f6243cac1800d44cb98ee"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU3MjUxNQ==", "bodyText": "Uh wow okay, that's quite a curiosity. This sounds like something warranting an issue opened in JMC Jira. If you agree I can write one up.", "url": "https://github.com/cryostatio/cryostat/pull/140#discussion_r394572515", "createdAt": "2020-03-18T18:57:20Z", "author": {"login": "jiekang"}, "path": "src/main/java/org/openjdk/jmc/ui/UIPlugin.java", "diffHunk": "@@ -0,0 +1,18 @@\n+package org.openjdk.jmc.ui;\n+\n+import java.util.logging.Logger;\n+\n+/**\n+ * TODO move this stub into -core This is only used for stubbing out a Logger instance used by JMC's\n+ * JFCXMLValidator !!! This is a major classloading hackaround !!!\n+ */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU2ODM3Mw=="}, "originalCommit": {"oid": "a3e4cbde0a04fe27b02f6243cac1800d44cb98ee"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU4NjY2NQ==", "bodyText": "Yea, I would agree with that. The XML stuff does currently live within a ui maven module, although within a model package, so that part makes sense. But IMO it's definitely wrong for a model to be using a view or controller's logger.", "url": "https://github.com/cryostatio/cryostat/pull/140#discussion_r394586665", "createdAt": "2020-03-18T19:23:56Z", "author": {"login": "andrewazores"}, "path": "src/main/java/org/openjdk/jmc/ui/UIPlugin.java", "diffHunk": "@@ -0,0 +1,18 @@\n+package org.openjdk.jmc.ui;\n+\n+import java.util.logging.Logger;\n+\n+/**\n+ * TODO move this stub into -core This is only used for stubbing out a Logger instance used by JMC's\n+ * JFCXMLValidator !!! This is a major classloading hackaround !!!\n+ */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU2ODM3Mw=="}, "originalCommit": {"oid": "a3e4cbde0a04fe27b02f6243cac1800d44cb98ee"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU4NzU3MA==", "bodyText": "And it's even worse than that really, because it isn't even the specific parent controller instance's logger or something - it's just a general static one on a class named UIPlugin...", "url": "https://github.com/cryostatio/cryostat/pull/140#discussion_r394587570", "createdAt": "2020-03-18T19:25:37Z", "author": {"login": "andrewazores"}, "path": "src/main/java/org/openjdk/jmc/ui/UIPlugin.java", "diffHunk": "@@ -0,0 +1,18 @@\n+package org.openjdk.jmc.ui;\n+\n+import java.util.logging.Logger;\n+\n+/**\n+ * TODO move this stub into -core This is only used for stubbing out a Logger instance used by JMC's\n+ * JFCXMLValidator !!! This is a major classloading hackaround !!!\n+ */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU2ODM3Mw=="}, "originalCommit": {"oid": "a3e4cbde0a04fe27b02f6243cac1800d44cb98ee"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDYwMzEzMw==", "bodyText": "I think I can work around this in a slightly less ugly way by using reflection to make some constructors visible and then not use the JFCXMLValidator at all. This would let us use JMC's XML parsing, which is nice, but JFC validation would be great to retain - especially when I get to #143 and users can upload their own .jfc files for defining new templates.\nMaybe I can do those reflection tricks plus implement a JFC validator based on the JMC one that doesn't call out to a UIPlugin logger and pass that in rather than allowing the JMC classes to default to their own validator.", "url": "https://github.com/cryostatio/cryostat/pull/140#discussion_r394603133", "createdAt": "2020-03-18T19:55:43Z", "author": {"login": "andrewazores"}, "path": "src/main/java/org/openjdk/jmc/ui/UIPlugin.java", "diffHunk": "@@ -0,0 +1,18 @@\n+package org.openjdk.jmc.ui;\n+\n+import java.util.logging.Logger;\n+\n+/**\n+ * TODO move this stub into -core This is only used for stubbing out a Logger instance used by JMC's\n+ * JFCXMLValidator !!! This is a major classloading hackaround !!!\n+ */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU2ODM3Mw=="}, "originalCommit": {"oid": "a3e4cbde0a04fe27b02f6243cac1800d44cb98ee"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDYxMTM3Mg==", "bodyText": "Nevermind - the IXMLValidator interface I'd need to implement is package-private, so making my own implementation doesn't really work. And the JFCXMLValidator class implementation is final. Well then.", "url": "https://github.com/cryostatio/cryostat/pull/140#discussion_r394611372", "createdAt": "2020-03-18T20:11:59Z", "author": {"login": "andrewazores"}, "path": "src/main/java/org/openjdk/jmc/ui/UIPlugin.java", "diffHunk": "@@ -0,0 +1,18 @@\n+package org.openjdk.jmc.ui;\n+\n+import java.util.logging.Logger;\n+\n+/**\n+ * TODO move this stub into -core This is only used for stubbing out a Logger instance used by JMC's\n+ * JFCXMLValidator !!! This is a major classloading hackaround !!!\n+ */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDU2ODM3Mw=="}, "originalCommit": {"oid": "a3e4cbde0a04fe27b02f6243cac1800d44cb98ee"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3MjkzODMwOnYy", "diffSide": "RIGHT", "path": "src/main/java/com/redhat/rhjmc/containerjfr/commands/internal/AbstractRecordingCommand.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQyMToxNzozN1rOF8a1Eg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQyMToxNzozN1rOF8a1Eg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODg5ODQ1MA==", "bodyText": "Heh, I'd replace may be expensive with \"will be very expensive\" :P", "url": "https://github.com/cryostatio/cryostat/pull/140#discussion_r398898450", "createdAt": "2020-03-26T21:17:37Z", "author": {"login": "jiekang"}, "path": "src/main/java/com/redhat/rhjmc/containerjfr/commands/internal/AbstractRecordingCommand.java", "diffHunk": "@@ -7,11 +7,18 @@\n import org.openjdk.jmc.flightrecorder.configuration.events.EventOptionID;\n import org.openjdk.jmc.rjmx.services.jfr.IEventTypeInfo;\n \n+import com.redhat.rhjmc.containerjfr.core.templates.Template;\n import com.redhat.rhjmc.containerjfr.core.tui.ClientWriter;\n \n abstract class AbstractRecordingCommand extends AbstractConnectedCommand {\n \n-    private static final Pattern ALL_EVENTS_PATTERN = Pattern.compile(\"^ALL$\", Pattern.MULTILINE);\n+    static final Template ALL_EVENTS_TEMPLATE =\n+            new Template(\n+                    \"ALL\",\n+                    \"Enable all available events in the target JVM, with default option values. This may be expensive and is intended primarily for testing ContainerJFR's own capabilities.\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f9da1061643e1acf8384c27530e42ed1053ff781"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3NTgzNDg1OnYy", "diffSide": "RIGHT", "path": "src/test/java/com/redhat/rhjmc/containerjfr/commands/internal/ListEventTemplatesCommandTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxNToyNjoxNFrOF82LUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxNToyNjoxNFrOF82LUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTM0NjUxMg==", "bodyText": "Does this string need changing also?", "url": "https://github.com/cryostatio/cryostat/pull/140#discussion_r399346512", "createdAt": "2020-03-27T15:26:14Z", "author": {"login": "jiekang"}, "path": "src/test/java/com/redhat/rhjmc/containerjfr/commands/internal/ListEventTemplatesCommandTest.java", "diffHunk": "@@ -0,0 +1,97 @@\n+package com.redhat.rhjmc.containerjfr.commands.internal;\n+\n+import java.util.List;\n+\n+import org.hamcrest.MatcherAssert;\n+import org.hamcrest.Matchers;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+import org.mockito.InOrder;\n+import org.mockito.Mock;\n+import org.mockito.Mockito;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import com.redhat.rhjmc.containerjfr.commands.SerializableCommand.ListOutput;\n+import com.redhat.rhjmc.containerjfr.commands.SerializableCommand.Output;\n+import com.redhat.rhjmc.containerjfr.core.net.JFRConnection;\n+import com.redhat.rhjmc.containerjfr.core.templates.Template;\n+import com.redhat.rhjmc.containerjfr.core.templates.TemplateService;\n+import com.redhat.rhjmc.containerjfr.core.tui.ClientWriter;\n+\n+@ExtendWith(MockitoExtension.class)\n+class ListEventTemplatesCommandTest {\n+\n+    ListEventTemplatesCommand cmd;\n+    @Mock JFRConnection connection;\n+    @Mock TemplateService templateSvc;\n+    @Mock ClientWriter cw;\n+\n+    @BeforeEach\n+    void setup() {\n+        cmd = new ListEventTemplatesCommand(cw);\n+    }\n+\n+    @Test\n+    void shouldBeNamedListEventTemplates() {\n+        MatcherAssert.assertThat(cmd.getName(), Matchers.equalTo(\"list-event-templates\"));\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(ints = {1, 2, 3})\n+    void shouldNotValidateWrongArgc(int n) {\n+        Assertions.assertFalse(cmd.validate(new String[n]));\n+        Mockito.verify(cw).println(\"No arguments expected\");\n+    }\n+\n+    @Test\n+    void shouldValidateNoArgs() {\n+        Assertions.assertTrue(cmd.validate(new String[0]));\n+        Mockito.verifyZeroInteractions(cw);\n+    }\n+\n+    @Test\n+    void executeShouldPrintListOfTemplateNames() throws Exception {\n+        Mockito.when(connection.getTemplateService()).thenReturn(templateSvc);\n+        Template foo = new Template(\"Foo\", \"a foo-ing template\", \"Foo Inc.\");\n+        Template bar = new Template(\"Bar\", \"a bar-ing template\", \"Bar Inc.\");\n+        Template baz = new Template(\"Baz\", \"a baz-ing template\", \"Baz Inc.\");\n+        Mockito.when(templateSvc.getTemplates()).thenReturn(List.of(foo, bar, baz));\n+\n+        cmd.connectionChanged(connection);\n+\n+        Mockito.verifyZeroInteractions(cw);\n+        cmd.execute(new String[0]);\n+        InOrder inOrder = Mockito.inOrder(cw);\n+        inOrder.verify(cw).println(\"Available recording templates:\");\n+        inOrder.verify(cw).println(\"\\t[Foo Inc.]\\tFoo:\\ta foo-ing template\");\n+        inOrder.verify(cw).println(\"\\t[Bar Inc.]\\tBar:\\ta bar-ing template\");\n+        inOrder.verify(cw).println(\"\\t[Baz Inc.]\\tBaz:\\ta baz-ing template\");\n+        inOrder.verify(cw)\n+                .println(\n+                        \"\\t[ContainerJFR]\\tALL:\\tEnable all available events in the target JVM, with default option values. This may be expensive and is intended primarily for testing ContainerJFR's own capabilities.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5ea234b7f402cd9c55c579899ca6950c6f99be30"}, "originalPosition": 75}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 815, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}