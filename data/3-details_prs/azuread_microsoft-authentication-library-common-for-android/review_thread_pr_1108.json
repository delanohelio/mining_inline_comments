{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTEzNTc0ODU1", "number": 1108, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwMzowNDo1N1rOE0N7_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwNDo0MzoyN1rOE0OuXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMTg5NzU3OnYy", "diffSide": "RIGHT", "path": "common/src/main/java/com/microsoft/identity/common/adal/internal/AuthenticationConstants.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwMzowNDo1N1rOHr1A5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwMzowNDo1N1rOHr1A5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcxOTM5Ng==", "bodyText": "these will change, so you may want a distinguishing factor in here.", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1108#discussion_r515719396", "createdAt": "2020-11-02T03:04:57Z", "author": {"login": "AdamBJohnsonx"}, "path": "common/src/main/java/com/microsoft/identity/common/adal/internal/AuthenticationConstants.java", "diffHunk": "@@ -644,11 +644,21 @@\n          */\n         public static final String BROKER_ACTIVITY_NAME = \"broker.activity.name\";\n \n+        /**\n+         * The Msal-To-Broker protocol name.\n+         */\n+        public static final String MSAL_TO_BROKER_PROTOCOL_NAME = \"msal.to.broker\";\n+\n         /**\n          * The newest Msal-To-Broker protocol version.\n          */\n         public static final String MSAL_TO_BROKER_PROTOCOL_VERSION_CODE = \"5.0\";\n \n+        /**\n+         * The Msal-To-Broker protocol name.\n+         */\n+        public static final String BROKER_API_TO_BROKER_PROTOCOL_NAME = \"broker.api.to.broker\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7de082f9113e0c86fee41e06432603094a278678"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMTg5Nzk0OnYy", "diffSide": "RIGHT", "path": "common/src/main/java/com/microsoft/identity/common/internal/broker/ipc/ContentProviderStrategy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwMzowNTowNlrOHr1BEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwMzowNTowNlrOHr1BEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcxOTQ0MQ==", "bodyText": "Log.", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1108#discussion_r515719441", "createdAt": "2020-11-02T03:05:06Z", "author": {"login": "AdamBJohnsonx"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/broker/ipc/ContentProviderStrategy.java", "diffHunk": "@@ -136,6 +136,10 @@ public boolean isBrokerContentProviderAvailable(@NonNull final String targetedBr\n         final List<ProviderInfo> providers = mContext.getPackageManager()\n                 .queryContentProviders(null, 0, 0);\n \n+        if (providers == null){\n+            return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7de082f9113e0c86fee41e06432603094a278678"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMTkwMDQ3OnYy", "diffSide": "RIGHT", "path": "common/src/main/java/com/microsoft/identity/common/internal/cache/HelloCache.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwMzowNzozMFrOHr1Clw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwMzowNzozMFrOHr1Clw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTcxOTgzMQ==", "bodyText": "We might want a way to clean these up so they don't continually build.", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1108#discussion_r515719831", "createdAt": "2020-11-02T03:07:30Z", "author": {"login": "AdamBJohnsonx"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/cache/HelloCache.java", "diffHunk": "@@ -0,0 +1,152 @@\n+//  Copyright (c) Microsoft Corporation.\n+//  All rights reserved.\n+//\n+//  This code is licensed under the MIT License.\n+//\n+//  Permission is hereby granted, free of charge, to any person obtaining a copy\n+//  of this software and associated documentation files(the \"Software\"), to deal\n+//  in the Software without restriction, including without limitation the rights\n+//  to use, copy, modify, merge, publish, distribute, sublicense, and / or sell\n+//  copies of the Software, and to permit persons to whom the Software is\n+//  furnished to do so, subject to the following conditions :\n+//\n+//  The above copyright notice and this permission notice shall be included in\n+//  all copies or substantial portions of the Software.\n+//\n+//  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+//  THE SOFTWARE.\n+\n+package com.microsoft.identity.common.internal.cache;\n+\n+import android.content.Context;\n+import android.content.pm.PackageInfo;\n+import android.content.pm.PackageManager;\n+import android.os.Build;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+import androidx.annotation.VisibleForTesting;\n+\n+import com.microsoft.identity.common.internal.logging.Logger;\n+\n+/**\n+ * Persisted cache for the IPC hello() protocol.\n+ * Use client's protocol version and the targeted app's package name and app version as a key\n+ * to cache the negotiated protocol version.\n+ * <p>\n+ * This means a new hello() call will ONLY be triggered only when.\n+ * 1. IPC operation is invoked for the very first time.\n+ * 2. Client bumps up protocol version.\n+ * 3. The targeted app is updated, uninstalled, reinstalled.\n+ * <p>\n+ * NOTE: the downside of this is that if you're debugging protocol change on the targeted app side,\n+ * you'll either have to keep bumping the test app version or clear the cache.\n+ * I've provided clearCache() for this purpose.\n+ */\n+public class HelloCache {\n+    private static final String TAG = HelloCache.class.getSimpleName();\n+\n+    private static final String SHARED_PREFERENCE_NAME = \"com.microsoft.common.ipc.hello.cache\";\n+\n+    private final SharedPreferencesFileManager mFileManager;\n+    private final Context mContext;\n+    private final String mProtocolName;\n+    private final String mTargetAppPackageName;\n+\n+    /**\n+     * Default constructor.\n+     *\n+     * @param context              application context.\n+     * @param protocolName         name of the protocol that invokes hello().\n+     * @param targetAppPackageName package name of the app that this client will hello() with.\n+     */\n+    public HelloCache(@NonNull final Context context,\n+                      @NonNull final String protocolName,\n+                      @NonNull final String targetAppPackageName) {\n+        mFileManager = new SharedPreferencesFileManager(context, SHARED_PREFERENCE_NAME);\n+        mContext = context;\n+        mProtocolName = protocolName;\n+        mTargetAppPackageName = targetAppPackageName;\n+    }\n+\n+    /**\n+     * Gets the cached negotiated protocol version. Returns null if there is none.\n+     *\n+     * @param clientMinimumProtocolVersion minimum version of the protocol that the client supports.\n+     * @param clientMaximumProtocolVersion maximum version of the protocol that to be advertised by the client.\n+     */\n+    public @Nullable String tryGetNegotiatedProtocolVersion(@Nullable final String clientMinimumProtocolVersion,\n+                                                            @NonNull final String clientMaximumProtocolVersion) {\n+        final String methodName = \":tryGetNegotiatedProtocolVersion\";\n+\n+        final String key;\n+        try {\n+            key = getKey(clientMinimumProtocolVersion, clientMaximumProtocolVersion);\n+        } catch (final PackageManager.NameNotFoundException e) {\n+            Logger.error(TAG + methodName, \"Failed to retrieve key\", e);\n+            return null;\n+        }\n+\n+        return mFileManager.getString(key);\n+    }\n+\n+    /**\n+     * Store the given negotiated protocol version into the cache.\n+     *\n+     * @param clientMinimumProtocolVersion minimum version of the protocol that the client supports.\n+     * @param clientMaximumProtocolVersion maximum version of the protocol that to be advertised by the client.\n+     * @param negotiatedProtocolVersion    the negotiated protocol version as returned from hello().\n+     */\n+    public void saveNegotiatedProtocolVersion(@Nullable final String clientMinimumProtocolVersion,\n+                                              @NonNull final String clientMaximumProtocolVersion,\n+                                              @NonNull final String negotiatedProtocolVersion) {\n+        final String methodName = \":saveNegotiatedProtocolVersion\";\n+\n+        final String key;\n+        try {\n+            key = getKey(clientMinimumProtocolVersion, clientMaximumProtocolVersion);\n+        } catch (final PackageManager.NameNotFoundException e) {\n+            Logger.error(TAG + methodName, \"Failed to retrieve key\", e);\n+            return;\n+        }\n+\n+        mFileManager.putString(key, negotiatedProtocolVersion);\n+    }\n+\n+    /**\n+     * Generates {@link SharedPreferencesFileManager}'s key.\n+     *\n+     * @param clientMinimumProtocolVersion minimum version of the protocol that the client supports.\n+     * @param clientMaximumProtocolVersion maximum version of the protocol that to be advertised by the client.\n+     */\n+    private @NonNull String getKey(@Nullable final String clientMinimumProtocolVersion,\n+                                   @NonNull final String clientMaximumProtocolVersion)\n+            throws PackageManager.NameNotFoundException {\n+        return mProtocolName +\n+                \"[\" + clientMinimumProtocolVersion + \",\" + clientMaximumProtocolVersion + \"]:\"\n+                + mTargetAppPackageName + \"[\" + getVersionCode() + \"]\";\n+    }\n+\n+    /**\n+     * To be used while debugging protocol change only.\n+     */\n+    @VisibleForTesting\n+    public void clearCache() {\n+        mFileManager.clear();\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7de082f9113e0c86fee41e06432603094a278678"}, "originalPosition": 141}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMjAwODYzOnYy", "diffSide": "RIGHT", "path": "changelog.txt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwNDoyOTo1NlrOHr1-BQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwNDoyOTo1NlrOHr1-BQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTczNTA0NQ==", "bodyText": "We probably want something more descriptive here (as this changelog is public)", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1108#discussion_r515735045", "createdAt": "2020-11-02T04:29:56Z", "author": {"login": "shahzaibj"}, "path": "changelog.txt", "diffHunk": "@@ -14,6 +14,7 @@ vNext\n     - [Part 3] Refactor AccountManager Strategy[IPC part 4] test cases for IPC strategies (#1092)\n     - [Part 4] test cases for IPC strategies (#1093)\n     - [Part 5.5] make changes to support the Broker API work (#1101)\n+- Hello() cache (#1108)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7de082f9113e0c86fee41e06432603094a278678"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMjAwOTI5OnYy", "diffSide": "RIGHT", "path": "common/src/main/java/com/microsoft/identity/common/adal/internal/AuthenticationConstants.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwNDozMDoyOFrOHr1-ZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwNDozMDoyOFrOHr1-ZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTczNTE0MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                     * The Msal-To-Broker protocol name.\n          \n          \n            \n                     * The Broker-To-Broker protocol name.", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1108#discussion_r515735140", "createdAt": "2020-11-02T04:30:28Z", "author": {"login": "shahzaibj"}, "path": "common/src/main/java/com/microsoft/identity/common/adal/internal/AuthenticationConstants.java", "diffHunk": "@@ -644,11 +644,21 @@\n          */\n         public static final String BROKER_ACTIVITY_NAME = \"broker.activity.name\";\n \n+        /**\n+         * The Msal-To-Broker protocol name.\n+         */\n+        public static final String MSAL_TO_BROKER_PROTOCOL_NAME = \"msal.to.broker\";\n+\n         /**\n          * The newest Msal-To-Broker protocol version.\n          */\n         public static final String MSAL_TO_BROKER_PROTOCOL_VERSION_CODE = \"5.0\";\n \n+        /**\n+         * The Msal-To-Broker protocol name.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7de082f9113e0c86fee41e06432603094a278678"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMjAxMjYxOnYy", "diffSide": "RIGHT", "path": "common/src/main/java/com/microsoft/identity/common/internal/cache/HelloCache.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwNDozMzowOVrOHr2ANw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwNzo0NzoxMVrOHr5MBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTczNTYwNw==", "bodyText": "Or you could pass a flag to disable/enable the cache for Hello....I would actually like to see that...doesn't necessarily have to be in this PR.", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1108#discussion_r515735607", "createdAt": "2020-11-02T04:33:09Z", "author": {"login": "shahzaibj"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/cache/HelloCache.java", "diffHunk": "@@ -0,0 +1,152 @@\n+//  Copyright (c) Microsoft Corporation.\n+//  All rights reserved.\n+//\n+//  This code is licensed under the MIT License.\n+//\n+//  Permission is hereby granted, free of charge, to any person obtaining a copy\n+//  of this software and associated documentation files(the \"Software\"), to deal\n+//  in the Software without restriction, including without limitation the rights\n+//  to use, copy, modify, merge, publish, distribute, sublicense, and / or sell\n+//  copies of the Software, and to permit persons to whom the Software is\n+//  furnished to do so, subject to the following conditions :\n+//\n+//  The above copyright notice and this permission notice shall be included in\n+//  all copies or substantial portions of the Software.\n+//\n+//  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+//  THE SOFTWARE.\n+\n+package com.microsoft.identity.common.internal.cache;\n+\n+import android.content.Context;\n+import android.content.pm.PackageInfo;\n+import android.content.pm.PackageManager;\n+import android.os.Build;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+import androidx.annotation.VisibleForTesting;\n+\n+import com.microsoft.identity.common.internal.logging.Logger;\n+\n+/**\n+ * Persisted cache for the IPC hello() protocol.\n+ * Use client's protocol version and the targeted app's package name and app version as a key\n+ * to cache the negotiated protocol version.\n+ * <p>\n+ * This means a new hello() call will ONLY be triggered only when.\n+ * 1. IPC operation is invoked for the very first time.\n+ * 2. Client bumps up protocol version.\n+ * 3. The targeted app is updated, uninstalled, reinstalled.\n+ * <p>\n+ * NOTE: the downside of this is that if you're debugging protocol change on the targeted app side,\n+ * you'll either have to keep bumping the test app version or clear the cache.\n+ * I've provided clearCache() for this purpose.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7de082f9113e0c86fee41e06432603094a278678"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc4Nzc4MQ==", "bodyText": "Might as well do it otherwise it'll sit in my backlog for eternity :D", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1108#discussion_r515787781", "createdAt": "2020-11-02T07:47:11Z", "author": {"login": "rpdome"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/cache/HelloCache.java", "diffHunk": "@@ -0,0 +1,152 @@\n+//  Copyright (c) Microsoft Corporation.\n+//  All rights reserved.\n+//\n+//  This code is licensed under the MIT License.\n+//\n+//  Permission is hereby granted, free of charge, to any person obtaining a copy\n+//  of this software and associated documentation files(the \"Software\"), to deal\n+//  in the Software without restriction, including without limitation the rights\n+//  to use, copy, modify, merge, publish, distribute, sublicense, and / or sell\n+//  copies of the Software, and to permit persons to whom the Software is\n+//  furnished to do so, subject to the following conditions :\n+//\n+//  The above copyright notice and this permission notice shall be included in\n+//  all copies or substantial portions of the Software.\n+//\n+//  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+//  THE SOFTWARE.\n+\n+package com.microsoft.identity.common.internal.cache;\n+\n+import android.content.Context;\n+import android.content.pm.PackageInfo;\n+import android.content.pm.PackageManager;\n+import android.os.Build;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+import androidx.annotation.VisibleForTesting;\n+\n+import com.microsoft.identity.common.internal.logging.Logger;\n+\n+/**\n+ * Persisted cache for the IPC hello() protocol.\n+ * Use client's protocol version and the targeted app's package name and app version as a key\n+ * to cache the negotiated protocol version.\n+ * <p>\n+ * This means a new hello() call will ONLY be triggered only when.\n+ * 1. IPC operation is invoked for the very first time.\n+ * 2. Client bumps up protocol version.\n+ * 3. The targeted app is updated, uninstalled, reinstalled.\n+ * <p>\n+ * NOTE: the downside of this is that if you're debugging protocol change on the targeted app side,\n+ * you'll either have to keep bumping the test app version or clear the cache.\n+ * I've provided clearCache() for this purpose.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTczNTYwNw=="}, "originalCommit": {"oid": "7de082f9113e0c86fee41e06432603094a278678"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMjAxNjg0OnYy", "diffSide": "RIGHT", "path": "common/src/main/java/com/microsoft/identity/common/internal/cache/HelloCache.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwNDozNjoxMVrOHr2CjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwNDozNjoxMVrOHr2CjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTczNjIwNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private @NonNull String getKey(@Nullable final String clientMinimumProtocolVersion,\n          \n          \n            \n                private @NonNull String getNegotiatedProtocolVersionCacheKey(@Nullable final String clientMinimumProtocolVersion,", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1108#discussion_r515736204", "createdAt": "2020-11-02T04:36:11Z", "author": {"login": "shahzaibj"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/cache/HelloCache.java", "diffHunk": "@@ -0,0 +1,152 @@\n+//  Copyright (c) Microsoft Corporation.\n+//  All rights reserved.\n+//\n+//  This code is licensed under the MIT License.\n+//\n+//  Permission is hereby granted, free of charge, to any person obtaining a copy\n+//  of this software and associated documentation files(the \"Software\"), to deal\n+//  in the Software without restriction, including without limitation the rights\n+//  to use, copy, modify, merge, publish, distribute, sublicense, and / or sell\n+//  copies of the Software, and to permit persons to whom the Software is\n+//  furnished to do so, subject to the following conditions :\n+//\n+//  The above copyright notice and this permission notice shall be included in\n+//  all copies or substantial portions of the Software.\n+//\n+//  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+//  THE SOFTWARE.\n+\n+package com.microsoft.identity.common.internal.cache;\n+\n+import android.content.Context;\n+import android.content.pm.PackageInfo;\n+import android.content.pm.PackageManager;\n+import android.os.Build;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+import androidx.annotation.VisibleForTesting;\n+\n+import com.microsoft.identity.common.internal.logging.Logger;\n+\n+/**\n+ * Persisted cache for the IPC hello() protocol.\n+ * Use client's protocol version and the targeted app's package name and app version as a key\n+ * to cache the negotiated protocol version.\n+ * <p>\n+ * This means a new hello() call will ONLY be triggered only when.\n+ * 1. IPC operation is invoked for the very first time.\n+ * 2. Client bumps up protocol version.\n+ * 3. The targeted app is updated, uninstalled, reinstalled.\n+ * <p>\n+ * NOTE: the downside of this is that if you're debugging protocol change on the targeted app side,\n+ * you'll either have to keep bumping the test app version or clear the cache.\n+ * I've provided clearCache() for this purpose.\n+ */\n+public class HelloCache {\n+    private static final String TAG = HelloCache.class.getSimpleName();\n+\n+    private static final String SHARED_PREFERENCE_NAME = \"com.microsoft.common.ipc.hello.cache\";\n+\n+    private final SharedPreferencesFileManager mFileManager;\n+    private final Context mContext;\n+    private final String mProtocolName;\n+    private final String mTargetAppPackageName;\n+\n+    /**\n+     * Default constructor.\n+     *\n+     * @param context              application context.\n+     * @param protocolName         name of the protocol that invokes hello().\n+     * @param targetAppPackageName package name of the app that this client will hello() with.\n+     */\n+    public HelloCache(@NonNull final Context context,\n+                      @NonNull final String protocolName,\n+                      @NonNull final String targetAppPackageName) {\n+        mFileManager = new SharedPreferencesFileManager(context, SHARED_PREFERENCE_NAME);\n+        mContext = context;\n+        mProtocolName = protocolName;\n+        mTargetAppPackageName = targetAppPackageName;\n+    }\n+\n+    /**\n+     * Gets the cached negotiated protocol version. Returns null if there is none.\n+     *\n+     * @param clientMinimumProtocolVersion minimum version of the protocol that the client supports.\n+     * @param clientMaximumProtocolVersion maximum version of the protocol that to be advertised by the client.\n+     */\n+    public @Nullable String tryGetNegotiatedProtocolVersion(@Nullable final String clientMinimumProtocolVersion,\n+                                                            @NonNull final String clientMaximumProtocolVersion) {\n+        final String methodName = \":tryGetNegotiatedProtocolVersion\";\n+\n+        final String key;\n+        try {\n+            key = getKey(clientMinimumProtocolVersion, clientMaximumProtocolVersion);\n+        } catch (final PackageManager.NameNotFoundException e) {\n+            Logger.error(TAG + methodName, \"Failed to retrieve key\", e);\n+            return null;\n+        }\n+\n+        return mFileManager.getString(key);\n+    }\n+\n+    /**\n+     * Store the given negotiated protocol version into the cache.\n+     *\n+     * @param clientMinimumProtocolVersion minimum version of the protocol that the client supports.\n+     * @param clientMaximumProtocolVersion maximum version of the protocol that to be advertised by the client.\n+     * @param negotiatedProtocolVersion    the negotiated protocol version as returned from hello().\n+     */\n+    public void saveNegotiatedProtocolVersion(@Nullable final String clientMinimumProtocolVersion,\n+                                              @NonNull final String clientMaximumProtocolVersion,\n+                                              @NonNull final String negotiatedProtocolVersion) {\n+        final String methodName = \":saveNegotiatedProtocolVersion\";\n+\n+        final String key;\n+        try {\n+            key = getKey(clientMinimumProtocolVersion, clientMaximumProtocolVersion);\n+        } catch (final PackageManager.NameNotFoundException e) {\n+            Logger.error(TAG + methodName, \"Failed to retrieve key\", e);\n+            return;\n+        }\n+\n+        mFileManager.putString(key, negotiatedProtocolVersion);\n+    }\n+\n+    /**\n+     * Generates {@link SharedPreferencesFileManager}'s key.\n+     *\n+     * @param clientMinimumProtocolVersion minimum version of the protocol that the client supports.\n+     * @param clientMaximumProtocolVersion maximum version of the protocol that to be advertised by the client.\n+     */\n+    private @NonNull String getKey(@Nullable final String clientMinimumProtocolVersion,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7de082f9113e0c86fee41e06432603094a278678"}, "originalPosition": 127}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMjAxNzI2OnYy", "diffSide": "RIGHT", "path": "common/src/main/java/com/microsoft/identity/common/internal/cache/HelloCache.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwNDozNjozNFrOHr2Czg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwNDozNjozNFrOHr2Czg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTczNjI3MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Generates {@link SharedPreferencesFileManager}'s key.\n          \n          \n            \n                 * Generates {@link SharedPreferencesFileManager}'s cache key for the negotiated protocol version.", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1108#discussion_r515736270", "createdAt": "2020-11-02T04:36:34Z", "author": {"login": "shahzaibj"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/cache/HelloCache.java", "diffHunk": "@@ -0,0 +1,152 @@\n+//  Copyright (c) Microsoft Corporation.\n+//  All rights reserved.\n+//\n+//  This code is licensed under the MIT License.\n+//\n+//  Permission is hereby granted, free of charge, to any person obtaining a copy\n+//  of this software and associated documentation files(the \"Software\"), to deal\n+//  in the Software without restriction, including without limitation the rights\n+//  to use, copy, modify, merge, publish, distribute, sublicense, and / or sell\n+//  copies of the Software, and to permit persons to whom the Software is\n+//  furnished to do so, subject to the following conditions :\n+//\n+//  The above copyright notice and this permission notice shall be included in\n+//  all copies or substantial portions of the Software.\n+//\n+//  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+//  THE SOFTWARE.\n+\n+package com.microsoft.identity.common.internal.cache;\n+\n+import android.content.Context;\n+import android.content.pm.PackageInfo;\n+import android.content.pm.PackageManager;\n+import android.os.Build;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+import androidx.annotation.VisibleForTesting;\n+\n+import com.microsoft.identity.common.internal.logging.Logger;\n+\n+/**\n+ * Persisted cache for the IPC hello() protocol.\n+ * Use client's protocol version and the targeted app's package name and app version as a key\n+ * to cache the negotiated protocol version.\n+ * <p>\n+ * This means a new hello() call will ONLY be triggered only when.\n+ * 1. IPC operation is invoked for the very first time.\n+ * 2. Client bumps up protocol version.\n+ * 3. The targeted app is updated, uninstalled, reinstalled.\n+ * <p>\n+ * NOTE: the downside of this is that if you're debugging protocol change on the targeted app side,\n+ * you'll either have to keep bumping the test app version or clear the cache.\n+ * I've provided clearCache() for this purpose.\n+ */\n+public class HelloCache {\n+    private static final String TAG = HelloCache.class.getSimpleName();\n+\n+    private static final String SHARED_PREFERENCE_NAME = \"com.microsoft.common.ipc.hello.cache\";\n+\n+    private final SharedPreferencesFileManager mFileManager;\n+    private final Context mContext;\n+    private final String mProtocolName;\n+    private final String mTargetAppPackageName;\n+\n+    /**\n+     * Default constructor.\n+     *\n+     * @param context              application context.\n+     * @param protocolName         name of the protocol that invokes hello().\n+     * @param targetAppPackageName package name of the app that this client will hello() with.\n+     */\n+    public HelloCache(@NonNull final Context context,\n+                      @NonNull final String protocolName,\n+                      @NonNull final String targetAppPackageName) {\n+        mFileManager = new SharedPreferencesFileManager(context, SHARED_PREFERENCE_NAME);\n+        mContext = context;\n+        mProtocolName = protocolName;\n+        mTargetAppPackageName = targetAppPackageName;\n+    }\n+\n+    /**\n+     * Gets the cached negotiated protocol version. Returns null if there is none.\n+     *\n+     * @param clientMinimumProtocolVersion minimum version of the protocol that the client supports.\n+     * @param clientMaximumProtocolVersion maximum version of the protocol that to be advertised by the client.\n+     */\n+    public @Nullable String tryGetNegotiatedProtocolVersion(@Nullable final String clientMinimumProtocolVersion,\n+                                                            @NonNull final String clientMaximumProtocolVersion) {\n+        final String methodName = \":tryGetNegotiatedProtocolVersion\";\n+\n+        final String key;\n+        try {\n+            key = getKey(clientMinimumProtocolVersion, clientMaximumProtocolVersion);\n+        } catch (final PackageManager.NameNotFoundException e) {\n+            Logger.error(TAG + methodName, \"Failed to retrieve key\", e);\n+            return null;\n+        }\n+\n+        return mFileManager.getString(key);\n+    }\n+\n+    /**\n+     * Store the given negotiated protocol version into the cache.\n+     *\n+     * @param clientMinimumProtocolVersion minimum version of the protocol that the client supports.\n+     * @param clientMaximumProtocolVersion maximum version of the protocol that to be advertised by the client.\n+     * @param negotiatedProtocolVersion    the negotiated protocol version as returned from hello().\n+     */\n+    public void saveNegotiatedProtocolVersion(@Nullable final String clientMinimumProtocolVersion,\n+                                              @NonNull final String clientMaximumProtocolVersion,\n+                                              @NonNull final String negotiatedProtocolVersion) {\n+        final String methodName = \":saveNegotiatedProtocolVersion\";\n+\n+        final String key;\n+        try {\n+            key = getKey(clientMinimumProtocolVersion, clientMaximumProtocolVersion);\n+        } catch (final PackageManager.NameNotFoundException e) {\n+            Logger.error(TAG + methodName, \"Failed to retrieve key\", e);\n+            return;\n+        }\n+\n+        mFileManager.putString(key, negotiatedProtocolVersion);\n+    }\n+\n+    /**\n+     * Generates {@link SharedPreferencesFileManager}'s key.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7de082f9113e0c86fee41e06432603094a278678"}, "originalPosition": 122}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMjAxOTk2OnYy", "diffSide": "RIGHT", "path": "common/src/main/java/com/microsoft/identity/common/internal/cache/HelloCache.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwNDozODo1OFrOHr2EUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwNDo0Mzo0OVrOHr2IEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTczNjY1OA==", "bodyText": "this cache is actually in the calling app itself right? If yes, then do we even need to store the package name?", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1108#discussion_r515736658", "createdAt": "2020-11-02T04:38:58Z", "author": {"login": "shahzaibj"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/cache/HelloCache.java", "diffHunk": "@@ -0,0 +1,152 @@\n+//  Copyright (c) Microsoft Corporation.\n+//  All rights reserved.\n+//\n+//  This code is licensed under the MIT License.\n+//\n+//  Permission is hereby granted, free of charge, to any person obtaining a copy\n+//  of this software and associated documentation files(the \"Software\"), to deal\n+//  in the Software without restriction, including without limitation the rights\n+//  to use, copy, modify, merge, publish, distribute, sublicense, and / or sell\n+//  copies of the Software, and to permit persons to whom the Software is\n+//  furnished to do so, subject to the following conditions :\n+//\n+//  The above copyright notice and this permission notice shall be included in\n+//  all copies or substantial portions of the Software.\n+//\n+//  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+//  THE SOFTWARE.\n+\n+package com.microsoft.identity.common.internal.cache;\n+\n+import android.content.Context;\n+import android.content.pm.PackageInfo;\n+import android.content.pm.PackageManager;\n+import android.os.Build;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+import androidx.annotation.VisibleForTesting;\n+\n+import com.microsoft.identity.common.internal.logging.Logger;\n+\n+/**\n+ * Persisted cache for the IPC hello() protocol.\n+ * Use client's protocol version and the targeted app's package name and app version as a key\n+ * to cache the negotiated protocol version.\n+ * <p>\n+ * This means a new hello() call will ONLY be triggered only when.\n+ * 1. IPC operation is invoked for the very first time.\n+ * 2. Client bumps up protocol version.\n+ * 3. The targeted app is updated, uninstalled, reinstalled.\n+ * <p>\n+ * NOTE: the downside of this is that if you're debugging protocol change on the targeted app side,\n+ * you'll either have to keep bumping the test app version or clear the cache.\n+ * I've provided clearCache() for this purpose.\n+ */\n+public class HelloCache {\n+    private static final String TAG = HelloCache.class.getSimpleName();\n+\n+    private static final String SHARED_PREFERENCE_NAME = \"com.microsoft.common.ipc.hello.cache\";\n+\n+    private final SharedPreferencesFileManager mFileManager;\n+    private final Context mContext;\n+    private final String mProtocolName;\n+    private final String mTargetAppPackageName;\n+\n+    /**\n+     * Default constructor.\n+     *\n+     * @param context              application context.\n+     * @param protocolName         name of the protocol that invokes hello().\n+     * @param targetAppPackageName package name of the app that this client will hello() with.\n+     */\n+    public HelloCache(@NonNull final Context context,\n+                      @NonNull final String protocolName,\n+                      @NonNull final String targetAppPackageName) {\n+        mFileManager = new SharedPreferencesFileManager(context, SHARED_PREFERENCE_NAME);\n+        mContext = context;\n+        mProtocolName = protocolName;\n+        mTargetAppPackageName = targetAppPackageName;\n+    }\n+\n+    /**\n+     * Gets the cached negotiated protocol version. Returns null if there is none.\n+     *\n+     * @param clientMinimumProtocolVersion minimum version of the protocol that the client supports.\n+     * @param clientMaximumProtocolVersion maximum version of the protocol that to be advertised by the client.\n+     */\n+    public @Nullable String tryGetNegotiatedProtocolVersion(@Nullable final String clientMinimumProtocolVersion,\n+                                                            @NonNull final String clientMaximumProtocolVersion) {\n+        final String methodName = \":tryGetNegotiatedProtocolVersion\";\n+\n+        final String key;\n+        try {\n+            key = getKey(clientMinimumProtocolVersion, clientMaximumProtocolVersion);\n+        } catch (final PackageManager.NameNotFoundException e) {\n+            Logger.error(TAG + methodName, \"Failed to retrieve key\", e);\n+            return null;\n+        }\n+\n+        return mFileManager.getString(key);\n+    }\n+\n+    /**\n+     * Store the given negotiated protocol version into the cache.\n+     *\n+     * @param clientMinimumProtocolVersion minimum version of the protocol that the client supports.\n+     * @param clientMaximumProtocolVersion maximum version of the protocol that to be advertised by the client.\n+     * @param negotiatedProtocolVersion    the negotiated protocol version as returned from hello().\n+     */\n+    public void saveNegotiatedProtocolVersion(@Nullable final String clientMinimumProtocolVersion,\n+                                              @NonNull final String clientMaximumProtocolVersion,\n+                                              @NonNull final String negotiatedProtocolVersion) {\n+        final String methodName = \":saveNegotiatedProtocolVersion\";\n+\n+        final String key;\n+        try {\n+            key = getKey(clientMinimumProtocolVersion, clientMaximumProtocolVersion);\n+        } catch (final PackageManager.NameNotFoundException e) {\n+            Logger.error(TAG + methodName, \"Failed to retrieve key\", e);\n+            return;\n+        }\n+\n+        mFileManager.putString(key, negotiatedProtocolVersion);\n+    }\n+\n+    /**\n+     * Generates {@link SharedPreferencesFileManager}'s key.\n+     *\n+     * @param clientMinimumProtocolVersion minimum version of the protocol that the client supports.\n+     * @param clientMaximumProtocolVersion maximum version of the protocol that to be advertised by the client.\n+     */\n+    private @NonNull String getKey(@Nullable final String clientMinimumProtocolVersion,\n+                                   @NonNull final String clientMaximumProtocolVersion)\n+            throws PackageManager.NameNotFoundException {\n+        return mProtocolName +\n+                \"[\" + clientMinimumProtocolVersion + \",\" + clientMaximumProtocolVersion + \"]:\"\n+                + mTargetAppPackageName + \"[\" + getVersionCode() + \"]\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7de082f9113e0c86fee41e06432603094a278678"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTczNjkyNg==", "bodyText": "package name of the broker.", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1108#discussion_r515736926", "createdAt": "2020-11-02T04:40:11Z", "author": {"login": "rpdome"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/cache/HelloCache.java", "diffHunk": "@@ -0,0 +1,152 @@\n+//  Copyright (c) Microsoft Corporation.\n+//  All rights reserved.\n+//\n+//  This code is licensed under the MIT License.\n+//\n+//  Permission is hereby granted, free of charge, to any person obtaining a copy\n+//  of this software and associated documentation files(the \"Software\"), to deal\n+//  in the Software without restriction, including without limitation the rights\n+//  to use, copy, modify, merge, publish, distribute, sublicense, and / or sell\n+//  copies of the Software, and to permit persons to whom the Software is\n+//  furnished to do so, subject to the following conditions :\n+//\n+//  The above copyright notice and this permission notice shall be included in\n+//  all copies or substantial portions of the Software.\n+//\n+//  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+//  THE SOFTWARE.\n+\n+package com.microsoft.identity.common.internal.cache;\n+\n+import android.content.Context;\n+import android.content.pm.PackageInfo;\n+import android.content.pm.PackageManager;\n+import android.os.Build;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+import androidx.annotation.VisibleForTesting;\n+\n+import com.microsoft.identity.common.internal.logging.Logger;\n+\n+/**\n+ * Persisted cache for the IPC hello() protocol.\n+ * Use client's protocol version and the targeted app's package name and app version as a key\n+ * to cache the negotiated protocol version.\n+ * <p>\n+ * This means a new hello() call will ONLY be triggered only when.\n+ * 1. IPC operation is invoked for the very first time.\n+ * 2. Client bumps up protocol version.\n+ * 3. The targeted app is updated, uninstalled, reinstalled.\n+ * <p>\n+ * NOTE: the downside of this is that if you're debugging protocol change on the targeted app side,\n+ * you'll either have to keep bumping the test app version or clear the cache.\n+ * I've provided clearCache() for this purpose.\n+ */\n+public class HelloCache {\n+    private static final String TAG = HelloCache.class.getSimpleName();\n+\n+    private static final String SHARED_PREFERENCE_NAME = \"com.microsoft.common.ipc.hello.cache\";\n+\n+    private final SharedPreferencesFileManager mFileManager;\n+    private final Context mContext;\n+    private final String mProtocolName;\n+    private final String mTargetAppPackageName;\n+\n+    /**\n+     * Default constructor.\n+     *\n+     * @param context              application context.\n+     * @param protocolName         name of the protocol that invokes hello().\n+     * @param targetAppPackageName package name of the app that this client will hello() with.\n+     */\n+    public HelloCache(@NonNull final Context context,\n+                      @NonNull final String protocolName,\n+                      @NonNull final String targetAppPackageName) {\n+        mFileManager = new SharedPreferencesFileManager(context, SHARED_PREFERENCE_NAME);\n+        mContext = context;\n+        mProtocolName = protocolName;\n+        mTargetAppPackageName = targetAppPackageName;\n+    }\n+\n+    /**\n+     * Gets the cached negotiated protocol version. Returns null if there is none.\n+     *\n+     * @param clientMinimumProtocolVersion minimum version of the protocol that the client supports.\n+     * @param clientMaximumProtocolVersion maximum version of the protocol that to be advertised by the client.\n+     */\n+    public @Nullable String tryGetNegotiatedProtocolVersion(@Nullable final String clientMinimumProtocolVersion,\n+                                                            @NonNull final String clientMaximumProtocolVersion) {\n+        final String methodName = \":tryGetNegotiatedProtocolVersion\";\n+\n+        final String key;\n+        try {\n+            key = getKey(clientMinimumProtocolVersion, clientMaximumProtocolVersion);\n+        } catch (final PackageManager.NameNotFoundException e) {\n+            Logger.error(TAG + methodName, \"Failed to retrieve key\", e);\n+            return null;\n+        }\n+\n+        return mFileManager.getString(key);\n+    }\n+\n+    /**\n+     * Store the given negotiated protocol version into the cache.\n+     *\n+     * @param clientMinimumProtocolVersion minimum version of the protocol that the client supports.\n+     * @param clientMaximumProtocolVersion maximum version of the protocol that to be advertised by the client.\n+     * @param negotiatedProtocolVersion    the negotiated protocol version as returned from hello().\n+     */\n+    public void saveNegotiatedProtocolVersion(@Nullable final String clientMinimumProtocolVersion,\n+                                              @NonNull final String clientMaximumProtocolVersion,\n+                                              @NonNull final String negotiatedProtocolVersion) {\n+        final String methodName = \":saveNegotiatedProtocolVersion\";\n+\n+        final String key;\n+        try {\n+            key = getKey(clientMinimumProtocolVersion, clientMaximumProtocolVersion);\n+        } catch (final PackageManager.NameNotFoundException e) {\n+            Logger.error(TAG + methodName, \"Failed to retrieve key\", e);\n+            return;\n+        }\n+\n+        mFileManager.putString(key, negotiatedProtocolVersion);\n+    }\n+\n+    /**\n+     * Generates {@link SharedPreferencesFileManager}'s key.\n+     *\n+     * @param clientMinimumProtocolVersion minimum version of the protocol that the client supports.\n+     * @param clientMaximumProtocolVersion maximum version of the protocol that to be advertised by the client.\n+     */\n+    private @NonNull String getKey(@Nullable final String clientMinimumProtocolVersion,\n+                                   @NonNull final String clientMaximumProtocolVersion)\n+            throws PackageManager.NameNotFoundException {\n+        return mProtocolName +\n+                \"[\" + clientMinimumProtocolVersion + \",\" + clientMaximumProtocolVersion + \"]:\"\n+                + mTargetAppPackageName + \"[\" + getVersionCode() + \"]\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTczNjY1OA=="}, "originalCommit": {"oid": "7de082f9113e0c86fee41e06432603094a278678"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTczNzYxNg==", "bodyText": "Got it", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1108#discussion_r515737616", "createdAt": "2020-11-02T04:43:49Z", "author": {"login": "shahzaibj"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/cache/HelloCache.java", "diffHunk": "@@ -0,0 +1,152 @@\n+//  Copyright (c) Microsoft Corporation.\n+//  All rights reserved.\n+//\n+//  This code is licensed under the MIT License.\n+//\n+//  Permission is hereby granted, free of charge, to any person obtaining a copy\n+//  of this software and associated documentation files(the \"Software\"), to deal\n+//  in the Software without restriction, including without limitation the rights\n+//  to use, copy, modify, merge, publish, distribute, sublicense, and / or sell\n+//  copies of the Software, and to permit persons to whom the Software is\n+//  furnished to do so, subject to the following conditions :\n+//\n+//  The above copyright notice and this permission notice shall be included in\n+//  all copies or substantial portions of the Software.\n+//\n+//  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+//  THE SOFTWARE.\n+\n+package com.microsoft.identity.common.internal.cache;\n+\n+import android.content.Context;\n+import android.content.pm.PackageInfo;\n+import android.content.pm.PackageManager;\n+import android.os.Build;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+import androidx.annotation.VisibleForTesting;\n+\n+import com.microsoft.identity.common.internal.logging.Logger;\n+\n+/**\n+ * Persisted cache for the IPC hello() protocol.\n+ * Use client's protocol version and the targeted app's package name and app version as a key\n+ * to cache the negotiated protocol version.\n+ * <p>\n+ * This means a new hello() call will ONLY be triggered only when.\n+ * 1. IPC operation is invoked for the very first time.\n+ * 2. Client bumps up protocol version.\n+ * 3. The targeted app is updated, uninstalled, reinstalled.\n+ * <p>\n+ * NOTE: the downside of this is that if you're debugging protocol change on the targeted app side,\n+ * you'll either have to keep bumping the test app version or clear the cache.\n+ * I've provided clearCache() for this purpose.\n+ */\n+public class HelloCache {\n+    private static final String TAG = HelloCache.class.getSimpleName();\n+\n+    private static final String SHARED_PREFERENCE_NAME = \"com.microsoft.common.ipc.hello.cache\";\n+\n+    private final SharedPreferencesFileManager mFileManager;\n+    private final Context mContext;\n+    private final String mProtocolName;\n+    private final String mTargetAppPackageName;\n+\n+    /**\n+     * Default constructor.\n+     *\n+     * @param context              application context.\n+     * @param protocolName         name of the protocol that invokes hello().\n+     * @param targetAppPackageName package name of the app that this client will hello() with.\n+     */\n+    public HelloCache(@NonNull final Context context,\n+                      @NonNull final String protocolName,\n+                      @NonNull final String targetAppPackageName) {\n+        mFileManager = new SharedPreferencesFileManager(context, SHARED_PREFERENCE_NAME);\n+        mContext = context;\n+        mProtocolName = protocolName;\n+        mTargetAppPackageName = targetAppPackageName;\n+    }\n+\n+    /**\n+     * Gets the cached negotiated protocol version. Returns null if there is none.\n+     *\n+     * @param clientMinimumProtocolVersion minimum version of the protocol that the client supports.\n+     * @param clientMaximumProtocolVersion maximum version of the protocol that to be advertised by the client.\n+     */\n+    public @Nullable String tryGetNegotiatedProtocolVersion(@Nullable final String clientMinimumProtocolVersion,\n+                                                            @NonNull final String clientMaximumProtocolVersion) {\n+        final String methodName = \":tryGetNegotiatedProtocolVersion\";\n+\n+        final String key;\n+        try {\n+            key = getKey(clientMinimumProtocolVersion, clientMaximumProtocolVersion);\n+        } catch (final PackageManager.NameNotFoundException e) {\n+            Logger.error(TAG + methodName, \"Failed to retrieve key\", e);\n+            return null;\n+        }\n+\n+        return mFileManager.getString(key);\n+    }\n+\n+    /**\n+     * Store the given negotiated protocol version into the cache.\n+     *\n+     * @param clientMinimumProtocolVersion minimum version of the protocol that the client supports.\n+     * @param clientMaximumProtocolVersion maximum version of the protocol that to be advertised by the client.\n+     * @param negotiatedProtocolVersion    the negotiated protocol version as returned from hello().\n+     */\n+    public void saveNegotiatedProtocolVersion(@Nullable final String clientMinimumProtocolVersion,\n+                                              @NonNull final String clientMaximumProtocolVersion,\n+                                              @NonNull final String negotiatedProtocolVersion) {\n+        final String methodName = \":saveNegotiatedProtocolVersion\";\n+\n+        final String key;\n+        try {\n+            key = getKey(clientMinimumProtocolVersion, clientMaximumProtocolVersion);\n+        } catch (final PackageManager.NameNotFoundException e) {\n+            Logger.error(TAG + methodName, \"Failed to retrieve key\", e);\n+            return;\n+        }\n+\n+        mFileManager.putString(key, negotiatedProtocolVersion);\n+    }\n+\n+    /**\n+     * Generates {@link SharedPreferencesFileManager}'s key.\n+     *\n+     * @param clientMinimumProtocolVersion minimum version of the protocol that the client supports.\n+     * @param clientMaximumProtocolVersion maximum version of the protocol that to be advertised by the client.\n+     */\n+    private @NonNull String getKey(@Nullable final String clientMinimumProtocolVersion,\n+                                   @NonNull final String clientMaximumProtocolVersion)\n+            throws PackageManager.NameNotFoundException {\n+        return mProtocolName +\n+                \"[\" + clientMinimumProtocolVersion + \",\" + clientMaximumProtocolVersion + \"]:\"\n+                + mTargetAppPackageName + \"[\" + getVersionCode() + \"]\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTczNjY1OA=="}, "originalCommit": {"oid": "7de082f9113e0c86fee41e06432603094a278678"}, "originalPosition": 132}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMjAyNTEzOnYy", "diffSide": "RIGHT", "path": "common/src/main/java/com/microsoft/identity/common/internal/controllers/BrokerMsalController.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwNDo0MjoxM1rOHr2G9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwNDo0Mjo0M1rOHr2HWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTczNzMzMg==", "bodyText": "and do we actually want a RuntimeException in that case?", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1108#discussion_r515737332", "createdAt": "2020-11-02T04:42:13Z", "author": {"login": "shahzaibj"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/controllers/BrokerMsalController.java", "diffHunk": "@@ -153,16 +170,41 @@ public BrokerMsalController(final Context applicationContext) {\n      * @param parameters a {@link CommandParameters}\n      * @return a protocol version negotiated by MSAL and Broker.\n      */\n-    private @NonNull String hello(@NonNull IIpcStrategy strategy,\n-                                  @NonNull final CommandParameters parameters) throws BaseException {\n+    @VisibleForTesting\n+    public @NonNull String hello(@NonNull IIpcStrategy strategy,\n+                                 @NonNull final CommandParameters parameters) throws BaseException {\n+\n+        final Bundle bundle = mRequestAdapter.getRequestBundleForHello(parameters);\n+        final String minimumProtocolVersion = bundle.getString(CLIENT_CONFIGURED_MINIMUM_BP_VERSION_KEY);\n+        final String maximumProtocolVersion = bundle.getString(CLIENT_ADVERTISED_MAXIMUM_BP_VERSION_KEY);\n+\n+        // This should be part of the bundle.\n+        // If we're hitting this, it means that the hello protocol changed. see getRequestBundleForHello().", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7de082f9113e0c86fee41e06432603094a278678"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTczNzQzNQ==", "bodyText": "can we just catch, log, and return anything that is BaseException?", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1108#discussion_r515737435", "createdAt": "2020-11-02T04:42:43Z", "author": {"login": "shahzaibj"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/controllers/BrokerMsalController.java", "diffHunk": "@@ -153,16 +170,41 @@ public BrokerMsalController(final Context applicationContext) {\n      * @param parameters a {@link CommandParameters}\n      * @return a protocol version negotiated by MSAL and Broker.\n      */\n-    private @NonNull String hello(@NonNull IIpcStrategy strategy,\n-                                  @NonNull final CommandParameters parameters) throws BaseException {\n+    @VisibleForTesting\n+    public @NonNull String hello(@NonNull IIpcStrategy strategy,\n+                                 @NonNull final CommandParameters parameters) throws BaseException {\n+\n+        final Bundle bundle = mRequestAdapter.getRequestBundleForHello(parameters);\n+        final String minimumProtocolVersion = bundle.getString(CLIENT_CONFIGURED_MINIMUM_BP_VERSION_KEY);\n+        final String maximumProtocolVersion = bundle.getString(CLIENT_ADVERTISED_MAXIMUM_BP_VERSION_KEY);\n+\n+        // This should be part of the bundle.\n+        // If we're hitting this, it means that the hello protocol changed. see getRequestBundleForHello().", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTczNzMzMg=="}, "originalCommit": {"oid": "7de082f9113e0c86fee41e06432603094a278678"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMjAyNjU0OnYy", "diffSide": "RIGHT", "path": "common/src/main/java/com/microsoft/identity/common/internal/controllers/BrokerMsalController.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwNDo0MzoyN1rOHr2Hwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwODoyNzowOVrOHr6S7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTczNzUzOA==", "bodyText": "we probably don't need this method....whatever it is doing I think can be done directly in the test", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1108#discussion_r515737538", "createdAt": "2020-11-02T04:43:27Z", "author": {"login": "shahzaibj"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/controllers/BrokerMsalController.java", "diffHunk": "@@ -103,15 +108,27 @@\n     private final Context mApplicationContext;\n     private final String mActiveBrokerPackageName;\n     private final BrokerOperationExecutor mBrokerOperationExecutor;\n+    private final HelloCache mHelloCache;\n \n     public BrokerMsalController(final Context applicationContext) {\n         mApplicationContext = applicationContext;\n-        mActiveBrokerPackageName = new BrokerValidator(mApplicationContext).getCurrentActiveBrokerPackageName();\n+        mActiveBrokerPackageName = getActiveBrokerPackageName();\n         if (TextUtils.isEmpty(mActiveBrokerPackageName)) {\n             throw new IllegalStateException(\"Active Broker not found. This class should not be initialized.\");\n         }\n \n         mBrokerOperationExecutor = new BrokerOperationExecutor(getIpcStrategies(mApplicationContext, mActiveBrokerPackageName));\n+        mHelloCache = getHelloCache();\n+    }\n+\n+    @VisibleForTesting\n+    public HelloCache getHelloCache() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7de082f9113e0c86fee41e06432603094a278678"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgwNTkzNQ==", "bodyText": "This is for testing if the cache is properly wired.. we need this to inject the mock Token cache into BrokerMsalController.", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1108#discussion_r515805935", "createdAt": "2020-11-02T08:27:09Z", "author": {"login": "rpdome"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/controllers/BrokerMsalController.java", "diffHunk": "@@ -103,15 +108,27 @@\n     private final Context mApplicationContext;\n     private final String mActiveBrokerPackageName;\n     private final BrokerOperationExecutor mBrokerOperationExecutor;\n+    private final HelloCache mHelloCache;\n \n     public BrokerMsalController(final Context applicationContext) {\n         mApplicationContext = applicationContext;\n-        mActiveBrokerPackageName = new BrokerValidator(mApplicationContext).getCurrentActiveBrokerPackageName();\n+        mActiveBrokerPackageName = getActiveBrokerPackageName();\n         if (TextUtils.isEmpty(mActiveBrokerPackageName)) {\n             throw new IllegalStateException(\"Active Broker not found. This class should not be initialized.\");\n         }\n \n         mBrokerOperationExecutor = new BrokerOperationExecutor(getIpcStrategies(mApplicationContext, mActiveBrokerPackageName));\n+        mHelloCache = getHelloCache();\n+    }\n+\n+    @VisibleForTesting\n+    public HelloCache getHelloCache() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTczNzUzOA=="}, "originalCommit": {"oid": "7de082f9113e0c86fee41e06432603094a278678"}, "originalPosition": 45}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2058, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}