{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDgwMzMwODEw", "number": 1026, "reviewThreads": {"totalCount": 22, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNVQwMDo1NToxMlrOEgjfzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQyMDo0ODozOVrOEjxQLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyNTcxNDcxOnYy", "diffSide": "RIGHT", "path": "common/src/main/java/com/microsoft/identity/common/internal/platform/IDevicePopManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNVQwMDo1NToxMlrOHNeZbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNVQwMDo1ODo0NlrOHNebCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg5MTU2Ng==", "bodyText": "Update javadoc", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1026#discussion_r483891566", "createdAt": "2020-09-05T00:55:12Z", "author": {"login": "iambmelt"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/platform/IDevicePopManager.java", "diffHunk": "@@ -90,6 +94,21 @@\n      */\n     void getRequestConfirmation(TaskCompletedCallbackWithError<String, ClientException> callback);\n \n+    /**\n+     * Signs an arbitrary piece of String data.\n+     *\n+     * @param input The input to sign.\n+     * @return The input data, signed by our private key.\n+     */\n+    String sign(String input) throws ClientException;\n+\n+    /**\n+     * Gets the public key associated with this DevicePoPManager formatted as an X.509 ASN1 Dump.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ceff46e71c4ce3fc9e8240798c37e07eedadd1c"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg5MTk3Nw==", "bodyText": "423c2b3", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1026#discussion_r483891977", "createdAt": "2020-09-05T00:58:46Z", "author": {"login": "iambmelt"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/platform/IDevicePopManager.java", "diffHunk": "@@ -90,6 +94,21 @@\n      */\n     void getRequestConfirmation(TaskCompletedCallbackWithError<String, ClientException> callback);\n \n+    /**\n+     * Signs an arbitrary piece of String data.\n+     *\n+     * @param input The input to sign.\n+     * @return The input data, signed by our private key.\n+     */\n+    String sign(String input) throws ClientException;\n+\n+    /**\n+     * Gets the public key associated with this DevicePoPManager formatted as an X.509 ASN1 Dump.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg5MTU2Ng=="}, "originalCommit": {"oid": "9ceff46e71c4ce3fc9e8240798c37e07eedadd1c"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyNTczNjU0OnYy", "diffSide": "RIGHT", "path": "common/src/main/java/com/microsoft/identity/common/internal/platform/IDevicePopManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNVQwMToyMTo1M1rOHNej_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNVQwMToyMTo1M1rOHNej_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg5NDI2OA==", "bodyText": "Reference:\n\nhttps://connect2id.com/products/nimbus-jose-jwt/examples/pem-encoded-objects", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1026#discussion_r483894268", "createdAt": "2020-09-05T01:21:53Z", "author": {"login": "iambmelt"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/platform/IDevicePopManager.java", "diffHunk": "@@ -34,6 +34,11 @@\n  */\n public interface IDevicePopManager {\n \n+    enum PublicKeyFormat {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e6f2a32826a8536fc36e7f14b58aedc69c49961"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyNTczNzgxOnYy", "diffSide": "RIGHT", "path": "common/src/main/java/com/microsoft/identity/common/internal/platform/DevicePopManager.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNVQwMToyNDowN1rOHNekpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQyMTozNToyM1rOHPbIeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg5NDQzOA==", "bodyText": "TODO determine signing strategy, or if multiple should be employed.", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1026#discussion_r483894438", "createdAt": "2020-09-05T01:24:07Z", "author": {"login": "iambmelt"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/platform/DevicePopManager.java", "diffHunk": "@@ -441,6 +444,66 @@ public void run() {\n         });\n     }\n \n+    @Override\n+    public String sign(@NonNull final String input) throws ClientException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e6f2a32826a8536fc36e7f14b58aedc69c49961"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI3NjQ3NQ==", "bodyText": "Currently using SHA256WithRSA", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1026#discussion_r485276475", "createdAt": "2020-09-09T01:03:29Z", "author": {"login": "iambmelt"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/platform/DevicePopManager.java", "diffHunk": "@@ -441,6 +444,66 @@ public void run() {\n         });\n     }\n \n+    @Override\n+    public String sign(@NonNull final String input) throws ClientException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg5NDQzOA=="}, "originalCommit": {"oid": "0e6f2a32826a8536fc36e7f14b58aedc69c49961"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTkzNTIyNA==", "bodyText": "Or should this be a different IDevicePopManager?", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1026#discussion_r485935224", "createdAt": "2020-09-09T21:35:23Z", "author": {"login": "AdamBJohnsonx"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/platform/DevicePopManager.java", "diffHunk": "@@ -441,6 +444,66 @@ public void run() {\n         });\n     }\n \n+    @Override\n+    public String sign(@NonNull final String input) throws ClientException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg5NDQzOA=="}, "originalCommit": {"oid": "0e6f2a32826a8536fc36e7f14b58aedc69c49961"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyNTczOTg4OnYy", "diffSide": "RIGHT", "path": "common/src/main/java/com/microsoft/identity/common/internal/platform/IDevicePopManager.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNVQwMToyNTo1OVrOHNelmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwMDo0NjoxNlrOHOypuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg5NDY4Mg==", "bodyText": "TODO: Do we need to accept something like a SigningParams; for instance, to specify an algorithm?\nAlso, the OneAuth API assumes signing cannot fail... we need some way to return error if this operation fails", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1026#discussion_r483894682", "createdAt": "2020-09-05T01:25:59Z", "author": {"login": "iambmelt"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/platform/IDevicePopManager.java", "diffHunk": "@@ -90,6 +95,23 @@\n      */\n     void getRequestConfirmation(TaskCompletedCallbackWithError<String, ClientException> callback);\n \n+    /**\n+     * Signs an arbitrary piece of String data.\n+     *\n+     * @param input The input to sign.\n+     * @return The input data, signed by our private key.\n+     */\n+    String sign(String input) throws ClientException;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e6f2a32826a8536fc36e7f14b58aedc69c49961"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI3MTg2Nw==", "bodyText": "Made the assumption that this is going to use SHA256WithRSA and implemented accordingly", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1026#discussion_r485271867", "createdAt": "2020-09-09T00:45:45Z", "author": {"login": "iambmelt"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/platform/IDevicePopManager.java", "diffHunk": "@@ -90,6 +95,23 @@\n      */\n     void getRequestConfirmation(TaskCompletedCallbackWithError<String, ClientException> callback);\n \n+    /**\n+     * Signs an arbitrary piece of String data.\n+     *\n+     * @param input The input to sign.\n+     * @return The input data, signed by our private key.\n+     */\n+    String sign(String input) throws ClientException;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg5NDY4Mg=="}, "originalCommit": {"oid": "0e6f2a32826a8536fc36e7f14b58aedc69c49961"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTI3MTk5Mg==", "bodyText": "7b21d10", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1026#discussion_r485271992", "createdAt": "2020-09-09T00:46:16Z", "author": {"login": "iambmelt"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/platform/IDevicePopManager.java", "diffHunk": "@@ -90,6 +95,23 @@\n      */\n     void getRequestConfirmation(TaskCompletedCallbackWithError<String, ClientException> callback);\n \n+    /**\n+     * Signs an arbitrary piece of String data.\n+     *\n+     * @param input The input to sign.\n+     * @return The input data, signed by our private key.\n+     */\n+    String sign(String input) throws ClientException;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzg5NDY4Mg=="}, "originalCommit": {"oid": "0e6f2a32826a8536fc36e7f14b58aedc69c49961"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzNDk1Njk2OnYy", "diffSide": "RIGHT", "path": "common/src/main/java/com/microsoft/identity/common/internal/platform/DevicePopManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMjoyODozMFrOHOwEzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMjo0Mzo0NlrOHOwZrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIyOTc3NA==", "bodyText": "If this is an enum, you could use a switch. Potential benefits, some static analysis tools will complain at you if you're not handling all of the potential enumerated values correctly.\nAlso, if you've got an unknown format, it would be really nice to have logged what the value actually was.", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1026#discussion_r485229774", "createdAt": "2020-09-08T22:28:30Z", "author": {"login": "AdamBJohnsonx"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/platform/DevicePopManager.java", "diffHunk": "@@ -441,6 +444,66 @@ public void run() {\n         });\n     }\n \n+    @Override\n+    public String sign(@NonNull final String input) throws ClientException {\n+        // TODO Sign how???\n+        // RS256? SHA256withECDSA?\n+        return null;\n+    }\n+\n+    @Override\n+    public String getPublicKey(@NonNull final PublicKeyFormat format) throws ClientException {\n+        if (X_509_SubjectPublicKeyInfo_ASN_1 == format) {\n+            return getX509SubjectPublicKeyInfo();\n+        } else if (PKCS1_RSAPublicKey == format) {\n+            return getPkcs1RsaPublicKey();\n+        } else {\n+            throw new ClientException(UNKNOWN_EXPORT_FORMAT);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e6f2a32826a8536fc36e7f14b58aedc69c49961"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIzNTExOQ==", "bodyText": "8d10b15, e78cf6b", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1026#discussion_r485235119", "createdAt": "2020-09-08T22:43:46Z", "author": {"login": "iambmelt"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/platform/DevicePopManager.java", "diffHunk": "@@ -441,6 +444,66 @@ public void run() {\n         });\n     }\n \n+    @Override\n+    public String sign(@NonNull final String input) throws ClientException {\n+        // TODO Sign how???\n+        // RS256? SHA256withECDSA?\n+        return null;\n+    }\n+\n+    @Override\n+    public String getPublicKey(@NonNull final PublicKeyFormat format) throws ClientException {\n+        if (X_509_SubjectPublicKeyInfo_ASN_1 == format) {\n+            return getX509SubjectPublicKeyInfo();\n+        } else if (PKCS1_RSAPublicKey == format) {\n+            return getPkcs1RsaPublicKey();\n+        } else {\n+            throw new ClientException(UNKNOWN_EXPORT_FORMAT);\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTIyOTc3NA=="}, "originalCommit": {"oid": "0e6f2a32826a8536fc36e7f14b58aedc69c49961"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MzkxNDg5OnYy", "diffSide": "RIGHT", "path": "common/src/main/java/com/microsoft/identity/common/internal/platform/IDevicePopManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMTowMDoxMVrOHQFkKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMToxNDoyNFrOHQF--Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYzMDQ0Mg==", "bodyText": "TODO: document the signing algorithm", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1026#discussion_r486630442", "createdAt": "2020-09-10T21:00:11Z", "author": {"login": "iambmelt"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/platform/IDevicePopManager.java", "diffHunk": "@@ -90,6 +104,32 @@\n      */\n     void getRequestConfirmation(TaskCompletedCallbackWithError<String, ClientException> callback);\n \n+    /**\n+     * Signs an arbitrary piece of String data.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8491a08b7f47015985e7aa429a21136b9122989a"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYzNzMwNQ==", "bodyText": "65c2d01", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1026#discussion_r486637305", "createdAt": "2020-09-10T21:14:24Z", "author": {"login": "iambmelt"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/platform/IDevicePopManager.java", "diffHunk": "@@ -90,6 +104,32 @@\n      */\n     void getRequestConfirmation(TaskCompletedCallbackWithError<String, ClientException> callback);\n \n+    /**\n+     * Signs an arbitrary piece of String data.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYzMDQ0Mg=="}, "originalCommit": {"oid": "8491a08b7f47015985e7aa429a21136b9122989a"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MzkxNTg4OnYy", "diffSide": "RIGHT", "path": "common/src/main/java/com/microsoft/identity/common/internal/platform/IDevicePopManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMTowMDozMFrOHQFkyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMToxNDoyOVrOHQF_Hw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYzMDYwMA==", "bodyText": "TODO: document the signing algorithm verified", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1026#discussion_r486630600", "createdAt": "2020-09-10T21:00:30Z", "author": {"login": "iambmelt"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/platform/IDevicePopManager.java", "diffHunk": "@@ -90,6 +104,32 @@\n      */\n     void getRequestConfirmation(TaskCompletedCallbackWithError<String, ClientException> callback);\n \n+    /**\n+     * Signs an arbitrary piece of String data.\n+     *\n+     * @param input The input to sign.\n+     * @return The input data, signed by our private key.\n+     */\n+    String sign(String input) throws ClientException;\n+\n+    /**\n+     * Verify a signature previously made by our Private Key.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8491a08b7f47015985e7aa429a21136b9122989a"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYzNzM0Mw==", "bodyText": "65c2d01", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1026#discussion_r486637343", "createdAt": "2020-09-10T21:14:29Z", "author": {"login": "iambmelt"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/platform/IDevicePopManager.java", "diffHunk": "@@ -90,6 +104,32 @@\n      */\n     void getRequestConfirmation(TaskCompletedCallbackWithError<String, ClientException> callback);\n \n+    /**\n+     * Signs an arbitrary piece of String data.\n+     *\n+     * @param input The input to sign.\n+     * @return The input data, signed by our private key.\n+     */\n+    String sign(String input) throws ClientException;\n+\n+    /**\n+     * Verify a signature previously made by our Private Key.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYzMDYwMA=="}, "originalCommit": {"oid": "8491a08b7f47015985e7aa429a21136b9122989a"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MzkxODEyOnYy", "diffSide": "RIGHT", "path": "common/src/main/java/com/microsoft/identity/common/internal/platform/DevicePopManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMTowMToxM1rOHQFmFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMTozNTo1N1rOHQGlzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYzMDkzNQ==", "bodyText": "@NonNull return type", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1026#discussion_r486630935", "createdAt": "2020-09-10T21:01:13Z", "author": {"login": "iambmelt"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/platform/DevicePopManager.java", "diffHunk": "@@ -441,6 +493,209 @@ public void run() {\n         });\n     }\n \n+    @Override", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8491a08b7f47015985e7aa429a21136b9122989a"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY0NzI0Nw==", "bodyText": "bda5f73", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1026#discussion_r486647247", "createdAt": "2020-09-10T21:35:57Z", "author": {"login": "iambmelt"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/platform/DevicePopManager.java", "diffHunk": "@@ -441,6 +493,209 @@ public void run() {\n         });\n     }\n \n+    @Override", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYzMDkzNQ=="}, "originalCommit": {"oid": "8491a08b7f47015985e7aa429a21136b9122989a"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MzkxOTMxOnYy", "diffSide": "RIGHT", "path": "common/src/main/java/com/microsoft/identity/common/internal/platform/DevicePopManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMTowMTozNFrOHQFm0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMTozNTo1M1rOHQGluQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYzMTEyMA==", "bodyText": "@NonNull return value", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1026#discussion_r486631120", "createdAt": "2020-09-10T21:01:34Z", "author": {"login": "iambmelt"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/platform/DevicePopManager.java", "diffHunk": "@@ -441,6 +493,209 @@ public void run() {\n         });\n     }\n \n+    @Override\n+    public String sign(@NonNull final String input) throws ClientException {\n+        final Exception exception;\n+        final String errCode;\n+\n+        try {\n+            final byte[] inputBytesToSign = input.getBytes(ENCODING_UTF8);\n+            final KeyStore.Entry keyEntry = mKeyStore.getEntry(KEYSTORE_ENTRY_ALIAS, null);\n+\n+            if (!(keyEntry instanceof KeyStore.PrivateKeyEntry)) {\n+                Logger.warn(\n+                        TAG + \":sign\",\n+                        PRIVATE_KEY_NOT_FOUND\n+                );\n+                throw new ClientException(INVALID_KEY_MISSING);\n+            }\n+\n+            final Signature signature = Signature.getInstance(SHA_256_WITH_RSA);\n+            signature.initSign(((KeyStore.PrivateKeyEntry) keyEntry).getPrivateKey());\n+            signature.update(inputBytesToSign);\n+            final byte[] signedBytes = signature.sign();\n+            return Base64.encodeToString(signedBytes, Base64.DEFAULT);\n+        } catch (final KeyStoreException e) {\n+            exception = e;\n+            errCode = KEYSTORE_NOT_INITIALIZED;\n+        } catch (final NoSuchAlgorithmException e) {\n+            exception = e;\n+            errCode = NO_SUCH_ALGORITHM;\n+        } catch (final UnrecoverableEntryException e) {\n+            exception = e;\n+            errCode = INVALID_PROTECTION_PARAMS;\n+        } catch (final InvalidKeyException e) {\n+            exception = e;\n+            errCode = INVALID_KEY;\n+        } catch (final SignatureException e) {\n+            exception = e;\n+            errCode = SIGNING_FAILURE;\n+        } catch (final UnsupportedEncodingException e) {\n+            exception = e;\n+            errCode = UNSUPPORTED_ENCODING;\n+        }\n+\n+        final ClientException clientException = new ClientException(\n+                errCode,\n+                exception.getMessage(),\n+                exception\n+        );\n+\n+        Logger.error(\n+                TAG,\n+                clientException.getMessage(),\n+                clientException\n+        );\n+\n+        throw clientException;\n+    }\n+\n+    @Override\n+    public boolean verify(@NonNull final String plainText, @NonNull final String signatureStr) {\n+        final String errCode;\n+        final Exception exception;\n+\n+        try {\n+            final byte[] inputBytesToVerify = plainText.getBytes(ENCODING_UTF8);\n+            final KeyStore.Entry keyEntry = mKeyStore.getEntry(KEYSTORE_ENTRY_ALIAS, null);\n+\n+            if (!(keyEntry instanceof KeyStore.PrivateKeyEntry)) {\n+                Logger.warn(\n+                        TAG + \":verify\",\n+                        PRIVATE_KEY_NOT_FOUND\n+                );\n+                return false;\n+            }\n+\n+            final Signature signature = Signature.getInstance(SHA_256_WITH_RSA);\n+            signature.initVerify(((KeyStore.PrivateKeyEntry) keyEntry).getCertificate());\n+            signature.update(inputBytesToVerify);\n+            final byte[] signatureBytes = Base64.decode(signatureStr, Base64.DEFAULT);\n+\n+            return signature.verify(signatureBytes);\n+        } catch (final UnsupportedEncodingException e) {\n+            errCode = UNSUPPORTED_ENCODING;\n+            exception = e;\n+        } catch (final NoSuchAlgorithmException e) {\n+            errCode = NO_SUCH_ALGORITHM;\n+            exception = e;\n+        } catch (final KeyStoreException e) {\n+            errCode = KEYSTORE_NOT_INITIALIZED;\n+            exception = e;\n+        } catch (final UnrecoverableEntryException e) {\n+            errCode = INVALID_PROTECTION_PARAMS;\n+            exception = e;\n+        } catch (final InvalidKeyException e) {\n+            errCode = INVALID_KEY;\n+            exception = e;\n+        } catch (final SignatureException e) {\n+            errCode = SIGNING_FAILURE;\n+            exception = e;\n+        }\n+\n+        Logger.error(\n+                TAG + \":verify\",\n+                errCode,\n+                exception\n+        );\n+\n+        return false;\n+    }\n+\n+    @Override", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8491a08b7f47015985e7aa429a21136b9122989a"}, "originalPosition": 217}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY0NzIyNQ==", "bodyText": "bda5f73", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1026#discussion_r486647225", "createdAt": "2020-09-10T21:35:53Z", "author": {"login": "iambmelt"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/platform/DevicePopManager.java", "diffHunk": "@@ -441,6 +493,209 @@ public void run() {\n         });\n     }\n \n+    @Override\n+    public String sign(@NonNull final String input) throws ClientException {\n+        final Exception exception;\n+        final String errCode;\n+\n+        try {\n+            final byte[] inputBytesToSign = input.getBytes(ENCODING_UTF8);\n+            final KeyStore.Entry keyEntry = mKeyStore.getEntry(KEYSTORE_ENTRY_ALIAS, null);\n+\n+            if (!(keyEntry instanceof KeyStore.PrivateKeyEntry)) {\n+                Logger.warn(\n+                        TAG + \":sign\",\n+                        PRIVATE_KEY_NOT_FOUND\n+                );\n+                throw new ClientException(INVALID_KEY_MISSING);\n+            }\n+\n+            final Signature signature = Signature.getInstance(SHA_256_WITH_RSA);\n+            signature.initSign(((KeyStore.PrivateKeyEntry) keyEntry).getPrivateKey());\n+            signature.update(inputBytesToSign);\n+            final byte[] signedBytes = signature.sign();\n+            return Base64.encodeToString(signedBytes, Base64.DEFAULT);\n+        } catch (final KeyStoreException e) {\n+            exception = e;\n+            errCode = KEYSTORE_NOT_INITIALIZED;\n+        } catch (final NoSuchAlgorithmException e) {\n+            exception = e;\n+            errCode = NO_SUCH_ALGORITHM;\n+        } catch (final UnrecoverableEntryException e) {\n+            exception = e;\n+            errCode = INVALID_PROTECTION_PARAMS;\n+        } catch (final InvalidKeyException e) {\n+            exception = e;\n+            errCode = INVALID_KEY;\n+        } catch (final SignatureException e) {\n+            exception = e;\n+            errCode = SIGNING_FAILURE;\n+        } catch (final UnsupportedEncodingException e) {\n+            exception = e;\n+            errCode = UNSUPPORTED_ENCODING;\n+        }\n+\n+        final ClientException clientException = new ClientException(\n+                errCode,\n+                exception.getMessage(),\n+                exception\n+        );\n+\n+        Logger.error(\n+                TAG,\n+                clientException.getMessage(),\n+                clientException\n+        );\n+\n+        throw clientException;\n+    }\n+\n+    @Override\n+    public boolean verify(@NonNull final String plainText, @NonNull final String signatureStr) {\n+        final String errCode;\n+        final Exception exception;\n+\n+        try {\n+            final byte[] inputBytesToVerify = plainText.getBytes(ENCODING_UTF8);\n+            final KeyStore.Entry keyEntry = mKeyStore.getEntry(KEYSTORE_ENTRY_ALIAS, null);\n+\n+            if (!(keyEntry instanceof KeyStore.PrivateKeyEntry)) {\n+                Logger.warn(\n+                        TAG + \":verify\",\n+                        PRIVATE_KEY_NOT_FOUND\n+                );\n+                return false;\n+            }\n+\n+            final Signature signature = Signature.getInstance(SHA_256_WITH_RSA);\n+            signature.initVerify(((KeyStore.PrivateKeyEntry) keyEntry).getCertificate());\n+            signature.update(inputBytesToVerify);\n+            final byte[] signatureBytes = Base64.decode(signatureStr, Base64.DEFAULT);\n+\n+            return signature.verify(signatureBytes);\n+        } catch (final UnsupportedEncodingException e) {\n+            errCode = UNSUPPORTED_ENCODING;\n+            exception = e;\n+        } catch (final NoSuchAlgorithmException e) {\n+            errCode = NO_SUCH_ALGORITHM;\n+            exception = e;\n+        } catch (final KeyStoreException e) {\n+            errCode = KEYSTORE_NOT_INITIALIZED;\n+            exception = e;\n+        } catch (final UnrecoverableEntryException e) {\n+            errCode = INVALID_PROTECTION_PARAMS;\n+            exception = e;\n+        } catch (final InvalidKeyException e) {\n+            errCode = INVALID_KEY;\n+            exception = e;\n+        } catch (final SignatureException e) {\n+            errCode = SIGNING_FAILURE;\n+            exception = e;\n+        }\n+\n+        Logger.error(\n+                TAG + \":verify\",\n+                errCode,\n+                exception\n+        );\n+\n+        return false;\n+    }\n+\n+    @Override", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYzMTEyMA=="}, "originalCommit": {"oid": "8491a08b7f47015985e7aa429a21136b9122989a"}, "originalPosition": 217}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MzkxOTk2OnYy", "diffSide": "RIGHT", "path": "common/src/main/java/com/microsoft/identity/common/internal/platform/DevicePopManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMTowMTo0OVrOHQFnSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMTozNTo0OVrOHQGllA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYzMTI0MQ==", "bodyText": "@NonNull return type", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1026#discussion_r486631241", "createdAt": "2020-09-10T21:01:49Z", "author": {"login": "iambmelt"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/platform/DevicePopManager.java", "diffHunk": "@@ -441,6 +493,209 @@ public void run() {\n         });\n     }\n \n+    @Override\n+    public String sign(@NonNull final String input) throws ClientException {\n+        final Exception exception;\n+        final String errCode;\n+\n+        try {\n+            final byte[] inputBytesToSign = input.getBytes(ENCODING_UTF8);\n+            final KeyStore.Entry keyEntry = mKeyStore.getEntry(KEYSTORE_ENTRY_ALIAS, null);\n+\n+            if (!(keyEntry instanceof KeyStore.PrivateKeyEntry)) {\n+                Logger.warn(\n+                        TAG + \":sign\",\n+                        PRIVATE_KEY_NOT_FOUND\n+                );\n+                throw new ClientException(INVALID_KEY_MISSING);\n+            }\n+\n+            final Signature signature = Signature.getInstance(SHA_256_WITH_RSA);\n+            signature.initSign(((KeyStore.PrivateKeyEntry) keyEntry).getPrivateKey());\n+            signature.update(inputBytesToSign);\n+            final byte[] signedBytes = signature.sign();\n+            return Base64.encodeToString(signedBytes, Base64.DEFAULT);\n+        } catch (final KeyStoreException e) {\n+            exception = e;\n+            errCode = KEYSTORE_NOT_INITIALIZED;\n+        } catch (final NoSuchAlgorithmException e) {\n+            exception = e;\n+            errCode = NO_SUCH_ALGORITHM;\n+        } catch (final UnrecoverableEntryException e) {\n+            exception = e;\n+            errCode = INVALID_PROTECTION_PARAMS;\n+        } catch (final InvalidKeyException e) {\n+            exception = e;\n+            errCode = INVALID_KEY;\n+        } catch (final SignatureException e) {\n+            exception = e;\n+            errCode = SIGNING_FAILURE;\n+        } catch (final UnsupportedEncodingException e) {\n+            exception = e;\n+            errCode = UNSUPPORTED_ENCODING;\n+        }\n+\n+        final ClientException clientException = new ClientException(\n+                errCode,\n+                exception.getMessage(),\n+                exception\n+        );\n+\n+        Logger.error(\n+                TAG,\n+                clientException.getMessage(),\n+                clientException\n+        );\n+\n+        throw clientException;\n+    }\n+\n+    @Override\n+    public boolean verify(@NonNull final String plainText, @NonNull final String signatureStr) {\n+        final String errCode;\n+        final Exception exception;\n+\n+        try {\n+            final byte[] inputBytesToVerify = plainText.getBytes(ENCODING_UTF8);\n+            final KeyStore.Entry keyEntry = mKeyStore.getEntry(KEYSTORE_ENTRY_ALIAS, null);\n+\n+            if (!(keyEntry instanceof KeyStore.PrivateKeyEntry)) {\n+                Logger.warn(\n+                        TAG + \":verify\",\n+                        PRIVATE_KEY_NOT_FOUND\n+                );\n+                return false;\n+            }\n+\n+            final Signature signature = Signature.getInstance(SHA_256_WITH_RSA);\n+            signature.initVerify(((KeyStore.PrivateKeyEntry) keyEntry).getCertificate());\n+            signature.update(inputBytesToVerify);\n+            final byte[] signatureBytes = Base64.decode(signatureStr, Base64.DEFAULT);\n+\n+            return signature.verify(signatureBytes);\n+        } catch (final UnsupportedEncodingException e) {\n+            errCode = UNSUPPORTED_ENCODING;\n+            exception = e;\n+        } catch (final NoSuchAlgorithmException e) {\n+            errCode = NO_SUCH_ALGORITHM;\n+            exception = e;\n+        } catch (final KeyStoreException e) {\n+            errCode = KEYSTORE_NOT_INITIALIZED;\n+            exception = e;\n+        } catch (final UnrecoverableEntryException e) {\n+            errCode = INVALID_PROTECTION_PARAMS;\n+            exception = e;\n+        } catch (final InvalidKeyException e) {\n+            errCode = INVALID_KEY;\n+            exception = e;\n+        } catch (final SignatureException e) {\n+            errCode = SIGNING_FAILURE;\n+            exception = e;\n+        }\n+\n+        Logger.error(\n+                TAG + \":verify\",\n+                errCode,\n+                exception\n+        );\n+\n+        return false;\n+    }\n+\n+    @Override\n+    public String getPublicKey(@NonNull final PublicKeyFormat format) throws ClientException {\n+        switch (format) {\n+            case X_509_SubjectPublicKeyInfo_ASN_1:\n+                return getX509SubjectPublicKeyInfo();\n+            case JWK:\n+                return getJwkPublicKey();\n+            default:\n+                final String errMsg = \"Unrecognized or unsupported key format: \" + format;\n+                final ClientException clientException = new ClientException(\n+                        UNKNOWN_EXPORT_FORMAT,\n+                        errMsg\n+                );\n+\n+                Logger.error(\n+                        TAG + \":getPublicKey\",\n+                        errMsg,\n+                        clientException\n+                );\n+\n+                throw clientException;\n+        }\n+    }\n+\n+    private String getJwkPublicKey() throws ClientException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8491a08b7f47015985e7aa429a21136b9122989a"}, "originalPosition": 241}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY0NzE4OA==", "bodyText": "bda5f73", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1026#discussion_r486647188", "createdAt": "2020-09-10T21:35:49Z", "author": {"login": "iambmelt"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/platform/DevicePopManager.java", "diffHunk": "@@ -441,6 +493,209 @@ public void run() {\n         });\n     }\n \n+    @Override\n+    public String sign(@NonNull final String input) throws ClientException {\n+        final Exception exception;\n+        final String errCode;\n+\n+        try {\n+            final byte[] inputBytesToSign = input.getBytes(ENCODING_UTF8);\n+            final KeyStore.Entry keyEntry = mKeyStore.getEntry(KEYSTORE_ENTRY_ALIAS, null);\n+\n+            if (!(keyEntry instanceof KeyStore.PrivateKeyEntry)) {\n+                Logger.warn(\n+                        TAG + \":sign\",\n+                        PRIVATE_KEY_NOT_FOUND\n+                );\n+                throw new ClientException(INVALID_KEY_MISSING);\n+            }\n+\n+            final Signature signature = Signature.getInstance(SHA_256_WITH_RSA);\n+            signature.initSign(((KeyStore.PrivateKeyEntry) keyEntry).getPrivateKey());\n+            signature.update(inputBytesToSign);\n+            final byte[] signedBytes = signature.sign();\n+            return Base64.encodeToString(signedBytes, Base64.DEFAULT);\n+        } catch (final KeyStoreException e) {\n+            exception = e;\n+            errCode = KEYSTORE_NOT_INITIALIZED;\n+        } catch (final NoSuchAlgorithmException e) {\n+            exception = e;\n+            errCode = NO_SUCH_ALGORITHM;\n+        } catch (final UnrecoverableEntryException e) {\n+            exception = e;\n+            errCode = INVALID_PROTECTION_PARAMS;\n+        } catch (final InvalidKeyException e) {\n+            exception = e;\n+            errCode = INVALID_KEY;\n+        } catch (final SignatureException e) {\n+            exception = e;\n+            errCode = SIGNING_FAILURE;\n+        } catch (final UnsupportedEncodingException e) {\n+            exception = e;\n+            errCode = UNSUPPORTED_ENCODING;\n+        }\n+\n+        final ClientException clientException = new ClientException(\n+                errCode,\n+                exception.getMessage(),\n+                exception\n+        );\n+\n+        Logger.error(\n+                TAG,\n+                clientException.getMessage(),\n+                clientException\n+        );\n+\n+        throw clientException;\n+    }\n+\n+    @Override\n+    public boolean verify(@NonNull final String plainText, @NonNull final String signatureStr) {\n+        final String errCode;\n+        final Exception exception;\n+\n+        try {\n+            final byte[] inputBytesToVerify = plainText.getBytes(ENCODING_UTF8);\n+            final KeyStore.Entry keyEntry = mKeyStore.getEntry(KEYSTORE_ENTRY_ALIAS, null);\n+\n+            if (!(keyEntry instanceof KeyStore.PrivateKeyEntry)) {\n+                Logger.warn(\n+                        TAG + \":verify\",\n+                        PRIVATE_KEY_NOT_FOUND\n+                );\n+                return false;\n+            }\n+\n+            final Signature signature = Signature.getInstance(SHA_256_WITH_RSA);\n+            signature.initVerify(((KeyStore.PrivateKeyEntry) keyEntry).getCertificate());\n+            signature.update(inputBytesToVerify);\n+            final byte[] signatureBytes = Base64.decode(signatureStr, Base64.DEFAULT);\n+\n+            return signature.verify(signatureBytes);\n+        } catch (final UnsupportedEncodingException e) {\n+            errCode = UNSUPPORTED_ENCODING;\n+            exception = e;\n+        } catch (final NoSuchAlgorithmException e) {\n+            errCode = NO_SUCH_ALGORITHM;\n+            exception = e;\n+        } catch (final KeyStoreException e) {\n+            errCode = KEYSTORE_NOT_INITIALIZED;\n+            exception = e;\n+        } catch (final UnrecoverableEntryException e) {\n+            errCode = INVALID_PROTECTION_PARAMS;\n+            exception = e;\n+        } catch (final InvalidKeyException e) {\n+            errCode = INVALID_KEY;\n+            exception = e;\n+        } catch (final SignatureException e) {\n+            errCode = SIGNING_FAILURE;\n+            exception = e;\n+        }\n+\n+        Logger.error(\n+                TAG + \":verify\",\n+                errCode,\n+                exception\n+        );\n+\n+        return false;\n+    }\n+\n+    @Override\n+    public String getPublicKey(@NonNull final PublicKeyFormat format) throws ClientException {\n+        switch (format) {\n+            case X_509_SubjectPublicKeyInfo_ASN_1:\n+                return getX509SubjectPublicKeyInfo();\n+            case JWK:\n+                return getJwkPublicKey();\n+            default:\n+                final String errMsg = \"Unrecognized or unsupported key format: \" + format;\n+                final ClientException clientException = new ClientException(\n+                        UNKNOWN_EXPORT_FORMAT,\n+                        errMsg\n+                );\n+\n+                Logger.error(\n+                        TAG + \":getPublicKey\",\n+                        errMsg,\n+                        clientException\n+                );\n+\n+                throw clientException;\n+        }\n+    }\n+\n+    private String getJwkPublicKey() throws ClientException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYzMTI0MQ=="}, "originalCommit": {"oid": "8491a08b7f47015985e7aa429a21136b9122989a"}, "originalPosition": 241}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MzkyMDYwOnYy", "diffSide": "RIGHT", "path": "common/src/main/java/com/microsoft/identity/common/internal/platform/IDevicePopManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMTowMjowMFrOHQFnuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMToyMTowMVrOHQGLaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYzMTM1Mw==", "bodyText": "Javadoc", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1026#discussion_r486631353", "createdAt": "2020-09-10T21:02:00Z", "author": {"login": "iambmelt"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/platform/IDevicePopManager.java", "diffHunk": "@@ -28,12 +28,18 @@\n import com.microsoft.identity.common.internal.controllers.TaskCompletedCallbackWithError;\n \n import java.net.URL;\n+import java.util.Date;\n \n /**\n  * Internal convenience class interface for PoP related functions.\n  */\n public interface IDevicePopManager {\n \n+    enum PublicKeyFormat {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8491a08b7f47015985e7aa429a21136b9122989a"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY0MDQ4OQ==", "bodyText": "f65f159", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1026#discussion_r486640489", "createdAt": "2020-09-10T21:21:01Z", "author": {"login": "iambmelt"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/platform/IDevicePopManager.java", "diffHunk": "@@ -28,12 +28,18 @@\n import com.microsoft.identity.common.internal.controllers.TaskCompletedCallbackWithError;\n \n import java.net.URL;\n+import java.util.Date;\n \n /**\n  * Internal convenience class interface for PoP related functions.\n  */\n public interface IDevicePopManager {\n \n+    enum PublicKeyFormat {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYzMTM1Mw=="}, "originalCommit": {"oid": "8491a08b7f47015985e7aa429a21136b9122989a"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MzkyMzQ4OnYy", "diffSide": "RIGHT", "path": "common/src/main/java/com/microsoft/identity/common/internal/platform/DevicePopManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMTowMjo1NVrOHQFpbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMTowNzo1NFrOHQFzGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYzMTc4OA==", "bodyText": "Why is this constant public when the other is not?", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1026#discussion_r486631788", "createdAt": "2020-09-10T21:02:55Z", "author": {"login": "AdamBJohnsonx"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/platform/DevicePopManager.java", "diffHunk": "@@ -108,6 +117,16 @@\n      */\n     private static final int RSA_KEY_SIZE = 2048;\n \n+    /**\n+     * Our designated signing algorithm; used for JWTs and generalized signing actions.\n+     */\n+    private static final String SHA_256_WITH_RSA = \"SHA256withRSA\";\n+\n+    /**\n+     * Log message when private key material cannot be found.\n+     */\n+    public static final String PRIVATE_KEY_NOT_FOUND = \"Not an instance of a PrivateKeyEntry\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8491a08b7f47015985e7aa429a21136b9122989a"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYzNDI2Ng==", "bodyText": "Auto-refactor tool's default vis -- fixed in b39b87a", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1026#discussion_r486634266", "createdAt": "2020-09-10T21:07:54Z", "author": {"login": "iambmelt"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/platform/DevicePopManager.java", "diffHunk": "@@ -108,6 +117,16 @@\n      */\n     private static final int RSA_KEY_SIZE = 2048;\n \n+    /**\n+     * Our designated signing algorithm; used for JWTs and generalized signing actions.\n+     */\n+    private static final String SHA_256_WITH_RSA = \"SHA256withRSA\";\n+\n+    /**\n+     * Log message when private key material cannot be found.\n+     */\n+    public static final String PRIVATE_KEY_NOT_FOUND = \"Not an instance of a PrivateKeyEntry\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYzMTc4OA=="}, "originalCommit": {"oid": "8491a08b7f47015985e7aa429a21136b9122989a"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MzkyNzIxOnYy", "diffSide": "RIGHT", "path": "common/src/main/java/com/microsoft/identity/common/internal/platform/DevicePopManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMTowMzo1OVrOHQFrkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMTowMzo1OVrOHQFrkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYzMjMzOA==", "bodyText": "ATM Machine?\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                     * JWK key for inner object.\n          \n          \n            \n                     * JWK for inner object.", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1026#discussion_r486632338", "createdAt": "2020-09-10T21:03:59Z", "author": {"login": "AdamBJohnsonx"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/platform/DevicePopManager.java", "diffHunk": "@@ -184,6 +203,11 @@\n          * A random value used for replay protection.\n          */\n         private static final String NONCE = \"nonce\";\n+\n+        /**\n+         * JWK key for inner object.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8491a08b7f47015985e7aa429a21136b9122989a"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0Mzk0NzA1OnYy", "diffSide": "RIGHT", "path": "common/src/main/java/com/microsoft/identity/common/internal/platform/DevicePopManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMToxMDoyMFrOHQF3ew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMToyMTo1NlrOHQGNIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYzNTM4Nw==", "bodyText": "Remove extra newline", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1026#discussion_r486635387", "createdAt": "2020-09-10T21:10:20Z", "author": {"login": "iambmelt"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/platform/DevicePopManager.java", "diffHunk": "@@ -441,6 +493,209 @@ public void run() {\n         });\n     }\n \n+    @Override\n+    public String sign(@NonNull final String input) throws ClientException {\n+        final Exception exception;\n+        final String errCode;\n+\n+        try {\n+            final byte[] inputBytesToSign = input.getBytes(ENCODING_UTF8);\n+            final KeyStore.Entry keyEntry = mKeyStore.getEntry(KEYSTORE_ENTRY_ALIAS, null);\n+\n+            if (!(keyEntry instanceof KeyStore.PrivateKeyEntry)) {\n+                Logger.warn(\n+                        TAG + \":sign\",\n+                        PRIVATE_KEY_NOT_FOUND\n+                );\n+                throw new ClientException(INVALID_KEY_MISSING);\n+            }\n+\n+            final Signature signature = Signature.getInstance(SHA_256_WITH_RSA);\n+            signature.initSign(((KeyStore.PrivateKeyEntry) keyEntry).getPrivateKey());\n+            signature.update(inputBytesToSign);\n+            final byte[] signedBytes = signature.sign();\n+            return Base64.encodeToString(signedBytes, Base64.DEFAULT);\n+        } catch (final KeyStoreException e) {\n+            exception = e;\n+            errCode = KEYSTORE_NOT_INITIALIZED;\n+        } catch (final NoSuchAlgorithmException e) {\n+            exception = e;\n+            errCode = NO_SUCH_ALGORITHM;\n+        } catch (final UnrecoverableEntryException e) {\n+            exception = e;\n+            errCode = INVALID_PROTECTION_PARAMS;\n+        } catch (final InvalidKeyException e) {\n+            exception = e;\n+            errCode = INVALID_KEY;\n+        } catch (final SignatureException e) {\n+            exception = e;\n+            errCode = SIGNING_FAILURE;\n+        } catch (final UnsupportedEncodingException e) {\n+            exception = e;\n+            errCode = UNSUPPORTED_ENCODING;\n+        }\n+\n+        final ClientException clientException = new ClientException(\n+                errCode,\n+                exception.getMessage(),\n+                exception\n+        );\n+\n+        Logger.error(\n+                TAG,\n+                clientException.getMessage(),\n+                clientException\n+        );\n+\n+        throw clientException;\n+    }\n+\n+    @Override\n+    public boolean verify(@NonNull final String plainText, @NonNull final String signatureStr) {\n+        final String errCode;\n+        final Exception exception;\n+\n+        try {\n+            final byte[] inputBytesToVerify = plainText.getBytes(ENCODING_UTF8);\n+            final KeyStore.Entry keyEntry = mKeyStore.getEntry(KEYSTORE_ENTRY_ALIAS, null);\n+\n+            if (!(keyEntry instanceof KeyStore.PrivateKeyEntry)) {\n+                Logger.warn(\n+                        TAG + \":verify\",\n+                        PRIVATE_KEY_NOT_FOUND\n+                );\n+                return false;\n+            }\n+\n+            final Signature signature = Signature.getInstance(SHA_256_WITH_RSA);\n+            signature.initVerify(((KeyStore.PrivateKeyEntry) keyEntry).getCertificate());\n+            signature.update(inputBytesToVerify);\n+            final byte[] signatureBytes = Base64.decode(signatureStr, Base64.DEFAULT);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e099e46a4933667293680a3e12d8bbb08788789e"}, "originalPosition": 186}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY0MDkzMA==", "bodyText": "8ffb1b7", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1026#discussion_r486640930", "createdAt": "2020-09-10T21:21:56Z", "author": {"login": "iambmelt"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/platform/DevicePopManager.java", "diffHunk": "@@ -441,6 +493,209 @@ public void run() {\n         });\n     }\n \n+    @Override\n+    public String sign(@NonNull final String input) throws ClientException {\n+        final Exception exception;\n+        final String errCode;\n+\n+        try {\n+            final byte[] inputBytesToSign = input.getBytes(ENCODING_UTF8);\n+            final KeyStore.Entry keyEntry = mKeyStore.getEntry(KEYSTORE_ENTRY_ALIAS, null);\n+\n+            if (!(keyEntry instanceof KeyStore.PrivateKeyEntry)) {\n+                Logger.warn(\n+                        TAG + \":sign\",\n+                        PRIVATE_KEY_NOT_FOUND\n+                );\n+                throw new ClientException(INVALID_KEY_MISSING);\n+            }\n+\n+            final Signature signature = Signature.getInstance(SHA_256_WITH_RSA);\n+            signature.initSign(((KeyStore.PrivateKeyEntry) keyEntry).getPrivateKey());\n+            signature.update(inputBytesToSign);\n+            final byte[] signedBytes = signature.sign();\n+            return Base64.encodeToString(signedBytes, Base64.DEFAULT);\n+        } catch (final KeyStoreException e) {\n+            exception = e;\n+            errCode = KEYSTORE_NOT_INITIALIZED;\n+        } catch (final NoSuchAlgorithmException e) {\n+            exception = e;\n+            errCode = NO_SUCH_ALGORITHM;\n+        } catch (final UnrecoverableEntryException e) {\n+            exception = e;\n+            errCode = INVALID_PROTECTION_PARAMS;\n+        } catch (final InvalidKeyException e) {\n+            exception = e;\n+            errCode = INVALID_KEY;\n+        } catch (final SignatureException e) {\n+            exception = e;\n+            errCode = SIGNING_FAILURE;\n+        } catch (final UnsupportedEncodingException e) {\n+            exception = e;\n+            errCode = UNSUPPORTED_ENCODING;\n+        }\n+\n+        final ClientException clientException = new ClientException(\n+                errCode,\n+                exception.getMessage(),\n+                exception\n+        );\n+\n+        Logger.error(\n+                TAG,\n+                clientException.getMessage(),\n+                clientException\n+        );\n+\n+        throw clientException;\n+    }\n+\n+    @Override\n+    public boolean verify(@NonNull final String plainText, @NonNull final String signatureStr) {\n+        final String errCode;\n+        final Exception exception;\n+\n+        try {\n+            final byte[] inputBytesToVerify = plainText.getBytes(ENCODING_UTF8);\n+            final KeyStore.Entry keyEntry = mKeyStore.getEntry(KEYSTORE_ENTRY_ALIAS, null);\n+\n+            if (!(keyEntry instanceof KeyStore.PrivateKeyEntry)) {\n+                Logger.warn(\n+                        TAG + \":verify\",\n+                        PRIVATE_KEY_NOT_FOUND\n+                );\n+                return false;\n+            }\n+\n+            final Signature signature = Signature.getInstance(SHA_256_WITH_RSA);\n+            signature.initVerify(((KeyStore.PrivateKeyEntry) keyEntry).getCertificate());\n+            signature.update(inputBytesToVerify);\n+            final byte[] signatureBytes = Base64.decode(signatureStr, Base64.DEFAULT);\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYzNTM4Nw=="}, "originalCommit": {"oid": "e099e46a4933667293680a3e12d8bbb08788789e"}, "originalPosition": 186}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0Mzk0ODA3OnYy", "diffSide": "RIGHT", "path": "common/src/main/java/com/microsoft/identity/common/internal/platform/DevicePopManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMToxMDozOVrOHQF4DQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMToyMzowMlrOHQGPCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYzNTUzMw==", "bodyText": "Remove resolved TODO", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1026#discussion_r486635533", "createdAt": "2020-09-10T21:10:39Z", "author": {"login": "iambmelt"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/platform/DevicePopManager.java", "diffHunk": "@@ -441,6 +493,209 @@ public void run() {\n         });\n     }\n \n+    @Override\n+    public String sign(@NonNull final String input) throws ClientException {\n+        final Exception exception;\n+        final String errCode;\n+\n+        try {\n+            final byte[] inputBytesToSign = input.getBytes(ENCODING_UTF8);\n+            final KeyStore.Entry keyEntry = mKeyStore.getEntry(KEYSTORE_ENTRY_ALIAS, null);\n+\n+            if (!(keyEntry instanceof KeyStore.PrivateKeyEntry)) {\n+                Logger.warn(\n+                        TAG + \":sign\",\n+                        PRIVATE_KEY_NOT_FOUND\n+                );\n+                throw new ClientException(INVALID_KEY_MISSING);\n+            }\n+\n+            final Signature signature = Signature.getInstance(SHA_256_WITH_RSA);\n+            signature.initSign(((KeyStore.PrivateKeyEntry) keyEntry).getPrivateKey());\n+            signature.update(inputBytesToSign);\n+            final byte[] signedBytes = signature.sign();\n+            return Base64.encodeToString(signedBytes, Base64.DEFAULT);\n+        } catch (final KeyStoreException e) {\n+            exception = e;\n+            errCode = KEYSTORE_NOT_INITIALIZED;\n+        } catch (final NoSuchAlgorithmException e) {\n+            exception = e;\n+            errCode = NO_SUCH_ALGORITHM;\n+        } catch (final UnrecoverableEntryException e) {\n+            exception = e;\n+            errCode = INVALID_PROTECTION_PARAMS;\n+        } catch (final InvalidKeyException e) {\n+            exception = e;\n+            errCode = INVALID_KEY;\n+        } catch (final SignatureException e) {\n+            exception = e;\n+            errCode = SIGNING_FAILURE;\n+        } catch (final UnsupportedEncodingException e) {\n+            exception = e;\n+            errCode = UNSUPPORTED_ENCODING;\n+        }\n+\n+        final ClientException clientException = new ClientException(\n+                errCode,\n+                exception.getMessage(),\n+                exception\n+        );\n+\n+        Logger.error(\n+                TAG,\n+                clientException.getMessage(),\n+                clientException\n+        );\n+\n+        throw clientException;\n+    }\n+\n+    @Override\n+    public boolean verify(@NonNull final String plainText, @NonNull final String signatureStr) {\n+        final String errCode;\n+        final Exception exception;\n+\n+        try {\n+            final byte[] inputBytesToVerify = plainText.getBytes(ENCODING_UTF8);\n+            final KeyStore.Entry keyEntry = mKeyStore.getEntry(KEYSTORE_ENTRY_ALIAS, null);\n+\n+            if (!(keyEntry instanceof KeyStore.PrivateKeyEntry)) {\n+                Logger.warn(\n+                        TAG + \":verify\",\n+                        PRIVATE_KEY_NOT_FOUND\n+                );\n+                return false;\n+            }\n+\n+            final Signature signature = Signature.getInstance(SHA_256_WITH_RSA);\n+            signature.initVerify(((KeyStore.PrivateKeyEntry) keyEntry).getCertificate());\n+            signature.update(inputBytesToVerify);\n+            final byte[] signatureBytes = Base64.decode(signatureStr, Base64.DEFAULT);\n+\n+            return signature.verify(signatureBytes);\n+        } catch (final UnsupportedEncodingException e) {\n+            errCode = UNSUPPORTED_ENCODING;\n+            exception = e;\n+        } catch (final NoSuchAlgorithmException e) {\n+            errCode = NO_SUCH_ALGORITHM;\n+            exception = e;\n+        } catch (final KeyStoreException e) {\n+            errCode = KEYSTORE_NOT_INITIALIZED;\n+            exception = e;\n+        } catch (final UnrecoverableEntryException e) {\n+            errCode = INVALID_PROTECTION_PARAMS;\n+            exception = e;\n+        } catch (final InvalidKeyException e) {\n+            errCode = INVALID_KEY;\n+            exception = e;\n+        } catch (final SignatureException e) {\n+            errCode = SIGNING_FAILURE;\n+            exception = e;\n+        }\n+\n+        Logger.error(\n+                TAG + \":verify\",\n+                errCode,\n+                exception\n+        );\n+\n+        return false;\n+    }\n+\n+    @Override\n+    public String getPublicKey(@NonNull final PublicKeyFormat format) throws ClientException {\n+        switch (format) {\n+            case X_509_SubjectPublicKeyInfo_ASN_1:\n+                return getX509SubjectPublicKeyInfo();\n+            case JWK:\n+                return getJwkPublicKey();\n+            default:\n+                final String errMsg = \"Unrecognized or unsupported key format: \" + format;\n+                final ClientException clientException = new ClientException(\n+                        UNKNOWN_EXPORT_FORMAT,\n+                        errMsg\n+                );\n+\n+                Logger.error(\n+                        TAG + \":getPublicKey\",\n+                        errMsg,\n+                        clientException\n+                );\n+\n+                throw clientException;\n+        }\n+    }\n+\n+    private String getJwkPublicKey() throws ClientException {\n+        final Exception exception;\n+        final String errCode;\n+\n+        try {\n+            final net.minidev.json.JSONObject jwkJson = getDevicePopJwkMinifiedJson();\n+            return jwkJson.getAsString(SignedHttpRequestJwtClaims.JWK); // TODO create a constant", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e099e46a4933667293680a3e12d8bbb08788789e"}, "originalPosition": 247}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY0MTQxNw==", "bodyText": "c113f14", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1026#discussion_r486641417", "createdAt": "2020-09-10T21:23:02Z", "author": {"login": "iambmelt"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/platform/DevicePopManager.java", "diffHunk": "@@ -441,6 +493,209 @@ public void run() {\n         });\n     }\n \n+    @Override\n+    public String sign(@NonNull final String input) throws ClientException {\n+        final Exception exception;\n+        final String errCode;\n+\n+        try {\n+            final byte[] inputBytesToSign = input.getBytes(ENCODING_UTF8);\n+            final KeyStore.Entry keyEntry = mKeyStore.getEntry(KEYSTORE_ENTRY_ALIAS, null);\n+\n+            if (!(keyEntry instanceof KeyStore.PrivateKeyEntry)) {\n+                Logger.warn(\n+                        TAG + \":sign\",\n+                        PRIVATE_KEY_NOT_FOUND\n+                );\n+                throw new ClientException(INVALID_KEY_MISSING);\n+            }\n+\n+            final Signature signature = Signature.getInstance(SHA_256_WITH_RSA);\n+            signature.initSign(((KeyStore.PrivateKeyEntry) keyEntry).getPrivateKey());\n+            signature.update(inputBytesToSign);\n+            final byte[] signedBytes = signature.sign();\n+            return Base64.encodeToString(signedBytes, Base64.DEFAULT);\n+        } catch (final KeyStoreException e) {\n+            exception = e;\n+            errCode = KEYSTORE_NOT_INITIALIZED;\n+        } catch (final NoSuchAlgorithmException e) {\n+            exception = e;\n+            errCode = NO_SUCH_ALGORITHM;\n+        } catch (final UnrecoverableEntryException e) {\n+            exception = e;\n+            errCode = INVALID_PROTECTION_PARAMS;\n+        } catch (final InvalidKeyException e) {\n+            exception = e;\n+            errCode = INVALID_KEY;\n+        } catch (final SignatureException e) {\n+            exception = e;\n+            errCode = SIGNING_FAILURE;\n+        } catch (final UnsupportedEncodingException e) {\n+            exception = e;\n+            errCode = UNSUPPORTED_ENCODING;\n+        }\n+\n+        final ClientException clientException = new ClientException(\n+                errCode,\n+                exception.getMessage(),\n+                exception\n+        );\n+\n+        Logger.error(\n+                TAG,\n+                clientException.getMessage(),\n+                clientException\n+        );\n+\n+        throw clientException;\n+    }\n+\n+    @Override\n+    public boolean verify(@NonNull final String plainText, @NonNull final String signatureStr) {\n+        final String errCode;\n+        final Exception exception;\n+\n+        try {\n+            final byte[] inputBytesToVerify = plainText.getBytes(ENCODING_UTF8);\n+            final KeyStore.Entry keyEntry = mKeyStore.getEntry(KEYSTORE_ENTRY_ALIAS, null);\n+\n+            if (!(keyEntry instanceof KeyStore.PrivateKeyEntry)) {\n+                Logger.warn(\n+                        TAG + \":verify\",\n+                        PRIVATE_KEY_NOT_FOUND\n+                );\n+                return false;\n+            }\n+\n+            final Signature signature = Signature.getInstance(SHA_256_WITH_RSA);\n+            signature.initVerify(((KeyStore.PrivateKeyEntry) keyEntry).getCertificate());\n+            signature.update(inputBytesToVerify);\n+            final byte[] signatureBytes = Base64.decode(signatureStr, Base64.DEFAULT);\n+\n+            return signature.verify(signatureBytes);\n+        } catch (final UnsupportedEncodingException e) {\n+            errCode = UNSUPPORTED_ENCODING;\n+            exception = e;\n+        } catch (final NoSuchAlgorithmException e) {\n+            errCode = NO_SUCH_ALGORITHM;\n+            exception = e;\n+        } catch (final KeyStoreException e) {\n+            errCode = KEYSTORE_NOT_INITIALIZED;\n+            exception = e;\n+        } catch (final UnrecoverableEntryException e) {\n+            errCode = INVALID_PROTECTION_PARAMS;\n+            exception = e;\n+        } catch (final InvalidKeyException e) {\n+            errCode = INVALID_KEY;\n+            exception = e;\n+        } catch (final SignatureException e) {\n+            errCode = SIGNING_FAILURE;\n+            exception = e;\n+        }\n+\n+        Logger.error(\n+                TAG + \":verify\",\n+                errCode,\n+                exception\n+        );\n+\n+        return false;\n+    }\n+\n+    @Override\n+    public String getPublicKey(@NonNull final PublicKeyFormat format) throws ClientException {\n+        switch (format) {\n+            case X_509_SubjectPublicKeyInfo_ASN_1:\n+                return getX509SubjectPublicKeyInfo();\n+            case JWK:\n+                return getJwkPublicKey();\n+            default:\n+                final String errMsg = \"Unrecognized or unsupported key format: \" + format;\n+                final ClientException clientException = new ClientException(\n+                        UNKNOWN_EXPORT_FORMAT,\n+                        errMsg\n+                );\n+\n+                Logger.error(\n+                        TAG + \":getPublicKey\",\n+                        errMsg,\n+                        clientException\n+                );\n+\n+                throw clientException;\n+        }\n+    }\n+\n+    private String getJwkPublicKey() throws ClientException {\n+        final Exception exception;\n+        final String errCode;\n+\n+        try {\n+            final net.minidev.json.JSONObject jwkJson = getDevicePopJwkMinifiedJson();\n+            return jwkJson.getAsString(SignedHttpRequestJwtClaims.JWK); // TODO create a constant", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYzNTUzMw=="}, "originalCommit": {"oid": "e099e46a4933667293680a3e12d8bbb08788789e"}, "originalPosition": 247}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NDIyMDg2OnYy", "diffSide": "RIGHT", "path": "common/src/androidTest/java/com/microsoft/identity/common/internal/platform/DevicePoPManagerSigningTests.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMjo1MzoyNlrOHQIawg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMjo1MzoyNlrOHQIawg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY3NzE4Ng==", "bodyText": "FYI Robolectric cannot be used here -- it throws Exceptions that the AndroidKeystore cannot be used. Falling back to emulator tests.....", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1026#discussion_r486677186", "createdAt": "2020-09-10T22:53:26Z", "author": {"login": "iambmelt"}, "path": "common/src/androidTest/java/com/microsoft/identity/common/internal/platform/DevicePoPManagerSigningTests.java", "diffHunk": "@@ -0,0 +1,108 @@\n+//  Copyright (c) Microsoft Corporation.\n+//  All rights reserved.\n+//\n+//  This code is licensed under the MIT License.\n+//\n+//  Permission is hereby granted, free of charge, to any person obtaining a copy\n+//  of this software and associated documentation files(the \"Software\"), to deal\n+//  in the Software without restriction, including without limitation the rights\n+//  to use, copy, modify, merge, publish, distribute, sublicense, and / or sell\n+//  copies of the Software, and to permit persons to whom the Software is\n+//  furnished to do so, subject to the following conditions :\n+//\n+//  The above copyright notice and this permission notice shall be included in\n+//  all copies or substantial portions of the Software.\n+//\n+//  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+//  THE SOFTWARE.\n+package com.microsoft.identity.common.internal.platform;\n+\n+import android.os.Build;\n+\n+import androidx.test.core.app.ApplicationProvider;\n+\n+import com.microsoft.identity.common.exception.ClientException;\n+\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+\n+import java.io.IOException;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.CertificateException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static com.microsoft.identity.common.internal.platform.DevicePopManager.SigningAlgorithms.MD5_WITH_RSA;\n+import static com.microsoft.identity.common.internal.platform.DevicePopManager.SigningAlgorithms.NONE_WITH_RSA;\n+import static com.microsoft.identity.common.internal.platform.DevicePopManager.SigningAlgorithms.SHA_256_WITH_RSA;\n+import static com.microsoft.identity.common.internal.platform.DevicePopManager.SigningAlgorithms.SHA_256_WITH_RSA_PSS;\n+import static com.microsoft.identity.common.internal.platform.DevicePopManager.SigningAlgorithms.SHA_384_WITH_RSA;\n+import static com.microsoft.identity.common.internal.platform.DevicePopManager.SigningAlgorithms.SHA_384_WITH_RSA_PSS;\n+import static com.microsoft.identity.common.internal.platform.DevicePopManager.SigningAlgorithms.SHA_512_WITH_RSA;\n+import static com.microsoft.identity.common.internal.platform.DevicePopManager.SigningAlgorithms.SHA_512_WITH_RSA_PSS;\n+\n+@RunWith(Parameterized.class)\n+public class DevicePoPManagerSigningTests {\n+\n+    private static final String DATA_TO_SIGN = \"The quick brown fox jumped over the lazy dog.\";\n+\n+    private final IDevicePopManager devicePopManager;\n+    private final String signingAlg;\n+\n+    @Parameterized.Parameters", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af0ca035a02c8d8dff1acf345dbcd1cf586bb204"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NDI1MzY3OnYy", "diffSide": "RIGHT", "path": "common/src/main/java/com/microsoft/identity/common/internal/platform/DevicePopManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMzowOToyM1rOHQIuag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMzoxNjowMFrOHQI2pw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY4MjIxOA==", "bodyText": "Update changelog", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1026#discussion_r486682218", "createdAt": "2020-09-10T23:09:23Z", "author": {"login": "iambmelt"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/platform/DevicePopManager.java", "diffHunk": "@@ -98,6 +107,37 @@\n \n     private static final String TAG = DevicePopManager.class.getSimpleName();\n \n+    /**\n+     * Signing algorithms supported by our underlying keystore. Not all algs available at all device\n+     * levels.\n+     */\n+    public static class SigningAlgorithms {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af0ca035a02c8d8dff1acf345dbcd1cf586bb204"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY4NDMyNw==", "bodyText": "12d7a01", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1026#discussion_r486684327", "createdAt": "2020-09-10T23:16:00Z", "author": {"login": "iambmelt"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/platform/DevicePopManager.java", "diffHunk": "@@ -98,6 +107,37 @@\n \n     private static final String TAG = DevicePopManager.class.getSimpleName();\n \n+    /**\n+     * Signing algorithms supported by our underlying keystore. Not all algs available at all device\n+     * levels.\n+     */\n+    public static class SigningAlgorithms {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY4MjIxOA=="}, "originalCommit": {"oid": "af0ca035a02c8d8dff1acf345dbcd1cf586bb204"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NDQ2MzkxOnYy", "diffSide": "RIGHT", "path": "common/src/main/java/com/microsoft/identity/common/internal/platform/DevicePopManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwMTowMDo0NFrOHQKolg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQyMzowOToxMFrOHSZ6AA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcxMzQ5NA==", "bodyText": "I've asked this question a lot on these - is there any reason that this can't be an enum?  You'll get compile-time safety in that case and it'll promote to an interface-level enum.  You'll have to change this code to support new algorithms that may appear, however.", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1026#discussion_r486713494", "createdAt": "2020-09-11T01:00:44Z", "author": {"login": "AdamBJohnsonx"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/platform/DevicePopManager.java", "diffHunk": "@@ -98,6 +107,37 @@\n \n     private static final String TAG = DevicePopManager.class.getSimpleName();\n \n+    /**\n+     * Signing algorithms supported by our underlying keystore. Not all algs available at all device\n+     * levels.\n+     */\n+    public static class SigningAlgorithms {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "12d7a01f595789c8926c4b009f4b173bb07322ef"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTA2MDg2NA==", "bodyText": "ef45a53", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1026#discussion_r489060864", "createdAt": "2020-09-15T23:09:10Z", "author": {"login": "iambmelt"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/platform/DevicePopManager.java", "diffHunk": "@@ -98,6 +107,37 @@\n \n     private static final String TAG = DevicePopManager.class.getSimpleName();\n \n+    /**\n+     * Signing algorithms supported by our underlying keystore. Not all algs available at all device\n+     * levels.\n+     */\n+    public static class SigningAlgorithms {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjcxMzQ5NA=="}, "originalCommit": {"oid": "12d7a01f595789c8926c4b009f4b173bb07322ef"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1OTQwNTg1OnYy", "diffSide": "RIGHT", "path": "common/src/androidTest/java/com/microsoft/identity/common/internal/platform/DevicePoPManagerTests.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQyMDo0Mjo0NlrOHSTz5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQyMDo0NzowNlrOHST8zw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk2MDk5Nw==", "bodyText": "nit: rename to testAsymmetricKeyCreationDateNullWhenUninitialized", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1026#discussion_r488960997", "createdAt": "2020-09-15T20:42:46Z", "author": {"login": "shahzaibj"}, "path": "common/src/androidTest/java/com/microsoft/identity/common/internal/platform/DevicePoPManagerTests.java", "diffHunk": "@@ -289,4 +302,60 @@ public void testMintSignedAccessTokenContainsRequisiteClaims()\n         Assert.assertEquals(nonce, jwtClaimsSet.getClaim(\"nonce\"));\n         Assert.assertNotNull(jwtClaimsSet.getClaim(\"cnf\"));\n     }\n+\n+    @Test\n+    public void testAsymmetricKeyNullWhenUninitialized() throws ClientException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c201e4f48b995f9b8a86a7e975939e30829d426"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk2MzI3OQ==", "bodyText": "See cf890e2 thanks!", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1026#discussion_r488963279", "createdAt": "2020-09-15T20:47:06Z", "author": {"login": "iambmelt"}, "path": "common/src/androidTest/java/com/microsoft/identity/common/internal/platform/DevicePoPManagerTests.java", "diffHunk": "@@ -289,4 +302,60 @@ public void testMintSignedAccessTokenContainsRequisiteClaims()\n         Assert.assertEquals(nonce, jwtClaimsSet.getClaim(\"nonce\"));\n         Assert.assertNotNull(jwtClaimsSet.getClaim(\"cnf\"));\n     }\n+\n+    @Test\n+    public void testAsymmetricKeyNullWhenUninitialized() throws ClientException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk2MDk5Nw=="}, "originalCommit": {"oid": "8c201e4f48b995f9b8a86a7e975939e30829d426"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1OTQxMzk5OnYy", "diffSide": "RIGHT", "path": "common/src/androidTest/java/com/microsoft/identity/common/internal/platform/DevicePoPManagerTests.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQyMDo0NToxMlrOHST4rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQyMzozMzozM1rOHSaysg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk2MjIyMg==", "bodyText": "What data type are these? If these are Strings, should we also assert not empty String?", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1026#discussion_r488962222", "createdAt": "2020-09-15T20:45:12Z", "author": {"login": "shahzaibj"}, "path": "common/src/androidTest/java/com/microsoft/identity/common/internal/platform/DevicePoPManagerTests.java", "diffHunk": "@@ -289,4 +302,60 @@ public void testMintSignedAccessTokenContainsRequisiteClaims()\n         Assert.assertEquals(nonce, jwtClaimsSet.getClaim(\"nonce\"));\n         Assert.assertNotNull(jwtClaimsSet.getClaim(\"cnf\"));\n     }\n+\n+    @Test\n+    public void testAsymmetricKeyNullWhenUninitialized() throws ClientException {\n+        final Date createdDate = mDevicePopManager.getAsymmetricKeyCreationDate();\n+        Assert.assertNull(createdDate);\n+    }\n+\n+    @Test\n+    public void testAsymmetricKeyHasCreationDate() throws ClientException {\n+        final Date createdDate = mDevicePopManager.getAsymmetricKeyCreationDate();\n+        Assert.assertNull(createdDate);\n+\n+        // Generate it\n+        mDevicePopManager.generateAsymmetricKey(mContext);\n+\n+        // Assert the Date exists\n+        Assert.assertNotNull(mDevicePopManager.getAsymmetricKeyCreationDate());\n+    }\n+\n+    @Test\n+    public void testAsymmetricKeyHasPublicKeyX509() throws ClientException, NoSuchAlgorithmException, InvalidKeySpecException {\n+        // Generate keys\n+        mDevicePopManager.generateAsymmetricKey(mContext);\n+\n+        // Get the public key\n+        final String publicKey = mDevicePopManager.getPublicKey(X_509_SubjectPublicKeyInfo_ASN_1);\n+\n+        // Rehydrate the certificate\n+        final byte[] bytes = Base64.decode(publicKey, Base64.DEFAULT);\n+        final KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\n+        final PublicKey pubKeyRestored = keyFactory.generatePublic(new X509EncodedKeySpec(bytes));\n+        Assert.assertEquals(\"X.509\", pubKeyRestored.getFormat());\n+    }\n+\n+    @Test\n+    public void testAsymmetricKeyHasPublicKeyJwk() throws ClientException {\n+        // Generate keys\n+        mDevicePopManager.generateAsymmetricKey(mContext);\n+\n+        // Get the public key\n+        final String publicKey = mDevicePopManager.getPublicKey(JWK);\n+\n+        // Convert it to JSON, parse to verify fields\n+        final JsonElement jwkElement = new JsonParser().parse(publicKey);\n+\n+        // Convert to JsonObject to extract claims\n+        final JsonObject jwkObj = jwkElement.getAsJsonObject();\n+\n+        // We should expect the following claims...\n+        // 'kty' - Key Type - Identifies the cryptographic alg used with this key (ex: RSA, EC)\n+        // 'e' - Public Exponent - The exponent used on signed/encoded data to decode the orig value\n+        // 'n' - Modulus - The product of two prime numbers used to generate the key pair\n+        Assert.assertNotNull(jwkObj.get(\"kty\"));\n+        Assert.assertNotNull(jwkObj.get(\"e\"));\n+        Assert.assertNotNull(jwkObj.get(\"n\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c201e4f48b995f9b8a86a7e975939e30829d426"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTA3NTM3OA==", "bodyText": "d09089b", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1026#discussion_r489075378", "createdAt": "2020-09-15T23:33:33Z", "author": {"login": "iambmelt"}, "path": "common/src/androidTest/java/com/microsoft/identity/common/internal/platform/DevicePoPManagerTests.java", "diffHunk": "@@ -289,4 +302,60 @@ public void testMintSignedAccessTokenContainsRequisiteClaims()\n         Assert.assertEquals(nonce, jwtClaimsSet.getClaim(\"nonce\"));\n         Assert.assertNotNull(jwtClaimsSet.getClaim(\"cnf\"));\n     }\n+\n+    @Test\n+    public void testAsymmetricKeyNullWhenUninitialized() throws ClientException {\n+        final Date createdDate = mDevicePopManager.getAsymmetricKeyCreationDate();\n+        Assert.assertNull(createdDate);\n+    }\n+\n+    @Test\n+    public void testAsymmetricKeyHasCreationDate() throws ClientException {\n+        final Date createdDate = mDevicePopManager.getAsymmetricKeyCreationDate();\n+        Assert.assertNull(createdDate);\n+\n+        // Generate it\n+        mDevicePopManager.generateAsymmetricKey(mContext);\n+\n+        // Assert the Date exists\n+        Assert.assertNotNull(mDevicePopManager.getAsymmetricKeyCreationDate());\n+    }\n+\n+    @Test\n+    public void testAsymmetricKeyHasPublicKeyX509() throws ClientException, NoSuchAlgorithmException, InvalidKeySpecException {\n+        // Generate keys\n+        mDevicePopManager.generateAsymmetricKey(mContext);\n+\n+        // Get the public key\n+        final String publicKey = mDevicePopManager.getPublicKey(X_509_SubjectPublicKeyInfo_ASN_1);\n+\n+        // Rehydrate the certificate\n+        final byte[] bytes = Base64.decode(publicKey, Base64.DEFAULT);\n+        final KeyFactory keyFactory = KeyFactory.getInstance(\"RSA\");\n+        final PublicKey pubKeyRestored = keyFactory.generatePublic(new X509EncodedKeySpec(bytes));\n+        Assert.assertEquals(\"X.509\", pubKeyRestored.getFormat());\n+    }\n+\n+    @Test\n+    public void testAsymmetricKeyHasPublicKeyJwk() throws ClientException {\n+        // Generate keys\n+        mDevicePopManager.generateAsymmetricKey(mContext);\n+\n+        // Get the public key\n+        final String publicKey = mDevicePopManager.getPublicKey(JWK);\n+\n+        // Convert it to JSON, parse to verify fields\n+        final JsonElement jwkElement = new JsonParser().parse(publicKey);\n+\n+        // Convert to JsonObject to extract claims\n+        final JsonObject jwkObj = jwkElement.getAsJsonObject();\n+\n+        // We should expect the following claims...\n+        // 'kty' - Key Type - Identifies the cryptographic alg used with this key (ex: RSA, EC)\n+        // 'e' - Public Exponent - The exponent used on signed/encoded data to decode the orig value\n+        // 'n' - Modulus - The product of two prime numbers used to generate the key pair\n+        Assert.assertNotNull(jwkObj.get(\"kty\"));\n+        Assert.assertNotNull(jwkObj.get(\"e\"));\n+        Assert.assertNotNull(jwkObj.get(\"n\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk2MjIyMg=="}, "originalCommit": {"oid": "8c201e4f48b995f9b8a86a7e975939e30829d426"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1OTQyMTkxOnYy", "diffSide": "RIGHT", "path": "common/src/main/java/com/microsoft/identity/common/internal/platform/DevicePopManager.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQyMDo0NzoyNVrOHST9bA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQyMzowOTo1NVrOHSZ8SA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk2MzQzNg==", "bodyText": "Could/should this be an enum?", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1026#discussion_r488963436", "createdAt": "2020-09-15T20:47:25Z", "author": {"login": "shahzaibj"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/platform/DevicePopManager.java", "diffHunk": "@@ -98,6 +107,37 @@\n \n     private static final String TAG = DevicePopManager.class.getSimpleName();\n \n+    /**\n+     * Signing algorithms supported by our underlying keystore. Not all algs available at all device\n+     * levels.\n+     */\n+    public static class SigningAlgorithms {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c201e4f48b995f9b8a86a7e975939e30829d426"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk2NjEzMg==", "bodyText": "Will leave as a string, these are as-is from the documentation and are supplied to the keystore as Strings -- that's Android's API. Having these as enums means conversion between types...(enum -> string). Since this isn't public API, I'm inclined to leave as-is\nSee:\nhttps://developer.android.com/training/articles/keystore#SupportedSignatures", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1026#discussion_r488966132", "createdAt": "2020-09-15T20:52:47Z", "author": {"login": "iambmelt"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/platform/DevicePopManager.java", "diffHunk": "@@ -98,6 +107,37 @@\n \n     private static final String TAG = DevicePopManager.class.getSimpleName();\n \n+    /**\n+     * Signing algorithms supported by our underlying keystore. Not all algs available at all device\n+     * levels.\n+     */\n+    public static class SigningAlgorithms {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk2MzQzNg=="}, "originalCommit": {"oid": "8c201e4f48b995f9b8a86a7e975939e30829d426"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk2OTA4OA==", "bodyText": "Eh.  trading a call to .name() on the enum for compile-time argument checking is fairly trivial in my experience.", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1026#discussion_r488969088", "createdAt": "2020-09-15T20:58:36Z", "author": {"login": "AdamBJohnsonx"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/platform/DevicePopManager.java", "diffHunk": "@@ -98,6 +107,37 @@\n \n     private static final String TAG = DevicePopManager.class.getSimpleName();\n \n+    /**\n+     * Signing algorithms supported by our underlying keystore. Not all algs available at all device\n+     * levels.\n+     */\n+    public static class SigningAlgorithms {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk2MzQzNg=="}, "originalCommit": {"oid": "8c201e4f48b995f9b8a86a7e975939e30829d426"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk3MDYyNg==", "bodyText": "Since this is proving to be popular feedback, I'll take this change after all", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1026#discussion_r488970626", "createdAt": "2020-09-15T21:01:37Z", "author": {"login": "iambmelt"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/platform/DevicePopManager.java", "diffHunk": "@@ -98,6 +107,37 @@\n \n     private static final String TAG = DevicePopManager.class.getSimpleName();\n \n+    /**\n+     * Signing algorithms supported by our underlying keystore. Not all algs available at all device\n+     * levels.\n+     */\n+    public static class SigningAlgorithms {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk2MzQzNg=="}, "originalCommit": {"oid": "8c201e4f48b995f9b8a86a7e975939e30829d426"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTA2MDc4MQ==", "bodyText": "ef45a53", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1026#discussion_r489060781", "createdAt": "2020-09-15T23:09:03Z", "author": {"login": "iambmelt"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/platform/DevicePopManager.java", "diffHunk": "@@ -98,6 +107,37 @@\n \n     private static final String TAG = DevicePopManager.class.getSimpleName();\n \n+    /**\n+     * Signing algorithms supported by our underlying keystore. Not all algs available at all device\n+     * levels.\n+     */\n+    public static class SigningAlgorithms {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk2MzQzNg=="}, "originalCommit": {"oid": "8c201e4f48b995f9b8a86a7e975939e30829d426"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTA2MTQ0OA==", "bodyText": "Minor note: using .toString() instead of .name() because the enum cannot contain / chars in its declaration, as is required for RSA w/ PSS", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1026#discussion_r489061448", "createdAt": "2020-09-15T23:09:55Z", "author": {"login": "iambmelt"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/platform/DevicePopManager.java", "diffHunk": "@@ -98,6 +107,37 @@\n \n     private static final String TAG = DevicePopManager.class.getSimpleName();\n \n+    /**\n+     * Signing algorithms supported by our underlying keystore. Not all algs available at all device\n+     * levels.\n+     */\n+    public static class SigningAlgorithms {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk2MzQzNg=="}, "originalCommit": {"oid": "8c201e4f48b995f9b8a86a7e975939e30829d426"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1OTQyNTczOnYy", "diffSide": "RIGHT", "path": "common/src/main/java/com/microsoft/identity/common/internal/platform/DevicePopManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQyMDo0ODozOVrOHST_rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNVQyMDo1NjoyOFrOHSUPMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk2NDAxNA==", "bodyText": "may be store :sign in a var called methodName to follow the pattern in other places", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1026#discussion_r488964014", "createdAt": "2020-09-15T20:48:39Z", "author": {"login": "shahzaibj"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/platform/DevicePopManager.java", "diffHunk": "@@ -441,6 +519,214 @@ public void run() {\n         });\n     }\n \n+    @Override\n+    public @NonNull\n+    String sign(@NonNull final String alg,\n+                @NonNull final String input) throws ClientException {\n+        final Exception exception;\n+        final String errCode;\n+\n+        try {\n+            final byte[] inputBytesToSign = input.getBytes(ENCODING_UTF8);\n+            final KeyStore.Entry keyEntry = mKeyStore.getEntry(KEYSTORE_ENTRY_ALIAS, null);\n+\n+            if (!(keyEntry instanceof KeyStore.PrivateKeyEntry)) {\n+                Logger.warn(\n+                        TAG + \":sign\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c201e4f48b995f9b8a86a7e975939e30829d426"}, "originalPosition": 154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk2Nzk4Ng==", "bodyText": "Applied in ef84e4a thanks!", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1026#discussion_r488967986", "createdAt": "2020-09-15T20:56:28Z", "author": {"login": "iambmelt"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/platform/DevicePopManager.java", "diffHunk": "@@ -441,6 +519,214 @@ public void run() {\n         });\n     }\n \n+    @Override\n+    public @NonNull\n+    String sign(@NonNull final String alg,\n+                @NonNull final String input) throws ClientException {\n+        final Exception exception;\n+        final String errCode;\n+\n+        try {\n+            final byte[] inputBytesToSign = input.getBytes(ENCODING_UTF8);\n+            final KeyStore.Entry keyEntry = mKeyStore.getEntry(KEYSTORE_ENTRY_ALIAS, null);\n+\n+            if (!(keyEntry instanceof KeyStore.PrivateKeyEntry)) {\n+                Logger.warn(\n+                        TAG + \":sign\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk2NDAxNA=="}, "originalCommit": {"oid": "8c201e4f48b995f9b8a86a7e975939e30829d426"}, "originalPosition": 154}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2254, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}