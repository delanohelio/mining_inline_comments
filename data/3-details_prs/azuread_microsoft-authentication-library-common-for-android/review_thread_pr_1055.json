{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkzMzUwODA3", "number": 1055, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQyMTozNjowM1rOEnnVnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNlQwNDo0NToyNFrOEntiOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA5OTc0NDI5OnYy", "diffSide": "RIGHT", "path": "common/src/main/java/com/microsoft/identity/common/internal/controllers/CommandDispatcher.java", "isResolved": true, "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNVQyMTozNjowM1rOHYTqSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNlQwMDo1ODo0NFrOHYaBAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI0OTk5Mw==", "bodyText": "May I ask what you meant by 'mutated' here? In what (hypothetical) scenario this might happen?", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1055#discussion_r495249993", "createdAt": "2020-09-25T21:36:03Z", "author": {"login": "rpdome"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/controllers/CommandDispatcher.java", "diffHunk": "@@ -110,48 +115,68 @@ public static void submitSilent(@SuppressWarnings(WarningType.rawtype_warning) @\n             return;\n         }\n \n+        final ResultFuture<CommandResult> finalFuture = future;\n+\n         sSilentExecutor.execute(new Runnable() {\n             @Override\n             public void run() {\n-                final String correlationId = initializeDiagnosticContext(command.getParameters().getCorrelationId());\n-\n-                // set correlation id on parameters as it may not already be set\n-                command.getParameters().setCorrelationId(correlationId);\n-\n-                EstsTelemetry.getInstance().initTelemetryForCommand(command);\n+                try {\n+                    final String correlationId = initializeDiagnosticContext(command.getParameters().getCorrelationId());\n \n-                EstsTelemetry.getInstance().emitApiId(command.getPublicApiId());\n+                    // set correlation id on parameters as it may not already be set\n+                    command.getParameters().setCorrelationId(correlationId);\n \n-                CommandResult commandResult = null;\n+                    EstsTelemetry.getInstance().initTelemetryForCommand(command);\n \n-                //Log operation parameters\n-                if (command.getParameters() instanceof SilentTokenCommandParameters) {\n-                    logSilentRequestParams(methodName, (SilentTokenCommandParameters) command.getParameters());\n-                    EstsTelemetry.getInstance().emitForceRefresh(((SilentTokenCommandParameters) command.getParameters()).isForceRefresh());\n-                }\n+                    EstsTelemetry.getInstance().emitApiId(command.getPublicApiId());\n \n-                //Check cache to see if the same command completed in the last 30 seconds\n-                commandResult = sCommandResultCache.get(command);\n+                    CommandResult commandResult = null;\n \n-                //If nothing in cache, execute the command and cache the result\n-                if (commandResult == null) {\n-                    commandResult = executeCommand(command);\n-                    cacheCommandResult(command, commandResult);\n-                } else {\n-                    Logger.info(\n-                            TAG + methodName,\n-                            \"Silent command result returned from cache.\"\n-                    );\n-                }\n+                    //Log operation parameters\n+                    if (command.getParameters() instanceof SilentTokenCommandParameters) {\n+                        logSilentRequestParams(methodName, (SilentTokenCommandParameters) command.getParameters());\n+                        EstsTelemetry.getInstance().emitForceRefresh(((SilentTokenCommandParameters) command.getParameters()).isForceRefresh());\n+                    }\n \n-                // set correlation id on Local Authentication Result\n-                setCorrelationIdOnResult(commandResult, correlationId);\n+                    //Check cache to see if the same command completed in the last 30 seconds\n+                    commandResult = sCommandResultCache.get(command);\n+\n+                    //If nothing in cache, execute the command and cache the result\n+                    if (commandResult == null) {\n+                        commandResult = executeCommand(command);\n+                        cacheCommandResult(command, commandResult);\n+                    } else {\n+                        Logger.info(\n+                                TAG + methodName,\n+                                \"Silent command result returned from cache.\"\n+                        );\n+                    }\n \n-                Telemetry.getInstance().flush(correlationId);\n-                EstsTelemetry.getInstance().flush(command, commandResult);\n+                    // set correlation id on Local Authentication Result\n+                    setCorrelationIdOnResult(commandResult, correlationId);\n \n-                //Return the result via the callback\n-                sExecutingCommandMap.remove(command).setResult(commandResult);\n+                    Telemetry.getInstance().flush(correlationId);\n+                    EstsTelemetry.getInstance().flush(command, commandResult);\n+                    finalFuture.setResult(commandResult);\n+                    //Return the result via the callback\n+                } catch (Throwable t) {\n+                    finalFuture.setException(new ExecutionException(t));\n+                } finally {\n+                    final ResultFuture mapFuture = sExecutingCommandMap.remove(command);\n+                    if (mapFuture == null) {\n+                        // If this has happened, the command that we started with has mutated.  We will", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "213855be64fce88ab7f09d920a34dbeb8cd93967"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI1MTY5NQ==", "bodyText": "If the object used as the key in the map is changed in such a way to cause it no longer to have the same value via equals/hashCode, then it will not be found in the map when we go to remove it.", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1055#discussion_r495251695", "createdAt": "2020-09-25T21:38:10Z", "author": {"login": "AdamBJohnsonx"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/controllers/CommandDispatcher.java", "diffHunk": "@@ -110,48 +115,68 @@ public static void submitSilent(@SuppressWarnings(WarningType.rawtype_warning) @\n             return;\n         }\n \n+        final ResultFuture<CommandResult> finalFuture = future;\n+\n         sSilentExecutor.execute(new Runnable() {\n             @Override\n             public void run() {\n-                final String correlationId = initializeDiagnosticContext(command.getParameters().getCorrelationId());\n-\n-                // set correlation id on parameters as it may not already be set\n-                command.getParameters().setCorrelationId(correlationId);\n-\n-                EstsTelemetry.getInstance().initTelemetryForCommand(command);\n+                try {\n+                    final String correlationId = initializeDiagnosticContext(command.getParameters().getCorrelationId());\n \n-                EstsTelemetry.getInstance().emitApiId(command.getPublicApiId());\n+                    // set correlation id on parameters as it may not already be set\n+                    command.getParameters().setCorrelationId(correlationId);\n \n-                CommandResult commandResult = null;\n+                    EstsTelemetry.getInstance().initTelemetryForCommand(command);\n \n-                //Log operation parameters\n-                if (command.getParameters() instanceof SilentTokenCommandParameters) {\n-                    logSilentRequestParams(methodName, (SilentTokenCommandParameters) command.getParameters());\n-                    EstsTelemetry.getInstance().emitForceRefresh(((SilentTokenCommandParameters) command.getParameters()).isForceRefresh());\n-                }\n+                    EstsTelemetry.getInstance().emitApiId(command.getPublicApiId());\n \n-                //Check cache to see if the same command completed in the last 30 seconds\n-                commandResult = sCommandResultCache.get(command);\n+                    CommandResult commandResult = null;\n \n-                //If nothing in cache, execute the command and cache the result\n-                if (commandResult == null) {\n-                    commandResult = executeCommand(command);\n-                    cacheCommandResult(command, commandResult);\n-                } else {\n-                    Logger.info(\n-                            TAG + methodName,\n-                            \"Silent command result returned from cache.\"\n-                    );\n-                }\n+                    //Log operation parameters\n+                    if (command.getParameters() instanceof SilentTokenCommandParameters) {\n+                        logSilentRequestParams(methodName, (SilentTokenCommandParameters) command.getParameters());\n+                        EstsTelemetry.getInstance().emitForceRefresh(((SilentTokenCommandParameters) command.getParameters()).isForceRefresh());\n+                    }\n \n-                // set correlation id on Local Authentication Result\n-                setCorrelationIdOnResult(commandResult, correlationId);\n+                    //Check cache to see if the same command completed in the last 30 seconds\n+                    commandResult = sCommandResultCache.get(command);\n+\n+                    //If nothing in cache, execute the command and cache the result\n+                    if (commandResult == null) {\n+                        commandResult = executeCommand(command);\n+                        cacheCommandResult(command, commandResult);\n+                    } else {\n+                        Logger.info(\n+                                TAG + methodName,\n+                                \"Silent command result returned from cache.\"\n+                        );\n+                    }\n \n-                Telemetry.getInstance().flush(correlationId);\n-                EstsTelemetry.getInstance().flush(command, commandResult);\n+                    // set correlation id on Local Authentication Result\n+                    setCorrelationIdOnResult(commandResult, correlationId);\n \n-                //Return the result via the callback\n-                sExecutingCommandMap.remove(command).setResult(commandResult);\n+                    Telemetry.getInstance().flush(correlationId);\n+                    EstsTelemetry.getInstance().flush(command, commandResult);\n+                    finalFuture.setResult(commandResult);\n+                    //Return the result via the callback\n+                } catch (Throwable t) {\n+                    finalFuture.setException(new ExecutionException(t));\n+                } finally {\n+                    final ResultFuture mapFuture = sExecutingCommandMap.remove(command);\n+                    if (mapFuture == null) {\n+                        // If this has happened, the command that we started with has mutated.  We will", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI0OTk5Mw=="}, "originalCommit": {"oid": "213855be64fce88ab7f09d920a34dbeb8cd93967"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI1MTcyNw==", "bodyText": "(also makes me wonder if the command object itself it a good key here)", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1055#discussion_r495251727", "createdAt": "2020-09-25T21:38:13Z", "author": {"login": "rpdome"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/controllers/CommandDispatcher.java", "diffHunk": "@@ -110,48 +115,68 @@ public static void submitSilent(@SuppressWarnings(WarningType.rawtype_warning) @\n             return;\n         }\n \n+        final ResultFuture<CommandResult> finalFuture = future;\n+\n         sSilentExecutor.execute(new Runnable() {\n             @Override\n             public void run() {\n-                final String correlationId = initializeDiagnosticContext(command.getParameters().getCorrelationId());\n-\n-                // set correlation id on parameters as it may not already be set\n-                command.getParameters().setCorrelationId(correlationId);\n-\n-                EstsTelemetry.getInstance().initTelemetryForCommand(command);\n+                try {\n+                    final String correlationId = initializeDiagnosticContext(command.getParameters().getCorrelationId());\n \n-                EstsTelemetry.getInstance().emitApiId(command.getPublicApiId());\n+                    // set correlation id on parameters as it may not already be set\n+                    command.getParameters().setCorrelationId(correlationId);\n \n-                CommandResult commandResult = null;\n+                    EstsTelemetry.getInstance().initTelemetryForCommand(command);\n \n-                //Log operation parameters\n-                if (command.getParameters() instanceof SilentTokenCommandParameters) {\n-                    logSilentRequestParams(methodName, (SilentTokenCommandParameters) command.getParameters());\n-                    EstsTelemetry.getInstance().emitForceRefresh(((SilentTokenCommandParameters) command.getParameters()).isForceRefresh());\n-                }\n+                    EstsTelemetry.getInstance().emitApiId(command.getPublicApiId());\n \n-                //Check cache to see if the same command completed in the last 30 seconds\n-                commandResult = sCommandResultCache.get(command);\n+                    CommandResult commandResult = null;\n \n-                //If nothing in cache, execute the command and cache the result\n-                if (commandResult == null) {\n-                    commandResult = executeCommand(command);\n-                    cacheCommandResult(command, commandResult);\n-                } else {\n-                    Logger.info(\n-                            TAG + methodName,\n-                            \"Silent command result returned from cache.\"\n-                    );\n-                }\n+                    //Log operation parameters\n+                    if (command.getParameters() instanceof SilentTokenCommandParameters) {\n+                        logSilentRequestParams(methodName, (SilentTokenCommandParameters) command.getParameters());\n+                        EstsTelemetry.getInstance().emitForceRefresh(((SilentTokenCommandParameters) command.getParameters()).isForceRefresh());\n+                    }\n \n-                // set correlation id on Local Authentication Result\n-                setCorrelationIdOnResult(commandResult, correlationId);\n+                    //Check cache to see if the same command completed in the last 30 seconds\n+                    commandResult = sCommandResultCache.get(command);\n+\n+                    //If nothing in cache, execute the command and cache the result\n+                    if (commandResult == null) {\n+                        commandResult = executeCommand(command);\n+                        cacheCommandResult(command, commandResult);\n+                    } else {\n+                        Logger.info(\n+                                TAG + methodName,\n+                                \"Silent command result returned from cache.\"\n+                        );\n+                    }\n \n-                Telemetry.getInstance().flush(correlationId);\n-                EstsTelemetry.getInstance().flush(command, commandResult);\n+                    // set correlation id on Local Authentication Result\n+                    setCorrelationIdOnResult(commandResult, correlationId);\n \n-                //Return the result via the callback\n-                sExecutingCommandMap.remove(command).setResult(commandResult);\n+                    Telemetry.getInstance().flush(correlationId);\n+                    EstsTelemetry.getInstance().flush(command, commandResult);\n+                    finalFuture.setResult(commandResult);\n+                    //Return the result via the callback\n+                } catch (Throwable t) {\n+                    finalFuture.setException(new ExecutionException(t));\n+                } finally {\n+                    final ResultFuture mapFuture = sExecutingCommandMap.remove(command);\n+                    if (mapFuture == null) {\n+                        // If this has happened, the command that we started with has mutated.  We will", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI0OTk5Mw=="}, "originalCommit": {"oid": "213855be64fce88ab7f09d920a34dbeb8cd93967"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI1MzY0MA==", "bodyText": "We could generate a key from the command object and remove that worry, too. It would need to be a giant unique string.", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1055#discussion_r495253640", "createdAt": "2020-09-25T21:40:39Z", "author": {"login": "AdamBJohnsonx"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/controllers/CommandDispatcher.java", "diffHunk": "@@ -110,48 +115,68 @@ public static void submitSilent(@SuppressWarnings(WarningType.rawtype_warning) @\n             return;\n         }\n \n+        final ResultFuture<CommandResult> finalFuture = future;\n+\n         sSilentExecutor.execute(new Runnable() {\n             @Override\n             public void run() {\n-                final String correlationId = initializeDiagnosticContext(command.getParameters().getCorrelationId());\n-\n-                // set correlation id on parameters as it may not already be set\n-                command.getParameters().setCorrelationId(correlationId);\n-\n-                EstsTelemetry.getInstance().initTelemetryForCommand(command);\n+                try {\n+                    final String correlationId = initializeDiagnosticContext(command.getParameters().getCorrelationId());\n \n-                EstsTelemetry.getInstance().emitApiId(command.getPublicApiId());\n+                    // set correlation id on parameters as it may not already be set\n+                    command.getParameters().setCorrelationId(correlationId);\n \n-                CommandResult commandResult = null;\n+                    EstsTelemetry.getInstance().initTelemetryForCommand(command);\n \n-                //Log operation parameters\n-                if (command.getParameters() instanceof SilentTokenCommandParameters) {\n-                    logSilentRequestParams(methodName, (SilentTokenCommandParameters) command.getParameters());\n-                    EstsTelemetry.getInstance().emitForceRefresh(((SilentTokenCommandParameters) command.getParameters()).isForceRefresh());\n-                }\n+                    EstsTelemetry.getInstance().emitApiId(command.getPublicApiId());\n \n-                //Check cache to see if the same command completed in the last 30 seconds\n-                commandResult = sCommandResultCache.get(command);\n+                    CommandResult commandResult = null;\n \n-                //If nothing in cache, execute the command and cache the result\n-                if (commandResult == null) {\n-                    commandResult = executeCommand(command);\n-                    cacheCommandResult(command, commandResult);\n-                } else {\n-                    Logger.info(\n-                            TAG + methodName,\n-                            \"Silent command result returned from cache.\"\n-                    );\n-                }\n+                    //Log operation parameters\n+                    if (command.getParameters() instanceof SilentTokenCommandParameters) {\n+                        logSilentRequestParams(methodName, (SilentTokenCommandParameters) command.getParameters());\n+                        EstsTelemetry.getInstance().emitForceRefresh(((SilentTokenCommandParameters) command.getParameters()).isForceRefresh());\n+                    }\n \n-                // set correlation id on Local Authentication Result\n-                setCorrelationIdOnResult(commandResult, correlationId);\n+                    //Check cache to see if the same command completed in the last 30 seconds\n+                    commandResult = sCommandResultCache.get(command);\n+\n+                    //If nothing in cache, execute the command and cache the result\n+                    if (commandResult == null) {\n+                        commandResult = executeCommand(command);\n+                        cacheCommandResult(command, commandResult);\n+                    } else {\n+                        Logger.info(\n+                                TAG + methodName,\n+                                \"Silent command result returned from cache.\"\n+                        );\n+                    }\n \n-                Telemetry.getInstance().flush(correlationId);\n-                EstsTelemetry.getInstance().flush(command, commandResult);\n+                    // set correlation id on Local Authentication Result\n+                    setCorrelationIdOnResult(commandResult, correlationId);\n \n-                //Return the result via the callback\n-                sExecutingCommandMap.remove(command).setResult(commandResult);\n+                    Telemetry.getInstance().flush(correlationId);\n+                    EstsTelemetry.getInstance().flush(command, commandResult);\n+                    finalFuture.setResult(commandResult);\n+                    //Return the result via the callback\n+                } catch (Throwable t) {\n+                    finalFuture.setException(new ExecutionException(t));\n+                } finally {\n+                    final ResultFuture mapFuture = sExecutingCommandMap.remove(command);\n+                    if (mapFuture == null) {\n+                        // If this has happened, the command that we started with has mutated.  We will", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI0OTk5Mw=="}, "originalCommit": {"oid": "213855be64fce88ab7f09d920a34dbeb8cd93967"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI1NjQ1OA==", "bodyText": "Did we find anything (so far) within the command that could change during execution?", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1055#discussion_r495256458", "createdAt": "2020-09-25T21:45:06Z", "author": {"login": "shahzaibj"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/controllers/CommandDispatcher.java", "diffHunk": "@@ -110,48 +115,68 @@ public static void submitSilent(@SuppressWarnings(WarningType.rawtype_warning) @\n             return;\n         }\n \n+        final ResultFuture<CommandResult> finalFuture = future;\n+\n         sSilentExecutor.execute(new Runnable() {\n             @Override\n             public void run() {\n-                final String correlationId = initializeDiagnosticContext(command.getParameters().getCorrelationId());\n-\n-                // set correlation id on parameters as it may not already be set\n-                command.getParameters().setCorrelationId(correlationId);\n-\n-                EstsTelemetry.getInstance().initTelemetryForCommand(command);\n+                try {\n+                    final String correlationId = initializeDiagnosticContext(command.getParameters().getCorrelationId());\n \n-                EstsTelemetry.getInstance().emitApiId(command.getPublicApiId());\n+                    // set correlation id on parameters as it may not already be set\n+                    command.getParameters().setCorrelationId(correlationId);\n \n-                CommandResult commandResult = null;\n+                    EstsTelemetry.getInstance().initTelemetryForCommand(command);\n \n-                //Log operation parameters\n-                if (command.getParameters() instanceof SilentTokenCommandParameters) {\n-                    logSilentRequestParams(methodName, (SilentTokenCommandParameters) command.getParameters());\n-                    EstsTelemetry.getInstance().emitForceRefresh(((SilentTokenCommandParameters) command.getParameters()).isForceRefresh());\n-                }\n+                    EstsTelemetry.getInstance().emitApiId(command.getPublicApiId());\n \n-                //Check cache to see if the same command completed in the last 30 seconds\n-                commandResult = sCommandResultCache.get(command);\n+                    CommandResult commandResult = null;\n \n-                //If nothing in cache, execute the command and cache the result\n-                if (commandResult == null) {\n-                    commandResult = executeCommand(command);\n-                    cacheCommandResult(command, commandResult);\n-                } else {\n-                    Logger.info(\n-                            TAG + methodName,\n-                            \"Silent command result returned from cache.\"\n-                    );\n-                }\n+                    //Log operation parameters\n+                    if (command.getParameters() instanceof SilentTokenCommandParameters) {\n+                        logSilentRequestParams(methodName, (SilentTokenCommandParameters) command.getParameters());\n+                        EstsTelemetry.getInstance().emitForceRefresh(((SilentTokenCommandParameters) command.getParameters()).isForceRefresh());\n+                    }\n \n-                // set correlation id on Local Authentication Result\n-                setCorrelationIdOnResult(commandResult, correlationId);\n+                    //Check cache to see if the same command completed in the last 30 seconds\n+                    commandResult = sCommandResultCache.get(command);\n+\n+                    //If nothing in cache, execute the command and cache the result\n+                    if (commandResult == null) {\n+                        commandResult = executeCommand(command);\n+                        cacheCommandResult(command, commandResult);\n+                    } else {\n+                        Logger.info(\n+                                TAG + methodName,\n+                                \"Silent command result returned from cache.\"\n+                        );\n+                    }\n \n-                Telemetry.getInstance().flush(correlationId);\n-                EstsTelemetry.getInstance().flush(command, commandResult);\n+                    // set correlation id on Local Authentication Result\n+                    setCorrelationIdOnResult(commandResult, correlationId);\n \n-                //Return the result via the callback\n-                sExecutingCommandMap.remove(command).setResult(commandResult);\n+                    Telemetry.getInstance().flush(correlationId);\n+                    EstsTelemetry.getInstance().flush(command, commandResult);\n+                    finalFuture.setResult(commandResult);\n+                    //Return the result via the callback\n+                } catch (Throwable t) {\n+                    finalFuture.setException(new ExecutionException(t));\n+                } finally {\n+                    final ResultFuture mapFuture = sExecutingCommandMap.remove(command);\n+                    if (mapFuture == null) {\n+                        // If this has happened, the command that we started with has mutated.  We will", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI0OTk5Mw=="}, "originalCommit": {"oid": "213855be64fce88ab7f09d920a34dbeb8cd93967"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI1NjkzMg==", "bodyText": "That might be better, but I think that'll be big-ish and for now this fix should prevent NPE in the meantime. Let's put a todo here and create a tracking work item maybe?", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1055#discussion_r495256932", "createdAt": "2020-09-25T21:45:51Z", "author": {"login": "rpdome"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/controllers/CommandDispatcher.java", "diffHunk": "@@ -110,48 +115,68 @@ public static void submitSilent(@SuppressWarnings(WarningType.rawtype_warning) @\n             return;\n         }\n \n+        final ResultFuture<CommandResult> finalFuture = future;\n+\n         sSilentExecutor.execute(new Runnable() {\n             @Override\n             public void run() {\n-                final String correlationId = initializeDiagnosticContext(command.getParameters().getCorrelationId());\n-\n-                // set correlation id on parameters as it may not already be set\n-                command.getParameters().setCorrelationId(correlationId);\n-\n-                EstsTelemetry.getInstance().initTelemetryForCommand(command);\n+                try {\n+                    final String correlationId = initializeDiagnosticContext(command.getParameters().getCorrelationId());\n \n-                EstsTelemetry.getInstance().emitApiId(command.getPublicApiId());\n+                    // set correlation id on parameters as it may not already be set\n+                    command.getParameters().setCorrelationId(correlationId);\n \n-                CommandResult commandResult = null;\n+                    EstsTelemetry.getInstance().initTelemetryForCommand(command);\n \n-                //Log operation parameters\n-                if (command.getParameters() instanceof SilentTokenCommandParameters) {\n-                    logSilentRequestParams(methodName, (SilentTokenCommandParameters) command.getParameters());\n-                    EstsTelemetry.getInstance().emitForceRefresh(((SilentTokenCommandParameters) command.getParameters()).isForceRefresh());\n-                }\n+                    EstsTelemetry.getInstance().emitApiId(command.getPublicApiId());\n \n-                //Check cache to see if the same command completed in the last 30 seconds\n-                commandResult = sCommandResultCache.get(command);\n+                    CommandResult commandResult = null;\n \n-                //If nothing in cache, execute the command and cache the result\n-                if (commandResult == null) {\n-                    commandResult = executeCommand(command);\n-                    cacheCommandResult(command, commandResult);\n-                } else {\n-                    Logger.info(\n-                            TAG + methodName,\n-                            \"Silent command result returned from cache.\"\n-                    );\n-                }\n+                    //Log operation parameters\n+                    if (command.getParameters() instanceof SilentTokenCommandParameters) {\n+                        logSilentRequestParams(methodName, (SilentTokenCommandParameters) command.getParameters());\n+                        EstsTelemetry.getInstance().emitForceRefresh(((SilentTokenCommandParameters) command.getParameters()).isForceRefresh());\n+                    }\n \n-                // set correlation id on Local Authentication Result\n-                setCorrelationIdOnResult(commandResult, correlationId);\n+                    //Check cache to see if the same command completed in the last 30 seconds\n+                    commandResult = sCommandResultCache.get(command);\n+\n+                    //If nothing in cache, execute the command and cache the result\n+                    if (commandResult == null) {\n+                        commandResult = executeCommand(command);\n+                        cacheCommandResult(command, commandResult);\n+                    } else {\n+                        Logger.info(\n+                                TAG + methodName,\n+                                \"Silent command result returned from cache.\"\n+                        );\n+                    }\n \n-                Telemetry.getInstance().flush(correlationId);\n-                EstsTelemetry.getInstance().flush(command, commandResult);\n+                    // set correlation id on Local Authentication Result\n+                    setCorrelationIdOnResult(commandResult, correlationId);\n \n-                //Return the result via the callback\n-                sExecutingCommandMap.remove(command).setResult(commandResult);\n+                    Telemetry.getInstance().flush(correlationId);\n+                    EstsTelemetry.getInstance().flush(command, commandResult);\n+                    finalFuture.setResult(commandResult);\n+                    //Return the result via the callback\n+                } catch (Throwable t) {\n+                    finalFuture.setException(new ExecutionException(t));\n+                } finally {\n+                    final ResultFuture mapFuture = sExecutingCommandMap.remove(command);\n+                    if (mapFuture == null) {\n+                        // If this has happened, the command that we started with has mutated.  We will", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI0OTk5Mw=="}, "originalCommit": {"oid": "213855be64fce88ab7f09d920a34dbeb8cd93967"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI1OTI0MA==", "bodyText": "Did we find anything (so far) within the command that could change during execution?\n\nNothing obvious.  If you look at the other CR, I put a bunch of safe-copy in place where I found it, but the scope is huge.  The thing with this is that it should be safe even if we write bugs into it, and that's really best.\nEDIT: I guess it's all in here, too/", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1055#discussion_r495259240", "createdAt": "2020-09-25T21:49:06Z", "author": {"login": "AdamBJohnsonx"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/controllers/CommandDispatcher.java", "diffHunk": "@@ -110,48 +115,68 @@ public static void submitSilent(@SuppressWarnings(WarningType.rawtype_warning) @\n             return;\n         }\n \n+        final ResultFuture<CommandResult> finalFuture = future;\n+\n         sSilentExecutor.execute(new Runnable() {\n             @Override\n             public void run() {\n-                final String correlationId = initializeDiagnosticContext(command.getParameters().getCorrelationId());\n-\n-                // set correlation id on parameters as it may not already be set\n-                command.getParameters().setCorrelationId(correlationId);\n-\n-                EstsTelemetry.getInstance().initTelemetryForCommand(command);\n+                try {\n+                    final String correlationId = initializeDiagnosticContext(command.getParameters().getCorrelationId());\n \n-                EstsTelemetry.getInstance().emitApiId(command.getPublicApiId());\n+                    // set correlation id on parameters as it may not already be set\n+                    command.getParameters().setCorrelationId(correlationId);\n \n-                CommandResult commandResult = null;\n+                    EstsTelemetry.getInstance().initTelemetryForCommand(command);\n \n-                //Log operation parameters\n-                if (command.getParameters() instanceof SilentTokenCommandParameters) {\n-                    logSilentRequestParams(methodName, (SilentTokenCommandParameters) command.getParameters());\n-                    EstsTelemetry.getInstance().emitForceRefresh(((SilentTokenCommandParameters) command.getParameters()).isForceRefresh());\n-                }\n+                    EstsTelemetry.getInstance().emitApiId(command.getPublicApiId());\n \n-                //Check cache to see if the same command completed in the last 30 seconds\n-                commandResult = sCommandResultCache.get(command);\n+                    CommandResult commandResult = null;\n \n-                //If nothing in cache, execute the command and cache the result\n-                if (commandResult == null) {\n-                    commandResult = executeCommand(command);\n-                    cacheCommandResult(command, commandResult);\n-                } else {\n-                    Logger.info(\n-                            TAG + methodName,\n-                            \"Silent command result returned from cache.\"\n-                    );\n-                }\n+                    //Log operation parameters\n+                    if (command.getParameters() instanceof SilentTokenCommandParameters) {\n+                        logSilentRequestParams(methodName, (SilentTokenCommandParameters) command.getParameters());\n+                        EstsTelemetry.getInstance().emitForceRefresh(((SilentTokenCommandParameters) command.getParameters()).isForceRefresh());\n+                    }\n \n-                // set correlation id on Local Authentication Result\n-                setCorrelationIdOnResult(commandResult, correlationId);\n+                    //Check cache to see if the same command completed in the last 30 seconds\n+                    commandResult = sCommandResultCache.get(command);\n+\n+                    //If nothing in cache, execute the command and cache the result\n+                    if (commandResult == null) {\n+                        commandResult = executeCommand(command);\n+                        cacheCommandResult(command, commandResult);\n+                    } else {\n+                        Logger.info(\n+                                TAG + methodName,\n+                                \"Silent command result returned from cache.\"\n+                        );\n+                    }\n \n-                Telemetry.getInstance().flush(correlationId);\n-                EstsTelemetry.getInstance().flush(command, commandResult);\n+                    // set correlation id on Local Authentication Result\n+                    setCorrelationIdOnResult(commandResult, correlationId);\n \n-                //Return the result via the callback\n-                sExecutingCommandMap.remove(command).setResult(commandResult);\n+                    Telemetry.getInstance().flush(correlationId);\n+                    EstsTelemetry.getInstance().flush(command, commandResult);\n+                    finalFuture.setResult(commandResult);\n+                    //Return the result via the callback\n+                } catch (Throwable t) {\n+                    finalFuture.setException(new ExecutionException(t));\n+                } finally {\n+                    final ResultFuture mapFuture = sExecutingCommandMap.remove(command);\n+                    if (mapFuture == null) {\n+                        // If this has happened, the command that we started with has mutated.  We will", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI0OTk5Mw=="}, "originalCommit": {"oid": "213855be64fce88ab7f09d920a34dbeb8cd93967"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI1OTY1Mg==", "bodyText": "Yup, agreed!", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1055#discussion_r495259652", "createdAt": "2020-09-25T21:49:39Z", "author": {"login": "shahzaibj"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/controllers/CommandDispatcher.java", "diffHunk": "@@ -110,48 +115,68 @@ public static void submitSilent(@SuppressWarnings(WarningType.rawtype_warning) @\n             return;\n         }\n \n+        final ResultFuture<CommandResult> finalFuture = future;\n+\n         sSilentExecutor.execute(new Runnable() {\n             @Override\n             public void run() {\n-                final String correlationId = initializeDiagnosticContext(command.getParameters().getCorrelationId());\n-\n-                // set correlation id on parameters as it may not already be set\n-                command.getParameters().setCorrelationId(correlationId);\n-\n-                EstsTelemetry.getInstance().initTelemetryForCommand(command);\n+                try {\n+                    final String correlationId = initializeDiagnosticContext(command.getParameters().getCorrelationId());\n \n-                EstsTelemetry.getInstance().emitApiId(command.getPublicApiId());\n+                    // set correlation id on parameters as it may not already be set\n+                    command.getParameters().setCorrelationId(correlationId);\n \n-                CommandResult commandResult = null;\n+                    EstsTelemetry.getInstance().initTelemetryForCommand(command);\n \n-                //Log operation parameters\n-                if (command.getParameters() instanceof SilentTokenCommandParameters) {\n-                    logSilentRequestParams(methodName, (SilentTokenCommandParameters) command.getParameters());\n-                    EstsTelemetry.getInstance().emitForceRefresh(((SilentTokenCommandParameters) command.getParameters()).isForceRefresh());\n-                }\n+                    EstsTelemetry.getInstance().emitApiId(command.getPublicApiId());\n \n-                //Check cache to see if the same command completed in the last 30 seconds\n-                commandResult = sCommandResultCache.get(command);\n+                    CommandResult commandResult = null;\n \n-                //If nothing in cache, execute the command and cache the result\n-                if (commandResult == null) {\n-                    commandResult = executeCommand(command);\n-                    cacheCommandResult(command, commandResult);\n-                } else {\n-                    Logger.info(\n-                            TAG + methodName,\n-                            \"Silent command result returned from cache.\"\n-                    );\n-                }\n+                    //Log operation parameters\n+                    if (command.getParameters() instanceof SilentTokenCommandParameters) {\n+                        logSilentRequestParams(methodName, (SilentTokenCommandParameters) command.getParameters());\n+                        EstsTelemetry.getInstance().emitForceRefresh(((SilentTokenCommandParameters) command.getParameters()).isForceRefresh());\n+                    }\n \n-                // set correlation id on Local Authentication Result\n-                setCorrelationIdOnResult(commandResult, correlationId);\n+                    //Check cache to see if the same command completed in the last 30 seconds\n+                    commandResult = sCommandResultCache.get(command);\n+\n+                    //If nothing in cache, execute the command and cache the result\n+                    if (commandResult == null) {\n+                        commandResult = executeCommand(command);\n+                        cacheCommandResult(command, commandResult);\n+                    } else {\n+                        Logger.info(\n+                                TAG + methodName,\n+                                \"Silent command result returned from cache.\"\n+                        );\n+                    }\n \n-                Telemetry.getInstance().flush(correlationId);\n-                EstsTelemetry.getInstance().flush(command, commandResult);\n+                    // set correlation id on Local Authentication Result\n+                    setCorrelationIdOnResult(commandResult, correlationId);\n \n-                //Return the result via the callback\n-                sExecutingCommandMap.remove(command).setResult(commandResult);\n+                    Telemetry.getInstance().flush(correlationId);\n+                    EstsTelemetry.getInstance().flush(command, commandResult);\n+                    finalFuture.setResult(commandResult);\n+                    //Return the result via the callback\n+                } catch (Throwable t) {\n+                    finalFuture.setException(new ExecutionException(t));\n+                } finally {\n+                    final ResultFuture mapFuture = sExecutingCommandMap.remove(command);\n+                    if (mapFuture == null) {\n+                        // If this has happened, the command that we started with has mutated.  We will", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI0OTk5Mw=="}, "originalCommit": {"oid": "213855be64fce88ab7f09d920a34dbeb8cd93967"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI2MTAyNQ==", "bodyText": "I'm actually going to wait on this until we have a unit test.  Brian and I are both trying to write some so there are more eyes on it.", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1055#discussion_r495261025", "createdAt": "2020-09-25T21:51:26Z", "author": {"login": "AdamBJohnsonx"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/controllers/CommandDispatcher.java", "diffHunk": "@@ -110,48 +115,68 @@ public static void submitSilent(@SuppressWarnings(WarningType.rawtype_warning) @\n             return;\n         }\n \n+        final ResultFuture<CommandResult> finalFuture = future;\n+\n         sSilentExecutor.execute(new Runnable() {\n             @Override\n             public void run() {\n-                final String correlationId = initializeDiagnosticContext(command.getParameters().getCorrelationId());\n-\n-                // set correlation id on parameters as it may not already be set\n-                command.getParameters().setCorrelationId(correlationId);\n-\n-                EstsTelemetry.getInstance().initTelemetryForCommand(command);\n+                try {\n+                    final String correlationId = initializeDiagnosticContext(command.getParameters().getCorrelationId());\n \n-                EstsTelemetry.getInstance().emitApiId(command.getPublicApiId());\n+                    // set correlation id on parameters as it may not already be set\n+                    command.getParameters().setCorrelationId(correlationId);\n \n-                CommandResult commandResult = null;\n+                    EstsTelemetry.getInstance().initTelemetryForCommand(command);\n \n-                //Log operation parameters\n-                if (command.getParameters() instanceof SilentTokenCommandParameters) {\n-                    logSilentRequestParams(methodName, (SilentTokenCommandParameters) command.getParameters());\n-                    EstsTelemetry.getInstance().emitForceRefresh(((SilentTokenCommandParameters) command.getParameters()).isForceRefresh());\n-                }\n+                    EstsTelemetry.getInstance().emitApiId(command.getPublicApiId());\n \n-                //Check cache to see if the same command completed in the last 30 seconds\n-                commandResult = sCommandResultCache.get(command);\n+                    CommandResult commandResult = null;\n \n-                //If nothing in cache, execute the command and cache the result\n-                if (commandResult == null) {\n-                    commandResult = executeCommand(command);\n-                    cacheCommandResult(command, commandResult);\n-                } else {\n-                    Logger.info(\n-                            TAG + methodName,\n-                            \"Silent command result returned from cache.\"\n-                    );\n-                }\n+                    //Log operation parameters\n+                    if (command.getParameters() instanceof SilentTokenCommandParameters) {\n+                        logSilentRequestParams(methodName, (SilentTokenCommandParameters) command.getParameters());\n+                        EstsTelemetry.getInstance().emitForceRefresh(((SilentTokenCommandParameters) command.getParameters()).isForceRefresh());\n+                    }\n \n-                // set correlation id on Local Authentication Result\n-                setCorrelationIdOnResult(commandResult, correlationId);\n+                    //Check cache to see if the same command completed in the last 30 seconds\n+                    commandResult = sCommandResultCache.get(command);\n+\n+                    //If nothing in cache, execute the command and cache the result\n+                    if (commandResult == null) {\n+                        commandResult = executeCommand(command);\n+                        cacheCommandResult(command, commandResult);\n+                    } else {\n+                        Logger.info(\n+                                TAG + methodName,\n+                                \"Silent command result returned from cache.\"\n+                        );\n+                    }\n \n-                Telemetry.getInstance().flush(correlationId);\n-                EstsTelemetry.getInstance().flush(command, commandResult);\n+                    // set correlation id on Local Authentication Result\n+                    setCorrelationIdOnResult(commandResult, correlationId);\n \n-                //Return the result via the callback\n-                sExecutingCommandMap.remove(command).setResult(commandResult);\n+                    Telemetry.getInstance().flush(correlationId);\n+                    EstsTelemetry.getInstance().flush(command, commandResult);\n+                    finalFuture.setResult(commandResult);\n+                    //Return the result via the callback\n+                } catch (Throwable t) {\n+                    finalFuture.setException(new ExecutionException(t));\n+                } finally {\n+                    final ResultFuture mapFuture = sExecutingCommandMap.remove(command);\n+                    if (mapFuture == null) {\n+                        // If this has happened, the command that we started with has mutated.  We will", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI0OTk5Mw=="}, "originalCommit": {"oid": "213855be64fce88ab7f09d920a34dbeb8cd93967"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI2MTQzNg==", "bodyText": "And if anybody else wants to play this game, more different viewpoints are better.", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1055#discussion_r495261436", "createdAt": "2020-09-25T21:52:04Z", "author": {"login": "AdamBJohnsonx"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/controllers/CommandDispatcher.java", "diffHunk": "@@ -110,48 +115,68 @@ public static void submitSilent(@SuppressWarnings(WarningType.rawtype_warning) @\n             return;\n         }\n \n+        final ResultFuture<CommandResult> finalFuture = future;\n+\n         sSilentExecutor.execute(new Runnable() {\n             @Override\n             public void run() {\n-                final String correlationId = initializeDiagnosticContext(command.getParameters().getCorrelationId());\n-\n-                // set correlation id on parameters as it may not already be set\n-                command.getParameters().setCorrelationId(correlationId);\n-\n-                EstsTelemetry.getInstance().initTelemetryForCommand(command);\n+                try {\n+                    final String correlationId = initializeDiagnosticContext(command.getParameters().getCorrelationId());\n \n-                EstsTelemetry.getInstance().emitApiId(command.getPublicApiId());\n+                    // set correlation id on parameters as it may not already be set\n+                    command.getParameters().setCorrelationId(correlationId);\n \n-                CommandResult commandResult = null;\n+                    EstsTelemetry.getInstance().initTelemetryForCommand(command);\n \n-                //Log operation parameters\n-                if (command.getParameters() instanceof SilentTokenCommandParameters) {\n-                    logSilentRequestParams(methodName, (SilentTokenCommandParameters) command.getParameters());\n-                    EstsTelemetry.getInstance().emitForceRefresh(((SilentTokenCommandParameters) command.getParameters()).isForceRefresh());\n-                }\n+                    EstsTelemetry.getInstance().emitApiId(command.getPublicApiId());\n \n-                //Check cache to see if the same command completed in the last 30 seconds\n-                commandResult = sCommandResultCache.get(command);\n+                    CommandResult commandResult = null;\n \n-                //If nothing in cache, execute the command and cache the result\n-                if (commandResult == null) {\n-                    commandResult = executeCommand(command);\n-                    cacheCommandResult(command, commandResult);\n-                } else {\n-                    Logger.info(\n-                            TAG + methodName,\n-                            \"Silent command result returned from cache.\"\n-                    );\n-                }\n+                    //Log operation parameters\n+                    if (command.getParameters() instanceof SilentTokenCommandParameters) {\n+                        logSilentRequestParams(methodName, (SilentTokenCommandParameters) command.getParameters());\n+                        EstsTelemetry.getInstance().emitForceRefresh(((SilentTokenCommandParameters) command.getParameters()).isForceRefresh());\n+                    }\n \n-                // set correlation id on Local Authentication Result\n-                setCorrelationIdOnResult(commandResult, correlationId);\n+                    //Check cache to see if the same command completed in the last 30 seconds\n+                    commandResult = sCommandResultCache.get(command);\n+\n+                    //If nothing in cache, execute the command and cache the result\n+                    if (commandResult == null) {\n+                        commandResult = executeCommand(command);\n+                        cacheCommandResult(command, commandResult);\n+                    } else {\n+                        Logger.info(\n+                                TAG + methodName,\n+                                \"Silent command result returned from cache.\"\n+                        );\n+                    }\n \n-                Telemetry.getInstance().flush(correlationId);\n-                EstsTelemetry.getInstance().flush(command, commandResult);\n+                    // set correlation id on Local Authentication Result\n+                    setCorrelationIdOnResult(commandResult, correlationId);\n \n-                //Return the result via the callback\n-                sExecutingCommandMap.remove(command).setResult(commandResult);\n+                    Telemetry.getInstance().flush(correlationId);\n+                    EstsTelemetry.getInstance().flush(command, commandResult);\n+                    finalFuture.setResult(commandResult);\n+                    //Return the result via the callback\n+                } catch (Throwable t) {\n+                    finalFuture.setException(new ExecutionException(t));\n+                } finally {\n+                    final ResultFuture mapFuture = sExecutingCommandMap.remove(command);\n+                    if (mapFuture == null) {\n+                        // If this has happened, the command that we started with has mutated.  We will", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI0OTk5Mw=="}, "originalCommit": {"oid": "213855be64fce88ab7f09d920a34dbeb8cd93967"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTM1NDExMg==", "bodyText": "Brian and I have added some tests.  I've put the todo item in place.", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1055#discussion_r495354112", "createdAt": "2020-09-26T00:58:44Z", "author": {"login": "AdamBJohnsonx"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/controllers/CommandDispatcher.java", "diffHunk": "@@ -110,48 +115,68 @@ public static void submitSilent(@SuppressWarnings(WarningType.rawtype_warning) @\n             return;\n         }\n \n+        final ResultFuture<CommandResult> finalFuture = future;\n+\n         sSilentExecutor.execute(new Runnable() {\n             @Override\n             public void run() {\n-                final String correlationId = initializeDiagnosticContext(command.getParameters().getCorrelationId());\n-\n-                // set correlation id on parameters as it may not already be set\n-                command.getParameters().setCorrelationId(correlationId);\n-\n-                EstsTelemetry.getInstance().initTelemetryForCommand(command);\n+                try {\n+                    final String correlationId = initializeDiagnosticContext(command.getParameters().getCorrelationId());\n \n-                EstsTelemetry.getInstance().emitApiId(command.getPublicApiId());\n+                    // set correlation id on parameters as it may not already be set\n+                    command.getParameters().setCorrelationId(correlationId);\n \n-                CommandResult commandResult = null;\n+                    EstsTelemetry.getInstance().initTelemetryForCommand(command);\n \n-                //Log operation parameters\n-                if (command.getParameters() instanceof SilentTokenCommandParameters) {\n-                    logSilentRequestParams(methodName, (SilentTokenCommandParameters) command.getParameters());\n-                    EstsTelemetry.getInstance().emitForceRefresh(((SilentTokenCommandParameters) command.getParameters()).isForceRefresh());\n-                }\n+                    EstsTelemetry.getInstance().emitApiId(command.getPublicApiId());\n \n-                //Check cache to see if the same command completed in the last 30 seconds\n-                commandResult = sCommandResultCache.get(command);\n+                    CommandResult commandResult = null;\n \n-                //If nothing in cache, execute the command and cache the result\n-                if (commandResult == null) {\n-                    commandResult = executeCommand(command);\n-                    cacheCommandResult(command, commandResult);\n-                } else {\n-                    Logger.info(\n-                            TAG + methodName,\n-                            \"Silent command result returned from cache.\"\n-                    );\n-                }\n+                    //Log operation parameters\n+                    if (command.getParameters() instanceof SilentTokenCommandParameters) {\n+                        logSilentRequestParams(methodName, (SilentTokenCommandParameters) command.getParameters());\n+                        EstsTelemetry.getInstance().emitForceRefresh(((SilentTokenCommandParameters) command.getParameters()).isForceRefresh());\n+                    }\n \n-                // set correlation id on Local Authentication Result\n-                setCorrelationIdOnResult(commandResult, correlationId);\n+                    //Check cache to see if the same command completed in the last 30 seconds\n+                    commandResult = sCommandResultCache.get(command);\n+\n+                    //If nothing in cache, execute the command and cache the result\n+                    if (commandResult == null) {\n+                        commandResult = executeCommand(command);\n+                        cacheCommandResult(command, commandResult);\n+                    } else {\n+                        Logger.info(\n+                                TAG + methodName,\n+                                \"Silent command result returned from cache.\"\n+                        );\n+                    }\n \n-                Telemetry.getInstance().flush(correlationId);\n-                EstsTelemetry.getInstance().flush(command, commandResult);\n+                    // set correlation id on Local Authentication Result\n+                    setCorrelationIdOnResult(commandResult, correlationId);\n \n-                //Return the result via the callback\n-                sExecutingCommandMap.remove(command).setResult(commandResult);\n+                    Telemetry.getInstance().flush(correlationId);\n+                    EstsTelemetry.getInstance().flush(command, commandResult);\n+                    finalFuture.setResult(commandResult);\n+                    //Return the result via the callback\n+                } catch (Throwable t) {\n+                    finalFuture.setException(new ExecutionException(t));\n+                } finally {\n+                    final ResultFuture mapFuture = sExecutingCommandMap.remove(command);\n+                    if (mapFuture == null) {\n+                        // If this has happened, the command that we started with has mutated.  We will", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI0OTk5Mw=="}, "originalCommit": {"oid": "213855be64fce88ab7f09d920a34dbeb8cd93967"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwMDM1ODkzOnYy", "diffSide": "RIGHT", "path": "common/src/main/java/com/microsoft/identity/common/internal/controllers/CommandDispatcher.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNlQwMDo1MjowM1rOHYZ2RA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNlQwMDo1MzoxOFrOHYZ4gw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTM1MTM2NA==", "bodyText": "Can we javadoc why this function is required? Otherwise not apparent to those who didn't debug this \ud83d\ude04", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1055#discussion_r495351364", "createdAt": "2020-09-26T00:52:03Z", "author": {"login": "iambmelt"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/controllers/CommandDispatcher.java", "diffHunk": "@@ -74,12 +78,31 @@\n     private static final Object sLock = new Object();\n     private static InteractiveTokenCommand sCommand = null;\n     private static final CommandResultCache sCommandResultCache = new CommandResultCache();\n+\n+    private static final Object mapAccessLock = new Object();\n+    @GuardedBy(\"mapAccessLock\")\n     // Suppressing rawtype warnings due to the generic type BaseCommand\n     @SuppressWarnings(WarningType.rawtype_warning)\n-    private static final ConcurrentMap<BaseCommand, ResultFuture<CommandResult>> sExecutingCommandMap = new ConcurrentHashMap<>();\n+    private static ConcurrentMap<BaseCommand, ResultFuture<CommandResult>> sExecutingCommandMap = new ConcurrentHashMap<>();\n+\n+    /**\n+     * MUST be executed under the mapAccessLock;\n+     * @param command\n+     */\n+    // Suppressing rawtype warnings due to the generic type BaseCommand\n+    @SuppressWarnings(WarningType.rawtype_warning)\n+    private static void cleanMap(BaseCommand command) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1954af37c469f25f6d410101126778770624d06e"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTM1MTkzOQ==", "bodyText": "6d73792", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1055#discussion_r495351939", "createdAt": "2020-09-26T00:53:18Z", "author": {"login": "iambmelt"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/controllers/CommandDispatcher.java", "diffHunk": "@@ -74,12 +78,31 @@\n     private static final Object sLock = new Object();\n     private static InteractiveTokenCommand sCommand = null;\n     private static final CommandResultCache sCommandResultCache = new CommandResultCache();\n+\n+    private static final Object mapAccessLock = new Object();\n+    @GuardedBy(\"mapAccessLock\")\n     // Suppressing rawtype warnings due to the generic type BaseCommand\n     @SuppressWarnings(WarningType.rawtype_warning)\n-    private static final ConcurrentMap<BaseCommand, ResultFuture<CommandResult>> sExecutingCommandMap = new ConcurrentHashMap<>();\n+    private static ConcurrentMap<BaseCommand, ResultFuture<CommandResult>> sExecutingCommandMap = new ConcurrentHashMap<>();\n+\n+    /**\n+     * MUST be executed under the mapAccessLock;\n+     * @param command\n+     */\n+    // Suppressing rawtype warnings due to the generic type BaseCommand\n+    @SuppressWarnings(WarningType.rawtype_warning)\n+    private static void cleanMap(BaseCommand command) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTM1MTM2NA=="}, "originalCommit": {"oid": "1954af37c469f25f6d410101126778770624d06e"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwMDc1OTYwOnYy", "diffSide": "RIGHT", "path": "common/src/main/java/com/microsoft/identity/common/internal/result/ResultFuture.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNlQwNDo0NToyNFrOHYdtMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yNlQwNDo0NToyNFrOHYdtMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQxNDU3OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1055#discussion_r495414579", "createdAt": "2020-09-26T04:45:24Z", "author": {"login": "AdamBJohnsonx"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/result/ResultFuture.java", "diffHunk": "@@ -129,4 +129,5 @@ public synchronized void whenComplete(@NonNull final BiConsumer<T, Throwable> co\n \n         mConsumers.add(consumerToAdd);\n     }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ca14fbc3acec8cae53966268a6aff7e4a9fe51c"}, "originalPosition": 4}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2291, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}