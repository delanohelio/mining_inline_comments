{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk0Mjk0MDE2", "number": 1060, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNzozMjo0NFrOEoMLKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNzozOToyMFrOEoMUKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNTc3OTYyOnYy", "diffSide": "RIGHT", "path": "common/src/androidTest/java/com/microsoft/identity/common/CommandDispatcherTest.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNzozMjo0NFrOHZIvyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNzo0ODowNFrOHZJRcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjExOTc1Mg==", "bodyText": "This looks like something we can use RoboTestUtils.flushScheduler() for?\n(no need to make changes in this PR)", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1060#discussion_r496119752", "createdAt": "2020-09-28T17:32:44Z", "author": {"login": "rpdome"}, "path": "common/src/androidTest/java/com/microsoft/identity/common/CommandDispatcherTest.java", "diffHunk": "@@ -0,0 +1,298 @@\n+// Copyright (c) Microsoft Corporation.\n+// All rights reserved.\n+//\n+// This code is licensed under the MIT License.\n+//\n+// Permission is hereby granted, free of charge, to any person obtaining a copy\n+// of this software and associated documentation files(the \"Software\"), to deal\n+// in the Software without restriction, including without limitation the rights\n+// to use, copy, modify, merge, publish, distribute, sublicense, and / or sell\n+// copies of the Software, and to permit persons to whom the Software is\n+// furnished to do so, subject to the following conditions :\n+//\n+// The above copyright notice and this permission notice shall be included in\n+// all copies or substantial portions of the Software.\n+//\n+// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+// THE SOFTWARE.\n+package com.microsoft.identity.common;\n+\n+import android.content.Intent;\n+\n+import androidx.annotation.NonNull;\n+import androidx.test.ext.junit.runners.AndroidJUnit4;\n+\n+import com.microsoft.identity.common.internal.cache.ICacheRecord;\n+import com.microsoft.identity.common.internal.commands.BaseCommand;\n+import com.microsoft.identity.common.internal.commands.CommandCallback;\n+import com.microsoft.identity.common.internal.commands.parameters.CommandParameters;\n+import com.microsoft.identity.common.internal.commands.parameters.DeviceCodeFlowCommandParameters;\n+import com.microsoft.identity.common.internal.commands.parameters.InteractiveTokenCommandParameters;\n+import com.microsoft.identity.common.internal.commands.parameters.RemoveAccountCommandParameters;\n+import com.microsoft.identity.common.internal.commands.parameters.SilentTokenCommandParameters;\n+import com.microsoft.identity.common.internal.controllers.BaseController;\n+import com.microsoft.identity.common.internal.controllers.CommandDispatcher;\n+import com.microsoft.identity.common.internal.controllers.CommandResult;\n+import com.microsoft.identity.common.internal.providers.oauth2.AuthorizationResult;\n+import com.microsoft.identity.common.internal.result.AcquireTokenResult;\n+import com.microsoft.identity.common.internal.result.FinalizableResultFuture;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CountDownLatch;\n+\n+\n+@RunWith(AndroidJUnit4.class)\n+public class CommandDispatcherTest {\n+\n+    private static final String TEST_RESULT_STR = \"test_result_str\";\n+\n+    @Test\n+    public void testCanSubmitSilently() throws InterruptedException {\n+        final CountDownLatch testLatch = new CountDownLatch(1);\n+\n+        final BaseCommand<String> testCommand = getTestCommand(testLatch);\n+        CommandDispatcher.submitSilent(testCommand);\n+        testLatch.await();\n+    }\n+\n+    private TestCommand getTestCommand(final CountDownLatch testLatch) {\n+        return new TestCommand(\n+                getEmptyTestParams(),\n+                new CommandCallback<String, Exception>() {\n+                    @Override\n+                    public void onCancel() {\n+                        testLatch.countDown();\n+                        Assert.fail();\n+                    }\n+\n+                    @Override\n+                    public void onError(Exception error) {\n+                        testLatch.countDown();\n+                        Assert.fail();\n+                    }\n+\n+                    @Override\n+                    public void onTaskCompleted(String s) {\n+                        testLatch.countDown();\n+                        Assert.assertEquals(TEST_RESULT_STR, s);\n+                    }\n+                }, 0);\n+    }\n+\n+    /**\n+     * This test represents the case where a command changes underneath our system\n+     * while we're using it as a key.  They're not immutable, so they're not safe to\n+     * use as keys in a map.  It won't hurt, though, unless we can't get rid of them.\n+     * To test this, we submit a command, block before it executes, alter it, release it,\n+     * and then make sure it gets cleaned up.\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testSubmitSilentWithParamMutation() throws Exception {\n+        final CountDownLatch testLatch = new CountDownLatch(1);\n+        CountDownLatch submitLatch = new CountDownLatch(1);\n+        CountDownLatch submitLatch1 = new CountDownLatch(1);\n+\n+        final TestCommand testCommand = new LatchedTestCommand(\n+                getEmptyTestParams(),\n+                new CommandCallback<String, Exception>() {\n+                    @Override\n+                    public void onCancel() {\n+                        testLatch.countDown();\n+                        Assert.fail();\n+                    }\n+\n+                    @Override\n+                    public void onError(Exception error) {\n+                        testLatch.countDown();\n+                        Assert.fail();\n+                    }\n+\n+                    @Override\n+                    public void onTaskCompleted(String s) {\n+                        testLatch.countDown();\n+                        Assert.assertEquals(TEST_RESULT_STR, s);\n+                    }\n+                }, 0, submitLatch, submitLatch1);\n+        FinalizableResultFuture<CommandResult> f = CommandDispatcher.submitSilentReturningFuture(testCommand);\n+        submitLatch1.await();\n+        testCommand.value = 2;\n+        submitLatch.countDown();\n+        testLatch.await();\n+        Assert.assertTrue(f.isDone());\n+        Assert.assertEquals(TEST_RESULT_STR, f.get().getResult());\n+        f.isCleanedUp();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "96ad614b366917dc4632bab7db8ae32c89125648"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyMTgzNg==", "bodyText": "Hah.  Yeah, I could have just gotten a reference on the executor and shut it down, I suppose.", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1060#discussion_r496121836", "createdAt": "2020-09-28T17:36:36Z", "author": {"login": "AdamBJohnsonx"}, "path": "common/src/androidTest/java/com/microsoft/identity/common/CommandDispatcherTest.java", "diffHunk": "@@ -0,0 +1,298 @@\n+// Copyright (c) Microsoft Corporation.\n+// All rights reserved.\n+//\n+// This code is licensed under the MIT License.\n+//\n+// Permission is hereby granted, free of charge, to any person obtaining a copy\n+// of this software and associated documentation files(the \"Software\"), to deal\n+// in the Software without restriction, including without limitation the rights\n+// to use, copy, modify, merge, publish, distribute, sublicense, and / or sell\n+// copies of the Software, and to permit persons to whom the Software is\n+// furnished to do so, subject to the following conditions :\n+//\n+// The above copyright notice and this permission notice shall be included in\n+// all copies or substantial portions of the Software.\n+//\n+// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+// THE SOFTWARE.\n+package com.microsoft.identity.common;\n+\n+import android.content.Intent;\n+\n+import androidx.annotation.NonNull;\n+import androidx.test.ext.junit.runners.AndroidJUnit4;\n+\n+import com.microsoft.identity.common.internal.cache.ICacheRecord;\n+import com.microsoft.identity.common.internal.commands.BaseCommand;\n+import com.microsoft.identity.common.internal.commands.CommandCallback;\n+import com.microsoft.identity.common.internal.commands.parameters.CommandParameters;\n+import com.microsoft.identity.common.internal.commands.parameters.DeviceCodeFlowCommandParameters;\n+import com.microsoft.identity.common.internal.commands.parameters.InteractiveTokenCommandParameters;\n+import com.microsoft.identity.common.internal.commands.parameters.RemoveAccountCommandParameters;\n+import com.microsoft.identity.common.internal.commands.parameters.SilentTokenCommandParameters;\n+import com.microsoft.identity.common.internal.controllers.BaseController;\n+import com.microsoft.identity.common.internal.controllers.CommandDispatcher;\n+import com.microsoft.identity.common.internal.controllers.CommandResult;\n+import com.microsoft.identity.common.internal.providers.oauth2.AuthorizationResult;\n+import com.microsoft.identity.common.internal.result.AcquireTokenResult;\n+import com.microsoft.identity.common.internal.result.FinalizableResultFuture;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CountDownLatch;\n+\n+\n+@RunWith(AndroidJUnit4.class)\n+public class CommandDispatcherTest {\n+\n+    private static final String TEST_RESULT_STR = \"test_result_str\";\n+\n+    @Test\n+    public void testCanSubmitSilently() throws InterruptedException {\n+        final CountDownLatch testLatch = new CountDownLatch(1);\n+\n+        final BaseCommand<String> testCommand = getTestCommand(testLatch);\n+        CommandDispatcher.submitSilent(testCommand);\n+        testLatch.await();\n+    }\n+\n+    private TestCommand getTestCommand(final CountDownLatch testLatch) {\n+        return new TestCommand(\n+                getEmptyTestParams(),\n+                new CommandCallback<String, Exception>() {\n+                    @Override\n+                    public void onCancel() {\n+                        testLatch.countDown();\n+                        Assert.fail();\n+                    }\n+\n+                    @Override\n+                    public void onError(Exception error) {\n+                        testLatch.countDown();\n+                        Assert.fail();\n+                    }\n+\n+                    @Override\n+                    public void onTaskCompleted(String s) {\n+                        testLatch.countDown();\n+                        Assert.assertEquals(TEST_RESULT_STR, s);\n+                    }\n+                }, 0);\n+    }\n+\n+    /**\n+     * This test represents the case where a command changes underneath our system\n+     * while we're using it as a key.  They're not immutable, so they're not safe to\n+     * use as keys in a map.  It won't hurt, though, unless we can't get rid of them.\n+     * To test this, we submit a command, block before it executes, alter it, release it,\n+     * and then make sure it gets cleaned up.\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testSubmitSilentWithParamMutation() throws Exception {\n+        final CountDownLatch testLatch = new CountDownLatch(1);\n+        CountDownLatch submitLatch = new CountDownLatch(1);\n+        CountDownLatch submitLatch1 = new CountDownLatch(1);\n+\n+        final TestCommand testCommand = new LatchedTestCommand(\n+                getEmptyTestParams(),\n+                new CommandCallback<String, Exception>() {\n+                    @Override\n+                    public void onCancel() {\n+                        testLatch.countDown();\n+                        Assert.fail();\n+                    }\n+\n+                    @Override\n+                    public void onError(Exception error) {\n+                        testLatch.countDown();\n+                        Assert.fail();\n+                    }\n+\n+                    @Override\n+                    public void onTaskCompleted(String s) {\n+                        testLatch.countDown();\n+                        Assert.assertEquals(TEST_RESULT_STR, s);\n+                    }\n+                }, 0, submitLatch, submitLatch1);\n+        FinalizableResultFuture<CommandResult> f = CommandDispatcher.submitSilentReturningFuture(testCommand);\n+        submitLatch1.await();\n+        testCommand.value = 2;\n+        submitLatch.countDown();\n+        testLatch.await();\n+        Assert.assertTrue(f.isDone());\n+        Assert.assertEquals(TEST_RESULT_STR, f.get().getResult());\n+        f.isCleanedUp();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjExOTc1Mg=="}, "originalCommit": {"oid": "96ad614b366917dc4632bab7db8ae32c89125648"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyODM3MA==", "bodyText": "could we add a TODO to migrate to that one (and get rid of the new future class) at some point in the future? (e.g. when you're working on the root cause fix)", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1060#discussion_r496128370", "createdAt": "2020-09-28T17:48:04Z", "author": {"login": "rpdome"}, "path": "common/src/androidTest/java/com/microsoft/identity/common/CommandDispatcherTest.java", "diffHunk": "@@ -0,0 +1,298 @@\n+// Copyright (c) Microsoft Corporation.\n+// All rights reserved.\n+//\n+// This code is licensed under the MIT License.\n+//\n+// Permission is hereby granted, free of charge, to any person obtaining a copy\n+// of this software and associated documentation files(the \"Software\"), to deal\n+// in the Software without restriction, including without limitation the rights\n+// to use, copy, modify, merge, publish, distribute, sublicense, and / or sell\n+// copies of the Software, and to permit persons to whom the Software is\n+// furnished to do so, subject to the following conditions :\n+//\n+// The above copyright notice and this permission notice shall be included in\n+// all copies or substantial portions of the Software.\n+//\n+// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+// THE SOFTWARE.\n+package com.microsoft.identity.common;\n+\n+import android.content.Intent;\n+\n+import androidx.annotation.NonNull;\n+import androidx.test.ext.junit.runners.AndroidJUnit4;\n+\n+import com.microsoft.identity.common.internal.cache.ICacheRecord;\n+import com.microsoft.identity.common.internal.commands.BaseCommand;\n+import com.microsoft.identity.common.internal.commands.CommandCallback;\n+import com.microsoft.identity.common.internal.commands.parameters.CommandParameters;\n+import com.microsoft.identity.common.internal.commands.parameters.DeviceCodeFlowCommandParameters;\n+import com.microsoft.identity.common.internal.commands.parameters.InteractiveTokenCommandParameters;\n+import com.microsoft.identity.common.internal.commands.parameters.RemoveAccountCommandParameters;\n+import com.microsoft.identity.common.internal.commands.parameters.SilentTokenCommandParameters;\n+import com.microsoft.identity.common.internal.controllers.BaseController;\n+import com.microsoft.identity.common.internal.controllers.CommandDispatcher;\n+import com.microsoft.identity.common.internal.controllers.CommandResult;\n+import com.microsoft.identity.common.internal.providers.oauth2.AuthorizationResult;\n+import com.microsoft.identity.common.internal.result.AcquireTokenResult;\n+import com.microsoft.identity.common.internal.result.FinalizableResultFuture;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.CountDownLatch;\n+\n+\n+@RunWith(AndroidJUnit4.class)\n+public class CommandDispatcherTest {\n+\n+    private static final String TEST_RESULT_STR = \"test_result_str\";\n+\n+    @Test\n+    public void testCanSubmitSilently() throws InterruptedException {\n+        final CountDownLatch testLatch = new CountDownLatch(1);\n+\n+        final BaseCommand<String> testCommand = getTestCommand(testLatch);\n+        CommandDispatcher.submitSilent(testCommand);\n+        testLatch.await();\n+    }\n+\n+    private TestCommand getTestCommand(final CountDownLatch testLatch) {\n+        return new TestCommand(\n+                getEmptyTestParams(),\n+                new CommandCallback<String, Exception>() {\n+                    @Override\n+                    public void onCancel() {\n+                        testLatch.countDown();\n+                        Assert.fail();\n+                    }\n+\n+                    @Override\n+                    public void onError(Exception error) {\n+                        testLatch.countDown();\n+                        Assert.fail();\n+                    }\n+\n+                    @Override\n+                    public void onTaskCompleted(String s) {\n+                        testLatch.countDown();\n+                        Assert.assertEquals(TEST_RESULT_STR, s);\n+                    }\n+                }, 0);\n+    }\n+\n+    /**\n+     * This test represents the case where a command changes underneath our system\n+     * while we're using it as a key.  They're not immutable, so they're not safe to\n+     * use as keys in a map.  It won't hurt, though, unless we can't get rid of them.\n+     * To test this, we submit a command, block before it executes, alter it, release it,\n+     * and then make sure it gets cleaned up.\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testSubmitSilentWithParamMutation() throws Exception {\n+        final CountDownLatch testLatch = new CountDownLatch(1);\n+        CountDownLatch submitLatch = new CountDownLatch(1);\n+        CountDownLatch submitLatch1 = new CountDownLatch(1);\n+\n+        final TestCommand testCommand = new LatchedTestCommand(\n+                getEmptyTestParams(),\n+                new CommandCallback<String, Exception>() {\n+                    @Override\n+                    public void onCancel() {\n+                        testLatch.countDown();\n+                        Assert.fail();\n+                    }\n+\n+                    @Override\n+                    public void onError(Exception error) {\n+                        testLatch.countDown();\n+                        Assert.fail();\n+                    }\n+\n+                    @Override\n+                    public void onTaskCompleted(String s) {\n+                        testLatch.countDown();\n+                        Assert.assertEquals(TEST_RESULT_STR, s);\n+                    }\n+                }, 0, submitLatch, submitLatch1);\n+        FinalizableResultFuture<CommandResult> f = CommandDispatcher.submitSilentReturningFuture(testCommand);\n+        submitLatch1.await();\n+        testCommand.value = 2;\n+        submitLatch.countDown();\n+        testLatch.await();\n+        Assert.assertTrue(f.isDone());\n+        Assert.assertEquals(TEST_RESULT_STR, f.get().getResult());\n+        f.isCleanedUp();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjExOTc1Mg=="}, "originalCommit": {"oid": "96ad614b366917dc4632bab7db8ae32c89125648"}, "originalPosition": 134}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNTc4NDk4OnYy", "diffSide": "RIGHT", "path": "common/src/main/java/com/microsoft/identity/common/internal/controllers/CommandDispatcher.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNzozNDoyNVrOHZIzEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNzo0MToyOVrOHZJCdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyMDU5NQ==", "bodyText": "synchronized?", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1060#discussion_r496120595", "createdAt": "2020-09-28T17:34:25Z", "author": {"login": "rpdome"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/controllers/CommandDispatcher.java", "diffHunk": "@@ -73,84 +77,145 @@\n     private static final Object sLock = new Object();\n     private static InteractiveTokenCommand sCommand = null;\n     private static final CommandResultCache sCommandResultCache = new CommandResultCache();\n-    private static final ConcurrentMap<BaseCommand, ResultFuture<CommandResult>> sExecutingCommandMap = new ConcurrentHashMap<>();\n+\n+    private static final Object mapAccessLock = new Object();\n+    @GuardedBy(\"mapAccessLock\")\n+    private static ConcurrentMap<BaseCommand, FinalizableResultFuture<CommandResult>> sExecutingCommandMap = new ConcurrentHashMap<>();\n+\n+    /**\n+     * Remove all keys that are the command reference from the executing command map.  Since if they key has\n+     * been changed, remove will not work, construct a new map and add all keys that are not identically\n+     * that key into the new map.\n+     *\n+     * @param command the command whose identity to use to cleanse the map.\n+     */\n+    private static void cleanMap(BaseCommand command) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "96ad614b366917dc4632bab7db8ae32c89125648"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyMTIwNw==", "bodyText": "Maybe document that it must be used under the mapAccessLock?", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1060#discussion_r496121207", "createdAt": "2020-09-28T17:35:22Z", "author": {"login": "AdamBJohnsonx"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/controllers/CommandDispatcher.java", "diffHunk": "@@ -73,84 +77,145 @@\n     private static final Object sLock = new Object();\n     private static InteractiveTokenCommand sCommand = null;\n     private static final CommandResultCache sCommandResultCache = new CommandResultCache();\n-    private static final ConcurrentMap<BaseCommand, ResultFuture<CommandResult>> sExecutingCommandMap = new ConcurrentHashMap<>();\n+\n+    private static final Object mapAccessLock = new Object();\n+    @GuardedBy(\"mapAccessLock\")\n+    private static ConcurrentMap<BaseCommand, FinalizableResultFuture<CommandResult>> sExecutingCommandMap = new ConcurrentHashMap<>();\n+\n+    /**\n+     * Remove all keys that are the command reference from the executing command map.  Since if they key has\n+     * been changed, remove will not work, construct a new map and add all keys that are not identically\n+     * that key into the new map.\n+     *\n+     * @param command the command whose identity to use to cleanse the map.\n+     */\n+    private static void cleanMap(BaseCommand command) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyMDU5NQ=="}, "originalCommit": {"oid": "96ad614b366917dc4632bab7db8ae32c89125648"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyMjk0MQ==", "bodyText": "Can we wrap them here? synchronize block is reentrant right?", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1060#discussion_r496122941", "createdAt": "2020-09-28T17:38:34Z", "author": {"login": "rpdome"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/controllers/CommandDispatcher.java", "diffHunk": "@@ -73,84 +77,145 @@\n     private static final Object sLock = new Object();\n     private static InteractiveTokenCommand sCommand = null;\n     private static final CommandResultCache sCommandResultCache = new CommandResultCache();\n-    private static final ConcurrentMap<BaseCommand, ResultFuture<CommandResult>> sExecutingCommandMap = new ConcurrentHashMap<>();\n+\n+    private static final Object mapAccessLock = new Object();\n+    @GuardedBy(\"mapAccessLock\")\n+    private static ConcurrentMap<BaseCommand, FinalizableResultFuture<CommandResult>> sExecutingCommandMap = new ConcurrentHashMap<>();\n+\n+    /**\n+     * Remove all keys that are the command reference from the executing command map.  Since if they key has\n+     * been changed, remove will not work, construct a new map and add all keys that are not identically\n+     * that key into the new map.\n+     *\n+     * @param command the command whose identity to use to cleanse the map.\n+     */\n+    private static void cleanMap(BaseCommand command) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyMDU5NQ=="}, "originalCommit": {"oid": "96ad614b366917dc4632bab7db8ae32c89125648"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyMzMwNg==", "bodyText": "I'm fine either way as soon as we can make sure the future dev are aware of this or can do the right thing)", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1060#discussion_r496123306", "createdAt": "2020-09-28T17:39:14Z", "author": {"login": "rpdome"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/controllers/CommandDispatcher.java", "diffHunk": "@@ -73,84 +77,145 @@\n     private static final Object sLock = new Object();\n     private static InteractiveTokenCommand sCommand = null;\n     private static final CommandResultCache sCommandResultCache = new CommandResultCache();\n-    private static final ConcurrentMap<BaseCommand, ResultFuture<CommandResult>> sExecutingCommandMap = new ConcurrentHashMap<>();\n+\n+    private static final Object mapAccessLock = new Object();\n+    @GuardedBy(\"mapAccessLock\")\n+    private static ConcurrentMap<BaseCommand, FinalizableResultFuture<CommandResult>> sExecutingCommandMap = new ConcurrentHashMap<>();\n+\n+    /**\n+     * Remove all keys that are the command reference from the executing command map.  Since if they key has\n+     * been changed, remove will not work, construct a new map and add all keys that are not identically\n+     * that key into the new map.\n+     *\n+     * @param command the command whose identity to use to cleanse the map.\n+     */\n+    private static void cleanMap(BaseCommand command) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyMDU5NQ=="}, "originalCommit": {"oid": "96ad614b366917dc4632bab7db8ae32c89125648"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyNDUzMg==", "bodyText": "Yeah we could.  I'l like to dispose of this completely once we can stabilize the key space for this map either by generating stable keys or making the objects immutable.", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1060#discussion_r496124532", "createdAt": "2020-09-28T17:41:29Z", "author": {"login": "AdamBJohnsonx"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/controllers/CommandDispatcher.java", "diffHunk": "@@ -73,84 +77,145 @@\n     private static final Object sLock = new Object();\n     private static InteractiveTokenCommand sCommand = null;\n     private static final CommandResultCache sCommandResultCache = new CommandResultCache();\n-    private static final ConcurrentMap<BaseCommand, ResultFuture<CommandResult>> sExecutingCommandMap = new ConcurrentHashMap<>();\n+\n+    private static final Object mapAccessLock = new Object();\n+    @GuardedBy(\"mapAccessLock\")\n+    private static ConcurrentMap<BaseCommand, FinalizableResultFuture<CommandResult>> sExecutingCommandMap = new ConcurrentHashMap<>();\n+\n+    /**\n+     * Remove all keys that are the command reference from the executing command map.  Since if they key has\n+     * been changed, remove will not work, construct a new map and add all keys that are not identically\n+     * that key into the new map.\n+     *\n+     * @param command the command whose identity to use to cleanse the map.\n+     */\n+    private static void cleanMap(BaseCommand command) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyMDU5NQ=="}, "originalCommit": {"oid": "96ad614b366917dc4632bab7db8ae32c89125648"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNTgwMjY2OnYy", "diffSide": "RIGHT", "path": "common/src/main/java/com/microsoft/identity/common/internal/controllers/CommandDispatcher.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNzozOToyMFrOHZI94A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxNzozOToyMFrOHZI94A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjEyMzM2MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * that key into the new map.\n          \n          \n            \n                 * that key into the new map.  <strong>MUST</strong> only be used under the mapAccessLock.", "url": "https://github.com/AzureAD/microsoft-authentication-library-common-for-android/pull/1060#discussion_r496123360", "createdAt": "2020-09-28T17:39:20Z", "author": {"login": "AdamBJohnsonx"}, "path": "common/src/main/java/com/microsoft/identity/common/internal/controllers/CommandDispatcher.java", "diffHunk": "@@ -73,84 +77,145 @@\n     private static final Object sLock = new Object();\n     private static InteractiveTokenCommand sCommand = null;\n     private static final CommandResultCache sCommandResultCache = new CommandResultCache();\n-    private static final ConcurrentMap<BaseCommand, ResultFuture<CommandResult>> sExecutingCommandMap = new ConcurrentHashMap<>();\n+\n+    private static final Object mapAccessLock = new Object();\n+    @GuardedBy(\"mapAccessLock\")\n+    private static ConcurrentMap<BaseCommand, FinalizableResultFuture<CommandResult>> sExecutingCommandMap = new ConcurrentHashMap<>();\n+\n+    /**\n+     * Remove all keys that are the command reference from the executing command map.  Since if they key has\n+     * been changed, remove will not work, construct a new map and add all keys that are not identically\n+     * that key into the new map.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "96ad614b366917dc4632bab7db8ae32c89125648"}, "originalPosition": 42}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2294, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}