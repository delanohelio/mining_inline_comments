{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcyNjQ3Njc2", "number": 509, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wOFQwMDoxNzozNVrODeL7OQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wOFQwMDoyMToxOFrODeL81w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyOTc5MjU3OnYy", "diffSide": "RIGHT", "path": "lib/net/ipv4.dl", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wOFQwMDoxNzozNVrOFnNywg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wOFQwMDoxNzozNVrOFnNywg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY2NDc3MA==", "bodyText": "this is strange.", "url": "https://github.com/vmware/differential-datalog/pull/509#discussion_r376664770", "createdAt": "2020-02-08T00:17:35Z", "author": {"login": "mbudiu-vmw"}, "path": "lib/net/ipv4.dl", "diffHunk": "@@ -0,0 +1,126 @@\n+/* An IPv4 address.\n+ *\n+ * IPv4 addresses are defined as 32-bit integers in IETF RFC 791. They are\n+ * usually represented as four octets.\n+ *\n+ * See IpAddr for a type encompassing both IPv4 and IPv6 addresses.\n+ *\n+ * The size of an Ipv4Addr struct may vary depending on the target operating\n+ * system.\n+ */\n+\n+import net.ipv6", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1960576337d254d7b02031a3b89c93f4746f086"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyOTc5NDQyOnYy", "diffSide": "RIGHT", "path": "lib/net/ipv4.dl", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wOFQwMDoxOTowNlrOFnNz3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wOFQwMDo0MDo1MFrOFnOBmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY2NTA1NA==", "bodyText": "I guess that's why you need that module.", "url": "https://github.com/vmware/differential-datalog/pull/509#discussion_r376665054", "createdAt": "2020-02-08T00:19:06Z", "author": {"login": "mbudiu-vmw"}, "path": "lib/net/ipv4.dl", "diffHunk": "@@ -0,0 +1,126 @@\n+/* An IPv4 address.\n+ *\n+ * IPv4 addresses are defined as 32-bit integers in IETF RFC 791. They are\n+ * usually represented as four octets.\n+ *\n+ * See IpAddr for a type encompassing both IPv4 and IPv6 addresses.\n+ *\n+ * The size of an Ipv4Addr struct may vary depending on the target operating\n+ * system.\n+ */\n+\n+import net.ipv6\n+\n+extern type Ipv4Addr\n+\n+/* Creates a new IPv4 address from four eight-bit octets.\n+ *\n+ * The result will represent the IP address a.b.c.d.\n+ */\n+extern function ipv4_new(a: u8, b: u8, c: u8, d: u8): Ipv4Addr\n+\n+/* Creates a new IPv4 address from a vector of octets.\n+ *\n+ * Returns None if the length of `octets` is not 4.\n+ */\n+extern function ipv4_from_octet_vec(octets: Vec<u8>): Option<Ipv4Addr>\n+\n+/* Converts a host byte order u32 into an Ipv4Addr.\n+ */\n+extern function ipv4_from_u32(ip: u32): Ipv4Addr\n+\n+/* Parse IPv4 address string in decimal notation, divided by .\n+ * (this is called \"dot-decimal notation\").\n+ */\n+extern function ipv4_from_str(s: string): Result<Ipv4Addr, string>\n+\n+/* Format IPv4 address using dot-decimal notation.\n+ */\n+extern function ipv4Addr2string(addr: Ipv4Addr): string\n+\n+/* An IPv4 address with the address pointing to localhost: 127.0.0.1.\n+ */\n+extern function iPV4_LOCALHOST(): Ipv4Addr\n+\n+/* An IPv4 address representing an unspecified address: 0.0.0.0.\n+ */\n+extern function iPV4_UNSPECIFIED(): Ipv4Addr\n+\n+/* An IPv4 address representing the broadcast address: 255.255.255.255.\n+ */\n+extern function iPV4_BROADCAST(): Ipv4Addr\n+\n+/* Returns the four eight-bit integers that make up this address.\n+ */\n+extern function ipv4_octets(addr: Ipv4Addr): (u8, u8, u8, u8)\n+\n+/* Returns a vector of four eight-bit integers the IPv4 address consists of.\n+ */\n+extern function ipv4_octet_vec(addr: Ipv4Addr): Vec<u8>\n+\n+/* Returns true for the special 'unspecified' address (0.0.0.0).\n+ *\n+ * This property is defined in UNIX Network Programming, Second Edition,\n+ * W. Richard Stevens, p. 891; see also ip7.\n+ */\n+extern function ipv4_is_unspecified(addr: Ipv4Addr): bool\n+\n+/* Returns true if this is a loopback address (127.0.0.0/8).\n+ *\n+ * This property is defined by IETF RFC 1122.\n+ */ \n+extern function ipv4_is_loopback(addr: Ipv4Addr): bool\n+\n+/* Returns true if this is a private address.\n+ *\n+ * The private address ranges are defined in IETF RFC 1918 and include:\n+ * - 10.0.0.0/8\n+ * - 172.16.0.0/12\n+ * - 192.168.0.0/16\n+ */\n+extern function ipv4_is_private(addr: Ipv4Addr): bool\n+\n+/* Returns true if the address is link-local (169.254.0.0/16).\n+ *\n+ * This property is defined by IETF RFC 3927.\n+ */\n+extern function ipv4_is_link_local(addr: Ipv4Addr): bool\n+\n+/* Returns true if this is a multicast address (224.0.0.0/4).\n+ *\n+ * Multicast addresses have a most significant octet between 224 and 239, and\n+ * is defined by IETF RFC 5771.\n+ */\n+extern function ipv4_is_multicast(addr: Ipv4Addr): bool\n+\n+/* Returns true if this is a broadcast address (255.255.255.255).\n+ *\n+ * A broadcast address has all octets set to 255 as defined in IETF RFC 919.\n+ */\n+extern function ipv4_is_broadcast(addr: Ipv4Addr): bool\n+\n+/* Returns true if this address is in a range designated for documentation.\n+ *\n+ * This is defined in IETF RFC 5737:\n+ *\n+ * - 192.0.2.0/24 (TEST-NET-1)\n+ * - 198.51.100.0/24 (TEST-NET-2)\n+ * - 203.0.113.0/24 (TEST-NET-3)\n+ */\n+extern function ipv4_is_documentation(addr: Ipv4Addr): bool\n+\n+/* Converts this address to an IPv4-compatible IPv6 address.\n+ *\n+ * a.b.c.d becomes ::a.b.c.d\n+ */\n+extern function ipv4_to_ipv6_compatible(addr: Ipv4Addr): Ipv6Addr", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1960576337d254d7b02031a3b89c93f4746f086"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY2ODU3MQ==", "bodyText": "Yep, fortunately we allow circular dependencies between modules.", "url": "https://github.com/vmware/differential-datalog/pull/509#discussion_r376668571", "createdAt": "2020-02-08T00:40:50Z", "author": {"login": "ryzhyk"}, "path": "lib/net/ipv4.dl", "diffHunk": "@@ -0,0 +1,126 @@\n+/* An IPv4 address.\n+ *\n+ * IPv4 addresses are defined as 32-bit integers in IETF RFC 791. They are\n+ * usually represented as four octets.\n+ *\n+ * See IpAddr for a type encompassing both IPv4 and IPv6 addresses.\n+ *\n+ * The size of an Ipv4Addr struct may vary depending on the target operating\n+ * system.\n+ */\n+\n+import net.ipv6\n+\n+extern type Ipv4Addr\n+\n+/* Creates a new IPv4 address from four eight-bit octets.\n+ *\n+ * The result will represent the IP address a.b.c.d.\n+ */\n+extern function ipv4_new(a: u8, b: u8, c: u8, d: u8): Ipv4Addr\n+\n+/* Creates a new IPv4 address from a vector of octets.\n+ *\n+ * Returns None if the length of `octets` is not 4.\n+ */\n+extern function ipv4_from_octet_vec(octets: Vec<u8>): Option<Ipv4Addr>\n+\n+/* Converts a host byte order u32 into an Ipv4Addr.\n+ */\n+extern function ipv4_from_u32(ip: u32): Ipv4Addr\n+\n+/* Parse IPv4 address string in decimal notation, divided by .\n+ * (this is called \"dot-decimal notation\").\n+ */\n+extern function ipv4_from_str(s: string): Result<Ipv4Addr, string>\n+\n+/* Format IPv4 address using dot-decimal notation.\n+ */\n+extern function ipv4Addr2string(addr: Ipv4Addr): string\n+\n+/* An IPv4 address with the address pointing to localhost: 127.0.0.1.\n+ */\n+extern function iPV4_LOCALHOST(): Ipv4Addr\n+\n+/* An IPv4 address representing an unspecified address: 0.0.0.0.\n+ */\n+extern function iPV4_UNSPECIFIED(): Ipv4Addr\n+\n+/* An IPv4 address representing the broadcast address: 255.255.255.255.\n+ */\n+extern function iPV4_BROADCAST(): Ipv4Addr\n+\n+/* Returns the four eight-bit integers that make up this address.\n+ */\n+extern function ipv4_octets(addr: Ipv4Addr): (u8, u8, u8, u8)\n+\n+/* Returns a vector of four eight-bit integers the IPv4 address consists of.\n+ */\n+extern function ipv4_octet_vec(addr: Ipv4Addr): Vec<u8>\n+\n+/* Returns true for the special 'unspecified' address (0.0.0.0).\n+ *\n+ * This property is defined in UNIX Network Programming, Second Edition,\n+ * W. Richard Stevens, p. 891; see also ip7.\n+ */\n+extern function ipv4_is_unspecified(addr: Ipv4Addr): bool\n+\n+/* Returns true if this is a loopback address (127.0.0.0/8).\n+ *\n+ * This property is defined by IETF RFC 1122.\n+ */ \n+extern function ipv4_is_loopback(addr: Ipv4Addr): bool\n+\n+/* Returns true if this is a private address.\n+ *\n+ * The private address ranges are defined in IETF RFC 1918 and include:\n+ * - 10.0.0.0/8\n+ * - 172.16.0.0/12\n+ * - 192.168.0.0/16\n+ */\n+extern function ipv4_is_private(addr: Ipv4Addr): bool\n+\n+/* Returns true if the address is link-local (169.254.0.0/16).\n+ *\n+ * This property is defined by IETF RFC 3927.\n+ */\n+extern function ipv4_is_link_local(addr: Ipv4Addr): bool\n+\n+/* Returns true if this is a multicast address (224.0.0.0/4).\n+ *\n+ * Multicast addresses have a most significant octet between 224 and 239, and\n+ * is defined by IETF RFC 5771.\n+ */\n+extern function ipv4_is_multicast(addr: Ipv4Addr): bool\n+\n+/* Returns true if this is a broadcast address (255.255.255.255).\n+ *\n+ * A broadcast address has all octets set to 255 as defined in IETF RFC 919.\n+ */\n+extern function ipv4_is_broadcast(addr: Ipv4Addr): bool\n+\n+/* Returns true if this address is in a range designated for documentation.\n+ *\n+ * This is defined in IETF RFC 5737:\n+ *\n+ * - 192.0.2.0/24 (TEST-NET-1)\n+ * - 198.51.100.0/24 (TEST-NET-2)\n+ * - 203.0.113.0/24 (TEST-NET-3)\n+ */\n+extern function ipv4_is_documentation(addr: Ipv4Addr): bool\n+\n+/* Converts this address to an IPv4-compatible IPv6 address.\n+ *\n+ * a.b.c.d becomes ::a.b.c.d\n+ */\n+extern function ipv4_to_ipv6_compatible(addr: Ipv4Addr): Ipv6Addr", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY2NTA1NA=="}, "originalCommit": {"oid": "f1960576337d254d7b02031a3b89c93f4746f086"}, "originalPosition": 116}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyOTc5NjcxOnYy", "diffSide": "RIGHT", "path": "lib/net/ipv6.dl", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wOFQwMDoyMToxOFrOFnN1MQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wOFQwMDoyMToxOFrOFnN1MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY2NTM5Mw==", "bodyText": "I didn't know you could have mutually recursive modules.", "url": "https://github.com/vmware/differential-datalog/pull/509#discussion_r376665393", "createdAt": "2020-02-08T00:21:18Z", "author": {"login": "mbudiu-vmw"}, "path": "lib/net/ipv6.dl", "diffHunk": "@@ -0,0 +1,134 @@\n+/* An IPv6 address.\n+ *\n+ * IPv6 addresses are defined as 128-bit integers in IETF RFC 4291. They are\n+ * usually represented as eight 16-bit segments.\n+ *\n+ * See IpAddr for a type encompassing both IPv4 and IPv6 addresses.\n+ *\n+ * The size of an Ipv6Addr struct may vary depending on the target operating\n+ * system.\n+ */\n+\n+import net.ipv4", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1960576337d254d7b02031a3b89c93f4746f086"}, "originalPosition": 12}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4862, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}