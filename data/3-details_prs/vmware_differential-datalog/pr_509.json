{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcyNjQ3Njc2", "number": 509, "title": "Antrea todos", "bodyText": "uuid.dl library for parsing and formatting UUIDs\nnet library, currently including functions and types for working with IPv4 and IPv6 addresses.\nused both libraries in the antrea example.", "createdAt": "2020-02-07T23:49:45Z", "url": "https://github.com/vmware/differential-datalog/pull/509", "merged": true, "mergeCommit": {"oid": "7d667b02e9e6e7a192e7adac5abcf05e5cc59c76"}, "closed": true, "closedAt": "2020-02-08T01:39:12Z", "author": {"login": "ryzhyk"}, "timelineItems": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcB0HYeAH2gAyMzcyNjQ3Njc2OjU2Mjg0MjlkOWI2NmM5ZDYzODkzZGVlNzQ2ZTgxMTg0OGNlMjA2MzY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcCI3yDAFqTM1NTUwNzA3NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "5628429d9b66c9d63893dee746e811848ce20636", "author": {"user": {"login": "ryzhyk", "name": "Leonid Ryzhyk"}}, "url": "https://github.com/vmware/differential-datalog/commit/5628429d9b66c9d63893dee746e811848ce20636", "committedDate": "2020-02-07T00:23:08Z", "message": "lib/uuid.dl: A library for working with UUIDs.\n\nDDlog bindings for the `uuid` Rust crate.  Defined `extern type Uuid`\nalong with functions to parse and format UUIDs using three different\nformats:\n\n- hyphenated: 936DA01F-9ABD-4D9D-80C7-02AF85C822A8\n- simple: 936da01f9abd4d9d80c702af85c822a8\n- urn: urn:uuid:936da01f-9abd-4d9d-80c7-02af85c822a8"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "51a0dd7a5bc3d7cb11cdbdb7e9cf42eb9267eb91", "author": {"user": {"login": "ryzhyk", "name": "Leonid Ryzhyk"}}, "url": "https://github.com/vmware/differential-datalog/commit/51a0dd7a5bc3d7cb11cdbdb7e9cf42eb9267eb91", "committedDate": "2020-02-07T00:23:08Z", "message": "Parse.hs: Forbid the use of `self` as identifier.\n\nIt clashes with Rust keyword.\n\nIdeally, we should be renaming such identifiers, but we don't have\nthe infrastructure to do this at the moment."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f1960576337d254d7b02031a3b89c93f4746f086", "author": {"user": {"login": "ryzhyk", "name": "Leonid Ryzhyk"}}, "url": "https://github.com/vmware/differential-datalog/commit/f1960576337d254d7b02031a3b89c93f4746f086", "committedDate": "2020-02-07T23:47:39Z", "message": "IP address manipulation library.\n\nThree new library types:\n`net.IpAddr`   - IPv4 or IPv6 address\n`net.Ipv4Addr` - IPv4 address\n`net.Ipv6Addr` - IPv6 address"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c716115fb095446c5af18f8fef6f2fc48d2d099e", "author": {"user": {"login": "ryzhyk", "name": "Leonid Ryzhyk"}}, "url": "https://github.com/vmware/differential-datalog/commit/c716115fb095446c5af18f8fef6f2fc48d2d099e", "committedDate": "2020-02-08T00:25:19Z", "message": "Minimal antrea test data."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU1NTA3MDc0", "url": "https://github.com/vmware/differential-datalog/pull/509#pullrequestreview-355507074", "createdAt": "2020-02-08T00:17:35Z", "commit": {"oid": "f1960576337d254d7b02031a3b89c93f4746f086"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wOFQwMDoxNzozNVrOFnNywg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wOFQwMDoyMToxOFrOFnN1MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY2NDc3MA==", "bodyText": "this is strange.", "url": "https://github.com/vmware/differential-datalog/pull/509#discussion_r376664770", "createdAt": "2020-02-08T00:17:35Z", "author": {"login": "mbudiu-vmw"}, "path": "lib/net/ipv4.dl", "diffHunk": "@@ -0,0 +1,126 @@\n+/* An IPv4 address.\n+ *\n+ * IPv4 addresses are defined as 32-bit integers in IETF RFC 791. They are\n+ * usually represented as four octets.\n+ *\n+ * See IpAddr for a type encompassing both IPv4 and IPv6 addresses.\n+ *\n+ * The size of an Ipv4Addr struct may vary depending on the target operating\n+ * system.\n+ */\n+\n+import net.ipv6", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1960576337d254d7b02031a3b89c93f4746f086"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY2NTA1NA==", "bodyText": "I guess that's why you need that module.", "url": "https://github.com/vmware/differential-datalog/pull/509#discussion_r376665054", "createdAt": "2020-02-08T00:19:06Z", "author": {"login": "mbudiu-vmw"}, "path": "lib/net/ipv4.dl", "diffHunk": "@@ -0,0 +1,126 @@\n+/* An IPv4 address.\n+ *\n+ * IPv4 addresses are defined as 32-bit integers in IETF RFC 791. They are\n+ * usually represented as four octets.\n+ *\n+ * See IpAddr for a type encompassing both IPv4 and IPv6 addresses.\n+ *\n+ * The size of an Ipv4Addr struct may vary depending on the target operating\n+ * system.\n+ */\n+\n+import net.ipv6\n+\n+extern type Ipv4Addr\n+\n+/* Creates a new IPv4 address from four eight-bit octets.\n+ *\n+ * The result will represent the IP address a.b.c.d.\n+ */\n+extern function ipv4_new(a: u8, b: u8, c: u8, d: u8): Ipv4Addr\n+\n+/* Creates a new IPv4 address from a vector of octets.\n+ *\n+ * Returns None if the length of `octets` is not 4.\n+ */\n+extern function ipv4_from_octet_vec(octets: Vec<u8>): Option<Ipv4Addr>\n+\n+/* Converts a host byte order u32 into an Ipv4Addr.\n+ */\n+extern function ipv4_from_u32(ip: u32): Ipv4Addr\n+\n+/* Parse IPv4 address string in decimal notation, divided by .\n+ * (this is called \"dot-decimal notation\").\n+ */\n+extern function ipv4_from_str(s: string): Result<Ipv4Addr, string>\n+\n+/* Format IPv4 address using dot-decimal notation.\n+ */\n+extern function ipv4Addr2string(addr: Ipv4Addr): string\n+\n+/* An IPv4 address with the address pointing to localhost: 127.0.0.1.\n+ */\n+extern function iPV4_LOCALHOST(): Ipv4Addr\n+\n+/* An IPv4 address representing an unspecified address: 0.0.0.0.\n+ */\n+extern function iPV4_UNSPECIFIED(): Ipv4Addr\n+\n+/* An IPv4 address representing the broadcast address: 255.255.255.255.\n+ */\n+extern function iPV4_BROADCAST(): Ipv4Addr\n+\n+/* Returns the four eight-bit integers that make up this address.\n+ */\n+extern function ipv4_octets(addr: Ipv4Addr): (u8, u8, u8, u8)\n+\n+/* Returns a vector of four eight-bit integers the IPv4 address consists of.\n+ */\n+extern function ipv4_octet_vec(addr: Ipv4Addr): Vec<u8>\n+\n+/* Returns true for the special 'unspecified' address (0.0.0.0).\n+ *\n+ * This property is defined in UNIX Network Programming, Second Edition,\n+ * W. Richard Stevens, p. 891; see also ip7.\n+ */\n+extern function ipv4_is_unspecified(addr: Ipv4Addr): bool\n+\n+/* Returns true if this is a loopback address (127.0.0.0/8).\n+ *\n+ * This property is defined by IETF RFC 1122.\n+ */ \n+extern function ipv4_is_loopback(addr: Ipv4Addr): bool\n+\n+/* Returns true if this is a private address.\n+ *\n+ * The private address ranges are defined in IETF RFC 1918 and include:\n+ * - 10.0.0.0/8\n+ * - 172.16.0.0/12\n+ * - 192.168.0.0/16\n+ */\n+extern function ipv4_is_private(addr: Ipv4Addr): bool\n+\n+/* Returns true if the address is link-local (169.254.0.0/16).\n+ *\n+ * This property is defined by IETF RFC 3927.\n+ */\n+extern function ipv4_is_link_local(addr: Ipv4Addr): bool\n+\n+/* Returns true if this is a multicast address (224.0.0.0/4).\n+ *\n+ * Multicast addresses have a most significant octet between 224 and 239, and\n+ * is defined by IETF RFC 5771.\n+ */\n+extern function ipv4_is_multicast(addr: Ipv4Addr): bool\n+\n+/* Returns true if this is a broadcast address (255.255.255.255).\n+ *\n+ * A broadcast address has all octets set to 255 as defined in IETF RFC 919.\n+ */\n+extern function ipv4_is_broadcast(addr: Ipv4Addr): bool\n+\n+/* Returns true if this address is in a range designated for documentation.\n+ *\n+ * This is defined in IETF RFC 5737:\n+ *\n+ * - 192.0.2.0/24 (TEST-NET-1)\n+ * - 198.51.100.0/24 (TEST-NET-2)\n+ * - 203.0.113.0/24 (TEST-NET-3)\n+ */\n+extern function ipv4_is_documentation(addr: Ipv4Addr): bool\n+\n+/* Converts this address to an IPv4-compatible IPv6 address.\n+ *\n+ * a.b.c.d becomes ::a.b.c.d\n+ */\n+extern function ipv4_to_ipv6_compatible(addr: Ipv4Addr): Ipv6Addr", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1960576337d254d7b02031a3b89c93f4746f086"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY2NTM5Mw==", "bodyText": "I didn't know you could have mutually recursive modules.", "url": "https://github.com/vmware/differential-datalog/pull/509#discussion_r376665393", "createdAt": "2020-02-08T00:21:18Z", "author": {"login": "mbudiu-vmw"}, "path": "lib/net/ipv6.dl", "diffHunk": "@@ -0,0 +1,134 @@\n+/* An IPv6 address.\n+ *\n+ * IPv6 addresses are defined as 128-bit integers in IETF RFC 4291. They are\n+ * usually represented as eight 16-bit segments.\n+ *\n+ * See IpAddr for a type encompassing both IPv4 and IPv6 addresses.\n+ *\n+ * The size of an Ipv6Addr struct may vary depending on the target operating\n+ * system.\n+ */\n+\n+import net.ipv4", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1960576337d254d7b02031a3b89c93f4746f086"}, "originalPosition": 12}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4636, "cost": 1, "resetAt": "2021-11-02T10:47:05Z"}}}