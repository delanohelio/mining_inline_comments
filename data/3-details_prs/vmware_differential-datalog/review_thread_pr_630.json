{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA0OTEwODI1", "number": 630, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxNjo1OToxN1rODy-feg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxNjo1OToxN1rODy-feg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0Nzc5MjU4OnYy", "diffSide": "RIGHT", "path": "lib/internment.rs", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxNjo1OToxN1rOGHV4ig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxNzoyNDoxOVrOGHWrPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM1MTc1NA==", "bodyText": "why keep this comment around?", "url": "https://github.com/vmware/differential-datalog/pull/630#discussion_r410351754", "createdAt": "2020-04-17T16:59:17Z", "author": {"login": "mbudiu-vmw"}, "path": "lib/internment.rs", "diffHunk": "@@ -0,0 +1,233 @@\n+use differential_datalog::record;\n+use differential_datalog::record::*;\n+use internment::ArcIntern;\n+use serde;\n+use std::cmp;\n+use std::fmt;\n+\n+#[cfg(feature = \"flatbuf\")]\n+use flatbuf::{FromFlatBuffer, ToFlatBuffer, ToFlatBufferTable, ToFlatBufferVectorElement};\n+\n+/* `flatc`-generated declarations re-exported by `flatbuf.rs` */\n+#[cfg(feature = \"flatbuf\")]\n+use flatbuf::fb;\n+\n+/* FlatBuffers runtime */\n+#[cfg(feature = \"flatbuf\")]\n+use flatbuffers as fbrt;\n+\n+#[derive(Default, Eq, PartialOrd, PartialEq, Ord, Clone, Hash)]\n+pub struct internment_Intern<A>\n+where\n+    A: Eq + Send + Hash + 'static,\n+{\n+    intern: ArcIntern<A>,\n+}\n+\n+impl<A: Eq + Hash + Send + 'static> internment_Intern<A> {\n+    pub fn new(x: A) -> internment_Intern<A> {\n+        internment_Intern {\n+            intern: ArcIntern::new(x),\n+        }\n+    }\n+    pub fn as_ref(&self) -> &A {\n+        self.intern.as_ref()\n+    }\n+}\n+\n+pub fn internment_intern<A: Eq + Hash + Send + Clone + 'static>(x: &A) -> internment_Intern<A> {\n+    internment_Intern::new(x.clone())\n+}\n+\n+pub fn internment_ival<A: Eq + Hash + Send + Clone>(x: &internment_Intern<A>) -> A {\n+    x.intern.as_ref().clone()\n+}\n+\n+/*pub fn intern_istring_ord(s: &intern_IString) -> u32 {\n+    s.x\n+}*/\n+\n+impl<A: fmt::Display + Eq + Hash + Send + Clone> fmt::Display for internment_Intern<A> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(self.as_ref(), f)\n+        //record::format_ddlog_str(&intern_istring_str(self), f)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "143c1bec0e50e54d405320cc179084995c130ac9"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM2NDczNA==", "bodyText": "Because this is very likely to cause problems for the new implementation and I will need to figure out how to fix it. At least there will be a reminder in the code.", "url": "https://github.com/vmware/differential-datalog/pull/630#discussion_r410364734", "createdAt": "2020-04-17T17:24:19Z", "author": {"login": "ryzhyk"}, "path": "lib/internment.rs", "diffHunk": "@@ -0,0 +1,233 @@\n+use differential_datalog::record;\n+use differential_datalog::record::*;\n+use internment::ArcIntern;\n+use serde;\n+use std::cmp;\n+use std::fmt;\n+\n+#[cfg(feature = \"flatbuf\")]\n+use flatbuf::{FromFlatBuffer, ToFlatBuffer, ToFlatBufferTable, ToFlatBufferVectorElement};\n+\n+/* `flatc`-generated declarations re-exported by `flatbuf.rs` */\n+#[cfg(feature = \"flatbuf\")]\n+use flatbuf::fb;\n+\n+/* FlatBuffers runtime */\n+#[cfg(feature = \"flatbuf\")]\n+use flatbuffers as fbrt;\n+\n+#[derive(Default, Eq, PartialOrd, PartialEq, Ord, Clone, Hash)]\n+pub struct internment_Intern<A>\n+where\n+    A: Eq + Send + Hash + 'static,\n+{\n+    intern: ArcIntern<A>,\n+}\n+\n+impl<A: Eq + Hash + Send + 'static> internment_Intern<A> {\n+    pub fn new(x: A) -> internment_Intern<A> {\n+        internment_Intern {\n+            intern: ArcIntern::new(x),\n+        }\n+    }\n+    pub fn as_ref(&self) -> &A {\n+        self.intern.as_ref()\n+    }\n+}\n+\n+pub fn internment_intern<A: Eq + Hash + Send + Clone + 'static>(x: &A) -> internment_Intern<A> {\n+    internment_Intern::new(x.clone())\n+}\n+\n+pub fn internment_ival<A: Eq + Hash + Send + Clone>(x: &internment_Intern<A>) -> A {\n+    x.intern.as_ref().clone()\n+}\n+\n+/*pub fn intern_istring_ord(s: &intern_IString) -> u32 {\n+    s.x\n+}*/\n+\n+impl<A: fmt::Display + Eq + Hash + Send + Clone> fmt::Display for internment_Intern<A> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(self.as_ref(), f)\n+        //record::format_ddlog_str(&intern_istring_str(self), f)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM1MTc1NA=="}, "originalCommit": {"oid": "143c1bec0e50e54d405320cc179084995c130ac9"}, "originalPosition": 53}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4736, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}