{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM0ODE0MjIw", "number": 849, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwMzoxMDo1MlrOFCtMxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwMzoxMDo1MlrOFCtMxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4MzgyMDIwOnYy", "diffSide": "RIGHT", "path": "doc/language_reference/language_reference.md", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwMzoxMDo1MlrOICAPsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQyMDoyMDowMlrOICnqww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk3MjA4Mw==", "bodyText": "This is no longer true. All string conversion functions are called to_string(). I forgot to update the docs.", "url": "https://github.com/vmware/differential-datalog/pull/849#discussion_r538972083", "createdAt": "2020-12-09T03:10:52Z", "author": {"login": "ryzhyk"}, "path": "doc/language_reference/language_reference.md", "diffHunk": "@@ -380,45 +390,106 @@ exponent ::= (* empty *)\n            | (\"e\"|\"E\") [\"+\"|\"-\"] decimal\n ```\n \n-The \"s\" in a literal indicates a \"signed\" literal.\n+The \"s\" in a literal indicates a \"signed\" literal.  Note that floating\n+point widths can only be 32 or 64, while integer width are arbitrary.\n \n-We support two types of UTF-8 string literals: quoted strings with escaping,\n-e.g., `\"foo\\nbar\"`\n-(**We rely on parsec's standard parser for strings, which\n-supports unicode and escaping. TODO: check and document its exact\n-functionality.**) and raw strings where all characters, including backslash and\n-line breaks are interpreted as is:\n+### String literals\n \n-```EBNF\n-string_literal   ::= '\"' utf8_character* '\"'\n-                     | \"[|\" utf8_character* \"|]\"\n-```\n+We support two types of UTF-8 string literals: quoted strings with\n+escaping, and raw strings.\n \n-Multiple string literals are automatically concatenated, e.g.,\n-`\"foo\" [|bar|]` is equivalent to `\"foobar\"`.\n+In quoted strings, e.g.,`\"foo\\nbar\"` C-like escape are recognized; for\n+example single quotes and backslash characters can be escaped using\n+backslashes; `\\n` is newline, and `\\t` is tab.  Unicode character with\n+code 100 can be written as `\\u{100}`.\n \n-Interpolated strings are string literals, that contain\n-expressions inside curly brackets preceeded by a dollar sign (`${}`), whose values are substituted at runtime.\n-Quoted strings are interpolate by default, e.g.,\n-`\"x: ${x}, y: ${y}, f(x): ${f(x)}\"` is equivalent to\n-`\"x: \" ++ x ++ \", y: \" ++ y ++ \", f(x): \" ++ f(x)`.\n-\n-Raw interpolated strings must be preceed by a dollar sign:\n+Interpolated strings are string literals, that contain expressions\n+inside curly brackets preceeded by a dollar sign (`${}`), whose values\n+are substituted at runtime.  Quoted strings are interpolated by\n+default, e.g., `\"x: ${x}, y: ${y}, f(x): ${f(x)}\"` is equivalent to\n+the following string expressoin: `\"x: \" ++ x ++ \", y: \" ++ y ++ \",\n+f(x): \" ++ f(x)`.\n \n ```EBNF\n+string_literal   ::= '\"' utf8_character* '\"'\n+                     | raw_string\n+                     | raw_interpolated_string\n+\n+raw_string       ::= \"[|\" utf8_character* \"|]\"\n raw_interpolated_string ::= (\"$[|\" utf8_character* \"|]\")+\n ```\n \n+Raw strings are delimited by `[|` and `|]` (where the closing sequence\n+cannot appear nested inside the string).  In raw strings all\n+characters, including backslash and line breaks are interpreted as-is.\n+Raw strings do not perform interpolation.\n+\n+Raw interpolated strings, which are preceeded by a dollar sign, will\n+perform interpolation: `$[|x: ${x}, y: ${y}, f(x): ${f(x)}|]` produces\n+the same string as above.\n+\n+Compare the value of the raw string `[|a = ${2+3}|]`, which is the\n+string containing the following characters: `a = ${2+3}`, with the\n+value of the raw interpolated string `$[|a = ${2+3}|]`, which is the\n+string containing `a = 5`.\n+\n Expressions in curly brackets can be arbitrarily complex, as long as\n they produce results of type `string`, e.g.:\n `$[|foo{var x = \"bar\"; x}|]` will evaluate to \"foobar\" at runtime.\n \n-Other terms:\n+Consecutive string literals are automatically concatenated, e.g.,\n+`\"foo\" [|bar|]` is equivalent to `\"foobar\"`.\n+\n+### Automatic string conversion\n+\n+Values of arbitrary types that occur inside interpolated strings or as\n+a second argument to the string concatenation operator (`++`) are\n+automatically converted to strings.\n+Values of primitive types (`string`, `bigint`, `bit`, and `bool`) are converted using\n+builtin methods.\n+\n+For user-defined types, conversion is performed by calling a user-defined function", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2549b7d64bceadb01d46683cff56c34325e965cd"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTYxNzk4Nw==", "bodyText": "Fixed this one; also combed the tree for remaining uses of the old name.", "url": "https://github.com/vmware/differential-datalog/pull/849#discussion_r539617987", "createdAt": "2020-12-09T20:20:02Z", "author": {"login": "mbudiu-vmw"}, "path": "doc/language_reference/language_reference.md", "diffHunk": "@@ -380,45 +390,106 @@ exponent ::= (* empty *)\n            | (\"e\"|\"E\") [\"+\"|\"-\"] decimal\n ```\n \n-The \"s\" in a literal indicates a \"signed\" literal.\n+The \"s\" in a literal indicates a \"signed\" literal.  Note that floating\n+point widths can only be 32 or 64, while integer width are arbitrary.\n \n-We support two types of UTF-8 string literals: quoted strings with escaping,\n-e.g., `\"foo\\nbar\"`\n-(**We rely on parsec's standard parser for strings, which\n-supports unicode and escaping. TODO: check and document its exact\n-functionality.**) and raw strings where all characters, including backslash and\n-line breaks are interpreted as is:\n+### String literals\n \n-```EBNF\n-string_literal   ::= '\"' utf8_character* '\"'\n-                     | \"[|\" utf8_character* \"|]\"\n-```\n+We support two types of UTF-8 string literals: quoted strings with\n+escaping, and raw strings.\n \n-Multiple string literals are automatically concatenated, e.g.,\n-`\"foo\" [|bar|]` is equivalent to `\"foobar\"`.\n+In quoted strings, e.g.,`\"foo\\nbar\"` C-like escape are recognized; for\n+example single quotes and backslash characters can be escaped using\n+backslashes; `\\n` is newline, and `\\t` is tab.  Unicode character with\n+code 100 can be written as `\\u{100}`.\n \n-Interpolated strings are string literals, that contain\n-expressions inside curly brackets preceeded by a dollar sign (`${}`), whose values are substituted at runtime.\n-Quoted strings are interpolate by default, e.g.,\n-`\"x: ${x}, y: ${y}, f(x): ${f(x)}\"` is equivalent to\n-`\"x: \" ++ x ++ \", y: \" ++ y ++ \", f(x): \" ++ f(x)`.\n-\n-Raw interpolated strings must be preceed by a dollar sign:\n+Interpolated strings are string literals, that contain expressions\n+inside curly brackets preceeded by a dollar sign (`${}`), whose values\n+are substituted at runtime.  Quoted strings are interpolated by\n+default, e.g., `\"x: ${x}, y: ${y}, f(x): ${f(x)}\"` is equivalent to\n+the following string expressoin: `\"x: \" ++ x ++ \", y: \" ++ y ++ \",\n+f(x): \" ++ f(x)`.\n \n ```EBNF\n+string_literal   ::= '\"' utf8_character* '\"'\n+                     | raw_string\n+                     | raw_interpolated_string\n+\n+raw_string       ::= \"[|\" utf8_character* \"|]\"\n raw_interpolated_string ::= (\"$[|\" utf8_character* \"|]\")+\n ```\n \n+Raw strings are delimited by `[|` and `|]` (where the closing sequence\n+cannot appear nested inside the string).  In raw strings all\n+characters, including backslash and line breaks are interpreted as-is.\n+Raw strings do not perform interpolation.\n+\n+Raw interpolated strings, which are preceeded by a dollar sign, will\n+perform interpolation: `$[|x: ${x}, y: ${y}, f(x): ${f(x)}|]` produces\n+the same string as above.\n+\n+Compare the value of the raw string `[|a = ${2+3}|]`, which is the\n+string containing the following characters: `a = ${2+3}`, with the\n+value of the raw interpolated string `$[|a = ${2+3}|]`, which is the\n+string containing `a = 5`.\n+\n Expressions in curly brackets can be arbitrarily complex, as long as\n they produce results of type `string`, e.g.:\n `$[|foo{var x = \"bar\"; x}|]` will evaluate to \"foobar\" at runtime.\n \n-Other terms:\n+Consecutive string literals are automatically concatenated, e.g.,\n+`\"foo\" [|bar|]` is equivalent to `\"foobar\"`.\n+\n+### Automatic string conversion\n+\n+Values of arbitrary types that occur inside interpolated strings or as\n+a second argument to the string concatenation operator (`++`) are\n+automatically converted to strings.\n+Values of primitive types (`string`, `bigint`, `bit`, and `bool`) are converted using\n+builtin methods.\n+\n+For user-defined types, conversion is performed by calling a user-defined function", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk3MjA4Mw=="}, "originalCommit": {"oid": "2549b7d64bceadb01d46683cff56c34325e965cd"}, "originalPosition": 100}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4699, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}