{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ0NDAzNDcz", "number": 693, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNVQxNzo1NzoyOVrOELe6kQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNVQxNzo1NzoyOVrOELe6kQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwNDc2MzA1OnYy", "diffSide": "RIGHT", "path": "rust/template/ddlog.h", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNVQxNzo1NzoyOVrOGtD5DA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNVQyMzoxNDo0M1rOGtFgNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkwMjg2MA==", "bodyText": "Looking at the implementation, I don't think t gets copied. It looks like the function expects it to be a static pointer.", "url": "https://github.com/vmware/differential-datalog/pull/693#discussion_r449902860", "createdAt": "2020-07-05T17:57:29Z", "author": {"login": "ryzhyk"}, "path": "rust/template/ddlog.h", "diffHunk": "@@ -954,6 +954,45 @@ extern size_t ddlog_get_strlen(const ddlog_record *rec);\n  */\n extern const char * ddlog_get_str_with_length(const ddlog_record *rec, size_t *len);\n \n+/*\n+ * Create a serialized record from a NULL-terminated string `t` containing\n+ * the serialization scheme and a NULL-terminated string `s` containing\n+ * the serialized data.\n+ * This function copies `s` to an internal buffer, so the caller is\n+ * responsible for deallocating `s` if it was dynamically allocated.\n+ *\n+ * Returns `NULL` if `t` or `s` are not a valid null-terminated UTF8 strings.\n+ */\n+extern ddlog_record* ddlog_serialized(const char *t, const char *s);\n+\n+/*\n+ * Create a serialized record.\n+ *\n+ * `t` - points to the start of a UTF8 string containing the\n+ *       serialization scheme. The string does not have to be\n+ *       NULL-terminated. The pointer must not be `NULL`\n+ * `t_len` - length of string in bytes.\n+ * `s` - points to the start of a UTF8 string containing the\n+ *       serialization scheme.  The string does not have to be\n+ *       NULL-terminated. The pointer must not be `NULL`, unless\n+ *       `s_len==0`, in which case the function ignores the value of the\n+ *       pointer and returns a record containing an empty string.\n+ * `s_len` - length of string in bytes.\n+ *\n+ * This function copies `s` and `t` to internal buffers, so the caller is", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b39032f54230acddbfe1d8ae5b626212d5fd57f"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkwNzM4OA==", "bodyText": "Ahh, whoops, I was copying it originally, then decided I would probably always know what kind of serialisation scheme a dataset was using.\nThat's it corrected now.", "url": "https://github.com/vmware/differential-datalog/pull/693#discussion_r449907388", "createdAt": "2020-07-05T18:51:19Z", "author": {"login": "c-nixon"}, "path": "rust/template/ddlog.h", "diffHunk": "@@ -954,6 +954,45 @@ extern size_t ddlog_get_strlen(const ddlog_record *rec);\n  */\n extern const char * ddlog_get_str_with_length(const ddlog_record *rec, size_t *len);\n \n+/*\n+ * Create a serialized record from a NULL-terminated string `t` containing\n+ * the serialization scheme and a NULL-terminated string `s` containing\n+ * the serialized data.\n+ * This function copies `s` to an internal buffer, so the caller is\n+ * responsible for deallocating `s` if it was dynamically allocated.\n+ *\n+ * Returns `NULL` if `t` or `s` are not a valid null-terminated UTF8 strings.\n+ */\n+extern ddlog_record* ddlog_serialized(const char *t, const char *s);\n+\n+/*\n+ * Create a serialized record.\n+ *\n+ * `t` - points to the start of a UTF8 string containing the\n+ *       serialization scheme. The string does not have to be\n+ *       NULL-terminated. The pointer must not be `NULL`\n+ * `t_len` - length of string in bytes.\n+ * `s` - points to the start of a UTF8 string containing the\n+ *       serialization scheme.  The string does not have to be\n+ *       NULL-terminated. The pointer must not be `NULL`, unless\n+ *       `s_len==0`, in which case the function ignores the value of the\n+ *       pointer and returns a record containing an empty string.\n+ * `s_len` - length of string in bytes.\n+ *\n+ * This function copies `s` and `t` to internal buffers, so the caller is", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkwMjg2MA=="}, "originalCommit": {"oid": "7b39032f54230acddbfe1d8ae5b626212d5fd57f"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkwODg3Nw==", "bodyText": "As to the use-case, I'm toying around with a service that takes a differential-ddlog program as a payload, and wires up it's input and output tables to some external streams using some additional metadata.\nDeserializing in datalog would result in a lot of unnecessary memory overhead since most of the payload data would never get used.", "url": "https://github.com/vmware/differential-datalog/pull/693#discussion_r449908877", "createdAt": "2020-07-05T19:08:51Z", "author": {"login": "c-nixon"}, "path": "rust/template/ddlog.h", "diffHunk": "@@ -954,6 +954,45 @@ extern size_t ddlog_get_strlen(const ddlog_record *rec);\n  */\n extern const char * ddlog_get_str_with_length(const ddlog_record *rec, size_t *len);\n \n+/*\n+ * Create a serialized record from a NULL-terminated string `t` containing\n+ * the serialization scheme and a NULL-terminated string `s` containing\n+ * the serialized data.\n+ * This function copies `s` to an internal buffer, so the caller is\n+ * responsible for deallocating `s` if it was dynamically allocated.\n+ *\n+ * Returns `NULL` if `t` or `s` are not a valid null-terminated UTF8 strings.\n+ */\n+extern ddlog_record* ddlog_serialized(const char *t, const char *s);\n+\n+/*\n+ * Create a serialized record.\n+ *\n+ * `t` - points to the start of a UTF8 string containing the\n+ *       serialization scheme. The string does not have to be\n+ *       NULL-terminated. The pointer must not be `NULL`\n+ * `t_len` - length of string in bytes.\n+ * `s` - points to the start of a UTF8 string containing the\n+ *       serialization scheme.  The string does not have to be\n+ *       NULL-terminated. The pointer must not be `NULL`, unless\n+ *       `s_len==0`, in which case the function ignores the value of the\n+ *       pointer and returns a record containing an empty string.\n+ * `s_len` - length of string in bytes.\n+ *\n+ * This function copies `s` and `t` to internal buffers, so the caller is", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkwMjg2MA=="}, "originalCommit": {"oid": "7b39032f54230acddbfe1d8ae5b626212d5fd57f"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkyOTI3MQ==", "bodyText": "DDlog-as-a-service would be neat.  If you feel that any of the stuff you build can be reused, a PR would be most welcome :)", "url": "https://github.com/vmware/differential-datalog/pull/693#discussion_r449929271", "createdAt": "2020-07-05T23:14:43Z", "author": {"login": "ryzhyk"}, "path": "rust/template/ddlog.h", "diffHunk": "@@ -954,6 +954,45 @@ extern size_t ddlog_get_strlen(const ddlog_record *rec);\n  */\n extern const char * ddlog_get_str_with_length(const ddlog_record *rec, size_t *len);\n \n+/*\n+ * Create a serialized record from a NULL-terminated string `t` containing\n+ * the serialization scheme and a NULL-terminated string `s` containing\n+ * the serialized data.\n+ * This function copies `s` to an internal buffer, so the caller is\n+ * responsible for deallocating `s` if it was dynamically allocated.\n+ *\n+ * Returns `NULL` if `t` or `s` are not a valid null-terminated UTF8 strings.\n+ */\n+extern ddlog_record* ddlog_serialized(const char *t, const char *s);\n+\n+/*\n+ * Create a serialized record.\n+ *\n+ * `t` - points to the start of a UTF8 string containing the\n+ *       serialization scheme. The string does not have to be\n+ *       NULL-terminated. The pointer must not be `NULL`\n+ * `t_len` - length of string in bytes.\n+ * `s` - points to the start of a UTF8 string containing the\n+ *       serialization scheme.  The string does not have to be\n+ *       NULL-terminated. The pointer must not be `NULL`, unless\n+ *       `s_len==0`, in which case the function ignores the value of the\n+ *       pointer and returns a record containing an empty string.\n+ * `s_len` - length of string in bytes.\n+ *\n+ * This function copies `s` and `t` to internal buffers, so the caller is", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTkwMjg2MA=="}, "originalCommit": {"oid": "7b39032f54230acddbfe1d8ae5b626212d5fd57f"}, "originalPosition": 29}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4778, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}