{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgyNTQ2NTY1", "number": 543, "title": "Deserialize records on the fly.", "bodyText": "Consider a scenario where input relations contain JSON strings.  These\nstrings are parsed using the recently added JSON lib and then DDlog goes\non to compute on the parsed data.  When working with large JSON\ndocuments where only a handful of attributes are actually used by DDlog,\nDDlog's memory footprint is dominated by unparsed JSON inputs.\nTo avoid this waste, we introduce a new record type that contains\nserialized data represented as a string.  DDlog parses this string using\nappropriate deserializer (currently, only json is supported) and drops\nthe string on the floor, keeping only the extracted data in memory.\nSyntactically, the new type of record is written down as\n@<format><string_token>, where <string_token> can be either a quoted\nstring literal or a reference to a file, e.g.:\ninsert json_test.Deserialized[@json\"{\\\"@type\\\": \\\"t.V1\\\", \\\"b\\\": true}\"]", "createdAt": "2020-03-02T18:46:24Z", "url": "https://github.com/vmware/differential-datalog/pull/543", "merged": true, "mergeCommit": {"oid": "3a575b40ba597a09d183794952b846c453a755ec"}, "closed": true, "closedAt": "2020-03-02T23:52:55Z", "author": {"login": "ryzhyk"}, "timelineItems": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcJzrV5ABqjMwODk1MjM1NDY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcJ1zsdABqjMwODk5ODQ0MzA=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "19fe73c62e727cf27062d2125ce7341eaad50136", "author": {"user": {"login": "ryzhyk", "name": "Leonid Ryzhyk"}}, "url": "https://github.com/vmware/differential-datalog/commit/19fe73c62e727cf27062d2125ce7341eaad50136", "committedDate": "2020-03-02T18:13:27Z", "message": "Deserialize records on the fly.\n\nConsider a scenario where input relations contain JSON strings.  These\nstrings are parsed using the recently added JSON lib and then DDlog goes\non to compute on the parsed data.  When working with large JSON\ndocuments where only a handful of attributes are actually used by DDlog,\nDDlog's memory footprint is dominated by unparsed JSON inputs.\n\nTo avoid this waste, we introduce a new record type that contains\nserialized data represented as a string.  DDlog parses this string using\nappropriate deserializer (currently, only json is supported) and drops\nthe string on the floor, keeping only the extracted data in memory.\n\nSyntactically, the new type of record is written down as\n`#<format><string_token>`, where `<string_token>` can be either a quoted\nstring literal or a reference to a file, e.g.:\n\n```\ninsert json_test.Deserialized[#json\"{\\\"@type\\\": \\\"t.V1\\\", \\\"b\\\": true}\"]\n```"}, "afterCommit": {"oid": "d8c93e1a7b4712938462547f1af8622395762ad2", "author": {"user": {"login": "ryzhyk", "name": "Leonid Ryzhyk"}}, "url": "https://github.com/vmware/differential-datalog/commit/d8c93e1a7b4712938462547f1af8622395762ad2", "committedDate": "2020-03-02T20:23:45Z", "message": "Deserialize records on the fly.\n\nConsider a scenario where input relations contain JSON strings.  These\nstrings are parsed using the recently added JSON lib and then DDlog goes\non to compute on the parsed data.  When working with large JSON\ndocuments where only a handful of attributes are actually used by DDlog,\nDDlog's memory footprint is dominated by unparsed JSON inputs.\n\nTo avoid this waste, we introduce a new record type that contains\nserialized data represented as a string.  DDlog parses this string using\nappropriate deserializer (currently, only json is supported) and drops\nthe string on the floor, keeping only the extracted data in memory.\n\nSyntactically, the new type of record is written down as\n`@<format><string_token>`, where `<string_token>` can be either a quoted\nstring literal or a reference to a file, e.g.:\n\n```\ninsert json_test.Deserialized[@json\"{\\\"@type\\\": \\\"t.V1\\\", \\\"b\\\": true}\"]\n```"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY3NTU5NjA1", "url": "https://github.com/vmware/differential-datalog/pull/543#pullrequestreview-367559605", "createdAt": "2020-03-02T21:59:07Z", "commit": {"oid": "d8c93e1a7b4712938462547f1af8622395762ad2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQyMTo1OTowOFrOFww1lg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQyMTo1OTowOFrOFww1lg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjY3NjExOA==", "bodyText": "Do you want to document this particular format?\nHow does one register a new deserializer?", "url": "https://github.com/vmware/differential-datalog/pull/543#discussion_r386676118", "createdAt": "2020-03-02T21:59:08Z", "author": {"login": "mbudiu-vmw"}, "path": "rust/template/cmd_parser/parse.rs", "diffHunk": "@@ -406,6 +414,28 @@ fn test_string() {\n     );\n }\n \n+named!(serialized_val<&[u8], Record>,\n+    do_parse!(\n+        tag!(\"@\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d8c93e1a7b4712938462547f1af8622395762ad2"}, "originalPosition": 52}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY3NTYwNDc4", "url": "https://github.com/vmware/differential-datalog/pull/543#pullrequestreview-367560478", "createdAt": "2020-03-02T22:00:31Z", "commit": {"oid": "d8c93e1a7b4712938462547f1af8622395762ad2"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c9a7934beeaac4c2b52ff836a6cdd0c18cc32eea", "author": {"user": {"login": "ryzhyk", "name": "Leonid Ryzhyk"}}, "url": "https://github.com/vmware/differential-datalog/commit/c9a7934beeaac4c2b52ff836a6cdd0c18cc32eea", "committedDate": "2020-03-02T22:52:39Z", "message": "Deserialize records on the fly.\n\nConsider a scenario where input relations contain JSON strings.  These\nstrings are parsed using the recently added JSON lib and then DDlog goes\non to compute on the parsed data.  When working with large JSON\ndocuments where only a handful of attributes are actually used by DDlog,\nDDlog's memory footprint is dominated by unparsed JSON inputs.\n\nTo avoid this waste, we introduce a new record type that contains\nserialized data represented as a string.  DDlog parses this string using\nappropriate deserializer (currently, only json is supported) and drops\nthe string on the floor, keeping only the extracted data in memory.\n\nSyntactically, the new type of record is written down as\n`@<format><string_token>`, where `<string_token>` can be either a quoted\nstring literal or a reference to a file, e.g.:\n\n```\ninsert json_test.Deserialized[@json\"{\\\"@type\\\": \\\"t.V1\\\", \\\"b\\\": true}\"]\n```"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d8c93e1a7b4712938462547f1af8622395762ad2", "author": {"user": {"login": "ryzhyk", "name": "Leonid Ryzhyk"}}, "url": "https://github.com/vmware/differential-datalog/commit/d8c93e1a7b4712938462547f1af8622395762ad2", "committedDate": "2020-03-02T20:23:45Z", "message": "Deserialize records on the fly.\n\nConsider a scenario where input relations contain JSON strings.  These\nstrings are parsed using the recently added JSON lib and then DDlog goes\non to compute on the parsed data.  When working with large JSON\ndocuments where only a handful of attributes are actually used by DDlog,\nDDlog's memory footprint is dominated by unparsed JSON inputs.\n\nTo avoid this waste, we introduce a new record type that contains\nserialized data represented as a string.  DDlog parses this string using\nappropriate deserializer (currently, only json is supported) and drops\nthe string on the floor, keeping only the extracted data in memory.\n\nSyntactically, the new type of record is written down as\n`@<format><string_token>`, where `<string_token>` can be either a quoted\nstring literal or a reference to a file, e.g.:\n\n```\ninsert json_test.Deserialized[@json\"{\\\"@type\\\": \\\"t.V1\\\", \\\"b\\\": true}\"]\n```"}, "afterCommit": {"oid": "c9a7934beeaac4c2b52ff836a6cdd0c18cc32eea", "author": {"user": {"login": "ryzhyk", "name": "Leonid Ryzhyk"}}, "url": "https://github.com/vmware/differential-datalog/commit/c9a7934beeaac4c2b52ff836a6cdd0c18cc32eea", "committedDate": "2020-03-02T22:52:39Z", "message": "Deserialize records on the fly.\n\nConsider a scenario where input relations contain JSON strings.  These\nstrings are parsed using the recently added JSON lib and then DDlog goes\non to compute on the parsed data.  When working with large JSON\ndocuments where only a handful of attributes are actually used by DDlog,\nDDlog's memory footprint is dominated by unparsed JSON inputs.\n\nTo avoid this waste, we introduce a new record type that contains\nserialized data represented as a string.  DDlog parses this string using\nappropriate deserializer (currently, only json is supported) and drops\nthe string on the floor, keeping only the extracted data in memory.\n\nSyntactically, the new type of record is written down as\n`@<format><string_token>`, where `<string_token>` can be either a quoted\nstring literal or a reference to a file, e.g.:\n\n```\ninsert json_test.Deserialized[@json\"{\\\"@type\\\": \\\"t.V1\\\", \\\"b\\\": true}\"]\n```"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4653, "cost": 1, "resetAt": "2021-11-02T10:47:05Z"}}}