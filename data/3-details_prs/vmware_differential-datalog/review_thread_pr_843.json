{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMyOTM2NDY2", "number": 843, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxOTo0NToxNlrOFB9H0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QyMDowMDo0N1rOFB9hdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3NTk0MzIxOnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxOTo0NToxNlrOIA3qiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QyMDoyNjozOVrOIA5PbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc4MjkyMA==", "bodyText": "so you use two different parsers? Can't you standardize on one?", "url": "https://github.com/vmware/differential-datalog/pull/843#discussion_r537782920", "createdAt": "2020-12-07T19:45:16Z", "author": {"login": "mbudiu-vmw"}, "path": "sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java", "diffHunk": "@@ -107,6 +103,9 @@ public DDlogJooqProvider(final DDlogAPI dDlogAPI, final List<String> sqlStatemen\n         // We translate DDL statements from the Presto dialect to H2.\n         // We then execute these statements in a temporary database so that JOOQ can extract useful metadata\n         // that we will use later (for example, the record types for views).\n+        final com.facebook.presto.sql.parser.SqlParser parser = new com.facebook.presto.sql.parser.SqlParser();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39816ed18fbadb211b008dfcca47da8c6c3bae43"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzgwODc0OA==", "bodyText": "This has implications for the ddlog-sql compiler. Right now, that code expects DDL in Presto's dialect, which is why I have to convert from Presto's dialect here (and therefore need the Presto parser).", "url": "https://github.com/vmware/differential-datalog/pull/843#discussion_r537808748", "createdAt": "2020-12-07T20:26:39Z", "author": {"login": "lalithsuresh"}, "path": "sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java", "diffHunk": "@@ -107,6 +103,9 @@ public DDlogJooqProvider(final DDlogAPI dDlogAPI, final List<String> sqlStatemen\n         // We translate DDL statements from the Presto dialect to H2.\n         // We then execute these statements in a temporary database so that JOOQ can extract useful metadata\n         // that we will use later (for example, the record types for views).\n+        final com.facebook.presto.sql.parser.SqlParser parser = new com.facebook.presto.sql.parser.SqlParser();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc4MjkyMA=="}, "originalCommit": {"oid": "39816ed18fbadb211b008dfcca47da8c6c3bae43"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3NTk1NDg1OnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxOTo0Nzo0NVrOIA3xNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxOTo0Nzo0NVrOIA3xNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc4NDYzMQ==", "bodyText": "Why not visitSelect((SqlSelect)call)?", "url": "https://github.com/vmware/differential-datalog/pull/843#discussion_r537784631", "createdAt": "2020-12-07T19:47:45Z", "author": {"login": "mbudiu-vmw"}, "path": "sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java", "diffHunk": "@@ -175,227 +190,239 @@ private void onChange(final DDlogCommand<DDlogRecord> command) {\n         }\n     }\n \n-    private MockResult executeOne(final QueryContext context) throws SQLException {\n-        final Statement statement = parser.createStatement(context.sql(), options);\n-        final MockResult result = queryVisitor.process(statement, context);\n-        if (result == null) {\n-            throw new SQLException(\"Could not execute SQL statement \" + context);\n+    private final class QueryVisitor extends SqlBasicVisitor<MockResult> {\n+        private final QueryContext context;\n+\n+        QueryVisitor(final QueryContext context) {\n+            this.context = context;\n         }\n-        return result;\n-    }\n \n-    /*\n-     * Visits an SQL query and converts into a JOOQ MockResult type.\n-     */\n-    private class QueryVisitor extends AstVisitor<MockResult, QueryContext> {\n         @Override\n-        protected MockResult visitQuerySpecification(final QuerySpecification node, final QueryContext context) {\n-            // The checks below encode assumption A1 (see javadoc for the DDlogJooqProvider class)\n-            final Select select = node.getSelect();\n-            if (!(select.getSelectItems().size() == 1\n-                    && select.getSelectItems().get(0) instanceof AllColumns\n-                    && node.getFrom().isPresent()\n-                    && node.getFrom().get() instanceof com.facebook.presto.sql.tree.Table)) {\n-                throw new RuntimeException(\"Statement not supported: \" + context.sql());\n-            }\n-            final String tableName = ((com.facebook.presto.sql.tree.Table) node.getFrom().get()).getName().toString();\n-            final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n-            if (fields == null) {\n-                throw new RuntimeException(String.format(\"Unknown table %s queried in statement: %s\", tableName,\n-                                           context.sql()));\n+        public MockResult visit(final SqlCall call) {\n+            switch (call.getKind()) {\n+                case SELECT:\n+                    return visitSelect(call);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39816ed18fbadb211b008dfcca47da8c6c3bae43"}, "originalPosition": 192}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3NTk2MjA3OnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxOTo0OTo0NVrOIA31nQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QyMDoyOTo1NVrOIA5Xgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc4NTc1Nw==", "bodyText": "This is not checked, but I guess you will get an exception anyway if it's not just a table.", "url": "https://github.com/vmware/differential-datalog/pull/843#discussion_r537785757", "createdAt": "2020-12-07T19:49:45Z", "author": {"login": "mbudiu-vmw"}, "path": "sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java", "diffHunk": "@@ -175,227 +190,239 @@ private void onChange(final DDlogCommand<DDlogRecord> command) {\n         }\n     }\n \n-    private MockResult executeOne(final QueryContext context) throws SQLException {\n-        final Statement statement = parser.createStatement(context.sql(), options);\n-        final MockResult result = queryVisitor.process(statement, context);\n-        if (result == null) {\n-            throw new SQLException(\"Could not execute SQL statement \" + context);\n+    private final class QueryVisitor extends SqlBasicVisitor<MockResult> {\n+        private final QueryContext context;\n+\n+        QueryVisitor(final QueryContext context) {\n+            this.context = context;\n         }\n-        return result;\n-    }\n \n-    /*\n-     * Visits an SQL query and converts into a JOOQ MockResult type.\n-     */\n-    private class QueryVisitor extends AstVisitor<MockResult, QueryContext> {\n         @Override\n-        protected MockResult visitQuerySpecification(final QuerySpecification node, final QueryContext context) {\n-            // The checks below encode assumption A1 (see javadoc for the DDlogJooqProvider class)\n-            final Select select = node.getSelect();\n-            if (!(select.getSelectItems().size() == 1\n-                    && select.getSelectItems().get(0) instanceof AllColumns\n-                    && node.getFrom().isPresent()\n-                    && node.getFrom().get() instanceof com.facebook.presto.sql.tree.Table)) {\n-                throw new RuntimeException(\"Statement not supported: \" + context.sql());\n-            }\n-            final String tableName = ((com.facebook.presto.sql.tree.Table) node.getFrom().get()).getName().toString();\n-            final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n-            if (fields == null) {\n-                throw new RuntimeException(String.format(\"Unknown table %s queried in statement: %s\", tableName,\n-                                           context.sql()));\n+        public MockResult visit(final SqlCall call) {\n+            switch (call.getKind()) {\n+                case SELECT:\n+                    return visitSelect(call);\n+                case INSERT:\n+                    return visitInsert(call);\n+                case DELETE:\n+                    return visitDelete(call);\n+                case UPDATE:\n+                    return visitUpdate(call);\n+                default:\n+                    return exception(call.toString());\n             }\n-            final Result<Record> result = dslContext.newResult(fields);\n-            result.addAll(materializedViews.computeIfAbsent(tableName.toUpperCase(), (k) -> new LinkedHashSet<>()));\n-            return new MockResult(1, result);\n         }\n \n-        @Override\n-        protected MockResult visitQuery(final Query node, final QueryContext context) {\n-            final QuerySpecification specification = (QuerySpecification) node.getQueryBody();\n-            return visitQuerySpecification(specification, context);\n+        private MockResult visitSelect(final SqlCall call) {\n+            // The checks below encode assumption A1 (see javadoc for the DDlogJooqProvider class)\n+            final SqlSelect select = (SqlSelect) call;\n+            if (!(select.getSelectList().size() == 1\n+                    && select.getSelectList().get(0).toString().equals(\"*\"))) {\n+                return exception(\"Statement not supported: \" + context.sql());\n+            }\n+            final String tableName = ((SqlIdentifier) select.getFrom()).getSimple();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39816ed18fbadb211b008dfcca47da8c6c3bae43"}, "originalPosition": 218}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzgxMDgxOQ==", "bodyText": "Yes, I'm hoping it'll fail anyway.", "url": "https://github.com/vmware/differential-datalog/pull/843#discussion_r537810819", "createdAt": "2020-12-07T20:29:55Z", "author": {"login": "lalithsuresh"}, "path": "sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java", "diffHunk": "@@ -175,227 +190,239 @@ private void onChange(final DDlogCommand<DDlogRecord> command) {\n         }\n     }\n \n-    private MockResult executeOne(final QueryContext context) throws SQLException {\n-        final Statement statement = parser.createStatement(context.sql(), options);\n-        final MockResult result = queryVisitor.process(statement, context);\n-        if (result == null) {\n-            throw new SQLException(\"Could not execute SQL statement \" + context);\n+    private final class QueryVisitor extends SqlBasicVisitor<MockResult> {\n+        private final QueryContext context;\n+\n+        QueryVisitor(final QueryContext context) {\n+            this.context = context;\n         }\n-        return result;\n-    }\n \n-    /*\n-     * Visits an SQL query and converts into a JOOQ MockResult type.\n-     */\n-    private class QueryVisitor extends AstVisitor<MockResult, QueryContext> {\n         @Override\n-        protected MockResult visitQuerySpecification(final QuerySpecification node, final QueryContext context) {\n-            // The checks below encode assumption A1 (see javadoc for the DDlogJooqProvider class)\n-            final Select select = node.getSelect();\n-            if (!(select.getSelectItems().size() == 1\n-                    && select.getSelectItems().get(0) instanceof AllColumns\n-                    && node.getFrom().isPresent()\n-                    && node.getFrom().get() instanceof com.facebook.presto.sql.tree.Table)) {\n-                throw new RuntimeException(\"Statement not supported: \" + context.sql());\n-            }\n-            final String tableName = ((com.facebook.presto.sql.tree.Table) node.getFrom().get()).getName().toString();\n-            final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n-            if (fields == null) {\n-                throw new RuntimeException(String.format(\"Unknown table %s queried in statement: %s\", tableName,\n-                                           context.sql()));\n+        public MockResult visit(final SqlCall call) {\n+            switch (call.getKind()) {\n+                case SELECT:\n+                    return visitSelect(call);\n+                case INSERT:\n+                    return visitInsert(call);\n+                case DELETE:\n+                    return visitDelete(call);\n+                case UPDATE:\n+                    return visitUpdate(call);\n+                default:\n+                    return exception(call.toString());\n             }\n-            final Result<Record> result = dslContext.newResult(fields);\n-            result.addAll(materializedViews.computeIfAbsent(tableName.toUpperCase(), (k) -> new LinkedHashSet<>()));\n-            return new MockResult(1, result);\n         }\n \n-        @Override\n-        protected MockResult visitQuery(final Query node, final QueryContext context) {\n-            final QuerySpecification specification = (QuerySpecification) node.getQueryBody();\n-            return visitQuerySpecification(specification, context);\n+        private MockResult visitSelect(final SqlCall call) {\n+            // The checks below encode assumption A1 (see javadoc for the DDlogJooqProvider class)\n+            final SqlSelect select = (SqlSelect) call;\n+            if (!(select.getSelectList().size() == 1\n+                    && select.getSelectList().get(0).toString().equals(\"*\"))) {\n+                return exception(\"Statement not supported: \" + context.sql());\n+            }\n+            final String tableName = ((SqlIdentifier) select.getFrom()).getSimple();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc4NTc1Nw=="}, "originalCommit": {"oid": "39816ed18fbadb211b008dfcca47da8c6c3bae43"}, "originalPosition": 218}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3NTk2OTEzOnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxOTo1MToyNVrOIA35nQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxOTo1MToyNVrOIA35nQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc4Njc4MQ==", "bodyText": "other people put the else on the same line with the }", "url": "https://github.com/vmware/differential-datalog/pull/843#discussion_r537786781", "createdAt": "2020-12-07T19:51:25Z", "author": {"login": "mbudiu-vmw"}, "path": "sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java", "diffHunk": "@@ -175,227 +190,239 @@ private void onChange(final DDlogCommand<DDlogRecord> command) {\n         }\n     }\n \n-    private MockResult executeOne(final QueryContext context) throws SQLException {\n-        final Statement statement = parser.createStatement(context.sql(), options);\n-        final MockResult result = queryVisitor.process(statement, context);\n-        if (result == null) {\n-            throw new SQLException(\"Could not execute SQL statement \" + context);\n+    private final class QueryVisitor extends SqlBasicVisitor<MockResult> {\n+        private final QueryContext context;\n+\n+        QueryVisitor(final QueryContext context) {\n+            this.context = context;\n         }\n-        return result;\n-    }\n \n-    /*\n-     * Visits an SQL query and converts into a JOOQ MockResult type.\n-     */\n-    private class QueryVisitor extends AstVisitor<MockResult, QueryContext> {\n         @Override\n-        protected MockResult visitQuerySpecification(final QuerySpecification node, final QueryContext context) {\n-            // The checks below encode assumption A1 (see javadoc for the DDlogJooqProvider class)\n-            final Select select = node.getSelect();\n-            if (!(select.getSelectItems().size() == 1\n-                    && select.getSelectItems().get(0) instanceof AllColumns\n-                    && node.getFrom().isPresent()\n-                    && node.getFrom().get() instanceof com.facebook.presto.sql.tree.Table)) {\n-                throw new RuntimeException(\"Statement not supported: \" + context.sql());\n-            }\n-            final String tableName = ((com.facebook.presto.sql.tree.Table) node.getFrom().get()).getName().toString();\n-            final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n-            if (fields == null) {\n-                throw new RuntimeException(String.format(\"Unknown table %s queried in statement: %s\", tableName,\n-                                           context.sql()));\n+        public MockResult visit(final SqlCall call) {\n+            switch (call.getKind()) {\n+                case SELECT:\n+                    return visitSelect(call);\n+                case INSERT:\n+                    return visitInsert(call);\n+                case DELETE:\n+                    return visitDelete(call);\n+                case UPDATE:\n+                    return visitUpdate(call);\n+                default:\n+                    return exception(call.toString());\n             }\n-            final Result<Record> result = dslContext.newResult(fields);\n-            result.addAll(materializedViews.computeIfAbsent(tableName.toUpperCase(), (k) -> new LinkedHashSet<>()));\n-            return new MockResult(1, result);\n         }\n \n-        @Override\n-        protected MockResult visitQuery(final Query node, final QueryContext context) {\n-            final QuerySpecification specification = (QuerySpecification) node.getQueryBody();\n-            return visitQuerySpecification(specification, context);\n+        private MockResult visitSelect(final SqlCall call) {\n+            // The checks below encode assumption A1 (see javadoc for the DDlogJooqProvider class)\n+            final SqlSelect select = (SqlSelect) call;\n+            if (!(select.getSelectList().size() == 1\n+                    && select.getSelectList().get(0).toString().equals(\"*\"))) {\n+                return exception(\"Statement not supported: \" + context.sql());\n+            }\n+            final String tableName = ((SqlIdentifier) select.getFrom()).getSimple();\n+            final Result<Record> result = fetchTable(tableName);\n+            return new MockResult(1, result);\n         }\n \n-        @Override\n-        protected MockResult visitInsert(final Insert node, final QueryContext context) {\n-            try {\n-                // The assertions below encode assumption A2 (see javadoc for the DDlogJooqProvider class)\n-                if (!(node.getQuery().getQueryBody() instanceof Values)) {\n-                    throw new RuntimeException(\"Statement not supported: \" + context.sql());\n+        private MockResult visitInsert(final SqlCall call) {\n+            // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A2\n+            // (see javadoc for the DDlogJooqProvider class)\n+            final SqlInsert insert = (SqlInsert) call;\n+            if (insert.getSource().getKind() != SqlKind.VALUES) {\n+                return exception(call.toString());\n+            }\n+            final SqlNode[] values = ((SqlBasicCall) insert.getSource()).getOperands();\n+            final String tableName = ((SqlIdentifier) insert.getTargetTable()).getSimple();\n+            final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n+            final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n+            for (final SqlNode value: values) {\n+                if (value.getKind() != SqlKind.ROW) {\n+                    return exception(call.toString());\n                 }\n-                final Values values = (Values) node.getQuery().getQueryBody();\n-                final String tableName = node.getTarget().toString();\n-                final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n-                final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n-                for (final Expression row: values.getRows()) {\n-                    if (!(row instanceof Row)) {\n-                        throw new RuntimeException(\"Statement not supported: \" + context.sql());\n+                final SqlNode[] rowElements = ((SqlBasicCall) value).operands;\n+                final DDlogRecord[] recordsArray = new DDlogRecord[rowElements.length];\n+                if (context.hasBinding()) {\n+                    // Is a statement with bound variables\n+                    for (int i = 0; i < rowElements.length; i++) {\n+                        final boolean isNullableField = fields.get(i).getDataType().nullable();\n+                        final DDlogRecord record = toValue(fields.get(i), context.nextBinding());\n+                        recordsArray[i] = maybeOption(isNullableField, record);\n                     }\n-                    final List<Expression> items = ((Row) row).getItems();\n-                    if (items.size() != fields.size()) {\n-                        final String error = String.format(\"Incorrect row size for insertion into table %s. \" +\n-                                                   \"Please specify all the table's fields in their declared order: %s\",\n-                                                    tableName, context.sql());\n-                        throw new RuntimeException(error);\n-                    }\n-                    final DDlogRecord[] recordsArray = new DDlogRecord[items.size()];\n-                    if (context.hasBinding()) {\n-                        // Is a statement with bound variables\n-                        for (int i = 0; i < items.size(); i++) {\n-                            final boolean isNullableField = fields.get(i).getDataType().nullable();\n-                            final DDlogRecord record = toValue(fields.get(i), context.nextBinding());\n-                            recordsArray[i] = maybeOption(isNullableField, record);\n-                        }\n-                    }\n-                    else {\n-                        // need to parse literals into DDLogRecords\n-                        for (int i = 0; i < items.size(); i++) {\n-                            final boolean isNullableField = fields.get(i).getDataType().nullable();\n-                            recordsArray[i] = parseLiterals.process(items.get(i), isNullableField);\n-                        }\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39816ed18fbadb211b008dfcca47da8c6c3bae43"}, "originalPosition": 282}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3NTk3NjgxOnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxOTo1MzowN1rOIA3-AA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxOTo1MzowN1rOIA3-AA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc4NzkwNA==", "bodyText": "\"not supported\" sounds a bit better than \"unsupported\"", "url": "https://github.com/vmware/differential-datalog/pull/843#discussion_r537787904", "createdAt": "2020-12-07T19:53:07Z", "author": {"login": "mbudiu-vmw"}, "path": "sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java", "diffHunk": "@@ -175,227 +190,239 @@ private void onChange(final DDlogCommand<DDlogRecord> command) {\n         }\n     }\n \n-    private MockResult executeOne(final QueryContext context) throws SQLException {\n-        final Statement statement = parser.createStatement(context.sql(), options);\n-        final MockResult result = queryVisitor.process(statement, context);\n-        if (result == null) {\n-            throw new SQLException(\"Could not execute SQL statement \" + context);\n+    private final class QueryVisitor extends SqlBasicVisitor<MockResult> {\n+        private final QueryContext context;\n+\n+        QueryVisitor(final QueryContext context) {\n+            this.context = context;\n         }\n-        return result;\n-    }\n \n-    /*\n-     * Visits an SQL query and converts into a JOOQ MockResult type.\n-     */\n-    private class QueryVisitor extends AstVisitor<MockResult, QueryContext> {\n         @Override\n-        protected MockResult visitQuerySpecification(final QuerySpecification node, final QueryContext context) {\n-            // The checks below encode assumption A1 (see javadoc for the DDlogJooqProvider class)\n-            final Select select = node.getSelect();\n-            if (!(select.getSelectItems().size() == 1\n-                    && select.getSelectItems().get(0) instanceof AllColumns\n-                    && node.getFrom().isPresent()\n-                    && node.getFrom().get() instanceof com.facebook.presto.sql.tree.Table)) {\n-                throw new RuntimeException(\"Statement not supported: \" + context.sql());\n-            }\n-            final String tableName = ((com.facebook.presto.sql.tree.Table) node.getFrom().get()).getName().toString();\n-            final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n-            if (fields == null) {\n-                throw new RuntimeException(String.format(\"Unknown table %s queried in statement: %s\", tableName,\n-                                           context.sql()));\n+        public MockResult visit(final SqlCall call) {\n+            switch (call.getKind()) {\n+                case SELECT:\n+                    return visitSelect(call);\n+                case INSERT:\n+                    return visitInsert(call);\n+                case DELETE:\n+                    return visitDelete(call);\n+                case UPDATE:\n+                    return visitUpdate(call);\n+                default:\n+                    return exception(call.toString());\n             }\n-            final Result<Record> result = dslContext.newResult(fields);\n-            result.addAll(materializedViews.computeIfAbsent(tableName.toUpperCase(), (k) -> new LinkedHashSet<>()));\n-            return new MockResult(1, result);\n         }\n \n-        @Override\n-        protected MockResult visitQuery(final Query node, final QueryContext context) {\n-            final QuerySpecification specification = (QuerySpecification) node.getQueryBody();\n-            return visitQuerySpecification(specification, context);\n+        private MockResult visitSelect(final SqlCall call) {\n+            // The checks below encode assumption A1 (see javadoc for the DDlogJooqProvider class)\n+            final SqlSelect select = (SqlSelect) call;\n+            if (!(select.getSelectList().size() == 1\n+                    && select.getSelectList().get(0).toString().equals(\"*\"))) {\n+                return exception(\"Statement not supported: \" + context.sql());\n+            }\n+            final String tableName = ((SqlIdentifier) select.getFrom()).getSimple();\n+            final Result<Record> result = fetchTable(tableName);\n+            return new MockResult(1, result);\n         }\n \n-        @Override\n-        protected MockResult visitInsert(final Insert node, final QueryContext context) {\n-            try {\n-                // The assertions below encode assumption A2 (see javadoc for the DDlogJooqProvider class)\n-                if (!(node.getQuery().getQueryBody() instanceof Values)) {\n-                    throw new RuntimeException(\"Statement not supported: \" + context.sql());\n+        private MockResult visitInsert(final SqlCall call) {\n+            // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A2\n+            // (see javadoc for the DDlogJooqProvider class)\n+            final SqlInsert insert = (SqlInsert) call;\n+            if (insert.getSource().getKind() != SqlKind.VALUES) {\n+                return exception(call.toString());\n+            }\n+            final SqlNode[] values = ((SqlBasicCall) insert.getSource()).getOperands();\n+            final String tableName = ((SqlIdentifier) insert.getTargetTable()).getSimple();\n+            final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n+            final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n+            for (final SqlNode value: values) {\n+                if (value.getKind() != SqlKind.ROW) {\n+                    return exception(call.toString());\n                 }\n-                final Values values = (Values) node.getQuery().getQueryBody();\n-                final String tableName = node.getTarget().toString();\n-                final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n-                final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n-                for (final Expression row: values.getRows()) {\n-                    if (!(row instanceof Row)) {\n-                        throw new RuntimeException(\"Statement not supported: \" + context.sql());\n+                final SqlNode[] rowElements = ((SqlBasicCall) value).operands;\n+                final DDlogRecord[] recordsArray = new DDlogRecord[rowElements.length];\n+                if (context.hasBinding()) {\n+                    // Is a statement with bound variables\n+                    for (int i = 0; i < rowElements.length; i++) {\n+                        final boolean isNullableField = fields.get(i).getDataType().nullable();\n+                        final DDlogRecord record = toValue(fields.get(i), context.nextBinding());\n+                        recordsArray[i] = maybeOption(isNullableField, record);\n                     }\n-                    final List<Expression> items = ((Row) row).getItems();\n-                    if (items.size() != fields.size()) {\n-                        final String error = String.format(\"Incorrect row size for insertion into table %s. \" +\n-                                                   \"Please specify all the table's fields in their declared order: %s\",\n-                                                    tableName, context.sql());\n-                        throw new RuntimeException(error);\n-                    }\n-                    final DDlogRecord[] recordsArray = new DDlogRecord[items.size()];\n-                    if (context.hasBinding()) {\n-                        // Is a statement with bound variables\n-                        for (int i = 0; i < items.size(); i++) {\n-                            final boolean isNullableField = fields.get(i).getDataType().nullable();\n-                            final DDlogRecord record = toValue(fields.get(i), context.nextBinding());\n-                            recordsArray[i] = maybeOption(isNullableField, record);\n-                        }\n-                    }\n-                    else {\n-                        // need to parse literals into DDLogRecords\n-                        for (int i = 0; i < items.size(); i++) {\n-                            final boolean isNullableField = fields.get(i).getDataType().nullable();\n-                            recordsArray[i] = parseLiterals.process(items.get(i), isNullableField);\n-                        }\n+                }\n+                else {\n+                    // need to parse literals into DDLogRecords\n+                    for (int i = 0; i < rowElements.length; i++) {\n+                        final boolean isNullableField = fields.get(i).getDataType().nullable();\n+                        final DDlogRecord result = rowElements[i].accept(PARSE_LITERALS);\n+                        recordsArray[i] = maybeOption(isNullableField, result);\n                     }\n+                }\n+                try {\n                     final DDlogRecord record = DDlogRecord.makeStruct(ddlogTableTypeName(tableName), recordsArray);\n                     final DDlogRecCommand command = new DDlogRecCommand(DDlogCommand.Kind.Insert, tableId, record);\n                     dDlogAPI.applyUpdates(new DDlogRecCommand[]{command});\n+                } catch (final DDlogException e) {\n+                    return exception(e);\n                 }\n-                final Result<Record1<Integer>> result = dslContext.newResult(updateCountField);\n-                final Record1<Integer> resultRecord = dslContext.newRecord(updateCountField);\n-                resultRecord.setValue(updateCountField, values.getRows().size());\n-                result.add(resultRecord);\n-                return new MockResult(values.getRows().size(), result);\n-            } catch (DDlogException e) {\n-                throw new RuntimeException(e);\n             }\n+            final Result<Record1<Integer>> result = dslContext.newResult(updateCountField);\n+            final Record1<Integer> resultRecord = dslContext.newRecord(updateCountField);\n+            resultRecord.setValue(updateCountField, values.length);\n+            result.add(resultRecord);\n+            return new MockResult(values.length, result);\n         }\n \n-        @Override\n-        protected MockResult visitDelete(final Delete node, final QueryContext context) {\n+        private MockResult visitDelete(final SqlCall call) {\n             // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A3\n             // (see javadoc for the DDlogJooqProvider class)\n-            final String tableName = node.getTable().getName().toString();\n-            if (!node.getWhere().isPresent()) {\n-                throw new RuntimeException(\"Delete queries without where clauses are unsupported: \" + context.sql());\n+            final SqlDelete delete = (SqlDelete) call;\n+            final String tableName = ((SqlIdentifier) delete.getTargetTable()).getSimple();\n+            if (delete.getCondition() == null) {\n+                return exception(\"Delete queries without where clauses are unsupported: \" + context.sql());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39816ed18fbadb211b008dfcca47da8c6c3bae43"}, "originalPosition": 324}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3NTk3OTgyOnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxOTo1Mzo1OVrOIA3_2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QyMDozNjowNVrOIA5l-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc4ODM3Nw==", "bodyText": "this line occurs in every function, maybe you can make it a separate method and do some nicer error handling?", "url": "https://github.com/vmware/differential-datalog/pull/843#discussion_r537788377", "createdAt": "2020-12-07T19:53:59Z", "author": {"login": "mbudiu-vmw"}, "path": "sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java", "diffHunk": "@@ -175,227 +190,239 @@ private void onChange(final DDlogCommand<DDlogRecord> command) {\n         }\n     }\n \n-    private MockResult executeOne(final QueryContext context) throws SQLException {\n-        final Statement statement = parser.createStatement(context.sql(), options);\n-        final MockResult result = queryVisitor.process(statement, context);\n-        if (result == null) {\n-            throw new SQLException(\"Could not execute SQL statement \" + context);\n+    private final class QueryVisitor extends SqlBasicVisitor<MockResult> {\n+        private final QueryContext context;\n+\n+        QueryVisitor(final QueryContext context) {\n+            this.context = context;\n         }\n-        return result;\n-    }\n \n-    /*\n-     * Visits an SQL query and converts into a JOOQ MockResult type.\n-     */\n-    private class QueryVisitor extends AstVisitor<MockResult, QueryContext> {\n         @Override\n-        protected MockResult visitQuerySpecification(final QuerySpecification node, final QueryContext context) {\n-            // The checks below encode assumption A1 (see javadoc for the DDlogJooqProvider class)\n-            final Select select = node.getSelect();\n-            if (!(select.getSelectItems().size() == 1\n-                    && select.getSelectItems().get(0) instanceof AllColumns\n-                    && node.getFrom().isPresent()\n-                    && node.getFrom().get() instanceof com.facebook.presto.sql.tree.Table)) {\n-                throw new RuntimeException(\"Statement not supported: \" + context.sql());\n-            }\n-            final String tableName = ((com.facebook.presto.sql.tree.Table) node.getFrom().get()).getName().toString();\n-            final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n-            if (fields == null) {\n-                throw new RuntimeException(String.format(\"Unknown table %s queried in statement: %s\", tableName,\n-                                           context.sql()));\n+        public MockResult visit(final SqlCall call) {\n+            switch (call.getKind()) {\n+                case SELECT:\n+                    return visitSelect(call);\n+                case INSERT:\n+                    return visitInsert(call);\n+                case DELETE:\n+                    return visitDelete(call);\n+                case UPDATE:\n+                    return visitUpdate(call);\n+                default:\n+                    return exception(call.toString());\n             }\n-            final Result<Record> result = dslContext.newResult(fields);\n-            result.addAll(materializedViews.computeIfAbsent(tableName.toUpperCase(), (k) -> new LinkedHashSet<>()));\n-            return new MockResult(1, result);\n         }\n \n-        @Override\n-        protected MockResult visitQuery(final Query node, final QueryContext context) {\n-            final QuerySpecification specification = (QuerySpecification) node.getQueryBody();\n-            return visitQuerySpecification(specification, context);\n+        private MockResult visitSelect(final SqlCall call) {\n+            // The checks below encode assumption A1 (see javadoc for the DDlogJooqProvider class)\n+            final SqlSelect select = (SqlSelect) call;\n+            if (!(select.getSelectList().size() == 1\n+                    && select.getSelectList().get(0).toString().equals(\"*\"))) {\n+                return exception(\"Statement not supported: \" + context.sql());\n+            }\n+            final String tableName = ((SqlIdentifier) select.getFrom()).getSimple();\n+            final Result<Record> result = fetchTable(tableName);\n+            return new MockResult(1, result);\n         }\n \n-        @Override\n-        protected MockResult visitInsert(final Insert node, final QueryContext context) {\n-            try {\n-                // The assertions below encode assumption A2 (see javadoc for the DDlogJooqProvider class)\n-                if (!(node.getQuery().getQueryBody() instanceof Values)) {\n-                    throw new RuntimeException(\"Statement not supported: \" + context.sql());\n+        private MockResult visitInsert(final SqlCall call) {\n+            // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A2\n+            // (see javadoc for the DDlogJooqProvider class)\n+            final SqlInsert insert = (SqlInsert) call;\n+            if (insert.getSource().getKind() != SqlKind.VALUES) {\n+                return exception(call.toString());\n+            }\n+            final SqlNode[] values = ((SqlBasicCall) insert.getSource()).getOperands();\n+            final String tableName = ((SqlIdentifier) insert.getTargetTable()).getSimple();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39816ed18fbadb211b008dfcca47da8c6c3bae43"}, "originalPosition": 237}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzgxNDUyMQ==", "bodyText": "getTargetTable() and getFrom() are not abstract methods, so it won't be easy to have a single method to do this. I've added an instanceof check to the beginning of each visit method.", "url": "https://github.com/vmware/differential-datalog/pull/843#discussion_r537814521", "createdAt": "2020-12-07T20:36:05Z", "author": {"login": "lalithsuresh"}, "path": "sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java", "diffHunk": "@@ -175,227 +190,239 @@ private void onChange(final DDlogCommand<DDlogRecord> command) {\n         }\n     }\n \n-    private MockResult executeOne(final QueryContext context) throws SQLException {\n-        final Statement statement = parser.createStatement(context.sql(), options);\n-        final MockResult result = queryVisitor.process(statement, context);\n-        if (result == null) {\n-            throw new SQLException(\"Could not execute SQL statement \" + context);\n+    private final class QueryVisitor extends SqlBasicVisitor<MockResult> {\n+        private final QueryContext context;\n+\n+        QueryVisitor(final QueryContext context) {\n+            this.context = context;\n         }\n-        return result;\n-    }\n \n-    /*\n-     * Visits an SQL query and converts into a JOOQ MockResult type.\n-     */\n-    private class QueryVisitor extends AstVisitor<MockResult, QueryContext> {\n         @Override\n-        protected MockResult visitQuerySpecification(final QuerySpecification node, final QueryContext context) {\n-            // The checks below encode assumption A1 (see javadoc for the DDlogJooqProvider class)\n-            final Select select = node.getSelect();\n-            if (!(select.getSelectItems().size() == 1\n-                    && select.getSelectItems().get(0) instanceof AllColumns\n-                    && node.getFrom().isPresent()\n-                    && node.getFrom().get() instanceof com.facebook.presto.sql.tree.Table)) {\n-                throw new RuntimeException(\"Statement not supported: \" + context.sql());\n-            }\n-            final String tableName = ((com.facebook.presto.sql.tree.Table) node.getFrom().get()).getName().toString();\n-            final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n-            if (fields == null) {\n-                throw new RuntimeException(String.format(\"Unknown table %s queried in statement: %s\", tableName,\n-                                           context.sql()));\n+        public MockResult visit(final SqlCall call) {\n+            switch (call.getKind()) {\n+                case SELECT:\n+                    return visitSelect(call);\n+                case INSERT:\n+                    return visitInsert(call);\n+                case DELETE:\n+                    return visitDelete(call);\n+                case UPDATE:\n+                    return visitUpdate(call);\n+                default:\n+                    return exception(call.toString());\n             }\n-            final Result<Record> result = dslContext.newResult(fields);\n-            result.addAll(materializedViews.computeIfAbsent(tableName.toUpperCase(), (k) -> new LinkedHashSet<>()));\n-            return new MockResult(1, result);\n         }\n \n-        @Override\n-        protected MockResult visitQuery(final Query node, final QueryContext context) {\n-            final QuerySpecification specification = (QuerySpecification) node.getQueryBody();\n-            return visitQuerySpecification(specification, context);\n+        private MockResult visitSelect(final SqlCall call) {\n+            // The checks below encode assumption A1 (see javadoc for the DDlogJooqProvider class)\n+            final SqlSelect select = (SqlSelect) call;\n+            if (!(select.getSelectList().size() == 1\n+                    && select.getSelectList().get(0).toString().equals(\"*\"))) {\n+                return exception(\"Statement not supported: \" + context.sql());\n+            }\n+            final String tableName = ((SqlIdentifier) select.getFrom()).getSimple();\n+            final Result<Record> result = fetchTable(tableName);\n+            return new MockResult(1, result);\n         }\n \n-        @Override\n-        protected MockResult visitInsert(final Insert node, final QueryContext context) {\n-            try {\n-                // The assertions below encode assumption A2 (see javadoc for the DDlogJooqProvider class)\n-                if (!(node.getQuery().getQueryBody() instanceof Values)) {\n-                    throw new RuntimeException(\"Statement not supported: \" + context.sql());\n+        private MockResult visitInsert(final SqlCall call) {\n+            // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A2\n+            // (see javadoc for the DDlogJooqProvider class)\n+            final SqlInsert insert = (SqlInsert) call;\n+            if (insert.getSource().getKind() != SqlKind.VALUES) {\n+                return exception(call.toString());\n+            }\n+            final SqlNode[] values = ((SqlBasicCall) insert.getSource()).getOperands();\n+            final String tableName = ((SqlIdentifier) insert.getTargetTable()).getSimple();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc4ODM3Nw=="}, "originalCommit": {"oid": "39816ed18fbadb211b008dfcca47da8c6c3bae43"}, "originalPosition": 237}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3NTk4MzYzOnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxOTo1NDo1M1rOIA4CKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxOTo1NDo1M1rOIA4CKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc4ODk2OQ==", "bodyText": "do you want to lift getTargetColumnList out of the loop?", "url": "https://github.com/vmware/differential-datalog/pull/843#discussion_r537788969", "createdAt": "2020-12-07T19:54:53Z", "author": {"login": "mbudiu-vmw"}, "path": "sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java", "diffHunk": "@@ -175,227 +190,239 @@ private void onChange(final DDlogCommand<DDlogRecord> command) {\n         }\n     }\n \n-    private MockResult executeOne(final QueryContext context) throws SQLException {\n-        final Statement statement = parser.createStatement(context.sql(), options);\n-        final MockResult result = queryVisitor.process(statement, context);\n-        if (result == null) {\n-            throw new SQLException(\"Could not execute SQL statement \" + context);\n+    private final class QueryVisitor extends SqlBasicVisitor<MockResult> {\n+        private final QueryContext context;\n+\n+        QueryVisitor(final QueryContext context) {\n+            this.context = context;\n         }\n-        return result;\n-    }\n \n-    /*\n-     * Visits an SQL query and converts into a JOOQ MockResult type.\n-     */\n-    private class QueryVisitor extends AstVisitor<MockResult, QueryContext> {\n         @Override\n-        protected MockResult visitQuerySpecification(final QuerySpecification node, final QueryContext context) {\n-            // The checks below encode assumption A1 (see javadoc for the DDlogJooqProvider class)\n-            final Select select = node.getSelect();\n-            if (!(select.getSelectItems().size() == 1\n-                    && select.getSelectItems().get(0) instanceof AllColumns\n-                    && node.getFrom().isPresent()\n-                    && node.getFrom().get() instanceof com.facebook.presto.sql.tree.Table)) {\n-                throw new RuntimeException(\"Statement not supported: \" + context.sql());\n-            }\n-            final String tableName = ((com.facebook.presto.sql.tree.Table) node.getFrom().get()).getName().toString();\n-            final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n-            if (fields == null) {\n-                throw new RuntimeException(String.format(\"Unknown table %s queried in statement: %s\", tableName,\n-                                           context.sql()));\n+        public MockResult visit(final SqlCall call) {\n+            switch (call.getKind()) {\n+                case SELECT:\n+                    return visitSelect(call);\n+                case INSERT:\n+                    return visitInsert(call);\n+                case DELETE:\n+                    return visitDelete(call);\n+                case UPDATE:\n+                    return visitUpdate(call);\n+                default:\n+                    return exception(call.toString());\n             }\n-            final Result<Record> result = dslContext.newResult(fields);\n-            result.addAll(materializedViews.computeIfAbsent(tableName.toUpperCase(), (k) -> new LinkedHashSet<>()));\n-            return new MockResult(1, result);\n         }\n \n-        @Override\n-        protected MockResult visitQuery(final Query node, final QueryContext context) {\n-            final QuerySpecification specification = (QuerySpecification) node.getQueryBody();\n-            return visitQuerySpecification(specification, context);\n+        private MockResult visitSelect(final SqlCall call) {\n+            // The checks below encode assumption A1 (see javadoc for the DDlogJooqProvider class)\n+            final SqlSelect select = (SqlSelect) call;\n+            if (!(select.getSelectList().size() == 1\n+                    && select.getSelectList().get(0).toString().equals(\"*\"))) {\n+                return exception(\"Statement not supported: \" + context.sql());\n+            }\n+            final String tableName = ((SqlIdentifier) select.getFrom()).getSimple();\n+            final Result<Record> result = fetchTable(tableName);\n+            return new MockResult(1, result);\n         }\n \n-        @Override\n-        protected MockResult visitInsert(final Insert node, final QueryContext context) {\n-            try {\n-                // The assertions below encode assumption A2 (see javadoc for the DDlogJooqProvider class)\n-                if (!(node.getQuery().getQueryBody() instanceof Values)) {\n-                    throw new RuntimeException(\"Statement not supported: \" + context.sql());\n+        private MockResult visitInsert(final SqlCall call) {\n+            // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A2\n+            // (see javadoc for the DDlogJooqProvider class)\n+            final SqlInsert insert = (SqlInsert) call;\n+            if (insert.getSource().getKind() != SqlKind.VALUES) {\n+                return exception(call.toString());\n+            }\n+            final SqlNode[] values = ((SqlBasicCall) insert.getSource()).getOperands();\n+            final String tableName = ((SqlIdentifier) insert.getTargetTable()).getSimple();\n+            final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n+            final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n+            for (final SqlNode value: values) {\n+                if (value.getKind() != SqlKind.ROW) {\n+                    return exception(call.toString());\n                 }\n-                final Values values = (Values) node.getQuery().getQueryBody();\n-                final String tableName = node.getTarget().toString();\n-                final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n-                final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n-                for (final Expression row: values.getRows()) {\n-                    if (!(row instanceof Row)) {\n-                        throw new RuntimeException(\"Statement not supported: \" + context.sql());\n+                final SqlNode[] rowElements = ((SqlBasicCall) value).operands;\n+                final DDlogRecord[] recordsArray = new DDlogRecord[rowElements.length];\n+                if (context.hasBinding()) {\n+                    // Is a statement with bound variables\n+                    for (int i = 0; i < rowElements.length; i++) {\n+                        final boolean isNullableField = fields.get(i).getDataType().nullable();\n+                        final DDlogRecord record = toValue(fields.get(i), context.nextBinding());\n+                        recordsArray[i] = maybeOption(isNullableField, record);\n                     }\n-                    final List<Expression> items = ((Row) row).getItems();\n-                    if (items.size() != fields.size()) {\n-                        final String error = String.format(\"Incorrect row size for insertion into table %s. \" +\n-                                                   \"Please specify all the table's fields in their declared order: %s\",\n-                                                    tableName, context.sql());\n-                        throw new RuntimeException(error);\n-                    }\n-                    final DDlogRecord[] recordsArray = new DDlogRecord[items.size()];\n-                    if (context.hasBinding()) {\n-                        // Is a statement with bound variables\n-                        for (int i = 0; i < items.size(); i++) {\n-                            final boolean isNullableField = fields.get(i).getDataType().nullable();\n-                            final DDlogRecord record = toValue(fields.get(i), context.nextBinding());\n-                            recordsArray[i] = maybeOption(isNullableField, record);\n-                        }\n-                    }\n-                    else {\n-                        // need to parse literals into DDLogRecords\n-                        for (int i = 0; i < items.size(); i++) {\n-                            final boolean isNullableField = fields.get(i).getDataType().nullable();\n-                            recordsArray[i] = parseLiterals.process(items.get(i), isNullableField);\n-                        }\n+                }\n+                else {\n+                    // need to parse literals into DDLogRecords\n+                    for (int i = 0; i < rowElements.length; i++) {\n+                        final boolean isNullableField = fields.get(i).getDataType().nullable();\n+                        final DDlogRecord result = rowElements[i].accept(PARSE_LITERALS);\n+                        recordsArray[i] = maybeOption(isNullableField, result);\n                     }\n+                }\n+                try {\n                     final DDlogRecord record = DDlogRecord.makeStruct(ddlogTableTypeName(tableName), recordsArray);\n                     final DDlogRecCommand command = new DDlogRecCommand(DDlogCommand.Kind.Insert, tableId, record);\n                     dDlogAPI.applyUpdates(new DDlogRecCommand[]{command});\n+                } catch (final DDlogException e) {\n+                    return exception(e);\n                 }\n-                final Result<Record1<Integer>> result = dslContext.newResult(updateCountField);\n-                final Record1<Integer> resultRecord = dslContext.newRecord(updateCountField);\n-                resultRecord.setValue(updateCountField, values.getRows().size());\n-                result.add(resultRecord);\n-                return new MockResult(values.getRows().size(), result);\n-            } catch (DDlogException e) {\n-                throw new RuntimeException(e);\n             }\n+            final Result<Record1<Integer>> result = dslContext.newResult(updateCountField);\n+            final Record1<Integer> resultRecord = dslContext.newRecord(updateCountField);\n+            resultRecord.setValue(updateCountField, values.length);\n+            result.add(resultRecord);\n+            return new MockResult(values.length, result);\n         }\n \n-        @Override\n-        protected MockResult visitDelete(final Delete node, final QueryContext context) {\n+        private MockResult visitDelete(final SqlCall call) {\n             // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A3\n             // (see javadoc for the DDlogJooqProvider class)\n-            final String tableName = node.getTable().getName().toString();\n-            if (!node.getWhere().isPresent()) {\n-                throw new RuntimeException(\"Delete queries without where clauses are unsupported: \" + context.sql());\n+            final SqlDelete delete = (SqlDelete) call;\n+            final String tableName = ((SqlIdentifier) delete.getTargetTable()).getSimple();\n+            if (delete.getCondition() == null) {\n+                return exception(\"Delete queries without where clauses are unsupported: \" + context.sql());\n             }\n             try {\n-                final Expression where = node.getWhere().get();\n-                final ParseWhereClauseForDeletes visitor = new ParseWhereClauseForDeletes(tableName);\n-                visitor.process(where, context);\n-                final DDlogRecord[] matchExpression = visitor.matchExpressions;\n-                final DDlogRecord record = matchExpression.length > 1 ? DDlogRecord.makeTuple(matchExpression)\n-                                                                      : matchExpression[0];\n-\n+                final SqlBasicCall where = (SqlBasicCall) delete.getCondition();\n+                final List<? extends Field<?>> pkFields = tablesToPrimaryKeys.get(tableName.toUpperCase());\n+                final DDlogRecord record = matchExpressionFromWhere(where, pkFields, context);\n                 final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n                 final DDlogRecCommand command = new DDlogRecCommand(DDlogCommand.Kind.DeleteKey, tableId, record);\n                 dDlogAPI.applyUpdates(new DDlogRecCommand[]{command});\n             } catch (final DDlogException e) {\n-                throw new RuntimeException(e);\n+                return exception(e);\n             }\n             final Result<Record1<Integer>> result = dslContext.newResult(updateCountField);\n             final Record1<Integer> resultRecord = dslContext.newRecord(updateCountField);\n             resultRecord.setValue(updateCountField, 1);\n             result.add(resultRecord);\n             return new MockResult(1, result);\n         }\n-    }\n \n-    private class ParseWhereClauseForDeletes extends AstVisitor<Void, QueryContext> {\n-        final DDlogRecord[] matchExpressions;\n-        final String tableName;\n+        private MockResult visitUpdate(final SqlCall call) {\n+            // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A4\n+            // (see javadoc for the DDlogJooqProvider class)\n+            final SqlUpdate update = (SqlUpdate) call;\n+            final String tableName = ((SqlIdentifier) update.getTargetTable()).getSimple();\n+            if (update.getCondition() == null) {\n+                return exception(\"Delete queries without where clauses are unsupported: \" + context.sql());\n+            }\n+            try {\n+                final List<? extends Field<?>> allFields = tablesToFields.get(tableName.toUpperCase());\n+                final int numColumnsToUpdate = update.getTargetColumnList().size();\n+                final DDlogRecord[] updatedValues = new DDlogRecord[numColumnsToUpdate];\n+                final String[] columnsToUpdate = new String[numColumnsToUpdate];\n+                for (int i = 0; i < numColumnsToUpdate; i++) {\n+                    final String columnName = ((SqlIdentifier) update.getTargetColumnList().get(i)).getSimple()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39816ed18fbadb211b008dfcca47da8c6c3bae43"}, "originalPosition": 369}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3NTk4Nzg0OnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxOTo1NTo1M1rOIA4EpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxOTo1NTo1M1rOIA4EpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc4OTYwNQ==", "bodyText": "This is a linear search. Could become expensive if you have many fields. You could build a hashmap with this information...", "url": "https://github.com/vmware/differential-datalog/pull/843#discussion_r537789605", "createdAt": "2020-12-07T19:55:53Z", "author": {"login": "mbudiu-vmw"}, "path": "sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java", "diffHunk": "@@ -175,227 +190,239 @@ private void onChange(final DDlogCommand<DDlogRecord> command) {\n         }\n     }\n \n-    private MockResult executeOne(final QueryContext context) throws SQLException {\n-        final Statement statement = parser.createStatement(context.sql(), options);\n-        final MockResult result = queryVisitor.process(statement, context);\n-        if (result == null) {\n-            throw new SQLException(\"Could not execute SQL statement \" + context);\n+    private final class QueryVisitor extends SqlBasicVisitor<MockResult> {\n+        private final QueryContext context;\n+\n+        QueryVisitor(final QueryContext context) {\n+            this.context = context;\n         }\n-        return result;\n-    }\n \n-    /*\n-     * Visits an SQL query and converts into a JOOQ MockResult type.\n-     */\n-    private class QueryVisitor extends AstVisitor<MockResult, QueryContext> {\n         @Override\n-        protected MockResult visitQuerySpecification(final QuerySpecification node, final QueryContext context) {\n-            // The checks below encode assumption A1 (see javadoc for the DDlogJooqProvider class)\n-            final Select select = node.getSelect();\n-            if (!(select.getSelectItems().size() == 1\n-                    && select.getSelectItems().get(0) instanceof AllColumns\n-                    && node.getFrom().isPresent()\n-                    && node.getFrom().get() instanceof com.facebook.presto.sql.tree.Table)) {\n-                throw new RuntimeException(\"Statement not supported: \" + context.sql());\n-            }\n-            final String tableName = ((com.facebook.presto.sql.tree.Table) node.getFrom().get()).getName().toString();\n-            final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n-            if (fields == null) {\n-                throw new RuntimeException(String.format(\"Unknown table %s queried in statement: %s\", tableName,\n-                                           context.sql()));\n+        public MockResult visit(final SqlCall call) {\n+            switch (call.getKind()) {\n+                case SELECT:\n+                    return visitSelect(call);\n+                case INSERT:\n+                    return visitInsert(call);\n+                case DELETE:\n+                    return visitDelete(call);\n+                case UPDATE:\n+                    return visitUpdate(call);\n+                default:\n+                    return exception(call.toString());\n             }\n-            final Result<Record> result = dslContext.newResult(fields);\n-            result.addAll(materializedViews.computeIfAbsent(tableName.toUpperCase(), (k) -> new LinkedHashSet<>()));\n-            return new MockResult(1, result);\n         }\n \n-        @Override\n-        protected MockResult visitQuery(final Query node, final QueryContext context) {\n-            final QuerySpecification specification = (QuerySpecification) node.getQueryBody();\n-            return visitQuerySpecification(specification, context);\n+        private MockResult visitSelect(final SqlCall call) {\n+            // The checks below encode assumption A1 (see javadoc for the DDlogJooqProvider class)\n+            final SqlSelect select = (SqlSelect) call;\n+            if (!(select.getSelectList().size() == 1\n+                    && select.getSelectList().get(0).toString().equals(\"*\"))) {\n+                return exception(\"Statement not supported: \" + context.sql());\n+            }\n+            final String tableName = ((SqlIdentifier) select.getFrom()).getSimple();\n+            final Result<Record> result = fetchTable(tableName);\n+            return new MockResult(1, result);\n         }\n \n-        @Override\n-        protected MockResult visitInsert(final Insert node, final QueryContext context) {\n-            try {\n-                // The assertions below encode assumption A2 (see javadoc for the DDlogJooqProvider class)\n-                if (!(node.getQuery().getQueryBody() instanceof Values)) {\n-                    throw new RuntimeException(\"Statement not supported: \" + context.sql());\n+        private MockResult visitInsert(final SqlCall call) {\n+            // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A2\n+            // (see javadoc for the DDlogJooqProvider class)\n+            final SqlInsert insert = (SqlInsert) call;\n+            if (insert.getSource().getKind() != SqlKind.VALUES) {\n+                return exception(call.toString());\n+            }\n+            final SqlNode[] values = ((SqlBasicCall) insert.getSource()).getOperands();\n+            final String tableName = ((SqlIdentifier) insert.getTargetTable()).getSimple();\n+            final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n+            final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n+            for (final SqlNode value: values) {\n+                if (value.getKind() != SqlKind.ROW) {\n+                    return exception(call.toString());\n                 }\n-                final Values values = (Values) node.getQuery().getQueryBody();\n-                final String tableName = node.getTarget().toString();\n-                final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n-                final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n-                for (final Expression row: values.getRows()) {\n-                    if (!(row instanceof Row)) {\n-                        throw new RuntimeException(\"Statement not supported: \" + context.sql());\n+                final SqlNode[] rowElements = ((SqlBasicCall) value).operands;\n+                final DDlogRecord[] recordsArray = new DDlogRecord[rowElements.length];\n+                if (context.hasBinding()) {\n+                    // Is a statement with bound variables\n+                    for (int i = 0; i < rowElements.length; i++) {\n+                        final boolean isNullableField = fields.get(i).getDataType().nullable();\n+                        final DDlogRecord record = toValue(fields.get(i), context.nextBinding());\n+                        recordsArray[i] = maybeOption(isNullableField, record);\n                     }\n-                    final List<Expression> items = ((Row) row).getItems();\n-                    if (items.size() != fields.size()) {\n-                        final String error = String.format(\"Incorrect row size for insertion into table %s. \" +\n-                                                   \"Please specify all the table's fields in their declared order: %s\",\n-                                                    tableName, context.sql());\n-                        throw new RuntimeException(error);\n-                    }\n-                    final DDlogRecord[] recordsArray = new DDlogRecord[items.size()];\n-                    if (context.hasBinding()) {\n-                        // Is a statement with bound variables\n-                        for (int i = 0; i < items.size(); i++) {\n-                            final boolean isNullableField = fields.get(i).getDataType().nullable();\n-                            final DDlogRecord record = toValue(fields.get(i), context.nextBinding());\n-                            recordsArray[i] = maybeOption(isNullableField, record);\n-                        }\n-                    }\n-                    else {\n-                        // need to parse literals into DDLogRecords\n-                        for (int i = 0; i < items.size(); i++) {\n-                            final boolean isNullableField = fields.get(i).getDataType().nullable();\n-                            recordsArray[i] = parseLiterals.process(items.get(i), isNullableField);\n-                        }\n+                }\n+                else {\n+                    // need to parse literals into DDLogRecords\n+                    for (int i = 0; i < rowElements.length; i++) {\n+                        final boolean isNullableField = fields.get(i).getDataType().nullable();\n+                        final DDlogRecord result = rowElements[i].accept(PARSE_LITERALS);\n+                        recordsArray[i] = maybeOption(isNullableField, result);\n                     }\n+                }\n+                try {\n                     final DDlogRecord record = DDlogRecord.makeStruct(ddlogTableTypeName(tableName), recordsArray);\n                     final DDlogRecCommand command = new DDlogRecCommand(DDlogCommand.Kind.Insert, tableId, record);\n                     dDlogAPI.applyUpdates(new DDlogRecCommand[]{command});\n+                } catch (final DDlogException e) {\n+                    return exception(e);\n                 }\n-                final Result<Record1<Integer>> result = dslContext.newResult(updateCountField);\n-                final Record1<Integer> resultRecord = dslContext.newRecord(updateCountField);\n-                resultRecord.setValue(updateCountField, values.getRows().size());\n-                result.add(resultRecord);\n-                return new MockResult(values.getRows().size(), result);\n-            } catch (DDlogException e) {\n-                throw new RuntimeException(e);\n             }\n+            final Result<Record1<Integer>> result = dslContext.newResult(updateCountField);\n+            final Record1<Integer> resultRecord = dslContext.newRecord(updateCountField);\n+            resultRecord.setValue(updateCountField, values.length);\n+            result.add(resultRecord);\n+            return new MockResult(values.length, result);\n         }\n \n-        @Override\n-        protected MockResult visitDelete(final Delete node, final QueryContext context) {\n+        private MockResult visitDelete(final SqlCall call) {\n             // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A3\n             // (see javadoc for the DDlogJooqProvider class)\n-            final String tableName = node.getTable().getName().toString();\n-            if (!node.getWhere().isPresent()) {\n-                throw new RuntimeException(\"Delete queries without where clauses are unsupported: \" + context.sql());\n+            final SqlDelete delete = (SqlDelete) call;\n+            final String tableName = ((SqlIdentifier) delete.getTargetTable()).getSimple();\n+            if (delete.getCondition() == null) {\n+                return exception(\"Delete queries without where clauses are unsupported: \" + context.sql());\n             }\n             try {\n-                final Expression where = node.getWhere().get();\n-                final ParseWhereClauseForDeletes visitor = new ParseWhereClauseForDeletes(tableName);\n-                visitor.process(where, context);\n-                final DDlogRecord[] matchExpression = visitor.matchExpressions;\n-                final DDlogRecord record = matchExpression.length > 1 ? DDlogRecord.makeTuple(matchExpression)\n-                                                                      : matchExpression[0];\n-\n+                final SqlBasicCall where = (SqlBasicCall) delete.getCondition();\n+                final List<? extends Field<?>> pkFields = tablesToPrimaryKeys.get(tableName.toUpperCase());\n+                final DDlogRecord record = matchExpressionFromWhere(where, pkFields, context);\n                 final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n                 final DDlogRecCommand command = new DDlogRecCommand(DDlogCommand.Kind.DeleteKey, tableId, record);\n                 dDlogAPI.applyUpdates(new DDlogRecCommand[]{command});\n             } catch (final DDlogException e) {\n-                throw new RuntimeException(e);\n+                return exception(e);\n             }\n             final Result<Record1<Integer>> result = dslContext.newResult(updateCountField);\n             final Record1<Integer> resultRecord = dslContext.newRecord(updateCountField);\n             resultRecord.setValue(updateCountField, 1);\n             result.add(resultRecord);\n             return new MockResult(1, result);\n         }\n-    }\n \n-    private class ParseWhereClauseForDeletes extends AstVisitor<Void, QueryContext> {\n-        final DDlogRecord[] matchExpressions;\n-        final String tableName;\n+        private MockResult visitUpdate(final SqlCall call) {\n+            // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A4\n+            // (see javadoc for the DDlogJooqProvider class)\n+            final SqlUpdate update = (SqlUpdate) call;\n+            final String tableName = ((SqlIdentifier) update.getTargetTable()).getSimple();\n+            if (update.getCondition() == null) {\n+                return exception(\"Delete queries without where clauses are unsupported: \" + context.sql());\n+            }\n+            try {\n+                final List<? extends Field<?>> allFields = tablesToFields.get(tableName.toUpperCase());\n+                final int numColumnsToUpdate = update.getTargetColumnList().size();\n+                final DDlogRecord[] updatedValues = new DDlogRecord[numColumnsToUpdate];\n+                final String[] columnsToUpdate = new String[numColumnsToUpdate];\n+                for (int i = 0; i < numColumnsToUpdate; i++) {\n+                    final String columnName = ((SqlIdentifier) update.getTargetColumnList().get(i)).getSimple()\n+                            .toLowerCase();\n+                    final Field<?> field = allFields.stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39816ed18fbadb211b008dfcca47da8c6c3bae43"}, "originalPosition": 371}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3NjAwNDMxOnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QxOTo1OTozOFrOIA4ONA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QyMzowNDowOVrOIA-zag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc5MjA1Mg==", "bodyText": "what does this do, concatenate the arrays?", "url": "https://github.com/vmware/differential-datalog/pull/843#discussion_r537792052", "createdAt": "2020-12-07T19:59:38Z", "author": {"login": "mbudiu-vmw"}, "path": "sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java", "diffHunk": "@@ -175,227 +190,239 @@ private void onChange(final DDlogCommand<DDlogRecord> command) {\n         }\n     }\n \n-    private MockResult executeOne(final QueryContext context) throws SQLException {\n-        final Statement statement = parser.createStatement(context.sql(), options);\n-        final MockResult result = queryVisitor.process(statement, context);\n-        if (result == null) {\n-            throw new SQLException(\"Could not execute SQL statement \" + context);\n+    private final class QueryVisitor extends SqlBasicVisitor<MockResult> {\n+        private final QueryContext context;\n+\n+        QueryVisitor(final QueryContext context) {\n+            this.context = context;\n         }\n-        return result;\n-    }\n \n-    /*\n-     * Visits an SQL query and converts into a JOOQ MockResult type.\n-     */\n-    private class QueryVisitor extends AstVisitor<MockResult, QueryContext> {\n         @Override\n-        protected MockResult visitQuerySpecification(final QuerySpecification node, final QueryContext context) {\n-            // The checks below encode assumption A1 (see javadoc for the DDlogJooqProvider class)\n-            final Select select = node.getSelect();\n-            if (!(select.getSelectItems().size() == 1\n-                    && select.getSelectItems().get(0) instanceof AllColumns\n-                    && node.getFrom().isPresent()\n-                    && node.getFrom().get() instanceof com.facebook.presto.sql.tree.Table)) {\n-                throw new RuntimeException(\"Statement not supported: \" + context.sql());\n-            }\n-            final String tableName = ((com.facebook.presto.sql.tree.Table) node.getFrom().get()).getName().toString();\n-            final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n-            if (fields == null) {\n-                throw new RuntimeException(String.format(\"Unknown table %s queried in statement: %s\", tableName,\n-                                           context.sql()));\n+        public MockResult visit(final SqlCall call) {\n+            switch (call.getKind()) {\n+                case SELECT:\n+                    return visitSelect(call);\n+                case INSERT:\n+                    return visitInsert(call);\n+                case DELETE:\n+                    return visitDelete(call);\n+                case UPDATE:\n+                    return visitUpdate(call);\n+                default:\n+                    return exception(call.toString());\n             }\n-            final Result<Record> result = dslContext.newResult(fields);\n-            result.addAll(materializedViews.computeIfAbsent(tableName.toUpperCase(), (k) -> new LinkedHashSet<>()));\n-            return new MockResult(1, result);\n         }\n \n-        @Override\n-        protected MockResult visitQuery(final Query node, final QueryContext context) {\n-            final QuerySpecification specification = (QuerySpecification) node.getQueryBody();\n-            return visitQuerySpecification(specification, context);\n+        private MockResult visitSelect(final SqlCall call) {\n+            // The checks below encode assumption A1 (see javadoc for the DDlogJooqProvider class)\n+            final SqlSelect select = (SqlSelect) call;\n+            if (!(select.getSelectList().size() == 1\n+                    && select.getSelectList().get(0).toString().equals(\"*\"))) {\n+                return exception(\"Statement not supported: \" + context.sql());\n+            }\n+            final String tableName = ((SqlIdentifier) select.getFrom()).getSimple();\n+            final Result<Record> result = fetchTable(tableName);\n+            return new MockResult(1, result);\n         }\n \n-        @Override\n-        protected MockResult visitInsert(final Insert node, final QueryContext context) {\n-            try {\n-                // The assertions below encode assumption A2 (see javadoc for the DDlogJooqProvider class)\n-                if (!(node.getQuery().getQueryBody() instanceof Values)) {\n-                    throw new RuntimeException(\"Statement not supported: \" + context.sql());\n+        private MockResult visitInsert(final SqlCall call) {\n+            // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A2\n+            // (see javadoc for the DDlogJooqProvider class)\n+            final SqlInsert insert = (SqlInsert) call;\n+            if (insert.getSource().getKind() != SqlKind.VALUES) {\n+                return exception(call.toString());\n+            }\n+            final SqlNode[] values = ((SqlBasicCall) insert.getSource()).getOperands();\n+            final String tableName = ((SqlIdentifier) insert.getTargetTable()).getSimple();\n+            final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n+            final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n+            for (final SqlNode value: values) {\n+                if (value.getKind() != SqlKind.ROW) {\n+                    return exception(call.toString());\n                 }\n-                final Values values = (Values) node.getQuery().getQueryBody();\n-                final String tableName = node.getTarget().toString();\n-                final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n-                final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n-                for (final Expression row: values.getRows()) {\n-                    if (!(row instanceof Row)) {\n-                        throw new RuntimeException(\"Statement not supported: \" + context.sql());\n+                final SqlNode[] rowElements = ((SqlBasicCall) value).operands;\n+                final DDlogRecord[] recordsArray = new DDlogRecord[rowElements.length];\n+                if (context.hasBinding()) {\n+                    // Is a statement with bound variables\n+                    for (int i = 0; i < rowElements.length; i++) {\n+                        final boolean isNullableField = fields.get(i).getDataType().nullable();\n+                        final DDlogRecord record = toValue(fields.get(i), context.nextBinding());\n+                        recordsArray[i] = maybeOption(isNullableField, record);\n                     }\n-                    final List<Expression> items = ((Row) row).getItems();\n-                    if (items.size() != fields.size()) {\n-                        final String error = String.format(\"Incorrect row size for insertion into table %s. \" +\n-                                                   \"Please specify all the table's fields in their declared order: %s\",\n-                                                    tableName, context.sql());\n-                        throw new RuntimeException(error);\n-                    }\n-                    final DDlogRecord[] recordsArray = new DDlogRecord[items.size()];\n-                    if (context.hasBinding()) {\n-                        // Is a statement with bound variables\n-                        for (int i = 0; i < items.size(); i++) {\n-                            final boolean isNullableField = fields.get(i).getDataType().nullable();\n-                            final DDlogRecord record = toValue(fields.get(i), context.nextBinding());\n-                            recordsArray[i] = maybeOption(isNullableField, record);\n-                        }\n-                    }\n-                    else {\n-                        // need to parse literals into DDLogRecords\n-                        for (int i = 0; i < items.size(); i++) {\n-                            final boolean isNullableField = fields.get(i).getDataType().nullable();\n-                            recordsArray[i] = parseLiterals.process(items.get(i), isNullableField);\n-                        }\n+                }\n+                else {\n+                    // need to parse literals into DDLogRecords\n+                    for (int i = 0; i < rowElements.length; i++) {\n+                        final boolean isNullableField = fields.get(i).getDataType().nullable();\n+                        final DDlogRecord result = rowElements[i].accept(PARSE_LITERALS);\n+                        recordsArray[i] = maybeOption(isNullableField, result);\n                     }\n+                }\n+                try {\n                     final DDlogRecord record = DDlogRecord.makeStruct(ddlogTableTypeName(tableName), recordsArray);\n                     final DDlogRecCommand command = new DDlogRecCommand(DDlogCommand.Kind.Insert, tableId, record);\n                     dDlogAPI.applyUpdates(new DDlogRecCommand[]{command});\n+                } catch (final DDlogException e) {\n+                    return exception(e);\n                 }\n-                final Result<Record1<Integer>> result = dslContext.newResult(updateCountField);\n-                final Record1<Integer> resultRecord = dslContext.newRecord(updateCountField);\n-                resultRecord.setValue(updateCountField, values.getRows().size());\n-                result.add(resultRecord);\n-                return new MockResult(values.getRows().size(), result);\n-            } catch (DDlogException e) {\n-                throw new RuntimeException(e);\n             }\n+            final Result<Record1<Integer>> result = dslContext.newResult(updateCountField);\n+            final Record1<Integer> resultRecord = dslContext.newRecord(updateCountField);\n+            resultRecord.setValue(updateCountField, values.length);\n+            result.add(resultRecord);\n+            return new MockResult(values.length, result);\n         }\n \n-        @Override\n-        protected MockResult visitDelete(final Delete node, final QueryContext context) {\n+        private MockResult visitDelete(final SqlCall call) {\n             // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A3\n             // (see javadoc for the DDlogJooqProvider class)\n-            final String tableName = node.getTable().getName().toString();\n-            if (!node.getWhere().isPresent()) {\n-                throw new RuntimeException(\"Delete queries without where clauses are unsupported: \" + context.sql());\n+            final SqlDelete delete = (SqlDelete) call;\n+            final String tableName = ((SqlIdentifier) delete.getTargetTable()).getSimple();\n+            if (delete.getCondition() == null) {\n+                return exception(\"Delete queries without where clauses are unsupported: \" + context.sql());\n             }\n             try {\n-                final Expression where = node.getWhere().get();\n-                final ParseWhereClauseForDeletes visitor = new ParseWhereClauseForDeletes(tableName);\n-                visitor.process(where, context);\n-                final DDlogRecord[] matchExpression = visitor.matchExpressions;\n-                final DDlogRecord record = matchExpression.length > 1 ? DDlogRecord.makeTuple(matchExpression)\n-                                                                      : matchExpression[0];\n-\n+                final SqlBasicCall where = (SqlBasicCall) delete.getCondition();\n+                final List<? extends Field<?>> pkFields = tablesToPrimaryKeys.get(tableName.toUpperCase());\n+                final DDlogRecord record = matchExpressionFromWhere(where, pkFields, context);\n                 final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n                 final DDlogRecCommand command = new DDlogRecCommand(DDlogCommand.Kind.DeleteKey, tableId, record);\n                 dDlogAPI.applyUpdates(new DDlogRecCommand[]{command});\n             } catch (final DDlogException e) {\n-                throw new RuntimeException(e);\n+                return exception(e);\n             }\n             final Result<Record1<Integer>> result = dslContext.newResult(updateCountField);\n             final Record1<Integer> resultRecord = dslContext.newRecord(updateCountField);\n             resultRecord.setValue(updateCountField, 1);\n             result.add(resultRecord);\n             return new MockResult(1, result);\n         }\n-    }\n \n-    private class ParseWhereClauseForDeletes extends AstVisitor<Void, QueryContext> {\n-        final DDlogRecord[] matchExpressions;\n-        final String tableName;\n+        private MockResult visitUpdate(final SqlCall call) {\n+            // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A4\n+            // (see javadoc for the DDlogJooqProvider class)\n+            final SqlUpdate update = (SqlUpdate) call;\n+            final String tableName = ((SqlIdentifier) update.getTargetTable()).getSimple();\n+            if (update.getCondition() == null) {\n+                return exception(\"Delete queries without where clauses are unsupported: \" + context.sql());\n+            }\n+            try {\n+                final List<? extends Field<?>> allFields = tablesToFields.get(tableName.toUpperCase());\n+                final int numColumnsToUpdate = update.getTargetColumnList().size();\n+                final DDlogRecord[] updatedValues = new DDlogRecord[numColumnsToUpdate];\n+                final String[] columnsToUpdate = new String[numColumnsToUpdate];\n+                for (int i = 0; i < numColumnsToUpdate; i++) {\n+                    final String columnName = ((SqlIdentifier) update.getTargetColumnList().get(i)).getSimple()\n+                            .toLowerCase();\n+                    final Field<?> field = allFields.stream()\n+                            .filter(f -> f.getUnqualifiedName().last().equalsIgnoreCase(columnName))\n+                            .findFirst()\n+                            .get();\n+                    final boolean isNullableField = field.getDataType().nullable();\n+                    final DDlogRecord valueToUpdateTo = context.hasBinding()\n+                            ? toValue(field, context.nextBinding())\n+                            : update.getSourceExpressionList().accept(PARSE_LITERALS);\n+                    final DDlogRecord maybeWrapped = maybeOption(isNullableField, valueToUpdateTo);\n+                    updatedValues[i] = maybeWrapped;\n+                    columnsToUpdate[i] = columnName;\n+                }\n \n-        public ParseWhereClauseForDeletes(final String tableName) {\n-            this.tableName = tableName;\n-            matchExpressions = new DDlogRecord[tablesToPrimaryKeys.get(tableName.toUpperCase()).size()];\n-        }\n+                final SqlBasicCall where = (SqlBasicCall) update.getCondition();\n+                final List<? extends Field<?>> pkFields = tablesToPrimaryKeys.get(tableName.toUpperCase());\n+                final DDlogRecord key = matchExpressionFromWhere(where, pkFields, context);\n \n-        @Override\n-        protected Void visitLogicalBinaryExpression(final LogicalBinaryExpression node, final QueryContext context) {\n-            if (!node.getOperator().equals(LogicalBinaryExpression.Operator.AND)) {\n-                throw new RuntimeException(\"Only equality-based comparisons on \" +\n-                        \"all (not some) primary-key columns are allowed: \" + node);\n+                final DDlogRecord updateRecord = DDlogRecord.makeNamedStruct(\"\", columnsToUpdate, updatedValues);\n+                final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n+                final DDlogRecCommand command = new DDlogRecCommand(DDlogCommand.Kind.Modify, tableId, key, updateRecord);\n+                dDlogAPI.applyUpdates(new DDlogRecCommand[]{command});\n+            } catch (final DDlogException e) {\n+                return exception(e);\n             }\n-            return super.visitLogicalBinaryExpression(node, context);\n+            final Result<Record1<Integer>> result = dslContext.newResult(updateCountField);\n+            final Record1<Integer> resultRecord = dslContext.newRecord(updateCountField);\n+            resultRecord.setValue(updateCountField, 1);\n+            result.add(resultRecord);\n+            return new MockResult(1, result);\n+        }\n+    }\n+\n+    private static DDlogRecord matchExpressionFromWhere(final SqlBasicCall where,\n+                                                        final List<? extends Field<?>> pkFields,\n+                                                        final QueryContext context) throws DDlogException {\n+        final WhereClauseToMatchExpression visitor = new WhereClauseToMatchExpression(pkFields, context);\n+        final DDlogRecord[] matchExpression = where.accept(visitor);\n+        return matchExpression.length > 1 ? DDlogRecord.makeTuple(matchExpression)\n+                                                              : matchExpression[0];\n+    }\n+\n+    private static final class WhereClauseToMatchExpression extends SqlBasicVisitor<DDlogRecord[]> {\n+        private final DDlogRecord[] matchExpressions;\n+        private final QueryContext context;\n+        private final List<? extends Field<?>> pkFields;\n+\n+        public WhereClauseToMatchExpression(final List<? extends Field<?>> pkFields, final QueryContext context) {\n+            this.context = context;\n+            this.pkFields = pkFields;\n+            this.matchExpressions = new DDlogRecord[pkFields.size()];\n         }\n \n         @Override\n-        protected Void visitComparisonExpression(final ComparisonExpression node, final QueryContext context) {\n-            final Expression left = node.getLeft();\n-            final Expression right = node.getRight();\n-            if (context.hasBinding()) {\n-                if (left instanceof Identifier && right instanceof Parameter) {\n-                    setMatchExpression((Identifier) left, context.nextBinding());\n-                    return null;\n-                } else if (right instanceof Identifier && left instanceof Parameter) {\n-                    setMatchExpression((Identifier) right, context.nextBinding());\n-                    return null;\n-                }\n-            } else {\n-                if (left instanceof Identifier && right instanceof Literal) {\n-                    setMatchExpression((Identifier) left, (Literal) right);\n-                    return null;\n-                } else if (right instanceof Identifier && left instanceof Literal) {\n-                    setMatchExpression((Identifier) right, (Literal) left);\n-                    return null;\n-                }\n+        public DDlogRecord[] visit(final SqlCall call) {\n+            final SqlBasicCall expr = (SqlBasicCall) call;\n+            switch (expr.getOperator().getKind()) {\n+                case AND:\n+                    return super.visit(call);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39816ed18fbadb211b008dfcca47da8c6c3bae43"}, "originalPosition": 457}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg0MjYyOA==", "bodyText": "It should, it doesn't, and good catch. :) I'll add a test that exercises this case.", "url": "https://github.com/vmware/differential-datalog/pull/843#discussion_r537842628", "createdAt": "2020-12-07T21:23:14Z", "author": {"login": "lalithsuresh"}, "path": "sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java", "diffHunk": "@@ -175,227 +190,239 @@ private void onChange(final DDlogCommand<DDlogRecord> command) {\n         }\n     }\n \n-    private MockResult executeOne(final QueryContext context) throws SQLException {\n-        final Statement statement = parser.createStatement(context.sql(), options);\n-        final MockResult result = queryVisitor.process(statement, context);\n-        if (result == null) {\n-            throw new SQLException(\"Could not execute SQL statement \" + context);\n+    private final class QueryVisitor extends SqlBasicVisitor<MockResult> {\n+        private final QueryContext context;\n+\n+        QueryVisitor(final QueryContext context) {\n+            this.context = context;\n         }\n-        return result;\n-    }\n \n-    /*\n-     * Visits an SQL query and converts into a JOOQ MockResult type.\n-     */\n-    private class QueryVisitor extends AstVisitor<MockResult, QueryContext> {\n         @Override\n-        protected MockResult visitQuerySpecification(final QuerySpecification node, final QueryContext context) {\n-            // The checks below encode assumption A1 (see javadoc for the DDlogJooqProvider class)\n-            final Select select = node.getSelect();\n-            if (!(select.getSelectItems().size() == 1\n-                    && select.getSelectItems().get(0) instanceof AllColumns\n-                    && node.getFrom().isPresent()\n-                    && node.getFrom().get() instanceof com.facebook.presto.sql.tree.Table)) {\n-                throw new RuntimeException(\"Statement not supported: \" + context.sql());\n-            }\n-            final String tableName = ((com.facebook.presto.sql.tree.Table) node.getFrom().get()).getName().toString();\n-            final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n-            if (fields == null) {\n-                throw new RuntimeException(String.format(\"Unknown table %s queried in statement: %s\", tableName,\n-                                           context.sql()));\n+        public MockResult visit(final SqlCall call) {\n+            switch (call.getKind()) {\n+                case SELECT:\n+                    return visitSelect(call);\n+                case INSERT:\n+                    return visitInsert(call);\n+                case DELETE:\n+                    return visitDelete(call);\n+                case UPDATE:\n+                    return visitUpdate(call);\n+                default:\n+                    return exception(call.toString());\n             }\n-            final Result<Record> result = dslContext.newResult(fields);\n-            result.addAll(materializedViews.computeIfAbsent(tableName.toUpperCase(), (k) -> new LinkedHashSet<>()));\n-            return new MockResult(1, result);\n         }\n \n-        @Override\n-        protected MockResult visitQuery(final Query node, final QueryContext context) {\n-            final QuerySpecification specification = (QuerySpecification) node.getQueryBody();\n-            return visitQuerySpecification(specification, context);\n+        private MockResult visitSelect(final SqlCall call) {\n+            // The checks below encode assumption A1 (see javadoc for the DDlogJooqProvider class)\n+            final SqlSelect select = (SqlSelect) call;\n+            if (!(select.getSelectList().size() == 1\n+                    && select.getSelectList().get(0).toString().equals(\"*\"))) {\n+                return exception(\"Statement not supported: \" + context.sql());\n+            }\n+            final String tableName = ((SqlIdentifier) select.getFrom()).getSimple();\n+            final Result<Record> result = fetchTable(tableName);\n+            return new MockResult(1, result);\n         }\n \n-        @Override\n-        protected MockResult visitInsert(final Insert node, final QueryContext context) {\n-            try {\n-                // The assertions below encode assumption A2 (see javadoc for the DDlogJooqProvider class)\n-                if (!(node.getQuery().getQueryBody() instanceof Values)) {\n-                    throw new RuntimeException(\"Statement not supported: \" + context.sql());\n+        private MockResult visitInsert(final SqlCall call) {\n+            // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A2\n+            // (see javadoc for the DDlogJooqProvider class)\n+            final SqlInsert insert = (SqlInsert) call;\n+            if (insert.getSource().getKind() != SqlKind.VALUES) {\n+                return exception(call.toString());\n+            }\n+            final SqlNode[] values = ((SqlBasicCall) insert.getSource()).getOperands();\n+            final String tableName = ((SqlIdentifier) insert.getTargetTable()).getSimple();\n+            final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n+            final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n+            for (final SqlNode value: values) {\n+                if (value.getKind() != SqlKind.ROW) {\n+                    return exception(call.toString());\n                 }\n-                final Values values = (Values) node.getQuery().getQueryBody();\n-                final String tableName = node.getTarget().toString();\n-                final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n-                final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n-                for (final Expression row: values.getRows()) {\n-                    if (!(row instanceof Row)) {\n-                        throw new RuntimeException(\"Statement not supported: \" + context.sql());\n+                final SqlNode[] rowElements = ((SqlBasicCall) value).operands;\n+                final DDlogRecord[] recordsArray = new DDlogRecord[rowElements.length];\n+                if (context.hasBinding()) {\n+                    // Is a statement with bound variables\n+                    for (int i = 0; i < rowElements.length; i++) {\n+                        final boolean isNullableField = fields.get(i).getDataType().nullable();\n+                        final DDlogRecord record = toValue(fields.get(i), context.nextBinding());\n+                        recordsArray[i] = maybeOption(isNullableField, record);\n                     }\n-                    final List<Expression> items = ((Row) row).getItems();\n-                    if (items.size() != fields.size()) {\n-                        final String error = String.format(\"Incorrect row size for insertion into table %s. \" +\n-                                                   \"Please specify all the table's fields in their declared order: %s\",\n-                                                    tableName, context.sql());\n-                        throw new RuntimeException(error);\n-                    }\n-                    final DDlogRecord[] recordsArray = new DDlogRecord[items.size()];\n-                    if (context.hasBinding()) {\n-                        // Is a statement with bound variables\n-                        for (int i = 0; i < items.size(); i++) {\n-                            final boolean isNullableField = fields.get(i).getDataType().nullable();\n-                            final DDlogRecord record = toValue(fields.get(i), context.nextBinding());\n-                            recordsArray[i] = maybeOption(isNullableField, record);\n-                        }\n-                    }\n-                    else {\n-                        // need to parse literals into DDLogRecords\n-                        for (int i = 0; i < items.size(); i++) {\n-                            final boolean isNullableField = fields.get(i).getDataType().nullable();\n-                            recordsArray[i] = parseLiterals.process(items.get(i), isNullableField);\n-                        }\n+                }\n+                else {\n+                    // need to parse literals into DDLogRecords\n+                    for (int i = 0; i < rowElements.length; i++) {\n+                        final boolean isNullableField = fields.get(i).getDataType().nullable();\n+                        final DDlogRecord result = rowElements[i].accept(PARSE_LITERALS);\n+                        recordsArray[i] = maybeOption(isNullableField, result);\n                     }\n+                }\n+                try {\n                     final DDlogRecord record = DDlogRecord.makeStruct(ddlogTableTypeName(tableName), recordsArray);\n                     final DDlogRecCommand command = new DDlogRecCommand(DDlogCommand.Kind.Insert, tableId, record);\n                     dDlogAPI.applyUpdates(new DDlogRecCommand[]{command});\n+                } catch (final DDlogException e) {\n+                    return exception(e);\n                 }\n-                final Result<Record1<Integer>> result = dslContext.newResult(updateCountField);\n-                final Record1<Integer> resultRecord = dslContext.newRecord(updateCountField);\n-                resultRecord.setValue(updateCountField, values.getRows().size());\n-                result.add(resultRecord);\n-                return new MockResult(values.getRows().size(), result);\n-            } catch (DDlogException e) {\n-                throw new RuntimeException(e);\n             }\n+            final Result<Record1<Integer>> result = dslContext.newResult(updateCountField);\n+            final Record1<Integer> resultRecord = dslContext.newRecord(updateCountField);\n+            resultRecord.setValue(updateCountField, values.length);\n+            result.add(resultRecord);\n+            return new MockResult(values.length, result);\n         }\n \n-        @Override\n-        protected MockResult visitDelete(final Delete node, final QueryContext context) {\n+        private MockResult visitDelete(final SqlCall call) {\n             // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A3\n             // (see javadoc for the DDlogJooqProvider class)\n-            final String tableName = node.getTable().getName().toString();\n-            if (!node.getWhere().isPresent()) {\n-                throw new RuntimeException(\"Delete queries without where clauses are unsupported: \" + context.sql());\n+            final SqlDelete delete = (SqlDelete) call;\n+            final String tableName = ((SqlIdentifier) delete.getTargetTable()).getSimple();\n+            if (delete.getCondition() == null) {\n+                return exception(\"Delete queries without where clauses are unsupported: \" + context.sql());\n             }\n             try {\n-                final Expression where = node.getWhere().get();\n-                final ParseWhereClauseForDeletes visitor = new ParseWhereClauseForDeletes(tableName);\n-                visitor.process(where, context);\n-                final DDlogRecord[] matchExpression = visitor.matchExpressions;\n-                final DDlogRecord record = matchExpression.length > 1 ? DDlogRecord.makeTuple(matchExpression)\n-                                                                      : matchExpression[0];\n-\n+                final SqlBasicCall where = (SqlBasicCall) delete.getCondition();\n+                final List<? extends Field<?>> pkFields = tablesToPrimaryKeys.get(tableName.toUpperCase());\n+                final DDlogRecord record = matchExpressionFromWhere(where, pkFields, context);\n                 final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n                 final DDlogRecCommand command = new DDlogRecCommand(DDlogCommand.Kind.DeleteKey, tableId, record);\n                 dDlogAPI.applyUpdates(new DDlogRecCommand[]{command});\n             } catch (final DDlogException e) {\n-                throw new RuntimeException(e);\n+                return exception(e);\n             }\n             final Result<Record1<Integer>> result = dslContext.newResult(updateCountField);\n             final Record1<Integer> resultRecord = dslContext.newRecord(updateCountField);\n             resultRecord.setValue(updateCountField, 1);\n             result.add(resultRecord);\n             return new MockResult(1, result);\n         }\n-    }\n \n-    private class ParseWhereClauseForDeletes extends AstVisitor<Void, QueryContext> {\n-        final DDlogRecord[] matchExpressions;\n-        final String tableName;\n+        private MockResult visitUpdate(final SqlCall call) {\n+            // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A4\n+            // (see javadoc for the DDlogJooqProvider class)\n+            final SqlUpdate update = (SqlUpdate) call;\n+            final String tableName = ((SqlIdentifier) update.getTargetTable()).getSimple();\n+            if (update.getCondition() == null) {\n+                return exception(\"Delete queries without where clauses are unsupported: \" + context.sql());\n+            }\n+            try {\n+                final List<? extends Field<?>> allFields = tablesToFields.get(tableName.toUpperCase());\n+                final int numColumnsToUpdate = update.getTargetColumnList().size();\n+                final DDlogRecord[] updatedValues = new DDlogRecord[numColumnsToUpdate];\n+                final String[] columnsToUpdate = new String[numColumnsToUpdate];\n+                for (int i = 0; i < numColumnsToUpdate; i++) {\n+                    final String columnName = ((SqlIdentifier) update.getTargetColumnList().get(i)).getSimple()\n+                            .toLowerCase();\n+                    final Field<?> field = allFields.stream()\n+                            .filter(f -> f.getUnqualifiedName().last().equalsIgnoreCase(columnName))\n+                            .findFirst()\n+                            .get();\n+                    final boolean isNullableField = field.getDataType().nullable();\n+                    final DDlogRecord valueToUpdateTo = context.hasBinding()\n+                            ? toValue(field, context.nextBinding())\n+                            : update.getSourceExpressionList().accept(PARSE_LITERALS);\n+                    final DDlogRecord maybeWrapped = maybeOption(isNullableField, valueToUpdateTo);\n+                    updatedValues[i] = maybeWrapped;\n+                    columnsToUpdate[i] = columnName;\n+                }\n \n-        public ParseWhereClauseForDeletes(final String tableName) {\n-            this.tableName = tableName;\n-            matchExpressions = new DDlogRecord[tablesToPrimaryKeys.get(tableName.toUpperCase()).size()];\n-        }\n+                final SqlBasicCall where = (SqlBasicCall) update.getCondition();\n+                final List<? extends Field<?>> pkFields = tablesToPrimaryKeys.get(tableName.toUpperCase());\n+                final DDlogRecord key = matchExpressionFromWhere(where, pkFields, context);\n \n-        @Override\n-        protected Void visitLogicalBinaryExpression(final LogicalBinaryExpression node, final QueryContext context) {\n-            if (!node.getOperator().equals(LogicalBinaryExpression.Operator.AND)) {\n-                throw new RuntimeException(\"Only equality-based comparisons on \" +\n-                        \"all (not some) primary-key columns are allowed: \" + node);\n+                final DDlogRecord updateRecord = DDlogRecord.makeNamedStruct(\"\", columnsToUpdate, updatedValues);\n+                final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n+                final DDlogRecCommand command = new DDlogRecCommand(DDlogCommand.Kind.Modify, tableId, key, updateRecord);\n+                dDlogAPI.applyUpdates(new DDlogRecCommand[]{command});\n+            } catch (final DDlogException e) {\n+                return exception(e);\n             }\n-            return super.visitLogicalBinaryExpression(node, context);\n+            final Result<Record1<Integer>> result = dslContext.newResult(updateCountField);\n+            final Record1<Integer> resultRecord = dslContext.newRecord(updateCountField);\n+            resultRecord.setValue(updateCountField, 1);\n+            result.add(resultRecord);\n+            return new MockResult(1, result);\n+        }\n+    }\n+\n+    private static DDlogRecord matchExpressionFromWhere(final SqlBasicCall where,\n+                                                        final List<? extends Field<?>> pkFields,\n+                                                        final QueryContext context) throws DDlogException {\n+        final WhereClauseToMatchExpression visitor = new WhereClauseToMatchExpression(pkFields, context);\n+        final DDlogRecord[] matchExpression = where.accept(visitor);\n+        return matchExpression.length > 1 ? DDlogRecord.makeTuple(matchExpression)\n+                                                              : matchExpression[0];\n+    }\n+\n+    private static final class WhereClauseToMatchExpression extends SqlBasicVisitor<DDlogRecord[]> {\n+        private final DDlogRecord[] matchExpressions;\n+        private final QueryContext context;\n+        private final List<? extends Field<?>> pkFields;\n+\n+        public WhereClauseToMatchExpression(final List<? extends Field<?>> pkFields, final QueryContext context) {\n+            this.context = context;\n+            this.pkFields = pkFields;\n+            this.matchExpressions = new DDlogRecord[pkFields.size()];\n         }\n \n         @Override\n-        protected Void visitComparisonExpression(final ComparisonExpression node, final QueryContext context) {\n-            final Expression left = node.getLeft();\n-            final Expression right = node.getRight();\n-            if (context.hasBinding()) {\n-                if (left instanceof Identifier && right instanceof Parameter) {\n-                    setMatchExpression((Identifier) left, context.nextBinding());\n-                    return null;\n-                } else if (right instanceof Identifier && left instanceof Parameter) {\n-                    setMatchExpression((Identifier) right, context.nextBinding());\n-                    return null;\n-                }\n-            } else {\n-                if (left instanceof Identifier && right instanceof Literal) {\n-                    setMatchExpression((Identifier) left, (Literal) right);\n-                    return null;\n-                } else if (right instanceof Identifier && left instanceof Literal) {\n-                    setMatchExpression((Identifier) right, (Literal) left);\n-                    return null;\n-                }\n+        public DDlogRecord[] visit(final SqlCall call) {\n+            final SqlBasicCall expr = (SqlBasicCall) call;\n+            switch (expr.getOperator().getKind()) {\n+                case AND:\n+                    return super.visit(call);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc5MjA1Mg=="}, "originalCommit": {"oid": "39816ed18fbadb211b008dfcca47da8c6c3bae43"}, "originalPosition": 457}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg5OTg4Mg==", "bodyText": "Actually, now that I look at the code, there's no change necessary. It just returns the matchExpressions[] array, which by the time that call returns, would have traversed every \"EQUALS\" node.\nI still need to add a test for this case. Will do that in the updated PR.", "url": "https://github.com/vmware/differential-datalog/pull/843#discussion_r537899882", "createdAt": "2020-12-07T23:04:09Z", "author": {"login": "lalithsuresh"}, "path": "sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java", "diffHunk": "@@ -175,227 +190,239 @@ private void onChange(final DDlogCommand<DDlogRecord> command) {\n         }\n     }\n \n-    private MockResult executeOne(final QueryContext context) throws SQLException {\n-        final Statement statement = parser.createStatement(context.sql(), options);\n-        final MockResult result = queryVisitor.process(statement, context);\n-        if (result == null) {\n-            throw new SQLException(\"Could not execute SQL statement \" + context);\n+    private final class QueryVisitor extends SqlBasicVisitor<MockResult> {\n+        private final QueryContext context;\n+\n+        QueryVisitor(final QueryContext context) {\n+            this.context = context;\n         }\n-        return result;\n-    }\n \n-    /*\n-     * Visits an SQL query and converts into a JOOQ MockResult type.\n-     */\n-    private class QueryVisitor extends AstVisitor<MockResult, QueryContext> {\n         @Override\n-        protected MockResult visitQuerySpecification(final QuerySpecification node, final QueryContext context) {\n-            // The checks below encode assumption A1 (see javadoc for the DDlogJooqProvider class)\n-            final Select select = node.getSelect();\n-            if (!(select.getSelectItems().size() == 1\n-                    && select.getSelectItems().get(0) instanceof AllColumns\n-                    && node.getFrom().isPresent()\n-                    && node.getFrom().get() instanceof com.facebook.presto.sql.tree.Table)) {\n-                throw new RuntimeException(\"Statement not supported: \" + context.sql());\n-            }\n-            final String tableName = ((com.facebook.presto.sql.tree.Table) node.getFrom().get()).getName().toString();\n-            final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n-            if (fields == null) {\n-                throw new RuntimeException(String.format(\"Unknown table %s queried in statement: %s\", tableName,\n-                                           context.sql()));\n+        public MockResult visit(final SqlCall call) {\n+            switch (call.getKind()) {\n+                case SELECT:\n+                    return visitSelect(call);\n+                case INSERT:\n+                    return visitInsert(call);\n+                case DELETE:\n+                    return visitDelete(call);\n+                case UPDATE:\n+                    return visitUpdate(call);\n+                default:\n+                    return exception(call.toString());\n             }\n-            final Result<Record> result = dslContext.newResult(fields);\n-            result.addAll(materializedViews.computeIfAbsent(tableName.toUpperCase(), (k) -> new LinkedHashSet<>()));\n-            return new MockResult(1, result);\n         }\n \n-        @Override\n-        protected MockResult visitQuery(final Query node, final QueryContext context) {\n-            final QuerySpecification specification = (QuerySpecification) node.getQueryBody();\n-            return visitQuerySpecification(specification, context);\n+        private MockResult visitSelect(final SqlCall call) {\n+            // The checks below encode assumption A1 (see javadoc for the DDlogJooqProvider class)\n+            final SqlSelect select = (SqlSelect) call;\n+            if (!(select.getSelectList().size() == 1\n+                    && select.getSelectList().get(0).toString().equals(\"*\"))) {\n+                return exception(\"Statement not supported: \" + context.sql());\n+            }\n+            final String tableName = ((SqlIdentifier) select.getFrom()).getSimple();\n+            final Result<Record> result = fetchTable(tableName);\n+            return new MockResult(1, result);\n         }\n \n-        @Override\n-        protected MockResult visitInsert(final Insert node, final QueryContext context) {\n-            try {\n-                // The assertions below encode assumption A2 (see javadoc for the DDlogJooqProvider class)\n-                if (!(node.getQuery().getQueryBody() instanceof Values)) {\n-                    throw new RuntimeException(\"Statement not supported: \" + context.sql());\n+        private MockResult visitInsert(final SqlCall call) {\n+            // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A2\n+            // (see javadoc for the DDlogJooqProvider class)\n+            final SqlInsert insert = (SqlInsert) call;\n+            if (insert.getSource().getKind() != SqlKind.VALUES) {\n+                return exception(call.toString());\n+            }\n+            final SqlNode[] values = ((SqlBasicCall) insert.getSource()).getOperands();\n+            final String tableName = ((SqlIdentifier) insert.getTargetTable()).getSimple();\n+            final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n+            final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n+            for (final SqlNode value: values) {\n+                if (value.getKind() != SqlKind.ROW) {\n+                    return exception(call.toString());\n                 }\n-                final Values values = (Values) node.getQuery().getQueryBody();\n-                final String tableName = node.getTarget().toString();\n-                final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n-                final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n-                for (final Expression row: values.getRows()) {\n-                    if (!(row instanceof Row)) {\n-                        throw new RuntimeException(\"Statement not supported: \" + context.sql());\n+                final SqlNode[] rowElements = ((SqlBasicCall) value).operands;\n+                final DDlogRecord[] recordsArray = new DDlogRecord[rowElements.length];\n+                if (context.hasBinding()) {\n+                    // Is a statement with bound variables\n+                    for (int i = 0; i < rowElements.length; i++) {\n+                        final boolean isNullableField = fields.get(i).getDataType().nullable();\n+                        final DDlogRecord record = toValue(fields.get(i), context.nextBinding());\n+                        recordsArray[i] = maybeOption(isNullableField, record);\n                     }\n-                    final List<Expression> items = ((Row) row).getItems();\n-                    if (items.size() != fields.size()) {\n-                        final String error = String.format(\"Incorrect row size for insertion into table %s. \" +\n-                                                   \"Please specify all the table's fields in their declared order: %s\",\n-                                                    tableName, context.sql());\n-                        throw new RuntimeException(error);\n-                    }\n-                    final DDlogRecord[] recordsArray = new DDlogRecord[items.size()];\n-                    if (context.hasBinding()) {\n-                        // Is a statement with bound variables\n-                        for (int i = 0; i < items.size(); i++) {\n-                            final boolean isNullableField = fields.get(i).getDataType().nullable();\n-                            final DDlogRecord record = toValue(fields.get(i), context.nextBinding());\n-                            recordsArray[i] = maybeOption(isNullableField, record);\n-                        }\n-                    }\n-                    else {\n-                        // need to parse literals into DDLogRecords\n-                        for (int i = 0; i < items.size(); i++) {\n-                            final boolean isNullableField = fields.get(i).getDataType().nullable();\n-                            recordsArray[i] = parseLiterals.process(items.get(i), isNullableField);\n-                        }\n+                }\n+                else {\n+                    // need to parse literals into DDLogRecords\n+                    for (int i = 0; i < rowElements.length; i++) {\n+                        final boolean isNullableField = fields.get(i).getDataType().nullable();\n+                        final DDlogRecord result = rowElements[i].accept(PARSE_LITERALS);\n+                        recordsArray[i] = maybeOption(isNullableField, result);\n                     }\n+                }\n+                try {\n                     final DDlogRecord record = DDlogRecord.makeStruct(ddlogTableTypeName(tableName), recordsArray);\n                     final DDlogRecCommand command = new DDlogRecCommand(DDlogCommand.Kind.Insert, tableId, record);\n                     dDlogAPI.applyUpdates(new DDlogRecCommand[]{command});\n+                } catch (final DDlogException e) {\n+                    return exception(e);\n                 }\n-                final Result<Record1<Integer>> result = dslContext.newResult(updateCountField);\n-                final Record1<Integer> resultRecord = dslContext.newRecord(updateCountField);\n-                resultRecord.setValue(updateCountField, values.getRows().size());\n-                result.add(resultRecord);\n-                return new MockResult(values.getRows().size(), result);\n-            } catch (DDlogException e) {\n-                throw new RuntimeException(e);\n             }\n+            final Result<Record1<Integer>> result = dslContext.newResult(updateCountField);\n+            final Record1<Integer> resultRecord = dslContext.newRecord(updateCountField);\n+            resultRecord.setValue(updateCountField, values.length);\n+            result.add(resultRecord);\n+            return new MockResult(values.length, result);\n         }\n \n-        @Override\n-        protected MockResult visitDelete(final Delete node, final QueryContext context) {\n+        private MockResult visitDelete(final SqlCall call) {\n             // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A3\n             // (see javadoc for the DDlogJooqProvider class)\n-            final String tableName = node.getTable().getName().toString();\n-            if (!node.getWhere().isPresent()) {\n-                throw new RuntimeException(\"Delete queries without where clauses are unsupported: \" + context.sql());\n+            final SqlDelete delete = (SqlDelete) call;\n+            final String tableName = ((SqlIdentifier) delete.getTargetTable()).getSimple();\n+            if (delete.getCondition() == null) {\n+                return exception(\"Delete queries without where clauses are unsupported: \" + context.sql());\n             }\n             try {\n-                final Expression where = node.getWhere().get();\n-                final ParseWhereClauseForDeletes visitor = new ParseWhereClauseForDeletes(tableName);\n-                visitor.process(where, context);\n-                final DDlogRecord[] matchExpression = visitor.matchExpressions;\n-                final DDlogRecord record = matchExpression.length > 1 ? DDlogRecord.makeTuple(matchExpression)\n-                                                                      : matchExpression[0];\n-\n+                final SqlBasicCall where = (SqlBasicCall) delete.getCondition();\n+                final List<? extends Field<?>> pkFields = tablesToPrimaryKeys.get(tableName.toUpperCase());\n+                final DDlogRecord record = matchExpressionFromWhere(where, pkFields, context);\n                 final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n                 final DDlogRecCommand command = new DDlogRecCommand(DDlogCommand.Kind.DeleteKey, tableId, record);\n                 dDlogAPI.applyUpdates(new DDlogRecCommand[]{command});\n             } catch (final DDlogException e) {\n-                throw new RuntimeException(e);\n+                return exception(e);\n             }\n             final Result<Record1<Integer>> result = dslContext.newResult(updateCountField);\n             final Record1<Integer> resultRecord = dslContext.newRecord(updateCountField);\n             resultRecord.setValue(updateCountField, 1);\n             result.add(resultRecord);\n             return new MockResult(1, result);\n         }\n-    }\n \n-    private class ParseWhereClauseForDeletes extends AstVisitor<Void, QueryContext> {\n-        final DDlogRecord[] matchExpressions;\n-        final String tableName;\n+        private MockResult visitUpdate(final SqlCall call) {\n+            // The assertions below, and in the ParseWhereClauseForDeletes visitor encode assumption A4\n+            // (see javadoc for the DDlogJooqProvider class)\n+            final SqlUpdate update = (SqlUpdate) call;\n+            final String tableName = ((SqlIdentifier) update.getTargetTable()).getSimple();\n+            if (update.getCondition() == null) {\n+                return exception(\"Delete queries without where clauses are unsupported: \" + context.sql());\n+            }\n+            try {\n+                final List<? extends Field<?>> allFields = tablesToFields.get(tableName.toUpperCase());\n+                final int numColumnsToUpdate = update.getTargetColumnList().size();\n+                final DDlogRecord[] updatedValues = new DDlogRecord[numColumnsToUpdate];\n+                final String[] columnsToUpdate = new String[numColumnsToUpdate];\n+                for (int i = 0; i < numColumnsToUpdate; i++) {\n+                    final String columnName = ((SqlIdentifier) update.getTargetColumnList().get(i)).getSimple()\n+                            .toLowerCase();\n+                    final Field<?> field = allFields.stream()\n+                            .filter(f -> f.getUnqualifiedName().last().equalsIgnoreCase(columnName))\n+                            .findFirst()\n+                            .get();\n+                    final boolean isNullableField = field.getDataType().nullable();\n+                    final DDlogRecord valueToUpdateTo = context.hasBinding()\n+                            ? toValue(field, context.nextBinding())\n+                            : update.getSourceExpressionList().accept(PARSE_LITERALS);\n+                    final DDlogRecord maybeWrapped = maybeOption(isNullableField, valueToUpdateTo);\n+                    updatedValues[i] = maybeWrapped;\n+                    columnsToUpdate[i] = columnName;\n+                }\n \n-        public ParseWhereClauseForDeletes(final String tableName) {\n-            this.tableName = tableName;\n-            matchExpressions = new DDlogRecord[tablesToPrimaryKeys.get(tableName.toUpperCase()).size()];\n-        }\n+                final SqlBasicCall where = (SqlBasicCall) update.getCondition();\n+                final List<? extends Field<?>> pkFields = tablesToPrimaryKeys.get(tableName.toUpperCase());\n+                final DDlogRecord key = matchExpressionFromWhere(where, pkFields, context);\n \n-        @Override\n-        protected Void visitLogicalBinaryExpression(final LogicalBinaryExpression node, final QueryContext context) {\n-            if (!node.getOperator().equals(LogicalBinaryExpression.Operator.AND)) {\n-                throw new RuntimeException(\"Only equality-based comparisons on \" +\n-                        \"all (not some) primary-key columns are allowed: \" + node);\n+                final DDlogRecord updateRecord = DDlogRecord.makeNamedStruct(\"\", columnsToUpdate, updatedValues);\n+                final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n+                final DDlogRecCommand command = new DDlogRecCommand(DDlogCommand.Kind.Modify, tableId, key, updateRecord);\n+                dDlogAPI.applyUpdates(new DDlogRecCommand[]{command});\n+            } catch (final DDlogException e) {\n+                return exception(e);\n             }\n-            return super.visitLogicalBinaryExpression(node, context);\n+            final Result<Record1<Integer>> result = dslContext.newResult(updateCountField);\n+            final Record1<Integer> resultRecord = dslContext.newRecord(updateCountField);\n+            resultRecord.setValue(updateCountField, 1);\n+            result.add(resultRecord);\n+            return new MockResult(1, result);\n+        }\n+    }\n+\n+    private static DDlogRecord matchExpressionFromWhere(final SqlBasicCall where,\n+                                                        final List<? extends Field<?>> pkFields,\n+                                                        final QueryContext context) throws DDlogException {\n+        final WhereClauseToMatchExpression visitor = new WhereClauseToMatchExpression(pkFields, context);\n+        final DDlogRecord[] matchExpression = where.accept(visitor);\n+        return matchExpression.length > 1 ? DDlogRecord.makeTuple(matchExpression)\n+                                                              : matchExpression[0];\n+    }\n+\n+    private static final class WhereClauseToMatchExpression extends SqlBasicVisitor<DDlogRecord[]> {\n+        private final DDlogRecord[] matchExpressions;\n+        private final QueryContext context;\n+        private final List<? extends Field<?>> pkFields;\n+\n+        public WhereClauseToMatchExpression(final List<? extends Field<?>> pkFields, final QueryContext context) {\n+            this.context = context;\n+            this.pkFields = pkFields;\n+            this.matchExpressions = new DDlogRecord[pkFields.size()];\n         }\n \n         @Override\n-        protected Void visitComparisonExpression(final ComparisonExpression node, final QueryContext context) {\n-            final Expression left = node.getLeft();\n-            final Expression right = node.getRight();\n-            if (context.hasBinding()) {\n-                if (left instanceof Identifier && right instanceof Parameter) {\n-                    setMatchExpression((Identifier) left, context.nextBinding());\n-                    return null;\n-                } else if (right instanceof Identifier && left instanceof Parameter) {\n-                    setMatchExpression((Identifier) right, context.nextBinding());\n-                    return null;\n-                }\n-            } else {\n-                if (left instanceof Identifier && right instanceof Literal) {\n-                    setMatchExpression((Identifier) left, (Literal) right);\n-                    return null;\n-                } else if (right instanceof Identifier && left instanceof Literal) {\n-                    setMatchExpression((Identifier) right, (Literal) left);\n-                    return null;\n-                }\n+        public DDlogRecord[] visit(final SqlCall call) {\n+            final SqlBasicCall expr = (SqlBasicCall) call;\n+            switch (expr.getOperator().getKind()) {\n+                case AND:\n+                    return super.visit(call);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc5MjA1Mg=="}, "originalCommit": {"oid": "39816ed18fbadb211b008dfcca47da8c6c3bae43"}, "originalPosition": 457}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3NjAwODg2OnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/com/vmware/ddlog/ParseLiterals.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QyMDowMDo0N1rOIA4Q2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QyMToyMzoyOVrOIA7UYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc5MjcyOA==", "bodyText": "CHAR is string?", "url": "https://github.com/vmware/differential-datalog/pull/843#discussion_r537792728", "createdAt": "2020-12-07T20:00:47Z", "author": {"login": "mbudiu-vmw"}, "path": "sql/src/main/java/com/vmware/ddlog/ParseLiterals.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/*\n+ * Copyright \u00a9 2018-2020 VMware, Inc. All Rights Reserved.\n+ * SPDX-License-Identifier: BSD-2\n+ */\n+\n+package com.vmware.ddlog;\n+\n+import ddlogapi.DDlogException;\n+import ddlogapi.DDlogRecord;\n+import org.apache.calcite.sql.SqlLiteral;\n+import org.apache.calcite.sql.util.SqlBasicVisitor;\n+\n+/*\n+ * Translates literals into corresponding DDlogRecord instances\n+ */\n+class ParseLiterals extends SqlBasicVisitor<DDlogRecord> {\n+\n+    @Override\n+    public DDlogRecord visit(final SqlLiteral sqlLiteral) {\n+        switch (sqlLiteral.getTypeName()) {\n+            case BOOLEAN:\n+                return new DDlogRecord(sqlLiteral.booleanValue());\n+            case DECIMAL:\n+                return new DDlogRecord(sqlLiteral.intValue(false));\n+            case CHAR:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "39816ed18fbadb211b008dfcca47da8c6c3bae43"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzg0Mjc4NA==", "bodyText": "Surprised me too, but yes.", "url": "https://github.com/vmware/differential-datalog/pull/843#discussion_r537842784", "createdAt": "2020-12-07T21:23:29Z", "author": {"login": "lalithsuresh"}, "path": "sql/src/main/java/com/vmware/ddlog/ParseLiterals.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/*\n+ * Copyright \u00a9 2018-2020 VMware, Inc. All Rights Reserved.\n+ * SPDX-License-Identifier: BSD-2\n+ */\n+\n+package com.vmware.ddlog;\n+\n+import ddlogapi.DDlogException;\n+import ddlogapi.DDlogRecord;\n+import org.apache.calcite.sql.SqlLiteral;\n+import org.apache.calcite.sql.util.SqlBasicVisitor;\n+\n+/*\n+ * Translates literals into corresponding DDlogRecord instances\n+ */\n+class ParseLiterals extends SqlBasicVisitor<DDlogRecord> {\n+\n+    @Override\n+    public DDlogRecord visit(final SqlLiteral sqlLiteral) {\n+        switch (sqlLiteral.getTypeName()) {\n+            case BOOLEAN:\n+                return new DDlogRecord(sqlLiteral.booleanValue());\n+            case DECIMAL:\n+                return new DDlogRecord(sqlLiteral.intValue(false));\n+            case CHAR:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc5MjcyOA=="}, "originalCommit": {"oid": "39816ed18fbadb211b008dfcca47da8c6c3bae43"}, "originalPosition": 25}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4696, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}