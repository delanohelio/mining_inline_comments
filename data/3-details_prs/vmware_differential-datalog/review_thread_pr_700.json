{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ4OTI0Nzc0", "number": 700, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxNTozMzoxMlrOEOvYLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxNTo0OTo1M1rOEOvx9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzODkxNzU4OnYy", "diffSide": "RIGHT", "path": "rust/template/distributed_datalog/src/accumulate/accumulator.rs", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxNTozMzoxMlrOGyDzPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxOTo0Njo1NVrOGyNUvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTE0NDI1Mw==", "bodyText": "This method can only be safely invoked when there is no transaction in progress (because it starts a transaction internally and we don't support nested transactions). Please change this function to return an error if there is a transaction in progress and also reflect this in the comment.", "url": "https://github.com/vmware/differential-datalog/pull/700#discussion_r455144253", "createdAt": "2020-07-15T15:33:12Z", "author": {"login": "ryzhyk"}, "path": "rust/template/distributed_datalog/src/accumulate/accumulator.rs", "diffHunk": "@@ -47,6 +47,10 @@ where\n \n     /// Return the current state of the data.\n     fn get_current_state(&self) -> HashMap<RelId, HashSet<V>>;\n+\n+    /// Sends a deletion update to all observers, thus clearing the accumulated state.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "44d1269d2b008987729bf134e87be7c9234194ef"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI5Mjk2MQ==", "bodyText": "I agree. Maybe we should also think of somehow \"registering\" the wish to clear the accumulator so that clear() is called on the next commit() automatically? This way, one can take a source offline while it is still committing updates. Otherwise, you would need to try multiple times to get the correct timing in-between transactions. What do you think @ryzhyk?", "url": "https://github.com/vmware/differential-datalog/pull/700#discussion_r455292961", "createdAt": "2020-07-15T19:32:56Z", "author": {"login": "falzberger"}, "path": "rust/template/distributed_datalog/src/accumulate/accumulator.rs", "diffHunk": "@@ -47,6 +47,10 @@ where\n \n     /// Return the current state of the data.\n     fn get_current_state(&self) -> HashMap<RelId, HashSet<V>>;\n+\n+    /// Sends a deletion update to all observers, thus clearing the accumulated state.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTE0NDI1Mw=="}, "originalCommit": {"oid": "44d1269d2b008987729bf134e87be7c9234194ef"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI5ODQzNw==", "bodyText": "I prefer to keep the semantics simple and have the control plane make sure that it does not call the method at the wrong time.  Delayed invocation sounds like a tricky thing to implement and use.", "url": "https://github.com/vmware/differential-datalog/pull/700#discussion_r455298437", "createdAt": "2020-07-15T19:43:38Z", "author": {"login": "ryzhyk"}, "path": "rust/template/distributed_datalog/src/accumulate/accumulator.rs", "diffHunk": "@@ -47,6 +47,10 @@ where\n \n     /// Return the current state of the data.\n     fn get_current_state(&self) -> HashMap<RelId, HashSet<V>>;\n+\n+    /// Sends a deletion update to all observers, thus clearing the accumulated state.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTE0NDI1Mw=="}, "originalCommit": {"oid": "44d1269d2b008987729bf134e87be7c9234194ef"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMwMDI4NA==", "bodyText": "Sure, that's also a valid point. I just think it will also be hard for the control plane to know exactly when an transaction is going on, as observables can call functions on their observers without sending any information about it to the control plane. Nevertheless, I completely agree with you to keep it simple in the first place.", "url": "https://github.com/vmware/differential-datalog/pull/700#discussion_r455300284", "createdAt": "2020-07-15T19:46:55Z", "author": {"login": "falzberger"}, "path": "rust/template/distributed_datalog/src/accumulate/accumulator.rs", "diffHunk": "@@ -47,6 +47,10 @@ where\n \n     /// Return the current state of the data.\n     fn get_current_state(&self) -> HashMap<RelId, HashSet<V>>;\n+\n+    /// Sends a deletion update to all observers, thus clearing the accumulated state.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTE0NDI1Mw=="}, "originalCommit": {"oid": "44d1269d2b008987729bf134e87be7c9234194ef"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzODk0NjM1OnYy", "diffSide": "RIGHT", "path": "rust/template/distributed_datalog/src/accumulate/accumulator.rs", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxNTo0MDoxNFrOGyEFFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxOTo0OTo0NlrOGyNbBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTE0ODgyMQ==", "bodyText": "I think, get_current_state returns a copy of the internal state, i.e., it does not actually clear the accumulator plus introduces the overhead of cloning.  You probably want to add another method to AccumulatingObserver that swaps its internal state with empty set and returns the actual internal state rather than its clone.\nI realize, this code was copied from previous on_completed implementation, so it looks like the problem already existed there. (@sugohugo , do you agree?)", "url": "https://github.com/vmware/differential-datalog/pull/700#discussion_r455148821", "createdAt": "2020-07-15T15:40:14Z", "author": {"login": "ryzhyk"}, "path": "rust/template/distributed_datalog/src/accumulate/accumulator.rs", "diffHunk": "@@ -98,6 +102,33 @@ where\n         trace!(\"DistributingAccumulator({})::get_current_state()\", self.id);\n         self.observer.get_current_state()\n     }\n+\n+    fn clear(&mut self) {\n+        trace!(\"DistributingAccumulator({})::clear\", self.id);\n+        let mut distributor = self.distributor.lock().unwrap();\n+\n+        let mut delete_updates = self\n+            .get_current_state()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "44d1269d2b008987729bf134e87be7c9234194ef"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI3NjAwNw==", "bodyText": "Actually, in accumulate/observer.rs:166 you still have the old on_completed implementation. When this logic was executed in on_completed previously, it also called the on_completed function in the AccumulatingObserver, thus clearing the internal state of it. So a possible solution would be to also add an implementation of clear() in AccumulatingObserver (which can just be the on_completed that is there now) which needs to be triggered when the accumulator is cleared.", "url": "https://github.com/vmware/differential-datalog/pull/700#discussion_r455276007", "createdAt": "2020-07-15T19:02:14Z", "author": {"login": "falzberger"}, "path": "rust/template/distributed_datalog/src/accumulate/accumulator.rs", "diffHunk": "@@ -98,6 +102,33 @@ where\n         trace!(\"DistributingAccumulator({})::get_current_state()\", self.id);\n         self.observer.get_current_state()\n     }\n+\n+    fn clear(&mut self) {\n+        trace!(\"DistributingAccumulator({})::clear\", self.id);\n+        let mut distributor = self.distributor.lock().unwrap();\n+\n+        let mut delete_updates = self\n+            .get_current_state()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTE0ODgyMQ=="}, "originalCommit": {"oid": "44d1269d2b008987729bf134e87be7c9234194ef"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI3OTE1MQ==", "bodyText": "Makes sense, although it does seem wasteful to clone the state just to deallocate all it immediately.", "url": "https://github.com/vmware/differential-datalog/pull/700#discussion_r455279151", "createdAt": "2020-07-15T19:07:56Z", "author": {"login": "ryzhyk"}, "path": "rust/template/distributed_datalog/src/accumulate/accumulator.rs", "diffHunk": "@@ -98,6 +102,33 @@ where\n         trace!(\"DistributingAccumulator({})::get_current_state()\", self.id);\n         self.observer.get_current_state()\n     }\n+\n+    fn clear(&mut self) {\n+        trace!(\"DistributingAccumulator({})::clear\", self.id);\n+        let mut distributor = self.distributor.lock().unwrap();\n+\n+        let mut delete_updates = self\n+            .get_current_state()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTE0ODgyMQ=="}, "originalCommit": {"oid": "44d1269d2b008987729bf134e87be7c9234194ef"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMwMTg5Mg==", "bodyText": "Yes, it is. I think I just did not consider this in the implementation, so the (current) on_completed() implementation in AccumulatingObserver can also just return its current state. I probably was too focused on using the get_current_state() method.", "url": "https://github.com/vmware/differential-datalog/pull/700#discussion_r455301892", "createdAt": "2020-07-15T19:49:46Z", "author": {"login": "falzberger"}, "path": "rust/template/distributed_datalog/src/accumulate/accumulator.rs", "diffHunk": "@@ -98,6 +102,33 @@ where\n         trace!(\"DistributingAccumulator({})::get_current_state()\", self.id);\n         self.observer.get_current_state()\n     }\n+\n+    fn clear(&mut self) {\n+        trace!(\"DistributingAccumulator({})::clear\", self.id);\n+        let mut distributor = self.distributor.lock().unwrap();\n+\n+        let mut delete_updates = self\n+            .get_current_state()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTE0ODgyMQ=="}, "originalCommit": {"oid": "44d1269d2b008987729bf134e87be7c9234194ef"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzODk3ODE0OnYy", "diffSide": "RIGHT", "path": "rust/template/distributed_datalog/src/instantiate.rs", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxNTo0ODozMFrOGyEZHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxODozNjozOFrOGyK9ag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTE1Mzk0OQ==", "bodyText": "Please add a FIXME to eventually find a way to connect the accumulator to receiver.", "url": "https://github.com/vmware/differential-datalog/pull/700#discussion_r455153949", "createdAt": "2020-07-15T15:48:30Z", "author": {"login": "ryzhyk"}, "path": "rust/template/distributed_datalog/src/instantiate.rs", "diffHunk": "@@ -175,16 +182,18 @@ where\n     let receiver =\n         TcpReceiver::new(addr).map_err(|e| format!(\"failed to create TcpReceiver: {}\", e))?;\n     let receiver = Arc::new(Mutex::new(receiver));\n-    // an empty set indicates the TcpReceiver\n-    let _ = sources.insert(\n-        BTreeSet::new(),\n-        vec![(SourceRealization::Node(receiver.clone()), ())],\n-    );\n-\n-    txnmux\n-        .add_observable(Box::new(receiver))\n-        .map_err(|_| \"failed to register TcpReceiver with TxnMux\".to_string())?;\n-    Ok(())\n+    let accumulator = Arc::new(Mutex::new(DistributingAccumulator::new()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "44d1269d2b008987729bf134e87be7c9234194ef"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI2MTU0Ng==", "bodyText": "Will do.", "url": "https://github.com/vmware/differential-datalog/pull/700#discussion_r455261546", "createdAt": "2020-07-15T18:36:38Z", "author": {"login": "krs85"}, "path": "rust/template/distributed_datalog/src/instantiate.rs", "diffHunk": "@@ -175,16 +182,18 @@ where\n     let receiver =\n         TcpReceiver::new(addr).map_err(|e| format!(\"failed to create TcpReceiver: {}\", e))?;\n     let receiver = Arc::new(Mutex::new(receiver));\n-    // an empty set indicates the TcpReceiver\n-    let _ = sources.insert(\n-        BTreeSet::new(),\n-        vec![(SourceRealization::Node(receiver.clone()), ())],\n-    );\n-\n-    txnmux\n-        .add_observable(Box::new(receiver))\n-        .map_err(|_| \"failed to register TcpReceiver with TxnMux\".to_string())?;\n-    Ok(())\n+    let accumulator = Arc::new(Mutex::new(DistributingAccumulator::new()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTE1Mzk0OQ=="}, "originalCommit": {"oid": "44d1269d2b008987729bf134e87be7c9234194ef"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzODk4MzU2OnYy", "diffSide": "RIGHT", "path": "rust/template/distributed_datalog/src/instantiate.rs", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxNTo0OTo1M1rOGyEcWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxODozNjoyOVrOGyK9Kg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTE1NDc3OA==", "bodyText": "Shouldn't this be called add_file_source?", "url": "https://github.com/vmware/differential-datalog/pull/700#discussion_r455154778", "createdAt": "2020-07-15T15:49:53Z", "author": {"login": "ryzhyk"}, "path": "rust/template/distributed_datalog/src/instantiate.rs", "diffHunk": "@@ -388,6 +372,63 @@ where\n     _sinks: HashMap<BTreeSet<RelId>, Vec<(SinkRealization<P::Convert>, usize)>>,\n }\n \n+impl<P> Realization<P>\n+where\n+    P: Send + DDlog + 'static,\n+    P::Convert: Send + DDlogConvert,\n+{\n+    /// Remove a source from the existing realization.\n+    /// Also clear the accumulator and disconnect\n+    /// from the TxnMux.\n+    pub fn remove_source(&mut self, src: &Source) {\n+        // Remove entry.\n+        let (_, accumulator, id) = self._sources.remove(src).unwrap();\n+        let mut accum_observ = accumulator.lock().unwrap();\n+\n+        // Clear accumulator.\n+        accum_observ.clear();\n+\n+        // Disconnect from TxnMux.\n+        self._txnmux.remove_observable(id);\n+    }\n+\n+    /// Add a source to an existing realization.\n+    pub fn add_source(&mut self, path: &Path) -> Result<(), String> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "44d1269d2b008987729bf134e87be7c9234194ef"}, "originalPosition": 183}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI2MTQ4Mg==", "bodyText": "That makes sense to me. I'll change it.", "url": "https://github.com/vmware/differential-datalog/pull/700#discussion_r455261482", "createdAt": "2020-07-15T18:36:29Z", "author": {"login": "krs85"}, "path": "rust/template/distributed_datalog/src/instantiate.rs", "diffHunk": "@@ -388,6 +372,63 @@ where\n     _sinks: HashMap<BTreeSet<RelId>, Vec<(SinkRealization<P::Convert>, usize)>>,\n }\n \n+impl<P> Realization<P>\n+where\n+    P: Send + DDlog + 'static,\n+    P::Convert: Send + DDlogConvert,\n+{\n+    /// Remove a source from the existing realization.\n+    /// Also clear the accumulator and disconnect\n+    /// from the TxnMux.\n+    pub fn remove_source(&mut self, src: &Source) {\n+        // Remove entry.\n+        let (_, accumulator, id) = self._sources.remove(src).unwrap();\n+        let mut accum_observ = accumulator.lock().unwrap();\n+\n+        // Clear accumulator.\n+        accum_observ.clear();\n+\n+        // Disconnect from TxnMux.\n+        self._txnmux.remove_observable(id);\n+    }\n+\n+    /// Add a source to an existing realization.\n+    pub fn add_source(&mut self, path: &Path) -> Result<(), String> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTE1NDc3OA=="}, "originalCommit": {"oid": "44d1269d2b008987729bf134e87be7c9234194ef"}, "originalPosition": 183}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4790, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}