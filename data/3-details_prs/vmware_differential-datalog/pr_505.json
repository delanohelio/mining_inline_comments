{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcwNjU0NzMy", "number": 505, "title": "Antrea", "bodyText": "Initial implementation of Antrea controller logic in DDlog:\nhttps://github.com/vmware-tanzu/antrea/blob/master/pkg/controller/networkpolicy/networkpolicy_controller.go\nThere are several todos in the code, and we only test that the code\ncompiles, not that it does anything useful.\nThis PR also introduces three new constructs: continue, break, and return. (#70)", "createdAt": "2020-02-04T05:33:05Z", "url": "https://github.com/vmware/differential-datalog/pull/505", "merged": true, "mergeCommit": {"oid": "3715e06029c8e60f383ed1f8947e76b232808e6b"}, "closed": true, "closedAt": "2020-02-05T07:15:56Z", "author": {"login": "ryzhyk"}, "timelineItems": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcBJPdJAFqTM1MzMxNzUxMw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcBQP-OABqjMwMDg3ODc5MTE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzMzE3NTEz", "url": "https://github.com/vmware/differential-datalog/pull/505#pullrequestreview-353317513", "createdAt": "2020-02-04T21:34:29Z", "commit": {"oid": "11822990ea93d6fce22fc4ea9cbe06866e163b44"}, "state": "APPROVED", "comments": {"totalCount": 34, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQyMTozNDoyOVrOFlkQYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQyMjoyNDowMVrOFlllrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDkzNTY1MA==", "bodyText": "should this be called something like \"repeat\"?", "url": "https://github.com/vmware/differential-datalog/pull/505#discussion_r374935650", "createdAt": "2020-02-04T21:34:29Z", "author": {"login": "mbudiu-vmw"}, "path": "lib/std.dl", "diffHunk": "@@ -137,9 +144,11 @@ extern function group_max(g: Group<'A>): 'A\n extern type Vec<'A>\n \n extern function vec_empty(): Vec<'A>\n+extern function vec_with_length(len: bit<64>, x: 'A): Vec<'A>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11822990ea93d6fce22fc4ea9cbe06866e163b44"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDkzNzU2Mw==", "bodyText": "don't you want stronger typing for the address?", "url": "https://github.com/vmware/differential-datalog/pull/505#discussion_r374937563", "createdAt": "2020-02-04T21:38:53Z", "author": {"login": "mbudiu-vmw"}, "path": "test/antrea/k8spolicy.dl", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Inputs consumed by Antrea controller from Kuberneters: pods, namespaces,\n+ * network policies.\n+ */\n+\n+// TODO: this module should probably be broken up into several to match Go module hierachy.\n+\n+import intern\n+\n+typedef UID = UID{uid: string}\n+\n+// PodSpec is a description of a pod.\n+typedef PodSpec = PodSpec {\n+\t// NodeName is a request to schedule this pod onto a specific node. If it is non-empty,\n+\t// the scheduler simply schedules this pod onto that node, assuming that it fits resource\n+\t// requirements.\n+\tnodeName: string\n+}\n+\n+// PodStatus represents information about the status of a pod. Status may trail the actual\n+// state of a system, especially if the node that hosts the pod cannot contact the control\n+// plane.\n+typedef PodStatus = PodStatus {\n+\t// IP address allocated to the pod. Routable at least within the cluster.\n+\t// Empty if not yet allocated.\n+\tpodIP: string", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11822990ea93d6fce22fc4ea9cbe06866e163b44"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDkzODIxNQ==", "bodyText": "weird indentation", "url": "https://github.com/vmware/differential-datalog/pull/505#discussion_r374938215", "createdAt": "2020-02-04T21:40:26Z", "author": {"login": "mbudiu-vmw"}, "path": "test/antrea/k8spolicy.dl", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Inputs consumed by Antrea controller from Kuberneters: pods, namespaces,\n+ * network policies.\n+ */\n+\n+// TODO: this module should probably be broken up into several to match Go module hierachy.\n+\n+import intern\n+\n+typedef UID = UID{uid: string}\n+\n+// PodSpec is a description of a pod.\n+typedef PodSpec = PodSpec {\n+\t// NodeName is a request to schedule this pod onto a specific node. If it is non-empty,\n+\t// the scheduler simply schedules this pod onto that node, assuming that it fits resource\n+\t// requirements.\n+\tnodeName: string\n+}\n+\n+// PodStatus represents information about the status of a pod. Status may trail the actual\n+// state of a system, especially if the node that hosts the pod cannot contact the control\n+// plane.\n+typedef PodStatus = PodStatus {\n+\t// IP address allocated to the pod. Routable at least within the cluster.\n+\t// Empty if not yet allocated.\n+\tpodIP: string\n+}\n+\n+// Pod is a collection of containers that can run on a host. This resource is created\n+// by clients and scheduled onto hosts. */\n+// TODO: primary key\n+input relation Pod (\n+\t// Name must be unique within a namespace.\n+    name: Option<string>,\n+    // Namespace defines the space within each name must be unique.\n+    namespace: Option<string>,\n+    // UID is the unique in time and space value for this object.\n+    uid: UID,\n+\t// Map of string keys and values that can be used to organize and categorize", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11822990ea93d6fce22fc4ea9cbe06866e163b44"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDkzODYzNA==", "bodyText": "indent", "url": "https://github.com/vmware/differential-datalog/pull/505#discussion_r374938634", "createdAt": "2020-02-04T21:41:20Z", "author": {"login": "mbudiu-vmw"}, "path": "test/antrea/k8spolicy.dl", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Inputs consumed by Antrea controller from Kuberneters: pods, namespaces,\n+ * network policies.\n+ */\n+\n+// TODO: this module should probably be broken up into several to match Go module hierachy.\n+\n+import intern\n+\n+typedef UID = UID{uid: string}\n+\n+// PodSpec is a description of a pod.\n+typedef PodSpec = PodSpec {\n+\t// NodeName is a request to schedule this pod onto a specific node. If it is non-empty,\n+\t// the scheduler simply schedules this pod onto that node, assuming that it fits resource\n+\t// requirements.\n+\tnodeName: string\n+}\n+\n+// PodStatus represents information about the status of a pod. Status may trail the actual\n+// state of a system, especially if the node that hosts the pod cannot contact the control\n+// plane.\n+typedef PodStatus = PodStatus {\n+\t// IP address allocated to the pod. Routable at least within the cluster.\n+\t// Empty if not yet allocated.\n+\tpodIP: string\n+}\n+\n+// Pod is a collection of containers that can run on a host. This resource is created\n+// by clients and scheduled onto hosts. */\n+// TODO: primary key\n+input relation Pod (\n+\t// Name must be unique within a namespace.\n+    name: Option<string>,\n+    // Namespace defines the space within each name must be unique.\n+    namespace: Option<string>,\n+    // UID is the unique in time and space value for this object.\n+    uid: UID,\n+\t// Map of string keys and values that can be used to organize and categorize\n+\t// (scope and select) objects. May match selectors of replication controllers\n+\t// and services.\n+\t// More info: http://kubernetes.io/docs/user-guide/labels\n+\t// +optional\n+\tlabels: Map<string, string>,\n+\t// Specification of the desired behavior of the pod.\n+    spec: PodSpec,\n+\t// Most recently observed status of the pod.\n+    status: PodStatus\n+)\n+\n+// Namespace provides a scope for Names.\n+// Use of multiple namespaces is optional.\n+input relation Namespace (\n+\t// Name must be unique within a namespace.\n+    name: string,\n+    // UID is the unique in time and space value for this object.\n+    uid: UID,\n+\t// Map of string keys and values that can be used to organize and categorize", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11822990ea93d6fce22fc4ea9cbe06866e163b44"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDkzODkwNw==", "bodyText": "indent", "url": "https://github.com/vmware/differential-datalog/pull/505#discussion_r374938907", "createdAt": "2020-02-04T21:41:53Z", "author": {"login": "mbudiu-vmw"}, "path": "test/antrea/k8spolicy.dl", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Inputs consumed by Antrea controller from Kuberneters: pods, namespaces,\n+ * network policies.\n+ */\n+\n+// TODO: this module should probably be broken up into several to match Go module hierachy.\n+\n+import intern\n+\n+typedef UID = UID{uid: string}\n+\n+// PodSpec is a description of a pod.\n+typedef PodSpec = PodSpec {\n+\t// NodeName is a request to schedule this pod onto a specific node. If it is non-empty,\n+\t// the scheduler simply schedules this pod onto that node, assuming that it fits resource\n+\t// requirements.\n+\tnodeName: string\n+}\n+\n+// PodStatus represents information about the status of a pod. Status may trail the actual\n+// state of a system, especially if the node that hosts the pod cannot contact the control\n+// plane.\n+typedef PodStatus = PodStatus {\n+\t// IP address allocated to the pod. Routable at least within the cluster.\n+\t// Empty if not yet allocated.\n+\tpodIP: string\n+}\n+\n+// Pod is a collection of containers that can run on a host. This resource is created\n+// by clients and scheduled onto hosts. */\n+// TODO: primary key\n+input relation Pod (\n+\t// Name must be unique within a namespace.\n+    name: Option<string>,\n+    // Namespace defines the space within each name must be unique.\n+    namespace: Option<string>,\n+    // UID is the unique in time and space value for this object.\n+    uid: UID,\n+\t// Map of string keys and values that can be used to organize and categorize\n+\t// (scope and select) objects. May match selectors of replication controllers\n+\t// and services.\n+\t// More info: http://kubernetes.io/docs/user-guide/labels\n+\t// +optional\n+\tlabels: Map<string, string>,\n+\t// Specification of the desired behavior of the pod.\n+    spec: PodSpec,\n+\t// Most recently observed status of the pod.\n+    status: PodStatus\n+)\n+\n+// Namespace provides a scope for Names.\n+// Use of multiple namespaces is optional.\n+input relation Namespace (\n+\t// Name must be unique within a namespace.\n+    name: string,\n+    // UID is the unique in time and space value for this object.\n+    uid: UID,\n+\t// Map of string keys and values that can be used to organize and categorize\n+\t// (scope and select) objects. May match selectors of replication controllers\n+\t// and services.\n+\t// More info: http://kubernetes.io/docs/user-guide/labels\n+\t// +optional\n+\tlabels: Map<string, string>\n+)\n+\n+// NetworkPolicy describes what network traffic is allowed for a set of Pods\n+input relation NetworkPolicy (\n+    // Name must be unique within a namespace.\n+    name: string,\n+    // Namespace defines the space within each name must be unique.\n+    namespace: string,\n+    // UID is the unique in time and space value for this object.\n+    uid: UID,\n+\t// Specification of the desired behavior for this NetworkPolicy.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11822990ea93d6fce22fc4ea9cbe06866e163b44"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDkzOTA2MQ==", "bodyText": "4 space indent?", "url": "https://github.com/vmware/differential-datalog/pull/505#discussion_r374939061", "createdAt": "2020-02-04T21:42:13Z", "author": {"login": "mbudiu-vmw"}, "path": "test/antrea/k8spolicy.dl", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Inputs consumed by Antrea controller from Kuberneters: pods, namespaces,\n+ * network policies.\n+ */\n+\n+// TODO: this module should probably be broken up into several to match Go module hierachy.\n+\n+import intern\n+\n+typedef UID = UID{uid: string}\n+\n+// PodSpec is a description of a pod.\n+typedef PodSpec = PodSpec {\n+\t// NodeName is a request to schedule this pod onto a specific node. If it is non-empty,\n+\t// the scheduler simply schedules this pod onto that node, assuming that it fits resource\n+\t// requirements.\n+\tnodeName: string\n+}\n+\n+// PodStatus represents information about the status of a pod. Status may trail the actual\n+// state of a system, especially if the node that hosts the pod cannot contact the control\n+// plane.\n+typedef PodStatus = PodStatus {\n+\t// IP address allocated to the pod. Routable at least within the cluster.\n+\t// Empty if not yet allocated.\n+\tpodIP: string\n+}\n+\n+// Pod is a collection of containers that can run on a host. This resource is created\n+// by clients and scheduled onto hosts. */\n+// TODO: primary key\n+input relation Pod (\n+\t// Name must be unique within a namespace.\n+    name: Option<string>,\n+    // Namespace defines the space within each name must be unique.\n+    namespace: Option<string>,\n+    // UID is the unique in time and space value for this object.\n+    uid: UID,\n+\t// Map of string keys and values that can be used to organize and categorize\n+\t// (scope and select) objects. May match selectors of replication controllers\n+\t// and services.\n+\t// More info: http://kubernetes.io/docs/user-guide/labels\n+\t// +optional\n+\tlabels: Map<string, string>,\n+\t// Specification of the desired behavior of the pod.\n+    spec: PodSpec,\n+\t// Most recently observed status of the pod.\n+    status: PodStatus\n+)\n+\n+// Namespace provides a scope for Names.\n+// Use of multiple namespaces is optional.\n+input relation Namespace (\n+\t// Name must be unique within a namespace.\n+    name: string,\n+    // UID is the unique in time and space value for this object.\n+    uid: UID,\n+\t// Map of string keys and values that can be used to organize and categorize\n+\t// (scope and select) objects. May match selectors of replication controllers\n+\t// and services.\n+\t// More info: http://kubernetes.io/docs/user-guide/labels\n+\t// +optional\n+\tlabels: Map<string, string>\n+)\n+\n+// NetworkPolicy describes what network traffic is allowed for a set of Pods\n+input relation NetworkPolicy (\n+    // Name must be unique within a namespace.\n+    name: string,\n+    // Namespace defines the space within each name must be unique.\n+    namespace: string,\n+    // UID is the unique in time and space value for this object.\n+    uid: UID,\n+\t// Specification of the desired behavior for this NetworkPolicy.\n+    spec: NetworkPolicySpec\n+)\n+\n+// A label selector is a label query over a set of resources. The result of matchLabels and\n+// matchExpressions are ANDed. An empty label selector matches all objects. A null\n+// label selector matches no objects.\n+typedef LabelSelector = LabelSelector {\n+\t// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11822990ea93d6fce22fc4ea9cbe06866e163b44"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDkzOTQxNg==", "bodyText": "does this come from some other piece of code", "url": "https://github.com/vmware/differential-datalog/pull/505#discussion_r374939416", "createdAt": "2020-02-04T21:42:55Z", "author": {"login": "mbudiu-vmw"}, "path": "test/antrea/k8spolicy.dl", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Inputs consumed by Antrea controller from Kuberneters: pods, namespaces,\n+ * network policies.\n+ */\n+\n+// TODO: this module should probably be broken up into several to match Go module hierachy.\n+\n+import intern\n+\n+typedef UID = UID{uid: string}\n+\n+// PodSpec is a description of a pod.\n+typedef PodSpec = PodSpec {\n+\t// NodeName is a request to schedule this pod onto a specific node. If it is non-empty,\n+\t// the scheduler simply schedules this pod onto that node, assuming that it fits resource\n+\t// requirements.\n+\tnodeName: string\n+}\n+\n+// PodStatus represents information about the status of a pod. Status may trail the actual\n+// state of a system, especially if the node that hosts the pod cannot contact the control\n+// plane.\n+typedef PodStatus = PodStatus {\n+\t// IP address allocated to the pod. Routable at least within the cluster.\n+\t// Empty if not yet allocated.\n+\tpodIP: string\n+}\n+\n+// Pod is a collection of containers that can run on a host. This resource is created\n+// by clients and scheduled onto hosts. */\n+// TODO: primary key\n+input relation Pod (\n+\t// Name must be unique within a namespace.\n+    name: Option<string>,\n+    // Namespace defines the space within each name must be unique.\n+    namespace: Option<string>,\n+    // UID is the unique in time and space value for this object.\n+    uid: UID,\n+\t// Map of string keys and values that can be used to organize and categorize\n+\t// (scope and select) objects. May match selectors of replication controllers\n+\t// and services.\n+\t// More info: http://kubernetes.io/docs/user-guide/labels\n+\t// +optional\n+\tlabels: Map<string, string>,\n+\t// Specification of the desired behavior of the pod.\n+    spec: PodSpec,\n+\t// Most recently observed status of the pod.\n+    status: PodStatus\n+)\n+\n+// Namespace provides a scope for Names.\n+// Use of multiple namespaces is optional.\n+input relation Namespace (\n+\t// Name must be unique within a namespace.\n+    name: string,\n+    // UID is the unique in time and space value for this object.\n+    uid: UID,\n+\t// Map of string keys and values that can be used to organize and categorize\n+\t// (scope and select) objects. May match selectors of replication controllers\n+\t// and services.\n+\t// More info: http://kubernetes.io/docs/user-guide/labels\n+\t// +optional\n+\tlabels: Map<string, string>\n+)\n+\n+// NetworkPolicy describes what network traffic is allowed for a set of Pods\n+input relation NetworkPolicy (\n+    // Name must be unique within a namespace.\n+    name: string,\n+    // Namespace defines the space within each name must be unique.\n+    namespace: string,\n+    // UID is the unique in time and space value for this object.\n+    uid: UID,\n+\t// Specification of the desired behavior for this NetworkPolicy.\n+    spec: NetworkPolicySpec\n+)\n+\n+// A label selector is a label query over a set of resources. The result of matchLabels and\n+// matchExpressions are ANDed. An empty label selector matches all objects. A null\n+// label selector matches no objects.\n+typedef LabelSelector = LabelSelector {\n+\t// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\n+\t// map is equivalent to an element of matchExpressions, whose key field is \"key\", the\n+\t// operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.\n+\t// +optional", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11822990ea93d6fce22fc4ea9cbe06866e163b44"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk0MDQwMA==", "bodyText": "indent", "url": "https://github.com/vmware/differential-datalog/pull/505#discussion_r374940400", "createdAt": "2020-02-04T21:45:05Z", "author": {"login": "mbudiu-vmw"}, "path": "test/antrea/k8spolicy.dl", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Inputs consumed by Antrea controller from Kuberneters: pods, namespaces,\n+ * network policies.\n+ */\n+\n+// TODO: this module should probably be broken up into several to match Go module hierachy.\n+\n+import intern\n+\n+typedef UID = UID{uid: string}\n+\n+// PodSpec is a description of a pod.\n+typedef PodSpec = PodSpec {\n+\t// NodeName is a request to schedule this pod onto a specific node. If it is non-empty,\n+\t// the scheduler simply schedules this pod onto that node, assuming that it fits resource\n+\t// requirements.\n+\tnodeName: string\n+}\n+\n+// PodStatus represents information about the status of a pod. Status may trail the actual\n+// state of a system, especially if the node that hosts the pod cannot contact the control\n+// plane.\n+typedef PodStatus = PodStatus {\n+\t// IP address allocated to the pod. Routable at least within the cluster.\n+\t// Empty if not yet allocated.\n+\tpodIP: string\n+}\n+\n+// Pod is a collection of containers that can run on a host. This resource is created\n+// by clients and scheduled onto hosts. */\n+// TODO: primary key\n+input relation Pod (\n+\t// Name must be unique within a namespace.\n+    name: Option<string>,\n+    // Namespace defines the space within each name must be unique.\n+    namespace: Option<string>,\n+    // UID is the unique in time and space value for this object.\n+    uid: UID,\n+\t// Map of string keys and values that can be used to organize and categorize\n+\t// (scope and select) objects. May match selectors of replication controllers\n+\t// and services.\n+\t// More info: http://kubernetes.io/docs/user-guide/labels\n+\t// +optional\n+\tlabels: Map<string, string>,\n+\t// Specification of the desired behavior of the pod.\n+    spec: PodSpec,\n+\t// Most recently observed status of the pod.\n+    status: PodStatus\n+)\n+\n+// Namespace provides a scope for Names.\n+// Use of multiple namespaces is optional.\n+input relation Namespace (\n+\t// Name must be unique within a namespace.\n+    name: string,\n+    // UID is the unique in time and space value for this object.\n+    uid: UID,\n+\t// Map of string keys and values that can be used to organize and categorize\n+\t// (scope and select) objects. May match selectors of replication controllers\n+\t// and services.\n+\t// More info: http://kubernetes.io/docs/user-guide/labels\n+\t// +optional\n+\tlabels: Map<string, string>\n+)\n+\n+// NetworkPolicy describes what network traffic is allowed for a set of Pods\n+input relation NetworkPolicy (\n+    // Name must be unique within a namespace.\n+    name: string,\n+    // Namespace defines the space within each name must be unique.\n+    namespace: string,\n+    // UID is the unique in time and space value for this object.\n+    uid: UID,\n+\t// Specification of the desired behavior for this NetworkPolicy.\n+    spec: NetworkPolicySpec\n+)\n+\n+// A label selector is a label query over a set of resources. The result of matchLabels and\n+// matchExpressions are ANDed. An empty label selector matches all objects. A null\n+// label selector matches no objects.\n+typedef LabelSelector = LabelSelector {\n+\t// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\n+\t// map is equivalent to an element of matchExpressions, whose key field is \"key\", the\n+\t// operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.\n+\t// +optional\n+\tmatchLabels: Map<string,string>,\n+\t// matchExpressions is a list of label selector requirements. The requirements are ANDed.\n+\t// +optional\n+\tmatchExpressions: Vec<LabelSelectorRequirement>\n+}\n+\n+/* The native Antrea implementation converts LabelSelector to a generic selector\n+ * struct before . */\n+// Matches returns true if the Requirement matches the input Labels.\n+// There is a match in the following cases:\n+// (1) The operator is Exists and Labels has the Requirement's key.\n+// (2) The operator is In, Labels has the Requirement's key and Labels'\n+//     value for that key is in Requirement's value set.\n+// (3) The operator is NotIn, Labels has the Requirement's key and\n+//     Labels' value for that key is not in Requirement's value set.\n+// (4) The operator is DoesNotExist or NotIn and Labels does not have the\n+//     Requirement's key.\n+function labelSelectorMatches(selector: Option<Ref<LabelSelector>>, labels: Map<string, string>): bool =\n+{\n+    match (selector) {\n+        None -> false,\n+        Some{s} -> {\n+            var matches = true;\n+            var sel = deref(s);\n+            if (map_is_empty(sel.matchLabels) and vec_is_empty(sel.matchExpressions)) {\n+                true\n+            } else {\n+                for (lab in sel.matchLabels) {\n+                    matches = matches and (map_get(labels, lab.0) == Some{lab.1})\n+                    // TODO: return false\n+                };\n+                for (e in sel.matchExpressions) {\n+                    matches = matches and\n+                    (match (e.operator) {\n+                        LabelSelectorOpIn -> {\n+                            match (map_get(labels, e.reqkey)) {\n+                                None -> false,\n+                                Some{val} -> vec_contains(e.values, val)\n+                            }\n+                        },\n+\t                    LabelSelectorOpNotIn -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11822990ea93d6fce22fc4ea9cbe06866e163b44"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk0MDY0Mw==", "bodyText": "not four spaces", "url": "https://github.com/vmware/differential-datalog/pull/505#discussion_r374940643", "createdAt": "2020-02-04T21:45:38Z", "author": {"login": "mbudiu-vmw"}, "path": "test/antrea/k8spolicy.dl", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Inputs consumed by Antrea controller from Kuberneters: pods, namespaces,\n+ * network policies.\n+ */\n+\n+// TODO: this module should probably be broken up into several to match Go module hierachy.\n+\n+import intern\n+\n+typedef UID = UID{uid: string}\n+\n+// PodSpec is a description of a pod.\n+typedef PodSpec = PodSpec {\n+\t// NodeName is a request to schedule this pod onto a specific node. If it is non-empty,\n+\t// the scheduler simply schedules this pod onto that node, assuming that it fits resource\n+\t// requirements.\n+\tnodeName: string\n+}\n+\n+// PodStatus represents information about the status of a pod. Status may trail the actual\n+// state of a system, especially if the node that hosts the pod cannot contact the control\n+// plane.\n+typedef PodStatus = PodStatus {\n+\t// IP address allocated to the pod. Routable at least within the cluster.\n+\t// Empty if not yet allocated.\n+\tpodIP: string\n+}\n+\n+// Pod is a collection of containers that can run on a host. This resource is created\n+// by clients and scheduled onto hosts. */\n+// TODO: primary key\n+input relation Pod (\n+\t// Name must be unique within a namespace.\n+    name: Option<string>,\n+    // Namespace defines the space within each name must be unique.\n+    namespace: Option<string>,\n+    // UID is the unique in time and space value for this object.\n+    uid: UID,\n+\t// Map of string keys and values that can be used to organize and categorize\n+\t// (scope and select) objects. May match selectors of replication controllers\n+\t// and services.\n+\t// More info: http://kubernetes.io/docs/user-guide/labels\n+\t// +optional\n+\tlabels: Map<string, string>,\n+\t// Specification of the desired behavior of the pod.\n+    spec: PodSpec,\n+\t// Most recently observed status of the pod.\n+    status: PodStatus\n+)\n+\n+// Namespace provides a scope for Names.\n+// Use of multiple namespaces is optional.\n+input relation Namespace (\n+\t// Name must be unique within a namespace.\n+    name: string,\n+    // UID is the unique in time and space value for this object.\n+    uid: UID,\n+\t// Map of string keys and values that can be used to organize and categorize\n+\t// (scope and select) objects. May match selectors of replication controllers\n+\t// and services.\n+\t// More info: http://kubernetes.io/docs/user-guide/labels\n+\t// +optional\n+\tlabels: Map<string, string>\n+)\n+\n+// NetworkPolicy describes what network traffic is allowed for a set of Pods\n+input relation NetworkPolicy (\n+    // Name must be unique within a namespace.\n+    name: string,\n+    // Namespace defines the space within each name must be unique.\n+    namespace: string,\n+    // UID is the unique in time and space value for this object.\n+    uid: UID,\n+\t// Specification of the desired behavior for this NetworkPolicy.\n+    spec: NetworkPolicySpec\n+)\n+\n+// A label selector is a label query over a set of resources. The result of matchLabels and\n+// matchExpressions are ANDed. An empty label selector matches all objects. A null\n+// label selector matches no objects.\n+typedef LabelSelector = LabelSelector {\n+\t// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\n+\t// map is equivalent to an element of matchExpressions, whose key field is \"key\", the\n+\t// operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.\n+\t// +optional\n+\tmatchLabels: Map<string,string>,\n+\t// matchExpressions is a list of label selector requirements. The requirements are ANDed.\n+\t// +optional\n+\tmatchExpressions: Vec<LabelSelectorRequirement>\n+}\n+\n+/* The native Antrea implementation converts LabelSelector to a generic selector\n+ * struct before . */\n+// Matches returns true if the Requirement matches the input Labels.\n+// There is a match in the following cases:\n+// (1) The operator is Exists and Labels has the Requirement's key.\n+// (2) The operator is In, Labels has the Requirement's key and Labels'\n+//     value for that key is in Requirement's value set.\n+// (3) The operator is NotIn, Labels has the Requirement's key and\n+//     Labels' value for that key is not in Requirement's value set.\n+// (4) The operator is DoesNotExist or NotIn and Labels does not have the\n+//     Requirement's key.\n+function labelSelectorMatches(selector: Option<Ref<LabelSelector>>, labels: Map<string, string>): bool =\n+{\n+    match (selector) {\n+        None -> false,\n+        Some{s} -> {\n+            var matches = true;\n+            var sel = deref(s);\n+            if (map_is_empty(sel.matchLabels) and vec_is_empty(sel.matchExpressions)) {\n+                true\n+            } else {\n+                for (lab in sel.matchLabels) {\n+                    matches = matches and (map_get(labels, lab.0) == Some{lab.1})\n+                    // TODO: return false\n+                };\n+                for (e in sel.matchExpressions) {\n+                    matches = matches and\n+                    (match (e.operator) {\n+                        LabelSelectorOpIn -> {\n+                            match (map_get(labels, e.reqkey)) {\n+                                None -> false,\n+                                Some{val} -> vec_contains(e.values, val)\n+                            }\n+                        },\n+\t                    LabelSelectorOpNotIn -> {\n+                            match (map_get(labels, e.reqkey)) {\n+                                None -> true,\n+                                Some{val} -> not vec_contains(e.values, val)\n+                            }\n+                        },\n+\t                    LabelSelectorOpExists -> map_contains_key(labels, e.reqkey),\n+\t                    LabelSelectorOpDoesNotExist -> not map_contains_key(labels, e.reqkey)\n+                    })\n+                };\n+                matches\n+            }\n+        }\n+    }\n+}\n+\n+// A label selector requirement is a selector that contains values, a key, and an operator that\n+// relates the key and values.\n+typedef LabelSelectorRequirement = LabelSelectorRequirement {\n+\t// key is the label key that the selector applies to.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11822990ea93d6fce22fc4ea9cbe06866e163b44"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk0MDg2Mw==", "bodyText": "I suspect these are also inherited.", "url": "https://github.com/vmware/differential-datalog/pull/505#discussion_r374940863", "createdAt": "2020-02-04T21:46:06Z", "author": {"login": "mbudiu-vmw"}, "path": "test/antrea/k8spolicy.dl", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Inputs consumed by Antrea controller from Kuberneters: pods, namespaces,\n+ * network policies.\n+ */\n+\n+// TODO: this module should probably be broken up into several to match Go module hierachy.\n+\n+import intern\n+\n+typedef UID = UID{uid: string}\n+\n+// PodSpec is a description of a pod.\n+typedef PodSpec = PodSpec {\n+\t// NodeName is a request to schedule this pod onto a specific node. If it is non-empty,\n+\t// the scheduler simply schedules this pod onto that node, assuming that it fits resource\n+\t// requirements.\n+\tnodeName: string\n+}\n+\n+// PodStatus represents information about the status of a pod. Status may trail the actual\n+// state of a system, especially if the node that hosts the pod cannot contact the control\n+// plane.\n+typedef PodStatus = PodStatus {\n+\t// IP address allocated to the pod. Routable at least within the cluster.\n+\t// Empty if not yet allocated.\n+\tpodIP: string\n+}\n+\n+// Pod is a collection of containers that can run on a host. This resource is created\n+// by clients and scheduled onto hosts. */\n+// TODO: primary key\n+input relation Pod (\n+\t// Name must be unique within a namespace.\n+    name: Option<string>,\n+    // Namespace defines the space within each name must be unique.\n+    namespace: Option<string>,\n+    // UID is the unique in time and space value for this object.\n+    uid: UID,\n+\t// Map of string keys and values that can be used to organize and categorize\n+\t// (scope and select) objects. May match selectors of replication controllers\n+\t// and services.\n+\t// More info: http://kubernetes.io/docs/user-guide/labels\n+\t// +optional\n+\tlabels: Map<string, string>,\n+\t// Specification of the desired behavior of the pod.\n+    spec: PodSpec,\n+\t// Most recently observed status of the pod.\n+    status: PodStatus\n+)\n+\n+// Namespace provides a scope for Names.\n+// Use of multiple namespaces is optional.\n+input relation Namespace (\n+\t// Name must be unique within a namespace.\n+    name: string,\n+    // UID is the unique in time and space value for this object.\n+    uid: UID,\n+\t// Map of string keys and values that can be used to organize and categorize\n+\t// (scope and select) objects. May match selectors of replication controllers\n+\t// and services.\n+\t// More info: http://kubernetes.io/docs/user-guide/labels\n+\t// +optional\n+\tlabels: Map<string, string>\n+)\n+\n+// NetworkPolicy describes what network traffic is allowed for a set of Pods\n+input relation NetworkPolicy (\n+    // Name must be unique within a namespace.\n+    name: string,\n+    // Namespace defines the space within each name must be unique.\n+    namespace: string,\n+    // UID is the unique in time and space value for this object.\n+    uid: UID,\n+\t// Specification of the desired behavior for this NetworkPolicy.\n+    spec: NetworkPolicySpec\n+)\n+\n+// A label selector is a label query over a set of resources. The result of matchLabels and\n+// matchExpressions are ANDed. An empty label selector matches all objects. A null\n+// label selector matches no objects.\n+typedef LabelSelector = LabelSelector {\n+\t// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\n+\t// map is equivalent to an element of matchExpressions, whose key field is \"key\", the\n+\t// operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.\n+\t// +optional\n+\tmatchLabels: Map<string,string>,\n+\t// matchExpressions is a list of label selector requirements. The requirements are ANDed.\n+\t// +optional\n+\tmatchExpressions: Vec<LabelSelectorRequirement>\n+}\n+\n+/* The native Antrea implementation converts LabelSelector to a generic selector\n+ * struct before . */\n+// Matches returns true if the Requirement matches the input Labels.\n+// There is a match in the following cases:\n+// (1) The operator is Exists and Labels has the Requirement's key.\n+// (2) The operator is In, Labels has the Requirement's key and Labels'\n+//     value for that key is in Requirement's value set.\n+// (3) The operator is NotIn, Labels has the Requirement's key and\n+//     Labels' value for that key is not in Requirement's value set.\n+// (4) The operator is DoesNotExist or NotIn and Labels does not have the\n+//     Requirement's key.\n+function labelSelectorMatches(selector: Option<Ref<LabelSelector>>, labels: Map<string, string>): bool =\n+{\n+    match (selector) {\n+        None -> false,\n+        Some{s} -> {\n+            var matches = true;\n+            var sel = deref(s);\n+            if (map_is_empty(sel.matchLabels) and vec_is_empty(sel.matchExpressions)) {\n+                true\n+            } else {\n+                for (lab in sel.matchLabels) {\n+                    matches = matches and (map_get(labels, lab.0) == Some{lab.1})\n+                    // TODO: return false\n+                };\n+                for (e in sel.matchExpressions) {\n+                    matches = matches and\n+                    (match (e.operator) {\n+                        LabelSelectorOpIn -> {\n+                            match (map_get(labels, e.reqkey)) {\n+                                None -> false,\n+                                Some{val} -> vec_contains(e.values, val)\n+                            }\n+                        },\n+\t                    LabelSelectorOpNotIn -> {\n+                            match (map_get(labels, e.reqkey)) {\n+                                None -> true,\n+                                Some{val} -> not vec_contains(e.values, val)\n+                            }\n+                        },\n+\t                    LabelSelectorOpExists -> map_contains_key(labels, e.reqkey),\n+\t                    LabelSelectorOpDoesNotExist -> not map_contains_key(labels, e.reqkey)\n+                    })\n+                };\n+                matches\n+            }\n+        }\n+    }\n+}\n+\n+// A label selector requirement is a selector that contains values, a key, and an operator that\n+// relates the key and values.\n+typedef LabelSelectorRequirement = LabelSelectorRequirement {\n+\t// key is the label key that the selector applies to.\n+\t// +patchMergeKey=key", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11822990ea93d6fce22fc4ea9cbe06866e163b44"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk0MTE2Mg==", "bodyText": "Can you move this earlier in the file?\nSame for the other base enum types; it makes it easier to read the previous functions.", "url": "https://github.com/vmware/differential-datalog/pull/505#discussion_r374941162", "createdAt": "2020-02-04T21:46:46Z", "author": {"login": "mbudiu-vmw"}, "path": "test/antrea/k8spolicy.dl", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Inputs consumed by Antrea controller from Kuberneters: pods, namespaces,\n+ * network policies.\n+ */\n+\n+// TODO: this module should probably be broken up into several to match Go module hierachy.\n+\n+import intern\n+\n+typedef UID = UID{uid: string}\n+\n+// PodSpec is a description of a pod.\n+typedef PodSpec = PodSpec {\n+\t// NodeName is a request to schedule this pod onto a specific node. If it is non-empty,\n+\t// the scheduler simply schedules this pod onto that node, assuming that it fits resource\n+\t// requirements.\n+\tnodeName: string\n+}\n+\n+// PodStatus represents information about the status of a pod. Status may trail the actual\n+// state of a system, especially if the node that hosts the pod cannot contact the control\n+// plane.\n+typedef PodStatus = PodStatus {\n+\t// IP address allocated to the pod. Routable at least within the cluster.\n+\t// Empty if not yet allocated.\n+\tpodIP: string\n+}\n+\n+// Pod is a collection of containers that can run on a host. This resource is created\n+// by clients and scheduled onto hosts. */\n+// TODO: primary key\n+input relation Pod (\n+\t// Name must be unique within a namespace.\n+    name: Option<string>,\n+    // Namespace defines the space within each name must be unique.\n+    namespace: Option<string>,\n+    // UID is the unique in time and space value for this object.\n+    uid: UID,\n+\t// Map of string keys and values that can be used to organize and categorize\n+\t// (scope and select) objects. May match selectors of replication controllers\n+\t// and services.\n+\t// More info: http://kubernetes.io/docs/user-guide/labels\n+\t// +optional\n+\tlabels: Map<string, string>,\n+\t// Specification of the desired behavior of the pod.\n+    spec: PodSpec,\n+\t// Most recently observed status of the pod.\n+    status: PodStatus\n+)\n+\n+// Namespace provides a scope for Names.\n+// Use of multiple namespaces is optional.\n+input relation Namespace (\n+\t// Name must be unique within a namespace.\n+    name: string,\n+    // UID is the unique in time and space value for this object.\n+    uid: UID,\n+\t// Map of string keys and values that can be used to organize and categorize\n+\t// (scope and select) objects. May match selectors of replication controllers\n+\t// and services.\n+\t// More info: http://kubernetes.io/docs/user-guide/labels\n+\t// +optional\n+\tlabels: Map<string, string>\n+)\n+\n+// NetworkPolicy describes what network traffic is allowed for a set of Pods\n+input relation NetworkPolicy (\n+    // Name must be unique within a namespace.\n+    name: string,\n+    // Namespace defines the space within each name must be unique.\n+    namespace: string,\n+    // UID is the unique in time and space value for this object.\n+    uid: UID,\n+\t// Specification of the desired behavior for this NetworkPolicy.\n+    spec: NetworkPolicySpec\n+)\n+\n+// A label selector is a label query over a set of resources. The result of matchLabels and\n+// matchExpressions are ANDed. An empty label selector matches all objects. A null\n+// label selector matches no objects.\n+typedef LabelSelector = LabelSelector {\n+\t// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\n+\t// map is equivalent to an element of matchExpressions, whose key field is \"key\", the\n+\t// operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.\n+\t// +optional\n+\tmatchLabels: Map<string,string>,\n+\t// matchExpressions is a list of label selector requirements. The requirements are ANDed.\n+\t// +optional\n+\tmatchExpressions: Vec<LabelSelectorRequirement>\n+}\n+\n+/* The native Antrea implementation converts LabelSelector to a generic selector\n+ * struct before . */\n+// Matches returns true if the Requirement matches the input Labels.\n+// There is a match in the following cases:\n+// (1) The operator is Exists and Labels has the Requirement's key.\n+// (2) The operator is In, Labels has the Requirement's key and Labels'\n+//     value for that key is in Requirement's value set.\n+// (3) The operator is NotIn, Labels has the Requirement's key and\n+//     Labels' value for that key is not in Requirement's value set.\n+// (4) The operator is DoesNotExist or NotIn and Labels does not have the\n+//     Requirement's key.\n+function labelSelectorMatches(selector: Option<Ref<LabelSelector>>, labels: Map<string, string>): bool =\n+{\n+    match (selector) {\n+        None -> false,\n+        Some{s} -> {\n+            var matches = true;\n+            var sel = deref(s);\n+            if (map_is_empty(sel.matchLabels) and vec_is_empty(sel.matchExpressions)) {\n+                true\n+            } else {\n+                for (lab in sel.matchLabels) {\n+                    matches = matches and (map_get(labels, lab.0) == Some{lab.1})\n+                    // TODO: return false\n+                };\n+                for (e in sel.matchExpressions) {\n+                    matches = matches and\n+                    (match (e.operator) {\n+                        LabelSelectorOpIn -> {\n+                            match (map_get(labels, e.reqkey)) {\n+                                None -> false,\n+                                Some{val} -> vec_contains(e.values, val)\n+                            }\n+                        },\n+\t                    LabelSelectorOpNotIn -> {\n+                            match (map_get(labels, e.reqkey)) {\n+                                None -> true,\n+                                Some{val} -> not vec_contains(e.values, val)\n+                            }\n+                        },\n+\t                    LabelSelectorOpExists -> map_contains_key(labels, e.reqkey),\n+\t                    LabelSelectorOpDoesNotExist -> not map_contains_key(labels, e.reqkey)\n+                    })\n+                };\n+                matches\n+            }\n+        }\n+    }\n+}\n+\n+// A label selector requirement is a selector that contains values, a key, and an operator that\n+// relates the key and values.\n+typedef LabelSelectorRequirement = LabelSelectorRequirement {\n+\t// key is the label key that the selector applies to.\n+\t// +patchMergeKey=key\n+\t// +patchStrategy=merge\n+\treqkey: string,\n+\t// operator represents a key's relationship to a set of values.\n+\t// Valid operators are In, NotIn, Exists and DoesNotExist.\n+\toperator: LabelSelectorOperator,\n+\t// values is an array of string values. If the operator is In or NotIn,\n+\t// the values array must be non-empty. If the operator is Exists or DoesNotExist,\n+\t// the values array must be empty. This array is replaced during a strategic\n+\t// merge patch.\n+\t// +optional\n+\tvalues: Vec<string>\n+}\n+\n+// A label selector operator is the set of operators that can be used in a selector requirement.\n+typedef LabelSelectorOperator = LabelSelectorOpIn", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11822990ea93d6fce22fc4ea9cbe06866e163b44"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk0MTUzOA==", "bodyText": "you should add a comment that this function is used by the ddlog serializer to string.", "url": "https://github.com/vmware/differential-datalog/pull/505#discussion_r374941538", "createdAt": "2020-02-04T21:47:39Z", "author": {"login": "mbudiu-vmw"}, "path": "test/antrea/k8spolicy.dl", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Inputs consumed by Antrea controller from Kuberneters: pods, namespaces,\n+ * network policies.\n+ */\n+\n+// TODO: this module should probably be broken up into several to match Go module hierachy.\n+\n+import intern\n+\n+typedef UID = UID{uid: string}\n+\n+// PodSpec is a description of a pod.\n+typedef PodSpec = PodSpec {\n+\t// NodeName is a request to schedule this pod onto a specific node. If it is non-empty,\n+\t// the scheduler simply schedules this pod onto that node, assuming that it fits resource\n+\t// requirements.\n+\tnodeName: string\n+}\n+\n+// PodStatus represents information about the status of a pod. Status may trail the actual\n+// state of a system, especially if the node that hosts the pod cannot contact the control\n+// plane.\n+typedef PodStatus = PodStatus {\n+\t// IP address allocated to the pod. Routable at least within the cluster.\n+\t// Empty if not yet allocated.\n+\tpodIP: string\n+}\n+\n+// Pod is a collection of containers that can run on a host. This resource is created\n+// by clients and scheduled onto hosts. */\n+// TODO: primary key\n+input relation Pod (\n+\t// Name must be unique within a namespace.\n+    name: Option<string>,\n+    // Namespace defines the space within each name must be unique.\n+    namespace: Option<string>,\n+    // UID is the unique in time and space value for this object.\n+    uid: UID,\n+\t// Map of string keys and values that can be used to organize and categorize\n+\t// (scope and select) objects. May match selectors of replication controllers\n+\t// and services.\n+\t// More info: http://kubernetes.io/docs/user-guide/labels\n+\t// +optional\n+\tlabels: Map<string, string>,\n+\t// Specification of the desired behavior of the pod.\n+    spec: PodSpec,\n+\t// Most recently observed status of the pod.\n+    status: PodStatus\n+)\n+\n+// Namespace provides a scope for Names.\n+// Use of multiple namespaces is optional.\n+input relation Namespace (\n+\t// Name must be unique within a namespace.\n+    name: string,\n+    // UID is the unique in time and space value for this object.\n+    uid: UID,\n+\t// Map of string keys and values that can be used to organize and categorize\n+\t// (scope and select) objects. May match selectors of replication controllers\n+\t// and services.\n+\t// More info: http://kubernetes.io/docs/user-guide/labels\n+\t// +optional\n+\tlabels: Map<string, string>\n+)\n+\n+// NetworkPolicy describes what network traffic is allowed for a set of Pods\n+input relation NetworkPolicy (\n+    // Name must be unique within a namespace.\n+    name: string,\n+    // Namespace defines the space within each name must be unique.\n+    namespace: string,\n+    // UID is the unique in time and space value for this object.\n+    uid: UID,\n+\t// Specification of the desired behavior for this NetworkPolicy.\n+    spec: NetworkPolicySpec\n+)\n+\n+// A label selector is a label query over a set of resources. The result of matchLabels and\n+// matchExpressions are ANDed. An empty label selector matches all objects. A null\n+// label selector matches no objects.\n+typedef LabelSelector = LabelSelector {\n+\t// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\n+\t// map is equivalent to an element of matchExpressions, whose key field is \"key\", the\n+\t// operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.\n+\t// +optional\n+\tmatchLabels: Map<string,string>,\n+\t// matchExpressions is a list of label selector requirements. The requirements are ANDed.\n+\t// +optional\n+\tmatchExpressions: Vec<LabelSelectorRequirement>\n+}\n+\n+/* The native Antrea implementation converts LabelSelector to a generic selector\n+ * struct before . */\n+// Matches returns true if the Requirement matches the input Labels.\n+// There is a match in the following cases:\n+// (1) The operator is Exists and Labels has the Requirement's key.\n+// (2) The operator is In, Labels has the Requirement's key and Labels'\n+//     value for that key is in Requirement's value set.\n+// (3) The operator is NotIn, Labels has the Requirement's key and\n+//     Labels' value for that key is not in Requirement's value set.\n+// (4) The operator is DoesNotExist or NotIn and Labels does not have the\n+//     Requirement's key.\n+function labelSelectorMatches(selector: Option<Ref<LabelSelector>>, labels: Map<string, string>): bool =\n+{\n+    match (selector) {\n+        None -> false,\n+        Some{s} -> {\n+            var matches = true;\n+            var sel = deref(s);\n+            if (map_is_empty(sel.matchLabels) and vec_is_empty(sel.matchExpressions)) {\n+                true\n+            } else {\n+                for (lab in sel.matchLabels) {\n+                    matches = matches and (map_get(labels, lab.0) == Some{lab.1})\n+                    // TODO: return false\n+                };\n+                for (e in sel.matchExpressions) {\n+                    matches = matches and\n+                    (match (e.operator) {\n+                        LabelSelectorOpIn -> {\n+                            match (map_get(labels, e.reqkey)) {\n+                                None -> false,\n+                                Some{val} -> vec_contains(e.values, val)\n+                            }\n+                        },\n+\t                    LabelSelectorOpNotIn -> {\n+                            match (map_get(labels, e.reqkey)) {\n+                                None -> true,\n+                                Some{val} -> not vec_contains(e.values, val)\n+                            }\n+                        },\n+\t                    LabelSelectorOpExists -> map_contains_key(labels, e.reqkey),\n+\t                    LabelSelectorOpDoesNotExist -> not map_contains_key(labels, e.reqkey)\n+                    })\n+                };\n+                matches\n+            }\n+        }\n+    }\n+}\n+\n+// A label selector requirement is a selector that contains values, a key, and an operator that\n+// relates the key and values.\n+typedef LabelSelectorRequirement = LabelSelectorRequirement {\n+\t// key is the label key that the selector applies to.\n+\t// +patchMergeKey=key\n+\t// +patchStrategy=merge\n+\treqkey: string,\n+\t// operator represents a key's relationship to a set of values.\n+\t// Valid operators are In, NotIn, Exists and DoesNotExist.\n+\toperator: LabelSelectorOperator,\n+\t// values is an array of string values. If the operator is In or NotIn,\n+\t// the values array must be non-empty. If the operator is Exists or DoesNotExist,\n+\t// the values array must be empty. This array is replaced during a strategic\n+\t// merge patch.\n+\t// +optional\n+\tvalues: Vec<string>\n+}\n+\n+// A label selector operator is the set of operators that can be used in a selector requirement.\n+typedef LabelSelectorOperator = LabelSelectorOpIn\n+\t                          | LabelSelectorOpNotIn\n+\t                          | LabelSelectorOpExists\n+\t                          | LabelSelectorOpDoesNotExist\n+\n+function labelSelectorOperator2string(op: LabelSelectorOperator): string =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11822990ea93d6fce22fc4ea9cbe06866e163b44"}, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk0MTYwNA==", "bodyText": "indent", "url": "https://github.com/vmware/differential-datalog/pull/505#discussion_r374941604", "createdAt": "2020-02-04T21:47:48Z", "author": {"login": "mbudiu-vmw"}, "path": "test/antrea/k8spolicy.dl", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Inputs consumed by Antrea controller from Kuberneters: pods, namespaces,\n+ * network policies.\n+ */\n+\n+// TODO: this module should probably be broken up into several to match Go module hierachy.\n+\n+import intern\n+\n+typedef UID = UID{uid: string}\n+\n+// PodSpec is a description of a pod.\n+typedef PodSpec = PodSpec {\n+\t// NodeName is a request to schedule this pod onto a specific node. If it is non-empty,\n+\t// the scheduler simply schedules this pod onto that node, assuming that it fits resource\n+\t// requirements.\n+\tnodeName: string\n+}\n+\n+// PodStatus represents information about the status of a pod. Status may trail the actual\n+// state of a system, especially if the node that hosts the pod cannot contact the control\n+// plane.\n+typedef PodStatus = PodStatus {\n+\t// IP address allocated to the pod. Routable at least within the cluster.\n+\t// Empty if not yet allocated.\n+\tpodIP: string\n+}\n+\n+// Pod is a collection of containers that can run on a host. This resource is created\n+// by clients and scheduled onto hosts. */\n+// TODO: primary key\n+input relation Pod (\n+\t// Name must be unique within a namespace.\n+    name: Option<string>,\n+    // Namespace defines the space within each name must be unique.\n+    namespace: Option<string>,\n+    // UID is the unique in time and space value for this object.\n+    uid: UID,\n+\t// Map of string keys and values that can be used to organize and categorize\n+\t// (scope and select) objects. May match selectors of replication controllers\n+\t// and services.\n+\t// More info: http://kubernetes.io/docs/user-guide/labels\n+\t// +optional\n+\tlabels: Map<string, string>,\n+\t// Specification of the desired behavior of the pod.\n+    spec: PodSpec,\n+\t// Most recently observed status of the pod.\n+    status: PodStatus\n+)\n+\n+// Namespace provides a scope for Names.\n+// Use of multiple namespaces is optional.\n+input relation Namespace (\n+\t// Name must be unique within a namespace.\n+    name: string,\n+    // UID is the unique in time and space value for this object.\n+    uid: UID,\n+\t// Map of string keys and values that can be used to organize and categorize\n+\t// (scope and select) objects. May match selectors of replication controllers\n+\t// and services.\n+\t// More info: http://kubernetes.io/docs/user-guide/labels\n+\t// +optional\n+\tlabels: Map<string, string>\n+)\n+\n+// NetworkPolicy describes what network traffic is allowed for a set of Pods\n+input relation NetworkPolicy (\n+    // Name must be unique within a namespace.\n+    name: string,\n+    // Namespace defines the space within each name must be unique.\n+    namespace: string,\n+    // UID is the unique in time and space value for this object.\n+    uid: UID,\n+\t// Specification of the desired behavior for this NetworkPolicy.\n+    spec: NetworkPolicySpec\n+)\n+\n+// A label selector is a label query over a set of resources. The result of matchLabels and\n+// matchExpressions are ANDed. An empty label selector matches all objects. A null\n+// label selector matches no objects.\n+typedef LabelSelector = LabelSelector {\n+\t// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\n+\t// map is equivalent to an element of matchExpressions, whose key field is \"key\", the\n+\t// operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.\n+\t// +optional\n+\tmatchLabels: Map<string,string>,\n+\t// matchExpressions is a list of label selector requirements. The requirements are ANDed.\n+\t// +optional\n+\tmatchExpressions: Vec<LabelSelectorRequirement>\n+}\n+\n+/* The native Antrea implementation converts LabelSelector to a generic selector\n+ * struct before . */\n+// Matches returns true if the Requirement matches the input Labels.\n+// There is a match in the following cases:\n+// (1) The operator is Exists and Labels has the Requirement's key.\n+// (2) The operator is In, Labels has the Requirement's key and Labels'\n+//     value for that key is in Requirement's value set.\n+// (3) The operator is NotIn, Labels has the Requirement's key and\n+//     Labels' value for that key is not in Requirement's value set.\n+// (4) The operator is DoesNotExist or NotIn and Labels does not have the\n+//     Requirement's key.\n+function labelSelectorMatches(selector: Option<Ref<LabelSelector>>, labels: Map<string, string>): bool =\n+{\n+    match (selector) {\n+        None -> false,\n+        Some{s} -> {\n+            var matches = true;\n+            var sel = deref(s);\n+            if (map_is_empty(sel.matchLabels) and vec_is_empty(sel.matchExpressions)) {\n+                true\n+            } else {\n+                for (lab in sel.matchLabels) {\n+                    matches = matches and (map_get(labels, lab.0) == Some{lab.1})\n+                    // TODO: return false\n+                };\n+                for (e in sel.matchExpressions) {\n+                    matches = matches and\n+                    (match (e.operator) {\n+                        LabelSelectorOpIn -> {\n+                            match (map_get(labels, e.reqkey)) {\n+                                None -> false,\n+                                Some{val} -> vec_contains(e.values, val)\n+                            }\n+                        },\n+\t                    LabelSelectorOpNotIn -> {\n+                            match (map_get(labels, e.reqkey)) {\n+                                None -> true,\n+                                Some{val} -> not vec_contains(e.values, val)\n+                            }\n+                        },\n+\t                    LabelSelectorOpExists -> map_contains_key(labels, e.reqkey),\n+\t                    LabelSelectorOpDoesNotExist -> not map_contains_key(labels, e.reqkey)\n+                    })\n+                };\n+                matches\n+            }\n+        }\n+    }\n+}\n+\n+// A label selector requirement is a selector that contains values, a key, and an operator that\n+// relates the key and values.\n+typedef LabelSelectorRequirement = LabelSelectorRequirement {\n+\t// key is the label key that the selector applies to.\n+\t// +patchMergeKey=key\n+\t// +patchStrategy=merge\n+\treqkey: string,\n+\t// operator represents a key's relationship to a set of values.\n+\t// Valid operators are In, NotIn, Exists and DoesNotExist.\n+\toperator: LabelSelectorOperator,\n+\t// values is an array of string values. If the operator is In or NotIn,\n+\t// the values array must be non-empty. If the operator is Exists or DoesNotExist,\n+\t// the values array must be empty. This array is replaced during a strategic\n+\t// merge patch.\n+\t// +optional\n+\tvalues: Vec<string>\n+}\n+\n+// A label selector operator is the set of operators that can be used in a selector requirement.\n+typedef LabelSelectorOperator = LabelSelectorOpIn\n+\t                          | LabelSelectorOpNotIn\n+\t                          | LabelSelectorOpExists\n+\t                          | LabelSelectorOpDoesNotExist\n+\n+function labelSelectorOperator2string(op: LabelSelectorOperator): string =\n+{\n+    match (op) {\n+        LabelSelectorOpIn           -> \"In\",\n+\t    LabelSelectorOpNotIn        -> \"NotIn\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11822990ea93d6fce22fc4ea9cbe06866e163b44"}, "originalPosition": 170}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk0MTc1OQ==", "bodyText": "I think this should also be moved earlier.", "url": "https://github.com/vmware/differential-datalog/pull/505#discussion_r374941759", "createdAt": "2020-02-04T21:48:07Z", "author": {"login": "mbudiu-vmw"}, "path": "test/antrea/k8spolicy.dl", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Inputs consumed by Antrea controller from Kuberneters: pods, namespaces,\n+ * network policies.\n+ */\n+\n+// TODO: this module should probably be broken up into several to match Go module hierachy.\n+\n+import intern\n+\n+typedef UID = UID{uid: string}\n+\n+// PodSpec is a description of a pod.\n+typedef PodSpec = PodSpec {\n+\t// NodeName is a request to schedule this pod onto a specific node. If it is non-empty,\n+\t// the scheduler simply schedules this pod onto that node, assuming that it fits resource\n+\t// requirements.\n+\tnodeName: string\n+}\n+\n+// PodStatus represents information about the status of a pod. Status may trail the actual\n+// state of a system, especially if the node that hosts the pod cannot contact the control\n+// plane.\n+typedef PodStatus = PodStatus {\n+\t// IP address allocated to the pod. Routable at least within the cluster.\n+\t// Empty if not yet allocated.\n+\tpodIP: string\n+}\n+\n+// Pod is a collection of containers that can run on a host. This resource is created\n+// by clients and scheduled onto hosts. */\n+// TODO: primary key\n+input relation Pod (\n+\t// Name must be unique within a namespace.\n+    name: Option<string>,\n+    // Namespace defines the space within each name must be unique.\n+    namespace: Option<string>,\n+    // UID is the unique in time and space value for this object.\n+    uid: UID,\n+\t// Map of string keys and values that can be used to organize and categorize\n+\t// (scope and select) objects. May match selectors of replication controllers\n+\t// and services.\n+\t// More info: http://kubernetes.io/docs/user-guide/labels\n+\t// +optional\n+\tlabels: Map<string, string>,\n+\t// Specification of the desired behavior of the pod.\n+    spec: PodSpec,\n+\t// Most recently observed status of the pod.\n+    status: PodStatus\n+)\n+\n+// Namespace provides a scope for Names.\n+// Use of multiple namespaces is optional.\n+input relation Namespace (\n+\t// Name must be unique within a namespace.\n+    name: string,\n+    // UID is the unique in time and space value for this object.\n+    uid: UID,\n+\t// Map of string keys and values that can be used to organize and categorize\n+\t// (scope and select) objects. May match selectors of replication controllers\n+\t// and services.\n+\t// More info: http://kubernetes.io/docs/user-guide/labels\n+\t// +optional\n+\tlabels: Map<string, string>\n+)\n+\n+// NetworkPolicy describes what network traffic is allowed for a set of Pods\n+input relation NetworkPolicy (\n+    // Name must be unique within a namespace.\n+    name: string,\n+    // Namespace defines the space within each name must be unique.\n+    namespace: string,\n+    // UID is the unique in time and space value for this object.\n+    uid: UID,\n+\t// Specification of the desired behavior for this NetworkPolicy.\n+    spec: NetworkPolicySpec\n+)\n+\n+// A label selector is a label query over a set of resources. The result of matchLabels and\n+// matchExpressions are ANDed. An empty label selector matches all objects. A null\n+// label selector matches no objects.\n+typedef LabelSelector = LabelSelector {\n+\t// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\n+\t// map is equivalent to an element of matchExpressions, whose key field is \"key\", the\n+\t// operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.\n+\t// +optional\n+\tmatchLabels: Map<string,string>,\n+\t// matchExpressions is a list of label selector requirements. The requirements are ANDed.\n+\t// +optional\n+\tmatchExpressions: Vec<LabelSelectorRequirement>\n+}\n+\n+/* The native Antrea implementation converts LabelSelector to a generic selector\n+ * struct before . */\n+// Matches returns true if the Requirement matches the input Labels.\n+// There is a match in the following cases:\n+// (1) The operator is Exists and Labels has the Requirement's key.\n+// (2) The operator is In, Labels has the Requirement's key and Labels'\n+//     value for that key is in Requirement's value set.\n+// (3) The operator is NotIn, Labels has the Requirement's key and\n+//     Labels' value for that key is not in Requirement's value set.\n+// (4) The operator is DoesNotExist or NotIn and Labels does not have the\n+//     Requirement's key.\n+function labelSelectorMatches(selector: Option<Ref<LabelSelector>>, labels: Map<string, string>): bool =\n+{\n+    match (selector) {\n+        None -> false,\n+        Some{s} -> {\n+            var matches = true;\n+            var sel = deref(s);\n+            if (map_is_empty(sel.matchLabels) and vec_is_empty(sel.matchExpressions)) {\n+                true\n+            } else {\n+                for (lab in sel.matchLabels) {\n+                    matches = matches and (map_get(labels, lab.0) == Some{lab.1})\n+                    // TODO: return false\n+                };\n+                for (e in sel.matchExpressions) {\n+                    matches = matches and\n+                    (match (e.operator) {\n+                        LabelSelectorOpIn -> {\n+                            match (map_get(labels, e.reqkey)) {\n+                                None -> false,\n+                                Some{val} -> vec_contains(e.values, val)\n+                            }\n+                        },\n+\t                    LabelSelectorOpNotIn -> {\n+                            match (map_get(labels, e.reqkey)) {\n+                                None -> true,\n+                                Some{val} -> not vec_contains(e.values, val)\n+                            }\n+                        },\n+\t                    LabelSelectorOpExists -> map_contains_key(labels, e.reqkey),\n+\t                    LabelSelectorOpDoesNotExist -> not map_contains_key(labels, e.reqkey)\n+                    })\n+                };\n+                matches\n+            }\n+        }\n+    }\n+}\n+\n+// A label selector requirement is a selector that contains values, a key, and an operator that\n+// relates the key and values.\n+typedef LabelSelectorRequirement = LabelSelectorRequirement {\n+\t// key is the label key that the selector applies to.\n+\t// +patchMergeKey=key\n+\t// +patchStrategy=merge\n+\treqkey: string,\n+\t// operator represents a key's relationship to a set of values.\n+\t// Valid operators are In, NotIn, Exists and DoesNotExist.\n+\toperator: LabelSelectorOperator,\n+\t// values is an array of string values. If the operator is In or NotIn,\n+\t// the values array must be non-empty. If the operator is Exists or DoesNotExist,\n+\t// the values array must be empty. This array is replaced during a strategic\n+\t// merge patch.\n+\t// +optional\n+\tvalues: Vec<string>\n+}\n+\n+// A label selector operator is the set of operators that can be used in a selector requirement.\n+typedef LabelSelectorOperator = LabelSelectorOpIn\n+\t                          | LabelSelectorOpNotIn\n+\t                          | LabelSelectorOpExists\n+\t                          | LabelSelectorOpDoesNotExist\n+\n+function labelSelectorOperator2string(op: LabelSelectorOperator): string =\n+{\n+    match (op) {\n+        LabelSelectorOpIn           -> \"In\",\n+\t    LabelSelectorOpNotIn        -> \"NotIn\",\n+\t    LabelSelectorOpExists       -> \"Exists\",\n+\t    LabelSelectorOpDoesNotExist -> \"DoesNotExist\"\n+    }\n+}\n+\n+typedef PolicyType = PolicyTypeIngress\n+                   | PolicyTypeEgress\n+\n+// NetworkPolicySpec provides the specification of a NetworkPolicy\n+typedef NetworkPolicySpec = NetworkPolicySpec {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11822990ea93d6fce22fc4ea9cbe06866e163b44"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk0MjIxOQ==", "bodyText": "Does +optional mean that the vector can be empty?\nOr is it like ovn where it means that the vector has 0 or 1?", "url": "https://github.com/vmware/differential-datalog/pull/505#discussion_r374942219", "createdAt": "2020-02-04T21:49:05Z", "author": {"login": "mbudiu-vmw"}, "path": "test/antrea/k8spolicy.dl", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Inputs consumed by Antrea controller from Kuberneters: pods, namespaces,\n+ * network policies.\n+ */\n+\n+// TODO: this module should probably be broken up into several to match Go module hierachy.\n+\n+import intern\n+\n+typedef UID = UID{uid: string}\n+\n+// PodSpec is a description of a pod.\n+typedef PodSpec = PodSpec {\n+\t// NodeName is a request to schedule this pod onto a specific node. If it is non-empty,\n+\t// the scheduler simply schedules this pod onto that node, assuming that it fits resource\n+\t// requirements.\n+\tnodeName: string\n+}\n+\n+// PodStatus represents information about the status of a pod. Status may trail the actual\n+// state of a system, especially if the node that hosts the pod cannot contact the control\n+// plane.\n+typedef PodStatus = PodStatus {\n+\t// IP address allocated to the pod. Routable at least within the cluster.\n+\t// Empty if not yet allocated.\n+\tpodIP: string\n+}\n+\n+// Pod is a collection of containers that can run on a host. This resource is created\n+// by clients and scheduled onto hosts. */\n+// TODO: primary key\n+input relation Pod (\n+\t// Name must be unique within a namespace.\n+    name: Option<string>,\n+    // Namespace defines the space within each name must be unique.\n+    namespace: Option<string>,\n+    // UID is the unique in time and space value for this object.\n+    uid: UID,\n+\t// Map of string keys and values that can be used to organize and categorize\n+\t// (scope and select) objects. May match selectors of replication controllers\n+\t// and services.\n+\t// More info: http://kubernetes.io/docs/user-guide/labels\n+\t// +optional\n+\tlabels: Map<string, string>,\n+\t// Specification of the desired behavior of the pod.\n+    spec: PodSpec,\n+\t// Most recently observed status of the pod.\n+    status: PodStatus\n+)\n+\n+// Namespace provides a scope for Names.\n+// Use of multiple namespaces is optional.\n+input relation Namespace (\n+\t// Name must be unique within a namespace.\n+    name: string,\n+    // UID is the unique in time and space value for this object.\n+    uid: UID,\n+\t// Map of string keys and values that can be used to organize and categorize\n+\t// (scope and select) objects. May match selectors of replication controllers\n+\t// and services.\n+\t// More info: http://kubernetes.io/docs/user-guide/labels\n+\t// +optional\n+\tlabels: Map<string, string>\n+)\n+\n+// NetworkPolicy describes what network traffic is allowed for a set of Pods\n+input relation NetworkPolicy (\n+    // Name must be unique within a namespace.\n+    name: string,\n+    // Namespace defines the space within each name must be unique.\n+    namespace: string,\n+    // UID is the unique in time and space value for this object.\n+    uid: UID,\n+\t// Specification of the desired behavior for this NetworkPolicy.\n+    spec: NetworkPolicySpec\n+)\n+\n+// A label selector is a label query over a set of resources. The result of matchLabels and\n+// matchExpressions are ANDed. An empty label selector matches all objects. A null\n+// label selector matches no objects.\n+typedef LabelSelector = LabelSelector {\n+\t// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\n+\t// map is equivalent to an element of matchExpressions, whose key field is \"key\", the\n+\t// operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.\n+\t// +optional\n+\tmatchLabels: Map<string,string>,\n+\t// matchExpressions is a list of label selector requirements. The requirements are ANDed.\n+\t// +optional\n+\tmatchExpressions: Vec<LabelSelectorRequirement>\n+}\n+\n+/* The native Antrea implementation converts LabelSelector to a generic selector\n+ * struct before . */\n+// Matches returns true if the Requirement matches the input Labels.\n+// There is a match in the following cases:\n+// (1) The operator is Exists and Labels has the Requirement's key.\n+// (2) The operator is In, Labels has the Requirement's key and Labels'\n+//     value for that key is in Requirement's value set.\n+// (3) The operator is NotIn, Labels has the Requirement's key and\n+//     Labels' value for that key is not in Requirement's value set.\n+// (4) The operator is DoesNotExist or NotIn and Labels does not have the\n+//     Requirement's key.\n+function labelSelectorMatches(selector: Option<Ref<LabelSelector>>, labels: Map<string, string>): bool =\n+{\n+    match (selector) {\n+        None -> false,\n+        Some{s} -> {\n+            var matches = true;\n+            var sel = deref(s);\n+            if (map_is_empty(sel.matchLabels) and vec_is_empty(sel.matchExpressions)) {\n+                true\n+            } else {\n+                for (lab in sel.matchLabels) {\n+                    matches = matches and (map_get(labels, lab.0) == Some{lab.1})\n+                    // TODO: return false\n+                };\n+                for (e in sel.matchExpressions) {\n+                    matches = matches and\n+                    (match (e.operator) {\n+                        LabelSelectorOpIn -> {\n+                            match (map_get(labels, e.reqkey)) {\n+                                None -> false,\n+                                Some{val} -> vec_contains(e.values, val)\n+                            }\n+                        },\n+\t                    LabelSelectorOpNotIn -> {\n+                            match (map_get(labels, e.reqkey)) {\n+                                None -> true,\n+                                Some{val} -> not vec_contains(e.values, val)\n+                            }\n+                        },\n+\t                    LabelSelectorOpExists -> map_contains_key(labels, e.reqkey),\n+\t                    LabelSelectorOpDoesNotExist -> not map_contains_key(labels, e.reqkey)\n+                    })\n+                };\n+                matches\n+            }\n+        }\n+    }\n+}\n+\n+// A label selector requirement is a selector that contains values, a key, and an operator that\n+// relates the key and values.\n+typedef LabelSelectorRequirement = LabelSelectorRequirement {\n+\t// key is the label key that the selector applies to.\n+\t// +patchMergeKey=key\n+\t// +patchStrategy=merge\n+\treqkey: string,\n+\t// operator represents a key's relationship to a set of values.\n+\t// Valid operators are In, NotIn, Exists and DoesNotExist.\n+\toperator: LabelSelectorOperator,\n+\t// values is an array of string values. If the operator is In or NotIn,\n+\t// the values array must be non-empty. If the operator is Exists or DoesNotExist,\n+\t// the values array must be empty. This array is replaced during a strategic\n+\t// merge patch.\n+\t// +optional\n+\tvalues: Vec<string>\n+}\n+\n+// A label selector operator is the set of operators that can be used in a selector requirement.\n+typedef LabelSelectorOperator = LabelSelectorOpIn\n+\t                          | LabelSelectorOpNotIn\n+\t                          | LabelSelectorOpExists\n+\t                          | LabelSelectorOpDoesNotExist\n+\n+function labelSelectorOperator2string(op: LabelSelectorOperator): string =\n+{\n+    match (op) {\n+        LabelSelectorOpIn           -> \"In\",\n+\t    LabelSelectorOpNotIn        -> \"NotIn\",\n+\t    LabelSelectorOpExists       -> \"Exists\",\n+\t    LabelSelectorOpDoesNotExist -> \"DoesNotExist\"\n+    }\n+}\n+\n+typedef PolicyType = PolicyTypeIngress\n+                   | PolicyTypeEgress\n+\n+// NetworkPolicySpec provides the specification of a NetworkPolicy\n+typedef NetworkPolicySpec = NetworkPolicySpec {\n+\t// Selects the pods to which this NetworkPolicy object applies. The array of\n+\t// ingress rules is applied to any pods selected by this field. Multiple network\n+\t// policies can select the same set of pods. In this case, the ingress rules for\n+\t// each are combined additively. This field is NOT optional and follows standard\n+\t// label selector semantics. An empty podSelector matches all pods in this\n+\t// namespace.\n+\tpodSelector: Ref<LabelSelector>,\n+\n+\t// List of ingress rules to be applied to the selected pods. Traffic is allowed to\n+\t// a pod if there are no NetworkPolicies selecting the pod\n+\t// (and cluster policy otherwise allows the traffic), OR if the traffic source is\n+\t// the pod's local node, OR if the traffic matches at least one ingress rule\n+\t// across all of the NetworkPolicy objects whose podSelector matches the pod. If\n+\t// this field is empty then this NetworkPolicy does not allow any traffic (and serves\n+\t// solely to ensure that the pods it selects are isolated by default)\n+\t// +optional", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11822990ea93d6fce22fc4ea9cbe06866e163b44"}, "originalPosition": 196}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk0NDIxNg==", "bodyText": "I suspect that all these comments are inherited from another language. It may be difficult to keep them in sync, but I have no suggestion really.", "url": "https://github.com/vmware/differential-datalog/pull/505#discussion_r374944216", "createdAt": "2020-02-04T21:53:16Z", "author": {"login": "mbudiu-vmw"}, "path": "test/antrea/k8spolicy.dl", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Inputs consumed by Antrea controller from Kuberneters: pods, namespaces,\n+ * network policies.\n+ */\n+\n+// TODO: this module should probably be broken up into several to match Go module hierachy.\n+\n+import intern\n+\n+typedef UID = UID{uid: string}\n+\n+// PodSpec is a description of a pod.\n+typedef PodSpec = PodSpec {\n+\t// NodeName is a request to schedule this pod onto a specific node. If it is non-empty,\n+\t// the scheduler simply schedules this pod onto that node, assuming that it fits resource\n+\t// requirements.\n+\tnodeName: string\n+}\n+\n+// PodStatus represents information about the status of a pod. Status may trail the actual\n+// state of a system, especially if the node that hosts the pod cannot contact the control\n+// plane.\n+typedef PodStatus = PodStatus {\n+\t// IP address allocated to the pod. Routable at least within the cluster.\n+\t// Empty if not yet allocated.\n+\tpodIP: string\n+}\n+\n+// Pod is a collection of containers that can run on a host. This resource is created\n+// by clients and scheduled onto hosts. */\n+// TODO: primary key\n+input relation Pod (\n+\t// Name must be unique within a namespace.\n+    name: Option<string>,\n+    // Namespace defines the space within each name must be unique.\n+    namespace: Option<string>,\n+    // UID is the unique in time and space value for this object.\n+    uid: UID,\n+\t// Map of string keys and values that can be used to organize and categorize\n+\t// (scope and select) objects. May match selectors of replication controllers\n+\t// and services.\n+\t// More info: http://kubernetes.io/docs/user-guide/labels\n+\t// +optional\n+\tlabels: Map<string, string>,\n+\t// Specification of the desired behavior of the pod.\n+    spec: PodSpec,\n+\t// Most recently observed status of the pod.\n+    status: PodStatus\n+)\n+\n+// Namespace provides a scope for Names.\n+// Use of multiple namespaces is optional.\n+input relation Namespace (\n+\t// Name must be unique within a namespace.\n+    name: string,\n+    // UID is the unique in time and space value for this object.\n+    uid: UID,\n+\t// Map of string keys and values that can be used to organize and categorize\n+\t// (scope and select) objects. May match selectors of replication controllers\n+\t// and services.\n+\t// More info: http://kubernetes.io/docs/user-guide/labels\n+\t// +optional\n+\tlabels: Map<string, string>\n+)\n+\n+// NetworkPolicy describes what network traffic is allowed for a set of Pods\n+input relation NetworkPolicy (\n+    // Name must be unique within a namespace.\n+    name: string,\n+    // Namespace defines the space within each name must be unique.\n+    namespace: string,\n+    // UID is the unique in time and space value for this object.\n+    uid: UID,\n+\t// Specification of the desired behavior for this NetworkPolicy.\n+    spec: NetworkPolicySpec\n+)\n+\n+// A label selector is a label query over a set of resources. The result of matchLabels and\n+// matchExpressions are ANDed. An empty label selector matches all objects. A null\n+// label selector matches no objects.\n+typedef LabelSelector = LabelSelector {\n+\t// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\n+\t// map is equivalent to an element of matchExpressions, whose key field is \"key\", the\n+\t// operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.\n+\t// +optional\n+\tmatchLabels: Map<string,string>,\n+\t// matchExpressions is a list of label selector requirements. The requirements are ANDed.\n+\t// +optional\n+\tmatchExpressions: Vec<LabelSelectorRequirement>\n+}\n+\n+/* The native Antrea implementation converts LabelSelector to a generic selector\n+ * struct before . */\n+// Matches returns true if the Requirement matches the input Labels.\n+// There is a match in the following cases:\n+// (1) The operator is Exists and Labels has the Requirement's key.\n+// (2) The operator is In, Labels has the Requirement's key and Labels'\n+//     value for that key is in Requirement's value set.\n+// (3) The operator is NotIn, Labels has the Requirement's key and\n+//     Labels' value for that key is not in Requirement's value set.\n+// (4) The operator is DoesNotExist or NotIn and Labels does not have the\n+//     Requirement's key.\n+function labelSelectorMatches(selector: Option<Ref<LabelSelector>>, labels: Map<string, string>): bool =\n+{\n+    match (selector) {\n+        None -> false,\n+        Some{s} -> {\n+            var matches = true;\n+            var sel = deref(s);\n+            if (map_is_empty(sel.matchLabels) and vec_is_empty(sel.matchExpressions)) {\n+                true\n+            } else {\n+                for (lab in sel.matchLabels) {\n+                    matches = matches and (map_get(labels, lab.0) == Some{lab.1})\n+                    // TODO: return false\n+                };\n+                for (e in sel.matchExpressions) {\n+                    matches = matches and\n+                    (match (e.operator) {\n+                        LabelSelectorOpIn -> {\n+                            match (map_get(labels, e.reqkey)) {\n+                                None -> false,\n+                                Some{val} -> vec_contains(e.values, val)\n+                            }\n+                        },\n+\t                    LabelSelectorOpNotIn -> {\n+                            match (map_get(labels, e.reqkey)) {\n+                                None -> true,\n+                                Some{val} -> not vec_contains(e.values, val)\n+                            }\n+                        },\n+\t                    LabelSelectorOpExists -> map_contains_key(labels, e.reqkey),\n+\t                    LabelSelectorOpDoesNotExist -> not map_contains_key(labels, e.reqkey)\n+                    })\n+                };\n+                matches\n+            }\n+        }\n+    }\n+}\n+\n+// A label selector requirement is a selector that contains values, a key, and an operator that\n+// relates the key and values.\n+typedef LabelSelectorRequirement = LabelSelectorRequirement {\n+\t// key is the label key that the selector applies to.\n+\t// +patchMergeKey=key\n+\t// +patchStrategy=merge\n+\treqkey: string,\n+\t// operator represents a key's relationship to a set of values.\n+\t// Valid operators are In, NotIn, Exists and DoesNotExist.\n+\toperator: LabelSelectorOperator,\n+\t// values is an array of string values. If the operator is In or NotIn,\n+\t// the values array must be non-empty. If the operator is Exists or DoesNotExist,\n+\t// the values array must be empty. This array is replaced during a strategic\n+\t// merge patch.\n+\t// +optional\n+\tvalues: Vec<string>\n+}\n+\n+// A label selector operator is the set of operators that can be used in a selector requirement.\n+typedef LabelSelectorOperator = LabelSelectorOpIn\n+\t                          | LabelSelectorOpNotIn\n+\t                          | LabelSelectorOpExists\n+\t                          | LabelSelectorOpDoesNotExist\n+\n+function labelSelectorOperator2string(op: LabelSelectorOperator): string =\n+{\n+    match (op) {\n+        LabelSelectorOpIn           -> \"In\",\n+\t    LabelSelectorOpNotIn        -> \"NotIn\",\n+\t    LabelSelectorOpExists       -> \"Exists\",\n+\t    LabelSelectorOpDoesNotExist -> \"DoesNotExist\"\n+    }\n+}\n+\n+typedef PolicyType = PolicyTypeIngress\n+                   | PolicyTypeEgress\n+\n+// NetworkPolicySpec provides the specification of a NetworkPolicy\n+typedef NetworkPolicySpec = NetworkPolicySpec {\n+\t// Selects the pods to which this NetworkPolicy object applies. The array of\n+\t// ingress rules is applied to any pods selected by this field. Multiple network\n+\t// policies can select the same set of pods. In this case, the ingress rules for\n+\t// each are combined additively. This field is NOT optional and follows standard\n+\t// label selector semantics. An empty podSelector matches all pods in this\n+\t// namespace.\n+\tpodSelector: Ref<LabelSelector>,\n+\n+\t// List of ingress rules to be applied to the selected pods. Traffic is allowed to\n+\t// a pod if there are no NetworkPolicies selecting the pod\n+\t// (and cluster policy otherwise allows the traffic), OR if the traffic source is\n+\t// the pod's local node, OR if the traffic matches at least one ingress rule\n+\t// across all of the NetworkPolicy objects whose podSelector matches the pod. If\n+\t// this field is empty then this NetworkPolicy does not allow any traffic (and serves\n+\t// solely to ensure that the pods it selects are isolated by default)\n+\t// +optional\n+\tingress: Vec<NetworkPolicyIngressRule>,\n+\n+\t// List of egress rules to be applied to the selected pods. Outgoing traffic is\n+\t// allowed if there are no NetworkPolicies selecting the pod (and cluster policy\n+\t// otherwise allows the traffic), OR if the traffic matches at least one egress rule\n+\t// across all of the NetworkPolicy objects whose podSelector matches the pod. If\n+\t// this field is empty then this NetworkPolicy limits all outgoing traffic (and serves\n+\t// solely to ensure that the pods it selects are isolated by default).\n+\t// This field is beta-level in 1.8\n+\t// +optional\n+\tegress: Vec<NetworkPolicyEgressRule>,\n+\n+\t// List of rule types that the NetworkPolicy relates to.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11822990ea93d6fce22fc4ea9cbe06866e163b44"}, "originalPosition": 209}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk0NzQzMw==", "bodyText": "indentation", "url": "https://github.com/vmware/differential-datalog/pull/505#discussion_r374947433", "createdAt": "2020-02-04T22:00:21Z", "author": {"login": "mbudiu-vmw"}, "path": "test/antrea/k8spolicy.dl", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Inputs consumed by Antrea controller from Kuberneters: pods, namespaces,\n+ * network policies.\n+ */\n+\n+// TODO: this module should probably be broken up into several to match Go module hierachy.\n+\n+import intern\n+\n+typedef UID = UID{uid: string}\n+\n+// PodSpec is a description of a pod.\n+typedef PodSpec = PodSpec {\n+\t// NodeName is a request to schedule this pod onto a specific node. If it is non-empty,\n+\t// the scheduler simply schedules this pod onto that node, assuming that it fits resource\n+\t// requirements.\n+\tnodeName: string\n+}\n+\n+// PodStatus represents information about the status of a pod. Status may trail the actual\n+// state of a system, especially if the node that hosts the pod cannot contact the control\n+// plane.\n+typedef PodStatus = PodStatus {\n+\t// IP address allocated to the pod. Routable at least within the cluster.\n+\t// Empty if not yet allocated.\n+\tpodIP: string\n+}\n+\n+// Pod is a collection of containers that can run on a host. This resource is created\n+// by clients and scheduled onto hosts. */\n+// TODO: primary key\n+input relation Pod (\n+\t// Name must be unique within a namespace.\n+    name: Option<string>,\n+    // Namespace defines the space within each name must be unique.\n+    namespace: Option<string>,\n+    // UID is the unique in time and space value for this object.\n+    uid: UID,\n+\t// Map of string keys and values that can be used to organize and categorize\n+\t// (scope and select) objects. May match selectors of replication controllers\n+\t// and services.\n+\t// More info: http://kubernetes.io/docs/user-guide/labels\n+\t// +optional\n+\tlabels: Map<string, string>,\n+\t// Specification of the desired behavior of the pod.\n+    spec: PodSpec,\n+\t// Most recently observed status of the pod.\n+    status: PodStatus\n+)\n+\n+// Namespace provides a scope for Names.\n+// Use of multiple namespaces is optional.\n+input relation Namespace (\n+\t// Name must be unique within a namespace.\n+    name: string,\n+    // UID is the unique in time and space value for this object.\n+    uid: UID,\n+\t// Map of string keys and values that can be used to organize and categorize\n+\t// (scope and select) objects. May match selectors of replication controllers\n+\t// and services.\n+\t// More info: http://kubernetes.io/docs/user-guide/labels\n+\t// +optional\n+\tlabels: Map<string, string>\n+)\n+\n+// NetworkPolicy describes what network traffic is allowed for a set of Pods\n+input relation NetworkPolicy (\n+    // Name must be unique within a namespace.\n+    name: string,\n+    // Namespace defines the space within each name must be unique.\n+    namespace: string,\n+    // UID is the unique in time and space value for this object.\n+    uid: UID,\n+\t// Specification of the desired behavior for this NetworkPolicy.\n+    spec: NetworkPolicySpec\n+)\n+\n+// A label selector is a label query over a set of resources. The result of matchLabels and\n+// matchExpressions are ANDed. An empty label selector matches all objects. A null\n+// label selector matches no objects.\n+typedef LabelSelector = LabelSelector {\n+\t// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\n+\t// map is equivalent to an element of matchExpressions, whose key field is \"key\", the\n+\t// operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.\n+\t// +optional\n+\tmatchLabels: Map<string,string>,\n+\t// matchExpressions is a list of label selector requirements. The requirements are ANDed.\n+\t// +optional\n+\tmatchExpressions: Vec<LabelSelectorRequirement>\n+}\n+\n+/* The native Antrea implementation converts LabelSelector to a generic selector\n+ * struct before . */\n+// Matches returns true if the Requirement matches the input Labels.\n+// There is a match in the following cases:\n+// (1) The operator is Exists and Labels has the Requirement's key.\n+// (2) The operator is In, Labels has the Requirement's key and Labels'\n+//     value for that key is in Requirement's value set.\n+// (3) The operator is NotIn, Labels has the Requirement's key and\n+//     Labels' value for that key is not in Requirement's value set.\n+// (4) The operator is DoesNotExist or NotIn and Labels does not have the\n+//     Requirement's key.\n+function labelSelectorMatches(selector: Option<Ref<LabelSelector>>, labels: Map<string, string>): bool =\n+{\n+    match (selector) {\n+        None -> false,\n+        Some{s} -> {\n+            var matches = true;\n+            var sel = deref(s);\n+            if (map_is_empty(sel.matchLabels) and vec_is_empty(sel.matchExpressions)) {\n+                true\n+            } else {\n+                for (lab in sel.matchLabels) {\n+                    matches = matches and (map_get(labels, lab.0) == Some{lab.1})\n+                    // TODO: return false\n+                };\n+                for (e in sel.matchExpressions) {\n+                    matches = matches and\n+                    (match (e.operator) {\n+                        LabelSelectorOpIn -> {\n+                            match (map_get(labels, e.reqkey)) {\n+                                None -> false,\n+                                Some{val} -> vec_contains(e.values, val)\n+                            }\n+                        },\n+\t                    LabelSelectorOpNotIn -> {\n+                            match (map_get(labels, e.reqkey)) {\n+                                None -> true,\n+                                Some{val} -> not vec_contains(e.values, val)\n+                            }\n+                        },\n+\t                    LabelSelectorOpExists -> map_contains_key(labels, e.reqkey),\n+\t                    LabelSelectorOpDoesNotExist -> not map_contains_key(labels, e.reqkey)\n+                    })\n+                };\n+                matches\n+            }\n+        }\n+    }\n+}\n+\n+// A label selector requirement is a selector that contains values, a key, and an operator that\n+// relates the key and values.\n+typedef LabelSelectorRequirement = LabelSelectorRequirement {\n+\t// key is the label key that the selector applies to.\n+\t// +patchMergeKey=key\n+\t// +patchStrategy=merge\n+\treqkey: string,\n+\t// operator represents a key's relationship to a set of values.\n+\t// Valid operators are In, NotIn, Exists and DoesNotExist.\n+\toperator: LabelSelectorOperator,\n+\t// values is an array of string values. If the operator is In or NotIn,\n+\t// the values array must be non-empty. If the operator is Exists or DoesNotExist,\n+\t// the values array must be empty. This array is replaced during a strategic\n+\t// merge patch.\n+\t// +optional\n+\tvalues: Vec<string>\n+}\n+\n+// A label selector operator is the set of operators that can be used in a selector requirement.\n+typedef LabelSelectorOperator = LabelSelectorOpIn\n+\t                          | LabelSelectorOpNotIn\n+\t                          | LabelSelectorOpExists\n+\t                          | LabelSelectorOpDoesNotExist\n+\n+function labelSelectorOperator2string(op: LabelSelectorOperator): string =\n+{\n+    match (op) {\n+        LabelSelectorOpIn           -> \"In\",\n+\t    LabelSelectorOpNotIn        -> \"NotIn\",\n+\t    LabelSelectorOpExists       -> \"Exists\",\n+\t    LabelSelectorOpDoesNotExist -> \"DoesNotExist\"\n+    }\n+}\n+\n+typedef PolicyType = PolicyTypeIngress\n+                   | PolicyTypeEgress\n+\n+// NetworkPolicySpec provides the specification of a NetworkPolicy\n+typedef NetworkPolicySpec = NetworkPolicySpec {\n+\t// Selects the pods to which this NetworkPolicy object applies. The array of\n+\t// ingress rules is applied to any pods selected by this field. Multiple network\n+\t// policies can select the same set of pods. In this case, the ingress rules for\n+\t// each are combined additively. This field is NOT optional and follows standard\n+\t// label selector semantics. An empty podSelector matches all pods in this\n+\t// namespace.\n+\tpodSelector: Ref<LabelSelector>,\n+\n+\t// List of ingress rules to be applied to the selected pods. Traffic is allowed to\n+\t// a pod if there are no NetworkPolicies selecting the pod\n+\t// (and cluster policy otherwise allows the traffic), OR if the traffic source is\n+\t// the pod's local node, OR if the traffic matches at least one ingress rule\n+\t// across all of the NetworkPolicy objects whose podSelector matches the pod. If\n+\t// this field is empty then this NetworkPolicy does not allow any traffic (and serves\n+\t// solely to ensure that the pods it selects are isolated by default)\n+\t// +optional\n+\tingress: Vec<NetworkPolicyIngressRule>,\n+\n+\t// List of egress rules to be applied to the selected pods. Outgoing traffic is\n+\t// allowed if there are no NetworkPolicies selecting the pod (and cluster policy\n+\t// otherwise allows the traffic), OR if the traffic matches at least one egress rule\n+\t// across all of the NetworkPolicy objects whose podSelector matches the pod. If\n+\t// this field is empty then this NetworkPolicy limits all outgoing traffic (and serves\n+\t// solely to ensure that the pods it selects are isolated by default).\n+\t// This field is beta-level in 1.8\n+\t// +optional\n+\tegress: Vec<NetworkPolicyEgressRule>,\n+\n+\t// List of rule types that the NetworkPolicy relates to.\n+\t// Valid options are \"Ingress\", \"Egress\", or \"Ingress,Egress\".\n+\t// If this field is not specified, it will default based on the existence of Ingress or Egress rules;\n+\t// policies that contain an Egress section are assumed to affect Egress, and all policies\n+\t// (whether or not they contain an Ingress section) are assumed to affect Ingress.\n+\t// If you want to write an egress-only policy, you must explicitly specify policyTypes [ \"Egress\" ].\n+\t// Likewise, if you want to write a policy that specifies that no egress is allowed,\n+\t// you must specify a policyTypes value that include \"Egress\" (since such a policy would not include\n+\t// an Egress section and would otherwise default to just [ \"Ingress\" ]).\n+\t// This field is beta-level in 1.8\n+\t// +optional\n+\tpolicyTypes: Vec<PolicyType>\n+}\n+\n+// NetworkPolicyIngressRule describes a particular set of traffic that is allowed to the pods\n+// matched by a NetworkPolicySpec's podSelector. The traffic must match both ports and from.\n+typedef NetworkPolicyIngressRule = NetworkPolicyIngressRule {\n+\t// List of ports which should be made accessible on the pods selected for this\n+\t// rule. Each item in this list is combined using a logical OR. If this field is\n+\t// empty or missing, this rule matches all ports (traffic not restricted by port).\n+\t// If this field is present and contains at least one item, then this rule allows\n+\t// traffic only if the traffic matches at least one port in the list.\n+\t// +optional\n+\tports: Vec<NetworkPolicyPort>,\n+\n+\t// List of sources which should be able to access the pods selected for this rule.\n+\t// Items in this list are combined using a logical OR operation. If this field is\n+\t// empty or missing, this rule matches all sources (traffic not restricted by\n+\t// source). If this field is present and contains at least on item, this rule\n+\t// allows traffic only if the traffic matches at least one item in the from list.\n+\t// +optional\n+\tfrom: Vec<NetworkPolicyPeer>\n+}\n+\n+// NetworkPolicyEgressRule describes a particular set of traffic that is allowed out of pods\n+// matched by a NetworkPolicySpec's podSelector. The traffic must match both ports and to.\n+// This type is beta-level in 1.8\n+typedef NetworkPolicyEgressRule = NetworkPolicyEgressRule {\n+\t// List of destination ports for outgoing traffic.\n+\t// Each item in this list is combined using a logical OR. If this field is\n+\t// empty or missing, this rule matches all ports (traffic not restricted by port).\n+\t// If this field is present and contains at least one item, then this rule allows\n+\t// traffic only if the traffic matches at least one port in the list.\n+\t// +optional\n+\tports: Vec<NetworkPolicyPort>,\n+\t// List of destinations for outgoing traffic of pods selected for this rule.\n+\t// Items in this list are combined using a logical OR operation. If this field is\n+\t// empty or missing, this rule matches all destinations (traffic not restricted by\n+\t// destination). If this field is present and contains at least one item, this rule\n+\t// allows traffic only if the traffic matches at least one item in the to list.\n+\t// +optional\n+\tto: Vec<NetworkPolicyPeer>\n+}\n+\n+typedef Protocol = IString\n+\n+typedef IntOrString = Either<signed<32>, string>\n+\n+function intOrStringIntValue(x: IntOrString): signed<32> =\n+{\n+    match (x) {\n+        Left{i} -> i,\n+        Right{s} -> {\n+            match (parse_dec_i64(s)) {\n+                None -> 0,\n+                Some{i} -> i as signed<32>\n+            }\n+        }\n+\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11822990ea93d6fce22fc4ea9cbe06866e163b44"}, "originalPosition": 277}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk0NzUxNA==", "bodyText": "what happens on overflow?", "url": "https://github.com/vmware/differential-datalog/pull/505#discussion_r374947514", "createdAt": "2020-02-04T22:00:32Z", "author": {"login": "mbudiu-vmw"}, "path": "test/antrea/k8spolicy.dl", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Inputs consumed by Antrea controller from Kuberneters: pods, namespaces,\n+ * network policies.\n+ */\n+\n+// TODO: this module should probably be broken up into several to match Go module hierachy.\n+\n+import intern\n+\n+typedef UID = UID{uid: string}\n+\n+// PodSpec is a description of a pod.\n+typedef PodSpec = PodSpec {\n+\t// NodeName is a request to schedule this pod onto a specific node. If it is non-empty,\n+\t// the scheduler simply schedules this pod onto that node, assuming that it fits resource\n+\t// requirements.\n+\tnodeName: string\n+}\n+\n+// PodStatus represents information about the status of a pod. Status may trail the actual\n+// state of a system, especially if the node that hosts the pod cannot contact the control\n+// plane.\n+typedef PodStatus = PodStatus {\n+\t// IP address allocated to the pod. Routable at least within the cluster.\n+\t// Empty if not yet allocated.\n+\tpodIP: string\n+}\n+\n+// Pod is a collection of containers that can run on a host. This resource is created\n+// by clients and scheduled onto hosts. */\n+// TODO: primary key\n+input relation Pod (\n+\t// Name must be unique within a namespace.\n+    name: Option<string>,\n+    // Namespace defines the space within each name must be unique.\n+    namespace: Option<string>,\n+    // UID is the unique in time and space value for this object.\n+    uid: UID,\n+\t// Map of string keys and values that can be used to organize and categorize\n+\t// (scope and select) objects. May match selectors of replication controllers\n+\t// and services.\n+\t// More info: http://kubernetes.io/docs/user-guide/labels\n+\t// +optional\n+\tlabels: Map<string, string>,\n+\t// Specification of the desired behavior of the pod.\n+    spec: PodSpec,\n+\t// Most recently observed status of the pod.\n+    status: PodStatus\n+)\n+\n+// Namespace provides a scope for Names.\n+// Use of multiple namespaces is optional.\n+input relation Namespace (\n+\t// Name must be unique within a namespace.\n+    name: string,\n+    // UID is the unique in time and space value for this object.\n+    uid: UID,\n+\t// Map of string keys and values that can be used to organize and categorize\n+\t// (scope and select) objects. May match selectors of replication controllers\n+\t// and services.\n+\t// More info: http://kubernetes.io/docs/user-guide/labels\n+\t// +optional\n+\tlabels: Map<string, string>\n+)\n+\n+// NetworkPolicy describes what network traffic is allowed for a set of Pods\n+input relation NetworkPolicy (\n+    // Name must be unique within a namespace.\n+    name: string,\n+    // Namespace defines the space within each name must be unique.\n+    namespace: string,\n+    // UID is the unique in time and space value for this object.\n+    uid: UID,\n+\t// Specification of the desired behavior for this NetworkPolicy.\n+    spec: NetworkPolicySpec\n+)\n+\n+// A label selector is a label query over a set of resources. The result of matchLabels and\n+// matchExpressions are ANDed. An empty label selector matches all objects. A null\n+// label selector matches no objects.\n+typedef LabelSelector = LabelSelector {\n+\t// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\n+\t// map is equivalent to an element of matchExpressions, whose key field is \"key\", the\n+\t// operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.\n+\t// +optional\n+\tmatchLabels: Map<string,string>,\n+\t// matchExpressions is a list of label selector requirements. The requirements are ANDed.\n+\t// +optional\n+\tmatchExpressions: Vec<LabelSelectorRequirement>\n+}\n+\n+/* The native Antrea implementation converts LabelSelector to a generic selector\n+ * struct before . */\n+// Matches returns true if the Requirement matches the input Labels.\n+// There is a match in the following cases:\n+// (1) The operator is Exists and Labels has the Requirement's key.\n+// (2) The operator is In, Labels has the Requirement's key and Labels'\n+//     value for that key is in Requirement's value set.\n+// (3) The operator is NotIn, Labels has the Requirement's key and\n+//     Labels' value for that key is not in Requirement's value set.\n+// (4) The operator is DoesNotExist or NotIn and Labels does not have the\n+//     Requirement's key.\n+function labelSelectorMatches(selector: Option<Ref<LabelSelector>>, labels: Map<string, string>): bool =\n+{\n+    match (selector) {\n+        None -> false,\n+        Some{s} -> {\n+            var matches = true;\n+            var sel = deref(s);\n+            if (map_is_empty(sel.matchLabels) and vec_is_empty(sel.matchExpressions)) {\n+                true\n+            } else {\n+                for (lab in sel.matchLabels) {\n+                    matches = matches and (map_get(labels, lab.0) == Some{lab.1})\n+                    // TODO: return false\n+                };\n+                for (e in sel.matchExpressions) {\n+                    matches = matches and\n+                    (match (e.operator) {\n+                        LabelSelectorOpIn -> {\n+                            match (map_get(labels, e.reqkey)) {\n+                                None -> false,\n+                                Some{val} -> vec_contains(e.values, val)\n+                            }\n+                        },\n+\t                    LabelSelectorOpNotIn -> {\n+                            match (map_get(labels, e.reqkey)) {\n+                                None -> true,\n+                                Some{val} -> not vec_contains(e.values, val)\n+                            }\n+                        },\n+\t                    LabelSelectorOpExists -> map_contains_key(labels, e.reqkey),\n+\t                    LabelSelectorOpDoesNotExist -> not map_contains_key(labels, e.reqkey)\n+                    })\n+                };\n+                matches\n+            }\n+        }\n+    }\n+}\n+\n+// A label selector requirement is a selector that contains values, a key, and an operator that\n+// relates the key and values.\n+typedef LabelSelectorRequirement = LabelSelectorRequirement {\n+\t// key is the label key that the selector applies to.\n+\t// +patchMergeKey=key\n+\t// +patchStrategy=merge\n+\treqkey: string,\n+\t// operator represents a key's relationship to a set of values.\n+\t// Valid operators are In, NotIn, Exists and DoesNotExist.\n+\toperator: LabelSelectorOperator,\n+\t// values is an array of string values. If the operator is In or NotIn,\n+\t// the values array must be non-empty. If the operator is Exists or DoesNotExist,\n+\t// the values array must be empty. This array is replaced during a strategic\n+\t// merge patch.\n+\t// +optional\n+\tvalues: Vec<string>\n+}\n+\n+// A label selector operator is the set of operators that can be used in a selector requirement.\n+typedef LabelSelectorOperator = LabelSelectorOpIn\n+\t                          | LabelSelectorOpNotIn\n+\t                          | LabelSelectorOpExists\n+\t                          | LabelSelectorOpDoesNotExist\n+\n+function labelSelectorOperator2string(op: LabelSelectorOperator): string =\n+{\n+    match (op) {\n+        LabelSelectorOpIn           -> \"In\",\n+\t    LabelSelectorOpNotIn        -> \"NotIn\",\n+\t    LabelSelectorOpExists       -> \"Exists\",\n+\t    LabelSelectorOpDoesNotExist -> \"DoesNotExist\"\n+    }\n+}\n+\n+typedef PolicyType = PolicyTypeIngress\n+                   | PolicyTypeEgress\n+\n+// NetworkPolicySpec provides the specification of a NetworkPolicy\n+typedef NetworkPolicySpec = NetworkPolicySpec {\n+\t// Selects the pods to which this NetworkPolicy object applies. The array of\n+\t// ingress rules is applied to any pods selected by this field. Multiple network\n+\t// policies can select the same set of pods. In this case, the ingress rules for\n+\t// each are combined additively. This field is NOT optional and follows standard\n+\t// label selector semantics. An empty podSelector matches all pods in this\n+\t// namespace.\n+\tpodSelector: Ref<LabelSelector>,\n+\n+\t// List of ingress rules to be applied to the selected pods. Traffic is allowed to\n+\t// a pod if there are no NetworkPolicies selecting the pod\n+\t// (and cluster policy otherwise allows the traffic), OR if the traffic source is\n+\t// the pod's local node, OR if the traffic matches at least one ingress rule\n+\t// across all of the NetworkPolicy objects whose podSelector matches the pod. If\n+\t// this field is empty then this NetworkPolicy does not allow any traffic (and serves\n+\t// solely to ensure that the pods it selects are isolated by default)\n+\t// +optional\n+\tingress: Vec<NetworkPolicyIngressRule>,\n+\n+\t// List of egress rules to be applied to the selected pods. Outgoing traffic is\n+\t// allowed if there are no NetworkPolicies selecting the pod (and cluster policy\n+\t// otherwise allows the traffic), OR if the traffic matches at least one egress rule\n+\t// across all of the NetworkPolicy objects whose podSelector matches the pod. If\n+\t// this field is empty then this NetworkPolicy limits all outgoing traffic (and serves\n+\t// solely to ensure that the pods it selects are isolated by default).\n+\t// This field is beta-level in 1.8\n+\t// +optional\n+\tegress: Vec<NetworkPolicyEgressRule>,\n+\n+\t// List of rule types that the NetworkPolicy relates to.\n+\t// Valid options are \"Ingress\", \"Egress\", or \"Ingress,Egress\".\n+\t// If this field is not specified, it will default based on the existence of Ingress or Egress rules;\n+\t// policies that contain an Egress section are assumed to affect Egress, and all policies\n+\t// (whether or not they contain an Ingress section) are assumed to affect Ingress.\n+\t// If you want to write an egress-only policy, you must explicitly specify policyTypes [ \"Egress\" ].\n+\t// Likewise, if you want to write a policy that specifies that no egress is allowed,\n+\t// you must specify a policyTypes value that include \"Egress\" (since such a policy would not include\n+\t// an Egress section and would otherwise default to just [ \"Ingress\" ]).\n+\t// This field is beta-level in 1.8\n+\t// +optional\n+\tpolicyTypes: Vec<PolicyType>\n+}\n+\n+// NetworkPolicyIngressRule describes a particular set of traffic that is allowed to the pods\n+// matched by a NetworkPolicySpec's podSelector. The traffic must match both ports and from.\n+typedef NetworkPolicyIngressRule = NetworkPolicyIngressRule {\n+\t// List of ports which should be made accessible on the pods selected for this\n+\t// rule. Each item in this list is combined using a logical OR. If this field is\n+\t// empty or missing, this rule matches all ports (traffic not restricted by port).\n+\t// If this field is present and contains at least one item, then this rule allows\n+\t// traffic only if the traffic matches at least one port in the list.\n+\t// +optional\n+\tports: Vec<NetworkPolicyPort>,\n+\n+\t// List of sources which should be able to access the pods selected for this rule.\n+\t// Items in this list are combined using a logical OR operation. If this field is\n+\t// empty or missing, this rule matches all sources (traffic not restricted by\n+\t// source). If this field is present and contains at least on item, this rule\n+\t// allows traffic only if the traffic matches at least one item in the from list.\n+\t// +optional\n+\tfrom: Vec<NetworkPolicyPeer>\n+}\n+\n+// NetworkPolicyEgressRule describes a particular set of traffic that is allowed out of pods\n+// matched by a NetworkPolicySpec's podSelector. The traffic must match both ports and to.\n+// This type is beta-level in 1.8\n+typedef NetworkPolicyEgressRule = NetworkPolicyEgressRule {\n+\t// List of destination ports for outgoing traffic.\n+\t// Each item in this list is combined using a logical OR. If this field is\n+\t// empty or missing, this rule matches all ports (traffic not restricted by port).\n+\t// If this field is present and contains at least one item, then this rule allows\n+\t// traffic only if the traffic matches at least one port in the list.\n+\t// +optional\n+\tports: Vec<NetworkPolicyPort>,\n+\t// List of destinations for outgoing traffic of pods selected for this rule.\n+\t// Items in this list are combined using a logical OR operation. If this field is\n+\t// empty or missing, this rule matches all destinations (traffic not restricted by\n+\t// destination). If this field is present and contains at least one item, this rule\n+\t// allows traffic only if the traffic matches at least one item in the to list.\n+\t// +optional\n+\tto: Vec<NetworkPolicyPeer>\n+}\n+\n+typedef Protocol = IString\n+\n+typedef IntOrString = Either<signed<32>, string>\n+\n+function intOrStringIntValue(x: IntOrString): signed<32> =\n+{\n+    match (x) {\n+        Left{i} -> i,\n+        Right{s} -> {\n+            match (parse_dec_i64(s)) {\n+                None -> 0,\n+                Some{i} -> i as signed<32>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11822990ea93d6fce22fc4ea9cbe06866e163b44"}, "originalPosition": 274}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk0NzkyOQ==", "bodyText": "why not an enum and a string conversion function?", "url": "https://github.com/vmware/differential-datalog/pull/505#discussion_r374947929", "createdAt": "2020-02-04T22:01:29Z", "author": {"login": "mbudiu-vmw"}, "path": "test/antrea/types.dl", "diffHunk": "@@ -0,0 +1,272 @@\n+/*\n+ * Types used in internal Antrea NetworkPolicy definition.\n+ */\n+\n+import intern\n+import k8spolicy as k8s\n+\n+// getNormalizedUID generates a unique UUID based on a given string.\n+// For example, it can be used to generate keys using normalized selectors\n+// unique within the Namespace by adding the constant UID.\n+function getNormalizedUID(name: string): string = {\n+    var uuid = hash128(name);\n+    // TODO: implement proper UUID formatter.\n+    \"${uuid}\"\n+}\n+\n+// normalizeExpr converts an expression to the form \"key1 OP [value1...]\".\n+function normalizeExpr(ekey: string, operator: k8s.LabelSelectorOperator, values: Vec<string>): string =\n+{\n+\tif vec_is_empty(values) {\n+\t\t\"${ekey} ${operator}\"\n+\t} else {\n+\t\t\"${ekey} ${operator} [${string_join(values, \\\",\\\")}]\"\n+\t}\n+}\n+\n+// selectorToString creates a string corresponding to a labelSelector in the form of\n+// \"key1 IN [value1,...] And key2 NotIn [value2,...] And ...\".\n+function selectorToString(selector: Ref<k8s.LabelSelector>): string =\n+{\n+    var sel = deref(selector);\n+\tvar selSlice: Set<string> = set_empty();\n+\t// Append labels in matchLabels as \"key In [value]\".\n+\tfor (kv in sel.matchLabels) {\n+\t\tset_insert(selSlice, normalizeExpr(kv.0, k8s.LabelSelectorOpIn, vec_singleton(kv.1)))\n+\t};\n+\tfor (expr in sel.matchExpressions) {\n+\t\tmatch (expr.operator) {\n+\t\t    k8s.LabelSelectorOpIn -> {\n+\t\t\t    set_insert(selSlice, normalizeExpr(expr.reqkey, k8s.LabelSelectorOpIn, expr.values))\n+            },\n+\t\t    k8s.LabelSelectorOpNotIn -> {\n+                set_insert(selSlice, normalizeExpr(expr.reqkey, k8s.LabelSelectorOpNotIn, expr.values))\n+            },\n+\t\t    k8s.LabelSelectorOpExists -> {\n+                set_insert(selSlice, normalizeExpr(expr.reqkey, k8s.LabelSelectorOpExists, vec_empty()))\n+            },\n+\t\t    k8s.LabelSelectorOpDoesNotExist -> {\n+\t\t\t    set_insert(selSlice, normalizeExpr(expr.reqkey, k8s.LabelSelectorOpDoesNotExist, vec_empty()))\n+            }\n+\t\t}\n+\t};\n+\tstring_join(set2vec(selSlice), \" And \")\n+}\n+\n+// A namespace selector is either a namespace name (or \"\")\n+// or a namespace label selector.\n+typedef NSSelector = NSSelectorNS{ns: string}\n+                   | NSSelectorLS{selector: Ref<k8s.LabelSelector>}\n+\n+// GroupSelector describes how to select pods.\n+typedef GroupSelector = GroupSelector {\n+\t// The normalized name is calculated from Namespace, PodSelector, and NamespaceSelector.\n+\t// If multiple policies have same selectors, they should share this group by comparing NormalizedName.\n+\t// It's also used to generate Name and UUID of group.\n+\tnormalizedName: string,\n+\t// Only pods from these namespaces will be matched.\n+\tnsSelector: NSSelector,\n+\t// This is a label selector which selects pods. If Namespace is also set, it selects the pods in the namespace.\n+\t// If NamespaceSelector is also set, it selects the pods in the namespaces selected by NamespaceSelector.\n+    podSelector: Option<Ref<k8s.LabelSelector>>\n+}\n+\n+// generateNormalizedName generates a string, based on the selectors, in\n+// the following format: \"namespace=NamespaceName And podSelector=normalizedPodSelector\".\n+// Note: Namespace and nsSelector may or may not be set depending on the\n+// selector. However, they cannot be set simultaneously.\n+function generateNormalizedName(nsSelector: NSSelector, podSelector: Option<Ref<k8s.LabelSelector>>): string =\n+{\n+\tvar normalizedName: Set<string> = set_empty();\n+\tmatch (nsSelector) {\n+        NSSelectorLS{ls} -> {\n+            set_insert(normalizedName, \"namespaceSelector=${selectorToString(ls)}\")\n+        },\n+        NSSelectorNS{ns} -> {\n+            if (ns != \"\") {\n+\t\t        set_insert(normalizedName, \"namespace=${ns}\")\n+            }\n+        }\n+    };\n+\tmatch (podSelector) {\n+        Some{ls} -> set_insert(normalizedName, \"podSelector=${selectorToString(ls)}\"),\n+        _ -> ()\n+\t};\n+\tstring_join(set2vec(normalizedName), \" And \")\n+}\n+\n+// toGroupSelector converts the podSelector and namespaceSelector\n+// and NetworkPolicy Namespace to a networkpolicy.GroupSelector object.\n+function toGroupSelector(namespace: string,\n+                         podSelector: Option<Ref<k8s.LabelSelector>>,\n+                         nsLabelSelector: Option<Ref<k8s.LabelSelector>>): GroupSelector =\n+{\n+    var nsSelector = match (nsLabelSelector) {\n+        // No namespaceSelector indicates that the pods must be selected within\n+        // the NetworkPolicy's Namespace.\n+        None            -> NSSelectorNS{namespace},\n+        Some{selector}  -> NSSelectorLS{selector}\n+    };\n+\tGroupSelector {\n+        .normalizedName = generateNormalizedName(nsSelector, podSelector),\n+\t\t.podSelector    = podSelector,\n+        .nsSelector     = nsSelector\n+    }\n+}\n+\n+// PodSet is a set of Pod references.\n+typedef PodSet = Set<k8s.PodReference>\n+\n+typedef Direction = DirectionIn\n+                  | DirectionOut\n+\n+// NetworkPolicyPeer describes a peer of NetworkPolicyRules.\n+// It could be a list of names of AddressGroups and/or a list of IPBlock.\n+typedef NetworkPolicyPeer = NetworkPolicyPeer {\n+\t// A list of names of AddressGroups.\n+\taddressGroups: Vec<string>,\n+\t// A list of IPBlock.\n+\tipBlocks: Vec<IPBlock>\n+}\n+\n+function networkPolicyPeerEmpty(): NetworkPolicyPeer =\n+{\n+    NetworkPolicyPeer {\n+        .addressGroups = vec_empty(),\n+        .ipBlocks = vec_empty()\n+    }\n+}\n+\n+// matchAllPeer is a NetworkPolicyPeer matching all source/destination IP addresses.\n+function matchAllPeer(): NetworkPolicyPeer =\n+{\n+    NetworkPolicyPeer {\n+        .addressGroups = vec_empty(),\n+\t    .ipBlocks      = vec_singleton(IPBlock{\n+            .cidr = IPNet {\n+                .ip             = ipv4zero(),\n+                .prefixLength   = 32'sd0\n+            },\n+            .except = vec_empty(): Vec<IPNet>\n+        })\n+    }\n+}\n+\n+typedef IPAddress = IPAddress{addr: Vec<bit<8>>}\n+\n+function ipv4zero(): IPAddress = {\n+    ipv4(0, 0, 0, 0)\n+}\n+\n+function ipv4(a: bit<8>, b: bit<8>, c: bit<8>, d: bit<8>): IPAddress =\n+{\n+    var bytes: Vec<bit<8>> = vec_with_length(12, 8'd0);\n+    vec_push(bytes, a);\n+    vec_push(bytes, b);\n+    vec_push(bytes, c);\n+    vec_push(bytes, d);\n+    IPAddress{bytes}\n+}\n+\n+// IPNet describes an IP network.\n+typedef IPNet = IPNet {\n+\tip:             IPAddress,\n+\tprefixLength:   signed<32>\n+}\n+\n+// TODO\n+function parseIP(s: string): Vec<bit<8>> = {\n+    vec_empty()\n+}\n+\n+// IPStrToIPAddress converts an IP string to networkpolicy.IPAddress.\n+// nil will returned if the IP string is not valid.\n+function ipStrToIPAddress(ip: string): IPAddress =\n+{\n+\tIPAddress{parseIP(ip)}\n+}\n+\n+// CIDRStrToIPNet converts a CIDR (eg. 10.0.0.0/16) to a *networkpolicy.IPNet.\n+function cidrStrToIPNet(cidr: string): Either<string,IPNet> =\n+{\n+\t// Split the cidr to retrieve the IP and prefix.\n+\tvar s = string_split(cidr, \"/\");\n+\tif (vec_len(s) != (2:bit<64>)) {\n+\t\tLeft{\"invalid format for IPBlock CIDR: ${cidr}\"}\n+\t} else {\n+        // Convert prefix length to int32\n+        match (parse_dec_i64(unwrap_some_or(vec_nth(s,1),\"\"))) {\n+            None -> Left{\"invalid prefix length: ${unwrap_some_or(vec_nth(s,1),\\\"\\\")}\"},\n+            Some{prefixLen64} -> {\n+                Right {\n+                    IPNet {\n+                        .ip             = ipStrToIPAddress(unwrap_some_or(vec_nth(s,0),\"\")),\n+                        .prefixLength   = prefixLen64 as signed<32>\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+// IPBlock describes a particular CIDR (Ex. \"192.168.1.1/24\"). The except entry describes CIDRs that should\n+// not be included within this rule.\n+typedef IPBlock = IPBlock {\n+\t// CIDR is an IPNet represents the IP Block.\n+\tcidr: IPNet,\n+\t// Except is a slice of IPNets that should not be included within an IP Block.\n+\t// Except values will be rejected if they are outside the CIDR range.\n+\t// +optional\n+\texcept: Vec<IPNet>\n+}\n+\n+typedef Protocol = IString", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11822990ea93d6fce22fc4ea9cbe06866e163b44"}, "originalPosition": 223}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk0ODY2Mg==", "bodyText": "again strings... I wonder whether if you could have an enum IPCblock and and then a variant named IPBlockString.", "url": "https://github.com/vmware/differential-datalog/pull/505#discussion_r374948662", "createdAt": "2020-02-04T22:03:00Z", "author": {"login": "mbudiu-vmw"}, "path": "test/antrea/k8spolicy.dl", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Inputs consumed by Antrea controller from Kuberneters: pods, namespaces,\n+ * network policies.\n+ */\n+\n+// TODO: this module should probably be broken up into several to match Go module hierachy.\n+\n+import intern\n+\n+typedef UID = UID{uid: string}\n+\n+// PodSpec is a description of a pod.\n+typedef PodSpec = PodSpec {\n+\t// NodeName is a request to schedule this pod onto a specific node. If it is non-empty,\n+\t// the scheduler simply schedules this pod onto that node, assuming that it fits resource\n+\t// requirements.\n+\tnodeName: string\n+}\n+\n+// PodStatus represents information about the status of a pod. Status may trail the actual\n+// state of a system, especially if the node that hosts the pod cannot contact the control\n+// plane.\n+typedef PodStatus = PodStatus {\n+\t// IP address allocated to the pod. Routable at least within the cluster.\n+\t// Empty if not yet allocated.\n+\tpodIP: string\n+}\n+\n+// Pod is a collection of containers that can run on a host. This resource is created\n+// by clients and scheduled onto hosts. */\n+// TODO: primary key\n+input relation Pod (\n+\t// Name must be unique within a namespace.\n+    name: Option<string>,\n+    // Namespace defines the space within each name must be unique.\n+    namespace: Option<string>,\n+    // UID is the unique in time and space value for this object.\n+    uid: UID,\n+\t// Map of string keys and values that can be used to organize and categorize\n+\t// (scope and select) objects. May match selectors of replication controllers\n+\t// and services.\n+\t// More info: http://kubernetes.io/docs/user-guide/labels\n+\t// +optional\n+\tlabels: Map<string, string>,\n+\t// Specification of the desired behavior of the pod.\n+    spec: PodSpec,\n+\t// Most recently observed status of the pod.\n+    status: PodStatus\n+)\n+\n+// Namespace provides a scope for Names.\n+// Use of multiple namespaces is optional.\n+input relation Namespace (\n+\t// Name must be unique within a namespace.\n+    name: string,\n+    // UID is the unique in time and space value for this object.\n+    uid: UID,\n+\t// Map of string keys and values that can be used to organize and categorize\n+\t// (scope and select) objects. May match selectors of replication controllers\n+\t// and services.\n+\t// More info: http://kubernetes.io/docs/user-guide/labels\n+\t// +optional\n+\tlabels: Map<string, string>\n+)\n+\n+// NetworkPolicy describes what network traffic is allowed for a set of Pods\n+input relation NetworkPolicy (\n+    // Name must be unique within a namespace.\n+    name: string,\n+    // Namespace defines the space within each name must be unique.\n+    namespace: string,\n+    // UID is the unique in time and space value for this object.\n+    uid: UID,\n+\t// Specification of the desired behavior for this NetworkPolicy.\n+    spec: NetworkPolicySpec\n+)\n+\n+// A label selector is a label query over a set of resources. The result of matchLabels and\n+// matchExpressions are ANDed. An empty label selector matches all objects. A null\n+// label selector matches no objects.\n+typedef LabelSelector = LabelSelector {\n+\t// matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels\n+\t// map is equivalent to an element of matchExpressions, whose key field is \"key\", the\n+\t// operator is \"In\", and the values array contains only \"value\". The requirements are ANDed.\n+\t// +optional\n+\tmatchLabels: Map<string,string>,\n+\t// matchExpressions is a list of label selector requirements. The requirements are ANDed.\n+\t// +optional\n+\tmatchExpressions: Vec<LabelSelectorRequirement>\n+}\n+\n+/* The native Antrea implementation converts LabelSelector to a generic selector\n+ * struct before . */\n+// Matches returns true if the Requirement matches the input Labels.\n+// There is a match in the following cases:\n+// (1) The operator is Exists and Labels has the Requirement's key.\n+// (2) The operator is In, Labels has the Requirement's key and Labels'\n+//     value for that key is in Requirement's value set.\n+// (3) The operator is NotIn, Labels has the Requirement's key and\n+//     Labels' value for that key is not in Requirement's value set.\n+// (4) The operator is DoesNotExist or NotIn and Labels does not have the\n+//     Requirement's key.\n+function labelSelectorMatches(selector: Option<Ref<LabelSelector>>, labels: Map<string, string>): bool =\n+{\n+    match (selector) {\n+        None -> false,\n+        Some{s} -> {\n+            var matches = true;\n+            var sel = deref(s);\n+            if (map_is_empty(sel.matchLabels) and vec_is_empty(sel.matchExpressions)) {\n+                true\n+            } else {\n+                for (lab in sel.matchLabels) {\n+                    matches = matches and (map_get(labels, lab.0) == Some{lab.1})\n+                    // TODO: return false\n+                };\n+                for (e in sel.matchExpressions) {\n+                    matches = matches and\n+                    (match (e.operator) {\n+                        LabelSelectorOpIn -> {\n+                            match (map_get(labels, e.reqkey)) {\n+                                None -> false,\n+                                Some{val} -> vec_contains(e.values, val)\n+                            }\n+                        },\n+\t                    LabelSelectorOpNotIn -> {\n+                            match (map_get(labels, e.reqkey)) {\n+                                None -> true,\n+                                Some{val} -> not vec_contains(e.values, val)\n+                            }\n+                        },\n+\t                    LabelSelectorOpExists -> map_contains_key(labels, e.reqkey),\n+\t                    LabelSelectorOpDoesNotExist -> not map_contains_key(labels, e.reqkey)\n+                    })\n+                };\n+                matches\n+            }\n+        }\n+    }\n+}\n+\n+// A label selector requirement is a selector that contains values, a key, and an operator that\n+// relates the key and values.\n+typedef LabelSelectorRequirement = LabelSelectorRequirement {\n+\t// key is the label key that the selector applies to.\n+\t// +patchMergeKey=key\n+\t// +patchStrategy=merge\n+\treqkey: string,\n+\t// operator represents a key's relationship to a set of values.\n+\t// Valid operators are In, NotIn, Exists and DoesNotExist.\n+\toperator: LabelSelectorOperator,\n+\t// values is an array of string values. If the operator is In or NotIn,\n+\t// the values array must be non-empty. If the operator is Exists or DoesNotExist,\n+\t// the values array must be empty. This array is replaced during a strategic\n+\t// merge patch.\n+\t// +optional\n+\tvalues: Vec<string>\n+}\n+\n+// A label selector operator is the set of operators that can be used in a selector requirement.\n+typedef LabelSelectorOperator = LabelSelectorOpIn\n+\t                          | LabelSelectorOpNotIn\n+\t                          | LabelSelectorOpExists\n+\t                          | LabelSelectorOpDoesNotExist\n+\n+function labelSelectorOperator2string(op: LabelSelectorOperator): string =\n+{\n+    match (op) {\n+        LabelSelectorOpIn           -> \"In\",\n+\t    LabelSelectorOpNotIn        -> \"NotIn\",\n+\t    LabelSelectorOpExists       -> \"Exists\",\n+\t    LabelSelectorOpDoesNotExist -> \"DoesNotExist\"\n+    }\n+}\n+\n+typedef PolicyType = PolicyTypeIngress\n+                   | PolicyTypeEgress\n+\n+// NetworkPolicySpec provides the specification of a NetworkPolicy\n+typedef NetworkPolicySpec = NetworkPolicySpec {\n+\t// Selects the pods to which this NetworkPolicy object applies. The array of\n+\t// ingress rules is applied to any pods selected by this field. Multiple network\n+\t// policies can select the same set of pods. In this case, the ingress rules for\n+\t// each are combined additively. This field is NOT optional and follows standard\n+\t// label selector semantics. An empty podSelector matches all pods in this\n+\t// namespace.\n+\tpodSelector: Ref<LabelSelector>,\n+\n+\t// List of ingress rules to be applied to the selected pods. Traffic is allowed to\n+\t// a pod if there are no NetworkPolicies selecting the pod\n+\t// (and cluster policy otherwise allows the traffic), OR if the traffic source is\n+\t// the pod's local node, OR if the traffic matches at least one ingress rule\n+\t// across all of the NetworkPolicy objects whose podSelector matches the pod. If\n+\t// this field is empty then this NetworkPolicy does not allow any traffic (and serves\n+\t// solely to ensure that the pods it selects are isolated by default)\n+\t// +optional\n+\tingress: Vec<NetworkPolicyIngressRule>,\n+\n+\t// List of egress rules to be applied to the selected pods. Outgoing traffic is\n+\t// allowed if there are no NetworkPolicies selecting the pod (and cluster policy\n+\t// otherwise allows the traffic), OR if the traffic matches at least one egress rule\n+\t// across all of the NetworkPolicy objects whose podSelector matches the pod. If\n+\t// this field is empty then this NetworkPolicy limits all outgoing traffic (and serves\n+\t// solely to ensure that the pods it selects are isolated by default).\n+\t// This field is beta-level in 1.8\n+\t// +optional\n+\tegress: Vec<NetworkPolicyEgressRule>,\n+\n+\t// List of rule types that the NetworkPolicy relates to.\n+\t// Valid options are \"Ingress\", \"Egress\", or \"Ingress,Egress\".\n+\t// If this field is not specified, it will default based on the existence of Ingress or Egress rules;\n+\t// policies that contain an Egress section are assumed to affect Egress, and all policies\n+\t// (whether or not they contain an Ingress section) are assumed to affect Ingress.\n+\t// If you want to write an egress-only policy, you must explicitly specify policyTypes [ \"Egress\" ].\n+\t// Likewise, if you want to write a policy that specifies that no egress is allowed,\n+\t// you must specify a policyTypes value that include \"Egress\" (since such a policy would not include\n+\t// an Egress section and would otherwise default to just [ \"Ingress\" ]).\n+\t// This field is beta-level in 1.8\n+\t// +optional\n+\tpolicyTypes: Vec<PolicyType>\n+}\n+\n+// NetworkPolicyIngressRule describes a particular set of traffic that is allowed to the pods\n+// matched by a NetworkPolicySpec's podSelector. The traffic must match both ports and from.\n+typedef NetworkPolicyIngressRule = NetworkPolicyIngressRule {\n+\t// List of ports which should be made accessible on the pods selected for this\n+\t// rule. Each item in this list is combined using a logical OR. If this field is\n+\t// empty or missing, this rule matches all ports (traffic not restricted by port).\n+\t// If this field is present and contains at least one item, then this rule allows\n+\t// traffic only if the traffic matches at least one port in the list.\n+\t// +optional\n+\tports: Vec<NetworkPolicyPort>,\n+\n+\t// List of sources which should be able to access the pods selected for this rule.\n+\t// Items in this list are combined using a logical OR operation. If this field is\n+\t// empty or missing, this rule matches all sources (traffic not restricted by\n+\t// source). If this field is present and contains at least on item, this rule\n+\t// allows traffic only if the traffic matches at least one item in the from list.\n+\t// +optional\n+\tfrom: Vec<NetworkPolicyPeer>\n+}\n+\n+// NetworkPolicyEgressRule describes a particular set of traffic that is allowed out of pods\n+// matched by a NetworkPolicySpec's podSelector. The traffic must match both ports and to.\n+// This type is beta-level in 1.8\n+typedef NetworkPolicyEgressRule = NetworkPolicyEgressRule {\n+\t// List of destination ports for outgoing traffic.\n+\t// Each item in this list is combined using a logical OR. If this field is\n+\t// empty or missing, this rule matches all ports (traffic not restricted by port).\n+\t// If this field is present and contains at least one item, then this rule allows\n+\t// traffic only if the traffic matches at least one port in the list.\n+\t// +optional\n+\tports: Vec<NetworkPolicyPort>,\n+\t// List of destinations for outgoing traffic of pods selected for this rule.\n+\t// Items in this list are combined using a logical OR operation. If this field is\n+\t// empty or missing, this rule matches all destinations (traffic not restricted by\n+\t// destination). If this field is present and contains at least one item, this rule\n+\t// allows traffic only if the traffic matches at least one item in the to list.\n+\t// +optional\n+\tto: Vec<NetworkPolicyPeer>\n+}\n+\n+typedef Protocol = IString\n+\n+typedef IntOrString = Either<signed<32>, string>\n+\n+function intOrStringIntValue(x: IntOrString): signed<32> =\n+{\n+    match (x) {\n+        Left{i} -> i,\n+        Right{s} -> {\n+            match (parse_dec_i64(s)) {\n+                None -> 0,\n+                Some{i} -> i as signed<32>\n+            }\n+        }\n+\t}\n+}\n+\n+// NetworkPolicyPort describes a port to allow traffic on\n+typedef NetworkPolicyPort = NetworkPolicyPort {\n+\t// The protocol (TCP, UDP, or SCTP) which traffic must match. If not specified, this\n+\t// field defaults to TCP.\n+\t// +optional\n+\tprotocol: Option<Protocol>,\n+\n+\t// The port on the given protocol. This can either be a numerical or named port on\n+\t// a pod. If this field is not provided, this matches all port names and numbers.\n+\t// +optional\n+\tport: Option<IntOrString>\n+}\n+\n+// IPBlock describes a particular CIDR (Ex. \"192.168.1.1/24\") that is allowed to the pods\n+// matched by a NetworkPolicySpec's podSelector. The except entry describes CIDRs that should\n+// not be included within this rule.\n+typedef IPBlock = IPBlock {\n+\t// CIDR is a string representing the IP Block\n+\t// Valid examples are \"192.168.1.1/24\"\n+\tcidr: string,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11822990ea93d6fce22fc4ea9cbe06866e163b44"}, "originalPosition": 299}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk1MDE2NA==", "bodyText": "maybe you could put here the definitions of the output relations too?", "url": "https://github.com/vmware/differential-datalog/pull/505#discussion_r374950164", "createdAt": "2020-02-04T22:06:25Z", "author": {"login": "mbudiu-vmw"}, "path": "test/antrea/networkpolicy_controller.dl", "diffHunk": "@@ -0,0 +1,364 @@\n+/*\n+ * DDlog implementation of Antrea controller logic (see networkpolicy_controller.go).\n+ */\n+\n+import intern\n+import k8spolicy as k8s\n+import types\n+\n+// TODO\n+function log_error(e: string): () = ()\n+\n+/* In DDlog, we split the AppliedToGroup struct into three relations:\n+ * AppliedToGroup: stores group name, id, and GroupSelector\n+ * AppliedToGroupPodsByNode: stores the node-to-pods mapping.\n+ * AppliedToGroupSpan: group span (nodes where the group must be sent).\n+ */\n+\n+output relation AppliedToGroup (\n+\t// UID is generated from the hash value of GroupSelector.NormalizedName.\n+\tuid: k8s.UID,\n+\t// Name of this group, currently it's same as UID.\n+\tname: string,\n+\t// Selector describes how the group selects pods.\n+\tselector: GroupSelector\n+)\n+\n+// PodsByNode is a mapping from nodeName to a set of Pods on the Node.\n+output relation AppliedToGroupPodsByNode(appliedToGroup: k8s.UID, podsByNode: Map<string, Set<k8s.UID>>)\n+\n+// AppliedToGroupSpan: set of node names that this AddressGroup should be sent to.\n+output relation AppliedToGroupSpan(appliedToGroup: k8s.UID, span: Set<k8s.UID>)\n+\n+/* In DDlog, we split the AddressGroup struct into three relations:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11822990ea93d6fce22fc4ea9cbe06866e163b44"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk1MDUxOA==", "bodyText": "Easier to remember if the definition follows the declaration.", "url": "https://github.com/vmware/differential-datalog/pull/505#discussion_r374950518", "createdAt": "2020-02-04T22:07:15Z", "author": {"login": "mbudiu-vmw"}, "path": "test/antrea/networkpolicy_controller.dl", "diffHunk": "@@ -0,0 +1,364 @@\n+/*\n+ * DDlog implementation of Antrea controller logic (see networkpolicy_controller.go).\n+ */\n+\n+import intern\n+import k8spolicy as k8s\n+import types\n+\n+// TODO\n+function log_error(e: string): () = ()\n+\n+/* In DDlog, we split the AppliedToGroup struct into three relations:\n+ * AppliedToGroup: stores group name, id, and GroupSelector\n+ * AppliedToGroupPodsByNode: stores the node-to-pods mapping.\n+ * AppliedToGroupSpan: group span (nodes where the group must be sent).\n+ */\n+\n+output relation AppliedToGroup (\n+\t// UID is generated from the hash value of GroupSelector.NormalizedName.\n+\tuid: k8s.UID,\n+\t// Name of this group, currently it's same as UID.\n+\tname: string,\n+\t// Selector describes how the group selects pods.\n+\tselector: GroupSelector\n+)\n+\n+// PodsByNode is a mapping from nodeName to a set of Pods on the Node.\n+output relation AppliedToGroupPodsByNode(appliedToGroup: k8s.UID, podsByNode: Map<string, Set<k8s.UID>>)\n+\n+// AppliedToGroupSpan: set of node names that this AddressGroup should be sent to.\n+output relation AppliedToGroupSpan(appliedToGroup: k8s.UID, span: Set<k8s.UID>)\n+\n+/* In DDlog, we split the AddressGroup struct into three relations:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk1MDE2NA=="}, "originalCommit": {"oid": "11822990ea93d6fce22fc4ea9cbe06866e163b44"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk1MTY5Mw==", "bodyText": "indentation", "url": "https://github.com/vmware/differential-datalog/pull/505#discussion_r374951693", "createdAt": "2020-02-04T22:10:15Z", "author": {"login": "mbudiu-vmw"}, "path": "test/antrea/networkpolicy_controller.dl", "diffHunk": "@@ -0,0 +1,364 @@\n+/*\n+ * DDlog implementation of Antrea controller logic (see networkpolicy_controller.go).\n+ */\n+\n+import intern\n+import k8spolicy as k8s\n+import types\n+\n+// TODO\n+function log_error(e: string): () = ()\n+\n+/* In DDlog, we split the AppliedToGroup struct into three relations:\n+ * AppliedToGroup: stores group name, id, and GroupSelector\n+ * AppliedToGroupPodsByNode: stores the node-to-pods mapping.\n+ * AppliedToGroupSpan: group span (nodes where the group must be sent).\n+ */\n+\n+output relation AppliedToGroup (\n+\t// UID is generated from the hash value of GroupSelector.NormalizedName.\n+\tuid: k8s.UID,\n+\t// Name of this group, currently it's same as UID.\n+\tname: string,\n+\t// Selector describes how the group selects pods.\n+\tselector: GroupSelector\n+)\n+\n+// PodsByNode is a mapping from nodeName to a set of Pods on the Node.\n+output relation AppliedToGroupPodsByNode(appliedToGroup: k8s.UID, podsByNode: Map<string, Set<k8s.UID>>)\n+\n+// AppliedToGroupSpan: set of node names that this AddressGroup should be sent to.\n+output relation AppliedToGroupSpan(appliedToGroup: k8s.UID, span: Set<k8s.UID>)\n+\n+/* In DDlog, we split the AddressGroup struct into three relations:\n+ * AddressGroup: stores group name, id, and GroupSelector\n+ * AddressGroupAddress: stores addresses of nodes that match the group selector.\n+ * AddressGroupSpan: group span (nodes where the group must be sent).\n+ */\n+\n+// AddressGroup describes a set of addresses used as source or destination of Network Policy rules.\n+output relation AddressGroup (\n+\t// UID is generated from the hash value of GroupSelector.NormalizedName.\n+\tuid: k8s.UID,\n+\t// Name of this group, currently it's same as UID.\n+\tname: string,\n+\t// Selector describes how the group selects pods to get their addresses.\n+\tselector: GroupSelector\n+)\n+\n+// Addresses is a set of IP addresses selected by this group.\n+output relation AddressGroupAddress(addresGroup: k8s.UID, address: string)\n+\n+// AddressGroupSpan: set of node names that this AddressGroup should be sent to.\n+output relation AddressGroupSpan(addressGroup: k8s.UID, span: Set<k8s.UID>)\n+\n+// NetworkPolicy describes what network traffic is allowed for a set of Pods.\n+output relation NetworkPolicy (\n+\t// UID of the original K8s Network Policy.\n+\tuid: k8s.UID,\n+\t// Name of the original K8s Network Policy.\n+\tname: string,\n+\t// Namespace of the original K8s Network Policy.\n+\tnamespace: string,\n+\t// Rules is a list of rules to be applied to the selected Pods.\n+\trules: Vec<NetworkPolicyRule>,\n+\t// AppliedToGroups is a list of names of AppliedToGroups to which this policy applies.\n+\tappliedToGroups: Vec<string>\n+)\n+\n+// NetworkPolicySpan: set of node names that this NetworkPolicy should be sent to.\n+output relation NetworkPolicySpan(policy: k8s.UID, span: Set<k8s.UID>)\n+\n+// createAppliedToGroup creates an AppliedToGroup object.\n+function createAppliedToGroup(np: k8s.NetworkPolicy): AppliedToGroup =\n+{\n+\tvar groupSelector = toGroupSelector(np.namespace, Some{np.spec.podSelector}, None);\n+\tvar appliedToGroupUID = getNormalizedUID(groupSelector.normalizedName);\n+\t// Construct a new AppliedToGroup.\n+\tAppliedToGroup {\n+\t\t.name       = appliedToGroupUID,\n+\t\t.uid        = k8s.UID{appliedToGroupUID},\n+\t\t.selector   = groupSelector\n+\t}\n+}\n+\n+function toAntreaPeer(peers: Vec<k8s.NetworkPolicyPeer>, np: k8s.NetworkPolicy): (NetworkPolicyPeer, Vec<AddressGroup>) =\n+{\n+\t// Empty NetworkPolicyPeer is supposed to match all addresses.\n+\t// See https://kubernetes.io/docs/concepts/services-networking/network-policies/#default-allow-all-ingress-traffic.\n+\t// It's treated as an IPBlock \"0.0.0.0/0\".\n+\tif (vec_is_empty(peers)) {\n+\t\t(matchAllPeer(), vec_empty())\n+\t} else {\n+        var ipBlocks: Vec<IPBlock> = vec_empty();\n+        var addressGroupNames: Vec<string> = vec_empty();\n+        var addressGroups: Vec<AddressGroup> = vec_empty();\n+\n+        for (peer in peers) {\n+            // A networking.NetworkPolicyPeer will either have an IPBlock or a\n+            // podSelector and/or namespaceSelector set.\n+            match (peer.ipBlock) {\n+                Some{peerIPBlock} -> {\n+                    match (toAntreaIPBlock(peerIPBlock)) {\n+                        Left{err} -> {\n+                            log_error(\"Failure processing NetworkPolicy ${np.namespace}/${np.name} IPBlock ${peerIPBlock}: ${err}\")\n+                        },\n+                        Right{ipBlock} -> {\n+                            vec_push(ipBlocks, ipBlock)\n+                        }\n+                    }\n+                },\n+                None -> {\n+                    var addressGroup = createAddressGroup(peer, np);\n+                    vec_push(addressGroups, addressGroup);\n+                    vec_push(addressGroupNames, addressGroup.name)\n+                }\n+            }\n+        };\n+        var nppeer = NetworkPolicyPeer {\n+            .addressGroups  = addressGroupNames,\n+            .ipBlocks       = ipBlocks\n+        };\n+        (nppeer, addressGroups)\n+    }\n+}\n+\n+// toAntreaProtocol converts a v1.Protocol object to an Antrea Protocol object.\n+function toAntreaProtocol(npProtocol: Option<k8s.Protocol>): Protocol =\n+{\n+\t// If Protocol is unset, it must default to TCP protocol.\n+    match (npProtocol) {\n+        None -> protocolTCP(),\n+        Some{proto} -> proto\n+    }\n+}\n+\n+// toAntreaServices converts a networkingv1.NetworkPolicyPort object to an\n+// Antrea Service object.\n+function toAntreaServices(npPorts: Vec<k8s.NetworkPolicyPort>): Vec<Service> =\n+{\n+\tvar antreaServices: Vec<Service> = vec_empty();\n+\tfor (npPort in npPorts) {\n+\t\tvar antreaService = Service {\n+\t\t\t.protocol   = toAntreaProtocol(npPort.protocol),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11822990ea93d6fce22fc4ea9cbe06866e163b44"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk1MTc2OQ==", "bodyText": "indentation", "url": "https://github.com/vmware/differential-datalog/pull/505#discussion_r374951769", "createdAt": "2020-02-04T22:10:25Z", "author": {"login": "mbudiu-vmw"}, "path": "test/antrea/networkpolicy_controller.dl", "diffHunk": "@@ -0,0 +1,364 @@\n+/*\n+ * DDlog implementation of Antrea controller logic (see networkpolicy_controller.go).\n+ */\n+\n+import intern\n+import k8spolicy as k8s\n+import types\n+\n+// TODO\n+function log_error(e: string): () = ()\n+\n+/* In DDlog, we split the AppliedToGroup struct into three relations:\n+ * AppliedToGroup: stores group name, id, and GroupSelector\n+ * AppliedToGroupPodsByNode: stores the node-to-pods mapping.\n+ * AppliedToGroupSpan: group span (nodes where the group must be sent).\n+ */\n+\n+output relation AppliedToGroup (\n+\t// UID is generated from the hash value of GroupSelector.NormalizedName.\n+\tuid: k8s.UID,\n+\t// Name of this group, currently it's same as UID.\n+\tname: string,\n+\t// Selector describes how the group selects pods.\n+\tselector: GroupSelector\n+)\n+\n+// PodsByNode is a mapping from nodeName to a set of Pods on the Node.\n+output relation AppliedToGroupPodsByNode(appliedToGroup: k8s.UID, podsByNode: Map<string, Set<k8s.UID>>)\n+\n+// AppliedToGroupSpan: set of node names that this AddressGroup should be sent to.\n+output relation AppliedToGroupSpan(appliedToGroup: k8s.UID, span: Set<k8s.UID>)\n+\n+/* In DDlog, we split the AddressGroup struct into three relations:\n+ * AddressGroup: stores group name, id, and GroupSelector\n+ * AddressGroupAddress: stores addresses of nodes that match the group selector.\n+ * AddressGroupSpan: group span (nodes where the group must be sent).\n+ */\n+\n+// AddressGroup describes a set of addresses used as source or destination of Network Policy rules.\n+output relation AddressGroup (\n+\t// UID is generated from the hash value of GroupSelector.NormalizedName.\n+\tuid: k8s.UID,\n+\t// Name of this group, currently it's same as UID.\n+\tname: string,\n+\t// Selector describes how the group selects pods to get their addresses.\n+\tselector: GroupSelector\n+)\n+\n+// Addresses is a set of IP addresses selected by this group.\n+output relation AddressGroupAddress(addresGroup: k8s.UID, address: string)\n+\n+// AddressGroupSpan: set of node names that this AddressGroup should be sent to.\n+output relation AddressGroupSpan(addressGroup: k8s.UID, span: Set<k8s.UID>)\n+\n+// NetworkPolicy describes what network traffic is allowed for a set of Pods.\n+output relation NetworkPolicy (\n+\t// UID of the original K8s Network Policy.\n+\tuid: k8s.UID,\n+\t// Name of the original K8s Network Policy.\n+\tname: string,\n+\t// Namespace of the original K8s Network Policy.\n+\tnamespace: string,\n+\t// Rules is a list of rules to be applied to the selected Pods.\n+\trules: Vec<NetworkPolicyRule>,\n+\t// AppliedToGroups is a list of names of AppliedToGroups to which this policy applies.\n+\tappliedToGroups: Vec<string>\n+)\n+\n+// NetworkPolicySpan: set of node names that this NetworkPolicy should be sent to.\n+output relation NetworkPolicySpan(policy: k8s.UID, span: Set<k8s.UID>)\n+\n+// createAppliedToGroup creates an AppliedToGroup object.\n+function createAppliedToGroup(np: k8s.NetworkPolicy): AppliedToGroup =\n+{\n+\tvar groupSelector = toGroupSelector(np.namespace, Some{np.spec.podSelector}, None);\n+\tvar appliedToGroupUID = getNormalizedUID(groupSelector.normalizedName);\n+\t// Construct a new AppliedToGroup.\n+\tAppliedToGroup {\n+\t\t.name       = appliedToGroupUID,\n+\t\t.uid        = k8s.UID{appliedToGroupUID},\n+\t\t.selector   = groupSelector\n+\t}\n+}\n+\n+function toAntreaPeer(peers: Vec<k8s.NetworkPolicyPeer>, np: k8s.NetworkPolicy): (NetworkPolicyPeer, Vec<AddressGroup>) =\n+{\n+\t// Empty NetworkPolicyPeer is supposed to match all addresses.\n+\t// See https://kubernetes.io/docs/concepts/services-networking/network-policies/#default-allow-all-ingress-traffic.\n+\t// It's treated as an IPBlock \"0.0.0.0/0\".\n+\tif (vec_is_empty(peers)) {\n+\t\t(matchAllPeer(), vec_empty())\n+\t} else {\n+        var ipBlocks: Vec<IPBlock> = vec_empty();\n+        var addressGroupNames: Vec<string> = vec_empty();\n+        var addressGroups: Vec<AddressGroup> = vec_empty();\n+\n+        for (peer in peers) {\n+            // A networking.NetworkPolicyPeer will either have an IPBlock or a\n+            // podSelector and/or namespaceSelector set.\n+            match (peer.ipBlock) {\n+                Some{peerIPBlock} -> {\n+                    match (toAntreaIPBlock(peerIPBlock)) {\n+                        Left{err} -> {\n+                            log_error(\"Failure processing NetworkPolicy ${np.namespace}/${np.name} IPBlock ${peerIPBlock}: ${err}\")\n+                        },\n+                        Right{ipBlock} -> {\n+                            vec_push(ipBlocks, ipBlock)\n+                        }\n+                    }\n+                },\n+                None -> {\n+                    var addressGroup = createAddressGroup(peer, np);\n+                    vec_push(addressGroups, addressGroup);\n+                    vec_push(addressGroupNames, addressGroup.name)\n+                }\n+            }\n+        };\n+        var nppeer = NetworkPolicyPeer {\n+            .addressGroups  = addressGroupNames,\n+            .ipBlocks       = ipBlocks\n+        };\n+        (nppeer, addressGroups)\n+    }\n+}\n+\n+// toAntreaProtocol converts a v1.Protocol object to an Antrea Protocol object.\n+function toAntreaProtocol(npProtocol: Option<k8s.Protocol>): Protocol =\n+{\n+\t// If Protocol is unset, it must default to TCP protocol.\n+    match (npProtocol) {\n+        None -> protocolTCP(),\n+        Some{proto} -> proto\n+    }\n+}\n+\n+// toAntreaServices converts a networkingv1.NetworkPolicyPort object to an\n+// Antrea Service object.\n+function toAntreaServices(npPorts: Vec<k8s.NetworkPolicyPort>): Vec<Service> =\n+{\n+\tvar antreaServices: Vec<Service> = vec_empty();\n+\tfor (npPort in npPorts) {\n+\t\tvar antreaService = Service {\n+\t\t\t.protocol   = toAntreaProtocol(npPort.protocol),\n+\t\t    .port       = match (npPort.port) {\n+                None    -> None: Option<signed<32>>,\n+                // TODO(abhiraut): Retrieve ports for named ports.\n+                Some{p} -> Some{ k8s.intOrStringIntValue(p) }\n+            }\n+\t\t};", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11822990ea93d6fce22fc4ea9cbe06866e163b44"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk1MTk4Nw==", "bodyText": "How about a type for error too?", "url": "https://github.com/vmware/differential-datalog/pull/505#discussion_r374951987", "createdAt": "2020-02-04T22:10:53Z", "author": {"login": "mbudiu-vmw"}, "path": "test/antrea/networkpolicy_controller.dl", "diffHunk": "@@ -0,0 +1,364 @@\n+/*\n+ * DDlog implementation of Antrea controller logic (see networkpolicy_controller.go).\n+ */\n+\n+import intern\n+import k8spolicy as k8s\n+import types\n+\n+// TODO\n+function log_error(e: string): () = ()\n+\n+/* In DDlog, we split the AppliedToGroup struct into three relations:\n+ * AppliedToGroup: stores group name, id, and GroupSelector\n+ * AppliedToGroupPodsByNode: stores the node-to-pods mapping.\n+ * AppliedToGroupSpan: group span (nodes where the group must be sent).\n+ */\n+\n+output relation AppliedToGroup (\n+\t// UID is generated from the hash value of GroupSelector.NormalizedName.\n+\tuid: k8s.UID,\n+\t// Name of this group, currently it's same as UID.\n+\tname: string,\n+\t// Selector describes how the group selects pods.\n+\tselector: GroupSelector\n+)\n+\n+// PodsByNode is a mapping from nodeName to a set of Pods on the Node.\n+output relation AppliedToGroupPodsByNode(appliedToGroup: k8s.UID, podsByNode: Map<string, Set<k8s.UID>>)\n+\n+// AppliedToGroupSpan: set of node names that this AddressGroup should be sent to.\n+output relation AppliedToGroupSpan(appliedToGroup: k8s.UID, span: Set<k8s.UID>)\n+\n+/* In DDlog, we split the AddressGroup struct into three relations:\n+ * AddressGroup: stores group name, id, and GroupSelector\n+ * AddressGroupAddress: stores addresses of nodes that match the group selector.\n+ * AddressGroupSpan: group span (nodes where the group must be sent).\n+ */\n+\n+// AddressGroup describes a set of addresses used as source or destination of Network Policy rules.\n+output relation AddressGroup (\n+\t// UID is generated from the hash value of GroupSelector.NormalizedName.\n+\tuid: k8s.UID,\n+\t// Name of this group, currently it's same as UID.\n+\tname: string,\n+\t// Selector describes how the group selects pods to get their addresses.\n+\tselector: GroupSelector\n+)\n+\n+// Addresses is a set of IP addresses selected by this group.\n+output relation AddressGroupAddress(addresGroup: k8s.UID, address: string)\n+\n+// AddressGroupSpan: set of node names that this AddressGroup should be sent to.\n+output relation AddressGroupSpan(addressGroup: k8s.UID, span: Set<k8s.UID>)\n+\n+// NetworkPolicy describes what network traffic is allowed for a set of Pods.\n+output relation NetworkPolicy (\n+\t// UID of the original K8s Network Policy.\n+\tuid: k8s.UID,\n+\t// Name of the original K8s Network Policy.\n+\tname: string,\n+\t// Namespace of the original K8s Network Policy.\n+\tnamespace: string,\n+\t// Rules is a list of rules to be applied to the selected Pods.\n+\trules: Vec<NetworkPolicyRule>,\n+\t// AppliedToGroups is a list of names of AppliedToGroups to which this policy applies.\n+\tappliedToGroups: Vec<string>\n+)\n+\n+// NetworkPolicySpan: set of node names that this NetworkPolicy should be sent to.\n+output relation NetworkPolicySpan(policy: k8s.UID, span: Set<k8s.UID>)\n+\n+// createAppliedToGroup creates an AppliedToGroup object.\n+function createAppliedToGroup(np: k8s.NetworkPolicy): AppliedToGroup =\n+{\n+\tvar groupSelector = toGroupSelector(np.namespace, Some{np.spec.podSelector}, None);\n+\tvar appliedToGroupUID = getNormalizedUID(groupSelector.normalizedName);\n+\t// Construct a new AppliedToGroup.\n+\tAppliedToGroup {\n+\t\t.name       = appliedToGroupUID,\n+\t\t.uid        = k8s.UID{appliedToGroupUID},\n+\t\t.selector   = groupSelector\n+\t}\n+}\n+\n+function toAntreaPeer(peers: Vec<k8s.NetworkPolicyPeer>, np: k8s.NetworkPolicy): (NetworkPolicyPeer, Vec<AddressGroup>) =\n+{\n+\t// Empty NetworkPolicyPeer is supposed to match all addresses.\n+\t// See https://kubernetes.io/docs/concepts/services-networking/network-policies/#default-allow-all-ingress-traffic.\n+\t// It's treated as an IPBlock \"0.0.0.0/0\".\n+\tif (vec_is_empty(peers)) {\n+\t\t(matchAllPeer(), vec_empty())\n+\t} else {\n+        var ipBlocks: Vec<IPBlock> = vec_empty();\n+        var addressGroupNames: Vec<string> = vec_empty();\n+        var addressGroups: Vec<AddressGroup> = vec_empty();\n+\n+        for (peer in peers) {\n+            // A networking.NetworkPolicyPeer will either have an IPBlock or a\n+            // podSelector and/or namespaceSelector set.\n+            match (peer.ipBlock) {\n+                Some{peerIPBlock} -> {\n+                    match (toAntreaIPBlock(peerIPBlock)) {\n+                        Left{err} -> {\n+                            log_error(\"Failure processing NetworkPolicy ${np.namespace}/${np.name} IPBlock ${peerIPBlock}: ${err}\")\n+                        },\n+                        Right{ipBlock} -> {\n+                            vec_push(ipBlocks, ipBlock)\n+                        }\n+                    }\n+                },\n+                None -> {\n+                    var addressGroup = createAddressGroup(peer, np);\n+                    vec_push(addressGroups, addressGroup);\n+                    vec_push(addressGroupNames, addressGroup.name)\n+                }\n+            }\n+        };\n+        var nppeer = NetworkPolicyPeer {\n+            .addressGroups  = addressGroupNames,\n+            .ipBlocks       = ipBlocks\n+        };\n+        (nppeer, addressGroups)\n+    }\n+}\n+\n+// toAntreaProtocol converts a v1.Protocol object to an Antrea Protocol object.\n+function toAntreaProtocol(npProtocol: Option<k8s.Protocol>): Protocol =\n+{\n+\t// If Protocol is unset, it must default to TCP protocol.\n+    match (npProtocol) {\n+        None -> protocolTCP(),\n+        Some{proto} -> proto\n+    }\n+}\n+\n+// toAntreaServices converts a networkingv1.NetworkPolicyPort object to an\n+// Antrea Service object.\n+function toAntreaServices(npPorts: Vec<k8s.NetworkPolicyPort>): Vec<Service> =\n+{\n+\tvar antreaServices: Vec<Service> = vec_empty();\n+\tfor (npPort in npPorts) {\n+\t\tvar antreaService = Service {\n+\t\t\t.protocol   = toAntreaProtocol(npPort.protocol),\n+\t\t    .port       = match (npPort.port) {\n+                None    -> None: Option<signed<32>>,\n+                // TODO(abhiraut): Retrieve ports for named ports.\n+                Some{p} -> Some{ k8s.intOrStringIntValue(p) }\n+            }\n+\t\t};\n+\t\tvec_push(antreaServices, antreaService)\n+\t};\n+\tantreaServices\n+}\n+\n+// toAntreaIPBlock converts a networkingv1.IPBlock to an Antrea IPBlock.\n+function toAntreaIPBlock(ipBlock: k8s.IPBlock): Either<string,IPBlock> =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11822990ea93d6fce22fc4ea9cbe06866e163b44"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk1MjM0MA==", "bodyText": "In fact I would create a type like the Rust Result.", "url": "https://github.com/vmware/differential-datalog/pull/505#discussion_r374952340", "createdAt": "2020-02-04T22:11:48Z", "author": {"login": "mbudiu-vmw"}, "path": "test/antrea/networkpolicy_controller.dl", "diffHunk": "@@ -0,0 +1,364 @@\n+/*\n+ * DDlog implementation of Antrea controller logic (see networkpolicy_controller.go).\n+ */\n+\n+import intern\n+import k8spolicy as k8s\n+import types\n+\n+// TODO\n+function log_error(e: string): () = ()\n+\n+/* In DDlog, we split the AppliedToGroup struct into three relations:\n+ * AppliedToGroup: stores group name, id, and GroupSelector\n+ * AppliedToGroupPodsByNode: stores the node-to-pods mapping.\n+ * AppliedToGroupSpan: group span (nodes where the group must be sent).\n+ */\n+\n+output relation AppliedToGroup (\n+\t// UID is generated from the hash value of GroupSelector.NormalizedName.\n+\tuid: k8s.UID,\n+\t// Name of this group, currently it's same as UID.\n+\tname: string,\n+\t// Selector describes how the group selects pods.\n+\tselector: GroupSelector\n+)\n+\n+// PodsByNode is a mapping from nodeName to a set of Pods on the Node.\n+output relation AppliedToGroupPodsByNode(appliedToGroup: k8s.UID, podsByNode: Map<string, Set<k8s.UID>>)\n+\n+// AppliedToGroupSpan: set of node names that this AddressGroup should be sent to.\n+output relation AppliedToGroupSpan(appliedToGroup: k8s.UID, span: Set<k8s.UID>)\n+\n+/* In DDlog, we split the AddressGroup struct into three relations:\n+ * AddressGroup: stores group name, id, and GroupSelector\n+ * AddressGroupAddress: stores addresses of nodes that match the group selector.\n+ * AddressGroupSpan: group span (nodes where the group must be sent).\n+ */\n+\n+// AddressGroup describes a set of addresses used as source or destination of Network Policy rules.\n+output relation AddressGroup (\n+\t// UID is generated from the hash value of GroupSelector.NormalizedName.\n+\tuid: k8s.UID,\n+\t// Name of this group, currently it's same as UID.\n+\tname: string,\n+\t// Selector describes how the group selects pods to get their addresses.\n+\tselector: GroupSelector\n+)\n+\n+// Addresses is a set of IP addresses selected by this group.\n+output relation AddressGroupAddress(addresGroup: k8s.UID, address: string)\n+\n+// AddressGroupSpan: set of node names that this AddressGroup should be sent to.\n+output relation AddressGroupSpan(addressGroup: k8s.UID, span: Set<k8s.UID>)\n+\n+// NetworkPolicy describes what network traffic is allowed for a set of Pods.\n+output relation NetworkPolicy (\n+\t// UID of the original K8s Network Policy.\n+\tuid: k8s.UID,\n+\t// Name of the original K8s Network Policy.\n+\tname: string,\n+\t// Namespace of the original K8s Network Policy.\n+\tnamespace: string,\n+\t// Rules is a list of rules to be applied to the selected Pods.\n+\trules: Vec<NetworkPolicyRule>,\n+\t// AppliedToGroups is a list of names of AppliedToGroups to which this policy applies.\n+\tappliedToGroups: Vec<string>\n+)\n+\n+// NetworkPolicySpan: set of node names that this NetworkPolicy should be sent to.\n+output relation NetworkPolicySpan(policy: k8s.UID, span: Set<k8s.UID>)\n+\n+// createAppliedToGroup creates an AppliedToGroup object.\n+function createAppliedToGroup(np: k8s.NetworkPolicy): AppliedToGroup =\n+{\n+\tvar groupSelector = toGroupSelector(np.namespace, Some{np.spec.podSelector}, None);\n+\tvar appliedToGroupUID = getNormalizedUID(groupSelector.normalizedName);\n+\t// Construct a new AppliedToGroup.\n+\tAppliedToGroup {\n+\t\t.name       = appliedToGroupUID,\n+\t\t.uid        = k8s.UID{appliedToGroupUID},\n+\t\t.selector   = groupSelector\n+\t}\n+}\n+\n+function toAntreaPeer(peers: Vec<k8s.NetworkPolicyPeer>, np: k8s.NetworkPolicy): (NetworkPolicyPeer, Vec<AddressGroup>) =\n+{\n+\t// Empty NetworkPolicyPeer is supposed to match all addresses.\n+\t// See https://kubernetes.io/docs/concepts/services-networking/network-policies/#default-allow-all-ingress-traffic.\n+\t// It's treated as an IPBlock \"0.0.0.0/0\".\n+\tif (vec_is_empty(peers)) {\n+\t\t(matchAllPeer(), vec_empty())\n+\t} else {\n+        var ipBlocks: Vec<IPBlock> = vec_empty();\n+        var addressGroupNames: Vec<string> = vec_empty();\n+        var addressGroups: Vec<AddressGroup> = vec_empty();\n+\n+        for (peer in peers) {\n+            // A networking.NetworkPolicyPeer will either have an IPBlock or a\n+            // podSelector and/or namespaceSelector set.\n+            match (peer.ipBlock) {\n+                Some{peerIPBlock} -> {\n+                    match (toAntreaIPBlock(peerIPBlock)) {\n+                        Left{err} -> {\n+                            log_error(\"Failure processing NetworkPolicy ${np.namespace}/${np.name} IPBlock ${peerIPBlock}: ${err}\")\n+                        },\n+                        Right{ipBlock} -> {\n+                            vec_push(ipBlocks, ipBlock)\n+                        }\n+                    }\n+                },\n+                None -> {\n+                    var addressGroup = createAddressGroup(peer, np);\n+                    vec_push(addressGroups, addressGroup);\n+                    vec_push(addressGroupNames, addressGroup.name)\n+                }\n+            }\n+        };\n+        var nppeer = NetworkPolicyPeer {\n+            .addressGroups  = addressGroupNames,\n+            .ipBlocks       = ipBlocks\n+        };\n+        (nppeer, addressGroups)\n+    }\n+}\n+\n+// toAntreaProtocol converts a v1.Protocol object to an Antrea Protocol object.\n+function toAntreaProtocol(npProtocol: Option<k8s.Protocol>): Protocol =\n+{\n+\t// If Protocol is unset, it must default to TCP protocol.\n+    match (npProtocol) {\n+        None -> protocolTCP(),\n+        Some{proto} -> proto\n+    }\n+}\n+\n+// toAntreaServices converts a networkingv1.NetworkPolicyPort object to an\n+// Antrea Service object.\n+function toAntreaServices(npPorts: Vec<k8s.NetworkPolicyPort>): Vec<Service> =\n+{\n+\tvar antreaServices: Vec<Service> = vec_empty();\n+\tfor (npPort in npPorts) {\n+\t\tvar antreaService = Service {\n+\t\t\t.protocol   = toAntreaProtocol(npPort.protocol),\n+\t\t    .port       = match (npPort.port) {\n+                None    -> None: Option<signed<32>>,\n+                // TODO(abhiraut): Retrieve ports for named ports.\n+                Some{p} -> Some{ k8s.intOrStringIntValue(p) }\n+            }\n+\t\t};\n+\t\tvec_push(antreaServices, antreaService)\n+\t};\n+\tantreaServices\n+}\n+\n+// toAntreaIPBlock converts a networkingv1.IPBlock to an Antrea IPBlock.\n+function toAntreaIPBlock(ipBlock: k8s.IPBlock): Either<string,IPBlock> =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk1MTk4Nw=="}, "originalCommit": {"oid": "11822990ea93d6fce22fc4ea9cbe06866e163b44"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk1MjczNQ==", "bodyText": "Maybe TODO(leonid) instead of XXX?\nSo it's clear that it's a DDlog problem and not inherited from Go.", "url": "https://github.com/vmware/differential-datalog/pull/505#discussion_r374952735", "createdAt": "2020-02-04T22:12:42Z", "author": {"login": "mbudiu-vmw"}, "path": "test/antrea/networkpolicy_controller.dl", "diffHunk": "@@ -0,0 +1,364 @@\n+/*\n+ * DDlog implementation of Antrea controller logic (see networkpolicy_controller.go).\n+ */\n+\n+import intern\n+import k8spolicy as k8s\n+import types\n+\n+// TODO\n+function log_error(e: string): () = ()\n+\n+/* In DDlog, we split the AppliedToGroup struct into three relations:\n+ * AppliedToGroup: stores group name, id, and GroupSelector\n+ * AppliedToGroupPodsByNode: stores the node-to-pods mapping.\n+ * AppliedToGroupSpan: group span (nodes where the group must be sent).\n+ */\n+\n+output relation AppliedToGroup (\n+\t// UID is generated from the hash value of GroupSelector.NormalizedName.\n+\tuid: k8s.UID,\n+\t// Name of this group, currently it's same as UID.\n+\tname: string,\n+\t// Selector describes how the group selects pods.\n+\tselector: GroupSelector\n+)\n+\n+// PodsByNode is a mapping from nodeName to a set of Pods on the Node.\n+output relation AppliedToGroupPodsByNode(appliedToGroup: k8s.UID, podsByNode: Map<string, Set<k8s.UID>>)\n+\n+// AppliedToGroupSpan: set of node names that this AddressGroup should be sent to.\n+output relation AppliedToGroupSpan(appliedToGroup: k8s.UID, span: Set<k8s.UID>)\n+\n+/* In DDlog, we split the AddressGroup struct into three relations:\n+ * AddressGroup: stores group name, id, and GroupSelector\n+ * AddressGroupAddress: stores addresses of nodes that match the group selector.\n+ * AddressGroupSpan: group span (nodes where the group must be sent).\n+ */\n+\n+// AddressGroup describes a set of addresses used as source or destination of Network Policy rules.\n+output relation AddressGroup (\n+\t// UID is generated from the hash value of GroupSelector.NormalizedName.\n+\tuid: k8s.UID,\n+\t// Name of this group, currently it's same as UID.\n+\tname: string,\n+\t// Selector describes how the group selects pods to get their addresses.\n+\tselector: GroupSelector\n+)\n+\n+// Addresses is a set of IP addresses selected by this group.\n+output relation AddressGroupAddress(addresGroup: k8s.UID, address: string)\n+\n+// AddressGroupSpan: set of node names that this AddressGroup should be sent to.\n+output relation AddressGroupSpan(addressGroup: k8s.UID, span: Set<k8s.UID>)\n+\n+// NetworkPolicy describes what network traffic is allowed for a set of Pods.\n+output relation NetworkPolicy (\n+\t// UID of the original K8s Network Policy.\n+\tuid: k8s.UID,\n+\t// Name of the original K8s Network Policy.\n+\tname: string,\n+\t// Namespace of the original K8s Network Policy.\n+\tnamespace: string,\n+\t// Rules is a list of rules to be applied to the selected Pods.\n+\trules: Vec<NetworkPolicyRule>,\n+\t// AppliedToGroups is a list of names of AppliedToGroups to which this policy applies.\n+\tappliedToGroups: Vec<string>\n+)\n+\n+// NetworkPolicySpan: set of node names that this NetworkPolicy should be sent to.\n+output relation NetworkPolicySpan(policy: k8s.UID, span: Set<k8s.UID>)\n+\n+// createAppliedToGroup creates an AppliedToGroup object.\n+function createAppliedToGroup(np: k8s.NetworkPolicy): AppliedToGroup =\n+{\n+\tvar groupSelector = toGroupSelector(np.namespace, Some{np.spec.podSelector}, None);\n+\tvar appliedToGroupUID = getNormalizedUID(groupSelector.normalizedName);\n+\t// Construct a new AppliedToGroup.\n+\tAppliedToGroup {\n+\t\t.name       = appliedToGroupUID,\n+\t\t.uid        = k8s.UID{appliedToGroupUID},\n+\t\t.selector   = groupSelector\n+\t}\n+}\n+\n+function toAntreaPeer(peers: Vec<k8s.NetworkPolicyPeer>, np: k8s.NetworkPolicy): (NetworkPolicyPeer, Vec<AddressGroup>) =\n+{\n+\t// Empty NetworkPolicyPeer is supposed to match all addresses.\n+\t// See https://kubernetes.io/docs/concepts/services-networking/network-policies/#default-allow-all-ingress-traffic.\n+\t// It's treated as an IPBlock \"0.0.0.0/0\".\n+\tif (vec_is_empty(peers)) {\n+\t\t(matchAllPeer(), vec_empty())\n+\t} else {\n+        var ipBlocks: Vec<IPBlock> = vec_empty();\n+        var addressGroupNames: Vec<string> = vec_empty();\n+        var addressGroups: Vec<AddressGroup> = vec_empty();\n+\n+        for (peer in peers) {\n+            // A networking.NetworkPolicyPeer will either have an IPBlock or a\n+            // podSelector and/or namespaceSelector set.\n+            match (peer.ipBlock) {\n+                Some{peerIPBlock} -> {\n+                    match (toAntreaIPBlock(peerIPBlock)) {\n+                        Left{err} -> {\n+                            log_error(\"Failure processing NetworkPolicy ${np.namespace}/${np.name} IPBlock ${peerIPBlock}: ${err}\")\n+                        },\n+                        Right{ipBlock} -> {\n+                            vec_push(ipBlocks, ipBlock)\n+                        }\n+                    }\n+                },\n+                None -> {\n+                    var addressGroup = createAddressGroup(peer, np);\n+                    vec_push(addressGroups, addressGroup);\n+                    vec_push(addressGroupNames, addressGroup.name)\n+                }\n+            }\n+        };\n+        var nppeer = NetworkPolicyPeer {\n+            .addressGroups  = addressGroupNames,\n+            .ipBlocks       = ipBlocks\n+        };\n+        (nppeer, addressGroups)\n+    }\n+}\n+\n+// toAntreaProtocol converts a v1.Protocol object to an Antrea Protocol object.\n+function toAntreaProtocol(npProtocol: Option<k8s.Protocol>): Protocol =\n+{\n+\t// If Protocol is unset, it must default to TCP protocol.\n+    match (npProtocol) {\n+        None -> protocolTCP(),\n+        Some{proto} -> proto\n+    }\n+}\n+\n+// toAntreaServices converts a networkingv1.NetworkPolicyPort object to an\n+// Antrea Service object.\n+function toAntreaServices(npPorts: Vec<k8s.NetworkPolicyPort>): Vec<Service> =\n+{\n+\tvar antreaServices: Vec<Service> = vec_empty();\n+\tfor (npPort in npPorts) {\n+\t\tvar antreaService = Service {\n+\t\t\t.protocol   = toAntreaProtocol(npPort.protocol),\n+\t\t    .port       = match (npPort.port) {\n+                None    -> None: Option<signed<32>>,\n+                // TODO(abhiraut): Retrieve ports for named ports.\n+                Some{p} -> Some{ k8s.intOrStringIntValue(p) }\n+            }\n+\t\t};\n+\t\tvec_push(antreaServices, antreaService)\n+\t};\n+\tantreaServices\n+}\n+\n+// toAntreaIPBlock converts a networkingv1.IPBlock to an Antrea IPBlock.\n+function toAntreaIPBlock(ipBlock: k8s.IPBlock): Either<string,IPBlock> =\n+{\n+\t// Convert the allowed IPBlock to networkpolicy.IPNet.\n+\tmatch (cidrStrToIPNet(ipBlock.cidr)) {\n+        Left{err} -> Left{err},\n+        Right{ipNet} -> {\n+            var exceptNets: Vec<IPNet> = vec_empty();\n+            var err: Option<string> = None;\n+            for (exc in ipBlock.except) {\n+                if is_none(err) {\n+                    // Convert the except IPBlock to networkpolicy.IPNet.\n+                    match (cidrStrToIPNet(exc)) {\n+                        Left{e} -> {\n+                            // XXX: fix this atrocity when we support the return statement.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11822990ea93d6fce22fc4ea9cbe06866e163b44"}, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk1MzA4NQ==", "bodyText": "inconsistent indentation.\nCan vi fix the whole file?", "url": "https://github.com/vmware/differential-datalog/pull/505#discussion_r374953085", "createdAt": "2020-02-04T22:13:31Z", "author": {"login": "mbudiu-vmw"}, "path": "test/antrea/networkpolicy_controller.dl", "diffHunk": "@@ -0,0 +1,364 @@\n+/*\n+ * DDlog implementation of Antrea controller logic (see networkpolicy_controller.go).\n+ */\n+\n+import intern\n+import k8spolicy as k8s\n+import types\n+\n+// TODO\n+function log_error(e: string): () = ()\n+\n+/* In DDlog, we split the AppliedToGroup struct into three relations:\n+ * AppliedToGroup: stores group name, id, and GroupSelector\n+ * AppliedToGroupPodsByNode: stores the node-to-pods mapping.\n+ * AppliedToGroupSpan: group span (nodes where the group must be sent).\n+ */\n+\n+output relation AppliedToGroup (\n+\t// UID is generated from the hash value of GroupSelector.NormalizedName.\n+\tuid: k8s.UID,\n+\t// Name of this group, currently it's same as UID.\n+\tname: string,\n+\t// Selector describes how the group selects pods.\n+\tselector: GroupSelector\n+)\n+\n+// PodsByNode is a mapping from nodeName to a set of Pods on the Node.\n+output relation AppliedToGroupPodsByNode(appliedToGroup: k8s.UID, podsByNode: Map<string, Set<k8s.UID>>)\n+\n+// AppliedToGroupSpan: set of node names that this AddressGroup should be sent to.\n+output relation AppliedToGroupSpan(appliedToGroup: k8s.UID, span: Set<k8s.UID>)\n+\n+/* In DDlog, we split the AddressGroup struct into three relations:\n+ * AddressGroup: stores group name, id, and GroupSelector\n+ * AddressGroupAddress: stores addresses of nodes that match the group selector.\n+ * AddressGroupSpan: group span (nodes where the group must be sent).\n+ */\n+\n+// AddressGroup describes a set of addresses used as source or destination of Network Policy rules.\n+output relation AddressGroup (\n+\t// UID is generated from the hash value of GroupSelector.NormalizedName.\n+\tuid: k8s.UID,\n+\t// Name of this group, currently it's same as UID.\n+\tname: string,\n+\t// Selector describes how the group selects pods to get their addresses.\n+\tselector: GroupSelector\n+)\n+\n+// Addresses is a set of IP addresses selected by this group.\n+output relation AddressGroupAddress(addresGroup: k8s.UID, address: string)\n+\n+// AddressGroupSpan: set of node names that this AddressGroup should be sent to.\n+output relation AddressGroupSpan(addressGroup: k8s.UID, span: Set<k8s.UID>)\n+\n+// NetworkPolicy describes what network traffic is allowed for a set of Pods.\n+output relation NetworkPolicy (\n+\t// UID of the original K8s Network Policy.\n+\tuid: k8s.UID,\n+\t// Name of the original K8s Network Policy.\n+\tname: string,\n+\t// Namespace of the original K8s Network Policy.\n+\tnamespace: string,\n+\t// Rules is a list of rules to be applied to the selected Pods.\n+\trules: Vec<NetworkPolicyRule>,\n+\t// AppliedToGroups is a list of names of AppliedToGroups to which this policy applies.\n+\tappliedToGroups: Vec<string>\n+)\n+\n+// NetworkPolicySpan: set of node names that this NetworkPolicy should be sent to.\n+output relation NetworkPolicySpan(policy: k8s.UID, span: Set<k8s.UID>)\n+\n+// createAppliedToGroup creates an AppliedToGroup object.\n+function createAppliedToGroup(np: k8s.NetworkPolicy): AppliedToGroup =\n+{\n+\tvar groupSelector = toGroupSelector(np.namespace, Some{np.spec.podSelector}, None);\n+\tvar appliedToGroupUID = getNormalizedUID(groupSelector.normalizedName);\n+\t// Construct a new AppliedToGroup.\n+\tAppliedToGroup {\n+\t\t.name       = appliedToGroupUID,\n+\t\t.uid        = k8s.UID{appliedToGroupUID},\n+\t\t.selector   = groupSelector\n+\t}\n+}\n+\n+function toAntreaPeer(peers: Vec<k8s.NetworkPolicyPeer>, np: k8s.NetworkPolicy): (NetworkPolicyPeer, Vec<AddressGroup>) =\n+{\n+\t// Empty NetworkPolicyPeer is supposed to match all addresses.\n+\t// See https://kubernetes.io/docs/concepts/services-networking/network-policies/#default-allow-all-ingress-traffic.\n+\t// It's treated as an IPBlock \"0.0.0.0/0\".\n+\tif (vec_is_empty(peers)) {\n+\t\t(matchAllPeer(), vec_empty())\n+\t} else {\n+        var ipBlocks: Vec<IPBlock> = vec_empty();\n+        var addressGroupNames: Vec<string> = vec_empty();\n+        var addressGroups: Vec<AddressGroup> = vec_empty();\n+\n+        for (peer in peers) {\n+            // A networking.NetworkPolicyPeer will either have an IPBlock or a\n+            // podSelector and/or namespaceSelector set.\n+            match (peer.ipBlock) {\n+                Some{peerIPBlock} -> {\n+                    match (toAntreaIPBlock(peerIPBlock)) {\n+                        Left{err} -> {\n+                            log_error(\"Failure processing NetworkPolicy ${np.namespace}/${np.name} IPBlock ${peerIPBlock}: ${err}\")\n+                        },\n+                        Right{ipBlock} -> {\n+                            vec_push(ipBlocks, ipBlock)\n+                        }\n+                    }\n+                },\n+                None -> {\n+                    var addressGroup = createAddressGroup(peer, np);\n+                    vec_push(addressGroups, addressGroup);\n+                    vec_push(addressGroupNames, addressGroup.name)\n+                }\n+            }\n+        };\n+        var nppeer = NetworkPolicyPeer {\n+            .addressGroups  = addressGroupNames,\n+            .ipBlocks       = ipBlocks\n+        };\n+        (nppeer, addressGroups)\n+    }\n+}\n+\n+// toAntreaProtocol converts a v1.Protocol object to an Antrea Protocol object.\n+function toAntreaProtocol(npProtocol: Option<k8s.Protocol>): Protocol =\n+{\n+\t// If Protocol is unset, it must default to TCP protocol.\n+    match (npProtocol) {\n+        None -> protocolTCP(),\n+        Some{proto} -> proto\n+    }\n+}\n+\n+// toAntreaServices converts a networkingv1.NetworkPolicyPort object to an\n+// Antrea Service object.\n+function toAntreaServices(npPorts: Vec<k8s.NetworkPolicyPort>): Vec<Service> =\n+{\n+\tvar antreaServices: Vec<Service> = vec_empty();\n+\tfor (npPort in npPorts) {\n+\t\tvar antreaService = Service {\n+\t\t\t.protocol   = toAntreaProtocol(npPort.protocol),\n+\t\t    .port       = match (npPort.port) {\n+                None    -> None: Option<signed<32>>,\n+                // TODO(abhiraut): Retrieve ports for named ports.\n+                Some{p} -> Some{ k8s.intOrStringIntValue(p) }\n+            }\n+\t\t};\n+\t\tvec_push(antreaServices, antreaService)\n+\t};\n+\tantreaServices\n+}\n+\n+// toAntreaIPBlock converts a networkingv1.IPBlock to an Antrea IPBlock.\n+function toAntreaIPBlock(ipBlock: k8s.IPBlock): Either<string,IPBlock> =\n+{\n+\t// Convert the allowed IPBlock to networkpolicy.IPNet.\n+\tmatch (cidrStrToIPNet(ipBlock.cidr)) {\n+        Left{err} -> Left{err},\n+        Right{ipNet} -> {\n+            var exceptNets: Vec<IPNet> = vec_empty();\n+            var err: Option<string> = None;\n+            for (exc in ipBlock.except) {\n+                if is_none(err) {\n+                    // Convert the except IPBlock to networkpolicy.IPNet.\n+                    match (cidrStrToIPNet(exc)) {\n+                        Left{e} -> {\n+                            // XXX: fix this atrocity when we support the return statement.\n+                            err = Some{e}\n+                        },\n+                        Right{exceptNet} -> {\n+                            vec_push(exceptNets, exceptNet)\n+                        }\n+                    }\n+                }\n+            };\n+            match (err) {\n+                None -> Right {\n+                    IPBlock {\n+                        .cidr   = ipNet,\n+                        .except = exceptNets\n+                    }\n+                },\n+                Some{e} -> Left{e}\n+            }\n+        }\n+    }\n+}\n+\n+// createAddressGroup creates an AddressGroup object corresponding to a\n+// NetworkPolicyPeer object in NetworkPolicyRule. This function simply\n+// creates the object without actually populating the PodAddresses as the\n+// affected Pods are calculated during sync process.\n+function createAddressGroup(peer: k8s.NetworkPolicyPeer, np: k8s.NetworkPolicy): AddressGroup =\n+{\n+\tvar groupSelector = toGroupSelector(np.namespace, peer.podSelector, peer.namespaceSelector);\n+\tvar normalizedUID = getNormalizedUID(groupSelector.normalizedName);\n+\n+    // Create an AddressGroup object per Peer object.\n+\tAddressGroup{\n+\t\t.uid        = k8s.UID{normalizedUID},\n+\t\t.name       = normalizedUID,\n+\t\t.selector   = groupSelector\n+\t}\n+}\n+\n+// processNetworkPolicy creates an internal NetworkPolicy instance corresponding\n+// to the networkingv1.NetworkPolicy object. This method does not commit the\n+// internal NetworkPolicy in store, instead returns an instance to the caller\n+// wherein, it will be either stored as a new Object in case of ADD event or\n+// modified and store the updated instance, in case of an UPDATE event.\n+function processNetworkPolicy(np: k8s.NetworkPolicy): (NetworkPolicy, AppliedToGroup, Vec<AddressGroup>) =\n+{\n+\tvar appliedToGroup = createAppliedToGroup(np);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11822990ea93d6fce22fc4ea9cbe06866e163b44"}, "originalPosition": 215}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk1MzY3Nw==", "bodyText": "the empty line is misleading", "url": "https://github.com/vmware/differential-datalog/pull/505#discussion_r374953677", "createdAt": "2020-02-04T22:14:56Z", "author": {"login": "mbudiu-vmw"}, "path": "test/antrea/networkpolicy_controller.dl", "diffHunk": "@@ -0,0 +1,364 @@\n+/*\n+ * DDlog implementation of Antrea controller logic (see networkpolicy_controller.go).\n+ */\n+\n+import intern\n+import k8spolicy as k8s\n+import types\n+\n+// TODO\n+function log_error(e: string): () = ()\n+\n+/* In DDlog, we split the AppliedToGroup struct into three relations:\n+ * AppliedToGroup: stores group name, id, and GroupSelector\n+ * AppliedToGroupPodsByNode: stores the node-to-pods mapping.\n+ * AppliedToGroupSpan: group span (nodes where the group must be sent).\n+ */\n+\n+output relation AppliedToGroup (\n+\t// UID is generated from the hash value of GroupSelector.NormalizedName.\n+\tuid: k8s.UID,\n+\t// Name of this group, currently it's same as UID.\n+\tname: string,\n+\t// Selector describes how the group selects pods.\n+\tselector: GroupSelector\n+)\n+\n+// PodsByNode is a mapping from nodeName to a set of Pods on the Node.\n+output relation AppliedToGroupPodsByNode(appliedToGroup: k8s.UID, podsByNode: Map<string, Set<k8s.UID>>)\n+\n+// AppliedToGroupSpan: set of node names that this AddressGroup should be sent to.\n+output relation AppliedToGroupSpan(appliedToGroup: k8s.UID, span: Set<k8s.UID>)\n+\n+/* In DDlog, we split the AddressGroup struct into three relations:\n+ * AddressGroup: stores group name, id, and GroupSelector\n+ * AddressGroupAddress: stores addresses of nodes that match the group selector.\n+ * AddressGroupSpan: group span (nodes where the group must be sent).\n+ */\n+\n+// AddressGroup describes a set of addresses used as source or destination of Network Policy rules.\n+output relation AddressGroup (\n+\t// UID is generated from the hash value of GroupSelector.NormalizedName.\n+\tuid: k8s.UID,\n+\t// Name of this group, currently it's same as UID.\n+\tname: string,\n+\t// Selector describes how the group selects pods to get their addresses.\n+\tselector: GroupSelector\n+)\n+\n+// Addresses is a set of IP addresses selected by this group.\n+output relation AddressGroupAddress(addresGroup: k8s.UID, address: string)\n+\n+// AddressGroupSpan: set of node names that this AddressGroup should be sent to.\n+output relation AddressGroupSpan(addressGroup: k8s.UID, span: Set<k8s.UID>)\n+\n+// NetworkPolicy describes what network traffic is allowed for a set of Pods.\n+output relation NetworkPolicy (\n+\t// UID of the original K8s Network Policy.\n+\tuid: k8s.UID,\n+\t// Name of the original K8s Network Policy.\n+\tname: string,\n+\t// Namespace of the original K8s Network Policy.\n+\tnamespace: string,\n+\t// Rules is a list of rules to be applied to the selected Pods.\n+\trules: Vec<NetworkPolicyRule>,\n+\t// AppliedToGroups is a list of names of AppliedToGroups to which this policy applies.\n+\tappliedToGroups: Vec<string>\n+)\n+\n+// NetworkPolicySpan: set of node names that this NetworkPolicy should be sent to.\n+output relation NetworkPolicySpan(policy: k8s.UID, span: Set<k8s.UID>)\n+\n+// createAppliedToGroup creates an AppliedToGroup object.\n+function createAppliedToGroup(np: k8s.NetworkPolicy): AppliedToGroup =\n+{\n+\tvar groupSelector = toGroupSelector(np.namespace, Some{np.spec.podSelector}, None);\n+\tvar appliedToGroupUID = getNormalizedUID(groupSelector.normalizedName);\n+\t// Construct a new AppliedToGroup.\n+\tAppliedToGroup {\n+\t\t.name       = appliedToGroupUID,\n+\t\t.uid        = k8s.UID{appliedToGroupUID},\n+\t\t.selector   = groupSelector\n+\t}\n+}\n+\n+function toAntreaPeer(peers: Vec<k8s.NetworkPolicyPeer>, np: k8s.NetworkPolicy): (NetworkPolicyPeer, Vec<AddressGroup>) =\n+{\n+\t// Empty NetworkPolicyPeer is supposed to match all addresses.\n+\t// See https://kubernetes.io/docs/concepts/services-networking/network-policies/#default-allow-all-ingress-traffic.\n+\t// It's treated as an IPBlock \"0.0.0.0/0\".\n+\tif (vec_is_empty(peers)) {\n+\t\t(matchAllPeer(), vec_empty())\n+\t} else {\n+        var ipBlocks: Vec<IPBlock> = vec_empty();\n+        var addressGroupNames: Vec<string> = vec_empty();\n+        var addressGroups: Vec<AddressGroup> = vec_empty();\n+\n+        for (peer in peers) {\n+            // A networking.NetworkPolicyPeer will either have an IPBlock or a\n+            // podSelector and/or namespaceSelector set.\n+            match (peer.ipBlock) {\n+                Some{peerIPBlock} -> {\n+                    match (toAntreaIPBlock(peerIPBlock)) {\n+                        Left{err} -> {\n+                            log_error(\"Failure processing NetworkPolicy ${np.namespace}/${np.name} IPBlock ${peerIPBlock}: ${err}\")\n+                        },\n+                        Right{ipBlock} -> {\n+                            vec_push(ipBlocks, ipBlock)\n+                        }\n+                    }\n+                },\n+                None -> {\n+                    var addressGroup = createAddressGroup(peer, np);\n+                    vec_push(addressGroups, addressGroup);\n+                    vec_push(addressGroupNames, addressGroup.name)\n+                }\n+            }\n+        };\n+        var nppeer = NetworkPolicyPeer {\n+            .addressGroups  = addressGroupNames,\n+            .ipBlocks       = ipBlocks\n+        };\n+        (nppeer, addressGroups)\n+    }\n+}\n+\n+// toAntreaProtocol converts a v1.Protocol object to an Antrea Protocol object.\n+function toAntreaProtocol(npProtocol: Option<k8s.Protocol>): Protocol =\n+{\n+\t// If Protocol is unset, it must default to TCP protocol.\n+    match (npProtocol) {\n+        None -> protocolTCP(),\n+        Some{proto} -> proto\n+    }\n+}\n+\n+// toAntreaServices converts a networkingv1.NetworkPolicyPort object to an\n+// Antrea Service object.\n+function toAntreaServices(npPorts: Vec<k8s.NetworkPolicyPort>): Vec<Service> =\n+{\n+\tvar antreaServices: Vec<Service> = vec_empty();\n+\tfor (npPort in npPorts) {\n+\t\tvar antreaService = Service {\n+\t\t\t.protocol   = toAntreaProtocol(npPort.protocol),\n+\t\t    .port       = match (npPort.port) {\n+                None    -> None: Option<signed<32>>,\n+                // TODO(abhiraut): Retrieve ports for named ports.\n+                Some{p} -> Some{ k8s.intOrStringIntValue(p) }\n+            }\n+\t\t};\n+\t\tvec_push(antreaServices, antreaService)\n+\t};\n+\tantreaServices\n+}\n+\n+// toAntreaIPBlock converts a networkingv1.IPBlock to an Antrea IPBlock.\n+function toAntreaIPBlock(ipBlock: k8s.IPBlock): Either<string,IPBlock> =\n+{\n+\t// Convert the allowed IPBlock to networkpolicy.IPNet.\n+\tmatch (cidrStrToIPNet(ipBlock.cidr)) {\n+        Left{err} -> Left{err},\n+        Right{ipNet} -> {\n+            var exceptNets: Vec<IPNet> = vec_empty();\n+            var err: Option<string> = None;\n+            for (exc in ipBlock.except) {\n+                if is_none(err) {\n+                    // Convert the except IPBlock to networkpolicy.IPNet.\n+                    match (cidrStrToIPNet(exc)) {\n+                        Left{e} -> {\n+                            // XXX: fix this atrocity when we support the return statement.\n+                            err = Some{e}\n+                        },\n+                        Right{exceptNet} -> {\n+                            vec_push(exceptNets, exceptNet)\n+                        }\n+                    }\n+                }\n+            };\n+            match (err) {\n+                None -> Right {\n+                    IPBlock {\n+                        .cidr   = ipNet,\n+                        .except = exceptNets\n+                    }\n+                },\n+                Some{e} -> Left{e}\n+            }\n+        }\n+    }\n+}\n+\n+// createAddressGroup creates an AddressGroup object corresponding to a\n+// NetworkPolicyPeer object in NetworkPolicyRule. This function simply\n+// creates the object without actually populating the PodAddresses as the\n+// affected Pods are calculated during sync process.\n+function createAddressGroup(peer: k8s.NetworkPolicyPeer, np: k8s.NetworkPolicy): AddressGroup =\n+{\n+\tvar groupSelector = toGroupSelector(np.namespace, peer.podSelector, peer.namespaceSelector);\n+\tvar normalizedUID = getNormalizedUID(groupSelector.normalizedName);\n+\n+    // Create an AddressGroup object per Peer object.\n+\tAddressGroup{\n+\t\t.uid        = k8s.UID{normalizedUID},\n+\t\t.name       = normalizedUID,\n+\t\t.selector   = groupSelector\n+\t}\n+}\n+\n+// processNetworkPolicy creates an internal NetworkPolicy instance corresponding\n+// to the networkingv1.NetworkPolicy object. This method does not commit the\n+// internal NetworkPolicy in store, instead returns an instance to the caller\n+// wherein, it will be either stored as a new Object in case of ADD event or\n+// modified and store the updated instance, in case of an UPDATE event.\n+function processNetworkPolicy(np: k8s.NetworkPolicy): (NetworkPolicy, AppliedToGroup, Vec<AddressGroup>) =\n+{\n+\tvar appliedToGroup = createAppliedToGroup(np);\n+\tvar rules: Vec<NetworkPolicyRule> = vec_empty();\n+    var addressGroups: Vec<AddressGroup> = vec_empty();\n+\tvar ingressRuleExists = false;\n+    var egressRuleExists  = false;\n+\n+\t// Compute NetworkPolicyRule for Ingress Rule.\n+\tfor (ingressRule in np.spec.ingress) {\n+\t\tingressRuleExists = true;\n+        (var from, var agroups) = toAntreaPeer(ingressRule.from, np);\n+        vec_append(addressGroups, agroups);\n+\t\tvec_push(rules, NetworkPolicyRule{\n+\t\t\t.direction = DirectionIn,\n+\t\t\t.from      = from,\n+            .to        = networkPolicyPeerEmpty(),\n+\t\t\t.services  = toAntreaServices(ingressRule.ports)\n+\t\t})\n+\t};\n+\t// Compute NetworkPolicyRule for Egress Rule.\n+\tfor (egressRule in np.spec.egress) {\n+\t\tegressRuleExists = true;\n+        (var to, var agroups) = toAntreaPeer(egressRule.to, np);\n+        vec_append(addressGroups, agroups);\n+\t\tvec_push(rules, NetworkPolicyRule {\n+\t\t\t.direction = DirectionOut,\n+            .from      = networkPolicyPeerEmpty(),\n+\t\t\t.to        = to,\n+\t\t\t.services  = toAntreaServices(egressRule.ports)\n+\t\t})\n+\t};\n+\n+\t// Traffic in a direction must be isolated if Spec.PolicyTypes specify it explicitly.\n+\tvar ingressIsolated = false;\n+    var egressIsolated = false;\n+\tfor (policyType in np.spec.policyTypes) {\n+\t\tmatch (policyType) {\n+            k8s.PolicyTypeIngress -> ingressIsolated = true,\n+\t\t    k8s.PolicyTypeEgress  -> egressIsolated = true\n+\t\t}\n+\t};\n+\n+\t// If ingress isolation is specified explicitly and there's no ingress rule, append a deny-all ingress rule.\n+\t// See https://kubernetes.io/docs/concepts/services-networking/network-policies/#default-deny-all-ingress-traffic\n+\tif (ingressIsolated and (not ingressRuleExists)) {\n+\t\tvec_push(rules, denyAllIngressRule())\n+\t};\n+\t// If egress isolation is specified explicitly and there's no egress rule, append a deny-all egress rule.\n+\t// See https://kubernetes.io/docs/concepts/services-networking/network-policies/#default-deny-all-egress-traffic\n+\tif (egressIsolated and (not egressRuleExists)) {\n+\t\tvec_push(rules, denyAllEgressRule())\n+\t};\n+\n+\tvar policy = NetworkPolicy {\n+\t\t.name               = np.name,\n+\t\t.namespace          = np.namespace,\n+\t\t.uid                = np.uid,\n+\t\t.appliedToGroups    = vec_singleton(appliedToGroup.name),\n+\t\t.rules              = rules\n+\t};\n+\n+    (policy, appliedToGroup, addressGroups)\n+}\n+\n+// Intermediate relation that stores policy and all associated address groups.\n+// This relation does not get indexed and therefore should not take any memory.\n+relation NetworkPolicyExt(\n+    policy: NetworkPolicy,\n+    addressGroups: Vec<AddressGroup>\n+)\n+\n+NetworkPolicyExt(internalPolicy, addrGroups),\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11822990ea93d6fce22fc4ea9cbe06866e163b44"}, "originalPosition": 286}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk1NTcxMg==", "bodyText": "Whose XXX is this?", "url": "https://github.com/vmware/differential-datalog/pull/505#discussion_r374955712", "createdAt": "2020-02-04T22:19:54Z", "author": {"login": "mbudiu-vmw"}, "path": "test/antrea/networkpolicy_controller.dl", "diffHunk": "@@ -0,0 +1,364 @@\n+/*\n+ * DDlog implementation of Antrea controller logic (see networkpolicy_controller.go).\n+ */\n+\n+import intern\n+import k8spolicy as k8s\n+import types\n+\n+// TODO\n+function log_error(e: string): () = ()\n+\n+/* In DDlog, we split the AppliedToGroup struct into three relations:\n+ * AppliedToGroup: stores group name, id, and GroupSelector\n+ * AppliedToGroupPodsByNode: stores the node-to-pods mapping.\n+ * AppliedToGroupSpan: group span (nodes where the group must be sent).\n+ */\n+\n+output relation AppliedToGroup (\n+\t// UID is generated from the hash value of GroupSelector.NormalizedName.\n+\tuid: k8s.UID,\n+\t// Name of this group, currently it's same as UID.\n+\tname: string,\n+\t// Selector describes how the group selects pods.\n+\tselector: GroupSelector\n+)\n+\n+// PodsByNode is a mapping from nodeName to a set of Pods on the Node.\n+output relation AppliedToGroupPodsByNode(appliedToGroup: k8s.UID, podsByNode: Map<string, Set<k8s.UID>>)\n+\n+// AppliedToGroupSpan: set of node names that this AddressGroup should be sent to.\n+output relation AppliedToGroupSpan(appliedToGroup: k8s.UID, span: Set<k8s.UID>)\n+\n+/* In DDlog, we split the AddressGroup struct into three relations:\n+ * AddressGroup: stores group name, id, and GroupSelector\n+ * AddressGroupAddress: stores addresses of nodes that match the group selector.\n+ * AddressGroupSpan: group span (nodes where the group must be sent).\n+ */\n+\n+// AddressGroup describes a set of addresses used as source or destination of Network Policy rules.\n+output relation AddressGroup (\n+\t// UID is generated from the hash value of GroupSelector.NormalizedName.\n+\tuid: k8s.UID,\n+\t// Name of this group, currently it's same as UID.\n+\tname: string,\n+\t// Selector describes how the group selects pods to get their addresses.\n+\tselector: GroupSelector\n+)\n+\n+// Addresses is a set of IP addresses selected by this group.\n+output relation AddressGroupAddress(addresGroup: k8s.UID, address: string)\n+\n+// AddressGroupSpan: set of node names that this AddressGroup should be sent to.\n+output relation AddressGroupSpan(addressGroup: k8s.UID, span: Set<k8s.UID>)\n+\n+// NetworkPolicy describes what network traffic is allowed for a set of Pods.\n+output relation NetworkPolicy (\n+\t// UID of the original K8s Network Policy.\n+\tuid: k8s.UID,\n+\t// Name of the original K8s Network Policy.\n+\tname: string,\n+\t// Namespace of the original K8s Network Policy.\n+\tnamespace: string,\n+\t// Rules is a list of rules to be applied to the selected Pods.\n+\trules: Vec<NetworkPolicyRule>,\n+\t// AppliedToGroups is a list of names of AppliedToGroups to which this policy applies.\n+\tappliedToGroups: Vec<string>\n+)\n+\n+// NetworkPolicySpan: set of node names that this NetworkPolicy should be sent to.\n+output relation NetworkPolicySpan(policy: k8s.UID, span: Set<k8s.UID>)\n+\n+// createAppliedToGroup creates an AppliedToGroup object.\n+function createAppliedToGroup(np: k8s.NetworkPolicy): AppliedToGroup =\n+{\n+\tvar groupSelector = toGroupSelector(np.namespace, Some{np.spec.podSelector}, None);\n+\tvar appliedToGroupUID = getNormalizedUID(groupSelector.normalizedName);\n+\t// Construct a new AppliedToGroup.\n+\tAppliedToGroup {\n+\t\t.name       = appliedToGroupUID,\n+\t\t.uid        = k8s.UID{appliedToGroupUID},\n+\t\t.selector   = groupSelector\n+\t}\n+}\n+\n+function toAntreaPeer(peers: Vec<k8s.NetworkPolicyPeer>, np: k8s.NetworkPolicy): (NetworkPolicyPeer, Vec<AddressGroup>) =\n+{\n+\t// Empty NetworkPolicyPeer is supposed to match all addresses.\n+\t// See https://kubernetes.io/docs/concepts/services-networking/network-policies/#default-allow-all-ingress-traffic.\n+\t// It's treated as an IPBlock \"0.0.0.0/0\".\n+\tif (vec_is_empty(peers)) {\n+\t\t(matchAllPeer(), vec_empty())\n+\t} else {\n+        var ipBlocks: Vec<IPBlock> = vec_empty();\n+        var addressGroupNames: Vec<string> = vec_empty();\n+        var addressGroups: Vec<AddressGroup> = vec_empty();\n+\n+        for (peer in peers) {\n+            // A networking.NetworkPolicyPeer will either have an IPBlock or a\n+            // podSelector and/or namespaceSelector set.\n+            match (peer.ipBlock) {\n+                Some{peerIPBlock} -> {\n+                    match (toAntreaIPBlock(peerIPBlock)) {\n+                        Left{err} -> {\n+                            log_error(\"Failure processing NetworkPolicy ${np.namespace}/${np.name} IPBlock ${peerIPBlock}: ${err}\")\n+                        },\n+                        Right{ipBlock} -> {\n+                            vec_push(ipBlocks, ipBlock)\n+                        }\n+                    }\n+                },\n+                None -> {\n+                    var addressGroup = createAddressGroup(peer, np);\n+                    vec_push(addressGroups, addressGroup);\n+                    vec_push(addressGroupNames, addressGroup.name)\n+                }\n+            }\n+        };\n+        var nppeer = NetworkPolicyPeer {\n+            .addressGroups  = addressGroupNames,\n+            .ipBlocks       = ipBlocks\n+        };\n+        (nppeer, addressGroups)\n+    }\n+}\n+\n+// toAntreaProtocol converts a v1.Protocol object to an Antrea Protocol object.\n+function toAntreaProtocol(npProtocol: Option<k8s.Protocol>): Protocol =\n+{\n+\t// If Protocol is unset, it must default to TCP protocol.\n+    match (npProtocol) {\n+        None -> protocolTCP(),\n+        Some{proto} -> proto\n+    }\n+}\n+\n+// toAntreaServices converts a networkingv1.NetworkPolicyPort object to an\n+// Antrea Service object.\n+function toAntreaServices(npPorts: Vec<k8s.NetworkPolicyPort>): Vec<Service> =\n+{\n+\tvar antreaServices: Vec<Service> = vec_empty();\n+\tfor (npPort in npPorts) {\n+\t\tvar antreaService = Service {\n+\t\t\t.protocol   = toAntreaProtocol(npPort.protocol),\n+\t\t    .port       = match (npPort.port) {\n+                None    -> None: Option<signed<32>>,\n+                // TODO(abhiraut): Retrieve ports for named ports.\n+                Some{p} -> Some{ k8s.intOrStringIntValue(p) }\n+            }\n+\t\t};\n+\t\tvec_push(antreaServices, antreaService)\n+\t};\n+\tantreaServices\n+}\n+\n+// toAntreaIPBlock converts a networkingv1.IPBlock to an Antrea IPBlock.\n+function toAntreaIPBlock(ipBlock: k8s.IPBlock): Either<string,IPBlock> =\n+{\n+\t// Convert the allowed IPBlock to networkpolicy.IPNet.\n+\tmatch (cidrStrToIPNet(ipBlock.cidr)) {\n+        Left{err} -> Left{err},\n+        Right{ipNet} -> {\n+            var exceptNets: Vec<IPNet> = vec_empty();\n+            var err: Option<string> = None;\n+            for (exc in ipBlock.except) {\n+                if is_none(err) {\n+                    // Convert the except IPBlock to networkpolicy.IPNet.\n+                    match (cidrStrToIPNet(exc)) {\n+                        Left{e} -> {\n+                            // XXX: fix this atrocity when we support the return statement.\n+                            err = Some{e}\n+                        },\n+                        Right{exceptNet} -> {\n+                            vec_push(exceptNets, exceptNet)\n+                        }\n+                    }\n+                }\n+            };\n+            match (err) {\n+                None -> Right {\n+                    IPBlock {\n+                        .cidr   = ipNet,\n+                        .except = exceptNets\n+                    }\n+                },\n+                Some{e} -> Left{e}\n+            }\n+        }\n+    }\n+}\n+\n+// createAddressGroup creates an AddressGroup object corresponding to a\n+// NetworkPolicyPeer object in NetworkPolicyRule. This function simply\n+// creates the object without actually populating the PodAddresses as the\n+// affected Pods are calculated during sync process.\n+function createAddressGroup(peer: k8s.NetworkPolicyPeer, np: k8s.NetworkPolicy): AddressGroup =\n+{\n+\tvar groupSelector = toGroupSelector(np.namespace, peer.podSelector, peer.namespaceSelector);\n+\tvar normalizedUID = getNormalizedUID(groupSelector.normalizedName);\n+\n+    // Create an AddressGroup object per Peer object.\n+\tAddressGroup{\n+\t\t.uid        = k8s.UID{normalizedUID},\n+\t\t.name       = normalizedUID,\n+\t\t.selector   = groupSelector\n+\t}\n+}\n+\n+// processNetworkPolicy creates an internal NetworkPolicy instance corresponding\n+// to the networkingv1.NetworkPolicy object. This method does not commit the\n+// internal NetworkPolicy in store, instead returns an instance to the caller\n+// wherein, it will be either stored as a new Object in case of ADD event or\n+// modified and store the updated instance, in case of an UPDATE event.\n+function processNetworkPolicy(np: k8s.NetworkPolicy): (NetworkPolicy, AppliedToGroup, Vec<AddressGroup>) =\n+{\n+\tvar appliedToGroup = createAppliedToGroup(np);\n+\tvar rules: Vec<NetworkPolicyRule> = vec_empty();\n+    var addressGroups: Vec<AddressGroup> = vec_empty();\n+\tvar ingressRuleExists = false;\n+    var egressRuleExists  = false;\n+\n+\t// Compute NetworkPolicyRule for Ingress Rule.\n+\tfor (ingressRule in np.spec.ingress) {\n+\t\tingressRuleExists = true;\n+        (var from, var agroups) = toAntreaPeer(ingressRule.from, np);\n+        vec_append(addressGroups, agroups);\n+\t\tvec_push(rules, NetworkPolicyRule{\n+\t\t\t.direction = DirectionIn,\n+\t\t\t.from      = from,\n+            .to        = networkPolicyPeerEmpty(),\n+\t\t\t.services  = toAntreaServices(ingressRule.ports)\n+\t\t})\n+\t};\n+\t// Compute NetworkPolicyRule for Egress Rule.\n+\tfor (egressRule in np.spec.egress) {\n+\t\tegressRuleExists = true;\n+        (var to, var agroups) = toAntreaPeer(egressRule.to, np);\n+        vec_append(addressGroups, agroups);\n+\t\tvec_push(rules, NetworkPolicyRule {\n+\t\t\t.direction = DirectionOut,\n+            .from      = networkPolicyPeerEmpty(),\n+\t\t\t.to        = to,\n+\t\t\t.services  = toAntreaServices(egressRule.ports)\n+\t\t})\n+\t};\n+\n+\t// Traffic in a direction must be isolated if Spec.PolicyTypes specify it explicitly.\n+\tvar ingressIsolated = false;\n+    var egressIsolated = false;\n+\tfor (policyType in np.spec.policyTypes) {\n+\t\tmatch (policyType) {\n+            k8s.PolicyTypeIngress -> ingressIsolated = true,\n+\t\t    k8s.PolicyTypeEgress  -> egressIsolated = true\n+\t\t}\n+\t};\n+\n+\t// If ingress isolation is specified explicitly and there's no ingress rule, append a deny-all ingress rule.\n+\t// See https://kubernetes.io/docs/concepts/services-networking/network-policies/#default-deny-all-ingress-traffic\n+\tif (ingressIsolated and (not ingressRuleExists)) {\n+\t\tvec_push(rules, denyAllIngressRule())\n+\t};\n+\t// If egress isolation is specified explicitly and there's no egress rule, append a deny-all egress rule.\n+\t// See https://kubernetes.io/docs/concepts/services-networking/network-policies/#default-deny-all-egress-traffic\n+\tif (egressIsolated and (not egressRuleExists)) {\n+\t\tvec_push(rules, denyAllEgressRule())\n+\t};\n+\n+\tvar policy = NetworkPolicy {\n+\t\t.name               = np.name,\n+\t\t.namespace          = np.namespace,\n+\t\t.uid                = np.uid,\n+\t\t.appliedToGroups    = vec_singleton(appliedToGroup.name),\n+\t\t.rules              = rules\n+\t};\n+\n+    (policy, appliedToGroup, addressGroups)\n+}\n+\n+// Intermediate relation that stores policy and all associated address groups.\n+// This relation does not get indexed and therefore should not take any memory.\n+relation NetworkPolicyExt(\n+    policy: NetworkPolicy,\n+    addressGroups: Vec<AddressGroup>\n+)\n+\n+NetworkPolicyExt(internalPolicy, addrGroups),\n+\n+AppliedToGroup[appliedTo] :-\n+    k8s.NetworkPolicy[policy],\n+    (var internalPolicy, var appliedTo, var addrGroups) = processNetworkPolicy(policy).\n+\n+NetworkPolicy[policy] :- NetworkPolicyExt(policy, _).\n+\n+AddressGroup[group] :-\n+    NetworkPolicyExt(_, groups),\n+    var group = FlatMap(groups).\n+\n+AddressGroupAddress(addressGroup.uid, pod.status.podIP) :-\n+    // Namespace presence indicates Pods must be selected from the same Namespace.\n+    addressGroup in AddressGroup(.selector = GroupSelector{.nsSelector = NSSelectorNS{ns}}),\n+    pod in k8s.Pod(.namespace = Some{ns}),\n+    pod.status.podIP != \"\",\n+    k8s.labelSelectorMatches(addressGroup.selector.podSelector, pod.labels).\n+\n+AddressGroupAddress(addressGroup.uid, pod.status.podIP) :-\n+    // Pods must be selected from Namespaces matching nsSelector.\n+    addressGroup in AddressGroup(.selector = GroupSelector{.nsSelector = NSSelectorLS{namespaceSelector}, .podSelector = podSelector}),\n+    namespace in k8s.Namespace(),\n+    k8s.labelSelectorMatches(Some{namespaceSelector}, namespace.labels),\n+    pod in k8s.Pod(.namespace = Some{namespace.name}),\n+    pod.status.podIP != \"\",\n+    is_none(podSelector) or k8s.labelSelectorMatches(podSelector, pod.labels).\n+\n+// NetworkPolicyAddressGroup: stores all address groups that a network policy references;\n+// used to compute AddressGroupSpan.\n+relation NetworkPolicyAddressGroup(np: k8s.UID, addressGroup: string)\n+\n+NetworkPolicyAddressGroup(np, addressGroup) :-\n+    NetworkPolicy(.uid = np, .rules = rules),\n+    var addressGroups = {\n+        var addressGroups: Vec<string> = vec_empty();\n+        for (rule in rules) {\n+            vec_append(addressGroups, rule.from.addressGroups);\n+            vec_append(addressGroups, rule.to.addressGroups)\n+        };\n+        addressGroups\n+    },\n+    var addressGroup = FlatMap(addressGroups).\n+\n+AddressGroupSpan(k8s.UID{addressGroup}, span) :-\n+    AddressGroup(.uid = k8s.UID{addressGroup}),\n+\t// Get all internal NetworkPolicy objects that refers this AddressGroup.\n+    NetworkPolicyAddressGroup(np, addressGroup),\n+    NetworkPolicySpan(np, npSpan),\n+    var span = Aggregate((addressGroup), group_set_unions(npSpan)).\n+\n+// AppliedToGroupPod: pods that belong to a group along with nodes\n+// where the pod is scheduled;\n+// used to compute AppliedToGroupPodsByNode and AppliedToGroupSpan.\n+relation AppliedToGroupPod(appliedToGroup: k8s.UID, pod: k8s.UID, nodeName: string)\n+\n+AppliedToGroupPod(appliedToGroup, pod.uid, pod.spec.nodeName) :-\n+    // XXX: Is it correct that we only consider selectors with namespace name set?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11822990ea93d6fce22fc4ea9cbe06866e163b44"}, "originalPosition": 342}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk1NjAyMg==", "bodyText": "it's remarkable how compact these rules are. they are actually easier to read than the comments that describe them...", "url": "https://github.com/vmware/differential-datalog/pull/505#discussion_r374956022", "createdAt": "2020-02-04T22:20:35Z", "author": {"login": "mbudiu-vmw"}, "path": "test/antrea/networkpolicy_controller.dl", "diffHunk": "@@ -0,0 +1,364 @@\n+/*\n+ * DDlog implementation of Antrea controller logic (see networkpolicy_controller.go).\n+ */\n+\n+import intern\n+import k8spolicy as k8s\n+import types\n+\n+// TODO\n+function log_error(e: string): () = ()\n+\n+/* In DDlog, we split the AppliedToGroup struct into three relations:\n+ * AppliedToGroup: stores group name, id, and GroupSelector\n+ * AppliedToGroupPodsByNode: stores the node-to-pods mapping.\n+ * AppliedToGroupSpan: group span (nodes where the group must be sent).\n+ */\n+\n+output relation AppliedToGroup (\n+\t// UID is generated from the hash value of GroupSelector.NormalizedName.\n+\tuid: k8s.UID,\n+\t// Name of this group, currently it's same as UID.\n+\tname: string,\n+\t// Selector describes how the group selects pods.\n+\tselector: GroupSelector\n+)\n+\n+// PodsByNode is a mapping from nodeName to a set of Pods on the Node.\n+output relation AppliedToGroupPodsByNode(appliedToGroup: k8s.UID, podsByNode: Map<string, Set<k8s.UID>>)\n+\n+// AppliedToGroupSpan: set of node names that this AddressGroup should be sent to.\n+output relation AppliedToGroupSpan(appliedToGroup: k8s.UID, span: Set<k8s.UID>)\n+\n+/* In DDlog, we split the AddressGroup struct into three relations:\n+ * AddressGroup: stores group name, id, and GroupSelector\n+ * AddressGroupAddress: stores addresses of nodes that match the group selector.\n+ * AddressGroupSpan: group span (nodes where the group must be sent).\n+ */\n+\n+// AddressGroup describes a set of addresses used as source or destination of Network Policy rules.\n+output relation AddressGroup (\n+\t// UID is generated from the hash value of GroupSelector.NormalizedName.\n+\tuid: k8s.UID,\n+\t// Name of this group, currently it's same as UID.\n+\tname: string,\n+\t// Selector describes how the group selects pods to get their addresses.\n+\tselector: GroupSelector\n+)\n+\n+// Addresses is a set of IP addresses selected by this group.\n+output relation AddressGroupAddress(addresGroup: k8s.UID, address: string)\n+\n+// AddressGroupSpan: set of node names that this AddressGroup should be sent to.\n+output relation AddressGroupSpan(addressGroup: k8s.UID, span: Set<k8s.UID>)\n+\n+// NetworkPolicy describes what network traffic is allowed for a set of Pods.\n+output relation NetworkPolicy (\n+\t// UID of the original K8s Network Policy.\n+\tuid: k8s.UID,\n+\t// Name of the original K8s Network Policy.\n+\tname: string,\n+\t// Namespace of the original K8s Network Policy.\n+\tnamespace: string,\n+\t// Rules is a list of rules to be applied to the selected Pods.\n+\trules: Vec<NetworkPolicyRule>,\n+\t// AppliedToGroups is a list of names of AppliedToGroups to which this policy applies.\n+\tappliedToGroups: Vec<string>\n+)\n+\n+// NetworkPolicySpan: set of node names that this NetworkPolicy should be sent to.\n+output relation NetworkPolicySpan(policy: k8s.UID, span: Set<k8s.UID>)\n+\n+// createAppliedToGroup creates an AppliedToGroup object.\n+function createAppliedToGroup(np: k8s.NetworkPolicy): AppliedToGroup =\n+{\n+\tvar groupSelector = toGroupSelector(np.namespace, Some{np.spec.podSelector}, None);\n+\tvar appliedToGroupUID = getNormalizedUID(groupSelector.normalizedName);\n+\t// Construct a new AppliedToGroup.\n+\tAppliedToGroup {\n+\t\t.name       = appliedToGroupUID,\n+\t\t.uid        = k8s.UID{appliedToGroupUID},\n+\t\t.selector   = groupSelector\n+\t}\n+}\n+\n+function toAntreaPeer(peers: Vec<k8s.NetworkPolicyPeer>, np: k8s.NetworkPolicy): (NetworkPolicyPeer, Vec<AddressGroup>) =\n+{\n+\t// Empty NetworkPolicyPeer is supposed to match all addresses.\n+\t// See https://kubernetes.io/docs/concepts/services-networking/network-policies/#default-allow-all-ingress-traffic.\n+\t// It's treated as an IPBlock \"0.0.0.0/0\".\n+\tif (vec_is_empty(peers)) {\n+\t\t(matchAllPeer(), vec_empty())\n+\t} else {\n+        var ipBlocks: Vec<IPBlock> = vec_empty();\n+        var addressGroupNames: Vec<string> = vec_empty();\n+        var addressGroups: Vec<AddressGroup> = vec_empty();\n+\n+        for (peer in peers) {\n+            // A networking.NetworkPolicyPeer will either have an IPBlock or a\n+            // podSelector and/or namespaceSelector set.\n+            match (peer.ipBlock) {\n+                Some{peerIPBlock} -> {\n+                    match (toAntreaIPBlock(peerIPBlock)) {\n+                        Left{err} -> {\n+                            log_error(\"Failure processing NetworkPolicy ${np.namespace}/${np.name} IPBlock ${peerIPBlock}: ${err}\")\n+                        },\n+                        Right{ipBlock} -> {\n+                            vec_push(ipBlocks, ipBlock)\n+                        }\n+                    }\n+                },\n+                None -> {\n+                    var addressGroup = createAddressGroup(peer, np);\n+                    vec_push(addressGroups, addressGroup);\n+                    vec_push(addressGroupNames, addressGroup.name)\n+                }\n+            }\n+        };\n+        var nppeer = NetworkPolicyPeer {\n+            .addressGroups  = addressGroupNames,\n+            .ipBlocks       = ipBlocks\n+        };\n+        (nppeer, addressGroups)\n+    }\n+}\n+\n+// toAntreaProtocol converts a v1.Protocol object to an Antrea Protocol object.\n+function toAntreaProtocol(npProtocol: Option<k8s.Protocol>): Protocol =\n+{\n+\t// If Protocol is unset, it must default to TCP protocol.\n+    match (npProtocol) {\n+        None -> protocolTCP(),\n+        Some{proto} -> proto\n+    }\n+}\n+\n+// toAntreaServices converts a networkingv1.NetworkPolicyPort object to an\n+// Antrea Service object.\n+function toAntreaServices(npPorts: Vec<k8s.NetworkPolicyPort>): Vec<Service> =\n+{\n+\tvar antreaServices: Vec<Service> = vec_empty();\n+\tfor (npPort in npPorts) {\n+\t\tvar antreaService = Service {\n+\t\t\t.protocol   = toAntreaProtocol(npPort.protocol),\n+\t\t    .port       = match (npPort.port) {\n+                None    -> None: Option<signed<32>>,\n+                // TODO(abhiraut): Retrieve ports for named ports.\n+                Some{p} -> Some{ k8s.intOrStringIntValue(p) }\n+            }\n+\t\t};\n+\t\tvec_push(antreaServices, antreaService)\n+\t};\n+\tantreaServices\n+}\n+\n+// toAntreaIPBlock converts a networkingv1.IPBlock to an Antrea IPBlock.\n+function toAntreaIPBlock(ipBlock: k8s.IPBlock): Either<string,IPBlock> =\n+{\n+\t// Convert the allowed IPBlock to networkpolicy.IPNet.\n+\tmatch (cidrStrToIPNet(ipBlock.cidr)) {\n+        Left{err} -> Left{err},\n+        Right{ipNet} -> {\n+            var exceptNets: Vec<IPNet> = vec_empty();\n+            var err: Option<string> = None;\n+            for (exc in ipBlock.except) {\n+                if is_none(err) {\n+                    // Convert the except IPBlock to networkpolicy.IPNet.\n+                    match (cidrStrToIPNet(exc)) {\n+                        Left{e} -> {\n+                            // XXX: fix this atrocity when we support the return statement.\n+                            err = Some{e}\n+                        },\n+                        Right{exceptNet} -> {\n+                            vec_push(exceptNets, exceptNet)\n+                        }\n+                    }\n+                }\n+            };\n+            match (err) {\n+                None -> Right {\n+                    IPBlock {\n+                        .cidr   = ipNet,\n+                        .except = exceptNets\n+                    }\n+                },\n+                Some{e} -> Left{e}\n+            }\n+        }\n+    }\n+}\n+\n+// createAddressGroup creates an AddressGroup object corresponding to a\n+// NetworkPolicyPeer object in NetworkPolicyRule. This function simply\n+// creates the object without actually populating the PodAddresses as the\n+// affected Pods are calculated during sync process.\n+function createAddressGroup(peer: k8s.NetworkPolicyPeer, np: k8s.NetworkPolicy): AddressGroup =\n+{\n+\tvar groupSelector = toGroupSelector(np.namespace, peer.podSelector, peer.namespaceSelector);\n+\tvar normalizedUID = getNormalizedUID(groupSelector.normalizedName);\n+\n+    // Create an AddressGroup object per Peer object.\n+\tAddressGroup{\n+\t\t.uid        = k8s.UID{normalizedUID},\n+\t\t.name       = normalizedUID,\n+\t\t.selector   = groupSelector\n+\t}\n+}\n+\n+// processNetworkPolicy creates an internal NetworkPolicy instance corresponding\n+// to the networkingv1.NetworkPolicy object. This method does not commit the\n+// internal NetworkPolicy in store, instead returns an instance to the caller\n+// wherein, it will be either stored as a new Object in case of ADD event or\n+// modified and store the updated instance, in case of an UPDATE event.\n+function processNetworkPolicy(np: k8s.NetworkPolicy): (NetworkPolicy, AppliedToGroup, Vec<AddressGroup>) =\n+{\n+\tvar appliedToGroup = createAppliedToGroup(np);\n+\tvar rules: Vec<NetworkPolicyRule> = vec_empty();\n+    var addressGroups: Vec<AddressGroup> = vec_empty();\n+\tvar ingressRuleExists = false;\n+    var egressRuleExists  = false;\n+\n+\t// Compute NetworkPolicyRule for Ingress Rule.\n+\tfor (ingressRule in np.spec.ingress) {\n+\t\tingressRuleExists = true;\n+        (var from, var agroups) = toAntreaPeer(ingressRule.from, np);\n+        vec_append(addressGroups, agroups);\n+\t\tvec_push(rules, NetworkPolicyRule{\n+\t\t\t.direction = DirectionIn,\n+\t\t\t.from      = from,\n+            .to        = networkPolicyPeerEmpty(),\n+\t\t\t.services  = toAntreaServices(ingressRule.ports)\n+\t\t})\n+\t};\n+\t// Compute NetworkPolicyRule for Egress Rule.\n+\tfor (egressRule in np.spec.egress) {\n+\t\tegressRuleExists = true;\n+        (var to, var agroups) = toAntreaPeer(egressRule.to, np);\n+        vec_append(addressGroups, agroups);\n+\t\tvec_push(rules, NetworkPolicyRule {\n+\t\t\t.direction = DirectionOut,\n+            .from      = networkPolicyPeerEmpty(),\n+\t\t\t.to        = to,\n+\t\t\t.services  = toAntreaServices(egressRule.ports)\n+\t\t})\n+\t};\n+\n+\t// Traffic in a direction must be isolated if Spec.PolicyTypes specify it explicitly.\n+\tvar ingressIsolated = false;\n+    var egressIsolated = false;\n+\tfor (policyType in np.spec.policyTypes) {\n+\t\tmatch (policyType) {\n+            k8s.PolicyTypeIngress -> ingressIsolated = true,\n+\t\t    k8s.PolicyTypeEgress  -> egressIsolated = true\n+\t\t}\n+\t};\n+\n+\t// If ingress isolation is specified explicitly and there's no ingress rule, append a deny-all ingress rule.\n+\t// See https://kubernetes.io/docs/concepts/services-networking/network-policies/#default-deny-all-ingress-traffic\n+\tif (ingressIsolated and (not ingressRuleExists)) {\n+\t\tvec_push(rules, denyAllIngressRule())\n+\t};\n+\t// If egress isolation is specified explicitly and there's no egress rule, append a deny-all egress rule.\n+\t// See https://kubernetes.io/docs/concepts/services-networking/network-policies/#default-deny-all-egress-traffic\n+\tif (egressIsolated and (not egressRuleExists)) {\n+\t\tvec_push(rules, denyAllEgressRule())\n+\t};\n+\n+\tvar policy = NetworkPolicy {\n+\t\t.name               = np.name,\n+\t\t.namespace          = np.namespace,\n+\t\t.uid                = np.uid,\n+\t\t.appliedToGroups    = vec_singleton(appliedToGroup.name),\n+\t\t.rules              = rules\n+\t};\n+\n+    (policy, appliedToGroup, addressGroups)\n+}\n+\n+// Intermediate relation that stores policy and all associated address groups.\n+// This relation does not get indexed and therefore should not take any memory.\n+relation NetworkPolicyExt(\n+    policy: NetworkPolicy,\n+    addressGroups: Vec<AddressGroup>\n+)\n+\n+NetworkPolicyExt(internalPolicy, addrGroups),\n+\n+AppliedToGroup[appliedTo] :-\n+    k8s.NetworkPolicy[policy],\n+    (var internalPolicy, var appliedTo, var addrGroups) = processNetworkPolicy(policy).\n+\n+NetworkPolicy[policy] :- NetworkPolicyExt(policy, _).\n+\n+AddressGroup[group] :-\n+    NetworkPolicyExt(_, groups),\n+    var group = FlatMap(groups).\n+\n+AddressGroupAddress(addressGroup.uid, pod.status.podIP) :-\n+    // Namespace presence indicates Pods must be selected from the same Namespace.\n+    addressGroup in AddressGroup(.selector = GroupSelector{.nsSelector = NSSelectorNS{ns}}),\n+    pod in k8s.Pod(.namespace = Some{ns}),\n+    pod.status.podIP != \"\",\n+    k8s.labelSelectorMatches(addressGroup.selector.podSelector, pod.labels).\n+\n+AddressGroupAddress(addressGroup.uid, pod.status.podIP) :-\n+    // Pods must be selected from Namespaces matching nsSelector.\n+    addressGroup in AddressGroup(.selector = GroupSelector{.nsSelector = NSSelectorLS{namespaceSelector}, .podSelector = podSelector}),\n+    namespace in k8s.Namespace(),\n+    k8s.labelSelectorMatches(Some{namespaceSelector}, namespace.labels),\n+    pod in k8s.Pod(.namespace = Some{namespace.name}),\n+    pod.status.podIP != \"\",\n+    is_none(podSelector) or k8s.labelSelectorMatches(podSelector, pod.labels).\n+\n+// NetworkPolicyAddressGroup: stores all address groups that a network policy references;\n+// used to compute AddressGroupSpan.\n+relation NetworkPolicyAddressGroup(np: k8s.UID, addressGroup: string)\n+\n+NetworkPolicyAddressGroup(np, addressGroup) :-\n+    NetworkPolicy(.uid = np, .rules = rules),\n+    var addressGroups = {\n+        var addressGroups: Vec<string> = vec_empty();\n+        for (rule in rules) {\n+            vec_append(addressGroups, rule.from.addressGroups);\n+            vec_append(addressGroups, rule.to.addressGroups)\n+        };\n+        addressGroups\n+    },\n+    var addressGroup = FlatMap(addressGroups).\n+\n+AddressGroupSpan(k8s.UID{addressGroup}, span) :-\n+    AddressGroup(.uid = k8s.UID{addressGroup}),\n+\t// Get all internal NetworkPolicy objects that refers this AddressGroup.\n+    NetworkPolicyAddressGroup(np, addressGroup),\n+    NetworkPolicySpan(np, npSpan),\n+    var span = Aggregate((addressGroup), group_set_unions(npSpan)).\n+\n+// AppliedToGroupPod: pods that belong to a group along with nodes\n+// where the pod is scheduled;\n+// used to compute AppliedToGroupPodsByNode and AppliedToGroupSpan.\n+relation AppliedToGroupPod(appliedToGroup: k8s.UID, pod: k8s.UID, nodeName: string)\n+\n+AppliedToGroupPod(appliedToGroup, pod.uid, pod.spec.nodeName) :-\n+    // XXX: Is it correct that we only consider selectors with namespace name set?\n+    AppliedToGroup(.uid = appliedToGroup,\n+                   .selector = GroupSelector{.nsSelector = NSSelectorNS{namespace}, .podSelector = podSelector}),\n+\t// Retrieve all Pods matching the podSelector.\n+    pod in k8s.Pod(.namespace = Some{namespace}),\n+    // No need to process Pod when it's not scheduled.\n+    pod.spec.nodeName != \"\",\n+    k8s.labelSelectorMatches(podSelector, pod.labels).\n+\n+AppliedToGroupPodsByNode(appliedToGroup, podsByNode) :-\n+    AppliedToGroupPod(appliedToGroup, pod, nodeName),\n+    var podsOnNode = Aggregate((appliedToGroup, nodeName), group2set(pod)),\n+    var podsByNode = Aggregate((appliedToGroup), group2map((nodeName, podsOnNode))).\n+\n+AppliedToGroupSpan(appliedToGroup, span) :-\n+    AppliedToGroupPod(appliedToGroup, pod, _),\n+    var span = Aggregate((appliedToGroup), group2set(pod)).\n+\n+NetworkPolicySpan(policy, span) :-", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11822990ea93d6fce22fc4ea9cbe06866e163b44"}, "originalPosition": 360}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk1NjQxMw==", "bodyText": "probably you can just use the substring function to carve pieces from the hex string.", "url": "https://github.com/vmware/differential-datalog/pull/505#discussion_r374956413", "createdAt": "2020-02-04T22:21:27Z", "author": {"login": "mbudiu-vmw"}, "path": "test/antrea/types.dl", "diffHunk": "@@ -0,0 +1,272 @@\n+/*\n+ * Types used in internal Antrea NetworkPolicy definition.\n+ */\n+\n+import intern\n+import k8spolicy as k8s\n+\n+// getNormalizedUID generates a unique UUID based on a given string.\n+// For example, it can be used to generate keys using normalized selectors\n+// unique within the Namespace by adding the constant UID.\n+function getNormalizedUID(name: string): string = {\n+    var uuid = hash128(name);\n+    // TODO: implement proper UUID formatter.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11822990ea93d6fce22fc4ea9cbe06866e163b44"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk1NjcxMA==", "bodyText": "inconsistent indentation", "url": "https://github.com/vmware/differential-datalog/pull/505#discussion_r374956710", "createdAt": "2020-02-04T22:22:08Z", "author": {"login": "mbudiu-vmw"}, "path": "test/antrea/types.dl", "diffHunk": "@@ -0,0 +1,272 @@\n+/*\n+ * Types used in internal Antrea NetworkPolicy definition.\n+ */\n+\n+import intern\n+import k8spolicy as k8s\n+\n+// getNormalizedUID generates a unique UUID based on a given string.\n+// For example, it can be used to generate keys using normalized selectors\n+// unique within the Namespace by adding the constant UID.\n+function getNormalizedUID(name: string): string = {\n+    var uuid = hash128(name);\n+    // TODO: implement proper UUID formatter.\n+    \"${uuid}\"\n+}\n+\n+// normalizeExpr converts an expression to the form \"key1 OP [value1...]\".\n+function normalizeExpr(ekey: string, operator: k8s.LabelSelectorOperator, values: Vec<string>): string =\n+{\n+\tif vec_is_empty(values) {\n+\t\t\"${ekey} ${operator}\"\n+\t} else {\n+\t\t\"${ekey} ${operator} [${string_join(values, \\\",\\\")}]\"\n+\t}\n+}\n+\n+// selectorToString creates a string corresponding to a labelSelector in the form of\n+// \"key1 IN [value1,...] And key2 NotIn [value2,...] And ...\".\n+function selectorToString(selector: Ref<k8s.LabelSelector>): string =\n+{\n+    var sel = deref(selector);\n+\tvar selSlice: Set<string> = set_empty();\n+\t// Append labels in matchLabels as \"key In [value]\".\n+\tfor (kv in sel.matchLabels) {\n+\t\tset_insert(selSlice, normalizeExpr(kv.0, k8s.LabelSelectorOpIn, vec_singleton(kv.1)))\n+\t};\n+\tfor (expr in sel.matchExpressions) {\n+\t\tmatch (expr.operator) {\n+\t\t    k8s.LabelSelectorOpIn -> {\n+\t\t\t    set_insert(selSlice, normalizeExpr(expr.reqkey, k8s.LabelSelectorOpIn, expr.values))\n+            },\n+\t\t    k8s.LabelSelectorOpNotIn -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11822990ea93d6fce22fc4ea9cbe06866e163b44"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDk1NzQ4NA==", "bodyText": "will this be extern?", "url": "https://github.com/vmware/differential-datalog/pull/505#discussion_r374957484", "createdAt": "2020-02-04T22:24:01Z", "author": {"login": "mbudiu-vmw"}, "path": "test/antrea/types.dl", "diffHunk": "@@ -0,0 +1,272 @@\n+/*\n+ * Types used in internal Antrea NetworkPolicy definition.\n+ */\n+\n+import intern\n+import k8spolicy as k8s\n+\n+// getNormalizedUID generates a unique UUID based on a given string.\n+// For example, it can be used to generate keys using normalized selectors\n+// unique within the Namespace by adding the constant UID.\n+function getNormalizedUID(name: string): string = {\n+    var uuid = hash128(name);\n+    // TODO: implement proper UUID formatter.\n+    \"${uuid}\"\n+}\n+\n+// normalizeExpr converts an expression to the form \"key1 OP [value1...]\".\n+function normalizeExpr(ekey: string, operator: k8s.LabelSelectorOperator, values: Vec<string>): string =\n+{\n+\tif vec_is_empty(values) {\n+\t\t\"${ekey} ${operator}\"\n+\t} else {\n+\t\t\"${ekey} ${operator} [${string_join(values, \\\",\\\")}]\"\n+\t}\n+}\n+\n+// selectorToString creates a string corresponding to a labelSelector in the form of\n+// \"key1 IN [value1,...] And key2 NotIn [value2,...] And ...\".\n+function selectorToString(selector: Ref<k8s.LabelSelector>): string =\n+{\n+    var sel = deref(selector);\n+\tvar selSlice: Set<string> = set_empty();\n+\t// Append labels in matchLabels as \"key In [value]\".\n+\tfor (kv in sel.matchLabels) {\n+\t\tset_insert(selSlice, normalizeExpr(kv.0, k8s.LabelSelectorOpIn, vec_singleton(kv.1)))\n+\t};\n+\tfor (expr in sel.matchExpressions) {\n+\t\tmatch (expr.operator) {\n+\t\t    k8s.LabelSelectorOpIn -> {\n+\t\t\t    set_insert(selSlice, normalizeExpr(expr.reqkey, k8s.LabelSelectorOpIn, expr.values))\n+            },\n+\t\t    k8s.LabelSelectorOpNotIn -> {\n+                set_insert(selSlice, normalizeExpr(expr.reqkey, k8s.LabelSelectorOpNotIn, expr.values))\n+            },\n+\t\t    k8s.LabelSelectorOpExists -> {\n+                set_insert(selSlice, normalizeExpr(expr.reqkey, k8s.LabelSelectorOpExists, vec_empty()))\n+            },\n+\t\t    k8s.LabelSelectorOpDoesNotExist -> {\n+\t\t\t    set_insert(selSlice, normalizeExpr(expr.reqkey, k8s.LabelSelectorOpDoesNotExist, vec_empty()))\n+            }\n+\t\t}\n+\t};\n+\tstring_join(set2vec(selSlice), \" And \")\n+}\n+\n+// A namespace selector is either a namespace name (or \"\")\n+// or a namespace label selector.\n+typedef NSSelector = NSSelectorNS{ns: string}\n+                   | NSSelectorLS{selector: Ref<k8s.LabelSelector>}\n+\n+// GroupSelector describes how to select pods.\n+typedef GroupSelector = GroupSelector {\n+\t// The normalized name is calculated from Namespace, PodSelector, and NamespaceSelector.\n+\t// If multiple policies have same selectors, they should share this group by comparing NormalizedName.\n+\t// It's also used to generate Name and UUID of group.\n+\tnormalizedName: string,\n+\t// Only pods from these namespaces will be matched.\n+\tnsSelector: NSSelector,\n+\t// This is a label selector which selects pods. If Namespace is also set, it selects the pods in the namespace.\n+\t// If NamespaceSelector is also set, it selects the pods in the namespaces selected by NamespaceSelector.\n+    podSelector: Option<Ref<k8s.LabelSelector>>\n+}\n+\n+// generateNormalizedName generates a string, based on the selectors, in\n+// the following format: \"namespace=NamespaceName And podSelector=normalizedPodSelector\".\n+// Note: Namespace and nsSelector may or may not be set depending on the\n+// selector. However, they cannot be set simultaneously.\n+function generateNormalizedName(nsSelector: NSSelector, podSelector: Option<Ref<k8s.LabelSelector>>): string =\n+{\n+\tvar normalizedName: Set<string> = set_empty();\n+\tmatch (nsSelector) {\n+        NSSelectorLS{ls} -> {\n+            set_insert(normalizedName, \"namespaceSelector=${selectorToString(ls)}\")\n+        },\n+        NSSelectorNS{ns} -> {\n+            if (ns != \"\") {\n+\t\t        set_insert(normalizedName, \"namespace=${ns}\")\n+            }\n+        }\n+    };\n+\tmatch (podSelector) {\n+        Some{ls} -> set_insert(normalizedName, \"podSelector=${selectorToString(ls)}\"),\n+        _ -> ()\n+\t};\n+\tstring_join(set2vec(normalizedName), \" And \")\n+}\n+\n+// toGroupSelector converts the podSelector and namespaceSelector\n+// and NetworkPolicy Namespace to a networkpolicy.GroupSelector object.\n+function toGroupSelector(namespace: string,\n+                         podSelector: Option<Ref<k8s.LabelSelector>>,\n+                         nsLabelSelector: Option<Ref<k8s.LabelSelector>>): GroupSelector =\n+{\n+    var nsSelector = match (nsLabelSelector) {\n+        // No namespaceSelector indicates that the pods must be selected within\n+        // the NetworkPolicy's Namespace.\n+        None            -> NSSelectorNS{namespace},\n+        Some{selector}  -> NSSelectorLS{selector}\n+    };\n+\tGroupSelector {\n+        .normalizedName = generateNormalizedName(nsSelector, podSelector),\n+\t\t.podSelector    = podSelector,\n+        .nsSelector     = nsSelector\n+    }\n+}\n+\n+// PodSet is a set of Pod references.\n+typedef PodSet = Set<k8s.PodReference>\n+\n+typedef Direction = DirectionIn\n+                  | DirectionOut\n+\n+// NetworkPolicyPeer describes a peer of NetworkPolicyRules.\n+// It could be a list of names of AddressGroups and/or a list of IPBlock.\n+typedef NetworkPolicyPeer = NetworkPolicyPeer {\n+\t// A list of names of AddressGroups.\n+\taddressGroups: Vec<string>,\n+\t// A list of IPBlock.\n+\tipBlocks: Vec<IPBlock>\n+}\n+\n+function networkPolicyPeerEmpty(): NetworkPolicyPeer =\n+{\n+    NetworkPolicyPeer {\n+        .addressGroups = vec_empty(),\n+        .ipBlocks = vec_empty()\n+    }\n+}\n+\n+// matchAllPeer is a NetworkPolicyPeer matching all source/destination IP addresses.\n+function matchAllPeer(): NetworkPolicyPeer =\n+{\n+    NetworkPolicyPeer {\n+        .addressGroups = vec_empty(),\n+\t    .ipBlocks      = vec_singleton(IPBlock{\n+            .cidr = IPNet {\n+                .ip             = ipv4zero(),\n+                .prefixLength   = 32'sd0\n+            },\n+            .except = vec_empty(): Vec<IPNet>\n+        })\n+    }\n+}\n+\n+typedef IPAddress = IPAddress{addr: Vec<bit<8>>}\n+\n+function ipv4zero(): IPAddress = {\n+    ipv4(0, 0, 0, 0)\n+}\n+\n+function ipv4(a: bit<8>, b: bit<8>, c: bit<8>, d: bit<8>): IPAddress =\n+{\n+    var bytes: Vec<bit<8>> = vec_with_length(12, 8'd0);\n+    vec_push(bytes, a);\n+    vec_push(bytes, b);\n+    vec_push(bytes, c);\n+    vec_push(bytes, d);\n+    IPAddress{bytes}\n+}\n+\n+// IPNet describes an IP network.\n+typedef IPNet = IPNet {\n+\tip:             IPAddress,\n+\tprefixLength:   signed<32>\n+}\n+\n+// TODO\n+function parseIP(s: string): Vec<bit<8>> = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "11822990ea93d6fce22fc4ea9cbe06866e163b44"}, "originalPosition": 178}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dc549a6798f63ebd7ba2ed0721e6c6b39750842a", "author": {"user": {"login": "ryzhyk", "name": "Leonid Ryzhyk"}}, "url": "https://github.com/vmware/differential-datalog/commit/dc549a6798f63ebd7ba2ed0721e6c6b39750842a", "committedDate": "2020-02-05T06:28:20Z", "message": "std.dl: New std lib functions + Result type.\n\n// Returns the value stored in Some or def if x==None.\nfunction option_unwrap_or(x: Option<'A>, def: 'A): 'A\n\n// Create a vector populated with len copies of x.\nextern function vec_with_length(len: bit<64>, x: 'A): Vec<'A>\n\n// Append other to v.\nextern function vec_append(v: mut Vec<'X>, other: Vec<'X>): ()\n\nResult<'V,'E> = Ok{'V} | Err{'E}"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "94cd211fc67233e716b80e16646005efeb3c19f7", "author": {"user": {"login": "ryzhyk", "name": "Leonid Ryzhyk"}}, "url": "https://github.com/vmware/differential-datalog/commit/94cd211fc67233e716b80e16646005efeb3c19f7", "committedDate": "2020-02-05T06:28:35Z", "message": "Validate.hs: Bug in exprInjectStringConversions.\n\nFixes a bug in the code that generates the name of the default string conversion\nfunction for a type.  The name of the function is the name of the type\nwith the first characted converted to lower case.  However, if the type\nis inside a module, we must be careful to apply lower case conversion to\nthe first character of the actual type name, not the module name prefix."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e78e57120c801afd4132271315da5d3eb8b8e6d7", "author": {"user": {"login": "ryzhyk", "name": "Leonid Ryzhyk"}}, "url": "https://github.com/vmware/differential-datalog/commit/e78e57120c801afd4132271315da5d3eb8b8e6d7", "committedDate": "2020-02-05T06:28:35Z", "message": "NS.hs: Allow read access to vars in loop expression.\n\nWe used to disallow referencing variables in the loop iterator\nexpression inside the body of a loop, i.e., in the following statement,\n`body` cannot refer to any of the variables used in `expr`:\n\n`for (<x> in <expr>) {<body>}`\n\nThis seems overly restrictive.  Rust (and common sense) disallow\nmodifying these variables, as they are read-borrowed inside the loop;\nhowever I don't see why reading should be a problem.  Unfortunately,\nI did not document the reason for the restriction, so not sure if there\never was one.  The worst thing that can happen is that the generated\nRust code won't compile."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fc19f7f11b0fe9629d2cf6e2459c86d76103216b", "author": {"user": {"login": "ryzhyk", "name": "Leonid Ryzhyk"}}, "url": "https://github.com/vmware/differential-datalog/commit/fc19f7f11b0fe9629d2cf6e2459c86d76103216b", "committedDate": "2020-02-05T06:31:11Z", "message": "break, continue, and return statements.\n\n`break` and `continue` can be used anywhere inside a loop.\n`return` can be used anywhere inside the body of a function."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a2bf1a2b0d68bf992bb48c5d933180445eb206d1", "author": {"user": {"login": "ryzhyk", "name": "Leonid Ryzhyk"}}, "url": "https://github.com/vmware/differential-datalog/commit/a2bf1a2b0d68bf992bb48c5d933180445eb206d1", "committedDate": "2020-02-05T06:31:11Z", "message": "DDlog port of Antrea controller (incomplete).\n\nInitial implementation of Antrea controller logic in DDlog:\nhttps://github.com/vmware-tanzu/antrea/blob/master/pkg/controller/networkpolicy/networkpolicy_controller.go\n\nThere are several todos in the code, and we only test that the code\ncompiles, not that it does anything useful."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7ef8b748f6ca275c559494e2c5bf99f92c5fe1fe", "author": {"user": {"login": "ryzhyk", "name": "Leonid Ryzhyk"}}, "url": "https://github.com/vmware/differential-datalog/commit/7ef8b748f6ca275c559494e2c5bf99f92c5fe1fe", "committedDate": "2020-02-05T06:31:11Z", "message": "Upgrade minimal supported rustc version to 1.39.\n\nThe latest flatbuffers crate relies on features that are unstable as of\nrust 1.36."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c0d305e645a89d2e96cd16f77653008a9149cded", "author": {"user": {"login": "ryzhyk", "name": "Leonid Ryzhyk"}}, "url": "https://github.com/vmware/differential-datalog/commit/c0d305e645a89d2e96cd16f77653008a9149cded", "committedDate": "2020-02-05T06:31:11Z", "message": "Fix parglare version in Dockerfile."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7d044b54479c7c756bb16389a2afb7979fd6efc9", "author": {"user": {"login": "ryzhyk", "name": "Leonid Ryzhyk"}}, "url": "https://github.com/vmware/differential-datalog/commit/7d044b54479c7c756bb16389a2afb7979fd6efc9", "committedDate": "2020-02-05T06:31:11Z", "message": "FlatBuffer.hs: Bug progTypesToSerialize.\n\nThe `progTypesToSerialize` method returns all types for which FlatBuffer\nschema must be generated.  This includes (recursively) all types used in\nrelations and indexes.  Since `Ref<T>` and `IObj<T>` types are transparent\nto FlatBuffers, we should strip them out, replacing them with simply\n`T`, in addition to performing usual normalization.  However, we only\napplied this unwrapping to the outer type declaration, not its type\narguments.\n\nAfter fixing the above issue, I realized that the old behavior was\n(accidentally) what we want for Rust binding generation, where we want\nto genetatr `From/ToFlatBuffer` implementation for all original types\nwith `Ref<>` and `IObj` wrappers.  So we now have to separate functions:\n`progTypesToSerialize` and `progRustTypesToSerialize`, where the second\nmethod implement the original behavior."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "11822990ea93d6fce22fc4ea9cbe06866e163b44", "author": {"user": {"login": "ryzhyk", "name": "Leonid Ryzhyk"}}, "url": "https://github.com/vmware/differential-datalog/commit/11822990ea93d6fce22fc4ea9cbe06866e163b44", "committedDate": "2020-02-04T02:41:40Z", "message": "FlatBuffer.hs: Bug progTypesToSerialize.\n\nThe `progTypesToSerialize` method returns all types for which FlatBuffer\nschema must be generated.  This includes (recursively) all types used in\nrelations and indexes.  Since `Ref<T>` and `IObj<T>` types are transparent\nto FlatBuffers, we should strip them out, replacing them with simply\n`T`, in addition to performing usual normalization.  However, we only\napplied this unwrapping to the outer type declaration, not its type\narguments.\n\nAfter fixing the above issue, I realized that the old behavior was\n(accidentally) what we want for Rust binding generation, where we want\nto genetatr `From/ToFlatBuffer` implementation for all original types\nwith `Ref<>` and `IObj` wrappers.  So we now have to separate functions:\n`progTypesToSerialize` and `progRustTypesToSerialize`, where the second\nmethod implement the original behavior."}, "afterCommit": {"oid": "7d044b54479c7c756bb16389a2afb7979fd6efc9", "author": {"user": {"login": "ryzhyk", "name": "Leonid Ryzhyk"}}, "url": "https://github.com/vmware/differential-datalog/commit/7d044b54479c7c756bb16389a2afb7979fd6efc9", "committedDate": "2020-02-05T06:31:11Z", "message": "FlatBuffer.hs: Bug progTypesToSerialize.\n\nThe `progTypesToSerialize` method returns all types for which FlatBuffer\nschema must be generated.  This includes (recursively) all types used in\nrelations and indexes.  Since `Ref<T>` and `IObj<T>` types are transparent\nto FlatBuffers, we should strip them out, replacing them with simply\n`T`, in addition to performing usual normalization.  However, we only\napplied this unwrapping to the outer type declaration, not its type\narguments.\n\nAfter fixing the above issue, I realized that the old behavior was\n(accidentally) what we want for Rust binding generation, where we want\nto genetatr `From/ToFlatBuffer` implementation for all original types\nwith `Ref<>` and `IObj` wrappers.  So we now have to separate functions:\n`progTypesToSerialize` and `progRustTypesToSerialize`, where the second\nmethod implement the original behavior."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4628, "cost": 1, "resetAt": "2021-11-02T10:47:05Z"}}}