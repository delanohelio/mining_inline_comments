{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIyNDg2OTk1", "number": 677, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQwMjozODowMlrOD_gTKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQwMjo0MTowN1rOD_gUgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3OTE2MDc1OnYy", "diffSide": "RIGHT", "path": "src/Language/DifferentialDatalog/Attribute.hs", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQwMjozODowMlrOGaM8Ig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxNDo1Mjo0OFrOGaiE5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDEyODE2Mg==", "bodyText": "it would be nice if the signature of this implementation was documented someplace.", "url": "https://github.com/vmware/differential-datalog/pull/677#discussion_r430128162", "createdAt": "2020-05-26T02:38:02Z", "author": {"login": "mbudiu-vmw"}, "path": "src/Language/DifferentialDatalog/Attribute.hs", "diffHunk": "@@ -157,6 +164,23 @@ tdefGetCustomSerdeAttr d tdef =\n          Left e  -> error e\n          Right b -> b\n \n+{- 'custom_from_record' attribute: Tells DDlog not to generate `FromRecord`\n+ - implementation for a type.  The user must write their own implementations in", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3619726f603f1ecb4439bf0b256d64107d23e3e3"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDQ3NDQ3MA==", "bodyText": "I don't think users should be writing these annotations. This is an ugly workaround for the OVSDB problem that I could not solve properly without a major type system overhaul.", "url": "https://github.com/vmware/differential-datalog/pull/677#discussion_r430474470", "createdAt": "2020-05-26T14:52:48Z", "author": {"login": "ryzhyk"}, "path": "src/Language/DifferentialDatalog/Attribute.hs", "diffHunk": "@@ -157,6 +164,23 @@ tdefGetCustomSerdeAttr d tdef =\n          Left e  -> error e\n          Right b -> b\n \n+{- 'custom_from_record' attribute: Tells DDlog not to generate `FromRecord`\n+ - implementation for a type.  The user must write their own implementations in", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDEyODE2Mg=="}, "originalCommit": {"oid": "3619726f603f1ecb4439bf0b256d64107d23e3e3"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3OTE2MTcxOnYy", "diffSide": "RIGHT", "path": "lib/std.dl", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQwMjozOTowN1rOGaM82Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQwMjozOTowN1rOGaM82Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDEyODM0NQ==", "bodyText": "I would add here a comment indicating what this means: the implementation must be given in the corresponding rust file, and it must have two functions with some signatures.", "url": "https://github.com/vmware/differential-datalog/pull/677#discussion_r430128345", "createdAt": "2020-05-26T02:39:07Z", "author": {"login": "mbudiu-vmw"}, "path": "lib/std.dl", "diffHunk": "@@ -80,6 +80,7 @@ extern function pow32(base:'A, exp: bit<32>): 'A\n  */\n \n #[rust=\"serde(from=\\\"Option<A>\\\", into=\\\"Option<A>\\\", bound(serialize=\\\"A: Clone+Serialize\\\"))\"]\n+#[custom_from_record]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3619726f603f1ecb4439bf0b256d64107d23e3e3"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3OTE2Mjc1OnYy", "diffSide": "RIGHT", "path": "lib/std.rs", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQwMjo0MDowN1rOGaM9hQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQwMjo0MDowN1rOGaM9hQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDEyODUxNw==", "bodyText": "it's in fact trickier, because the implementation has to know about this Record type. So then that has to be documented someplace.", "url": "https://github.com/vmware/differential-datalog/pull/677#discussion_r430128517", "createdAt": "2020-05-26T02:40:07Z", "author": {"login": "mbudiu-vmw"}, "path": "lib/std.rs", "diffHunk": "@@ -145,6 +145,62 @@ impl<T> From<std_Option<T>> for Option<T> {\n     }\n }\n \n+impl<A: record::FromRecord + serde::de::DeserializeOwned + Default> record::FromRecord\n+    for std_Option<A>\n+{\n+    fn from_record(val: &record::Record) -> result::Result<Self, String> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3619726f603f1ecb4439bf0b256d64107d23e3e3"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3OTE2NDE3OnYy", "diffSide": "RIGHT", "path": "lib/std.rs", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQwMjo0MTowN1rOGaM-VQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxNDo1NDowOFrOGaiIqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDEyODcyNQ==", "bodyText": "what about other collections?", "url": "https://github.com/vmware/differential-datalog/pull/677#discussion_r430128725", "createdAt": "2020-05-26T02:41:07Z", "author": {"login": "mbudiu-vmw"}, "path": "lib/std.rs", "diffHunk": "@@ -145,6 +145,62 @@ impl<T> From<std_Option<T>> for Option<T> {\n     }\n }\n \n+impl<A: record::FromRecord + serde::de::DeserializeOwned + Default> record::FromRecord\n+    for std_Option<A>\n+{\n+    fn from_record(val: &record::Record) -> result::Result<Self, String> {\n+        match val {\n+            record::Record::PosStruct(constr, args) => match constr.as_ref() {\n+                \"std.None\" if args.len() == 0 => Ok(std_Option::std_None {}),\n+                \"std.Some\" if args.len() == 1 => Ok(std_Option::std_Some {\n+                    x: <A>::from_record(&args[0])?,\n+                }),\n+                c => result::Result::Err(format!(\n+                    \"unknown constructor {} of type std_Option in {:?}\",\n+                    c, *val\n+                )),\n+            },\n+            record::Record::NamedStruct(constr, args) => match constr.as_ref() {\n+                \"std.None\" => Ok(std_Option::std_None {}),\n+                \"std.Some\" => Ok(std_Option::std_Some {\n+                    x: record::arg_extract::<A>(args, \"x\")?,\n+                }),\n+                c => result::Result::Err(format!(\n+                    \"unknown constructor {} of type std_Option in {:?}\",\n+                    c, *val\n+                )),\n+            },\n+            /* `Option` encoded as an array of size 0 or 1.  This is, for instance, useful when\n+             * interfacing with OVSDB. */\n+            record::Record::Array(kind, records) => match (records.len()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3619726f603f1ecb4439bf0b256d64107d23e3e3"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDQ3NTQzNA==", "bodyText": "sets, maps, etc., are extern types and already have their own manual implementations of FromRecord that support arrays.", "url": "https://github.com/vmware/differential-datalog/pull/677#discussion_r430475434", "createdAt": "2020-05-26T14:54:08Z", "author": {"login": "ryzhyk"}, "path": "lib/std.rs", "diffHunk": "@@ -145,6 +145,62 @@ impl<T> From<std_Option<T>> for Option<T> {\n     }\n }\n \n+impl<A: record::FromRecord + serde::de::DeserializeOwned + Default> record::FromRecord\n+    for std_Option<A>\n+{\n+    fn from_record(val: &record::Record) -> result::Result<Self, String> {\n+        match val {\n+            record::Record::PosStruct(constr, args) => match constr.as_ref() {\n+                \"std.None\" if args.len() == 0 => Ok(std_Option::std_None {}),\n+                \"std.Some\" if args.len() == 1 => Ok(std_Option::std_Some {\n+                    x: <A>::from_record(&args[0])?,\n+                }),\n+                c => result::Result::Err(format!(\n+                    \"unknown constructor {} of type std_Option in {:?}\",\n+                    c, *val\n+                )),\n+            },\n+            record::Record::NamedStruct(constr, args) => match constr.as_ref() {\n+                \"std.None\" => Ok(std_Option::std_None {}),\n+                \"std.Some\" => Ok(std_Option::std_Some {\n+                    x: record::arg_extract::<A>(args, \"x\")?,\n+                }),\n+                c => result::Result::Err(format!(\n+                    \"unknown constructor {} of type std_Option in {:?}\",\n+                    c, *val\n+                )),\n+            },\n+            /* `Option` encoded as an array of size 0 or 1.  This is, for instance, useful when\n+             * interfacing with OVSDB. */\n+            record::Record::Array(kind, records) => match (records.len()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDEyODcyNQ=="}, "originalCommit": {"oid": "3619726f603f1ecb4439bf0b256d64107d23e3e3"}, "originalPosition": 31}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4759, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}