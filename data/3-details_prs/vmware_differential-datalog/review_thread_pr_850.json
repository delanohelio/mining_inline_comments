{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM0ODQxOTc5", "number": 850, "reviewThreads": {"totalCount": 26, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwMjoxNzoxMVrOFCsWTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxODo1MDo0MFrOFDFSPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4MzY4MDc2OnYy", "diffSide": "RIGHT", "path": "lib/ddlog_std.dl", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwMjoxNzoxMVrOIB_EoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxODo1NjoyNVrOICkZaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk1Mjg2NQ==", "bodyText": "what's wrong with this function? If you don't want it, why not just delete it?", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r538952865", "createdAt": "2020-12-09T02:17:11Z", "author": {"login": "mbudiu-vmw"}, "path": "lib/ddlog_std.dl", "diffHunk": "@@ -291,7 +288,7 @@ function map_err(res: Result<'V, 'E1>, f: function('E1): 'E2): Result<'V, 'E2> {\n  * Range; all values starting at 'from' and ending at 'to'\n  * inclusively, in steps of 'step'.  'step' must be positive.\n  */\n-extern function range(from: 'A, to: 'A, step: 'A): Vec<'A>\n+//extern function range(from: 'A, to: 'A, step: 'A): Vec<'A>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "342ea2391a8c483c2aa391afbc1b004627e7be62"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU2NDM5NQ==", "bodyText": "DDlog no longer allows unimplemented extern functions (as it reexports them in the Rust API, which does not compile if the function isn't actually there).  Some time ago we decided to keep it there to make it explicit that it is now deprecated. I can remove it.", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r539564395", "createdAt": "2020-12-09T18:56:25Z", "author": {"login": "ryzhyk"}, "path": "lib/ddlog_std.dl", "diffHunk": "@@ -291,7 +288,7 @@ function map_err(res: Result<'V, 'E1>, f: function('E1): 'E2): Result<'V, 'E2> {\n  * Range; all values starting at 'from' and ending at 'to'\n  * inclusively, in steps of 'step'.  'step' must be positive.\n  */\n-extern function range(from: 'A, to: 'A, step: 'A): Vec<'A>\n+//extern function range(from: 'A, to: 'A, step: 'A): Vec<'A>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk1Mjg2NQ=="}, "originalCommit": {"oid": "342ea2391a8c483c2aa391afbc1b004627e7be62"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4MzY4MjQ2OnYy", "diffSide": "LEFT", "path": "lib/ddlog_std.dl", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwMjoxNzo0OFrOIB_FhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxODo1OTozMVrOICkhdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk1MzA5Mg==", "bodyText": "this one isn't useful?", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r538953092", "createdAt": "2020-12-09T02:17:48Z", "author": {"login": "mbudiu-vmw"}, "path": "lib/ddlog_std.dl", "diffHunk": "@@ -806,7 +803,6 @@ extern function vec_push_imm(v: Vec<'X>, x: 'X): Vec<'X>\n extern function vec_contains(v: Vec<'X>, x: 'X): bool\n extern function vec_is_empty(v: Vec<'X>): bool\n extern function vec_nth(v: Vec<'X>, n: usize): Option<'X>\n-extern function vec_set_nth(v: Vec<'X>, n: usize, value: 'X)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "342ea2391a8c483c2aa391afbc1b004627e7be62"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU2NjQ1NQ==", "bodyText": "I think it lacked the implementation and shouldn't have been there in the first place. There's  a vec_update_nth.", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r539566455", "createdAt": "2020-12-09T18:59:31Z", "author": {"login": "ryzhyk"}, "path": "lib/ddlog_std.dl", "diffHunk": "@@ -806,7 +803,6 @@ extern function vec_push_imm(v: Vec<'X>, x: 'X): Vec<'X>\n extern function vec_contains(v: Vec<'X>, x: 'X): bool\n extern function vec_is_empty(v: Vec<'X>): bool\n extern function vec_nth(v: Vec<'X>, n: usize): Option<'X>\n-extern function vec_set_nth(v: Vec<'X>, n: usize, value: 'X)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk1MzA5Mg=="}, "originalCommit": {"oid": "342ea2391a8c483c2aa391afbc1b004627e7be62"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4MzY4OTE2OnYy", "diffSide": "RIGHT", "path": "lib/internment.flatbuf.rs", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwMjoyMDoxNlrOIB_JGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwMjoyMDoxNlrOIB_JGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk1NDAwOQ==", "bodyText": "delete?", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r538954009", "createdAt": "2020-12-09T02:20:16Z", "author": {"login": "mbudiu-vmw"}, "path": "lib/internment.flatbuf.rs", "diffHunk": "@@ -0,0 +1,54 @@\n+impl<A, FB> FromFlatBuffer<FB> for internment::Intern<A>\n+where\n+    A: Eq + std::hash::Hash + Send + Sync + 'static,\n+    A: FromFlatBuffer<FB>,\n+{\n+    fn from_flatbuf(fb: FB) -> Result<Self, String> {\n+        Ok(internment::Intern::new(A::from_flatbuf(fb)?))\n+    }\n+}\n+\n+impl<'b, A, T> ToFlatBuffer<'b> for internment::Intern<A>\n+where\n+    T: 'b,\n+    A: Eq + Send + Sync + std::hash::Hash + ToFlatBuffer<'b, Target = T>,\n+{\n+    type Target = T;\n+\n+    fn to_flatbuf(&self, fbb: &mut fbrt::FlatBufferBuilder<'b>) -> Self::Target {\n+        self.as_ref().to_flatbuf(fbb)\n+    }\n+}\n+\n+/*#[cfg(feature = \"flatbuf\")]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "342ea2391a8c483c2aa391afbc1b004627e7be62"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4MzcyNDExOnYy", "diffSide": "RIGHT", "path": "src/Language/DifferentialDatalog/Compile.hs", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwMjozMzoxMVrOIB_b1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwMjozMzoxMVrOIB_b1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk1ODgwNg==", "bodyText": "delete?", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r538958806", "createdAt": "2020-12-09T02:33:11Z", "author": {"login": "mbudiu-vmw"}, "path": "src/Language/DifferentialDatalog/Compile.hs", "diffHunk": "@@ -369,36 +398,42 @@ emptyCompilerState = CompilerState {\n rnameFlat :: String -> Doc\n rnameFlat = pp . replace \"::\" \"_\"\n \n--- Types and functions are stored in Rust modules that mirror the DDlog\n--- module hierarchy.\n--- 'local' is true iff the name is being used in the same crate where it was\n--- declared, i.e., the 'types' crate.\n-rnameScoped :: Bool -> String -> Doc\n-rnameScoped local n = rnameScoped' (if local then \"crate\" else \"::types\") n\n-\n-rnameScoped' :: String -> String -> Doc\n-rnameScoped' scope n = pp scope <> \"::\" <> pp n\n+-- Types, functions, rules, etc., are stored in Rust modules that mirror the DDlog\n+-- module hierarchy.  This function generates a qualified Rust identifier (e.g.,\n+-- 'crate_name::module_name::name') that refers to entity whose fully qualified\n+-- DDlog identifier is 'n'.\n+-- 'local_module' - module accessing the identifier or 'Nothing' if it's accessed\n+-- from an external crate.\n+-- 'n' - fully qualified DDlog identifier\n+rnameScoped :: (?crate_graph::CrateGraph, ?specname::String) => Maybe ModuleName -> String -> Doc\n+rnameScoped local_module n =\n+    ridentScoped local_module (nameScope n) (nameLocalStr n)\n+\n+-- Generate a qualified Rust identifier that refers to variable 'n' declared in\n+-- 'target_module' from 'local_module'.\n+ridentScoped :: (?crate_graph::CrateGraph, ?specname::String) => Maybe ModuleName -> ModuleName -> String -> Doc\n+ridentScoped Nothing target_module n =\n+    pp $ intercalate \"::\" $ absolutePath target_module ++ [n]\n+ridentScoped (Just local_module) target_module n =\n+    pp $ intercalate \"::\" $ relativePath local_module target_module ++ [n]\n \n mkRelEnum :: DatalogProgram -> Doc\n mkRelEnum d =\n-    \"#[derive(Copy,Clone,Debug,PartialEq,Eq,Hash)]\"                                                                                       $$\n-    \"pub enum Relations {\"                                                                                                                $$\n-    (nest' $ vcat $ punctuate comma $ map (\\rel -> rnameFlat (name rel) <+> \"=\" <+> pp (relIdentifier d rel)) $ M.elems $ progRelations d)    $$\n+    \"#[derive(Copy,Clone,Debug,PartialEq,Eq,Hash)]\"                                                                                        $$\n+    \"pub enum Relations {\"                                                                                                                 $$\n+    (nest' $ vcat $ punctuate comma $ map (\\rel -> rnameFlat (name rel) <+> \"=\" <+> pp (relIdentifier d rel)) $ M.elems $ progRelations d) $$\n     \"}\"\n \n mkIdxEnum :: DatalogProgram -> Doc\n mkIdxEnum d =\n     \"#[derive(Copy,Clone,Debug,PartialEq,Eq,Hash)]\"                                                                                       $$\n     \"pub enum Indexes {\"                                                                                                                  $$\n-    (nest' $ vcat $ punctuate comma $ map (\\idx -> rnameFlat (name idx) <+> \"=\" <+> pp (idxIdentifier d idx)) $ M.elems $ progIndexes d)      $$\n+    (nest' $ vcat $ punctuate comma $ map (\\idx -> rnameFlat (name idx) <+> \"=\" <+> pp (idxIdentifier d idx)) $ M.elems $ progIndexes d)  $$\n     \"}\"\n \n-relId :: String -> Doc\n-relId rel = \"Relations::\" <> rnameFlat rel <+> \"as RelId\"\n-\n--- t must be normalized\n-addType :: Type -> CompilerMonad ()\n-addType t = modify $ \\s -> s{cTypes = S.insert t $ cTypes s}\n+relId :: DatalogProgram -> String -> Doc\n+--relId rel = \"Relations::\" <> rnameFlat rel <+> \"as RelId\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "342ea2391a8c483c2aa391afbc1b004627e7be62"}, "originalPosition": 292}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4MzczMzQyOnYy", "diffSide": "RIGHT", "path": "src/Language/DifferentialDatalog/Compile.hs", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwMjozNjo0MlrOIB_gug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxOTowMjoxN1rOICkowQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk2MDA1OA==", "bodyText": "2018?", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r538960058", "createdAt": "2020-12-09T02:36:42Z", "author": {"login": "mbudiu-vmw"}, "path": "src/Language/DifferentialDatalog/Compile.hs", "diffHunk": "@@ -568,87 +601,316 @@ compile d_unoptimized specname modules rs_code toml_code dir crate_types = do\n                         ++ \"members = [\\n\"\n                         ++ \"    \\\"cmd_parser\\\",\\n\"\n                         ++ \"    \\\"differential_datalog\\\",\\n\"\n-                        ++ \"    \\\"distributed_datalog\\\",\\n\"\n                         ++ \"    \\\"ovsdb\\\",\\n\"\n-                        ++ \"    \\\"types\\\",\\n\"\n                         ++ \"]\\n\"\n                 )\n-    updateFile (dir </> rustProjectDir specname </> \"Cargo.toml\")       (render $ mainCargo specname crate_types toml_footer)\n-    updateFile (dir </> rustProjectDir specname </> \"src/lib.rs\")       (render main)\n+    updateFile (dir </> rustProjectDir </> \"Cargo.toml\")       (render $ mainCargo rs_code crate_types toml_footer)\n+    updateFile (dir </> rustProjectDir </> \"src/lib.rs\")       (render main)\n     return ()\n \n--- | Compile Datalog program into Rust code.\n---\n--- Returns Rust code for three crates:\n--- * 'types' crate containing DDlog type declarations, functions, and all imported\n---   Rust library code.\n--- * 'value' crate that declares relations and value types.\n--- * 'main' crate that contains rule definitions in Rust and imports the other two.\n---\n-compileLib :: (?cfg::Config) => DatalogProgram -> String -> [DatalogModule] -> M.Map ModuleName Doc -> (M.Map ModuleName Doc, Doc)\n-compileLib d specname modules rs_code = (typeLib, mainLib)\n+\n+compileLib :: (?cfg::Config, ?specname::String, ?crate_graph::CrateGraph, ?modules::[DatalogModule]) => DatalogProgram -> M.Map ModuleName (Doc, Doc, Doc) -> (M.Map FilePath Doc, Doc)\n+compileLib d rs_code =\n+    (crates, main_lib)\n     where\n-    modules' = addMissingModules modules\n     statics = collectStatics d\n-    -- Start with empty modules, except the main module that contains static declarations.\n-    typeLib0 = M.fromList $ map (\\m -> if moduleName m == mainModuleName\n-                                       then (moduleName m, typesLibHeader specname $+$ mkStatics d statics)\n-                                       else (moduleName m, typesModuleHeader specname)) modules'\n-    -- Add submodule lists.\n-    typeLibMods = M.mapWithKey (\\mname mtext ->\n-                                 let children = filter (\\other_mod -> other_mod `moduleIsChildOf` mname)\n-                                                $ map moduleName modules'\n-                                 in mtext $+$ vcat (map (\\(ModuleName c) -> \"pub mod\" <+> pp (last c) <> \";\") children))\n-                               typeLib0\n-    -- Add Rust code.\n-    typeLibRs = foldl' (\\libs (mname, rs) -> M.adjust ($+$ rs) mname libs) typeLibMods $ M.toList rs_code\n-    -- Add typedefs\n-    typeLibTdefs = foldl' (\\libs tdef -> M.adjust ($+$ mkTypedef d tdef) (nameScope tdef) libs) typeLibRs $ progTypedefs d\n-    -- Add functions\n-    typeLibExternFuncs = let ?statics = statics in\n-                         foldl' (\\libs func -> M.adjust ($+$ mkFunc d func) (nameScope func) libs) typeLibTdefs fextern\n-    typeLibAllFuncs = let ?statics = statics in\n-                       foldl' (\\libs func -> M.adjust ($+$ mkFunc d func) (nameScope func) libs) typeLibExternFuncs fdef\n-    -- Add 'DDValConvert' impls to 'types' crate.\n-    -- Since multiple DDlog types can map to the same Rust type, we convert\n-    -- types to Rust and fold over the resulting set.\n-    typeLib = S.foldl (\\libs _ -> M.adjust ($+$ \"\") mainModuleName libs) typeLibAllFuncs\n-                      $ S.map (render . mkType d True) $ S.filter (typeNeedsDDValConvert d) $ cTypes cstate\n-    mainLib = mainHeader specname           $+$\n-              mkUpdateDeserializer d        $+$\n-              mkDDValueFromRecord d         $+$ -- Function to convert cmd_parser::Record to Value\n-              mkIndexesIntoArrId d cstate   $+$\n-              mkRelEnum d                   $+$ -- 'enum Relations'\n-              mkIdxEnum d                   $+$ -- 'enum Indexes'\n-              prog\n+    -- First pass: Compile DDlog rules, generate arrangements.\n+    (nodes, cstate) = compileRules d statics\n+    -- Second pass: Populate Rust crates with compiled code in `nodes`.\n+    crates = M.unions $ map (compileCrate d statics nodes rs_code) $ cgCrates ?crate_graph\n+    -- Generate the main library file.\n+    main_lib = compileMainLib d nodes cstate\n+\n+compileRules :: (?cfg::Config, ?specname::String, ?modules::[DatalogModule], ?crate_graph::CrateGraph) => DatalogProgram -> Statics -> ([ProgNode], CompilerState)\n+compileRules d statics =\n+    runState (do -- First pass: compute arrangements\n+                 createArrangements d\n+                 -- Second pass: compile relations\n+                 mapIdxM (\\scc i -> compileSCC d statics depgraph i scc) sccs)\n+             $ emptyCompilerState { cArrangements = arrs }\n+    where\n     -- Compute ordered SCCs of the dependency graph.  These will define the\n     -- structure of the program.\n     depgraph = progDependencyGraph d\n     sccs = G.topsort' $ G.condensation depgraph\n     -- Initialize arrangements map\n     arrs = M.fromList $ map (, []) $ M.keys $ progRelations d\n-    -- Initialize types\n-    -- Make sure that empty tuple is always in Value, so it can be\n-    -- used to implement Value::default()\n-    types = S.fromList $ (tTuple []) : (map (typeNormalize d . relType) $ M.elems $ progRelations d)\n-    -- Compile SCCs\n-    (prog, cstate) = let ?statics = statics in\n-                     runState (do -- First pass: compute arrangements\n-                                  createArrangements d\n-                                  -- Second pass: compile relations\n-                                  nodes <- mapM (compileSCC d depgraph) sccs\n-                                  mkProg nodes)\n-                              $ emptyCompilerState { cArrangements = arrs\n-                                                   , cTypes        = types }\n-    -- Functions\n-    (fdef, fextern) = partition (isJust . funcDef) $ concat $ M.elems $ progFunctions d\n+\n+compileCrate :: (?cfg::Config, ?specname::String, ?crate_graph::CrateGraph, ?modules::[DatalogModule])\n+    => DatalogProgram -> Statics -> [ProgNode] -> M.Map ModuleName (Doc, Doc, Doc) -> Crate -> M.Map FilePath Doc\n+compileCrate d statics nodes rs_code crate =\n+    M.fromList $ toml:modules\n+    where\n+    -- Generate 'Cargo.toml'.\n+    toml = mkCargoToml rs_code crate\n+    -- Generate individual modules.\n+    modules = map (compileModule d statics nodes rs_code crate) $ S.toList crate\n+\n+mkCargoToml :: (?cfg::Config, ?specname::String, ?crate_graph::CrateGraph, ?modules::[DatalogModule])\n+    => M.Map ModuleName (Doc, Doc, Doc) -> Crate -> (FilePath, Doc)\n+mkCargoToml rs_code crate =\n+    (filepath, code)\n+    where\n+    filepath = \"types\" </> (crateDirPath crate) </> \"Cargo.toml\"\n+    code = \"[package]\"                                                                     $$\n+           \"name = \\\"\" <> pp crate_name <> \"\\\"\"                                            $$\n+           \"version = \\\"0.1.0\\\"\"                                                           $$\n+           \"edition = \\\"2018\\\"\"                                                            $$", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "342ea2391a8c483c2aa391afbc1b004627e7be62"}, "originalPosition": 519}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU2ODMyMQ==", "bodyText": "Yes, we are on the 2018 Rust edition, which is currently the latest.", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r539568321", "createdAt": "2020-12-09T19:02:17Z", "author": {"login": "ryzhyk"}, "path": "src/Language/DifferentialDatalog/Compile.hs", "diffHunk": "@@ -568,87 +601,316 @@ compile d_unoptimized specname modules rs_code toml_code dir crate_types = do\n                         ++ \"members = [\\n\"\n                         ++ \"    \\\"cmd_parser\\\",\\n\"\n                         ++ \"    \\\"differential_datalog\\\",\\n\"\n-                        ++ \"    \\\"distributed_datalog\\\",\\n\"\n                         ++ \"    \\\"ovsdb\\\",\\n\"\n-                        ++ \"    \\\"types\\\",\\n\"\n                         ++ \"]\\n\"\n                 )\n-    updateFile (dir </> rustProjectDir specname </> \"Cargo.toml\")       (render $ mainCargo specname crate_types toml_footer)\n-    updateFile (dir </> rustProjectDir specname </> \"src/lib.rs\")       (render main)\n+    updateFile (dir </> rustProjectDir </> \"Cargo.toml\")       (render $ mainCargo rs_code crate_types toml_footer)\n+    updateFile (dir </> rustProjectDir </> \"src/lib.rs\")       (render main)\n     return ()\n \n--- | Compile Datalog program into Rust code.\n---\n--- Returns Rust code for three crates:\n--- * 'types' crate containing DDlog type declarations, functions, and all imported\n---   Rust library code.\n--- * 'value' crate that declares relations and value types.\n--- * 'main' crate that contains rule definitions in Rust and imports the other two.\n---\n-compileLib :: (?cfg::Config) => DatalogProgram -> String -> [DatalogModule] -> M.Map ModuleName Doc -> (M.Map ModuleName Doc, Doc)\n-compileLib d specname modules rs_code = (typeLib, mainLib)\n+\n+compileLib :: (?cfg::Config, ?specname::String, ?crate_graph::CrateGraph, ?modules::[DatalogModule]) => DatalogProgram -> M.Map ModuleName (Doc, Doc, Doc) -> (M.Map FilePath Doc, Doc)\n+compileLib d rs_code =\n+    (crates, main_lib)\n     where\n-    modules' = addMissingModules modules\n     statics = collectStatics d\n-    -- Start with empty modules, except the main module that contains static declarations.\n-    typeLib0 = M.fromList $ map (\\m -> if moduleName m == mainModuleName\n-                                       then (moduleName m, typesLibHeader specname $+$ mkStatics d statics)\n-                                       else (moduleName m, typesModuleHeader specname)) modules'\n-    -- Add submodule lists.\n-    typeLibMods = M.mapWithKey (\\mname mtext ->\n-                                 let children = filter (\\other_mod -> other_mod `moduleIsChildOf` mname)\n-                                                $ map moduleName modules'\n-                                 in mtext $+$ vcat (map (\\(ModuleName c) -> \"pub mod\" <+> pp (last c) <> \";\") children))\n-                               typeLib0\n-    -- Add Rust code.\n-    typeLibRs = foldl' (\\libs (mname, rs) -> M.adjust ($+$ rs) mname libs) typeLibMods $ M.toList rs_code\n-    -- Add typedefs\n-    typeLibTdefs = foldl' (\\libs tdef -> M.adjust ($+$ mkTypedef d tdef) (nameScope tdef) libs) typeLibRs $ progTypedefs d\n-    -- Add functions\n-    typeLibExternFuncs = let ?statics = statics in\n-                         foldl' (\\libs func -> M.adjust ($+$ mkFunc d func) (nameScope func) libs) typeLibTdefs fextern\n-    typeLibAllFuncs = let ?statics = statics in\n-                       foldl' (\\libs func -> M.adjust ($+$ mkFunc d func) (nameScope func) libs) typeLibExternFuncs fdef\n-    -- Add 'DDValConvert' impls to 'types' crate.\n-    -- Since multiple DDlog types can map to the same Rust type, we convert\n-    -- types to Rust and fold over the resulting set.\n-    typeLib = S.foldl (\\libs _ -> M.adjust ($+$ \"\") mainModuleName libs) typeLibAllFuncs\n-                      $ S.map (render . mkType d True) $ S.filter (typeNeedsDDValConvert d) $ cTypes cstate\n-    mainLib = mainHeader specname           $+$\n-              mkUpdateDeserializer d        $+$\n-              mkDDValueFromRecord d         $+$ -- Function to convert cmd_parser::Record to Value\n-              mkIndexesIntoArrId d cstate   $+$\n-              mkRelEnum d                   $+$ -- 'enum Relations'\n-              mkIdxEnum d                   $+$ -- 'enum Indexes'\n-              prog\n+    -- First pass: Compile DDlog rules, generate arrangements.\n+    (nodes, cstate) = compileRules d statics\n+    -- Second pass: Populate Rust crates with compiled code in `nodes`.\n+    crates = M.unions $ map (compileCrate d statics nodes rs_code) $ cgCrates ?crate_graph\n+    -- Generate the main library file.\n+    main_lib = compileMainLib d nodes cstate\n+\n+compileRules :: (?cfg::Config, ?specname::String, ?modules::[DatalogModule], ?crate_graph::CrateGraph) => DatalogProgram -> Statics -> ([ProgNode], CompilerState)\n+compileRules d statics =\n+    runState (do -- First pass: compute arrangements\n+                 createArrangements d\n+                 -- Second pass: compile relations\n+                 mapIdxM (\\scc i -> compileSCC d statics depgraph i scc) sccs)\n+             $ emptyCompilerState { cArrangements = arrs }\n+    where\n     -- Compute ordered SCCs of the dependency graph.  These will define the\n     -- structure of the program.\n     depgraph = progDependencyGraph d\n     sccs = G.topsort' $ G.condensation depgraph\n     -- Initialize arrangements map\n     arrs = M.fromList $ map (, []) $ M.keys $ progRelations d\n-    -- Initialize types\n-    -- Make sure that empty tuple is always in Value, so it can be\n-    -- used to implement Value::default()\n-    types = S.fromList $ (tTuple []) : (map (typeNormalize d . relType) $ M.elems $ progRelations d)\n-    -- Compile SCCs\n-    (prog, cstate) = let ?statics = statics in\n-                     runState (do -- First pass: compute arrangements\n-                                  createArrangements d\n-                                  -- Second pass: compile relations\n-                                  nodes <- mapM (compileSCC d depgraph) sccs\n-                                  mkProg nodes)\n-                              $ emptyCompilerState { cArrangements = arrs\n-                                                   , cTypes        = types }\n-    -- Functions\n-    (fdef, fextern) = partition (isJust . funcDef) $ concat $ M.elems $ progFunctions d\n+\n+compileCrate :: (?cfg::Config, ?specname::String, ?crate_graph::CrateGraph, ?modules::[DatalogModule])\n+    => DatalogProgram -> Statics -> [ProgNode] -> M.Map ModuleName (Doc, Doc, Doc) -> Crate -> M.Map FilePath Doc\n+compileCrate d statics nodes rs_code crate =\n+    M.fromList $ toml:modules\n+    where\n+    -- Generate 'Cargo.toml'.\n+    toml = mkCargoToml rs_code crate\n+    -- Generate individual modules.\n+    modules = map (compileModule d statics nodes rs_code crate) $ S.toList crate\n+\n+mkCargoToml :: (?cfg::Config, ?specname::String, ?crate_graph::CrateGraph, ?modules::[DatalogModule])\n+    => M.Map ModuleName (Doc, Doc, Doc) -> Crate -> (FilePath, Doc)\n+mkCargoToml rs_code crate =\n+    (filepath, code)\n+    where\n+    filepath = \"types\" </> (crateDirPath crate) </> \"Cargo.toml\"\n+    code = \"[package]\"                                                                     $$\n+           \"name = \\\"\" <> pp crate_name <> \"\\\"\"                                            $$\n+           \"version = \\\"0.1.0\\\"\"                                                           $$\n+           \"edition = \\\"2018\\\"\"                                                            $$", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk2MDA1OA=="}, "originalCommit": {"oid": "342ea2391a8c483c2aa391afbc1b004627e7be62"}, "originalPosition": 519}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4MzczNjYyOnYy", "diffSide": "RIGHT", "path": "src/Language/DifferentialDatalog/Compile.hs", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwMjozNzo1MVrOIB_iag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxOTowMzozOFrOICksDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk2MDQ5MA==", "bodyText": "shouldn't this be actually concatenated from some file rather than be here inline?", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r538960490", "createdAt": "2020-12-09T02:37:51Z", "author": {"login": "mbudiu-vmw"}, "path": "src/Language/DifferentialDatalog/Compile.hs", "diffHunk": "@@ -568,87 +601,316 @@ compile d_unoptimized specname modules rs_code toml_code dir crate_types = do\n                         ++ \"members = [\\n\"\n                         ++ \"    \\\"cmd_parser\\\",\\n\"\n                         ++ \"    \\\"differential_datalog\\\",\\n\"\n-                        ++ \"    \\\"distributed_datalog\\\",\\n\"\n                         ++ \"    \\\"ovsdb\\\",\\n\"\n-                        ++ \"    \\\"types\\\",\\n\"\n                         ++ \"]\\n\"\n                 )\n-    updateFile (dir </> rustProjectDir specname </> \"Cargo.toml\")       (render $ mainCargo specname crate_types toml_footer)\n-    updateFile (dir </> rustProjectDir specname </> \"src/lib.rs\")       (render main)\n+    updateFile (dir </> rustProjectDir </> \"Cargo.toml\")       (render $ mainCargo rs_code crate_types toml_footer)\n+    updateFile (dir </> rustProjectDir </> \"src/lib.rs\")       (render main)\n     return ()\n \n--- | Compile Datalog program into Rust code.\n---\n--- Returns Rust code for three crates:\n--- * 'types' crate containing DDlog type declarations, functions, and all imported\n---   Rust library code.\n--- * 'value' crate that declares relations and value types.\n--- * 'main' crate that contains rule definitions in Rust and imports the other two.\n---\n-compileLib :: (?cfg::Config) => DatalogProgram -> String -> [DatalogModule] -> M.Map ModuleName Doc -> (M.Map ModuleName Doc, Doc)\n-compileLib d specname modules rs_code = (typeLib, mainLib)\n+\n+compileLib :: (?cfg::Config, ?specname::String, ?crate_graph::CrateGraph, ?modules::[DatalogModule]) => DatalogProgram -> M.Map ModuleName (Doc, Doc, Doc) -> (M.Map FilePath Doc, Doc)\n+compileLib d rs_code =\n+    (crates, main_lib)\n     where\n-    modules' = addMissingModules modules\n     statics = collectStatics d\n-    -- Start with empty modules, except the main module that contains static declarations.\n-    typeLib0 = M.fromList $ map (\\m -> if moduleName m == mainModuleName\n-                                       then (moduleName m, typesLibHeader specname $+$ mkStatics d statics)\n-                                       else (moduleName m, typesModuleHeader specname)) modules'\n-    -- Add submodule lists.\n-    typeLibMods = M.mapWithKey (\\mname mtext ->\n-                                 let children = filter (\\other_mod -> other_mod `moduleIsChildOf` mname)\n-                                                $ map moduleName modules'\n-                                 in mtext $+$ vcat (map (\\(ModuleName c) -> \"pub mod\" <+> pp (last c) <> \";\") children))\n-                               typeLib0\n-    -- Add Rust code.\n-    typeLibRs = foldl' (\\libs (mname, rs) -> M.adjust ($+$ rs) mname libs) typeLibMods $ M.toList rs_code\n-    -- Add typedefs\n-    typeLibTdefs = foldl' (\\libs tdef -> M.adjust ($+$ mkTypedef d tdef) (nameScope tdef) libs) typeLibRs $ progTypedefs d\n-    -- Add functions\n-    typeLibExternFuncs = let ?statics = statics in\n-                         foldl' (\\libs func -> M.adjust ($+$ mkFunc d func) (nameScope func) libs) typeLibTdefs fextern\n-    typeLibAllFuncs = let ?statics = statics in\n-                       foldl' (\\libs func -> M.adjust ($+$ mkFunc d func) (nameScope func) libs) typeLibExternFuncs fdef\n-    -- Add 'DDValConvert' impls to 'types' crate.\n-    -- Since multiple DDlog types can map to the same Rust type, we convert\n-    -- types to Rust and fold over the resulting set.\n-    typeLib = S.foldl (\\libs _ -> M.adjust ($+$ \"\") mainModuleName libs) typeLibAllFuncs\n-                      $ S.map (render . mkType d True) $ S.filter (typeNeedsDDValConvert d) $ cTypes cstate\n-    mainLib = mainHeader specname           $+$\n-              mkUpdateDeserializer d        $+$\n-              mkDDValueFromRecord d         $+$ -- Function to convert cmd_parser::Record to Value\n-              mkIndexesIntoArrId d cstate   $+$\n-              mkRelEnum d                   $+$ -- 'enum Relations'\n-              mkIdxEnum d                   $+$ -- 'enum Indexes'\n-              prog\n+    -- First pass: Compile DDlog rules, generate arrangements.\n+    (nodes, cstate) = compileRules d statics\n+    -- Second pass: Populate Rust crates with compiled code in `nodes`.\n+    crates = M.unions $ map (compileCrate d statics nodes rs_code) $ cgCrates ?crate_graph\n+    -- Generate the main library file.\n+    main_lib = compileMainLib d nodes cstate\n+\n+compileRules :: (?cfg::Config, ?specname::String, ?modules::[DatalogModule], ?crate_graph::CrateGraph) => DatalogProgram -> Statics -> ([ProgNode], CompilerState)\n+compileRules d statics =\n+    runState (do -- First pass: compute arrangements\n+                 createArrangements d\n+                 -- Second pass: compile relations\n+                 mapIdxM (\\scc i -> compileSCC d statics depgraph i scc) sccs)\n+             $ emptyCompilerState { cArrangements = arrs }\n+    where\n     -- Compute ordered SCCs of the dependency graph.  These will define the\n     -- structure of the program.\n     depgraph = progDependencyGraph d\n     sccs = G.topsort' $ G.condensation depgraph\n     -- Initialize arrangements map\n     arrs = M.fromList $ map (, []) $ M.keys $ progRelations d\n-    -- Initialize types\n-    -- Make sure that empty tuple is always in Value, so it can be\n-    -- used to implement Value::default()\n-    types = S.fromList $ (tTuple []) : (map (typeNormalize d . relType) $ M.elems $ progRelations d)\n-    -- Compile SCCs\n-    (prog, cstate) = let ?statics = statics in\n-                     runState (do -- First pass: compute arrangements\n-                                  createArrangements d\n-                                  -- Second pass: compile relations\n-                                  nodes <- mapM (compileSCC d depgraph) sccs\n-                                  mkProg nodes)\n-                              $ emptyCompilerState { cArrangements = arrs\n-                                                   , cTypes        = types }\n-    -- Functions\n-    (fdef, fextern) = partition (isJust . funcDef) $ concat $ M.elems $ progFunctions d\n+\n+compileCrate :: (?cfg::Config, ?specname::String, ?crate_graph::CrateGraph, ?modules::[DatalogModule])\n+    => DatalogProgram -> Statics -> [ProgNode] -> M.Map ModuleName (Doc, Doc, Doc) -> Crate -> M.Map FilePath Doc\n+compileCrate d statics nodes rs_code crate =\n+    M.fromList $ toml:modules\n+    where\n+    -- Generate 'Cargo.toml'.\n+    toml = mkCargoToml rs_code crate\n+    -- Generate individual modules.\n+    modules = map (compileModule d statics nodes rs_code crate) $ S.toList crate\n+\n+mkCargoToml :: (?cfg::Config, ?specname::String, ?crate_graph::CrateGraph, ?modules::[DatalogModule])\n+    => M.Map ModuleName (Doc, Doc, Doc) -> Crate -> (FilePath, Doc)\n+mkCargoToml rs_code crate =\n+    (filepath, code)\n+    where\n+    filepath = \"types\" </> (crateDirPath crate) </> \"Cargo.toml\"\n+    code = \"[package]\"                                                                     $$\n+           \"name = \\\"\" <> pp crate_name <> \"\\\"\"                                            $$\n+           \"version = \\\"0.1.0\\\"\"                                                           $$\n+           \"edition = \\\"2018\\\"\"                                                            $$\n+           \"\"                                                                              $$\n+           \"[features]\"                                                                    $$", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "342ea2391a8c483c2aa391afbc1b004627e7be62"}, "originalPosition": 521}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU2OTE2NQ==", "bodyText": "Problem is, this is a function of the output of the crate decomposition algorithm and must be generated.", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r539569165", "createdAt": "2020-12-09T19:03:38Z", "author": {"login": "ryzhyk"}, "path": "src/Language/DifferentialDatalog/Compile.hs", "diffHunk": "@@ -568,87 +601,316 @@ compile d_unoptimized specname modules rs_code toml_code dir crate_types = do\n                         ++ \"members = [\\n\"\n                         ++ \"    \\\"cmd_parser\\\",\\n\"\n                         ++ \"    \\\"differential_datalog\\\",\\n\"\n-                        ++ \"    \\\"distributed_datalog\\\",\\n\"\n                         ++ \"    \\\"ovsdb\\\",\\n\"\n-                        ++ \"    \\\"types\\\",\\n\"\n                         ++ \"]\\n\"\n                 )\n-    updateFile (dir </> rustProjectDir specname </> \"Cargo.toml\")       (render $ mainCargo specname crate_types toml_footer)\n-    updateFile (dir </> rustProjectDir specname </> \"src/lib.rs\")       (render main)\n+    updateFile (dir </> rustProjectDir </> \"Cargo.toml\")       (render $ mainCargo rs_code crate_types toml_footer)\n+    updateFile (dir </> rustProjectDir </> \"src/lib.rs\")       (render main)\n     return ()\n \n--- | Compile Datalog program into Rust code.\n---\n--- Returns Rust code for three crates:\n--- * 'types' crate containing DDlog type declarations, functions, and all imported\n---   Rust library code.\n--- * 'value' crate that declares relations and value types.\n--- * 'main' crate that contains rule definitions in Rust and imports the other two.\n---\n-compileLib :: (?cfg::Config) => DatalogProgram -> String -> [DatalogModule] -> M.Map ModuleName Doc -> (M.Map ModuleName Doc, Doc)\n-compileLib d specname modules rs_code = (typeLib, mainLib)\n+\n+compileLib :: (?cfg::Config, ?specname::String, ?crate_graph::CrateGraph, ?modules::[DatalogModule]) => DatalogProgram -> M.Map ModuleName (Doc, Doc, Doc) -> (M.Map FilePath Doc, Doc)\n+compileLib d rs_code =\n+    (crates, main_lib)\n     where\n-    modules' = addMissingModules modules\n     statics = collectStatics d\n-    -- Start with empty modules, except the main module that contains static declarations.\n-    typeLib0 = M.fromList $ map (\\m -> if moduleName m == mainModuleName\n-                                       then (moduleName m, typesLibHeader specname $+$ mkStatics d statics)\n-                                       else (moduleName m, typesModuleHeader specname)) modules'\n-    -- Add submodule lists.\n-    typeLibMods = M.mapWithKey (\\mname mtext ->\n-                                 let children = filter (\\other_mod -> other_mod `moduleIsChildOf` mname)\n-                                                $ map moduleName modules'\n-                                 in mtext $+$ vcat (map (\\(ModuleName c) -> \"pub mod\" <+> pp (last c) <> \";\") children))\n-                               typeLib0\n-    -- Add Rust code.\n-    typeLibRs = foldl' (\\libs (mname, rs) -> M.adjust ($+$ rs) mname libs) typeLibMods $ M.toList rs_code\n-    -- Add typedefs\n-    typeLibTdefs = foldl' (\\libs tdef -> M.adjust ($+$ mkTypedef d tdef) (nameScope tdef) libs) typeLibRs $ progTypedefs d\n-    -- Add functions\n-    typeLibExternFuncs = let ?statics = statics in\n-                         foldl' (\\libs func -> M.adjust ($+$ mkFunc d func) (nameScope func) libs) typeLibTdefs fextern\n-    typeLibAllFuncs = let ?statics = statics in\n-                       foldl' (\\libs func -> M.adjust ($+$ mkFunc d func) (nameScope func) libs) typeLibExternFuncs fdef\n-    -- Add 'DDValConvert' impls to 'types' crate.\n-    -- Since multiple DDlog types can map to the same Rust type, we convert\n-    -- types to Rust and fold over the resulting set.\n-    typeLib = S.foldl (\\libs _ -> M.adjust ($+$ \"\") mainModuleName libs) typeLibAllFuncs\n-                      $ S.map (render . mkType d True) $ S.filter (typeNeedsDDValConvert d) $ cTypes cstate\n-    mainLib = mainHeader specname           $+$\n-              mkUpdateDeserializer d        $+$\n-              mkDDValueFromRecord d         $+$ -- Function to convert cmd_parser::Record to Value\n-              mkIndexesIntoArrId d cstate   $+$\n-              mkRelEnum d                   $+$ -- 'enum Relations'\n-              mkIdxEnum d                   $+$ -- 'enum Indexes'\n-              prog\n+    -- First pass: Compile DDlog rules, generate arrangements.\n+    (nodes, cstate) = compileRules d statics\n+    -- Second pass: Populate Rust crates with compiled code in `nodes`.\n+    crates = M.unions $ map (compileCrate d statics nodes rs_code) $ cgCrates ?crate_graph\n+    -- Generate the main library file.\n+    main_lib = compileMainLib d nodes cstate\n+\n+compileRules :: (?cfg::Config, ?specname::String, ?modules::[DatalogModule], ?crate_graph::CrateGraph) => DatalogProgram -> Statics -> ([ProgNode], CompilerState)\n+compileRules d statics =\n+    runState (do -- First pass: compute arrangements\n+                 createArrangements d\n+                 -- Second pass: compile relations\n+                 mapIdxM (\\scc i -> compileSCC d statics depgraph i scc) sccs)\n+             $ emptyCompilerState { cArrangements = arrs }\n+    where\n     -- Compute ordered SCCs of the dependency graph.  These will define the\n     -- structure of the program.\n     depgraph = progDependencyGraph d\n     sccs = G.topsort' $ G.condensation depgraph\n     -- Initialize arrangements map\n     arrs = M.fromList $ map (, []) $ M.keys $ progRelations d\n-    -- Initialize types\n-    -- Make sure that empty tuple is always in Value, so it can be\n-    -- used to implement Value::default()\n-    types = S.fromList $ (tTuple []) : (map (typeNormalize d . relType) $ M.elems $ progRelations d)\n-    -- Compile SCCs\n-    (prog, cstate) = let ?statics = statics in\n-                     runState (do -- First pass: compute arrangements\n-                                  createArrangements d\n-                                  -- Second pass: compile relations\n-                                  nodes <- mapM (compileSCC d depgraph) sccs\n-                                  mkProg nodes)\n-                              $ emptyCompilerState { cArrangements = arrs\n-                                                   , cTypes        = types }\n-    -- Functions\n-    (fdef, fextern) = partition (isJust . funcDef) $ concat $ M.elems $ progFunctions d\n+\n+compileCrate :: (?cfg::Config, ?specname::String, ?crate_graph::CrateGraph, ?modules::[DatalogModule])\n+    => DatalogProgram -> Statics -> [ProgNode] -> M.Map ModuleName (Doc, Doc, Doc) -> Crate -> M.Map FilePath Doc\n+compileCrate d statics nodes rs_code crate =\n+    M.fromList $ toml:modules\n+    where\n+    -- Generate 'Cargo.toml'.\n+    toml = mkCargoToml rs_code crate\n+    -- Generate individual modules.\n+    modules = map (compileModule d statics nodes rs_code crate) $ S.toList crate\n+\n+mkCargoToml :: (?cfg::Config, ?specname::String, ?crate_graph::CrateGraph, ?modules::[DatalogModule])\n+    => M.Map ModuleName (Doc, Doc, Doc) -> Crate -> (FilePath, Doc)\n+mkCargoToml rs_code crate =\n+    (filepath, code)\n+    where\n+    filepath = \"types\" </> (crateDirPath crate) </> \"Cargo.toml\"\n+    code = \"[package]\"                                                                     $$\n+           \"name = \\\"\" <> pp crate_name <> \"\\\"\"                                            $$\n+           \"version = \\\"0.1.0\\\"\"                                                           $$\n+           \"edition = \\\"2018\\\"\"                                                            $$\n+           \"\"                                                                              $$\n+           \"[features]\"                                                                    $$", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk2MDQ5MA=="}, "originalCommit": {"oid": "342ea2391a8c483c2aa391afbc1b004627e7be62"}, "originalPosition": 521}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4Mzc0NDczOnYy", "diffSide": "RIGHT", "path": "src/Language/DifferentialDatalog/Compile.hs", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwMjo0MToyNFrOIB_m8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwMjo0MToyNFrOIB_m8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk2MTY0OA==", "bodyText": "how about this? is it needed?", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r538961648", "createdAt": "2020-12-09T02:41:24Z", "author": {"login": "mbudiu-vmw"}, "path": "src/Language/DifferentialDatalog/Compile.hs", "diffHunk": "@@ -658,6 +920,7 @@ mkUpdateDeserializer d =\n -- on the other hand is strict in this sense.  This function injects\n -- intermediate empty modules before generating Rust code to keep the Rust\n -- compiler happy.\n+{-", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "342ea2391a8c483c2aa391afbc1b004627e7be62"}, "originalPosition": 784}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NjUxNzY3OnYy", "diffSide": "RIGHT", "path": "lib/ddlog_bigint.rs", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxNDo0ODo0NVrOICYbJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxNzoxNDozMFrOICf-JA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM2ODIyOQ==", "bodyText": "I'd probably just stick to naming these functions in snake case, e.g. from_uint() even though it's not the exact name of the type", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r539368229", "createdAt": "2020-12-09T14:48:45Z", "author": {"login": "Kixiron"}, "path": "lib/ddlog_bigint.rs", "diffHunk": "@@ -69,7 +73,7 @@ impl Int {\n     pub fn from_i128(v: i128) -> Int {\n         Int { x: BigInt::from(v) }\n     }\n-    pub fn from_Uint(v: uint::Uint) -> Int {\n+    pub fn from_Uint(v: Uint) -> Int {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "342ea2391a8c483c2aa391afbc1b004627e7be62"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ5MTg3Ng==", "bodyText": "Turns out, we rely on from_<typename> functions in generated code. Sure, we could use something like to_snake_case, but I prefer to keep things simple.  I will add a comment before the impl block to clarify the choice of naming.", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r539491876", "createdAt": "2020-12-09T17:14:30Z", "author": {"login": "ryzhyk"}, "path": "lib/ddlog_bigint.rs", "diffHunk": "@@ -69,7 +73,7 @@ impl Int {\n     pub fn from_i128(v: i128) -> Int {\n         Int { x: BigInt::from(v) }\n     }\n-    pub fn from_Uint(v: uint::Uint) -> Int {\n+    pub fn from_Uint(v: Uint) -> Int {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM2ODIyOQ=="}, "originalCommit": {"oid": "342ea2391a8c483c2aa391afbc1b004627e7be62"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NjUyMzgzOnYy", "diffSide": "RIGHT", "path": "lib/ddlog_bigint.rs", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxNDo0OTozOVrOICYelA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxNDo0OTozOVrOICYelA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM2OTEwOA==", "bodyText": "I'd implement From<Uint> in addition to this", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r539369108", "createdAt": "2020-12-09T14:49:39Z", "author": {"login": "Kixiron"}, "path": "lib/ddlog_bigint.rs", "diffHunk": "@@ -69,7 +73,7 @@ impl Int {\n     pub fn from_i128(v: i128) -> Int {\n         Int { x: BigInt::from(v) }\n     }\n-    pub fn from_Uint(v: uint::Uint) -> Int {\n+    pub fn from_Uint(v: Uint) -> Int {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "342ea2391a8c483c2aa391afbc1b004627e7be62"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NjUzMjQyOnYy", "diffSide": "RIGHT", "path": "lib/allocate.rs", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxNDo1MToxNlrOICYj3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxNjo0OTo1NVrOICeyuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM3MDQ2MQ==", "bodyText": "A lot of paths throughout the ddlog modules are fully qualified, would simply importing them work?", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r539370461", "createdAt": "2020-12-09T14:51:16Z", "author": {"login": "Kixiron"}, "path": "lib/allocate.rs", "diffHunk": "@@ -3,11 +3,11 @@ use std::collections::BTreeSet;\n use std::ops;\n \n pub fn allocate<B: Ord + Clone, N: num::Num + ops::Add + cmp::Ord + Copy>(\n-    allocated: &crate::ddlog_std::Set<N>,\n-    toallocate: &crate::ddlog_std::Vec<B>,\n+    allocated: &ddlog_std::Set<N>,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "342ea2391a8c483c2aa391afbc1b004627e7be62"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ1MDE3OA==", "bodyText": "Thanks for reviewing, this is really valuable!\nAll Rust code, including libraries used to live in the same namespace.  Fortunately, this is no longer the case, so yes, at least as far as native library code goes, imports should work. I sometimes prefer qualified names, especially when the actual type or function name is too generic.  I noticed that you feel different about these things :)\nI'll fix this library as you suggest.  Overall, I feel that our native library code has been tortured to death by all the refactorings and looks terrible in many ways, including those identified in your review.", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r539450178", "createdAt": "2020-12-09T16:23:29Z", "author": {"login": "ryzhyk"}, "path": "lib/allocate.rs", "diffHunk": "@@ -3,11 +3,11 @@ use std::collections::BTreeSet;\n use std::ops;\n \n pub fn allocate<B: Ord + Clone, N: num::Num + ops::Add + cmp::Ord + Copy>(\n-    allocated: &crate::ddlog_std::Set<N>,\n-    toallocate: &crate::ddlog_std::Vec<B>,\n+    allocated: &ddlog_std::Set<N>,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM3MDQ2MQ=="}, "originalCommit": {"oid": "342ea2391a8c483c2aa391afbc1b004627e7be62"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ2NTA5NQ==", "bodyText": "I generally prefer importing things since it becomes nicer to work within, for overtly generic names (such as Vec) I'd just alias it to DDlogVec or something", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r539465095", "createdAt": "2020-12-09T16:40:58Z", "author": {"login": "Kixiron"}, "path": "lib/allocate.rs", "diffHunk": "@@ -3,11 +3,11 @@ use std::collections::BTreeSet;\n use std::ops;\n \n pub fn allocate<B: Ord + Clone, N: num::Num + ops::Add + cmp::Ord + Copy>(\n-    allocated: &crate::ddlog_std::Set<N>,\n-    toallocate: &crate::ddlog_std::Vec<B>,\n+    allocated: &ddlog_std::Set<N>,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM3MDQ2MQ=="}, "originalCommit": {"oid": "342ea2391a8c483c2aa391afbc1b004627e7be62"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ3MjU2OA==", "bodyText": "Heh, we can agree to disagree.  In case of our native libraries, though, any consistent style would be an improvement :)", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r539472568", "createdAt": "2020-12-09T16:49:55Z", "author": {"login": "ryzhyk"}, "path": "lib/allocate.rs", "diffHunk": "@@ -3,11 +3,11 @@ use std::collections::BTreeSet;\n use std::ops;\n \n pub fn allocate<B: Ord + Clone, N: num::Num + ops::Add + cmp::Ord + Copy>(\n-    allocated: &crate::ddlog_std::Set<N>,\n-    toallocate: &crate::ddlog_std::Vec<B>,\n+    allocated: &ddlog_std::Set<N>,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM3MDQ2MQ=="}, "originalCommit": {"oid": "342ea2391a8c483c2aa391afbc1b004627e7be62"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NjUzODE2OnYy", "diffSide": "RIGHT", "path": "lib/ddlog_bigint.rs", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxNDo1MjoxNVrOICYnag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxNjoyMToxN1rOICdT-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM3MTM3MA==", "bodyText": "Maybe put the c api under a module & feature gate to mirror the other c_api feature gated items", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r539371370", "createdAt": "2020-12-09T14:52:15Z", "author": {"login": "Kixiron"}, "path": "lib/ddlog_bigint.rs", "diffHunk": "@@ -323,3 +327,263 @@ impl num::Zero for Int {\n         self.x == BigInt::zero()\n     }\n }\n+\n+#[derive(Eq, PartialOrd, PartialEq, Ord, Clone, Hash)]\n+pub struct Uint {\n+    x: BigUint,\n+}\n+\n+impl Default for Uint {\n+    fn default() -> Uint {\n+        Uint {\n+            x: BigUint::default(),\n+        }\n+    }\n+}\n+\n+impl Abomonation for Uint {}\n+\n+impl Uint {\n+    pub fn from_biguint(v: BigUint) -> Uint {\n+        Uint { x: v }\n+    }\n+    pub fn from_bigint(v: BigInt) -> Uint {\n+        Uint {\n+            x: v.to_biguint().unwrap(),\n+        }\n+    }\n+    pub fn from_Int(v: Int) -> Uint {\n+        v.to_Uint().unwrap()\n+    }\n+    pub fn from_u8(v: u8) -> Uint {\n+        Uint {\n+            x: BigUint::from(v),\n+        }\n+    }\n+    pub fn from_u16(v: u16) -> Uint {\n+        Uint {\n+            x: BigUint::from(v),\n+        }\n+    }\n+    pub fn from_u32(v: u32) -> Uint {\n+        Uint {\n+            x: BigUint::from(v),\n+        }\n+    }\n+    pub fn from_u64(v: u64) -> Uint {\n+        Uint {\n+            x: BigUint::from(v),\n+        }\n+    }\n+    pub fn from_u128(v: u128) -> Uint {\n+        Uint {\n+            x: BigUint::from(v),\n+        }\n+    }\n+    pub fn from_bytes_be(bytes: &[u8]) -> Uint {\n+        Uint {\n+            x: BigUint::from_bytes_be(bytes),\n+        }\n+    }\n+    pub fn to_bytes_be(&self) -> Vec<u8> {\n+        self.x.to_bytes_be()\n+    }\n+    pub fn to_u8(&self) -> Option<u8> {\n+        self.x.to_u8()\n+    }\n+    pub fn to_u16(&self) -> Option<u16> {\n+        self.x.to_u16()\n+    }\n+    pub fn to_u32(&self) -> Option<u32> {\n+        self.x.to_u32()\n+    }\n+    pub fn to_u64(&self) -> Option<u64> {\n+        self.x.to_u64()\n+    }\n+    pub fn to_u128(&self) -> Option<u128> {\n+        self.x.to_u128()\n+    }\n+    pub fn to_Int(&self) -> Option<Int> {\n+        self.x.to_bigint().map(Int::from_bigint)\n+    }\n+    pub fn to_float(&self) -> OrderedFloat<f32> {\n+        match self.x.to_f32() {\n+            None => OrderedFloat::<f32>(std::f32::NAN),\n+            Some(x) => OrderedFloat::<f32>(x),\n+        }\n+    }\n+    pub fn to_double(&self) -> OrderedFloat<f64> {\n+        match self.x.to_f64() {\n+            None => OrderedFloat::<f64>(std::f64::NAN),\n+            Some(x) => OrderedFloat::<f64>(x),\n+        }\n+    }\n+    pub fn parse_bytes(buf: &[u8], radix: u32) -> Uint {\n+        Uint {\n+            x: BigUint::parse_bytes(buf, radix).unwrap(),\n+        }\n+    }\n+}\n+\n+#[no_mangle]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "342ea2391a8c483c2aa391afbc1b004627e7be62"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ0ODMxNA==", "bodyText": "Good idea!", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r539448314", "createdAt": "2020-12-09T16:21:17Z", "author": {"login": "ryzhyk"}, "path": "lib/ddlog_bigint.rs", "diffHunk": "@@ -323,3 +327,263 @@ impl num::Zero for Int {\n         self.x == BigInt::zero()\n     }\n }\n+\n+#[derive(Eq, PartialOrd, PartialEq, Ord, Clone, Hash)]\n+pub struct Uint {\n+    x: BigUint,\n+}\n+\n+impl Default for Uint {\n+    fn default() -> Uint {\n+        Uint {\n+            x: BigUint::default(),\n+        }\n+    }\n+}\n+\n+impl Abomonation for Uint {}\n+\n+impl Uint {\n+    pub fn from_biguint(v: BigUint) -> Uint {\n+        Uint { x: v }\n+    }\n+    pub fn from_bigint(v: BigInt) -> Uint {\n+        Uint {\n+            x: v.to_biguint().unwrap(),\n+        }\n+    }\n+    pub fn from_Int(v: Int) -> Uint {\n+        v.to_Uint().unwrap()\n+    }\n+    pub fn from_u8(v: u8) -> Uint {\n+        Uint {\n+            x: BigUint::from(v),\n+        }\n+    }\n+    pub fn from_u16(v: u16) -> Uint {\n+        Uint {\n+            x: BigUint::from(v),\n+        }\n+    }\n+    pub fn from_u32(v: u32) -> Uint {\n+        Uint {\n+            x: BigUint::from(v),\n+        }\n+    }\n+    pub fn from_u64(v: u64) -> Uint {\n+        Uint {\n+            x: BigUint::from(v),\n+        }\n+    }\n+    pub fn from_u128(v: u128) -> Uint {\n+        Uint {\n+            x: BigUint::from(v),\n+        }\n+    }\n+    pub fn from_bytes_be(bytes: &[u8]) -> Uint {\n+        Uint {\n+            x: BigUint::from_bytes_be(bytes),\n+        }\n+    }\n+    pub fn to_bytes_be(&self) -> Vec<u8> {\n+        self.x.to_bytes_be()\n+    }\n+    pub fn to_u8(&self) -> Option<u8> {\n+        self.x.to_u8()\n+    }\n+    pub fn to_u16(&self) -> Option<u16> {\n+        self.x.to_u16()\n+    }\n+    pub fn to_u32(&self) -> Option<u32> {\n+        self.x.to_u32()\n+    }\n+    pub fn to_u64(&self) -> Option<u64> {\n+        self.x.to_u64()\n+    }\n+    pub fn to_u128(&self) -> Option<u128> {\n+        self.x.to_u128()\n+    }\n+    pub fn to_Int(&self) -> Option<Int> {\n+        self.x.to_bigint().map(Int::from_bigint)\n+    }\n+    pub fn to_float(&self) -> OrderedFloat<f32> {\n+        match self.x.to_f32() {\n+            None => OrderedFloat::<f32>(std::f32::NAN),\n+            Some(x) => OrderedFloat::<f32>(x),\n+        }\n+    }\n+    pub fn to_double(&self) -> OrderedFloat<f64> {\n+        match self.x.to_f64() {\n+            None => OrderedFloat::<f64>(std::f64::NAN),\n+            Some(x) => OrderedFloat::<f64>(x),\n+        }\n+    }\n+    pub fn parse_bytes(buf: &[u8], radix: u32) -> Uint {\n+        Uint {\n+            x: BigUint::parse_bytes(buf, radix).unwrap(),\n+        }\n+    }\n+}\n+\n+#[no_mangle]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM3MTM3MA=="}, "originalCommit": {"oid": "342ea2391a8c483c2aa391afbc1b004627e7be62"}, "originalPosition": 181}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NjU0NzUzOnYy", "diffSide": "RIGHT", "path": "lib/ddlog_log.rs", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxNDo1Mzo1OVrOICYtYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxNjozNDowM1rOICd-Zw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM3Mjg5Nw==", "bodyText": "Tangential, but it would be nice to figure out a way to allow ddlog functions to take &str/&[T] over &String/&Vec<T> along with coped arguments", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r539372897", "createdAt": "2020-12-09T14:53:59Z", "author": {"login": "Kixiron"}, "path": "lib/ddlog_log.rs", "diffHunk": "@@ -32,6 +31,7 @@ static LOG_CONFIG: Lazy<sync::RwLock<LogConfig>> =\n \n /// Logging API exposed to the DDlog program.\n /// (see detailed documentation in `log.dl`)\n+#[allow(clippy::ptr_arg, clippy::trivially_copy_pass_by_ref)]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "342ea2391a8c483c2aa391afbc1b004627e7be62"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ1Mjc3Ng==", "bodyText": "This is probably doable at least for read-only function arguments, but will probably require changes to the code generator. Definitely not in this PR.", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r539452776", "createdAt": "2020-12-09T16:26:35Z", "author": {"login": "ryzhyk"}, "path": "lib/ddlog_log.rs", "diffHunk": "@@ -32,6 +31,7 @@ static LOG_CONFIG: Lazy<sync::RwLock<LogConfig>> =\n \n /// Logging API exposed to the DDlog program.\n /// (see detailed documentation in `log.dl`)\n+#[allow(clippy::ptr_arg, clippy::trivially_copy_pass_by_ref)]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM3Mjg5Nw=="}, "originalCommit": {"oid": "342ea2391a8c483c2aa391afbc1b004627e7be62"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ1OTE3NQ==", "bodyText": "Yes, that's definitely out of scope for this pr", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r539459175", "createdAt": "2020-12-09T16:34:03Z", "author": {"login": "Kixiron"}, "path": "lib/ddlog_log.rs", "diffHunk": "@@ -32,6 +31,7 @@ static LOG_CONFIG: Lazy<sync::RwLock<LogConfig>> =\n \n /// Logging API exposed to the DDlog program.\n /// (see detailed documentation in `log.dl`)\n+#[allow(clippy::ptr_arg, clippy::trivially_copy_pass_by_ref)]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM3Mjg5Nw=="}, "originalCommit": {"oid": "342ea2391a8c483c2aa391afbc1b004627e7be62"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NjU1NDI0OnYy", "diffSide": "RIGHT", "path": "lib/ddlog_rt.flatbuf.rs", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxNDo1NToxMlrOICYxhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxNDo1NToxMlrOICYxhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM3Mzk1Nw==", "bodyText": "Very minor style nit, but I'd probably put the trait bounds in a where clause", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r539373957", "createdAt": "2020-12-09T14:55:12Z", "author": {"login": "Kixiron"}, "path": "lib/ddlog_rt.flatbuf.rs", "diffHunk": "@@ -0,0 +1,47 @@\n+impl<'a, Args: 'static + Clone, Output: 'static + Clone> FromFlatBuffer<&'a str>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "342ea2391a8c483c2aa391afbc1b004627e7be62"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NjU2NDI1OnYy", "diffSide": "RIGHT", "path": "lib/ddlog_rt.rs", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxNDo1Njo1NFrOICY3gg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxNDo1Njo1NFrOICY3gg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM3NTQ5MA==", "bodyText": "I don't think this function is needed, any &String should automatically coerce into a &str unless there's a missing Deref implementation on ddlog strings", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r539375490", "createdAt": "2020-12-09T14:56:54Z", "author": {"login": "Kixiron"}, "path": "lib/ddlog_rt.rs", "diffHunk": "@@ -1,41 +1,102 @@\n-#![allow(clippy::trivially_copy_pass_by_ref)]\n-\n-//! Runtime support for DDlog closures.\n-\n-use ::std::cmp::Ordering;\n-use ::std::fmt::Debug;\n-use ::std::fmt::Display;\n-use ::std::fmt::Formatter;\n-use ::std::hash::Hash;\n-use ::std::hash::Hasher;\n-use ::std::result::Result;\n-\n-use ::serde::de::Error;\n-use ::serde::Deserialize;\n-use ::serde::Deserializer;\n-use ::serde::Serialize;\n-use ::serde::Serializer;\n-\n-use crate::Val;\n-\n-#[cfg(feature = \"flatbuf\")]\n-use flatbuffers as fbrt;\n+use std::cmp::Ordering;\n+use std::fmt::Debug;\n+use std::fmt::Display;\n+use std::fmt::Formatter;\n+use std::hash::Hash;\n+use std::hash::Hasher;\n+use std::result::Result;\n+\n+use serde::de::Error;\n+use serde::Deserializer;\n+use serde::Serializer;\n+\n+/* This module is designed to be imported both as a standard DDlog library and as a normal Rust\n+ * module, e.g., from `differential_datalog_test`.  We therefore need to import thit trait\n+ * so that it is available in the latter case and rename it so that it doesn't cause duplicate\n+ * import error in the former case. */\n+use differential_datalog::record::IntoRecord as IntoRec;\n+use differential_datalog::record::Record;\n+use ordered_float::OrderedFloat;\n+\n+use abomonation::Abomonation;\n+\n+/// All DDlog types are expected to implement this trait.  In particular, it is used as a type\n+/// bound on all type variables.\n+pub trait Val:\n+    Default\n+    + Eq\n+    + Ord\n+    + Clone\n+    + Hash\n+    + PartialEq\n+    + PartialOrd\n+    + serde::Serialize\n+    + ::serde::de::DeserializeOwned\n+    + 'static\n+{\n+}\n \n-#[cfg(feature = \"flatbuf\")]\n-use crate::flatbuf;\n+impl<T> Val for T where\n+    T: Default\n+        + Eq\n+        + Ord\n+        + Clone\n+        + Hash\n+        + PartialEq\n+        + PartialOrd\n+        + serde::Serialize\n+        + ::serde::de::DeserializeOwned\n+        + 'static\n+{\n+}\n \n-#[cfg(feature = \"flatbuf\")]\n-use crate::flatbuf::ToFlatBuffer;\n+/// Use in generated Rust code to implement string concatenation (`++`)\n+pub fn string_append_str(mut s1: String, s2: &str) -> String {\n+    s1.push_str(s2);\n+    s1\n+}\n \n-#[cfg(feature = \"flatbuf\")]\n-use crate::flatbuf::fb;\n+/// Use in generated Rust code to implement string concatenation (`++`)\n+#[allow(clippy::ptr_arg)]\n+pub fn string_append(mut s1: String, s2: &String) -> String {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "342ea2391a8c483c2aa391afbc1b004627e7be62"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NjU3MDI3OnYy", "diffSide": "RIGHT", "path": "lib/ddlog_rt.rs", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxNDo1Nzo1NFrOICY7Fg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxNDo1Nzo1NFrOICY7Fg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM3NjQwNg==", "bodyText": "An explanation on how to use the macro and its syntax would be helpful", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r539376406", "createdAt": "2020-12-09T14:57:54Z", "author": {"login": "Kixiron"}, "path": "lib/ddlog_rt.rs", "diffHunk": "@@ -1,41 +1,102 @@\n-#![allow(clippy::trivially_copy_pass_by_ref)]\n-\n-//! Runtime support for DDlog closures.\n-\n-use ::std::cmp::Ordering;\n-use ::std::fmt::Debug;\n-use ::std::fmt::Display;\n-use ::std::fmt::Formatter;\n-use ::std::hash::Hash;\n-use ::std::hash::Hasher;\n-use ::std::result::Result;\n-\n-use ::serde::de::Error;\n-use ::serde::Deserialize;\n-use ::serde::Deserializer;\n-use ::serde::Serialize;\n-use ::serde::Serializer;\n-\n-use crate::Val;\n-\n-#[cfg(feature = \"flatbuf\")]\n-use flatbuffers as fbrt;\n+use std::cmp::Ordering;\n+use std::fmt::Debug;\n+use std::fmt::Display;\n+use std::fmt::Formatter;\n+use std::hash::Hash;\n+use std::hash::Hasher;\n+use std::result::Result;\n+\n+use serde::de::Error;\n+use serde::Deserializer;\n+use serde::Serializer;\n+\n+/* This module is designed to be imported both as a standard DDlog library and as a normal Rust\n+ * module, e.g., from `differential_datalog_test`.  We therefore need to import thit trait\n+ * so that it is available in the latter case and rename it so that it doesn't cause duplicate\n+ * import error in the former case. */\n+use differential_datalog::record::IntoRecord as IntoRec;\n+use differential_datalog::record::Record;\n+use ordered_float::OrderedFloat;\n+\n+use abomonation::Abomonation;\n+\n+/// All DDlog types are expected to implement this trait.  In particular, it is used as a type\n+/// bound on all type variables.\n+pub trait Val:\n+    Default\n+    + Eq\n+    + Ord\n+    + Clone\n+    + Hash\n+    + PartialEq\n+    + PartialOrd\n+    + serde::Serialize\n+    + ::serde::de::DeserializeOwned\n+    + 'static\n+{\n+}\n \n-#[cfg(feature = \"flatbuf\")]\n-use crate::flatbuf;\n+impl<T> Val for T where\n+    T: Default\n+        + Eq\n+        + Ord\n+        + Clone\n+        + Hash\n+        + PartialEq\n+        + PartialOrd\n+        + serde::Serialize\n+        + ::serde::de::DeserializeOwned\n+        + 'static\n+{\n+}\n \n-#[cfg(feature = \"flatbuf\")]\n-use crate::flatbuf::ToFlatBuffer;\n+/// Use in generated Rust code to implement string concatenation (`++`)\n+pub fn string_append_str(mut s1: String, s2: &str) -> String {\n+    s1.push_str(s2);\n+    s1\n+}\n \n-#[cfg(feature = \"flatbuf\")]\n-use crate::flatbuf::fb;\n+/// Use in generated Rust code to implement string concatenation (`++`)\n+#[allow(clippy::ptr_arg)]\n+pub fn string_append(mut s1: String, s2: &String) -> String {\n+    s1.push_str(s2.as_str());\n+    s1\n+}\n \n-use ::differential_datalog::record::FromRecord;\n-use ::differential_datalog::record::IntoRecord;\n-use ::differential_datalog::record::Mutator;\n-use ::differential_datalog::record::Record;\n+/// Used to implement fields with `deserialize_from_array` attributed.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "342ea2391a8c483c2aa391afbc1b004627e7be62"}, "originalPosition": 98}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NjczNDMyOnYy", "diffSide": "RIGHT", "path": "lib/ddlog_rt.rs", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxNToyNzowOFrOICaemg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxNToyNzowOFrOICaemg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQwMTg4Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                use super::Closure;\n          \n          \n            \n                use super::ClosureImpl;\n          \n          \n            \n                use serde::Deserialize;\n          \n          \n            \n                use serde::Serialize;\n          \n          \n            \n                use super::{Closure, ClosureImpl};\n          \n          \n            \n                use serde::{Deserialize, Serialize};", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r539401882", "createdAt": "2020-12-09T15:27:08Z", "author": {"login": "Kixiron"}, "path": "lib/ddlog_rt.rs", "diffHunk": "@@ -275,65 +343,12 @@ impl<Args: 'static + Clone, Output: 'static + Clone> Abomonation\n     }\n }\n \n-#[cfg(feature = \"flatbuf\")]\n-impl<'a, Args: 'static + Clone, Output: 'static + Clone> flatbuf::FromFlatBuffer<&'a str>\n-    for Box<dyn Closure<Args, Output>>\n-{\n-    fn from_flatbuf(s: &'a str) -> Result<Self, String> {\n-        Err(format!(\"'from_flatbuf' not implemented for closures.\"))\n-    }\n-}\n-\n-#[cfg(feature = \"flatbuf\")]\n-impl<'a, Args: 'static + Clone, Output: 'static + Clone> flatbuf::FromFlatBuffer<fb::__String<'a>>\n-    for Box<dyn Closure<Args, Output>>\n-{\n-    fn from_flatbuf(v: fb::__String<'a>) -> Result<Self, String> {\n-        Err(format!(\"'from_flatbuf' not implemented for closures.\"))\n-    }\n-}\n-\n-#[cfg(feature = \"flatbuf\")]\n-impl<'b, Args: 'static + Clone, Output: 'static + Clone> ToFlatBuffer<'b>\n-    for Box<dyn Closure<Args, Output>>\n-{\n-    type Target = fbrt::WIPOffset<&'b str>;\n-    fn to_flatbuf(&self, fbb: &mut fbrt::FlatBufferBuilder<'b>) -> Self::Target {\n-        fbb.create_string(&format!(\"{}\", self))\n-    }\n-}\n-\n-#[cfg(feature = \"flatbuf\")]\n-impl<'b, Args: 'static + Clone, Output: 'static + Clone> flatbuf::ToFlatBufferTable<'b>\n-    for Box<dyn Closure<Args, Output>>\n-{\n-    type Target = fb::__String<'b>;\n-    fn to_flatbuf_table(\n-        &self,\n-        fbb: &mut fbrt::FlatBufferBuilder<'b>,\n-    ) -> fbrt::WIPOffset<Self::Target> {\n-        let v = self.to_flatbuf(fbb);\n-        fb::__String::create(fbb, &fb::__StringArgs { v: Some(v) })\n-    }\n-}\n-\n-#[cfg(feature = \"flatbuf\")]\n-impl<'b, Args: 'static + Clone, Output: 'static + Clone> flatbuf::ToFlatBufferVectorElement<'b>\n-    for Box<dyn Closure<Args, Output>>\n-{\n-    type Target = <Self as flatbuf::ToFlatBuffer<'b>>::Target;\n-\n-    fn to_flatbuf_vector_element(&self, fbb: &mut fbrt::FlatBufferBuilder<'b>) -> Self::Target {\n-        self.to_flatbuf(fbb)\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n-    use crate::closure::Closure;\n-    use crate::closure::ClosureImpl;\n-    use ::serde::Deserialize;\n-    use ::serde::Serialize;\n+    use super::Closure;\n+    use super::ClosureImpl;\n+    use serde::Deserialize;\n+    use serde::Serialize;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "342ea2391a8c483c2aa391afbc1b004627e7be62"}, "originalPosition": 281}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4Njc0NjQ2OnYy", "diffSide": "RIGHT", "path": "lib/internment.rs", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxNToyOToyMVrOICal-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxNToyOToyMVrOICal-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQwMzc2OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            pub fn istring_join(strings: &ddlog_std::Vec<istring>, sep: &String) -> String {\n          \n          \n            \n            pub fn istring_join(strings: &[istring], sep: &str) -> String {\n          \n      \n    \n    \n  \n\nDeref coercion should allow &String -> &str and &ddlog_std::Vec<T> -> &[T], may need to implement Deref<Target = Vec<T>> and Deref<Target = [T]> for ddlog_std::Vec<T> though", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r539403769", "createdAt": "2020-12-09T15:29:21Z", "author": {"login": "Kixiron"}, "path": "lib/internment.rs", "diffHunk": "@@ -138,66 +126,7 @@ where\n     }\n }\n \n-#[cfg(feature = \"flatbuf\")]\n-impl<A, FB> FromFlatBuffer<FB> for Intern<A>\n-where\n-    A: Eq + Hash + Send + Sync + 'static,\n-    A: FromFlatBuffer<FB>,\n-{\n-    fn from_flatbuf(fb: FB) -> Result<Self, String> {\n-        Ok(Intern::new(A::from_flatbuf(fb)?))\n-    }\n-}\n-\n-#[cfg(feature = \"flatbuf\")]\n-impl<'b, A, T> ToFlatBuffer<'b> for Intern<A>\n-where\n-    T: 'b,\n-    A: Eq + Send + Sync + Hash + ToFlatBuffer<'b, Target = T>,\n-{\n-    type Target = T;\n-\n-    fn to_flatbuf(&self, fbb: &mut fbrt::FlatBufferBuilder<'b>) -> Self::Target {\n-        self.as_ref().to_flatbuf(fbb)\n-    }\n-}\n-\n-/*#[cfg(feature = \"flatbuf\")]\n-impl<'a> FromFlatBuffer<fb::__String<'a>> for intern_istring {\n-    fn from_flatbuf(v: fb::__String<'a>) -> Response<Self> {\n-        Ok(intern_string_intern(&String::from_flatbuf(v)?))\n-    }\n-}*/\n-\n-#[cfg(feature = \"flatbuf\")]\n-impl<'b, A, T> ToFlatBufferTable<'b> for Intern<A>\n-where\n-    T: 'b,\n-    A: Eq + Send + Sync + Hash + ToFlatBufferTable<'b, Target = T>,\n-{\n-    type Target = T;\n-    fn to_flatbuf_table(\n-        &self,\n-        fbb: &mut fbrt::FlatBufferBuilder<'b>,\n-    ) -> fbrt::WIPOffset<Self::Target> {\n-        self.as_ref().to_flatbuf_table(fbb)\n-    }\n-}\n-\n-#[cfg(feature = \"flatbuf\")]\n-impl<'b, A, T> ToFlatBufferVectorElement<'b> for Intern<A>\n-where\n-    T: 'b + fbrt::Push + Copy,\n-    A: Eq + Send + Sync + Hash + ToFlatBufferVectorElement<'b, Target = T>,\n-{\n-    type Target = T;\n-\n-    fn to_flatbuf_vector_element(&self, fbb: &mut fbrt::FlatBufferBuilder<'b>) -> Self::Target {\n-        self.as_ref().to_flatbuf_vector_element(fbb)\n-    }\n-}\n-\n-pub fn istring_join(strings: &crate::ddlog_std::Vec<istring>, sep: &String) -> String {\n+pub fn istring_join(strings: &ddlog_std::Vec<istring>, sep: &String) -> String {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "342ea2391a8c483c2aa391afbc1b004627e7be62"}, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4Njc3OTEzOnYy", "diffSide": "RIGHT", "path": "lib/ddlog_bigint.rs", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxNTozNToyMVrOICa55w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxNzoxMzoxN1rOICf6tQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQwODg3MQ==", "bodyText": "Implementing Deref<Target = BigInt> would add to ergonomics a lot (Same with Uint)", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r539408871", "createdAt": "2020-12-09T15:35:21Z", "author": {"login": "Kixiron"}, "path": "lib/ddlog_bigint.rs", "diffHunk": "@@ -20,6 +16,14 @@ use std::ops::*;\n use std::os::raw::c_char;\n use std::str::FromStr;\n \n+/* This module is designed to be imported both as a standard DDlog library and as a normal Rust\n+ * module, e.g., from `differential_datalog_test`.  We therefore need to import these traits\n+ * so that they are available in the latter case and rename them so that they don't cause duplicate\n+ * import error in the former case. */\n+use differential_datalog::record::FromRecord as FromRec;\n+use differential_datalog::record::IntoRecord as IntoRec;\n+use differential_datalog::record::Record;\n+\n #[derive(Eq, PartialOrd, PartialEq, Ord, Clone, Hash)]\n pub struct Int {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "342ea2391a8c483c2aa391afbc1b004627e7be62"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ2NzcxMw==", "bodyText": "As long as it doesn't mess up the generated code. There's a bit of a tension here between ergonomics and surprising side effects in automatically generated code where fewer magic conversions is better. The same is true for many other library types. I don't think we have a consistent approach here. I'll try implementing these Deref and see if anything breaks.", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r539467713", "createdAt": "2020-12-09T16:43:58Z", "author": {"login": "ryzhyk"}, "path": "lib/ddlog_bigint.rs", "diffHunk": "@@ -20,6 +16,14 @@ use std::ops::*;\n use std::os::raw::c_char;\n use std::str::FromStr;\n \n+/* This module is designed to be imported both as a standard DDlog library and as a normal Rust\n+ * module, e.g., from `differential_datalog_test`.  We therefore need to import these traits\n+ * so that they are available in the latter case and rename them so that they don't cause duplicate\n+ * import error in the former case. */\n+use differential_datalog::record::FromRecord as FromRec;\n+use differential_datalog::record::IntoRecord as IntoRec;\n+use differential_datalog::record::Record;\n+\n #[derive(Eq, PartialOrd, PartialEq, Ord, Clone, Hash)]\n pub struct Int {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQwODg3MQ=="}, "originalCommit": {"oid": "342ea2391a8c483c2aa391afbc1b004627e7be62"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ5MDk5Nw==", "bodyText": "If it ends up that there's a multitude of unwanted behavior happening, we can delay that and I can make a pr that makes you ye generated code use more qualified function calls, but hopefully it doesn't come to that", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r539490997", "createdAt": "2020-12-09T17:13:17Z", "author": {"login": "Kixiron"}, "path": "lib/ddlog_bigint.rs", "diffHunk": "@@ -20,6 +16,14 @@ use std::ops::*;\n use std::os::raw::c_char;\n use std::str::FromStr;\n \n+/* This module is designed to be imported both as a standard DDlog library and as a normal Rust\n+ * module, e.g., from `differential_datalog_test`.  We therefore need to import these traits\n+ * so that they are available in the latter case and rename them so that they don't cause duplicate\n+ * import error in the former case. */\n+use differential_datalog::record::FromRecord as FromRec;\n+use differential_datalog::record::IntoRecord as IntoRec;\n+use differential_datalog::record::Record;\n+\n #[derive(Eq, PartialOrd, PartialEq, Ord, Clone, Hash)]\n pub struct Int {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQwODg3MQ=="}, "originalCommit": {"oid": "342ea2391a8c483c2aa391afbc1b004627e7be62"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NzY1NDE4OnYy", "diffSide": "RIGHT", "path": "src/Language/DifferentialDatalog/Crate.hs", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxODoyNjoxMFrOICjIsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxODoyNjoxMFrOICjIsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU0MzcyOQ==", "bodyText": "typo?", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r539543729", "createdAt": "2020-12-09T18:26:10Z", "author": {"login": "mbudiu-vmw"}, "path": "src/Language/DifferentialDatalog/Crate.hs", "diffHunk": "@@ -0,0 +1,235 @@\n+{-\n+Copyright (c) 2020 VMware, Inc.\n+SPDX-License-Identifier: MIT\n+\n+Permission is hereby granted, free of charge, to any person obtaining a copy\n+of this software and associated documentation files (the \"Software\"), to deal\n+in the Software without restriction, including without limitation the rights\n+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+copies of the Software, and to permit persons to whom the Software is\n+furnished to do so, subject to the following conditions:\n+\n+The above copyright notice and this permission notice shall be included in all\n+copies or substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+SOFTWARE.\n+-}\n+\n+{- |\n+Module     : Crate\n+Description: Decompose generated Rust project into crates.\n+-}\n+\n+{-# LANGUAGE RecordWildCards, FlexibleContexts, TupleSections, LambdaCase, ImplicitParams, ScopedTypeVariables #-}\n+\n+module Language.DifferentialDatalog.Crate(\n+    Crate,\n+    CrateGraph(..),\n+    partitionIntoCrates,\n+    crateMainModule,\n+    crateName,\n+    cgModuleCrate,\n+    cgLookupCrate\n+) where\n+\n+import Data.List\n+import Data.Maybe\n+import qualified Data.Map as M\n+import qualified Data.Set as S\n+import qualified Data.Graph.Inductive as G\n+--import Debug.Trace\n+\n+import Language.DifferentialDatalog.Module\n+import Language.DifferentialDatalog.Syntax\n+import Language.DifferentialDatalog.Util\n+\n+-- A crate is a set of modules.\n+type Crate = S.Set ModuleName\n+\n+-- Returns the top-level module of a crate.  This is well-defined, as by\n+-- construction crate modules form a crate with a unique root.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "342ea2391a8c483c2aa391afbc1b004627e7be62"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NzY4ODUwOnYy", "diffSide": "RIGHT", "path": "src/Language/DifferentialDatalog/Crate.hs", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxODozMzozNVrOICjc1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxODozMzozNVrOICjc1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU0ODg4NQ==", "bodyText": "these could be utility functions in some library, but I don't know if it's worth moving them", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r539548885", "createdAt": "2020-12-09T18:33:35Z", "author": {"login": "mbudiu-vmw"}, "path": "src/Language/DifferentialDatalog/Crate.hs", "diffHunk": "@@ -0,0 +1,235 @@\n+{-\n+Copyright (c) 2020 VMware, Inc.\n+SPDX-License-Identifier: MIT\n+\n+Permission is hereby granted, free of charge, to any person obtaining a copy\n+of this software and associated documentation files (the \"Software\"), to deal\n+in the Software without restriction, including without limitation the rights\n+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+copies of the Software, and to permit persons to whom the Software is\n+furnished to do so, subject to the following conditions:\n+\n+The above copyright notice and this permission notice shall be included in all\n+copies or substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+SOFTWARE.\n+-}\n+\n+{- |\n+Module     : Crate\n+Description: Decompose generated Rust project into crates.\n+-}\n+\n+{-# LANGUAGE RecordWildCards, FlexibleContexts, TupleSections, LambdaCase, ImplicitParams, ScopedTypeVariables #-}\n+\n+module Language.DifferentialDatalog.Crate(\n+    Crate,\n+    CrateGraph(..),\n+    partitionIntoCrates,\n+    crateMainModule,\n+    crateName,\n+    cgModuleCrate,\n+    cgLookupCrate\n+) where\n+\n+import Data.List\n+import Data.Maybe\n+import qualified Data.Map as M\n+import qualified Data.Set as S\n+import qualified Data.Graph.Inductive as G\n+--import Debug.Trace\n+\n+import Language.DifferentialDatalog.Module\n+import Language.DifferentialDatalog.Syntax\n+import Language.DifferentialDatalog.Util\n+\n+-- A crate is a set of modules.\n+type Crate = S.Set ModuleName\n+\n+-- Returns the top-level module of a crate.  This is well-defined, as by\n+-- construction crate modules form a crate with a unique root.\n+crateMainModule :: Crate -> ModuleName\n+crateMainModule crate =\n+    minimumBy (\\m1 m2 -> (length $ modulePath m1) `compare` (length $ modulePath m2)) crate\n+\n+-- Crate name as the path to its main module.\n+-- Prepend \"types__\" to crate names to avoid name clashes with other Rust\n+-- crates (from 'crates.io'), except standard library crates, whose names\n+-- we don't want to obfuscate.\n+-- FIXME: this naming schema does not exclude name clashes.\n+crateName :: Crate -> String\n+crateName crate | elem (crateMainModule crate) stdLibs =\n+    intercalate \"__\" $ (modulePath $ crateMainModule crate)\n+                | otherwise =\n+    intercalate \"__\" $ \"types\" : (modulePath $ crateMainModule crate)\n+\n+-- A crate graph is a graph with crates as vertices and with two\n+-- types of edges:\n+-- * Dependency edges represent module dependencies.  Two crates are connected\n+--   by a dependency edge iff there is a dependency between a pair of modules\n+--   inside these crates.\n+-- * Parent edges represent the DDlog module hierarchy.\n+data CrateGraph = CrateGraph {\n+    -- Crates.\n+    cgCrates    :: [Crate],\n+    -- Map from module names to index of the crate the module belongs to.\n+    cgMod2Crate :: M.Map ModuleName Int\n+} deriving (Eq, Show)\n+\n+cgEmpty :: CrateGraph\n+cgEmpty =\n+    CrateGraph {\n+        cgCrates       = [],\n+        cgMod2Crate    = M.empty\n+    }\n+\n+cgAddCrate :: CrateGraph -> Crate -> CrateGraph\n+cgAddCrate cg@CrateGraph{..} crate | elem crate cgCrates = cg\n+                                   | otherwise =\n+    CrateGraph {\n+        cgCrates = cgCrates ++ [crate],\n+        cgMod2Crate = foldl' (\\modCrates m -> M.insert m (length cgCrates) modCrates)\n+                             cgMod2Crate (S.toList crate)\n+    }\n+\n+cgLookupCrate :: CrateGraph -> String -> Maybe Crate\n+cgLookupCrate cg crate_name = find ((== crate_name) . crateName) $ cgCrates cg\n+\n+cgModuleCrate :: CrateGraph -> ModuleName -> Crate\n+cgModuleCrate CrateGraph{..} mod_name = cgCrates !! (cgMod2Crate M.! mod_name)\n+\n+-- Module dependencies.  Currently just the list of module imports, but\n+-- we may want to use a more accurate method based on actual dependencies\n+-- used by types and functions in the module.\n+moduleDeps :: (?mmap :: M.Map ModuleName DatalogModule) => ModuleName -> [ModuleName]\n+moduleDeps m = fromMaybe [] $ ((map importModule) . progImports . moduleDefs) <$> ?mmap M.!? m\n+\n+-- Expand crate so that modules in the crate form a single connected\n+-- subtree of the module graph:\n+-- Find the lowest common ancestor of all modules in the crate and add\n+-- modules along all branches from the ancestor to modules in the crate to\n+-- the crate.\n+--\n+-- Example:\n+-- Module hirarchy:\n+-- top\n+--  |\n+--  |-m1\n+--    |-m2\n+--    |-m3\n+--    |  |-m4\n+--    |  |-m5\n+--    |\n+--    |-m6\n+--       |-m7\n+--       |-m8\n+--\n+-- crate1 = {m8, m4}.\n+-- The lowest common ancestor of m8 and m4 is m1.  We therefore\n+-- extend the crate with m1 and all modules down the path from m1\n+-- to m8 and m4:\n+-- crate1' = {m1, m3, m4, m6, m8}.\n+addLowestCommonAncestor :: Crate -> Crate\n+addLowestCommonAncestor crate =\n+    S.foldl (\\mods m -> foldl' (\\mods' mname -> S.insert (ModuleName mname) mods') (S.insert m mods)\n+                               $ drop lca_len $ inits $ modulePath m)\n+            S.empty crate\n+    where\n+    -- Lowest common ancestor path length.\n+    lca_len = length $ lcp $ map modulePath $ S.toList crate\n+    -- Longest common prefix.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "342ea2391a8c483c2aa391afbc1b004627e7be62"}, "originalPosition": 146}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NzcxMDM5OnYy", "diffSide": "RIGHT", "path": "src/Language/DifferentialDatalog/Expr.hs", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxODozODoyNVrOICjp7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxOToxMzoxN1rOIClD6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU1MjIzOQ==", "bodyText": "aren't literals in this category too? or constant expressions?", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r539552239", "createdAt": "2020-12-09T18:38:25Z", "author": {"login": "mbudiu-vmw"}, "path": "src/Language/DifferentialDatalog/Expr.hs", "diffHunk": "@@ -527,6 +528,14 @@ exprIsPure d ctx e | isNothing funcs = False\n                    | otherwise = all (\\f -> not $ funcGetSideEffectAttr d f) $ fromJust funcs\n     where funcs = exprFuncsRec d ctx e\n \n+-- | Expression can be evaluated statically.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "342ea2391a8c483c2aa391afbc1b004627e7be62"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU3NTI3Mg==", "bodyText": "For now we only convert function calls to statics.  Most literals and constant expressions are statically evaluated anyway by the Rust compiler.", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r539575272", "createdAt": "2020-12-09T19:13:17Z", "author": {"login": "ryzhyk"}, "path": "src/Language/DifferentialDatalog/Expr.hs", "diffHunk": "@@ -527,6 +528,14 @@ exprIsPure d ctx e | isNothing funcs = False\n                    | otherwise = all (\\f -> not $ funcGetSideEffectAttr d f) $ fromJust funcs\n     where funcs = exprFuncsRec d ctx e\n \n+-- | Expression can be evaluated statically.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU1MjIzOQ=="}, "originalCommit": {"oid": "342ea2391a8c483c2aa391afbc1b004627e7be62"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NzcyODA3OnYy", "diffSide": "RIGHT", "path": "src/Language/DifferentialDatalog/Module.hs", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxODo0MjoxOVrOICj0ZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxODo0MjoxOVrOICj0ZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU1NDkxNw==", "bodyText": "Could this be read from ddlog_std.dl?", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r539554917", "createdAt": "2020-12-09T18:42:19Z", "author": {"login": "mbudiu-vmw"}, "path": "src/Language/DifferentialDatalog/Module.hs", "diffHunk": "@@ -109,9 +115,14 @@ emptyModule mname = DatalogModule {\n     moduleDefs = emptyDatalogProgram\n }\n \n--- Standard library module name.\n+-- Standard library module names.\n stdLibs :: [ModuleName]\n-stdLibs = [ModuleName [mOD_STD], ModuleName [\"internment\"]]\n+stdLibs = [ ModuleName [mOD_RT]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "342ea2391a8c483c2aa391afbc1b004627e7be62"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NzczMTY1OnYy", "diffSide": "RIGHT", "path": "src/Language/DifferentialDatalog/Module.hs", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxODo0MzoxM1rOICj2fw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxODo0MzoxM1rOICj2fw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU1NTQ1NQ==", "bodyText": "common subexpression (dropExresion $ moduleFile mod)", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r539555455", "createdAt": "2020-12-09T18:43:13Z", "author": {"login": "mbudiu-vmw"}, "path": "src/Language/DifferentialDatalog/Module.hs", "diffHunk": "@@ -121,57 +132,59 @@ stdImports :: [Import]\n stdImports = map stdImport stdLibs\n \n -- | Parse a datalog program along with all its imports; returns a \"flat\"\n--- program without imports and the list of Rust files associated with each\n--- module in the program.\n+-- program without imports.  In addition, returns `.rs` and `.toml` code\n+-- for each module.\n --\n -- 'roots' is the list of directories to search for imports\n --\n -- if 'import_std' is true, imports the standard libraries\n -- to each module.\n-parseDatalogProgram :: [FilePath] -> Bool -> String -> FilePath -> IO ([DatalogModule], DatalogProgram, M.Map ModuleName Doc, Doc)\n+parseDatalogProgram :: [FilePath] -> Bool -> String -> FilePath -> IO ([DatalogModule], DatalogProgram, M.Map ModuleName (Doc, Doc, Doc))\n parseDatalogProgram roots import_std fdata fname = do\n     roots' <- nub <$> mapM canonicalizePath roots\n     prog <- parseDatalogString fdata fname\n     let prog' = if import_std\n                    then prog { progImports = stdImports ++ progImports prog }\n                    else prog\n     let main_mod = DatalogModule (ModuleName []) fname prog'\n+    let ?specname = takeBaseName fname\n     imports <- evalStateT (parseImports roots' main_mod) []\n     let all_modules = main_mod : imports\n     prog'' <- flattenNamespace all_modules\n-    -- Collect Rust files associated with each module.\n-    rs <- (M.fromList . catMaybes) <$>\n-          mapM ((\\mod -> do\n-                    let rsfile = addExtension (dropExtension $ moduleFile mod) \"rs\"\n-                    rs_exists <- doesFileExist rsfile\n-                    if rs_exists\n-                       then do rs_code <- readFile rsfile\n-                               return $ Just (moduleName mod, pp rs_code)\n-                       else return Nothing))\n-               all_modules\n-    -- collect .toml files associated with modules\n-    toml <- (vcat . catMaybes) <$>\n-          mapM ((\\mod -> do let tomlfile = addExtension (dropExtension $ moduleFile mod) \"toml\"\n-                            exists <- doesFileExist tomlfile\n-                            if exists\n-                               then do toml_code <- readFile tomlfile\n-                                       return $ Just $ pp toml_code\n-                               else return Nothing))\n+    -- Collect '.rs' and '.toml' files associated with each module.\n+    rs <- M.fromList <$>\n+          mapM (\\mod -> do\n+                   let rsfile = addExtension (dropExtension $ moduleFile mod) \"rs\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "342ea2391a8c483c2aa391afbc1b004627e7be62"}, "originalPosition": 98}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NzczNDExOnYy", "diffSide": "RIGHT", "path": "src/Language/DifferentialDatalog/Module.hs", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxODo0Mzo0NFrOICj35g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxODo0Mzo0NFrOICj35g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU1NTgxNA==", "bodyText": "this also looks like a little function", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r539555814", "createdAt": "2020-12-09T18:43:44Z", "author": {"login": "mbudiu-vmw"}, "path": "src/Language/DifferentialDatalog/Module.hs", "diffHunk": "@@ -121,57 +132,59 @@ stdImports :: [Import]\n stdImports = map stdImport stdLibs\n \n -- | Parse a datalog program along with all its imports; returns a \"flat\"\n--- program without imports and the list of Rust files associated with each\n--- module in the program.\n+-- program without imports.  In addition, returns `.rs` and `.toml` code\n+-- for each module.\n --\n -- 'roots' is the list of directories to search for imports\n --\n -- if 'import_std' is true, imports the standard libraries\n -- to each module.\n-parseDatalogProgram :: [FilePath] -> Bool -> String -> FilePath -> IO ([DatalogModule], DatalogProgram, M.Map ModuleName Doc, Doc)\n+parseDatalogProgram :: [FilePath] -> Bool -> String -> FilePath -> IO ([DatalogModule], DatalogProgram, M.Map ModuleName (Doc, Doc, Doc))\n parseDatalogProgram roots import_std fdata fname = do\n     roots' <- nub <$> mapM canonicalizePath roots\n     prog <- parseDatalogString fdata fname\n     let prog' = if import_std\n                    then prog { progImports = stdImports ++ progImports prog }\n                    else prog\n     let main_mod = DatalogModule (ModuleName []) fname prog'\n+    let ?specname = takeBaseName fname\n     imports <- evalStateT (parseImports roots' main_mod) []\n     let all_modules = main_mod : imports\n     prog'' <- flattenNamespace all_modules\n-    -- Collect Rust files associated with each module.\n-    rs <- (M.fromList . catMaybes) <$>\n-          mapM ((\\mod -> do\n-                    let rsfile = addExtension (dropExtension $ moduleFile mod) \"rs\"\n-                    rs_exists <- doesFileExist rsfile\n-                    if rs_exists\n-                       then do rs_code <- readFile rsfile\n-                               return $ Just (moduleName mod, pp rs_code)\n-                       else return Nothing))\n-               all_modules\n-    -- collect .toml files associated with modules\n-    toml <- (vcat . catMaybes) <$>\n-          mapM ((\\mod -> do let tomlfile = addExtension (dropExtension $ moduleFile mod) \"toml\"\n-                            exists <- doesFileExist tomlfile\n-                            if exists\n-                               then do toml_code <- readFile tomlfile\n-                                       return $ Just $ pp toml_code\n-                               else return Nothing))\n+    -- Collect '.rs' and '.toml' files associated with each module.\n+    rs <- M.fromList <$>\n+          mapM (\\mod -> do\n+                   let rsfile = addExtension (dropExtension $ moduleFile mod) \"rs\"\n+                   let fbfile = addExtension (dropExtension $ moduleFile mod) \".flatbuf.rs\"\n+                   let tomlfile = addExtension (dropExtension $ moduleFile mod) \"toml\"\n+                   rs_exists <- doesFileExist rsfile\n+                   flatbuf_exists <- doesFileExist fbfile\n+                   toml_exists <- doesFileExist tomlfile\n+                   rs_code <- if rs_exists", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "342ea2391a8c483c2aa391afbc1b004627e7be62"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4Nzc1NTQ4OnYy", "diffSide": "RIGHT", "path": "test/antrea/test-antrea.sh", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxODo0ODoyMFrOICkEjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxOTo0NzoyNVrOICmbEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU1OTA1Mw==", "bodyText": "does this save much?", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r539559053", "createdAt": "2020-12-09T18:48:20Z", "author": {"login": "mbudiu-vmw"}, "path": "test/antrea/test-antrea.sh", "diffHunk": "@@ -4,7 +4,15 @@\n \n set -e\n \n-stack install\n+# When running in CI, the DDlog compiler should be preinstalled by the build stage.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "342ea2391a8c483c2aa391afbc1b004627e7be62"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU5NzU4Nw==", "bodyText": "Big time!", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r539597587", "createdAt": "2020-12-09T19:47:25Z", "author": {"login": "ryzhyk"}, "path": "test/antrea/test-antrea.sh", "diffHunk": "@@ -4,7 +4,15 @@\n \n set -e\n \n-stack install\n+# When running in CI, the DDlog compiler should be preinstalled by the build stage.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU1OTA1Mw=="}, "originalCommit": {"oid": "342ea2391a8c483c2aa391afbc1b004627e7be62"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4Nzc2NjM2OnYy", "diffSide": "RIGHT", "path": "test/datalog_tests/json_test.dl", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxODo1MDo0MFrOICkKuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxODo1MDo0MFrOICkKuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU2MDYzNQ==", "bodyText": "this is a subtle user-facing change. I wonder where this has to be documented.", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r539560635", "createdAt": "2020-12-09T18:50:40Z", "author": {"login": "mbudiu-vmw"}, "path": "test/datalog_tests/json_test.dl", "diffHunk": "@@ -163,7 +163,7 @@ JsonTest(struct_with_map1(),\n \n typedef U64FromString = U64FromString {\n     x: string,\n-    #[rust=\"serde(with=\\\"crate::json::serde_string\\\")\"]\n+    #[rust=\"serde(with=\\\"types__json::serde_string\\\")\"]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "342ea2391a8c483c2aa391afbc1b004627e7be62"}, "originalPosition": 5}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4703, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}