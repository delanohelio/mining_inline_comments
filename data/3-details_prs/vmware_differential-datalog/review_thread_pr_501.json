{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYxODkzMjQ5", "number": 501, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxNzo0MzowOFrODXmgjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxODoxNjoyMlrODXnG_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2MDc0NzY3OnYy", "diffSide": "RIGHT", "path": "rust/template/differential_datalog/ddval.rs", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxNzo0MzowOFrOFc_B3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxNzo0MzowOFrOFc_B3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkzNzExNw==", "bodyText": "typo", "url": "https://github.com/vmware/differential-datalog/pull/501#discussion_r365937117", "createdAt": "2020-01-13T17:43:08Z", "author": {"login": "mbudiu-vmw"}, "path": "rust/template/differential_datalog/ddval.rs", "diffHunk": "@@ -0,0 +1,423 @@\n+//! DDValue: Generic value type stored in all differential-dataflow relations.\n+//!\n+//! Rationale: Differential dataflow allows the user to assign an arbitrary user-defined type to\n+//! each collection.  It relies on Rust's static dispatch mechanism to specialize its internal\n+//! machinery for each user-defined type.  Unfortunately, beyond very simple programs this leads to\n+//! extremely long compilation times.  One workaround that we used to rely on is to declare a\n+//! single enum type with a variant per concrete type used in at least one relation.  This make\n+//! compilation feasible, but still very slow (~6 minutes for a simple DDlog program and ~10\n+//! minutes for complex programs).\n+//!\n+//! Another alternative we implement here is to use a fixed value type that does not depend on\n+//! a concrete DDlog program and rely on dynamic dispatch to forward operations that DD expects\n+//! all values to implement (comparison, hashing, etc.) to their concrete implementations.  This\n+//! way this crate (differetial-datalog) can be compiled all the way to binary code separately", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a5a18288ac80d325d0bd391f3d86c3007f5604c"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2MDc3NjIxOnYy", "diffSide": "RIGHT", "path": "rust/template/differential_datalog/ddval.rs", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxNzo1MjoxMlrOFc_TSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxODozNTo1NFrOFdAfuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk0MTU3OA==", "bodyText": "Will this work safely for any type t that satisfies these bounds?", "url": "https://github.com/vmware/differential-datalog/pull/501#discussion_r365941578", "createdAt": "2020-01-13T17:52:12Z", "author": {"login": "mbudiu-vmw"}, "path": "rust/template/differential_datalog/ddval.rs", "diffHunk": "@@ -0,0 +1,423 @@\n+//! DDValue: Generic value type stored in all differential-dataflow relations.\n+//!\n+//! Rationale: Differential dataflow allows the user to assign an arbitrary user-defined type to\n+//! each collection.  It relies on Rust's static dispatch mechanism to specialize its internal\n+//! machinery for each user-defined type.  Unfortunately, beyond very simple programs this leads to\n+//! extremely long compilation times.  One workaround that we used to rely on is to declare a\n+//! single enum type with a variant per concrete type used in at least one relation.  This make\n+//! compilation feasible, but still very slow (~6 minutes for a simple DDlog program and ~10\n+//! minutes for complex programs).\n+//!\n+//! Another alternative we implement here is to use a fixed value type that does not depend on\n+//! a concrete DDlog program and rely on dynamic dispatch to forward operations that DD expects\n+//! all values to implement (comparison, hashing, etc.) to their concrete implementations.  This\n+//! way this crate (differetial-datalog) can be compiled all the way to binary code separately\n+//! from the DDlog program using it and does not need to be re-compiled when the DDlog program\n+//! changes.  Thus, the only part that must be re-compiled on changes to the DDlog code is the\n+//! auto-generated crate that declares concrete value types and rules.  This is much faster than\n+//! re-compiling both crates together.\n+//!\n+//! The next design decision is how to implement dynamic dispatch.  Rust trait objects is an\n+//! obvious choice, with value type being declared as `Box<dyn SomeTrait>`.  However, this proved\n+//! suboptimal in our experiments, as this design requires a dynamic memory allocation per value,\n+//! no matter how small.  Furthermore, cloning a value (which DD does a lot, e.g., during\n+//! compaction) requires another allocation.\n+//!\n+//! We improve over this naive design in two ways.  First, we use `Arc` instead of `Box`, which\n+//! introduces extra space overhead to store the reference count, but avoids memory allocation due\n+//! to cloning and shares the same heap allocation across multiple copies of the value.  Second, we\n+//! store small objects <=`usize` bytes inline instead of wrapping them in an Arc to avoid dynamic\n+//! memory allocation for such objects altogether.  Unfortunately, Rust's dynamic dispatch\n+//! mechanism does not support this, so we roll our own instead, with the following `DDValue`\n+//! declaration:\n+//!\n+//! ```\n+//! use differential_datalog::ddval::*;\n+//! pub struct DDValue {\n+//!    val: DDVal,\n+//!    vtable: &'static DDValMethods,\n+//! }\n+//! ```\n+//!\n+//! where `DDVal` is a `usize` that stores either an `Arc<T>` or `T` (where `T` is the actual type\n+//! of value stored in the DDlog relation), and `DDValMethods` is a virtual table of methods that\n+//! must be implemented for all DD values.\n+//!\n+//! This design still requires a separate heap allocation for each value >8 bytes, which slows\n+//! things down quite a bit.  Nevertheless, it has the same performance as our earlier\n+//! implementation using static dispatch and at least in some benchmarks uses less memory.  The\n+//! only way to improve things further I can think of is to somehow co-design this with DD to use\n+//! DD's knowledge of the context where a value is being created to, e.g., allocate blocks of\n+//! values when possible.\n+//!\n+\n+use std::fmt::Debug;\n+use std::fmt::Display;\n+use std::fmt::Formatter;\n+use std::hash::Hash;\n+use std::hash::Hasher;\n+\n+use serde::de::Deserialize;\n+use serde::de::Deserializer;\n+use serde::ser::Serialize;\n+use serde::ser::Serializer;\n+\n+use abomonation::Abomonation;\n+\n+use crate::record::IntoRecord;\n+use crate::record::Mutator;\n+use crate::record::Record;\n+\n+/// Type-erased representation of a value.  Can store the actual value or a pointer to it.\n+/// This could be just a `usize`, but we wrap it in a struct as we don't want it to implement\n+/// `Copy`.\n+pub struct DDVal {\n+    pub v: usize,\n+}\n+\n+/// DDValue: this type is stored in all DD collections.\n+/// It consists of value and associated vtable.\n+pub struct DDValue {\n+    val: DDVal,\n+    vtable: &'static DDValMethods,\n+}\n+\n+/// vtable of methods to be implemented by every value stored in DD.\n+pub struct DDValMethods {\n+    pub clone: fn(this: &DDVal) -> DDVal,\n+    pub into_record: fn(this: DDVal) -> Record,\n+    pub eq: fn(this: &DDVal, other: &DDVal) -> bool,\n+    pub partial_cmp: fn(this: &DDVal, other: &DDVal) -> Option<std::cmp::Ordering>,\n+    pub cmp: fn(this: &DDVal, other: &DDVal) -> std::cmp::Ordering,\n+    pub hash: fn(this: &DDVal, state: &mut dyn Hasher),\n+    pub mutate: fn(this: &mut DDVal, record: &Record) -> Result<(), String>,\n+    pub fmt_debug: fn(this: &DDVal, f: &mut Formatter) -> Result<(), std::fmt::Error>,\n+    pub fmt_display: fn(this: &DDVal, f: &mut Formatter) -> Result<(), std::fmt::Error>,\n+    pub drop: fn(this: &mut DDVal),\n+    pub ddval_serialize: fn(this: &DDVal) -> &dyn DDValSerialize,\n+}\n+\n+impl Drop for DDValue {\n+    fn drop(&mut self) {\n+        (self.vtable.drop)(&mut self.val);\n+    }\n+}\n+\n+impl DDValue {\n+    pub fn new(val: DDVal, vtable: &'static DDValMethods) -> DDValue {\n+        DDValue { val, vtable }\n+    }\n+\n+    pub fn into_ddval(self) -> DDVal {\n+        let res = DDVal { v: self.val.v };\n+        std::mem::forget(self);\n+        res\n+    }\n+}\n+\n+impl Mutator<DDValue> for Record {\n+    fn mutate(&self, x: &mut DDValue) -> Result<(), String> {\n+        (x.vtable.mutate)(&mut x.val, self)\n+    }\n+}\n+\n+impl IntoRecord for DDValue {\n+    fn into_record(self) -> Record {\n+        (self.vtable.into_record)(self.into_ddval())\n+    }\n+}\n+\n+impl Abomonation for DDValue {\n+    unsafe fn entomb<W: std::io::Write>(&self, _write: &mut W) -> std::io::Result<()> {\n+        panic!(\"DDValue::entomb: not implemented\")\n+    }\n+    unsafe fn exhume<'a, 'b>(&'a mut self, _bytes: &'b mut [u8]) -> Option<&'b mut [u8]> {\n+        panic!(\"DDValue::exhume: not implemented\")\n+    }\n+    fn extent(&self) -> usize {\n+        panic!(\"DDValue::extent: not implemented\")\n+    }\n+}\n+\n+impl Serialize for DDValue {\n+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n+    where\n+        S: Serializer,\n+    {\n+        (self.vtable.ddval_serialize)(&self.val).serialize(serializer)\n+    }\n+}\n+\n+impl<'de> Deserialize<'de> for DDValue {\n+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n+    where\n+        D: Deserializer<'de>,\n+    {\n+        let val: Box<dyn DDValSerialize> = Deserialize::deserialize(deserializer)?;\n+        Ok(val.ddvalue())\n+    }\n+}\n+\n+impl Display for DDValue {\n+    fn fmt(&self, f: &mut Formatter) -> Result<(), std::fmt::Error> {\n+        (self.vtable.fmt_display)(&self.val, f)\n+    }\n+}\n+\n+impl Debug for DDValue {\n+    fn fmt(&self, f: &mut Formatter) -> Result<(), std::fmt::Error> {\n+        (self.vtable.fmt_debug)(&self.val, f)\n+    }\n+}\n+\n+impl PartialOrd for DDValue {\n+    fn partial_cmp(&self, other: &DDValue) -> Option<std::cmp::Ordering> {\n+        (self.vtable.partial_cmp)(&self.val, &other.val)\n+    }\n+}\n+\n+impl PartialEq for DDValue {\n+    fn eq(&self, other: &Self) -> bool {\n+        (self.vtable.eq)(&self.val, &other.val)\n+    }\n+}\n+\n+impl Eq for DDValue {}\n+\n+impl Ord for DDValue {\n+    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n+        (self.vtable.cmp)(&self.val, &other.val)\n+    }\n+}\n+\n+impl Clone for DDValue {\n+    fn clone(&self) -> Self {\n+        DDValue {\n+            val: (self.vtable.clone)(&self.val),\n+            vtable: self.vtable,\n+        }\n+    }\n+}\n+\n+impl Hash for DDValue {\n+    fn hash<H>(&self, state: &mut H)\n+    where\n+        H: Hasher,\n+    {\n+        (self.vtable.hash)(&self.val, state)\n+    }\n+}\n+\n+/// Trait to convert `DDVal` into concrete value type and back.\n+pub trait DDValConvert: Sized {\n+    /// Extract reference to concrete type from `&DDVal`.  This causes undefined behavior\n+    /// if `v` does not contain a value of type `Self`.\n+    unsafe fn from_ddval_ref(v: &DDVal) -> &Self;\n+\n+    unsafe fn from_ddvalue_ref(v: &DDValue) -> &Self {\n+        Self::from_ddval_ref(&v.val)\n+    }\n+\n+    /// Extract mutable reference to concrete type from `&mut DDVal`.  This causes\n+    /// undefined behavior if `v` does not contain a value of type `Self`.\n+    unsafe fn from_ddval_mut_ref(v: &mut DDVal) -> &mut Self;\n+\n+    /// Extracts concrete value contained in `v`.  Panics if `v` does not contain a\n+    /// value of type `Self`.\n+    unsafe fn from_ddval(v: DDVal) -> Self;\n+\n+    unsafe fn from_ddvalue(v: DDValue) -> Self {\n+        Self::from_ddval(v.into_ddval())\n+    }\n+\n+    /// Convert a value to a `DDVal`, erasing its original type.  This is a safe conversion\n+    /// that cannot fail.\n+    fn into_ddval(self) -> DDVal;\n+\n+    fn into_ddvalue(self) -> DDValue;\n+}\n+\n+#[typetag::serde]\n+pub trait DDValSerialize {\n+    fn ddvalue(&self) -> DDValue;\n+}\n+\n+/// Macro to implement `DDValConvert` for type `t` that satisfies the following type bounds:\n+///", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a5a18288ac80d325d0bd391f3d86c3007f5604c"}, "originalPosition": 246}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk2MTE0Nw==", "bodyText": "Hopefully :)", "url": "https://github.com/vmware/differential-datalog/pull/501#discussion_r365961147", "createdAt": "2020-01-13T18:35:54Z", "author": {"login": "ryzhyk"}, "path": "rust/template/differential_datalog/ddval.rs", "diffHunk": "@@ -0,0 +1,423 @@\n+//! DDValue: Generic value type stored in all differential-dataflow relations.\n+//!\n+//! Rationale: Differential dataflow allows the user to assign an arbitrary user-defined type to\n+//! each collection.  It relies on Rust's static dispatch mechanism to specialize its internal\n+//! machinery for each user-defined type.  Unfortunately, beyond very simple programs this leads to\n+//! extremely long compilation times.  One workaround that we used to rely on is to declare a\n+//! single enum type with a variant per concrete type used in at least one relation.  This make\n+//! compilation feasible, but still very slow (~6 minutes for a simple DDlog program and ~10\n+//! minutes for complex programs).\n+//!\n+//! Another alternative we implement here is to use a fixed value type that does not depend on\n+//! a concrete DDlog program and rely on dynamic dispatch to forward operations that DD expects\n+//! all values to implement (comparison, hashing, etc.) to their concrete implementations.  This\n+//! way this crate (differetial-datalog) can be compiled all the way to binary code separately\n+//! from the DDlog program using it and does not need to be re-compiled when the DDlog program\n+//! changes.  Thus, the only part that must be re-compiled on changes to the DDlog code is the\n+//! auto-generated crate that declares concrete value types and rules.  This is much faster than\n+//! re-compiling both crates together.\n+//!\n+//! The next design decision is how to implement dynamic dispatch.  Rust trait objects is an\n+//! obvious choice, with value type being declared as `Box<dyn SomeTrait>`.  However, this proved\n+//! suboptimal in our experiments, as this design requires a dynamic memory allocation per value,\n+//! no matter how small.  Furthermore, cloning a value (which DD does a lot, e.g., during\n+//! compaction) requires another allocation.\n+//!\n+//! We improve over this naive design in two ways.  First, we use `Arc` instead of `Box`, which\n+//! introduces extra space overhead to store the reference count, but avoids memory allocation due\n+//! to cloning and shares the same heap allocation across multiple copies of the value.  Second, we\n+//! store small objects <=`usize` bytes inline instead of wrapping them in an Arc to avoid dynamic\n+//! memory allocation for such objects altogether.  Unfortunately, Rust's dynamic dispatch\n+//! mechanism does not support this, so we roll our own instead, with the following `DDValue`\n+//! declaration:\n+//!\n+//! ```\n+//! use differential_datalog::ddval::*;\n+//! pub struct DDValue {\n+//!    val: DDVal,\n+//!    vtable: &'static DDValMethods,\n+//! }\n+//! ```\n+//!\n+//! where `DDVal` is a `usize` that stores either an `Arc<T>` or `T` (where `T` is the actual type\n+//! of value stored in the DDlog relation), and `DDValMethods` is a virtual table of methods that\n+//! must be implemented for all DD values.\n+//!\n+//! This design still requires a separate heap allocation for each value >8 bytes, which slows\n+//! things down quite a bit.  Nevertheless, it has the same performance as our earlier\n+//! implementation using static dispatch and at least in some benchmarks uses less memory.  The\n+//! only way to improve things further I can think of is to somehow co-design this with DD to use\n+//! DD's knowledge of the context where a value is being created to, e.g., allocate blocks of\n+//! values when possible.\n+//!\n+\n+use std::fmt::Debug;\n+use std::fmt::Display;\n+use std::fmt::Formatter;\n+use std::hash::Hash;\n+use std::hash::Hasher;\n+\n+use serde::de::Deserialize;\n+use serde::de::Deserializer;\n+use serde::ser::Serialize;\n+use serde::ser::Serializer;\n+\n+use abomonation::Abomonation;\n+\n+use crate::record::IntoRecord;\n+use crate::record::Mutator;\n+use crate::record::Record;\n+\n+/// Type-erased representation of a value.  Can store the actual value or a pointer to it.\n+/// This could be just a `usize`, but we wrap it in a struct as we don't want it to implement\n+/// `Copy`.\n+pub struct DDVal {\n+    pub v: usize,\n+}\n+\n+/// DDValue: this type is stored in all DD collections.\n+/// It consists of value and associated vtable.\n+pub struct DDValue {\n+    val: DDVal,\n+    vtable: &'static DDValMethods,\n+}\n+\n+/// vtable of methods to be implemented by every value stored in DD.\n+pub struct DDValMethods {\n+    pub clone: fn(this: &DDVal) -> DDVal,\n+    pub into_record: fn(this: DDVal) -> Record,\n+    pub eq: fn(this: &DDVal, other: &DDVal) -> bool,\n+    pub partial_cmp: fn(this: &DDVal, other: &DDVal) -> Option<std::cmp::Ordering>,\n+    pub cmp: fn(this: &DDVal, other: &DDVal) -> std::cmp::Ordering,\n+    pub hash: fn(this: &DDVal, state: &mut dyn Hasher),\n+    pub mutate: fn(this: &mut DDVal, record: &Record) -> Result<(), String>,\n+    pub fmt_debug: fn(this: &DDVal, f: &mut Formatter) -> Result<(), std::fmt::Error>,\n+    pub fmt_display: fn(this: &DDVal, f: &mut Formatter) -> Result<(), std::fmt::Error>,\n+    pub drop: fn(this: &mut DDVal),\n+    pub ddval_serialize: fn(this: &DDVal) -> &dyn DDValSerialize,\n+}\n+\n+impl Drop for DDValue {\n+    fn drop(&mut self) {\n+        (self.vtable.drop)(&mut self.val);\n+    }\n+}\n+\n+impl DDValue {\n+    pub fn new(val: DDVal, vtable: &'static DDValMethods) -> DDValue {\n+        DDValue { val, vtable }\n+    }\n+\n+    pub fn into_ddval(self) -> DDVal {\n+        let res = DDVal { v: self.val.v };\n+        std::mem::forget(self);\n+        res\n+    }\n+}\n+\n+impl Mutator<DDValue> for Record {\n+    fn mutate(&self, x: &mut DDValue) -> Result<(), String> {\n+        (x.vtable.mutate)(&mut x.val, self)\n+    }\n+}\n+\n+impl IntoRecord for DDValue {\n+    fn into_record(self) -> Record {\n+        (self.vtable.into_record)(self.into_ddval())\n+    }\n+}\n+\n+impl Abomonation for DDValue {\n+    unsafe fn entomb<W: std::io::Write>(&self, _write: &mut W) -> std::io::Result<()> {\n+        panic!(\"DDValue::entomb: not implemented\")\n+    }\n+    unsafe fn exhume<'a, 'b>(&'a mut self, _bytes: &'b mut [u8]) -> Option<&'b mut [u8]> {\n+        panic!(\"DDValue::exhume: not implemented\")\n+    }\n+    fn extent(&self) -> usize {\n+        panic!(\"DDValue::extent: not implemented\")\n+    }\n+}\n+\n+impl Serialize for DDValue {\n+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n+    where\n+        S: Serializer,\n+    {\n+        (self.vtable.ddval_serialize)(&self.val).serialize(serializer)\n+    }\n+}\n+\n+impl<'de> Deserialize<'de> for DDValue {\n+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n+    where\n+        D: Deserializer<'de>,\n+    {\n+        let val: Box<dyn DDValSerialize> = Deserialize::deserialize(deserializer)?;\n+        Ok(val.ddvalue())\n+    }\n+}\n+\n+impl Display for DDValue {\n+    fn fmt(&self, f: &mut Formatter) -> Result<(), std::fmt::Error> {\n+        (self.vtable.fmt_display)(&self.val, f)\n+    }\n+}\n+\n+impl Debug for DDValue {\n+    fn fmt(&self, f: &mut Formatter) -> Result<(), std::fmt::Error> {\n+        (self.vtable.fmt_debug)(&self.val, f)\n+    }\n+}\n+\n+impl PartialOrd for DDValue {\n+    fn partial_cmp(&self, other: &DDValue) -> Option<std::cmp::Ordering> {\n+        (self.vtable.partial_cmp)(&self.val, &other.val)\n+    }\n+}\n+\n+impl PartialEq for DDValue {\n+    fn eq(&self, other: &Self) -> bool {\n+        (self.vtable.eq)(&self.val, &other.val)\n+    }\n+}\n+\n+impl Eq for DDValue {}\n+\n+impl Ord for DDValue {\n+    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n+        (self.vtable.cmp)(&self.val, &other.val)\n+    }\n+}\n+\n+impl Clone for DDValue {\n+    fn clone(&self) -> Self {\n+        DDValue {\n+            val: (self.vtable.clone)(&self.val),\n+            vtable: self.vtable,\n+        }\n+    }\n+}\n+\n+impl Hash for DDValue {\n+    fn hash<H>(&self, state: &mut H)\n+    where\n+        H: Hasher,\n+    {\n+        (self.vtable.hash)(&self.val, state)\n+    }\n+}\n+\n+/// Trait to convert `DDVal` into concrete value type and back.\n+pub trait DDValConvert: Sized {\n+    /// Extract reference to concrete type from `&DDVal`.  This causes undefined behavior\n+    /// if `v` does not contain a value of type `Self`.\n+    unsafe fn from_ddval_ref(v: &DDVal) -> &Self;\n+\n+    unsafe fn from_ddvalue_ref(v: &DDValue) -> &Self {\n+        Self::from_ddval_ref(&v.val)\n+    }\n+\n+    /// Extract mutable reference to concrete type from `&mut DDVal`.  This causes\n+    /// undefined behavior if `v` does not contain a value of type `Self`.\n+    unsafe fn from_ddval_mut_ref(v: &mut DDVal) -> &mut Self;\n+\n+    /// Extracts concrete value contained in `v`.  Panics if `v` does not contain a\n+    /// value of type `Self`.\n+    unsafe fn from_ddval(v: DDVal) -> Self;\n+\n+    unsafe fn from_ddvalue(v: DDValue) -> Self {\n+        Self::from_ddval(v.into_ddval())\n+    }\n+\n+    /// Convert a value to a `DDVal`, erasing its original type.  This is a safe conversion\n+    /// that cannot fail.\n+    fn into_ddval(self) -> DDVal;\n+\n+    fn into_ddvalue(self) -> DDValue;\n+}\n+\n+#[typetag::serde]\n+pub trait DDValSerialize {\n+    fn ddvalue(&self) -> DDValue;\n+}\n+\n+/// Macro to implement `DDValConvert` for type `t` that satisfies the following type bounds:\n+///", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk0MTU3OA=="}, "originalCommit": {"oid": "4a5a18288ac80d325d0bd391f3d86c3007f5604c"}, "originalPosition": 246}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2MDc4ODE0OnYy", "diffSide": "RIGHT", "path": "rust/template/differential_datalog/ddval.rs", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxNzo1NTo0MlrOFc_aUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxODozNjoyNVrOFdAguw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk0MzM3Nw==", "bodyText": "I hope that there's only one vtable for each different type t.", "url": "https://github.com/vmware/differential-datalog/pull/501#discussion_r365943377", "createdAt": "2020-01-13T17:55:42Z", "author": {"login": "mbudiu-vmw"}, "path": "rust/template/differential_datalog/ddval.rs", "diffHunk": "@@ -0,0 +1,423 @@\n+//! DDValue: Generic value type stored in all differential-dataflow relations.\n+//!\n+//! Rationale: Differential dataflow allows the user to assign an arbitrary user-defined type to\n+//! each collection.  It relies on Rust's static dispatch mechanism to specialize its internal\n+//! machinery for each user-defined type.  Unfortunately, beyond very simple programs this leads to\n+//! extremely long compilation times.  One workaround that we used to rely on is to declare a\n+//! single enum type with a variant per concrete type used in at least one relation.  This make\n+//! compilation feasible, but still very slow (~6 minutes for a simple DDlog program and ~10\n+//! minutes for complex programs).\n+//!\n+//! Another alternative we implement here is to use a fixed value type that does not depend on\n+//! a concrete DDlog program and rely on dynamic dispatch to forward operations that DD expects\n+//! all values to implement (comparison, hashing, etc.) to their concrete implementations.  This\n+//! way this crate (differetial-datalog) can be compiled all the way to binary code separately\n+//! from the DDlog program using it and does not need to be re-compiled when the DDlog program\n+//! changes.  Thus, the only part that must be re-compiled on changes to the DDlog code is the\n+//! auto-generated crate that declares concrete value types and rules.  This is much faster than\n+//! re-compiling both crates together.\n+//!\n+//! The next design decision is how to implement dynamic dispatch.  Rust trait objects is an\n+//! obvious choice, with value type being declared as `Box<dyn SomeTrait>`.  However, this proved\n+//! suboptimal in our experiments, as this design requires a dynamic memory allocation per value,\n+//! no matter how small.  Furthermore, cloning a value (which DD does a lot, e.g., during\n+//! compaction) requires another allocation.\n+//!\n+//! We improve over this naive design in two ways.  First, we use `Arc` instead of `Box`, which\n+//! introduces extra space overhead to store the reference count, but avoids memory allocation due\n+//! to cloning and shares the same heap allocation across multiple copies of the value.  Second, we\n+//! store small objects <=`usize` bytes inline instead of wrapping them in an Arc to avoid dynamic\n+//! memory allocation for such objects altogether.  Unfortunately, Rust's dynamic dispatch\n+//! mechanism does not support this, so we roll our own instead, with the following `DDValue`\n+//! declaration:\n+//!\n+//! ```\n+//! use differential_datalog::ddval::*;\n+//! pub struct DDValue {\n+//!    val: DDVal,\n+//!    vtable: &'static DDValMethods,\n+//! }\n+//! ```\n+//!\n+//! where `DDVal` is a `usize` that stores either an `Arc<T>` or `T` (where `T` is the actual type\n+//! of value stored in the DDlog relation), and `DDValMethods` is a virtual table of methods that\n+//! must be implemented for all DD values.\n+//!\n+//! This design still requires a separate heap allocation for each value >8 bytes, which slows\n+//! things down quite a bit.  Nevertheless, it has the same performance as our earlier\n+//! implementation using static dispatch and at least in some benchmarks uses less memory.  The\n+//! only way to improve things further I can think of is to somehow co-design this with DD to use\n+//! DD's knowledge of the context where a value is being created to, e.g., allocate blocks of\n+//! values when possible.\n+//!\n+\n+use std::fmt::Debug;\n+use std::fmt::Display;\n+use std::fmt::Formatter;\n+use std::hash::Hash;\n+use std::hash::Hasher;\n+\n+use serde::de::Deserialize;\n+use serde::de::Deserializer;\n+use serde::ser::Serialize;\n+use serde::ser::Serializer;\n+\n+use abomonation::Abomonation;\n+\n+use crate::record::IntoRecord;\n+use crate::record::Mutator;\n+use crate::record::Record;\n+\n+/// Type-erased representation of a value.  Can store the actual value or a pointer to it.\n+/// This could be just a `usize`, but we wrap it in a struct as we don't want it to implement\n+/// `Copy`.\n+pub struct DDVal {\n+    pub v: usize,\n+}\n+\n+/// DDValue: this type is stored in all DD collections.\n+/// It consists of value and associated vtable.\n+pub struct DDValue {\n+    val: DDVal,\n+    vtable: &'static DDValMethods,\n+}\n+\n+/// vtable of methods to be implemented by every value stored in DD.\n+pub struct DDValMethods {\n+    pub clone: fn(this: &DDVal) -> DDVal,\n+    pub into_record: fn(this: DDVal) -> Record,\n+    pub eq: fn(this: &DDVal, other: &DDVal) -> bool,\n+    pub partial_cmp: fn(this: &DDVal, other: &DDVal) -> Option<std::cmp::Ordering>,\n+    pub cmp: fn(this: &DDVal, other: &DDVal) -> std::cmp::Ordering,\n+    pub hash: fn(this: &DDVal, state: &mut dyn Hasher),\n+    pub mutate: fn(this: &mut DDVal, record: &Record) -> Result<(), String>,\n+    pub fmt_debug: fn(this: &DDVal, f: &mut Formatter) -> Result<(), std::fmt::Error>,\n+    pub fmt_display: fn(this: &DDVal, f: &mut Formatter) -> Result<(), std::fmt::Error>,\n+    pub drop: fn(this: &mut DDVal),\n+    pub ddval_serialize: fn(this: &DDVal) -> &dyn DDValSerialize,\n+}\n+\n+impl Drop for DDValue {\n+    fn drop(&mut self) {\n+        (self.vtable.drop)(&mut self.val);\n+    }\n+}\n+\n+impl DDValue {\n+    pub fn new(val: DDVal, vtable: &'static DDValMethods) -> DDValue {\n+        DDValue { val, vtable }\n+    }\n+\n+    pub fn into_ddval(self) -> DDVal {\n+        let res = DDVal { v: self.val.v };\n+        std::mem::forget(self);\n+        res\n+    }\n+}\n+\n+impl Mutator<DDValue> for Record {\n+    fn mutate(&self, x: &mut DDValue) -> Result<(), String> {\n+        (x.vtable.mutate)(&mut x.val, self)\n+    }\n+}\n+\n+impl IntoRecord for DDValue {\n+    fn into_record(self) -> Record {\n+        (self.vtable.into_record)(self.into_ddval())\n+    }\n+}\n+\n+impl Abomonation for DDValue {\n+    unsafe fn entomb<W: std::io::Write>(&self, _write: &mut W) -> std::io::Result<()> {\n+        panic!(\"DDValue::entomb: not implemented\")\n+    }\n+    unsafe fn exhume<'a, 'b>(&'a mut self, _bytes: &'b mut [u8]) -> Option<&'b mut [u8]> {\n+        panic!(\"DDValue::exhume: not implemented\")\n+    }\n+    fn extent(&self) -> usize {\n+        panic!(\"DDValue::extent: not implemented\")\n+    }\n+}\n+\n+impl Serialize for DDValue {\n+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n+    where\n+        S: Serializer,\n+    {\n+        (self.vtable.ddval_serialize)(&self.val).serialize(serializer)\n+    }\n+}\n+\n+impl<'de> Deserialize<'de> for DDValue {\n+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n+    where\n+        D: Deserializer<'de>,\n+    {\n+        let val: Box<dyn DDValSerialize> = Deserialize::deserialize(deserializer)?;\n+        Ok(val.ddvalue())\n+    }\n+}\n+\n+impl Display for DDValue {\n+    fn fmt(&self, f: &mut Formatter) -> Result<(), std::fmt::Error> {\n+        (self.vtable.fmt_display)(&self.val, f)\n+    }\n+}\n+\n+impl Debug for DDValue {\n+    fn fmt(&self, f: &mut Formatter) -> Result<(), std::fmt::Error> {\n+        (self.vtable.fmt_debug)(&self.val, f)\n+    }\n+}\n+\n+impl PartialOrd for DDValue {\n+    fn partial_cmp(&self, other: &DDValue) -> Option<std::cmp::Ordering> {\n+        (self.vtable.partial_cmp)(&self.val, &other.val)\n+    }\n+}\n+\n+impl PartialEq for DDValue {\n+    fn eq(&self, other: &Self) -> bool {\n+        (self.vtable.eq)(&self.val, &other.val)\n+    }\n+}\n+\n+impl Eq for DDValue {}\n+\n+impl Ord for DDValue {\n+    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n+        (self.vtable.cmp)(&self.val, &other.val)\n+    }\n+}\n+\n+impl Clone for DDValue {\n+    fn clone(&self) -> Self {\n+        DDValue {\n+            val: (self.vtable.clone)(&self.val),\n+            vtable: self.vtable,\n+        }\n+    }\n+}\n+\n+impl Hash for DDValue {\n+    fn hash<H>(&self, state: &mut H)\n+    where\n+        H: Hasher,\n+    {\n+        (self.vtable.hash)(&self.val, state)\n+    }\n+}\n+\n+/// Trait to convert `DDVal` into concrete value type and back.\n+pub trait DDValConvert: Sized {\n+    /// Extract reference to concrete type from `&DDVal`.  This causes undefined behavior\n+    /// if `v` does not contain a value of type `Self`.\n+    unsafe fn from_ddval_ref(v: &DDVal) -> &Self;\n+\n+    unsafe fn from_ddvalue_ref(v: &DDValue) -> &Self {\n+        Self::from_ddval_ref(&v.val)\n+    }\n+\n+    /// Extract mutable reference to concrete type from `&mut DDVal`.  This causes\n+    /// undefined behavior if `v` does not contain a value of type `Self`.\n+    unsafe fn from_ddval_mut_ref(v: &mut DDVal) -> &mut Self;\n+\n+    /// Extracts concrete value contained in `v`.  Panics if `v` does not contain a\n+    /// value of type `Self`.\n+    unsafe fn from_ddval(v: DDVal) -> Self;\n+\n+    unsafe fn from_ddvalue(v: DDValue) -> Self {\n+        Self::from_ddval(v.into_ddval())\n+    }\n+\n+    /// Convert a value to a `DDVal`, erasing its original type.  This is a safe conversion\n+    /// that cannot fail.\n+    fn into_ddval(self) -> DDVal;\n+\n+    fn into_ddvalue(self) -> DDValue;\n+}\n+\n+#[typetag::serde]\n+pub trait DDValSerialize {\n+    fn ddvalue(&self) -> DDValue;\n+}\n+\n+/// Macro to implement `DDValConvert` for type `t` that satisfies the following type bounds:\n+///\n+/// t: Eq + Ord + Clone + Send + Debug + Sync + Hash + PartialOrd + IntoRecord + 'static,\n+/// Record: Mutator<t>\n+///\n+#[macro_export]\n+macro_rules! decl_ddval_convert {\n+    ( $t:ty ) => {\n+        #[typetag::serde]\n+        impl $crate::ddval::DDValSerialize for $t {\n+            fn ddvalue(&self) -> $crate::ddval::DDValue {\n+                $crate::ddval::DDValConvert::into_ddvalue(self.clone())\n+            }\n+        }\n+\n+        impl $crate::ddval::DDValConvert for $t {\n+            unsafe fn from_ddval_ref(v: &$crate::ddval::DDVal) -> &Self {\n+                if std::mem::size_of::<Self>() <= std::mem::size_of::<usize>() {\n+                    &*(&v.v as *const usize as *const Self)\n+                } else {\n+                    &*(v.v as *const Self)\n+                }\n+            }\n+\n+            unsafe fn from_ddval_mut_ref(v: &mut $crate::ddval::DDVal) -> &mut Self {\n+                if std::mem::size_of::<Self>() <= std::mem::size_of::<usize>() {\n+                    &mut *(&mut v.v as *mut usize as *mut Self)\n+                } else {\n+                    let arc = std::sync::Arc::from_raw(v.v as *const Self);\n+                    v.v = std::sync::Arc::into_raw(arc) as usize;\n+                    &mut *(v.v as *mut Self)\n+                }\n+            }\n+\n+            unsafe fn from_ddval(v: $crate::ddval::DDVal) -> Self {\n+                if std::mem::size_of::<Self>() <= std::mem::size_of::<usize>() {\n+                    let res: Self = std::mem::transmute::<[u8; std::mem::size_of::<Self>()], Self>(\n+                        *(&v.v as *const usize as *const [u8; std::mem::size_of::<Self>()]),\n+                    );\n+                    std::mem::forget(v);\n+                    res\n+                } else {\n+                    let arc = std::sync::Arc::from_raw(v.v as *const Self);\n+                    std::sync::Arc::try_unwrap(arc).unwrap_or_else(|a| (*a).clone())\n+                }\n+            }\n+\n+            fn into_ddval(self) -> $crate::ddval::DDVal {\n+                if std::mem::size_of::<Self>() <= std::mem::size_of::<usize>() {\n+                    let mut v: usize = 0;\n+                    unsafe {\n+                        *(&mut v as *mut usize as *mut [u8; std::mem::size_of::<Self>()]) =\n+                            std::mem::transmute::<Self, [u8; std::mem::size_of::<Self>()]>(self);\n+                    };\n+                    $crate::ddval::DDVal { v }\n+                } else {\n+                    $crate::ddval::DDVal {\n+                        v: std::sync::Arc::into_raw(std::sync::Arc::new(self)) as usize,\n+                    }\n+                }\n+            }\n+\n+            fn into_ddvalue(self) -> $crate::ddval::DDValue {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a5a18288ac80d325d0bd391f3d86c3007f5604c"}, "originalPosition": 307}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk2MTQwMw==", "bodyText": "Yes, the const declaration should take care of this.", "url": "https://github.com/vmware/differential-datalog/pull/501#discussion_r365961403", "createdAt": "2020-01-13T18:36:25Z", "author": {"login": "ryzhyk"}, "path": "rust/template/differential_datalog/ddval.rs", "diffHunk": "@@ -0,0 +1,423 @@\n+//! DDValue: Generic value type stored in all differential-dataflow relations.\n+//!\n+//! Rationale: Differential dataflow allows the user to assign an arbitrary user-defined type to\n+//! each collection.  It relies on Rust's static dispatch mechanism to specialize its internal\n+//! machinery for each user-defined type.  Unfortunately, beyond very simple programs this leads to\n+//! extremely long compilation times.  One workaround that we used to rely on is to declare a\n+//! single enum type with a variant per concrete type used in at least one relation.  This make\n+//! compilation feasible, but still very slow (~6 minutes for a simple DDlog program and ~10\n+//! minutes for complex programs).\n+//!\n+//! Another alternative we implement here is to use a fixed value type that does not depend on\n+//! a concrete DDlog program and rely on dynamic dispatch to forward operations that DD expects\n+//! all values to implement (comparison, hashing, etc.) to their concrete implementations.  This\n+//! way this crate (differetial-datalog) can be compiled all the way to binary code separately\n+//! from the DDlog program using it and does not need to be re-compiled when the DDlog program\n+//! changes.  Thus, the only part that must be re-compiled on changes to the DDlog code is the\n+//! auto-generated crate that declares concrete value types and rules.  This is much faster than\n+//! re-compiling both crates together.\n+//!\n+//! The next design decision is how to implement dynamic dispatch.  Rust trait objects is an\n+//! obvious choice, with value type being declared as `Box<dyn SomeTrait>`.  However, this proved\n+//! suboptimal in our experiments, as this design requires a dynamic memory allocation per value,\n+//! no matter how small.  Furthermore, cloning a value (which DD does a lot, e.g., during\n+//! compaction) requires another allocation.\n+//!\n+//! We improve over this naive design in two ways.  First, we use `Arc` instead of `Box`, which\n+//! introduces extra space overhead to store the reference count, but avoids memory allocation due\n+//! to cloning and shares the same heap allocation across multiple copies of the value.  Second, we\n+//! store small objects <=`usize` bytes inline instead of wrapping them in an Arc to avoid dynamic\n+//! memory allocation for such objects altogether.  Unfortunately, Rust's dynamic dispatch\n+//! mechanism does not support this, so we roll our own instead, with the following `DDValue`\n+//! declaration:\n+//!\n+//! ```\n+//! use differential_datalog::ddval::*;\n+//! pub struct DDValue {\n+//!    val: DDVal,\n+//!    vtable: &'static DDValMethods,\n+//! }\n+//! ```\n+//!\n+//! where `DDVal` is a `usize` that stores either an `Arc<T>` or `T` (where `T` is the actual type\n+//! of value stored in the DDlog relation), and `DDValMethods` is a virtual table of methods that\n+//! must be implemented for all DD values.\n+//!\n+//! This design still requires a separate heap allocation for each value >8 bytes, which slows\n+//! things down quite a bit.  Nevertheless, it has the same performance as our earlier\n+//! implementation using static dispatch and at least in some benchmarks uses less memory.  The\n+//! only way to improve things further I can think of is to somehow co-design this with DD to use\n+//! DD's knowledge of the context where a value is being created to, e.g., allocate blocks of\n+//! values when possible.\n+//!\n+\n+use std::fmt::Debug;\n+use std::fmt::Display;\n+use std::fmt::Formatter;\n+use std::hash::Hash;\n+use std::hash::Hasher;\n+\n+use serde::de::Deserialize;\n+use serde::de::Deserializer;\n+use serde::ser::Serialize;\n+use serde::ser::Serializer;\n+\n+use abomonation::Abomonation;\n+\n+use crate::record::IntoRecord;\n+use crate::record::Mutator;\n+use crate::record::Record;\n+\n+/// Type-erased representation of a value.  Can store the actual value or a pointer to it.\n+/// This could be just a `usize`, but we wrap it in a struct as we don't want it to implement\n+/// `Copy`.\n+pub struct DDVal {\n+    pub v: usize,\n+}\n+\n+/// DDValue: this type is stored in all DD collections.\n+/// It consists of value and associated vtable.\n+pub struct DDValue {\n+    val: DDVal,\n+    vtable: &'static DDValMethods,\n+}\n+\n+/// vtable of methods to be implemented by every value stored in DD.\n+pub struct DDValMethods {\n+    pub clone: fn(this: &DDVal) -> DDVal,\n+    pub into_record: fn(this: DDVal) -> Record,\n+    pub eq: fn(this: &DDVal, other: &DDVal) -> bool,\n+    pub partial_cmp: fn(this: &DDVal, other: &DDVal) -> Option<std::cmp::Ordering>,\n+    pub cmp: fn(this: &DDVal, other: &DDVal) -> std::cmp::Ordering,\n+    pub hash: fn(this: &DDVal, state: &mut dyn Hasher),\n+    pub mutate: fn(this: &mut DDVal, record: &Record) -> Result<(), String>,\n+    pub fmt_debug: fn(this: &DDVal, f: &mut Formatter) -> Result<(), std::fmt::Error>,\n+    pub fmt_display: fn(this: &DDVal, f: &mut Formatter) -> Result<(), std::fmt::Error>,\n+    pub drop: fn(this: &mut DDVal),\n+    pub ddval_serialize: fn(this: &DDVal) -> &dyn DDValSerialize,\n+}\n+\n+impl Drop for DDValue {\n+    fn drop(&mut self) {\n+        (self.vtable.drop)(&mut self.val);\n+    }\n+}\n+\n+impl DDValue {\n+    pub fn new(val: DDVal, vtable: &'static DDValMethods) -> DDValue {\n+        DDValue { val, vtable }\n+    }\n+\n+    pub fn into_ddval(self) -> DDVal {\n+        let res = DDVal { v: self.val.v };\n+        std::mem::forget(self);\n+        res\n+    }\n+}\n+\n+impl Mutator<DDValue> for Record {\n+    fn mutate(&self, x: &mut DDValue) -> Result<(), String> {\n+        (x.vtable.mutate)(&mut x.val, self)\n+    }\n+}\n+\n+impl IntoRecord for DDValue {\n+    fn into_record(self) -> Record {\n+        (self.vtable.into_record)(self.into_ddval())\n+    }\n+}\n+\n+impl Abomonation for DDValue {\n+    unsafe fn entomb<W: std::io::Write>(&self, _write: &mut W) -> std::io::Result<()> {\n+        panic!(\"DDValue::entomb: not implemented\")\n+    }\n+    unsafe fn exhume<'a, 'b>(&'a mut self, _bytes: &'b mut [u8]) -> Option<&'b mut [u8]> {\n+        panic!(\"DDValue::exhume: not implemented\")\n+    }\n+    fn extent(&self) -> usize {\n+        panic!(\"DDValue::extent: not implemented\")\n+    }\n+}\n+\n+impl Serialize for DDValue {\n+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n+    where\n+        S: Serializer,\n+    {\n+        (self.vtable.ddval_serialize)(&self.val).serialize(serializer)\n+    }\n+}\n+\n+impl<'de> Deserialize<'de> for DDValue {\n+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n+    where\n+        D: Deserializer<'de>,\n+    {\n+        let val: Box<dyn DDValSerialize> = Deserialize::deserialize(deserializer)?;\n+        Ok(val.ddvalue())\n+    }\n+}\n+\n+impl Display for DDValue {\n+    fn fmt(&self, f: &mut Formatter) -> Result<(), std::fmt::Error> {\n+        (self.vtable.fmt_display)(&self.val, f)\n+    }\n+}\n+\n+impl Debug for DDValue {\n+    fn fmt(&self, f: &mut Formatter) -> Result<(), std::fmt::Error> {\n+        (self.vtable.fmt_debug)(&self.val, f)\n+    }\n+}\n+\n+impl PartialOrd for DDValue {\n+    fn partial_cmp(&self, other: &DDValue) -> Option<std::cmp::Ordering> {\n+        (self.vtable.partial_cmp)(&self.val, &other.val)\n+    }\n+}\n+\n+impl PartialEq for DDValue {\n+    fn eq(&self, other: &Self) -> bool {\n+        (self.vtable.eq)(&self.val, &other.val)\n+    }\n+}\n+\n+impl Eq for DDValue {}\n+\n+impl Ord for DDValue {\n+    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n+        (self.vtable.cmp)(&self.val, &other.val)\n+    }\n+}\n+\n+impl Clone for DDValue {\n+    fn clone(&self) -> Self {\n+        DDValue {\n+            val: (self.vtable.clone)(&self.val),\n+            vtable: self.vtable,\n+        }\n+    }\n+}\n+\n+impl Hash for DDValue {\n+    fn hash<H>(&self, state: &mut H)\n+    where\n+        H: Hasher,\n+    {\n+        (self.vtable.hash)(&self.val, state)\n+    }\n+}\n+\n+/// Trait to convert `DDVal` into concrete value type and back.\n+pub trait DDValConvert: Sized {\n+    /// Extract reference to concrete type from `&DDVal`.  This causes undefined behavior\n+    /// if `v` does not contain a value of type `Self`.\n+    unsafe fn from_ddval_ref(v: &DDVal) -> &Self;\n+\n+    unsafe fn from_ddvalue_ref(v: &DDValue) -> &Self {\n+        Self::from_ddval_ref(&v.val)\n+    }\n+\n+    /// Extract mutable reference to concrete type from `&mut DDVal`.  This causes\n+    /// undefined behavior if `v` does not contain a value of type `Self`.\n+    unsafe fn from_ddval_mut_ref(v: &mut DDVal) -> &mut Self;\n+\n+    /// Extracts concrete value contained in `v`.  Panics if `v` does not contain a\n+    /// value of type `Self`.\n+    unsafe fn from_ddval(v: DDVal) -> Self;\n+\n+    unsafe fn from_ddvalue(v: DDValue) -> Self {\n+        Self::from_ddval(v.into_ddval())\n+    }\n+\n+    /// Convert a value to a `DDVal`, erasing its original type.  This is a safe conversion\n+    /// that cannot fail.\n+    fn into_ddval(self) -> DDVal;\n+\n+    fn into_ddvalue(self) -> DDValue;\n+}\n+\n+#[typetag::serde]\n+pub trait DDValSerialize {\n+    fn ddvalue(&self) -> DDValue;\n+}\n+\n+/// Macro to implement `DDValConvert` for type `t` that satisfies the following type bounds:\n+///\n+/// t: Eq + Ord + Clone + Send + Debug + Sync + Hash + PartialOrd + IntoRecord + 'static,\n+/// Record: Mutator<t>\n+///\n+#[macro_export]\n+macro_rules! decl_ddval_convert {\n+    ( $t:ty ) => {\n+        #[typetag::serde]\n+        impl $crate::ddval::DDValSerialize for $t {\n+            fn ddvalue(&self) -> $crate::ddval::DDValue {\n+                $crate::ddval::DDValConvert::into_ddvalue(self.clone())\n+            }\n+        }\n+\n+        impl $crate::ddval::DDValConvert for $t {\n+            unsafe fn from_ddval_ref(v: &$crate::ddval::DDVal) -> &Self {\n+                if std::mem::size_of::<Self>() <= std::mem::size_of::<usize>() {\n+                    &*(&v.v as *const usize as *const Self)\n+                } else {\n+                    &*(v.v as *const Self)\n+                }\n+            }\n+\n+            unsafe fn from_ddval_mut_ref(v: &mut $crate::ddval::DDVal) -> &mut Self {\n+                if std::mem::size_of::<Self>() <= std::mem::size_of::<usize>() {\n+                    &mut *(&mut v.v as *mut usize as *mut Self)\n+                } else {\n+                    let arc = std::sync::Arc::from_raw(v.v as *const Self);\n+                    v.v = std::sync::Arc::into_raw(arc) as usize;\n+                    &mut *(v.v as *mut Self)\n+                }\n+            }\n+\n+            unsafe fn from_ddval(v: $crate::ddval::DDVal) -> Self {\n+                if std::mem::size_of::<Self>() <= std::mem::size_of::<usize>() {\n+                    let res: Self = std::mem::transmute::<[u8; std::mem::size_of::<Self>()], Self>(\n+                        *(&v.v as *const usize as *const [u8; std::mem::size_of::<Self>()]),\n+                    );\n+                    std::mem::forget(v);\n+                    res\n+                } else {\n+                    let arc = std::sync::Arc::from_raw(v.v as *const Self);\n+                    std::sync::Arc::try_unwrap(arc).unwrap_or_else(|a| (*a).clone())\n+                }\n+            }\n+\n+            fn into_ddval(self) -> $crate::ddval::DDVal {\n+                if std::mem::size_of::<Self>() <= std::mem::size_of::<usize>() {\n+                    let mut v: usize = 0;\n+                    unsafe {\n+                        *(&mut v as *mut usize as *mut [u8; std::mem::size_of::<Self>()]) =\n+                            std::mem::transmute::<Self, [u8; std::mem::size_of::<Self>()]>(self);\n+                    };\n+                    $crate::ddval::DDVal { v }\n+                } else {\n+                    $crate::ddval::DDVal {\n+                        v: std::sync::Arc::into_raw(std::sync::Arc::new(self)) as usize,\n+                    }\n+                }\n+            }\n+\n+            fn into_ddvalue(self) -> $crate::ddval::DDValue {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk0MzM3Nw=="}, "originalCommit": {"oid": "4a5a18288ac80d325d0bd391f3d86c3007f5604c"}, "originalPosition": 307}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2MDc5MjcyOnYy", "diffSide": "RIGHT", "path": "rust/template/differential_datalog/ddval.rs", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxNzo1NzowN1rOFc_dFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxODozNzo1MVrOFdAjRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk0NDA4Ng==", "bodyText": "Can you compare values with different vtables?", "url": "https://github.com/vmware/differential-datalog/pull/501#discussion_r365944086", "createdAt": "2020-01-13T17:57:07Z", "author": {"login": "mbudiu-vmw"}, "path": "rust/template/differential_datalog/ddval.rs", "diffHunk": "@@ -0,0 +1,423 @@\n+//! DDValue: Generic value type stored in all differential-dataflow relations.\n+//!\n+//! Rationale: Differential dataflow allows the user to assign an arbitrary user-defined type to\n+//! each collection.  It relies on Rust's static dispatch mechanism to specialize its internal\n+//! machinery for each user-defined type.  Unfortunately, beyond very simple programs this leads to\n+//! extremely long compilation times.  One workaround that we used to rely on is to declare a\n+//! single enum type with a variant per concrete type used in at least one relation.  This make\n+//! compilation feasible, but still very slow (~6 minutes for a simple DDlog program and ~10\n+//! minutes for complex programs).\n+//!\n+//! Another alternative we implement here is to use a fixed value type that does not depend on\n+//! a concrete DDlog program and rely on dynamic dispatch to forward operations that DD expects\n+//! all values to implement (comparison, hashing, etc.) to their concrete implementations.  This\n+//! way this crate (differetial-datalog) can be compiled all the way to binary code separately\n+//! from the DDlog program using it and does not need to be re-compiled when the DDlog program\n+//! changes.  Thus, the only part that must be re-compiled on changes to the DDlog code is the\n+//! auto-generated crate that declares concrete value types and rules.  This is much faster than\n+//! re-compiling both crates together.\n+//!\n+//! The next design decision is how to implement dynamic dispatch.  Rust trait objects is an\n+//! obvious choice, with value type being declared as `Box<dyn SomeTrait>`.  However, this proved\n+//! suboptimal in our experiments, as this design requires a dynamic memory allocation per value,\n+//! no matter how small.  Furthermore, cloning a value (which DD does a lot, e.g., during\n+//! compaction) requires another allocation.\n+//!\n+//! We improve over this naive design in two ways.  First, we use `Arc` instead of `Box`, which\n+//! introduces extra space overhead to store the reference count, but avoids memory allocation due\n+//! to cloning and shares the same heap allocation across multiple copies of the value.  Second, we\n+//! store small objects <=`usize` bytes inline instead of wrapping them in an Arc to avoid dynamic\n+//! memory allocation for such objects altogether.  Unfortunately, Rust's dynamic dispatch\n+//! mechanism does not support this, so we roll our own instead, with the following `DDValue`\n+//! declaration:\n+//!\n+//! ```\n+//! use differential_datalog::ddval::*;\n+//! pub struct DDValue {\n+//!    val: DDVal,\n+//!    vtable: &'static DDValMethods,\n+//! }\n+//! ```\n+//!\n+//! where `DDVal` is a `usize` that stores either an `Arc<T>` or `T` (where `T` is the actual type\n+//! of value stored in the DDlog relation), and `DDValMethods` is a virtual table of methods that\n+//! must be implemented for all DD values.\n+//!\n+//! This design still requires a separate heap allocation for each value >8 bytes, which slows\n+//! things down quite a bit.  Nevertheless, it has the same performance as our earlier\n+//! implementation using static dispatch and at least in some benchmarks uses less memory.  The\n+//! only way to improve things further I can think of is to somehow co-design this with DD to use\n+//! DD's knowledge of the context where a value is being created to, e.g., allocate blocks of\n+//! values when possible.\n+//!\n+\n+use std::fmt::Debug;\n+use std::fmt::Display;\n+use std::fmt::Formatter;\n+use std::hash::Hash;\n+use std::hash::Hasher;\n+\n+use serde::de::Deserialize;\n+use serde::de::Deserializer;\n+use serde::ser::Serialize;\n+use serde::ser::Serializer;\n+\n+use abomonation::Abomonation;\n+\n+use crate::record::IntoRecord;\n+use crate::record::Mutator;\n+use crate::record::Record;\n+\n+/// Type-erased representation of a value.  Can store the actual value or a pointer to it.\n+/// This could be just a `usize`, but we wrap it in a struct as we don't want it to implement\n+/// `Copy`.\n+pub struct DDVal {\n+    pub v: usize,\n+}\n+\n+/// DDValue: this type is stored in all DD collections.\n+/// It consists of value and associated vtable.\n+pub struct DDValue {\n+    val: DDVal,\n+    vtable: &'static DDValMethods,\n+}\n+\n+/// vtable of methods to be implemented by every value stored in DD.\n+pub struct DDValMethods {\n+    pub clone: fn(this: &DDVal) -> DDVal,\n+    pub into_record: fn(this: DDVal) -> Record,\n+    pub eq: fn(this: &DDVal, other: &DDVal) -> bool,\n+    pub partial_cmp: fn(this: &DDVal, other: &DDVal) -> Option<std::cmp::Ordering>,\n+    pub cmp: fn(this: &DDVal, other: &DDVal) -> std::cmp::Ordering,\n+    pub hash: fn(this: &DDVal, state: &mut dyn Hasher),\n+    pub mutate: fn(this: &mut DDVal, record: &Record) -> Result<(), String>,\n+    pub fmt_debug: fn(this: &DDVal, f: &mut Formatter) -> Result<(), std::fmt::Error>,\n+    pub fmt_display: fn(this: &DDVal, f: &mut Formatter) -> Result<(), std::fmt::Error>,\n+    pub drop: fn(this: &mut DDVal),\n+    pub ddval_serialize: fn(this: &DDVal) -> &dyn DDValSerialize,\n+}\n+\n+impl Drop for DDValue {\n+    fn drop(&mut self) {\n+        (self.vtable.drop)(&mut self.val);\n+    }\n+}\n+\n+impl DDValue {\n+    pub fn new(val: DDVal, vtable: &'static DDValMethods) -> DDValue {\n+        DDValue { val, vtable }\n+    }\n+\n+    pub fn into_ddval(self) -> DDVal {\n+        let res = DDVal { v: self.val.v };\n+        std::mem::forget(self);\n+        res\n+    }\n+}\n+\n+impl Mutator<DDValue> for Record {\n+    fn mutate(&self, x: &mut DDValue) -> Result<(), String> {\n+        (x.vtable.mutate)(&mut x.val, self)\n+    }\n+}\n+\n+impl IntoRecord for DDValue {\n+    fn into_record(self) -> Record {\n+        (self.vtable.into_record)(self.into_ddval())\n+    }\n+}\n+\n+impl Abomonation for DDValue {\n+    unsafe fn entomb<W: std::io::Write>(&self, _write: &mut W) -> std::io::Result<()> {\n+        panic!(\"DDValue::entomb: not implemented\")\n+    }\n+    unsafe fn exhume<'a, 'b>(&'a mut self, _bytes: &'b mut [u8]) -> Option<&'b mut [u8]> {\n+        panic!(\"DDValue::exhume: not implemented\")\n+    }\n+    fn extent(&self) -> usize {\n+        panic!(\"DDValue::extent: not implemented\")\n+    }\n+}\n+\n+impl Serialize for DDValue {\n+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n+    where\n+        S: Serializer,\n+    {\n+        (self.vtable.ddval_serialize)(&self.val).serialize(serializer)\n+    }\n+}\n+\n+impl<'de> Deserialize<'de> for DDValue {\n+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n+    where\n+        D: Deserializer<'de>,\n+    {\n+        let val: Box<dyn DDValSerialize> = Deserialize::deserialize(deserializer)?;\n+        Ok(val.ddvalue())\n+    }\n+}\n+\n+impl Display for DDValue {\n+    fn fmt(&self, f: &mut Formatter) -> Result<(), std::fmt::Error> {\n+        (self.vtable.fmt_display)(&self.val, f)\n+    }\n+}\n+\n+impl Debug for DDValue {\n+    fn fmt(&self, f: &mut Formatter) -> Result<(), std::fmt::Error> {\n+        (self.vtable.fmt_debug)(&self.val, f)\n+    }\n+}\n+\n+impl PartialOrd for DDValue {\n+    fn partial_cmp(&self, other: &DDValue) -> Option<std::cmp::Ordering> {\n+        (self.vtable.partial_cmp)(&self.val, &other.val)\n+    }\n+}\n+\n+impl PartialEq for DDValue {\n+    fn eq(&self, other: &Self) -> bool {\n+        (self.vtable.eq)(&self.val, &other.val)\n+    }\n+}\n+\n+impl Eq for DDValue {}\n+\n+impl Ord for DDValue {\n+    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n+        (self.vtable.cmp)(&self.val, &other.val)\n+    }\n+}\n+\n+impl Clone for DDValue {\n+    fn clone(&self) -> Self {\n+        DDValue {\n+            val: (self.vtable.clone)(&self.val),\n+            vtable: self.vtable,\n+        }\n+    }\n+}\n+\n+impl Hash for DDValue {\n+    fn hash<H>(&self, state: &mut H)\n+    where\n+        H: Hasher,\n+    {\n+        (self.vtable.hash)(&self.val, state)\n+    }\n+}\n+\n+/// Trait to convert `DDVal` into concrete value type and back.\n+pub trait DDValConvert: Sized {\n+    /// Extract reference to concrete type from `&DDVal`.  This causes undefined behavior\n+    /// if `v` does not contain a value of type `Self`.\n+    unsafe fn from_ddval_ref(v: &DDVal) -> &Self;\n+\n+    unsafe fn from_ddvalue_ref(v: &DDValue) -> &Self {\n+        Self::from_ddval_ref(&v.val)\n+    }\n+\n+    /// Extract mutable reference to concrete type from `&mut DDVal`.  This causes\n+    /// undefined behavior if `v` does not contain a value of type `Self`.\n+    unsafe fn from_ddval_mut_ref(v: &mut DDVal) -> &mut Self;\n+\n+    /// Extracts concrete value contained in `v`.  Panics if `v` does not contain a\n+    /// value of type `Self`.\n+    unsafe fn from_ddval(v: DDVal) -> Self;\n+\n+    unsafe fn from_ddvalue(v: DDValue) -> Self {\n+        Self::from_ddval(v.into_ddval())\n+    }\n+\n+    /// Convert a value to a `DDVal`, erasing its original type.  This is a safe conversion\n+    /// that cannot fail.\n+    fn into_ddval(self) -> DDVal;\n+\n+    fn into_ddvalue(self) -> DDValue;\n+}\n+\n+#[typetag::serde]\n+pub trait DDValSerialize {\n+    fn ddvalue(&self) -> DDValue;\n+}\n+\n+/// Macro to implement `DDValConvert` for type `t` that satisfies the following type bounds:\n+///\n+/// t: Eq + Ord + Clone + Send + Debug + Sync + Hash + PartialOrd + IntoRecord + 'static,\n+/// Record: Mutator<t>\n+///\n+#[macro_export]\n+macro_rules! decl_ddval_convert {\n+    ( $t:ty ) => {\n+        #[typetag::serde]\n+        impl $crate::ddval::DDValSerialize for $t {\n+            fn ddvalue(&self) -> $crate::ddval::DDValue {\n+                $crate::ddval::DDValConvert::into_ddvalue(self.clone())\n+            }\n+        }\n+\n+        impl $crate::ddval::DDValConvert for $t {\n+            unsafe fn from_ddval_ref(v: &$crate::ddval::DDVal) -> &Self {\n+                if std::mem::size_of::<Self>() <= std::mem::size_of::<usize>() {\n+                    &*(&v.v as *const usize as *const Self)\n+                } else {\n+                    &*(v.v as *const Self)\n+                }\n+            }\n+\n+            unsafe fn from_ddval_mut_ref(v: &mut $crate::ddval::DDVal) -> &mut Self {\n+                if std::mem::size_of::<Self>() <= std::mem::size_of::<usize>() {\n+                    &mut *(&mut v.v as *mut usize as *mut Self)\n+                } else {\n+                    let arc = std::sync::Arc::from_raw(v.v as *const Self);\n+                    v.v = std::sync::Arc::into_raw(arc) as usize;\n+                    &mut *(v.v as *mut Self)\n+                }\n+            }\n+\n+            unsafe fn from_ddval(v: $crate::ddval::DDVal) -> Self {\n+                if std::mem::size_of::<Self>() <= std::mem::size_of::<usize>() {\n+                    let res: Self = std::mem::transmute::<[u8; std::mem::size_of::<Self>()], Self>(\n+                        *(&v.v as *const usize as *const [u8; std::mem::size_of::<Self>()]),\n+                    );\n+                    std::mem::forget(v);\n+                    res\n+                } else {\n+                    let arc = std::sync::Arc::from_raw(v.v as *const Self);\n+                    std::sync::Arc::try_unwrap(arc).unwrap_or_else(|a| (*a).clone())\n+                }\n+            }\n+\n+            fn into_ddval(self) -> $crate::ddval::DDVal {\n+                if std::mem::size_of::<Self>() <= std::mem::size_of::<usize>() {\n+                    let mut v: usize = 0;\n+                    unsafe {\n+                        *(&mut v as *mut usize as *mut [u8; std::mem::size_of::<Self>()]) =\n+                            std::mem::transmute::<Self, [u8; std::mem::size_of::<Self>()]>(self);\n+                    };\n+                    $crate::ddval::DDVal { v }\n+                } else {\n+                    $crate::ddval::DDVal {\n+                        v: std::sync::Arc::into_raw(std::sync::Arc::new(self)) as usize,\n+                    }\n+                }\n+            }\n+\n+            fn into_ddvalue(self) -> $crate::ddval::DDValue {\n+                const VTABLE: $crate::ddval::DDValMethods = $crate::ddval::DDValMethods {\n+                    clone: {\n+                        fn __f(this: &$crate::ddval::DDVal) -> $crate::ddval::DDVal {\n+                            if std::mem::size_of::<$t>() <= std::mem::size_of::<usize>() {\n+                                unsafe { <$t>::from_ddval_ref(this) }.clone().into_ddval()\n+                            } else {\n+                                let arc = unsafe { std::sync::Arc::from_raw(this.v as *const $t) };\n+                                let res = $crate::ddval::DDVal {\n+                                    v: std::sync::Arc::into_raw(arc.clone()) as usize,\n+                                };\n+                                std::sync::Arc::into_raw(arc);\n+                                res\n+                            }\n+                        };\n+                        __f\n+                    },\n+                    into_record: {\n+                        fn __f(this: $crate::ddval::DDVal) -> $crate::record::Record {\n+                            unsafe { <$t>::from_ddval(this) }.into_record()\n+                        };\n+                        __f\n+                    },\n+                    eq: {\n+                        fn __f(this: &$crate::ddval::DDVal, other: &$crate::ddval::DDVal) -> bool {\n+                            unsafe { <$t>::from_ddval_ref(this).eq(<$t>::from_ddval_ref(other)) }\n+                        };\n+                        __f\n+                    },\n+                    partial_cmp: {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a5a18288ac80d325d0bd391f3d86c3007f5604c"}, "originalPosition": 336}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk2MjA1Mw==", "bodyText": "No. Values of different types should never be compared. We enforce this at runtime.", "url": "https://github.com/vmware/differential-datalog/pull/501#discussion_r365962053", "createdAt": "2020-01-13T18:37:51Z", "author": {"login": "ryzhyk"}, "path": "rust/template/differential_datalog/ddval.rs", "diffHunk": "@@ -0,0 +1,423 @@\n+//! DDValue: Generic value type stored in all differential-dataflow relations.\n+//!\n+//! Rationale: Differential dataflow allows the user to assign an arbitrary user-defined type to\n+//! each collection.  It relies on Rust's static dispatch mechanism to specialize its internal\n+//! machinery for each user-defined type.  Unfortunately, beyond very simple programs this leads to\n+//! extremely long compilation times.  One workaround that we used to rely on is to declare a\n+//! single enum type with a variant per concrete type used in at least one relation.  This make\n+//! compilation feasible, but still very slow (~6 minutes for a simple DDlog program and ~10\n+//! minutes for complex programs).\n+//!\n+//! Another alternative we implement here is to use a fixed value type that does not depend on\n+//! a concrete DDlog program and rely on dynamic dispatch to forward operations that DD expects\n+//! all values to implement (comparison, hashing, etc.) to their concrete implementations.  This\n+//! way this crate (differetial-datalog) can be compiled all the way to binary code separately\n+//! from the DDlog program using it and does not need to be re-compiled when the DDlog program\n+//! changes.  Thus, the only part that must be re-compiled on changes to the DDlog code is the\n+//! auto-generated crate that declares concrete value types and rules.  This is much faster than\n+//! re-compiling both crates together.\n+//!\n+//! The next design decision is how to implement dynamic dispatch.  Rust trait objects is an\n+//! obvious choice, with value type being declared as `Box<dyn SomeTrait>`.  However, this proved\n+//! suboptimal in our experiments, as this design requires a dynamic memory allocation per value,\n+//! no matter how small.  Furthermore, cloning a value (which DD does a lot, e.g., during\n+//! compaction) requires another allocation.\n+//!\n+//! We improve over this naive design in two ways.  First, we use `Arc` instead of `Box`, which\n+//! introduces extra space overhead to store the reference count, but avoids memory allocation due\n+//! to cloning and shares the same heap allocation across multiple copies of the value.  Second, we\n+//! store small objects <=`usize` bytes inline instead of wrapping them in an Arc to avoid dynamic\n+//! memory allocation for such objects altogether.  Unfortunately, Rust's dynamic dispatch\n+//! mechanism does not support this, so we roll our own instead, with the following `DDValue`\n+//! declaration:\n+//!\n+//! ```\n+//! use differential_datalog::ddval::*;\n+//! pub struct DDValue {\n+//!    val: DDVal,\n+//!    vtable: &'static DDValMethods,\n+//! }\n+//! ```\n+//!\n+//! where `DDVal` is a `usize` that stores either an `Arc<T>` or `T` (where `T` is the actual type\n+//! of value stored in the DDlog relation), and `DDValMethods` is a virtual table of methods that\n+//! must be implemented for all DD values.\n+//!\n+//! This design still requires a separate heap allocation for each value >8 bytes, which slows\n+//! things down quite a bit.  Nevertheless, it has the same performance as our earlier\n+//! implementation using static dispatch and at least in some benchmarks uses less memory.  The\n+//! only way to improve things further I can think of is to somehow co-design this with DD to use\n+//! DD's knowledge of the context where a value is being created to, e.g., allocate blocks of\n+//! values when possible.\n+//!\n+\n+use std::fmt::Debug;\n+use std::fmt::Display;\n+use std::fmt::Formatter;\n+use std::hash::Hash;\n+use std::hash::Hasher;\n+\n+use serde::de::Deserialize;\n+use serde::de::Deserializer;\n+use serde::ser::Serialize;\n+use serde::ser::Serializer;\n+\n+use abomonation::Abomonation;\n+\n+use crate::record::IntoRecord;\n+use crate::record::Mutator;\n+use crate::record::Record;\n+\n+/// Type-erased representation of a value.  Can store the actual value or a pointer to it.\n+/// This could be just a `usize`, but we wrap it in a struct as we don't want it to implement\n+/// `Copy`.\n+pub struct DDVal {\n+    pub v: usize,\n+}\n+\n+/// DDValue: this type is stored in all DD collections.\n+/// It consists of value and associated vtable.\n+pub struct DDValue {\n+    val: DDVal,\n+    vtable: &'static DDValMethods,\n+}\n+\n+/// vtable of methods to be implemented by every value stored in DD.\n+pub struct DDValMethods {\n+    pub clone: fn(this: &DDVal) -> DDVal,\n+    pub into_record: fn(this: DDVal) -> Record,\n+    pub eq: fn(this: &DDVal, other: &DDVal) -> bool,\n+    pub partial_cmp: fn(this: &DDVal, other: &DDVal) -> Option<std::cmp::Ordering>,\n+    pub cmp: fn(this: &DDVal, other: &DDVal) -> std::cmp::Ordering,\n+    pub hash: fn(this: &DDVal, state: &mut dyn Hasher),\n+    pub mutate: fn(this: &mut DDVal, record: &Record) -> Result<(), String>,\n+    pub fmt_debug: fn(this: &DDVal, f: &mut Formatter) -> Result<(), std::fmt::Error>,\n+    pub fmt_display: fn(this: &DDVal, f: &mut Formatter) -> Result<(), std::fmt::Error>,\n+    pub drop: fn(this: &mut DDVal),\n+    pub ddval_serialize: fn(this: &DDVal) -> &dyn DDValSerialize,\n+}\n+\n+impl Drop for DDValue {\n+    fn drop(&mut self) {\n+        (self.vtable.drop)(&mut self.val);\n+    }\n+}\n+\n+impl DDValue {\n+    pub fn new(val: DDVal, vtable: &'static DDValMethods) -> DDValue {\n+        DDValue { val, vtable }\n+    }\n+\n+    pub fn into_ddval(self) -> DDVal {\n+        let res = DDVal { v: self.val.v };\n+        std::mem::forget(self);\n+        res\n+    }\n+}\n+\n+impl Mutator<DDValue> for Record {\n+    fn mutate(&self, x: &mut DDValue) -> Result<(), String> {\n+        (x.vtable.mutate)(&mut x.val, self)\n+    }\n+}\n+\n+impl IntoRecord for DDValue {\n+    fn into_record(self) -> Record {\n+        (self.vtable.into_record)(self.into_ddval())\n+    }\n+}\n+\n+impl Abomonation for DDValue {\n+    unsafe fn entomb<W: std::io::Write>(&self, _write: &mut W) -> std::io::Result<()> {\n+        panic!(\"DDValue::entomb: not implemented\")\n+    }\n+    unsafe fn exhume<'a, 'b>(&'a mut self, _bytes: &'b mut [u8]) -> Option<&'b mut [u8]> {\n+        panic!(\"DDValue::exhume: not implemented\")\n+    }\n+    fn extent(&self) -> usize {\n+        panic!(\"DDValue::extent: not implemented\")\n+    }\n+}\n+\n+impl Serialize for DDValue {\n+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n+    where\n+        S: Serializer,\n+    {\n+        (self.vtable.ddval_serialize)(&self.val).serialize(serializer)\n+    }\n+}\n+\n+impl<'de> Deserialize<'de> for DDValue {\n+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n+    where\n+        D: Deserializer<'de>,\n+    {\n+        let val: Box<dyn DDValSerialize> = Deserialize::deserialize(deserializer)?;\n+        Ok(val.ddvalue())\n+    }\n+}\n+\n+impl Display for DDValue {\n+    fn fmt(&self, f: &mut Formatter) -> Result<(), std::fmt::Error> {\n+        (self.vtable.fmt_display)(&self.val, f)\n+    }\n+}\n+\n+impl Debug for DDValue {\n+    fn fmt(&self, f: &mut Formatter) -> Result<(), std::fmt::Error> {\n+        (self.vtable.fmt_debug)(&self.val, f)\n+    }\n+}\n+\n+impl PartialOrd for DDValue {\n+    fn partial_cmp(&self, other: &DDValue) -> Option<std::cmp::Ordering> {\n+        (self.vtable.partial_cmp)(&self.val, &other.val)\n+    }\n+}\n+\n+impl PartialEq for DDValue {\n+    fn eq(&self, other: &Self) -> bool {\n+        (self.vtable.eq)(&self.val, &other.val)\n+    }\n+}\n+\n+impl Eq for DDValue {}\n+\n+impl Ord for DDValue {\n+    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n+        (self.vtable.cmp)(&self.val, &other.val)\n+    }\n+}\n+\n+impl Clone for DDValue {\n+    fn clone(&self) -> Self {\n+        DDValue {\n+            val: (self.vtable.clone)(&self.val),\n+            vtable: self.vtable,\n+        }\n+    }\n+}\n+\n+impl Hash for DDValue {\n+    fn hash<H>(&self, state: &mut H)\n+    where\n+        H: Hasher,\n+    {\n+        (self.vtable.hash)(&self.val, state)\n+    }\n+}\n+\n+/// Trait to convert `DDVal` into concrete value type and back.\n+pub trait DDValConvert: Sized {\n+    /// Extract reference to concrete type from `&DDVal`.  This causes undefined behavior\n+    /// if `v` does not contain a value of type `Self`.\n+    unsafe fn from_ddval_ref(v: &DDVal) -> &Self;\n+\n+    unsafe fn from_ddvalue_ref(v: &DDValue) -> &Self {\n+        Self::from_ddval_ref(&v.val)\n+    }\n+\n+    /// Extract mutable reference to concrete type from `&mut DDVal`.  This causes\n+    /// undefined behavior if `v` does not contain a value of type `Self`.\n+    unsafe fn from_ddval_mut_ref(v: &mut DDVal) -> &mut Self;\n+\n+    /// Extracts concrete value contained in `v`.  Panics if `v` does not contain a\n+    /// value of type `Self`.\n+    unsafe fn from_ddval(v: DDVal) -> Self;\n+\n+    unsafe fn from_ddvalue(v: DDValue) -> Self {\n+        Self::from_ddval(v.into_ddval())\n+    }\n+\n+    /// Convert a value to a `DDVal`, erasing its original type.  This is a safe conversion\n+    /// that cannot fail.\n+    fn into_ddval(self) -> DDVal;\n+\n+    fn into_ddvalue(self) -> DDValue;\n+}\n+\n+#[typetag::serde]\n+pub trait DDValSerialize {\n+    fn ddvalue(&self) -> DDValue;\n+}\n+\n+/// Macro to implement `DDValConvert` for type `t` that satisfies the following type bounds:\n+///\n+/// t: Eq + Ord + Clone + Send + Debug + Sync + Hash + PartialOrd + IntoRecord + 'static,\n+/// Record: Mutator<t>\n+///\n+#[macro_export]\n+macro_rules! decl_ddval_convert {\n+    ( $t:ty ) => {\n+        #[typetag::serde]\n+        impl $crate::ddval::DDValSerialize for $t {\n+            fn ddvalue(&self) -> $crate::ddval::DDValue {\n+                $crate::ddval::DDValConvert::into_ddvalue(self.clone())\n+            }\n+        }\n+\n+        impl $crate::ddval::DDValConvert for $t {\n+            unsafe fn from_ddval_ref(v: &$crate::ddval::DDVal) -> &Self {\n+                if std::mem::size_of::<Self>() <= std::mem::size_of::<usize>() {\n+                    &*(&v.v as *const usize as *const Self)\n+                } else {\n+                    &*(v.v as *const Self)\n+                }\n+            }\n+\n+            unsafe fn from_ddval_mut_ref(v: &mut $crate::ddval::DDVal) -> &mut Self {\n+                if std::mem::size_of::<Self>() <= std::mem::size_of::<usize>() {\n+                    &mut *(&mut v.v as *mut usize as *mut Self)\n+                } else {\n+                    let arc = std::sync::Arc::from_raw(v.v as *const Self);\n+                    v.v = std::sync::Arc::into_raw(arc) as usize;\n+                    &mut *(v.v as *mut Self)\n+                }\n+            }\n+\n+            unsafe fn from_ddval(v: $crate::ddval::DDVal) -> Self {\n+                if std::mem::size_of::<Self>() <= std::mem::size_of::<usize>() {\n+                    let res: Self = std::mem::transmute::<[u8; std::mem::size_of::<Self>()], Self>(\n+                        *(&v.v as *const usize as *const [u8; std::mem::size_of::<Self>()]),\n+                    );\n+                    std::mem::forget(v);\n+                    res\n+                } else {\n+                    let arc = std::sync::Arc::from_raw(v.v as *const Self);\n+                    std::sync::Arc::try_unwrap(arc).unwrap_or_else(|a| (*a).clone())\n+                }\n+            }\n+\n+            fn into_ddval(self) -> $crate::ddval::DDVal {\n+                if std::mem::size_of::<Self>() <= std::mem::size_of::<usize>() {\n+                    let mut v: usize = 0;\n+                    unsafe {\n+                        *(&mut v as *mut usize as *mut [u8; std::mem::size_of::<Self>()]) =\n+                            std::mem::transmute::<Self, [u8; std::mem::size_of::<Self>()]>(self);\n+                    };\n+                    $crate::ddval::DDVal { v }\n+                } else {\n+                    $crate::ddval::DDVal {\n+                        v: std::sync::Arc::into_raw(std::sync::Arc::new(self)) as usize,\n+                    }\n+                }\n+            }\n+\n+            fn into_ddvalue(self) -> $crate::ddval::DDValue {\n+                const VTABLE: $crate::ddval::DDValMethods = $crate::ddval::DDValMethods {\n+                    clone: {\n+                        fn __f(this: &$crate::ddval::DDVal) -> $crate::ddval::DDVal {\n+                            if std::mem::size_of::<$t>() <= std::mem::size_of::<usize>() {\n+                                unsafe { <$t>::from_ddval_ref(this) }.clone().into_ddval()\n+                            } else {\n+                                let arc = unsafe { std::sync::Arc::from_raw(this.v as *const $t) };\n+                                let res = $crate::ddval::DDVal {\n+                                    v: std::sync::Arc::into_raw(arc.clone()) as usize,\n+                                };\n+                                std::sync::Arc::into_raw(arc);\n+                                res\n+                            }\n+                        };\n+                        __f\n+                    },\n+                    into_record: {\n+                        fn __f(this: $crate::ddval::DDVal) -> $crate::record::Record {\n+                            unsafe { <$t>::from_ddval(this) }.into_record()\n+                        };\n+                        __f\n+                    },\n+                    eq: {\n+                        fn __f(this: &$crate::ddval::DDVal, other: &$crate::ddval::DDVal) -> bool {\n+                            unsafe { <$t>::from_ddval_ref(this).eq(<$t>::from_ddval_ref(other)) }\n+                        };\n+                        __f\n+                    },\n+                    partial_cmp: {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk0NDA4Ng=="}, "originalCommit": {"oid": "4a5a18288ac80d325d0bd391f3d86c3007f5604c"}, "originalPosition": 336}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2MDc5Njg1OnYy", "diffSide": "RIGHT", "path": "rust/template/differential_datalog/ddval.rs", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxNzo1ODoyMlrOFc_fmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxNzo1ODoyMlrOFc_fmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk0NDcyOQ==", "bodyText": "This is actually quite nice - the fact you can do this in such a compact way.\nI don't think there are many languages where you can do this kind of stuff.", "url": "https://github.com/vmware/differential-datalog/pull/501#discussion_r365944729", "createdAt": "2020-01-13T17:58:22Z", "author": {"login": "mbudiu-vmw"}, "path": "rust/template/differential_datalog/ddval.rs", "diffHunk": "@@ -0,0 +1,423 @@\n+//! DDValue: Generic value type stored in all differential-dataflow relations.\n+//!\n+//! Rationale: Differential dataflow allows the user to assign an arbitrary user-defined type to\n+//! each collection.  It relies on Rust's static dispatch mechanism to specialize its internal\n+//! machinery for each user-defined type.  Unfortunately, beyond very simple programs this leads to\n+//! extremely long compilation times.  One workaround that we used to rely on is to declare a\n+//! single enum type with a variant per concrete type used in at least one relation.  This make\n+//! compilation feasible, but still very slow (~6 minutes for a simple DDlog program and ~10\n+//! minutes for complex programs).\n+//!\n+//! Another alternative we implement here is to use a fixed value type that does not depend on\n+//! a concrete DDlog program and rely on dynamic dispatch to forward operations that DD expects\n+//! all values to implement (comparison, hashing, etc.) to their concrete implementations.  This\n+//! way this crate (differetial-datalog) can be compiled all the way to binary code separately\n+//! from the DDlog program using it and does not need to be re-compiled when the DDlog program\n+//! changes.  Thus, the only part that must be re-compiled on changes to the DDlog code is the\n+//! auto-generated crate that declares concrete value types and rules.  This is much faster than\n+//! re-compiling both crates together.\n+//!\n+//! The next design decision is how to implement dynamic dispatch.  Rust trait objects is an\n+//! obvious choice, with value type being declared as `Box<dyn SomeTrait>`.  However, this proved\n+//! suboptimal in our experiments, as this design requires a dynamic memory allocation per value,\n+//! no matter how small.  Furthermore, cloning a value (which DD does a lot, e.g., during\n+//! compaction) requires another allocation.\n+//!\n+//! We improve over this naive design in two ways.  First, we use `Arc` instead of `Box`, which\n+//! introduces extra space overhead to store the reference count, but avoids memory allocation due\n+//! to cloning and shares the same heap allocation across multiple copies of the value.  Second, we\n+//! store small objects <=`usize` bytes inline instead of wrapping them in an Arc to avoid dynamic\n+//! memory allocation for such objects altogether.  Unfortunately, Rust's dynamic dispatch\n+//! mechanism does not support this, so we roll our own instead, with the following `DDValue`\n+//! declaration:\n+//!\n+//! ```\n+//! use differential_datalog::ddval::*;\n+//! pub struct DDValue {\n+//!    val: DDVal,\n+//!    vtable: &'static DDValMethods,\n+//! }\n+//! ```\n+//!\n+//! where `DDVal` is a `usize` that stores either an `Arc<T>` or `T` (where `T` is the actual type\n+//! of value stored in the DDlog relation), and `DDValMethods` is a virtual table of methods that\n+//! must be implemented for all DD values.\n+//!\n+//! This design still requires a separate heap allocation for each value >8 bytes, which slows\n+//! things down quite a bit.  Nevertheless, it has the same performance as our earlier\n+//! implementation using static dispatch and at least in some benchmarks uses less memory.  The\n+//! only way to improve things further I can think of is to somehow co-design this with DD to use\n+//! DD's knowledge of the context where a value is being created to, e.g., allocate blocks of\n+//! values when possible.\n+//!\n+\n+use std::fmt::Debug;\n+use std::fmt::Display;\n+use std::fmt::Formatter;\n+use std::hash::Hash;\n+use std::hash::Hasher;\n+\n+use serde::de::Deserialize;\n+use serde::de::Deserializer;\n+use serde::ser::Serialize;\n+use serde::ser::Serializer;\n+\n+use abomonation::Abomonation;\n+\n+use crate::record::IntoRecord;\n+use crate::record::Mutator;\n+use crate::record::Record;\n+\n+/// Type-erased representation of a value.  Can store the actual value or a pointer to it.\n+/// This could be just a `usize`, but we wrap it in a struct as we don't want it to implement\n+/// `Copy`.\n+pub struct DDVal {\n+    pub v: usize,\n+}\n+\n+/// DDValue: this type is stored in all DD collections.\n+/// It consists of value and associated vtable.\n+pub struct DDValue {\n+    val: DDVal,\n+    vtable: &'static DDValMethods,\n+}\n+\n+/// vtable of methods to be implemented by every value stored in DD.\n+pub struct DDValMethods {\n+    pub clone: fn(this: &DDVal) -> DDVal,\n+    pub into_record: fn(this: DDVal) -> Record,\n+    pub eq: fn(this: &DDVal, other: &DDVal) -> bool,\n+    pub partial_cmp: fn(this: &DDVal, other: &DDVal) -> Option<std::cmp::Ordering>,\n+    pub cmp: fn(this: &DDVal, other: &DDVal) -> std::cmp::Ordering,\n+    pub hash: fn(this: &DDVal, state: &mut dyn Hasher),\n+    pub mutate: fn(this: &mut DDVal, record: &Record) -> Result<(), String>,\n+    pub fmt_debug: fn(this: &DDVal, f: &mut Formatter) -> Result<(), std::fmt::Error>,\n+    pub fmt_display: fn(this: &DDVal, f: &mut Formatter) -> Result<(), std::fmt::Error>,\n+    pub drop: fn(this: &mut DDVal),\n+    pub ddval_serialize: fn(this: &DDVal) -> &dyn DDValSerialize,\n+}\n+\n+impl Drop for DDValue {\n+    fn drop(&mut self) {\n+        (self.vtable.drop)(&mut self.val);\n+    }\n+}\n+\n+impl DDValue {\n+    pub fn new(val: DDVal, vtable: &'static DDValMethods) -> DDValue {\n+        DDValue { val, vtable }\n+    }\n+\n+    pub fn into_ddval(self) -> DDVal {\n+        let res = DDVal { v: self.val.v };\n+        std::mem::forget(self);\n+        res\n+    }\n+}\n+\n+impl Mutator<DDValue> for Record {\n+    fn mutate(&self, x: &mut DDValue) -> Result<(), String> {\n+        (x.vtable.mutate)(&mut x.val, self)\n+    }\n+}\n+\n+impl IntoRecord for DDValue {\n+    fn into_record(self) -> Record {\n+        (self.vtable.into_record)(self.into_ddval())\n+    }\n+}\n+\n+impl Abomonation for DDValue {\n+    unsafe fn entomb<W: std::io::Write>(&self, _write: &mut W) -> std::io::Result<()> {\n+        panic!(\"DDValue::entomb: not implemented\")\n+    }\n+    unsafe fn exhume<'a, 'b>(&'a mut self, _bytes: &'b mut [u8]) -> Option<&'b mut [u8]> {\n+        panic!(\"DDValue::exhume: not implemented\")\n+    }\n+    fn extent(&self) -> usize {\n+        panic!(\"DDValue::extent: not implemented\")\n+    }\n+}\n+\n+impl Serialize for DDValue {\n+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n+    where\n+        S: Serializer,\n+    {\n+        (self.vtable.ddval_serialize)(&self.val).serialize(serializer)\n+    }\n+}\n+\n+impl<'de> Deserialize<'de> for DDValue {\n+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n+    where\n+        D: Deserializer<'de>,\n+    {\n+        let val: Box<dyn DDValSerialize> = Deserialize::deserialize(deserializer)?;\n+        Ok(val.ddvalue())\n+    }\n+}\n+\n+impl Display for DDValue {\n+    fn fmt(&self, f: &mut Formatter) -> Result<(), std::fmt::Error> {\n+        (self.vtable.fmt_display)(&self.val, f)\n+    }\n+}\n+\n+impl Debug for DDValue {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a5a18288ac80d325d0bd391f3d86c3007f5604c"}, "originalPosition": 167}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2MDgwMDM1OnYy", "diffSide": "RIGHT", "path": "rust/template/differential_datalog/ddval.rs", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxNzo1OTo0MVrOFc_hyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxODozOTowN1rOFdAlaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk0NTI5MQ==", "bodyText": "So this won't help much the tests?", "url": "https://github.com/vmware/differential-datalog/pull/501#discussion_r365945291", "createdAt": "2020-01-13T17:59:41Z", "author": {"login": "mbudiu-vmw"}, "path": "rust/template/differential_datalog/ddval.rs", "diffHunk": "@@ -0,0 +1,423 @@\n+//! DDValue: Generic value type stored in all differential-dataflow relations.\n+//!\n+//! Rationale: Differential dataflow allows the user to assign an arbitrary user-defined type to\n+//! each collection.  It relies on Rust's static dispatch mechanism to specialize its internal\n+//! machinery for each user-defined type.  Unfortunately, beyond very simple programs this leads to\n+//! extremely long compilation times.  One workaround that we used to rely on is to declare a\n+//! single enum type with a variant per concrete type used in at least one relation.  This make\n+//! compilation feasible, but still very slow (~6 minutes for a simple DDlog program and ~10\n+//! minutes for complex programs).\n+//!\n+//! Another alternative we implement here is to use a fixed value type that does not depend on\n+//! a concrete DDlog program and rely on dynamic dispatch to forward operations that DD expects\n+//! all values to implement (comparison, hashing, etc.) to their concrete implementations.  This\n+//! way this crate (differetial-datalog) can be compiled all the way to binary code separately\n+//! from the DDlog program using it and does not need to be re-compiled when the DDlog program\n+//! changes.  Thus, the only part that must be re-compiled on changes to the DDlog code is the\n+//! auto-generated crate that declares concrete value types and rules.  This is much faster than\n+//! re-compiling both crates together.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a5a18288ac80d325d0bd391f3d86c3007f5604c"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk2MjYwMw==", "bodyText": "Not until we move the shared crate out of the template and in a separate location (even then I wonder what it will take to convince Rust not to re-compile it for each test).", "url": "https://github.com/vmware/differential-datalog/pull/501#discussion_r365962603", "createdAt": "2020-01-13T18:39:07Z", "author": {"login": "ryzhyk"}, "path": "rust/template/differential_datalog/ddval.rs", "diffHunk": "@@ -0,0 +1,423 @@\n+//! DDValue: Generic value type stored in all differential-dataflow relations.\n+//!\n+//! Rationale: Differential dataflow allows the user to assign an arbitrary user-defined type to\n+//! each collection.  It relies on Rust's static dispatch mechanism to specialize its internal\n+//! machinery for each user-defined type.  Unfortunately, beyond very simple programs this leads to\n+//! extremely long compilation times.  One workaround that we used to rely on is to declare a\n+//! single enum type with a variant per concrete type used in at least one relation.  This make\n+//! compilation feasible, but still very slow (~6 minutes for a simple DDlog program and ~10\n+//! minutes for complex programs).\n+//!\n+//! Another alternative we implement here is to use a fixed value type that does not depend on\n+//! a concrete DDlog program and rely on dynamic dispatch to forward operations that DD expects\n+//! all values to implement (comparison, hashing, etc.) to their concrete implementations.  This\n+//! way this crate (differetial-datalog) can be compiled all the way to binary code separately\n+//! from the DDlog program using it and does not need to be re-compiled when the DDlog program\n+//! changes.  Thus, the only part that must be re-compiled on changes to the DDlog code is the\n+//! auto-generated crate that declares concrete value types and rules.  This is much faster than\n+//! re-compiling both crates together.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk0NTI5MQ=="}, "originalCommit": {"oid": "4a5a18288ac80d325d0bd391f3d86c3007f5604c"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2MDgwNDU5OnYy", "diffSide": "RIGHT", "path": "rust/template/differential_datalog/program.rs", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxODowMDo1OVrOFc_kRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxODowMDo1OVrOFc_kRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk0NTkyNw==", "bodyText": "This is actually very nice - it's almost search-and-replace.", "url": "https://github.com/vmware/differential-datalog/pull/501#discussion_r365945927", "createdAt": "2020-01-13T18:00:59Z", "author": {"login": "mbudiu-vmw"}, "path": "rust/template/differential_datalog/program.rs", "diffHunk": "@@ -2525,7 +2479,7 @@ impl<V: Val> RunningProgram<V> {\n     }\n \n     /* Broadcast message to all worker threads. */\n-    fn broadcast(&self, msg: Msg<V>) -> Response<()> {\n+    fn broadcast(&self, msg: Msg) -> Response<()> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a5a18288ac80d325d0bd391f3d86c3007f5604c"}, "originalPosition": 1140}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2MDgxODQwOnYy", "diffSide": "RIGHT", "path": "rust/template/differential_datalog/test.rs", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxODowNjowM1rOFc_szQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxODo0MjozNVrOFdArkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk0ODEwOQ==", "bodyText": "This does not seem to be the same thing as the original code - this can never return None.\nWas the original code unable to statically typecheck?\nWhere is the dynamic type check made?", "url": "https://github.com/vmware/differential-datalog/pull/501#discussion_r365948109", "createdAt": "2020-01-13T18:06:03Z", "author": {"login": "mbudiu-vmw"}, "path": "rust/template/differential_datalog/test.rs", "diffHunk": "@@ -639,20 +376,16 @@ fn test_semijoin(nthreads: usize) {\n             })))),\n         }\n     };\n-    fn fmfun1(v: Value) -> Option<Value> {\n-        match v {\n-            Value::Tuple2(v1, _v2) => Some(*v1),\n-            _ => None,\n-        }\n+    fn fmfun1(v: DDValue) -> Option<DDValue> {\n+        let Tuple2(ref v1, ref _v2) = unsafe { Tuple2::<U64>::from_ddvalue(v) };", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a5a18288ac80d325d0bd391f3d86c3007f5604c"}, "originalPosition": 497}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk2NDE3Ng==", "bodyText": "The original code used an enum Value and had to always match on it even though we knew exactly what variant we handle in every function. Now we use unsafe conversion instead.", "url": "https://github.com/vmware/differential-datalog/pull/501#discussion_r365964176", "createdAt": "2020-01-13T18:42:35Z", "author": {"login": "ryzhyk"}, "path": "rust/template/differential_datalog/test.rs", "diffHunk": "@@ -639,20 +376,16 @@ fn test_semijoin(nthreads: usize) {\n             })))),\n         }\n     };\n-    fn fmfun1(v: Value) -> Option<Value> {\n-        match v {\n-            Value::Tuple2(v1, _v2) => Some(*v1),\n-            _ => None,\n-        }\n+    fn fmfun1(v: DDValue) -> Option<DDValue> {\n+        let Tuple2(ref v1, ref _v2) = unsafe { Tuple2::<U64>::from_ddvalue(v) };", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk0ODEwOQ=="}, "originalCommit": {"oid": "4a5a18288ac80d325d0bd391f3d86c3007f5604c"}, "originalPosition": 497}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2MDg0NjA0OnYy", "diffSide": "RIGHT", "path": "src/Language/DifferentialDatalog/Compile.hs", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxODoxNjoyMlrOFc_-UA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxODo0MTowNVrOFdAo0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk1MjU5Mg==", "bodyText": "was this a bug? these do not seem to be equivalent.", "url": "https://github.com/vmware/differential-datalog/pull/501#discussion_r365952592", "createdAt": "2020-01-13T18:16:22Z", "author": {"login": "mbudiu-vmw"}, "path": "src/Language/DifferentialDatalog/Compile.hs", "diffHunk": "@@ -794,51 +765,51 @@ mkValueFromRecord d@DatalogProgram{..} =\n     mkIdxId2NameC                                                                                   $$\n     mkIdxIdMap d                                                                                    $$\n     mkIdxIdMapC d                                                                                   $$\n-    \"pub fn relval_from_record(rel: Relations, _rec: &record::Record) -> Result<Value, String> {\"   $$\n+    \"pub fn relval_from_record(rel: Relations, _rec: &record::Record) -> result::Result<DDValue, String> {\" $$\n     \"    match rel {\"                                                                               $$\n-    (nest' $ nest' $ vcat $ punctuate comma entries)                                                $$\n+    (nest' $ nest' $ vcommaSep entries)                                                             $$\n     \"    }\"                                                                                         $$\n     \"}\"                                                                                             $$\n-    \"pub fn relkey_from_record(rel: Relations, _rec: &record::Record) -> Result<Value, String> {\"   $$\n+    \"pub fn relkey_from_record(rel: Relations, _rec: &record::Record) -> result::Result<DDValue, String> {\" $$\n     \"    match rel {\"                                                                               $$\n-    (nest' $ nest' $ vcat $ key_entries)                                                            $$\n+    (nest' $ nest' $ vcommaSep key_entries)                                                         $$", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a5a18288ac80d325d0bd391f3d86c3007f5604c"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk2MzQ3NA==", "bodyText": "I think the comma used to be in key_entries.", "url": "https://github.com/vmware/differential-datalog/pull/501#discussion_r365963474", "createdAt": "2020-01-13T18:41:05Z", "author": {"login": "ryzhyk"}, "path": "src/Language/DifferentialDatalog/Compile.hs", "diffHunk": "@@ -794,51 +765,51 @@ mkValueFromRecord d@DatalogProgram{..} =\n     mkIdxId2NameC                                                                                   $$\n     mkIdxIdMap d                                                                                    $$\n     mkIdxIdMapC d                                                                                   $$\n-    \"pub fn relval_from_record(rel: Relations, _rec: &record::Record) -> Result<Value, String> {\"   $$\n+    \"pub fn relval_from_record(rel: Relations, _rec: &record::Record) -> result::Result<DDValue, String> {\" $$\n     \"    match rel {\"                                                                               $$\n-    (nest' $ nest' $ vcat $ punctuate comma entries)                                                $$\n+    (nest' $ nest' $ vcommaSep entries)                                                             $$\n     \"    }\"                                                                                         $$\n     \"}\"                                                                                             $$\n-    \"pub fn relkey_from_record(rel: Relations, _rec: &record::Record) -> Result<Value, String> {\"   $$\n+    \"pub fn relkey_from_record(rel: Relations, _rec: &record::Record) -> result::Result<DDValue, String> {\" $$\n     \"    match rel {\"                                                                               $$\n-    (nest' $ nest' $ vcat $ key_entries)                                                            $$\n+    (nest' $ nest' $ vcommaSep key_entries)                                                         $$", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk1MjU5Mg=="}, "originalCommit": {"oid": "4a5a18288ac80d325d0bd391f3d86c3007f5604c"}, "originalPosition": 135}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4847, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}