{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc5MzIwMzE1", "number": 534, "title": "Access fields of stucts & tuples wrapped in Ref's.", "bodyText": "This commit addresses one of the awkward aspects of working with complex\ntypes wrapped in Ref<>'s.  Ideally, we would like Ref<>'s to be as\ntransparent as possible, so that one could work with them as if they were\nobjects of the inner type wrapped in the Ref.  We're not quite there\nyet.  One issue is that Rust does not allow matching on the contents of\na Ref.  The other issue is that accessing fields of structs or tuples\nwrapped in a Ref<> requires either unwrapping it using deref or\nusing pattern matching syntax, as in:\nrelation StudentInfo(student: Ref<Student>, school: Ref<School>)\n\nTopScore(school, top_score) :-\n    StudentInfo(&Student{.sat_score = sat}, &School{.name = school}),\n    // WE HAVE BOUND THE `.sat_score` FIELD OF Student TO `sat` AND CAN\n    // USE IT BELOW.\n    var top_score = Aggregate((school), group_max(sat)).\n\nThis commit extends the field access syntax s.field to perform automatic\ndereferencing if s is a Ref<>, so the above rule can now be equivalently\nre-written as:\nTopScore(school, top_score) :-\n    StudentInfo(student, &School{.name = school}),\n    var top_score = Aggregate((school), group_max(student.sat_score)).", "createdAt": "2020-02-25T01:44:53Z", "url": "https://github.com/vmware/differential-datalog/pull/534", "merged": true, "mergeCommit": {"oid": "2060fcc1d8021325bcfd09a53e506ec58750553f"}, "closed": true, "closedAt": "2020-02-25T17:10:26Z", "author": {"login": "ryzhyk"}, "timelineItems": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcHoKiiAFqTM2MzgyMTk4OQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcHoNYLABqjMwNjc2NjU0ODY=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzODIxOTg5", "url": "https://github.com/vmware/differential-datalog/pull/534#pullrequestreview-363821989", "createdAt": "2020-02-25T01:47:07Z", "commit": {"oid": "8c29e94f587fb47d5685303dce04c5d28e3d85dc"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQwMTo0NzowN1rOFt2EJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQwMTo0NzowN1rOFt2EJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYxNjAzNw==", "bodyText": "missing something here", "url": "https://github.com/vmware/differential-datalog/pull/534#discussion_r383616037", "createdAt": "2020-02-25T01:47:07Z", "author": {"login": "mbudiu-vmw"}, "path": "doc/tutorial/tutorial.md", "diffHunk": "@@ -1393,6 +1393,17 @@ TopScore(school, top_score) :-\n \n We again use `&` to pattern match values stored by reference.\n \n+As another syntactic convenience, DDlog allows accessing fields of structs and\n+tuples wrapped in references directly using, without dereferencing them first.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c29e94f587fb47d5685303dce04c5d28e3d85dc"}, "originalPosition": 5}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c3299dae32bc4066f8b214ff81b2789b592617df", "author": {"user": {"login": "ryzhyk", "name": "Leonid Ryzhyk"}}, "url": "https://github.com/vmware/differential-datalog/commit/c3299dae32bc4066f8b214ff81b2789b592617df", "committedDate": "2020-02-25T01:53:35Z", "message": "Access fields of stucts & tuples wrapped in Ref's.\n\nThis commit addresses one of the awkward aspects of working with complex\ntypes wrapped in `Ref<>`'s.  Ideally, we would like `Ref<>`'s to be as\ntransparent as possible, so that one could work with them as if they were\nobjects of the inner type wrapped in the `Ref`.  We're not quite there\nyet.  One issue is that Rust does not allow matching on the contents of\na `Ref`.  The other issue is that accessing fields of structs or tuples\nwrapped in a `Ref<>` requires either unwrapping it using `deref` or\nusing pattern matching syntax, as in:\n\n```\nrelation StudentInfo(student: Ref<Student>, school: Ref<School>)\n\nTopScore(school, top_score) :-\n    StudentInfo(&Student{.sat_score = sat}, &School{.name = school}),\n    // WE HAVE BOUND THE `.sat_score` FIELD OF Student TO `sat` AND CAN\n    // USE IT BELOW.\n    var top_score = Aggregate((school), group_max(sat)).\n```\n\nThis commit extends the field access syntax `s.field` to perform automatic\ndereferencing if `s` is a `Ref<>`, so the above rule can now be equivalently\nre-written as:\n\n```\nTopScore(school, top_score) :-\n    StudentInfo(student, &School{.name = school}),\n    var top_score = Aggregate((school), group_max(student.sat_score)).\n```"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8c29e94f587fb47d5685303dce04c5d28e3d85dc", "author": {"user": {"login": "ryzhyk", "name": "Leonid Ryzhyk"}}, "url": "https://github.com/vmware/differential-datalog/commit/8c29e94f587fb47d5685303dce04c5d28e3d85dc", "committedDate": "2020-02-24T23:00:20Z", "message": "Access fields of stucts & tuples wrapped in Ref's.\n\nThis commit addresses one of the awkward aspects of working with complex\ntypes wrapped in `Ref<>`'s.  Ideally, we would like `Ref<>`'s to be as\ntransparent as possible, so that one could work with them as if they were\nobjects of the inner type wrapped in the `Ref`.  We're not quite there\nyet.  One issue is that Rust does not allow matching on the contents of\na `Ref`.  The other issue is that accessing fields of structs or tuples\nwrapped in a `Ref<>` requires either unwrapping it using `deref` or\nusing pattern matching syntax, as in:\n\n```\nrelation StudentInfo(student: Ref<Student>, school: Ref<School>)\n\nTopScore(school, top_score) :-\n    StudentInfo(&Student{.sat_score = sat}, &School{.name = school}),\n    // WE HAVE BOUND THE `.sat_score` FIELD OF Student TO `sat` AND CAN\n    // USE IT BELOW.\n    var top_score = Aggregate((school), group_max(sat)).\n```\n\nThis commit extends the field access syntax `s.field` to perform automatic\ndereferencing if `s` is a `Ref<>`, so the above rule can now be equivalently\nre-written as:\n\n```\nTopScore(school, top_score) :-\n    StudentInfo(student, &School{.name = school}),\n    var top_score = Aggregate((school), group_max(student.sat_score)).\n```"}, "afterCommit": {"oid": "c3299dae32bc4066f8b214ff81b2789b592617df", "author": {"user": {"login": "ryzhyk", "name": "Leonid Ryzhyk"}}, "url": "https://github.com/vmware/differential-datalog/commit/c3299dae32bc4066f8b214ff81b2789b592617df", "committedDate": "2020-02-25T01:53:35Z", "message": "Access fields of stucts & tuples wrapped in Ref's.\n\nThis commit addresses one of the awkward aspects of working with complex\ntypes wrapped in `Ref<>`'s.  Ideally, we would like `Ref<>`'s to be as\ntransparent as possible, so that one could work with them as if they were\nobjects of the inner type wrapped in the `Ref`.  We're not quite there\nyet.  One issue is that Rust does not allow matching on the contents of\na `Ref`.  The other issue is that accessing fields of structs or tuples\nwrapped in a `Ref<>` requires either unwrapping it using `deref` or\nusing pattern matching syntax, as in:\n\n```\nrelation StudentInfo(student: Ref<Student>, school: Ref<School>)\n\nTopScore(school, top_score) :-\n    StudentInfo(&Student{.sat_score = sat}, &School{.name = school}),\n    // WE HAVE BOUND THE `.sat_score` FIELD OF Student TO `sat` AND CAN\n    // USE IT BELOW.\n    var top_score = Aggregate((school), group_max(sat)).\n```\n\nThis commit extends the field access syntax `s.field` to perform automatic\ndereferencing if `s` is a `Ref<>`, so the above rule can now be equivalently\nre-written as:\n\n```\nTopScore(school, top_score) :-\n    StudentInfo(student, &School{.name = school}),\n    var top_score = Aggregate((school), group_max(student.sat_score)).\n```"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4648, "cost": 1, "resetAt": "2021-11-02T10:47:05Z"}}}