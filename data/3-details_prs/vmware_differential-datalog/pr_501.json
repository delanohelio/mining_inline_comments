{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYxODkzMjQ5", "number": 501, "title": "Improve re-compilation time using dynamic dispatch.", "bodyText": "Rationale:\nDifferential dataflow allows the user to assign an arbitrary user-defined type to\neach collection.  It relies on Rust's static dispatch mechanism to specialize its internal\nmachinery for each user-defined type.  Unfortunately, beyond very simple programs this leads to\nextremely long compilation times.  One workaround that we used to rely on is to declare a\nsingle enum type with a variant per concrete type used in at least one relation.  This make\ncompilation feasible, but still very slow (~6 minutes for a simple DDlog program and ~10\nminutes for complex programs).\nDesign:\nAnother alternative we implement here is to use a fixed value type that does not depend on\na concrete DDlog program and rely on dynamic dispatch to forward operations that DD expects\nall values to implement (comparison, hashing, etc.) to their concrete implementations.  This\nway the differetial-datalog crate can be compiled all the way to binary code separately\nfrom the DDlog program using it and does not need to be re-compiled when the DDlog program\nchanges.  Thus, the only part that must be re-compiled on changes to the DDlog code is the\nauto-generated crate that declares concrete value types and rules.  This is much faster than\nre-compiling both crates together.\nThe next design decision is how to implement dynamic dispatch.  Rust trait objects is an\nobvious choice, with value type being declared as Box<dyn SomeTrait>.  However, this proved\nsuboptimal in our experiments, as this design requires a dynamic memory allocation per value,\nno matter how small.  Furthermore, cloning a value (which DD does a lot, e.g., during\ncompaction) requires another allocation.\nWe improve over this naive design in two ways.  First, we use Arc instead of Box, which\nintroduces extra space overhead to store the reference count, but avoids memory allocation due\nto cloning and shares the same heap allocation across multiple copies of the value.  Second, we\nstore small objects <=usize bytes inline instead of wrapping them in an Arc to avoid dynamic\nmemory allocation for such objects altogether.  Unfortunately, Rust's dynamic dispatch\nmechanism does not support this, so we roll our own instead, with the following DDValue\ndeclaration:\npub struct DDValue {\n   val: DDVal,\n   vtable: &'static DDValMethods,\n}\n\nwhere DDVal is a usize that stores either an Arc<T> or T (where T is the actual type\nof value stored in the DDlog relation), and DDValMethods is a virtual table of methods that\nmust be implemented for all DD values.\nResults:\nThis design still requires a separate heap allocation for each value >8 bytes, which slows\nthings down quite a bit.  Nevertheless, it has the same performance as our earlier\nimplementation using static dispatch and at least in some benchmarks uses less memory.\n(see doc/benchmarking/dynamic-dispatch.gnumeric for more detail)\nWhile initial compilation time is approximately the same as before, re-compilation after changing\nDDlog code is much faster, e.g., approximately one minute for redist_opt.dl and 5 minutes for ovn-northd.\nFuture work:\nThere's more to do here, most importantly:\n\nMove differential-datalog crate out of the template and into a shared location, e.g., $DDLOG_HOME, so we only need to compile it once and not for each DDlog program.  This way we should be able to run more tests.\nSee if we can speed-up recompilation of large programs even more, e.g., by placing each value type in a separate module that will only be recompiled when that type changes.\nSmarter memory allocation strategy that would allocate multiple values at once using domain-specific information from DD.", "createdAt": "2020-01-13T00:52:39Z", "url": "https://github.com/vmware/differential-datalog/pull/501", "merged": true, "mergeCommit": {"oid": "6408db3819e54d7221bb7db239e5ec46b68b275d"}, "closed": true, "closedAt": "2020-01-13T19:28:54Z", "author": {"login": "ryzhyk"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABbx-KSRAH2gAyMzYxODkzMjQ5OmIyM2JmYTdiNTlkYjlkMDdjYzkyMjE0NmM5NjRlZDMzOTczZmIyYzU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb6A4rvgBqjI5NDQzMzEwNzQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "b23bfa7b59db9d07cc922146c964ed33973fb2c5", "author": {"user": {"login": "ryzhyk", "name": "Leonid Ryzhyk"}}, "url": "https://github.com/vmware/differential-datalog/commit/b23bfa7b59db9d07cc922146c964ed33973fb2c5", "committedDate": "2019-12-19T19:02:34Z", "message": "Dynamic dispatch: Phase 1.\n\nThis starts a series of patches that will address a long-standing\nproblem of slow compilation times.  The problem is really in the Rust\ncompiler, but since it does not look like it's going away any time soon,\nwe will instead change the way DDlog generates Rust code to avoid\nrunning into the problem.\n\nThe problem: the use of static dispatch as default in Rust means that\nevery time a DDlog program changes, the entire timely dataflow +\ndifferential dataflow + differentlial datalog library stack gets\nspecialized to the Value type generated by DDlog and essentially\nrecompiled from scratch.  Furthermore, because the Value type is a large\nenum that implements many traits, this specialization is particularly\nexpensive.\n\nThe solution is to enforce dynamic dispatch by using a trait object of\ntype `Box<dyn DDVal>` as value type in `differential_datalog`, where\n`DDVal` is a new trait that provides all operations needed by DD.  This\nmeans that all generated functions must perform unsafe conversion from\n`Box<dyn DDVal>` to the actual `Value` type, but it can be nicely\nencapsulated and is safe in practice as long as someone doesn't declare\nand use two different value types in the same program.\n\nAside from solving the compilation time problem, this design also\nenables us to encapsulate the DDlog API in a dynamic library that can be\ngenerated once and shared by all generated DDlog programs.  Thus most of\nthe DDlog runtime stack will not need to be copied to each generated\nprogram.  The only code that must be generated for each DDlog program\nwill consist only of value type and rule declarations.  This code can be\nencapsulated in a separate static or dynamic library.  Once this is\ndone, it will become straightforward to load multiple different DDlog\nprograms, e.g., in the same JVM.\n\nThis patch (Phase 1) refactors both the Rust runtime and the compiler to\nuse `Box<dyn DDVal>` as value type; thus we shoudl already start\nenjoying the benefits of dynamic dispatch; however `api.rs` is still\nspecialized for each DDlog program, and the entire Rust runtime is still\nshipped with each DDlog program."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "103c3e0052cb10d33cc40106f81e54121a2b5d49", "author": {"user": {"login": "ryzhyk", "name": "Leonid Ryzhyk"}}, "url": "https://github.com/vmware/differential-datalog/commit/103c3e0052cb10d33cc40106f81e54121a2b5d49", "committedDate": "2020-01-11T19:05:38Z", "message": "Wrap Value in Arc instead of Box.\n\nThe use of dynamic dispatch increased memory and CPU usage of DDlog\nprograms due to boxing (and hence a large number of memory allocations).\nThis commit attempts to combat the problem by replacing `Box` with `Arc`\nin the hope that much of the overhead is due to cloning of boxed values.\n\nThe new generic value type stored in all DD tables is:\n\n```\npub struct DDValue {\n   val: Arc<dyn DDVal>,\n}\n```\n\nWhere the concrete type hiding behind `dyn DDVal` is still the good old\n`enum Value`."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eb8dddc265946bdf76cf4819c4179a689ca28b9f", "author": {"user": {"login": "ryzhyk", "name": "Leonid Ryzhyk"}}, "url": "https://github.com/vmware/differential-datalog/commit/eb8dddc265946bdf76cf4819c4179a689ca28b9f", "committedDate": "2020-01-11T19:07:46Z", "message": "Get rid of enum Value.\n\nWith the use of dynamic dispatch, it is no longer necessary to declare a\nsingle enum for all value types.  This wastes memory for the tag field\nand also because of variants are padded to the same size.  In addition,\nchecking the tag in each generated function must have some CPU overhead.\n\nWe get rid of `enum Value` and instead declare a separate type for\neach type that must be stored in a DD relation.  In addition to\naddressing the above problems, this also has the potential to speed up\ncompilation, as different value variants can in principle be placed in\nits own module for separate compilation.\n\nThe generic value type is still\n\n```\npub struct DDValue {\n    val: Arc<dyn DDVal>,\n}\n```\n\nhowever the concrete type behind `dyn DDVal` is the actual type of the\nrelation it belongs to.  Unsafe coercions are used to extract this\ntype in generated code.\n\nThe change is transparent to users, except that we no longer support the\n`--box-threshold` switch."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyMDIwNzUz", "url": "https://github.com/vmware/differential-datalog/pull/501#pullrequestreview-342020753", "createdAt": "2020-01-13T17:43:08Z", "commit": {"oid": "4a5a18288ac80d325d0bd391f3d86c3007f5604c"}, "state": "APPROVED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxNzo0MzowOFrOFc_B3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxODoxNjoyMlrOFc_-UA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTkzNzExNw==", "bodyText": "typo", "url": "https://github.com/vmware/differential-datalog/pull/501#discussion_r365937117", "createdAt": "2020-01-13T17:43:08Z", "author": {"login": "mbudiu-vmw"}, "path": "rust/template/differential_datalog/ddval.rs", "diffHunk": "@@ -0,0 +1,423 @@\n+//! DDValue: Generic value type stored in all differential-dataflow relations.\n+//!\n+//! Rationale: Differential dataflow allows the user to assign an arbitrary user-defined type to\n+//! each collection.  It relies on Rust's static dispatch mechanism to specialize its internal\n+//! machinery for each user-defined type.  Unfortunately, beyond very simple programs this leads to\n+//! extremely long compilation times.  One workaround that we used to rely on is to declare a\n+//! single enum type with a variant per concrete type used in at least one relation.  This make\n+//! compilation feasible, but still very slow (~6 minutes for a simple DDlog program and ~10\n+//! minutes for complex programs).\n+//!\n+//! Another alternative we implement here is to use a fixed value type that does not depend on\n+//! a concrete DDlog program and rely on dynamic dispatch to forward operations that DD expects\n+//! all values to implement (comparison, hashing, etc.) to their concrete implementations.  This\n+//! way this crate (differetial-datalog) can be compiled all the way to binary code separately", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a5a18288ac80d325d0bd391f3d86c3007f5604c"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk0MTU3OA==", "bodyText": "Will this work safely for any type t that satisfies these bounds?", "url": "https://github.com/vmware/differential-datalog/pull/501#discussion_r365941578", "createdAt": "2020-01-13T17:52:12Z", "author": {"login": "mbudiu-vmw"}, "path": "rust/template/differential_datalog/ddval.rs", "diffHunk": "@@ -0,0 +1,423 @@\n+//! DDValue: Generic value type stored in all differential-dataflow relations.\n+//!\n+//! Rationale: Differential dataflow allows the user to assign an arbitrary user-defined type to\n+//! each collection.  It relies on Rust's static dispatch mechanism to specialize its internal\n+//! machinery for each user-defined type.  Unfortunately, beyond very simple programs this leads to\n+//! extremely long compilation times.  One workaround that we used to rely on is to declare a\n+//! single enum type with a variant per concrete type used in at least one relation.  This make\n+//! compilation feasible, but still very slow (~6 minutes for a simple DDlog program and ~10\n+//! minutes for complex programs).\n+//!\n+//! Another alternative we implement here is to use a fixed value type that does not depend on\n+//! a concrete DDlog program and rely on dynamic dispatch to forward operations that DD expects\n+//! all values to implement (comparison, hashing, etc.) to their concrete implementations.  This\n+//! way this crate (differetial-datalog) can be compiled all the way to binary code separately\n+//! from the DDlog program using it and does not need to be re-compiled when the DDlog program\n+//! changes.  Thus, the only part that must be re-compiled on changes to the DDlog code is the\n+//! auto-generated crate that declares concrete value types and rules.  This is much faster than\n+//! re-compiling both crates together.\n+//!\n+//! The next design decision is how to implement dynamic dispatch.  Rust trait objects is an\n+//! obvious choice, with value type being declared as `Box<dyn SomeTrait>`.  However, this proved\n+//! suboptimal in our experiments, as this design requires a dynamic memory allocation per value,\n+//! no matter how small.  Furthermore, cloning a value (which DD does a lot, e.g., during\n+//! compaction) requires another allocation.\n+//!\n+//! We improve over this naive design in two ways.  First, we use `Arc` instead of `Box`, which\n+//! introduces extra space overhead to store the reference count, but avoids memory allocation due\n+//! to cloning and shares the same heap allocation across multiple copies of the value.  Second, we\n+//! store small objects <=`usize` bytes inline instead of wrapping them in an Arc to avoid dynamic\n+//! memory allocation for such objects altogether.  Unfortunately, Rust's dynamic dispatch\n+//! mechanism does not support this, so we roll our own instead, with the following `DDValue`\n+//! declaration:\n+//!\n+//! ```\n+//! use differential_datalog::ddval::*;\n+//! pub struct DDValue {\n+//!    val: DDVal,\n+//!    vtable: &'static DDValMethods,\n+//! }\n+//! ```\n+//!\n+//! where `DDVal` is a `usize` that stores either an `Arc<T>` or `T` (where `T` is the actual type\n+//! of value stored in the DDlog relation), and `DDValMethods` is a virtual table of methods that\n+//! must be implemented for all DD values.\n+//!\n+//! This design still requires a separate heap allocation for each value >8 bytes, which slows\n+//! things down quite a bit.  Nevertheless, it has the same performance as our earlier\n+//! implementation using static dispatch and at least in some benchmarks uses less memory.  The\n+//! only way to improve things further I can think of is to somehow co-design this with DD to use\n+//! DD's knowledge of the context where a value is being created to, e.g., allocate blocks of\n+//! values when possible.\n+//!\n+\n+use std::fmt::Debug;\n+use std::fmt::Display;\n+use std::fmt::Formatter;\n+use std::hash::Hash;\n+use std::hash::Hasher;\n+\n+use serde::de::Deserialize;\n+use serde::de::Deserializer;\n+use serde::ser::Serialize;\n+use serde::ser::Serializer;\n+\n+use abomonation::Abomonation;\n+\n+use crate::record::IntoRecord;\n+use crate::record::Mutator;\n+use crate::record::Record;\n+\n+/// Type-erased representation of a value.  Can store the actual value or a pointer to it.\n+/// This could be just a `usize`, but we wrap it in a struct as we don't want it to implement\n+/// `Copy`.\n+pub struct DDVal {\n+    pub v: usize,\n+}\n+\n+/// DDValue: this type is stored in all DD collections.\n+/// It consists of value and associated vtable.\n+pub struct DDValue {\n+    val: DDVal,\n+    vtable: &'static DDValMethods,\n+}\n+\n+/// vtable of methods to be implemented by every value stored in DD.\n+pub struct DDValMethods {\n+    pub clone: fn(this: &DDVal) -> DDVal,\n+    pub into_record: fn(this: DDVal) -> Record,\n+    pub eq: fn(this: &DDVal, other: &DDVal) -> bool,\n+    pub partial_cmp: fn(this: &DDVal, other: &DDVal) -> Option<std::cmp::Ordering>,\n+    pub cmp: fn(this: &DDVal, other: &DDVal) -> std::cmp::Ordering,\n+    pub hash: fn(this: &DDVal, state: &mut dyn Hasher),\n+    pub mutate: fn(this: &mut DDVal, record: &Record) -> Result<(), String>,\n+    pub fmt_debug: fn(this: &DDVal, f: &mut Formatter) -> Result<(), std::fmt::Error>,\n+    pub fmt_display: fn(this: &DDVal, f: &mut Formatter) -> Result<(), std::fmt::Error>,\n+    pub drop: fn(this: &mut DDVal),\n+    pub ddval_serialize: fn(this: &DDVal) -> &dyn DDValSerialize,\n+}\n+\n+impl Drop for DDValue {\n+    fn drop(&mut self) {\n+        (self.vtable.drop)(&mut self.val);\n+    }\n+}\n+\n+impl DDValue {\n+    pub fn new(val: DDVal, vtable: &'static DDValMethods) -> DDValue {\n+        DDValue { val, vtable }\n+    }\n+\n+    pub fn into_ddval(self) -> DDVal {\n+        let res = DDVal { v: self.val.v };\n+        std::mem::forget(self);\n+        res\n+    }\n+}\n+\n+impl Mutator<DDValue> for Record {\n+    fn mutate(&self, x: &mut DDValue) -> Result<(), String> {\n+        (x.vtable.mutate)(&mut x.val, self)\n+    }\n+}\n+\n+impl IntoRecord for DDValue {\n+    fn into_record(self) -> Record {\n+        (self.vtable.into_record)(self.into_ddval())\n+    }\n+}\n+\n+impl Abomonation for DDValue {\n+    unsafe fn entomb<W: std::io::Write>(&self, _write: &mut W) -> std::io::Result<()> {\n+        panic!(\"DDValue::entomb: not implemented\")\n+    }\n+    unsafe fn exhume<'a, 'b>(&'a mut self, _bytes: &'b mut [u8]) -> Option<&'b mut [u8]> {\n+        panic!(\"DDValue::exhume: not implemented\")\n+    }\n+    fn extent(&self) -> usize {\n+        panic!(\"DDValue::extent: not implemented\")\n+    }\n+}\n+\n+impl Serialize for DDValue {\n+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n+    where\n+        S: Serializer,\n+    {\n+        (self.vtable.ddval_serialize)(&self.val).serialize(serializer)\n+    }\n+}\n+\n+impl<'de> Deserialize<'de> for DDValue {\n+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n+    where\n+        D: Deserializer<'de>,\n+    {\n+        let val: Box<dyn DDValSerialize> = Deserialize::deserialize(deserializer)?;\n+        Ok(val.ddvalue())\n+    }\n+}\n+\n+impl Display for DDValue {\n+    fn fmt(&self, f: &mut Formatter) -> Result<(), std::fmt::Error> {\n+        (self.vtable.fmt_display)(&self.val, f)\n+    }\n+}\n+\n+impl Debug for DDValue {\n+    fn fmt(&self, f: &mut Formatter) -> Result<(), std::fmt::Error> {\n+        (self.vtable.fmt_debug)(&self.val, f)\n+    }\n+}\n+\n+impl PartialOrd for DDValue {\n+    fn partial_cmp(&self, other: &DDValue) -> Option<std::cmp::Ordering> {\n+        (self.vtable.partial_cmp)(&self.val, &other.val)\n+    }\n+}\n+\n+impl PartialEq for DDValue {\n+    fn eq(&self, other: &Self) -> bool {\n+        (self.vtable.eq)(&self.val, &other.val)\n+    }\n+}\n+\n+impl Eq for DDValue {}\n+\n+impl Ord for DDValue {\n+    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n+        (self.vtable.cmp)(&self.val, &other.val)\n+    }\n+}\n+\n+impl Clone for DDValue {\n+    fn clone(&self) -> Self {\n+        DDValue {\n+            val: (self.vtable.clone)(&self.val),\n+            vtable: self.vtable,\n+        }\n+    }\n+}\n+\n+impl Hash for DDValue {\n+    fn hash<H>(&self, state: &mut H)\n+    where\n+        H: Hasher,\n+    {\n+        (self.vtable.hash)(&self.val, state)\n+    }\n+}\n+\n+/// Trait to convert `DDVal` into concrete value type and back.\n+pub trait DDValConvert: Sized {\n+    /// Extract reference to concrete type from `&DDVal`.  This causes undefined behavior\n+    /// if `v` does not contain a value of type `Self`.\n+    unsafe fn from_ddval_ref(v: &DDVal) -> &Self;\n+\n+    unsafe fn from_ddvalue_ref(v: &DDValue) -> &Self {\n+        Self::from_ddval_ref(&v.val)\n+    }\n+\n+    /// Extract mutable reference to concrete type from `&mut DDVal`.  This causes\n+    /// undefined behavior if `v` does not contain a value of type `Self`.\n+    unsafe fn from_ddval_mut_ref(v: &mut DDVal) -> &mut Self;\n+\n+    /// Extracts concrete value contained in `v`.  Panics if `v` does not contain a\n+    /// value of type `Self`.\n+    unsafe fn from_ddval(v: DDVal) -> Self;\n+\n+    unsafe fn from_ddvalue(v: DDValue) -> Self {\n+        Self::from_ddval(v.into_ddval())\n+    }\n+\n+    /// Convert a value to a `DDVal`, erasing its original type.  This is a safe conversion\n+    /// that cannot fail.\n+    fn into_ddval(self) -> DDVal;\n+\n+    fn into_ddvalue(self) -> DDValue;\n+}\n+\n+#[typetag::serde]\n+pub trait DDValSerialize {\n+    fn ddvalue(&self) -> DDValue;\n+}\n+\n+/// Macro to implement `DDValConvert` for type `t` that satisfies the following type bounds:\n+///", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a5a18288ac80d325d0bd391f3d86c3007f5604c"}, "originalPosition": 246}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk0MzM3Nw==", "bodyText": "I hope that there's only one vtable for each different type t.", "url": "https://github.com/vmware/differential-datalog/pull/501#discussion_r365943377", "createdAt": "2020-01-13T17:55:42Z", "author": {"login": "mbudiu-vmw"}, "path": "rust/template/differential_datalog/ddval.rs", "diffHunk": "@@ -0,0 +1,423 @@\n+//! DDValue: Generic value type stored in all differential-dataflow relations.\n+//!\n+//! Rationale: Differential dataflow allows the user to assign an arbitrary user-defined type to\n+//! each collection.  It relies on Rust's static dispatch mechanism to specialize its internal\n+//! machinery for each user-defined type.  Unfortunately, beyond very simple programs this leads to\n+//! extremely long compilation times.  One workaround that we used to rely on is to declare a\n+//! single enum type with a variant per concrete type used in at least one relation.  This make\n+//! compilation feasible, but still very slow (~6 minutes for a simple DDlog program and ~10\n+//! minutes for complex programs).\n+//!\n+//! Another alternative we implement here is to use a fixed value type that does not depend on\n+//! a concrete DDlog program and rely on dynamic dispatch to forward operations that DD expects\n+//! all values to implement (comparison, hashing, etc.) to their concrete implementations.  This\n+//! way this crate (differetial-datalog) can be compiled all the way to binary code separately\n+//! from the DDlog program using it and does not need to be re-compiled when the DDlog program\n+//! changes.  Thus, the only part that must be re-compiled on changes to the DDlog code is the\n+//! auto-generated crate that declares concrete value types and rules.  This is much faster than\n+//! re-compiling both crates together.\n+//!\n+//! The next design decision is how to implement dynamic dispatch.  Rust trait objects is an\n+//! obvious choice, with value type being declared as `Box<dyn SomeTrait>`.  However, this proved\n+//! suboptimal in our experiments, as this design requires a dynamic memory allocation per value,\n+//! no matter how small.  Furthermore, cloning a value (which DD does a lot, e.g., during\n+//! compaction) requires another allocation.\n+//!\n+//! We improve over this naive design in two ways.  First, we use `Arc` instead of `Box`, which\n+//! introduces extra space overhead to store the reference count, but avoids memory allocation due\n+//! to cloning and shares the same heap allocation across multiple copies of the value.  Second, we\n+//! store small objects <=`usize` bytes inline instead of wrapping them in an Arc to avoid dynamic\n+//! memory allocation for such objects altogether.  Unfortunately, Rust's dynamic dispatch\n+//! mechanism does not support this, so we roll our own instead, with the following `DDValue`\n+//! declaration:\n+//!\n+//! ```\n+//! use differential_datalog::ddval::*;\n+//! pub struct DDValue {\n+//!    val: DDVal,\n+//!    vtable: &'static DDValMethods,\n+//! }\n+//! ```\n+//!\n+//! where `DDVal` is a `usize` that stores either an `Arc<T>` or `T` (where `T` is the actual type\n+//! of value stored in the DDlog relation), and `DDValMethods` is a virtual table of methods that\n+//! must be implemented for all DD values.\n+//!\n+//! This design still requires a separate heap allocation for each value >8 bytes, which slows\n+//! things down quite a bit.  Nevertheless, it has the same performance as our earlier\n+//! implementation using static dispatch and at least in some benchmarks uses less memory.  The\n+//! only way to improve things further I can think of is to somehow co-design this with DD to use\n+//! DD's knowledge of the context where a value is being created to, e.g., allocate blocks of\n+//! values when possible.\n+//!\n+\n+use std::fmt::Debug;\n+use std::fmt::Display;\n+use std::fmt::Formatter;\n+use std::hash::Hash;\n+use std::hash::Hasher;\n+\n+use serde::de::Deserialize;\n+use serde::de::Deserializer;\n+use serde::ser::Serialize;\n+use serde::ser::Serializer;\n+\n+use abomonation::Abomonation;\n+\n+use crate::record::IntoRecord;\n+use crate::record::Mutator;\n+use crate::record::Record;\n+\n+/// Type-erased representation of a value.  Can store the actual value or a pointer to it.\n+/// This could be just a `usize`, but we wrap it in a struct as we don't want it to implement\n+/// `Copy`.\n+pub struct DDVal {\n+    pub v: usize,\n+}\n+\n+/// DDValue: this type is stored in all DD collections.\n+/// It consists of value and associated vtable.\n+pub struct DDValue {\n+    val: DDVal,\n+    vtable: &'static DDValMethods,\n+}\n+\n+/// vtable of methods to be implemented by every value stored in DD.\n+pub struct DDValMethods {\n+    pub clone: fn(this: &DDVal) -> DDVal,\n+    pub into_record: fn(this: DDVal) -> Record,\n+    pub eq: fn(this: &DDVal, other: &DDVal) -> bool,\n+    pub partial_cmp: fn(this: &DDVal, other: &DDVal) -> Option<std::cmp::Ordering>,\n+    pub cmp: fn(this: &DDVal, other: &DDVal) -> std::cmp::Ordering,\n+    pub hash: fn(this: &DDVal, state: &mut dyn Hasher),\n+    pub mutate: fn(this: &mut DDVal, record: &Record) -> Result<(), String>,\n+    pub fmt_debug: fn(this: &DDVal, f: &mut Formatter) -> Result<(), std::fmt::Error>,\n+    pub fmt_display: fn(this: &DDVal, f: &mut Formatter) -> Result<(), std::fmt::Error>,\n+    pub drop: fn(this: &mut DDVal),\n+    pub ddval_serialize: fn(this: &DDVal) -> &dyn DDValSerialize,\n+}\n+\n+impl Drop for DDValue {\n+    fn drop(&mut self) {\n+        (self.vtable.drop)(&mut self.val);\n+    }\n+}\n+\n+impl DDValue {\n+    pub fn new(val: DDVal, vtable: &'static DDValMethods) -> DDValue {\n+        DDValue { val, vtable }\n+    }\n+\n+    pub fn into_ddval(self) -> DDVal {\n+        let res = DDVal { v: self.val.v };\n+        std::mem::forget(self);\n+        res\n+    }\n+}\n+\n+impl Mutator<DDValue> for Record {\n+    fn mutate(&self, x: &mut DDValue) -> Result<(), String> {\n+        (x.vtable.mutate)(&mut x.val, self)\n+    }\n+}\n+\n+impl IntoRecord for DDValue {\n+    fn into_record(self) -> Record {\n+        (self.vtable.into_record)(self.into_ddval())\n+    }\n+}\n+\n+impl Abomonation for DDValue {\n+    unsafe fn entomb<W: std::io::Write>(&self, _write: &mut W) -> std::io::Result<()> {\n+        panic!(\"DDValue::entomb: not implemented\")\n+    }\n+    unsafe fn exhume<'a, 'b>(&'a mut self, _bytes: &'b mut [u8]) -> Option<&'b mut [u8]> {\n+        panic!(\"DDValue::exhume: not implemented\")\n+    }\n+    fn extent(&self) -> usize {\n+        panic!(\"DDValue::extent: not implemented\")\n+    }\n+}\n+\n+impl Serialize for DDValue {\n+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n+    where\n+        S: Serializer,\n+    {\n+        (self.vtable.ddval_serialize)(&self.val).serialize(serializer)\n+    }\n+}\n+\n+impl<'de> Deserialize<'de> for DDValue {\n+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n+    where\n+        D: Deserializer<'de>,\n+    {\n+        let val: Box<dyn DDValSerialize> = Deserialize::deserialize(deserializer)?;\n+        Ok(val.ddvalue())\n+    }\n+}\n+\n+impl Display for DDValue {\n+    fn fmt(&self, f: &mut Formatter) -> Result<(), std::fmt::Error> {\n+        (self.vtable.fmt_display)(&self.val, f)\n+    }\n+}\n+\n+impl Debug for DDValue {\n+    fn fmt(&self, f: &mut Formatter) -> Result<(), std::fmt::Error> {\n+        (self.vtable.fmt_debug)(&self.val, f)\n+    }\n+}\n+\n+impl PartialOrd for DDValue {\n+    fn partial_cmp(&self, other: &DDValue) -> Option<std::cmp::Ordering> {\n+        (self.vtable.partial_cmp)(&self.val, &other.val)\n+    }\n+}\n+\n+impl PartialEq for DDValue {\n+    fn eq(&self, other: &Self) -> bool {\n+        (self.vtable.eq)(&self.val, &other.val)\n+    }\n+}\n+\n+impl Eq for DDValue {}\n+\n+impl Ord for DDValue {\n+    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n+        (self.vtable.cmp)(&self.val, &other.val)\n+    }\n+}\n+\n+impl Clone for DDValue {\n+    fn clone(&self) -> Self {\n+        DDValue {\n+            val: (self.vtable.clone)(&self.val),\n+            vtable: self.vtable,\n+        }\n+    }\n+}\n+\n+impl Hash for DDValue {\n+    fn hash<H>(&self, state: &mut H)\n+    where\n+        H: Hasher,\n+    {\n+        (self.vtable.hash)(&self.val, state)\n+    }\n+}\n+\n+/// Trait to convert `DDVal` into concrete value type and back.\n+pub trait DDValConvert: Sized {\n+    /// Extract reference to concrete type from `&DDVal`.  This causes undefined behavior\n+    /// if `v` does not contain a value of type `Self`.\n+    unsafe fn from_ddval_ref(v: &DDVal) -> &Self;\n+\n+    unsafe fn from_ddvalue_ref(v: &DDValue) -> &Self {\n+        Self::from_ddval_ref(&v.val)\n+    }\n+\n+    /// Extract mutable reference to concrete type from `&mut DDVal`.  This causes\n+    /// undefined behavior if `v` does not contain a value of type `Self`.\n+    unsafe fn from_ddval_mut_ref(v: &mut DDVal) -> &mut Self;\n+\n+    /// Extracts concrete value contained in `v`.  Panics if `v` does not contain a\n+    /// value of type `Self`.\n+    unsafe fn from_ddval(v: DDVal) -> Self;\n+\n+    unsafe fn from_ddvalue(v: DDValue) -> Self {\n+        Self::from_ddval(v.into_ddval())\n+    }\n+\n+    /// Convert a value to a `DDVal`, erasing its original type.  This is a safe conversion\n+    /// that cannot fail.\n+    fn into_ddval(self) -> DDVal;\n+\n+    fn into_ddvalue(self) -> DDValue;\n+}\n+\n+#[typetag::serde]\n+pub trait DDValSerialize {\n+    fn ddvalue(&self) -> DDValue;\n+}\n+\n+/// Macro to implement `DDValConvert` for type `t` that satisfies the following type bounds:\n+///\n+/// t: Eq + Ord + Clone + Send + Debug + Sync + Hash + PartialOrd + IntoRecord + 'static,\n+/// Record: Mutator<t>\n+///\n+#[macro_export]\n+macro_rules! decl_ddval_convert {\n+    ( $t:ty ) => {\n+        #[typetag::serde]\n+        impl $crate::ddval::DDValSerialize for $t {\n+            fn ddvalue(&self) -> $crate::ddval::DDValue {\n+                $crate::ddval::DDValConvert::into_ddvalue(self.clone())\n+            }\n+        }\n+\n+        impl $crate::ddval::DDValConvert for $t {\n+            unsafe fn from_ddval_ref(v: &$crate::ddval::DDVal) -> &Self {\n+                if std::mem::size_of::<Self>() <= std::mem::size_of::<usize>() {\n+                    &*(&v.v as *const usize as *const Self)\n+                } else {\n+                    &*(v.v as *const Self)\n+                }\n+            }\n+\n+            unsafe fn from_ddval_mut_ref(v: &mut $crate::ddval::DDVal) -> &mut Self {\n+                if std::mem::size_of::<Self>() <= std::mem::size_of::<usize>() {\n+                    &mut *(&mut v.v as *mut usize as *mut Self)\n+                } else {\n+                    let arc = std::sync::Arc::from_raw(v.v as *const Self);\n+                    v.v = std::sync::Arc::into_raw(arc) as usize;\n+                    &mut *(v.v as *mut Self)\n+                }\n+            }\n+\n+            unsafe fn from_ddval(v: $crate::ddval::DDVal) -> Self {\n+                if std::mem::size_of::<Self>() <= std::mem::size_of::<usize>() {\n+                    let res: Self = std::mem::transmute::<[u8; std::mem::size_of::<Self>()], Self>(\n+                        *(&v.v as *const usize as *const [u8; std::mem::size_of::<Self>()]),\n+                    );\n+                    std::mem::forget(v);\n+                    res\n+                } else {\n+                    let arc = std::sync::Arc::from_raw(v.v as *const Self);\n+                    std::sync::Arc::try_unwrap(arc).unwrap_or_else(|a| (*a).clone())\n+                }\n+            }\n+\n+            fn into_ddval(self) -> $crate::ddval::DDVal {\n+                if std::mem::size_of::<Self>() <= std::mem::size_of::<usize>() {\n+                    let mut v: usize = 0;\n+                    unsafe {\n+                        *(&mut v as *mut usize as *mut [u8; std::mem::size_of::<Self>()]) =\n+                            std::mem::transmute::<Self, [u8; std::mem::size_of::<Self>()]>(self);\n+                    };\n+                    $crate::ddval::DDVal { v }\n+                } else {\n+                    $crate::ddval::DDVal {\n+                        v: std::sync::Arc::into_raw(std::sync::Arc::new(self)) as usize,\n+                    }\n+                }\n+            }\n+\n+            fn into_ddvalue(self) -> $crate::ddval::DDValue {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a5a18288ac80d325d0bd391f3d86c3007f5604c"}, "originalPosition": 307}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk0NDA4Ng==", "bodyText": "Can you compare values with different vtables?", "url": "https://github.com/vmware/differential-datalog/pull/501#discussion_r365944086", "createdAt": "2020-01-13T17:57:07Z", "author": {"login": "mbudiu-vmw"}, "path": "rust/template/differential_datalog/ddval.rs", "diffHunk": "@@ -0,0 +1,423 @@\n+//! DDValue: Generic value type stored in all differential-dataflow relations.\n+//!\n+//! Rationale: Differential dataflow allows the user to assign an arbitrary user-defined type to\n+//! each collection.  It relies on Rust's static dispatch mechanism to specialize its internal\n+//! machinery for each user-defined type.  Unfortunately, beyond very simple programs this leads to\n+//! extremely long compilation times.  One workaround that we used to rely on is to declare a\n+//! single enum type with a variant per concrete type used in at least one relation.  This make\n+//! compilation feasible, but still very slow (~6 minutes for a simple DDlog program and ~10\n+//! minutes for complex programs).\n+//!\n+//! Another alternative we implement here is to use a fixed value type that does not depend on\n+//! a concrete DDlog program and rely on dynamic dispatch to forward operations that DD expects\n+//! all values to implement (comparison, hashing, etc.) to their concrete implementations.  This\n+//! way this crate (differetial-datalog) can be compiled all the way to binary code separately\n+//! from the DDlog program using it and does not need to be re-compiled when the DDlog program\n+//! changes.  Thus, the only part that must be re-compiled on changes to the DDlog code is the\n+//! auto-generated crate that declares concrete value types and rules.  This is much faster than\n+//! re-compiling both crates together.\n+//!\n+//! The next design decision is how to implement dynamic dispatch.  Rust trait objects is an\n+//! obvious choice, with value type being declared as `Box<dyn SomeTrait>`.  However, this proved\n+//! suboptimal in our experiments, as this design requires a dynamic memory allocation per value,\n+//! no matter how small.  Furthermore, cloning a value (which DD does a lot, e.g., during\n+//! compaction) requires another allocation.\n+//!\n+//! We improve over this naive design in two ways.  First, we use `Arc` instead of `Box`, which\n+//! introduces extra space overhead to store the reference count, but avoids memory allocation due\n+//! to cloning and shares the same heap allocation across multiple copies of the value.  Second, we\n+//! store small objects <=`usize` bytes inline instead of wrapping them in an Arc to avoid dynamic\n+//! memory allocation for such objects altogether.  Unfortunately, Rust's dynamic dispatch\n+//! mechanism does not support this, so we roll our own instead, with the following `DDValue`\n+//! declaration:\n+//!\n+//! ```\n+//! use differential_datalog::ddval::*;\n+//! pub struct DDValue {\n+//!    val: DDVal,\n+//!    vtable: &'static DDValMethods,\n+//! }\n+//! ```\n+//!\n+//! where `DDVal` is a `usize` that stores either an `Arc<T>` or `T` (where `T` is the actual type\n+//! of value stored in the DDlog relation), and `DDValMethods` is a virtual table of methods that\n+//! must be implemented for all DD values.\n+//!\n+//! This design still requires a separate heap allocation for each value >8 bytes, which slows\n+//! things down quite a bit.  Nevertheless, it has the same performance as our earlier\n+//! implementation using static dispatch and at least in some benchmarks uses less memory.  The\n+//! only way to improve things further I can think of is to somehow co-design this with DD to use\n+//! DD's knowledge of the context where a value is being created to, e.g., allocate blocks of\n+//! values when possible.\n+//!\n+\n+use std::fmt::Debug;\n+use std::fmt::Display;\n+use std::fmt::Formatter;\n+use std::hash::Hash;\n+use std::hash::Hasher;\n+\n+use serde::de::Deserialize;\n+use serde::de::Deserializer;\n+use serde::ser::Serialize;\n+use serde::ser::Serializer;\n+\n+use abomonation::Abomonation;\n+\n+use crate::record::IntoRecord;\n+use crate::record::Mutator;\n+use crate::record::Record;\n+\n+/// Type-erased representation of a value.  Can store the actual value or a pointer to it.\n+/// This could be just a `usize`, but we wrap it in a struct as we don't want it to implement\n+/// `Copy`.\n+pub struct DDVal {\n+    pub v: usize,\n+}\n+\n+/// DDValue: this type is stored in all DD collections.\n+/// It consists of value and associated vtable.\n+pub struct DDValue {\n+    val: DDVal,\n+    vtable: &'static DDValMethods,\n+}\n+\n+/// vtable of methods to be implemented by every value stored in DD.\n+pub struct DDValMethods {\n+    pub clone: fn(this: &DDVal) -> DDVal,\n+    pub into_record: fn(this: DDVal) -> Record,\n+    pub eq: fn(this: &DDVal, other: &DDVal) -> bool,\n+    pub partial_cmp: fn(this: &DDVal, other: &DDVal) -> Option<std::cmp::Ordering>,\n+    pub cmp: fn(this: &DDVal, other: &DDVal) -> std::cmp::Ordering,\n+    pub hash: fn(this: &DDVal, state: &mut dyn Hasher),\n+    pub mutate: fn(this: &mut DDVal, record: &Record) -> Result<(), String>,\n+    pub fmt_debug: fn(this: &DDVal, f: &mut Formatter) -> Result<(), std::fmt::Error>,\n+    pub fmt_display: fn(this: &DDVal, f: &mut Formatter) -> Result<(), std::fmt::Error>,\n+    pub drop: fn(this: &mut DDVal),\n+    pub ddval_serialize: fn(this: &DDVal) -> &dyn DDValSerialize,\n+}\n+\n+impl Drop for DDValue {\n+    fn drop(&mut self) {\n+        (self.vtable.drop)(&mut self.val);\n+    }\n+}\n+\n+impl DDValue {\n+    pub fn new(val: DDVal, vtable: &'static DDValMethods) -> DDValue {\n+        DDValue { val, vtable }\n+    }\n+\n+    pub fn into_ddval(self) -> DDVal {\n+        let res = DDVal { v: self.val.v };\n+        std::mem::forget(self);\n+        res\n+    }\n+}\n+\n+impl Mutator<DDValue> for Record {\n+    fn mutate(&self, x: &mut DDValue) -> Result<(), String> {\n+        (x.vtable.mutate)(&mut x.val, self)\n+    }\n+}\n+\n+impl IntoRecord for DDValue {\n+    fn into_record(self) -> Record {\n+        (self.vtable.into_record)(self.into_ddval())\n+    }\n+}\n+\n+impl Abomonation for DDValue {\n+    unsafe fn entomb<W: std::io::Write>(&self, _write: &mut W) -> std::io::Result<()> {\n+        panic!(\"DDValue::entomb: not implemented\")\n+    }\n+    unsafe fn exhume<'a, 'b>(&'a mut self, _bytes: &'b mut [u8]) -> Option<&'b mut [u8]> {\n+        panic!(\"DDValue::exhume: not implemented\")\n+    }\n+    fn extent(&self) -> usize {\n+        panic!(\"DDValue::extent: not implemented\")\n+    }\n+}\n+\n+impl Serialize for DDValue {\n+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n+    where\n+        S: Serializer,\n+    {\n+        (self.vtable.ddval_serialize)(&self.val).serialize(serializer)\n+    }\n+}\n+\n+impl<'de> Deserialize<'de> for DDValue {\n+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n+    where\n+        D: Deserializer<'de>,\n+    {\n+        let val: Box<dyn DDValSerialize> = Deserialize::deserialize(deserializer)?;\n+        Ok(val.ddvalue())\n+    }\n+}\n+\n+impl Display for DDValue {\n+    fn fmt(&self, f: &mut Formatter) -> Result<(), std::fmt::Error> {\n+        (self.vtable.fmt_display)(&self.val, f)\n+    }\n+}\n+\n+impl Debug for DDValue {\n+    fn fmt(&self, f: &mut Formatter) -> Result<(), std::fmt::Error> {\n+        (self.vtable.fmt_debug)(&self.val, f)\n+    }\n+}\n+\n+impl PartialOrd for DDValue {\n+    fn partial_cmp(&self, other: &DDValue) -> Option<std::cmp::Ordering> {\n+        (self.vtable.partial_cmp)(&self.val, &other.val)\n+    }\n+}\n+\n+impl PartialEq for DDValue {\n+    fn eq(&self, other: &Self) -> bool {\n+        (self.vtable.eq)(&self.val, &other.val)\n+    }\n+}\n+\n+impl Eq for DDValue {}\n+\n+impl Ord for DDValue {\n+    fn cmp(&self, other: &Self) -> std::cmp::Ordering {\n+        (self.vtable.cmp)(&self.val, &other.val)\n+    }\n+}\n+\n+impl Clone for DDValue {\n+    fn clone(&self) -> Self {\n+        DDValue {\n+            val: (self.vtable.clone)(&self.val),\n+            vtable: self.vtable,\n+        }\n+    }\n+}\n+\n+impl Hash for DDValue {\n+    fn hash<H>(&self, state: &mut H)\n+    where\n+        H: Hasher,\n+    {\n+        (self.vtable.hash)(&self.val, state)\n+    }\n+}\n+\n+/// Trait to convert `DDVal` into concrete value type and back.\n+pub trait DDValConvert: Sized {\n+    /// Extract reference to concrete type from `&DDVal`.  This causes undefined behavior\n+    /// if `v` does not contain a value of type `Self`.\n+    unsafe fn from_ddval_ref(v: &DDVal) -> &Self;\n+\n+    unsafe fn from_ddvalue_ref(v: &DDValue) -> &Self {\n+        Self::from_ddval_ref(&v.val)\n+    }\n+\n+    /// Extract mutable reference to concrete type from `&mut DDVal`.  This causes\n+    /// undefined behavior if `v` does not contain a value of type `Self`.\n+    unsafe fn from_ddval_mut_ref(v: &mut DDVal) -> &mut Self;\n+\n+    /// Extracts concrete value contained in `v`.  Panics if `v` does not contain a\n+    /// value of type `Self`.\n+    unsafe fn from_ddval(v: DDVal) -> Self;\n+\n+    unsafe fn from_ddvalue(v: DDValue) -> Self {\n+        Self::from_ddval(v.into_ddval())\n+    }\n+\n+    /// Convert a value to a `DDVal`, erasing its original type.  This is a safe conversion\n+    /// that cannot fail.\n+    fn into_ddval(self) -> DDVal;\n+\n+    fn into_ddvalue(self) -> DDValue;\n+}\n+\n+#[typetag::serde]\n+pub trait DDValSerialize {\n+    fn ddvalue(&self) -> DDValue;\n+}\n+\n+/// Macro to implement `DDValConvert` for type `t` that satisfies the following type bounds:\n+///\n+/// t: Eq + Ord + Clone + Send + Debug + Sync + Hash + PartialOrd + IntoRecord + 'static,\n+/// Record: Mutator<t>\n+///\n+#[macro_export]\n+macro_rules! decl_ddval_convert {\n+    ( $t:ty ) => {\n+        #[typetag::serde]\n+        impl $crate::ddval::DDValSerialize for $t {\n+            fn ddvalue(&self) -> $crate::ddval::DDValue {\n+                $crate::ddval::DDValConvert::into_ddvalue(self.clone())\n+            }\n+        }\n+\n+        impl $crate::ddval::DDValConvert for $t {\n+            unsafe fn from_ddval_ref(v: &$crate::ddval::DDVal) -> &Self {\n+                if std::mem::size_of::<Self>() <= std::mem::size_of::<usize>() {\n+                    &*(&v.v as *const usize as *const Self)\n+                } else {\n+                    &*(v.v as *const Self)\n+                }\n+            }\n+\n+            unsafe fn from_ddval_mut_ref(v: &mut $crate::ddval::DDVal) -> &mut Self {\n+                if std::mem::size_of::<Self>() <= std::mem::size_of::<usize>() {\n+                    &mut *(&mut v.v as *mut usize as *mut Self)\n+                } else {\n+                    let arc = std::sync::Arc::from_raw(v.v as *const Self);\n+                    v.v = std::sync::Arc::into_raw(arc) as usize;\n+                    &mut *(v.v as *mut Self)\n+                }\n+            }\n+\n+            unsafe fn from_ddval(v: $crate::ddval::DDVal) -> Self {\n+                if std::mem::size_of::<Self>() <= std::mem::size_of::<usize>() {\n+                    let res: Self = std::mem::transmute::<[u8; std::mem::size_of::<Self>()], Self>(\n+                        *(&v.v as *const usize as *const [u8; std::mem::size_of::<Self>()]),\n+                    );\n+                    std::mem::forget(v);\n+                    res\n+                } else {\n+                    let arc = std::sync::Arc::from_raw(v.v as *const Self);\n+                    std::sync::Arc::try_unwrap(arc).unwrap_or_else(|a| (*a).clone())\n+                }\n+            }\n+\n+            fn into_ddval(self) -> $crate::ddval::DDVal {\n+                if std::mem::size_of::<Self>() <= std::mem::size_of::<usize>() {\n+                    let mut v: usize = 0;\n+                    unsafe {\n+                        *(&mut v as *mut usize as *mut [u8; std::mem::size_of::<Self>()]) =\n+                            std::mem::transmute::<Self, [u8; std::mem::size_of::<Self>()]>(self);\n+                    };\n+                    $crate::ddval::DDVal { v }\n+                } else {\n+                    $crate::ddval::DDVal {\n+                        v: std::sync::Arc::into_raw(std::sync::Arc::new(self)) as usize,\n+                    }\n+                }\n+            }\n+\n+            fn into_ddvalue(self) -> $crate::ddval::DDValue {\n+                const VTABLE: $crate::ddval::DDValMethods = $crate::ddval::DDValMethods {\n+                    clone: {\n+                        fn __f(this: &$crate::ddval::DDVal) -> $crate::ddval::DDVal {\n+                            if std::mem::size_of::<$t>() <= std::mem::size_of::<usize>() {\n+                                unsafe { <$t>::from_ddval_ref(this) }.clone().into_ddval()\n+                            } else {\n+                                let arc = unsafe { std::sync::Arc::from_raw(this.v as *const $t) };\n+                                let res = $crate::ddval::DDVal {\n+                                    v: std::sync::Arc::into_raw(arc.clone()) as usize,\n+                                };\n+                                std::sync::Arc::into_raw(arc);\n+                                res\n+                            }\n+                        };\n+                        __f\n+                    },\n+                    into_record: {\n+                        fn __f(this: $crate::ddval::DDVal) -> $crate::record::Record {\n+                            unsafe { <$t>::from_ddval(this) }.into_record()\n+                        };\n+                        __f\n+                    },\n+                    eq: {\n+                        fn __f(this: &$crate::ddval::DDVal, other: &$crate::ddval::DDVal) -> bool {\n+                            unsafe { <$t>::from_ddval_ref(this).eq(<$t>::from_ddval_ref(other)) }\n+                        };\n+                        __f\n+                    },\n+                    partial_cmp: {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a5a18288ac80d325d0bd391f3d86c3007f5604c"}, "originalPosition": 336}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk0NDcyOQ==", "bodyText": "This is actually quite nice - the fact you can do this in such a compact way.\nI don't think there are many languages where you can do this kind of stuff.", "url": "https://github.com/vmware/differential-datalog/pull/501#discussion_r365944729", "createdAt": "2020-01-13T17:58:22Z", "author": {"login": "mbudiu-vmw"}, "path": "rust/template/differential_datalog/ddval.rs", "diffHunk": "@@ -0,0 +1,423 @@\n+//! DDValue: Generic value type stored in all differential-dataflow relations.\n+//!\n+//! Rationale: Differential dataflow allows the user to assign an arbitrary user-defined type to\n+//! each collection.  It relies on Rust's static dispatch mechanism to specialize its internal\n+//! machinery for each user-defined type.  Unfortunately, beyond very simple programs this leads to\n+//! extremely long compilation times.  One workaround that we used to rely on is to declare a\n+//! single enum type with a variant per concrete type used in at least one relation.  This make\n+//! compilation feasible, but still very slow (~6 minutes for a simple DDlog program and ~10\n+//! minutes for complex programs).\n+//!\n+//! Another alternative we implement here is to use a fixed value type that does not depend on\n+//! a concrete DDlog program and rely on dynamic dispatch to forward operations that DD expects\n+//! all values to implement (comparison, hashing, etc.) to their concrete implementations.  This\n+//! way this crate (differetial-datalog) can be compiled all the way to binary code separately\n+//! from the DDlog program using it and does not need to be re-compiled when the DDlog program\n+//! changes.  Thus, the only part that must be re-compiled on changes to the DDlog code is the\n+//! auto-generated crate that declares concrete value types and rules.  This is much faster than\n+//! re-compiling both crates together.\n+//!\n+//! The next design decision is how to implement dynamic dispatch.  Rust trait objects is an\n+//! obvious choice, with value type being declared as `Box<dyn SomeTrait>`.  However, this proved\n+//! suboptimal in our experiments, as this design requires a dynamic memory allocation per value,\n+//! no matter how small.  Furthermore, cloning a value (which DD does a lot, e.g., during\n+//! compaction) requires another allocation.\n+//!\n+//! We improve over this naive design in two ways.  First, we use `Arc` instead of `Box`, which\n+//! introduces extra space overhead to store the reference count, but avoids memory allocation due\n+//! to cloning and shares the same heap allocation across multiple copies of the value.  Second, we\n+//! store small objects <=`usize` bytes inline instead of wrapping them in an Arc to avoid dynamic\n+//! memory allocation for such objects altogether.  Unfortunately, Rust's dynamic dispatch\n+//! mechanism does not support this, so we roll our own instead, with the following `DDValue`\n+//! declaration:\n+//!\n+//! ```\n+//! use differential_datalog::ddval::*;\n+//! pub struct DDValue {\n+//!    val: DDVal,\n+//!    vtable: &'static DDValMethods,\n+//! }\n+//! ```\n+//!\n+//! where `DDVal` is a `usize` that stores either an `Arc<T>` or `T` (where `T` is the actual type\n+//! of value stored in the DDlog relation), and `DDValMethods` is a virtual table of methods that\n+//! must be implemented for all DD values.\n+//!\n+//! This design still requires a separate heap allocation for each value >8 bytes, which slows\n+//! things down quite a bit.  Nevertheless, it has the same performance as our earlier\n+//! implementation using static dispatch and at least in some benchmarks uses less memory.  The\n+//! only way to improve things further I can think of is to somehow co-design this with DD to use\n+//! DD's knowledge of the context where a value is being created to, e.g., allocate blocks of\n+//! values when possible.\n+//!\n+\n+use std::fmt::Debug;\n+use std::fmt::Display;\n+use std::fmt::Formatter;\n+use std::hash::Hash;\n+use std::hash::Hasher;\n+\n+use serde::de::Deserialize;\n+use serde::de::Deserializer;\n+use serde::ser::Serialize;\n+use serde::ser::Serializer;\n+\n+use abomonation::Abomonation;\n+\n+use crate::record::IntoRecord;\n+use crate::record::Mutator;\n+use crate::record::Record;\n+\n+/// Type-erased representation of a value.  Can store the actual value or a pointer to it.\n+/// This could be just a `usize`, but we wrap it in a struct as we don't want it to implement\n+/// `Copy`.\n+pub struct DDVal {\n+    pub v: usize,\n+}\n+\n+/// DDValue: this type is stored in all DD collections.\n+/// It consists of value and associated vtable.\n+pub struct DDValue {\n+    val: DDVal,\n+    vtable: &'static DDValMethods,\n+}\n+\n+/// vtable of methods to be implemented by every value stored in DD.\n+pub struct DDValMethods {\n+    pub clone: fn(this: &DDVal) -> DDVal,\n+    pub into_record: fn(this: DDVal) -> Record,\n+    pub eq: fn(this: &DDVal, other: &DDVal) -> bool,\n+    pub partial_cmp: fn(this: &DDVal, other: &DDVal) -> Option<std::cmp::Ordering>,\n+    pub cmp: fn(this: &DDVal, other: &DDVal) -> std::cmp::Ordering,\n+    pub hash: fn(this: &DDVal, state: &mut dyn Hasher),\n+    pub mutate: fn(this: &mut DDVal, record: &Record) -> Result<(), String>,\n+    pub fmt_debug: fn(this: &DDVal, f: &mut Formatter) -> Result<(), std::fmt::Error>,\n+    pub fmt_display: fn(this: &DDVal, f: &mut Formatter) -> Result<(), std::fmt::Error>,\n+    pub drop: fn(this: &mut DDVal),\n+    pub ddval_serialize: fn(this: &DDVal) -> &dyn DDValSerialize,\n+}\n+\n+impl Drop for DDValue {\n+    fn drop(&mut self) {\n+        (self.vtable.drop)(&mut self.val);\n+    }\n+}\n+\n+impl DDValue {\n+    pub fn new(val: DDVal, vtable: &'static DDValMethods) -> DDValue {\n+        DDValue { val, vtable }\n+    }\n+\n+    pub fn into_ddval(self) -> DDVal {\n+        let res = DDVal { v: self.val.v };\n+        std::mem::forget(self);\n+        res\n+    }\n+}\n+\n+impl Mutator<DDValue> for Record {\n+    fn mutate(&self, x: &mut DDValue) -> Result<(), String> {\n+        (x.vtable.mutate)(&mut x.val, self)\n+    }\n+}\n+\n+impl IntoRecord for DDValue {\n+    fn into_record(self) -> Record {\n+        (self.vtable.into_record)(self.into_ddval())\n+    }\n+}\n+\n+impl Abomonation for DDValue {\n+    unsafe fn entomb<W: std::io::Write>(&self, _write: &mut W) -> std::io::Result<()> {\n+        panic!(\"DDValue::entomb: not implemented\")\n+    }\n+    unsafe fn exhume<'a, 'b>(&'a mut self, _bytes: &'b mut [u8]) -> Option<&'b mut [u8]> {\n+        panic!(\"DDValue::exhume: not implemented\")\n+    }\n+    fn extent(&self) -> usize {\n+        panic!(\"DDValue::extent: not implemented\")\n+    }\n+}\n+\n+impl Serialize for DDValue {\n+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n+    where\n+        S: Serializer,\n+    {\n+        (self.vtable.ddval_serialize)(&self.val).serialize(serializer)\n+    }\n+}\n+\n+impl<'de> Deserialize<'de> for DDValue {\n+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n+    where\n+        D: Deserializer<'de>,\n+    {\n+        let val: Box<dyn DDValSerialize> = Deserialize::deserialize(deserializer)?;\n+        Ok(val.ddvalue())\n+    }\n+}\n+\n+impl Display for DDValue {\n+    fn fmt(&self, f: &mut Formatter) -> Result<(), std::fmt::Error> {\n+        (self.vtable.fmt_display)(&self.val, f)\n+    }\n+}\n+\n+impl Debug for DDValue {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a5a18288ac80d325d0bd391f3d86c3007f5604c"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk0NTI5MQ==", "bodyText": "So this won't help much the tests?", "url": "https://github.com/vmware/differential-datalog/pull/501#discussion_r365945291", "createdAt": "2020-01-13T17:59:41Z", "author": {"login": "mbudiu-vmw"}, "path": "rust/template/differential_datalog/ddval.rs", "diffHunk": "@@ -0,0 +1,423 @@\n+//! DDValue: Generic value type stored in all differential-dataflow relations.\n+//!\n+//! Rationale: Differential dataflow allows the user to assign an arbitrary user-defined type to\n+//! each collection.  It relies on Rust's static dispatch mechanism to specialize its internal\n+//! machinery for each user-defined type.  Unfortunately, beyond very simple programs this leads to\n+//! extremely long compilation times.  One workaround that we used to rely on is to declare a\n+//! single enum type with a variant per concrete type used in at least one relation.  This make\n+//! compilation feasible, but still very slow (~6 minutes for a simple DDlog program and ~10\n+//! minutes for complex programs).\n+//!\n+//! Another alternative we implement here is to use a fixed value type that does not depend on\n+//! a concrete DDlog program and rely on dynamic dispatch to forward operations that DD expects\n+//! all values to implement (comparison, hashing, etc.) to their concrete implementations.  This\n+//! way this crate (differetial-datalog) can be compiled all the way to binary code separately\n+//! from the DDlog program using it and does not need to be re-compiled when the DDlog program\n+//! changes.  Thus, the only part that must be re-compiled on changes to the DDlog code is the\n+//! auto-generated crate that declares concrete value types and rules.  This is much faster than\n+//! re-compiling both crates together.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a5a18288ac80d325d0bd391f3d86c3007f5604c"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk0NTkyNw==", "bodyText": "This is actually very nice - it's almost search-and-replace.", "url": "https://github.com/vmware/differential-datalog/pull/501#discussion_r365945927", "createdAt": "2020-01-13T18:00:59Z", "author": {"login": "mbudiu-vmw"}, "path": "rust/template/differential_datalog/program.rs", "diffHunk": "@@ -2525,7 +2479,7 @@ impl<V: Val> RunningProgram<V> {\n     }\n \n     /* Broadcast message to all worker threads. */\n-    fn broadcast(&self, msg: Msg<V>) -> Response<()> {\n+    fn broadcast(&self, msg: Msg) -> Response<()> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a5a18288ac80d325d0bd391f3d86c3007f5604c"}, "originalPosition": 1140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk0ODEwOQ==", "bodyText": "This does not seem to be the same thing as the original code - this can never return None.\nWas the original code unable to statically typecheck?\nWhere is the dynamic type check made?", "url": "https://github.com/vmware/differential-datalog/pull/501#discussion_r365948109", "createdAt": "2020-01-13T18:06:03Z", "author": {"login": "mbudiu-vmw"}, "path": "rust/template/differential_datalog/test.rs", "diffHunk": "@@ -639,20 +376,16 @@ fn test_semijoin(nthreads: usize) {\n             })))),\n         }\n     };\n-    fn fmfun1(v: Value) -> Option<Value> {\n-        match v {\n-            Value::Tuple2(v1, _v2) => Some(*v1),\n-            _ => None,\n-        }\n+    fn fmfun1(v: DDValue) -> Option<DDValue> {\n+        let Tuple2(ref v1, ref _v2) = unsafe { Tuple2::<U64>::from_ddvalue(v) };", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a5a18288ac80d325d0bd391f3d86c3007f5604c"}, "originalPosition": 497}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTk1MjU5Mg==", "bodyText": "was this a bug? these do not seem to be equivalent.", "url": "https://github.com/vmware/differential-datalog/pull/501#discussion_r365952592", "createdAt": "2020-01-13T18:16:22Z", "author": {"login": "mbudiu-vmw"}, "path": "src/Language/DifferentialDatalog/Compile.hs", "diffHunk": "@@ -794,51 +765,51 @@ mkValueFromRecord d@DatalogProgram{..} =\n     mkIdxId2NameC                                                                                   $$\n     mkIdxIdMap d                                                                                    $$\n     mkIdxIdMapC d                                                                                   $$\n-    \"pub fn relval_from_record(rel: Relations, _rec: &record::Record) -> Result<Value, String> {\"   $$\n+    \"pub fn relval_from_record(rel: Relations, _rec: &record::Record) -> result::Result<DDValue, String> {\" $$\n     \"    match rel {\"                                                                               $$\n-    (nest' $ nest' $ vcat $ punctuate comma entries)                                                $$\n+    (nest' $ nest' $ vcommaSep entries)                                                             $$\n     \"    }\"                                                                                         $$\n     \"}\"                                                                                             $$\n-    \"pub fn relkey_from_record(rel: Relations, _rec: &record::Record) -> Result<Value, String> {\"   $$\n+    \"pub fn relkey_from_record(rel: Relations, _rec: &record::Record) -> result::Result<DDValue, String> {\" $$\n     \"    match rel {\"                                                                               $$\n-    (nest' $ nest' $ vcat $ key_entries)                                                            $$\n+    (nest' $ nest' $ vcommaSep key_entries)                                                         $$", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a5a18288ac80d325d0bd391f3d86c3007f5604c"}, "originalPosition": 135}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "92c3639f7fafea9b6f077d8b47c26b6fe1cdf857", "author": {"user": {"login": "ryzhyk", "name": "Leonid Ryzhyk"}}, "url": "https://github.com/vmware/differential-datalog/commit/92c3639f7fafea9b6f077d8b47c26b6fe1cdf857", "committedDate": "2020-01-13T18:43:45Z", "message": "Store small values inline.\n\nDynamic dispatch, as implemented in the previous commits, introduces a\nlarge number of small heap allocations, causing significant CPU and\nmemory overhead.  This is particularly wasteful for small values, as\neach value, even if it's only a few bytes long, requires 32 bytes\nof metadata (pointer to Arc + pointer to vtable + 8-byte strong\nreference counter + 8-byte weak reference counter).\n\nWe eliminate this overhead for small values <=8 bytes by storing them\ninline inside `DDValue` (where `Arc<value_type>`) would normally be\nstored.  Unfortunately, this means that we can no longer rely on Rust's\ndynamic dispatch mechanism, which does not support such optimizations.\nWe mock up our own dynamic dispatch mechanism instead.  Instead of\nusing trait objects, we define our own datatype that consists of a\npointer to data (or data stored inline) and a vtable, defined as a\nstruct with pointers.  At runtime we delegate operations on `DDValue`\nto methods in the vtable.\n\nCombined with previous optimizations, this improves the performance of\ndynamic dispatch to be on a par with static dispatch on the redist_opt\nbenchmark, with memory footprint being even better than with static\ndispatch (by ~15%)."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f164e064917c13eba9def2c51732a3deec7c76c1", "author": {"user": {"login": "ryzhyk", "name": "Leonid Ryzhyk"}}, "url": "https://github.com/vmware/differential-datalog/commit/f164e064917c13eba9def2c51732a3deec7c76c1", "committedDate": "2020-01-13T18:43:45Z", "message": "dynamic-dispatch.gnumeric: Dynamic dispatch benchmarks.\n\nPerformance numbers for the different implementations of dynamic\ndispatch for the redist_opt benchmark."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "317255534513bb9fa866bf496b9e272a4141abe4", "author": {"user": {"login": "ryzhyk", "name": "Leonid Ryzhyk"}}, "url": "https://github.com/vmware/differential-datalog/commit/317255534513bb9fa866bf496b9e272a4141abe4", "committedDate": "2020-01-13T18:43:45Z", "message": "run-test.sh: Time DDlog runs.\n\nModify the `run-test.sh` script to wrap invocation of DDlog CLI in\n`/usr/bin/time`.  This is useful in tracking how DDlog's CPU and\nmemory efficiency evolves across releases (manually for now)."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d158b317dabbbf4c8ae5257cd7510f8b541c2e71", "author": {"user": {"login": "ryzhyk", "name": "Leonid Ryzhyk"}}, "url": "https://github.com/vmware/differential-datalog/commit/d158b317dabbbf4c8ae5257cd7510f8b541c2e71", "committedDate": "2020-01-13T18:43:45Z", "message": ".gitlab-ci.yml: Move souffle0 to the new test framework.\n\nUse the `run-test.sh` script to run souffle0 test (which will track its\nperformance with `/usr/bin/time`).  Also compile this test in release\nand tag it `ddlog-ci-1`."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4a5a18288ac80d325d0bd391f3d86c3007f5604c", "author": {"user": {"login": "ryzhyk", "name": "Leonid Ryzhyk"}}, "url": "https://github.com/vmware/differential-datalog/commit/4a5a18288ac80d325d0bd391f3d86c3007f5604c", "committedDate": "2020-01-12T23:19:17Z", "message": ".gitlab-ci.yml: Move souffle0 to the new test framework.\n\nUse the `run-test.sh` script to run souffle0 test (which will track its\nperformance with `/usr/bin/time`).  Also compile this test in release\nand tag it `ddlog-ci-1`."}, "afterCommit": {"oid": "d158b317dabbbf4c8ae5257cd7510f8b541c2e71", "author": {"user": {"login": "ryzhyk", "name": "Leonid Ryzhyk"}}, "url": "https://github.com/vmware/differential-datalog/commit/d158b317dabbbf4c8ae5257cd7510f8b541c2e71", "committedDate": "2020-01-13T18:43:45Z", "message": ".gitlab-ci.yml: Move souffle0 to the new test framework.\n\nUse the `run-test.sh` script to run souffle0 test (which will track its\nperformance with `/usr/bin/time`).  Also compile this test in release\nand tag it `ddlog-ci-1`."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4618, "cost": 1, "resetAt": "2021-11-02T10:47:05Z"}}}