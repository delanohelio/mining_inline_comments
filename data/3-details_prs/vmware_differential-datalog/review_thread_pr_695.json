{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ0OTg3Mjcy", "number": 695, "reviewThreads": {"totalCount": 24, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMToyNDoyM1rOEL2Raw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMzozNzoyMFrOEL4EwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwODU4OTg3OnYy", "diffSide": "RIGHT", "path": "src/Language/DifferentialDatalog/Type.hs", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMToyNDoyM1rOGtnlMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMToyNDoyM1rOGtnlMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQ4NzYwMg==", "bodyText": "typo in error message", "url": "https://github.com/vmware/differential-datalog/pull/695#discussion_r450487602", "createdAt": "2020-07-06T21:24:23Z", "author": {"login": "mbudiu-vmw"}, "path": "src/Language/DifferentialDatalog/Type.hs", "diffHunk": "@@ -250,29 +246,25 @@ structTypeArgs d p ctx cname argtypes = do\n                                         \" to a concrete type in a call to type constructor \" ++ cname\n                      Just t  -> return t)\n          tdefArgs\n+-}\n \n-eunknown :: (MonadError String me) => DatalogProgram -> Pos -> ECtx -> me Type\n-eunknown d p ctx = err d p $ \"Expression has unknown type in \" ++ show ctx\n-\n-mtype2me :: (MonadError String me) => DatalogProgram -> Pos -> ECtx -> Maybe Type -> me Type\n-mtype2me d p ctx Nothing  = err d p $ \"Expression has unknown type in \" ++ show ctx\n-mtype2me _ _ _   (Just t) = return t\n-\n-exprNodeType' :: (MonadError String me) => DatalogProgram -> ECtx -> ExprNode (Maybe Type) -> me Type\n+exprNodeType' :: DatalogProgram -> ECtx -> ExprNode Type -> Type\n exprNodeType' d ctx (EVar p v)            =\n-    let (lvs, rvs) = ctxVars d ctx in\n-    case find ((==v) . name) $ lvs ++ rvs of\n-         Just var -> varCheckType d var\n+    let vs = ctxAllVars d ctx in\n+    case find ((==v) . name) vs of\n+         Just var -> varType d var\n          Nothing | ctxInRuleRHSPositivePattern ctx -- handle implicit vardecls in rules\n-                 -> varCheckType d $ ExprVar ctx $ EVar p v\n-         _       -> eunknown d p ctx\n+                 -> varType d $ ExprVar ctx $ EVar p v\n+         _       -> error $ \"exprNodeType': unknown vairable \" ++ v ++ \" at \" ++ show p", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4e516367fe3150eab8a89dae8b789b7a4498dc9"}, "originalPosition": 129}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwODU5MjY5OnYy", "diffSide": "RIGHT", "path": "src/Language/DifferentialDatalog/Type.hs", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMToyNToxOVrOGtnm5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMToyNToxOVrOGtnm5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQ4ODAzOA==", "bodyText": "why keep this comment?", "url": "https://github.com/vmware/differential-datalog/pull/695#discussion_r450488038", "createdAt": "2020-07-06T21:25:19Z", "author": {"login": "mbudiu-vmw"}, "path": "src/Language/DifferentialDatalog/Type.hs", "diffHunk": "@@ -250,29 +246,25 @@ structTypeArgs d p ctx cname argtypes = do\n                                         \" to a concrete type in a call to type constructor \" ++ cname\n                      Just t  -> return t)\n          tdefArgs\n+-}\n \n-eunknown :: (MonadError String me) => DatalogProgram -> Pos -> ECtx -> me Type\n-eunknown d p ctx = err d p $ \"Expression has unknown type in \" ++ show ctx\n-\n-mtype2me :: (MonadError String me) => DatalogProgram -> Pos -> ECtx -> Maybe Type -> me Type\n-mtype2me d p ctx Nothing  = err d p $ \"Expression has unknown type in \" ++ show ctx\n-mtype2me _ _ _   (Just t) = return t\n-\n-exprNodeType' :: (MonadError String me) => DatalogProgram -> ECtx -> ExprNode (Maybe Type) -> me Type\n+exprNodeType' :: DatalogProgram -> ECtx -> ExprNode Type -> Type\n exprNodeType' d ctx (EVar p v)            =\n-    let (lvs, rvs) = ctxVars d ctx in\n-    case find ((==v) . name) $ lvs ++ rvs of\n-         Just var -> varCheckType d var\n+    let vs = ctxAllVars d ctx in\n+    case find ((==v) . name) vs of\n+         Just var -> varType d var\n          Nothing | ctxInRuleRHSPositivePattern ctx -- handle implicit vardecls in rules\n-                 -> varCheckType d $ ExprVar ctx $ EVar p v\n-         _       -> eunknown d p ctx\n+                 -> varType d $ ExprVar ctx $ EVar p v\n+         _       -> error $ \"exprNodeType': unknown vairable \" ++ v ++ \" at \" ++ show p\n \n-exprNodeType' d ctx (EApply p f mas)      = do\n-    let func = getFunc d f\n-    let t = funcType func\n+exprNodeType' d ctx (EApply _ f _) | -- Type inference engine annotates calls to functions whose return type is polymorphic.\n+                                     typeIsPolymorphic t  = ctxExpectType ctx\n+                                   | otherwise            = t\n+    where t = funcType $ getFunc d f\n+{-", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4e516367fe3150eab8a89dae8b789b7a4498dc9"}, "originalPosition": 138}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwODU5NDQ1OnYy", "diffSide": "RIGHT", "path": "src/Language/DifferentialDatalog/Type.hs", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMToyNTo1NVrOGtnn4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMToyNTo1NVrOGtnn4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQ4ODI4OA==", "bodyText": "and this one?", "url": "https://github.com/vmware/differential-datalog/pull/695#discussion_r450488288", "createdAt": "2020-07-06T21:25:55Z", "author": {"login": "mbudiu-vmw"}, "path": "src/Language/DifferentialDatalog/Type.hs", "diffHunk": "@@ -281,103 +273,74 @@ exprNodeType' d ctx (EApply p f mas)      = do\n           $ \"Could not infer types of the following type variables (see the signature of function \" ++ f ++ \"): \" ++\n             (intercalate \", \" $ map (\"'\" ++) $ funcTypeVars func \\\\ M.keys subst)\n     return $ typeSubstTypeArgs subst t\n+-}\n \n-exprNodeType' d ctx (EField p Nothing _)  = eunknown d p ctx\n-exprNodeType' d _   (EField p (Just e) f) = do\n-    case typDeref' d e of\n-         t@TStruct{} ->\n-             case find ((==f) . name) $ structFields t of\n-                  Nothing  -> err d p $ \"Unknown field \\\"\" ++ f ++ \"\\\" in struct of type \" ++ show t\n-                  Just fld -> do check d (not $ structFieldGuarded t f) p\n-                                       $ \"Access to guarded field \\\"\" ++ f ++ \"\\\"\"\n-                                 return $ fieldType fld\n-         _           -> err d (pos e) $ \"Expression is not a struct\"\n-\n-\n-exprNodeType' d ctx (ETupField p Nothing _)  = eunknown d p ctx\n-exprNodeType' d _   (ETupField p (Just e) i) = do\n-    case typDeref' d e of\n-         t@TTuple{} -> do check d (((length $ typeTupArgs t) > i) && (0 <= i)) p\n-                            $ \"Tuple \\\"\" ++ show t ++ \"\\\" does not have \" ++ show i ++ \" fields\"\n-                          return $ (typeTupArgs t) !! i\n-         _           -> err d (pos e) $ \"Expression is not a tuple\"\n-\n-exprNodeType' _ _   (EBool _ _)           = return tBool\n-\n-exprNodeType' d ctx (EInt p _)            = do\n-    case ctxExpectType' d ctx of\n-         Just t@(TBit _ _)    -> return t\n-         Just t@(TSigned _ _) -> return t\n-         Just t@(TInt _)      -> return t\n-         Just t@(TDouble _)   -> return t\n-         Just t@(TFloat _)    -> return t\n-         Nothing              -> return tInt\n-         _                    -> eunknown d p ctx\n-\n-exprNodeType' _ _   (EString _ _)         = return tString\n-exprNodeType' _ _   (EBit _ w _)          = return $ tBit w\n-exprNodeType' _ _   (ESigned _ w _)       = return $ tSigned w\n-exprNodeType' _ _   (EFloat _ _)          = return $ tFloat\n-exprNodeType' _ _   (EDouble _ _)         = return $ tDouble\n-\n-exprNodeType' d ctx (EStruct p c mas)     = do\n-    let tdef = consType d c\n-    as <- mapM (\\(f, mt) -> (f,) <$> mtype2me d p ctx mt) mas\n-    targs <- structTypeArgs d p ctx c as\n-    return $ tUser (name tdef) targs\n-\n-exprNodeType' d ctx (ETuple p fs)         = fmap tTuple $ mapM (mtype2me d p ctx) fs\n-exprNodeType' _ _   (ESlice _ _ h l)      = return $ tBit $ h - l + 1\n-exprNodeType' d ctx (EMatch p _ cs)       = mtype2me d p ctx $ (fromJust . snd) <$> find (isJust . snd) cs\n-exprNodeType' d ctx (EVarDecl p _)        = mtype2me d p ctx $ ctxExpectType d ctx\n-exprNodeType' d ctx (ESeq p _ e2)         = mtype2me d p ctx e2\n-exprNodeType' d ctx (EITE p _ Nothing e)  = mtype2me d p ctx e\n-exprNodeType' _ _   (EITE _ _ (Just t) _) = return t\n-exprNodeType' _ _   (EFor _ _ _ _)        = return $ tTuple []\n-exprNodeType' _ _   (ESet _ _ _)          = return $ tTuple []\n-exprNodeType' d ctx (EContinue _)         = return $ maybe (tTuple []) id (ctxExpectType d ctx)\n-exprNodeType' d ctx (EBreak _)            = return $ maybe (tTuple []) id (ctxExpectType d ctx)\n-exprNodeType' d ctx (EReturn _ _)         = return $ maybe (tTuple []) id (ctxExpectType d ctx)\n-\n-exprNodeType' d _   (EBinOp _ op (Just e1) (Just e2)) =\n+exprNodeType' d _   (EField _ e f) =\n+    let t@TStruct{} = typDeref' d e \n+        fld = fromJust $ find ((==f) . name) $ structFields t\n+     --Just fld -> do check d (not $ structFieldGuarded t f) p", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4e516367fe3150eab8a89dae8b789b7a4498dc9"}, "originalPosition": 213}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwODU5NjIxOnYy", "diffSide": "RIGHT", "path": "src/Language/DifferentialDatalog/Type.hs", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMToyNjozMlrOGtno_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwMDoyOTo1OFrOGtrN0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQ4ODU3Mg==", "bodyText": "Could this crash if out of bounds?", "url": "https://github.com/vmware/differential-datalog/pull/695#discussion_r450488572", "createdAt": "2020-07-06T21:26:32Z", "author": {"login": "mbudiu-vmw"}, "path": "src/Language/DifferentialDatalog/Type.hs", "diffHunk": "@@ -281,103 +273,74 @@ exprNodeType' d ctx (EApply p f mas)      = do\n           $ \"Could not infer types of the following type variables (see the signature of function \" ++ f ++ \"): \" ++\n             (intercalate \", \" $ map (\"'\" ++) $ funcTypeVars func \\\\ M.keys subst)\n     return $ typeSubstTypeArgs subst t\n+-}\n \n-exprNodeType' d ctx (EField p Nothing _)  = eunknown d p ctx\n-exprNodeType' d _   (EField p (Just e) f) = do\n-    case typDeref' d e of\n-         t@TStruct{} ->\n-             case find ((==f) . name) $ structFields t of\n-                  Nothing  -> err d p $ \"Unknown field \\\"\" ++ f ++ \"\\\" in struct of type \" ++ show t\n-                  Just fld -> do check d (not $ structFieldGuarded t f) p\n-                                       $ \"Access to guarded field \\\"\" ++ f ++ \"\\\"\"\n-                                 return $ fieldType fld\n-         _           -> err d (pos e) $ \"Expression is not a struct\"\n-\n-\n-exprNodeType' d ctx (ETupField p Nothing _)  = eunknown d p ctx\n-exprNodeType' d _   (ETupField p (Just e) i) = do\n-    case typDeref' d e of\n-         t@TTuple{} -> do check d (((length $ typeTupArgs t) > i) && (0 <= i)) p\n-                            $ \"Tuple \\\"\" ++ show t ++ \"\\\" does not have \" ++ show i ++ \" fields\"\n-                          return $ (typeTupArgs t) !! i\n-         _           -> err d (pos e) $ \"Expression is not a tuple\"\n-\n-exprNodeType' _ _   (EBool _ _)           = return tBool\n-\n-exprNodeType' d ctx (EInt p _)            = do\n-    case ctxExpectType' d ctx of\n-         Just t@(TBit _ _)    -> return t\n-         Just t@(TSigned _ _) -> return t\n-         Just t@(TInt _)      -> return t\n-         Just t@(TDouble _)   -> return t\n-         Just t@(TFloat _)    -> return t\n-         Nothing              -> return tInt\n-         _                    -> eunknown d p ctx\n-\n-exprNodeType' _ _   (EString _ _)         = return tString\n-exprNodeType' _ _   (EBit _ w _)          = return $ tBit w\n-exprNodeType' _ _   (ESigned _ w _)       = return $ tSigned w\n-exprNodeType' _ _   (EFloat _ _)          = return $ tFloat\n-exprNodeType' _ _   (EDouble _ _)         = return $ tDouble\n-\n-exprNodeType' d ctx (EStruct p c mas)     = do\n-    let tdef = consType d c\n-    as <- mapM (\\(f, mt) -> (f,) <$> mtype2me d p ctx mt) mas\n-    targs <- structTypeArgs d p ctx c as\n-    return $ tUser (name tdef) targs\n-\n-exprNodeType' d ctx (ETuple p fs)         = fmap tTuple $ mapM (mtype2me d p ctx) fs\n-exprNodeType' _ _   (ESlice _ _ h l)      = return $ tBit $ h - l + 1\n-exprNodeType' d ctx (EMatch p _ cs)       = mtype2me d p ctx $ (fromJust . snd) <$> find (isJust . snd) cs\n-exprNodeType' d ctx (EVarDecl p _)        = mtype2me d p ctx $ ctxExpectType d ctx\n-exprNodeType' d ctx (ESeq p _ e2)         = mtype2me d p ctx e2\n-exprNodeType' d ctx (EITE p _ Nothing e)  = mtype2me d p ctx e\n-exprNodeType' _ _   (EITE _ _ (Just t) _) = return t\n-exprNodeType' _ _   (EFor _ _ _ _)        = return $ tTuple []\n-exprNodeType' _ _   (ESet _ _ _)          = return $ tTuple []\n-exprNodeType' d ctx (EContinue _)         = return $ maybe (tTuple []) id (ctxExpectType d ctx)\n-exprNodeType' d ctx (EBreak _)            = return $ maybe (tTuple []) id (ctxExpectType d ctx)\n-exprNodeType' d ctx (EReturn _ _)         = return $ maybe (tTuple []) id (ctxExpectType d ctx)\n-\n-exprNodeType' d _   (EBinOp _ op (Just e1) (Just e2)) =\n+exprNodeType' d _   (EField _ e f) =\n+    let t@TStruct{} = typDeref' d e \n+        fld = fromJust $ find ((==f) . name) $ structFields t\n+     --Just fld -> do check d (not $ structFieldGuarded t f) p\n+     -- $ \"Access to guarded field \\\"\" ++ f ++ \"\\\"\"\n+    in fieldType fld\n+\n+exprNodeType' d _   (ETupField _ e i) =\n+    let t@TTuple{} = typDeref' d e\n+    in (typeTupArgs t) !! i", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4e516367fe3150eab8a89dae8b789b7a4498dc9"}, "originalPosition": 219}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU0NzE1Mg==", "bodyText": "Hopefully not.  This function is called after type validation, which should in particular check this.", "url": "https://github.com/vmware/differential-datalog/pull/695#discussion_r450547152", "createdAt": "2020-07-07T00:29:58Z", "author": {"login": "ryzhyk"}, "path": "src/Language/DifferentialDatalog/Type.hs", "diffHunk": "@@ -281,103 +273,74 @@ exprNodeType' d ctx (EApply p f mas)      = do\n           $ \"Could not infer types of the following type variables (see the signature of function \" ++ f ++ \"): \" ++\n             (intercalate \", \" $ map (\"'\" ++) $ funcTypeVars func \\\\ M.keys subst)\n     return $ typeSubstTypeArgs subst t\n+-}\n \n-exprNodeType' d ctx (EField p Nothing _)  = eunknown d p ctx\n-exprNodeType' d _   (EField p (Just e) f) = do\n-    case typDeref' d e of\n-         t@TStruct{} ->\n-             case find ((==f) . name) $ structFields t of\n-                  Nothing  -> err d p $ \"Unknown field \\\"\" ++ f ++ \"\\\" in struct of type \" ++ show t\n-                  Just fld -> do check d (not $ structFieldGuarded t f) p\n-                                       $ \"Access to guarded field \\\"\" ++ f ++ \"\\\"\"\n-                                 return $ fieldType fld\n-         _           -> err d (pos e) $ \"Expression is not a struct\"\n-\n-\n-exprNodeType' d ctx (ETupField p Nothing _)  = eunknown d p ctx\n-exprNodeType' d _   (ETupField p (Just e) i) = do\n-    case typDeref' d e of\n-         t@TTuple{} -> do check d (((length $ typeTupArgs t) > i) && (0 <= i)) p\n-                            $ \"Tuple \\\"\" ++ show t ++ \"\\\" does not have \" ++ show i ++ \" fields\"\n-                          return $ (typeTupArgs t) !! i\n-         _           -> err d (pos e) $ \"Expression is not a tuple\"\n-\n-exprNodeType' _ _   (EBool _ _)           = return tBool\n-\n-exprNodeType' d ctx (EInt p _)            = do\n-    case ctxExpectType' d ctx of\n-         Just t@(TBit _ _)    -> return t\n-         Just t@(TSigned _ _) -> return t\n-         Just t@(TInt _)      -> return t\n-         Just t@(TDouble _)   -> return t\n-         Just t@(TFloat _)    -> return t\n-         Nothing              -> return tInt\n-         _                    -> eunknown d p ctx\n-\n-exprNodeType' _ _   (EString _ _)         = return tString\n-exprNodeType' _ _   (EBit _ w _)          = return $ tBit w\n-exprNodeType' _ _   (ESigned _ w _)       = return $ tSigned w\n-exprNodeType' _ _   (EFloat _ _)          = return $ tFloat\n-exprNodeType' _ _   (EDouble _ _)         = return $ tDouble\n-\n-exprNodeType' d ctx (EStruct p c mas)     = do\n-    let tdef = consType d c\n-    as <- mapM (\\(f, mt) -> (f,) <$> mtype2me d p ctx mt) mas\n-    targs <- structTypeArgs d p ctx c as\n-    return $ tUser (name tdef) targs\n-\n-exprNodeType' d ctx (ETuple p fs)         = fmap tTuple $ mapM (mtype2me d p ctx) fs\n-exprNodeType' _ _   (ESlice _ _ h l)      = return $ tBit $ h - l + 1\n-exprNodeType' d ctx (EMatch p _ cs)       = mtype2me d p ctx $ (fromJust . snd) <$> find (isJust . snd) cs\n-exprNodeType' d ctx (EVarDecl p _)        = mtype2me d p ctx $ ctxExpectType d ctx\n-exprNodeType' d ctx (ESeq p _ e2)         = mtype2me d p ctx e2\n-exprNodeType' d ctx (EITE p _ Nothing e)  = mtype2me d p ctx e\n-exprNodeType' _ _   (EITE _ _ (Just t) _) = return t\n-exprNodeType' _ _   (EFor _ _ _ _)        = return $ tTuple []\n-exprNodeType' _ _   (ESet _ _ _)          = return $ tTuple []\n-exprNodeType' d ctx (EContinue _)         = return $ maybe (tTuple []) id (ctxExpectType d ctx)\n-exprNodeType' d ctx (EBreak _)            = return $ maybe (tTuple []) id (ctxExpectType d ctx)\n-exprNodeType' d ctx (EReturn _ _)         = return $ maybe (tTuple []) id (ctxExpectType d ctx)\n-\n-exprNodeType' d _   (EBinOp _ op (Just e1) (Just e2)) =\n+exprNodeType' d _   (EField _ e f) =\n+    let t@TStruct{} = typDeref' d e \n+        fld = fromJust $ find ((==f) . name) $ structFields t\n+     --Just fld -> do check d (not $ structFieldGuarded t f) p\n+     -- $ \"Access to guarded field \\\"\" ++ f ++ \"\\\"\"\n+    in fieldType fld\n+\n+exprNodeType' d _   (ETupField _ e i) =\n+    let t@TTuple{} = typDeref' d e\n+    in (typeTupArgs t) !! i", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQ4ODU3Mg=="}, "originalCommit": {"oid": "e4e516367fe3150eab8a89dae8b789b7a4498dc9"}, "originalPosition": 219}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwODYxNDQ3OnYy", "diffSide": "RIGHT", "path": "test/datalog_tests/function.fail.ast.expected", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMTozMzoxOVrOGtn0EA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMTozMzoxOVrOGtn0EA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQ5MTQwOA==", "bodyText": "this is a significant improvement.", "url": "https://github.com/vmware/differential-datalog/pull/695#discussion_r450491408", "createdAt": "2020-07-06T21:33:19Z", "author": {"login": "mbudiu-vmw"}, "path": "test/datalog_tests/function.fail.ast.expected", "diffHunk": "@@ -10,12 +10,11 @@ error: ./test/datalog_tests/function.fail.dl:11:17-11:18: Variable v already def\n         C0{.x = v} -> v,\n                 ^\n \n-error: ./test/datalog_tests/function.fail.dl:11:17-11:24: Couldn't match expected type bit<32> with actual type bool (context: CtxTop\n-CtxFunc            shadow\n-CtxSeq2            ((var a: Alt) = C0{.x=1};  (var i: bit<32>) = match (a) {                         C0{.x=(var w: b...\n-CtxSetR            (var i: bit<32>) = match (a) {                        C0{.x=(var w: bool)} -> w,                 ...\n-CtxMatchPat        match (a) {     C0{.x=(var w: bool)} -> w,     C1{.x=var w} -> w } 0\n-CtxStruct          C0{.x=(var w: bool)} x)\n+error: ./test/datalog_tests/function.fail.dl:11:17-11:24: Type mismatch:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8121236dd1c82b3614327c4a96723920bf9d651"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwODYxODM2OnYy", "diffSide": "RIGHT", "path": "test/datalog_tests/function.fail.ast.expected", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMTozNDo1MVrOGtn2cA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwMDozMzowMlrOGtrQ6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQ5MjAxNg==", "bodyText": "why is the line number this time 6:1?", "url": "https://github.com/vmware/differential-datalog/pull/695#discussion_r450492016", "createdAt": "2020-07-06T21:34:51Z", "author": {"login": "mbudiu-vmw"}, "path": "test/datalog_tests/function.fail.ast.expected", "diffHunk": "@@ -43,7 +42,7 @@ Failed to parse input file: \"./test/datalog_tests/function.fail.dl\" (line 5, col\n unexpected \"f\"\n expecting \"=\" or \"{\"\n \n-error: ./test/datalog_tests/function.fail.dl:4:5-4:6: Expression is not a struct\n+error: ./test/datalog_tests/function.fail.dl:4:5-6:1: expression 'x' must have a field named 'bar', but its type 'bigint' doesn't", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8121236dd1c82b3614327c4a96723920bf9d651"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU0Nzk0Ng==", "bodyText": "Fixed; nice catch.", "url": "https://github.com/vmware/differential-datalog/pull/695#discussion_r450547946", "createdAt": "2020-07-07T00:33:02Z", "author": {"login": "ryzhyk"}, "path": "test/datalog_tests/function.fail.ast.expected", "diffHunk": "@@ -43,7 +42,7 @@ Failed to parse input file: \"./test/datalog_tests/function.fail.dl\" (line 5, col\n unexpected \"f\"\n expecting \"=\" or \"{\"\n \n-error: ./test/datalog_tests/function.fail.dl:4:5-4:6: Expression is not a struct\n+error: ./test/datalog_tests/function.fail.dl:4:5-6:1: expression 'x' must have a field named 'bar', but its type 'bigint' doesn't", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQ5MjAxNg=="}, "originalCommit": {"oid": "f8121236dd1c82b3614327c4a96723920bf9d651"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwODYzMDYwOnYy", "diffSide": "RIGHT", "path": "test/datalog_tests/function.fail.ast.expected", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMTozOToyMlrOGtn9zQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwMDozMzo0NlrOGtrRfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQ5MzkwMQ==", "bodyText": "This error message I find confusing, but perhaps I will get used to it.\nWe should explain somewhere why continue and break are typed.", "url": "https://github.com/vmware/differential-datalog/pull/695#discussion_r450493901", "createdAt": "2020-07-06T21:39:22Z", "author": {"login": "mbudiu-vmw"}, "path": "test/datalog_tests/function.fail.ast.expected", "diffHunk": "@@ -79,13 +78,15 @@ error: ./test/datalog_tests/function.fail.dl:6:5-7:1: \"continue\" outside of a lo\n     continue\n     ^\n \n-error: ./test/datalog_tests/function.fail.dl:8:9-8:18: Expression continue is not an l-value\n+error: ./test/datalog_tests/function.fail.dl:8:9-8:18: Expression (continue: bool) is not an l-value", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8121236dd1c82b3614327c4a96723920bf9d651"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQ5Njg4Nw==", "bodyText": "I think it's just simpler not to print types when giving errors about continue, return and break. Otherwise it's too confusing.", "url": "https://github.com/vmware/differential-datalog/pull/695#discussion_r450496887", "createdAt": "2020-07-06T21:47:18Z", "author": {"login": "mbudiu-vmw"}, "path": "test/datalog_tests/function.fail.ast.expected", "diffHunk": "@@ -79,13 +78,15 @@ error: ./test/datalog_tests/function.fail.dl:6:5-7:1: \"continue\" outside of a lo\n     continue\n     ^\n \n-error: ./test/datalog_tests/function.fail.dl:8:9-8:18: Expression continue is not an l-value\n+error: ./test/datalog_tests/function.fail.dl:8:9-8:18: Expression (continue: bool) is not an l-value", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQ5MzkwMQ=="}, "originalCommit": {"oid": "f8121236dd1c82b3614327c4a96723920bf9d651"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU0ODA5NA==", "bodyText": "I think it's just simpler not to print types when giving errors about continue, return and break. Otherwise it's too confusing.\n\nOk, I did that.", "url": "https://github.com/vmware/differential-datalog/pull/695#discussion_r450548094", "createdAt": "2020-07-07T00:33:46Z", "author": {"login": "ryzhyk"}, "path": "test/datalog_tests/function.fail.ast.expected", "diffHunk": "@@ -79,13 +78,15 @@ error: ./test/datalog_tests/function.fail.dl:6:5-7:1: \"continue\" outside of a lo\n     continue\n     ^\n \n-error: ./test/datalog_tests/function.fail.dl:8:9-8:18: Expression continue is not an l-value\n+error: ./test/datalog_tests/function.fail.dl:8:9-8:18: Expression (continue: bool) is not an l-value", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQ5MzkwMQ=="}, "originalCommit": {"oid": "f8121236dd1c82b3614327c4a96723920bf9d651"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwODYzNDc4OnYy", "diffSide": "RIGHT", "path": "test/datalog_tests/function.fail.ast.expected", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMTo0MTowMVrOGtoAWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMTo0MTowMVrOGtoAWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQ5NDU1Mg==", "bodyText": "this one could probably be improved a bit, but this may require more work, explaining why () is expected.", "url": "https://github.com/vmware/differential-datalog/pull/695#discussion_r450494552", "createdAt": "2020-07-06T21:41:01Z", "author": {"login": "mbudiu-vmw"}, "path": "test/datalog_tests/function.fail.ast.expected", "diffHunk": "@@ -79,13 +78,15 @@ error: ./test/datalog_tests/function.fail.dl:6:5-7:1: \"continue\" outside of a lo\n     continue\n     ^\n \n-error: ./test/datalog_tests/function.fail.dl:8:9-8:18: Expression continue is not an l-value\n+error: ./test/datalog_tests/function.fail.dl:8:9-8:18: Expression (continue: bool) is not an l-value\n         continue = true\n         ^^^^^^^^^\n \n-error: ./test/datalog_tests/function.fail.dl:6:12-7:1: Couldn't match expected type () with actual type bool (context: CtxTop\n-CtxFunc            control_flow\n-CtxReturn          return false)\n+error: ./test/datalog_tests/function.fail.dl:6:12-7:1: Type mismatch:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8121236dd1c82b3614327c4a96723920bf9d651"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwODY2NjMyOnYy", "diffSide": "RIGHT", "path": "test/datalog_tests/simple.dl", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMTo1MzozNVrOGtoTMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMTo1MzozNVrOGtoTMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQ5OTM3Ng==", "bodyText": "no changes in the ast file?", "url": "https://github.com/vmware/differential-datalog/pull/695#discussion_r450499376", "createdAt": "2020-07-06T21:53:35Z", "author": {"login": "mbudiu-vmw"}, "path": "test/datalog_tests/simple.dl", "diffHunk": "@@ -160,17 +160,17 @@ output relation Compare(label: string, value: bool)\n \n Compare(\"true >= false\", true >= false).\n Compare([|\"\" >= \"a\"|], \"\" >= \"a\").\n-Compare(\"5 <= 3\", 5 <= 3).\n-Compare(\"(1, 2) >= (3, 4)\", (1, 2) >= (3, 4)).\n-Compare(\"(1, 2) < (3, 4)\", (1, 2) < (3, 4)).\n-Compare(\"(1, 2) < (1, 4)\", (1, 2) < (1, 4)).\n+Compare(\"5 <= 3\", (5: u64) <= 3).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8121236dd1c82b3614327c4a96723920bf9d651"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwODY3NDc2OnYy", "diffSide": "RIGHT", "path": "src/Language/DifferentialDatalog/Expr.hs", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMTo1Njo1MlrOGtoYGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwMDozODo0NVrOGtrWHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDUwMDYzMg==", "bodyText": "Was this a bug? This looks like a strange change.", "url": "https://github.com/vmware/differential-datalog/pull/695#discussion_r450500632", "createdAt": "2020-07-06T21:56:52Z", "author": {"login": "mbudiu-vmw"}, "path": "src/Language/DifferentialDatalog/Expr.hs", "diffHunk": "@@ -391,16 +404,16 @@ exprIsDeconstruct' _ (ETyped _ e _)   = e\n exprIsDeconstruct' _ _                = False\n \n -- | True if 'e' is a variable or field expression, and\n--- can be assigned to (i.e., the variable is writable)\n+-- can be assigned to (i.e., the variable is writable).\n exprIsVarOrFieldLVal :: DatalogProgram -> ECtx -> Expr -> Bool\n exprIsVarOrFieldLVal d ctx e = snd $ exprFoldCtx (exprIsVarOrFieldLVal' d) ctx e\n \n exprIsVarOrFieldLVal' :: DatalogProgram -> ECtx -> ExprNode (Expr, Bool) -> (Expr, Bool)\n exprIsVarOrFieldLVal' d ctx expr =\n     case expr of\n         (EVar _ v)            -> (E e', isLVar d ctx v)\n-        (EField _ (e, b) _)   -> (E e', b && (isSharedRef d $ exprType d (CtxField e' ctx) e))\n-        (ETupField _ (e,b) _) -> (E e', b && (isSharedRef d $ exprType d (CtxTupField e' ctx) e))\n+        (EField _ (e, b) _)   -> (E e', b && (not $ isSharedRef d $ exprType d (CtxField e' ctx) e))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8121236dd1c82b3614327c4a96723920bf9d651"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU0OTI3OA==", "bodyText": "I think this was a bug.  Looks like our tests did not cover this simple case. I'll add some tests for this.", "url": "https://github.com/vmware/differential-datalog/pull/695#discussion_r450549278", "createdAt": "2020-07-07T00:38:45Z", "author": {"login": "ryzhyk"}, "path": "src/Language/DifferentialDatalog/Expr.hs", "diffHunk": "@@ -391,16 +404,16 @@ exprIsDeconstruct' _ (ETyped _ e _)   = e\n exprIsDeconstruct' _ _                = False\n \n -- | True if 'e' is a variable or field expression, and\n--- can be assigned to (i.e., the variable is writable)\n+-- can be assigned to (i.e., the variable is writable).\n exprIsVarOrFieldLVal :: DatalogProgram -> ECtx -> Expr -> Bool\n exprIsVarOrFieldLVal d ctx e = snd $ exprFoldCtx (exprIsVarOrFieldLVal' d) ctx e\n \n exprIsVarOrFieldLVal' :: DatalogProgram -> ECtx -> ExprNode (Expr, Bool) -> (Expr, Bool)\n exprIsVarOrFieldLVal' d ctx expr =\n     case expr of\n         (EVar _ v)            -> (E e', isLVar d ctx v)\n-        (EField _ (e, b) _)   -> (E e', b && (isSharedRef d $ exprType d (CtxField e' ctx) e))\n-        (ETupField _ (e,b) _) -> (E e', b && (isSharedRef d $ exprType d (CtxTupField e' ctx) e))\n+        (EField _ (e, b) _)   -> (E e', b && (not $ isSharedRef d $ exprType d (CtxField e' ctx) e))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDUwMDYzMg=="}, "originalCommit": {"oid": "f8121236dd1c82b3614327c4a96723920bf9d651"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwODY3ODk5OnYy", "diffSide": "RIGHT", "path": "src/Language/DifferentialDatalog/Expr.hs", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMTo1ODoyMlrOGtoapw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwMDo0MDo1OVrOGtrYIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDUwMTI4Nw==", "bodyText": "Shouldn't this come after validating the length?", "url": "https://github.com/vmware/differential-datalog/pull/695#discussion_r450501287", "createdAt": "2020-07-06T21:58:22Z", "author": {"login": "mbudiu-vmw"}, "path": "src/Language/DifferentialDatalog/Expr.hs", "diffHunk": "@@ -471,3 +484,42 @@ exprTypeMapM fun e = exprFoldM fun' e\n     fun' (ETyped p e' t) = (E . ETyped p e') <$> typeMapM fun t\n     fun' (EAs p e' t)    = (E . EAs p e') <$> typeMapM fun t\n     fun' e'              = return $ E e'\n+\n+-- Automatically insert string conversion functions in the Concat\n+-- operator:  '\"x:\" ++ x', where 'x' is of type int becomes\n+-- '\"x:\" ++ int_2string(x)'.\n+exprInjectStringConversion :: (MonadError String me) => DatalogProgram -> ENode -> Type -> me Expr\n+exprInjectStringConversion d e t = do\n+    -- find string conversion function\n+    fname <- case t of\n+                  TBool{}     -> return $ bUILTIN_2STRING_FUNC\n+                  TInt{}      -> return $ bUILTIN_2STRING_FUNC\n+                  TString{}   -> return $ bUILTIN_2STRING_FUNC\n+                  TBit{}      -> return $ bUILTIN_2STRING_FUNC\n+                  TSigned{}   -> return $ bUILTIN_2STRING_FUNC\n+                  TDouble{}   -> return $ bUILTIN_2STRING_FUNC\n+                  TFloat{}    -> return $ bUILTIN_2STRING_FUNC\n+                  TUser{..}   -> return $ mk2string_func typeName\n+                  TOpaque{..} -> return $ mk2string_func typeName\n+                  TTuple{}    -> err d (pos e) \"Automatic string conversion for tuples is not supported\"\n+                  TVar{..}    -> err d (pos e) $\n+                                     \"Cannot automatically convert \" ++ show e ++\n+                                     \" of variable type \" ++ tvarName ++ \" to string\"\n+                  TStruct{}   -> error \"unexpected TStruct in exprInjectStringConversions\"\n+    f <- case lookupFunc d fname of\n+              Nothing  -> err d (pos e) $ \"Cannot find declaration of function \" ++ fname ++\n+                                        \" needed to convert expression \" ++ show e ++ \" to string\"\n+              Just fun -> return fun\n+    let arg0 = funcArgs f !! 0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8121236dd1c82b3614327c4a96723920bf9d651"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU0OTc5NQ==", "bodyText": "It's sufficient that it's only used after length validation.  The magic of lazy evaluation.  I'll move it down though to avoid confusion.", "url": "https://github.com/vmware/differential-datalog/pull/695#discussion_r450549795", "createdAt": "2020-07-07T00:40:59Z", "author": {"login": "ryzhyk"}, "path": "src/Language/DifferentialDatalog/Expr.hs", "diffHunk": "@@ -471,3 +484,42 @@ exprTypeMapM fun e = exprFoldM fun' e\n     fun' (ETyped p e' t) = (E . ETyped p e') <$> typeMapM fun t\n     fun' (EAs p e' t)    = (E . EAs p e') <$> typeMapM fun t\n     fun' e'              = return $ E e'\n+\n+-- Automatically insert string conversion functions in the Concat\n+-- operator:  '\"x:\" ++ x', where 'x' is of type int becomes\n+-- '\"x:\" ++ int_2string(x)'.\n+exprInjectStringConversion :: (MonadError String me) => DatalogProgram -> ENode -> Type -> me Expr\n+exprInjectStringConversion d e t = do\n+    -- find string conversion function\n+    fname <- case t of\n+                  TBool{}     -> return $ bUILTIN_2STRING_FUNC\n+                  TInt{}      -> return $ bUILTIN_2STRING_FUNC\n+                  TString{}   -> return $ bUILTIN_2STRING_FUNC\n+                  TBit{}      -> return $ bUILTIN_2STRING_FUNC\n+                  TSigned{}   -> return $ bUILTIN_2STRING_FUNC\n+                  TDouble{}   -> return $ bUILTIN_2STRING_FUNC\n+                  TFloat{}    -> return $ bUILTIN_2STRING_FUNC\n+                  TUser{..}   -> return $ mk2string_func typeName\n+                  TOpaque{..} -> return $ mk2string_func typeName\n+                  TTuple{}    -> err d (pos e) \"Automatic string conversion for tuples is not supported\"\n+                  TVar{..}    -> err d (pos e) $\n+                                     \"Cannot automatically convert \" ++ show e ++\n+                                     \" of variable type \" ++ tvarName ++ \" to string\"\n+                  TStruct{}   -> error \"unexpected TStruct in exprInjectStringConversions\"\n+    f <- case lookupFunc d fname of\n+              Nothing  -> err d (pos e) $ \"Cannot find declaration of function \" ++ fname ++\n+                                        \" needed to convert expression \" ++ show e ++ \" to string\"\n+              Just fun -> return fun\n+    let arg0 = funcArgs f !! 0", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDUwMTI4Nw=="}, "originalCommit": {"oid": "f8121236dd1c82b3614327c4a96723920bf9d651"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwODY4Njg0OnYy", "diffSide": "RIGHT", "path": "src/Language/DifferentialDatalog/NS.hs", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMjowMToyNFrOGtofbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMjowMToyNFrOGtofbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDUwMjUwOQ==", "bodyText": "delete?", "url": "https://github.com/vmware/differential-datalog/pull/695#discussion_r450502509", "createdAt": "2020-07-06T22:01:24Z", "author": {"login": "mbudiu-vmw"}, "path": "src/Language/DifferentialDatalog/NS.hs", "diffHunk": "@@ -148,9 +148,10 @@ ctxVars d ctx =\n          CtxMatchPat _ _ _        -> ([], plvars ++ prvars)\n          CtxMatchVal e pctx i     -> let patternVars = exprVarDecls d (CtxMatchPat e pctx i)\n                                                        $ fst $ (exprCases e) !! i in\n-                                     if exprIsVarOrFieldLVal d pctx $ exprMatchExpr e\n+                                     {-if exprIsVarOrFieldLVal d pctx $ exprMatchExpr e", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8121236dd1c82b3614327c4a96723920bf9d651"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwODcxNzAzOnYy", "diffSide": "RIGHT", "path": "src/Language/DifferentialDatalog/Optimize.hs", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMjoxNDozMVrOGtoxwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwMDo0MzoxOFrOGtraZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDUwNzIwMQ==", "bodyText": "why not do this always? I don't expect it takes too long.", "url": "https://github.com/vmware/differential-datalog/pull/695#discussion_r450507201", "createdAt": "2020-07-06T22:14:31Z", "author": {"login": "mbudiu-vmw"}, "path": "src/Language/DifferentialDatalog/Optimize.hs", "diffHunk": "@@ -37,19 +37,22 @@ import Control.Monad.State\n import qualified Data.Map as M\n --import Debug.Trace\n \n+import Language.DifferentialDatalog.Config\n import Language.DifferentialDatalog.Pos\n import Language.DifferentialDatalog.Name\n import Language.DifferentialDatalog.Type\n import Language.DifferentialDatalog.Syntax\n import Language.DifferentialDatalog.Rule\n import Language.DifferentialDatalog.Validate\n \n-optimize :: DatalogProgram -> DatalogProgram\n+optimize :: (?cfg::Config) => DatalogProgram -> DatalogProgram\n optimize d = \n     let d' = optEliminateCommonPrefixes $ optExpandMultiheadRules d\n-    in case validate d' of\n-            Left err -> error $ \"could not validate optimized spec: \" ++ err\n-            Right _  -> d'\n+    in if confReValidate ?cfg\n+       then case validate d' of", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8121236dd1c82b3614327c4a96723920bf9d651"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU1MDM3NA==", "bodyText": "It does on large programs.  Takes 8 seconds on ovn. I'll keep optimizing, but yeah it can be expensive right now.", "url": "https://github.com/vmware/differential-datalog/pull/695#discussion_r450550374", "createdAt": "2020-07-07T00:43:18Z", "author": {"login": "ryzhyk"}, "path": "src/Language/DifferentialDatalog/Optimize.hs", "diffHunk": "@@ -37,19 +37,22 @@ import Control.Monad.State\n import qualified Data.Map as M\n --import Debug.Trace\n \n+import Language.DifferentialDatalog.Config\n import Language.DifferentialDatalog.Pos\n import Language.DifferentialDatalog.Name\n import Language.DifferentialDatalog.Type\n import Language.DifferentialDatalog.Syntax\n import Language.DifferentialDatalog.Rule\n import Language.DifferentialDatalog.Validate\n \n-optimize :: DatalogProgram -> DatalogProgram\n+optimize :: (?cfg::Config) => DatalogProgram -> DatalogProgram\n optimize d = \n     let d' = optEliminateCommonPrefixes $ optExpandMultiheadRules d\n-    in case validate d' of\n-            Left err -> error $ \"could not validate optimized spec: \" ++ err\n-            Right _  -> d'\n+    in if confReValidate ?cfg\n+       then case validate d' of", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDUwNzIwMQ=="}, "originalCommit": {"oid": "f8121236dd1c82b3614327c4a96723920bf9d651"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwODc0Mzc2OnYy", "diffSide": "RIGHT", "path": "test/datalog_tests/tutorial.debug.ast.expected", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMjoyNjoxNVrOGtpBxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMjoyNjoxNVrOGtpBxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDUxMTMwMQ==", "bodyText": "I see now why you want parentheses for return.", "url": "https://github.com/vmware/differential-datalog/pull/695#discussion_r450511301", "createdAt": "2020-07-06T22:26:15Z", "author": {"login": "mbudiu-vmw"}, "path": "test/datalog_tests/tutorial.debug.ast.expected", "diffHunk": "@@ -123,59 +123,59 @@ typedef tcp_pkt_t = TCPPkt{src: bit<16>, dst: bit<16>, flags: bit<9>}\n typedef udp_pkt_t = UDPPkt{src: bit<16>, dst: bit<16>, len: bit<16>}\n function __debug_17_1_std.group_min (g: std.Group<string,('I, bit<64>)>): (std.Vec<'I>, bit<64>)\n {\n-    ((var inputs, var original_group) = debug.debug_split_group(g);\n+    (((var inputs: std.Vec<'I>), (var original_group: std.Group<string,bit<64>>)) = debug.debug_split_group(g);\n      (inputs, std.group_min(original_group)))\n }\n function __debug_18_1_std.group_max (g: std.Group<string,('I, bit<64>)>): (std.Vec<'I>, bit<64>)\n {\n-    ((var inputs, var original_group) = debug.debug_split_group(g);\n+    (((var inputs: std.Vec<'I>), (var original_group: std.Group<string,bit<64>>)) = debug.debug_split_group(g);\n      (inputs, std.group_max(original_group)))\n }\n function __debug_19_1_best_vendor (g: std.Group<string,('I, (string, bit<64>))>): (std.Vec<'I>, (string, bit<64>))\n {\n-    ((var inputs, var original_group) = debug.debug_split_group(g);\n+    (((var inputs: std.Vec<'I>), (var original_group: std.Group<string,(string, bit<64>)>)) = debug.debug_split_group(g);\n      (inputs, best_vendor(original_group)))\n }\n function __debug_20_2_best_vendor_string (g: std.Group<string,('I, (string, bit<64>))>): (std.Vec<'I>, string)\n {\n-    ((var inputs, var original_group) = debug.debug_split_group(g);\n+    (((var inputs: std.Vec<'I>), (var original_group: std.Group<string,(string, bit<64>)>)) = debug.debug_split_group(g);\n      (inputs, best_vendor_string(original_group)))\n }\n function __debug_30_1_std.group_max (g: std.Group<string,('I, bit<16>)>): (std.Vec<'I>, bit<16>)\n {\n-    ((var inputs, var original_group) = debug.debug_split_group(g);\n+    (((var inputs: std.Vec<'I>), (var original_group: std.Group<string,bit<16>>)) = debug.debug_split_group(g);\n      (inputs, std.group_max(original_group)))\n }\n function __debug_31_1_std.group_max (g: std.Group<string,('I, bit<16>)>): (std.Vec<'I>, bit<16>)\n {\n-    ((var inputs, var original_group) = debug.debug_split_group(g);\n+    (((var inputs: std.Vec<'I>), (var original_group: std.Group<string,bit<16>>)) = debug.debug_split_group(g);\n      (inputs, std.group_max(original_group)))\n }\n-function __debug_32_1_std.group2vec (g: std.Group<internment.istring,('I, bit<64>)>): (std.Vec<'I>, std.Vec<bit<64>>)\n+function __debug_32_1_std.group2vec (g: std.Group<internment.Intern<string>,('I, bit<64>)>): (std.Vec<'I>, std.Vec<bit<64>>)\n {\n-    ((var inputs, var original_group) = debug.debug_split_group(g);\n+    (((var inputs: std.Vec<'I>), (var original_group: std.Group<internment.Intern<string>,bit<64>>)) = debug.debug_split_group(g);\n      (inputs, std.group2vec(original_group)))\n }\n function addr_port (ip: ip_addr_t, proto: string, preferred_port: bit<16>): string\n {\n     ((var port: bit<16>) = match (proto) {\n                                \"FTP\" -> 16'd20,\n                                \"HTTPS\" -> 16'd443,\n-                               _ -> if (preferred_port != 16'd0) {\n-                                        preferred_port\n-                                    } else {\n-                                          return ((\"\" ++ ip_addr_t2string(ip)) ++ \":80\")\n-                                      }\n+                               (_: string) -> if (preferred_port != 16'd0) {\n+                                                  preferred_port\n+                                              } else {\n+                                                    ((return ((\"\" ++ (ip_addr_t2string(ip): string)) ++ \":80\")): bit<16>)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4dfd3a0fc5e4521508ae6fbc3e5566908026e6ac"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwODc0NjU5OnYy", "diffSide": "RIGHT", "path": "test/datalog_tests/simple2.dl", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMjoyNzoyNlrOGtpDaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMjoyNzoyNlrOGtpDaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDUxMTcyMQ==", "bodyText": "how about a test with multiple generic functions calling each other to test unification?", "url": "https://github.com/vmware/differential-datalog/pull/695#discussion_r450511721", "createdAt": "2020-07-06T22:27:26Z", "author": {"login": "mbudiu-vmw"}, "path": "test/datalog_tests/simple2.dl", "diffHunk": "@@ -140,3 +140,19 @@ OutputInspectNot(x, y) :-\n     InputInspectNot1(x, y),\n     not InputInspectNot2(x),\n     Inspect log.log(\"../simple2.log\", \"${ddlog_timestamp}: ${if (ddlog_weight > 0) {\\\"insert\\\"} else {\\\"delete\\\"}}: x=${y} y=${y}\").\n+\n+// Type inference test.\n+function ti_f(value: Option<string>): Option<(string, string)> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4dfd3a0fc5e4521508ae6fbc3e5566908026e6ac"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwODc4OTA3OnYy", "diffSide": "RIGHT", "path": "src/Language/DifferentialDatalog/Validate.hs", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMjo0OToxMlrOGtpdZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMjo0OToxMlrOGtpdZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDUxODM3NQ==", "bodyText": "\"validated\"", "url": "https://github.com/vmware/differential-datalog/pull/695#discussion_r450518375", "createdAt": "2020-07-06T22:49:12Z", "author": {"login": "mbudiu-vmw"}, "path": "src/Language/DifferentialDatalog/Validate.hs", "diffHunk": "@@ -234,103 +226,127 @@ funcValidateProto d f@Function{..} = do\n     typeValidate d tvars funcType\n \n \n-funcValidateDefinition :: (MonadError String me) => DatalogProgram -> Function -> me ()\n+funcValidateDefinition :: (MonadError String me) => DatalogProgram -> Function -> me Function\n funcValidateDefinition d f@Function{..} = do\n     case funcDef of\n-         Nothing  -> return ()\n-         Just def -> exprValidate d (funcTypeVars f) (CtxFunc f) def\n+         Nothing  -> return f\n+         Just def -> do def' <- exprValidate d (funcTypeVars f) (CtxFunc f) def\n+                        return f{funcDef = Just def'}\n \n-relValidate :: (MonadError String me) => DatalogProgram -> Relation -> me ()\n+relValidate :: (MonadError String me) => DatalogProgram -> Relation -> me Relation\n relValidate d rel@Relation{..} = do\n     typeValidate d [] relType\n     check d (isNothing relPrimaryKey || relRole == RelInput) (pos rel)\n         $ \"Only input relations can be declared with a primary key\"\n-    maybe (return ()) (exprValidate d [] (CtxKey rel) . keyExpr) relPrimaryKey\n-\n-indexValidate :: (MonadError String me) => DatalogProgram -> Index -> me ()\n-indexValidate d idx@Index{..} = do\n-    fieldsValidate d [] idxVars\n-    atomValidate d (CtxIndex idx) idxAtom\n-    check d (exprIsPatternImpl $ atomVal idxAtom) (pos idxAtom)\n+    case relPrimaryKey of\n+         Nothing -> return rel\n+         Just pkey -> do pkey' <- exprValidate d [] (CtxKey rel) $ keyExpr pkey\n+                         return rel{relPrimaryKey = Just pkey{keyExpr = pkey'}}\n+\n+indexValidate :: (MonadError String me) => DatalogProgram -> Index -> me Index\n+indexValidate d idx = do\n+    fieldsValidate d [] $ idxVars idx\n+    atomValidate d (CtxIndex idx) $ idxAtom idx\n+    val' <- exprValidate d [] (CtxIndex idx) $ atomVal $ idxAtom idx\n+    let idx' = idx {idxAtom = (idxAtom idx) {atomVal = val'}}\n+    check d (exprIsPatternImpl $ atomVal $ idxAtom idx') (pos $ idxAtom idx')\n           $ \"Index expression is not a pattern\"\n     -- Atom is defined over exactly the variables in the index.\n     -- (variables in 'atom_vars \\\\ idx_vars' should be caught by 'atomValidate'\n     -- above, so we only need to check for 'idx_vars \\\\ atom_vars' here).\n-    let idx_vars = map name idxVars\n-    let atom_vars = map name $ exprFreeVars d (CtxIndex idx) (atomVal idxAtom)\n-    check d (null $ idx_vars \\\\ atom_vars) (pos idx)\n+    let idx_vars = map name $ idxVars idx'\n+    let atom_vars = map name $ exprFreeVars d (CtxIndex idx') (atomVal $ idxAtom idx')\n+    check d (null $ idx_vars \\\\ atom_vars) (pos idx')\n           $ \"The following index variables are not constrained by the index pattern: \" ++\n             (show $ idx_vars \\\\ atom_vars)\n+    return idx'\n \n-ruleValidate :: (MonadError String me) => DatalogProgram -> Rule -> me ()\n+ruleValidate :: (MonadError String me) => DatalogProgram -> Rule -> me Rule\n ruleValidate d rl@Rule{..} = do\n     when (not $ null ruleRHS) $ do\n         case head ruleRHS of\n              RHSLiteral True _ -> return ()\n-             _                 -> err d (pos rl) \"Rule must start with positive literal\"\n+             _                 -> err d (pos rl) \"Rule must start with a positive literal\"\n     mapIdxM_ (ruleRHSValidate d rl) ruleRHS\n-    mapIdxM_ (ruleLHSValidate d rl) ruleLHS\n+    mapM_ (ruleLHSValidate d rl) ruleLHS\n+    -- It is now safe to perform type inference\n+    ruleValidateExpressions d rl\n+\n+-- We must perform type inference on all parts of the rule at the same time.\n+ruleValidateExpressions :: (MonadError String me) => DatalogProgram -> Rule -> me Rule\n+ruleValidateExpressions d rl = do\n+    let rhs_es = concat $\n+                 mapIdx (\\rhs i ->\n+                          case rhs of\n+                               RHSLiteral{..} -> [(CtxRuleRAtom rl i, atomVal rhsAtom)]\n+                               RHSCondition{..} -> [(CtxRuleRCond rl i, rhsExpr)]\n+                               RHSFlatMap{..} -> [(CtxRuleRFlatMap rl i, rhsMapExpr)]\n+                               RHSAggregate{..} -> [ (CtxRuleRGroupBy rl i, rhsGroupBy)\n+                                                   , (CtxRuleRAggregate rl i, rhsAggExpr)]\n+                               RHSInspect{..} -> [(CtxRuleRInspect rl i, rhsInspectExpr)])\n+                        $ ruleRHS rl\n+    let lhs_es = mapIdx (\\lhs i -> (CtxRuleL rl i, atomVal lhs)) $ ruleLHS rl\n+    es' <- exprsTypeCheck d [] (rhs_es++lhs_es)\n+    -- Put type-annotated expressions back into the rule.\n+    let (es'', rhss') = foldl' (\\(es, rhss) rhs ->\n+                                case rhs of\n+                                     RHSLiteral{..} -> (tail es, rhss ++ [rhs{rhsAtom = rhsAtom {atomVal = head es}}])\n+                                     RHSCondition{..} -> (tail es, rhss ++ [rhs{rhsExpr = head es}])\n+                                     RHSFlatMap{..} -> (tail es, rhss ++ [rhs{rhsMapExpr = head es}])\n+                                     RHSAggregate{..} -> (tail $ tail es, rhss ++ [rhs{rhsGroupBy = head es, rhsAggExpr = head $ tail es}])\n+                                     RHSInspect{..} -> (tail es, rhss ++ [rhs{rhsInspectExpr = head es}]))\n+                            (es', []) $ ruleRHS rl\n+    let ([], lhss') = foldl' (\\(es, lhss) lhs -> (tail es, lhss ++ [lhs{atomVal = head es}]))\n+                            (es'', []) $ ruleLHS rl\n+    let rl' = rl{ruleLHS = lhss', ruleRHS = rhss'}\n+\n+    -- Post-validate.\n+    let rhs_es' = concat $\n+                  mapIdx (\\rhs i ->\n+                           case rhs of\n+                                RHSLiteral{..} -> [(CtxRuleRAtom rl' i, atomVal rhsAtom)]\n+                                RHSCondition{..} -> [(CtxRuleRCond rl' i, rhsExpr)]\n+                                RHSFlatMap{..} -> [(CtxRuleRFlatMap rl' i, rhsMapExpr)]\n+                                RHSAggregate{..} -> [ (CtxRuleRGroupBy rl' i, rhsGroupBy)\n+                                                    , (CtxRuleRAggregate rl' i, rhsAggExpr)]\n+                                RHSInspect{..} -> [(CtxRuleRInspect rl' i, rhsInspectExpr)])\n+                         $ ruleRHS rl'\n+    let lhs_es' = mapIdx (\\lhs i -> (CtxRuleL rl' i, atomVal lhs)) $ ruleLHS rl'\n+    exprsPostCheck d (rhs_es'++lhs_es')\n+    return rl'\n \n atomValidate :: (MonadError String me) => DatalogProgram -> ECtx -> Atom -> me ()\n atomValidate d ctx atom = do\n     _ <- checkRelation (pos atom) d $ atomRelation atom\n-    exprValidate d [] ctx $ atomVal atom\n     -- variable cannot be declared and used in the same atom\n     uniqNames (Just d) (\\v -> \"Variable \" ++ show v ++ \" is both declared and used inside relational atom \" ++ show atom)\n         $ exprVarDecls d ctx $ atomVal atom\n \n+-- Validate an RHS term of a rule.  Once all RHS and LHS terms have been\n+-- validate, it is safe to call 'ruleValidateExpressions'.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fed5a9f6f42e8a4563c8f2339cf1d4c024d92d9a"}, "originalPosition": 203}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwODc5MTk2OnYy", "diffSide": "RIGHT", "path": "src/Language/DifferentialDatalog/Validate.hs", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMjo1MDoyOVrOGtpfCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMjo1MDoyOVrOGtpfCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDUxODc5Mw==", "bodyText": "\"called\"?", "url": "https://github.com/vmware/differential-datalog/pull/695#discussion_r450518793", "createdAt": "2020-07-06T22:50:29Z", "author": {"login": "mbudiu-vmw"}, "path": "src/Language/DifferentialDatalog/Validate.hs", "diffHunk": "@@ -473,11 +489,36 @@ depGraphValidate d@DatalogProgram{..} = do\n                         _ -> return ())\n           $ filter ((> 1) . length) sccs\n \n-exprValidate :: (MonadError String me) => DatalogProgram -> [String] -> ECtx -> Expr -> me ()\n-exprValidate d tvars ctx e = {-trace (\"exprValidate \" ++ show e ++ \" in \\n\" ++ show ctx) $ -} do\n-    exprTraverseCtxM (exprValidate1 d tvars) ctx e\n-    exprTraverseTypeME d (exprValidate2 d) ctx e\n-    exprTraverseCtxM (exprCheckMatchPatterns d) ctx e\n+-- Validate and perform type inference on a single expression.\n+exprValidate :: (MonadError String me) => DatalogProgram -> [String] -> ECtx -> Expr -> me Expr\n+exprValidate d tvars ctx e = do\n+    e' <- head <$> exprsTypeCheck d tvars [(ctx, e)]\n+    exprsPostCheck d [(ctx, e')]\n+    return e'\n+\n+-- Multiple expressions (e.g., expressions in a rule) must be validated in two\n+-- phases.\n+-- Phase 1: 'exprsTypeCheck': check that the expressions are well-formed\n+-- (all identifiers point to existng functions and variables) and perform type\n+-- inference.\n+-- Phase 2: 'exprsPostCheck': additional checks that can only be safely\n+-- performed after type inference.  Before calling this function, the called", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fed5a9f6f42e8a4563c8f2339cf1d4c024d92d9a"}, "originalPosition": 293}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwODgwMjI5OnYy", "diffSide": "RIGHT", "path": "src/Language/DifferentialDatalog/Unification.hs", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMjo1NTo1M1rOGtplUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwMTowMToxMFrOGtrrlg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDUyMDQwMQ==", "bodyText": "Are you checking that tv does not occur in te?", "url": "https://github.com/vmware/differential-datalog/pull/695#discussion_r450520401", "createdAt": "2020-07-06T22:55:53Z", "author": {"login": "mbudiu-vmw"}, "path": "src/Language/DifferentialDatalog/Unification.hs", "diffHunk": "@@ -0,0 +1,816 @@\n+{-\n+Copyright (c) 2020 VMware, Inc.\n+SPDX-License-Identifier: MIT\n+\n+Permission is hereby granted, free of charge, to any person obtaining a copy\n+of this software and associated documentation files (the \"Software\"), to deal\n+in the Software without restriction, including without limitation the rights\n+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+copies of the Software, and to permit persons to whom the Software is\n+furnished to do so, subject to the following conditions:\n+\n+The above copyright notice and this permission notice shall be included in all\n+copies or substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+SOFTWARE.\n+-}\n+\n+{-|\n+Unification-based type inference algorithm.\n+-}\n+\n+{-# LANGUAGE FlexibleContexts, RecordWildCards, TupleSections, ImplicitParams, RankNTypes #-}\n+\n+module Language.DifferentialDatalog.Unification(\n+    Typing,\n+    DDExpr(..),\n+    PredicateExplanation(..),\n+    ExplanationKind(..),\n+    Constraint(..),\n+    constraintsShow,\n+    WidthVar(..),\n+    IExpr(..),\n+    TypeVar(..),\n+    tvObject,\n+    TExpr(..),\n+    teToType,\n+    teDeref,\n+    Predicate(..),\n+    solve\n+)\n+where\n+\n+import Control.Monad.Except\n+import Control.Monad.State\n+import Data.List\n+import qualified Data.Map as M\n+import Data.Maybe\n+--import Debug.Trace\n+\n+import Language.DifferentialDatalog.Attribute\n+import Language.DifferentialDatalog.Error\n+import Language.DifferentialDatalog.Name\n+import Language.DifferentialDatalog.Pos\n+import Language.DifferentialDatalog.Syntax\n+import Language.DifferentialDatalog.Var\n+\n+type Typing = M.Map TypeVar Type\n+\n+-- Uniquely identifies an expression in a DDlog program.\n+data DDExpr = DDExpr {ddexprCtx::ECtx, ddexprExpr::Expr} deriving (Eq, Ord)\n+\n+instance Show DDExpr where\n+    show e = show $ ddexprExpr e\n+\n+instance WithPos DDExpr where\n+    pos e = pos $ ddexprExpr e\n+    atPos _ _ = error \"DDExpr.atPos: not impleemnted\"\n+\n+-- A type constraint is an atomic predicate, that requires two type expressions\n+-- to be equivalent, a width constraint, that requires two integer expressions\n+-- representing bit widths to be equivalent, or a lazy constraint.  We use a\n+-- unification-based solver to solve type constraints, which does not handle\n+-- arbitrary Boolean combinations of constraints, hence this restricted structure.\n+data Constraint = CPredicate {cPred::Predicate}\n+                  -- Width constraint of the form 'expr1 == expr2', where\n+                  -- 'expr1' and 'expr2'.\n+                | CWidthEq {cLHS::IExpr, cRHS::IExpr, cWidthExplanation::WidthExplanation}\n+                  -- A lazy constraint gets activated once the type of a\n+                  -- specified \"trigger\" expression ('cExpr') is fully resolved.  It is\n+                  -- used to represent disjunctive constraints, where the set\n+                  -- of predicates depends on the type of the trigger.  E.g.,\n+                  -- the type of 'x.f' depends on the type of 'x', e.g., '(x:\n+                  -- Struct1 && x.f is bool || x:Struct2 && x.f: string ||\n+                  -- ...)'.  This is not easy to do with a unification solver,\n+                  -- so we let the constraint lay dormant until the solver can\n+                  -- rule out all but one disjunct.\n+                  -- 'cExpr' - trigger expression; does not change after the\n+                  -- constraint is created.\n+                  -- 'cType' - type expression that represents our current\n+                  -- knowledge of the type of 'cExpr'.  Gets refined as the\n+                  -- solver performs substitutions.\n+                  -- 'cExpand' - once 'cType' is resolved into a constant type\n+                  -- expression, this function is invoked to generate a set of\n+                  -- constraints that this lazy constraint resolves into.\n+                  -- 'cDefault' - optional default set of constraints to be used\n+                  -- if the program does not contain enough information to resolve\n+                  -- the type of the trigger expression, e.g., an integer literal\n+                  -- can be interpreted as 'u64' by default.\n+                  -- 'cExplanation' - description of the constraint for\n+                  -- debugging purposes.\n+                  --\n+                  -- TODO: currently, a lazy constraint is only triggered once\n+                  -- the type has been completely resolved, at which point it is\n+                  -- required to produce a set of constraints of fail.  Some use\n+                  -- cases may benefit from a more subtle design where a partial\n+                  -- expansion of the trigger expression is sufficient to\n+                  -- trigger the constraint.  To support this we will need to\n+                  -- change the 'cExpand' signature to return\n+                  -- 'Option<[Constraint]>', with 'Nothing' meaning that 'cType'\n+                  -- is not yet sufficiently concretized to expand the\n+                  -- constraint.\n+                | CLazy { cType::TExpr\n+                        , cExpand::(forall me . (MonadError String me) => TExpr -> me [Constraint])\n+                        , cDefault::Maybe [Constraint]\n+                        , cExpr::DDExpr\n+                        , cExplanation::String\n+                        }\n+\n+constraintShow :: Constraint -> TVarShortcuts String\n+constraintShow (CPredicate p)         = predShow p\n+constraintShow (CWidthEq ie1 ie2 _)   = return $ show ie1 ++ \" = \" ++ show ie2\n+constraintShow (CLazy te _ _ _ expl)  = return $ expl ++ \" [partial type: \" ++ show te ++ \"]\"\n+\n+constraintsShow :: [Constraint] -> String\n+constraintsShow cs = evalState (\n+    do cs' <- mapM constraintShow cs\n+       return $ intercalate \"\\n\" cs' ) M.empty\n+\n+instance Show Constraint where\n+    show c = evalState (constraintShow c) M.empty\n+\n+-- A constraint is in the solved form if it has the following shape:\n+-- 'tv = te' or 'te = tv',\n+-- where 'tv' is a type variable and 'te' is an arbitrary type expression.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fed5a9f6f42e8a4563c8f2339cf1d4c024d92d9a"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU1NDc3NA==", "bodyText": "Not explicitly.  I think if this happens, it will generate a type error farther down the line.", "url": "https://github.com/vmware/differential-datalog/pull/695#discussion_r450554774", "createdAt": "2020-07-07T01:01:10Z", "author": {"login": "ryzhyk"}, "path": "src/Language/DifferentialDatalog/Unification.hs", "diffHunk": "@@ -0,0 +1,816 @@\n+{-\n+Copyright (c) 2020 VMware, Inc.\n+SPDX-License-Identifier: MIT\n+\n+Permission is hereby granted, free of charge, to any person obtaining a copy\n+of this software and associated documentation files (the \"Software\"), to deal\n+in the Software without restriction, including without limitation the rights\n+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+copies of the Software, and to permit persons to whom the Software is\n+furnished to do so, subject to the following conditions:\n+\n+The above copyright notice and this permission notice shall be included in all\n+copies or substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+SOFTWARE.\n+-}\n+\n+{-|\n+Unification-based type inference algorithm.\n+-}\n+\n+{-# LANGUAGE FlexibleContexts, RecordWildCards, TupleSections, ImplicitParams, RankNTypes #-}\n+\n+module Language.DifferentialDatalog.Unification(\n+    Typing,\n+    DDExpr(..),\n+    PredicateExplanation(..),\n+    ExplanationKind(..),\n+    Constraint(..),\n+    constraintsShow,\n+    WidthVar(..),\n+    IExpr(..),\n+    TypeVar(..),\n+    tvObject,\n+    TExpr(..),\n+    teToType,\n+    teDeref,\n+    Predicate(..),\n+    solve\n+)\n+where\n+\n+import Control.Monad.Except\n+import Control.Monad.State\n+import Data.List\n+import qualified Data.Map as M\n+import Data.Maybe\n+--import Debug.Trace\n+\n+import Language.DifferentialDatalog.Attribute\n+import Language.DifferentialDatalog.Error\n+import Language.DifferentialDatalog.Name\n+import Language.DifferentialDatalog.Pos\n+import Language.DifferentialDatalog.Syntax\n+import Language.DifferentialDatalog.Var\n+\n+type Typing = M.Map TypeVar Type\n+\n+-- Uniquely identifies an expression in a DDlog program.\n+data DDExpr = DDExpr {ddexprCtx::ECtx, ddexprExpr::Expr} deriving (Eq, Ord)\n+\n+instance Show DDExpr where\n+    show e = show $ ddexprExpr e\n+\n+instance WithPos DDExpr where\n+    pos e = pos $ ddexprExpr e\n+    atPos _ _ = error \"DDExpr.atPos: not impleemnted\"\n+\n+-- A type constraint is an atomic predicate, that requires two type expressions\n+-- to be equivalent, a width constraint, that requires two integer expressions\n+-- representing bit widths to be equivalent, or a lazy constraint.  We use a\n+-- unification-based solver to solve type constraints, which does not handle\n+-- arbitrary Boolean combinations of constraints, hence this restricted structure.\n+data Constraint = CPredicate {cPred::Predicate}\n+                  -- Width constraint of the form 'expr1 == expr2', where\n+                  -- 'expr1' and 'expr2'.\n+                | CWidthEq {cLHS::IExpr, cRHS::IExpr, cWidthExplanation::WidthExplanation}\n+                  -- A lazy constraint gets activated once the type of a\n+                  -- specified \"trigger\" expression ('cExpr') is fully resolved.  It is\n+                  -- used to represent disjunctive constraints, where the set\n+                  -- of predicates depends on the type of the trigger.  E.g.,\n+                  -- the type of 'x.f' depends on the type of 'x', e.g., '(x:\n+                  -- Struct1 && x.f is bool || x:Struct2 && x.f: string ||\n+                  -- ...)'.  This is not easy to do with a unification solver,\n+                  -- so we let the constraint lay dormant until the solver can\n+                  -- rule out all but one disjunct.\n+                  -- 'cExpr' - trigger expression; does not change after the\n+                  -- constraint is created.\n+                  -- 'cType' - type expression that represents our current\n+                  -- knowledge of the type of 'cExpr'.  Gets refined as the\n+                  -- solver performs substitutions.\n+                  -- 'cExpand' - once 'cType' is resolved into a constant type\n+                  -- expression, this function is invoked to generate a set of\n+                  -- constraints that this lazy constraint resolves into.\n+                  -- 'cDefault' - optional default set of constraints to be used\n+                  -- if the program does not contain enough information to resolve\n+                  -- the type of the trigger expression, e.g., an integer literal\n+                  -- can be interpreted as 'u64' by default.\n+                  -- 'cExplanation' - description of the constraint for\n+                  -- debugging purposes.\n+                  --\n+                  -- TODO: currently, a lazy constraint is only triggered once\n+                  -- the type has been completely resolved, at which point it is\n+                  -- required to produce a set of constraints of fail.  Some use\n+                  -- cases may benefit from a more subtle design where a partial\n+                  -- expansion of the trigger expression is sufficient to\n+                  -- trigger the constraint.  To support this we will need to\n+                  -- change the 'cExpand' signature to return\n+                  -- 'Option<[Constraint]>', with 'Nothing' meaning that 'cType'\n+                  -- is not yet sufficiently concretized to expand the\n+                  -- constraint.\n+                | CLazy { cType::TExpr\n+                        , cExpand::(forall me . (MonadError String me) => TExpr -> me [Constraint])\n+                        , cDefault::Maybe [Constraint]\n+                        , cExpr::DDExpr\n+                        , cExplanation::String\n+                        }\n+\n+constraintShow :: Constraint -> TVarShortcuts String\n+constraintShow (CPredicate p)         = predShow p\n+constraintShow (CWidthEq ie1 ie2 _)   = return $ show ie1 ++ \" = \" ++ show ie2\n+constraintShow (CLazy te _ _ _ expl)  = return $ expl ++ \" [partial type: \" ++ show te ++ \"]\"\n+\n+constraintsShow :: [Constraint] -> String\n+constraintsShow cs = evalState (\n+    do cs' <- mapM constraintShow cs\n+       return $ intercalate \"\\n\" cs' ) M.empty\n+\n+instance Show Constraint where\n+    show c = evalState (constraintShow c) M.empty\n+\n+-- A constraint is in the solved form if it has the following shape:\n+-- 'tv = te' or 'te = tv',\n+-- where 'tv' is a type variable and 'te' is an arbitrary type expression.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDUyMDQwMQ=="}, "originalCommit": {"oid": "fed5a9f6f42e8a4563c8f2339cf1d4c024d92d9a"}, "originalPosition": 140}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwODgzMjM1OnYy", "diffSide": "RIGHT", "path": "src/Language/DifferentialDatalog/Unification.hs", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMzoxMToxMVrOGtp3PQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwMTowMjo1MVrOGtrtXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDUyNDk4OQ==", "bodyText": "I guess you do.", "url": "https://github.com/vmware/differential-datalog/pull/695#discussion_r450524989", "createdAt": "2020-07-06T23:11:11Z", "author": {"login": "mbudiu-vmw"}, "path": "src/Language/DifferentialDatalog/Unification.hs", "diffHunk": "@@ -0,0 +1,816 @@\n+{-\n+Copyright (c) 2020 VMware, Inc.\n+SPDX-License-Identifier: MIT\n+\n+Permission is hereby granted, free of charge, to any person obtaining a copy\n+of this software and associated documentation files (the \"Software\"), to deal\n+in the Software without restriction, including without limitation the rights\n+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+copies of the Software, and to permit persons to whom the Software is\n+furnished to do so, subject to the following conditions:\n+\n+The above copyright notice and this permission notice shall be included in all\n+copies or substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+SOFTWARE.\n+-}\n+\n+{-|\n+Unification-based type inference algorithm.\n+-}\n+\n+{-# LANGUAGE FlexibleContexts, RecordWildCards, TupleSections, ImplicitParams, RankNTypes #-}\n+\n+module Language.DifferentialDatalog.Unification(\n+    Typing,\n+    DDExpr(..),\n+    PredicateExplanation(..),\n+    ExplanationKind(..),\n+    Constraint(..),\n+    constraintsShow,\n+    WidthVar(..),\n+    IExpr(..),\n+    TypeVar(..),\n+    tvObject,\n+    TExpr(..),\n+    teToType,\n+    teDeref,\n+    Predicate(..),\n+    solve\n+)\n+where\n+\n+import Control.Monad.Except\n+import Control.Monad.State\n+import Data.List\n+import qualified Data.Map as M\n+import Data.Maybe\n+--import Debug.Trace\n+\n+import Language.DifferentialDatalog.Attribute\n+import Language.DifferentialDatalog.Error\n+import Language.DifferentialDatalog.Name\n+import Language.DifferentialDatalog.Pos\n+import Language.DifferentialDatalog.Syntax\n+import Language.DifferentialDatalog.Var\n+\n+type Typing = M.Map TypeVar Type\n+\n+-- Uniquely identifies an expression in a DDlog program.\n+data DDExpr = DDExpr {ddexprCtx::ECtx, ddexprExpr::Expr} deriving (Eq, Ord)\n+\n+instance Show DDExpr where\n+    show e = show $ ddexprExpr e\n+\n+instance WithPos DDExpr where\n+    pos e = pos $ ddexprExpr e\n+    atPos _ _ = error \"DDExpr.atPos: not impleemnted\"\n+\n+-- A type constraint is an atomic predicate, that requires two type expressions\n+-- to be equivalent, a width constraint, that requires two integer expressions\n+-- representing bit widths to be equivalent, or a lazy constraint.  We use a\n+-- unification-based solver to solve type constraints, which does not handle\n+-- arbitrary Boolean combinations of constraints, hence this restricted structure.\n+data Constraint = CPredicate {cPred::Predicate}\n+                  -- Width constraint of the form 'expr1 == expr2', where\n+                  -- 'expr1' and 'expr2'.\n+                | CWidthEq {cLHS::IExpr, cRHS::IExpr, cWidthExplanation::WidthExplanation}\n+                  -- A lazy constraint gets activated once the type of a\n+                  -- specified \"trigger\" expression ('cExpr') is fully resolved.  It is\n+                  -- used to represent disjunctive constraints, where the set\n+                  -- of predicates depends on the type of the trigger.  E.g.,\n+                  -- the type of 'x.f' depends on the type of 'x', e.g., '(x:\n+                  -- Struct1 && x.f is bool || x:Struct2 && x.f: string ||\n+                  -- ...)'.  This is not easy to do with a unification solver,\n+                  -- so we let the constraint lay dormant until the solver can\n+                  -- rule out all but one disjunct.\n+                  -- 'cExpr' - trigger expression; does not change after the\n+                  -- constraint is created.\n+                  -- 'cType' - type expression that represents our current\n+                  -- knowledge of the type of 'cExpr'.  Gets refined as the\n+                  -- solver performs substitutions.\n+                  -- 'cExpand' - once 'cType' is resolved into a constant type\n+                  -- expression, this function is invoked to generate a set of\n+                  -- constraints that this lazy constraint resolves into.\n+                  -- 'cDefault' - optional default set of constraints to be used\n+                  -- if the program does not contain enough information to resolve\n+                  -- the type of the trigger expression, e.g., an integer literal\n+                  -- can be interpreted as 'u64' by default.\n+                  -- 'cExplanation' - description of the constraint for\n+                  -- debugging purposes.\n+                  --\n+                  -- TODO: currently, a lazy constraint is only triggered once\n+                  -- the type has been completely resolved, at which point it is\n+                  -- required to produce a set of constraints of fail.  Some use\n+                  -- cases may benefit from a more subtle design where a partial\n+                  -- expansion of the trigger expression is sufficient to\n+                  -- trigger the constraint.  To support this we will need to\n+                  -- change the 'cExpand' signature to return\n+                  -- 'Option<[Constraint]>', with 'Nothing' meaning that 'cType'\n+                  -- is not yet sufficiently concretized to expand the\n+                  -- constraint.\n+                | CLazy { cType::TExpr\n+                        , cExpand::(forall me . (MonadError String me) => TExpr -> me [Constraint])\n+                        , cDefault::Maybe [Constraint]\n+                        , cExpr::DDExpr\n+                        , cExplanation::String\n+                        }\n+\n+constraintShow :: Constraint -> TVarShortcuts String\n+constraintShow (CPredicate p)         = predShow p\n+constraintShow (CWidthEq ie1 ie2 _)   = return $ show ie1 ++ \" = \" ++ show ie2\n+constraintShow (CLazy te _ _ _ expl)  = return $ expl ++ \" [partial type: \" ++ show te ++ \"]\"\n+\n+constraintsShow :: [Constraint] -> String\n+constraintsShow cs = evalState (\n+    do cs' <- mapM constraintShow cs\n+       return $ intercalate \"\\n\" cs' ) M.empty\n+\n+instance Show Constraint where\n+    show c = evalState (constraintShow c) M.empty\n+\n+-- A constraint is in the solved form if it has the following shape:\n+-- 'tv = te' or 'te = tv',\n+-- where 'tv' is a type variable and 'te' is an arbitrary type expression.\n+constraintIsSolved :: Constraint -> Bool\n+constraintIsSolved (CPredicate (PEq TETVar{} _ _)) = True\n+constraintIsSolved (CPredicate (PEq _ TETVar{} _)) = True\n+constraintIsSolved (CWidthEq IVar{} _ _)           = True\n+constraintIsSolved (CWidthEq _ IVar{} _)           = True\n+constraintIsSolved _                               = False\n+\n+-- Normalization rotates a solved constraint so that the type variable\n+-- is on the left: 'te = tv' is transformed into 'tv = te'.\n+constraintNormalize :: Constraint -> Constraint\n+constraintNormalize (CPredicate (PEq te tv@TETVar{} e)) = CPredicate $ PEq tv te e\n+constraintNormalize (CWidthEq ie iv@IVar{} e)           = CWidthEq iv ie e\n+constraintNormalize c                                   = c\n+\n+constraintIsLazy :: Constraint -> Bool\n+constraintIsLazy CLazy{} = True\n+constraintIsLazy _       = False\n+\n+constraintIsPredicate :: Constraint -> Bool\n+constraintIsPredicate CPredicate{} = True\n+constraintIsPredicate _            = False\n+\n+-- Generate a width constraint in canonical form: all constants are on one side\n+-- of the constraint, variables that appear on both sides are cancelled out.\n+cWidthEq :: IExpr -> IExpr -> WidthExplanation -> [Constraint]\n+cWidthEq ie1 ie2 e = if ie1' == ie2' then [] else [CWidthEq ie1' ie2' e]\n+    where\n+    ievars1 = ieVars ie1\n+    ievars2 = ieVars ie2\n+    ieconst1 = ieConst ie1\n+    ieconst2 = ieConst ie2\n+    -- Group constants in one side of the equation.\n+    cnst = ieconst2 - ieconst1\n+    -- Cancel out variables that appear on both sides of the equation.\n+    ie1' = ieSum $ (map IVar $ ievars1 \\\\ ievars2) ++ if cnst < 0 then [IConst (-cnst)] else []\n+    ie2' = ieSum $ (map IVar $ ievars2 \\\\ ievars1) ++ if cnst > 0 then [IConst cnst] else []\n+\n+cwidthReportConflict :: (?d::DatalogProgram, MonadError String me) => Constraint -> me a\n+cwidthReportConflict c@(CWidthEq _ _ e) = err ?d (pos e) $ \"Unsatisfiable constraint '\" ++ show c ++ \"' in\\n\" ++\n+                                                           evalState (explanationShow e) M.empty\n+cwidthReportConflict c = error $ \"cwidthReportConflict \" ++ show c\n+\n+removeConstraint :: Int -> SolverState -> SolverState\n+removeConstraint idx st = st{ solverConstraints = take idx cs ++ drop (idx+1) cs }\n+    where cs = solverConstraints st\n+\n+addConstraints :: [Constraint] -> SolverState -> SolverState\n+addConstraints new_cs st = st{ solverConstraints = new_cs ++ cs}\n+    where cs = solverConstraints st\n+\n+-- Integer expressions represent widths of bit and signed types.\n+data IExpr = -- Integer constant.\n+             IConst Int\n+             -- Integer variable.\n+           | IVar WidthVar\n+             -- Sum of two widths.\n+           | IPlus IExpr IExpr\n+           deriving (Eq, Ord)\n+\n+instance Show IExpr where\n+    show (IConst i)         = show i\n+    show (IVar v)           = show v\n+    show (IPlus ie1 ie2)    = show ie1 ++ \" + \" ++ show ie2\n+\n+-- Integer expression is a constant (i.e., does not contain any variables).\n+ieIsConstant :: IExpr -> Bool\n+ieIsConstant IConst{}      = True\n+ieIsConstant IVar{}        = False\n+ieIsConstant (IPlus e1 e2) = ieIsConstant e1 && ieIsConstant e2\n+\n+-- List variables that occur in a width expression.\n+-- Each variable occurs in the result as many times as it occurs in the\n+-- expression.\n+ieVars :: IExpr -> [WidthVar]\n+ieVars IConst{}         = []\n+ieVars (IVar v)         = [v]\n+ieVars (IPlus ie1 ie2)  = ieVars ie1 ++ ieVars ie2\n+\n+-- Sum-up all integer constants in a width expression.\n+ieConst :: IExpr -> Int\n+ieConst (IConst w)      = w\n+ieConst IVar{}          = 0\n+ieConst (IPlus ie1 ie2) = ieConst ie1 + ieConst ie2\n+\n+ieSum :: [IExpr] -> IExpr\n+ieSum es = ieNormalize $ ieSum' es\n+\n+ieSum' :: [IExpr] -> IExpr\n+ieSum' []        = IConst 0\n+ieSum' [ie]      = ie\n+ieSum' (ie:ies)  = IPlus ie $ ieSum' ies\n+\n+ieNormalize :: IExpr -> IExpr\n+ieNormalize ie = ieSum' $ map IVar vs ++ cs\n+    where\n+    vs = ieVars ie\n+    c = ieConst ie\n+    cs = if null vs || c /= 0\n+         then [IConst c]\n+         else []\n+\n+-- Integer variables used in constraint encoding.\n+data WidthVar = -- Integer variable equal to the width of a DDExpr.\n+                WidthOfExpr DDExpr\n+                deriving (Eq, Ord)\n+\n+instance Show WidthVar where\n+    show (WidthOfExpr e) = \"width_of(\" ++ show e ++ \")\"\n+\n+-- Type variables used in constraint encoding.\n+-- The goal of type inference is to find a satisfying assignment to all\n+-- type and integer variables.\n+data TypeVar = -- Type of a DDlog expression.\n+               TVarTypeOfExpr {tvarId::Int, tvarExpr::DDExpr}\n+               -- Type of a DDlog variable.\n+             | TVarTypeOfVar {tvarId::Int, tvarVar::Var}\n+               -- We sometimes need to introduce extra type variables to model\n+               -- unknown type arguments of function calls.  We could use\n+               -- arbitrary auto-generated names for them, but to avoid a state\n+               -- monad and enable meaningful error message, we use the\n+               -- expression where the type argument occurs and its name\n+               -- to uniquely identify the variable.\n+             | TVarAux {tvarId::Int, tvarExpr::DDExpr, tvarName::String}\n+\n+instance Eq TypeVar where\n+    (==) tv1 tv2 = tvarId tv1 == tvarId tv2\n+\n+instance Ord TypeVar where\n+    compare tv1 tv2 = compare (tvarId tv1) (tvarId tv2)\n+\n+instance WithPos TypeVar where\n+    pos (TVarTypeOfExpr _ de) = pos de\n+    pos (TVarTypeOfVar _ v)   = pos v\n+    pos (TVarAux _ de _)      = pos de\n+    atPos _ _ = error \"TypeVar.atPos: not implemented\"\n+\n+-- Returns a string describing the object whose type this variable refers to.\n+tvObject :: TypeVar -> String\n+tvObject (TVarTypeOfExpr _ de) = \"expression '\"   ++ show de ++ \"'\" -- TODO: abbreviate long expressions\n+tvObject (TVarTypeOfVar _ v)   = \"variable '\"     ++ name v ++ \"'\"\n+tvObject (TVarAux _ _ v)       = \"type argument \" ++ name v -- TODO: type argument v of function/type ...\n+\n+-- State monad that assigns symbolic names 'a, 'b, ... to type variables in one\n+-- or more type expressions.\n+--\n+-- When pretty printing constraints, predicates or type expressions we would\n+-- like to replace type variables with short symbolic shortcuts, which should be\n+-- consistent, i.e., the same variable is alway represent by the same symbolic\n+-- name.  We achieve this by printing all related type expressions, e.g., all\n+-- type expressions involved in a type resolution conflict within this monad.\n+type TVarShortcuts a = State (M.Map TypeVar String) a\n+\n+-- Return existing shortcut for 'tv' or generate a new one.\n+tvName :: TypeVar -> TVarShortcuts String\n+tvName tv = do\n+    -- \"a\", \"b\", .. , \"z\", \"aa\", \"ab\", ....\n+    let allStrings = [ s ++ [c] | s <- \"\": allStrings, c <- ['a'..'z'] ]\n+    names <- get\n+    case M.lookup tv names of\n+         Just n  -> return n\n+         Nothing -> do let n = allStrings !! M.size names\n+                       put $ M.insert tv n names\n+                       return n\n+\n+-- Type expression: an expression that returns a value of 'Type' sort.\n+data TExpr = TEBool\n+           | TEString\n+           | TEBigInt\n+           | TEBit IExpr\n+           | TESigned IExpr\n+           | TEFloat\n+           | TEDouble\n+             -- Tuple type whose size and field types may be only partially known.\n+           | TETuple [TExpr]\n+             -- User-defined type.\n+           | TEUser String [TExpr]\n+             -- Extern type.\n+           | TEExtern String [TExpr]\n+             -- In a function context only, a type argument of the function (e.g., 'A).\n+           | TETArg String\n+             -- Type variable.\n+           | TETVar TypeVar\n+           deriving (Eq, Ord)\n+\n+teShow :: TExpr -> TVarShortcuts String\n+teShow TEBool                 = return \"bool\"\n+teShow TEString               = return \"string\"\n+teShow TEBigInt               = return \"bigint\"\n+teShow (TEBit w)              = return $ \"bit<\" ++ show w ++ \">\"\n+teShow (TESigned w)           = return $ \"signed<\" ++ show w ++ \">\"\n+teShow TEFloat                = return \"float\"\n+teShow TEDouble               = return \"double\"\n+teShow (TETuple as)           = ((++ \")\") . (\"(\" ++) . intercalate \",\") <$> mapM teShow as\n+teShow (TEUser n as)          = ((++ \">\") . ((n ++ \"<\") ++) . intercalate \",\") <$> mapM teShow as\n+teShow (TEExtern n as)        = ((++ \">\") . ((n ++ \"<\") ++) . intercalate \",\") <$> mapM teShow as\n+teShow (TETArg n)             = return $ \"'\" ++ n\n+teShow (TETVar tv)            = (\"'\" ++) <$> tvName tv\n+\n+instance Show TExpr where\n+    show te = evalState (teShow te) M.empty\n+\n+-- Type expression is a constant (i.e., does not contain any type variables).\n+teIsConstant :: TExpr -> Bool\n+teIsConstant TEBool             = True\n+teIsConstant TEString           = True\n+teIsConstant TEBigInt           = True\n+teIsConstant (TEBit w)          = ieIsConstant w\n+teIsConstant (TESigned w)       = ieIsConstant w\n+teIsConstant TEFloat            = True\n+teIsConstant TEDouble           = True\n+teIsConstant (TETuple as)       = all teIsConstant as\n+teIsConstant (TEUser _ as)      = all teIsConstant as\n+teIsConstant (TEExtern _ as)    = all teIsConstant as\n+teIsConstant TETArg{}           = True\n+teIsConstant TETVar{}           = False\n+\n+-- All type variables in a type expression.\n+teTypeVars :: TExpr -> [TypeVar]\n+teTypeVars TEBool             = []\n+teTypeVars TEString           = []\n+teTypeVars TEBigInt           = []\n+teTypeVars TEBit{}            = []\n+teTypeVars TESigned{}         = []\n+teTypeVars TEFloat            = []\n+teTypeVars TEDouble           = []\n+teTypeVars (TETuple as)       = nub $ concatMap teTypeVars as\n+teTypeVars (TEUser _ as)      = nub $ concatMap teTypeVars as\n+teTypeVars (TEExtern _ as)    = nub $ concatMap teTypeVars as\n+teTypeVars TETArg{}           = []\n+teTypeVars (TETVar v)         = [v]\n+\n+-- Convert constant type expression to a DDlog type.\n+teToType :: TExpr -> Type\n+teToType TEBool                 = tBool\n+teToType TEString               = tString\n+teToType TEBigInt               = tInt\n+teToType (TEBit (IConst w))     = tBit w\n+teToType (TESigned (IConst w))  = tSigned w\n+teToType TEFloat                = tFloat\n+teToType TEDouble               = tDouble\n+teToType (TETuple as)           = tTuple $ map teToType as\n+teToType (TEUser n as)          = tUser n $ map teToType as\n+teToType (TEExtern n as)        = tOpaque n $ map teToType as\n+teToType (TETArg n)             = tVar n\n+teToType te                     = error $ \"Unification.teToType: non-constant type expression \" ++ show te\n+\n+-- Unwrap all layers of shared references.\n+teDeref :: (?d::DatalogProgram) => TExpr -> TExpr\n+teDeref (TEExtern n [t]) | elem n sref_types = teDeref t\n+    where\n+    sref_types = map name\n+                 $ filter (tdefGetSharedRefAttr ?d)\n+                 $ M.elems $ progTypedefs ?d\n+teDeref t = t\n+\n+-- Check if type expression is a constant and if not, return an explanation.\n+-- 'obj' is the object whose type 'te' describes.\n+teCheckConstant :: (?d::DatalogProgram, MonadError String me) => TypeVar -> TExpr -> me ()\n+teCheckConstant tvar te | teIsConstant te = return ()\n+                        | not $ null tvars =\n+    -- 'te' depends on an unresolved type variable 'tv'.  So instead of\n+    -- complaining that the type of 'te' is unknown, we try to be more specific\n+    -- and complain that the type of the entity 'tv' represents is unknown.\n+    err ?d (pos tv) $ \"Cannot infer type of \" ++ tvObject tv\n+                       | otherwise =\n+    -- 'te' is not a constant, but it does not depend on any type variables,\n+    -- hence it must have parts whose width is not yet resolved into a constant.\n+    err ?d (pos tvar) $ \"Unable to infer complete type of \" ++ tvObject tvar ++ \". Partially inferred type: \" ++ show te\n+    where tvars = teTypeVars te\n+          tv : _ = tvars\n+\n+-- Type congruence, e.g., '|e| = BigInt'.\n+data Predicate = PEq {\n+    -- Left-hand side of the equation.\n+    predLHS         ::  TExpr,\n+    -- Right-hand side.\n+    predRHS         ::  TExpr,\n+    -- Explanation of the predicate used in generating an error message\n+    -- when the predicate becomes a contradiction.\n+    predExplanation ::  PredicateExplanation\n+}\n+\n+instance Eq Predicate where\n+    (==) (PEq l1 r1 _) (PEq l2 r2 _) = (l1, r1) == (l2, r2)\n+\n+instance Ord Predicate where\n+    compare (PEq l1 r1 _) (PEq l2 r2 _) = compare (l1, r1) (l2, r2)\n+\n+predShow :: Predicate -> TVarShortcuts String\n+predShow (PEq te1 te2 _) = do\n+    s1 <- teShow te1\n+    s2 <- teShow te2\n+    return $ s1 ++ \" = \" ++ s2\n+\n+instance Show Predicate where\n+    show p = evalState (predShow p) M.empty\n+\n+-- Explanation of a predicate contains metadata used to generate meaningful error\n+-- messages if the predicate becomes a contradiction.\n+--\n+-- When a predicate 'P1: t1 = t2' is initially created, 't1' is typically a type\n+-- variable that represents the type of a program variable or expression.\n+-- The meaning of the predicate is that the expected type of this variable or\n+-- expression is 't2'.  Thus the predicate's explanation is 'ExplanationTVar t1'.\n+--\n+-- The predicate can undergo two types of transformations: substitution and\n+-- unification.  After a substitution, the resulting predicate keeps its original\n+-- explanation, e.g., substitutions 't1 <- Struct1<a>' and 't2 <- Struct1<b>'\n+-- yield predicate 'P2: Struct1<a> = Struct1<b>' whose explanation is still\n+-- 'ExplanationTVar t1'.  After unification, we get a new predicate\n+-- 'P3: a=b' whose explanation it the \"parent\" predicate it was derived from:\n+-- 'ExplanationParent P2'.  Consider further substitutions 'a <- bool',\n+-- 'b <- (bool, string)', which yield an unsatisfiable predicate:\n+-- 'P3: bool = (bool, string)', whose explanation is still 'P2', except that we\n+-- also apply the substitution to the explanation, yielding\n+-- 'P2_2: Struct1<bool> = Struct1<(bool, string)>'.\n+--\n+-- This explanation carries enough information to generate the following error\n+-- messageL\n+--\n+-- ~~~~~~~~~\n+-- Type mistmatch:\n+-- expected type: (bool, string)\n+-- ectual type: bool\n+--\n+-- in\n+--\n+-- expected type: Struct1<(bool, string)>\n+-- actual type: Struct1<bool>\n+--\n+-- in\n+--\n+-- <expression or variable that 't1' refers to>.\n+-- ~~~~~~~~~\n+data PredicateExplanation =\n+    ExplanationParent Predicate |\n+    ExplanationTVar   TypeVar ExplanationKind\n+\n+-- A predicate can represent either expected or actual type of a type variable.\n+-- For example, in expression 'x: bool', variable 'x' has expected type 'bool'.\n+-- If a different type is derived for 'x' by type inference, we complain\n+-- that 'x' has expected type 'bool', but its actual type is 'string'\".\n+-- A literal \"foo\", on the other hand has actual type 'string'.  If a different\n+-- type is derived for it, we complain the expression \"foo\" of type 'string' is\n+-- used in a context that expects a 'bool'.\n+data ExplanationKind = Expected | Actual deriving (Eq)\n+\n+instance WithPos PredicateExplanation where\n+    pos (ExplanationParent p)         = pos (predExplanation p)\n+    pos (ExplanationTVar tv _)        = pos tv\n+    atPos _ _ = error \"PredicateExplanation.atPos not implemented\"\n+\n+-- As an optimization, we do not apply substitutions to explanations until the\n+-- explanation actually needs to be output in case of a type error, at which\n+-- point we apply all substitutions in 'SolverState'.\n+explanationSubstituteAll :: SolverState -> PredicateExplanation -> PredicateExplanation\n+-- Do not apply substitution to the original explanation, which points to the\n+-- variable or expression the predicate constrains.\n+explanationSubstituteAll _   e@ExplanationTVar{}  = e\n+explanationSubstituteAll st (ExplanationParent p) = ExplanationParent $ head $ predSubstituteAll st p\n+\n+explanationShow :: PredicateExplanation -> TVarShortcuts String\n+explanationShow (ExplanationTVar tv _)              = return $ tvObject tv\n+explanationShow (ExplanationParent (PEq te1 te2 e)) = do\n+    ts1 <- teShow te1\n+    ts2 <- teShow te2\n+    es <- explanationShow e\n+    return $ if explanationKind e == Expected\n+             then \"expected type: \" ++ ts2 ++ \"\\nactual type: \" ++ ts1 ++ \"\\nin\\n\" ++ es\n+             else \"expected type: \" ++ ts1 ++ \"\\nactual type: \" ++ ts2 ++ \"\\nin\\n\" ++ es\n+\n+explanationKind :: PredicateExplanation -> ExplanationKind\n+explanationKind (ExplanationTVar _ k) = k\n+explanationKind (ExplanationParent p) = explanationKind (predExplanation p)\n+\n+-- Report type resolution conflict in an unsatisfiable predicate (where\n+-- left and right side cannot be unified).\n+predReportConflict :: (?d::DatalogProgram, MonadError String me) => SolverState -> Predicate -> me a\n+predReportConflict st (PEq te1 te2 explanation) =\n+    evalState (do ts1 <- teShow te1\n+                  ts2 <- teShow te2\n+                  es <- explanationShow $ explanationSubstituteAll st explanation\n+                  return $ err ?d (pos explanation) $\n+                               if explanationKind explanation == Expected\n+                               then \"Type mismatch:\\nexpected type: \" ++ ts2 ++ \"\\nactual type: \" ++ ts1 ++ \"\\nin\\n\" ++ es\n+                               else \"Type mismatch:\\nexpected type: \" ++ ts1 ++ \"\\nactual type: \" ++ ts2 ++ \"\\nin\\n\" ++ es)\n+              M.empty\n+\n+-- Explanation of a width constraint.  For now just the explanation of the\n+-- predicate it is derived from.\n+type WidthExplanation = PredicateExplanation\n+\n+{-\n+\n+Notation:\n+\n+TV - set of type variables.  A type variable is introduced for each\n+     subexpression and variable in the program; additional variables\n+     can be introduced to encode unknown type arguments of structs and\n+     functions.\n+\n+IV - set of integer variables, which encode widths of signed and\n+     unsigned bitvector types.\n+\n+TE - set of type expressions (TypeInference.TExpr).\n+IE - set of integer expressions (TypeInference.IExpr).\n+\n+te, te1, te2 - type expressions from TE.\n+ie, ie1, ie2 - integer expressions from IV.\n+\n+State of the algorithm:\n+\n+TA: TV -> TE - partial type variable assignment computed so far.\n+    Assigned variables cannot appear in the RHS of an assignment\n+    or in any of the remaining constraints.\n+\n+IA: IV -> IE - partial integer variable assignment computed so far.\n+    Assigned variables cannot appear in the RHS of an assignment\n+    or in any of the remaining constraints.\n+\n+CS: 2^Constraint - Unresolved type constraints.\n+\n+Pseudocode:\n+\n+Type inference:\n+    while (CS is not empty) {\n+        1. Pick 'c in C' s.t. 'c = (tv == te)', 'tv in TV', 'te in TE'.\n+           - If such 'c' does not exist, pick any predicate constraint in\n+             'C' and apply Unify to it. GOTO 1.\n+           - If there are only lazy and width constraints left in 'C',\n+             pick a lazy constraint with a default solution and expand it\n+             to that solution.\n+           - If such constraint does not exist, FAIL.\n+        2. Variable substitution:\n+           - remove 'c' from 'C'\n+           - apply Substitution to replace 'tv' with 'te' in all remaining\n+             constraints and assignments.\n+           - add 'tv -> te' to 'TA'\n+    }\n+    Check that a complete typing has been found: all assignments in 'TA' are\n+    constant expressions (no variables). Otherwise, FAIL: undespecified types.\n+\n+The above algorithm uses two subroutines:\n+\n+Unify(c), where 'c = (te1 == te2)'\n+    1. Remove 'c' from 'C'.\n+    2. Recursively match 'te1' and 'te2' to produce a set of constraints of the form\n+      'tv = te', 'iv = ie' or a conflict of the form 'te3 == te4' where 'te3' and\n+      'te4' have different type constructors or 'ie3 == ie4' where 'ie3' and 'ie4' are\n+      two different integer constants.  A 'tv = te' constraint is also considered a", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fed5a9f6f42e8a4563c8f2339cf1d4c024d92d9a"}, "originalPosition": 590}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU1NTIzMQ==", "bodyText": "heh, you're right, I do :)", "url": "https://github.com/vmware/differential-datalog/pull/695#discussion_r450555231", "createdAt": "2020-07-07T01:02:51Z", "author": {"login": "ryzhyk"}, "path": "src/Language/DifferentialDatalog/Unification.hs", "diffHunk": "@@ -0,0 +1,816 @@\n+{-\n+Copyright (c) 2020 VMware, Inc.\n+SPDX-License-Identifier: MIT\n+\n+Permission is hereby granted, free of charge, to any person obtaining a copy\n+of this software and associated documentation files (the \"Software\"), to deal\n+in the Software without restriction, including without limitation the rights\n+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+copies of the Software, and to permit persons to whom the Software is\n+furnished to do so, subject to the following conditions:\n+\n+The above copyright notice and this permission notice shall be included in all\n+copies or substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+SOFTWARE.\n+-}\n+\n+{-|\n+Unification-based type inference algorithm.\n+-}\n+\n+{-# LANGUAGE FlexibleContexts, RecordWildCards, TupleSections, ImplicitParams, RankNTypes #-}\n+\n+module Language.DifferentialDatalog.Unification(\n+    Typing,\n+    DDExpr(..),\n+    PredicateExplanation(..),\n+    ExplanationKind(..),\n+    Constraint(..),\n+    constraintsShow,\n+    WidthVar(..),\n+    IExpr(..),\n+    TypeVar(..),\n+    tvObject,\n+    TExpr(..),\n+    teToType,\n+    teDeref,\n+    Predicate(..),\n+    solve\n+)\n+where\n+\n+import Control.Monad.Except\n+import Control.Monad.State\n+import Data.List\n+import qualified Data.Map as M\n+import Data.Maybe\n+--import Debug.Trace\n+\n+import Language.DifferentialDatalog.Attribute\n+import Language.DifferentialDatalog.Error\n+import Language.DifferentialDatalog.Name\n+import Language.DifferentialDatalog.Pos\n+import Language.DifferentialDatalog.Syntax\n+import Language.DifferentialDatalog.Var\n+\n+type Typing = M.Map TypeVar Type\n+\n+-- Uniquely identifies an expression in a DDlog program.\n+data DDExpr = DDExpr {ddexprCtx::ECtx, ddexprExpr::Expr} deriving (Eq, Ord)\n+\n+instance Show DDExpr where\n+    show e = show $ ddexprExpr e\n+\n+instance WithPos DDExpr where\n+    pos e = pos $ ddexprExpr e\n+    atPos _ _ = error \"DDExpr.atPos: not impleemnted\"\n+\n+-- A type constraint is an atomic predicate, that requires two type expressions\n+-- to be equivalent, a width constraint, that requires two integer expressions\n+-- representing bit widths to be equivalent, or a lazy constraint.  We use a\n+-- unification-based solver to solve type constraints, which does not handle\n+-- arbitrary Boolean combinations of constraints, hence this restricted structure.\n+data Constraint = CPredicate {cPred::Predicate}\n+                  -- Width constraint of the form 'expr1 == expr2', where\n+                  -- 'expr1' and 'expr2'.\n+                | CWidthEq {cLHS::IExpr, cRHS::IExpr, cWidthExplanation::WidthExplanation}\n+                  -- A lazy constraint gets activated once the type of a\n+                  -- specified \"trigger\" expression ('cExpr') is fully resolved.  It is\n+                  -- used to represent disjunctive constraints, where the set\n+                  -- of predicates depends on the type of the trigger.  E.g.,\n+                  -- the type of 'x.f' depends on the type of 'x', e.g., '(x:\n+                  -- Struct1 && x.f is bool || x:Struct2 && x.f: string ||\n+                  -- ...)'.  This is not easy to do with a unification solver,\n+                  -- so we let the constraint lay dormant until the solver can\n+                  -- rule out all but one disjunct.\n+                  -- 'cExpr' - trigger expression; does not change after the\n+                  -- constraint is created.\n+                  -- 'cType' - type expression that represents our current\n+                  -- knowledge of the type of 'cExpr'.  Gets refined as the\n+                  -- solver performs substitutions.\n+                  -- 'cExpand' - once 'cType' is resolved into a constant type\n+                  -- expression, this function is invoked to generate a set of\n+                  -- constraints that this lazy constraint resolves into.\n+                  -- 'cDefault' - optional default set of constraints to be used\n+                  -- if the program does not contain enough information to resolve\n+                  -- the type of the trigger expression, e.g., an integer literal\n+                  -- can be interpreted as 'u64' by default.\n+                  -- 'cExplanation' - description of the constraint for\n+                  -- debugging purposes.\n+                  --\n+                  -- TODO: currently, a lazy constraint is only triggered once\n+                  -- the type has been completely resolved, at which point it is\n+                  -- required to produce a set of constraints of fail.  Some use\n+                  -- cases may benefit from a more subtle design where a partial\n+                  -- expansion of the trigger expression is sufficient to\n+                  -- trigger the constraint.  To support this we will need to\n+                  -- change the 'cExpand' signature to return\n+                  -- 'Option<[Constraint]>', with 'Nothing' meaning that 'cType'\n+                  -- is not yet sufficiently concretized to expand the\n+                  -- constraint.\n+                | CLazy { cType::TExpr\n+                        , cExpand::(forall me . (MonadError String me) => TExpr -> me [Constraint])\n+                        , cDefault::Maybe [Constraint]\n+                        , cExpr::DDExpr\n+                        , cExplanation::String\n+                        }\n+\n+constraintShow :: Constraint -> TVarShortcuts String\n+constraintShow (CPredicate p)         = predShow p\n+constraintShow (CWidthEq ie1 ie2 _)   = return $ show ie1 ++ \" = \" ++ show ie2\n+constraintShow (CLazy te _ _ _ expl)  = return $ expl ++ \" [partial type: \" ++ show te ++ \"]\"\n+\n+constraintsShow :: [Constraint] -> String\n+constraintsShow cs = evalState (\n+    do cs' <- mapM constraintShow cs\n+       return $ intercalate \"\\n\" cs' ) M.empty\n+\n+instance Show Constraint where\n+    show c = evalState (constraintShow c) M.empty\n+\n+-- A constraint is in the solved form if it has the following shape:\n+-- 'tv = te' or 'te = tv',\n+-- where 'tv' is a type variable and 'te' is an arbitrary type expression.\n+constraintIsSolved :: Constraint -> Bool\n+constraintIsSolved (CPredicate (PEq TETVar{} _ _)) = True\n+constraintIsSolved (CPredicate (PEq _ TETVar{} _)) = True\n+constraintIsSolved (CWidthEq IVar{} _ _)           = True\n+constraintIsSolved (CWidthEq _ IVar{} _)           = True\n+constraintIsSolved _                               = False\n+\n+-- Normalization rotates a solved constraint so that the type variable\n+-- is on the left: 'te = tv' is transformed into 'tv = te'.\n+constraintNormalize :: Constraint -> Constraint\n+constraintNormalize (CPredicate (PEq te tv@TETVar{} e)) = CPredicate $ PEq tv te e\n+constraintNormalize (CWidthEq ie iv@IVar{} e)           = CWidthEq iv ie e\n+constraintNormalize c                                   = c\n+\n+constraintIsLazy :: Constraint -> Bool\n+constraintIsLazy CLazy{} = True\n+constraintIsLazy _       = False\n+\n+constraintIsPredicate :: Constraint -> Bool\n+constraintIsPredicate CPredicate{} = True\n+constraintIsPredicate _            = False\n+\n+-- Generate a width constraint in canonical form: all constants are on one side\n+-- of the constraint, variables that appear on both sides are cancelled out.\n+cWidthEq :: IExpr -> IExpr -> WidthExplanation -> [Constraint]\n+cWidthEq ie1 ie2 e = if ie1' == ie2' then [] else [CWidthEq ie1' ie2' e]\n+    where\n+    ievars1 = ieVars ie1\n+    ievars2 = ieVars ie2\n+    ieconst1 = ieConst ie1\n+    ieconst2 = ieConst ie2\n+    -- Group constants in one side of the equation.\n+    cnst = ieconst2 - ieconst1\n+    -- Cancel out variables that appear on both sides of the equation.\n+    ie1' = ieSum $ (map IVar $ ievars1 \\\\ ievars2) ++ if cnst < 0 then [IConst (-cnst)] else []\n+    ie2' = ieSum $ (map IVar $ ievars2 \\\\ ievars1) ++ if cnst > 0 then [IConst cnst] else []\n+\n+cwidthReportConflict :: (?d::DatalogProgram, MonadError String me) => Constraint -> me a\n+cwidthReportConflict c@(CWidthEq _ _ e) = err ?d (pos e) $ \"Unsatisfiable constraint '\" ++ show c ++ \"' in\\n\" ++\n+                                                           evalState (explanationShow e) M.empty\n+cwidthReportConflict c = error $ \"cwidthReportConflict \" ++ show c\n+\n+removeConstraint :: Int -> SolverState -> SolverState\n+removeConstraint idx st = st{ solverConstraints = take idx cs ++ drop (idx+1) cs }\n+    where cs = solverConstraints st\n+\n+addConstraints :: [Constraint] -> SolverState -> SolverState\n+addConstraints new_cs st = st{ solverConstraints = new_cs ++ cs}\n+    where cs = solverConstraints st\n+\n+-- Integer expressions represent widths of bit and signed types.\n+data IExpr = -- Integer constant.\n+             IConst Int\n+             -- Integer variable.\n+           | IVar WidthVar\n+             -- Sum of two widths.\n+           | IPlus IExpr IExpr\n+           deriving (Eq, Ord)\n+\n+instance Show IExpr where\n+    show (IConst i)         = show i\n+    show (IVar v)           = show v\n+    show (IPlus ie1 ie2)    = show ie1 ++ \" + \" ++ show ie2\n+\n+-- Integer expression is a constant (i.e., does not contain any variables).\n+ieIsConstant :: IExpr -> Bool\n+ieIsConstant IConst{}      = True\n+ieIsConstant IVar{}        = False\n+ieIsConstant (IPlus e1 e2) = ieIsConstant e1 && ieIsConstant e2\n+\n+-- List variables that occur in a width expression.\n+-- Each variable occurs in the result as many times as it occurs in the\n+-- expression.\n+ieVars :: IExpr -> [WidthVar]\n+ieVars IConst{}         = []\n+ieVars (IVar v)         = [v]\n+ieVars (IPlus ie1 ie2)  = ieVars ie1 ++ ieVars ie2\n+\n+-- Sum-up all integer constants in a width expression.\n+ieConst :: IExpr -> Int\n+ieConst (IConst w)      = w\n+ieConst IVar{}          = 0\n+ieConst (IPlus ie1 ie2) = ieConst ie1 + ieConst ie2\n+\n+ieSum :: [IExpr] -> IExpr\n+ieSum es = ieNormalize $ ieSum' es\n+\n+ieSum' :: [IExpr] -> IExpr\n+ieSum' []        = IConst 0\n+ieSum' [ie]      = ie\n+ieSum' (ie:ies)  = IPlus ie $ ieSum' ies\n+\n+ieNormalize :: IExpr -> IExpr\n+ieNormalize ie = ieSum' $ map IVar vs ++ cs\n+    where\n+    vs = ieVars ie\n+    c = ieConst ie\n+    cs = if null vs || c /= 0\n+         then [IConst c]\n+         else []\n+\n+-- Integer variables used in constraint encoding.\n+data WidthVar = -- Integer variable equal to the width of a DDExpr.\n+                WidthOfExpr DDExpr\n+                deriving (Eq, Ord)\n+\n+instance Show WidthVar where\n+    show (WidthOfExpr e) = \"width_of(\" ++ show e ++ \")\"\n+\n+-- Type variables used in constraint encoding.\n+-- The goal of type inference is to find a satisfying assignment to all\n+-- type and integer variables.\n+data TypeVar = -- Type of a DDlog expression.\n+               TVarTypeOfExpr {tvarId::Int, tvarExpr::DDExpr}\n+               -- Type of a DDlog variable.\n+             | TVarTypeOfVar {tvarId::Int, tvarVar::Var}\n+               -- We sometimes need to introduce extra type variables to model\n+               -- unknown type arguments of function calls.  We could use\n+               -- arbitrary auto-generated names for them, but to avoid a state\n+               -- monad and enable meaningful error message, we use the\n+               -- expression where the type argument occurs and its name\n+               -- to uniquely identify the variable.\n+             | TVarAux {tvarId::Int, tvarExpr::DDExpr, tvarName::String}\n+\n+instance Eq TypeVar where\n+    (==) tv1 tv2 = tvarId tv1 == tvarId tv2\n+\n+instance Ord TypeVar where\n+    compare tv1 tv2 = compare (tvarId tv1) (tvarId tv2)\n+\n+instance WithPos TypeVar where\n+    pos (TVarTypeOfExpr _ de) = pos de\n+    pos (TVarTypeOfVar _ v)   = pos v\n+    pos (TVarAux _ de _)      = pos de\n+    atPos _ _ = error \"TypeVar.atPos: not implemented\"\n+\n+-- Returns a string describing the object whose type this variable refers to.\n+tvObject :: TypeVar -> String\n+tvObject (TVarTypeOfExpr _ de) = \"expression '\"   ++ show de ++ \"'\" -- TODO: abbreviate long expressions\n+tvObject (TVarTypeOfVar _ v)   = \"variable '\"     ++ name v ++ \"'\"\n+tvObject (TVarAux _ _ v)       = \"type argument \" ++ name v -- TODO: type argument v of function/type ...\n+\n+-- State monad that assigns symbolic names 'a, 'b, ... to type variables in one\n+-- or more type expressions.\n+--\n+-- When pretty printing constraints, predicates or type expressions we would\n+-- like to replace type variables with short symbolic shortcuts, which should be\n+-- consistent, i.e., the same variable is alway represent by the same symbolic\n+-- name.  We achieve this by printing all related type expressions, e.g., all\n+-- type expressions involved in a type resolution conflict within this monad.\n+type TVarShortcuts a = State (M.Map TypeVar String) a\n+\n+-- Return existing shortcut for 'tv' or generate a new one.\n+tvName :: TypeVar -> TVarShortcuts String\n+tvName tv = do\n+    -- \"a\", \"b\", .. , \"z\", \"aa\", \"ab\", ....\n+    let allStrings = [ s ++ [c] | s <- \"\": allStrings, c <- ['a'..'z'] ]\n+    names <- get\n+    case M.lookup tv names of\n+         Just n  -> return n\n+         Nothing -> do let n = allStrings !! M.size names\n+                       put $ M.insert tv n names\n+                       return n\n+\n+-- Type expression: an expression that returns a value of 'Type' sort.\n+data TExpr = TEBool\n+           | TEString\n+           | TEBigInt\n+           | TEBit IExpr\n+           | TESigned IExpr\n+           | TEFloat\n+           | TEDouble\n+             -- Tuple type whose size and field types may be only partially known.\n+           | TETuple [TExpr]\n+             -- User-defined type.\n+           | TEUser String [TExpr]\n+             -- Extern type.\n+           | TEExtern String [TExpr]\n+             -- In a function context only, a type argument of the function (e.g., 'A).\n+           | TETArg String\n+             -- Type variable.\n+           | TETVar TypeVar\n+           deriving (Eq, Ord)\n+\n+teShow :: TExpr -> TVarShortcuts String\n+teShow TEBool                 = return \"bool\"\n+teShow TEString               = return \"string\"\n+teShow TEBigInt               = return \"bigint\"\n+teShow (TEBit w)              = return $ \"bit<\" ++ show w ++ \">\"\n+teShow (TESigned w)           = return $ \"signed<\" ++ show w ++ \">\"\n+teShow TEFloat                = return \"float\"\n+teShow TEDouble               = return \"double\"\n+teShow (TETuple as)           = ((++ \")\") . (\"(\" ++) . intercalate \",\") <$> mapM teShow as\n+teShow (TEUser n as)          = ((++ \">\") . ((n ++ \"<\") ++) . intercalate \",\") <$> mapM teShow as\n+teShow (TEExtern n as)        = ((++ \">\") . ((n ++ \"<\") ++) . intercalate \",\") <$> mapM teShow as\n+teShow (TETArg n)             = return $ \"'\" ++ n\n+teShow (TETVar tv)            = (\"'\" ++) <$> tvName tv\n+\n+instance Show TExpr where\n+    show te = evalState (teShow te) M.empty\n+\n+-- Type expression is a constant (i.e., does not contain any type variables).\n+teIsConstant :: TExpr -> Bool\n+teIsConstant TEBool             = True\n+teIsConstant TEString           = True\n+teIsConstant TEBigInt           = True\n+teIsConstant (TEBit w)          = ieIsConstant w\n+teIsConstant (TESigned w)       = ieIsConstant w\n+teIsConstant TEFloat            = True\n+teIsConstant TEDouble           = True\n+teIsConstant (TETuple as)       = all teIsConstant as\n+teIsConstant (TEUser _ as)      = all teIsConstant as\n+teIsConstant (TEExtern _ as)    = all teIsConstant as\n+teIsConstant TETArg{}           = True\n+teIsConstant TETVar{}           = False\n+\n+-- All type variables in a type expression.\n+teTypeVars :: TExpr -> [TypeVar]\n+teTypeVars TEBool             = []\n+teTypeVars TEString           = []\n+teTypeVars TEBigInt           = []\n+teTypeVars TEBit{}            = []\n+teTypeVars TESigned{}         = []\n+teTypeVars TEFloat            = []\n+teTypeVars TEDouble           = []\n+teTypeVars (TETuple as)       = nub $ concatMap teTypeVars as\n+teTypeVars (TEUser _ as)      = nub $ concatMap teTypeVars as\n+teTypeVars (TEExtern _ as)    = nub $ concatMap teTypeVars as\n+teTypeVars TETArg{}           = []\n+teTypeVars (TETVar v)         = [v]\n+\n+-- Convert constant type expression to a DDlog type.\n+teToType :: TExpr -> Type\n+teToType TEBool                 = tBool\n+teToType TEString               = tString\n+teToType TEBigInt               = tInt\n+teToType (TEBit (IConst w))     = tBit w\n+teToType (TESigned (IConst w))  = tSigned w\n+teToType TEFloat                = tFloat\n+teToType TEDouble               = tDouble\n+teToType (TETuple as)           = tTuple $ map teToType as\n+teToType (TEUser n as)          = tUser n $ map teToType as\n+teToType (TEExtern n as)        = tOpaque n $ map teToType as\n+teToType (TETArg n)             = tVar n\n+teToType te                     = error $ \"Unification.teToType: non-constant type expression \" ++ show te\n+\n+-- Unwrap all layers of shared references.\n+teDeref :: (?d::DatalogProgram) => TExpr -> TExpr\n+teDeref (TEExtern n [t]) | elem n sref_types = teDeref t\n+    where\n+    sref_types = map name\n+                 $ filter (tdefGetSharedRefAttr ?d)\n+                 $ M.elems $ progTypedefs ?d\n+teDeref t = t\n+\n+-- Check if type expression is a constant and if not, return an explanation.\n+-- 'obj' is the object whose type 'te' describes.\n+teCheckConstant :: (?d::DatalogProgram, MonadError String me) => TypeVar -> TExpr -> me ()\n+teCheckConstant tvar te | teIsConstant te = return ()\n+                        | not $ null tvars =\n+    -- 'te' depends on an unresolved type variable 'tv'.  So instead of\n+    -- complaining that the type of 'te' is unknown, we try to be more specific\n+    -- and complain that the type of the entity 'tv' represents is unknown.\n+    err ?d (pos tv) $ \"Cannot infer type of \" ++ tvObject tv\n+                       | otherwise =\n+    -- 'te' is not a constant, but it does not depend on any type variables,\n+    -- hence it must have parts whose width is not yet resolved into a constant.\n+    err ?d (pos tvar) $ \"Unable to infer complete type of \" ++ tvObject tvar ++ \". Partially inferred type: \" ++ show te\n+    where tvars = teTypeVars te\n+          tv : _ = tvars\n+\n+-- Type congruence, e.g., '|e| = BigInt'.\n+data Predicate = PEq {\n+    -- Left-hand side of the equation.\n+    predLHS         ::  TExpr,\n+    -- Right-hand side.\n+    predRHS         ::  TExpr,\n+    -- Explanation of the predicate used in generating an error message\n+    -- when the predicate becomes a contradiction.\n+    predExplanation ::  PredicateExplanation\n+}\n+\n+instance Eq Predicate where\n+    (==) (PEq l1 r1 _) (PEq l2 r2 _) = (l1, r1) == (l2, r2)\n+\n+instance Ord Predicate where\n+    compare (PEq l1 r1 _) (PEq l2 r2 _) = compare (l1, r1) (l2, r2)\n+\n+predShow :: Predicate -> TVarShortcuts String\n+predShow (PEq te1 te2 _) = do\n+    s1 <- teShow te1\n+    s2 <- teShow te2\n+    return $ s1 ++ \" = \" ++ s2\n+\n+instance Show Predicate where\n+    show p = evalState (predShow p) M.empty\n+\n+-- Explanation of a predicate contains metadata used to generate meaningful error\n+-- messages if the predicate becomes a contradiction.\n+--\n+-- When a predicate 'P1: t1 = t2' is initially created, 't1' is typically a type\n+-- variable that represents the type of a program variable or expression.\n+-- The meaning of the predicate is that the expected type of this variable or\n+-- expression is 't2'.  Thus the predicate's explanation is 'ExplanationTVar t1'.\n+--\n+-- The predicate can undergo two types of transformations: substitution and\n+-- unification.  After a substitution, the resulting predicate keeps its original\n+-- explanation, e.g., substitutions 't1 <- Struct1<a>' and 't2 <- Struct1<b>'\n+-- yield predicate 'P2: Struct1<a> = Struct1<b>' whose explanation is still\n+-- 'ExplanationTVar t1'.  After unification, we get a new predicate\n+-- 'P3: a=b' whose explanation it the \"parent\" predicate it was derived from:\n+-- 'ExplanationParent P2'.  Consider further substitutions 'a <- bool',\n+-- 'b <- (bool, string)', which yield an unsatisfiable predicate:\n+-- 'P3: bool = (bool, string)', whose explanation is still 'P2', except that we\n+-- also apply the substitution to the explanation, yielding\n+-- 'P2_2: Struct1<bool> = Struct1<(bool, string)>'.\n+--\n+-- This explanation carries enough information to generate the following error\n+-- messageL\n+--\n+-- ~~~~~~~~~\n+-- Type mistmatch:\n+-- expected type: (bool, string)\n+-- ectual type: bool\n+--\n+-- in\n+--\n+-- expected type: Struct1<(bool, string)>\n+-- actual type: Struct1<bool>\n+--\n+-- in\n+--\n+-- <expression or variable that 't1' refers to>.\n+-- ~~~~~~~~~\n+data PredicateExplanation =\n+    ExplanationParent Predicate |\n+    ExplanationTVar   TypeVar ExplanationKind\n+\n+-- A predicate can represent either expected or actual type of a type variable.\n+-- For example, in expression 'x: bool', variable 'x' has expected type 'bool'.\n+-- If a different type is derived for 'x' by type inference, we complain\n+-- that 'x' has expected type 'bool', but its actual type is 'string'\".\n+-- A literal \"foo\", on the other hand has actual type 'string'.  If a different\n+-- type is derived for it, we complain the expression \"foo\" of type 'string' is\n+-- used in a context that expects a 'bool'.\n+data ExplanationKind = Expected | Actual deriving (Eq)\n+\n+instance WithPos PredicateExplanation where\n+    pos (ExplanationParent p)         = pos (predExplanation p)\n+    pos (ExplanationTVar tv _)        = pos tv\n+    atPos _ _ = error \"PredicateExplanation.atPos not implemented\"\n+\n+-- As an optimization, we do not apply substitutions to explanations until the\n+-- explanation actually needs to be output in case of a type error, at which\n+-- point we apply all substitutions in 'SolverState'.\n+explanationSubstituteAll :: SolverState -> PredicateExplanation -> PredicateExplanation\n+-- Do not apply substitution to the original explanation, which points to the\n+-- variable or expression the predicate constrains.\n+explanationSubstituteAll _   e@ExplanationTVar{}  = e\n+explanationSubstituteAll st (ExplanationParent p) = ExplanationParent $ head $ predSubstituteAll st p\n+\n+explanationShow :: PredicateExplanation -> TVarShortcuts String\n+explanationShow (ExplanationTVar tv _)              = return $ tvObject tv\n+explanationShow (ExplanationParent (PEq te1 te2 e)) = do\n+    ts1 <- teShow te1\n+    ts2 <- teShow te2\n+    es <- explanationShow e\n+    return $ if explanationKind e == Expected\n+             then \"expected type: \" ++ ts2 ++ \"\\nactual type: \" ++ ts1 ++ \"\\nin\\n\" ++ es\n+             else \"expected type: \" ++ ts1 ++ \"\\nactual type: \" ++ ts2 ++ \"\\nin\\n\" ++ es\n+\n+explanationKind :: PredicateExplanation -> ExplanationKind\n+explanationKind (ExplanationTVar _ k) = k\n+explanationKind (ExplanationParent p) = explanationKind (predExplanation p)\n+\n+-- Report type resolution conflict in an unsatisfiable predicate (where\n+-- left and right side cannot be unified).\n+predReportConflict :: (?d::DatalogProgram, MonadError String me) => SolverState -> Predicate -> me a\n+predReportConflict st (PEq te1 te2 explanation) =\n+    evalState (do ts1 <- teShow te1\n+                  ts2 <- teShow te2\n+                  es <- explanationShow $ explanationSubstituteAll st explanation\n+                  return $ err ?d (pos explanation) $\n+                               if explanationKind explanation == Expected\n+                               then \"Type mismatch:\\nexpected type: \" ++ ts2 ++ \"\\nactual type: \" ++ ts1 ++ \"\\nin\\n\" ++ es\n+                               else \"Type mismatch:\\nexpected type: \" ++ ts1 ++ \"\\nactual type: \" ++ ts2 ++ \"\\nin\\n\" ++ es)\n+              M.empty\n+\n+-- Explanation of a width constraint.  For now just the explanation of the\n+-- predicate it is derived from.\n+type WidthExplanation = PredicateExplanation\n+\n+{-\n+\n+Notation:\n+\n+TV - set of type variables.  A type variable is introduced for each\n+     subexpression and variable in the program; additional variables\n+     can be introduced to encode unknown type arguments of structs and\n+     functions.\n+\n+IV - set of integer variables, which encode widths of signed and\n+     unsigned bitvector types.\n+\n+TE - set of type expressions (TypeInference.TExpr).\n+IE - set of integer expressions (TypeInference.IExpr).\n+\n+te, te1, te2 - type expressions from TE.\n+ie, ie1, ie2 - integer expressions from IV.\n+\n+State of the algorithm:\n+\n+TA: TV -> TE - partial type variable assignment computed so far.\n+    Assigned variables cannot appear in the RHS of an assignment\n+    or in any of the remaining constraints.\n+\n+IA: IV -> IE - partial integer variable assignment computed so far.\n+    Assigned variables cannot appear in the RHS of an assignment\n+    or in any of the remaining constraints.\n+\n+CS: 2^Constraint - Unresolved type constraints.\n+\n+Pseudocode:\n+\n+Type inference:\n+    while (CS is not empty) {\n+        1. Pick 'c in C' s.t. 'c = (tv == te)', 'tv in TV', 'te in TE'.\n+           - If such 'c' does not exist, pick any predicate constraint in\n+             'C' and apply Unify to it. GOTO 1.\n+           - If there are only lazy and width constraints left in 'C',\n+             pick a lazy constraint with a default solution and expand it\n+             to that solution.\n+           - If such constraint does not exist, FAIL.\n+        2. Variable substitution:\n+           - remove 'c' from 'C'\n+           - apply Substitution to replace 'tv' with 'te' in all remaining\n+             constraints and assignments.\n+           - add 'tv -> te' to 'TA'\n+    }\n+    Check that a complete typing has been found: all assignments in 'TA' are\n+    constant expressions (no variables). Otherwise, FAIL: undespecified types.\n+\n+The above algorithm uses two subroutines:\n+\n+Unify(c), where 'c = (te1 == te2)'\n+    1. Remove 'c' from 'C'.\n+    2. Recursively match 'te1' and 'te2' to produce a set of constraints of the form\n+      'tv = te', 'iv = ie' or a conflict of the form 'te3 == te4' where 'te3' and\n+      'te4' have different type constructors or 'ie3 == ie4' where 'ie3' and 'ie4' are\n+      two different integer constants.  A 'tv = te' constraint is also considered a", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDUyNDk4OQ=="}, "originalCommit": {"oid": "fed5a9f6f42e8a4563c8f2339cf1d4c024d92d9a"}, "originalPosition": 590}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwODgzNzc2OnYy", "diffSide": "RIGHT", "path": "src/Language/DifferentialDatalog/Unification.hs", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMzoxMzo1OFrOGtp6dA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMzoxMzo1OFrOGtp6dA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDUyNTgxMg==", "bodyText": "delete comment?", "url": "https://github.com/vmware/differential-datalog/pull/695#discussion_r450525812", "createdAt": "2020-07-06T23:13:58Z", "author": {"login": "mbudiu-vmw"}, "path": "src/Language/DifferentialDatalog/Unification.hs", "diffHunk": "@@ -0,0 +1,816 @@\n+{-\n+Copyright (c) 2020 VMware, Inc.\n+SPDX-License-Identifier: MIT\n+\n+Permission is hereby granted, free of charge, to any person obtaining a copy\n+of this software and associated documentation files (the \"Software\"), to deal\n+in the Software without restriction, including without limitation the rights\n+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+copies of the Software, and to permit persons to whom the Software is\n+furnished to do so, subject to the following conditions:\n+\n+The above copyright notice and this permission notice shall be included in all\n+copies or substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+SOFTWARE.\n+-}\n+\n+{-|\n+Unification-based type inference algorithm.\n+-}\n+\n+{-# LANGUAGE FlexibleContexts, RecordWildCards, TupleSections, ImplicitParams, RankNTypes #-}\n+\n+module Language.DifferentialDatalog.Unification(\n+    Typing,\n+    DDExpr(..),\n+    PredicateExplanation(..),\n+    ExplanationKind(..),\n+    Constraint(..),\n+    constraintsShow,\n+    WidthVar(..),\n+    IExpr(..),\n+    TypeVar(..),\n+    tvObject,\n+    TExpr(..),\n+    teToType,\n+    teDeref,\n+    Predicate(..),\n+    solve\n+)\n+where\n+\n+import Control.Monad.Except\n+import Control.Monad.State\n+import Data.List\n+import qualified Data.Map as M\n+import Data.Maybe\n+--import Debug.Trace\n+\n+import Language.DifferentialDatalog.Attribute\n+import Language.DifferentialDatalog.Error\n+import Language.DifferentialDatalog.Name\n+import Language.DifferentialDatalog.Pos\n+import Language.DifferentialDatalog.Syntax\n+import Language.DifferentialDatalog.Var\n+\n+type Typing = M.Map TypeVar Type\n+\n+-- Uniquely identifies an expression in a DDlog program.\n+data DDExpr = DDExpr {ddexprCtx::ECtx, ddexprExpr::Expr} deriving (Eq, Ord)\n+\n+instance Show DDExpr where\n+    show e = show $ ddexprExpr e\n+\n+instance WithPos DDExpr where\n+    pos e = pos $ ddexprExpr e\n+    atPos _ _ = error \"DDExpr.atPos: not impleemnted\"\n+\n+-- A type constraint is an atomic predicate, that requires two type expressions\n+-- to be equivalent, a width constraint, that requires two integer expressions\n+-- representing bit widths to be equivalent, or a lazy constraint.  We use a\n+-- unification-based solver to solve type constraints, which does not handle\n+-- arbitrary Boolean combinations of constraints, hence this restricted structure.\n+data Constraint = CPredicate {cPred::Predicate}\n+                  -- Width constraint of the form 'expr1 == expr2', where\n+                  -- 'expr1' and 'expr2'.\n+                | CWidthEq {cLHS::IExpr, cRHS::IExpr, cWidthExplanation::WidthExplanation}\n+                  -- A lazy constraint gets activated once the type of a\n+                  -- specified \"trigger\" expression ('cExpr') is fully resolved.  It is\n+                  -- used to represent disjunctive constraints, where the set\n+                  -- of predicates depends on the type of the trigger.  E.g.,\n+                  -- the type of 'x.f' depends on the type of 'x', e.g., '(x:\n+                  -- Struct1 && x.f is bool || x:Struct2 && x.f: string ||\n+                  -- ...)'.  This is not easy to do with a unification solver,\n+                  -- so we let the constraint lay dormant until the solver can\n+                  -- rule out all but one disjunct.\n+                  -- 'cExpr' - trigger expression; does not change after the\n+                  -- constraint is created.\n+                  -- 'cType' - type expression that represents our current\n+                  -- knowledge of the type of 'cExpr'.  Gets refined as the\n+                  -- solver performs substitutions.\n+                  -- 'cExpand' - once 'cType' is resolved into a constant type\n+                  -- expression, this function is invoked to generate a set of\n+                  -- constraints that this lazy constraint resolves into.\n+                  -- 'cDefault' - optional default set of constraints to be used\n+                  -- if the program does not contain enough information to resolve\n+                  -- the type of the trigger expression, e.g., an integer literal\n+                  -- can be interpreted as 'u64' by default.\n+                  -- 'cExplanation' - description of the constraint for\n+                  -- debugging purposes.\n+                  --\n+                  -- TODO: currently, a lazy constraint is only triggered once\n+                  -- the type has been completely resolved, at which point it is\n+                  -- required to produce a set of constraints of fail.  Some use\n+                  -- cases may benefit from a more subtle design where a partial\n+                  -- expansion of the trigger expression is sufficient to\n+                  -- trigger the constraint.  To support this we will need to\n+                  -- change the 'cExpand' signature to return\n+                  -- 'Option<[Constraint]>', with 'Nothing' meaning that 'cType'\n+                  -- is not yet sufficiently concretized to expand the\n+                  -- constraint.\n+                | CLazy { cType::TExpr\n+                        , cExpand::(forall me . (MonadError String me) => TExpr -> me [Constraint])\n+                        , cDefault::Maybe [Constraint]\n+                        , cExpr::DDExpr\n+                        , cExplanation::String\n+                        }\n+\n+constraintShow :: Constraint -> TVarShortcuts String\n+constraintShow (CPredicate p)         = predShow p\n+constraintShow (CWidthEq ie1 ie2 _)   = return $ show ie1 ++ \" = \" ++ show ie2\n+constraintShow (CLazy te _ _ _ expl)  = return $ expl ++ \" [partial type: \" ++ show te ++ \"]\"\n+\n+constraintsShow :: [Constraint] -> String\n+constraintsShow cs = evalState (\n+    do cs' <- mapM constraintShow cs\n+       return $ intercalate \"\\n\" cs' ) M.empty\n+\n+instance Show Constraint where\n+    show c = evalState (constraintShow c) M.empty\n+\n+-- A constraint is in the solved form if it has the following shape:\n+-- 'tv = te' or 'te = tv',\n+-- where 'tv' is a type variable and 'te' is an arbitrary type expression.\n+constraintIsSolved :: Constraint -> Bool\n+constraintIsSolved (CPredicate (PEq TETVar{} _ _)) = True\n+constraintIsSolved (CPredicate (PEq _ TETVar{} _)) = True\n+constraintIsSolved (CWidthEq IVar{} _ _)           = True\n+constraintIsSolved (CWidthEq _ IVar{} _)           = True\n+constraintIsSolved _                               = False\n+\n+-- Normalization rotates a solved constraint so that the type variable\n+-- is on the left: 'te = tv' is transformed into 'tv = te'.\n+constraintNormalize :: Constraint -> Constraint\n+constraintNormalize (CPredicate (PEq te tv@TETVar{} e)) = CPredicate $ PEq tv te e\n+constraintNormalize (CWidthEq ie iv@IVar{} e)           = CWidthEq iv ie e\n+constraintNormalize c                                   = c\n+\n+constraintIsLazy :: Constraint -> Bool\n+constraintIsLazy CLazy{} = True\n+constraintIsLazy _       = False\n+\n+constraintIsPredicate :: Constraint -> Bool\n+constraintIsPredicate CPredicate{} = True\n+constraintIsPredicate _            = False\n+\n+-- Generate a width constraint in canonical form: all constants are on one side\n+-- of the constraint, variables that appear on both sides are cancelled out.\n+cWidthEq :: IExpr -> IExpr -> WidthExplanation -> [Constraint]\n+cWidthEq ie1 ie2 e = if ie1' == ie2' then [] else [CWidthEq ie1' ie2' e]\n+    where\n+    ievars1 = ieVars ie1\n+    ievars2 = ieVars ie2\n+    ieconst1 = ieConst ie1\n+    ieconst2 = ieConst ie2\n+    -- Group constants in one side of the equation.\n+    cnst = ieconst2 - ieconst1\n+    -- Cancel out variables that appear on both sides of the equation.\n+    ie1' = ieSum $ (map IVar $ ievars1 \\\\ ievars2) ++ if cnst < 0 then [IConst (-cnst)] else []\n+    ie2' = ieSum $ (map IVar $ ievars2 \\\\ ievars1) ++ if cnst > 0 then [IConst cnst] else []\n+\n+cwidthReportConflict :: (?d::DatalogProgram, MonadError String me) => Constraint -> me a\n+cwidthReportConflict c@(CWidthEq _ _ e) = err ?d (pos e) $ \"Unsatisfiable constraint '\" ++ show c ++ \"' in\\n\" ++\n+                                                           evalState (explanationShow e) M.empty\n+cwidthReportConflict c = error $ \"cwidthReportConflict \" ++ show c\n+\n+removeConstraint :: Int -> SolverState -> SolverState\n+removeConstraint idx st = st{ solverConstraints = take idx cs ++ drop (idx+1) cs }\n+    where cs = solverConstraints st\n+\n+addConstraints :: [Constraint] -> SolverState -> SolverState\n+addConstraints new_cs st = st{ solverConstraints = new_cs ++ cs}\n+    where cs = solverConstraints st\n+\n+-- Integer expressions represent widths of bit and signed types.\n+data IExpr = -- Integer constant.\n+             IConst Int\n+             -- Integer variable.\n+           | IVar WidthVar\n+             -- Sum of two widths.\n+           | IPlus IExpr IExpr\n+           deriving (Eq, Ord)\n+\n+instance Show IExpr where\n+    show (IConst i)         = show i\n+    show (IVar v)           = show v\n+    show (IPlus ie1 ie2)    = show ie1 ++ \" + \" ++ show ie2\n+\n+-- Integer expression is a constant (i.e., does not contain any variables).\n+ieIsConstant :: IExpr -> Bool\n+ieIsConstant IConst{}      = True\n+ieIsConstant IVar{}        = False\n+ieIsConstant (IPlus e1 e2) = ieIsConstant e1 && ieIsConstant e2\n+\n+-- List variables that occur in a width expression.\n+-- Each variable occurs in the result as many times as it occurs in the\n+-- expression.\n+ieVars :: IExpr -> [WidthVar]\n+ieVars IConst{}         = []\n+ieVars (IVar v)         = [v]\n+ieVars (IPlus ie1 ie2)  = ieVars ie1 ++ ieVars ie2\n+\n+-- Sum-up all integer constants in a width expression.\n+ieConst :: IExpr -> Int\n+ieConst (IConst w)      = w\n+ieConst IVar{}          = 0\n+ieConst (IPlus ie1 ie2) = ieConst ie1 + ieConst ie2\n+\n+ieSum :: [IExpr] -> IExpr\n+ieSum es = ieNormalize $ ieSum' es\n+\n+ieSum' :: [IExpr] -> IExpr\n+ieSum' []        = IConst 0\n+ieSum' [ie]      = ie\n+ieSum' (ie:ies)  = IPlus ie $ ieSum' ies\n+\n+ieNormalize :: IExpr -> IExpr\n+ieNormalize ie = ieSum' $ map IVar vs ++ cs\n+    where\n+    vs = ieVars ie\n+    c = ieConst ie\n+    cs = if null vs || c /= 0\n+         then [IConst c]\n+         else []\n+\n+-- Integer variables used in constraint encoding.\n+data WidthVar = -- Integer variable equal to the width of a DDExpr.\n+                WidthOfExpr DDExpr\n+                deriving (Eq, Ord)\n+\n+instance Show WidthVar where\n+    show (WidthOfExpr e) = \"width_of(\" ++ show e ++ \")\"\n+\n+-- Type variables used in constraint encoding.\n+-- The goal of type inference is to find a satisfying assignment to all\n+-- type and integer variables.\n+data TypeVar = -- Type of a DDlog expression.\n+               TVarTypeOfExpr {tvarId::Int, tvarExpr::DDExpr}\n+               -- Type of a DDlog variable.\n+             | TVarTypeOfVar {tvarId::Int, tvarVar::Var}\n+               -- We sometimes need to introduce extra type variables to model\n+               -- unknown type arguments of function calls.  We could use\n+               -- arbitrary auto-generated names for them, but to avoid a state\n+               -- monad and enable meaningful error message, we use the\n+               -- expression where the type argument occurs and its name\n+               -- to uniquely identify the variable.\n+             | TVarAux {tvarId::Int, tvarExpr::DDExpr, tvarName::String}\n+\n+instance Eq TypeVar where\n+    (==) tv1 tv2 = tvarId tv1 == tvarId tv2\n+\n+instance Ord TypeVar where\n+    compare tv1 tv2 = compare (tvarId tv1) (tvarId tv2)\n+\n+instance WithPos TypeVar where\n+    pos (TVarTypeOfExpr _ de) = pos de\n+    pos (TVarTypeOfVar _ v)   = pos v\n+    pos (TVarAux _ de _)      = pos de\n+    atPos _ _ = error \"TypeVar.atPos: not implemented\"\n+\n+-- Returns a string describing the object whose type this variable refers to.\n+tvObject :: TypeVar -> String\n+tvObject (TVarTypeOfExpr _ de) = \"expression '\"   ++ show de ++ \"'\" -- TODO: abbreviate long expressions\n+tvObject (TVarTypeOfVar _ v)   = \"variable '\"     ++ name v ++ \"'\"\n+tvObject (TVarAux _ _ v)       = \"type argument \" ++ name v -- TODO: type argument v of function/type ...\n+\n+-- State monad that assigns symbolic names 'a, 'b, ... to type variables in one\n+-- or more type expressions.\n+--\n+-- When pretty printing constraints, predicates or type expressions we would\n+-- like to replace type variables with short symbolic shortcuts, which should be\n+-- consistent, i.e., the same variable is alway represent by the same symbolic\n+-- name.  We achieve this by printing all related type expressions, e.g., all\n+-- type expressions involved in a type resolution conflict within this monad.\n+type TVarShortcuts a = State (M.Map TypeVar String) a\n+\n+-- Return existing shortcut for 'tv' or generate a new one.\n+tvName :: TypeVar -> TVarShortcuts String\n+tvName tv = do\n+    -- \"a\", \"b\", .. , \"z\", \"aa\", \"ab\", ....\n+    let allStrings = [ s ++ [c] | s <- \"\": allStrings, c <- ['a'..'z'] ]\n+    names <- get\n+    case M.lookup tv names of\n+         Just n  -> return n\n+         Nothing -> do let n = allStrings !! M.size names\n+                       put $ M.insert tv n names\n+                       return n\n+\n+-- Type expression: an expression that returns a value of 'Type' sort.\n+data TExpr = TEBool\n+           | TEString\n+           | TEBigInt\n+           | TEBit IExpr\n+           | TESigned IExpr\n+           | TEFloat\n+           | TEDouble\n+             -- Tuple type whose size and field types may be only partially known.\n+           | TETuple [TExpr]\n+             -- User-defined type.\n+           | TEUser String [TExpr]\n+             -- Extern type.\n+           | TEExtern String [TExpr]\n+             -- In a function context only, a type argument of the function (e.g., 'A).\n+           | TETArg String\n+             -- Type variable.\n+           | TETVar TypeVar\n+           deriving (Eq, Ord)\n+\n+teShow :: TExpr -> TVarShortcuts String\n+teShow TEBool                 = return \"bool\"\n+teShow TEString               = return \"string\"\n+teShow TEBigInt               = return \"bigint\"\n+teShow (TEBit w)              = return $ \"bit<\" ++ show w ++ \">\"\n+teShow (TESigned w)           = return $ \"signed<\" ++ show w ++ \">\"\n+teShow TEFloat                = return \"float\"\n+teShow TEDouble               = return \"double\"\n+teShow (TETuple as)           = ((++ \")\") . (\"(\" ++) . intercalate \",\") <$> mapM teShow as\n+teShow (TEUser n as)          = ((++ \">\") . ((n ++ \"<\") ++) . intercalate \",\") <$> mapM teShow as\n+teShow (TEExtern n as)        = ((++ \">\") . ((n ++ \"<\") ++) . intercalate \",\") <$> mapM teShow as\n+teShow (TETArg n)             = return $ \"'\" ++ n\n+teShow (TETVar tv)            = (\"'\" ++) <$> tvName tv\n+\n+instance Show TExpr where\n+    show te = evalState (teShow te) M.empty\n+\n+-- Type expression is a constant (i.e., does not contain any type variables).\n+teIsConstant :: TExpr -> Bool\n+teIsConstant TEBool             = True\n+teIsConstant TEString           = True\n+teIsConstant TEBigInt           = True\n+teIsConstant (TEBit w)          = ieIsConstant w\n+teIsConstant (TESigned w)       = ieIsConstant w\n+teIsConstant TEFloat            = True\n+teIsConstant TEDouble           = True\n+teIsConstant (TETuple as)       = all teIsConstant as\n+teIsConstant (TEUser _ as)      = all teIsConstant as\n+teIsConstant (TEExtern _ as)    = all teIsConstant as\n+teIsConstant TETArg{}           = True\n+teIsConstant TETVar{}           = False\n+\n+-- All type variables in a type expression.\n+teTypeVars :: TExpr -> [TypeVar]\n+teTypeVars TEBool             = []\n+teTypeVars TEString           = []\n+teTypeVars TEBigInt           = []\n+teTypeVars TEBit{}            = []\n+teTypeVars TESigned{}         = []\n+teTypeVars TEFloat            = []\n+teTypeVars TEDouble           = []\n+teTypeVars (TETuple as)       = nub $ concatMap teTypeVars as\n+teTypeVars (TEUser _ as)      = nub $ concatMap teTypeVars as\n+teTypeVars (TEExtern _ as)    = nub $ concatMap teTypeVars as\n+teTypeVars TETArg{}           = []\n+teTypeVars (TETVar v)         = [v]\n+\n+-- Convert constant type expression to a DDlog type.\n+teToType :: TExpr -> Type\n+teToType TEBool                 = tBool\n+teToType TEString               = tString\n+teToType TEBigInt               = tInt\n+teToType (TEBit (IConst w))     = tBit w\n+teToType (TESigned (IConst w))  = tSigned w\n+teToType TEFloat                = tFloat\n+teToType TEDouble               = tDouble\n+teToType (TETuple as)           = tTuple $ map teToType as\n+teToType (TEUser n as)          = tUser n $ map teToType as\n+teToType (TEExtern n as)        = tOpaque n $ map teToType as\n+teToType (TETArg n)             = tVar n\n+teToType te                     = error $ \"Unification.teToType: non-constant type expression \" ++ show te\n+\n+-- Unwrap all layers of shared references.\n+teDeref :: (?d::DatalogProgram) => TExpr -> TExpr\n+teDeref (TEExtern n [t]) | elem n sref_types = teDeref t\n+    where\n+    sref_types = map name\n+                 $ filter (tdefGetSharedRefAttr ?d)\n+                 $ M.elems $ progTypedefs ?d\n+teDeref t = t\n+\n+-- Check if type expression is a constant and if not, return an explanation.\n+-- 'obj' is the object whose type 'te' describes.\n+teCheckConstant :: (?d::DatalogProgram, MonadError String me) => TypeVar -> TExpr -> me ()\n+teCheckConstant tvar te | teIsConstant te = return ()\n+                        | not $ null tvars =\n+    -- 'te' depends on an unresolved type variable 'tv'.  So instead of\n+    -- complaining that the type of 'te' is unknown, we try to be more specific\n+    -- and complain that the type of the entity 'tv' represents is unknown.\n+    err ?d (pos tv) $ \"Cannot infer type of \" ++ tvObject tv\n+                       | otherwise =\n+    -- 'te' is not a constant, but it does not depend on any type variables,\n+    -- hence it must have parts whose width is not yet resolved into a constant.\n+    err ?d (pos tvar) $ \"Unable to infer complete type of \" ++ tvObject tvar ++ \". Partially inferred type: \" ++ show te\n+    where tvars = teTypeVars te\n+          tv : _ = tvars\n+\n+-- Type congruence, e.g., '|e| = BigInt'.\n+data Predicate = PEq {\n+    -- Left-hand side of the equation.\n+    predLHS         ::  TExpr,\n+    -- Right-hand side.\n+    predRHS         ::  TExpr,\n+    -- Explanation of the predicate used in generating an error message\n+    -- when the predicate becomes a contradiction.\n+    predExplanation ::  PredicateExplanation\n+}\n+\n+instance Eq Predicate where\n+    (==) (PEq l1 r1 _) (PEq l2 r2 _) = (l1, r1) == (l2, r2)\n+\n+instance Ord Predicate where\n+    compare (PEq l1 r1 _) (PEq l2 r2 _) = compare (l1, r1) (l2, r2)\n+\n+predShow :: Predicate -> TVarShortcuts String\n+predShow (PEq te1 te2 _) = do\n+    s1 <- teShow te1\n+    s2 <- teShow te2\n+    return $ s1 ++ \" = \" ++ s2\n+\n+instance Show Predicate where\n+    show p = evalState (predShow p) M.empty\n+\n+-- Explanation of a predicate contains metadata used to generate meaningful error\n+-- messages if the predicate becomes a contradiction.\n+--\n+-- When a predicate 'P1: t1 = t2' is initially created, 't1' is typically a type\n+-- variable that represents the type of a program variable or expression.\n+-- The meaning of the predicate is that the expected type of this variable or\n+-- expression is 't2'.  Thus the predicate's explanation is 'ExplanationTVar t1'.\n+--\n+-- The predicate can undergo two types of transformations: substitution and\n+-- unification.  After a substitution, the resulting predicate keeps its original\n+-- explanation, e.g., substitutions 't1 <- Struct1<a>' and 't2 <- Struct1<b>'\n+-- yield predicate 'P2: Struct1<a> = Struct1<b>' whose explanation is still\n+-- 'ExplanationTVar t1'.  After unification, we get a new predicate\n+-- 'P3: a=b' whose explanation it the \"parent\" predicate it was derived from:\n+-- 'ExplanationParent P2'.  Consider further substitutions 'a <- bool',\n+-- 'b <- (bool, string)', which yield an unsatisfiable predicate:\n+-- 'P3: bool = (bool, string)', whose explanation is still 'P2', except that we\n+-- also apply the substitution to the explanation, yielding\n+-- 'P2_2: Struct1<bool> = Struct1<(bool, string)>'.\n+--\n+-- This explanation carries enough information to generate the following error\n+-- messageL\n+--\n+-- ~~~~~~~~~\n+-- Type mistmatch:\n+-- expected type: (bool, string)\n+-- ectual type: bool\n+--\n+-- in\n+--\n+-- expected type: Struct1<(bool, string)>\n+-- actual type: Struct1<bool>\n+--\n+-- in\n+--\n+-- <expression or variable that 't1' refers to>.\n+-- ~~~~~~~~~\n+data PredicateExplanation =\n+    ExplanationParent Predicate |\n+    ExplanationTVar   TypeVar ExplanationKind\n+\n+-- A predicate can represent either expected or actual type of a type variable.\n+-- For example, in expression 'x: bool', variable 'x' has expected type 'bool'.\n+-- If a different type is derived for 'x' by type inference, we complain\n+-- that 'x' has expected type 'bool', but its actual type is 'string'\".\n+-- A literal \"foo\", on the other hand has actual type 'string'.  If a different\n+-- type is derived for it, we complain the expression \"foo\" of type 'string' is\n+-- used in a context that expects a 'bool'.\n+data ExplanationKind = Expected | Actual deriving (Eq)\n+\n+instance WithPos PredicateExplanation where\n+    pos (ExplanationParent p)         = pos (predExplanation p)\n+    pos (ExplanationTVar tv _)        = pos tv\n+    atPos _ _ = error \"PredicateExplanation.atPos not implemented\"\n+\n+-- As an optimization, we do not apply substitutions to explanations until the\n+-- explanation actually needs to be output in case of a type error, at which\n+-- point we apply all substitutions in 'SolverState'.\n+explanationSubstituteAll :: SolverState -> PredicateExplanation -> PredicateExplanation\n+-- Do not apply substitution to the original explanation, which points to the\n+-- variable or expression the predicate constrains.\n+explanationSubstituteAll _   e@ExplanationTVar{}  = e\n+explanationSubstituteAll st (ExplanationParent p) = ExplanationParent $ head $ predSubstituteAll st p\n+\n+explanationShow :: PredicateExplanation -> TVarShortcuts String\n+explanationShow (ExplanationTVar tv _)              = return $ tvObject tv\n+explanationShow (ExplanationParent (PEq te1 te2 e)) = do\n+    ts1 <- teShow te1\n+    ts2 <- teShow te2\n+    es <- explanationShow e\n+    return $ if explanationKind e == Expected\n+             then \"expected type: \" ++ ts2 ++ \"\\nactual type: \" ++ ts1 ++ \"\\nin\\n\" ++ es\n+             else \"expected type: \" ++ ts1 ++ \"\\nactual type: \" ++ ts2 ++ \"\\nin\\n\" ++ es\n+\n+explanationKind :: PredicateExplanation -> ExplanationKind\n+explanationKind (ExplanationTVar _ k) = k\n+explanationKind (ExplanationParent p) = explanationKind (predExplanation p)\n+\n+-- Report type resolution conflict in an unsatisfiable predicate (where\n+-- left and right side cannot be unified).\n+predReportConflict :: (?d::DatalogProgram, MonadError String me) => SolverState -> Predicate -> me a\n+predReportConflict st (PEq te1 te2 explanation) =\n+    evalState (do ts1 <- teShow te1\n+                  ts2 <- teShow te2\n+                  es <- explanationShow $ explanationSubstituteAll st explanation\n+                  return $ err ?d (pos explanation) $\n+                               if explanationKind explanation == Expected\n+                               then \"Type mismatch:\\nexpected type: \" ++ ts2 ++ \"\\nactual type: \" ++ ts1 ++ \"\\nin\\n\" ++ es\n+                               else \"Type mismatch:\\nexpected type: \" ++ ts1 ++ \"\\nactual type: \" ++ ts2 ++ \"\\nin\\n\" ++ es)\n+              M.empty\n+\n+-- Explanation of a width constraint.  For now just the explanation of the\n+-- predicate it is derived from.\n+type WidthExplanation = PredicateExplanation\n+\n+{-\n+\n+Notation:\n+\n+TV - set of type variables.  A type variable is introduced for each\n+     subexpression and variable in the program; additional variables\n+     can be introduced to encode unknown type arguments of structs and\n+     functions.\n+\n+IV - set of integer variables, which encode widths of signed and\n+     unsigned bitvector types.\n+\n+TE - set of type expressions (TypeInference.TExpr).\n+IE - set of integer expressions (TypeInference.IExpr).\n+\n+te, te1, te2 - type expressions from TE.\n+ie, ie1, ie2 - integer expressions from IV.\n+\n+State of the algorithm:\n+\n+TA: TV -> TE - partial type variable assignment computed so far.\n+    Assigned variables cannot appear in the RHS of an assignment\n+    or in any of the remaining constraints.\n+\n+IA: IV -> IE - partial integer variable assignment computed so far.\n+    Assigned variables cannot appear in the RHS of an assignment\n+    or in any of the remaining constraints.\n+\n+CS: 2^Constraint - Unresolved type constraints.\n+\n+Pseudocode:\n+\n+Type inference:\n+    while (CS is not empty) {\n+        1. Pick 'c in C' s.t. 'c = (tv == te)', 'tv in TV', 'te in TE'.\n+           - If such 'c' does not exist, pick any predicate constraint in\n+             'C' and apply Unify to it. GOTO 1.\n+           - If there are only lazy and width constraints left in 'C',\n+             pick a lazy constraint with a default solution and expand it\n+             to that solution.\n+           - If such constraint does not exist, FAIL.\n+        2. Variable substitution:\n+           - remove 'c' from 'C'\n+           - apply Substitution to replace 'tv' with 'te' in all remaining\n+             constraints and assignments.\n+           - add 'tv -> te' to 'TA'\n+    }\n+    Check that a complete typing has been found: all assignments in 'TA' are\n+    constant expressions (no variables). Otherwise, FAIL: undespecified types.\n+\n+The above algorithm uses two subroutines:\n+\n+Unify(c), where 'c = (te1 == te2)'\n+    1. Remove 'c' from 'C'.\n+    2. Recursively match 'te1' and 'te2' to produce a set of constraints of the form\n+      'tv = te', 'iv = ie' or a conflict of the form 'te3 == te4' where 'te3' and\n+      'te4' have different type constructors or 'ie3 == ie4' where 'ie3' and 'ie4' are\n+      two different integer constants.  A 'tv = te' constraint is also considered a\n+      conflict if 'te' depends on 'tv' (and is not identity 'tv').\n+    3. If conflict detected, FAIL: conflicting types.\n+    4. Otherwise, add newly derived equations to 'C'.\n+\n+Substitution(tv, te):\n+    Replace all occurrences of 'tv' with 'te' in 'C' and 'TA'.\n+    Eliminate tautologies like 'te1 == te1'\n+    Lazy constraints 'c in C' are handled by applying the substitution\n+    to the trigger expression and expanding the constraint if its type\n+    is fully resolved.\n+-}\n+\n+data SolverState = SolverState {\n+    -- Partial typing computed so far.\n+    -- Assigned variables cannot appear in the RHS of an assignment\n+    -- or in any of the remaining constraints.\n+    solverPartialTyping :: M.Map TypeVar TExpr,\n+\n+    -- IA: IV -> IE - partial integer variable assignment computed so far.\n+    -- Assigned variables cannot appear in the RHS of an assignment\n+    -- or in any of the remaining constraints.\n+    solverPartialWidth :: M.Map WidthVar IExpr,\n+\n+    -- Unresolved type constraints.\n+    solverConstraints :: [Constraint]\n+}\n+\n+solve :: (MonadError String me) => DatalogProgram -> [Constraint] -> me Typing\n+solve d cs = let ?d = d in solve' init_state\n+    where\n+    init_state = SolverState {\n+        solverPartialTyping = M.empty,\n+        solverPartialWidth = M.empty,\n+        solverConstraints = cs\n+    }\n+\n+solve' :: (?d::DatalogProgram, MonadError String me) => SolverState -> me Typing\n+solve' st | null (solverConstraints st) = do\n+    -- Check that a complete typing has been found: all assignments in 'TA' and\n+    -- 'IA' are constant expressions (no variables). Otherwise, FAIL: underspecified types.\n+    mapM_ (\\(tv, te) -> teCheckConstant tv te) $ M.toList $ solverPartialTyping st\n+    return $ M.map teToType $ solverPartialTyping st\n+          | otherwise =\n+    -- 1. Pick 'c in C' s.t. 'c = (tv == te)', 'tv in TV', 'te in TE'.\n+    --   - If such 'c' does not exist, pick any predicate constraint in\n+    --     'C' and apply Unification to it.\n+    --   - If there are only lazy and width constraints left in 'C',\n+    --     pick a disjunctive constraint with a default solution.\n+    --   - If such constraint does not exist, FAIL.\n+    --trace (\"solve': constraints:\\n\" ++ constraintsShow (solverConstraints st)) $\n+    case findIndex constraintIsSolved  $ solverConstraints st of\n+         Nothing -> case findIndex (constraintIsPredicate) $ solverConstraints st of\n+                         Nothing -> case findIndex (\\c -> constraintIsLazy c && isJust (cDefault c)) $ solverConstraints st of\n+                                         Just i -> do let st' = removeConstraint i st\n+                                                      let CLazy _ _ (Just def) _ _ = solverConstraints st !! i\n+                                                      let st'' = addConstraints (concatMap (constraintSubstituteAll st') def) st'\n+                                                      solve' st''\n+                                         Nothing -> case solverConstraints st !! 0 of\n+                                                         CLazy{..} -> err ?d (pos cExpr) $ \"Failed to infer type of expression '\" ++ show cExpr ++ \"'\"\n+                                                         c@CWidthEq{} -> cwidthReportConflict c\n+                                                         c -> error $ \"solve': unexpected constraint \" ++ show c\n+                                                         {-\" partial type: \" ++ show cType ++", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fed5a9f6f42e8a4563c8f2339cf1d4c024d92d9a"}, "originalPosition": 652}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwODg1MzQ0OnYy", "diffSide": "RIGHT", "path": "src/Language/DifferentialDatalog/TypeInference.hs", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMzoyMjowNVrOGtqDtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMzoyMjowNVrOGtqDtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDUyODE4MA==", "bodyText": "helper function for this line?", "url": "https://github.com/vmware/differential-datalog/pull/695#discussion_r450528180", "createdAt": "2020-07-06T23:22:05Z", "author": {"login": "mbudiu-vmw"}, "path": "src/Language/DifferentialDatalog/TypeInference.hs", "diffHunk": "@@ -21,298 +21,422 @@ OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n SOFTWARE.\n -}\n \n-{-# LANGUAGE FlexibleContexts, RecordWildCards, TupleSections, ImplicitParams #-}\n+{-# LANGUAGE FlexibleContexts, RecordWildCards, TupleSections, ImplicitParams, RankNTypes #-}\n \n module Language.DifferentialDatalog.TypeInference(\n-    TypeInferenceResult(..),\n+    DDExpr(..),\n+    tvObject,\n     inferTypes\n )\n where\n \n import qualified Data.Map as M\n+import Data.List\n+--import Data.List.Utils\n+import Control.Monad.Except\n import Control.Monad.State.Lazy\n import Data.Maybe\n+import GHC.Float\n+--import Debug.Trace\n \n import Language.DifferentialDatalog.Attribute\n import Language.DifferentialDatalog.ECtx\n+import Language.DifferentialDatalog.Error\n import Language.DifferentialDatalog.Expr\n import Language.DifferentialDatalog.Name\n import Language.DifferentialDatalog.NS\n import Language.DifferentialDatalog.Ops\n-import Language.DifferentialDatalog.Rule\n+import Language.DifferentialDatalog.Pos\n+import {-# SOURCE #-} Language.DifferentialDatalog.Rule\n import Language.DifferentialDatalog.Syntax\n import Language.DifferentialDatalog.Type\n import Language.DifferentialDatalog.Util\n+import Language.DifferentialDatalog.Unification\n import Language.DifferentialDatalog.Var\n \n-data TypeInferenceResult = TypeInferenceOk (M.Map Var Type) (M.Map ECtx Type)\n-                         | TypeInferenceConflict\n-                         | TypeInferenceAmbiguity\n-\n--- Uniquely identifies an expression in a DDlog program.\n-data DDExpr = DDExpr {ddexprCtx::ECtx, ddexprExpr::Expr}\n-\n--- A type constraint is an atomic predicate or a disjuncion of conjuntions of\n--- predicates.  We use a unification-based solver to resolv type constraints,\n--- which does not handle arbitrary Boolean combination constraints, hence this\n--- restricted structure.\n-data Constraint = CPredicate Predicate\n-                  -- Disjunction of conjunctions.  The first condition in each\n-                  -- conjunction must not overlap with others, e.g.,\n-                  -- 'c11 && c12 && ... ||\n-                  --  ...\n-                  --  cn1 && cn2 && ...'\n-                  --  where 'c1i' are all mutually exclusive.\n-                | CDisj [[Predicate]]\n-\n-cdisj :: [[Predicate]] -> [Constraint]\n-cdisj [ps] = map CPredicate ps\n-cdisj pss  = [CDisj pss]\n-\n--- Integer expressions represent widths of bit and signed types.\n-data IExpr = -- Integer constant.\n-             IConst Int\n-             -- Integer variable equal to the width of a DDExpr.\n-           | IWidthOfExpr DDExpr\n-             -- Sum of two widths.\n-           | IPlus IExpr IExpr\n-\n--- Type expression: an expression that returns a value of 'Type' sort.\n-data TExpr = TEBool\n-           | TEString\n-           | TEBigInt\n-           | TEBit IExpr\n-           | TESigned IExpr\n-           | TEFloat\n-           | TEDouble\n-             -- Tuple type whose size and field types may be only partially known.\n-           | TETuple (Maybe Int) (M.Map Int TExpr)\n-             -- User-defined type.\n-           | TEUser String [TExpr]\n-             -- Extern type.\n-           | TEExtern String [TExpr]\n-             -- In a function context only, a type argument of the function (e.g., 'A).\n-           | TETArg String\n-             -- Type of a DDlog expression.\n-           | TETypeOfExpr DDExpr\n-             -- Type of a DDlog variable.\n-           | TETypeOfVar Var\n-             -- We sometimes need to introduce extra type variables to model\n-             -- unknown type arguments of function calls.  We could use\n-             -- arbitrary auto-generated names for them, but to avoid a state\n-             -- monad, we use context and type argument name to uniquely\n-             -- identify the variable.\n-           | TETVar ECtx String\n+-- Constraint generator state.\n+data GeneratorState = GeneratorState {\n+    -- Constraints generated so far.\n+    genConstraints :: [Constraint],\n+    -- TypeVar-to-id map.  We assign unique ids to type variables to speed up\n+    -- comparisons.\n+    genVars        :: M.Map (Maybe DDExpr, Maybe Var, Maybe String) Int,\n+    -- The number of type variables in 'genVars'. Used to assign ids to new variables.\n+    genNumVars     :: Int\n+}\n+\n+emptyGenerator :: GeneratorState\n+emptyGenerator = GeneratorState {\n+    genConstraints = [],\n+    genVars        = M.empty,\n+    genNumVars     = 0\n+}\n+\n+type GeneratorMonad t = State GeneratorState t\n+\n+addConstraint :: Constraint -> GeneratorMonad ()\n+addConstraint c = modify $ \\gen@GeneratorState{..} -> gen{genConstraints = c : genConstraints}\n+\n+addConstraints :: [Constraint] -> GeneratorMonad ()\n+addConstraints cs = modify $ \\gen@GeneratorState{..} -> gen{genConstraints = cs ++ genConstraints}\n+\n+tvarTypeOfVar :: Var -> GeneratorMonad TypeVar\n+tvarTypeOfVar v = do\n+    gen@GeneratorState{..} <- get\n+    case M.lookup (Nothing, Just v, Nothing) genVars of\n+         Nothing -> do let tv = TVarTypeOfVar genNumVars v\n+                       put $ gen {genVars = M.insert (Nothing, Just v, Nothing) genNumVars genVars, genNumVars = genNumVars + 1}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fed5a9f6f42e8a4563c8f2339cf1d4c024d92d9a"}, "originalPosition": 129}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwODg3NzczOnYy", "diffSide": "RIGHT", "path": "src/Language/DifferentialDatalog/TypeInference.hs", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMzozNDowNlrOGtqRtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QwMTowNDowMFrOGtruZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDUzMTc2NQ==", "bodyText": "wouldn't bigint be enough?", "url": "https://github.com/vmware/differential-datalog/pull/695#discussion_r450531765", "createdAt": "2020-07-06T23:34:06Z", "author": {"login": "mbudiu-vmw"}, "path": "src/Language/DifferentialDatalog/TypeInference.hs", "diffHunk": "@@ -321,87 +445,113 @@ contextConstraints de@(DDExpr (CtxRuleRCond rl i) _) | rhsIsFilterCondition $ ru\n -- (|v1|,...,|vn|)=K,\n -- |e| = V,\n -- |v| = T\n-contextConstraints de@(DDExpr ctx@(CtxRuleRAggregate rl i) _) =\n-    [ teTuple (map (\\v -> TETypeOfVar (getVar ?d ctx v)) rhsGroupBy) === typeToTExpr' ctx ktype\n-    , TETypeOfExpr de === typeToTExpr' ctx vtype\n-    , TETypeOfVar (AggregateVar rl i) === typeToTExpr' ctx ret_type]\n+contextConstraints de@(DDExpr (CtxRuleRAggregate rl i) _) = do\n+    addConstraint =<< tvarTypeOfExpr de <~~~~> typeToTExpr' de vtype\n+    addConstraint =<< tvarTypeOfVar (AggregateVar rl i) <====> typeToTExpr' de ret_type\n     where\n     RHSAggregate{..} = ruleRHS rl !! i\n     Function{funcArgs = [grp_type], funcType = ret_type} = getFunc ?d rhsAggFunc\n-    TOpaque{typeArgs = [ktype, vtype]} = typ' ?d grp_type\n+    TOpaque{typeArgs = [_, vtype]} = typ' ?d grp_type\n+\n+contextConstraints de@(DDExpr ctx@(CtxRuleRGroupBy rl i) _) =\n+    addConstraint =<< tvarTypeOfExpr (DDExpr ctx rhsGroupBy) <~~~~> typeToTExpr' de ktype\n+    where\n+    RHSAggregate{..} = ruleRHS rl !! i\n+    Function{funcArgs = [grp_type]} = getFunc ?d rhsAggFunc\n+    TOpaque{typeArgs = [ktype, _]} = typ' ?d grp_type\n+\n \n -- When evaluating 'var v = FlatMap(e)'\n -- the following type constraints are added:\n -- |v| = iterator_type(|e|)\n contextConstraints de@(DDExpr (CtxRuleRFlatMap rl i) _) =\n-    [deIsSet de $ TETypeOfVar (FlatMapVar rl i)]\n+    addConstraint =<< deIsIterable de =<< tvarTypeOfVar (FlatMapVar rl i)\n \n -- When evaluating expression e in an Inspect clause of a rule:\n -- |e| = Tuple0, |var ddlog_weight| = Bit 64, |var ddlog_iter| = ....\n-contextConstraints de@(DDExpr (CtxRuleRInspect rl _) _) =\n-    [ TETypeOfExpr de === TETuple (Just 0) M.empty\n-    , TETypeOfVar WeightVar === typeToTExpr (tUser wEIGHT_TYPE [])\n-    , if ruleIsRecursive ?d rl\n-         then TETypeOfVar (TSVar rl) === typeToTExpr (tUser nESTED_TS_TYPE [])\n-         else TETypeOfVar (TSVar rl) === typeToTExpr (tUser ePOCH_TYPE []) ]\n+contextConstraints de@(DDExpr (CtxRuleRInspect rl _) _) = do\n+    addConstraint =<< tvarTypeOfExpr de <~~~~ teTuple []\n+    addConstraint =<< tvarTypeOfVar WeightVar <==== typeToTExpr (tUser wEIGHT_TYPE [])\n+    if ruleIsRecursive ?d rl\n+       then addConstraint =<< tvarTypeOfVar (TSVar rl) <==== typeToTExpr (tUser nESTED_TS_TYPE [])\n+       else addConstraint =<< tvarTypeOfVar (TSVar rl) <==== typeToTExpr (tUser ePOCH_TYPE [])\n \n contextConstraints (DDExpr ctx _) =\n     error $ \"contextConstraints called in unexpected context \" ++ show ctx\n \n {- Encode type constraints for an expression. -}\n \n-exprConstraints :: (?d::DatalogProgram) => DDExpr -> [Constraint]\n+exprConstraints :: (?d::DatalogProgram) => DDExpr -> GeneratorMonad ()\n exprConstraints (DDExpr ctx e) =\n-    execState (exprTraverseCtxM exprConstraints' ctx e) []\n+    exprTraverseCtxM exprConstraints' ctx e\n \n-exprConstraints' :: (?d::DatalogProgram) => ECtx -> ENode -> State [Constraint] ()\n+exprConstraints' :: (?d::DatalogProgram) => ECtx -> ENode -> GeneratorMonad ()\n exprConstraints' ctx e = do\n     let ddexpr = DDExpr ctx $ E e\n-    let constr = exprConstraints_ ddexpr\n-    modify (++ constr)\n+    exprConstraints_ ddexpr\n \n -- Variable reference expression has the same type as the variable.\n-exprConstraints_ :: (?d::DatalogProgram) => DDExpr -> [Constraint]\n-exprConstraints_ de@(DDExpr ctx (E (EVar _ v))) =\n-    [TETypeOfExpr de === TETypeOfVar (getVar ?d ctx v)]\n+exprConstraints_ :: (?d::DatalogProgram) => DDExpr -> GeneratorMonad ()\n+exprConstraints_ de@(DDExpr ctx e@(E (EVar _ v))) = do\n+    let var = case lookupVar ?d ctx v of\n+                   Nothing -> case exprVarDecls ?d ctx e of\n+                                   [var'] -> var'\n+                                   _      -> error $ \"Unknown variable '\" ++ v ++ \"' in \" ++ show ctx\n+                   Just var' -> var'\n+    addConstraint =<< tvarTypeOfExpr de <====> teTypeOfVar var\n \n -- Boolean literal.\n exprConstraints_ de@(DDExpr _ (E EBool{})) =\n-    [deIsBool de]\n+    addConstraint =<< tvarTypeOfExpr de <==== TEBool\n \n -- String literal.\n exprConstraints_ de@(DDExpr _ (E EString{})) =\n-    [deIsString de]\n+    addConstraint =<< tvarTypeOfExpr de <==== TEString\n \n -- Unsigned bitvector literal.\n exprConstraints_ de@(DDExpr _ (E EBit{..})) =\n-    [TETypeOfExpr de === TEBit (IConst exprWidth)]\n+    addConstraint =<< tvarTypeOfExpr de <==== TEBit (IConst exprWidth)\n \n -- Signed bitvector literal.\n exprConstraints_ de@(DDExpr _ (E ESigned{..})) =\n-    [TETypeOfExpr de === TESigned (IConst exprWidth)]\n+    addConstraint =<< tvarTypeOfExpr de <==== TESigned (IConst exprWidth)\n \n -- Integer expression with unspecified width can be a signed or unsigned\n -- bitvector or a bigint.  All of these cases are captured by 'deIsInt'.\n-exprConstraints_ de@(DDExpr _ (E EInt{})) =\n-    [deIsInt de]\n+exprConstraints_ de@(DDExpr _ (E EInt{..})) = do\n+    dev <- tvarTypeOfExpr de\n+    -- Default to bit<64/128>, signed<64/128>, or bigint based on the sign and value of\n+    -- the integer literal.\n+    let def = if exprIVal >= 0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fed5a9f6f42e8a4563c8f2339cf1d4c024d92d9a"}, "originalPosition": 737}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU1NTQ5NA==", "bodyText": "it would, but it's expensive.", "url": "https://github.com/vmware/differential-datalog/pull/695#discussion_r450555494", "createdAt": "2020-07-07T01:04:00Z", "author": {"login": "ryzhyk"}, "path": "src/Language/DifferentialDatalog/TypeInference.hs", "diffHunk": "@@ -321,87 +445,113 @@ contextConstraints de@(DDExpr (CtxRuleRCond rl i) _) | rhsIsFilterCondition $ ru\n -- (|v1|,...,|vn|)=K,\n -- |e| = V,\n -- |v| = T\n-contextConstraints de@(DDExpr ctx@(CtxRuleRAggregate rl i) _) =\n-    [ teTuple (map (\\v -> TETypeOfVar (getVar ?d ctx v)) rhsGroupBy) === typeToTExpr' ctx ktype\n-    , TETypeOfExpr de === typeToTExpr' ctx vtype\n-    , TETypeOfVar (AggregateVar rl i) === typeToTExpr' ctx ret_type]\n+contextConstraints de@(DDExpr (CtxRuleRAggregate rl i) _) = do\n+    addConstraint =<< tvarTypeOfExpr de <~~~~> typeToTExpr' de vtype\n+    addConstraint =<< tvarTypeOfVar (AggregateVar rl i) <====> typeToTExpr' de ret_type\n     where\n     RHSAggregate{..} = ruleRHS rl !! i\n     Function{funcArgs = [grp_type], funcType = ret_type} = getFunc ?d rhsAggFunc\n-    TOpaque{typeArgs = [ktype, vtype]} = typ' ?d grp_type\n+    TOpaque{typeArgs = [_, vtype]} = typ' ?d grp_type\n+\n+contextConstraints de@(DDExpr ctx@(CtxRuleRGroupBy rl i) _) =\n+    addConstraint =<< tvarTypeOfExpr (DDExpr ctx rhsGroupBy) <~~~~> typeToTExpr' de ktype\n+    where\n+    RHSAggregate{..} = ruleRHS rl !! i\n+    Function{funcArgs = [grp_type]} = getFunc ?d rhsAggFunc\n+    TOpaque{typeArgs = [ktype, _]} = typ' ?d grp_type\n+\n \n -- When evaluating 'var v = FlatMap(e)'\n -- the following type constraints are added:\n -- |v| = iterator_type(|e|)\n contextConstraints de@(DDExpr (CtxRuleRFlatMap rl i) _) =\n-    [deIsSet de $ TETypeOfVar (FlatMapVar rl i)]\n+    addConstraint =<< deIsIterable de =<< tvarTypeOfVar (FlatMapVar rl i)\n \n -- When evaluating expression e in an Inspect clause of a rule:\n -- |e| = Tuple0, |var ddlog_weight| = Bit 64, |var ddlog_iter| = ....\n-contextConstraints de@(DDExpr (CtxRuleRInspect rl _) _) =\n-    [ TETypeOfExpr de === TETuple (Just 0) M.empty\n-    , TETypeOfVar WeightVar === typeToTExpr (tUser wEIGHT_TYPE [])\n-    , if ruleIsRecursive ?d rl\n-         then TETypeOfVar (TSVar rl) === typeToTExpr (tUser nESTED_TS_TYPE [])\n-         else TETypeOfVar (TSVar rl) === typeToTExpr (tUser ePOCH_TYPE []) ]\n+contextConstraints de@(DDExpr (CtxRuleRInspect rl _) _) = do\n+    addConstraint =<< tvarTypeOfExpr de <~~~~ teTuple []\n+    addConstraint =<< tvarTypeOfVar WeightVar <==== typeToTExpr (tUser wEIGHT_TYPE [])\n+    if ruleIsRecursive ?d rl\n+       then addConstraint =<< tvarTypeOfVar (TSVar rl) <==== typeToTExpr (tUser nESTED_TS_TYPE [])\n+       else addConstraint =<< tvarTypeOfVar (TSVar rl) <==== typeToTExpr (tUser ePOCH_TYPE [])\n \n contextConstraints (DDExpr ctx _) =\n     error $ \"contextConstraints called in unexpected context \" ++ show ctx\n \n {- Encode type constraints for an expression. -}\n \n-exprConstraints :: (?d::DatalogProgram) => DDExpr -> [Constraint]\n+exprConstraints :: (?d::DatalogProgram) => DDExpr -> GeneratorMonad ()\n exprConstraints (DDExpr ctx e) =\n-    execState (exprTraverseCtxM exprConstraints' ctx e) []\n+    exprTraverseCtxM exprConstraints' ctx e\n \n-exprConstraints' :: (?d::DatalogProgram) => ECtx -> ENode -> State [Constraint] ()\n+exprConstraints' :: (?d::DatalogProgram) => ECtx -> ENode -> GeneratorMonad ()\n exprConstraints' ctx e = do\n     let ddexpr = DDExpr ctx $ E e\n-    let constr = exprConstraints_ ddexpr\n-    modify (++ constr)\n+    exprConstraints_ ddexpr\n \n -- Variable reference expression has the same type as the variable.\n-exprConstraints_ :: (?d::DatalogProgram) => DDExpr -> [Constraint]\n-exprConstraints_ de@(DDExpr ctx (E (EVar _ v))) =\n-    [TETypeOfExpr de === TETypeOfVar (getVar ?d ctx v)]\n+exprConstraints_ :: (?d::DatalogProgram) => DDExpr -> GeneratorMonad ()\n+exprConstraints_ de@(DDExpr ctx e@(E (EVar _ v))) = do\n+    let var = case lookupVar ?d ctx v of\n+                   Nothing -> case exprVarDecls ?d ctx e of\n+                                   [var'] -> var'\n+                                   _      -> error $ \"Unknown variable '\" ++ v ++ \"' in \" ++ show ctx\n+                   Just var' -> var'\n+    addConstraint =<< tvarTypeOfExpr de <====> teTypeOfVar var\n \n -- Boolean literal.\n exprConstraints_ de@(DDExpr _ (E EBool{})) =\n-    [deIsBool de]\n+    addConstraint =<< tvarTypeOfExpr de <==== TEBool\n \n -- String literal.\n exprConstraints_ de@(DDExpr _ (E EString{})) =\n-    [deIsString de]\n+    addConstraint =<< tvarTypeOfExpr de <==== TEString\n \n -- Unsigned bitvector literal.\n exprConstraints_ de@(DDExpr _ (E EBit{..})) =\n-    [TETypeOfExpr de === TEBit (IConst exprWidth)]\n+    addConstraint =<< tvarTypeOfExpr de <==== TEBit (IConst exprWidth)\n \n -- Signed bitvector literal.\n exprConstraints_ de@(DDExpr _ (E ESigned{..})) =\n-    [TETypeOfExpr de === TESigned (IConst exprWidth)]\n+    addConstraint =<< tvarTypeOfExpr de <==== TESigned (IConst exprWidth)\n \n -- Integer expression with unspecified width can be a signed or unsigned\n -- bitvector or a bigint.  All of these cases are captured by 'deIsInt'.\n-exprConstraints_ de@(DDExpr _ (E EInt{})) =\n-    [deIsInt de]\n+exprConstraints_ de@(DDExpr _ (E EInt{..})) = do\n+    dev <- tvarTypeOfExpr de\n+    -- Default to bit<64/128>, signed<64/128>, or bigint based on the sign and value of\n+    -- the integer literal.\n+    let def = if exprIVal >= 0", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDUzMTc2NQ=="}, "originalCommit": {"oid": "fed5a9f6f42e8a4563c8f2339cf1d4c024d92d9a"}, "originalPosition": 737}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwODg4MjQ1OnYy", "diffSide": "RIGHT", "path": "src/Language/DifferentialDatalog/TypeInference.hs", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMzozNTo1OFrOGtqUVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMzozNTo1OFrOGtqUVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDUzMjQzNw==", "bodyText": "what is \"guarded\"?", "url": "https://github.com/vmware/differential-datalog/pull/695#discussion_r450532437", "createdAt": "2020-07-06T23:35:58Z", "author": {"login": "mbudiu-vmw"}, "path": "src/Language/DifferentialDatalog/TypeInference.hs", "diffHunk": "@@ -411,11 +561,25 @@ exprConstraints_ de@(DDExpr ctx (E e@EApply{..})) =\n -- 'is_S1 |e1| and |e| = |e1.f|\n --  or .. or\n --  is_Sn |e1| and |e| = |e1.f|'\n-exprConstraints_ de@(DDExpr ctx (E e@EField{..})) =\n-    cdisj\n-    $ map (\\TypeDef{tdefType = Just t,..} ->\n-            deIsStruct_ estruct tdefName : [PEq (TETypeOfExpr de) (typeToTExpr' ctx' (typ $ structGetField t exprField))])\n-      candidates\n+--\n+-- In addition, 'e1' can be a shared reference to a struct:\n+-- for each shared reference type 'Ref_i' and each struct 'S_j', add a disjunct:\n+-- '|e1| = Ref_i<S_j> and |e| = |S_j.f|'\n+\n+exprConstraints_ de@(DDExpr ctx (E e@EField{..})) = do\n+    dv <- tvarTypeOfExpr de\n+    let expand t' = case teDeref t' of\n+                         te@(TEUser n _) | elem n (map name candidates) -> do\n+                            let t'' = fromJust $ tdefType $ getType ?d n\n+                            let guarded = structFieldGuarded t'' exprField\n+                            check ?d (not guarded) (pos e) $ \"Access to guarded field \\\"\" ++ exprField ++ \"\\\"\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fed5a9f6f42e8a4563c8f2339cf1d4c024d92d9a"}, "originalPosition": 796}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwODg4NTEzOnYy", "diffSide": "RIGHT", "path": "src/Language/DifferentialDatalog/TypeInference.hs", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMzozNzoyMFrOGtqV1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMzozNzoyMFrOGtqV1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDUzMjgyMQ==", "bodyText": "in the comment above you are probably missing h >= l", "url": "https://github.com/vmware/differential-datalog/pull/695#discussion_r450532821", "createdAt": "2020-07-06T23:37:20Z", "author": {"login": "mbudiu-vmw"}, "path": "src/Language/DifferentialDatalog/TypeInference.hs", "diffHunk": "@@ -449,17 +627,18 @@ exprConstraints_ de@(DDExpr ctx (E e@EStruct{..})) =\n --\n -- '|e| = (|e1|,...,|en|)'.\n exprConstraints_ de@(DDExpr ctx (E e@ETuple{..})) =\n-    [TETypeOfExpr de === TETuple (Just $ length exprTupleFields) (M.fromList $ mapIdx (\\e' i -> (i, TETypeOfExpr (DDExpr (CtxTuple e ctx i) e'))) exprTupleFields)]\n+    addConstraint =<< tvarTypeOfExpr de <====>\n+                      (teTuple <$> mapIdxM (\\e' i -> teTypeOfExpr (DDExpr (CtxTuple e ctx i) e')) exprTupleFields)\n \n -- Bit slice 'e1[h:l]'\n --\n -- 'is_Bit(|e1|) and |e|=Bit (h-l+1)'\n --\n -- TODO: additional constraint 'bitWidth |e1| >= h-l+1 and'\n -- should be enforced outside of the type inference engine.\n-exprConstraints_ de@(DDExpr ctx (E e@ESlice{..})) =\n-    [ TETypeOfExpr de === TEBit (IConst w)\n-    , deIsBit ebits]\n+exprConstraints_ de@(DDExpr ctx (E e@ESlice{..})) = do", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fed5a9f6f42e8a4563c8f2339cf1d4c024d92d9a"}, "originalPosition": 869}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4782, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}