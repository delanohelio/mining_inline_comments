{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc1NTgxNDEz", "number": 756, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQyMjowODozMFrOEd5sEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQyMzowMjoxOFrOEd6QDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5Nzg5MzI5OnYy", "diffSide": "RIGHT", "path": "lib/std.dl", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQyMjowODozMFrOHJVsMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOVQwMDoxODo0MFrOHJXXRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU1NDYwOQ==", "bodyText": "how about returning bool to indicate whether the move happened?", "url": "https://github.com/vmware/differential-datalog/pull/756#discussion_r479554609", "createdAt": "2020-08-28T22:08:30Z", "author": {"login": "mbudiu-vmw"}, "path": "lib/std.dl", "diffHunk": "@@ -497,14 +497,32 @@ function to_set(s: Vec<'A>): Set<'A> {\n     vec_to_set(s)\n }\n \n-function sort(v: mut Vec<'X>): () {\n+function sort(v: mut Vec<'X>) {\n     vec_sort(v)\n }\n \n function sort_imm(v: Vec<'X>): Vec<'X> {\n     vec_sort_imm(v)\n }\n \n+/* Resize vector.  If `new_size` is greater than `v.len()`, then\n+ * all new slots are filled with `value`. */\n+function resize(v: mut Vec<'X>, new_len: usize, value: 'X) {\n+    vec_resize(v, new_len, value)\n+}\n+\n+/* Swap value at index `idx` for `value`.\n+ * Stores the old value at this index in `value` unless `idx` exceeds\n+ * the size of the vector (in which case the vector remains unmodified). */\n+function swap_nth(v: mut Vec<'X>, idx: usize, value: mut 'X) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9498f4299109388448ed77798f5a0a5c995975a7"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU4MjAyMw==", "bodyText": "good idea", "url": "https://github.com/vmware/differential-datalog/pull/756#discussion_r479582023", "createdAt": "2020-08-29T00:18:40Z", "author": {"login": "ryzhyk"}, "path": "lib/std.dl", "diffHunk": "@@ -497,14 +497,32 @@ function to_set(s: Vec<'A>): Set<'A> {\n     vec_to_set(s)\n }\n \n-function sort(v: mut Vec<'X>): () {\n+function sort(v: mut Vec<'X>) {\n     vec_sort(v)\n }\n \n function sort_imm(v: Vec<'X>): Vec<'X> {\n     vec_sort_imm(v)\n }\n \n+/* Resize vector.  If `new_size` is greater than `v.len()`, then\n+ * all new slots are filled with `value`. */\n+function resize(v: mut Vec<'X>, new_len: usize, value: 'X) {\n+    vec_resize(v, new_len, value)\n+}\n+\n+/* Swap value at index `idx` for `value`.\n+ * Stores the old value at this index in `value` unless `idx` exceeds\n+ * the size of the vector (in which case the vector remains unmodified). */\n+function swap_nth(v: mut Vec<'X>, idx: usize, value: mut 'X) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU1NDYwOQ=="}, "originalCommit": {"oid": "9498f4299109388448ed77798f5a0a5c995975a7"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5NzkyOTQ2OnYy", "diffSide": "RIGHT", "path": "src/Language/DifferentialDatalog/NS.hs", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQyMjoyODowOVrOHJWAzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQyMjoyODowOVrOHJWAzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU1OTg4Ng==", "bodyText": "typo in comment", "url": "https://github.com/vmware/differential-datalog/pull/756#discussion_r479559886", "createdAt": "2020-08-28T22:28:09Z", "author": {"login": "mbudiu-vmw"}, "path": "src/Language/DifferentialDatalog/NS.hs", "diffHunk": "@@ -142,12 +142,24 @@ getRelation d n = fromJust $ lookupRelation d n\n arg2v :: Function -> FuncArg -> Var\n arg2v f a = ArgVar f (name a)\n \n+-- All variables visible in 'ctx'.  This function is safe to call before\n+-- type checking.\n ctxAllVars :: DatalogProgram -> ECtx -> [Var]\n-ctxAllVars d ctx = let (lvs, rvs) = ctxVars d ctx in lvs ++ rvs\n+ctxAllVars d ctx = let (lvs, rvs) = ctxVars' d ctx False in lvs ++ rvs\n \n--- All variables available in the scope: (l-vars, read-only vars).\n+-- All variables visible in the 'ctx', classified into (writable, read-only\n+-- varables).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9498f4299109388448ed77798f5a0a5c995975a7"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5NzkzOTMxOnYy", "diffSide": "RIGHT", "path": "src/Language/DifferentialDatalog/NS.hs", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQyMjozMzo1NlrOHJWGfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOVQwMDoyNjo0OVrOHJXcCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU2MTM0MQ==", "bodyText": "if it missclassifies what are the consequences? I don't understand what the caller is supposed to do in this case with the result. You must have some contract about it, which is not stated.", "url": "https://github.com/vmware/differential-datalog/pull/756#discussion_r479561341", "createdAt": "2020-08-28T22:33:56Z", "author": {"login": "mbudiu-vmw"}, "path": "src/Language/DifferentialDatalog/NS.hs", "diffHunk": "@@ -142,12 +142,24 @@ getRelation d n = fromJust $ lookupRelation d n\n arg2v :: Function -> FuncArg -> Var\n arg2v f a = ArgVar f (name a)\n \n+-- All variables visible in 'ctx'.  This function is safe to call before\n+-- type checking.\n ctxAllVars :: DatalogProgram -> ECtx -> [Var]\n-ctxAllVars d ctx = let (lvs, rvs) = ctxVars d ctx in lvs ++ rvs\n+ctxAllVars d ctx = let (lvs, rvs) = ctxVars' d ctx False in lvs ++ rvs\n \n--- All variables available in the scope: (l-vars, read-only vars).\n+-- All variables visible in the 'ctx', classified into (writable, read-only\n+-- varables).\n+-- This function is _unsafe_ to use before type inference.\n ctxVars :: DatalogProgram -> ECtx -> ([Var], [Var])\n-ctxVars d ctx =\n+ctxVars d ctx = ctxVars' d ctx True\n+\n+-- All variables available in the scope: (l-vars, read-only vars).\n+--\n+-- The 'with_types' flag is true if 'd' contains enough type information\n+-- to determine variable types (i.e., it has been through type inference).\n+-- When false, `ctxVars` may misclassify", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9498f4299109388448ed77798f5a0a5c995975a7"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU4MzI0MA==", "bodyText": "I clarified the contract.  This function is private to the module and is only called in a safe way there.", "url": "https://github.com/vmware/differential-datalog/pull/756#discussion_r479583240", "createdAt": "2020-08-29T00:26:49Z", "author": {"login": "ryzhyk"}, "path": "src/Language/DifferentialDatalog/NS.hs", "diffHunk": "@@ -142,12 +142,24 @@ getRelation d n = fromJust $ lookupRelation d n\n arg2v :: Function -> FuncArg -> Var\n arg2v f a = ArgVar f (name a)\n \n+-- All variables visible in 'ctx'.  This function is safe to call before\n+-- type checking.\n ctxAllVars :: DatalogProgram -> ECtx -> [Var]\n-ctxAllVars d ctx = let (lvs, rvs) = ctxVars d ctx in lvs ++ rvs\n+ctxAllVars d ctx = let (lvs, rvs) = ctxVars' d ctx False in lvs ++ rvs\n \n--- All variables available in the scope: (l-vars, read-only vars).\n+-- All variables visible in the 'ctx', classified into (writable, read-only\n+-- varables).\n+-- This function is _unsafe_ to use before type inference.\n ctxVars :: DatalogProgram -> ECtx -> ([Var], [Var])\n-ctxVars d ctx =\n+ctxVars d ctx = ctxVars' d ctx True\n+\n+-- All variables available in the scope: (l-vars, read-only vars).\n+--\n+-- The 'with_types' flag is true if 'd' contains enough type information\n+-- to determine variable types (i.e., it has been through type inference).\n+-- When false, `ctxVars` may misclassify", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU2MTM0MQ=="}, "originalCommit": {"oid": "9498f4299109388448ed77798f5a0a5c995975a7"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5Nzk0MzA2OnYy", "diffSide": "RIGHT", "path": "src/Language/DifferentialDatalog/NS.hs", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQyMjozNjowOFrOHJWImQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQyMjozNjowOFrOHJWImQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU2MTg4MQ==", "bodyText": "I guess that your contract is that you will return a conservative approximation of the writability - some writable variables may be misclassified as readable. But you still get all of them.", "url": "https://github.com/vmware/differential-datalog/pull/756#discussion_r479561881", "createdAt": "2020-08-28T22:36:08Z", "author": {"login": "mbudiu-vmw"}, "path": "src/Language/DifferentialDatalog/NS.hs", "diffHunk": "@@ -161,33 +173,42 @@ ctxVars d ctx =\n          CtxRuleRGroupBy rl i     -> ([], ruleRHSVars d rl i)\n          CtxKey rel@Relation{..}  -> ([], [KeyVar rel])\n          CtxIndex idx@Index{..}   -> ([], map (\\v -> (IdxVar idx $ name v)) idxVars)\n-         CtxApply _ _ _           -> ([], plvars ++ prvars)\n+         CtxApply _ _ _           -> (plvars, prvars)\n          CtxField _ _             -> (plvars, prvars)\n          CtxTupField _ _          -> (plvars, prvars)\n          CtxStruct _ _ _          -> (plvars, prvars)\n          CtxTuple _ _ _           -> (plvars, prvars)\n          CtxSlice  _ _            -> ([], plvars ++ prvars)\n-         CtxMatchExpr _ _         -> ([], plvars ++ prvars)\n+         CtxMatchExpr _ _         -> (plvars, prvars)\n          CtxMatchPat _ _ _        -> ([], plvars ++ prvars)\n          CtxMatchVal e pctx i     -> let patternVars = exprVarDecls d (CtxMatchPat e pctx i)\n-                                                       $ fst $ (exprCases e) !! i in\n-                                     {-if exprIsVarOrFieldLVal d pctx $ exprMatchExpr e\n-                                        then (plvars ++ patternVars, prvars)\n-                                        else -}\n-                                     (plvars, patternVars ++ prvars)\n+                                                       $ fst $ (exprCases e) !! i\n+                                         patternVarNames = map name patternVars\n+                                         plvars' = filter (\\v -> notElem (name v) patternVarNames) plvars\n+                                         prvars' = filter (\\v -> notElem (name v) patternVarNames) prvars in\n+                                     -- 'exprIsVarOrFieldLVal' needs to determine the type of 'e' and\n+                                     -- may crash if called before type inference.\n+                                     if with_types && (exprIsVarOrFieldLVal d pctx $ exprMatchExpr e)\n+                                        then (patternVars ++ plvars', prvars')", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9498f4299109388448ed77798f5a0a5c995975a7"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5Nzk0NTcwOnYy", "diffSide": "RIGHT", "path": "src/Language/DifferentialDatalog/NS.hs", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQyMjozNzo1NVrOHJWKEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQyMjozNzo1NVrOHJWKEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU2MjI1Ng==", "bodyText": "this stuff should probably be documented.", "url": "https://github.com/vmware/differential-datalog/pull/756#discussion_r479562256", "createdAt": "2020-08-28T22:37:55Z", "author": {"login": "mbudiu-vmw"}, "path": "src/Language/DifferentialDatalog/NS.hs", "diffHunk": "@@ -161,33 +173,42 @@ ctxVars d ctx =\n          CtxRuleRGroupBy rl i     -> ([], ruleRHSVars d rl i)\n          CtxKey rel@Relation{..}  -> ([], [KeyVar rel])\n          CtxIndex idx@Index{..}   -> ([], map (\\v -> (IdxVar idx $ name v)) idxVars)\n-         CtxApply _ _ _           -> ([], plvars ++ prvars)\n+         CtxApply _ _ _           -> (plvars, prvars)\n          CtxField _ _             -> (plvars, prvars)\n          CtxTupField _ _          -> (plvars, prvars)\n          CtxStruct _ _ _          -> (plvars, prvars)\n          CtxTuple _ _ _           -> (plvars, prvars)\n          CtxSlice  _ _            -> ([], plvars ++ prvars)\n-         CtxMatchExpr _ _         -> ([], plvars ++ prvars)\n+         CtxMatchExpr _ _         -> (plvars, prvars)\n          CtxMatchPat _ _ _        -> ([], plvars ++ prvars)\n          CtxMatchVal e pctx i     -> let patternVars = exprVarDecls d (CtxMatchPat e pctx i)\n-                                                       $ fst $ (exprCases e) !! i in\n-                                     {-if exprIsVarOrFieldLVal d pctx $ exprMatchExpr e\n-                                        then (plvars ++ patternVars, prvars)\n-                                        else -}\n-                                     (plvars, patternVars ++ prvars)\n+                                                       $ fst $ (exprCases e) !! i\n+                                         patternVarNames = map name patternVars\n+                                         plvars' = filter (\\v -> notElem (name v) patternVarNames) plvars\n+                                         prvars' = filter (\\v -> notElem (name v) patternVarNames) prvars in\n+                                     -- 'exprIsVarOrFieldLVal' needs to determine the type of 'e' and\n+                                     -- may crash if called before type inference.\n+                                     if with_types && (exprIsVarOrFieldLVal d pctx $ exprMatchExpr e)\n+                                        then (patternVars ++ plvars', prvars')\n+                                        else (plvars', patternVars ++ prvars')\n          CtxSeq1 _ _              -> (plvars, prvars)\n          CtxSeq2 e pctx           -> let seq1vars = exprVarDecls d (CtxSeq1 e pctx) $ exprLeft e\n-                                     in (plvars ++ seq1vars, prvars)\n+                                         varNames = map name seq1vars\n+                                         plvars' = filter (\\v -> notElem (name v) varNames) plvars\n+                                         prvars' = filter (\\v -> notElem (name v) varNames) prvars\n+                                     in (plvars' ++ seq1vars, prvars')\n          CtxITEIf _ _             -> ([], plvars ++ prvars)\n          CtxITEThen _ _           -> (plvars, prvars)\n          CtxITEElse _ _           -> (plvars, prvars)\n          CtxForIter _ _           -> (plvars, prvars)\n          CtxForBody e@EFor{..} pctx -> let loopvar = ForVar pctx e\n+                                           prvars' = (filter ((/= name loopvar) . name) prvars)\n+                                           iterVarNames = map name $ exprVars d (CtxForIter e pctx) exprIter\n                                            -- variables that occur in the iterator expression cannot\n                                            -- be modified inside the loop\n-                                           plvars_not_iter = filter (\\v -> notElem v $ exprVars d (CtxForIter e pctx) exprIter) plvars\n-                                           plvars_iter = filter (\\v -> elem v $ exprVars d (CtxForIter e pctx) exprIter) plvars\n-                                       in (plvars_not_iter, prvars ++ plvars_iter ++ [loopvar])\n+                                           plvars_not_iter = filter (\\v -> name v /= (name loopvar) && notElem (name v) iterVarNames) plvars", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9498f4299109388448ed77798f5a0a5c995975a7"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5Nzk0NzI4OnYy", "diffSide": "RIGHT", "path": "src/Language/DifferentialDatalog/Parse.hs", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQyMjozODo1MVrOHJWK9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOVQwMDoyNzo0M1rOHJXcvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU2MjQ4NQ==", "bodyText": "how about giving a warning that this syntax is deprecated?\nwe should consider removing it in the future.", "url": "https://github.com/vmware/differential-datalog/pull/756#discussion_r479562485", "createdAt": "2020-08-28T22:38:51Z", "author": {"login": "mbudiu-vmw"}, "path": "src/Language/DifferentialDatalog/Parse.hs", "diffHunk": "@@ -297,13 +297,13 @@ typeDef = (TypeDef nopos []) <$ reserved \"typedef\" <*> typeIdent <*>\n func = (Function nopos [] <$  (try $ reserved \"extern\" *> reserved \"function\")\n                          <*> funcIdent\n                          <*> (parens $ commaSep farg)\n-                         <*> (colon *> typeSpecSimple)\n+                         <*> (option (TTuple nopos []) (colon *> typeSpecSimple))\n                          <*> (return Nothing))\n        <|>\n        (Function nopos [] <$  reserved \"function\"\n                          <*> funcIdent\n                          <*> (parens $ commaSep farg)\n-                         <*> (colon *> typeSpecSimple)\n+                         <*> (option (TTuple nopos []) (colon *> typeSpecSimple))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9498f4299109388448ed77798f5a0a5c995975a7"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU4MzQyMA==", "bodyText": "That's the right thing to do, but we don't have the infrastructure for warning atm.  In particular, it should be possible to deprecate warnings or convert them to errors.", "url": "https://github.com/vmware/differential-datalog/pull/756#discussion_r479583420", "createdAt": "2020-08-29T00:27:43Z", "author": {"login": "ryzhyk"}, "path": "src/Language/DifferentialDatalog/Parse.hs", "diffHunk": "@@ -297,13 +297,13 @@ typeDef = (TypeDef nopos []) <$ reserved \"typedef\" <*> typeIdent <*>\n func = (Function nopos [] <$  (try $ reserved \"extern\" *> reserved \"function\")\n                          <*> funcIdent\n                          <*> (parens $ commaSep farg)\n-                         <*> (colon *> typeSpecSimple)\n+                         <*> (option (TTuple nopos []) (colon *> typeSpecSimple))\n                          <*> (return Nothing))\n        <|>\n        (Function nopos [] <$  reserved \"function\"\n                          <*> funcIdent\n                          <*> (parens $ commaSep farg)\n-                         <*> (colon *> typeSpecSimple)\n+                         <*> (option (TTuple nopos []) (colon *> typeSpecSimple))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU2MjQ4NQ=="}, "originalCommit": {"oid": "9498f4299109388448ed77798f5a0a5c995975a7"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5Nzk1MjA0OnYy", "diffSide": "RIGHT", "path": "test/datalog_tests/json_test.dl", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQyMjo0MTozOFrOHJWNsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOVQwMDoyODo0MVrOHJXdWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU2MzE4NA==", "bodyText": "How about adding a function to convert a path like this into a vec of ptrs?\nWith a heuristic that numbers become indexes?", "url": "https://github.com/vmware/differential-datalog/pull/756#discussion_r479563184", "createdAt": "2020-08-28T22:41:38Z", "author": {"login": "mbudiu-vmw"}, "path": "test/datalog_tests/json_test.dl", "diffHunk": "@@ -204,3 +204,34 @@ JsonTestValue(\"wrapped \" ++ wenum2(),\n          (from_json_string(wenum2()): Result<WrappedEnum, string>).to_json_value().unwrap_or_default().to_json_string_or_default()).\n JsonTestValue(\"wrapped \" ++ wenum3(),\n          (from_json_string(wenum3()): Result<WrappedEnum, string>).to_json_value().unwrap_or_default().to_json_string_or_default()).\n+\n+/* JsonPtr test. */\n+\n+JsonTest(\"set_by_ptr test\", mutilate_jval().to_json_string_or_default()).\n+\n+function mutilate_jval(): JsonValue {\n+    var jval: JsonValue = from_json_string(nestedStruct1()).unwrap_or_default();\n+    // replace existing field.\n+    jval.set_by_ptr([JKeyPtr{i\"nested\"}, JKeyPtr{i\"x\"}], from_json_string(boolStruct2()).unwrap_or_default());\n+    // create new field.\n+    jval.set_by_ptr([JKeyPtr{i\"nested\"}, JKeyPtr{i\"y\"}], from_json_string(boolStruct2()).unwrap_or_default());\n+    // replace z with array.\n+    jval.set_by_ptr([JKeyPtr{i\"nested\"}, JKeyPtr{i\"z\"}], JsonArray{[from_json_string(wenum1()).unwrap_or_default(), from_json_string(wenum2()).unwrap_or_default()]});\n+    // replace array element.\n+    jval.set_by_ptr([JKeyPtr{i\"nested\"}, JKeyPtr{i\"z\"}, JIdxPtr{1}], from_json_string(wenum3()).unwrap_or_default());\n+    // replace value inside array.\n+    jval.set_by_ptr([JKeyPtr{i\"nested\"}, JKeyPtr{i\"z\"}, JIdxPtr{1}, JKeyPtr{i\"b\"}], from_json_string(struct_with_map1()).unwrap_or_default());\n+    // extend array.\n+    jval.set_by_ptr([JKeyPtr{i\"nested\"}, JKeyPtr{i\"z\"}, JIdxPtr{10}, JKeyPtr{i\"b\"}], from_json_string(struct_with_map1()).unwrap_or_default());\n+    // convert null into map\n+    jval.set_by_ptr([JKeyPtr{i\"nested\"}, JKeyPtr{i\"z\"}, JIdxPtr{9}, JKeyPtr{i\"q\"}], from_json_string(struct_with_map1()).unwrap_or_default());\n+\n+    // this should be a no-op.\n+    jval.set_by_ptr([JKeyPtr{i\"t\"}, JKeyPtr{i\"z\"}], from_json_string(struct_with_map1()).unwrap_or_default());\n+\n+    jval\n+}\n+\n+JsonTest(\"get_by_ptr(nested/z/10/b)\", mutilate_jval().get_by_ptr([JKeyPtr{i\"nested\"}, JKeyPtr{i\"z\"}, JIdxPtr{10}, JKeyPtr{i\"b\"}]).to_json_string().unwrap_or_default()).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9498f4299109388448ed77798f5a0a5c995975a7"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU4MzU3Nw==", "bodyText": "The only use-case I have uses non-standard syntax for pointers, so I am taking the lazy approach here.", "url": "https://github.com/vmware/differential-datalog/pull/756#discussion_r479583577", "createdAt": "2020-08-29T00:28:41Z", "author": {"login": "ryzhyk"}, "path": "test/datalog_tests/json_test.dl", "diffHunk": "@@ -204,3 +204,34 @@ JsonTestValue(\"wrapped \" ++ wenum2(),\n          (from_json_string(wenum2()): Result<WrappedEnum, string>).to_json_value().unwrap_or_default().to_json_string_or_default()).\n JsonTestValue(\"wrapped \" ++ wenum3(),\n          (from_json_string(wenum3()): Result<WrappedEnum, string>).to_json_value().unwrap_or_default().to_json_string_or_default()).\n+\n+/* JsonPtr test. */\n+\n+JsonTest(\"set_by_ptr test\", mutilate_jval().to_json_string_or_default()).\n+\n+function mutilate_jval(): JsonValue {\n+    var jval: JsonValue = from_json_string(nestedStruct1()).unwrap_or_default();\n+    // replace existing field.\n+    jval.set_by_ptr([JKeyPtr{i\"nested\"}, JKeyPtr{i\"x\"}], from_json_string(boolStruct2()).unwrap_or_default());\n+    // create new field.\n+    jval.set_by_ptr([JKeyPtr{i\"nested\"}, JKeyPtr{i\"y\"}], from_json_string(boolStruct2()).unwrap_or_default());\n+    // replace z with array.\n+    jval.set_by_ptr([JKeyPtr{i\"nested\"}, JKeyPtr{i\"z\"}], JsonArray{[from_json_string(wenum1()).unwrap_or_default(), from_json_string(wenum2()).unwrap_or_default()]});\n+    // replace array element.\n+    jval.set_by_ptr([JKeyPtr{i\"nested\"}, JKeyPtr{i\"z\"}, JIdxPtr{1}], from_json_string(wenum3()).unwrap_or_default());\n+    // replace value inside array.\n+    jval.set_by_ptr([JKeyPtr{i\"nested\"}, JKeyPtr{i\"z\"}, JIdxPtr{1}, JKeyPtr{i\"b\"}], from_json_string(struct_with_map1()).unwrap_or_default());\n+    // extend array.\n+    jval.set_by_ptr([JKeyPtr{i\"nested\"}, JKeyPtr{i\"z\"}, JIdxPtr{10}, JKeyPtr{i\"b\"}], from_json_string(struct_with_map1()).unwrap_or_default());\n+    // convert null into map\n+    jval.set_by_ptr([JKeyPtr{i\"nested\"}, JKeyPtr{i\"z\"}, JIdxPtr{9}, JKeyPtr{i\"q\"}], from_json_string(struct_with_map1()).unwrap_or_default());\n+\n+    // this should be a no-op.\n+    jval.set_by_ptr([JKeyPtr{i\"t\"}, JKeyPtr{i\"z\"}], from_json_string(struct_with_map1()).unwrap_or_default());\n+\n+    jval\n+}\n+\n+JsonTest(\"get_by_ptr(nested/z/10/b)\", mutilate_jval().get_by_ptr([JKeyPtr{i\"nested\"}, JKeyPtr{i\"z\"}, JIdxPtr{10}, JKeyPtr{i\"b\"}]).to_json_string().unwrap_or_default()).", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU2MzE4NA=="}, "originalCommit": {"oid": "9498f4299109388448ed77798f5a0a5c995975a7"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5Nzk1NDE3OnYy", "diffSide": "RIGHT", "path": "test/datalog_tests/json_test.dump.expected", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQyMjo0Mjo1OFrOHJWO5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQyMjo0Mjo1OFrOHJWO5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU2MzQ5NA==", "bodyText": "json literals are very hard to read as strings due to all the quotes being quoted.\nMakes me think we should add a syntax for Json literals... like interned strings.", "url": "https://github.com/vmware/differential-datalog/pull/756#discussion_r479563494", "createdAt": "2020-08-28T22:42:58Z", "author": {"login": "mbudiu-vmw"}, "path": "test/datalog_tests/json_test.dump.expected", "diffHunk": "@@ -3,6 +3,10 @@ json_test::JsonTest{.description = \"-100\", .value = \"{\\\"std_Ok\\\":{\\\"res\\\":-100}}\n json_test::JsonTest{.description = \"100\", .value = \"{\\\"std_Ok\\\":{\\\"res\\\":100}}\"}\n json_test::JsonTest{.description = \"2.99792458e8\", .value = \"{\\\"std_Ok\\\":{\\\"res\\\":299792458.0}}\"}\n json_test::JsonTest{.description = \"[{\\\"b\\\":true}, {\\\"b\\\":false}, {\\\"b\\\":true}, {\\\"b\\\":false}]\", .value = \"{\\\"std_Ok\\\":{\\\"res\\\":[{\\\"b\\\":true},{\\\"b\\\":false},{\\\"b\\\":true},{\\\"b\\\":false}]}}\"}\n+json_test::JsonTest{.description = \"get_by_ptr([])\", .value = \"{\\\"id\\\":\\\"1001001001\\\",\\\"nested\\\":{\\\"x\\\":{\\\"b\\\":true,\\\"foo\\\":\\\"bar\\\"},\\\"y\\\":{\\\"b\\\":true,\\\"foo\\\":\\\"bar\\\"},\\\"z\\\":[{\\\"@type\\\":\\\"t.V1\\\",\\\"b\\\":true},{\\\"@type\\\":\\\"t.V2\\\",\\\"b\\\":{\\\"f\\\":[{\\\"key\\\":100,\\\"payload\\\":\\\"foo\\\"}]}},null,null,null,null,null,null,null,{\\\"q\\\":{\\\"f\\\":[{\\\"key\\\":100,\\\"payload\\\":\\\"foo\\\"}]}},{\\\"b\\\":{\\\"f\\\":[{\\\"key\\\":100,\\\"payload\\\":\\\"foo\\\"}]}}]},\\\"t\\\":\\\"foo\\\"}\"}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9498f4299109388448ed77798f5a0a5c995975a7"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5Nzk4MzY4OnYy", "diffSide": "RIGHT", "path": "test/datalog_tests/std_test.dump.expected", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQyMzowMToxOFrOHJWflQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQyMzowMToxOFrOHJWflQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU2Nzc2NQ==", "bodyText": "did you intend to have this double slash here?", "url": "https://github.com/vmware/differential-datalog/pull/756#discussion_r479567765", "createdAt": "2020-08-28T23:01:18Z", "author": {"login": "mbudiu-vmw"}, "path": "test/datalog_tests/std_test.dump.expected", "diffHunk": "@@ -22,3 +22,15 @@ std_test::Pow{.descr = \"$pow32(2: u64, 32)\", .val = \"4294967296\"}\n std_test::Pow{.descr = \"pow32(2: u32, 32)\", .val = \"0\"}\n std_test::Default{.descr = \"DefaultEnum\", .val = \"DEnum1\"}\n std_test::Default{.descr = \"u32\", .val = \"0\"}\n+std_test::MapDelete{.descr = \"alphabet\", .m = [(0, \"a\"), (1, \"b\"), (2, \"c\"), (3, \"d\"), (4, \"e\")], .s = std::None{}}\n+std_test::MapDelete{.descr = \"alphabet\\\\4\", .m = [(0, \"a\"), (1, \"b\"), (2, \"c\"), (3, \"d\")], .s = std::Some{.x = \"e\"}}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9498f4299109388448ed77798f5a0a5c995975a7"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk5Nzk4NTQxOnYy", "diffSide": "RIGHT", "path": "test/datalog_tests/std_test.dl", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQyMzowMjoxOFrOHJWgfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQyMzowMjoxOFrOHJWgfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU2Nzk5Ng==", "bodyText": "should the string be resize(10, -100)?", "url": "https://github.com/vmware/differential-datalog/pull/756#discussion_r479567996", "createdAt": "2020-08-28T23:02:18Z", "author": {"login": "mbudiu-vmw"}, "path": "test/datalog_tests/std_test.dl", "diffHunk": "@@ -14,6 +14,32 @@ SortedVectorInPlace(sorted) :-\n         v2\n     }.\n \n+output relation IntVecTest(descr: string, vec: Vec<s64>)\n+\n+IntVecTest(\"vec0\", vec0()).\n+IntVecTest(\"vec0.resize(10)\", {var v = vec0(); v.resize(10, -100); v}).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9498f4299109388448ed77798f5a0a5c995975a7"}, "originalPosition": 7}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4834, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}