{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE4MTIwNDkx", "number": 806, "title": "ddlog-jooq: support inserts and batch queries", "bodyText": "This patch adds support for simple insert queries and batch queries via a jooq connection.", "createdAt": "2020-11-10T00:08:51Z", "url": "https://github.com/vmware/differential-datalog/pull/806", "merged": true, "mergeCommit": {"oid": "00716233958af4a99bd7b4868df1595a68bf2665"}, "closed": true, "closedAt": "2020-11-10T18:51:11Z", "author": {"login": "lalithsuresh"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABda9TnXAH2gAyNTE4MTIwNDkxOmE5MDEwOTRjYzkwYTlkMWI0YTlkMGNlNmRlZDJjYWY4MzE1MmNmM2U=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdbBr60AH2gAyNTE4MTIwNDkxOmUxNDAxODkxOGQzY2Y5OTEwYWYwNWJlYTUxODcwZjJlMDJkMWU1MWY=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "a901094cc90a9d1b4a9d0ce6ded2caf83152cf3e", "author": {"user": {"login": "lalithsuresh", "name": "Lalith Suresh"}}, "url": "https://github.com/vmware/differential-datalog/commit/a901094cc90a9d1b4a9d0ce6ded2caf83152cf3e", "committedDate": "2020-11-09T23:24:54Z", "message": "Support insert queries\n\nSigned-off-by: Lalith Suresh <lsuresh@vmware.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fc9f3db754593e963d126f818e714445c28732be", "author": {"user": {"login": "lalithsuresh", "name": "Lalith Suresh"}}, "url": "https://github.com/vmware/differential-datalog/commit/fc9f3db754593e963d126f818e714445c28732be", "committedDate": "2020-11-09T23:57:18Z", "message": "Support batch queries\n\nSigned-off-by: Lalith Suresh <lsuresh@vmware.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI2NzU0Njg2", "url": "https://github.com/vmware/differential-datalog/pull/806#pullrequestreview-526754686", "createdAt": "2020-11-10T00:11:30Z", "commit": {"oid": "fc9f3db754593e963d126f818e714445c28732be"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwMDoxMTozMFrOHwGnXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwMDoyMToxMlrOHwGzyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDIwMjA3Ng==", "bodyText": "ideally you should use the presto parser for this too.", "url": "https://github.com/vmware/differential-datalog/pull/806#discussion_r520202076", "createdAt": "2020-11-10T00:11:30Z", "author": {"login": "mbudiu-vmw"}, "path": "sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java", "diffHunk": "@@ -49,26 +58,38 @@ public DDlogJooqProvider(final DDlogAPI dDlogAPI, final List<String> sqlStatemen\n \n     @Override\n     public MockResult[] execute(final MockExecuteContext ctx) throws SQLException {\n-        final MockResult[] mock = new MockResult[1];\n-        // The execute context contains SQL string(s), bind values, and other meta-data\n-        final String sql = ctx.sql();\n+        final String[] batchSql = ctx.batchSQL();\n+        final MockResult[] mock = new MockResult[batchSql.length];\n+        try {\n+            dDlogAPI.transactionStart();\n+            for (int i = 0; i < batchSql.length; i++) {\n+                mock[i] = execute(batchSql[i]);\n+            }\n+            dDlogAPI.transactionCommit();\n+        } catch (final DDlogException e) {\n+            throw new RuntimeException(e);\n+        }\n+        return mock;\n+    }\n \n+    private MockResult execute(final String sql) throws SQLException {\n         if (sql.toUpperCase().startsWith(\"SELECT\")) {\n-            mock[0] = executeSelectStar(sql);\n+            return executeSelectStar(sql);\n+        } else if (sql.toUpperCase().startsWith(\"INSERT INTO\")) {\n+            return executeInsert(sql);\n         } else {\n             // Exceptions are propagated through the JDBC and jOOQ APIs\n             throw new SQLException(\"Statement not supported: \" + sql);\n         }\n-        return mock;\n     }\n \n     private MockResult executeSelectStar(final String sql) throws SQLException {\n-        final String[] s = sql.toUpperCase().split(\" \");\n-        if (!(s.length == 4 && s[1].equals(\"*\") && s[2].equals(\"FROM\"))) {\n+        final String[] s = sql.split(\"[ \\t\\n]+\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc9f3db754593e963d126f818e714445c28732be"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDIwMzU1MA==", "bodyText": "maybe it's time to create a helper function to return a relation name from a table name.", "url": "https://github.com/vmware/differential-datalog/pull/806#discussion_r520203550", "createdAt": "2020-11-10T00:16:03Z", "author": {"login": "mbudiu-vmw"}, "path": "sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java", "diffHunk": "@@ -89,13 +110,42 @@ private MockResult executeSelectStar(final String sql) throws SQLException {\n         return new MockResult(1, result);\n     }\n \n+    private MockResult executeInsert(final String sql) throws SQLException {\n+        final String[] s = sql.replaceAll(\"[(),]\", \"\")\n+                              .split(\"[ \\t\\n]+\");\n+        if (!(s.length >= 4 && s[1].equalsIgnoreCase(\"INTO\")\n+                && s[3].equalsIgnoreCase(\"VALUES\"))) {\n+            throw new SQLException(\"Statement not supported: \" + sql);\n+        }\n+        final String tableName = s[2];\n+        final int valuesIndex = 4; // the index representing the 1st field of the value being inserted\n+        final List<Field<?>> fields = tables.get(tableName.toUpperCase());\n+        if (fields == null) {\n+            throw new SQLException(\"Table cannot be queried: \" + tableName);\n+        }\n+        String[] valuesTuple = Arrays.copyOfRange(s, valuesIndex, s.length);\n+        final DDlogRecord dDlogRecord = toDDlogRecord(tableName, valuesTuple);\n+        final int tableId = dDlogAPI.getTableId(\"R\" + tableName.toLowerCase());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc9f3db754593e963d126f818e714445c28732be"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDIwNDE1Ng==", "bodyText": "technically these are two different constructors of the same type, the option type.", "url": "https://github.com/vmware/differential-datalog/pull/806#discussion_r520204156", "createdAt": "2020-11-10T00:17:54Z", "author": {"login": "mbudiu-vmw"}, "path": "sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java", "diffHunk": "@@ -22,21 +25,27 @@\n import java.util.Arrays;\n import java.util.HashMap;\n import java.util.List;\n+import java.util.Locale;\n import java.util.Map;\n \n+import static org.jooq.impl.DSL.field;\n+\n public class DDlogJooqProvider implements MockDataProvider {\n     private static final String INTEGER_TYPE = \"java.lang.Integer\";\n     private static final String STRING_TYPE = \"java.lang.String\";\n     private static final String BOOLEAN_TYPE = \"java.lang.Boolean\";\n     private static final String LONG_TYPE = \"java.lang.Long\";\n-\n+    private static final String DDLOG_SOME_TYPE = \"ddlog_std::Some\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc9f3db754593e963d126f818e714445c28732be"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDIwNDU1OA==", "bodyText": "it's handy to output the unexpected string for debugging.\ntrim() is sometimes useful too.", "url": "https://github.com/vmware/differential-datalog/pull/806#discussion_r520204558", "createdAt": "2020-11-10T00:19:08Z", "author": {"login": "mbudiu-vmw"}, "path": "sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java", "diffHunk": "@@ -111,4 +161,72 @@ private Object structToValue(final Field<?> field, final DDlogRecord record) {\n                 throw new RuntimeException(\"Unknown datatype %s of field %s in table %s in update received\");\n         }\n     }\n+\n+    private DDlogRecord toDDlogRecord(final String tableName, final String[] args) {\n+        final DDlogRecord[] recordsArray = new DDlogRecord[args.length];\n+        final List<Field<?>> fields = tables.get(tableName.toUpperCase());\n+\n+        int fieldIndex = 0;\n+        for (final Field<?> field : fields) {\n+            final Class<?> cls = field.getType();\n+            try {\n+                // Handle nullable columns here\n+                if (args[fieldIndex] == null) {\n+                    recordsArray[fieldIndex] = DDlogRecord.makeStruct(DDLOG_NONE_TYPE, new DDlogRecord[0]);\n+                }\n+                else {\n+                    switch (cls.getName()) {\n+                        case BOOLEAN_TYPE:\n+                            recordsArray[fieldIndex] = maybeOption(field,\n+                                    new DDlogRecord(Boolean.parseBoolean(args[fieldIndex])));\n+                            break;\n+                        case INTEGER_TYPE:\n+                            recordsArray[fieldIndex] = maybeOption(field,\n+                                    new DDlogRecord(Integer.parseInt(args[fieldIndex])));\n+                            break;\n+                        case LONG_TYPE:\n+                            recordsArray[fieldIndex] = maybeOption(field,\n+                                    new DDlogRecord(Long.parseLong(args[fieldIndex])));\n+                            break;\n+                        case STRING_TYPE:\n+                            // Strings have to be escaped by single quotes\n+                            if (args[fieldIndex].startsWith(\"'\") && args[fieldIndex].endsWith(\"'\")) {\n+                                recordsArray[fieldIndex] = maybeOption(field,\n+                                        new DDlogRecord(args[fieldIndex].substring(1, args[fieldIndex].length() - 1)));\n+                            } else {\n+                                throw new RuntimeException(\"Unexpected string\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc9f3db754593e963d126f818e714445c28732be"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDIwNDgyNw==", "bodyText": "there's a bunch of common functionality between all these cases that could be factored out, not sure it's worth.", "url": "https://github.com/vmware/differential-datalog/pull/806#discussion_r520204827", "createdAt": "2020-11-10T00:19:45Z", "author": {"login": "mbudiu-vmw"}, "path": "sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java", "diffHunk": "@@ -111,4 +161,72 @@ private Object structToValue(final Field<?> field, final DDlogRecord record) {\n                 throw new RuntimeException(\"Unknown datatype %s of field %s in table %s in update received\");\n         }\n     }\n+\n+    private DDlogRecord toDDlogRecord(final String tableName, final String[] args) {\n+        final DDlogRecord[] recordsArray = new DDlogRecord[args.length];\n+        final List<Field<?>> fields = tables.get(tableName.toUpperCase());\n+\n+        int fieldIndex = 0;\n+        for (final Field<?> field : fields) {\n+            final Class<?> cls = field.getType();\n+            try {\n+                // Handle nullable columns here\n+                if (args[fieldIndex] == null) {\n+                    recordsArray[fieldIndex] = DDlogRecord.makeStruct(DDLOG_NONE_TYPE, new DDlogRecord[0]);\n+                }\n+                else {\n+                    switch (cls.getName()) {\n+                        case BOOLEAN_TYPE:\n+                            recordsArray[fieldIndex] = maybeOption(field,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc9f3db754593e963d126f818e714445c28732be"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDIwNTI1OQ==", "bodyText": "you can still make each test a separate function and call it here.", "url": "https://github.com/vmware/differential-datalog/pull/806#discussion_r520205259", "createdAt": "2020-11-10T00:21:12Z", "author": {"login": "mbudiu-vmw"}, "path": "sql/src/test/java/ddlog/JooqProviderTest.java", "diffHunk": "@@ -27,60 +25,85 @@\n import java.util.ArrayList;\n import java.util.List;\n \n-import static org.junit.Assert.assertArrayEquals;\n-import static org.junit.Assert.assertEquals;\n+import static junit.framework.TestCase.assertFalse;\n+import static junit.framework.TestCase.assertTrue;\n+import static org.jooq.impl.DSL.field;\n \n public class JooqProviderTest {\n \n+    /*\n+     * We can only have one DDlog program loaded in memory at a time. We\n+     * therefore conduct a series of tests within a single method.\n+     */\n     @Test\n-    public void testddlog() throws IOException, DDlogException {\n-        final Translator t = new Translator(null);\n-        final String s1 = \"create table hosts (id integer, capacity integer)\";\n-        final String v2 = \"create view hostsv as select distinct * from hosts\";\n-        final String v1 = \"create view good_hosts as select distinct * from hosts where capacity < 50\";\n-        t.translateSqlStatement(s1);\n-        t.translateSqlStatement(v2);\n-        t.translateSqlStatement(v1);\n-        final DDlogProgram dDlogProgram = t.getDDlogProgram();\n-        writeProgramToFile(dDlogProgram.toString());\n-        DDlogAPI.compileDDlogProgram(\"/tmp/program.dl\", true, \"../lib\", \"./lib\");\n-        DDlogAPI.loadDDlog();\n-\n-        final DDlogAPI dDlogAPI = new DDlogAPI(1, null, true);\n-        final int numInserts = 5;\n-        dDlogAPI.transactionStart();\n-        for (int i = 0; i < numInserts; i++) {\n-            final DDlogRecord rec = new DDlogRecord(i);\n-            final DDlogRecord cap = new DDlogRecord(20);\n-            final DDlogRecord struct = DDlogRecord.makeStruct(\"Thosts\", rec, cap);\n-            final int id = dDlogAPI.getTableId(\"Rhosts\");\n-            final DDlogRecCommand command = new DDlogRecCommand(DDlogCommand.Kind.Insert, id, struct);\n-            dDlogAPI.applyUpdates(new DDlogRecCommand[]{command});\n-        }\n-        dDlogAPI.transactionCommit();\n-\n-        final List<String> ddl = new ArrayList<>();\n+    public void testInsertAndSelect() throws IOException, DDlogException {\n+        String s1 = \"create table hosts (id varchar(36), capacity integer, up boolean)\";\n+        String v2 = \"create view hostsv as select distinct * from hosts\";\n+        String v1 = \"create view good_hosts as select distinct * from hosts where capacity < 10\";\n+        List<String> ddl = new ArrayList<>();\n         ddl.add(s1);\n         ddl.add(v2);\n         ddl.add(v1);\n+        compileAndLoad(\"testInserts\", ddl);\n+        final DDlogAPI dDlogAPI = new DDlogAPI(1, null, true);\n \n         // Initialise the data provider\n         MockDataProvider provider = new DDlogJooqProvider(dDlogAPI, ddl);\n         MockConnection connection = new MockConnection(provider);\n \n         // Pass the mock connection to a jOOQ DSLContext:\n         DSLContext create = DSL.using(connection);\n-        final Result<Record> fetch = create.fetch(\"select * from hostsv\");\n-        assertEquals(numInserts, fetch.size());\n-        assertArrayEquals(new int[]{0, 1, 2, 3, 4},\n-                          fetch.stream().mapToInt(r -> r.get(0, Integer.class)).toArray());\n+\n+        // Test 1: insert statements.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc9f3db754593e963d126f818e714445c28732be"}, "originalPosition": 79}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7740884fde54820a6f2eb982cce263b24e2a14a2", "author": {"user": {"login": "lalithsuresh", "name": "Lalith Suresh"}}, "url": "https://github.com/vmware/differential-datalog/commit/7740884fde54820a6f2eb982cce263b24e2a14a2", "committedDate": "2020-11-10T02:06:51Z", "message": "Use Presto API to parse queries in DdlogJooqProvider\n\nSigned-off-by: Lalith Suresh <lsuresh@vmware.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "749d6fa1ba08025c6597d620ba78f45cbfa0eb6a", "author": {"user": {"login": "lalithsuresh", "name": "Lalith Suresh"}}, "url": "https://github.com/vmware/differential-datalog/commit/749d6fa1ba08025c6597d620ba78f45cbfa0eb6a", "committedDate": "2020-11-10T02:32:07Z", "message": "Add comments to DDlogJooqProvider\n\nSigned-off-by: Lalith Suresh <lsuresh@vmware.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6c7dc48662a2db2f9e017b4f2a859b46a0832522", "author": {"user": {"login": "lalithsuresh", "name": "Lalith Suresh"}}, "url": "https://github.com/vmware/differential-datalog/commit/6c7dc48662a2db2f9e017b4f2a859b46a0832522", "committedDate": "2020-11-10T02:34:23Z", "message": "Rename DDLOG_{SOME,NONE}_TYPE to DDLOG_{SOME,NONE}\n\nSigned-off-by: Lalith Suresh <lsuresh@vmware.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI2ODE0MzU2", "url": "https://github.com/vmware/differential-datalog/pull/806#pullrequestreview-526814356", "createdAt": "2020-11-10T02:52:29Z", "commit": {"oid": "6c7dc48662a2db2f9e017b4f2a859b46a0832522"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwMjo1MjoyOVrOHwJumQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQwMjo1NDowN1rOHwJwfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI1MzA4MQ==", "bodyText": "this is a bit inconsistent, sometimes you throw, sometimes you assert.", "url": "https://github.com/vmware/differential-datalog/pull/806#discussion_r520253081", "createdAt": "2020-11-10T02:52:29Z", "author": {"login": "mbudiu-vmw"}, "path": "sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java", "diffHunk": "@@ -24,78 +42,226 @@\n import java.util.List;\n import java.util.Map;\n \n+import static org.jooq.impl.DSL.field;\n+\n+\n+/**\n+ * This class provides a restricted mechanism to make a DDlog program appear like an SQL database that can be\n+ * queried over a JDBC connection. To initialize, it requires a set of \"create table\" and \"create view\" statements\n+ * to be supplied during initialization. For example:\n+ *\n+ *         final DDlogAPI dDlogAPI = new DDlogAPI(1, null, true);\n+ *\n+ *         // Initialise the data provider. ddl represents a list of Strings that are SQL DDL statements\n+ *         // like \"create table\" and \"create view\"\n+ *         MockDataProvider provider = new DDlogJooqProvider(dDlogAPI, ddl);\n+ *         MockConnection connection = new MockConnection(provider);\n+ *\n+ *         // Pass the mock connection to a jOOQ DSLContext:\n+ *         DSLContext create = DSL.using(connection);\n+ *\n+ * After that, the connection that is created with this MockProvider can execute a restricted subset of SQL queries.\n+ * We assume these queries are of one of the following forms:\n+ *   A1. \"select * from T\" where T is a table name which corresponds to a ddlog output relation. By definition,\n+ *                        T can therefore only be an SQL view for which there is a corresponding\n+ *                        \"create view T as ...\" that is passed to the  DdlogJooqProvider.\n+ *   A2. \"insert into T values (<row>)\" where T is a base table. That is, there should be a corresponding\n+ *                                     \"create table T...\" DDL statement that is passed to the DDlogJooqProvider.\n+ */\n public class DDlogJooqProvider implements MockDataProvider {\n     private static final String INTEGER_TYPE = \"java.lang.Integer\";\n     private static final String STRING_TYPE = \"java.lang.String\";\n     private static final String BOOLEAN_TYPE = \"java.lang.Boolean\";\n     private static final String LONG_TYPE = \"java.lang.Long\";\n-\n+    private static final String DDLOG_SOME = \"ddlog_std::Some\";\n+    private static final String DDLOG_NONE = \"ddlog_std::None\";\n     private final DDlogAPI dDlogAPI;\n     private final DSLContext dslContext;\n+    private final Field<Integer> updateCountField;\n     private final Map<String, List<Field<?>>> tables = new HashMap<>();\n+    private final SqlParser parser = new SqlParser();\n+    private final ParsingOptions options = ParsingOptions.builder().build();\n+    private final QueryVisitor queryVisitor = new QueryVisitor();\n+    private final ParseLiterals parseLiterals = new ParseLiterals();\n \n     public DDlogJooqProvider(final DDlogAPI dDlogAPI, final List<String> sqlStatements) {\n         this.dDlogAPI = dDlogAPI;\n-        dslContext = DSL.using(\"jdbc:h2:mem:\");\n+        this.dslContext = DSL.using(\"jdbc:h2:mem:\");\n+        this.updateCountField = field(\"UPDATE_COUNT\", Integer.class);\n         for (final String sql : sqlStatements) {\n             dslContext.execute(sql);\n         }\n         for (final Table<?> table: dslContext.meta().getTables()) {\n-            if (table.getSchema().getName().equals(\"PUBLIC\")) {\n+            if (table.getSchema().getName().equals(\"PUBLIC\")) { // H2-specific assumption\n                 tables.put(table.getName(), Arrays.asList(table.fields()));\n             }\n         }\n     }\n \n+    /*\n+     * All executed SQL queries against a JOOQ connection are received here\n+     */\n     @Override\n     public MockResult[] execute(final MockExecuteContext ctx) throws SQLException {\n-        final MockResult[] mock = new MockResult[1];\n-        // The execute context contains SQL string(s), bind values, and other meta-data\n-        final String sql = ctx.sql();\n-\n-        if (sql.toUpperCase().startsWith(\"SELECT\")) {\n-            mock[0] = executeSelectStar(sql);\n-        } else {\n-            // Exceptions are propagated through the JDBC and jOOQ APIs\n-            throw new SQLException(\"Statement not supported: \" + sql);\n+        final String[] batchSql = ctx.batchSQL();\n+        final MockResult[] mock = new MockResult[batchSql.length];\n+        try {\n+            dDlogAPI.transactionStart();\n+            for (int i = 0; i < batchSql.length; i++) {\n+                mock[i] = executeOne(batchSql[i]);\n+            }\n+            dDlogAPI.transactionCommit();\n+        } catch (final DDlogException e) {\n+            throw new RuntimeException(e);\n         }\n         return mock;\n     }\n \n-    private MockResult executeSelectStar(final String sql) throws SQLException {\n-        final String[] s = sql.toUpperCase().split(\" \");\n-        if (!(s.length == 4 && s[1].equals(\"*\") && s[2].equals(\"FROM\"))) {\n-            throw new SQLException(\"Statement not supported: \" + sql);\n+    private MockResult executeOne(final String sql) throws SQLException {\n+        final Statement statement = parser.createStatement(sql, options);\n+        final MockResult result = queryVisitor.process(statement, sql);\n+        if (result == null) {\n+            throw new SQLException(\"Could not execute SQL statement \" + sql);\n         }\n-        final String tableName = s[3];\n-        final List<Field<?>> fields = tables.get(tableName);\n-        if (fields == null) {\n-            throw new SQLException(\"Unknown table: \" + tableName);\n+        return result;\n+    }\n+\n+    /*\n+     * Visits an SQL query and converts into a JOOQ MockResult type.\n+     */\n+    private class QueryVisitor extends AstVisitor<MockResult, String> {\n+        @Override\n+        protected MockResult visitQuerySpecification(final QuerySpecification node, String sql) {\n+            // The checks below encode assumption A1 (see javadoc for the DDlogJooqProvider class)\n+            final Select select = node.getSelect();\n+            if (!(select.getSelectItems().size() == 1 && select.getSelectItems().get(0) instanceof AllColumns)) {\n+                throw new RuntimeException(\"Statement not supported: \" + sql);\n+            }\n+            assert node.getFrom().isPresent() && node.getFrom().get() instanceof com.facebook.presto.sql.tree.Table;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c7dc48662a2db2f9e017b4f2a859b46a0832522"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDI1MzU2NA==", "bodyText": "I have some helper function Linq.map/zip/any that you may want to occasionally use.", "url": "https://github.com/vmware/differential-datalog/pull/806#discussion_r520253564", "createdAt": "2020-11-10T02:54:07Z", "author": {"login": "mbudiu-vmw"}, "path": "sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java", "diffHunk": "@@ -24,78 +42,226 @@\n import java.util.List;\n import java.util.Map;\n \n+import static org.jooq.impl.DSL.field;\n+\n+\n+/**\n+ * This class provides a restricted mechanism to make a DDlog program appear like an SQL database that can be\n+ * queried over a JDBC connection. To initialize, it requires a set of \"create table\" and \"create view\" statements\n+ * to be supplied during initialization. For example:\n+ *\n+ *         final DDlogAPI dDlogAPI = new DDlogAPI(1, null, true);\n+ *\n+ *         // Initialise the data provider. ddl represents a list of Strings that are SQL DDL statements\n+ *         // like \"create table\" and \"create view\"\n+ *         MockDataProvider provider = new DDlogJooqProvider(dDlogAPI, ddl);\n+ *         MockConnection connection = new MockConnection(provider);\n+ *\n+ *         // Pass the mock connection to a jOOQ DSLContext:\n+ *         DSLContext create = DSL.using(connection);\n+ *\n+ * After that, the connection that is created with this MockProvider can execute a restricted subset of SQL queries.\n+ * We assume these queries are of one of the following forms:\n+ *   A1. \"select * from T\" where T is a table name which corresponds to a ddlog output relation. By definition,\n+ *                        T can therefore only be an SQL view for which there is a corresponding\n+ *                        \"create view T as ...\" that is passed to the  DdlogJooqProvider.\n+ *   A2. \"insert into T values (<row>)\" where T is a base table. That is, there should be a corresponding\n+ *                                     \"create table T...\" DDL statement that is passed to the DDlogJooqProvider.\n+ */\n public class DDlogJooqProvider implements MockDataProvider {\n     private static final String INTEGER_TYPE = \"java.lang.Integer\";\n     private static final String STRING_TYPE = \"java.lang.String\";\n     private static final String BOOLEAN_TYPE = \"java.lang.Boolean\";\n     private static final String LONG_TYPE = \"java.lang.Long\";\n-\n+    private static final String DDLOG_SOME = \"ddlog_std::Some\";\n+    private static final String DDLOG_NONE = \"ddlog_std::None\";\n     private final DDlogAPI dDlogAPI;\n     private final DSLContext dslContext;\n+    private final Field<Integer> updateCountField;\n     private final Map<String, List<Field<?>>> tables = new HashMap<>();\n+    private final SqlParser parser = new SqlParser();\n+    private final ParsingOptions options = ParsingOptions.builder().build();\n+    private final QueryVisitor queryVisitor = new QueryVisitor();\n+    private final ParseLiterals parseLiterals = new ParseLiterals();\n \n     public DDlogJooqProvider(final DDlogAPI dDlogAPI, final List<String> sqlStatements) {\n         this.dDlogAPI = dDlogAPI;\n-        dslContext = DSL.using(\"jdbc:h2:mem:\");\n+        this.dslContext = DSL.using(\"jdbc:h2:mem:\");\n+        this.updateCountField = field(\"UPDATE_COUNT\", Integer.class);\n         for (final String sql : sqlStatements) {\n             dslContext.execute(sql);\n         }\n         for (final Table<?> table: dslContext.meta().getTables()) {\n-            if (table.getSchema().getName().equals(\"PUBLIC\")) {\n+            if (table.getSchema().getName().equals(\"PUBLIC\")) { // H2-specific assumption\n                 tables.put(table.getName(), Arrays.asList(table.fields()));\n             }\n         }\n     }\n \n+    /*\n+     * All executed SQL queries against a JOOQ connection are received here\n+     */\n     @Override\n     public MockResult[] execute(final MockExecuteContext ctx) throws SQLException {\n-        final MockResult[] mock = new MockResult[1];\n-        // The execute context contains SQL string(s), bind values, and other meta-data\n-        final String sql = ctx.sql();\n-\n-        if (sql.toUpperCase().startsWith(\"SELECT\")) {\n-            mock[0] = executeSelectStar(sql);\n-        } else {\n-            // Exceptions are propagated through the JDBC and jOOQ APIs\n-            throw new SQLException(\"Statement not supported: \" + sql);\n+        final String[] batchSql = ctx.batchSQL();\n+        final MockResult[] mock = new MockResult[batchSql.length];\n+        try {\n+            dDlogAPI.transactionStart();\n+            for (int i = 0; i < batchSql.length; i++) {\n+                mock[i] = executeOne(batchSql[i]);\n+            }\n+            dDlogAPI.transactionCommit();\n+        } catch (final DDlogException e) {\n+            throw new RuntimeException(e);\n         }\n         return mock;\n     }\n \n-    private MockResult executeSelectStar(final String sql) throws SQLException {\n-        final String[] s = sql.toUpperCase().split(\" \");\n-        if (!(s.length == 4 && s[1].equals(\"*\") && s[2].equals(\"FROM\"))) {\n-            throw new SQLException(\"Statement not supported: \" + sql);\n+    private MockResult executeOne(final String sql) throws SQLException {\n+        final Statement statement = parser.createStatement(sql, options);\n+        final MockResult result = queryVisitor.process(statement, sql);\n+        if (result == null) {\n+            throw new SQLException(\"Could not execute SQL statement \" + sql);\n         }\n-        final String tableName = s[3];\n-        final List<Field<?>> fields = tables.get(tableName);\n-        if (fields == null) {\n-            throw new SQLException(\"Unknown table: \" + tableName);\n+        return result;\n+    }\n+\n+    /*\n+     * Visits an SQL query and converts into a JOOQ MockResult type.\n+     */\n+    private class QueryVisitor extends AstVisitor<MockResult, String> {\n+        @Override\n+        protected MockResult visitQuerySpecification(final QuerySpecification node, String sql) {\n+            // The checks below encode assumption A1 (see javadoc for the DDlogJooqProvider class)\n+            final Select select = node.getSelect();\n+            if (!(select.getSelectItems().size() == 1 && select.getSelectItems().get(0) instanceof AllColumns)) {\n+                throw new RuntimeException(\"Statement not supported: \" + sql);\n+            }\n+            assert node.getFrom().isPresent() && node.getFrom().get() instanceof com.facebook.presto.sql.tree.Table;\n+            final String tableName = ((com.facebook.presto.sql.tree.Table) node.getFrom().get()).getName().toString();\n+            final List<Field<?>> fields = tables.get(tableName.toUpperCase());\n+            if (fields == null) {\n+                throw new RuntimeException(String.format(\"Unknown table %s queried in statement: %s\", tableName, sql));\n+            }\n+            final Result<Record> result = dslContext.newResult(fields);\n+            try {\n+                dDlogAPI.dumpTable(ddlogRelationName(tableName), (record, l) -> {\n+                    final Record jooqRecord = dslContext.newRecord(fields);\n+                    final Object[] returnValue = new Object[fields.size()];\n+                    for (int i = 0; i < fields.size(); i++) {\n+                        returnValue[i] = structToValue(fields.get(i), record.getStructField(i));\n+                    }\n+                    jooqRecord.fromArray(returnValue);\n+                    result.add(jooqRecord);\n+                });\n+            } catch (final DDlogException e) {\n+                throw new RuntimeException(e);\n+            }\n+            return new MockResult(1, result);\n         }\n-        final Result<Record> result = dslContext.newResult(fields);\n-        try {\n-            dDlogAPI.dumpTable(\"R\" + tableName.toLowerCase(), (record, l) -> {\n-                final Record jooqRecord = dslContext.newRecord(fields);\n-                final Object[] returnValue = new Object[fields.size()];\n-                for (int i = 0; i < fields.size(); i++) {\n-                    returnValue[i] = structToValue(fields.get(i), record.getStructField(i));\n+\n+        @Override\n+        protected MockResult visitQuery(final Query node, final String context) {\n+            final QuerySpecification specification = (QuerySpecification) node.getQueryBody();\n+            return visitQuerySpecification(specification, context);\n+        }\n+\n+        @Override\n+        protected MockResult visitInsert(final Insert node, final String sql) {\n+            try {\n+                // The assertions below encode assumption A2 (see javadoc for the DDlogJooqProvider class)\n+                assert node.getQuery().getQueryBody() instanceof Values;\n+                final Values values = (Values) node.getQuery().getQueryBody();\n+                final String tableName = node.getTarget().toString();\n+                final List<Field<?>> fields = tables.get(tableName.toUpperCase());\n+                final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n+                for (final Expression row: values.getRows()) {\n+                    assert row instanceof Row;\n+                    final List<Expression> items = ((Row) row).getItems();\n+                    assert items.size() == fields.size();\n+                    final DDlogRecord[] recordsArray = new DDlogRecord[items.size()];\n+                    for (int i = 0; i < items.size(); i++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6c7dc48662a2db2f9e017b4f2a859b46a0832522"}, "originalPosition": 200}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e14018918d3cf9910af05bea51870f2e02d1e51f", "author": {"user": {"login": "lalithsuresh", "name": "Lalith Suresh"}}, "url": "https://github.com/vmware/differential-datalog/commit/e14018918d3cf9910af05bea51870f2e02d1e51f", "committedDate": "2020-11-10T04:31:04Z", "message": "Change assertions to throw Exceptions instead\n\nSigned-off-by: Lalith Suresh <lsuresh@vmware.com>"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4431, "cost": 1, "resetAt": "2021-11-02T10:47:05Z"}}}