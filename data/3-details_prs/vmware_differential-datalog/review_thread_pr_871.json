{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQxNDI0OTUx", "number": 871, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMFQwMToyMzo1MFrOFHggkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMFQwMToyMzo1MFrOFHggkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzNDE2OTc2OnYy", "diffSide": "RIGHT", "path": "lib/ddlog_std.rs", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMFQwMToyMzo1MFrOII_1dg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMFQwMjoyOToxMFrOIJAJEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjMwNTM5OA==", "bodyText": "Just curious, why the strong preference for single-line comments?", "url": "https://github.com/vmware/differential-datalog/pull/871#discussion_r546305398", "createdAt": "2020-12-20T01:23:50Z", "author": {"login": "ryzhyk"}, "path": "lib/ddlog_std.rs", "diffHunk": "@@ -202,81 +203,88 @@ pub fn bigint_pow32(base: &ddlog_bigint::Int, exp: &u32) -> ddlog_bigint::Int {\n }\n \n // Option\n-pub fn option2std<T>(x: ::std::option::Option<T>) -> Option<T> {\n+pub fn option2std<T>(x: StdOption<T>) -> Option<T> {\n     match x {\n-        ::std::option::Option::None => Option::None,\n-        ::std::option::Option::Some(v) => Option::Some { x: v },\n+        StdOption::None => Option::None,\n+        StdOption::Some(v) => Option::Some { x: v },\n     }\n }\n \n-pub fn std2option<T>(x: Option<T>) -> ::std::option::Option<T> {\n+pub fn std2option<T>(x: Option<T>) -> StdOption<T> {\n     match x {\n-        Option::None => ::std::option::Option::None,\n-        Option::Some { x } => ::std::option::Option::Some(x),\n+        Option::None => StdOption::None,\n+        Option::Some { x } => StdOption::Some(x),\n     }\n }\n \n-impl<T> From<::std::option::Option<T>> for Option<T> {\n-    fn from(x: ::std::option::Option<T>) -> Self {\n+impl<T> From<StdOption<T>> for Option<T> {\n+    fn from(x: StdOption<T>) -> Self {\n         option2std(x)\n     }\n }\n \n // this requires Rust 1.41+\n-impl<T> From<Option<T>> for ::std::option::Option<T> {\n+impl<T> From<Option<T>> for StdOption<T> {\n     fn from(x: Option<T>) -> Self {\n         std2option(x)\n     }\n }\n \n-impl<A: FromRecord + serde::de::DeserializeOwned + Default> FromRecord for Option<A> {\n-    fn from_record(val: &Record) -> result::Result<Self, String> {\n+impl<T> FromRecord for Option<T>\n+where\n+    T: FromRecord + DeserializeOwned + Default,\n+{\n+    fn from_record(val: &Record) -> StdResult<Self, String> {\n         match val {\n             Record::PosStruct(constr, args) => match constr.as_ref() {\n                 \"ddlog_std::None\" if args.len() == 0 => Ok(Option::None {}),\n                 \"ddlog_std::Some\" if args.len() == 1 => Ok(Option::Some {\n-                    x: <A>::from_record(&args[0])?,\n+                    x: <T>::from_record(&args[0])?,\n                 }),\n-                c => result::Result::Err(format!(\n+                c => StdResult::Err(format!(\n                     \"unknown constructor {} of type Option in {:?}\",\n                     c, *val\n                 )),\n             },\n+\n             Record::NamedStruct(constr, args) => match constr.as_ref() {\n                 \"ddlog_std::None\" => Ok(Option::None {}),\n                 \"ddlog_std::Some\" => Ok(Option::Some {\n-                    x: arg_extract::<A>(args, \"x\")?,\n+                    x: arg_extract::<T>(args, \"x\")?,\n                 }),\n-                c => result::Result::Err(format!(\n+                c => StdResult::Err(format!(\n                     \"unknown constructor {} of type Option in {:?}\",\n                     c, *val\n                 )),\n             },\n-            /* `Option` encoded as an array of size 0 or 1.  This is, for instance, useful when\n-             * interfacing with OVSDB. */\n+\n+            // `Option` encoded as an array of size 0 or 1.  This is, for instance, useful when", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "07ac7ad3766d1c1d54d1ac3fd4d79e74396143eb"}, "originalPosition": 243}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjMxMDQxNg==", "bodyText": "They're more standard in rust I guess, multiline comments aren't used that often", "url": "https://github.com/vmware/differential-datalog/pull/871#discussion_r546310416", "createdAt": "2020-12-20T02:29:10Z", "author": {"login": "Kixiron"}, "path": "lib/ddlog_std.rs", "diffHunk": "@@ -202,81 +203,88 @@ pub fn bigint_pow32(base: &ddlog_bigint::Int, exp: &u32) -> ddlog_bigint::Int {\n }\n \n // Option\n-pub fn option2std<T>(x: ::std::option::Option<T>) -> Option<T> {\n+pub fn option2std<T>(x: StdOption<T>) -> Option<T> {\n     match x {\n-        ::std::option::Option::None => Option::None,\n-        ::std::option::Option::Some(v) => Option::Some { x: v },\n+        StdOption::None => Option::None,\n+        StdOption::Some(v) => Option::Some { x: v },\n     }\n }\n \n-pub fn std2option<T>(x: Option<T>) -> ::std::option::Option<T> {\n+pub fn std2option<T>(x: Option<T>) -> StdOption<T> {\n     match x {\n-        Option::None => ::std::option::Option::None,\n-        Option::Some { x } => ::std::option::Option::Some(x),\n+        Option::None => StdOption::None,\n+        Option::Some { x } => StdOption::Some(x),\n     }\n }\n \n-impl<T> From<::std::option::Option<T>> for Option<T> {\n-    fn from(x: ::std::option::Option<T>) -> Self {\n+impl<T> From<StdOption<T>> for Option<T> {\n+    fn from(x: StdOption<T>) -> Self {\n         option2std(x)\n     }\n }\n \n // this requires Rust 1.41+\n-impl<T> From<Option<T>> for ::std::option::Option<T> {\n+impl<T> From<Option<T>> for StdOption<T> {\n     fn from(x: Option<T>) -> Self {\n         std2option(x)\n     }\n }\n \n-impl<A: FromRecord + serde::de::DeserializeOwned + Default> FromRecord for Option<A> {\n-    fn from_record(val: &Record) -> result::Result<Self, String> {\n+impl<T> FromRecord for Option<T>\n+where\n+    T: FromRecord + DeserializeOwned + Default,\n+{\n+    fn from_record(val: &Record) -> StdResult<Self, String> {\n         match val {\n             Record::PosStruct(constr, args) => match constr.as_ref() {\n                 \"ddlog_std::None\" if args.len() == 0 => Ok(Option::None {}),\n                 \"ddlog_std::Some\" if args.len() == 1 => Ok(Option::Some {\n-                    x: <A>::from_record(&args[0])?,\n+                    x: <T>::from_record(&args[0])?,\n                 }),\n-                c => result::Result::Err(format!(\n+                c => StdResult::Err(format!(\n                     \"unknown constructor {} of type Option in {:?}\",\n                     c, *val\n                 )),\n             },\n+\n             Record::NamedStruct(constr, args) => match constr.as_ref() {\n                 \"ddlog_std::None\" => Ok(Option::None {}),\n                 \"ddlog_std::Some\" => Ok(Option::Some {\n-                    x: arg_extract::<A>(args, \"x\")?,\n+                    x: arg_extract::<T>(args, \"x\")?,\n                 }),\n-                c => result::Result::Err(format!(\n+                c => StdResult::Err(format!(\n                     \"unknown constructor {} of type Option in {:?}\",\n                     c, *val\n                 )),\n             },\n-            /* `Option` encoded as an array of size 0 or 1.  This is, for instance, useful when\n-             * interfacing with OVSDB. */\n+\n+            // `Option` encoded as an array of size 0 or 1.  This is, for instance, useful when", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjMwNTM5OA=="}, "originalCommit": {"oid": "07ac7ad3766d1c1d54d1ac3fd4d79e74396143eb"}, "originalPosition": 243}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4716, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}