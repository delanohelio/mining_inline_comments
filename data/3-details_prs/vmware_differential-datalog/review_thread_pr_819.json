{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIzNTExNzgw", "number": 819, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQyMjoxNzozM1rOE6yk5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQyMjoyNDoxOFrOE6ytqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwMDgxNTExOnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQyMjoxNzozM1rOH2ElLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQyMjoxNzozM1rOH2ElLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ2MDIwNA==", "bodyText": "inconsistent indentation", "url": "https://github.com/vmware/differential-datalog/pull/819#discussion_r526460204", "createdAt": "2020-11-18T22:17:33Z", "author": {"login": "mbudiu-vmw"}, "path": "sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java", "diffHunk": "@@ -130,11 +131,17 @@ public DDlogJooqProvider(final DDlogAPI dDlogAPI, final List<String> sqlStatemen\n         final String[] batchSql = ctx.batchSQL();\n         final MockResult[] mock = new MockResult[batchSql.length];\n         try {\n-            dDlogAPI.transactionStart();\n-            for (int i = 0; i < batchSql.length; i++) {\n-                mock[i] = executeOne(batchSql[i]);\n+            try {\n+                dDlogAPI.transactionStart();\n+                final Object[][] bindings = ctx.batchBindings();\n+                for (int i = 0; i < batchSql.length; i++) {\n+                    final Object[] binding = bindings != null && bindings.length > i ? bindings[i] : new Object[0];\n+                    final QueryContext context = new QueryContext(batchSql[i], binding);\n+                    mock[i] = executeOne(context);\n+                }\n+            } finally {\n+                    dDlogAPI.transactionCommitDumpChanges(this::onChange);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f93a5a3ee5c8fe1c497dc2c0489fd6e13bf6f59"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwMDgxNzY0OnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQyMjoxODoyMVrOH2EmrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQyMjoxODoyMVrOH2EmrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ2MDU4OA==", "bodyText": "You can cache Object[0].", "url": "https://github.com/vmware/differential-datalog/pull/819#discussion_r526460588", "createdAt": "2020-11-18T22:18:21Z", "author": {"login": "mbudiu-vmw"}, "path": "sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java", "diffHunk": "@@ -130,11 +131,17 @@ public DDlogJooqProvider(final DDlogAPI dDlogAPI, final List<String> sqlStatemen\n         final String[] batchSql = ctx.batchSQL();\n         final MockResult[] mock = new MockResult[batchSql.length];\n         try {\n-            dDlogAPI.transactionStart();\n-            for (int i = 0; i < batchSql.length; i++) {\n-                mock[i] = executeOne(batchSql[i]);\n+            try {\n+                dDlogAPI.transactionStart();\n+                final Object[][] bindings = ctx.batchBindings();\n+                for (int i = 0; i < batchSql.length; i++) {\n+                    final Object[] binding = bindings != null && bindings.length > i ? bindings[i] : new Object[0];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f93a5a3ee5c8fe1c497dc2c0489fd6e13bf6f59"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwMDgyNTk3OnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQyMjoyMDo0NlrOH2EriA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQyMjo1NDo1MVrOH2FqZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ2MTgzMg==", "bodyText": "May be nice to figure out why this would happen.", "url": "https://github.com/vmware/differential-datalog/pull/819#discussion_r526461832", "createdAt": "2020-11-18T22:20:46Z", "author": {"login": "mbudiu-vmw"}, "path": "sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java", "diffHunk": "@@ -164,68 +171,85 @@ private void onChange(final DDlogCommand<DDlogRecord> command) {\n         }\n     }\n \n-    private MockResult executeOne(final String sql) throws SQLException {\n-        final Statement statement = parser.createStatement(sql, options);\n-        final MockResult result = queryVisitor.process(statement, sql);\n+    private MockResult executeOne(final QueryContext context) throws SQLException {\n+        final Statement statement = parser.createStatement(context.sql(), options);\n+        final MockResult result = queryVisitor.process(statement, context);\n         if (result == null) {\n-            throw new SQLException(\"Could not execute SQL statement \" + sql);\n+            throw new SQLException(\"Could not execute SQL statement \" + context);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f93a5a3ee5c8fe1c497dc2c0489fd6e13bf6f59"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ3NzkyNw==", "bodyText": "This can only happen if we receive a statement type we can't support (something other than selects, inserts, or deletes, or queries with a shape different than what we can handle as listed in the class's Javadocs).", "url": "https://github.com/vmware/differential-datalog/pull/819#discussion_r526477927", "createdAt": "2020-11-18T22:54:51Z", "author": {"login": "lalithsuresh"}, "path": "sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java", "diffHunk": "@@ -164,68 +171,85 @@ private void onChange(final DDlogCommand<DDlogRecord> command) {\n         }\n     }\n \n-    private MockResult executeOne(final String sql) throws SQLException {\n-        final Statement statement = parser.createStatement(sql, options);\n-        final MockResult result = queryVisitor.process(statement, sql);\n+    private MockResult executeOne(final QueryContext context) throws SQLException {\n+        final Statement statement = parser.createStatement(context.sql(), options);\n+        final MockResult result = queryVisitor.process(statement, context);\n         if (result == null) {\n-            throw new SQLException(\"Could not execute SQL statement \" + sql);\n+            throw new SQLException(\"Could not execute SQL statement \" + context);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ2MTgzMg=="}, "originalCommit": {"oid": "8f93a5a3ee5c8fe1c497dc2c0489fd6e13bf6f59"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwMDgyODgyOnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQyMjoyMTo0MFrOH2EtOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQyMjoyMTo0MFrOH2EtOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ2MjI2NQ==", "bodyText": "bound", "url": "https://github.com/vmware/differential-datalog/pull/819#discussion_r526462265", "createdAt": "2020-11-18T22:21:40Z", "author": {"login": "mbudiu-vmw"}, "path": "sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java", "diffHunk": "@@ -164,68 +171,85 @@ private void onChange(final DDlogCommand<DDlogRecord> command) {\n         }\n     }\n \n-    private MockResult executeOne(final String sql) throws SQLException {\n-        final Statement statement = parser.createStatement(sql, options);\n-        final MockResult result = queryVisitor.process(statement, sql);\n+    private MockResult executeOne(final QueryContext context) throws SQLException {\n+        final Statement statement = parser.createStatement(context.sql(), options);\n+        final MockResult result = queryVisitor.process(statement, context);\n         if (result == null) {\n-            throw new SQLException(\"Could not execute SQL statement \" + sql);\n+            throw new SQLException(\"Could not execute SQL statement \" + context);\n         }\n         return result;\n     }\n \n     /*\n      * Visits an SQL query and converts into a JOOQ MockResult type.\n      */\n-    private class QueryVisitor extends AstVisitor<MockResult, String> {\n+    private class QueryVisitor extends AstVisitor<MockResult, QueryContext> {\n         @Override\n-        protected MockResult visitQuerySpecification(final QuerySpecification node, String sql) {\n+        protected MockResult visitQuerySpecification(final QuerySpecification node, final QueryContext context) {\n             // The checks below encode assumption A1 (see javadoc for the DDlogJooqProvider class)\n             final Select select = node.getSelect();\n             if (!(select.getSelectItems().size() == 1\n                     && select.getSelectItems().get(0) instanceof AllColumns\n                     && node.getFrom().isPresent()\n                     && node.getFrom().get() instanceof com.facebook.presto.sql.tree.Table)) {\n-                throw new RuntimeException(\"Statement not supported: \" + sql);\n+                throw new RuntimeException(\"Statement not supported: \" + context.sql());\n             }\n             final String tableName = ((com.facebook.presto.sql.tree.Table) node.getFrom().get()).getName().toString();\n             final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n             if (fields == null) {\n-                throw new RuntimeException(String.format(\"Unknown table %s queried in statement: %s\", tableName, sql));\n+                throw new RuntimeException(String.format(\"Unknown table %s queried in statement: %s\", tableName,\n+                                           context.sql()));\n             }\n             final Result<Record> result = dslContext.newResult(fields);\n             result.addAll(materializedViews.computeIfAbsent(tableName.toUpperCase(), (k) -> new LinkedHashSet<>()));\n             return new MockResult(1, result);\n         }\n \n         @Override\n-        protected MockResult visitQuery(final Query node, final String context) {\n+        protected MockResult visitQuery(final Query node, final QueryContext context) {\n             final QuerySpecification specification = (QuerySpecification) node.getQueryBody();\n             return visitQuerySpecification(specification, context);\n         }\n \n         @Override\n-        protected MockResult visitInsert(final Insert node, final String sql) {\n+        protected MockResult visitInsert(final Insert node, final QueryContext context) {\n             try {\n                 // The assertions below encode assumption A2 (see javadoc for the DDlogJooqProvider class)\n                 if (!(node.getQuery().getQueryBody() instanceof Values)) {\n-                    throw new RuntimeException(\"Statement not supported: \" + sql);\n+                    throw new RuntimeException(\"Statement not supported: \" + context.sql());\n                 }\n                 final Values values = (Values) node.getQuery().getQueryBody();\n                 final String tableName = node.getTarget().toString();\n                 final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n                 final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n+                int bindingIndex = 0;\n                 for (final Expression row: values.getRows()) {\n                     if (!(row instanceof Row)) {\n-                        throw new RuntimeException(\"Statement not supported: \" + sql);\n+                        throw new RuntimeException(\"Statement not supported: \" + context.sql());\n                     }\n                     final List<Expression> items = ((Row) row).getItems();\n                     if (items.size() != fields.size()) {\n-                        throw new RuntimeException(\n-                                String.format(\"Incorrect row size for insertion into table %s: %s\", tableName, sql));\n+                        final String error = String.format(\"Incorrect row size for insertion into table %s. \" +\n+                                                   \"Please specify all the table's fields in their declared order: %s\",\n+                                                    tableName, context.sql());\n+                        throw new RuntimeException(error);\n                     }\n                     final DDlogRecord[] recordsArray = new DDlogRecord[items.size()];\n-                    for (int i = 0; i < items.size(); i++) {\n-                        recordsArray[i] = parseLiterals.process(items.get(i), fields.get(i).getDataType().nullable());\n+                    if (context.hasBinding()) {\n+                        // Is a statement with bind variables", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f93a5a3ee5c8fe1c497dc2c0489fd6e13bf6f59"}, "originalPosition": 124}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwMDgzNzUyOnYy", "diffSide": "RIGHT", "path": "sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQyMjoyNDoxOFrOH2EyaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOFQyMzowMDowMlrOH2Fy8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ2MzU5Mg==", "bodyText": "Should this counter be maintained in the context and provided by a context.nextBinding() method?", "url": "https://github.com/vmware/differential-datalog/pull/819#discussion_r526463592", "createdAt": "2020-11-18T22:24:18Z", "author": {"login": "mbudiu-vmw"}, "path": "sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java", "diffHunk": "@@ -164,68 +171,85 @@ private void onChange(final DDlogCommand<DDlogRecord> command) {\n         }\n     }\n \n-    private MockResult executeOne(final String sql) throws SQLException {\n-        final Statement statement = parser.createStatement(sql, options);\n-        final MockResult result = queryVisitor.process(statement, sql);\n+    private MockResult executeOne(final QueryContext context) throws SQLException {\n+        final Statement statement = parser.createStatement(context.sql(), options);\n+        final MockResult result = queryVisitor.process(statement, context);\n         if (result == null) {\n-            throw new SQLException(\"Could not execute SQL statement \" + sql);\n+            throw new SQLException(\"Could not execute SQL statement \" + context);\n         }\n         return result;\n     }\n \n     /*\n      * Visits an SQL query and converts into a JOOQ MockResult type.\n      */\n-    private class QueryVisitor extends AstVisitor<MockResult, String> {\n+    private class QueryVisitor extends AstVisitor<MockResult, QueryContext> {\n         @Override\n-        protected MockResult visitQuerySpecification(final QuerySpecification node, String sql) {\n+        protected MockResult visitQuerySpecification(final QuerySpecification node, final QueryContext context) {\n             // The checks below encode assumption A1 (see javadoc for the DDlogJooqProvider class)\n             final Select select = node.getSelect();\n             if (!(select.getSelectItems().size() == 1\n                     && select.getSelectItems().get(0) instanceof AllColumns\n                     && node.getFrom().isPresent()\n                     && node.getFrom().get() instanceof com.facebook.presto.sql.tree.Table)) {\n-                throw new RuntimeException(\"Statement not supported: \" + sql);\n+                throw new RuntimeException(\"Statement not supported: \" + context.sql());\n             }\n             final String tableName = ((com.facebook.presto.sql.tree.Table) node.getFrom().get()).getName().toString();\n             final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n             if (fields == null) {\n-                throw new RuntimeException(String.format(\"Unknown table %s queried in statement: %s\", tableName, sql));\n+                throw new RuntimeException(String.format(\"Unknown table %s queried in statement: %s\", tableName,\n+                                           context.sql()));\n             }\n             final Result<Record> result = dslContext.newResult(fields);\n             result.addAll(materializedViews.computeIfAbsent(tableName.toUpperCase(), (k) -> new LinkedHashSet<>()));\n             return new MockResult(1, result);\n         }\n \n         @Override\n-        protected MockResult visitQuery(final Query node, final String context) {\n+        protected MockResult visitQuery(final Query node, final QueryContext context) {\n             final QuerySpecification specification = (QuerySpecification) node.getQueryBody();\n             return visitQuerySpecification(specification, context);\n         }\n \n         @Override\n-        protected MockResult visitInsert(final Insert node, final String sql) {\n+        protected MockResult visitInsert(final Insert node, final QueryContext context) {\n             try {\n                 // The assertions below encode assumption A2 (see javadoc for the DDlogJooqProvider class)\n                 if (!(node.getQuery().getQueryBody() instanceof Values)) {\n-                    throw new RuntimeException(\"Statement not supported: \" + sql);\n+                    throw new RuntimeException(\"Statement not supported: \" + context.sql());\n                 }\n                 final Values values = (Values) node.getQuery().getQueryBody();\n                 final String tableName = node.getTarget().toString();\n                 final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n                 final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n+                int bindingIndex = 0;\n                 for (final Expression row: values.getRows()) {\n                     if (!(row instanceof Row)) {\n-                        throw new RuntimeException(\"Statement not supported: \" + sql);\n+                        throw new RuntimeException(\"Statement not supported: \" + context.sql());\n                     }\n                     final List<Expression> items = ((Row) row).getItems();\n                     if (items.size() != fields.size()) {\n-                        throw new RuntimeException(\n-                                String.format(\"Incorrect row size for insertion into table %s: %s\", tableName, sql));\n+                        final String error = String.format(\"Incorrect row size for insertion into table %s. \" +\n+                                                   \"Please specify all the table's fields in their declared order: %s\",\n+                                                    tableName, context.sql());\n+                        throw new RuntimeException(error);\n                     }\n                     final DDlogRecord[] recordsArray = new DDlogRecord[items.size()];\n-                    for (int i = 0; i < items.size(); i++) {\n-                        recordsArray[i] = parseLiterals.process(items.get(i), fields.get(i).getDataType().nullable());\n+                    if (context.hasBinding()) {\n+                        // Is a statement with bind variables\n+                        for (int i = 0; i < items.size(); i++) {\n+                            final boolean isNullableField = fields.get(i).getDataType().nullable();\n+                            final DDlogRecord record = toValue(fields.get(i), context.binding()[bindingIndex]);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f93a5a3ee5c8fe1c497dc2c0489fd6e13bf6f59"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ3ODcwMQ==", "bodyText": "That's a good idea. Every use of the binding seems to bump an index. So it's better to keep it behind the Context.", "url": "https://github.com/vmware/differential-datalog/pull/819#discussion_r526478701", "createdAt": "2020-11-18T22:56:41Z", "author": {"login": "lalithsuresh"}, "path": "sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java", "diffHunk": "@@ -164,68 +171,85 @@ private void onChange(final DDlogCommand<DDlogRecord> command) {\n         }\n     }\n \n-    private MockResult executeOne(final String sql) throws SQLException {\n-        final Statement statement = parser.createStatement(sql, options);\n-        final MockResult result = queryVisitor.process(statement, sql);\n+    private MockResult executeOne(final QueryContext context) throws SQLException {\n+        final Statement statement = parser.createStatement(context.sql(), options);\n+        final MockResult result = queryVisitor.process(statement, context);\n         if (result == null) {\n-            throw new SQLException(\"Could not execute SQL statement \" + sql);\n+            throw new SQLException(\"Could not execute SQL statement \" + context);\n         }\n         return result;\n     }\n \n     /*\n      * Visits an SQL query and converts into a JOOQ MockResult type.\n      */\n-    private class QueryVisitor extends AstVisitor<MockResult, String> {\n+    private class QueryVisitor extends AstVisitor<MockResult, QueryContext> {\n         @Override\n-        protected MockResult visitQuerySpecification(final QuerySpecification node, String sql) {\n+        protected MockResult visitQuerySpecification(final QuerySpecification node, final QueryContext context) {\n             // The checks below encode assumption A1 (see javadoc for the DDlogJooqProvider class)\n             final Select select = node.getSelect();\n             if (!(select.getSelectItems().size() == 1\n                     && select.getSelectItems().get(0) instanceof AllColumns\n                     && node.getFrom().isPresent()\n                     && node.getFrom().get() instanceof com.facebook.presto.sql.tree.Table)) {\n-                throw new RuntimeException(\"Statement not supported: \" + sql);\n+                throw new RuntimeException(\"Statement not supported: \" + context.sql());\n             }\n             final String tableName = ((com.facebook.presto.sql.tree.Table) node.getFrom().get()).getName().toString();\n             final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n             if (fields == null) {\n-                throw new RuntimeException(String.format(\"Unknown table %s queried in statement: %s\", tableName, sql));\n+                throw new RuntimeException(String.format(\"Unknown table %s queried in statement: %s\", tableName,\n+                                           context.sql()));\n             }\n             final Result<Record> result = dslContext.newResult(fields);\n             result.addAll(materializedViews.computeIfAbsent(tableName.toUpperCase(), (k) -> new LinkedHashSet<>()));\n             return new MockResult(1, result);\n         }\n \n         @Override\n-        protected MockResult visitQuery(final Query node, final String context) {\n+        protected MockResult visitQuery(final Query node, final QueryContext context) {\n             final QuerySpecification specification = (QuerySpecification) node.getQueryBody();\n             return visitQuerySpecification(specification, context);\n         }\n \n         @Override\n-        protected MockResult visitInsert(final Insert node, final String sql) {\n+        protected MockResult visitInsert(final Insert node, final QueryContext context) {\n             try {\n                 // The assertions below encode assumption A2 (see javadoc for the DDlogJooqProvider class)\n                 if (!(node.getQuery().getQueryBody() instanceof Values)) {\n-                    throw new RuntimeException(\"Statement not supported: \" + sql);\n+                    throw new RuntimeException(\"Statement not supported: \" + context.sql());\n                 }\n                 final Values values = (Values) node.getQuery().getQueryBody();\n                 final String tableName = node.getTarget().toString();\n                 final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n                 final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n+                int bindingIndex = 0;\n                 for (final Expression row: values.getRows()) {\n                     if (!(row instanceof Row)) {\n-                        throw new RuntimeException(\"Statement not supported: \" + sql);\n+                        throw new RuntimeException(\"Statement not supported: \" + context.sql());\n                     }\n                     final List<Expression> items = ((Row) row).getItems();\n                     if (items.size() != fields.size()) {\n-                        throw new RuntimeException(\n-                                String.format(\"Incorrect row size for insertion into table %s: %s\", tableName, sql));\n+                        final String error = String.format(\"Incorrect row size for insertion into table %s. \" +\n+                                                   \"Please specify all the table's fields in their declared order: %s\",\n+                                                    tableName, context.sql());\n+                        throw new RuntimeException(error);\n                     }\n                     final DDlogRecord[] recordsArray = new DDlogRecord[items.size()];\n-                    for (int i = 0; i < items.size(); i++) {\n-                        recordsArray[i] = parseLiterals.process(items.get(i), fields.get(i).getDataType().nullable());\n+                    if (context.hasBinding()) {\n+                        // Is a statement with bind variables\n+                        for (int i = 0; i < items.size(); i++) {\n+                            final boolean isNullableField = fields.get(i).getDataType().nullable();\n+                            final DDlogRecord record = toValue(fields.get(i), context.binding()[bindingIndex]);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ2MzU5Mg=="}, "originalCommit": {"oid": "8f93a5a3ee5c8fe1c497dc2c0489fd6e13bf6f59"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ4MDExMw==", "bodyText": "Done.", "url": "https://github.com/vmware/differential-datalog/pull/819#discussion_r526480113", "createdAt": "2020-11-18T23:00:02Z", "author": {"login": "lalithsuresh"}, "path": "sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java", "diffHunk": "@@ -164,68 +171,85 @@ private void onChange(final DDlogCommand<DDlogRecord> command) {\n         }\n     }\n \n-    private MockResult executeOne(final String sql) throws SQLException {\n-        final Statement statement = parser.createStatement(sql, options);\n-        final MockResult result = queryVisitor.process(statement, sql);\n+    private MockResult executeOne(final QueryContext context) throws SQLException {\n+        final Statement statement = parser.createStatement(context.sql(), options);\n+        final MockResult result = queryVisitor.process(statement, context);\n         if (result == null) {\n-            throw new SQLException(\"Could not execute SQL statement \" + sql);\n+            throw new SQLException(\"Could not execute SQL statement \" + context);\n         }\n         return result;\n     }\n \n     /*\n      * Visits an SQL query and converts into a JOOQ MockResult type.\n      */\n-    private class QueryVisitor extends AstVisitor<MockResult, String> {\n+    private class QueryVisitor extends AstVisitor<MockResult, QueryContext> {\n         @Override\n-        protected MockResult visitQuerySpecification(final QuerySpecification node, String sql) {\n+        protected MockResult visitQuerySpecification(final QuerySpecification node, final QueryContext context) {\n             // The checks below encode assumption A1 (see javadoc for the DDlogJooqProvider class)\n             final Select select = node.getSelect();\n             if (!(select.getSelectItems().size() == 1\n                     && select.getSelectItems().get(0) instanceof AllColumns\n                     && node.getFrom().isPresent()\n                     && node.getFrom().get() instanceof com.facebook.presto.sql.tree.Table)) {\n-                throw new RuntimeException(\"Statement not supported: \" + sql);\n+                throw new RuntimeException(\"Statement not supported: \" + context.sql());\n             }\n             final String tableName = ((com.facebook.presto.sql.tree.Table) node.getFrom().get()).getName().toString();\n             final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n             if (fields == null) {\n-                throw new RuntimeException(String.format(\"Unknown table %s queried in statement: %s\", tableName, sql));\n+                throw new RuntimeException(String.format(\"Unknown table %s queried in statement: %s\", tableName,\n+                                           context.sql()));\n             }\n             final Result<Record> result = dslContext.newResult(fields);\n             result.addAll(materializedViews.computeIfAbsent(tableName.toUpperCase(), (k) -> new LinkedHashSet<>()));\n             return new MockResult(1, result);\n         }\n \n         @Override\n-        protected MockResult visitQuery(final Query node, final String context) {\n+        protected MockResult visitQuery(final Query node, final QueryContext context) {\n             final QuerySpecification specification = (QuerySpecification) node.getQueryBody();\n             return visitQuerySpecification(specification, context);\n         }\n \n         @Override\n-        protected MockResult visitInsert(final Insert node, final String sql) {\n+        protected MockResult visitInsert(final Insert node, final QueryContext context) {\n             try {\n                 // The assertions below encode assumption A2 (see javadoc for the DDlogJooqProvider class)\n                 if (!(node.getQuery().getQueryBody() instanceof Values)) {\n-                    throw new RuntimeException(\"Statement not supported: \" + sql);\n+                    throw new RuntimeException(\"Statement not supported: \" + context.sql());\n                 }\n                 final Values values = (Values) node.getQuery().getQueryBody();\n                 final String tableName = node.getTarget().toString();\n                 final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n                 final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n+                int bindingIndex = 0;\n                 for (final Expression row: values.getRows()) {\n                     if (!(row instanceof Row)) {\n-                        throw new RuntimeException(\"Statement not supported: \" + sql);\n+                        throw new RuntimeException(\"Statement not supported: \" + context.sql());\n                     }\n                     final List<Expression> items = ((Row) row).getItems();\n                     if (items.size() != fields.size()) {\n-                        throw new RuntimeException(\n-                                String.format(\"Incorrect row size for insertion into table %s: %s\", tableName, sql));\n+                        final String error = String.format(\"Incorrect row size for insertion into table %s. \" +\n+                                                   \"Please specify all the table's fields in their declared order: %s\",\n+                                                    tableName, context.sql());\n+                        throw new RuntimeException(error);\n                     }\n                     final DDlogRecord[] recordsArray = new DDlogRecord[items.size()];\n-                    for (int i = 0; i < items.size(); i++) {\n-                        recordsArray[i] = parseLiterals.process(items.get(i), fields.get(i).getDataType().nullable());\n+                    if (context.hasBinding()) {\n+                        // Is a statement with bind variables\n+                        for (int i = 0; i < items.size(); i++) {\n+                            final boolean isNullableField = fields.get(i).getDataType().nullable();\n+                            final DDlogRecord record = toValue(fields.get(i), context.binding()[bindingIndex]);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ2MzU5Mg=="}, "originalCommit": {"oid": "8f93a5a3ee5c8fe1c497dc2c0489fd6e13bf6f59"}, "originalPosition": 127}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4664, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}