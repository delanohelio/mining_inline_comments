{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY2OTg2MjY4", "number": 737, "title": "D3log realization sinks api", "bodyText": "This pull request continues the refactoring of the Realization interface by extending functionality to the sink side. These additions include the ability to add and remove both file and tcp sender sinks. The functionality also includes the ability to add and remove sink accumulators. The following is a list of functionality added:\n\nImplements add_sink() and remove_sink() for both file sinks and tcp sender sinks.\nImplements add_sink_accumulator() and remove_sink_accumulator().\nRefactors add_tcp_senders() and add_file_sinks() to use this new API.\nFixes existing bug where a new stream was being added to the server for every sink, instead of a new stream added to the server for each accumulator.\nAdds multiple functions to Realization for the purpose of unit testing. Unit testing for Realization is done in server_api, and because elements of Realization are private, a few helper functions were needed.\nAdds unit tests to exercise the new changes to the Realization API.", "createdAt": "2020-08-12T20:19:38Z", "url": "https://github.com/vmware/differential-datalog/pull/737", "merged": true, "mergeCommit": {"oid": "645308b1dce28cdef6f118e98428e711d6d8e823"}, "closed": true, "closedAt": "2020-08-24T17:19:52Z", "author": {"login": "krs85"}, "timelineItems": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc_ibLRAFqTQ2ODAxNjYyNA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdCE0DzABqjM2ODYxNDM5ODg=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4MDE2NjI0", "url": "https://github.com/vmware/differential-datalog/pull/737#pullrequestreview-468016624", "createdAt": "2020-08-15T20:42:37Z", "commit": {"oid": "5d11e192f5043ab1af92b1f7ad6a7d3804d550b8"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNVQyMDo0MjozN1rOHBNhFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNlQxODo0ODo1N1rOHBUb5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTAzMjA4NA==", "bodyText": "why not implement Default to keep clippy happy?", "url": "https://github.com/vmware/differential-datalog/pull/737#discussion_r471032084", "createdAt": "2020-08-15T20:42:37Z", "author": {"login": "ryzhyk"}, "path": "rust/template/distributed_datalog/src/instantiate.rs", "diffHunk": "@@ -316,20 +196,36 @@ where\n     >,\n     /// The transaction multiplexer as input to the DDLogServer\n     _txnmux: TxnMux<Update<DDValue>, String>,\n-    /// All sink accumulators of this realization to connect new nodes to\n-    _accumulators: HashMap<\n+    /// All sinks of this realization with their subscription\n+    _sinks: HashMap<\n         BTreeSet<RelId>,\n-        SharedObserver<DistributingAccumulator<Update<DDValue>, DDValue, String>>,\n+        (\n+            SharedObserver<DistributingAccumulator<Update<DDValue>, DDValue, String>>,\n+            UpdatesObservable<Update<DDValue>, String>,\n+            HashMap<Sink, (SinkRealization<P::Convert>, usize)>,\n+        ),\n     >,\n-    /// All sinks of this realization with their subscription\n-    _sinks: HashMap<BTreeSet<RelId>, Vec<(SinkRealization<P::Convert>, usize)>>,\n }\n \n impl<P> Realization<P>\n where\n     P: Send + DDlog + 'static,\n     P::Convert: Send + DDlogConvert,\n {\n+    /// Instantiates a new, default Realization.\n+    #[allow(clippy::new_without_default)]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5d11e192f5043ab1af92b1f7ad6a7d3804d550b8"}, "originalPosition": 204}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTAzMjQzNQ==", "bodyText": "A more accurate error message would indicate that the sink was not found and would also print the sink in question.", "url": "https://github.com/vmware/differential-datalog/pull/737#discussion_r471032435", "createdAt": "2020-08-15T20:47:23Z", "author": {"login": "ryzhyk"}, "path": "rust/template/distributed_datalog/src/instantiate.rs", "diffHunk": "@@ -405,13 +301,218 @@ where\n         }\n     }\n \n+    /// Remove file sink or tcp sender from an existing Realization.\n+    /// Locate the entry in _sinks whose map contains the sink.\n+    /// Remove the entry from the sink map.\n+    /// Unsubscribe the accumulator from the sink.\n+    /// Return an error if unable to find a sink map containing the sink.\n+    pub fn remove_sink(&mut self, sink: &Sink) -> Result<(), String> {\n+        for (accumulator, _, sink_map) in self._sinks.values_mut() {\n+            if sink_map.contains_key(sink) {\n+                let (_, subscription) = sink_map.remove(sink).unwrap();\n+                let _ = accumulator.unsubscribe(&subscription);\n+                return Ok(());\n+            }\n+        }\n+        Err(\"failed to remove sink from realization\".to_string())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5d11e192f5043ab1af92b1f7ad6a7d3804d550b8"}, "originalPosition": 246}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTE0Mjg2Mg==", "bodyText": "file sink -> TCP sink", "url": "https://github.com/vmware/differential-datalog/pull/737#discussion_r471142862", "createdAt": "2020-08-16T18:20:47Z", "author": {"login": "ryzhyk"}, "path": "rust/template/distributed_datalog/src/instantiate.rs", "diffHunk": "@@ -405,13 +301,218 @@ where\n         }\n     }\n \n+    /// Remove file sink or tcp sender from an existing Realization.\n+    /// Locate the entry in _sinks whose map contains the sink.\n+    /// Remove the entry from the sink map.\n+    /// Unsubscribe the accumulator from the sink.\n+    /// Return an error if unable to find a sink map containing the sink.\n+    pub fn remove_sink(&mut self, sink: &Sink) -> Result<(), String> {\n+        for (accumulator, _, sink_map) in self._sinks.values_mut() {\n+            if sink_map.contains_key(sink) {\n+                let (_, subscription) = sink_map.remove(sink).unwrap();\n+                let _ = accumulator.unsubscribe(&subscription);\n+                return Ok(());\n+            }\n+        }\n+        Err(\"failed to remove sink from realization\".to_string())\n+    }\n+\n+    /// Add file sink or tcp sender to an existing Realization.\n+    /// Creates and adds accumulator for this rel_ids to the Realization if needed.\n+    /// Subscribes the accumulator to the sink and adds the sink to\n+    /// the accumulator's map.\n+    pub fn add_sink(\n+        &mut self,\n+        sink: &Sink,\n+        rel_ids: BTreeSet<RelId>,\n+        server: &mut DDlogServer<P>,\n+    ) -> Result<(), String> {\n+        // Add the accumulator to the realization if needed.\n+        self.add_sink_accumulator(rel_ids.clone(), server)?;\n+        let (accumulator, _, sink_map) = self._sinks.get_mut(&rel_ids).unwrap();\n+\n+        match sink {\n+            Sink::File(path) => {\n+                let file = File::create(path)\n+                    .map_err(|e| format!(\"failed to create file {}:, {}\", path.display(), e))?;\n+                let file_sink = Arc::new(Mutex::new(FileSink::<P::Convert>::new(file)));\n+\n+                // Subscribe the accumulator to this sink.\n+                let subscription = accumulator\n+                    .lock()\n+                    .unwrap()\n+                    .subscribe(Box::new(file_sink.clone()))\n+                    .map_err(|_| \"failed to subscribe file sink to accumulator\".to_string())?;\n+\n+                // Add sink to sink map for this accumulator.\n+                let _ = sink_map.insert(\n+                    sink.clone(),\n+                    (SinkRealization::File(file_sink), subscription),\n+                );\n+            }\n+            Sink::TcpSender(addr) => {\n+                match addr {\n+                    Addr::Ip(address) => {\n+                        let tcp_sender = TcpSender::new(*address)\n+                            .map_err(|e| format!(\"failed to create TcpSender socket: {}\", e))?;\n+                        let sink = Arc::new(Mutex::new(tcp_sender));\n+\n+                        // Subscribe the accumulator to this sink.\n+                        let subscription = accumulator\n+                            .lock()\n+                            .unwrap()\n+                            .subscribe(Box::new(sink.clone()))\n+                            .map_err(|_| \"failed to subscribe file sink to accumulator\")?;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5d11e192f5043ab1af92b1f7ad6a7d3804d550b8"}, "originalPosition": 294}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTE0Mzk0Mw==", "bodyText": "accum is the last reference to this accumulator, right? So shouldn't it clear itself internal state as it goes out of scope?", "url": "https://github.com/vmware/differential-datalog/pull/737#discussion_r471143943", "createdAt": "2020-08-16T18:32:10Z", "author": {"login": "ryzhyk"}, "path": "rust/template/distributed_datalog/src/instantiate.rs", "diffHunk": "@@ -405,13 +301,218 @@ where\n         }\n     }\n \n+    /// Remove file sink or tcp sender from an existing Realization.\n+    /// Locate the entry in _sinks whose map contains the sink.\n+    /// Remove the entry from the sink map.\n+    /// Unsubscribe the accumulator from the sink.\n+    /// Return an error if unable to find a sink map containing the sink.\n+    pub fn remove_sink(&mut self, sink: &Sink) -> Result<(), String> {\n+        for (accumulator, _, sink_map) in self._sinks.values_mut() {\n+            if sink_map.contains_key(sink) {\n+                let (_, subscription) = sink_map.remove(sink).unwrap();\n+                let _ = accumulator.unsubscribe(&subscription);\n+                return Ok(());\n+            }\n+        }\n+        Err(\"failed to remove sink from realization\".to_string())\n+    }\n+\n+    /// Add file sink or tcp sender to an existing Realization.\n+    /// Creates and adds accumulator for this rel_ids to the Realization if needed.\n+    /// Subscribes the accumulator to the sink and adds the sink to\n+    /// the accumulator's map.\n+    pub fn add_sink(\n+        &mut self,\n+        sink: &Sink,\n+        rel_ids: BTreeSet<RelId>,\n+        server: &mut DDlogServer<P>,\n+    ) -> Result<(), String> {\n+        // Add the accumulator to the realization if needed.\n+        self.add_sink_accumulator(rel_ids.clone(), server)?;\n+        let (accumulator, _, sink_map) = self._sinks.get_mut(&rel_ids).unwrap();\n+\n+        match sink {\n+            Sink::File(path) => {\n+                let file = File::create(path)\n+                    .map_err(|e| format!(\"failed to create file {}:, {}\", path.display(), e))?;\n+                let file_sink = Arc::new(Mutex::new(FileSink::<P::Convert>::new(file)));\n+\n+                // Subscribe the accumulator to this sink.\n+                let subscription = accumulator\n+                    .lock()\n+                    .unwrap()\n+                    .subscribe(Box::new(file_sink.clone()))\n+                    .map_err(|_| \"failed to subscribe file sink to accumulator\".to_string())?;\n+\n+                // Add sink to sink map for this accumulator.\n+                let _ = sink_map.insert(\n+                    sink.clone(),\n+                    (SinkRealization::File(file_sink), subscription),\n+                );\n+            }\n+            Sink::TcpSender(addr) => {\n+                match addr {\n+                    Addr::Ip(address) => {\n+                        let tcp_sender = TcpSender::new(*address)\n+                            .map_err(|e| format!(\"failed to create TcpSender socket: {}\", e))?;\n+                        let sink = Arc::new(Mutex::new(tcp_sender));\n+\n+                        // Subscribe the accumulator to this sink.\n+                        let subscription = accumulator\n+                            .lock()\n+                            .unwrap()\n+                            .subscribe(Box::new(sink.clone()))\n+                            .map_err(|_| \"failed to subscribe file sink to accumulator\")?;\n+\n+                        // Add sink to sink map for this accumulator.\n+                        let _ = sink_map.insert(\n+                            Sink::TcpSender(*addr),\n+                            (SinkRealization::Node(sink), subscription),\n+                        );\n+                    }\n+                }\n+            }\n+        }\n+        Ok(())\n+    }\n+\n+    /// Remove the sink accumulator from the realization.\n+    /// Remove accumulator's entry (keyed by rel_ids) from _sinks.\n+    /// Disconnect accumulator from the server:\n+    /// - Unsubscribe the stream from the accumulator.\n+    /// - Remove the stream from the server.\n+    /// Clear the accumulator.\n+    pub fn remove_sink_accumulator(\n+        &mut self,\n+        rel_ids: BTreeSet<RelId>,\n+        server: &mut DDlogServer<P>,\n+    ) -> Result<(), String> {\n+        if let Some(entry) = self._sinks.remove(&rel_ids) {\n+            let (accumulator, mut stream, sink_map) = entry;\n+            if sink_map.is_empty() {\n+                // Disconnect accumulator from server.\n+                // First, unsubscribe the stream from the accumulator.\n+                let _ = stream.unsubscribe(&());\n+                // Next, remove the stream from the server.\n+                server.remove_stream(stream);\n+\n+                let mut accum = accumulator.lock().unwrap();\n+                // Clear the accumulator.\n+                if accum.clear().is_ok() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5d11e192f5043ab1af92b1f7ad6a7d3804d550b8"}, "originalPosition": 330}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTE0NDI3MA==", "bodyText": "Why is this a transaction-in-progress error as opposed to just accumulator still having sinks attached to it?", "url": "https://github.com/vmware/differential-datalog/pull/737#discussion_r471144270", "createdAt": "2020-08-16T18:35:30Z", "author": {"login": "ryzhyk"}, "path": "rust/template/distributed_datalog/src/instantiate.rs", "diffHunk": "@@ -405,13 +301,218 @@ where\n         }\n     }\n \n+    /// Remove file sink or tcp sender from an existing Realization.\n+    /// Locate the entry in _sinks whose map contains the sink.\n+    /// Remove the entry from the sink map.\n+    /// Unsubscribe the accumulator from the sink.\n+    /// Return an error if unable to find a sink map containing the sink.\n+    pub fn remove_sink(&mut self, sink: &Sink) -> Result<(), String> {\n+        for (accumulator, _, sink_map) in self._sinks.values_mut() {\n+            if sink_map.contains_key(sink) {\n+                let (_, subscription) = sink_map.remove(sink).unwrap();\n+                let _ = accumulator.unsubscribe(&subscription);\n+                return Ok(());\n+            }\n+        }\n+        Err(\"failed to remove sink from realization\".to_string())\n+    }\n+\n+    /// Add file sink or tcp sender to an existing Realization.\n+    /// Creates and adds accumulator for this rel_ids to the Realization if needed.\n+    /// Subscribes the accumulator to the sink and adds the sink to\n+    /// the accumulator's map.\n+    pub fn add_sink(\n+        &mut self,\n+        sink: &Sink,\n+        rel_ids: BTreeSet<RelId>,\n+        server: &mut DDlogServer<P>,\n+    ) -> Result<(), String> {\n+        // Add the accumulator to the realization if needed.\n+        self.add_sink_accumulator(rel_ids.clone(), server)?;\n+        let (accumulator, _, sink_map) = self._sinks.get_mut(&rel_ids).unwrap();\n+\n+        match sink {\n+            Sink::File(path) => {\n+                let file = File::create(path)\n+                    .map_err(|e| format!(\"failed to create file {}:, {}\", path.display(), e))?;\n+                let file_sink = Arc::new(Mutex::new(FileSink::<P::Convert>::new(file)));\n+\n+                // Subscribe the accumulator to this sink.\n+                let subscription = accumulator\n+                    .lock()\n+                    .unwrap()\n+                    .subscribe(Box::new(file_sink.clone()))\n+                    .map_err(|_| \"failed to subscribe file sink to accumulator\".to_string())?;\n+\n+                // Add sink to sink map for this accumulator.\n+                let _ = sink_map.insert(\n+                    sink.clone(),\n+                    (SinkRealization::File(file_sink), subscription),\n+                );\n+            }\n+            Sink::TcpSender(addr) => {\n+                match addr {\n+                    Addr::Ip(address) => {\n+                        let tcp_sender = TcpSender::new(*address)\n+                            .map_err(|e| format!(\"failed to create TcpSender socket: {}\", e))?;\n+                        let sink = Arc::new(Mutex::new(tcp_sender));\n+\n+                        // Subscribe the accumulator to this sink.\n+                        let subscription = accumulator\n+                            .lock()\n+                            .unwrap()\n+                            .subscribe(Box::new(sink.clone()))\n+                            .map_err(|_| \"failed to subscribe file sink to accumulator\")?;\n+\n+                        // Add sink to sink map for this accumulator.\n+                        let _ = sink_map.insert(\n+                            Sink::TcpSender(*addr),\n+                            (SinkRealization::Node(sink), subscription),\n+                        );\n+                    }\n+                }\n+            }\n+        }\n+        Ok(())\n+    }\n+\n+    /// Remove the sink accumulator from the realization.\n+    /// Remove accumulator's entry (keyed by rel_ids) from _sinks.\n+    /// Disconnect accumulator from the server:\n+    /// - Unsubscribe the stream from the accumulator.\n+    /// - Remove the stream from the server.\n+    /// Clear the accumulator.\n+    pub fn remove_sink_accumulator(\n+        &mut self,\n+        rel_ids: BTreeSet<RelId>,\n+        server: &mut DDlogServer<P>,\n+    ) -> Result<(), String> {\n+        if let Some(entry) = self._sinks.remove(&rel_ids) {\n+            let (accumulator, mut stream, sink_map) = entry;\n+            if sink_map.is_empty() {\n+                // Disconnect accumulator from server.\n+                // First, unsubscribe the stream from the accumulator.\n+                let _ = stream.unsubscribe(&());\n+                // Next, remove the stream from the server.\n+                server.remove_stream(stream);\n+\n+                let mut accum = accumulator.lock().unwrap();\n+                // Clear the accumulator.\n+                if accum.clear().is_ok() {\n+                    Ok(())\n+                } else {\n+                    Err(\"Cannot remove accumulator, failed to clear\".to_string())\n+                }\n+            } else {\n+                Err(\"Cannot remove accumulator, transaction in progress\".to_string())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5d11e192f5043ab1af92b1f7ad6a7d3804d550b8"}, "originalPosition": 336}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTE0NDU4MA==", "bodyText": "Please annotate all methods used for testing with #[cfg(test)].", "url": "https://github.com/vmware/differential-datalog/pull/737#discussion_r471144580", "createdAt": "2020-08-16T18:38:50Z", "author": {"login": "ryzhyk"}, "path": "rust/template/distributed_datalog/src/instantiate.rs", "diffHunk": "@@ -405,13 +301,218 @@ where\n         }\n     }\n \n+    /// Remove file sink or tcp sender from an existing Realization.\n+    /// Locate the entry in _sinks whose map contains the sink.\n+    /// Remove the entry from the sink map.\n+    /// Unsubscribe the accumulator from the sink.\n+    /// Return an error if unable to find a sink map containing the sink.\n+    pub fn remove_sink(&mut self, sink: &Sink) -> Result<(), String> {\n+        for (accumulator, _, sink_map) in self._sinks.values_mut() {\n+            if sink_map.contains_key(sink) {\n+                let (_, subscription) = sink_map.remove(sink).unwrap();\n+                let _ = accumulator.unsubscribe(&subscription);\n+                return Ok(());\n+            }\n+        }\n+        Err(\"failed to remove sink from realization\".to_string())\n+    }\n+\n+    /// Add file sink or tcp sender to an existing Realization.\n+    /// Creates and adds accumulator for this rel_ids to the Realization if needed.\n+    /// Subscribes the accumulator to the sink and adds the sink to\n+    /// the accumulator's map.\n+    pub fn add_sink(\n+        &mut self,\n+        sink: &Sink,\n+        rel_ids: BTreeSet<RelId>,\n+        server: &mut DDlogServer<P>,\n+    ) -> Result<(), String> {\n+        // Add the accumulator to the realization if needed.\n+        self.add_sink_accumulator(rel_ids.clone(), server)?;\n+        let (accumulator, _, sink_map) = self._sinks.get_mut(&rel_ids).unwrap();\n+\n+        match sink {\n+            Sink::File(path) => {\n+                let file = File::create(path)\n+                    .map_err(|e| format!(\"failed to create file {}:, {}\", path.display(), e))?;\n+                let file_sink = Arc::new(Mutex::new(FileSink::<P::Convert>::new(file)));\n+\n+                // Subscribe the accumulator to this sink.\n+                let subscription = accumulator\n+                    .lock()\n+                    .unwrap()\n+                    .subscribe(Box::new(file_sink.clone()))\n+                    .map_err(|_| \"failed to subscribe file sink to accumulator\".to_string())?;\n+\n+                // Add sink to sink map for this accumulator.\n+                let _ = sink_map.insert(\n+                    sink.clone(),\n+                    (SinkRealization::File(file_sink), subscription),\n+                );\n+            }\n+            Sink::TcpSender(addr) => {\n+                match addr {\n+                    Addr::Ip(address) => {\n+                        let tcp_sender = TcpSender::new(*address)\n+                            .map_err(|e| format!(\"failed to create TcpSender socket: {}\", e))?;\n+                        let sink = Arc::new(Mutex::new(tcp_sender));\n+\n+                        // Subscribe the accumulator to this sink.\n+                        let subscription = accumulator\n+                            .lock()\n+                            .unwrap()\n+                            .subscribe(Box::new(sink.clone()))\n+                            .map_err(|_| \"failed to subscribe file sink to accumulator\")?;\n+\n+                        // Add sink to sink map for this accumulator.\n+                        let _ = sink_map.insert(\n+                            Sink::TcpSender(*addr),\n+                            (SinkRealization::Node(sink), subscription),\n+                        );\n+                    }\n+                }\n+            }\n+        }\n+        Ok(())\n+    }\n+\n+    /// Remove the sink accumulator from the realization.\n+    /// Remove accumulator's entry (keyed by rel_ids) from _sinks.\n+    /// Disconnect accumulator from the server:\n+    /// - Unsubscribe the stream from the accumulator.\n+    /// - Remove the stream from the server.\n+    /// Clear the accumulator.\n+    pub fn remove_sink_accumulator(\n+        &mut self,\n+        rel_ids: BTreeSet<RelId>,\n+        server: &mut DDlogServer<P>,\n+    ) -> Result<(), String> {\n+        if let Some(entry) = self._sinks.remove(&rel_ids) {\n+            let (accumulator, mut stream, sink_map) = entry;\n+            if sink_map.is_empty() {\n+                // Disconnect accumulator from server.\n+                // First, unsubscribe the stream from the accumulator.\n+                let _ = stream.unsubscribe(&());\n+                // Next, remove the stream from the server.\n+                server.remove_stream(stream);\n+\n+                let mut accum = accumulator.lock().unwrap();\n+                // Clear the accumulator.\n+                if accum.clear().is_ok() {\n+                    Ok(())\n+                } else {\n+                    Err(\"Cannot remove accumulator, failed to clear\".to_string())\n+                }\n+            } else {\n+                Err(\"Cannot remove accumulator, transaction in progress\".to_string())\n+            }\n+        } else {\n+            Err(\"Unable to locate accumulator to remove from _sinks\".to_string())\n+        }\n+    }\n+\n+    /// Creates and adds a sink accumulator to the existing Realization.\n+    /// Adds a stream to the server for the accumulator.\n+    /// Creates an entry in Realization _sinks for this rel_ids.\n+    pub fn add_sink_accumulator(\n+        &mut self,\n+        rel_ids: BTreeSet<RelId>,\n+        server: &mut DDlogServer<P>,\n+    ) -> Result<(), String> {\n+        if !self._sinks.contains_key(&rel_ids) {\n+            let accumulator = Arc::new(Mutex::new(DistributingAccumulator::new()));\n+            let mut update_observ = server.add_stream(rel_ids.clone());\n+            update_observ\n+                .subscribe(Box::new(accumulator.clone()))\n+                .map_err(|_| \"failed to subscribe accumulator to DDlogServer\".to_string())?;\n+\n+            let _ = self\n+                ._sinks\n+                .insert(rel_ids, (accumulator, update_observ, HashMap::new()));\n+        }\n+        Ok(())\n+    }\n+\n+    /// Checks that the given file source exists in the Realization.\n+    /// Used for testing.\n+    pub fn contains_file_source(&self, path: PathBuf) -> bool {\n+        self._sources.contains_key(&Source::File(path))\n+    }\n+\n+    /// Checks that a tcp receiver exists in the Realization.\n+    /// Used for testing.\n+    pub fn contains_tcp_receiver(&self) -> bool {\n+        self._sources.contains_key(&Source::TcpReceiver)\n+    }\n+\n+    /// Retrieves the id for the source (generated by the TxnMux).\n+    /// Used for testing.\n+    pub fn get_source_id(&self, path: PathBuf) -> usize {\n+        let (_, _, id) = self._sources.get(&Source::File(path)).unwrap();\n+        *id\n+    }\n+\n+    /// Retrieves the id for the TcpReceiver in the Realization.\n+    /// Used for testing.\n+    pub fn get_tcp_receiver_id(&self) -> usize {\n+        let (_, _, id) = self._sources.get(&Source::TcpReceiver).unwrap();\n+        *id\n+    }\n+\n+    /// Checks that the given source (checking by its id) is contained\n+    /// in the TxnMux's subscriptions.\n+    /// Used for testing.\n+    pub fn txn_subscription_exists(&self, id: usize) -> bool {\n+        self._txnmux.subscription_exists(id)\n+    }\n+\n+    /// Checks that the given sink both has an associated accumulator and\n+    /// that said accumulator is subscribed to the sink.\n+    /// Used for testing.\n+    pub fn accumulator_is_subscribed_to_sink(&self, rel_ids: BTreeSet<RelId>, sink: &Sink) -> bool {\n+        let (_, _, sink_map) = self._sinks.get(&rel_ids).unwrap();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5d11e192f5043ab1af92b1f7ad6a7d3804d550b8"}, "originalPosition": 402}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTE0NTQ0NQ==", "bodyText": "These tests look good, but we should also test the dataflow through the system, e.g., that connecting a new sink to an accumulatator brings it up to a correct state.\nLet's wrap up this PR and try to add more tests as a separate PR.", "url": "https://github.com/vmware/differential-datalog/pull/737#discussion_r471145445", "createdAt": "2020-08-16T18:48:57Z", "author": {"login": "ryzhyk"}, "path": "test/datalog_tests/server_api/tests/realization_tests.rs", "diffHunk": "@@ -0,0 +1,154 @@\n+#[cfg(test)]\n+mod tests {\n+    use distributed_datalog::{Addr, DDlogServer, Realization, Sink, Source};\n+    use server_api_ddlog::api::HDDlog;\n+    use std::collections::{BTreeSet, HashMap};\n+    use std::net::{IpAddr, Ipv4Addr, SocketAddr};\n+    use std::path::PathBuf;\n+    use tempfile::NamedTempFile;\n+\n+    #[test]\n+    fn add_and_then_remove_file_source_from_realization() {\n+        let mut realization = Realization::<HDDlog>::new();\n+\n+        let file = NamedTempFile::new().unwrap();\n+        let path = file.path();\n+        // Check that adding the file succeeds.\n+        assert_eq!(realization.add_file_source(path), Ok(()));\n+\n+        let pathbuf = PathBuf::from(path);\n+        // Check that realization has the file as a source.\n+        assert!(realization.contains_file_source(pathbuf.clone()));\n+        let source_id = realization.get_source_id((&path).to_path_buf());\n+        // Check TxnMux has subscription to source.\n+        assert!(realization.txn_subscription_exists(source_id));\n+\n+        // Check that removing the file sink succeeds.\n+        assert_eq!(\n+            realization.remove_source(&Source::File(pathbuf.clone())),\n+            Ok(())\n+        );\n+        // Check that the realization no longer contains the file sink.\n+        assert!(!realization.contains_file_source(pathbuf));\n+    }\n+\n+    #[test]\n+    fn add_and_then_remove_tcp_receiver_from_realization() {\n+        let mut realization = Realization::<HDDlog>::new();\n+\n+        let addr = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 5000);\n+        // Check that realization has tcp receiver.\n+        assert_eq!(realization.add_tcp_receiver(&addr), Ok(()));\n+\n+        let source_id = realization.get_tcp_receiver_id();\n+        // Check that TxnMux is subscribed to tcp receiver.\n+        assert!(realization.txn_subscription_exists(source_id));\n+        // Check that Realization contains the tcp receiver.\n+        assert!(realization.contains_tcp_receiver());\n+\n+        // Check that removing the tcp receiver succeeds.\n+        assert_eq!(realization.remove_source(&Source::TcpReceiver), Ok(()));\n+        // Check that the realization no longer contains the tcp receiver.\n+        assert!(!realization.contains_tcp_receiver());\n+    }\n+\n+    #[test]\n+    fn add_and_remove_tcp_sender_sink() {\n+        let mut realization = Realization::<HDDlog>::new();\n+\n+        // Set up dummy realization.\n+        let addr = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 5000);\n+        let mut rel_ids = BTreeSet::new();\n+        rel_ids.insert(1);\n+        rel_ids.insert(2);\n+        rel_ids.insert(3);\n+\n+        let mut server = DDlogServer::new(None, HashMap::new());\n+        let sink = Sink::TcpSender(Addr::Ip(addr));\n+\n+        // Check that realization successfully adds tcp sender sink.\n+        assert_eq!(\n+            realization.add_sink(&sink, rel_ids.clone(), &mut server),\n+            Ok(())\n+        );\n+        // Check that realization has an accumulator for the sink and that the\n+        // subscription exists.\n+        assert!(realization.accumulator_is_subscribed_to_sink(rel_ids.clone(), &sink));\n+\n+        // Check that realization successfully removes the tcp sender sink.\n+        assert_eq!(realization.remove_sink(&sink), Ok(()));\n+        assert!(!realization.accumulator_is_subscribed_to_sink(rel_ids.clone(), &sink));\n+\n+        // Check that the sink accumulator can be successfully removed.\n+        assert_eq!(\n+            realization.remove_sink_accumulator(rel_ids, &mut server),\n+            Ok(())\n+        );\n+    }\n+\n+    #[test]\n+    fn add_and_remove_file_sink() {\n+        // Set up dummy realization.\n+        let mut realization = Realization::<HDDlog>::new();\n+\n+        let file = NamedTempFile::new().unwrap();\n+        let path = file.path();\n+\n+        let mut rel_ids = BTreeSet::new();\n+        rel_ids.insert(1);\n+        rel_ids.insert(2);\n+        rel_ids.insert(3);\n+\n+        let pathbuf = PathBuf::from(path);\n+        let mut server = DDlogServer::new(None, HashMap::new());\n+        let sink = Sink::File(pathbuf);\n+\n+        // Check that realization successfully adds file sink.\n+        assert_eq!(\n+            realization.add_sink(&sink, rel_ids.clone(), &mut server),\n+            Ok(())\n+        );\n+        // Check that realization has an accumulator for the sink and that the\n+        // subscription exists.\n+        assert!(realization.accumulator_is_subscribed_to_sink(rel_ids.clone(), &sink));\n+\n+        // Check that realization successfully removes the file sink.\n+        assert_eq!(realization.remove_sink(&sink), Ok(()));\n+        assert!(!realization.accumulator_is_subscribed_to_sink(rel_ids.clone(), &sink));\n+\n+        // Check that the sink accumulator can be successfully removed.\n+        assert_eq!(\n+            realization.remove_sink_accumulator(rel_ids, &mut server),\n+            Ok(())\n+        );\n+    }\n+\n+    #[test]\n+    fn remove_sink_accumulator_prematurely() {\n+        // Should error if the accumulator to be removed still has sinks.\n+\n+        let mut realization = Realization::<HDDlog>::new();\n+\n+        let file = NamedTempFile::new().unwrap();\n+        let path = file.path();\n+\n+        let mut rel_ids = BTreeSet::new();\n+        rel_ids.insert(1);\n+        rel_ids.insert(2);\n+        rel_ids.insert(3);\n+\n+        let pathbuf = PathBuf::from(path);\n+        let mut server = DDlogServer::new(None, HashMap::new());\n+        let sink = Sink::File(pathbuf);\n+\n+        // Check that the sink is added successfully.\n+        assert_eq!(\n+            realization.add_sink(&sink, rel_ids.clone(), &mut server),\n+            Ok(())\n+        );\n+        // Check that removing the sink accumulator returns an error.\n+        assert!(realization\n+            .remove_sink_accumulator(rel_ids, &mut server)\n+            .is_err());\n+    }\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5d11e192f5043ab1af92b1f7ad6a7d3804d550b8"}, "originalPosition": 154}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5aaf233dca622d3a5bca71ab2609b44df4180d56", "author": {"user": {"login": "krs85", "name": "Kelly"}}, "url": "https://github.com/vmware/differential-datalog/commit/5aaf233dca622d3a5bca71ab2609b44df4180d56", "committedDate": "2020-08-24T15:54:09Z", "message": "wip for add and removing sinks and sink accums"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1a65f06c540cb8c177a381f7acd3a1a4a585146e", "author": {"user": {"login": "krs85", "name": "Kelly"}}, "url": "https://github.com/vmware/differential-datalog/commit/1a65f06c540cb8c177a381f7acd3a1a4a585146e", "committedDate": "2020-08-24T15:54:09Z", "message": "wip still"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "809250ac9e806ac5676e141dcae4a2e329ef3a03", "author": {"user": {"login": "krs85", "name": "Kelly"}}, "url": "https://github.com/vmware/differential-datalog/commit/809250ac9e806ac5676e141dcae4a2e329ef3a03", "committedDate": "2020-08-24T15:54:09Z", "message": "add_sink() and add_sink_accumulator()"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e58f59a1cc727a42ea9eb139f4c3e1ecc5fcaaf6", "author": {"user": {"login": "krs85", "name": "Kelly"}}, "url": "https://github.com/vmware/differential-datalog/commit/e58f59a1cc727a42ea9eb139f4c3e1ecc5fcaaf6", "committedDate": "2020-08-24T15:54:09Z", "message": "remove_sink()"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7716f9f0ff775467a6598150267cbc54d9d1e1c4", "author": {"user": {"login": "krs85", "name": "Kelly"}}, "url": "https://github.com/vmware/differential-datalog/commit/7716f9f0ff775467a6598150267cbc54d9d1e1c4", "committedDate": "2020-08-24T15:54:09Z", "message": "Changes _sinks entries to also contain the accumulator's stream, implements remove_sink_accumulator(), fixes add_sink_accumulator()"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4fa39a5e35434396cd6246b3b6dec2fff6ef6ee6", "author": {"user": {"login": "krs85", "name": "Kelly"}}, "url": "https://github.com/vmware/differential-datalog/commit/4fa39a5e35434396cd6246b3b6dec2fff6ef6ee6", "committedDate": "2020-08-24T15:54:09Z", "message": "small fix in comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "069f7e2efa851c4aeca52799e568384278cd93d3", "author": {"user": {"login": "krs85", "name": "Kelly"}}, "url": "https://github.com/vmware/differential-datalog/commit/069f7e2efa851c4aeca52799e568384278cd93d3", "committedDate": "2020-08-24T15:54:09Z", "message": "Fix clippy errors, fix silly unwrap call"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3be2fcbeafbad2dd7b6c7dad0f52c42c1aea381a", "author": {"user": {"login": "krs85", "name": "Kelly"}}, "url": "https://github.com/vmware/differential-datalog/commit/3be2fcbeafbad2dd7b6c7dad0f52c42c1aea381a", "committedDate": "2020-08-24T15:54:09Z", "message": "Finishes up implementation of sink side of Realization API. Adds basic unit tests for the new API and updates old tests."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0f9b1b0bac5d3fdd04958b22632318482329d4d3", "author": {"user": {"login": "krs85", "name": "Kelly"}}, "url": "https://github.com/vmware/differential-datalog/commit/0f9b1b0bac5d3fdd04958b22632318482329d4d3", "committedDate": "2020-08-24T15:54:09Z", "message": "Minor fixes for PR"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "780211cab70c58b148d994d53b5170ff753bbf8f", "author": {"user": {"login": "krs85", "name": "Kelly"}}, "url": "https://github.com/vmware/differential-datalog/commit/780211cab70c58b148d994d53b5170ff753bbf8f", "committedDate": "2020-08-24T15:54:09Z", "message": "Small clippy fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6eefb2aa59e4388fa856cb74823a50e60071365e", "author": {"user": {"login": "krs85", "name": "Kelly"}}, "url": "https://github.com/vmware/differential-datalog/commit/6eefb2aa59e4388fa856cb74823a50e60071365e", "committedDate": "2020-08-24T15:54:09Z", "message": "Remove unnecessary clear() for sink accumulator"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c6a94a4bdbb9597b2291e92e92f79364e15fd898", "author": {"user": {"login": "krs85", "name": "Kelly"}}, "url": "https://github.com/vmware/differential-datalog/commit/c6a94a4bdbb9597b2291e92e92f79364e15fd898", "committedDate": "2020-08-24T15:54:09Z", "message": "removing #cfg(test) annotations"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2fc12d727205a7496bbdd8606d13af8246f5d157", "author": {"user": {"login": "krs85", "name": "Kelly"}}, "url": "https://github.com/vmware/differential-datalog/commit/2fc12d727205a7496bbdd8606d13af8246f5d157", "committedDate": "2020-08-24T14:40:38Z", "message": "removing #cfg(test) annotations"}, "afterCommit": {"oid": "c6a94a4bdbb9597b2291e92e92f79364e15fd898", "author": {"user": {"login": "krs85", "name": "Kelly"}}, "url": "https://github.com/vmware/differential-datalog/commit/c6a94a4bdbb9597b2291e92e92f79364e15fd898", "committedDate": "2020-08-24T15:54:09Z", "message": "removing #cfg(test) annotations"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4592, "cost": 1, "resetAt": "2021-11-02T10:47:05Z"}}}