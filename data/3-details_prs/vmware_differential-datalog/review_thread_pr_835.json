{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMwNjM2MDkz", "number": 835, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwMzowOToyOVrOFCtLXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwMzowOToyOVrOFCtLXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4MzgxNjYxOnYy", "diffSide": "RIGHT", "path": "rust/template/differential_datalog/program/mod.rs", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwMzowOToyOVrOICANuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQwNzoyODozNlrOIDsVKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk3MTU3OQ==", "bodyText": "This is where this PR breaks things.  The original version takes a slice and traverses it multiple times.  The new version takes iterator.  It exhausts the iterator in the first loop, so subsequent call to rels.all always returns true, so filter does nothing.", "url": "https://github.com/vmware/differential-datalog/pull/835#discussion_r538971579", "createdAt": "2020-12-09T03:09:29Z", "author": {"login": "ryzhyk"}, "path": "rust/template/differential_datalog/program/mod.rs", "diffHunk": "@@ -1595,39 +1601,41 @@ impl Program {\n     }\n \n     /// Returns all input relations of the program\n-    fn input_relations(&self) -> Vec<RelId> {\n-        self.nodes\n-            .iter()\n-            .flat_map(|node| match node {\n-                ProgNode::Rel { rel: r } => {\n-                    if r.input {\n-                        vec![r.id]\n-                    } else {\n-                        vec![]\n-                    }\n+    fn input_relations<'a>(&'a self) -> impl Iterator<Item = RelId> + 'a {\n+        self.nodes.iter().filter_map(|node| match node {\n+            ProgNode::Rel { rel: r } => {\n+                if r.input {\n+                    Some(r.id)\n+                } else {\n+                    None\n                 }\n-                ProgNode::Apply { .. } => vec![],\n-                ProgNode::SCC { rels: rs } => {\n-                    for r in rs {\n-                        assert!(!r.rel.input, \"input relation ({}) in SCC\", r.rel.name);\n-                    }\n-                    vec![]\n+            }\n+            ProgNode::Apply { .. } => None,\n+            ProgNode::SCC { rels: rs } => {\n+                for r in rs {\n+                    assert!(!r.rel.input, \"input relation ({}) in SCC\", r.rel.name);\n                 }\n-            })\n-            .collect()\n+\n+                None\n+            }\n+        })\n     }\n \n     /// Return all relations required to compute rels, excluding recursive dependencies on rels\n-    fn dependencies(rels: &[&Relation]) -> FnvHashSet<Dep> {\n+    fn dependencies<'a, R>(mut rels: R) -> FnvHashSet<Dep>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da69fc29349860df3607d8f100120e3841a0ed48"}, "originalPosition": 233}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ0MDcxNw==", "bodyText": "@Kixiron , let me know if you'll have time to fix this; otherwise I can do it.", "url": "https://github.com/vmware/differential-datalog/pull/835#discussion_r539440717", "createdAt": "2020-12-09T16:12:21Z", "author": {"login": "ryzhyk"}, "path": "rust/template/differential_datalog/program/mod.rs", "diffHunk": "@@ -1595,39 +1601,41 @@ impl Program {\n     }\n \n     /// Returns all input relations of the program\n-    fn input_relations(&self) -> Vec<RelId> {\n-        self.nodes\n-            .iter()\n-            .flat_map(|node| match node {\n-                ProgNode::Rel { rel: r } => {\n-                    if r.input {\n-                        vec![r.id]\n-                    } else {\n-                        vec![]\n-                    }\n+    fn input_relations<'a>(&'a self) -> impl Iterator<Item = RelId> + 'a {\n+        self.nodes.iter().filter_map(|node| match node {\n+            ProgNode::Rel { rel: r } => {\n+                if r.input {\n+                    Some(r.id)\n+                } else {\n+                    None\n                 }\n-                ProgNode::Apply { .. } => vec![],\n-                ProgNode::SCC { rels: rs } => {\n-                    for r in rs {\n-                        assert!(!r.rel.input, \"input relation ({}) in SCC\", r.rel.name);\n-                    }\n-                    vec![]\n+            }\n+            ProgNode::Apply { .. } => None,\n+            ProgNode::SCC { rels: rs } => {\n+                for r in rs {\n+                    assert!(!r.rel.input, \"input relation ({}) in SCC\", r.rel.name);\n                 }\n-            })\n-            .collect()\n+\n+                None\n+            }\n+        })\n     }\n \n     /// Return all relations required to compute rels, excluding recursive dependencies on rels\n-    fn dependencies(rels: &[&Relation]) -> FnvHashSet<Dep> {\n+    fn dependencies<'a, R>(mut rels: R) -> FnvHashSet<Dep>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk3MTU3OQ=="}, "originalCommit": {"oid": "da69fc29349860df3607d8f100120e3841a0ed48"}, "originalPosition": 233}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDY5MTkzNg==", "bodyText": "This is not performance-critical code, but your improvements still make things cleaner.\n\nI take it back. It turns out that struct Program can grow huge for large programs due all the strings that are further bloated by type annotations injected by the type checker. I really like this PR now as it avoids cloning this struct. I am going to fix the bug and merge.", "url": "https://github.com/vmware/differential-datalog/pull/835#discussion_r540691936", "createdAt": "2020-12-11T05:00:38Z", "author": {"login": "ryzhyk"}, "path": "rust/template/differential_datalog/program/mod.rs", "diffHunk": "@@ -1595,39 +1601,41 @@ impl Program {\n     }\n \n     /// Returns all input relations of the program\n-    fn input_relations(&self) -> Vec<RelId> {\n-        self.nodes\n-            .iter()\n-            .flat_map(|node| match node {\n-                ProgNode::Rel { rel: r } => {\n-                    if r.input {\n-                        vec![r.id]\n-                    } else {\n-                        vec![]\n-                    }\n+    fn input_relations<'a>(&'a self) -> impl Iterator<Item = RelId> + 'a {\n+        self.nodes.iter().filter_map(|node| match node {\n+            ProgNode::Rel { rel: r } => {\n+                if r.input {\n+                    Some(r.id)\n+                } else {\n+                    None\n                 }\n-                ProgNode::Apply { .. } => vec![],\n-                ProgNode::SCC { rels: rs } => {\n-                    for r in rs {\n-                        assert!(!r.rel.input, \"input relation ({}) in SCC\", r.rel.name);\n-                    }\n-                    vec![]\n+            }\n+            ProgNode::Apply { .. } => None,\n+            ProgNode::SCC { rels: rs } => {\n+                for r in rs {\n+                    assert!(!r.rel.input, \"input relation ({}) in SCC\", r.rel.name);\n                 }\n-            })\n-            .collect()\n+\n+                None\n+            }\n+        })\n     }\n \n     /// Return all relations required to compute rels, excluding recursive dependencies on rels\n-    fn dependencies(rels: &[&Relation]) -> FnvHashSet<Dep> {\n+    fn dependencies<'a, R>(mut rels: R) -> FnvHashSet<Dep>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk3MTU3OQ=="}, "originalCommit": {"oid": "da69fc29349860df3607d8f100120e3841a0ed48"}, "originalPosition": 233}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDY5NDU3MQ==", "bodyText": "Actually, it's the other PR that does this, and it still copies the program once.", "url": "https://github.com/vmware/differential-datalog/pull/835#discussion_r540694571", "createdAt": "2020-12-11T05:09:33Z", "author": {"login": "ryzhyk"}, "path": "rust/template/differential_datalog/program/mod.rs", "diffHunk": "@@ -1595,39 +1601,41 @@ impl Program {\n     }\n \n     /// Returns all input relations of the program\n-    fn input_relations(&self) -> Vec<RelId> {\n-        self.nodes\n-            .iter()\n-            .flat_map(|node| match node {\n-                ProgNode::Rel { rel: r } => {\n-                    if r.input {\n-                        vec![r.id]\n-                    } else {\n-                        vec![]\n-                    }\n+    fn input_relations<'a>(&'a self) -> impl Iterator<Item = RelId> + 'a {\n+        self.nodes.iter().filter_map(|node| match node {\n+            ProgNode::Rel { rel: r } => {\n+                if r.input {\n+                    Some(r.id)\n+                } else {\n+                    None\n                 }\n-                ProgNode::Apply { .. } => vec![],\n-                ProgNode::SCC { rels: rs } => {\n-                    for r in rs {\n-                        assert!(!r.rel.input, \"input relation ({}) in SCC\", r.rel.name);\n-                    }\n-                    vec![]\n+            }\n+            ProgNode::Apply { .. } => None,\n+            ProgNode::SCC { rels: rs } => {\n+                for r in rs {\n+                    assert!(!r.rel.input, \"input relation ({}) in SCC\", r.rel.name);\n                 }\n-            })\n-            .collect()\n+\n+                None\n+            }\n+        })\n     }\n \n     /// Return all relations required to compute rels, excluding recursive dependencies on rels\n-    fn dependencies(rels: &[&Relation]) -> FnvHashSet<Dep> {\n+    fn dependencies<'a, R>(mut rels: R) -> FnvHashSet<Dep>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk3MTU3OQ=="}, "originalCommit": {"oid": "da69fc29349860df3607d8f100120e3841a0ed48"}, "originalPosition": 233}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDcyNTEwMw==", "bodyText": "I believe that self: Arc<Self> is valid in stable rust, that would allow not cloning the physical program any", "url": "https://github.com/vmware/differential-datalog/pull/835#discussion_r540725103", "createdAt": "2020-12-11T06:41:55Z", "author": {"login": "Kixiron"}, "path": "rust/template/differential_datalog/program/mod.rs", "diffHunk": "@@ -1595,39 +1601,41 @@ impl Program {\n     }\n \n     /// Returns all input relations of the program\n-    fn input_relations(&self) -> Vec<RelId> {\n-        self.nodes\n-            .iter()\n-            .flat_map(|node| match node {\n-                ProgNode::Rel { rel: r } => {\n-                    if r.input {\n-                        vec![r.id]\n-                    } else {\n-                        vec![]\n-                    }\n+    fn input_relations<'a>(&'a self) -> impl Iterator<Item = RelId> + 'a {\n+        self.nodes.iter().filter_map(|node| match node {\n+            ProgNode::Rel { rel: r } => {\n+                if r.input {\n+                    Some(r.id)\n+                } else {\n+                    None\n                 }\n-                ProgNode::Apply { .. } => vec![],\n-                ProgNode::SCC { rels: rs } => {\n-                    for r in rs {\n-                        assert!(!r.rel.input, \"input relation ({}) in SCC\", r.rel.name);\n-                    }\n-                    vec![]\n+            }\n+            ProgNode::Apply { .. } => None,\n+            ProgNode::SCC { rels: rs } => {\n+                for r in rs {\n+                    assert!(!r.rel.input, \"input relation ({}) in SCC\", r.rel.name);\n                 }\n-            })\n-            .collect()\n+\n+                None\n+            }\n+        })\n     }\n \n     /// Return all relations required to compute rels, excluding recursive dependencies on rels\n-    fn dependencies(rels: &[&Relation]) -> FnvHashSet<Dep> {\n+    fn dependencies<'a, R>(mut rels: R) -> FnvHashSet<Dep>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk3MTU3OQ=="}, "originalCommit": {"oid": "da69fc29349860df3607d8f100120e3841a0ed48"}, "originalPosition": 233}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDc0Mjk1NA==", "bodyText": "Good point. I'll try that too.  I am also going to change types of all strings in Program to Cow<String>, as these are typically static strings, so we don't need to allocate them even once.", "url": "https://github.com/vmware/differential-datalog/pull/835#discussion_r540742954", "createdAt": "2020-12-11T07:28:36Z", "author": {"login": "ryzhyk"}, "path": "rust/template/differential_datalog/program/mod.rs", "diffHunk": "@@ -1595,39 +1601,41 @@ impl Program {\n     }\n \n     /// Returns all input relations of the program\n-    fn input_relations(&self) -> Vec<RelId> {\n-        self.nodes\n-            .iter()\n-            .flat_map(|node| match node {\n-                ProgNode::Rel { rel: r } => {\n-                    if r.input {\n-                        vec![r.id]\n-                    } else {\n-                        vec![]\n-                    }\n+    fn input_relations<'a>(&'a self) -> impl Iterator<Item = RelId> + 'a {\n+        self.nodes.iter().filter_map(|node| match node {\n+            ProgNode::Rel { rel: r } => {\n+                if r.input {\n+                    Some(r.id)\n+                } else {\n+                    None\n                 }\n-                ProgNode::Apply { .. } => vec![],\n-                ProgNode::SCC { rels: rs } => {\n-                    for r in rs {\n-                        assert!(!r.rel.input, \"input relation ({}) in SCC\", r.rel.name);\n-                    }\n-                    vec![]\n+            }\n+            ProgNode::Apply { .. } => None,\n+            ProgNode::SCC { rels: rs } => {\n+                for r in rs {\n+                    assert!(!r.rel.input, \"input relation ({}) in SCC\", r.rel.name);\n                 }\n-            })\n-            .collect()\n+\n+                None\n+            }\n+        })\n     }\n \n     /// Return all relations required to compute rels, excluding recursive dependencies on rels\n-    fn dependencies(rels: &[&Relation]) -> FnvHashSet<Dep> {\n+    fn dependencies<'a, R>(mut rels: R) -> FnvHashSet<Dep>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk3MTU3OQ=="}, "originalCommit": {"oid": "da69fc29349860df3607d8f100120e3841a0ed48"}, "originalPosition": 233}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4683, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}