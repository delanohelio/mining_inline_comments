{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMyMDg1Nzc5", "number": 682, "reviewThreads": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QwMzoxMDo1MlrOEFOlaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNFQxNzozMjozMVrOEFViiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczOTE3Mjg5OnYy", "diffSide": "RIGHT", "path": "app/Main.hs", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QwMzoxMDo1MlrOGjVY1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQyMDo0OToxN1rOGkCOcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwMzc2NA==", "bodyText": "The compiler performs several source transformations. The help message should be clear as to which intermediate representation is being dumped.  In case we want to support dumping multiple intermediate representations in the future, the name of the flag should be more specific.", "url": "https://github.com/vmware/differential-datalog/pull/682#discussion_r439703764", "createdAt": "2020-06-13T03:10:52Z", "author": {"login": "ryzhyk"}, "path": "app/Main.hs", "diffHunk": "@@ -75,6 +77,8 @@ options = [ Option ['h'] [\"help\"]             (NoArg Help)\n           , Option []    [\"no-dynlib\"]        (NoArg NoDynLib)                  \"Do not generate dynamic library (default).\"\n           , Option []    [\"staticlib\"]        (NoArg StaticLib)                 \"Generate static library (default).\"\n           , Option []    [\"no-staticlib\"]     (NoArg NoStaticLib)               \"Do not generate static library.\"\n+          , Option ['g'] []                   (NoArg DebugHooks)                \"Enable debugging hooks.\"\n+          , Option []    [\"pp\"]               (NoArg DumpSource)                \"Dump the transformed source into an ast file (FILE.ast).\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8327f2c7a52ad61702434b97775ef7568a091860"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQzODM4Ng==", "bodyText": "Updated the help message. Let me know if it's ok now?", "url": "https://github.com/vmware/differential-datalog/pull/682#discussion_r440438386", "createdAt": "2020-06-15T20:49:17Z", "author": {"login": "haroldlim"}, "path": "app/Main.hs", "diffHunk": "@@ -75,6 +77,8 @@ options = [ Option ['h'] [\"help\"]             (NoArg Help)\n           , Option []    [\"no-dynlib\"]        (NoArg NoDynLib)                  \"Do not generate dynamic library (default).\"\n           , Option []    [\"staticlib\"]        (NoArg StaticLib)                 \"Generate static library (default).\"\n           , Option []    [\"no-staticlib\"]     (NoArg NoStaticLib)               \"Do not generate static library.\"\n+          , Option ['g'] []                   (NoArg DebugHooks)                \"Enable debugging hooks.\"\n+          , Option []    [\"pp\"]               (NoArg DumpSource)                \"Dump the transformed source into an ast file (FILE.ast).\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwMzc2NA=="}, "originalCommit": {"oid": "8327f2c7a52ad61702434b97775ef7568a091860"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczOTE3NjE5OnYy", "diffSide": "RIGHT", "path": "app/Main.hs", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QwMzoxODozMVrOGjVahA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQyMDo0NzozM1rOGkCK_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwNDE5Ng==", "bodyText": "It might be helpful to run validation again after injectDebuggingHooks, at least during debugging, just to catch bugs.", "url": "https://github.com/vmware/differential-datalog/pull/682#discussion_r439704196", "createdAt": "2020-06-13T03:18:31Z", "author": {"login": "ryzhyk"}, "path": "app/Main.hs", "diffHunk": "@@ -159,15 +169,22 @@ parseValidate Config{..} = do\n     d''' <- case confOutputInput of\n          \"\" -> return d''\n          x  ->  return $ progMirrorInputRelations d'' x\n-    d' <- case validate d''' of\n+    d'''' <- case validate d''' of\n                Left e   -> errorWithoutStackTrace $ \"error: \" ++ e\n-               Right d' -> return d'\n+               Right d'''' -> return d''''\n+    d' <- case confDebugHooks of\n+         False -> return d''''\n+         True  -> return $ injectDebuggingHooks d''''", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8327f2c7a52ad61702434b97775ef7568a091860"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQzNzUwMg==", "bodyText": "Do you want me to add additional validation step as part of this PR (or just do it for testing purposes). I've added it locally but didn't include it in the commit.", "url": "https://github.com/vmware/differential-datalog/pull/682#discussion_r440437502", "createdAt": "2020-06-15T20:47:33Z", "author": {"login": "haroldlim"}, "path": "app/Main.hs", "diffHunk": "@@ -159,15 +169,22 @@ parseValidate Config{..} = do\n     d''' <- case confOutputInput of\n          \"\" -> return d''\n          x  ->  return $ progMirrorInputRelations d'' x\n-    d' <- case validate d''' of\n+    d'''' <- case validate d''' of\n                Left e   -> errorWithoutStackTrace $ \"error: \" ++ e\n-               Right d' -> return d'\n+               Right d'''' -> return d''''\n+    d' <- case confDebugHooks of\n+         False -> return d''''\n+         True  -> return $ injectDebuggingHooks d''''", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwNDE5Ng=="}, "originalCommit": {"oid": "8327f2c7a52ad61702434b97775ef7568a091860"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczOTE4MDg1OnYy", "diffSide": "RIGHT", "path": "lib/debug.rs", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QwMzoyODo1NVrOGjVc-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QwMzoyODo1NVrOGjVc-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwNDgyNA==", "bodyText": "You should be able to do this as a one-liner using the write! macro. I can help with that. We should also figure out what is the best data format to use to communicate with the debugger.  For now, this looks good enough.", "url": "https://github.com/vmware/differential-datalog/pull/682#discussion_r439704824", "createdAt": "2020-06-13T03:28:55Z", "author": {"login": "ryzhyk"}, "path": "lib/debug.rs", "diffHunk": "@@ -0,0 +1,61 @@\n+use std::fmt;\n+use std::fs::OpenOptions;\n+use std::io::Write;\n+use std::string::ToString;\n+\n+pub fn debug_debug_event<T1: ToString, A1: fmt::Debug, A2: fmt::Debug>(\n+    operator_id: &u32,\n+    w: &std_DDWeight,\n+    ts: &T1,\n+    input1: &A1,\n+    out: &A2,\n+) {\n+    let mut file = OpenOptions::new()\n+        .append(true)\n+        .create(true)\n+        .open(\"debug.log\".to_string())\n+        .unwrap();\n+    let mut owned_string: String = \"\".to_owned();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8327f2c7a52ad61702434b97775ef7568a091860"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczOTE4MjU3OnYy", "diffSide": "RIGHT", "path": "src/Language/DifferentialDatalog/Compile.hs", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QwMzozMzoyMFrOGjVd5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QwMzozMzoyMFrOGjVd5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwNTA2Mg==", "bodyText": "Shortcut: map atomVal $ ruleLHS rl", "url": "https://github.com/vmware/differential-datalog/pull/682#discussion_r439705062", "createdAt": "2020-06-13T03:33:20Z", "author": {"login": "ryzhyk"}, "path": "src/Language/DifferentialDatalog/Compile.hs", "diffHunk": "@@ -2736,3 +2737,23 @@ mkInt v | v <= (toInteger (maxBound::Word128)) && v >= (toInteger (minBound::Wor\n         = \"Int::from_i128(\" <> pp v <> \")\"\n         | otherwise\n         = \"Int::parse_bytes(b\\\"\" <> pp v <> \"\\\", 10)\"\n+\n+-- Compute the atom or tuple of variables after the prefix of length n.\n+-- If this is the last term, then it is an expression of the LHS variables for each head\n+-- of the rule.\n+-- If this is the first term, then it's the atom of the RHSLiteral.\n+-- Otherwise, this is the variables from rhsVarsAfter converted into an ETuple expression.\n+recordAfterPrefix :: DatalogProgram -> Rule -> Int -> [Expr]\n+recordAfterPrefix d rl i =\n+  if i == length (ruleRHS rl) - 1\n+     then  map (\\lhs -> atomVal lhs) $ ruleLHS rl", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8327f2c7a52ad61702434b97775ef7568a091860"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczOTE4MzgxOnYy", "diffSide": "RIGHT", "path": "src/Language/DifferentialDatalog/Compile.hs", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QwMzozNjo0NFrOGjVehQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QwMzozNjo0NFrOGjVehQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwNTIyMQ==", "bodyText": "[eVar $ exprVar $ enode $ atomVal $ rhsAtom $ head $ ruleRHS rl]", "url": "https://github.com/vmware/differential-datalog/pull/682#discussion_r439705221", "createdAt": "2020-06-13T03:36:44Z", "author": {"login": "ryzhyk"}, "path": "src/Language/DifferentialDatalog/Compile.hs", "diffHunk": "@@ -2736,3 +2737,23 @@ mkInt v | v <= (toInteger (maxBound::Word128)) && v >= (toInteger (minBound::Wor\n         = \"Int::from_i128(\" <> pp v <> \")\"\n         | otherwise\n         = \"Int::parse_bytes(b\\\"\" <> pp v <> \"\\\", 10)\"\n+\n+-- Compute the atom or tuple of variables after the prefix of length n.\n+-- If this is the last term, then it is an expression of the LHS variables for each head\n+-- of the rule.\n+-- If this is the first term, then it's the atom of the RHSLiteral.\n+-- Otherwise, this is the variables from rhsVarsAfter converted into an ETuple expression.\n+recordAfterPrefix :: DatalogProgram -> Rule -> Int -> [Expr]\n+recordAfterPrefix d rl i =\n+  if i == length (ruleRHS rl) - 1\n+     then  map (\\lhs -> atomVal lhs) $ ruleLHS rl\n+     else if i == 0\n+             then [E EVar { exprPos = nopos,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8327f2c7a52ad61702434b97775ef7568a091860"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczOTE4NTAwOnYy", "diffSide": "RIGHT", "path": "src/Language/DifferentialDatalog/Compile.hs", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QwMzozOTozM1rOGjVfJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QwMzozOTozM1rOGjVfJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwNTM4Mg==", "bodyText": "You can use eTuple and eVar functions to shorten this.\nYou can also use the Haskell LambdaCase extension to abbreviate \\v -> case v of as just \\case.\nBetter yet, use name v to get the name of the variable without having to do case analysis.", "url": "https://github.com/vmware/differential-datalog/pull/682#discussion_r439705382", "createdAt": "2020-06-13T03:39:33Z", "author": {"login": "ryzhyk"}, "path": "src/Language/DifferentialDatalog/Compile.hs", "diffHunk": "@@ -2736,3 +2737,23 @@ mkInt v | v <= (toInteger (maxBound::Word128)) && v >= (toInteger (minBound::Wor\n         = \"Int::from_i128(\" <> pp v <> \")\"\n         | otherwise\n         = \"Int::parse_bytes(b\\\"\" <> pp v <> \"\\\", 10)\"\n+\n+-- Compute the atom or tuple of variables after the prefix of length n.\n+-- If this is the last term, then it is an expression of the LHS variables for each head\n+-- of the rule.\n+-- If this is the first term, then it's the atom of the RHSLiteral.\n+-- Otherwise, this is the variables from rhsVarsAfter converted into an ETuple expression.\n+recordAfterPrefix :: DatalogProgram -> Rule -> Int -> [Expr]\n+recordAfterPrefix d rl i =\n+  if i == length (ruleRHS rl) - 1\n+     then  map (\\lhs -> atomVal lhs) $ ruleLHS rl\n+     else if i == 0\n+             then [E EVar { exprPos = nopos,\n+                            exprVar = exprVar $ enode $ atomVal $ rhsAtom (ruleRHS rl !! i) }]\n+             else [E ETuple { exprPos = nopos,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8327f2c7a52ad61702434b97775ef7568a091860"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczOTE5MTE4OnYy", "diffSide": "RIGHT", "path": "src/Language/DifferentialDatalog/DatalogProgram.hs", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QwMzo1MzoyMFrOGjViKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QwMzo1MzoyMFrOGjViKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwNjE1NA==", "bodyText": "eBinding bindingName expr", "url": "https://github.com/vmware/differential-datalog/pull/682#discussion_r439706154", "createdAt": "2020-06-13T03:53:20Z", "author": {"login": "ryzhyk"}, "path": "src/Language/DifferentialDatalog/DatalogProgram.hs", "diffHunk": "@@ -307,3 +311,221 @@ progMirrorInputRelations d prefix =\n     rules = map (\\(n,r) -> makeRule n r) inputRels\n   in d { progRelations = M.union (progRelations d) $ M.fromList relCopies,\n          progRules     = (progRules d) ++ rules }\n+\n+-- For RHSLiteral, a binding to the expression is inserted if it's not bound to a variable.\n+-- For example, R(a, b, z, _) gets transformed into __r0 in R(a, b, z, _),\n+addBindingToRHSLiteral :: (RuleRHS, Int) -> RuleRHS\n+addBindingToRHSLiteral (r@RHSLiteral{}, index) =\n+  let\n+    bindingName = \"__\" ++ (map toLower $ atomRelation $ rhsAtom r) ++ (show index)\n+    expr = atomVal $ rhsAtom r\n+    exprNode = enode expr\n+    updatedAtomVal = case exprNode of\n+                     EBinding{} -> expr\n+                     _          -> E $ EBinding { exprPos = exprPos exprNode,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8327f2c7a52ad61702434b97775ef7568a091860"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczOTIwNDQ5OnYy", "diffSide": "RIGHT", "path": "src/Language/DifferentialDatalog/DatalogProgram.hs", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QwNDoyNzozNFrOGjVo8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQyMDo0ODowMVrOGkCMBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwNzg5MA==", "bodyText": "head is a bit nicer than !! 0.\nAlso, please use eTuple, eSet,eVarDecl, eTupField, eVar to shorten this code.", "url": "https://github.com/vmware/differential-datalog/pull/682#discussion_r439707890", "createdAt": "2020-06-13T04:27:34Z", "author": {"login": "ryzhyk"}, "path": "src/Language/DifferentialDatalog/DatalogProgram.hs", "diffHunk": "@@ -307,3 +311,221 @@ progMirrorInputRelations d prefix =\n     rules = map (\\(n,r) -> makeRule n r) inputRels\n   in d { progRelations = M.union (progRelations d) $ M.fromList relCopies,\n          progRules     = (progRules d) ++ rules }\n+\n+-- For RHSLiteral, a binding to the expression is inserted if it's not bound to a variable.\n+-- For example, R(a, b, z, _) gets transformed into __r0 in R(a, b, z, _),\n+addBindingToRHSLiteral :: (RuleRHS, Int) -> RuleRHS\n+addBindingToRHSLiteral (r@RHSLiteral{}, index) =\n+  let\n+    bindingName = \"__\" ++ (map toLower $ atomRelation $ rhsAtom r) ++ (show index)\n+    expr = atomVal $ rhsAtom r\n+    exprNode = enode expr\n+    updatedAtomVal = case exprNode of\n+                     EBinding{} -> expr\n+                     _          -> E $ EBinding { exprPos = exprPos exprNode,\n+                                                  exprVar = bindingName,\n+                                                  exprPattern = expr }\n+    updatedAtom = (rhsAtom r) { atomVal = updatedAtomVal }\n+  in r { rhsAtom = updatedAtom }\n+addBindingToRHSLiteral (rule, _) = rule\n+\n+-- For RHSAggregate, the aggregate function is prepended with __debug_\n+-- The input to the aggregate function is transformed into a tuple of\n+-- input to the aggregate operator and the original value.\n+-- The return variable is also prepended with __inputs_, which will now be\n+-- a tuple.\n+-- The corrddesponding compiler-generated function also outputs the set of\n+-- inputs, so that it is visible to the inspect operator.\n+-- an RHSCondition is also appended that declares and sets the original\n+-- return variable of the pre-updated aggregate operator.\n+updateRHSAggregate :: DatalogProgram -> Rule -> Int -> [RuleRHS]\n+updateRHSAggregate d rule index =\n+  let\n+     r = (ruleRHS rule) !! index\n+     funcName = \"__debug_\" ++ (rhsAggFunc r)\n+     varRet = \"__inputs_\" ++ (rhsVar r)\n+     input = E ETuple { exprPos = nopos,\n+                        exprTupleFields = [ (Compile.recordAfterPrefix d rule (index - 1)) !! 0,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8327f2c7a52ad61702434b97775ef7568a091860"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQzNzc2NA==", "bodyText": "Thanks. didn't realize we have those helper functions.", "url": "https://github.com/vmware/differential-datalog/pull/682#discussion_r440437764", "createdAt": "2020-06-15T20:48:01Z", "author": {"login": "haroldlim"}, "path": "src/Language/DifferentialDatalog/DatalogProgram.hs", "diffHunk": "@@ -307,3 +311,221 @@ progMirrorInputRelations d prefix =\n     rules = map (\\(n,r) -> makeRule n r) inputRels\n   in d { progRelations = M.union (progRelations d) $ M.fromList relCopies,\n          progRules     = (progRules d) ++ rules }\n+\n+-- For RHSLiteral, a binding to the expression is inserted if it's not bound to a variable.\n+-- For example, R(a, b, z, _) gets transformed into __r0 in R(a, b, z, _),\n+addBindingToRHSLiteral :: (RuleRHS, Int) -> RuleRHS\n+addBindingToRHSLiteral (r@RHSLiteral{}, index) =\n+  let\n+    bindingName = \"__\" ++ (map toLower $ atomRelation $ rhsAtom r) ++ (show index)\n+    expr = atomVal $ rhsAtom r\n+    exprNode = enode expr\n+    updatedAtomVal = case exprNode of\n+                     EBinding{} -> expr\n+                     _          -> E $ EBinding { exprPos = exprPos exprNode,\n+                                                  exprVar = bindingName,\n+                                                  exprPattern = expr }\n+    updatedAtom = (rhsAtom r) { atomVal = updatedAtomVal }\n+  in r { rhsAtom = updatedAtom }\n+addBindingToRHSLiteral (rule, _) = rule\n+\n+-- For RHSAggregate, the aggregate function is prepended with __debug_\n+-- The input to the aggregate function is transformed into a tuple of\n+-- input to the aggregate operator and the original value.\n+-- The return variable is also prepended with __inputs_, which will now be\n+-- a tuple.\n+-- The corrddesponding compiler-generated function also outputs the set of\n+-- inputs, so that it is visible to the inspect operator.\n+-- an RHSCondition is also appended that declares and sets the original\n+-- return variable of the pre-updated aggregate operator.\n+updateRHSAggregate :: DatalogProgram -> Rule -> Int -> [RuleRHS]\n+updateRHSAggregate d rule index =\n+  let\n+     r = (ruleRHS rule) !! index\n+     funcName = \"__debug_\" ++ (rhsAggFunc r)\n+     varRet = \"__inputs_\" ++ (rhsVar r)\n+     input = E ETuple { exprPos = nopos,\n+                        exprTupleFields = [ (Compile.recordAfterPrefix d rule (index - 1)) !! 0,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwNzg5MA=="}, "originalCommit": {"oid": "8327f2c7a52ad61702434b97775ef7568a091860"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczOTIwNzUxOnYy", "diffSide": "RIGHT", "path": "src/Language/DifferentialDatalog/DatalogProgram.hs", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QwNDozNToyOVrOGjVqgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QyMToyNjozMFrOGjZeKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwODI5MQ==", "bodyText": "Why not just make it a tuple?", "url": "https://github.com/vmware/differential-datalog/pull/682#discussion_r439708291", "createdAt": "2020-06-13T04:35:29Z", "author": {"login": "ryzhyk"}, "path": "src/Language/DifferentialDatalog/DatalogProgram.hs", "diffHunk": "@@ -307,3 +311,221 @@ progMirrorInputRelations d prefix =\n     rules = map (\\(n,r) -> makeRule n r) inputRels\n   in d { progRelations = M.union (progRelations d) $ M.fromList relCopies,\n          progRules     = (progRules d) ++ rules }\n+\n+-- For RHSLiteral, a binding to the expression is inserted if it's not bound to a variable.\n+-- For example, R(a, b, z, _) gets transformed into __r0 in R(a, b, z, _),\n+addBindingToRHSLiteral :: (RuleRHS, Int) -> RuleRHS\n+addBindingToRHSLiteral (r@RHSLiteral{}, index) =\n+  let\n+    bindingName = \"__\" ++ (map toLower $ atomRelation $ rhsAtom r) ++ (show index)\n+    expr = atomVal $ rhsAtom r\n+    exprNode = enode expr\n+    updatedAtomVal = case exprNode of\n+                     EBinding{} -> expr\n+                     _          -> E $ EBinding { exprPos = exprPos exprNode,\n+                                                  exprVar = bindingName,\n+                                                  exprPattern = expr }\n+    updatedAtom = (rhsAtom r) { atomVal = updatedAtomVal }\n+  in r { rhsAtom = updatedAtom }\n+addBindingToRHSLiteral (rule, _) = rule\n+\n+-- For RHSAggregate, the aggregate function is prepended with __debug_\n+-- The input to the aggregate function is transformed into a tuple of\n+-- input to the aggregate operator and the original value.\n+-- The return variable is also prepended with __inputs_, which will now be\n+-- a tuple.\n+-- The corrddesponding compiler-generated function also outputs the set of\n+-- inputs, so that it is visible to the inspect operator.\n+-- an RHSCondition is also appended that declares and sets the original\n+-- return variable of the pre-updated aggregate operator.\n+updateRHSAggregate :: DatalogProgram -> Rule -> Int -> [RuleRHS]\n+updateRHSAggregate d rule index =\n+  let\n+     r = (ruleRHS rule) !! index\n+     funcName = \"__debug_\" ++ (rhsAggFunc r)\n+     varRet = \"__inputs_\" ++ (rhsVar r)\n+     input = E ETuple { exprPos = nopos,\n+                        exprTupleFields = [ (Compile.recordAfterPrefix d rule (index - 1)) !! 0,\n+                                            (rhsAggExpr r) ] }\n+     rAgg = RHSAggregate { rhsVar = varRet,\n+                           rhsGroupBy = rhsGroupBy r,\n+                           rhsAggFunc = funcName,\n+                           rhsAggExpr = input }\n+     rCond = RHSCondition { rhsExpr = E ESet { exprPos = nopos,\n+                                               exprLVal = E EVarDecl { exprPos = nopos,\n+                                                                       exprVName = rhsVar r },\n+                                               exprRVal = E ETupField { exprPos = nopos,\n+                                                                        exprTuple = E EVar { exprPos = nopos,\n+                                                                                             exprVar = varRet },\n+                                                                        exprTupField = 1 } } }\n+  in [ rAgg, rCond ]\n+\n+-- OperatorID is based on rule index, rhs index and head index\n+-- The 12 MSB are reserved for the rule index.\n+-- The next 16 bits are reserved for the rhs index.\n+-- The 4 LSB are reserved for the head index.\n+generateOperatorIdExpr :: Int -> Int -> Int -> Expr\n+generateOperatorIdExpr rlIdx rhsIdx headIdx =\n+  let\n+    operatorId = toInteger $ (shiftL (rlIdx .&. 4095) 20) .|. (shiftL (rhsIdx .&. 32767) 4) .|. (headIdx .&. 15)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8327f2c7a52ad61702434b97775ef7568a091860"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc3MDY2Nw==", "bodyText": "Brain fart. Forgot that I can use tuples.", "url": "https://github.com/vmware/differential-datalog/pull/682#discussion_r439770667", "createdAt": "2020-06-13T21:26:30Z", "author": {"login": "haroldlim"}, "path": "src/Language/DifferentialDatalog/DatalogProgram.hs", "diffHunk": "@@ -307,3 +311,221 @@ progMirrorInputRelations d prefix =\n     rules = map (\\(n,r) -> makeRule n r) inputRels\n   in d { progRelations = M.union (progRelations d) $ M.fromList relCopies,\n          progRules     = (progRules d) ++ rules }\n+\n+-- For RHSLiteral, a binding to the expression is inserted if it's not bound to a variable.\n+-- For example, R(a, b, z, _) gets transformed into __r0 in R(a, b, z, _),\n+addBindingToRHSLiteral :: (RuleRHS, Int) -> RuleRHS\n+addBindingToRHSLiteral (r@RHSLiteral{}, index) =\n+  let\n+    bindingName = \"__\" ++ (map toLower $ atomRelation $ rhsAtom r) ++ (show index)\n+    expr = atomVal $ rhsAtom r\n+    exprNode = enode expr\n+    updatedAtomVal = case exprNode of\n+                     EBinding{} -> expr\n+                     _          -> E $ EBinding { exprPos = exprPos exprNode,\n+                                                  exprVar = bindingName,\n+                                                  exprPattern = expr }\n+    updatedAtom = (rhsAtom r) { atomVal = updatedAtomVal }\n+  in r { rhsAtom = updatedAtom }\n+addBindingToRHSLiteral (rule, _) = rule\n+\n+-- For RHSAggregate, the aggregate function is prepended with __debug_\n+-- The input to the aggregate function is transformed into a tuple of\n+-- input to the aggregate operator and the original value.\n+-- The return variable is also prepended with __inputs_, which will now be\n+-- a tuple.\n+-- The corrddesponding compiler-generated function also outputs the set of\n+-- inputs, so that it is visible to the inspect operator.\n+-- an RHSCondition is also appended that declares and sets the original\n+-- return variable of the pre-updated aggregate operator.\n+updateRHSAggregate :: DatalogProgram -> Rule -> Int -> [RuleRHS]\n+updateRHSAggregate d rule index =\n+  let\n+     r = (ruleRHS rule) !! index\n+     funcName = \"__debug_\" ++ (rhsAggFunc r)\n+     varRet = \"__inputs_\" ++ (rhsVar r)\n+     input = E ETuple { exprPos = nopos,\n+                        exprTupleFields = [ (Compile.recordAfterPrefix d rule (index - 1)) !! 0,\n+                                            (rhsAggExpr r) ] }\n+     rAgg = RHSAggregate { rhsVar = varRet,\n+                           rhsGroupBy = rhsGroupBy r,\n+                           rhsAggFunc = funcName,\n+                           rhsAggExpr = input }\n+     rCond = RHSCondition { rhsExpr = E ESet { exprPos = nopos,\n+                                               exprLVal = E EVarDecl { exprPos = nopos,\n+                                                                       exprVName = rhsVar r },\n+                                               exprRVal = E ETupField { exprPos = nopos,\n+                                                                        exprTuple = E EVar { exprPos = nopos,\n+                                                                                             exprVar = varRet },\n+                                                                        exprTupField = 1 } } }\n+  in [ rAgg, rCond ]\n+\n+-- OperatorID is based on rule index, rhs index and head index\n+-- The 12 MSB are reserved for the rule index.\n+-- The next 16 bits are reserved for the rhs index.\n+-- The 4 LSB are reserved for the head index.\n+generateOperatorIdExpr :: Int -> Int -> Int -> Expr\n+generateOperatorIdExpr rlIdx rhsIdx headIdx =\n+  let\n+    operatorId = toInteger $ (shiftL (rlIdx .&. 4095) 20) .|. (shiftL (rhsIdx .&. 32767) 4) .|. (headIdx .&. 15)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwODI5MQ=="}, "originalCommit": {"oid": "8327f2c7a52ad61702434b97775ef7568a091860"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczOTIxMDc4OnYy", "diffSide": "RIGHT", "path": "src/Language/DifferentialDatalog/DatalogProgram.hs", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QwNDo0NDoyNVrOGjVsLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QwNDo0NDoyNVrOGjVsLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwODcxOQ==", "bodyText": "eVar", "url": "https://github.com/vmware/differential-datalog/pull/682#discussion_r439708719", "createdAt": "2020-06-13T04:44:25Z", "author": {"login": "ryzhyk"}, "path": "src/Language/DifferentialDatalog/DatalogProgram.hs", "diffHunk": "@@ -307,3 +311,221 @@ progMirrorInputRelations d prefix =\n     rules = map (\\(n,r) -> makeRule n r) inputRels\n   in d { progRelations = M.union (progRelations d) $ M.fromList relCopies,\n          progRules     = (progRules d) ++ rules }\n+\n+-- For RHSLiteral, a binding to the expression is inserted if it's not bound to a variable.\n+-- For example, R(a, b, z, _) gets transformed into __r0 in R(a, b, z, _),\n+addBindingToRHSLiteral :: (RuleRHS, Int) -> RuleRHS\n+addBindingToRHSLiteral (r@RHSLiteral{}, index) =\n+  let\n+    bindingName = \"__\" ++ (map toLower $ atomRelation $ rhsAtom r) ++ (show index)\n+    expr = atomVal $ rhsAtom r\n+    exprNode = enode expr\n+    updatedAtomVal = case exprNode of\n+                     EBinding{} -> expr\n+                     _          -> E $ EBinding { exprPos = exprPos exprNode,\n+                                                  exprVar = bindingName,\n+                                                  exprPattern = expr }\n+    updatedAtom = (rhsAtom r) { atomVal = updatedAtomVal }\n+  in r { rhsAtom = updatedAtom }\n+addBindingToRHSLiteral (rule, _) = rule\n+\n+-- For RHSAggregate, the aggregate function is prepended with __debug_\n+-- The input to the aggregate function is transformed into a tuple of\n+-- input to the aggregate operator and the original value.\n+-- The return variable is also prepended with __inputs_, which will now be\n+-- a tuple.\n+-- The corrddesponding compiler-generated function also outputs the set of\n+-- inputs, so that it is visible to the inspect operator.\n+-- an RHSCondition is also appended that declares and sets the original\n+-- return variable of the pre-updated aggregate operator.\n+updateRHSAggregate :: DatalogProgram -> Rule -> Int -> [RuleRHS]\n+updateRHSAggregate d rule index =\n+  let\n+     r = (ruleRHS rule) !! index\n+     funcName = \"__debug_\" ++ (rhsAggFunc r)\n+     varRet = \"__inputs_\" ++ (rhsVar r)\n+     input = E ETuple { exprPos = nopos,\n+                        exprTupleFields = [ (Compile.recordAfterPrefix d rule (index - 1)) !! 0,\n+                                            (rhsAggExpr r) ] }\n+     rAgg = RHSAggregate { rhsVar = varRet,\n+                           rhsGroupBy = rhsGroupBy r,\n+                           rhsAggFunc = funcName,\n+                           rhsAggExpr = input }\n+     rCond = RHSCondition { rhsExpr = E ESet { exprPos = nopos,\n+                                               exprLVal = E EVarDecl { exprPos = nopos,\n+                                                                       exprVName = rhsVar r },\n+                                               exprRVal = E ETupField { exprPos = nopos,\n+                                                                        exprTuple = E EVar { exprPos = nopos,\n+                                                                                             exprVar = varRet },\n+                                                                        exprTupField = 1 } } }\n+  in [ rAgg, rCond ]\n+\n+-- OperatorID is based on rule index, rhs index and head index\n+-- The 12 MSB are reserved for the rule index.\n+-- The next 16 bits are reserved for the rhs index.\n+-- The 4 LSB are reserved for the head index.\n+generateOperatorIdExpr :: Int -> Int -> Int -> Expr\n+generateOperatorIdExpr rlIdx rhsIdx headIdx =\n+  let\n+    operatorId = toInteger $ (shiftL (rlIdx .&. 4095) 20) .|. (shiftL (rhsIdx .&. 32767) 4) .|. (headIdx .&. 15)\n+  in E EBit { exprPos = nopos,\n+               exprWidth = 32,\n+               exprIVal = operatorId }\n+\n+ddlogWeightExpr :: Expr\n+ddlogWeightExpr =\n+  E EVar { exprPos = nopos,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8327f2c7a52ad61702434b97775ef7568a091860"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczOTIxNDgxOnYy", "diffSide": "RIGHT", "path": "src/Language/DifferentialDatalog/DatalogProgram.hs", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QwNDo1NToxMVrOGjVucg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNFQxNjo1MToyMFrOGjeMyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwOTI5OA==", "bodyText": "Isn't the index==0 case covered by recordAfterPrefix?", "url": "https://github.com/vmware/differential-datalog/pull/682#discussion_r439709298", "createdAt": "2020-06-13T04:55:11Z", "author": {"login": "ryzhyk"}, "path": "src/Language/DifferentialDatalog/DatalogProgram.hs", "diffHunk": "@@ -307,3 +311,221 @@ progMirrorInputRelations d prefix =\n     rules = map (\\(n,r) -> makeRule n r) inputRels\n   in d { progRelations = M.union (progRelations d) $ M.fromList relCopies,\n          progRules     = (progRules d) ++ rules }\n+\n+-- For RHSLiteral, a binding to the expression is inserted if it's not bound to a variable.\n+-- For example, R(a, b, z, _) gets transformed into __r0 in R(a, b, z, _),\n+addBindingToRHSLiteral :: (RuleRHS, Int) -> RuleRHS\n+addBindingToRHSLiteral (r@RHSLiteral{}, index) =\n+  let\n+    bindingName = \"__\" ++ (map toLower $ atomRelation $ rhsAtom r) ++ (show index)\n+    expr = atomVal $ rhsAtom r\n+    exprNode = enode expr\n+    updatedAtomVal = case exprNode of\n+                     EBinding{} -> expr\n+                     _          -> E $ EBinding { exprPos = exprPos exprNode,\n+                                                  exprVar = bindingName,\n+                                                  exprPattern = expr }\n+    updatedAtom = (rhsAtom r) { atomVal = updatedAtomVal }\n+  in r { rhsAtom = updatedAtom }\n+addBindingToRHSLiteral (rule, _) = rule\n+\n+-- For RHSAggregate, the aggregate function is prepended with __debug_\n+-- The input to the aggregate function is transformed into a tuple of\n+-- input to the aggregate operator and the original value.\n+-- The return variable is also prepended with __inputs_, which will now be\n+-- a tuple.\n+-- The corrddesponding compiler-generated function also outputs the set of\n+-- inputs, so that it is visible to the inspect operator.\n+-- an RHSCondition is also appended that declares and sets the original\n+-- return variable of the pre-updated aggregate operator.\n+updateRHSAggregate :: DatalogProgram -> Rule -> Int -> [RuleRHS]\n+updateRHSAggregate d rule index =\n+  let\n+     r = (ruleRHS rule) !! index\n+     funcName = \"__debug_\" ++ (rhsAggFunc r)\n+     varRet = \"__inputs_\" ++ (rhsVar r)\n+     input = E ETuple { exprPos = nopos,\n+                        exprTupleFields = [ (Compile.recordAfterPrefix d rule (index - 1)) !! 0,\n+                                            (rhsAggExpr r) ] }\n+     rAgg = RHSAggregate { rhsVar = varRet,\n+                           rhsGroupBy = rhsGroupBy r,\n+                           rhsAggFunc = funcName,\n+                           rhsAggExpr = input }\n+     rCond = RHSCondition { rhsExpr = E ESet { exprPos = nopos,\n+                                               exprLVal = E EVarDecl { exprPos = nopos,\n+                                                                       exprVName = rhsVar r },\n+                                               exprRVal = E ETupField { exprPos = nopos,\n+                                                                        exprTuple = E EVar { exprPos = nopos,\n+                                                                                             exprVar = varRet },\n+                                                                        exprTupField = 1 } } }\n+  in [ rAgg, rCond ]\n+\n+-- OperatorID is based on rule index, rhs index and head index\n+-- The 12 MSB are reserved for the rule index.\n+-- The next 16 bits are reserved for the rhs index.\n+-- The 4 LSB are reserved for the head index.\n+generateOperatorIdExpr :: Int -> Int -> Int -> Expr\n+generateOperatorIdExpr rlIdx rhsIdx headIdx =\n+  let\n+    operatorId = toInteger $ (shiftL (rlIdx .&. 4095) 20) .|. (shiftL (rhsIdx .&. 32767) 4) .|. (headIdx .&. 15)\n+  in E EBit { exprPos = nopos,\n+               exprWidth = 32,\n+               exprIVal = operatorId }\n+\n+ddlogWeightExpr :: Expr\n+ddlogWeightExpr =\n+  E EVar { exprPos = nopos,\n+           exprVar = \"ddlog_weight\" }\n+\n+ddlogTimestampExpr :: Expr\n+ddlogTimestampExpr =\n+  E EVar { exprPos = nopos,\n+           exprVar = \"ddlog_timestamp\" }\n+\n+generateInspectDebugJoin :: DatalogProgram -> Int -> Rule -> Int -> [RuleRHS]\n+generateInspectDebugJoin d ruleIdx rule index =\n+  let\n+    input1 = (Compile.recordAfterPrefix d rule (index - 1)) !! 0\n+    input2 = E EVar { exprPos = nopos,\n+                      exprVar = exprVar $ enode $ atomVal $ rhsAtom (ruleRHS rule !! index) }\n+    outputs = Compile.recordAfterPrefix d rule index\n+  in map (\\i -> RHSInspect {rhsInspectExpr = E $ EApply {exprPos = nopos,\n+                                                         exprFunc = \"debug.debug_event_join\",\n+                                                         exprArgs = [generateOperatorIdExpr ruleIdx index i,\n+                                                                     ddlogWeightExpr,\n+                                                                     ddlogTimestampExpr,\n+                                                                     input1,\n+                                                                     input2,\n+                                                                     outputs !! i]}}) [0..length outputs - 1]\n+\n+generateInspectDebug :: DatalogProgram -> Int -> Rule -> Int -> [RuleRHS]\n+generateInspectDebug d ruleIdx rule index =\n+  let\n+    input1 = if index == 0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8327f2c7a52ad61702434b97775ef7568a091860"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTgxMDQ5Mw==", "bodyText": "I'm trying to handle the case where the rule only has a single literal.\nR5(a, b) :-\nr1 in R1(a, b, _, _).\nI want the call to debug_event to have (r1, R5{a, b})\nSo input is r1, and output is the R5.\nIf I use recordAfterPrefix  (index), it will return R5. So both input and output will be R5{a, b}. Or does it matter in this case?", "url": "https://github.com/vmware/differential-datalog/pull/682#discussion_r439810493", "createdAt": "2020-06-14T09:37:20Z", "author": {"login": "haroldlim"}, "path": "src/Language/DifferentialDatalog/DatalogProgram.hs", "diffHunk": "@@ -307,3 +311,221 @@ progMirrorInputRelations d prefix =\n     rules = map (\\(n,r) -> makeRule n r) inputRels\n   in d { progRelations = M.union (progRelations d) $ M.fromList relCopies,\n          progRules     = (progRules d) ++ rules }\n+\n+-- For RHSLiteral, a binding to the expression is inserted if it's not bound to a variable.\n+-- For example, R(a, b, z, _) gets transformed into __r0 in R(a, b, z, _),\n+addBindingToRHSLiteral :: (RuleRHS, Int) -> RuleRHS\n+addBindingToRHSLiteral (r@RHSLiteral{}, index) =\n+  let\n+    bindingName = \"__\" ++ (map toLower $ atomRelation $ rhsAtom r) ++ (show index)\n+    expr = atomVal $ rhsAtom r\n+    exprNode = enode expr\n+    updatedAtomVal = case exprNode of\n+                     EBinding{} -> expr\n+                     _          -> E $ EBinding { exprPos = exprPos exprNode,\n+                                                  exprVar = bindingName,\n+                                                  exprPattern = expr }\n+    updatedAtom = (rhsAtom r) { atomVal = updatedAtomVal }\n+  in r { rhsAtom = updatedAtom }\n+addBindingToRHSLiteral (rule, _) = rule\n+\n+-- For RHSAggregate, the aggregate function is prepended with __debug_\n+-- The input to the aggregate function is transformed into a tuple of\n+-- input to the aggregate operator and the original value.\n+-- The return variable is also prepended with __inputs_, which will now be\n+-- a tuple.\n+-- The corrddesponding compiler-generated function also outputs the set of\n+-- inputs, so that it is visible to the inspect operator.\n+-- an RHSCondition is also appended that declares and sets the original\n+-- return variable of the pre-updated aggregate operator.\n+updateRHSAggregate :: DatalogProgram -> Rule -> Int -> [RuleRHS]\n+updateRHSAggregate d rule index =\n+  let\n+     r = (ruleRHS rule) !! index\n+     funcName = \"__debug_\" ++ (rhsAggFunc r)\n+     varRet = \"__inputs_\" ++ (rhsVar r)\n+     input = E ETuple { exprPos = nopos,\n+                        exprTupleFields = [ (Compile.recordAfterPrefix d rule (index - 1)) !! 0,\n+                                            (rhsAggExpr r) ] }\n+     rAgg = RHSAggregate { rhsVar = varRet,\n+                           rhsGroupBy = rhsGroupBy r,\n+                           rhsAggFunc = funcName,\n+                           rhsAggExpr = input }\n+     rCond = RHSCondition { rhsExpr = E ESet { exprPos = nopos,\n+                                               exprLVal = E EVarDecl { exprPos = nopos,\n+                                                                       exprVName = rhsVar r },\n+                                               exprRVal = E ETupField { exprPos = nopos,\n+                                                                        exprTuple = E EVar { exprPos = nopos,\n+                                                                                             exprVar = varRet },\n+                                                                        exprTupField = 1 } } }\n+  in [ rAgg, rCond ]\n+\n+-- OperatorID is based on rule index, rhs index and head index\n+-- The 12 MSB are reserved for the rule index.\n+-- The next 16 bits are reserved for the rhs index.\n+-- The 4 LSB are reserved for the head index.\n+generateOperatorIdExpr :: Int -> Int -> Int -> Expr\n+generateOperatorIdExpr rlIdx rhsIdx headIdx =\n+  let\n+    operatorId = toInteger $ (shiftL (rlIdx .&. 4095) 20) .|. (shiftL (rhsIdx .&. 32767) 4) .|. (headIdx .&. 15)\n+  in E EBit { exprPos = nopos,\n+               exprWidth = 32,\n+               exprIVal = operatorId }\n+\n+ddlogWeightExpr :: Expr\n+ddlogWeightExpr =\n+  E EVar { exprPos = nopos,\n+           exprVar = \"ddlog_weight\" }\n+\n+ddlogTimestampExpr :: Expr\n+ddlogTimestampExpr =\n+  E EVar { exprPos = nopos,\n+           exprVar = \"ddlog_timestamp\" }\n+\n+generateInspectDebugJoin :: DatalogProgram -> Int -> Rule -> Int -> [RuleRHS]\n+generateInspectDebugJoin d ruleIdx rule index =\n+  let\n+    input1 = (Compile.recordAfterPrefix d rule (index - 1)) !! 0\n+    input2 = E EVar { exprPos = nopos,\n+                      exprVar = exprVar $ enode $ atomVal $ rhsAtom (ruleRHS rule !! index) }\n+    outputs = Compile.recordAfterPrefix d rule index\n+  in map (\\i -> RHSInspect {rhsInspectExpr = E $ EApply {exprPos = nopos,\n+                                                         exprFunc = \"debug.debug_event_join\",\n+                                                         exprArgs = [generateOperatorIdExpr ruleIdx index i,\n+                                                                     ddlogWeightExpr,\n+                                                                     ddlogTimestampExpr,\n+                                                                     input1,\n+                                                                     input2,\n+                                                                     outputs !! i]}}) [0..length outputs - 1]\n+\n+generateInspectDebug :: DatalogProgram -> Int -> Rule -> Int -> [RuleRHS]\n+generateInspectDebug d ruleIdx rule index =\n+  let\n+    input1 = if index == 0", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwOTI5OA=="}, "originalCommit": {"oid": "8327f2c7a52ad61702434b97775ef7568a091860"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg0ODEzNg==", "bodyText": "My bad, your code makes sense!", "url": "https://github.com/vmware/differential-datalog/pull/682#discussion_r439848136", "createdAt": "2020-06-14T16:51:20Z", "author": {"login": "ryzhyk"}, "path": "src/Language/DifferentialDatalog/DatalogProgram.hs", "diffHunk": "@@ -307,3 +311,221 @@ progMirrorInputRelations d prefix =\n     rules = map (\\(n,r) -> makeRule n r) inputRels\n   in d { progRelations = M.union (progRelations d) $ M.fromList relCopies,\n          progRules     = (progRules d) ++ rules }\n+\n+-- For RHSLiteral, a binding to the expression is inserted if it's not bound to a variable.\n+-- For example, R(a, b, z, _) gets transformed into __r0 in R(a, b, z, _),\n+addBindingToRHSLiteral :: (RuleRHS, Int) -> RuleRHS\n+addBindingToRHSLiteral (r@RHSLiteral{}, index) =\n+  let\n+    bindingName = \"__\" ++ (map toLower $ atomRelation $ rhsAtom r) ++ (show index)\n+    expr = atomVal $ rhsAtom r\n+    exprNode = enode expr\n+    updatedAtomVal = case exprNode of\n+                     EBinding{} -> expr\n+                     _          -> E $ EBinding { exprPos = exprPos exprNode,\n+                                                  exprVar = bindingName,\n+                                                  exprPattern = expr }\n+    updatedAtom = (rhsAtom r) { atomVal = updatedAtomVal }\n+  in r { rhsAtom = updatedAtom }\n+addBindingToRHSLiteral (rule, _) = rule\n+\n+-- For RHSAggregate, the aggregate function is prepended with __debug_\n+-- The input to the aggregate function is transformed into a tuple of\n+-- input to the aggregate operator and the original value.\n+-- The return variable is also prepended with __inputs_, which will now be\n+-- a tuple.\n+-- The corrddesponding compiler-generated function also outputs the set of\n+-- inputs, so that it is visible to the inspect operator.\n+-- an RHSCondition is also appended that declares and sets the original\n+-- return variable of the pre-updated aggregate operator.\n+updateRHSAggregate :: DatalogProgram -> Rule -> Int -> [RuleRHS]\n+updateRHSAggregate d rule index =\n+  let\n+     r = (ruleRHS rule) !! index\n+     funcName = \"__debug_\" ++ (rhsAggFunc r)\n+     varRet = \"__inputs_\" ++ (rhsVar r)\n+     input = E ETuple { exprPos = nopos,\n+                        exprTupleFields = [ (Compile.recordAfterPrefix d rule (index - 1)) !! 0,\n+                                            (rhsAggExpr r) ] }\n+     rAgg = RHSAggregate { rhsVar = varRet,\n+                           rhsGroupBy = rhsGroupBy r,\n+                           rhsAggFunc = funcName,\n+                           rhsAggExpr = input }\n+     rCond = RHSCondition { rhsExpr = E ESet { exprPos = nopos,\n+                                               exprLVal = E EVarDecl { exprPos = nopos,\n+                                                                       exprVName = rhsVar r },\n+                                               exprRVal = E ETupField { exprPos = nopos,\n+                                                                        exprTuple = E EVar { exprPos = nopos,\n+                                                                                             exprVar = varRet },\n+                                                                        exprTupField = 1 } } }\n+  in [ rAgg, rCond ]\n+\n+-- OperatorID is based on rule index, rhs index and head index\n+-- The 12 MSB are reserved for the rule index.\n+-- The next 16 bits are reserved for the rhs index.\n+-- The 4 LSB are reserved for the head index.\n+generateOperatorIdExpr :: Int -> Int -> Int -> Expr\n+generateOperatorIdExpr rlIdx rhsIdx headIdx =\n+  let\n+    operatorId = toInteger $ (shiftL (rlIdx .&. 4095) 20) .|. (shiftL (rhsIdx .&. 32767) 4) .|. (headIdx .&. 15)\n+  in E EBit { exprPos = nopos,\n+               exprWidth = 32,\n+               exprIVal = operatorId }\n+\n+ddlogWeightExpr :: Expr\n+ddlogWeightExpr =\n+  E EVar { exprPos = nopos,\n+           exprVar = \"ddlog_weight\" }\n+\n+ddlogTimestampExpr :: Expr\n+ddlogTimestampExpr =\n+  E EVar { exprPos = nopos,\n+           exprVar = \"ddlog_timestamp\" }\n+\n+generateInspectDebugJoin :: DatalogProgram -> Int -> Rule -> Int -> [RuleRHS]\n+generateInspectDebugJoin d ruleIdx rule index =\n+  let\n+    input1 = (Compile.recordAfterPrefix d rule (index - 1)) !! 0\n+    input2 = E EVar { exprPos = nopos,\n+                      exprVar = exprVar $ enode $ atomVal $ rhsAtom (ruleRHS rule !! index) }\n+    outputs = Compile.recordAfterPrefix d rule index\n+  in map (\\i -> RHSInspect {rhsInspectExpr = E $ EApply {exprPos = nopos,\n+                                                         exprFunc = \"debug.debug_event_join\",\n+                                                         exprArgs = [generateOperatorIdExpr ruleIdx index i,\n+                                                                     ddlogWeightExpr,\n+                                                                     ddlogTimestampExpr,\n+                                                                     input1,\n+                                                                     input2,\n+                                                                     outputs !! i]}}) [0..length outputs - 1]\n+\n+generateInspectDebug :: DatalogProgram -> Int -> Rule -> Int -> [RuleRHS]\n+generateInspectDebug d ruleIdx rule index =\n+  let\n+    input1 = if index == 0", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwOTI5OA=="}, "originalCommit": {"oid": "8327f2c7a52ad61702434b97775ef7568a091860"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczOTIyODMyOnYy", "diffSide": "RIGHT", "path": "src/Language/DifferentialDatalog/DatalogProgram.hs", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QwNToyODozNVrOGjV1SQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QwNToyODozNVrOGjV1SQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcxMTA0OQ==", "bodyText": "An example generated function would be nice.", "url": "https://github.com/vmware/differential-datalog/pull/682#discussion_r439711049", "createdAt": "2020-06-13T05:28:35Z", "author": {"login": "ryzhyk"}, "path": "src/Language/DifferentialDatalog/DatalogProgram.hs", "diffHunk": "@@ -307,3 +311,221 @@ progMirrorInputRelations d prefix =\n     rules = map (\\(n,r) -> makeRule n r) inputRels\n   in d { progRelations = M.union (progRelations d) $ M.fromList relCopies,\n          progRules     = (progRules d) ++ rules }\n+\n+-- For RHSLiteral, a binding to the expression is inserted if it's not bound to a variable.\n+-- For example, R(a, b, z, _) gets transformed into __r0 in R(a, b, z, _),\n+addBindingToRHSLiteral :: (RuleRHS, Int) -> RuleRHS\n+addBindingToRHSLiteral (r@RHSLiteral{}, index) =\n+  let\n+    bindingName = \"__\" ++ (map toLower $ atomRelation $ rhsAtom r) ++ (show index)\n+    expr = atomVal $ rhsAtom r\n+    exprNode = enode expr\n+    updatedAtomVal = case exprNode of\n+                     EBinding{} -> expr\n+                     _          -> E $ EBinding { exprPos = exprPos exprNode,\n+                                                  exprVar = bindingName,\n+                                                  exprPattern = expr }\n+    updatedAtom = (rhsAtom r) { atomVal = updatedAtomVal }\n+  in r { rhsAtom = updatedAtom }\n+addBindingToRHSLiteral (rule, _) = rule\n+\n+-- For RHSAggregate, the aggregate function is prepended with __debug_\n+-- The input to the aggregate function is transformed into a tuple of\n+-- input to the aggregate operator and the original value.\n+-- The return variable is also prepended with __inputs_, which will now be\n+-- a tuple.\n+-- The corrddesponding compiler-generated function also outputs the set of\n+-- inputs, so that it is visible to the inspect operator.\n+-- an RHSCondition is also appended that declares and sets the original\n+-- return variable of the pre-updated aggregate operator.\n+updateRHSAggregate :: DatalogProgram -> Rule -> Int -> [RuleRHS]\n+updateRHSAggregate d rule index =\n+  let\n+     r = (ruleRHS rule) !! index\n+     funcName = \"__debug_\" ++ (rhsAggFunc r)\n+     varRet = \"__inputs_\" ++ (rhsVar r)\n+     input = E ETuple { exprPos = nopos,\n+                        exprTupleFields = [ (Compile.recordAfterPrefix d rule (index - 1)) !! 0,\n+                                            (rhsAggExpr r) ] }\n+     rAgg = RHSAggregate { rhsVar = varRet,\n+                           rhsGroupBy = rhsGroupBy r,\n+                           rhsAggFunc = funcName,\n+                           rhsAggExpr = input }\n+     rCond = RHSCondition { rhsExpr = E ESet { exprPos = nopos,\n+                                               exprLVal = E EVarDecl { exprPos = nopos,\n+                                                                       exprVName = rhsVar r },\n+                                               exprRVal = E ETupField { exprPos = nopos,\n+                                                                        exprTuple = E EVar { exprPos = nopos,\n+                                                                                             exprVar = varRet },\n+                                                                        exprTupField = 1 } } }\n+  in [ rAgg, rCond ]\n+\n+-- OperatorID is based on rule index, rhs index and head index\n+-- The 12 MSB are reserved for the rule index.\n+-- The next 16 bits are reserved for the rhs index.\n+-- The 4 LSB are reserved for the head index.\n+generateOperatorIdExpr :: Int -> Int -> Int -> Expr\n+generateOperatorIdExpr rlIdx rhsIdx headIdx =\n+  let\n+    operatorId = toInteger $ (shiftL (rlIdx .&. 4095) 20) .|. (shiftL (rhsIdx .&. 32767) 4) .|. (headIdx .&. 15)\n+  in E EBit { exprPos = nopos,\n+               exprWidth = 32,\n+               exprIVal = operatorId }\n+\n+ddlogWeightExpr :: Expr\n+ddlogWeightExpr =\n+  E EVar { exprPos = nopos,\n+           exprVar = \"ddlog_weight\" }\n+\n+ddlogTimestampExpr :: Expr\n+ddlogTimestampExpr =\n+  E EVar { exprPos = nopos,\n+           exprVar = \"ddlog_timestamp\" }\n+\n+generateInspectDebugJoin :: DatalogProgram -> Int -> Rule -> Int -> [RuleRHS]\n+generateInspectDebugJoin d ruleIdx rule index =\n+  let\n+    input1 = (Compile.recordAfterPrefix d rule (index - 1)) !! 0\n+    input2 = E EVar { exprPos = nopos,\n+                      exprVar = exprVar $ enode $ atomVal $ rhsAtom (ruleRHS rule !! index) }\n+    outputs = Compile.recordAfterPrefix d rule index\n+  in map (\\i -> RHSInspect {rhsInspectExpr = E $ EApply {exprPos = nopos,\n+                                                         exprFunc = \"debug.debug_event_join\",\n+                                                         exprArgs = [generateOperatorIdExpr ruleIdx index i,\n+                                                                     ddlogWeightExpr,\n+                                                                     ddlogTimestampExpr,\n+                                                                     input1,\n+                                                                     input2,\n+                                                                     outputs !! i]}}) [0..length outputs - 1]\n+\n+generateInspectDebug :: DatalogProgram -> Int -> Rule -> Int -> [RuleRHS]\n+generateInspectDebug d ruleIdx rule index =\n+  let\n+    input1 = if index == 0\n+                then E EVar { exprPos = nopos,\n+                              exprVar = exprVar $ enode $ atomVal $ rhsAtom (ruleRHS rule !! index) }\n+                else (Compile.recordAfterPrefix d rule (index - 1)) !! 0\n+    outputs = Compile.recordAfterPrefix d rule index\n+  in map (\\i -> RHSInspect {rhsInspectExpr = E $ EApply {exprPos = nopos,\n+                                                         exprFunc = \"debug.debug_event\",\n+                                                         exprArgs = [generateOperatorIdExpr ruleIdx index i,\n+                                                                     ddlogWeightExpr,\n+                                                                     ddlogTimestampExpr,\n+                                                                     input1,\n+                                                                     outputs !! i]}}) [0..length outputs - 1]\n+\n+generateInspectDebugAggregate :: DatalogProgram -> Int -> Rule -> Int -> [RuleRHS]\n+generateInspectDebugAggregate d ruleIdx rule index =\n+  let\n+    input1 = E ETupField { exprPos = nopos,\n+                           exprTuple = E EVar { exprPos = nopos,\n+                                                exprVar = rhsVar $ (ruleRHS rule !! index) },\n+                           exprTupField = 0 }\n+    outputs = Compile.recordAfterPrefix d rule index\n+  in map (\\i -> RHSInspect {rhsInspectExpr = E $ EApply {exprPos = nopos,\n+                                                         exprFunc = \"debug.debug_event\",\n+                                                         exprArgs = [generateOperatorIdExpr ruleIdx index i,\n+                                                                     ddlogWeightExpr,\n+                                                                     ddlogTimestampExpr,\n+                                                                     input1,\n+                                                                     outputs !! i]}}) [0..length outputs -1]\n+\n+mkInspect :: DatalogProgram -> Int -> Rule -> Int -> Maybe [RuleRHS]\n+mkInspect d ruleIdx rule index =\n+  let rhsRule = ruleRHS rule\n+  in if index == 0 && index < length rhsRule - 1\n+        then Nothing\n+        else if rhsIsCondition (rhsRule !! index) && index /= length rhsRule - 1 && rhsIsCondition (rhsRule !! (index + 1))\n+                then Nothing\n+                else if index == 0\n+                     then Just $ generateInspectDebug d ruleIdx rule index -- single term rule\n+                     else case rhsRule !! index of\n+                          RHSLiteral{rhsPolarity=True} -> Just $ generateInspectDebugJoin d ruleIdx rule index -- join\n+                          RHSAggregate{} -> Just $ generateInspectDebugAggregate d ruleIdx rule index -- aggregate\n+                          _ -> Just $ generateInspectDebug d ruleIdx rule index -- antijoin, flatmap, filter/assignment, inspect\n+\n+-- Insert inspect debug hook after each RHS term, except for the following:\n+-- 1. If a group of conditions appear consecutively, inspect debug hook is only\n+-- inserted after the last condition in the group.\n+-- 2. Inspect debug hook is not inserted after the first term, unless the rule\n+-- only contains one literal.\n+-- 3. If a rule has multiple heads, then multiple inspect is inserted after the last\n+-- term corresponding to each head.\n+insertRHSInspectDebugHooks :: DatalogProgram -> Int -> Rule -> [RuleRHS]\n+insertRHSInspectDebugHooks d rlIdx rule =\n+  concatMap (\\i -> let inspect = concat $ maybeToList $ mkInspect d rlIdx rule i in\n+                   (ruleRHS rule !! i) : inspect) [0..length (ruleRHS rule) - 1]\n+\n+updateRHSRules :: DatalogProgram -> Int -> Rule -> [RuleRHS]\n+updateRHSRules d rlIdx rule =\n+  let\n+    -- First pass updates RHSLiteral without any binding with a binding.\n+    rhs =  map (\\r -> case r of\n+                      (RHSLiteral True _ , _) -> addBindingToRHSLiteral r\n+                      _                       -> fst r) $ zip (ruleRHS rule) [0..]\n+    -- Second pass updates RHSAggregate to use the debug function (so that inputs are not dropped).\n+    rhs' = concatMap (\\i -> case rhs !! i of\n+                            RHSAggregate{} -> updateRHSAggregate d rule {ruleRHS = rhs} i\n+                            _              -> [rhs !! i]) $ [0..length rhs - 1]\n+  in insertRHSInspectDebugHooks d rlIdx rule {ruleRHS = rhs'}\n+\n+-- Insert an aggregate function that wraps the original function used in the aggregate term.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8327f2c7a52ad61702434b97775ef7568a091860"}, "originalPosition": 187}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0MDI4ODIxOnYy", "diffSide": "RIGHT", "path": "src/Language/DifferentialDatalog/DatalogProgram.hs", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNFQxNjo1MzoyNlrOGjeNfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQyMDo0ODoyNFrOGkCMvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg0ODMxNw==", "bodyText": "One more comment I missed in my initial review: I think all the logic related to injecting debugging hooks deserves a separate module: src/Language/DifferentialDatalog/Debug.hs.", "url": "https://github.com/vmware/differential-datalog/pull/682#discussion_r439848317", "createdAt": "2020-06-14T16:53:26Z", "author": {"login": "ryzhyk"}, "path": "src/Language/DifferentialDatalog/DatalogProgram.hs", "diffHunk": "@@ -307,3 +311,221 @@ progMirrorInputRelations d prefix =\n     rules = map (\\(n,r) -> makeRule n r) inputRels\n   in d { progRelations = M.union (progRelations d) $ M.fromList relCopies,\n          progRules     = (progRules d) ++ rules }\n+\n+-- For RHSLiteral, a binding to the expression is inserted if it's not bound to a variable.\n+-- For example, R(a, b, z, _) gets transformed into __r0 in R(a, b, z, _),\n+addBindingToRHSLiteral :: (RuleRHS, Int) -> RuleRHS", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8327f2c7a52ad61702434b97775ef7568a091860"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQzNzk0OA==", "bodyText": "Done.", "url": "https://github.com/vmware/differential-datalog/pull/682#discussion_r440437948", "createdAt": "2020-06-15T20:48:24Z", "author": {"login": "haroldlim"}, "path": "src/Language/DifferentialDatalog/DatalogProgram.hs", "diffHunk": "@@ -307,3 +311,221 @@ progMirrorInputRelations d prefix =\n     rules = map (\\(n,r) -> makeRule n r) inputRels\n   in d { progRelations = M.union (progRelations d) $ M.fromList relCopies,\n          progRules     = (progRules d) ++ rules }\n+\n+-- For RHSLiteral, a binding to the expression is inserted if it's not bound to a variable.\n+-- For example, R(a, b, z, _) gets transformed into __r0 in R(a, b, z, _),\n+addBindingToRHSLiteral :: (RuleRHS, Int) -> RuleRHS", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg0ODMxNw=="}, "originalCommit": {"oid": "8327f2c7a52ad61702434b97775ef7568a091860"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0MDMxMjQxOnYy", "diffSide": "RIGHT", "path": "src/Language/DifferentialDatalog/DatalogProgram.hs", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNFQxNzozMjozMVrOGjeZtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNFQxNzozMjozMVrOGjeZtg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1MTQ0Ng==", "bodyText": "I don't think you need a special case for 0; foldl will do the right thing if aggregates is empty.\nAlso, it is always recommended to use foldl' over foldl in Haskell.\nFinal nit: concatMap (\\rule -> ruleRHS rule) rules is just concatMap ruleRHS rules.", "url": "https://github.com/vmware/differential-datalog/pull/682#discussion_r439851446", "createdAt": "2020-06-14T17:32:31Z", "author": {"login": "ryzhyk"}, "path": "src/Language/DifferentialDatalog/DatalogProgram.hs", "diffHunk": "@@ -307,3 +311,221 @@ progMirrorInputRelations d prefix =\n     rules = map (\\(n,r) -> makeRule n r) inputRels\n   in d { progRelations = M.union (progRelations d) $ M.fromList relCopies,\n          progRules     = (progRules d) ++ rules }\n+\n+-- For RHSLiteral, a binding to the expression is inserted if it's not bound to a variable.\n+-- For example, R(a, b, z, _) gets transformed into __r0 in R(a, b, z, _),\n+addBindingToRHSLiteral :: (RuleRHS, Int) -> RuleRHS\n+addBindingToRHSLiteral (r@RHSLiteral{}, index) =\n+  let\n+    bindingName = \"__\" ++ (map toLower $ atomRelation $ rhsAtom r) ++ (show index)\n+    expr = atomVal $ rhsAtom r\n+    exprNode = enode expr\n+    updatedAtomVal = case exprNode of\n+                     EBinding{} -> expr\n+                     _          -> E $ EBinding { exprPos = exprPos exprNode,\n+                                                  exprVar = bindingName,\n+                                                  exprPattern = expr }\n+    updatedAtom = (rhsAtom r) { atomVal = updatedAtomVal }\n+  in r { rhsAtom = updatedAtom }\n+addBindingToRHSLiteral (rule, _) = rule\n+\n+-- For RHSAggregate, the aggregate function is prepended with __debug_\n+-- The input to the aggregate function is transformed into a tuple of\n+-- input to the aggregate operator and the original value.\n+-- The return variable is also prepended with __inputs_, which will now be\n+-- a tuple.\n+-- The corrddesponding compiler-generated function also outputs the set of\n+-- inputs, so that it is visible to the inspect operator.\n+-- an RHSCondition is also appended that declares and sets the original\n+-- return variable of the pre-updated aggregate operator.\n+updateRHSAggregate :: DatalogProgram -> Rule -> Int -> [RuleRHS]\n+updateRHSAggregate d rule index =\n+  let\n+     r = (ruleRHS rule) !! index\n+     funcName = \"__debug_\" ++ (rhsAggFunc r)\n+     varRet = \"__inputs_\" ++ (rhsVar r)\n+     input = E ETuple { exprPos = nopos,\n+                        exprTupleFields = [ (Compile.recordAfterPrefix d rule (index - 1)) !! 0,\n+                                            (rhsAggExpr r) ] }\n+     rAgg = RHSAggregate { rhsVar = varRet,\n+                           rhsGroupBy = rhsGroupBy r,\n+                           rhsAggFunc = funcName,\n+                           rhsAggExpr = input }\n+     rCond = RHSCondition { rhsExpr = E ESet { exprPos = nopos,\n+                                               exprLVal = E EVarDecl { exprPos = nopos,\n+                                                                       exprVName = rhsVar r },\n+                                               exprRVal = E ETupField { exprPos = nopos,\n+                                                                        exprTuple = E EVar { exprPos = nopos,\n+                                                                                             exprVar = varRet },\n+                                                                        exprTupField = 1 } } }\n+  in [ rAgg, rCond ]\n+\n+-- OperatorID is based on rule index, rhs index and head index\n+-- The 12 MSB are reserved for the rule index.\n+-- The next 16 bits are reserved for the rhs index.\n+-- The 4 LSB are reserved for the head index.\n+generateOperatorIdExpr :: Int -> Int -> Int -> Expr\n+generateOperatorIdExpr rlIdx rhsIdx headIdx =\n+  let\n+    operatorId = toInteger $ (shiftL (rlIdx .&. 4095) 20) .|. (shiftL (rhsIdx .&. 32767) 4) .|. (headIdx .&. 15)\n+  in E EBit { exprPos = nopos,\n+               exprWidth = 32,\n+               exprIVal = operatorId }\n+\n+ddlogWeightExpr :: Expr\n+ddlogWeightExpr =\n+  E EVar { exprPos = nopos,\n+           exprVar = \"ddlog_weight\" }\n+\n+ddlogTimestampExpr :: Expr\n+ddlogTimestampExpr =\n+  E EVar { exprPos = nopos,\n+           exprVar = \"ddlog_timestamp\" }\n+\n+generateInspectDebugJoin :: DatalogProgram -> Int -> Rule -> Int -> [RuleRHS]\n+generateInspectDebugJoin d ruleIdx rule index =\n+  let\n+    input1 = (Compile.recordAfterPrefix d rule (index - 1)) !! 0\n+    input2 = E EVar { exprPos = nopos,\n+                      exprVar = exprVar $ enode $ atomVal $ rhsAtom (ruleRHS rule !! index) }\n+    outputs = Compile.recordAfterPrefix d rule index\n+  in map (\\i -> RHSInspect {rhsInspectExpr = E $ EApply {exprPos = nopos,\n+                                                         exprFunc = \"debug.debug_event_join\",\n+                                                         exprArgs = [generateOperatorIdExpr ruleIdx index i,\n+                                                                     ddlogWeightExpr,\n+                                                                     ddlogTimestampExpr,\n+                                                                     input1,\n+                                                                     input2,\n+                                                                     outputs !! i]}}) [0..length outputs - 1]\n+\n+generateInspectDebug :: DatalogProgram -> Int -> Rule -> Int -> [RuleRHS]\n+generateInspectDebug d ruleIdx rule index =\n+  let\n+    input1 = if index == 0\n+                then E EVar { exprPos = nopos,\n+                              exprVar = exprVar $ enode $ atomVal $ rhsAtom (ruleRHS rule !! index) }\n+                else (Compile.recordAfterPrefix d rule (index - 1)) !! 0\n+    outputs = Compile.recordAfterPrefix d rule index\n+  in map (\\i -> RHSInspect {rhsInspectExpr = E $ EApply {exprPos = nopos,\n+                                                         exprFunc = \"debug.debug_event\",\n+                                                         exprArgs = [generateOperatorIdExpr ruleIdx index i,\n+                                                                     ddlogWeightExpr,\n+                                                                     ddlogTimestampExpr,\n+                                                                     input1,\n+                                                                     outputs !! i]}}) [0..length outputs - 1]\n+\n+generateInspectDebugAggregate :: DatalogProgram -> Int -> Rule -> Int -> [RuleRHS]\n+generateInspectDebugAggregate d ruleIdx rule index =\n+  let\n+    input1 = E ETupField { exprPos = nopos,\n+                           exprTuple = E EVar { exprPos = nopos,\n+                                                exprVar = rhsVar $ (ruleRHS rule !! index) },\n+                           exprTupField = 0 }\n+    outputs = Compile.recordAfterPrefix d rule index\n+  in map (\\i -> RHSInspect {rhsInspectExpr = E $ EApply {exprPos = nopos,\n+                                                         exprFunc = \"debug.debug_event\",\n+                                                         exprArgs = [generateOperatorIdExpr ruleIdx index i,\n+                                                                     ddlogWeightExpr,\n+                                                                     ddlogTimestampExpr,\n+                                                                     input1,\n+                                                                     outputs !! i]}}) [0..length outputs -1]\n+\n+mkInspect :: DatalogProgram -> Int -> Rule -> Int -> Maybe [RuleRHS]\n+mkInspect d ruleIdx rule index =\n+  let rhsRule = ruleRHS rule\n+  in if index == 0 && index < length rhsRule - 1\n+        then Nothing\n+        else if rhsIsCondition (rhsRule !! index) && index /= length rhsRule - 1 && rhsIsCondition (rhsRule !! (index + 1))\n+                then Nothing\n+                else if index == 0\n+                     then Just $ generateInspectDebug d ruleIdx rule index -- single term rule\n+                     else case rhsRule !! index of\n+                          RHSLiteral{rhsPolarity=True} -> Just $ generateInspectDebugJoin d ruleIdx rule index -- join\n+                          RHSAggregate{} -> Just $ generateInspectDebugAggregate d ruleIdx rule index -- aggregate\n+                          _ -> Just $ generateInspectDebug d ruleIdx rule index -- antijoin, flatmap, filter/assignment, inspect\n+\n+-- Insert inspect debug hook after each RHS term, except for the following:\n+-- 1. If a group of conditions appear consecutively, inspect debug hook is only\n+-- inserted after the last condition in the group.\n+-- 2. Inspect debug hook is not inserted after the first term, unless the rule\n+-- only contains one literal.\n+-- 3. If a rule has multiple heads, then multiple inspect is inserted after the last\n+-- term corresponding to each head.\n+insertRHSInspectDebugHooks :: DatalogProgram -> Int -> Rule -> [RuleRHS]\n+insertRHSInspectDebugHooks d rlIdx rule =\n+  concatMap (\\i -> let inspect = concat $ maybeToList $ mkInspect d rlIdx rule i in\n+                   (ruleRHS rule !! i) : inspect) [0..length (ruleRHS rule) - 1]\n+\n+updateRHSRules :: DatalogProgram -> Int -> Rule -> [RuleRHS]\n+updateRHSRules d rlIdx rule =\n+  let\n+    -- First pass updates RHSLiteral without any binding with a binding.\n+    rhs =  map (\\r -> case r of\n+                      (RHSLiteral True _ , _) -> addBindingToRHSLiteral r\n+                      _                       -> fst r) $ zip (ruleRHS rule) [0..]\n+    -- Second pass updates RHSAggregate to use the debug function (so that inputs are not dropped).\n+    rhs' = concatMap (\\i -> case rhs !! i of\n+                            RHSAggregate{} -> updateRHSAggregate d rule {ruleRHS = rhs} i\n+                            _              -> [rhs !! i]) $ [0..length rhs - 1]\n+  in insertRHSInspectDebugHooks d rlIdx rule {ruleRHS = rhs'}\n+\n+-- Insert an aggregate function that wraps the original function used in the aggregate term.\n+insertDebugAggregateFunction :: M.Map String Function -> String -> String -> M.Map String Function\n+insertDebugAggregateFunction functions fname origFname=\n+  let\n+    funcBody = E ESeq { exprPos = nopos,\n+                        exprLeft = E ESet { exprPos = nopos,\n+                                            exprLVal = E ETuple { exprPos = nopos,\n+                                                                  exprTupleFields = [ E EVarDecl { exprPos = nopos,\n+                                                                                                   exprVName = \"inputs\" },\n+                                                                                      E EVarDecl { exprPos = nopos,\n+                                                                                                   exprVName = \"original_group\" } ] },\n+                                            exprRVal = E EApply { exprPos = nopos,\n+                                                                  exprFunc = \"debug.debug_split_group\",\n+                                                                  exprArgs = [ E EVar { exprPos = nopos,\n+                                                                                        exprVar = \"g\" } ] } },\n+                        exprRight = E ETuple { exprPos = nopos,\n+                                               exprTupleFields = [ E EVar { exprPos = nopos,\n+                                                                            exprVar = \"inputs\" },\n+                                                                   E EApply { exprPos = nopos,\n+                                                                              exprFunc = origFname,\n+                                                                              exprArgs = [ E EVar { exprPos = nopos,\n+                                                                                                    exprVar = \"original_group\" } ] } ] } }\n+    function = Function { funcPos = nopos,\n+                          funcAttrs = [],\n+                          funcName = fname,\n+                          funcArgs = [ FuncArg { argPos = nopos,\n+                                                 argName = \"g\",\n+                                                 argMut = False,\n+                                                 argType = TOpaque { typePos = nopos,\n+                                                                     typeName = \"std.Group\",\n+                                                                     typeArgs = [ TVar { typePos = nopos, tvarName = \"K\" },\n+                                                                                  TTuple { typePos = nopos,\n+                                                                                           typeTupArgs = [ TVar { typePos = nopos, tvarName = \"I\" },\n+                                                                                                           TVar { typePos = nopos, tvarName = \"V\" } ] } ] } } ],\n+                          funcType = TTuple { typePos = nopos,\n+                                              typeTupArgs = [ TOpaque { typePos = nopos,\n+                                                                        typeName = \"std.Set\",\n+                                                                        typeArgs = [ TVar { typePos = nopos, tvarName = \"I\" } ] },\n+                                                              TVar { typePos = nopos, tvarName = \"V\" } ] },\n+                          funcDef = Just funcBody }\n+  in M.insert fname function functions\n+\n+-- Generate and insert into the map of functions a wrapper aggregate function for\n+-- each aggregate function used in the rule.\n+updateFunctions :: [Rule] -> M.Map String Function -> M.Map String Function\n+updateFunctions rules functions =\n+  let\n+    aggregates = filter rhsIsAggregate $ concatMap (\\rule -> ruleRHS rule) rules\n+  in case length aggregates of\n+     0 -> functions", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8327f2c7a52ad61702434b97775ef7568a091860"}, "originalPosition": 236}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4766, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}