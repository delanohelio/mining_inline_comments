{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQyMjA3NTY2", "number": 875, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMjozMDoyOVrOFIUivg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQwMToxOTo1NlrOFJ5_Kw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ0MjY5NTAyOnYy", "diffSide": "RIGHT", "path": "Cargo.toml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yMlQyMjozMDoyOVrOIKLFQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yNFQwMzoxODo1OVrOIK9f7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUzODI0Mg==", "bodyText": "Why does this have to be a separate crate?", "url": "https://github.com/vmware/differential-datalog/pull/875#discussion_r547538242", "createdAt": "2020-12-22T22:30:29Z", "author": {"login": "ryzhyk"}, "path": "Cargo.toml", "diffHunk": "@@ -1,9 +1,11 @@\n [workspace]\n members = [\n     \"rust/template\",\n+    \"rust/template/ovsdb\",\n     \"rust/template/cmd_parser\",\n-    \"rust/template/differential_datalog\",\n+    \"rust/template/ddlog_derive\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca6f41baf1cbe9bef71ac895a2b46d4157b46a0e"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM2NDI3MQ==", "bodyText": "Procedural macros have to be separate crates (that can only export proc/derive macros) since they're compiled and ran at compile time", "url": "https://github.com/vmware/differential-datalog/pull/875#discussion_r548364271", "createdAt": "2020-12-24T03:18:59Z", "author": {"login": "Kixiron"}, "path": "Cargo.toml", "diffHunk": "@@ -1,9 +1,11 @@\n [workspace]\n members = [\n     \"rust/template\",\n+    \"rust/template/ovsdb\",\n     \"rust/template/cmd_parser\",\n-    \"rust/template/differential_datalog\",\n+    \"rust/template/ddlog_derive\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUzODI0Mg=="}, "originalCommit": {"oid": "ca6f41baf1cbe9bef71ac895a2b46d4157b46a0e"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ1OTMxNDkzOnYy", "diffSide": "RIGHT", "path": "rust/template/ddlog_derive/src/mutator.rs", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQwMToxOToyNVrOIMbf5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQwMToxOToyNVrOIMbf5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTkwNDM1Ng==", "bodyText": "The error message is not correct if self is a struct with >0 fields.", "url": "https://github.com/vmware/differential-datalog/pull/875#discussion_r549904356", "createdAt": "2020-12-30T01:19:25Z", "author": {"login": "ryzhyk"}, "path": "rust/template/ddlog_derive/src/mutator.rs", "diffHunk": "@@ -0,0 +1,250 @@\n+use super::{add_trait_bounds, get_rename};\n+use proc_macro2::TokenStream;\n+use quote::{format_ident, quote};\n+use syn::{\n+    parse_quote, spanned::Spanned, Data, DataEnum, DataStruct, DeriveInput, Error, Fields,\n+    FieldsNamed, FieldsUnnamed, Ident, ImplGenerics, Index, Result, TypeGenerics, WhereClause,\n+};\n+\n+pub fn mutator_inner(mut input: DeriveInput) -> Result<TokenStream> {\n+    // The name of the struct\n+    let struct_ident = input.ident;\n+\n+    // Make sure every generic is able to be mutated by `Record`\n+    // The redundant clone circumvents mutating the collection we're iterating over\n+    #[allow(clippy::redundant_clone)]\n+    for generic in input\n+        .generics\n+        .clone()\n+        .type_params()\n+        .map(|param| &param.ident)\n+    {\n+        input\n+            .generics\n+            .make_where_clause()\n+            .predicates\n+            .push(parse_quote! {\n+                differential_datalog::record::Record: differential_datalog::record::Mutator<#generic>\n+            });\n+    }\n+\n+    // Add the required trait bounds\n+    let generics = add_trait_bounds(\n+        input.generics,\n+        vec![parse_quote!(differential_datalog::record::FromRecord)],\n+    );\n+    let generics = generics.split_for_impl();\n+\n+    match input.data {\n+        // Derive for structs\n+        Data::Struct(derive_struct) => mutator_struct(struct_ident, derive_struct, generics),\n+\n+        // Derive for enums\n+        Data::Enum(derive_enum) => mutator_enum(struct_ident, derive_enum, generics),\n+\n+        // Unions can't safely/soundly be automatically implemented over,\n+        // the user will have to manually enforce invariants on it\n+        Data::Union(union) => Err(Error::new_spanned(\n+            union.union_token,\n+            \"`Mutator` is not able to be automatically implemented on unions\",\n+        )),\n+    }\n+}\n+\n+/// Unit structs have nothing to mutate, so make sure the constructor is correct and that\n+/// there's no fields on the record\n+fn unit_struct_mutator() -> TokenStream {\n+    quote! {\n+        match self {\n+            differential_datalog::record::Record::PosStruct(constructor, args)\n+                if args.is_empty() => {},\n+\n+            differential_datalog::record::Record::NamedStruct(constructor, args)\n+                if args.is_empty() => {},\n+\n+            error => {\n+                return std::result::Result::Err(std::format!(\"not a struct {:?}\", error));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bdbf02b7ddb4b5912ba9f3aa52286ea83065a0ae"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ1OTMxNTYzOnYy", "diffSide": "RIGHT", "path": "rust/template/ddlog_derive/src/mutator.rs", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQwMToxOTo1NlrOIMbgQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0zMFQwMToxOTo1NlrOIMbgQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTkwNDQ1MQ==", "bodyText": "same issue here", "url": "https://github.com/vmware/differential-datalog/pull/875#discussion_r549904451", "createdAt": "2020-12-30T01:19:56Z", "author": {"login": "ryzhyk"}, "path": "rust/template/ddlog_derive/src/mutator.rs", "diffHunk": "@@ -0,0 +1,250 @@\n+use super::{add_trait_bounds, get_rename};\n+use proc_macro2::TokenStream;\n+use quote::{format_ident, quote};\n+use syn::{\n+    parse_quote, spanned::Spanned, Data, DataEnum, DataStruct, DeriveInput, Error, Fields,\n+    FieldsNamed, FieldsUnnamed, Ident, ImplGenerics, Index, Result, TypeGenerics, WhereClause,\n+};\n+\n+pub fn mutator_inner(mut input: DeriveInput) -> Result<TokenStream> {\n+    // The name of the struct\n+    let struct_ident = input.ident;\n+\n+    // Make sure every generic is able to be mutated by `Record`\n+    // The redundant clone circumvents mutating the collection we're iterating over\n+    #[allow(clippy::redundant_clone)]\n+    for generic in input\n+        .generics\n+        .clone()\n+        .type_params()\n+        .map(|param| &param.ident)\n+    {\n+        input\n+            .generics\n+            .make_where_clause()\n+            .predicates\n+            .push(parse_quote! {\n+                differential_datalog::record::Record: differential_datalog::record::Mutator<#generic>\n+            });\n+    }\n+\n+    // Add the required trait bounds\n+    let generics = add_trait_bounds(\n+        input.generics,\n+        vec![parse_quote!(differential_datalog::record::FromRecord)],\n+    );\n+    let generics = generics.split_for_impl();\n+\n+    match input.data {\n+        // Derive for structs\n+        Data::Struct(derive_struct) => mutator_struct(struct_ident, derive_struct, generics),\n+\n+        // Derive for enums\n+        Data::Enum(derive_enum) => mutator_enum(struct_ident, derive_enum, generics),\n+\n+        // Unions can't safely/soundly be automatically implemented over,\n+        // the user will have to manually enforce invariants on it\n+        Data::Union(union) => Err(Error::new_spanned(\n+            union.union_token,\n+            \"`Mutator` is not able to be automatically implemented on unions\",\n+        )),\n+    }\n+}\n+\n+/// Unit structs have nothing to mutate, so make sure the constructor is correct and that\n+/// there's no fields on the record\n+fn unit_struct_mutator() -> TokenStream {\n+    quote! {\n+        match self {\n+            differential_datalog::record::Record::PosStruct(constructor, args)\n+                if args.is_empty() => {},\n+\n+            differential_datalog::record::Record::NamedStruct(constructor, args)\n+                if args.is_empty() => {},\n+\n+            error => {\n+                return std::result::Result::Err(std::format!(\"not a struct {:?}\", error));\n+            },\n+        }\n+    }\n+}\n+\n+fn tuple_struct_mutator<'a>(\n+    tuple_struct: &'a FieldsUnnamed,\n+) -> (TokenStream, impl Iterator<Item = Ident> + 'a) {\n+    let num_fields = tuple_struct.unnamed.len();\n+\n+    let indices = tuple_struct.unnamed.iter().enumerate().map(|(idx, field)| {\n+        let index = Index {\n+            index: idx as u32,\n+            span: field.span(),\n+        };\n+\n+        format_ident!(\"_{}\", index)\n+    });\n+\n+    let field_mutations = tuple_struct\n+        .unnamed\n+        .iter()\n+        .zip(indices.clone())\n+        .enumerate()\n+        .map(|(idx, (field, index))| {\n+            let field_ty = &field.ty;\n+\n+            quote! {\n+                <dyn differential_datalog::record::Mutator<#field_ty>>::mutate(&args[#idx], #index)?;\n+            }\n+        });\n+\n+    let mutator = quote! {\n+        match self {\n+            differential_datalog::record::Record::PosStruct(constructor, args)\n+                if args.len() == #num_fields => {\n+                    #( #field_mutations )*\n+                },\n+\n+            error => {\n+                return std::result::Result::Err(std::format!(\"not a struct {:?}\", error));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bdbf02b7ddb4b5912ba9f3aa52286ea83065a0ae"}, "originalPosition": 107}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4722, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}