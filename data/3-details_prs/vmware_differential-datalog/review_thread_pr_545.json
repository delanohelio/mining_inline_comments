{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg0NDgzMjQz", "number": 545, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMTozNjowMlrODlmFWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMTozODoxNFrODlmICw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNzQ3ODY0OnYy", "diffSide": "RIGHT", "path": "lib/json.dl", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMTozNjowMlrOFylCIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwNjowNzo0OFrOFyuCcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU3OTg3Mw==", "bodyText": "I don't like this.\nPerhaps JSON null would be a better choice.", "url": "https://github.com/vmware/differential-datalog/pull/545#discussion_r388579873", "createdAt": "2020-03-05T21:36:02Z", "author": {"login": "mbudiu-vmw"}, "path": "lib/json.dl", "diffHunk": "@@ -40,6 +40,6 @@ typedef JsonNum = // Integer number.  The value must be in the range between the\n                   // inclusive.  Values outside of this range will be truncated\n                   // during serialization.\n                   JsonInt{i: s128}\n-                | // Always finite.\n-                  // TODO.\n-                  JsonFloat\n+                | // NaN and infinity are not valid JSON values.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7096e009e1f59fd593b0458085d251ab9cf2fdb6"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODcyNzQxMA==", "bodyText": "ok, null it is.", "url": "https://github.com/vmware/differential-datalog/pull/545#discussion_r388727410", "createdAt": "2020-03-06T06:07:48Z", "author": {"login": "ryzhyk"}, "path": "lib/json.dl", "diffHunk": "@@ -40,6 +40,6 @@ typedef JsonNum = // Integer number.  The value must be in the range between the\n                   // inclusive.  Values outside of this range will be truncated\n                   // during serialization.\n                   JsonInt{i: s128}\n-                | // Always finite.\n-                  // TODO.\n-                  JsonFloat\n+                | // NaN and infinity are not valid JSON values.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU3OTg3Mw=="}, "originalCommit": {"oid": "7096e009e1f59fd593b0458085d251ab9cf2fdb6"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNzQ4NDE4OnYy", "diffSide": "RIGHT", "path": "rust/template/cmd_parser/parse.rs", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMTozNzo1MVrOFylFpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMTozNzo1MVrOFylFpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU4MDc3NQ==", "bodyText": "doubles, no apostrophe.\nyou may want a similar comment for bigint if it isn't there", "url": "https://github.com/vmware/differential-datalog/pull/545#discussion_r388580775", "createdAt": "2020-03-05T21:37:51Z", "author": {"login": "mbudiu-vmw"}, "path": "rust/template/cmd_parser/parse.rs", "diffHunk": "@@ -563,6 +564,70 @@ fn test_struct() {\n                                                                     (Cow::from(\"sfield\"), Record::String(\"foo\\nbar\".to_string()))]))]))));\n }\n \n+// nom's implementation mof `recognize_float` accepts integer literals\n+// like `5`, making it impossible for the parser to distinguish between\n+// floats and integers.  The following is a strict version of `recognize_float`\n+// that only accepts literals containing `.`, e.g., `0.5` or `e|E`, e.g.,\n+// `5e-1`.\n+named!(recognize_float<&[u8], &[u8]>,\n+  recognize!(\n+    do_parse!(\n+      opt!(alt!(char!('+') | char!('-'))) >>\n+      alt!(\n+          do_parse!(digit >>\n+                    alt!( value!((),tuple!(char!('.'), opt!(digit), opt!(recognize_exponent)))\n+                        | recognize_exponent) >>\n+                    (()))\n+        | do_parse!(char!('.') >>\n+                   digit >>\n+                   opt!(recognize_exponent) >>\n+                   (()))) >>\n+      (())\n+    )\n+  )\n+);\n+\n+named!(recognize_exponent<&[u8], ()>,\n+       do_parse!(alt!(char!('e') | char!('E')) >>\n+                 opt!(alt!(char!('+') | char!('-'))) >>\n+                 digit >>\n+                 (()))\n+);\n+\n+// We do not have enough type information to distinguish between floats\n+// and doubles during parsing, so we parse all floating point numbers as\n+// double's and postpone casting them to floats until when they get converted", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7096e009e1f59fd593b0458085d251ab9cf2fdb6"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNzQ4NTU1OnYy", "diffSide": "RIGHT", "path": "rust/template/cmd_parser/parse.rs", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMTozODoxNFrOFylGdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwNjowMDoxOFrOFyt8xA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU4MDk4Mw==", "bodyText": "I wonder what happens on overflow", "url": "https://github.com/vmware/differential-datalog/pull/545#discussion_r388580983", "createdAt": "2020-03-05T21:38:14Z", "author": {"login": "mbudiu-vmw"}, "path": "rust/template/cmd_parser/parse.rs", "diffHunk": "@@ -563,6 +564,70 @@ fn test_struct() {\n                                                                     (Cow::from(\"sfield\"), Record::String(\"foo\\nbar\".to_string()))]))]))));\n }\n \n+// nom's implementation mof `recognize_float` accepts integer literals\n+// like `5`, making it impossible for the parser to distinguish between\n+// floats and integers.  The following is a strict version of `recognize_float`\n+// that only accepts literals containing `.`, e.g., `0.5` or `e|E`, e.g.,\n+// `5e-1`.\n+named!(recognize_float<&[u8], &[u8]>,\n+  recognize!(\n+    do_parse!(\n+      opt!(alt!(char!('+') | char!('-'))) >>\n+      alt!(\n+          do_parse!(digit >>\n+                    alt!( value!((),tuple!(char!('.'), opt!(digit), opt!(recognize_exponent)))\n+                        | recognize_exponent) >>\n+                    (()))\n+        | do_parse!(char!('.') >>\n+                   digit >>\n+                   opt!(recognize_exponent) >>\n+                   (()))) >>\n+      (())\n+    )\n+  )\n+);\n+\n+named!(recognize_exponent<&[u8], ()>,\n+       do_parse!(alt!(char!('e') | char!('E')) >>\n+                 opt!(alt!(char!('+') | char!('-'))) >>\n+                 digit >>\n+                 (()))\n+);\n+\n+// We do not have enough type information to distinguish between floats\n+// and doubles during parsing, so we parse all floating point numbers as\n+// double's and postpone casting them to floats until when they get converted\n+// into concrete types.\n+named!(float_val<&[u8], Record>,\n+       do_parse!(val: flat_map!(recognize_float, parse_to!(f64)) >>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7096e009e1f59fd593b0458085d251ab9cf2fdb6"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODcyNTk1Ng==", "bodyText": "It will be rounded up to infinity", "url": "https://github.com/vmware/differential-datalog/pull/545#discussion_r388725956", "createdAt": "2020-03-06T06:00:18Z", "author": {"login": "ryzhyk"}, "path": "rust/template/cmd_parser/parse.rs", "diffHunk": "@@ -563,6 +564,70 @@ fn test_struct() {\n                                                                     (Cow::from(\"sfield\"), Record::String(\"foo\\nbar\".to_string()))]))]))));\n }\n \n+// nom's implementation mof `recognize_float` accepts integer literals\n+// like `5`, making it impossible for the parser to distinguish between\n+// floats and integers.  The following is a strict version of `recognize_float`\n+// that only accepts literals containing `.`, e.g., `0.5` or `e|E`, e.g.,\n+// `5e-1`.\n+named!(recognize_float<&[u8], &[u8]>,\n+  recognize!(\n+    do_parse!(\n+      opt!(alt!(char!('+') | char!('-'))) >>\n+      alt!(\n+          do_parse!(digit >>\n+                    alt!( value!((),tuple!(char!('.'), opt!(digit), opt!(recognize_exponent)))\n+                        | recognize_exponent) >>\n+                    (()))\n+        | do_parse!(char!('.') >>\n+                   digit >>\n+                   opt!(recognize_exponent) >>\n+                   (()))) >>\n+      (())\n+    )\n+  )\n+);\n+\n+named!(recognize_exponent<&[u8], ()>,\n+       do_parse!(alt!(char!('e') | char!('E')) >>\n+                 opt!(alt!(char!('+') | char!('-'))) >>\n+                 digit >>\n+                 (()))\n+);\n+\n+// We do not have enough type information to distinguish between floats\n+// and doubles during parsing, so we parse all floating point numbers as\n+// double's and postpone casting them to floats until when they get converted\n+// into concrete types.\n+named!(float_val<&[u8], Record>,\n+       do_parse!(val: flat_map!(recognize_float, parse_to!(f64)) >>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU4MDk4Mw=="}, "originalCommit": {"oid": "7096e009e1f59fd593b0458085d251ab9cf2fdb6"}, "originalPosition": 56}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4879, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}