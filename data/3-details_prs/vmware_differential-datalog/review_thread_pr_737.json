{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY2OTg2MjY4", "number": 737, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNVQyMDo0MjozN1rOEYvUlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNlQxODo0ODo1N1rOEY1D9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0Mzc2NTk5OnYy", "diffSide": "RIGHT", "path": "rust/template/distributed_datalog/src/instantiate.rs", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNVQyMDo0MjozN1rOHBNhFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxNTozMzoxOFrOHDM_5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTAzMjA4NA==", "bodyText": "why not implement Default to keep clippy happy?", "url": "https://github.com/vmware/differential-datalog/pull/737#discussion_r471032084", "createdAt": "2020-08-15T20:42:37Z", "author": {"login": "ryzhyk"}, "path": "rust/template/distributed_datalog/src/instantiate.rs", "diffHunk": "@@ -316,20 +196,36 @@ where\n     >,\n     /// The transaction multiplexer as input to the DDLogServer\n     _txnmux: TxnMux<Update<DDValue>, String>,\n-    /// All sink accumulators of this realization to connect new nodes to\n-    _accumulators: HashMap<\n+    /// All sinks of this realization with their subscription\n+    _sinks: HashMap<\n         BTreeSet<RelId>,\n-        SharedObserver<DistributingAccumulator<Update<DDValue>, DDValue, String>>,\n+        (\n+            SharedObserver<DistributingAccumulator<Update<DDValue>, DDValue, String>>,\n+            UpdatesObservable<Update<DDValue>, String>,\n+            HashMap<Sink, (SinkRealization<P::Convert>, usize)>,\n+        ),\n     >,\n-    /// All sinks of this realization with their subscription\n-    _sinks: HashMap<BTreeSet<RelId>, Vec<(SinkRealization<P::Convert>, usize)>>,\n }\n \n impl<P> Realization<P>\n where\n     P: Send + DDlog + 'static,\n     P::Convert: Send + DDlogConvert,\n {\n+    /// Instantiates a new, default Realization.\n+    #[allow(clippy::new_without_default)]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5d11e192f5043ab1af92b1f7ad6a7d3804d550b8"}, "originalPosition": 204}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzEyMDc0MQ==", "bodyText": "I think this was a mental TODO that I forgot about... but you're totally right, will fix!", "url": "https://github.com/vmware/differential-datalog/pull/737#discussion_r473120741", "createdAt": "2020-08-19T15:33:18Z", "author": {"login": "krs85"}, "path": "rust/template/distributed_datalog/src/instantiate.rs", "diffHunk": "@@ -316,20 +196,36 @@ where\n     >,\n     /// The transaction multiplexer as input to the DDLogServer\n     _txnmux: TxnMux<Update<DDValue>, String>,\n-    /// All sink accumulators of this realization to connect new nodes to\n-    _accumulators: HashMap<\n+    /// All sinks of this realization with their subscription\n+    _sinks: HashMap<\n         BTreeSet<RelId>,\n-        SharedObserver<DistributingAccumulator<Update<DDValue>, DDValue, String>>,\n+        (\n+            SharedObserver<DistributingAccumulator<Update<DDValue>, DDValue, String>>,\n+            UpdatesObservable<Update<DDValue>, String>,\n+            HashMap<Sink, (SinkRealization<P::Convert>, usize)>,\n+        ),\n     >,\n-    /// All sinks of this realization with their subscription\n-    _sinks: HashMap<BTreeSet<RelId>, Vec<(SinkRealization<P::Convert>, usize)>>,\n }\n \n impl<P> Realization<P>\n where\n     P: Send + DDlog + 'static,\n     P::Convert: Send + DDlogConvert,\n {\n+    /// Instantiates a new, default Realization.\n+    #[allow(clippy::new_without_default)]", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTAzMjA4NA=="}, "originalCommit": {"oid": "5d11e192f5043ab1af92b1f7ad6a7d3804d550b8"}, "originalPosition": 204}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0Mzc2ODkxOnYy", "diffSide": "RIGHT", "path": "rust/template/distributed_datalog/src/instantiate.rs", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNVQyMDo0NzoyM1rOHBNicw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxNTozNDoyNVrOHDNCxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTAzMjQzNQ==", "bodyText": "A more accurate error message would indicate that the sink was not found and would also print the sink in question.", "url": "https://github.com/vmware/differential-datalog/pull/737#discussion_r471032435", "createdAt": "2020-08-15T20:47:23Z", "author": {"login": "ryzhyk"}, "path": "rust/template/distributed_datalog/src/instantiate.rs", "diffHunk": "@@ -405,13 +301,218 @@ where\n         }\n     }\n \n+    /// Remove file sink or tcp sender from an existing Realization.\n+    /// Locate the entry in _sinks whose map contains the sink.\n+    /// Remove the entry from the sink map.\n+    /// Unsubscribe the accumulator from the sink.\n+    /// Return an error if unable to find a sink map containing the sink.\n+    pub fn remove_sink(&mut self, sink: &Sink) -> Result<(), String> {\n+        for (accumulator, _, sink_map) in self._sinks.values_mut() {\n+            if sink_map.contains_key(sink) {\n+                let (_, subscription) = sink_map.remove(sink).unwrap();\n+                let _ = accumulator.unsubscribe(&subscription);\n+                return Ok(());\n+            }\n+        }\n+        Err(\"failed to remove sink from realization\".to_string())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5d11e192f5043ab1af92b1f7ad6a7d3804d550b8"}, "originalPosition": 246}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzEyMTQ3Ng==", "bodyText": "Makes sense, will fix.", "url": "https://github.com/vmware/differential-datalog/pull/737#discussion_r473121476", "createdAt": "2020-08-19T15:34:25Z", "author": {"login": "krs85"}, "path": "rust/template/distributed_datalog/src/instantiate.rs", "diffHunk": "@@ -405,13 +301,218 @@ where\n         }\n     }\n \n+    /// Remove file sink or tcp sender from an existing Realization.\n+    /// Locate the entry in _sinks whose map contains the sink.\n+    /// Remove the entry from the sink map.\n+    /// Unsubscribe the accumulator from the sink.\n+    /// Return an error if unable to find a sink map containing the sink.\n+    pub fn remove_sink(&mut self, sink: &Sink) -> Result<(), String> {\n+        for (accumulator, _, sink_map) in self._sinks.values_mut() {\n+            if sink_map.contains_key(sink) {\n+                let (_, subscription) = sink_map.remove(sink).unwrap();\n+                let _ = accumulator.unsubscribe(&subscription);\n+                return Ok(());\n+            }\n+        }\n+        Err(\"failed to remove sink from realization\".to_string())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTAzMjQzNQ=="}, "originalCommit": {"oid": "5d11e192f5043ab1af92b1f7ad6a7d3804d550b8"}, "originalPosition": 246}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0NDY4NjMxOnYy", "diffSide": "RIGHT", "path": "rust/template/distributed_datalog/src/instantiate.rs", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNlQxODoyMDo0N1rOHBURzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxNTo0NTozM1rOHDNgtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTE0Mjg2Mg==", "bodyText": "file sink -> TCP sink", "url": "https://github.com/vmware/differential-datalog/pull/737#discussion_r471142862", "createdAt": "2020-08-16T18:20:47Z", "author": {"login": "ryzhyk"}, "path": "rust/template/distributed_datalog/src/instantiate.rs", "diffHunk": "@@ -405,13 +301,218 @@ where\n         }\n     }\n \n+    /// Remove file sink or tcp sender from an existing Realization.\n+    /// Locate the entry in _sinks whose map contains the sink.\n+    /// Remove the entry from the sink map.\n+    /// Unsubscribe the accumulator from the sink.\n+    /// Return an error if unable to find a sink map containing the sink.\n+    pub fn remove_sink(&mut self, sink: &Sink) -> Result<(), String> {\n+        for (accumulator, _, sink_map) in self._sinks.values_mut() {\n+            if sink_map.contains_key(sink) {\n+                let (_, subscription) = sink_map.remove(sink).unwrap();\n+                let _ = accumulator.unsubscribe(&subscription);\n+                return Ok(());\n+            }\n+        }\n+        Err(\"failed to remove sink from realization\".to_string())\n+    }\n+\n+    /// Add file sink or tcp sender to an existing Realization.\n+    /// Creates and adds accumulator for this rel_ids to the Realization if needed.\n+    /// Subscribes the accumulator to the sink and adds the sink to\n+    /// the accumulator's map.\n+    pub fn add_sink(\n+        &mut self,\n+        sink: &Sink,\n+        rel_ids: BTreeSet<RelId>,\n+        server: &mut DDlogServer<P>,\n+    ) -> Result<(), String> {\n+        // Add the accumulator to the realization if needed.\n+        self.add_sink_accumulator(rel_ids.clone(), server)?;\n+        let (accumulator, _, sink_map) = self._sinks.get_mut(&rel_ids).unwrap();\n+\n+        match sink {\n+            Sink::File(path) => {\n+                let file = File::create(path)\n+                    .map_err(|e| format!(\"failed to create file {}:, {}\", path.display(), e))?;\n+                let file_sink = Arc::new(Mutex::new(FileSink::<P::Convert>::new(file)));\n+\n+                // Subscribe the accumulator to this sink.\n+                let subscription = accumulator\n+                    .lock()\n+                    .unwrap()\n+                    .subscribe(Box::new(file_sink.clone()))\n+                    .map_err(|_| \"failed to subscribe file sink to accumulator\".to_string())?;\n+\n+                // Add sink to sink map for this accumulator.\n+                let _ = sink_map.insert(\n+                    sink.clone(),\n+                    (SinkRealization::File(file_sink), subscription),\n+                );\n+            }\n+            Sink::TcpSender(addr) => {\n+                match addr {\n+                    Addr::Ip(address) => {\n+                        let tcp_sender = TcpSender::new(*address)\n+                            .map_err(|e| format!(\"failed to create TcpSender socket: {}\", e))?;\n+                        let sink = Arc::new(Mutex::new(tcp_sender));\n+\n+                        // Subscribe the accumulator to this sink.\n+                        let subscription = accumulator\n+                            .lock()\n+                            .unwrap()\n+                            .subscribe(Box::new(sink.clone()))\n+                            .map_err(|_| \"failed to subscribe file sink to accumulator\")?;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5d11e192f5043ab1af92b1f7ad6a7d3804d550b8"}, "originalPosition": 294}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzEyOTE0MQ==", "bodyText": "Makes sense, will fix.", "url": "https://github.com/vmware/differential-datalog/pull/737#discussion_r473129141", "createdAt": "2020-08-19T15:45:33Z", "author": {"login": "krs85"}, "path": "rust/template/distributed_datalog/src/instantiate.rs", "diffHunk": "@@ -405,13 +301,218 @@ where\n         }\n     }\n \n+    /// Remove file sink or tcp sender from an existing Realization.\n+    /// Locate the entry in _sinks whose map contains the sink.\n+    /// Remove the entry from the sink map.\n+    /// Unsubscribe the accumulator from the sink.\n+    /// Return an error if unable to find a sink map containing the sink.\n+    pub fn remove_sink(&mut self, sink: &Sink) -> Result<(), String> {\n+        for (accumulator, _, sink_map) in self._sinks.values_mut() {\n+            if sink_map.contains_key(sink) {\n+                let (_, subscription) = sink_map.remove(sink).unwrap();\n+                let _ = accumulator.unsubscribe(&subscription);\n+                return Ok(());\n+            }\n+        }\n+        Err(\"failed to remove sink from realization\".to_string())\n+    }\n+\n+    /// Add file sink or tcp sender to an existing Realization.\n+    /// Creates and adds accumulator for this rel_ids to the Realization if needed.\n+    /// Subscribes the accumulator to the sink and adds the sink to\n+    /// the accumulator's map.\n+    pub fn add_sink(\n+        &mut self,\n+        sink: &Sink,\n+        rel_ids: BTreeSet<RelId>,\n+        server: &mut DDlogServer<P>,\n+    ) -> Result<(), String> {\n+        // Add the accumulator to the realization if needed.\n+        self.add_sink_accumulator(rel_ids.clone(), server)?;\n+        let (accumulator, _, sink_map) = self._sinks.get_mut(&rel_ids).unwrap();\n+\n+        match sink {\n+            Sink::File(path) => {\n+                let file = File::create(path)\n+                    .map_err(|e| format!(\"failed to create file {}:, {}\", path.display(), e))?;\n+                let file_sink = Arc::new(Mutex::new(FileSink::<P::Convert>::new(file)));\n+\n+                // Subscribe the accumulator to this sink.\n+                let subscription = accumulator\n+                    .lock()\n+                    .unwrap()\n+                    .subscribe(Box::new(file_sink.clone()))\n+                    .map_err(|_| \"failed to subscribe file sink to accumulator\".to_string())?;\n+\n+                // Add sink to sink map for this accumulator.\n+                let _ = sink_map.insert(\n+                    sink.clone(),\n+                    (SinkRealization::File(file_sink), subscription),\n+                );\n+            }\n+            Sink::TcpSender(addr) => {\n+                match addr {\n+                    Addr::Ip(address) => {\n+                        let tcp_sender = TcpSender::new(*address)\n+                            .map_err(|e| format!(\"failed to create TcpSender socket: {}\", e))?;\n+                        let sink = Arc::new(Mutex::new(tcp_sender));\n+\n+                        // Subscribe the accumulator to this sink.\n+                        let subscription = accumulator\n+                            .lock()\n+                            .unwrap()\n+                            .subscribe(Box::new(sink.clone()))\n+                            .map_err(|_| \"failed to subscribe file sink to accumulator\")?;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTE0Mjg2Mg=="}, "originalCommit": {"oid": "5d11e192f5043ab1af92b1f7ad6a7d3804d550b8"}, "originalPosition": 294}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0NDY5NDcxOnYy", "diffSide": "RIGHT", "path": "rust/template/distributed_datalog/src/instantiate.rs", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNlQxODozMjoxMFrOHBUWBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNlQxODozMjoxMFrOHBUWBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTE0Mzk0Mw==", "bodyText": "accum is the last reference to this accumulator, right? So shouldn't it clear itself internal state as it goes out of scope?", "url": "https://github.com/vmware/differential-datalog/pull/737#discussion_r471143943", "createdAt": "2020-08-16T18:32:10Z", "author": {"login": "ryzhyk"}, "path": "rust/template/distributed_datalog/src/instantiate.rs", "diffHunk": "@@ -405,13 +301,218 @@ where\n         }\n     }\n \n+    /// Remove file sink or tcp sender from an existing Realization.\n+    /// Locate the entry in _sinks whose map contains the sink.\n+    /// Remove the entry from the sink map.\n+    /// Unsubscribe the accumulator from the sink.\n+    /// Return an error if unable to find a sink map containing the sink.\n+    pub fn remove_sink(&mut self, sink: &Sink) -> Result<(), String> {\n+        for (accumulator, _, sink_map) in self._sinks.values_mut() {\n+            if sink_map.contains_key(sink) {\n+                let (_, subscription) = sink_map.remove(sink).unwrap();\n+                let _ = accumulator.unsubscribe(&subscription);\n+                return Ok(());\n+            }\n+        }\n+        Err(\"failed to remove sink from realization\".to_string())\n+    }\n+\n+    /// Add file sink or tcp sender to an existing Realization.\n+    /// Creates and adds accumulator for this rel_ids to the Realization if needed.\n+    /// Subscribes the accumulator to the sink and adds the sink to\n+    /// the accumulator's map.\n+    pub fn add_sink(\n+        &mut self,\n+        sink: &Sink,\n+        rel_ids: BTreeSet<RelId>,\n+        server: &mut DDlogServer<P>,\n+    ) -> Result<(), String> {\n+        // Add the accumulator to the realization if needed.\n+        self.add_sink_accumulator(rel_ids.clone(), server)?;\n+        let (accumulator, _, sink_map) = self._sinks.get_mut(&rel_ids).unwrap();\n+\n+        match sink {\n+            Sink::File(path) => {\n+                let file = File::create(path)\n+                    .map_err(|e| format!(\"failed to create file {}:, {}\", path.display(), e))?;\n+                let file_sink = Arc::new(Mutex::new(FileSink::<P::Convert>::new(file)));\n+\n+                // Subscribe the accumulator to this sink.\n+                let subscription = accumulator\n+                    .lock()\n+                    .unwrap()\n+                    .subscribe(Box::new(file_sink.clone()))\n+                    .map_err(|_| \"failed to subscribe file sink to accumulator\".to_string())?;\n+\n+                // Add sink to sink map for this accumulator.\n+                let _ = sink_map.insert(\n+                    sink.clone(),\n+                    (SinkRealization::File(file_sink), subscription),\n+                );\n+            }\n+            Sink::TcpSender(addr) => {\n+                match addr {\n+                    Addr::Ip(address) => {\n+                        let tcp_sender = TcpSender::new(*address)\n+                            .map_err(|e| format!(\"failed to create TcpSender socket: {}\", e))?;\n+                        let sink = Arc::new(Mutex::new(tcp_sender));\n+\n+                        // Subscribe the accumulator to this sink.\n+                        let subscription = accumulator\n+                            .lock()\n+                            .unwrap()\n+                            .subscribe(Box::new(sink.clone()))\n+                            .map_err(|_| \"failed to subscribe file sink to accumulator\")?;\n+\n+                        // Add sink to sink map for this accumulator.\n+                        let _ = sink_map.insert(\n+                            Sink::TcpSender(*addr),\n+                            (SinkRealization::Node(sink), subscription),\n+                        );\n+                    }\n+                }\n+            }\n+        }\n+        Ok(())\n+    }\n+\n+    /// Remove the sink accumulator from the realization.\n+    /// Remove accumulator's entry (keyed by rel_ids) from _sinks.\n+    /// Disconnect accumulator from the server:\n+    /// - Unsubscribe the stream from the accumulator.\n+    /// - Remove the stream from the server.\n+    /// Clear the accumulator.\n+    pub fn remove_sink_accumulator(\n+        &mut self,\n+        rel_ids: BTreeSet<RelId>,\n+        server: &mut DDlogServer<P>,\n+    ) -> Result<(), String> {\n+        if let Some(entry) = self._sinks.remove(&rel_ids) {\n+            let (accumulator, mut stream, sink_map) = entry;\n+            if sink_map.is_empty() {\n+                // Disconnect accumulator from server.\n+                // First, unsubscribe the stream from the accumulator.\n+                let _ = stream.unsubscribe(&());\n+                // Next, remove the stream from the server.\n+                server.remove_stream(stream);\n+\n+                let mut accum = accumulator.lock().unwrap();\n+                // Clear the accumulator.\n+                if accum.clear().is_ok() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5d11e192f5043ab1af92b1f7ad6a7d3804d550b8"}, "originalPosition": 330}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0NDY5NzE4OnYy", "diffSide": "RIGHT", "path": "rust/template/distributed_datalog/src/instantiate.rs", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNlQxODozNTozMFrOHBUXTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNlQxODozNTozMFrOHBUXTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTE0NDI3MA==", "bodyText": "Why is this a transaction-in-progress error as opposed to just accumulator still having sinks attached to it?", "url": "https://github.com/vmware/differential-datalog/pull/737#discussion_r471144270", "createdAt": "2020-08-16T18:35:30Z", "author": {"login": "ryzhyk"}, "path": "rust/template/distributed_datalog/src/instantiate.rs", "diffHunk": "@@ -405,13 +301,218 @@ where\n         }\n     }\n \n+    /// Remove file sink or tcp sender from an existing Realization.\n+    /// Locate the entry in _sinks whose map contains the sink.\n+    /// Remove the entry from the sink map.\n+    /// Unsubscribe the accumulator from the sink.\n+    /// Return an error if unable to find a sink map containing the sink.\n+    pub fn remove_sink(&mut self, sink: &Sink) -> Result<(), String> {\n+        for (accumulator, _, sink_map) in self._sinks.values_mut() {\n+            if sink_map.contains_key(sink) {\n+                let (_, subscription) = sink_map.remove(sink).unwrap();\n+                let _ = accumulator.unsubscribe(&subscription);\n+                return Ok(());\n+            }\n+        }\n+        Err(\"failed to remove sink from realization\".to_string())\n+    }\n+\n+    /// Add file sink or tcp sender to an existing Realization.\n+    /// Creates and adds accumulator for this rel_ids to the Realization if needed.\n+    /// Subscribes the accumulator to the sink and adds the sink to\n+    /// the accumulator's map.\n+    pub fn add_sink(\n+        &mut self,\n+        sink: &Sink,\n+        rel_ids: BTreeSet<RelId>,\n+        server: &mut DDlogServer<P>,\n+    ) -> Result<(), String> {\n+        // Add the accumulator to the realization if needed.\n+        self.add_sink_accumulator(rel_ids.clone(), server)?;\n+        let (accumulator, _, sink_map) = self._sinks.get_mut(&rel_ids).unwrap();\n+\n+        match sink {\n+            Sink::File(path) => {\n+                let file = File::create(path)\n+                    .map_err(|e| format!(\"failed to create file {}:, {}\", path.display(), e))?;\n+                let file_sink = Arc::new(Mutex::new(FileSink::<P::Convert>::new(file)));\n+\n+                // Subscribe the accumulator to this sink.\n+                let subscription = accumulator\n+                    .lock()\n+                    .unwrap()\n+                    .subscribe(Box::new(file_sink.clone()))\n+                    .map_err(|_| \"failed to subscribe file sink to accumulator\".to_string())?;\n+\n+                // Add sink to sink map for this accumulator.\n+                let _ = sink_map.insert(\n+                    sink.clone(),\n+                    (SinkRealization::File(file_sink), subscription),\n+                );\n+            }\n+            Sink::TcpSender(addr) => {\n+                match addr {\n+                    Addr::Ip(address) => {\n+                        let tcp_sender = TcpSender::new(*address)\n+                            .map_err(|e| format!(\"failed to create TcpSender socket: {}\", e))?;\n+                        let sink = Arc::new(Mutex::new(tcp_sender));\n+\n+                        // Subscribe the accumulator to this sink.\n+                        let subscription = accumulator\n+                            .lock()\n+                            .unwrap()\n+                            .subscribe(Box::new(sink.clone()))\n+                            .map_err(|_| \"failed to subscribe file sink to accumulator\")?;\n+\n+                        // Add sink to sink map for this accumulator.\n+                        let _ = sink_map.insert(\n+                            Sink::TcpSender(*addr),\n+                            (SinkRealization::Node(sink), subscription),\n+                        );\n+                    }\n+                }\n+            }\n+        }\n+        Ok(())\n+    }\n+\n+    /// Remove the sink accumulator from the realization.\n+    /// Remove accumulator's entry (keyed by rel_ids) from _sinks.\n+    /// Disconnect accumulator from the server:\n+    /// - Unsubscribe the stream from the accumulator.\n+    /// - Remove the stream from the server.\n+    /// Clear the accumulator.\n+    pub fn remove_sink_accumulator(\n+        &mut self,\n+        rel_ids: BTreeSet<RelId>,\n+        server: &mut DDlogServer<P>,\n+    ) -> Result<(), String> {\n+        if let Some(entry) = self._sinks.remove(&rel_ids) {\n+            let (accumulator, mut stream, sink_map) = entry;\n+            if sink_map.is_empty() {\n+                // Disconnect accumulator from server.\n+                // First, unsubscribe the stream from the accumulator.\n+                let _ = stream.unsubscribe(&());\n+                // Next, remove the stream from the server.\n+                server.remove_stream(stream);\n+\n+                let mut accum = accumulator.lock().unwrap();\n+                // Clear the accumulator.\n+                if accum.clear().is_ok() {\n+                    Ok(())\n+                } else {\n+                    Err(\"Cannot remove accumulator, failed to clear\".to_string())\n+                }\n+            } else {\n+                Err(\"Cannot remove accumulator, transaction in progress\".to_string())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5d11e192f5043ab1af92b1f7ad6a7d3804d550b8"}, "originalPosition": 336}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0NDY5OTYyOnYy", "diffSide": "RIGHT", "path": "rust/template/distributed_datalog/src/instantiate.rs", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNlQxODozODo1MFrOHBUYhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNlQxODozODo1MFrOHBUYhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTE0NDU4MA==", "bodyText": "Please annotate all methods used for testing with #[cfg(test)].", "url": "https://github.com/vmware/differential-datalog/pull/737#discussion_r471144580", "createdAt": "2020-08-16T18:38:50Z", "author": {"login": "ryzhyk"}, "path": "rust/template/distributed_datalog/src/instantiate.rs", "diffHunk": "@@ -405,13 +301,218 @@ where\n         }\n     }\n \n+    /// Remove file sink or tcp sender from an existing Realization.\n+    /// Locate the entry in _sinks whose map contains the sink.\n+    /// Remove the entry from the sink map.\n+    /// Unsubscribe the accumulator from the sink.\n+    /// Return an error if unable to find a sink map containing the sink.\n+    pub fn remove_sink(&mut self, sink: &Sink) -> Result<(), String> {\n+        for (accumulator, _, sink_map) in self._sinks.values_mut() {\n+            if sink_map.contains_key(sink) {\n+                let (_, subscription) = sink_map.remove(sink).unwrap();\n+                let _ = accumulator.unsubscribe(&subscription);\n+                return Ok(());\n+            }\n+        }\n+        Err(\"failed to remove sink from realization\".to_string())\n+    }\n+\n+    /// Add file sink or tcp sender to an existing Realization.\n+    /// Creates and adds accumulator for this rel_ids to the Realization if needed.\n+    /// Subscribes the accumulator to the sink and adds the sink to\n+    /// the accumulator's map.\n+    pub fn add_sink(\n+        &mut self,\n+        sink: &Sink,\n+        rel_ids: BTreeSet<RelId>,\n+        server: &mut DDlogServer<P>,\n+    ) -> Result<(), String> {\n+        // Add the accumulator to the realization if needed.\n+        self.add_sink_accumulator(rel_ids.clone(), server)?;\n+        let (accumulator, _, sink_map) = self._sinks.get_mut(&rel_ids).unwrap();\n+\n+        match sink {\n+            Sink::File(path) => {\n+                let file = File::create(path)\n+                    .map_err(|e| format!(\"failed to create file {}:, {}\", path.display(), e))?;\n+                let file_sink = Arc::new(Mutex::new(FileSink::<P::Convert>::new(file)));\n+\n+                // Subscribe the accumulator to this sink.\n+                let subscription = accumulator\n+                    .lock()\n+                    .unwrap()\n+                    .subscribe(Box::new(file_sink.clone()))\n+                    .map_err(|_| \"failed to subscribe file sink to accumulator\".to_string())?;\n+\n+                // Add sink to sink map for this accumulator.\n+                let _ = sink_map.insert(\n+                    sink.clone(),\n+                    (SinkRealization::File(file_sink), subscription),\n+                );\n+            }\n+            Sink::TcpSender(addr) => {\n+                match addr {\n+                    Addr::Ip(address) => {\n+                        let tcp_sender = TcpSender::new(*address)\n+                            .map_err(|e| format!(\"failed to create TcpSender socket: {}\", e))?;\n+                        let sink = Arc::new(Mutex::new(tcp_sender));\n+\n+                        // Subscribe the accumulator to this sink.\n+                        let subscription = accumulator\n+                            .lock()\n+                            .unwrap()\n+                            .subscribe(Box::new(sink.clone()))\n+                            .map_err(|_| \"failed to subscribe file sink to accumulator\")?;\n+\n+                        // Add sink to sink map for this accumulator.\n+                        let _ = sink_map.insert(\n+                            Sink::TcpSender(*addr),\n+                            (SinkRealization::Node(sink), subscription),\n+                        );\n+                    }\n+                }\n+            }\n+        }\n+        Ok(())\n+    }\n+\n+    /// Remove the sink accumulator from the realization.\n+    /// Remove accumulator's entry (keyed by rel_ids) from _sinks.\n+    /// Disconnect accumulator from the server:\n+    /// - Unsubscribe the stream from the accumulator.\n+    /// - Remove the stream from the server.\n+    /// Clear the accumulator.\n+    pub fn remove_sink_accumulator(\n+        &mut self,\n+        rel_ids: BTreeSet<RelId>,\n+        server: &mut DDlogServer<P>,\n+    ) -> Result<(), String> {\n+        if let Some(entry) = self._sinks.remove(&rel_ids) {\n+            let (accumulator, mut stream, sink_map) = entry;\n+            if sink_map.is_empty() {\n+                // Disconnect accumulator from server.\n+                // First, unsubscribe the stream from the accumulator.\n+                let _ = stream.unsubscribe(&());\n+                // Next, remove the stream from the server.\n+                server.remove_stream(stream);\n+\n+                let mut accum = accumulator.lock().unwrap();\n+                // Clear the accumulator.\n+                if accum.clear().is_ok() {\n+                    Ok(())\n+                } else {\n+                    Err(\"Cannot remove accumulator, failed to clear\".to_string())\n+                }\n+            } else {\n+                Err(\"Cannot remove accumulator, transaction in progress\".to_string())\n+            }\n+        } else {\n+            Err(\"Unable to locate accumulator to remove from _sinks\".to_string())\n+        }\n+    }\n+\n+    /// Creates and adds a sink accumulator to the existing Realization.\n+    /// Adds a stream to the server for the accumulator.\n+    /// Creates an entry in Realization _sinks for this rel_ids.\n+    pub fn add_sink_accumulator(\n+        &mut self,\n+        rel_ids: BTreeSet<RelId>,\n+        server: &mut DDlogServer<P>,\n+    ) -> Result<(), String> {\n+        if !self._sinks.contains_key(&rel_ids) {\n+            let accumulator = Arc::new(Mutex::new(DistributingAccumulator::new()));\n+            let mut update_observ = server.add_stream(rel_ids.clone());\n+            update_observ\n+                .subscribe(Box::new(accumulator.clone()))\n+                .map_err(|_| \"failed to subscribe accumulator to DDlogServer\".to_string())?;\n+\n+            let _ = self\n+                ._sinks\n+                .insert(rel_ids, (accumulator, update_observ, HashMap::new()));\n+        }\n+        Ok(())\n+    }\n+\n+    /// Checks that the given file source exists in the Realization.\n+    /// Used for testing.\n+    pub fn contains_file_source(&self, path: PathBuf) -> bool {\n+        self._sources.contains_key(&Source::File(path))\n+    }\n+\n+    /// Checks that a tcp receiver exists in the Realization.\n+    /// Used for testing.\n+    pub fn contains_tcp_receiver(&self) -> bool {\n+        self._sources.contains_key(&Source::TcpReceiver)\n+    }\n+\n+    /// Retrieves the id for the source (generated by the TxnMux).\n+    /// Used for testing.\n+    pub fn get_source_id(&self, path: PathBuf) -> usize {\n+        let (_, _, id) = self._sources.get(&Source::File(path)).unwrap();\n+        *id\n+    }\n+\n+    /// Retrieves the id for the TcpReceiver in the Realization.\n+    /// Used for testing.\n+    pub fn get_tcp_receiver_id(&self) -> usize {\n+        let (_, _, id) = self._sources.get(&Source::TcpReceiver).unwrap();\n+        *id\n+    }\n+\n+    /// Checks that the given source (checking by its id) is contained\n+    /// in the TxnMux's subscriptions.\n+    /// Used for testing.\n+    pub fn txn_subscription_exists(&self, id: usize) -> bool {\n+        self._txnmux.subscription_exists(id)\n+    }\n+\n+    /// Checks that the given sink both has an associated accumulator and\n+    /// that said accumulator is subscribed to the sink.\n+    /// Used for testing.\n+    pub fn accumulator_is_subscribed_to_sink(&self, rel_ids: BTreeSet<RelId>, sink: &Sink) -> bool {\n+        let (_, _, sink_map) = self._sinks.get(&rel_ids).unwrap();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5d11e192f5043ab1af92b1f7ad6a7d3804d550b8"}, "originalPosition": 402}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0NDcwNjQ3OnYy", "diffSide": "RIGHT", "path": "test/datalog_tests/server_api/tests/realization_tests.rs", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNlQxODo0ODo1N1rOHBUb5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxNjowMjoxNVrOHDOMng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTE0NTQ0NQ==", "bodyText": "These tests look good, but we should also test the dataflow through the system, e.g., that connecting a new sink to an accumulatator brings it up to a correct state.\nLet's wrap up this PR and try to add more tests as a separate PR.", "url": "https://github.com/vmware/differential-datalog/pull/737#discussion_r471145445", "createdAt": "2020-08-16T18:48:57Z", "author": {"login": "ryzhyk"}, "path": "test/datalog_tests/server_api/tests/realization_tests.rs", "diffHunk": "@@ -0,0 +1,154 @@\n+#[cfg(test)]\n+mod tests {\n+    use distributed_datalog::{Addr, DDlogServer, Realization, Sink, Source};\n+    use server_api_ddlog::api::HDDlog;\n+    use std::collections::{BTreeSet, HashMap};\n+    use std::net::{IpAddr, Ipv4Addr, SocketAddr};\n+    use std::path::PathBuf;\n+    use tempfile::NamedTempFile;\n+\n+    #[test]\n+    fn add_and_then_remove_file_source_from_realization() {\n+        let mut realization = Realization::<HDDlog>::new();\n+\n+        let file = NamedTempFile::new().unwrap();\n+        let path = file.path();\n+        // Check that adding the file succeeds.\n+        assert_eq!(realization.add_file_source(path), Ok(()));\n+\n+        let pathbuf = PathBuf::from(path);\n+        // Check that realization has the file as a source.\n+        assert!(realization.contains_file_source(pathbuf.clone()));\n+        let source_id = realization.get_source_id((&path).to_path_buf());\n+        // Check TxnMux has subscription to source.\n+        assert!(realization.txn_subscription_exists(source_id));\n+\n+        // Check that removing the file sink succeeds.\n+        assert_eq!(\n+            realization.remove_source(&Source::File(pathbuf.clone())),\n+            Ok(())\n+        );\n+        // Check that the realization no longer contains the file sink.\n+        assert!(!realization.contains_file_source(pathbuf));\n+    }\n+\n+    #[test]\n+    fn add_and_then_remove_tcp_receiver_from_realization() {\n+        let mut realization = Realization::<HDDlog>::new();\n+\n+        let addr = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 5000);\n+        // Check that realization has tcp receiver.\n+        assert_eq!(realization.add_tcp_receiver(&addr), Ok(()));\n+\n+        let source_id = realization.get_tcp_receiver_id();\n+        // Check that TxnMux is subscribed to tcp receiver.\n+        assert!(realization.txn_subscription_exists(source_id));\n+        // Check that Realization contains the tcp receiver.\n+        assert!(realization.contains_tcp_receiver());\n+\n+        // Check that removing the tcp receiver succeeds.\n+        assert_eq!(realization.remove_source(&Source::TcpReceiver), Ok(()));\n+        // Check that the realization no longer contains the tcp receiver.\n+        assert!(!realization.contains_tcp_receiver());\n+    }\n+\n+    #[test]\n+    fn add_and_remove_tcp_sender_sink() {\n+        let mut realization = Realization::<HDDlog>::new();\n+\n+        // Set up dummy realization.\n+        let addr = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 5000);\n+        let mut rel_ids = BTreeSet::new();\n+        rel_ids.insert(1);\n+        rel_ids.insert(2);\n+        rel_ids.insert(3);\n+\n+        let mut server = DDlogServer::new(None, HashMap::new());\n+        let sink = Sink::TcpSender(Addr::Ip(addr));\n+\n+        // Check that realization successfully adds tcp sender sink.\n+        assert_eq!(\n+            realization.add_sink(&sink, rel_ids.clone(), &mut server),\n+            Ok(())\n+        );\n+        // Check that realization has an accumulator for the sink and that the\n+        // subscription exists.\n+        assert!(realization.accumulator_is_subscribed_to_sink(rel_ids.clone(), &sink));\n+\n+        // Check that realization successfully removes the tcp sender sink.\n+        assert_eq!(realization.remove_sink(&sink), Ok(()));\n+        assert!(!realization.accumulator_is_subscribed_to_sink(rel_ids.clone(), &sink));\n+\n+        // Check that the sink accumulator can be successfully removed.\n+        assert_eq!(\n+            realization.remove_sink_accumulator(rel_ids, &mut server),\n+            Ok(())\n+        );\n+    }\n+\n+    #[test]\n+    fn add_and_remove_file_sink() {\n+        // Set up dummy realization.\n+        let mut realization = Realization::<HDDlog>::new();\n+\n+        let file = NamedTempFile::new().unwrap();\n+        let path = file.path();\n+\n+        let mut rel_ids = BTreeSet::new();\n+        rel_ids.insert(1);\n+        rel_ids.insert(2);\n+        rel_ids.insert(3);\n+\n+        let pathbuf = PathBuf::from(path);\n+        let mut server = DDlogServer::new(None, HashMap::new());\n+        let sink = Sink::File(pathbuf);\n+\n+        // Check that realization successfully adds file sink.\n+        assert_eq!(\n+            realization.add_sink(&sink, rel_ids.clone(), &mut server),\n+            Ok(())\n+        );\n+        // Check that realization has an accumulator for the sink and that the\n+        // subscription exists.\n+        assert!(realization.accumulator_is_subscribed_to_sink(rel_ids.clone(), &sink));\n+\n+        // Check that realization successfully removes the file sink.\n+        assert_eq!(realization.remove_sink(&sink), Ok(()));\n+        assert!(!realization.accumulator_is_subscribed_to_sink(rel_ids.clone(), &sink));\n+\n+        // Check that the sink accumulator can be successfully removed.\n+        assert_eq!(\n+            realization.remove_sink_accumulator(rel_ids, &mut server),\n+            Ok(())\n+        );\n+    }\n+\n+    #[test]\n+    fn remove_sink_accumulator_prematurely() {\n+        // Should error if the accumulator to be removed still has sinks.\n+\n+        let mut realization = Realization::<HDDlog>::new();\n+\n+        let file = NamedTempFile::new().unwrap();\n+        let path = file.path();\n+\n+        let mut rel_ids = BTreeSet::new();\n+        rel_ids.insert(1);\n+        rel_ids.insert(2);\n+        rel_ids.insert(3);\n+\n+        let pathbuf = PathBuf::from(path);\n+        let mut server = DDlogServer::new(None, HashMap::new());\n+        let sink = Sink::File(pathbuf);\n+\n+        // Check that the sink is added successfully.\n+        assert_eq!(\n+            realization.add_sink(&sink, rel_ids.clone(), &mut server),\n+            Ok(())\n+        );\n+        // Check that removing the sink accumulator returns an error.\n+        assert!(realization\n+            .remove_sink_accumulator(rel_ids, &mut server)\n+            .is_err());\n+    }\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5d11e192f5043ab1af92b1f7ad6a7d3804d550b8"}, "originalPosition": 154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE0MDM4Mg==", "bodyText": "Sounds good to me.", "url": "https://github.com/vmware/differential-datalog/pull/737#discussion_r473140382", "createdAt": "2020-08-19T16:02:15Z", "author": {"login": "krs85"}, "path": "test/datalog_tests/server_api/tests/realization_tests.rs", "diffHunk": "@@ -0,0 +1,154 @@\n+#[cfg(test)]\n+mod tests {\n+    use distributed_datalog::{Addr, DDlogServer, Realization, Sink, Source};\n+    use server_api_ddlog::api::HDDlog;\n+    use std::collections::{BTreeSet, HashMap};\n+    use std::net::{IpAddr, Ipv4Addr, SocketAddr};\n+    use std::path::PathBuf;\n+    use tempfile::NamedTempFile;\n+\n+    #[test]\n+    fn add_and_then_remove_file_source_from_realization() {\n+        let mut realization = Realization::<HDDlog>::new();\n+\n+        let file = NamedTempFile::new().unwrap();\n+        let path = file.path();\n+        // Check that adding the file succeeds.\n+        assert_eq!(realization.add_file_source(path), Ok(()));\n+\n+        let pathbuf = PathBuf::from(path);\n+        // Check that realization has the file as a source.\n+        assert!(realization.contains_file_source(pathbuf.clone()));\n+        let source_id = realization.get_source_id((&path).to_path_buf());\n+        // Check TxnMux has subscription to source.\n+        assert!(realization.txn_subscription_exists(source_id));\n+\n+        // Check that removing the file sink succeeds.\n+        assert_eq!(\n+            realization.remove_source(&Source::File(pathbuf.clone())),\n+            Ok(())\n+        );\n+        // Check that the realization no longer contains the file sink.\n+        assert!(!realization.contains_file_source(pathbuf));\n+    }\n+\n+    #[test]\n+    fn add_and_then_remove_tcp_receiver_from_realization() {\n+        let mut realization = Realization::<HDDlog>::new();\n+\n+        let addr = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 5000);\n+        // Check that realization has tcp receiver.\n+        assert_eq!(realization.add_tcp_receiver(&addr), Ok(()));\n+\n+        let source_id = realization.get_tcp_receiver_id();\n+        // Check that TxnMux is subscribed to tcp receiver.\n+        assert!(realization.txn_subscription_exists(source_id));\n+        // Check that Realization contains the tcp receiver.\n+        assert!(realization.contains_tcp_receiver());\n+\n+        // Check that removing the tcp receiver succeeds.\n+        assert_eq!(realization.remove_source(&Source::TcpReceiver), Ok(()));\n+        // Check that the realization no longer contains the tcp receiver.\n+        assert!(!realization.contains_tcp_receiver());\n+    }\n+\n+    #[test]\n+    fn add_and_remove_tcp_sender_sink() {\n+        let mut realization = Realization::<HDDlog>::new();\n+\n+        // Set up dummy realization.\n+        let addr = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 5000);\n+        let mut rel_ids = BTreeSet::new();\n+        rel_ids.insert(1);\n+        rel_ids.insert(2);\n+        rel_ids.insert(3);\n+\n+        let mut server = DDlogServer::new(None, HashMap::new());\n+        let sink = Sink::TcpSender(Addr::Ip(addr));\n+\n+        // Check that realization successfully adds tcp sender sink.\n+        assert_eq!(\n+            realization.add_sink(&sink, rel_ids.clone(), &mut server),\n+            Ok(())\n+        );\n+        // Check that realization has an accumulator for the sink and that the\n+        // subscription exists.\n+        assert!(realization.accumulator_is_subscribed_to_sink(rel_ids.clone(), &sink));\n+\n+        // Check that realization successfully removes the tcp sender sink.\n+        assert_eq!(realization.remove_sink(&sink), Ok(()));\n+        assert!(!realization.accumulator_is_subscribed_to_sink(rel_ids.clone(), &sink));\n+\n+        // Check that the sink accumulator can be successfully removed.\n+        assert_eq!(\n+            realization.remove_sink_accumulator(rel_ids, &mut server),\n+            Ok(())\n+        );\n+    }\n+\n+    #[test]\n+    fn add_and_remove_file_sink() {\n+        // Set up dummy realization.\n+        let mut realization = Realization::<HDDlog>::new();\n+\n+        let file = NamedTempFile::new().unwrap();\n+        let path = file.path();\n+\n+        let mut rel_ids = BTreeSet::new();\n+        rel_ids.insert(1);\n+        rel_ids.insert(2);\n+        rel_ids.insert(3);\n+\n+        let pathbuf = PathBuf::from(path);\n+        let mut server = DDlogServer::new(None, HashMap::new());\n+        let sink = Sink::File(pathbuf);\n+\n+        // Check that realization successfully adds file sink.\n+        assert_eq!(\n+            realization.add_sink(&sink, rel_ids.clone(), &mut server),\n+            Ok(())\n+        );\n+        // Check that realization has an accumulator for the sink and that the\n+        // subscription exists.\n+        assert!(realization.accumulator_is_subscribed_to_sink(rel_ids.clone(), &sink));\n+\n+        // Check that realization successfully removes the file sink.\n+        assert_eq!(realization.remove_sink(&sink), Ok(()));\n+        assert!(!realization.accumulator_is_subscribed_to_sink(rel_ids.clone(), &sink));\n+\n+        // Check that the sink accumulator can be successfully removed.\n+        assert_eq!(\n+            realization.remove_sink_accumulator(rel_ids, &mut server),\n+            Ok(())\n+        );\n+    }\n+\n+    #[test]\n+    fn remove_sink_accumulator_prematurely() {\n+        // Should error if the accumulator to be removed still has sinks.\n+\n+        let mut realization = Realization::<HDDlog>::new();\n+\n+        let file = NamedTempFile::new().unwrap();\n+        let path = file.path();\n+\n+        let mut rel_ids = BTreeSet::new();\n+        rel_ids.insert(1);\n+        rel_ids.insert(2);\n+        rel_ids.insert(3);\n+\n+        let pathbuf = PathBuf::from(path);\n+        let mut server = DDlogServer::new(None, HashMap::new());\n+        let sink = Sink::File(pathbuf);\n+\n+        // Check that the sink is added successfully.\n+        assert_eq!(\n+            realization.add_sink(&sink, rel_ids.clone(), &mut server),\n+            Ok(())\n+        );\n+        // Check that removing the sink accumulator returns an error.\n+        assert!(realization\n+            .remove_sink_accumulator(rel_ids, &mut server)\n+            .is_err());\n+    }\n+}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTE0NTQ0NQ=="}, "originalCommit": {"oid": "5d11e192f5043ab1af92b1f7ad6a7d3804d550b8"}, "originalPosition": 154}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4817, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}