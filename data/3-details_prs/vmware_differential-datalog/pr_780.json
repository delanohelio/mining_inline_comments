{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA2NDU0ODQ5", "number": 780, "title": "Implement RFC #774.", "bodyText": "", "createdAt": "2020-10-20T04:24:32Z", "url": "https://github.com/vmware/differential-datalog/pull/780", "merged": true, "mergeCommit": {"oid": "902af28ec12471b464b4a7df9099075bea7e4796"}, "closed": true, "closedAt": "2020-10-21T02:39:21Z", "author": {"login": "ryzhyk"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdUP8OsgH2gAyNTA2NDU0ODQ5OjBlZTg3NzY2ZWIzNzExN2M2OTA2MzYyNDBmZGNhYWRkYjExZjVmZTc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdUiyKYgH2gAyNTA2NDU0ODQ5OjNmNGVhY2YwNDZlZjQ5YjUyOWY4MzRlNDMyYTc1M2YzNDI3ZGI4NWY=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "0ee87766eb37117c690636240fdcaaddb11f5fe7", "author": {"user": {"login": "ryzhyk", "name": "Leonid Ryzhyk"}}, "url": "https://github.com/vmware/differential-datalog/commit/0ee87766eb37117c690636240fdcaaddb11f5fe7", "committedDate": "2020-10-20T03:10:05Z", "message": "Apply filters after grouping.\n\nIn preparation to introducing new `group_by` syntax, we generalize the\naggregation operator in the `differential_datalog` crate to support\nfiltering aggregation results.  Previously, the operator always returned\nright after applying the reduction function.  Any subsequent filters\nhad to be applied as separate differential operators.  This introduced\nsmall overhead, which would get much worse once we decouple group_by\nand reduce operations.\n\n- Generalize `differential_datalog` to allow the reduce function to\n  return `Option`.\n\n- Change Compile.hs to apply all filters following aggregation as part\n  of the aggregation operator."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a7b6a0399c0bd91737eda469d3791c16938169de", "author": {"user": {"login": "ryzhyk", "name": "Leonid Ryzhyk"}}, "url": "https://github.com/vmware/differential-datalog/commit/a7b6a0399c0bd91737eda469d3791c16938169de", "committedDate": "2020-10-20T03:10:05Z", "message": "`group_by` operator.\n\nThe `group_by` operator is a simpler, cleaner version of `Aggregate`\n(the latter is still supported, but is now considered obsolete).\n\n`Aggregate` had several problems that made it difficult to understand\nand use.  First, `Aggregate` combines three separate operations in one.\nConsider the following example:\n\n```\nvar m = Aggregate((x,y), group_min(z+q)).\n```\n\nHere we (1) project input records to an integer value `z+q`, (2) group\nthe result by variables `x` and `y`, (3) reduce the result using the\n`group_min` function.\n\nThe second problem is that the result of `Aggregate` must always be\nbound to a variable and cannot be use in any other context, e.g.,\n`Aggregate((x,y), group_count(())) > 1` is invalid.\n\n-----------\n\nWe observe that we can always break up aggregation into two parts by\nsplitting the reduction step (step 3 above) into a separate operator.\nIn fact, we don't even need a new operator for reduction, as it is just\nan arbitrary computation over the group returned by step 2.  Thus we\nreplace `Aggregate` with a `group_by` operator that projects and groups\nthe input relation and returns an object of type `Group<K, V>`.  It is\nup to the user what to do with the resulting group.  They may instantly\nreduce it by applying an arbitrary function to it.  Alternatively, they\nmay bind it to a variable and use it later in the rule, or even store in\nthe output relation:\n\nExample 1: Group-reduce (this is equivalent to the above `Aggregate`\nexample):\n\n```\nvar m = (z+q).group_by((x,y)).min()\n```\n\nExample 2: Only group; reduce later\n\n```\nvar g = (z+q).group_by((x,y)),\ng.size() > 3,\nvar m = g.min(),\n```\n\nWe allow using `group_by` as an ordinary function that can occur\nanywhere in an expression:\n\n```\nx.group_by(y).count() > 1\n```\n\nHowever, it is only allowed inside filter clauses of a rule and can only\noccur once (multiple group_by's are possible to support, but are potentially\ntoo confusing and error-prone).\n\nImplementation-wise, there are three parts to this commit:\n\n1. Generalize the `Group<K,V>` type.  This type was previously only used\n   inside differential's `reduce` method and was backed by\n   a reference to the slice that stores group elements.  In order to be\n   able to pass groups around freely like any other DDlog type, we have\n   to clone the contents of the slice.  However, we only want to do this\n   when necessary: in the common case where the group is instantly\n   reduced, no cloning should be necessary.  To this end the new `Group`\n   implementation is an enum with reference and value-backed variants.\n   In addition, some unsafe magic, documented in `ddlog_std.dl`, is used\n   to convince Rust that the former variant has static lifetime.\n\n2. New syntax described in #774 and illustrated above.\n\n3 Library of higher-order functions over groups (similar to those for\n  vectors) along with tests."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4330d1ccfe875f8bac7ce541939f766fafcf28fa", "author": {"user": {"login": "ryzhyk", "name": "Leonid Ryzhyk"}}, "url": "https://github.com/vmware/differential-datalog/commit/4330d1ccfe875f8bac7ce541939f766fafcf28fa", "committedDate": "2020-10-20T03:10:05Z", "message": "Document the `group_by()` operator.\n\n- Rewrite tutorial section on Aggregation to talk about `group_by`\n  instead.\n- Update language reference."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEyMzIyMDQz", "url": "https://github.com/vmware/differential-datalog/pull/780#pullrequestreview-512322043", "createdAt": "2020-10-20T04:27:49Z", "commit": {"oid": "4330d1ccfe875f8bac7ce541939f766fafcf28fa"}, "state": "APPROVED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQwNDoyNzo1MFrOHkqLbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxOToxNDo0MlrOHlNR-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIwMTgzNw==", "bodyText": "How about you point to the y in the head\nR(x, y) :-\n  // ^ this y cannot be used", "url": "https://github.com/vmware/differential-datalog/pull/780#discussion_r508201837", "createdAt": "2020-10-20T04:27:50Z", "author": {"login": "mbudiu-vmw"}, "path": "doc/language_reference/language_reference.md", "diffHunk": "@@ -748,12 +732,12 @@ R(x,y) :- S(x), T(f(x), y). // ok, x is introduced before being used in f(x)\n ### Constraints on rules\n \n 1. Negative atoms and condition clauses may not introduce new variables.\n-1. Variables introduced in a clause are visible in clauses following it.  An aggregate\n+1. Variables introduced in a clause are visible in clauses following it.  A group_by\n    clause has the effect of concealing all variables except for the\n-   group-by variables and the aggregate variable.\n+   group-by variables.\n    ```\n-   R(x,y) :- S(x), T(x, y), var z = Aggregate((x), min(y)). // error:\n-        // y cannot be used in the head, as it is concealed by aggregation\n+   R(x,y) :- S(x), T(x, y), var z = y.group_by(x).min(). // error:\n+        // y cannot be used in the head, as it is concealed by grouping", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4330d1ccfe875f8bac7ce541939f766fafcf28fa"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIwMjczOQ==", "bodyText": "what is the order of the elements in a group?", "url": "https://github.com/vmware/differential-datalog/pull/780#discussion_r508202739", "createdAt": "2020-10-20T04:31:39Z", "author": {"login": "mbudiu-vmw"}, "path": "doc/tutorial/tutorial.md", "diffHunk": "@@ -1310,87 +1310,148 @@ on itself, either directly or via a chain of rules.  The [language\n reference](../language_reference/language_reference.md#constraints-on-dependency-graph)\n describes constraints on the recursive programs accepted by DDlog.\n \n-#### Aggregation\n+#### Grouping\n \n-The `Aggregate` operator groups records that have the same values of a subset of\n-variables (group-by variables) and applies an aggregation function to each group.\n+The `group_by` operator groups records that share common values of a subset of\n+variables (group-by variables).\n The following program groups the `Price` relation by `item` and selects the minimal\n price for each item:\n \n ```\n-input relation Price(item: string, vendor: string, price: bit<64>)\n-output relation BestPrice(item: string, price: bit<64>)\n+input relation Price(item: string, vendor: string, price: u64)\n+output relation BestPrice(item: string, price: u64)\n \n BestPrice(item, best_price) :-\n     Price(.item = item, .price = price),\n-    var best_price = Aggregate((item), group_min(price)).\n+    var group: Group<string, u64> = price.group_by(item),\n+    var best_price = group.min().\n ```\n \n-Here `group_min()` is one of several aggregation functions defined in\n-`lib/ddlog_std.rs`.\n+The `group_by` operator first selects the `price` variable from each record and\n+then groups the resulting table of prices such that all records in a group share the\n+same value of the `item` variable.  It yields a new table with one record per group.\n+The contents of the group is bound to a variable of type `Group<string,u64>`,\n+where `string` is the type of group key, i.e., the variable(s) that we group by\n+(in this case, `item`), and `u64` is the type of values in the group.\n \n-It is possible to group a relation by multiple fields.  For\n-example, the following rule computes the lowest price that each vendor\n-charged for each item:\n+In general, the `group_by` operator has the following syntax:\n+\n+```\n+<select clause>.group_by(<group-by vars>)\n+```\n+\n+where `<select clause>` is an arbitrary expression that projects records\n+from the input relation into values to be grouped. `<group-by vars>` is a single\n+variable or a tuple of variables to be used as the key to group by:\n+\n+```\n+/* Group by an empty tuple: aggregates the entire relation into a single group. */\n+var group: Group<(), usize> = (x: usize).group_by(())\n+\n+/* Group by a single variable.  Generates one group per each unique value\n+ * of y. */\n+var group: Group<string, usize> = (x: usize).group_by(y: string)\n+\n+/* Group by multiple variables.  Generates a group per each unique combination\n+ * of `y` and `z`. */\n+var group: Group<(string, bool), usize> = x.group_by((y: string, z: bool))\n+```\n+\n+The following rule groups prices by both item name and vendor in order to compute\n+the lowest price that each vendor charges for each item:\n \n ```\n BestPricePerVendor(item, vendor, best_price) :-\n     Price(.item = item, .vendor = vendor, .price = price),\n-    var best_price = Aggregate((item, vendor), group_min(price)).\n+    var group = price.group_by((item, vendor)),\n+    var best_price = group.min().\n+```\n+\n+Typically, the group returned by `group_by` is immediately\n+reduced to a single value, e.g., by computing its minimal element as in the\n+`BestPrice` example.  In this case, we can pass the group directly\n+to the reduction function without having to first store it in a variable:\n+\n+```\n+BestPrice(item, best_price) :-\n+    Price(.item = item, .price = price),\n+    // Group and immediately reduce.\n+    var best_price = price.group_by(item).min().\n+```\n+\n+In fact, the `group_by` operator can be used as any normal expression, e.g.:\n+\n+```\n+// Items under 100 dollars.\n+Under100(item) :-\n+    Price(.item = item, .price = price),\n+    // Group and immediately reduce.\n+    price.group_by(item).min() < 100.\n+```\n+\n+`min()` is one of several standard reduction functions defined in\n+`lib/ddlog_std.dl`.  Below we list few of the others:\n+\n+```\n+/**/\n+function key(g: Group<'K, 'V>): 'K\n+\n+/* The number of elements in the group.  The result is always greater than 0. */\n+function size(g: Group<'K, 'V>): usize\n+\n+/* The first element of the group.  This operation is well defined,\n+ * as a group returned by `group-by` cannot be empty. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4330d1ccfe875f8bac7ce541939f766fafcf28fa"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIwMjkzOA==", "bodyText": "and ordering", "url": "https://github.com/vmware/differential-datalog/pull/780#discussion_r508202938", "createdAt": "2020-10-20T04:32:18Z", "author": {"login": "mbudiu-vmw"}, "path": "doc/tutorial/tutorial.md", "diffHunk": "@@ -1310,87 +1310,148 @@ on itself, either directly or via a chain of rules.  The [language\n reference](../language_reference/language_reference.md#constraints-on-dependency-graph)\n describes constraints on the recursive programs accepted by DDlog.\n \n-#### Aggregation\n+#### Grouping\n \n-The `Aggregate` operator groups records that have the same values of a subset of\n-variables (group-by variables) and applies an aggregation function to each group.\n+The `group_by` operator groups records that share common values of a subset of\n+variables (group-by variables).\n The following program groups the `Price` relation by `item` and selects the minimal\n price for each item:\n \n ```\n-input relation Price(item: string, vendor: string, price: bit<64>)\n-output relation BestPrice(item: string, price: bit<64>)\n+input relation Price(item: string, vendor: string, price: u64)\n+output relation BestPrice(item: string, price: u64)\n \n BestPrice(item, best_price) :-\n     Price(.item = item, .price = price),\n-    var best_price = Aggregate((item), group_min(price)).\n+    var group: Group<string, u64> = price.group_by(item),\n+    var best_price = group.min().\n ```\n \n-Here `group_min()` is one of several aggregation functions defined in\n-`lib/ddlog_std.rs`.\n+The `group_by` operator first selects the `price` variable from each record and\n+then groups the resulting table of prices such that all records in a group share the\n+same value of the `item` variable.  It yields a new table with one record per group.\n+The contents of the group is bound to a variable of type `Group<string,u64>`,\n+where `string` is the type of group key, i.e., the variable(s) that we group by\n+(in this case, `item`), and `u64` is the type of values in the group.\n \n-It is possible to group a relation by multiple fields.  For\n-example, the following rule computes the lowest price that each vendor\n-charged for each item:\n+In general, the `group_by` operator has the following syntax:\n+\n+```\n+<select clause>.group_by(<group-by vars>)\n+```\n+\n+where `<select clause>` is an arbitrary expression that projects records\n+from the input relation into values to be grouped. `<group-by vars>` is a single\n+variable or a tuple of variables to be used as the key to group by:\n+\n+```\n+/* Group by an empty tuple: aggregates the entire relation into a single group. */\n+var group: Group<(), usize> = (x: usize).group_by(())\n+\n+/* Group by a single variable.  Generates one group per each unique value\n+ * of y. */\n+var group: Group<string, usize> = (x: usize).group_by(y: string)\n+\n+/* Group by multiple variables.  Generates a group per each unique combination\n+ * of `y` and `z`. */\n+var group: Group<(string, bool), usize> = x.group_by((y: string, z: bool))\n+```\n+\n+The following rule groups prices by both item name and vendor in order to compute\n+the lowest price that each vendor charges for each item:\n \n ```\n BestPricePerVendor(item, vendor, best_price) :-\n     Price(.item = item, .vendor = vendor, .price = price),\n-    var best_price = Aggregate((item, vendor), group_min(price)).\n+    var group = price.group_by((item, vendor)),\n+    var best_price = group.min().\n+```\n+\n+Typically, the group returned by `group_by` is immediately\n+reduced to a single value, e.g., by computing its minimal element as in the\n+`BestPrice` example.  In this case, we can pass the group directly\n+to the reduction function without having to first store it in a variable:\n+\n+```\n+BestPrice(item, best_price) :-\n+    Price(.item = item, .price = price),\n+    // Group and immediately reduce.\n+    var best_price = price.group_by(item).min().\n+```\n+\n+In fact, the `group_by` operator can be used as any normal expression, e.g.:\n+\n+```\n+// Items under 100 dollars.\n+Under100(item) :-\n+    Price(.item = item, .price = price),\n+    // Group and immediately reduce.\n+    price.group_by(item).min() < 100.\n+```\n+\n+`min()` is one of several standard reduction functions defined in\n+`lib/ddlog_std.dl`.  Below we list few of the others:\n+\n+```\n+/**/\n+function key(g: Group<'K, 'V>): 'K\n+\n+/* The number of elements in the group.  The result is always greater than 0. */\n+function size(g: Group<'K, 'V>): usize\n+\n+/* The first element of the group.  This operation is well defined,\n+ * as a group returned by `group-by` cannot be empty. */\n+function first(g: Group<'K, 'V>): 'V\n+\n+/* Nth element of the group. */\n+function nth(g: Group<'K,'V>, n: usize): Option<'V>\n+\n+/* Convert group to a vector of its elements.  The resulting \n+ * vector has the same size as the group. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4330d1ccfe875f8bac7ce541939f766fafcf28fa"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODIwMzEzOA==", "bodyText": "arg_min?", "url": "https://github.com/vmware/differential-datalog/pull/780#discussion_r508203138", "createdAt": "2020-10-20T04:33:08Z", "author": {"login": "mbudiu-vmw"}, "path": "doc/tutorial/tutorial.md", "diffHunk": "@@ -1310,87 +1310,148 @@ on itself, either directly or via a chain of rules.  The [language\n reference](../language_reference/language_reference.md#constraints-on-dependency-graph)\n describes constraints on the recursive programs accepted by DDlog.\n \n-#### Aggregation\n+#### Grouping\n \n-The `Aggregate` operator groups records that have the same values of a subset of\n-variables (group-by variables) and applies an aggregation function to each group.\n+The `group_by` operator groups records that share common values of a subset of\n+variables (group-by variables).\n The following program groups the `Price` relation by `item` and selects the minimal\n price for each item:\n \n ```\n-input relation Price(item: string, vendor: string, price: bit<64>)\n-output relation BestPrice(item: string, price: bit<64>)\n+input relation Price(item: string, vendor: string, price: u64)\n+output relation BestPrice(item: string, price: u64)\n \n BestPrice(item, best_price) :-\n     Price(.item = item, .price = price),\n-    var best_price = Aggregate((item), group_min(price)).\n+    var group: Group<string, u64> = price.group_by(item),\n+    var best_price = group.min().\n ```\n \n-Here `group_min()` is one of several aggregation functions defined in\n-`lib/ddlog_std.rs`.\n+The `group_by` operator first selects the `price` variable from each record and\n+then groups the resulting table of prices such that all records in a group share the\n+same value of the `item` variable.  It yields a new table with one record per group.\n+The contents of the group is bound to a variable of type `Group<string,u64>`,\n+where `string` is the type of group key, i.e., the variable(s) that we group by\n+(in this case, `item`), and `u64` is the type of values in the group.\n \n-It is possible to group a relation by multiple fields.  For\n-example, the following rule computes the lowest price that each vendor\n-charged for each item:\n+In general, the `group_by` operator has the following syntax:\n+\n+```\n+<select clause>.group_by(<group-by vars>)\n+```\n+\n+where `<select clause>` is an arbitrary expression that projects records\n+from the input relation into values to be grouped. `<group-by vars>` is a single\n+variable or a tuple of variables to be used as the key to group by:\n+\n+```\n+/* Group by an empty tuple: aggregates the entire relation into a single group. */\n+var group: Group<(), usize> = (x: usize).group_by(())\n+\n+/* Group by a single variable.  Generates one group per each unique value\n+ * of y. */\n+var group: Group<string, usize> = (x: usize).group_by(y: string)\n+\n+/* Group by multiple variables.  Generates a group per each unique combination\n+ * of `y` and `z`. */\n+var group: Group<(string, bool), usize> = x.group_by((y: string, z: bool))\n+```\n+\n+The following rule groups prices by both item name and vendor in order to compute\n+the lowest price that each vendor charges for each item:\n \n ```\n BestPricePerVendor(item, vendor, best_price) :-\n     Price(.item = item, .vendor = vendor, .price = price),\n-    var best_price = Aggregate((item, vendor), group_min(price)).\n+    var group = price.group_by((item, vendor)),\n+    var best_price = group.min().\n+```\n+\n+Typically, the group returned by `group_by` is immediately\n+reduced to a single value, e.g., by computing its minimal element as in the\n+`BestPrice` example.  In this case, we can pass the group directly\n+to the reduction function without having to first store it in a variable:\n+\n+```\n+BestPrice(item, best_price) :-\n+    Price(.item = item, .price = price),\n+    // Group and immediately reduce.\n+    var best_price = price.group_by(item).min().\n+```\n+\n+In fact, the `group_by` operator can be used as any normal expression, e.g.:\n+\n+```\n+// Items under 100 dollars.\n+Under100(item) :-\n+    Price(.item = item, .price = price),\n+    // Group and immediately reduce.\n+    price.group_by(item).min() < 100.\n+```\n+\n+`min()` is one of several standard reduction functions defined in\n+`lib/ddlog_std.dl`.  Below we list few of the others:\n+\n+```\n+/**/\n+function key(g: Group<'K, 'V>): 'K\n+\n+/* The number of elements in the group.  The result is always greater than 0. */\n+function size(g: Group<'K, 'V>): usize\n+\n+/* The first element of the group.  This operation is well defined,\n+ * as a group returned by `group-by` cannot be empty. */\n+function first(g: Group<'K, 'V>): 'V\n+\n+/* Nth element of the group. */\n+function nth(g: Group<'K,'V>, n: usize): Option<'V>\n+\n+/* Convert group to a vector of its elements.  The resulting \n+ * vector has the same size as the group. */\n+function to_vec(g: Group<'K, 'V>): Vec<'V>\n ```\n \n What if we wanted to return the name of the vendor along with the\n-lowest price for each item?  The following naive attempt will not work:\n+lowest price for each item?  The following naive attempt will **not work**:\n \n ```\n output relation BestVendor(item: string, vendor: string, price: bit<64>)\n \n-BestVendor(item, vendor, best_price) :-\n+BestVendor(item, vendor /*unknown variable*/, best_price) :-\n     Price(.item = item, .vendor = vendor, .price = price),\n-    var best_price = Aggregate((item), group_min(price)).\n+    var best_price = price.group_by(item).min().\n ```\n \n DDlog will complain that `vendor` is unknown in the head of the rule. What\n happens here is that we first group records with the same `item` value\n and then reduce each group to a single value, `best_price`.  All other\n variables (except `item` and `best_price`) disappear from the scope and cannot\n-be used in the body of the rule following the `Aggregate` operator or in\n+be used in the body of the rule following the `group_by` operator or in\n its head.\n \n-A correct solution requires a different aggregation function that takes a\n-group of `(vendor, price)` tuples and picks one with the smallest price.  To\n-enable such use cases, DDlog allows users to implement their own custom\n-aggregation functions:\n+A correct solution requires a different function that takes a\n+group of `(vendor, price)` tuples and picks one with the smallest price.\n+This can be achieved using the `arg_min` function,\n+that takes a group and a closure that maps an element of the group into\n+an integer value and returns the first element in the group that minimizes\n+the value returned by the closure:\n \n ```\n-/* User-defined aggregate that picks a tuple with the smallest price */\n-function best_vendor(g: Group<'K, (string, bit<64>)>): (string, bit<64>)\n-{\n-    var min_vendor = \"\";\n-    var min_price: bit<64> = 'hffffffffffffffff;\n-    for (vendor_price in g) {\n-        if (vendor_price.1 < min_price) {\n-            min_vendor = vendor_price.0;\n-            min_price = vendor_price.1\n-        }\n-    };\n-    (min_vendor, min_price)\n-}\n+// Defines `arg_min` and other higher-order functions over groups.\n+import group\n \n BestVendor(item, best_vendor, best_price) :-\n     Price(item, vendor, price),\n-    var best_vendor_price = Aggregate((item), best_vendor((vendor, price))),\n-    (var best_vendor, var best_price) = best_vendor_price.\n+    (var best_vendor, var best_price) = (vendor, price).group_by(item).arg_min(|vendor_price| vendor_price.1).\n ```\n \n-The aggregation function takes an argument of type `Group`, parameterized by\n-group key and group value types.  The group key is a tuple consisting of all\n-group-by variables.  The value type is the type of records in the group and.\n+`group_min`, along with other useful higher-order functions over groups,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4330d1ccfe875f8bac7ce541939f766fafcf28fa"}, "originalPosition": 177}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY5Mzc1MQ==", "bodyText": "How can this be empty?", "url": "https://github.com/vmware/differential-datalog/pull/780#discussion_r508693751", "createdAt": "2020-10-20T17:02:07Z", "author": {"login": "mbudiu-vmw"}, "path": "lib/ddlog_std.rs", "diffHunk": "@@ -1145,110 +1149,347 @@ pub fn hash128<T: Hash>(x: &T) -> u128 {\n pub type ProjectFunc<X> = ::std::rc::Rc<dyn Fn(&DDValue) -> X>;\n \n /*\n- * Group type (used in aggregation operators)\n+ * Group type (returned by the `group_by` operator).\n+ *\n+ * A group captures output of the differential dataflow `reduce` operator.\n+ * Thus, upon creation it is backed by references to DD state.  However, we\n+ * would like to be able to manipulate groups as normal variables, store then\n+ * in relations, which requires copying the contents of a group during cloning.\n+ * Since we want the same code (e.g., the same aggregation functions) to work\n+ * on both reference-backed and value-backed groups, we represent groups as\n+ * an enum and provide uniform API over both variants.\n+ *\n+ * There is a problem of managing the lifetime of a group.  Since one of the\n+ * two variants contains references, the group type is parameterized by the\n+ * lifetime of these refs.  However, in order to be able to freely store and\n+ * pass groups to and from functions, we want `'static` lifetime.  Because\n+ * of the way we use groups in DDlog-generated code, we can safely transmute\n+ * them to the `'static` lifetime upon creation.  Here is why.  A group is\n+ * always created like this:\n+ * ```\n+ * let ref g = GroupEnum::ByRef{key, vals, project}\n+ * ```\n+ * where `vals` haa local lifetime `'a` that contains the lifetime\n+ * `'b` of the resulting reference `g`.  Since we are never going to move\n+ * `vals` refs out of the group (the accessor API returns them\n+ * by-value), it is ok to tranmute `g` from `&'b Group<'a>` to\n+ * `&'b Group<'static>` and have the `'b` lifetime protect access to the group.\n+ * The only way to use the group outside of `'b` is to clone it, which will\n+ * create an instance of `ByVal` that truly has `'static` lifetime.\n  */\n-pub struct Group<'a, K, V> {\n-    /* TODO: remove \"pub\" */\n-    pub key: &'a K,\n-    pub group: &'a [(&'a DDValue, Weight)],\n-    pub project: ProjectFunc<V>,\n+\n+pub type Group<K, V> = GroupEnum<'static, K, V>;\n+\n+pub enum GroupEnum<'a, K, V> {\n+    ByRef {\n+        key: K,\n+        group: &'a [(&'a DDValue, Weight)],\n+        project: ProjectFunc<V>,\n+    },\n+    ByVal {\n+        key: K,\n+        group: ::std::vec::Vec<V>,\n+    },\n+}\n+\n+/* Always clone by value. */\n+impl<K: Clone, V: Clone> Clone for Group<K, V> {\n+    fn clone(&self) -> Self {\n+        match self {\n+            GroupEnum::ByRef {\n+                key,\n+                group,\n+                project,\n+            } => GroupEnum::ByVal {\n+                key: key.clone(),\n+                group: group.iter().map(|(v, _)| project(v)).collect(),\n+            },\n+            GroupEnum::ByVal { key, group } => GroupEnum::ByVal {\n+                key: key.clone(),\n+                group: group.clone(),\n+            },\n+        }\n+    }\n }\n \n-/* This is needed so we can support for-loops over `Group`'s\n- */\n-pub struct GroupIter<'a, V> {\n-    iter: slice::Iter<'a, (&'a DDValue, Weight)>,\n-    project: ProjectFunc<V>,\n+impl<K: Default, V: Default> Default for Group<K, V> {\n+    fn default() -> Self {\n+        GroupEnum::ByVal {\n+            key: K::default(),\n+            group: vec![],\n+        }\n+    }\n+}\n+\n+/* We compare two groups by comparing values returned by their `project()`\n+ * functions, not the underlying DDValue's.  DDValue's are not visiable to\n+ * the DDlog program; hence two groups are iff they have the same\n+ * projections. */\n+\n+impl<K: PartialEq, V: Clone + PartialEq> PartialEq for Group<K, V> {\n+    fn eq(&self, other: &Self) -> bool {\n+        (self.key_ref() == other.key_ref()) && (self.iter().eq(other.iter()))\n+    }\n+}\n+\n+impl<K: PartialEq, V: Clone + PartialEq> Eq for Group<K, V> {}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4330d1ccfe875f8bac7ce541939f766fafcf28fa"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc0ODYzNQ==", "bodyText": "maybe you can unify arg_min and arg_max using a lambda for the comparison", "url": "https://github.com/vmware/differential-datalog/pull/780#discussion_r508748635", "createdAt": "2020-10-20T18:30:25Z", "author": {"login": "mbudiu-vmw"}, "path": "lib/group.dl", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * Functions for working with groups (see basic group operations defined in\n+ * `ddlog_std.dl`).\n+ */\n+\n+/* We implement `map`, `flatmap`, `sort_by`, etc., as group-to-vector\n+ * rather than group-to-group transformations, since the output of\n+ * these methods can potentially be empty, thus violating the invariant\n+ * that a group always has at least one element. */\n+\n+/* Applies closure `f` to each element of the group. */\n+function map(g: Group<'K, 'V1>, f: function('V1): 'V2): Vec<'V2> {\n+    var res = vec_with_capacity(g.count());\n+    for (x in g) {\n+        res.push(f(x))\n+    };\n+    res\n+}\n+\n+/* Applies closure `f` to each element of the group and concatenates the\n+ * resulting vectors, returning a flat vector. */\n+function flatmap(g: Group<'K, 'V1>, f: function('V1): Vec<'V2>): Vec<'V2> {\n+    var res = vec_empty();\n+    for (x in g) {\n+        res.append(f(x))\n+    };\n+    res\n+}\n+\n+/* Returns the element that gives the minimum value from the specified function.\n+ * If several elements are equally minimum, the first element is returned. */\n+function arg_min(g: Group<'K, 'V>, f: function('V): 'A): 'V {\n+    var min_arg = g.first();\n+    var min_val = f(g.first());\n+    for (x in g) {\n+        var v = f(x);\n+        if (v < min_val) {\n+            min_val = v;\n+            min_arg = x;\n+        }\n+    };\n+    min_arg\n+}\n+\n+/* Returns the element that gives the maximum value from the specified function.\n+ * If several elements are equally maximum, the first element is returned. */\n+function arg_max(g: Group<'K, 'V>, f: function('V): 'A): 'V {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4330d1ccfe875f8bac7ce541939f766fafcf28fa"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc2MDU5Mw==", "bodyText": "how do you know this name won't clash?", "url": "https://github.com/vmware/differential-datalog/pull/780#discussion_r508760593", "createdAt": "2020-10-20T18:45:58Z", "author": {"login": "mbudiu-vmw"}, "path": "src/Language/DifferentialDatalog/Debug.hs", "diffHunk": "@@ -60,46 +57,29 @@ addBindingToRHSLiteral (r@(RHSLiteral True _), index) =\n   in r { rhsAtom = updatedAtom }\n addBindingToRHSLiteral (rule, _) = rule\n \n--- Generate debug function name.\n-debugAggregateFunctionName :: Int -> Int -> String -> String\n-debugAggregateFunctionName rlidx rhsidx fname =\n-    scoped scope fname_local'\n-    where\n-    fname_local = nameLocalStr fname\n-    fname_local' = \"__debug_\" ++ show rlidx ++ \"_\" ++ show rhsidx ++ \"_\" ++ fname_local\n-    scope = nameScope fname\n-\n--- For RHSAggregate, the aggregate function is prepended with\n--- __debug_<rule_idx>_<rhs_idx>.\n--- The input to the aggregate function is transformed into a tuple of\n--- input to the aggregate operator and the original value.\n--- The return variable is also prepended with __inputs_, which will now be\n--- a tuple.\n--- The corresponding compiler-generated function also outputs the set of\n--- inputs, so that it is visible to the inspect operator.\n--- an RHSCondition is also appended that declares and sets the original\n--- return variable of the pre-updated aggregate operator.\n--- updateRHSAggregate returns a list of RuleRHS and original index of the RuleRHS.\n--- Since aggregate function get converted into two terms, the original index is\n--- returned, so that the debug inspect operator can use the operator id based on\n--- the original index and the debugger tool can simply correlate the events\n--- to the original source.\n-updateRHSAggregate :: DatalogProgram -> Rule -> Int -> Int -> [(RuleRHS, Int)]\n-updateRHSAggregate d rule rlidx rhsidx =\n+-- Transform RHSGroupBy to output a vector of input records in addition to the\n+-- user-defined group by rewriting:\n+-- 'var g = e.group_by(v1,v2)'\n+-- as\n+-- 'var __debug_g = (e, r).group_by(v1,v2),\n+--  (var input, var g) = debug_split_group(__debug_g),'\n+updateRHSGroupBy :: DatalogProgram -> Rule -> Int -> [(RuleRHS, Int)]\n+updateRHSGroupBy d rule rhsidx =\n   let\n      r = (ruleRHS rule) !! rhsidx\n-     aggVar = AggregateVar rule rhsidx\n-     funcName = debugAggregateFunctionName rlidx rhsidx (rhsAggFunc r)\n-     varRet = \"__inputs_\" ++ (rhsVar r)\n-     input = eTuple [ (Compile.recordAfterPrefix d rule (rhsidx - 1)) !! 0\n-                    , rhsAggExpr r ]\n-     rAgg = RHSAggregate { rhsVar     = varRet,\n-                           rhsGroupBy = rhsGroupBy r,\n-                           rhsAggFunc = funcName,\n-                           rhsAggExpr = input }\n-     rCond = RHSCondition { rhsExpr = eSet (eVarDecl (rhsVar r) (varType d aggVar)) (eTupField (eVar varRet) 1) }\n+     aggVar = GroupVar rule rhsidx\n+     group_var = \"__debug_\" ++ rhsVar r\n+     input1 = head $ Compile.recordAfterPrefix d rule (rhsidx - 1)\n+     input = eTuple [ input1, rhsProject r ]\n+     rAgg = RHSGroupBy { rhsVar     = group_var\n+                       , rhsProject = input\n+                       , rhsGroupBy = rhsGroupBy r\n+                       }\n+     tinputs = tOpaque (mOD_STD ++ \"::Vec\") [exprType d (CtxRuleRProject rule rhsidx) input1]\n+     rCond = RHSCondition { rhsExpr = eSet (eTuple [eVarDecl \"__inputs\" tinputs, eVarDecl (rhsVar r) (varType d aggVar)])", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4330d1ccfe875f8bac7ce541939f766fafcf28fa"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc2MTUxNA==", "bodyText": "the fact that the next piece of code is no longer special is a good sign", "url": "https://github.com/vmware/differential-datalog/pull/780#discussion_r508761514", "createdAt": "2020-10-20T18:47:22Z", "author": {"login": "mbudiu-vmw"}, "path": "src/Language/DifferentialDatalog/Debug.hs", "diffHunk": "@@ -194,60 +174,7 @@ debugUpdateRHSRules :: DatalogProgram -> Int -> Rule -> [RuleRHS]\n debugUpdateRHSRules d rlIdx rule =\n   let\n     -- First pass updates RHSLiteral without any binding with a binding.\n-    rhs =  map addBindingToRHSLiteral $ zip (ruleRHS rule) [0..]\n-    -- Second pass updates RHSAggregate to use the debug function (so that inputs are not dropped).\n-    (rhs', preRhsIdxs) = unzip $ concatMap (updateRHSAggregate d rule{ruleRHS = rhs} rlIdx) [0..length rhs - 1]\n+    rhs = map addBindingToRHSLiteral $ zip (ruleRHS rule) [0..]\n+    -- Second pass updates RHSGroupBy to include inputs in the group.\n+    (rhs', preRhsIdxs) = unzip $ concatMap (updateRHSGroupBy d rule{ruleRHS = rhs}) [0..length rhs - 1]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4330d1ccfe875f8bac7ce541939f766fafcf28fa"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc2OTMyMw==", "bodyText": "why is this name really fresh?", "url": "https://github.com/vmware/differential-datalog/pull/780#discussion_r508769323", "createdAt": "2020-10-20T19:00:50Z", "author": {"login": "mbudiu-vmw"}, "path": "src/Language/DifferentialDatalog/Parse.hs", "diffHunk": "@@ -408,20 +411,66 @@ apply = Apply nopos <$  reserved \"apply\" <*> transIdent\n \n rule = Rule nopos <$>\n        (commaSep1 $ atom True) <*>\n-       (option [] (reservedOp \":-\" *> commaSep rulerhs)) <* dot\n-\n-rulerhs =  do _ <- try $ lookAhead $ (optional $ reserved \"not\") *> (optional $ try $ varIdent <* reserved \"in\") *> (optional $ reservedOp \"&\") *> relIdent *> (symbol \"(\" <|> symbol \"[\")\n-              RHSLiteral <$> (option True (False <$ reserved \"not\")) <*> atom False\n-       <|> do _ <- try $ lookAhead $ reserved \"var\" *> varIdent *> reservedOp \"=\" *> reserved \"Aggregate\"\n-              RHSAggregate <$> (reserved \"var\" *> varIdent) <*>\n-                               (reservedOp \"=\" *> reserved \"Aggregate\" *> symbol \"(\" *> group_by_expr) <*>\n-                               (comma *> funcIdent) <*>\n-                               (parens expr <* symbol \")\")\n-       <|> do _ <- try $ lookAhead $ reserved \"var\" *> varIdent *> reservedOp \"=\" *> reserved \"FlatMap\"\n-              RHSFlatMap <$> (reserved \"var\" *> varIdent) <*>\n-                             (reservedOp \"=\" *> reserved \"FlatMap\" *> parens expr)\n-       <|> (RHSInspect <$ reserved \"Inspect\" <*> expr)\n-       <|> (RHSCondition <$> expr)\n+       (option [] (reservedOp \":-\" *> (concat <$> commaSep rulerhs))) <* dot\n+\n+rulerhs :: ParsecT String () Identity [RuleRHS]\n+rulerhs =  (do _ <- try $ lookAhead $ (optional $ reserved \"not\") *> (optional $ try $ varIdent <* reserved \"in\") *> (optional $ reservedOp \"&\") *> relIdent *> (symbol \"(\" <|> symbol \"[\")\n+               (\\x -> [x]) <$> (RHSLiteral <$> (option True (False <$ reserved \"not\")) <*> atom False))\n+          <|> aggregate\n+          <|> do _ <- try $ lookAhead $ reserved \"var\" *> varIdent *> reservedOp \"=\" *> reserved \"FlatMap\"\n+                 (\\x -> [x]) <$> (RHSFlatMap <$> (reserved \"var\" *> varIdent) <*>\n+                                                 (reservedOp \"=\" *> reserved \"FlatMap\" *> parens expr))\n+          <|> (((\\x -> [x]) . RHSInspect) <$ reserved \"Inspect\" <*> expr)\n+          <|> rhsCondition\n+\n+-- If expression contains any group-by subexpressions, transform them into\n+-- separate RHSGroupBy clauses and replace them with fresh variables, e.g.:\n+-- 'var c = (x,y).group_by(z).count()'\n+-- becomes\n+-- 'var __group = (x,y).group_by(z),\n+--  var c = __group.count()'\n+rhsCondition = do\n+    e <- expr\n+    case ST.runState (runExceptT $ exprFoldM extractGroupBy e) Nothing of\n+         (Left emsg, _)       -> errorWithoutStackTrace emsg\n+         (Right e', group_by) ->\n+               case e' of\n+                    E (ESet _ (E (EVarDecl _ gvar1)) (E (EVar _ gvar2))) | gvar1 == \"__group\" && gvar1 == gvar2\n+                                                                         -> return $ maybeToList group_by\n+                    _ -> return $ (maybeToList group_by) ++ [RHSCondition e']\n+\n+extractGroupBy (EApply p (E (EFunc _ [f])) args) | f == \"group_by\" = do\n+    checkNoProg (length args == 2) p\n+                $ \"The 'group_by' operator must be invoked with two arguments, e.g., 'expr1.group_by(expr2)' or 'group_by(expr1, expr2)',\" ++\n+                  \" but it is invoked with \" ++ show (length args)\n+    let [project, group_by] = args\n+    previous_groupby_clause <- ST.get\n+    checkNoProg (isNothing previous_groupby_clause) p\n+                $ \"'group_by' operator can occur at most once in an expression. Previous occurrence: \" ++\n+                  show (pos $ rhsGroupBy $ fromJust previous_groupby_clause)\n+    ST.put $ Just $ RHSGroupBy \"__group\" project group_by\n+    return $ E $ EVar p \"__group\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4330d1ccfe875f8bac7ce541939f766fafcf28fa"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc2OTczNQ==", "bodyText": "can you add a TODO here to add a warning when we have them?", "url": "https://github.com/vmware/differential-datalog/pull/780#discussion_r508769735", "createdAt": "2020-10-20T19:01:32Z", "author": {"login": "mbudiu-vmw"}, "path": "src/Language/DifferentialDatalog/Parse.hs", "diffHunk": "@@ -408,20 +411,66 @@ apply = Apply nopos <$  reserved \"apply\" <*> transIdent\n \n rule = Rule nopos <$>\n        (commaSep1 $ atom True) <*>\n-       (option [] (reservedOp \":-\" *> commaSep rulerhs)) <* dot\n-\n-rulerhs =  do _ <- try $ lookAhead $ (optional $ reserved \"not\") *> (optional $ try $ varIdent <* reserved \"in\") *> (optional $ reservedOp \"&\") *> relIdent *> (symbol \"(\" <|> symbol \"[\")\n-              RHSLiteral <$> (option True (False <$ reserved \"not\")) <*> atom False\n-       <|> do _ <- try $ lookAhead $ reserved \"var\" *> varIdent *> reservedOp \"=\" *> reserved \"Aggregate\"\n-              RHSAggregate <$> (reserved \"var\" *> varIdent) <*>\n-                               (reservedOp \"=\" *> reserved \"Aggregate\" *> symbol \"(\" *> group_by_expr) <*>\n-                               (comma *> funcIdent) <*>\n-                               (parens expr <* symbol \")\")\n-       <|> do _ <- try $ lookAhead $ reserved \"var\" *> varIdent *> reservedOp \"=\" *> reserved \"FlatMap\"\n-              RHSFlatMap <$> (reserved \"var\" *> varIdent) <*>\n-                             (reservedOp \"=\" *> reserved \"FlatMap\" *> parens expr)\n-       <|> (RHSInspect <$ reserved \"Inspect\" <*> expr)\n-       <|> (RHSCondition <$> expr)\n+       (option [] (reservedOp \":-\" *> (concat <$> commaSep rulerhs))) <* dot\n+\n+rulerhs :: ParsecT String () Identity [RuleRHS]\n+rulerhs =  (do _ <- try $ lookAhead $ (optional $ reserved \"not\") *> (optional $ try $ varIdent <* reserved \"in\") *> (optional $ reservedOp \"&\") *> relIdent *> (symbol \"(\" <|> symbol \"[\")\n+               (\\x -> [x]) <$> (RHSLiteral <$> (option True (False <$ reserved \"not\")) <*> atom False))\n+          <|> aggregate\n+          <|> do _ <- try $ lookAhead $ reserved \"var\" *> varIdent *> reservedOp \"=\" *> reserved \"FlatMap\"\n+                 (\\x -> [x]) <$> (RHSFlatMap <$> (reserved \"var\" *> varIdent) <*>\n+                                                 (reservedOp \"=\" *> reserved \"FlatMap\" *> parens expr))\n+          <|> (((\\x -> [x]) . RHSInspect) <$ reserved \"Inspect\" <*> expr)\n+          <|> rhsCondition\n+\n+-- If expression contains any group-by subexpressions, transform them into\n+-- separate RHSGroupBy clauses and replace them with fresh variables, e.g.:\n+-- 'var c = (x,y).group_by(z).count()'\n+-- becomes\n+-- 'var __group = (x,y).group_by(z),\n+--  var c = __group.count()'\n+rhsCondition = do\n+    e <- expr\n+    case ST.runState (runExceptT $ exprFoldM extractGroupBy e) Nothing of\n+         (Left emsg, _)       -> errorWithoutStackTrace emsg\n+         (Right e', group_by) ->\n+               case e' of\n+                    E (ESet _ (E (EVarDecl _ gvar1)) (E (EVar _ gvar2))) | gvar1 == \"__group\" && gvar1 == gvar2\n+                                                                         -> return $ maybeToList group_by\n+                    _ -> return $ (maybeToList group_by) ++ [RHSCondition e']\n+\n+extractGroupBy (EApply p (E (EFunc _ [f])) args) | f == \"group_by\" = do\n+    checkNoProg (length args == 2) p\n+                $ \"The 'group_by' operator must be invoked with two arguments, e.g., 'expr1.group_by(expr2)' or 'group_by(expr1, expr2)',\" ++\n+                  \" but it is invoked with \" ++ show (length args)\n+    let [project, group_by] = args\n+    previous_groupby_clause <- ST.get\n+    checkNoProg (isNothing previous_groupby_clause) p\n+                $ \"'group_by' operator can occur at most once in an expression. Previous occurrence: \" ++\n+                  show (pos $ rhsGroupBy $ fromJust previous_groupby_clause)\n+    ST.put $ Just $ RHSGroupBy \"__group\" project group_by\n+    return $ E $ EVar p \"__group\"\n+extractGroupBy e  = return $ E e\n+\n+-- Deprecated Aggregate syntax.\n+aggregate = do", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4330d1ccfe875f8bac7ce541939f766fafcf28fa"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc3MDYwNw==", "bodyText": "is this then a good name?", "url": "https://github.com/vmware/differential-datalog/pull/780#discussion_r508770607", "createdAt": "2020-10-20T19:03:07Z", "author": {"login": "mbudiu-vmw"}, "path": "src/Language/DifferentialDatalog/Syntax.hs", "diffHunk": "@@ -590,8 +590,32 @@ instance Show Atom where\n -- positive/negative polarity, Boolean conditions, aggregation,\n -- disaggregation (flatmap), inspect operations.\n data RuleRHS = RHSLiteral   {rhsPolarity :: Bool, rhsAtom :: Atom}\n-             | RHSCondition {rhsExpr :: Expr}\n-             | RHSAggregate {rhsVar :: String, rhsGroupBy :: Expr, rhsAggFunc :: String, rhsAggExpr :: Expr}\n+               -- Expression that can filter or map input collation, or both:\n+               -- * Filtering: `x == y`\n+               -- * Mapping: `var x = f(y)`\n+               -- * Filter/map: `Some{x} = f(y)`\n+             | RHSCondition {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4330d1ccfe875f8bac7ce541939f766fafcf28fa"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc3NDYzMw==", "bodyText": "this is  a weird example.", "url": "https://github.com/vmware/differential-datalog/pull/780#discussion_r508774633", "createdAt": "2020-10-20T19:10:17Z", "author": {"login": "mbudiu-vmw"}, "path": "test/datalog_tests/group_test.dl", "diffHunk": "@@ -0,0 +1,112 @@\n+import group\n+import vec\n+\n+/* Some data to group and aggregate. */\n+input relation Data(x: usize, y: Vec<string>, z: Vec<bigint>, q: string)\n+\n+// map\n+output relation Map1(key: Vec<string>, val: Vec<string>)\n+\n+Map1(y, val) :-\n+    Data(x, y, z, q),\n+    var val = (z,q).group_by(y).map(|zq| zq.1 ++ \": \" ++ zq.0.map(to_string).join(\",\")).\n+\n+output relation Map2(key: Vec<string>, val: Vec<string>)\n+\n+// As above, but store the group in a variable and aggregate it later in the rule.\n+Map1(y, val) :-\n+    Data(x, y, z, q),\n+    var group = (z,q).group_by(y),\n+    // a no-op join to make sure that `group` ends up stored in an intermediate\n+    // relation.\n+    Data(.y = y),\n+    var val = group.map(|zq| zq.1 ++ \":: \" ++ zq.0.map(to_string).join(\",\")).\n+\n+// As above, but this time introduce an explicit relation for the group.\n+relation Group1(g: Group<Vec<string>, (Vec<bigint>, string)>)\n+\n+Group1(group) :-\n+    Data(x, y, z, q),\n+    var group = (z,q).group_by(y).\n+\n+Map1(group.key(),\n+     group.map(|zq| zq.1 ++ \"::: \" ++ zq.0.map(to_string).join(\",\"))) :-\n+    Group1(group).\n+\n+// flatmap\n+output relation FlatMap1(key: Vec<string>, val: Vec<string>)\n+\n+FlatMap1(y, val) :-\n+    Data(x, y, z, q),\n+    var val = (z,q).group_by(y).flatmap(|zq| zq.0.map(to_string).push_imm(zq.1)).\n+\n+// argmin\n+output relation ArgMin1(key: (Vec<string>, usize), val: (Vec<bigint>, string))\n+\n+ArgMin1((y,x), min_val) :-\n+    Data(x,y,z,q),\n+    var min_val = (z,q).group_by((y,x)).arg_min(|zq| zq.0.nth(0).unwrap_or_default()).\n+\n+// argmax\n+output relation ArgMax1(key: (Vec<string>, usize), val: (Vec<bigint>, string))\n+\n+ArgMax1((y,x), max_val) :-\n+    Data(x,y,z,q),\n+    var max_val = (z,q).group_by((y,x)).arg_max(|zq| zq.0.nth(0).unwrap_or_default()).\n+\n+// find\n+output relation Find1(val: Data)\n+\n+Find1(finding) :-\n+    d in Data(),\n+    Some{var finding} = d.group_by(()).find(|d| d.z.nth(1).unwrap_or_default() == 3).\n+\n+// no matches\n+Find1(finding) :-\n+    d in Data(),\n+    var g = d.group_by(()),\n+    Some{var finding} = g.find(|d| d.z.nth(1).unwrap_or_default() == 5).\n+\n+// filter\n+output relation Filter1(val: Vec<Data>)\n+\n+Filter1(g.filter(|d| d.z.len() == 3)) :-\n+    d in Data(),\n+    var g = d.group_by(()),\n+    d in Data().", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4330d1ccfe875f8bac7ce541939f766fafcf28fa"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc3Njk1NA==", "bodyText": "Do you want to capture the comma in the source position of this expression?", "url": "https://github.com/vmware/differential-datalog/pull/780#discussion_r508776954", "createdAt": "2020-10-20T19:14:42Z", "author": {"login": "mbudiu-vmw"}, "path": "test/datalog_tests/rules.fail.ast.expected", "diffHunk": "@@ -11,24 +11,36 @@ error: ./test/datalog_tests/rules.fail.dl:10:1-11:1: Relation R3 is mutually rec\n R2(x) :- R1(x), not R3(x, \"foo\").\n ^\n \n-error: ./test/datalog_tests/rules.fail.dl:9:23-9:28: Type mismatch:\n-expected type: string\n-actual type: (string,string)\n+error: ./test/datalog_tests/rules.fail.dl:9:28-9:39: Type mismatch:\n+expected type: (string,string)\n+actual type: string\n+in\n+expected type: ddlog_std::Group<(string,string),string>\n+actual type: ddlog_std::Group<string,string>\n+in\n+expected type: function( ddlog_std::Group<(string,string),string>):string\n+actual type: function( ddlog_std::Group<string,string>):string\n in\n-expression '(x, z)'\n+expression 'concat_ys'\n     var s = Aggregate((x,z), concat_ys(y)).\n-                      ^^^^^\n+                           ^^^^^^^^^^^", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4330d1ccfe875f8bac7ce541939f766fafcf28fa"}, "originalPosition": 21}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "65facd7e9ce7e865c3d1bd2ab18e7bd130a512ae", "author": {"user": {"login": "ryzhyk", "name": "Leonid Ryzhyk"}}, "url": "https://github.com/vmware/differential-datalog/commit/65facd7e9ce7e865c3d1bd2ab18e7bd130a512ae", "committedDate": "2020-10-21T00:25:12Z", "message": "Prevent name clashes in Rust.\n\nPrevent potential name clash in Index and Relation enum\nconversion to int.  The problem occurred in programs that\nhappened to contain a relation or index named `Error`."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "00176a81204177e0db2242e6e931d22b2607a00c", "author": {"user": {"login": "ryzhyk", "name": "Leonid Ryzhyk"}}, "url": "https://github.com/vmware/differential-datalog/commit/00176a81204177e0db2242e6e931d22b2607a00c", "committedDate": "2020-10-21T00:56:08Z", "message": "Poor type error reporting in FlatMap.\n\nWe used to report actual type of the FlatMap result as expected type,\nmaking type errors hard to understand.\n\nOne remaining issue related to FlatMap is that we incorrectly report the\nsource code location of the FlatMap variable since we don't store its actual\nlocation.  This will be fixed once we change FlatMap syntax to have an\nexpression, not just variable, in the left-hand side."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3f4eacf046ef49b529f834e432a753f3427db85f", "author": {"user": {"login": "ryzhyk", "name": "Leonid Ryzhyk"}}, "url": "https://github.com/vmware/differential-datalog/commit/3f4eacf046ef49b529f834e432a753f3427db85f", "committedDate": "2020-10-21T01:07:17Z", "message": "Review comments."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4413, "cost": 1, "resetAt": "2021-11-02T10:47:05Z"}}}