{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDcxNDI4Mzc5", "number": 744, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxOToyMDoyMVrOEbFN5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxOToyNToxOFrOEbFXRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2ODMyNDg1OnYy", "diffSide": "RIGHT", "path": "test/datalog_tests/rust_api_test/src/main.rs", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxOToyMDoyMVrOHE4vhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxOToyMDoyMVrOHE4vhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDg4NjAyMQ==", "bodyText": "\"in execution\"", "url": "https://github.com/vmware/differential-datalog/pull/744#discussion_r474886021", "createdAt": "2020-08-21T19:20:21Z", "author": {"login": "mbudiu-vmw"}, "path": "test/datalog_tests/rust_api_test/src/main.rs", "diffHunk": "@@ -0,0 +1,172 @@\n+use std::borrow::Cow;\n+\n+// The main auto-generated crate `<progname>_ddlog` declares\n+// `HDDlog` type that serves as a reference to a running DDlog program.\n+// `HDDlog` implements `trait differential_datalog::DDlog` (see below).\n+use tutorial_ddlog::api::HDDlog;\n+\n+// The differential_datalog crate contains the DDlog runtime that is\n+// the same for all DDlog programs and simply gets copied to each generated\n+// DDlog workspace unmodified (this will change in future releases).\n+use differential_datalog::DDlog; // Trait that must be implemented by an instance of a DDlog program.\n+use differential_datalog::DeltaMap; // Type that represents a set of changes to DDlog relations.\n+                                    // Returned by `DDlog::transaction_commit_dump_changes()`.\n+use differential_datalog::ddval::DDValue; // Generic type that wraps all DDlog value.\n+use differential_datalog::ddval::DDValConvert; // Trait to convert Rust types to/from DDValue.\n+                                               // All types in the `value::Value` module (see below)\n+                                               // implement this trait.\n+use differential_datalog::program::RelId; // Numeric relations id.\n+use differential_datalog::program::Update; // Type-safe representation of a DDlog command (insert/delete_val/delete_key/...)\n+\n+// The `record` module defines dynamically typed representation of DDlog values and commands.\n+use differential_datalog::record::Record; // Dynamically typed representation of DDlog values.\n+use differential_datalog::record::RelIdentifier; // Relation identifier: either `RelId` or `Cow<str>`g.\n+use differential_datalog::record::UpdCmd; // Dynamically typed representation of DDlog command.\n+\n+// The auto-generated `types` crate contains Rust types that correspond to user-defined DDlog\n+// types, one for each typedef and each relation in the DDlog program.\n+use types::*;\n+\n+// The auto-generated `value` crate contains\n+// * The `Value` model that define a wrapper type for each input and\n+//   output relation in the DDlog program, as well as\n+// * `enum Relations` that enumerates program relations\n+// * Several functions that convert between numeric relation id's and\n+//   symbolic names.\n+use value::relid2name;\n+use value::Relations;\n+use value::Value;\n+\n+fn main() -> Result<(), String> {\n+\n+    fn cb(_rel: usize, _rec: &Record, _w: isize) {}\n+\n+    // Instantiate a DDlog program.\n+    // Returns a handle to the program and initial contents of output relations.\n+    // Arguments\n+    // - number of worker threads (you typically want 1 or 2).\n+    // - Boolean flag that indicates whether DDlog will track the complete snapshot\n+    //   of output relations.  Should only be used if you plan to dump `dump_table`\n+    //   their contents using `HDDlog::dump_table()`.\n+    // - Callback - obsolete and will disappear in future releases.\n+    let (mut hddlog, init_state) = HDDlog::run(1, false, cb)?;\n+\n+    println!(\"Initial state\");\n+    dump_delta(&init_state);\n+\n+    /*\n+     * We perform two transactions that insert in the following two DDlog relations\n+     * (see `tutorial.dl`):\n+     *\n+     * ```\n+     * input relation Word1(word: string, cat: Category)\n+     * input relation Word2(word: string, cat: Category)\n+     * ```\n+     *\n+     * The first transactio uses the type-safe API, which should be preferred when\n+     * writing a client bound to a specific known DDlog program.\n+     *\n+     * The second transaction uses the dynamically typed record API.\n+     */\n+\n+    // There can be at most one transaction at a time.  Attempt to start anothe transaction", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68405e13637262bb6268d306556ead63063f413e"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2ODMzMDk1OnYy", "diffSide": "RIGHT", "path": "test/datalog_tests/rust_api_test/src/main.rs", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxOToyMTozOVrOHE4zjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxOToyMTozOVrOHE4zjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDg4NzA1NA==", "bodyText": "how about a clear reference to the dl program that is being invoked by this rust program?\nInsert here the path to tutorial.dl", "url": "https://github.com/vmware/differential-datalog/pull/744#discussion_r474887054", "createdAt": "2020-08-21T19:21:39Z", "author": {"login": "mbudiu-vmw"}, "path": "test/datalog_tests/rust_api_test/src/main.rs", "diffHunk": "@@ -0,0 +1,172 @@\n+use std::borrow::Cow;\n+\n+// The main auto-generated crate `<progname>_ddlog` declares", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68405e13637262bb6268d306556ead63063f413e"}, "originalPosition": 3}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2ODMzMjg3OnYy", "diffSide": "RIGHT", "path": "test/datalog_tests/rust_api_test/src/main.rs", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxOToyMjowMlrOHE40yw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxOToyMjowMlrOHE40yw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDg4NzM3MQ==", "bodyText": "implements", "url": "https://github.com/vmware/differential-datalog/pull/744#discussion_r474887371", "createdAt": "2020-08-21T19:22:02Z", "author": {"login": "mbudiu-vmw"}, "path": "test/datalog_tests/rust_api_test/src/main.rs", "diffHunk": "@@ -0,0 +1,172 @@\n+use std::borrow::Cow;\n+\n+// The main auto-generated crate `<progname>_ddlog` declares\n+// `HDDlog` type that serves as a reference to a running DDlog program.\n+// `HDDlog` implements `trait differential_datalog::DDlog` (see below).\n+use tutorial_ddlog::api::HDDlog;\n+\n+// The differential_datalog crate contains the DDlog runtime that is\n+// the same for all DDlog programs and simply gets copied to each generated\n+// DDlog workspace unmodified (this will change in future releases).\n+use differential_datalog::DDlog; // Trait that must be implemented by an instance of a DDlog program.\n+use differential_datalog::DeltaMap; // Type that represents a set of changes to DDlog relations.\n+                                    // Returned by `DDlog::transaction_commit_dump_changes()`.\n+use differential_datalog::ddval::DDValue; // Generic type that wraps all DDlog value.\n+use differential_datalog::ddval::DDValConvert; // Trait to convert Rust types to/from DDValue.\n+                                               // All types in the `value::Value` module (see below)\n+                                               // implement this trait.\n+use differential_datalog::program::RelId; // Numeric relations id.\n+use differential_datalog::program::Update; // Type-safe representation of a DDlog command (insert/delete_val/delete_key/...)\n+\n+// The `record` module defines dynamically typed representation of DDlog values and commands.\n+use differential_datalog::record::Record; // Dynamically typed representation of DDlog values.\n+use differential_datalog::record::RelIdentifier; // Relation identifier: either `RelId` or `Cow<str>`g.\n+use differential_datalog::record::UpdCmd; // Dynamically typed representation of DDlog command.\n+\n+// The auto-generated `types` crate contains Rust types that correspond to user-defined DDlog\n+// types, one for each typedef and each relation in the DDlog program.\n+use types::*;\n+\n+// The auto-generated `value` crate contains\n+// * The `Value` model that define a wrapper type for each input and\n+//   output relation in the DDlog program, as well as\n+// * `enum Relations` that enumerates program relations\n+// * Several functions that convert between numeric relation id's and\n+//   symbolic names.\n+use value::relid2name;\n+use value::Relations;\n+use value::Value;\n+\n+fn main() -> Result<(), String> {\n+\n+    fn cb(_rel: usize, _rec: &Record, _w: isize) {}\n+\n+    // Instantiate a DDlog program.\n+    // Returns a handle to the program and initial contents of output relations.\n+    // Arguments\n+    // - number of worker threads (you typically want 1 or 2).\n+    // - Boolean flag that indicates whether DDlog will track the complete snapshot\n+    //   of output relations.  Should only be used if you plan to dump `dump_table`\n+    //   their contents using `HDDlog::dump_table()`.\n+    // - Callback - obsolete and will disappear in future releases.\n+    let (mut hddlog, init_state) = HDDlog::run(1, false, cb)?;\n+\n+    println!(\"Initial state\");\n+    dump_delta(&init_state);\n+\n+    /*\n+     * We perform two transactions that insert in the following two DDlog relations\n+     * (see `tutorial.dl`):\n+     *\n+     * ```\n+     * input relation Word1(word: string, cat: Category)\n+     * input relation Word2(word: string, cat: Category)\n+     * ```\n+     *\n+     * The first transactio uses the type-safe API, which should be preferred when\n+     * writing a client bound to a specific known DDlog program.\n+     *\n+     * The second transaction uses the dynamically typed record API.\n+     */\n+\n+    // There can be at most one transaction at a time.  Attempt to start anothe transaction\n+    // when there is one in progress will return an error.\n+    hddlog.transaction_start()?;\n+\n+    // A transaction can consist of multiple `apply_valupdates()` calls, each taking\n+    // multiple updates.  An update inserts, deletes or modifies a record in a DDlog\n+    // relation.\n+    let updates = vec![\n+        Update::Insert { // We are going to insert..\n+            relid: Relations::Word1 as RelId, // .. into relation with this Id.\n+            // `Word1` type, declared in the `types` crate has the same fields as\n+            // the corresponding DDlog type.\n+            // `Value::Word1` from the `value` crate is a wrapper around this type\n+            // that implement `into_ddvalue()`", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68405e13637262bb6268d306556ead63063f413e"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2ODMzNDU0OnYy", "diffSide": "RIGHT", "path": "test/datalog_tests/rust_api_test/src/main.rs", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxOToyMjoyNlrOHE419A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxOToyMjoyNlrOHE419A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDg4NzY2OA==", "bodyText": "some comment on the errors that could occur?", "url": "https://github.com/vmware/differential-datalog/pull/744#discussion_r474887668", "createdAt": "2020-08-21T19:22:26Z", "author": {"login": "mbudiu-vmw"}, "path": "test/datalog_tests/rust_api_test/src/main.rs", "diffHunk": "@@ -0,0 +1,172 @@\n+use std::borrow::Cow;\n+\n+// The main auto-generated crate `<progname>_ddlog` declares\n+// `HDDlog` type that serves as a reference to a running DDlog program.\n+// `HDDlog` implements `trait differential_datalog::DDlog` (see below).\n+use tutorial_ddlog::api::HDDlog;\n+\n+// The differential_datalog crate contains the DDlog runtime that is\n+// the same for all DDlog programs and simply gets copied to each generated\n+// DDlog workspace unmodified (this will change in future releases).\n+use differential_datalog::DDlog; // Trait that must be implemented by an instance of a DDlog program.\n+use differential_datalog::DeltaMap; // Type that represents a set of changes to DDlog relations.\n+                                    // Returned by `DDlog::transaction_commit_dump_changes()`.\n+use differential_datalog::ddval::DDValue; // Generic type that wraps all DDlog value.\n+use differential_datalog::ddval::DDValConvert; // Trait to convert Rust types to/from DDValue.\n+                                               // All types in the `value::Value` module (see below)\n+                                               // implement this trait.\n+use differential_datalog::program::RelId; // Numeric relations id.\n+use differential_datalog::program::Update; // Type-safe representation of a DDlog command (insert/delete_val/delete_key/...)\n+\n+// The `record` module defines dynamically typed representation of DDlog values and commands.\n+use differential_datalog::record::Record; // Dynamically typed representation of DDlog values.\n+use differential_datalog::record::RelIdentifier; // Relation identifier: either `RelId` or `Cow<str>`g.\n+use differential_datalog::record::UpdCmd; // Dynamically typed representation of DDlog command.\n+\n+// The auto-generated `types` crate contains Rust types that correspond to user-defined DDlog\n+// types, one for each typedef and each relation in the DDlog program.\n+use types::*;\n+\n+// The auto-generated `value` crate contains\n+// * The `Value` model that define a wrapper type for each input and\n+//   output relation in the DDlog program, as well as\n+// * `enum Relations` that enumerates program relations\n+// * Several functions that convert between numeric relation id's and\n+//   symbolic names.\n+use value::relid2name;\n+use value::Relations;\n+use value::Value;\n+\n+fn main() -> Result<(), String> {\n+\n+    fn cb(_rel: usize, _rec: &Record, _w: isize) {}\n+\n+    // Instantiate a DDlog program.\n+    // Returns a handle to the program and initial contents of output relations.\n+    // Arguments\n+    // - number of worker threads (you typically want 1 or 2).\n+    // - Boolean flag that indicates whether DDlog will track the complete snapshot\n+    //   of output relations.  Should only be used if you plan to dump `dump_table`\n+    //   their contents using `HDDlog::dump_table()`.\n+    // - Callback - obsolete and will disappear in future releases.\n+    let (mut hddlog, init_state) = HDDlog::run(1, false, cb)?;\n+\n+    println!(\"Initial state\");\n+    dump_delta(&init_state);\n+\n+    /*\n+     * We perform two transactions that insert in the following two DDlog relations\n+     * (see `tutorial.dl`):\n+     *\n+     * ```\n+     * input relation Word1(word: string, cat: Category)\n+     * input relation Word2(word: string, cat: Category)\n+     * ```\n+     *\n+     * The first transactio uses the type-safe API, which should be preferred when\n+     * writing a client bound to a specific known DDlog program.\n+     *\n+     * The second transaction uses the dynamically typed record API.\n+     */\n+\n+    // There can be at most one transaction at a time.  Attempt to start anothe transaction\n+    // when there is one in progress will return an error.\n+    hddlog.transaction_start()?;\n+\n+    // A transaction can consist of multiple `apply_valupdates()` calls, each taking\n+    // multiple updates.  An update inserts, deletes or modifies a record in a DDlog\n+    // relation.\n+    let updates = vec![\n+        Update::Insert { // We are going to insert..\n+            relid: Relations::Word1 as RelId, // .. into relation with this Id.\n+            // `Word1` type, declared in the `types` crate has the same fields as\n+            // the corresponding DDlog type.\n+            // `Value::Word1` from the `value` crate is a wrapper around this type\n+            // that implement `into_ddvalue()`\n+            v: Value::Word1(Word1 {\n+                word: \"foo-\".to_string(),\n+                cat: Category::CategoryOther,\n+            })\n+            .into_ddvalue(),\n+        },\n+        Update::Insert {\n+            relid: Relations::Word2 as RelId,\n+            v: Value::Word2(Word2 {\n+                word: \"bar\".to_string(),\n+                cat: Category::CategoryOther,\n+            })\n+            .into_ddvalue(),\n+        },\n+    ];\n+    hddlog.apply_valupdates(updates.into_iter())?;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68405e13637262bb6268d306556ead63063f413e"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2ODM0ODg0OnYy", "diffSide": "RIGHT", "path": "test/datalog_tests/rust_api_test/src/main.rs", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxOToyNToxOFrOHE4_EQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQyMzozNTo0MFrOHFAXsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDg5MDAwMQ==", "bodyText": "This is a pity. Is there a dynamically safe version? One would imagine that you can generate one. Perhaps val can have a set of generated methods?", "url": "https://github.com/vmware/differential-datalog/pull/744#discussion_r474890001", "createdAt": "2020-08-21T19:25:18Z", "author": {"login": "mbudiu-vmw"}, "path": "test/datalog_tests/rust_api_test/src/main.rs", "diffHunk": "@@ -0,0 +1,172 @@\n+use std::borrow::Cow;\n+\n+// The main auto-generated crate `<progname>_ddlog` declares\n+// `HDDlog` type that serves as a reference to a running DDlog program.\n+// `HDDlog` implements `trait differential_datalog::DDlog` (see below).\n+use tutorial_ddlog::api::HDDlog;\n+\n+// The differential_datalog crate contains the DDlog runtime that is\n+// the same for all DDlog programs and simply gets copied to each generated\n+// DDlog workspace unmodified (this will change in future releases).\n+use differential_datalog::DDlog; // Trait that must be implemented by an instance of a DDlog program.\n+use differential_datalog::DeltaMap; // Type that represents a set of changes to DDlog relations.\n+                                    // Returned by `DDlog::transaction_commit_dump_changes()`.\n+use differential_datalog::ddval::DDValue; // Generic type that wraps all DDlog value.\n+use differential_datalog::ddval::DDValConvert; // Trait to convert Rust types to/from DDValue.\n+                                               // All types in the `value::Value` module (see below)\n+                                               // implement this trait.\n+use differential_datalog::program::RelId; // Numeric relations id.\n+use differential_datalog::program::Update; // Type-safe representation of a DDlog command (insert/delete_val/delete_key/...)\n+\n+// The `record` module defines dynamically typed representation of DDlog values and commands.\n+use differential_datalog::record::Record; // Dynamically typed representation of DDlog values.\n+use differential_datalog::record::RelIdentifier; // Relation identifier: either `RelId` or `Cow<str>`g.\n+use differential_datalog::record::UpdCmd; // Dynamically typed representation of DDlog command.\n+\n+// The auto-generated `types` crate contains Rust types that correspond to user-defined DDlog\n+// types, one for each typedef and each relation in the DDlog program.\n+use types::*;\n+\n+// The auto-generated `value` crate contains\n+// * The `Value` model that define a wrapper type for each input and\n+//   output relation in the DDlog program, as well as\n+// * `enum Relations` that enumerates program relations\n+// * Several functions that convert between numeric relation id's and\n+//   symbolic names.\n+use value::relid2name;\n+use value::Relations;\n+use value::Value;\n+\n+fn main() -> Result<(), String> {\n+\n+    fn cb(_rel: usize, _rec: &Record, _w: isize) {}\n+\n+    // Instantiate a DDlog program.\n+    // Returns a handle to the program and initial contents of output relations.\n+    // Arguments\n+    // - number of worker threads (you typically want 1 or 2).\n+    // - Boolean flag that indicates whether DDlog will track the complete snapshot\n+    //   of output relations.  Should only be used if you plan to dump `dump_table`\n+    //   their contents using `HDDlog::dump_table()`.\n+    // - Callback - obsolete and will disappear in future releases.\n+    let (mut hddlog, init_state) = HDDlog::run(1, false, cb)?;\n+\n+    println!(\"Initial state\");\n+    dump_delta(&init_state);\n+\n+    /*\n+     * We perform two transactions that insert in the following two DDlog relations\n+     * (see `tutorial.dl`):\n+     *\n+     * ```\n+     * input relation Word1(word: string, cat: Category)\n+     * input relation Word2(word: string, cat: Category)\n+     * ```\n+     *\n+     * The first transactio uses the type-safe API, which should be preferred when\n+     * writing a client bound to a specific known DDlog program.\n+     *\n+     * The second transaction uses the dynamically typed record API.\n+     */\n+\n+    // There can be at most one transaction at a time.  Attempt to start anothe transaction\n+    // when there is one in progress will return an error.\n+    hddlog.transaction_start()?;\n+\n+    // A transaction can consist of multiple `apply_valupdates()` calls, each taking\n+    // multiple updates.  An update inserts, deletes or modifies a record in a DDlog\n+    // relation.\n+    let updates = vec![\n+        Update::Insert { // We are going to insert..\n+            relid: Relations::Word1 as RelId, // .. into relation with this Id.\n+            // `Word1` type, declared in the `types` crate has the same fields as\n+            // the corresponding DDlog type.\n+            // `Value::Word1` from the `value` crate is a wrapper around this type\n+            // that implement `into_ddvalue()`\n+            v: Value::Word1(Word1 {\n+                word: \"foo-\".to_string(),\n+                cat: Category::CategoryOther,\n+            })\n+            .into_ddvalue(),\n+        },\n+        Update::Insert {\n+            relid: Relations::Word2 as RelId,\n+            v: Value::Word2(Word2 {\n+                word: \"bar\".to_string(),\n+                cat: Category::CategoryOther,\n+            })\n+            .into_ddvalue(),\n+        },\n+    ];\n+    hddlog.apply_valupdates(updates.into_iter())?;\n+\n+    // Commit the transaction; returns a `DeltaMap` object that contains the set\n+    // of changes to output relations produced by the transaction.\n+    let mut delta = hddlog.transaction_commit_dump_changes()?;\n+    //assert_eq!(delta, delta_expected);\n+\n+    println!(\"\\nState after transaction 1\");\n+    dump_delta(&delta);\n+    \n+    // This shows how to extract values from `DeltaMap`.\n+    println!(\"\\nEnumerating new phrases\");\n+\n+    // Retrieve the set of changes for a particular relation.\n+    let new_phrases = delta.get_rel(Relations::Phrases as RelId);\n+    for (val, weight) in new_phrases.iter() {\n+        // weight = 1 - insert.\n+        // weight = -1 - delete.\n+        assert_eq!(*weight, 1);\n+        // `val` has type `DDValue`; converting it to a concrete Rust\n+        // type is an unsafe operation: specifying the wrong Rust type\n+        // will lead to undefined behavior.\n+        let phrase: &Value::Phrases = unsafe { Value::Phrases::from_ddvalue_ref(val) };", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68405e13637262bb6268d306556ead63063f413e"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTAxMDk5Mw==", "bodyText": "Yes, that's the plan.", "url": "https://github.com/vmware/differential-datalog/pull/744#discussion_r475010993", "createdAt": "2020-08-21T23:35:40Z", "author": {"login": "ryzhyk"}, "path": "test/datalog_tests/rust_api_test/src/main.rs", "diffHunk": "@@ -0,0 +1,172 @@\n+use std::borrow::Cow;\n+\n+// The main auto-generated crate `<progname>_ddlog` declares\n+// `HDDlog` type that serves as a reference to a running DDlog program.\n+// `HDDlog` implements `trait differential_datalog::DDlog` (see below).\n+use tutorial_ddlog::api::HDDlog;\n+\n+// The differential_datalog crate contains the DDlog runtime that is\n+// the same for all DDlog programs and simply gets copied to each generated\n+// DDlog workspace unmodified (this will change in future releases).\n+use differential_datalog::DDlog; // Trait that must be implemented by an instance of a DDlog program.\n+use differential_datalog::DeltaMap; // Type that represents a set of changes to DDlog relations.\n+                                    // Returned by `DDlog::transaction_commit_dump_changes()`.\n+use differential_datalog::ddval::DDValue; // Generic type that wraps all DDlog value.\n+use differential_datalog::ddval::DDValConvert; // Trait to convert Rust types to/from DDValue.\n+                                               // All types in the `value::Value` module (see below)\n+                                               // implement this trait.\n+use differential_datalog::program::RelId; // Numeric relations id.\n+use differential_datalog::program::Update; // Type-safe representation of a DDlog command (insert/delete_val/delete_key/...)\n+\n+// The `record` module defines dynamically typed representation of DDlog values and commands.\n+use differential_datalog::record::Record; // Dynamically typed representation of DDlog values.\n+use differential_datalog::record::RelIdentifier; // Relation identifier: either `RelId` or `Cow<str>`g.\n+use differential_datalog::record::UpdCmd; // Dynamically typed representation of DDlog command.\n+\n+// The auto-generated `types` crate contains Rust types that correspond to user-defined DDlog\n+// types, one for each typedef and each relation in the DDlog program.\n+use types::*;\n+\n+// The auto-generated `value` crate contains\n+// * The `Value` model that define a wrapper type for each input and\n+//   output relation in the DDlog program, as well as\n+// * `enum Relations` that enumerates program relations\n+// * Several functions that convert between numeric relation id's and\n+//   symbolic names.\n+use value::relid2name;\n+use value::Relations;\n+use value::Value;\n+\n+fn main() -> Result<(), String> {\n+\n+    fn cb(_rel: usize, _rec: &Record, _w: isize) {}\n+\n+    // Instantiate a DDlog program.\n+    // Returns a handle to the program and initial contents of output relations.\n+    // Arguments\n+    // - number of worker threads (you typically want 1 or 2).\n+    // - Boolean flag that indicates whether DDlog will track the complete snapshot\n+    //   of output relations.  Should only be used if you plan to dump `dump_table`\n+    //   their contents using `HDDlog::dump_table()`.\n+    // - Callback - obsolete and will disappear in future releases.\n+    let (mut hddlog, init_state) = HDDlog::run(1, false, cb)?;\n+\n+    println!(\"Initial state\");\n+    dump_delta(&init_state);\n+\n+    /*\n+     * We perform two transactions that insert in the following two DDlog relations\n+     * (see `tutorial.dl`):\n+     *\n+     * ```\n+     * input relation Word1(word: string, cat: Category)\n+     * input relation Word2(word: string, cat: Category)\n+     * ```\n+     *\n+     * The first transactio uses the type-safe API, which should be preferred when\n+     * writing a client bound to a specific known DDlog program.\n+     *\n+     * The second transaction uses the dynamically typed record API.\n+     */\n+\n+    // There can be at most one transaction at a time.  Attempt to start anothe transaction\n+    // when there is one in progress will return an error.\n+    hddlog.transaction_start()?;\n+\n+    // A transaction can consist of multiple `apply_valupdates()` calls, each taking\n+    // multiple updates.  An update inserts, deletes or modifies a record in a DDlog\n+    // relation.\n+    let updates = vec![\n+        Update::Insert { // We are going to insert..\n+            relid: Relations::Word1 as RelId, // .. into relation with this Id.\n+            // `Word1` type, declared in the `types` crate has the same fields as\n+            // the corresponding DDlog type.\n+            // `Value::Word1` from the `value` crate is a wrapper around this type\n+            // that implement `into_ddvalue()`\n+            v: Value::Word1(Word1 {\n+                word: \"foo-\".to_string(),\n+                cat: Category::CategoryOther,\n+            })\n+            .into_ddvalue(),\n+        },\n+        Update::Insert {\n+            relid: Relations::Word2 as RelId,\n+            v: Value::Word2(Word2 {\n+                word: \"bar\".to_string(),\n+                cat: Category::CategoryOther,\n+            })\n+            .into_ddvalue(),\n+        },\n+    ];\n+    hddlog.apply_valupdates(updates.into_iter())?;\n+\n+    // Commit the transaction; returns a `DeltaMap` object that contains the set\n+    // of changes to output relations produced by the transaction.\n+    let mut delta = hddlog.transaction_commit_dump_changes()?;\n+    //assert_eq!(delta, delta_expected);\n+\n+    println!(\"\\nState after transaction 1\");\n+    dump_delta(&delta);\n+    \n+    // This shows how to extract values from `DeltaMap`.\n+    println!(\"\\nEnumerating new phrases\");\n+\n+    // Retrieve the set of changes for a particular relation.\n+    let new_phrases = delta.get_rel(Relations::Phrases as RelId);\n+    for (val, weight) in new_phrases.iter() {\n+        // weight = 1 - insert.\n+        // weight = -1 - delete.\n+        assert_eq!(*weight, 1);\n+        // `val` has type `DDValue`; converting it to a concrete Rust\n+        // type is an unsafe operation: specifying the wrong Rust type\n+        // will lead to undefined behavior.\n+        let phrase: &Value::Phrases = unsafe { Value::Phrases::from_ddvalue_ref(val) };", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDg5MDAwMQ=="}, "originalCommit": {"oid": "68405e13637262bb6268d306556ead63063f413e"}, "originalPosition": 123}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4820, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}