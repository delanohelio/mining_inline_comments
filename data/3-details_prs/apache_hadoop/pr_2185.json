{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDYxOTMzNDM4", "number": 2185, "title": "HADOOP-15891. provide Regex Based Mount Point In Inode Tree", "bodyText": "https://issues.apache.org/jira/browse/HADOOP-15891", "createdAt": "2020-08-03T04:24:54Z", "url": "https://github.com/apache/hadoop/pull/2185", "merged": true, "mergeCommit": {"oid": "12a316cdf9994feaa36c3ff7d13e67d70398a9f3"}, "closed": true, "closedAt": "2020-09-11T04:20:33Z", "author": {"login": "JohnZZGithub"}, "timelineItems": {"totalCount": 34, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc7b6GtgBqjM2MTgwODgxNjA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdHtlbhgFqTQ4NjQ2MzQ0Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "db45b766e7e9eb1a9557925caf1e9b721b4de2cc", "author": {"user": null}, "url": "https://github.com/apache/hadoop/commit/db45b766e7e9eb1a9557925caf1e9b721b4de2cc", "committedDate": "2020-08-03T04:23:05Z", "message": "HADOOP-15891: provide Regex Based Mount Point In Inode Tree\n\nDifferential Revision: https://phabricator.twitter.biz/D526212"}, "afterCommit": {"oid": "65c151a5680e015d6d2a143a99fe197f92b6e1da", "author": {"user": null}, "url": "https://github.com/apache/hadoop/commit/65c151a5680e015d6d2a143a99fe197f92b6e1da", "committedDate": "2020-08-04T00:49:00Z", "message": "HADOOP-15891: provide Regex Based Mount Point In Inode Tree\n\nDifferential Revision: https://phabricator.twitter.biz/D526212"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "65c151a5680e015d6d2a143a99fe197f92b6e1da", "author": {"user": null}, "url": "https://github.com/apache/hadoop/commit/65c151a5680e015d6d2a143a99fe197f92b6e1da", "committedDate": "2020-08-04T00:49:00Z", "message": "HADOOP-15891: provide Regex Based Mount Point In Inode Tree\n\nDifferential Revision: https://phabricator.twitter.biz/D526212"}, "afterCommit": {"oid": "1fe566506bf0978a39b49194e622da52ea70cbb4", "author": {"user": null}, "url": "https://github.com/apache/hadoop/commit/1fe566506bf0978a39b49194e622da52ea70cbb4", "committedDate": "2020-08-04T03:11:52Z", "message": "HADOOP-15891: provide Regex Based Mount Point In Inode Tree\n\nDifferential Revision: https://phabricator.twitter.biz/D526212"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1fe566506bf0978a39b49194e622da52ea70cbb4", "author": {"user": null}, "url": "https://github.com/apache/hadoop/commit/1fe566506bf0978a39b49194e622da52ea70cbb4", "committedDate": "2020-08-04T03:11:52Z", "message": "HADOOP-15891: provide Regex Based Mount Point In Inode Tree\n\nDifferential Revision: https://phabricator.twitter.biz/D526212"}, "afterCommit": {"oid": "3ae248e04f985df5c838720d6f798191ffc0b465", "author": {"user": null}, "url": "https://github.com/apache/hadoop/commit/3ae248e04f985df5c838720d6f798191ffc0b465", "committedDate": "2020-08-04T17:53:19Z", "message": "HADOOP-15891: provide Regex Based Mount Point In Inode Tree\n\nDifferential Revision: https://phabricator.twitter.biz/D526212"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3ae248e04f985df5c838720d6f798191ffc0b465", "author": {"user": null}, "url": "https://github.com/apache/hadoop/commit/3ae248e04f985df5c838720d6f798191ffc0b465", "committedDate": "2020-08-04T17:53:19Z", "message": "HADOOP-15891: provide Regex Based Mount Point In Inode Tree\n\nDifferential Revision: https://phabricator.twitter.biz/D526212"}, "afterCommit": {"oid": "44f3909fca1d3a0e10b83d9c43a241022a4b0edf", "author": {"user": null}, "url": "https://github.com/apache/hadoop/commit/44f3909fca1d3a0e10b83d9c43a241022a4b0edf", "committedDate": "2020-08-04T23:27:27Z", "message": "HADOOP-15891: provide Regex Based Mount Point In Inode Tree\n\nDifferential Revision: https://phabricator.twitter.biz/D526212"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "44f3909fca1d3a0e10b83d9c43a241022a4b0edf", "author": {"user": null}, "url": "https://github.com/apache/hadoop/commit/44f3909fca1d3a0e10b83d9c43a241022a4b0edf", "committedDate": "2020-08-04T23:27:27Z", "message": "HADOOP-15891: provide Regex Based Mount Point In Inode Tree\n\nDifferential Revision: https://phabricator.twitter.biz/D526212"}, "afterCommit": {"oid": "d3e5b8331000f9189c7d2073d08a281532f36a8d", "author": {"user": null}, "url": "https://github.com/apache/hadoop/commit/d3e5b8331000f9189c7d2073d08a281532f36a8d", "committedDate": "2020-08-06T18:42:19Z", "message": "HADOOP-15891: provide Regex Based Mount Point In Inode Tree\n\nDifferential Revision: https://phabricator.twitter.biz/D526212"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzNDg2MjI4", "url": "https://github.com/apache/hadoop/pull/2185#pullrequestreview-463486228", "createdAt": "2020-08-07T17:33:57Z", "commit": {"oid": "d3e5b8331000f9189c7d2073d08a281532f36a8d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNzozMzo1N1rOG9iM1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNzozMzo1N1rOG9iM1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE3NjY2MQ==", "bodyText": "It looks complex. But the major change here is simple.\nBefore:\nif (key.startsWith(mountTablePrefix)) {\n// hundred line of code\n}\nAfter:\nif (!key.startsWith(mountTablePrefix)) {\ncontinue\n}\n// hundred line of code", "url": "https://github.com/apache/hadoop/pull/2185#discussion_r467176661", "createdAt": "2020-08-07T17:33:57Z", "author": {"login": "JohnZZGithub"}, "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/viewfs/InodeTree.java", "diffHunk": "@@ -486,84 +506,113 @@ protected InodeTree(final Configuration config, final String viewName,\n     final UserGroupInformation ugi = UserGroupInformation.getCurrentUser();\n     for (Entry<String, String> si : config) {\n       final String key = si.getKey();\n-      if (key.startsWith(mountTablePrefix)) {\n-        gotMountTableEntry = true;\n-        LinkType linkType;\n-        String src = key.substring(mountTablePrefix.length());\n-        String settings = null;\n-        if (src.startsWith(linkPrefix)) {\n-          src = src.substring(linkPrefix.length());\n-          if (src.equals(SlashPath.toString())) {\n-            throw new UnsupportedFileSystemException(\"Unexpected mount table \"\n-                + \"link entry '\" + key + \"'. Use \"\n-                + Constants.CONFIG_VIEWFS_LINK_MERGE_SLASH  + \" instead!\");\n-          }\n-          linkType = LinkType.SINGLE;\n-        } else if (src.startsWith(linkFallbackPrefix)) {\n-          if (src.length() != linkFallbackPrefix.length()) {\n-            throw new IOException(\"ViewFs: Mount points initialization error.\" +\n-                \" Invalid \" + Constants.CONFIG_VIEWFS_LINK_FALLBACK +\n-                \" entry in config: \" + src);\n-          }\n-          linkType = LinkType.SINGLE_FALLBACK;\n-        } else if (src.startsWith(linkMergePrefix)) { // A merge link\n-          src = src.substring(linkMergePrefix.length());\n-          linkType = LinkType.MERGE;\n-        } else if (src.startsWith(linkMergeSlashPrefix)) {\n-          // This is a LinkMergeSlash entry. This entry should\n-          // not have any additional source path.\n-          if (src.length() != linkMergeSlashPrefix.length()) {\n-            throw new IOException(\"ViewFs: Mount points initialization error.\" +\n-                \" Invalid \" + Constants.CONFIG_VIEWFS_LINK_MERGE_SLASH +\n-                \" entry in config: \" + src);\n-          }\n-          linkType = LinkType.MERGE_SLASH;\n-        } else if (src.startsWith(Constants.CONFIG_VIEWFS_LINK_NFLY)) {\n-          // prefix.settings.src\n-          src = src.substring(Constants.CONFIG_VIEWFS_LINK_NFLY.length() + 1);\n-          // settings.src\n-          settings = src.substring(0, src.indexOf('.'));\n-          // settings\n-\n-          // settings.src\n-          src = src.substring(settings.length() + 1);\n-          // src\n-\n-          linkType = LinkType.NFLY;\n-        } else if (src.startsWith(Constants.CONFIG_VIEWFS_HOMEDIR)) {\n-          // ignore - we set home dir from config\n-          continue;\n-        } else {\n-          throw new IOException(\"ViewFs: Cannot initialize: Invalid entry in \" +\n-              \"Mount table in config: \" + src);\n-        }\n+      if (!key.startsWith(mountTablePrefix)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3e5b8331000f9189c7d2073d08a281532f36a8d"}, "originalPosition": 153}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d3e5b8331000f9189c7d2073d08a281532f36a8d", "author": {"user": null}, "url": "https://github.com/apache/hadoop/commit/d3e5b8331000f9189c7d2073d08a281532f36a8d", "committedDate": "2020-08-06T18:42:19Z", "message": "HADOOP-15891: provide Regex Based Mount Point In Inode Tree\n\nDifferential Revision: https://phabricator.twitter.biz/D526212"}, "afterCommit": {"oid": "c58b945a32a978c470be07ef47e9ed7edfff428c", "author": {"user": null}, "url": "https://github.com/apache/hadoop/commit/c58b945a32a978c470be07ef47e9ed7edfff428c", "committedDate": "2020-08-10T21:03:57Z", "message": "HADOOP-15891: provide Regex Based Mount Point In Inode Tree\n\nDifferential Revision: https://phabricator.twitter.biz/D526212"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzOTgzNjYz", "url": "https://github.com/apache/hadoop/pull/2185#pullrequestreview-463983663", "createdAt": "2020-08-10T06:36:44Z", "commit": {"oid": "d3e5b8331000f9189c7d2073d08a281532f36a8d"}, "state": "COMMENTED", "comments": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQwNjozNjo0NFrOG-Cy8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxOToxMjozOVrOHB3h_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzcxMDcwNQ==", "bodyText": "you mean fs.viewfs.mounttable.<mnt_tbl_name>.linkRegex ?", "url": "https://github.com/apache/hadoop/pull/2185#discussion_r467710705", "createdAt": "2020-08-10T06:36:44Z", "author": {"login": "umamaheswararao"}, "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/viewfs/InodeTree.java", "diffHunk": "@@ -226,7 +239,14 @@ void addLink(final String pathComponent, final INodeLink<T> link)\n      * Config prefix: fs.viewfs.mounttable.<mnt_tbl_name>.linkNfly\n      * Refer: {@link Constants#CONFIG_VIEWFS_LINK_NFLY}\n      */\n-    NFLY;\n+    NFLY,\n+    /**\n+     * Link entry which source are regex exrepssions and target refer matched\n+     * group from source\n+     * Config prefix: fs.viewfs.mounttable.<mnt_tbl_name>.linkMerge", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d3e5b8331000f9189c7d2073d08a281532f36a8d"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTI2ODI2NQ==", "bodyText": "Below params javadoc does not help anything I think. If you want to add, please add description( most of that params seems self explanatory ), otherwise just remove params part.", "url": "https://github.com/apache/hadoop/pull/2185#discussion_r471268265", "createdAt": "2020-08-17T06:59:51Z", "author": {"login": "umamaheswararao"}, "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/viewfs/ConfigUtil.java", "diffHunk": "@@ -166,6 +166,41 @@ public static void addLinkNfly(final Configuration conf, final String src,\n     addLinkNfly(conf, getDefaultMountTableName(conf), src, null, targets);\n   }\n \n+\n+  /**\n+   * Add a LinkRegex to the config for the specified mount table.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c58b945a32a978c470be07ef47e9ed7edfff428c"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTMwNjE3NQ==", "bodyText": "below key construction can be outside of lock?", "url": "https://github.com/apache/hadoop/pull/2185#discussion_r471306175", "createdAt": "2020-08-17T07:57:54Z", "author": {"login": "umamaheswararao"}, "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/viewfs/InodeTree.java", "diffHunk": "@@ -646,102 +714,222 @@ boolean isInternalDir() {\n   }\n \n   /**\n-   * Resolve the pathname p relative to root InodeDir\n+   * Resolve the pathname p relative to root InodeDir.\n    * @param p - input path\n    * @param resolveLastComponent\n    * @return ResolveResult which allows further resolution of the remaining path\n    * @throws FileNotFoundException\n    */\n   ResolveResult<T> resolve(final String p, final boolean resolveLastComponent)\n       throws FileNotFoundException {\n-    String[] path = breakIntoPathComponents(p);\n-    if (path.length <= 1) { // special case for when path is \"/\"\n-      T targetFs = root.isInternalDir() ?\n-          getRootDir().getInternalDirFs() : getRootLink().getTargetFileSystem();\n-      ResolveResult<T> res = new ResolveResult<T>(ResultKind.INTERNAL_DIR,\n-          targetFs, root.fullPath, SlashPath);\n-      return res;\n-    }\n+    ResolveResult<T> resolveResult = null;\n+    resolveResult = getResolveResultFromCache(p, resolveLastComponent);\n+    if (resolveResult != null) {\n+      return resolveResult;\n+    }\n+\n+    try {\n+      String[] path = breakIntoPathComponents(p);\n+      if (path.length <= 1) { // special case for when path is \"/\"\n+        T targetFs = root.isInternalDir() ?\n+            getRootDir().getInternalDirFs()\n+            : getRootLink().getTargetFileSystem();\n+        resolveResult = new ResolveResult<T>(ResultKind.INTERNAL_DIR,\n+            targetFs, root.fullPath, SlashPath);\n+        return resolveResult;\n+      }\n \n-    /**\n-     * linkMergeSlash has been configured. The root of this mount table has\n-     * been linked to the root directory of a file system.\n-     * The first non-slash path component should be name of the mount table.\n-     */\n-    if (root.isLink()) {\n-      Path remainingPath;\n-      StringBuilder remainingPathStr = new StringBuilder();\n-      // ignore first slash\n-      for (int i = 1; i < path.length; i++) {\n-        remainingPathStr.append(\"/\").append(path[i]);\n+      /**\n+       * linkMergeSlash has been configured. The root of this mount table has\n+       * been linked to the root directory of a file system.\n+       * The first non-slash path component should be name of the mount table.\n+       */\n+      if (root.isLink()) {\n+        Path remainingPath;\n+        StringBuilder remainingPathStr = new StringBuilder();\n+        // ignore first slash\n+        for (int i = 1; i < path.length; i++) {\n+          remainingPathStr.append(\"/\").append(path[i]);\n+        }\n+        remainingPath = new Path(remainingPathStr.toString());\n+        resolveResult = new ResolveResult<T>(ResultKind.EXTERNAL_DIR,\n+            getRootLink().getTargetFileSystem(), root.fullPath, remainingPath);\n+        return resolveResult;\n       }\n-      remainingPath = new Path(remainingPathStr.toString());\n-      ResolveResult<T> res = new ResolveResult<T>(ResultKind.EXTERNAL_DIR,\n-          getRootLink().getTargetFileSystem(), root.fullPath, remainingPath);\n-      return res;\n-    }\n-    Preconditions.checkState(root.isInternalDir());\n-    INodeDir<T> curInode = getRootDir();\n+      Preconditions.checkState(root.isInternalDir());\n+      INodeDir<T> curInode = getRootDir();\n \n-    int i;\n-    // ignore first slash\n-    for (i = 1; i < path.length - (resolveLastComponent ? 0 : 1); i++) {\n-      INode<T> nextInode = curInode.resolveInternal(path[i]);\n-      if (nextInode == null) {\n-        if (hasFallbackLink()) {\n-          return new ResolveResult<T>(ResultKind.EXTERNAL_DIR,\n-              getRootFallbackLink().getTargetFileSystem(),\n-              root.fullPath, new Path(p));\n-        } else {\n-          StringBuilder failedAt = new StringBuilder(path[0]);\n-          for (int j = 1; j <= i; ++j) {\n-            failedAt.append('/').append(path[j]);\n+      // Try to resolve path in the regex mount point\n+      resolveResult = tryResolveInRegexMountpoint(p, resolveLastComponent);\n+      if (resolveResult != null) {\n+        return resolveResult;\n+      }\n+\n+      int i;\n+      // ignore first slash\n+      for (i = 1; i < path.length - (resolveLastComponent ? 0 : 1); i++) {\n+        INode<T> nextInode = curInode.resolveInternal(path[i]);\n+        if (nextInode == null) {\n+          if (hasFallbackLink()) {\n+            resolveResult = new ResolveResult<T>(ResultKind.EXTERNAL_DIR,\n+                getRootFallbackLink().getTargetFileSystem(), root.fullPath,\n+                new Path(p));\n+            return resolveResult;\n+          } else {\n+            StringBuilder failedAt = new StringBuilder(path[0]);\n+            for (int j = 1; j <= i; ++j) {\n+              failedAt.append('/').append(path[j]);\n+            }\n+            throw (new FileNotFoundException(\n+                \"File/Directory does not exist: \" + failedAt.toString()));\n           }\n-          throw (new FileNotFoundException(\n-              \"File/Directory does not exist: \" + failedAt.toString()));\n         }\n-      }\n \n-      if (nextInode.isLink()) {\n-        final INodeLink<T> link = (INodeLink<T>) nextInode;\n-        final Path remainingPath;\n-        if (i >= path.length - 1) {\n-          remainingPath = SlashPath;\n-        } else {\n-          StringBuilder remainingPathStr = new StringBuilder(\"/\" + path[i + 1]);\n-          for (int j = i + 2; j < path.length; ++j) {\n-            remainingPathStr.append('/').append(path[j]);\n+        if (nextInode.isLink()) {\n+          final INodeLink<T> link = (INodeLink<T>) nextInode;\n+          final Path remainingPath;\n+          if (i >= path.length - 1) {\n+            remainingPath = SlashPath;\n+          } else {\n+            StringBuilder remainingPathStr =\n+                new StringBuilder(\"/\" + path[i + 1]);\n+            for (int j = i + 2; j < path.length; ++j) {\n+              remainingPathStr.append('/').append(path[j]);\n+            }\n+            remainingPath = new Path(remainingPathStr.toString());\n           }\n-          remainingPath = new Path(remainingPathStr.toString());\n+          resolveResult = new ResolveResult<T>(ResultKind.EXTERNAL_DIR,\n+              link.getTargetFileSystem(), nextInode.fullPath, remainingPath);\n+          return resolveResult;\n+        } else if (nextInode.isInternalDir()) {\n+          curInode = (INodeDir<T>) nextInode;\n         }\n-        final ResolveResult<T> res =\n-            new ResolveResult<T>(ResultKind.EXTERNAL_DIR,\n-                link.getTargetFileSystem(), nextInode.fullPath, remainingPath);\n-        return res;\n-      } else if (nextInode.isInternalDir()) {\n-        curInode = (INodeDir<T>) nextInode;\n+      }\n+\n+      // We have resolved to an internal dir in mount table.\n+      Path remainingPath;\n+      if (resolveLastComponent) {\n+        remainingPath = SlashPath;\n+      } else {\n+        // note we have taken care of when path is \"/\" above\n+        // for internal dirs rem-path does not start with / since the lookup\n+        // that follows will do a children.get(remaningPath) and will have to\n+        // strip-out the initial /\n+        StringBuilder remainingPathStr = new StringBuilder(\"/\" + path[i]);\n+        for (int j = i + 1; j < path.length; ++j) {\n+          remainingPathStr.append('/').append(path[j]);\n+        }\n+        remainingPath = new Path(remainingPathStr.toString());\n+      }\n+      resolveResult = new ResolveResult<T>(ResultKind.INTERNAL_DIR,\n+          curInode.getInternalDirFs(), curInode.fullPath, remainingPath);\n+      return resolveResult;\n+    } finally {\n+      if (pathResolutionCacheCapacity > 0 && resolveResult != null) {\n+        addResolveResultToCache(p, resolveLastComponent, resolveResult);\n       }\n     }\n+  }\n \n-    // We have resolved to an internal dir in mount table.\n-    Path remainingPath;\n-    if (resolveLastComponent) {\n-      remainingPath = SlashPath;\n-    } else {\n-      // note we have taken care of when path is \"/\" above\n-      // for internal dirs rem-path does not start with / since the lookup\n-      // that follows will do a children.get(remaningPath) and will have to\n-      // strip-out the initial /\n-      StringBuilder remainingPathStr = new StringBuilder(\"/\" + path[i]);\n-      for (int j = i + 1; j < path.length; ++j) {\n-        remainingPathStr.append('/').append(path[j]);\n+  /**\n+   * Walk through all regex mount points to see\n+   * whether the path match any regex expressions.\n+   *\n+   * @param srcPath\n+   * @param resolveLastComponent\n+   * @return\n+   */\n+  protected ResolveResult<T> tryResolveInRegexMountpoint(final String srcPath,\n+      final boolean resolveLastComponent) {\n+    for (RegexMountPoint regexMountPoint : regexMountPointList) {\n+      ResolveResult resolveResult =\n+          regexMountPoint.resolve(srcPath, resolveLastComponent);\n+      if (resolveResult != null) {\n+        return resolveResult;\n       }\n-      remainingPath = new Path(remainingPathStr.toString());\n     }\n-    final ResolveResult<T> res =\n-        new ResolveResult<T>(ResultKind.INTERNAL_DIR,\n-            curInode.getInternalDirFs(), curInode.fullPath, remainingPath);\n-    return res;\n+    return null;\n+  }\n+\n+  /**\n+   * Build resolve result return to caller.\n+   *\n+   * @param resultKind\n+   * @param resolvedPathStr\n+   * @param targetOfResolvedPathStr\n+   * @param remainingPath\n+   * @return\n+   */\n+  protected ResolveResult<T> buildResolveResultForRegexMountPoint(\n+      ResultKind resultKind, String resolvedPathStr,\n+      String targetOfResolvedPathStr, Path remainingPath) {\n+    try {\n+      T targetFs = getTargetFileSystem(new URI(targetOfResolvedPathStr));\n+      return new ResolveResult<T>(resultKind, targetFs, resolvedPathStr,\n+          remainingPath);\n+    } catch (IOException ex) {\n+      LOGGER.error(String.format(\n+          \"Got Exception while build resolve result.\"\n+              + \" ResultKind:%s, resolvedPathStr:%s,\"\n+              + \" targetOfResolvedPathStr:%s, remainingPath:%s,\"\n+              + \" will return null.\",\n+          resultKind, resolvedPathStr, targetOfResolvedPathStr, remainingPath),\n+          ex);\n+      return null;\n+    } catch (URISyntaxException uex) {\n+      LOGGER.error(String.format(\n+          \"Got Exception while build resolve result.\"\n+              + \" ResultKind:%s, resolvedPathStr:%s,\"\n+              + \" targetOfResolvedPathStr:%s, remainingPath:%s,\"\n+              + \" will return null.\",\n+          resultKind, resolvedPathStr, targetOfResolvedPathStr, remainingPath),\n+          uex);\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * Return resolution cache capacity.\n+   *\n+   * @return\n+   */\n+  public int getPathResolutionCacheCapacity() {\n+    return pathResolutionCacheCapacity;\n+  }\n+\n+  private void addResolveResultToCache(final String pathStr,\n+      final Boolean resolveLastComponent,\n+      final ResolveResult<T> resolveResult) {\n+    try {\n+      cacheRWLock.writeLock().lock();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c58b945a32a978c470be07ef47e9ed7edfff428c"}, "originalPosition": 596}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTMwNjM4Nw==", "bodyText": "same as above.", "url": "https://github.com/apache/hadoop/pull/2185#discussion_r471306387", "createdAt": "2020-08-17T07:58:20Z", "author": {"login": "umamaheswararao"}, "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/viewfs/InodeTree.java", "diffHunk": "@@ -646,102 +714,222 @@ boolean isInternalDir() {\n   }\n \n   /**\n-   * Resolve the pathname p relative to root InodeDir\n+   * Resolve the pathname p relative to root InodeDir.\n    * @param p - input path\n    * @param resolveLastComponent\n    * @return ResolveResult which allows further resolution of the remaining path\n    * @throws FileNotFoundException\n    */\n   ResolveResult<T> resolve(final String p, final boolean resolveLastComponent)\n       throws FileNotFoundException {\n-    String[] path = breakIntoPathComponents(p);\n-    if (path.length <= 1) { // special case for when path is \"/\"\n-      T targetFs = root.isInternalDir() ?\n-          getRootDir().getInternalDirFs() : getRootLink().getTargetFileSystem();\n-      ResolveResult<T> res = new ResolveResult<T>(ResultKind.INTERNAL_DIR,\n-          targetFs, root.fullPath, SlashPath);\n-      return res;\n-    }\n+    ResolveResult<T> resolveResult = null;\n+    resolveResult = getResolveResultFromCache(p, resolveLastComponent);\n+    if (resolveResult != null) {\n+      return resolveResult;\n+    }\n+\n+    try {\n+      String[] path = breakIntoPathComponents(p);\n+      if (path.length <= 1) { // special case for when path is \"/\"\n+        T targetFs = root.isInternalDir() ?\n+            getRootDir().getInternalDirFs()\n+            : getRootLink().getTargetFileSystem();\n+        resolveResult = new ResolveResult<T>(ResultKind.INTERNAL_DIR,\n+            targetFs, root.fullPath, SlashPath);\n+        return resolveResult;\n+      }\n \n-    /**\n-     * linkMergeSlash has been configured. The root of this mount table has\n-     * been linked to the root directory of a file system.\n-     * The first non-slash path component should be name of the mount table.\n-     */\n-    if (root.isLink()) {\n-      Path remainingPath;\n-      StringBuilder remainingPathStr = new StringBuilder();\n-      // ignore first slash\n-      for (int i = 1; i < path.length; i++) {\n-        remainingPathStr.append(\"/\").append(path[i]);\n+      /**\n+       * linkMergeSlash has been configured. The root of this mount table has\n+       * been linked to the root directory of a file system.\n+       * The first non-slash path component should be name of the mount table.\n+       */\n+      if (root.isLink()) {\n+        Path remainingPath;\n+        StringBuilder remainingPathStr = new StringBuilder();\n+        // ignore first slash\n+        for (int i = 1; i < path.length; i++) {\n+          remainingPathStr.append(\"/\").append(path[i]);\n+        }\n+        remainingPath = new Path(remainingPathStr.toString());\n+        resolveResult = new ResolveResult<T>(ResultKind.EXTERNAL_DIR,\n+            getRootLink().getTargetFileSystem(), root.fullPath, remainingPath);\n+        return resolveResult;\n       }\n-      remainingPath = new Path(remainingPathStr.toString());\n-      ResolveResult<T> res = new ResolveResult<T>(ResultKind.EXTERNAL_DIR,\n-          getRootLink().getTargetFileSystem(), root.fullPath, remainingPath);\n-      return res;\n-    }\n-    Preconditions.checkState(root.isInternalDir());\n-    INodeDir<T> curInode = getRootDir();\n+      Preconditions.checkState(root.isInternalDir());\n+      INodeDir<T> curInode = getRootDir();\n \n-    int i;\n-    // ignore first slash\n-    for (i = 1; i < path.length - (resolveLastComponent ? 0 : 1); i++) {\n-      INode<T> nextInode = curInode.resolveInternal(path[i]);\n-      if (nextInode == null) {\n-        if (hasFallbackLink()) {\n-          return new ResolveResult<T>(ResultKind.EXTERNAL_DIR,\n-              getRootFallbackLink().getTargetFileSystem(),\n-              root.fullPath, new Path(p));\n-        } else {\n-          StringBuilder failedAt = new StringBuilder(path[0]);\n-          for (int j = 1; j <= i; ++j) {\n-            failedAt.append('/').append(path[j]);\n+      // Try to resolve path in the regex mount point\n+      resolveResult = tryResolveInRegexMountpoint(p, resolveLastComponent);\n+      if (resolveResult != null) {\n+        return resolveResult;\n+      }\n+\n+      int i;\n+      // ignore first slash\n+      for (i = 1; i < path.length - (resolveLastComponent ? 0 : 1); i++) {\n+        INode<T> nextInode = curInode.resolveInternal(path[i]);\n+        if (nextInode == null) {\n+          if (hasFallbackLink()) {\n+            resolveResult = new ResolveResult<T>(ResultKind.EXTERNAL_DIR,\n+                getRootFallbackLink().getTargetFileSystem(), root.fullPath,\n+                new Path(p));\n+            return resolveResult;\n+          } else {\n+            StringBuilder failedAt = new StringBuilder(path[0]);\n+            for (int j = 1; j <= i; ++j) {\n+              failedAt.append('/').append(path[j]);\n+            }\n+            throw (new FileNotFoundException(\n+                \"File/Directory does not exist: \" + failedAt.toString()));\n           }\n-          throw (new FileNotFoundException(\n-              \"File/Directory does not exist: \" + failedAt.toString()));\n         }\n-      }\n \n-      if (nextInode.isLink()) {\n-        final INodeLink<T> link = (INodeLink<T>) nextInode;\n-        final Path remainingPath;\n-        if (i >= path.length - 1) {\n-          remainingPath = SlashPath;\n-        } else {\n-          StringBuilder remainingPathStr = new StringBuilder(\"/\" + path[i + 1]);\n-          for (int j = i + 2; j < path.length; ++j) {\n-            remainingPathStr.append('/').append(path[j]);\n+        if (nextInode.isLink()) {\n+          final INodeLink<T> link = (INodeLink<T>) nextInode;\n+          final Path remainingPath;\n+          if (i >= path.length - 1) {\n+            remainingPath = SlashPath;\n+          } else {\n+            StringBuilder remainingPathStr =\n+                new StringBuilder(\"/\" + path[i + 1]);\n+            for (int j = i + 2; j < path.length; ++j) {\n+              remainingPathStr.append('/').append(path[j]);\n+            }\n+            remainingPath = new Path(remainingPathStr.toString());\n           }\n-          remainingPath = new Path(remainingPathStr.toString());\n+          resolveResult = new ResolveResult<T>(ResultKind.EXTERNAL_DIR,\n+              link.getTargetFileSystem(), nextInode.fullPath, remainingPath);\n+          return resolveResult;\n+        } else if (nextInode.isInternalDir()) {\n+          curInode = (INodeDir<T>) nextInode;\n         }\n-        final ResolveResult<T> res =\n-            new ResolveResult<T>(ResultKind.EXTERNAL_DIR,\n-                link.getTargetFileSystem(), nextInode.fullPath, remainingPath);\n-        return res;\n-      } else if (nextInode.isInternalDir()) {\n-        curInode = (INodeDir<T>) nextInode;\n+      }\n+\n+      // We have resolved to an internal dir in mount table.\n+      Path remainingPath;\n+      if (resolveLastComponent) {\n+        remainingPath = SlashPath;\n+      } else {\n+        // note we have taken care of when path is \"/\" above\n+        // for internal dirs rem-path does not start with / since the lookup\n+        // that follows will do a children.get(remaningPath) and will have to\n+        // strip-out the initial /\n+        StringBuilder remainingPathStr = new StringBuilder(\"/\" + path[i]);\n+        for (int j = i + 1; j < path.length; ++j) {\n+          remainingPathStr.append('/').append(path[j]);\n+        }\n+        remainingPath = new Path(remainingPathStr.toString());\n+      }\n+      resolveResult = new ResolveResult<T>(ResultKind.INTERNAL_DIR,\n+          curInode.getInternalDirFs(), curInode.fullPath, remainingPath);\n+      return resolveResult;\n+    } finally {\n+      if (pathResolutionCacheCapacity > 0 && resolveResult != null) {\n+        addResolveResultToCache(p, resolveLastComponent, resolveResult);\n       }\n     }\n+  }\n \n-    // We have resolved to an internal dir in mount table.\n-    Path remainingPath;\n-    if (resolveLastComponent) {\n-      remainingPath = SlashPath;\n-    } else {\n-      // note we have taken care of when path is \"/\" above\n-      // for internal dirs rem-path does not start with / since the lookup\n-      // that follows will do a children.get(remaningPath) and will have to\n-      // strip-out the initial /\n-      StringBuilder remainingPathStr = new StringBuilder(\"/\" + path[i]);\n-      for (int j = i + 1; j < path.length; ++j) {\n-        remainingPathStr.append('/').append(path[j]);\n+  /**\n+   * Walk through all regex mount points to see\n+   * whether the path match any regex expressions.\n+   *\n+   * @param srcPath\n+   * @param resolveLastComponent\n+   * @return\n+   */\n+  protected ResolveResult<T> tryResolveInRegexMountpoint(final String srcPath,\n+      final boolean resolveLastComponent) {\n+    for (RegexMountPoint regexMountPoint : regexMountPointList) {\n+      ResolveResult resolveResult =\n+          regexMountPoint.resolve(srcPath, resolveLastComponent);\n+      if (resolveResult != null) {\n+        return resolveResult;\n       }\n-      remainingPath = new Path(remainingPathStr.toString());\n     }\n-    final ResolveResult<T> res =\n-        new ResolveResult<T>(ResultKind.INTERNAL_DIR,\n-            curInode.getInternalDirFs(), curInode.fullPath, remainingPath);\n-    return res;\n+    return null;\n+  }\n+\n+  /**\n+   * Build resolve result return to caller.\n+   *\n+   * @param resultKind\n+   * @param resolvedPathStr\n+   * @param targetOfResolvedPathStr\n+   * @param remainingPath\n+   * @return\n+   */\n+  protected ResolveResult<T> buildResolveResultForRegexMountPoint(\n+      ResultKind resultKind, String resolvedPathStr,\n+      String targetOfResolvedPathStr, Path remainingPath) {\n+    try {\n+      T targetFs = getTargetFileSystem(new URI(targetOfResolvedPathStr));\n+      return new ResolveResult<T>(resultKind, targetFs, resolvedPathStr,\n+          remainingPath);\n+    } catch (IOException ex) {\n+      LOGGER.error(String.format(\n+          \"Got Exception while build resolve result.\"\n+              + \" ResultKind:%s, resolvedPathStr:%s,\"\n+              + \" targetOfResolvedPathStr:%s, remainingPath:%s,\"\n+              + \" will return null.\",\n+          resultKind, resolvedPathStr, targetOfResolvedPathStr, remainingPath),\n+          ex);\n+      return null;\n+    } catch (URISyntaxException uex) {\n+      LOGGER.error(String.format(\n+          \"Got Exception while build resolve result.\"\n+              + \" ResultKind:%s, resolvedPathStr:%s,\"\n+              + \" targetOfResolvedPathStr:%s, remainingPath:%s,\"\n+              + \" will return null.\",\n+          resultKind, resolvedPathStr, targetOfResolvedPathStr, remainingPath),\n+          uex);\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * Return resolution cache capacity.\n+   *\n+   * @return\n+   */\n+  public int getPathResolutionCacheCapacity() {\n+    return pathResolutionCacheCapacity;\n+  }\n+\n+  private void addResolveResultToCache(final String pathStr,\n+      final Boolean resolveLastComponent,\n+      final ResolveResult<T> resolveResult) {\n+    try {\n+      cacheRWLock.writeLock().lock();\n+      String key = getResolveCacheKeyStr(pathStr, resolveLastComponent);\n+      pathResolutionCache.put(key, resolveResult);\n+    } finally {\n+      cacheRWLock.writeLock().unlock();\n+    }\n+  }\n+\n+  private ResolveResult<T> getResolveResultFromCache(final String pathStr,\n+      final Boolean resolveLastComponent) {\n+    if (pathResolutionCacheCapacity <= 0) {\n+      return null;\n+    }\n+    try {\n+      cacheRWLock.readLock().lock();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c58b945a32a978c470be07ef47e9ed7edfff428c"}, "originalPosition": 610}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTMxNjQwMw==", "bodyText": "Please move annotation to separate line below.", "url": "https://github.com/apache/hadoop/pull/2185#discussion_r471316403", "createdAt": "2020-08-17T08:17:27Z", "author": {"login": "umamaheswararao"}, "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/viewfs/InodeTree.java", "diffHunk": "@@ -646,102 +714,222 @@ boolean isInternalDir() {\n   }\n \n   /**\n-   * Resolve the pathname p relative to root InodeDir\n+   * Resolve the pathname p relative to root InodeDir.\n    * @param p - input path\n    * @param resolveLastComponent\n    * @return ResolveResult which allows further resolution of the remaining path\n    * @throws FileNotFoundException\n    */\n   ResolveResult<T> resolve(final String p, final boolean resolveLastComponent)\n       throws FileNotFoundException {\n-    String[] path = breakIntoPathComponents(p);\n-    if (path.length <= 1) { // special case for when path is \"/\"\n-      T targetFs = root.isInternalDir() ?\n-          getRootDir().getInternalDirFs() : getRootLink().getTargetFileSystem();\n-      ResolveResult<T> res = new ResolveResult<T>(ResultKind.INTERNAL_DIR,\n-          targetFs, root.fullPath, SlashPath);\n-      return res;\n-    }\n+    ResolveResult<T> resolveResult = null;\n+    resolveResult = getResolveResultFromCache(p, resolveLastComponent);\n+    if (resolveResult != null) {\n+      return resolveResult;\n+    }\n+\n+    try {\n+      String[] path = breakIntoPathComponents(p);\n+      if (path.length <= 1) { // special case for when path is \"/\"\n+        T targetFs = root.isInternalDir() ?\n+            getRootDir().getInternalDirFs()\n+            : getRootLink().getTargetFileSystem();\n+        resolveResult = new ResolveResult<T>(ResultKind.INTERNAL_DIR,\n+            targetFs, root.fullPath, SlashPath);\n+        return resolveResult;\n+      }\n \n-    /**\n-     * linkMergeSlash has been configured. The root of this mount table has\n-     * been linked to the root directory of a file system.\n-     * The first non-slash path component should be name of the mount table.\n-     */\n-    if (root.isLink()) {\n-      Path remainingPath;\n-      StringBuilder remainingPathStr = new StringBuilder();\n-      // ignore first slash\n-      for (int i = 1; i < path.length; i++) {\n-        remainingPathStr.append(\"/\").append(path[i]);\n+      /**\n+       * linkMergeSlash has been configured. The root of this mount table has\n+       * been linked to the root directory of a file system.\n+       * The first non-slash path component should be name of the mount table.\n+       */\n+      if (root.isLink()) {\n+        Path remainingPath;\n+        StringBuilder remainingPathStr = new StringBuilder();\n+        // ignore first slash\n+        for (int i = 1; i < path.length; i++) {\n+          remainingPathStr.append(\"/\").append(path[i]);\n+        }\n+        remainingPath = new Path(remainingPathStr.toString());\n+        resolveResult = new ResolveResult<T>(ResultKind.EXTERNAL_DIR,\n+            getRootLink().getTargetFileSystem(), root.fullPath, remainingPath);\n+        return resolveResult;\n       }\n-      remainingPath = new Path(remainingPathStr.toString());\n-      ResolveResult<T> res = new ResolveResult<T>(ResultKind.EXTERNAL_DIR,\n-          getRootLink().getTargetFileSystem(), root.fullPath, remainingPath);\n-      return res;\n-    }\n-    Preconditions.checkState(root.isInternalDir());\n-    INodeDir<T> curInode = getRootDir();\n+      Preconditions.checkState(root.isInternalDir());\n+      INodeDir<T> curInode = getRootDir();\n \n-    int i;\n-    // ignore first slash\n-    for (i = 1; i < path.length - (resolveLastComponent ? 0 : 1); i++) {\n-      INode<T> nextInode = curInode.resolveInternal(path[i]);\n-      if (nextInode == null) {\n-        if (hasFallbackLink()) {\n-          return new ResolveResult<T>(ResultKind.EXTERNAL_DIR,\n-              getRootFallbackLink().getTargetFileSystem(),\n-              root.fullPath, new Path(p));\n-        } else {\n-          StringBuilder failedAt = new StringBuilder(path[0]);\n-          for (int j = 1; j <= i; ++j) {\n-            failedAt.append('/').append(path[j]);\n+      // Try to resolve path in the regex mount point\n+      resolveResult = tryResolveInRegexMountpoint(p, resolveLastComponent);\n+      if (resolveResult != null) {\n+        return resolveResult;\n+      }\n+\n+      int i;\n+      // ignore first slash\n+      for (i = 1; i < path.length - (resolveLastComponent ? 0 : 1); i++) {\n+        INode<T> nextInode = curInode.resolveInternal(path[i]);\n+        if (nextInode == null) {\n+          if (hasFallbackLink()) {\n+            resolveResult = new ResolveResult<T>(ResultKind.EXTERNAL_DIR,\n+                getRootFallbackLink().getTargetFileSystem(), root.fullPath,\n+                new Path(p));\n+            return resolveResult;\n+          } else {\n+            StringBuilder failedAt = new StringBuilder(path[0]);\n+            for (int j = 1; j <= i; ++j) {\n+              failedAt.append('/').append(path[j]);\n+            }\n+            throw (new FileNotFoundException(\n+                \"File/Directory does not exist: \" + failedAt.toString()));\n           }\n-          throw (new FileNotFoundException(\n-              \"File/Directory does not exist: \" + failedAt.toString()));\n         }\n-      }\n \n-      if (nextInode.isLink()) {\n-        final INodeLink<T> link = (INodeLink<T>) nextInode;\n-        final Path remainingPath;\n-        if (i >= path.length - 1) {\n-          remainingPath = SlashPath;\n-        } else {\n-          StringBuilder remainingPathStr = new StringBuilder(\"/\" + path[i + 1]);\n-          for (int j = i + 2; j < path.length; ++j) {\n-            remainingPathStr.append('/').append(path[j]);\n+        if (nextInode.isLink()) {\n+          final INodeLink<T> link = (INodeLink<T>) nextInode;\n+          final Path remainingPath;\n+          if (i >= path.length - 1) {\n+            remainingPath = SlashPath;\n+          } else {\n+            StringBuilder remainingPathStr =\n+                new StringBuilder(\"/\" + path[i + 1]);\n+            for (int j = i + 2; j < path.length; ++j) {\n+              remainingPathStr.append('/').append(path[j]);\n+            }\n+            remainingPath = new Path(remainingPathStr.toString());\n           }\n-          remainingPath = new Path(remainingPathStr.toString());\n+          resolveResult = new ResolveResult<T>(ResultKind.EXTERNAL_DIR,\n+              link.getTargetFileSystem(), nextInode.fullPath, remainingPath);\n+          return resolveResult;\n+        } else if (nextInode.isInternalDir()) {\n+          curInode = (INodeDir<T>) nextInode;\n         }\n-        final ResolveResult<T> res =\n-            new ResolveResult<T>(ResultKind.EXTERNAL_DIR,\n-                link.getTargetFileSystem(), nextInode.fullPath, remainingPath);\n-        return res;\n-      } else if (nextInode.isInternalDir()) {\n-        curInode = (INodeDir<T>) nextInode;\n+      }\n+\n+      // We have resolved to an internal dir in mount table.\n+      Path remainingPath;\n+      if (resolveLastComponent) {\n+        remainingPath = SlashPath;\n+      } else {\n+        // note we have taken care of when path is \"/\" above\n+        // for internal dirs rem-path does not start with / since the lookup\n+        // that follows will do a children.get(remaningPath) and will have to\n+        // strip-out the initial /\n+        StringBuilder remainingPathStr = new StringBuilder(\"/\" + path[i]);\n+        for (int j = i + 1; j < path.length; ++j) {\n+          remainingPathStr.append('/').append(path[j]);\n+        }\n+        remainingPath = new Path(remainingPathStr.toString());\n+      }\n+      resolveResult = new ResolveResult<T>(ResultKind.INTERNAL_DIR,\n+          curInode.getInternalDirFs(), curInode.fullPath, remainingPath);\n+      return resolveResult;\n+    } finally {\n+      if (pathResolutionCacheCapacity > 0 && resolveResult != null) {\n+        addResolveResultToCache(p, resolveLastComponent, resolveResult);\n       }\n     }\n+  }\n \n-    // We have resolved to an internal dir in mount table.\n-    Path remainingPath;\n-    if (resolveLastComponent) {\n-      remainingPath = SlashPath;\n-    } else {\n-      // note we have taken care of when path is \"/\" above\n-      // for internal dirs rem-path does not start with / since the lookup\n-      // that follows will do a children.get(remaningPath) and will have to\n-      // strip-out the initial /\n-      StringBuilder remainingPathStr = new StringBuilder(\"/\" + path[i]);\n-      for (int j = i + 1; j < path.length; ++j) {\n-        remainingPathStr.append('/').append(path[j]);\n+  /**\n+   * Walk through all regex mount points to see\n+   * whether the path match any regex expressions.\n+   *\n+   * @param srcPath\n+   * @param resolveLastComponent\n+   * @return\n+   */\n+  protected ResolveResult<T> tryResolveInRegexMountpoint(final String srcPath,\n+      final boolean resolveLastComponent) {\n+    for (RegexMountPoint regexMountPoint : regexMountPointList) {\n+      ResolveResult resolveResult =\n+          regexMountPoint.resolve(srcPath, resolveLastComponent);\n+      if (resolveResult != null) {\n+        return resolveResult;\n       }\n-      remainingPath = new Path(remainingPathStr.toString());\n     }\n-    final ResolveResult<T> res =\n-        new ResolveResult<T>(ResultKind.INTERNAL_DIR,\n-            curInode.getInternalDirFs(), curInode.fullPath, remainingPath);\n-    return res;\n+    return null;\n+  }\n+\n+  /**\n+   * Build resolve result return to caller.\n+   *\n+   * @param resultKind\n+   * @param resolvedPathStr\n+   * @param targetOfResolvedPathStr\n+   * @param remainingPath\n+   * @return\n+   */\n+  protected ResolveResult<T> buildResolveResultForRegexMountPoint(\n+      ResultKind resultKind, String resolvedPathStr,\n+      String targetOfResolvedPathStr, Path remainingPath) {\n+    try {\n+      T targetFs = getTargetFileSystem(new URI(targetOfResolvedPathStr));\n+      return new ResolveResult<T>(resultKind, targetFs, resolvedPathStr,\n+          remainingPath);\n+    } catch (IOException ex) {\n+      LOGGER.error(String.format(\n+          \"Got Exception while build resolve result.\"\n+              + \" ResultKind:%s, resolvedPathStr:%s,\"\n+              + \" targetOfResolvedPathStr:%s, remainingPath:%s,\"\n+              + \" will return null.\",\n+          resultKind, resolvedPathStr, targetOfResolvedPathStr, remainingPath),\n+          ex);\n+      return null;\n+    } catch (URISyntaxException uex) {\n+      LOGGER.error(String.format(\n+          \"Got Exception while build resolve result.\"\n+              + \" ResultKind:%s, resolvedPathStr:%s,\"\n+              + \" targetOfResolvedPathStr:%s, remainingPath:%s,\"\n+              + \" will return null.\",\n+          resultKind, resolvedPathStr, targetOfResolvedPathStr, remainingPath),\n+          uex);\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * Return resolution cache capacity.\n+   *\n+   * @return\n+   */\n+  public int getPathResolutionCacheCapacity() {\n+    return pathResolutionCacheCapacity;\n+  }\n+\n+  private void addResolveResultToCache(final String pathStr,\n+      final Boolean resolveLastComponent,\n+      final ResolveResult<T> resolveResult) {\n+    try {\n+      cacheRWLock.writeLock().lock();\n+      String key = getResolveCacheKeyStr(pathStr, resolveLastComponent);\n+      pathResolutionCache.put(key, resolveResult);\n+    } finally {\n+      cacheRWLock.writeLock().unlock();\n+    }\n+  }\n+\n+  private ResolveResult<T> getResolveResultFromCache(final String pathStr,\n+      final Boolean resolveLastComponent) {\n+    if (pathResolutionCacheCapacity <= 0) {\n+      return null;\n+    }\n+    try {\n+      cacheRWLock.readLock().lock();\n+      String key = getResolveCacheKeyStr(pathStr, resolveLastComponent);\n+      return (ResolveResult<T>) pathResolutionCache.get(key);\n+    } finally {\n+      cacheRWLock.readLock().unlock();\n+    }\n+  }\n+\n+  public static String getResolveCacheKeyStr(final String path,\n+      Boolean resolveLastComp) {\n+    return path + \",resolveLastComp\" + resolveLastComp;\n+  }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c58b945a32a978c470be07ef47e9ed7edfff428c"}, "originalPosition": 622}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTMxODI3MA==", "bodyText": "nit: typo: give space after comma", "url": "https://github.com/apache/hadoop/pull/2185#discussion_r471318270", "createdAt": "2020-08-17T08:20:56Z", "author": {"login": "umamaheswararao"}, "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/viewfs/RegexMountPoint.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.viewfs;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.regex.PatternSyntaxException;\n+\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.apache.hadoop.classification.InterfaceStability;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.util.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.hadoop.fs.viewfs.InodeTree.SlashPath;\n+\n+/**\n+ * Regex mount point is build to implement regex based mount point.\n+ */\n+@InterfaceAudience.Private\n+@InterfaceStability.Unstable\n+class RegexMountPoint<T> {\n+  private static final Logger LOGGER =\n+      LoggerFactory.getLogger(RegexMountPoint.class.getName());\n+\n+  private InodeTree inodeTree;\n+  private String srcPathRegex;\n+  private Pattern srcPattern;\n+  private String dstPath;\n+  private String interceptorSettingsString;\n+  private List<RegexMountPointInterceptor> interceptorList;\n+\n+  public static final String SETTING_SRCREGEX_SEP = \"#.\";\n+  public static final char INTERCEPTOR_SEP = ';';\n+  public static final char INTERCEPTOR_INTERNAL_SEP = ':';\n+  // ${var},$var\n+  public static final Pattern VAR_PATTERN_IN_DEST =\n+      Pattern.compile(\"\\\\$((\\\\{\\\\w+\\\\})|(\\\\w+))\");\n+\n+  // key => $key or key = > ${key}\n+  private Map<String, Set<String>> varInDestPathMap;\n+\n+  public Map<String, Set<String>> getVarInDestPathMap() {\n+    return varInDestPathMap;\n+  }\n+\n+  RegexMountPoint(InodeTree inodeTree, String sourcePathRegex,\n+      String destPath, String settingsStr) {\n+    this.inodeTree = inodeTree;\n+    this.srcPathRegex = sourcePathRegex;\n+    this.dstPath = destPath;\n+    this.interceptorSettingsString = settingsStr;\n+    this.interceptorList = new ArrayList<>();\n+  }\n+\n+  /**\n+   * Initialize regex mount point.\n+   *\n+   * @throws IOException\n+   */\n+  public void initialize() throws IOException {\n+    try {\n+      srcPattern = Pattern.compile(srcPathRegex);\n+    } catch (PatternSyntaxException ex) {\n+      throw new IOException(\n+          \"Failed to initialized mount point due to bad src path regex:\"\n+              + srcPathRegex + \", dstPath:\" + dstPath, ex);\n+    }\n+    varInDestPathMap = getVarListInString(dstPath);\n+    initializeInterceptors();\n+  }\n+\n+  private void initializeInterceptors() throws IOException {\n+    if (interceptorSettingsString == null\n+        || interceptorSettingsString.isEmpty()) {\n+      return;\n+    }\n+    String[] interceptorStrArray =\n+        StringUtils.split(interceptorSettingsString, INTERCEPTOR_SEP);\n+    for (String interceptorStr : interceptorStrArray) {\n+      RegexMountPointInterceptor interceptor =\n+          RegexMountPointInterceptorFactory.create(interceptorStr);\n+      if (interceptor == null) {\n+        throw new IOException(\n+            \"Illegal settings String \" + interceptorSettingsString);\n+      }\n+      interceptor.initialize();\n+      interceptorList.add(interceptor);\n+    }\n+  }\n+\n+  /**\n+   * Get $var1 and $var2 style variables in string.\n+   *\n+   * @param input\n+   * @return\n+   */\n+  public static Map<String, Set<String>> getVarListInString(String input) {\n+    Map<String, Set<String>> varMap = new HashMap<>();\n+    Matcher matcher = VAR_PATTERN_IN_DEST.matcher(input);\n+    while (matcher.find()) {\n+      // $var or ${var}\n+      String varName = matcher.group(0);\n+      // var or {var}\n+      String strippedVarName = matcher.group(1);\n+      if (strippedVarName.startsWith(\"{\")) {\n+        // {varName} = > varName\n+        strippedVarName =\n+            strippedVarName.substring(1, strippedVarName.length() - 1);\n+      }\n+      varMap.putIfAbsent(strippedVarName, new HashSet<>());\n+      varMap.get(strippedVarName).add(varName);\n+    }\n+    return varMap;\n+  }\n+\n+  public String getSrcPathRegex() {\n+    return srcPathRegex;\n+  }\n+\n+  public Pattern getSrcPattern() {\n+    return srcPattern;\n+  }\n+\n+  public String getDstPath() {\n+    return dstPath;\n+  }\n+\n+  public static Pattern getVarPatternInDest() {\n+    return VAR_PATTERN_IN_DEST;\n+  }\n+\n+  /**\n+   * Get resolved path from regex mount points.\n+   * @param srcPath\n+   * @param resolveLastComponent\n+   * @return\n+   */\n+  public InodeTree.ResolveResult<T> resolve(final String srcPath,\n+      final boolean resolveLastComponent) {\n+    String pathStrToResolve = srcPath;\n+    if (!resolveLastComponent) {\n+      int lastSlashIndex = srcPath.lastIndexOf(SlashPath.toString());\n+      if (lastSlashIndex == -1) {\n+        return null;\n+      }\n+      pathStrToResolve = srcPath.substring(0, lastSlashIndex);\n+    }\n+    for (RegexMountPointInterceptor interceptor : interceptorList) {\n+      pathStrToResolve = interceptor.interceptSource(pathStrToResolve);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c58b945a32a978c470be07ef47e9ed7edfff428c"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTYwOTYyMA==", "bodyText": "Since this patch already big and this cache improvement seems to be generic for all cases, can we file separate Sub JIRA for this cache part?", "url": "https://github.com/apache/hadoop/pull/2185#discussion_r471609620", "createdAt": "2020-08-17T16:51:50Z", "author": {"login": "umamaheswararao"}, "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/viewfs/InodeTree.java", "diffHunk": "@@ -646,102 +714,222 @@ boolean isInternalDir() {\n   }\n \n   /**\n-   * Resolve the pathname p relative to root InodeDir\n+   * Resolve the pathname p relative to root InodeDir.\n    * @param p - input path\n    * @param resolveLastComponent\n    * @return ResolveResult which allows further resolution of the remaining path\n    * @throws FileNotFoundException\n    */\n   ResolveResult<T> resolve(final String p, final boolean resolveLastComponent)\n       throws FileNotFoundException {\n-    String[] path = breakIntoPathComponents(p);\n-    if (path.length <= 1) { // special case for when path is \"/\"\n-      T targetFs = root.isInternalDir() ?\n-          getRootDir().getInternalDirFs() : getRootLink().getTargetFileSystem();\n-      ResolveResult<T> res = new ResolveResult<T>(ResultKind.INTERNAL_DIR,\n-          targetFs, root.fullPath, SlashPath);\n-      return res;\n-    }\n+    ResolveResult<T> resolveResult = null;\n+    resolveResult = getResolveResultFromCache(p, resolveLastComponent);\n+    if (resolveResult != null) {\n+      return resolveResult;\n+    }\n+\n+    try {\n+      String[] path = breakIntoPathComponents(p);\n+      if (path.length <= 1) { // special case for when path is \"/\"\n+        T targetFs = root.isInternalDir() ?\n+            getRootDir().getInternalDirFs()\n+            : getRootLink().getTargetFileSystem();\n+        resolveResult = new ResolveResult<T>(ResultKind.INTERNAL_DIR,\n+            targetFs, root.fullPath, SlashPath);\n+        return resolveResult;\n+      }\n \n-    /**\n-     * linkMergeSlash has been configured. The root of this mount table has\n-     * been linked to the root directory of a file system.\n-     * The first non-slash path component should be name of the mount table.\n-     */\n-    if (root.isLink()) {\n-      Path remainingPath;\n-      StringBuilder remainingPathStr = new StringBuilder();\n-      // ignore first slash\n-      for (int i = 1; i < path.length; i++) {\n-        remainingPathStr.append(\"/\").append(path[i]);\n+      /**\n+       * linkMergeSlash has been configured. The root of this mount table has\n+       * been linked to the root directory of a file system.\n+       * The first non-slash path component should be name of the mount table.\n+       */\n+      if (root.isLink()) {\n+        Path remainingPath;\n+        StringBuilder remainingPathStr = new StringBuilder();\n+        // ignore first slash\n+        for (int i = 1; i < path.length; i++) {\n+          remainingPathStr.append(\"/\").append(path[i]);\n+        }\n+        remainingPath = new Path(remainingPathStr.toString());\n+        resolveResult = new ResolveResult<T>(ResultKind.EXTERNAL_DIR,\n+            getRootLink().getTargetFileSystem(), root.fullPath, remainingPath);\n+        return resolveResult;\n       }\n-      remainingPath = new Path(remainingPathStr.toString());\n-      ResolveResult<T> res = new ResolveResult<T>(ResultKind.EXTERNAL_DIR,\n-          getRootLink().getTargetFileSystem(), root.fullPath, remainingPath);\n-      return res;\n-    }\n-    Preconditions.checkState(root.isInternalDir());\n-    INodeDir<T> curInode = getRootDir();\n+      Preconditions.checkState(root.isInternalDir());\n+      INodeDir<T> curInode = getRootDir();\n \n-    int i;\n-    // ignore first slash\n-    for (i = 1; i < path.length - (resolveLastComponent ? 0 : 1); i++) {\n-      INode<T> nextInode = curInode.resolveInternal(path[i]);\n-      if (nextInode == null) {\n-        if (hasFallbackLink()) {\n-          return new ResolveResult<T>(ResultKind.EXTERNAL_DIR,\n-              getRootFallbackLink().getTargetFileSystem(),\n-              root.fullPath, new Path(p));\n-        } else {\n-          StringBuilder failedAt = new StringBuilder(path[0]);\n-          for (int j = 1; j <= i; ++j) {\n-            failedAt.append('/').append(path[j]);\n+      // Try to resolve path in the regex mount point\n+      resolveResult = tryResolveInRegexMountpoint(p, resolveLastComponent);\n+      if (resolveResult != null) {\n+        return resolveResult;\n+      }\n+\n+      int i;\n+      // ignore first slash\n+      for (i = 1; i < path.length - (resolveLastComponent ? 0 : 1); i++) {\n+        INode<T> nextInode = curInode.resolveInternal(path[i]);\n+        if (nextInode == null) {\n+          if (hasFallbackLink()) {\n+            resolveResult = new ResolveResult<T>(ResultKind.EXTERNAL_DIR,\n+                getRootFallbackLink().getTargetFileSystem(), root.fullPath,\n+                new Path(p));\n+            return resolveResult;\n+          } else {\n+            StringBuilder failedAt = new StringBuilder(path[0]);\n+            for (int j = 1; j <= i; ++j) {\n+              failedAt.append('/').append(path[j]);\n+            }\n+            throw (new FileNotFoundException(\n+                \"File/Directory does not exist: \" + failedAt.toString()));\n           }\n-          throw (new FileNotFoundException(\n-              \"File/Directory does not exist: \" + failedAt.toString()));\n         }\n-      }\n \n-      if (nextInode.isLink()) {\n-        final INodeLink<T> link = (INodeLink<T>) nextInode;\n-        final Path remainingPath;\n-        if (i >= path.length - 1) {\n-          remainingPath = SlashPath;\n-        } else {\n-          StringBuilder remainingPathStr = new StringBuilder(\"/\" + path[i + 1]);\n-          for (int j = i + 2; j < path.length; ++j) {\n-            remainingPathStr.append('/').append(path[j]);\n+        if (nextInode.isLink()) {\n+          final INodeLink<T> link = (INodeLink<T>) nextInode;\n+          final Path remainingPath;\n+          if (i >= path.length - 1) {\n+            remainingPath = SlashPath;\n+          } else {\n+            StringBuilder remainingPathStr =\n+                new StringBuilder(\"/\" + path[i + 1]);\n+            for (int j = i + 2; j < path.length; ++j) {\n+              remainingPathStr.append('/').append(path[j]);\n+            }\n+            remainingPath = new Path(remainingPathStr.toString());\n           }\n-          remainingPath = new Path(remainingPathStr.toString());\n+          resolveResult = new ResolveResult<T>(ResultKind.EXTERNAL_DIR,\n+              link.getTargetFileSystem(), nextInode.fullPath, remainingPath);\n+          return resolveResult;\n+        } else if (nextInode.isInternalDir()) {\n+          curInode = (INodeDir<T>) nextInode;\n         }\n-        final ResolveResult<T> res =\n-            new ResolveResult<T>(ResultKind.EXTERNAL_DIR,\n-                link.getTargetFileSystem(), nextInode.fullPath, remainingPath);\n-        return res;\n-      } else if (nextInode.isInternalDir()) {\n-        curInode = (INodeDir<T>) nextInode;\n+      }\n+\n+      // We have resolved to an internal dir in mount table.\n+      Path remainingPath;\n+      if (resolveLastComponent) {\n+        remainingPath = SlashPath;\n+      } else {\n+        // note we have taken care of when path is \"/\" above\n+        // for internal dirs rem-path does not start with / since the lookup\n+        // that follows will do a children.get(remaningPath) and will have to\n+        // strip-out the initial /\n+        StringBuilder remainingPathStr = new StringBuilder(\"/\" + path[i]);\n+        for (int j = i + 1; j < path.length; ++j) {\n+          remainingPathStr.append('/').append(path[j]);\n+        }\n+        remainingPath = new Path(remainingPathStr.toString());\n+      }\n+      resolveResult = new ResolveResult<T>(ResultKind.INTERNAL_DIR,\n+          curInode.getInternalDirFs(), curInode.fullPath, remainingPath);\n+      return resolveResult;\n+    } finally {\n+      if (pathResolutionCacheCapacity > 0 && resolveResult != null) {\n+        addResolveResultToCache(p, resolveLastComponent, resolveResult);\n       }\n     }\n+  }\n \n-    // We have resolved to an internal dir in mount table.\n-    Path remainingPath;\n-    if (resolveLastComponent) {\n-      remainingPath = SlashPath;\n-    } else {\n-      // note we have taken care of when path is \"/\" above\n-      // for internal dirs rem-path does not start with / since the lookup\n-      // that follows will do a children.get(remaningPath) and will have to\n-      // strip-out the initial /\n-      StringBuilder remainingPathStr = new StringBuilder(\"/\" + path[i]);\n-      for (int j = i + 1; j < path.length; ++j) {\n-        remainingPathStr.append('/').append(path[j]);\n+  /**\n+   * Walk through all regex mount points to see\n+   * whether the path match any regex expressions.\n+   *\n+   * @param srcPath\n+   * @param resolveLastComponent\n+   * @return\n+   */\n+  protected ResolveResult<T> tryResolveInRegexMountpoint(final String srcPath,\n+      final boolean resolveLastComponent) {\n+    for (RegexMountPoint regexMountPoint : regexMountPointList) {\n+      ResolveResult resolveResult =\n+          regexMountPoint.resolve(srcPath, resolveLastComponent);\n+      if (resolveResult != null) {\n+        return resolveResult;\n       }\n-      remainingPath = new Path(remainingPathStr.toString());\n     }\n-    final ResolveResult<T> res =\n-        new ResolveResult<T>(ResultKind.INTERNAL_DIR,\n-            curInode.getInternalDirFs(), curInode.fullPath, remainingPath);\n-    return res;\n+    return null;\n+  }\n+\n+  /**\n+   * Build resolve result return to caller.\n+   *\n+   * @param resultKind\n+   * @param resolvedPathStr\n+   * @param targetOfResolvedPathStr\n+   * @param remainingPath\n+   * @return\n+   */\n+  protected ResolveResult<T> buildResolveResultForRegexMountPoint(\n+      ResultKind resultKind, String resolvedPathStr,\n+      String targetOfResolvedPathStr, Path remainingPath) {\n+    try {\n+      T targetFs = getTargetFileSystem(new URI(targetOfResolvedPathStr));\n+      return new ResolveResult<T>(resultKind, targetFs, resolvedPathStr,\n+          remainingPath);\n+    } catch (IOException ex) {\n+      LOGGER.error(String.format(\n+          \"Got Exception while build resolve result.\"\n+              + \" ResultKind:%s, resolvedPathStr:%s,\"\n+              + \" targetOfResolvedPathStr:%s, remainingPath:%s,\"\n+              + \" will return null.\",\n+          resultKind, resolvedPathStr, targetOfResolvedPathStr, remainingPath),\n+          ex);\n+      return null;\n+    } catch (URISyntaxException uex) {\n+      LOGGER.error(String.format(\n+          \"Got Exception while build resolve result.\"\n+              + \" ResultKind:%s, resolvedPathStr:%s,\"\n+              + \" targetOfResolvedPathStr:%s, remainingPath:%s,\"\n+              + \" will return null.\",\n+          resultKind, resolvedPathStr, targetOfResolvedPathStr, remainingPath),\n+          uex);\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * Return resolution cache capacity.\n+   *\n+   * @return\n+   */\n+  public int getPathResolutionCacheCapacity() {\n+    return pathResolutionCacheCapacity;\n+  }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c58b945a32a978c470be07ef47e9ed7edfff428c"}, "originalPosition": 591}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY0OTI2Mg==", "bodyText": "Instead of asking users to disable, isn't it the better way is to add getTargetFileSystem(uri, userCache=true/false) method?\nSo, that the users already using other mount points need not disable for the sake if regex based mount points right?", "url": "https://github.com/apache/hadoop/pull/2185#discussion_r471649262", "createdAt": "2020-08-17T17:31:22Z", "author": {"login": "umamaheswararao"}, "path": "hadoop-hdfs-project/hadoop-hdfs/src/site/markdown/ViewFs.md", "diffHunk": "@@ -366,6 +366,82 @@ Don't want to change scheme or difficult to copy mount-table configurations to a\n \n Please refer to the [View File System Overload Scheme Guide](./ViewFsOverloadScheme.html)\n \n+Regex Pattern Based Mount Points\n+--------------------------------\n+\n+The view file system mount points were a Key-Value based mapping system. It is not friendly for user cases which mapping config could be abstracted to rules. E.g. Users want to provide a GCS bucket per user and there might be thousands of users in total. The old key-value based approach won't work well for several reasons:\n+\n+1. The mount table is used by FileSystem clients. There's a cost to spread the config to all clients and we should avoid it if possible. The [View File System Overload Scheme Guide](./ViewFsOverloadScheme.html) could help the distribution by central mount table management. But the mount table still have to be updated on every change. The change could be greatly avoided if provide a rule-based mount table..\n+\n+2. The client have to understand all the KVs in the mount table. This is not ideal when the mountable grows to thousands of items. E.g. thousands of file systems might be initialized even users only need one. And the config itself will become bloated at scale.\n+\n+### Understand the Difference\n+\n+In the key-value based mount table, view file system treats every mount point as a partition. There's several file system APIs which will lead to operation on all partitions. E.g. there's an HDFS cluster with multiple mount. Users want to run \u201chadoop fs -put file viewfs://hdfs.namenode.apache.org/tmp/\u201d cmd to copy data from local disk to our HDFS cluster. The cmd will trigger ViewFileSystem to call setVerifyChecksum() method which will initialize the file system for every mount point.\n+For a regex-base rule mount table entry, we couldn't know what's corresponding path until parsing. So the regex based mount table entry will be ignored on such cases and the file system will be created upon accessing. The inner cache of ViewFs is also not available for regex-base mount points now as it assumes target file system doesn't change after viewfs initialization. Please disable it if you want to use regex-base mount table. We also need to change the rename strategy to SAME_FILESYSTEM_ACROSS_MOUNTPOINT for the same reason.\n+```xml\n+<property>\n+    <name>fs.viewfs.enable.inner.cache</name>\n+    <value>false</value>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c58b945a32a978c470be07ef47e9ed7edfff428c"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY1ODE1NQ==", "bodyText": "same as above comment", "url": "https://github.com/apache/hadoop/pull/2185#discussion_r471658155", "createdAt": "2020-08-17T17:48:16Z", "author": {"login": "umamaheswararao"}, "path": "hadoop-hdfs-project/hadoop-hdfs/src/test/java/org/apache/hadoop/fs/viewfs/TestViewFileSystemLinkRegex.java", "diffHunk": "@@ -0,0 +1,320 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.viewfs;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.FSDataOutputStream;\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.FileSystemTestHelper;\n+import org.apache.hadoop.fs.FsConstants;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.hdfs.DFSConfigKeys;\n+import org.apache.hadoop.hdfs.MiniDFSCluster;\n+import org.apache.hadoop.hdfs.MiniDFSNNTopology;\n+import org.apache.hadoop.test.GenericTestUtils;\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.hadoop.fs.viewfs.Constants.CONFIG_VIEWFS_ENABLE_INNER_CACHE;\n+import static org.apache.hadoop.fs.viewfs.RegexMountPoint.INTERCEPTOR_INTERNAL_SEP;\n+\n+/**\n+ * Test linkRegex node type for view file system.\n+ */\n+public class TestViewFileSystemLinkRegex extends ViewFileSystemBaseTest {\n+  public static final Logger LOGGER =\n+      LoggerFactory.getLogger(TestViewFileSystemLinkRegex.class);\n+\n+  private static FileSystem fsDefault;\n+  private static MiniDFSCluster cluster;\n+  private static Configuration clusterConfig;\n+  private static final int NAME_SPACES_COUNT = 3;\n+  private static final int DATA_NODES_COUNT = 3;\n+  private static final int FS_INDEX_DEFAULT = 0;\n+  private static final FileSystem[] FS_HDFS = new FileSystem[NAME_SPACES_COUNT];\n+  private static final String CLUSTER_NAME =\n+      \"TestViewFileSystemLinkRegexCluster\";\n+  private static final File TEST_DIR = GenericTestUtils\n+      .getTestDir(TestViewFileSystemLinkRegex.class.getSimpleName());\n+  private static final String TEST_BASE_PATH =\n+      \"/tmp/TestViewFileSystemLinkRegex\";\n+\n+  @Override\n+  protected FileSystemTestHelper createFileSystemHelper() {\n+    return new FileSystemTestHelper(TEST_BASE_PATH);\n+  }\n+\n+  @BeforeClass\n+  public static void clusterSetupAtBeginning() throws IOException {\n+    SupportsBlocks = true;\n+    clusterConfig = ViewFileSystemTestSetup.createConfig();\n+    clusterConfig.setBoolean(\n+        DFSConfigKeys.DFS_NAMENODE_DELEGATION_TOKEN_ALWAYS_USE_KEY,\n+        true);\n+    cluster = new MiniDFSCluster.Builder(clusterConfig).nnTopology(\n+        MiniDFSNNTopology.simpleFederatedTopology(NAME_SPACES_COUNT))\n+        .numDataNodes(DATA_NODES_COUNT).build();\n+    cluster.waitClusterUp();\n+\n+    for (int i = 0; i < NAME_SPACES_COUNT; i++) {\n+      FS_HDFS[i] = cluster.getFileSystem(i);\n+    }\n+    fsDefault = FS_HDFS[FS_INDEX_DEFAULT];\n+  }\n+\n+  @AfterClass\n+  public static void clusterShutdownAtEnd() throws Exception {\n+    if (cluster != null) {\n+      cluster.shutdown();\n+    }\n+  }\n+\n+  @Override\n+  @Before\n+  public void setUp() throws Exception {\n+    fsTarget = fsDefault;\n+    super.setUp();\n+  }\n+\n+  /**\n+   * Override this so that we don't set the targetTestRoot to any path under the\n+   * root of the FS, and so that we don't try to delete the test dir, but rather\n+   * only its contents.\n+   */\n+  @Override\n+  void initializeTargetTestRoot() throws IOException {\n+    targetTestRoot = fsDefault.makeQualified(new Path(\"/\"));\n+    for (FileStatus status : fsDefault.listStatus(targetTestRoot)) {\n+      fsDefault.delete(status.getPath(), true);\n+    }\n+  }\n+\n+  @Override\n+  void setupMountPoints() {\n+    super.setupMountPoints();\n+  }\n+\n+  @Override\n+  int getExpectedDelegationTokenCount() {\n+    return 1; // all point to the same fs so 1 unique token\n+  }\n+\n+  @Override\n+  int getExpectedDelegationTokenCountWithCredentials() {\n+    return 1;\n+  }\n+\n+  public String buildReplaceInterceptorSettingString(String srcRegex,\n+      String replaceString) {\n+    return\n+        RegexMountPointInterceptorType.REPLACE_RESOLVED_DST_PATH.getConfigName()\n+            + INTERCEPTOR_INTERNAL_SEP + srcRegex + INTERCEPTOR_INTERNAL_SEP\n+            + replaceString;\n+  }\n+\n+  public String linkInterceptorSettings(\n+      List<String> interceptorSettingStrList) {\n+    StringBuilder stringBuilder = new StringBuilder();\n+    int listSize = interceptorSettingStrList.size();\n+    for (int i = 0; i < listSize; ++i) {\n+      stringBuilder.append(interceptorSettingStrList.get(i));\n+      if (i < listSize - 1) {\n+        stringBuilder.append(RegexMountPoint.INTERCEPTOR_SEP);\n+      }\n+    }\n+    return stringBuilder.toString();\n+  }\n+\n+  @Test\n+  public void testConfLinkRegexIndexMapping() throws Exception {\n+    conf.setBoolean(CONFIG_VIEWFS_ENABLE_INNER_CACHE, false);\n+    // (^/(\\w+),/targetTestRoot/$1)\n+    // => /targetTestRoot/testConfLinkRegexIndexMapping1\n+    URI viewFsUri =\n+        new URI(FsConstants.VIEWFS_SCHEME, CLUSTER_NAME, \"/\", null, null);\n+    String regexStr = \"^/(\\\\w+)\";\n+    String dstPathStr = targetTestRoot + \"$1\";\n+    Path srcPath = new Path(\"/testConfLinkRegexIndexMapping1\");\n+    Path expectedResolveResult =\n+        new Path(dstPathStr.replace(\"$1\", \"testConfLinkRegexIndexMapping1\"));\n+    FSDataOutputStream outputStream = fsTarget.create((expectedResolveResult));\n+    fsTarget.listStatus(expectedResolveResult);\n+    outputStream.close();\n+    ConfigUtil.addLinkRegex(conf, CLUSTER_NAME, regexStr, dstPathStr, null);\n+    FileSystem vfs = FileSystem.get(viewFsUri, conf);\n+    Assert.assertTrue(expectedResolveResult.equals(vfs.resolvePath(srcPath)));\n+    Assert.assertEquals(0L, vfs.getFileStatus(srcPath).getLen());\n+\n+    // Test ${1} format\n+    // ^/(\\w+, /targetTestRoot/${1})\n+    // => /targetTestRoot/testConfLinkRegexIndexMapping2\n+    dstPathStr = targetTestRoot + \"${1}\";\n+    srcPath = new Path(\"/testConfLinkRegexIndexMapping2\");\n+    expectedResolveResult =\n+        new Path(dstPathStr.replace(\"${1}\", \"testConfLinkRegexIndexMapping2\"));\n+    outputStream = fsTarget.create(expectedResolveResult);\n+    fsTarget.listStatus(expectedResolveResult);\n+    outputStream.close();\n+    ConfigUtil.addLinkRegex(conf, CLUSTER_NAME, regexStr, dstPathStr, null);\n+    vfs = FileSystem.get(viewFsUri, conf);\n+    Assert.assertTrue(expectedResolveResult.equals(vfs.resolvePath(srcPath)));\n+    Assert.assertEquals(0L, vfs.getFileStatus(srcPath).getLen());\n+\n+    //(^/(\\w+)/file1, /targetTestRoot/$1)\n+    // = > /targetTestRoot/testConfLinkRegexIndexMapping3/file1\n+    dstPathStr = targetTestRoot + \"$1\";\n+    srcPath = new Path(\"/testConfLinkRegexIndexMapping3/file1\");\n+    expectedResolveResult = new Path(\n+        dstPathStr.replace(\"$1\", \"testConfLinkRegexIndexMapping3/file1\"));\n+    outputStream = fsTarget.create(expectedResolveResult);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c58b945a32a978c470be07ef47e9ed7edfff428c"}, "originalPosition": 196}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY1ODgwMQ==", "bodyText": "you may want to close vfs as well?", "url": "https://github.com/apache/hadoop/pull/2185#discussion_r471658801", "createdAt": "2020-08-17T17:49:20Z", "author": {"login": "umamaheswararao"}, "path": "hadoop-hdfs-project/hadoop-hdfs/src/test/java/org/apache/hadoop/fs/viewfs/TestViewFileSystemLinkRegex.java", "diffHunk": "@@ -0,0 +1,320 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.viewfs;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.FSDataOutputStream;\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.FileSystemTestHelper;\n+import org.apache.hadoop.fs.FsConstants;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.hdfs.DFSConfigKeys;\n+import org.apache.hadoop.hdfs.MiniDFSCluster;\n+import org.apache.hadoop.hdfs.MiniDFSNNTopology;\n+import org.apache.hadoop.test.GenericTestUtils;\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.hadoop.fs.viewfs.Constants.CONFIG_VIEWFS_ENABLE_INNER_CACHE;\n+import static org.apache.hadoop.fs.viewfs.RegexMountPoint.INTERCEPTOR_INTERNAL_SEP;\n+\n+/**\n+ * Test linkRegex node type for view file system.\n+ */\n+public class TestViewFileSystemLinkRegex extends ViewFileSystemBaseTest {\n+  public static final Logger LOGGER =\n+      LoggerFactory.getLogger(TestViewFileSystemLinkRegex.class);\n+\n+  private static FileSystem fsDefault;\n+  private static MiniDFSCluster cluster;\n+  private static Configuration clusterConfig;\n+  private static final int NAME_SPACES_COUNT = 3;\n+  private static final int DATA_NODES_COUNT = 3;\n+  private static final int FS_INDEX_DEFAULT = 0;\n+  private static final FileSystem[] FS_HDFS = new FileSystem[NAME_SPACES_COUNT];\n+  private static final String CLUSTER_NAME =\n+      \"TestViewFileSystemLinkRegexCluster\";\n+  private static final File TEST_DIR = GenericTestUtils\n+      .getTestDir(TestViewFileSystemLinkRegex.class.getSimpleName());\n+  private static final String TEST_BASE_PATH =\n+      \"/tmp/TestViewFileSystemLinkRegex\";\n+\n+  @Override\n+  protected FileSystemTestHelper createFileSystemHelper() {\n+    return new FileSystemTestHelper(TEST_BASE_PATH);\n+  }\n+\n+  @BeforeClass\n+  public static void clusterSetupAtBeginning() throws IOException {\n+    SupportsBlocks = true;\n+    clusterConfig = ViewFileSystemTestSetup.createConfig();\n+    clusterConfig.setBoolean(\n+        DFSConfigKeys.DFS_NAMENODE_DELEGATION_TOKEN_ALWAYS_USE_KEY,\n+        true);\n+    cluster = new MiniDFSCluster.Builder(clusterConfig).nnTopology(\n+        MiniDFSNNTopology.simpleFederatedTopology(NAME_SPACES_COUNT))\n+        .numDataNodes(DATA_NODES_COUNT).build();\n+    cluster.waitClusterUp();\n+\n+    for (int i = 0; i < NAME_SPACES_COUNT; i++) {\n+      FS_HDFS[i] = cluster.getFileSystem(i);\n+    }\n+    fsDefault = FS_HDFS[FS_INDEX_DEFAULT];\n+  }\n+\n+  @AfterClass\n+  public static void clusterShutdownAtEnd() throws Exception {\n+    if (cluster != null) {\n+      cluster.shutdown();\n+    }\n+  }\n+\n+  @Override\n+  @Before\n+  public void setUp() throws Exception {\n+    fsTarget = fsDefault;\n+    super.setUp();\n+  }\n+\n+  /**\n+   * Override this so that we don't set the targetTestRoot to any path under the\n+   * root of the FS, and so that we don't try to delete the test dir, but rather\n+   * only its contents.\n+   */\n+  @Override\n+  void initializeTargetTestRoot() throws IOException {\n+    targetTestRoot = fsDefault.makeQualified(new Path(\"/\"));\n+    for (FileStatus status : fsDefault.listStatus(targetTestRoot)) {\n+      fsDefault.delete(status.getPath(), true);\n+    }\n+  }\n+\n+  @Override\n+  void setupMountPoints() {\n+    super.setupMountPoints();\n+  }\n+\n+  @Override\n+  int getExpectedDelegationTokenCount() {\n+    return 1; // all point to the same fs so 1 unique token\n+  }\n+\n+  @Override\n+  int getExpectedDelegationTokenCountWithCredentials() {\n+    return 1;\n+  }\n+\n+  public String buildReplaceInterceptorSettingString(String srcRegex,\n+      String replaceString) {\n+    return\n+        RegexMountPointInterceptorType.REPLACE_RESOLVED_DST_PATH.getConfigName()\n+            + INTERCEPTOR_INTERNAL_SEP + srcRegex + INTERCEPTOR_INTERNAL_SEP\n+            + replaceString;\n+  }\n+\n+  public String linkInterceptorSettings(\n+      List<String> interceptorSettingStrList) {\n+    StringBuilder stringBuilder = new StringBuilder();\n+    int listSize = interceptorSettingStrList.size();\n+    for (int i = 0; i < listSize; ++i) {\n+      stringBuilder.append(interceptorSettingStrList.get(i));\n+      if (i < listSize - 1) {\n+        stringBuilder.append(RegexMountPoint.INTERCEPTOR_SEP);\n+      }\n+    }\n+    return stringBuilder.toString();\n+  }\n+\n+  @Test\n+  public void testConfLinkRegexIndexMapping() throws Exception {\n+    conf.setBoolean(CONFIG_VIEWFS_ENABLE_INNER_CACHE, false);\n+    // (^/(\\w+),/targetTestRoot/$1)\n+    // => /targetTestRoot/testConfLinkRegexIndexMapping1\n+    URI viewFsUri =\n+        new URI(FsConstants.VIEWFS_SCHEME, CLUSTER_NAME, \"/\", null, null);\n+    String regexStr = \"^/(\\\\w+)\";\n+    String dstPathStr = targetTestRoot + \"$1\";\n+    Path srcPath = new Path(\"/testConfLinkRegexIndexMapping1\");\n+    Path expectedResolveResult =\n+        new Path(dstPathStr.replace(\"$1\", \"testConfLinkRegexIndexMapping1\"));\n+    FSDataOutputStream outputStream = fsTarget.create((expectedResolveResult));\n+    fsTarget.listStatus(expectedResolveResult);\n+    outputStream.close();\n+    ConfigUtil.addLinkRegex(conf, CLUSTER_NAME, regexStr, dstPathStr, null);\n+    FileSystem vfs = FileSystem.get(viewFsUri, conf);\n+    Assert.assertTrue(expectedResolveResult.equals(vfs.resolvePath(srcPath)));\n+    Assert.assertEquals(0L, vfs.getFileStatus(srcPath).getLen());\n+\n+    // Test ${1} format\n+    // ^/(\\w+, /targetTestRoot/${1})\n+    // => /targetTestRoot/testConfLinkRegexIndexMapping2\n+    dstPathStr = targetTestRoot + \"${1}\";\n+    srcPath = new Path(\"/testConfLinkRegexIndexMapping2\");\n+    expectedResolveResult =\n+        new Path(dstPathStr.replace(\"${1}\", \"testConfLinkRegexIndexMapping2\"));\n+    outputStream = fsTarget.create(expectedResolveResult);\n+    fsTarget.listStatus(expectedResolveResult);\n+    outputStream.close();\n+    ConfigUtil.addLinkRegex(conf, CLUSTER_NAME, regexStr, dstPathStr, null);\n+    vfs = FileSystem.get(viewFsUri, conf);\n+    Assert.assertTrue(expectedResolveResult.equals(vfs.resolvePath(srcPath)));\n+    Assert.assertEquals(0L, vfs.getFileStatus(srcPath).getLen());\n+\n+    //(^/(\\w+)/file1, /targetTestRoot/$1)\n+    // = > /targetTestRoot/testConfLinkRegexIndexMapping3/file1\n+    dstPathStr = targetTestRoot + \"$1\";\n+    srcPath = new Path(\"/testConfLinkRegexIndexMapping3/file1\");\n+    expectedResolveResult = new Path(\n+        dstPathStr.replace(\"$1\", \"testConfLinkRegexIndexMapping3/file1\"));\n+    outputStream = fsTarget.create(expectedResolveResult);\n+    fsTarget.listStatus(expectedResolveResult);\n+    outputStream.close();\n+    ConfigUtil.addLinkRegex(conf, CLUSTER_NAME, regexStr, dstPathStr, null);\n+    vfs = FileSystem.get(viewFsUri, conf);\n+    Assert.assertTrue(expectedResolveResult.equals(vfs.resolvePath(srcPath)));\n+    Assert.assertEquals(0L, vfs.getFileStatus(srcPath).getLen());\n+\n+    //(^/(\\w+)/file1, /targetTestRoot/$1/)\n+    // = > /targetTestRoot/testConfLinkRegexIndexMapping4/file1\n+    dstPathStr = targetTestRoot + \"$1/\";\n+    srcPath = new Path(\"/testConfLinkRegexIndexMapping4/file1\");\n+    expectedResolveResult = new Path(\n+        dstPathStr.replace(\"$1\", \"testConfLinkRegexIndexMapping4/file1\"));\n+    outputStream = fsTarget.create(expectedResolveResult);\n+    fsTarget.listStatus(expectedResolveResult);\n+    outputStream.close();\n+    ConfigUtil.addLinkRegex(conf, CLUSTER_NAME, regexStr, dstPathStr, null);\n+    vfs = FileSystem.get(viewFsUri, conf);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c58b945a32a978c470be07ef47e9ed7edfff428c"}, "originalPosition": 214}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY1OTI2MQ==", "bodyText": "same as above...please take care of other similar places.", "url": "https://github.com/apache/hadoop/pull/2185#discussion_r471659261", "createdAt": "2020-08-17T17:50:04Z", "author": {"login": "umamaheswararao"}, "path": "hadoop-hdfs-project/hadoop-hdfs/src/test/java/org/apache/hadoop/fs/viewfs/TestViewFileSystemLinkRegex.java", "diffHunk": "@@ -0,0 +1,320 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.viewfs;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.FSDataOutputStream;\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.FileSystemTestHelper;\n+import org.apache.hadoop.fs.FsConstants;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.hdfs.DFSConfigKeys;\n+import org.apache.hadoop.hdfs.MiniDFSCluster;\n+import org.apache.hadoop.hdfs.MiniDFSNNTopology;\n+import org.apache.hadoop.test.GenericTestUtils;\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.hadoop.fs.viewfs.Constants.CONFIG_VIEWFS_ENABLE_INNER_CACHE;\n+import static org.apache.hadoop.fs.viewfs.RegexMountPoint.INTERCEPTOR_INTERNAL_SEP;\n+\n+/**\n+ * Test linkRegex node type for view file system.\n+ */\n+public class TestViewFileSystemLinkRegex extends ViewFileSystemBaseTest {\n+  public static final Logger LOGGER =\n+      LoggerFactory.getLogger(TestViewFileSystemLinkRegex.class);\n+\n+  private static FileSystem fsDefault;\n+  private static MiniDFSCluster cluster;\n+  private static Configuration clusterConfig;\n+  private static final int NAME_SPACES_COUNT = 3;\n+  private static final int DATA_NODES_COUNT = 3;\n+  private static final int FS_INDEX_DEFAULT = 0;\n+  private static final FileSystem[] FS_HDFS = new FileSystem[NAME_SPACES_COUNT];\n+  private static final String CLUSTER_NAME =\n+      \"TestViewFileSystemLinkRegexCluster\";\n+  private static final File TEST_DIR = GenericTestUtils\n+      .getTestDir(TestViewFileSystemLinkRegex.class.getSimpleName());\n+  private static final String TEST_BASE_PATH =\n+      \"/tmp/TestViewFileSystemLinkRegex\";\n+\n+  @Override\n+  protected FileSystemTestHelper createFileSystemHelper() {\n+    return new FileSystemTestHelper(TEST_BASE_PATH);\n+  }\n+\n+  @BeforeClass\n+  public static void clusterSetupAtBeginning() throws IOException {\n+    SupportsBlocks = true;\n+    clusterConfig = ViewFileSystemTestSetup.createConfig();\n+    clusterConfig.setBoolean(\n+        DFSConfigKeys.DFS_NAMENODE_DELEGATION_TOKEN_ALWAYS_USE_KEY,\n+        true);\n+    cluster = new MiniDFSCluster.Builder(clusterConfig).nnTopology(\n+        MiniDFSNNTopology.simpleFederatedTopology(NAME_SPACES_COUNT))\n+        .numDataNodes(DATA_NODES_COUNT).build();\n+    cluster.waitClusterUp();\n+\n+    for (int i = 0; i < NAME_SPACES_COUNT; i++) {\n+      FS_HDFS[i] = cluster.getFileSystem(i);\n+    }\n+    fsDefault = FS_HDFS[FS_INDEX_DEFAULT];\n+  }\n+\n+  @AfterClass\n+  public static void clusterShutdownAtEnd() throws Exception {\n+    if (cluster != null) {\n+      cluster.shutdown();\n+    }\n+  }\n+\n+  @Override\n+  @Before\n+  public void setUp() throws Exception {\n+    fsTarget = fsDefault;\n+    super.setUp();\n+  }\n+\n+  /**\n+   * Override this so that we don't set the targetTestRoot to any path under the\n+   * root of the FS, and so that we don't try to delete the test dir, but rather\n+   * only its contents.\n+   */\n+  @Override\n+  void initializeTargetTestRoot() throws IOException {\n+    targetTestRoot = fsDefault.makeQualified(new Path(\"/\"));\n+    for (FileStatus status : fsDefault.listStatus(targetTestRoot)) {\n+      fsDefault.delete(status.getPath(), true);\n+    }\n+  }\n+\n+  @Override\n+  void setupMountPoints() {\n+    super.setupMountPoints();\n+  }\n+\n+  @Override\n+  int getExpectedDelegationTokenCount() {\n+    return 1; // all point to the same fs so 1 unique token\n+  }\n+\n+  @Override\n+  int getExpectedDelegationTokenCountWithCredentials() {\n+    return 1;\n+  }\n+\n+  public String buildReplaceInterceptorSettingString(String srcRegex,\n+      String replaceString) {\n+    return\n+        RegexMountPointInterceptorType.REPLACE_RESOLVED_DST_PATH.getConfigName()\n+            + INTERCEPTOR_INTERNAL_SEP + srcRegex + INTERCEPTOR_INTERNAL_SEP\n+            + replaceString;\n+  }\n+\n+  public String linkInterceptorSettings(\n+      List<String> interceptorSettingStrList) {\n+    StringBuilder stringBuilder = new StringBuilder();\n+    int listSize = interceptorSettingStrList.size();\n+    for (int i = 0; i < listSize; ++i) {\n+      stringBuilder.append(interceptorSettingStrList.get(i));\n+      if (i < listSize - 1) {\n+        stringBuilder.append(RegexMountPoint.INTERCEPTOR_SEP);\n+      }\n+    }\n+    return stringBuilder.toString();\n+  }\n+\n+  @Test\n+  public void testConfLinkRegexIndexMapping() throws Exception {\n+    conf.setBoolean(CONFIG_VIEWFS_ENABLE_INNER_CACHE, false);\n+    // (^/(\\w+),/targetTestRoot/$1)\n+    // => /targetTestRoot/testConfLinkRegexIndexMapping1\n+    URI viewFsUri =\n+        new URI(FsConstants.VIEWFS_SCHEME, CLUSTER_NAME, \"/\", null, null);\n+    String regexStr = \"^/(\\\\w+)\";\n+    String dstPathStr = targetTestRoot + \"$1\";\n+    Path srcPath = new Path(\"/testConfLinkRegexIndexMapping1\");\n+    Path expectedResolveResult =\n+        new Path(dstPathStr.replace(\"$1\", \"testConfLinkRegexIndexMapping1\"));\n+    FSDataOutputStream outputStream = fsTarget.create((expectedResolveResult));\n+    fsTarget.listStatus(expectedResolveResult);\n+    outputStream.close();\n+    ConfigUtil.addLinkRegex(conf, CLUSTER_NAME, regexStr, dstPathStr, null);\n+    FileSystem vfs = FileSystem.get(viewFsUri, conf);\n+    Assert.assertTrue(expectedResolveResult.equals(vfs.resolvePath(srcPath)));\n+    Assert.assertEquals(0L, vfs.getFileStatus(srcPath).getLen());\n+\n+    // Test ${1} format\n+    // ^/(\\w+, /targetTestRoot/${1})\n+    // => /targetTestRoot/testConfLinkRegexIndexMapping2\n+    dstPathStr = targetTestRoot + \"${1}\";\n+    srcPath = new Path(\"/testConfLinkRegexIndexMapping2\");\n+    expectedResolveResult =\n+        new Path(dstPathStr.replace(\"${1}\", \"testConfLinkRegexIndexMapping2\"));\n+    outputStream = fsTarget.create(expectedResolveResult);\n+    fsTarget.listStatus(expectedResolveResult);\n+    outputStream.close();\n+    ConfigUtil.addLinkRegex(conf, CLUSTER_NAME, regexStr, dstPathStr, null);\n+    vfs = FileSystem.get(viewFsUri, conf);\n+    Assert.assertTrue(expectedResolveResult.equals(vfs.resolvePath(srcPath)));\n+    Assert.assertEquals(0L, vfs.getFileStatus(srcPath).getLen());\n+\n+    //(^/(\\w+)/file1, /targetTestRoot/$1)\n+    // = > /targetTestRoot/testConfLinkRegexIndexMapping3/file1\n+    dstPathStr = targetTestRoot + \"$1\";\n+    srcPath = new Path(\"/testConfLinkRegexIndexMapping3/file1\");\n+    expectedResolveResult = new Path(\n+        dstPathStr.replace(\"$1\", \"testConfLinkRegexIndexMapping3/file1\"));\n+    outputStream = fsTarget.create(expectedResolveResult);\n+    fsTarget.listStatus(expectedResolveResult);\n+    outputStream.close();\n+    ConfigUtil.addLinkRegex(conf, CLUSTER_NAME, regexStr, dstPathStr, null);\n+    vfs = FileSystem.get(viewFsUri, conf);\n+    Assert.assertTrue(expectedResolveResult.equals(vfs.resolvePath(srcPath)));\n+    Assert.assertEquals(0L, vfs.getFileStatus(srcPath).getLen());\n+\n+    //(^/(\\w+)/file1, /targetTestRoot/$1/)\n+    // = > /targetTestRoot/testConfLinkRegexIndexMapping4/file1\n+    dstPathStr = targetTestRoot + \"$1/\";\n+    srcPath = new Path(\"/testConfLinkRegexIndexMapping4/file1\");\n+    expectedResolveResult = new Path(\n+        dstPathStr.replace(\"$1\", \"testConfLinkRegexIndexMapping4/file1\"));\n+    outputStream = fsTarget.create(expectedResolveResult);\n+    fsTarget.listStatus(expectedResolveResult);\n+    outputStream.close();\n+    ConfigUtil.addLinkRegex(conf, CLUSTER_NAME, regexStr, dstPathStr, null);\n+    vfs = FileSystem.get(viewFsUri, conf);\n+    Assert.assertTrue(expectedResolveResult.equals(vfs.resolvePath(srcPath)));\n+    Assert.assertEquals(0L, vfs.getFileStatus(srcPath).getLen());\n+  }\n+\n+  @Test\n+  public void testConfLinkRegexNamedGroupMapping() throws Exception {\n+    conf.setBoolean(CONFIG_VIEWFS_ENABLE_INNER_CACHE, false);\n+    // ^/(?<firstDir>\\\\w+) = > /targetTestRoot/$firstDir\n+    URI viewFsUri =\n+        new URI(FsConstants.VIEWFS_SCHEME, CLUSTER_NAME, \"/\", null, null);\n+    String regexStr = \"^/(?<firstDir>\\\\w+)\";\n+    String dstPathStr = targetTestRoot + \"$firstDir\";\n+    Path srcPath = new Path(\"/testConfLinkRegexNamedGroupMapping1\");\n+    Path expectedResolveResult = new Path(\n+        dstPathStr.replace(\"$firstDir\", \"testConfLinkRegexNamedGroupMapping1\"));\n+    FSDataOutputStream outputStream = fsTarget.create((expectedResolveResult));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c58b945a32a978c470be07ef47e9ed7edfff428c"}, "originalPosition": 230}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY2NjYxMA==", "bodyText": "Could we assert the results of listStatus. Probably create few files under that expected target path. So, the ls will get some file and assert to make sure it's getting from target.", "url": "https://github.com/apache/hadoop/pull/2185#discussion_r471666610", "createdAt": "2020-08-17T18:03:26Z", "author": {"login": "umamaheswararao"}, "path": "hadoop-hdfs-project/hadoop-hdfs/src/test/java/org/apache/hadoop/fs/viewfs/TestViewFileSystemLinkRegex.java", "diffHunk": "@@ -0,0 +1,320 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.viewfs;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.FSDataOutputStream;\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.FileSystemTestHelper;\n+import org.apache.hadoop.fs.FsConstants;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.hdfs.DFSConfigKeys;\n+import org.apache.hadoop.hdfs.MiniDFSCluster;\n+import org.apache.hadoop.hdfs.MiniDFSNNTopology;\n+import org.apache.hadoop.test.GenericTestUtils;\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.hadoop.fs.viewfs.Constants.CONFIG_VIEWFS_ENABLE_INNER_CACHE;\n+import static org.apache.hadoop.fs.viewfs.RegexMountPoint.INTERCEPTOR_INTERNAL_SEP;\n+\n+/**\n+ * Test linkRegex node type for view file system.\n+ */\n+public class TestViewFileSystemLinkRegex extends ViewFileSystemBaseTest {\n+  public static final Logger LOGGER =\n+      LoggerFactory.getLogger(TestViewFileSystemLinkRegex.class);\n+\n+  private static FileSystem fsDefault;\n+  private static MiniDFSCluster cluster;\n+  private static Configuration clusterConfig;\n+  private static final int NAME_SPACES_COUNT = 3;\n+  private static final int DATA_NODES_COUNT = 3;\n+  private static final int FS_INDEX_DEFAULT = 0;\n+  private static final FileSystem[] FS_HDFS = new FileSystem[NAME_SPACES_COUNT];\n+  private static final String CLUSTER_NAME =\n+      \"TestViewFileSystemLinkRegexCluster\";\n+  private static final File TEST_DIR = GenericTestUtils\n+      .getTestDir(TestViewFileSystemLinkRegex.class.getSimpleName());\n+  private static final String TEST_BASE_PATH =\n+      \"/tmp/TestViewFileSystemLinkRegex\";\n+\n+  @Override\n+  protected FileSystemTestHelper createFileSystemHelper() {\n+    return new FileSystemTestHelper(TEST_BASE_PATH);\n+  }\n+\n+  @BeforeClass\n+  public static void clusterSetupAtBeginning() throws IOException {\n+    SupportsBlocks = true;\n+    clusterConfig = ViewFileSystemTestSetup.createConfig();\n+    clusterConfig.setBoolean(\n+        DFSConfigKeys.DFS_NAMENODE_DELEGATION_TOKEN_ALWAYS_USE_KEY,\n+        true);\n+    cluster = new MiniDFSCluster.Builder(clusterConfig).nnTopology(\n+        MiniDFSNNTopology.simpleFederatedTopology(NAME_SPACES_COUNT))\n+        .numDataNodes(DATA_NODES_COUNT).build();\n+    cluster.waitClusterUp();\n+\n+    for (int i = 0; i < NAME_SPACES_COUNT; i++) {\n+      FS_HDFS[i] = cluster.getFileSystem(i);\n+    }\n+    fsDefault = FS_HDFS[FS_INDEX_DEFAULT];\n+  }\n+\n+  @AfterClass\n+  public static void clusterShutdownAtEnd() throws Exception {\n+    if (cluster != null) {\n+      cluster.shutdown();\n+    }\n+  }\n+\n+  @Override\n+  @Before\n+  public void setUp() throws Exception {\n+    fsTarget = fsDefault;\n+    super.setUp();\n+  }\n+\n+  /**\n+   * Override this so that we don't set the targetTestRoot to any path under the\n+   * root of the FS, and so that we don't try to delete the test dir, but rather\n+   * only its contents.\n+   */\n+  @Override\n+  void initializeTargetTestRoot() throws IOException {\n+    targetTestRoot = fsDefault.makeQualified(new Path(\"/\"));\n+    for (FileStatus status : fsDefault.listStatus(targetTestRoot)) {\n+      fsDefault.delete(status.getPath(), true);\n+    }\n+  }\n+\n+  @Override\n+  void setupMountPoints() {\n+    super.setupMountPoints();\n+  }\n+\n+  @Override\n+  int getExpectedDelegationTokenCount() {\n+    return 1; // all point to the same fs so 1 unique token\n+  }\n+\n+  @Override\n+  int getExpectedDelegationTokenCountWithCredentials() {\n+    return 1;\n+  }\n+\n+  public String buildReplaceInterceptorSettingString(String srcRegex,\n+      String replaceString) {\n+    return\n+        RegexMountPointInterceptorType.REPLACE_RESOLVED_DST_PATH.getConfigName()\n+            + INTERCEPTOR_INTERNAL_SEP + srcRegex + INTERCEPTOR_INTERNAL_SEP\n+            + replaceString;\n+  }\n+\n+  public String linkInterceptorSettings(\n+      List<String> interceptorSettingStrList) {\n+    StringBuilder stringBuilder = new StringBuilder();\n+    int listSize = interceptorSettingStrList.size();\n+    for (int i = 0; i < listSize; ++i) {\n+      stringBuilder.append(interceptorSettingStrList.get(i));\n+      if (i < listSize - 1) {\n+        stringBuilder.append(RegexMountPoint.INTERCEPTOR_SEP);\n+      }\n+    }\n+    return stringBuilder.toString();\n+  }\n+\n+  @Test\n+  public void testConfLinkRegexIndexMapping() throws Exception {\n+    conf.setBoolean(CONFIG_VIEWFS_ENABLE_INNER_CACHE, false);\n+    // (^/(\\w+),/targetTestRoot/$1)\n+    // => /targetTestRoot/testConfLinkRegexIndexMapping1\n+    URI viewFsUri =\n+        new URI(FsConstants.VIEWFS_SCHEME, CLUSTER_NAME, \"/\", null, null);\n+    String regexStr = \"^/(\\\\w+)\";\n+    String dstPathStr = targetTestRoot + \"$1\";\n+    Path srcPath = new Path(\"/testConfLinkRegexIndexMapping1\");\n+    Path expectedResolveResult =\n+        new Path(dstPathStr.replace(\"$1\", \"testConfLinkRegexIndexMapping1\"));\n+    FSDataOutputStream outputStream = fsTarget.create((expectedResolveResult));\n+    fsTarget.listStatus(expectedResolveResult);\n+    outputStream.close();\n+    ConfigUtil.addLinkRegex(conf, CLUSTER_NAME, regexStr, dstPathStr, null);\n+    FileSystem vfs = FileSystem.get(viewFsUri, conf);\n+    Assert.assertTrue(expectedResolveResult.equals(vfs.resolvePath(srcPath)));\n+    Assert.assertEquals(0L, vfs.getFileStatus(srcPath).getLen());\n+\n+    // Test ${1} format\n+    // ^/(\\w+, /targetTestRoot/${1})\n+    // => /targetTestRoot/testConfLinkRegexIndexMapping2\n+    dstPathStr = targetTestRoot + \"${1}\";\n+    srcPath = new Path(\"/testConfLinkRegexIndexMapping2\");\n+    expectedResolveResult =\n+        new Path(dstPathStr.replace(\"${1}\", \"testConfLinkRegexIndexMapping2\"));\n+    outputStream = fsTarget.create(expectedResolveResult);\n+    fsTarget.listStatus(expectedResolveResult);\n+    outputStream.close();\n+    ConfigUtil.addLinkRegex(conf, CLUSTER_NAME, regexStr, dstPathStr, null);\n+    vfs = FileSystem.get(viewFsUri, conf);\n+    Assert.assertTrue(expectedResolveResult.equals(vfs.resolvePath(srcPath)));\n+    Assert.assertEquals(0L, vfs.getFileStatus(srcPath).getLen());\n+\n+    //(^/(\\w+)/file1, /targetTestRoot/$1)\n+    // = > /targetTestRoot/testConfLinkRegexIndexMapping3/file1\n+    dstPathStr = targetTestRoot + \"$1\";\n+    srcPath = new Path(\"/testConfLinkRegexIndexMapping3/file1\");\n+    expectedResolveResult = new Path(\n+        dstPathStr.replace(\"$1\", \"testConfLinkRegexIndexMapping3/file1\"));\n+    outputStream = fsTarget.create(expectedResolveResult);\n+    fsTarget.listStatus(expectedResolveResult);\n+    outputStream.close();\n+    ConfigUtil.addLinkRegex(conf, CLUSTER_NAME, regexStr, dstPathStr, null);\n+    vfs = FileSystem.get(viewFsUri, conf);\n+    Assert.assertTrue(expectedResolveResult.equals(vfs.resolvePath(srcPath)));\n+    Assert.assertEquals(0L, vfs.getFileStatus(srcPath).getLen());\n+\n+    //(^/(\\w+)/file1, /targetTestRoot/$1/)\n+    // = > /targetTestRoot/testConfLinkRegexIndexMapping4/file1\n+    dstPathStr = targetTestRoot + \"$1/\";\n+    srcPath = new Path(\"/testConfLinkRegexIndexMapping4/file1\");\n+    expectedResolveResult = new Path(\n+        dstPathStr.replace(\"$1\", \"testConfLinkRegexIndexMapping4/file1\"));\n+    outputStream = fsTarget.create(expectedResolveResult);\n+    fsTarget.listStatus(expectedResolveResult);\n+    outputStream.close();\n+    ConfigUtil.addLinkRegex(conf, CLUSTER_NAME, regexStr, dstPathStr, null);\n+    vfs = FileSystem.get(viewFsUri, conf);\n+    Assert.assertTrue(expectedResolveResult.equals(vfs.resolvePath(srcPath)));\n+    Assert.assertEquals(0L, vfs.getFileStatus(srcPath).getLen());\n+  }\n+\n+  @Test\n+  public void testConfLinkRegexNamedGroupMapping() throws Exception {\n+    conf.setBoolean(CONFIG_VIEWFS_ENABLE_INNER_CACHE, false);\n+    // ^/(?<firstDir>\\\\w+) = > /targetTestRoot/$firstDir\n+    URI viewFsUri =\n+        new URI(FsConstants.VIEWFS_SCHEME, CLUSTER_NAME, \"/\", null, null);\n+    String regexStr = \"^/(?<firstDir>\\\\w+)\";\n+    String dstPathStr = targetTestRoot + \"$firstDir\";\n+    Path srcPath = new Path(\"/testConfLinkRegexNamedGroupMapping1\");\n+    Path expectedResolveResult = new Path(\n+        dstPathStr.replace(\"$firstDir\", \"testConfLinkRegexNamedGroupMapping1\"));\n+    FSDataOutputStream outputStream = fsTarget.create((expectedResolveResult));\n+    fsTarget.listStatus(expectedResolveResult);\n+    outputStream.close();\n+    ConfigUtil.addLinkRegex(conf, CLUSTER_NAME, regexStr, dstPathStr, null);\n+    FileSystem vfs = FileSystem.get(viewFsUri, conf);\n+    Assert.assertTrue(expectedResolveResult.equals(vfs.resolvePath(srcPath)));\n+    Assert.assertEquals(0L, vfs.getFileStatus(srcPath).getLen());\n+\n+    // Test ${1} format\n+    dstPathStr = targetTestRoot + \"${firstDir}\";\n+    srcPath = new Path(\"/testConfLinkRegexNamedGroupMapping2\");\n+    expectedResolveResult = new Path(dstPathStr\n+        .replace(\"${firstDir}\", \"testConfLinkRegexNamedGroupMapping2\"));\n+    outputStream = fsTarget.create(expectedResolveResult);\n+    fsTarget.listStatus(expectedResolveResult);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c58b945a32a978c470be07ef47e9ed7edfff428c"}, "originalPosition": 244}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY3MDEwOQ==", "bodyText": "seems like no change here. Can we avoid it?", "url": "https://github.com/apache/hadoop/pull/2185#discussion_r471670109", "createdAt": "2020-08-17T18:09:11Z", "author": {"login": "umamaheswararao"}, "path": "hadoop-common-project/hadoop-common/src/test/java/org/apache/hadoop/fs/viewfs/ViewFileSystemBaseTest.java", "diffHunk": "@@ -1417,7 +1418,8 @@ public void testGetContentSummaryWithFileInLocalFS() throws Exception {\n       fos.write(expected.getBytes());\n     }\n     ConfigUtil.addLink(conf,\n-        \"/internalDir/internalDir2/linkToLocalFile\", localFile.toURI());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c58b945a32a978c470be07ef47e9ed7edfff428c"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY3MTAzMw==", "bodyText": "Nits: please add annotation in separate line above. You may want to change for all such lines below and above.", "url": "https://github.com/apache/hadoop/pull/2185#discussion_r471671033", "createdAt": "2020-08-17T18:10:40Z", "author": {"login": "umamaheswararao"}, "path": "hadoop-common-project/hadoop-common/src/test/java/org/apache/hadoop/fs/viewfs/TestRegexMountPointResolvedDstPathReplaceInterceptor.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.viewfs;\n+\n+import java.io.IOException;\n+\n+import org.apache.hadoop.fs.Path;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import static org.apache.hadoop.fs.viewfs.RegexMountPointInterceptorType.REPLACE_RESOLVED_DST_PATH;\n+\n+/**\n+ * Test RegexMountPointResolvedDstPathReplaceInterceptor.\n+ */\n+public class TestRegexMountPointResolvedDstPathReplaceInterceptor {\n+\n+  public String createSerializedString(String regex, String replaceString) {\n+    return REPLACE_RESOLVED_DST_PATH.getConfigName()\n+        + RegexMountPoint.INTERCEPTOR_INTERNAL_SEP + regex\n+        + RegexMountPoint.INTERCEPTOR_INTERNAL_SEP + replaceString;\n+  }\n+\n+  @Test public void testDeserializeFromStringNormalCase() throws IOException {\n+    String srcRegex = \"-\";\n+    String replaceString = \"_\";\n+    String serializedString = createSerializedString(srcRegex, replaceString);\n+    RegexMountPointResolvedDstPathReplaceInterceptor interceptor =\n+        RegexMountPointResolvedDstPathReplaceInterceptor\n+            .deserializeFromString(serializedString);\n+    Assert.assertTrue(interceptor.getSrcRegexString().equals(srcRegex));\n+    Assert.assertTrue(interceptor.getReplaceString().equals(replaceString));\n+    Assert.assertTrue(interceptor.getSrcRegexPattern() == null);\n+    interceptor.initialize();\n+    Assert.assertTrue(\n+        interceptor.getSrcRegexPattern().toString().equals(srcRegex));\n+  }\n+\n+  @Test public void testDeserializeFromStringBadCase() throws IOException {\n+    String srcRegex = \"-\";\n+    String replaceString = \"_\";\n+    String serializedString = createSerializedString(srcRegex, replaceString);\n+    serializedString = serializedString + \":ddd\";\n+    RegexMountPointResolvedDstPathReplaceInterceptor interceptor =\n+        RegexMountPointResolvedDstPathReplaceInterceptor\n+            .deserializeFromString(serializedString);\n+    Assert.assertEquals(interceptor, null);\n+  }\n+\n+  @Test public void testSerialization() {\n+    String srcRegex = \"word1\";\n+    String replaceString = \"word2\";\n+    String serializedString = createSerializedString(srcRegex, replaceString);\n+    RegexMountPointResolvedDstPathReplaceInterceptor interceptor =\n+        new RegexMountPointResolvedDstPathReplaceInterceptor(srcRegex,\n+            replaceString);\n+    Assert.assertEquals(interceptor.serializeToString(), serializedString);\n+  }\n+\n+  @Test public void testInterceptSource() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c58b945a32a978c470be07ef47e9ed7edfff428c"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY3MzA4OQ==", "bodyText": "Not about this test, In general on inner cache disabling: There was a suggestion for avoiding explicitly user disabling it. If that not possible, you may want to have check while analyzing mount points itself that, if cache is enabled and using regex mounts, then you may want to fail fs initialization itself?", "url": "https://github.com/apache/hadoop/pull/2185#discussion_r471673089", "createdAt": "2020-08-17T18:14:41Z", "author": {"login": "umamaheswararao"}, "path": "hadoop-common-project/hadoop-common/src/test/java/org/apache/hadoop/fs/viewfs/ViewFileSystemBaseTest.java", "diffHunk": "@@ -1430,4 +1432,49 @@ public void testGetContentSummaryWithFileInLocalFS() throws Exception {\n           summaryAfter.getLength());\n     }\n   }\n+\n+  @Test\n+  public void testMountPointCache() throws Exception {\n+    conf.setInt(Constants.CONFIG_VIEWFS_PATH_RESOLUTION_CACHE_CAPACITY, 1);\n+    conf.setBoolean(\"fs.viewfs.impl.disable.cache\", true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c58b945a32a978c470be07ef47e9ed7edfff428c"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTcxNjIxMA==", "bodyText": "I agree with this issue and filed a JIRA for it. https://issues.apache.org/jira/browse/HADOOP-17028\nThis issue should be solved once implement that.", "url": "https://github.com/apache/hadoop/pull/2185#discussion_r471716210", "createdAt": "2020-08-17T19:04:37Z", "author": {"login": "umamaheswararao"}, "path": "hadoop-hdfs-project/hadoop-hdfs/src/site/markdown/ViewFs.md", "diffHunk": "@@ -366,6 +366,82 @@ Don't want to change scheme or difficult to copy mount-table configurations to a\n \n Please refer to the [View File System Overload Scheme Guide](./ViewFsOverloadScheme.html)\n \n+Regex Pattern Based Mount Points\n+--------------------------------\n+\n+The view file system mount points were a Key-Value based mapping system. It is not friendly for user cases which mapping config could be abstracted to rules. E.g. Users want to provide a GCS bucket per user and there might be thousands of users in total. The old key-value based approach won't work well for several reasons:\n+\n+1. The mount table is used by FileSystem clients. There's a cost to spread the config to all clients and we should avoid it if possible. The [View File System Overload Scheme Guide](./ViewFsOverloadScheme.html) could help the distribution by central mount table management. But the mount table still have to be updated on every change. The change could be greatly avoided if provide a rule-based mount table..\n+\n+2. The client have to understand all the KVs in the mount table. This is not ideal when the mountable grows to thousands of items. E.g. thousands of file systems might be initialized even users only need one. And the config itself will become bloated at scale.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c58b945a32a978c470be07ef47e9ed7edfff428c"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTcyMDQ0NA==", "bodyText": "Do you mind writing some description test steps in javadoc. It will be helpful to better understand about scenarios.", "url": "https://github.com/apache/hadoop/pull/2185#discussion_r471720444", "createdAt": "2020-08-17T19:12:39Z", "author": {"login": "umamaheswararao"}, "path": "hadoop-hdfs-project/hadoop-hdfs/src/test/java/org/apache/hadoop/fs/viewfs/TestViewFileSystemLinkRegex.java", "diffHunk": "@@ -0,0 +1,320 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.viewfs;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.FSDataOutputStream;\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.FileSystemTestHelper;\n+import org.apache.hadoop.fs.FsConstants;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.hdfs.DFSConfigKeys;\n+import org.apache.hadoop.hdfs.MiniDFSCluster;\n+import org.apache.hadoop.hdfs.MiniDFSNNTopology;\n+import org.apache.hadoop.test.GenericTestUtils;\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.hadoop.fs.viewfs.Constants.CONFIG_VIEWFS_ENABLE_INNER_CACHE;\n+import static org.apache.hadoop.fs.viewfs.RegexMountPoint.INTERCEPTOR_INTERNAL_SEP;\n+\n+/**\n+ * Test linkRegex node type for view file system.\n+ */\n+public class TestViewFileSystemLinkRegex extends ViewFileSystemBaseTest {\n+  public static final Logger LOGGER =\n+      LoggerFactory.getLogger(TestViewFileSystemLinkRegex.class);\n+\n+  private static FileSystem fsDefault;\n+  private static MiniDFSCluster cluster;\n+  private static Configuration clusterConfig;\n+  private static final int NAME_SPACES_COUNT = 3;\n+  private static final int DATA_NODES_COUNT = 3;\n+  private static final int FS_INDEX_DEFAULT = 0;\n+  private static final FileSystem[] FS_HDFS = new FileSystem[NAME_SPACES_COUNT];\n+  private static final String CLUSTER_NAME =\n+      \"TestViewFileSystemLinkRegexCluster\";\n+  private static final File TEST_DIR = GenericTestUtils\n+      .getTestDir(TestViewFileSystemLinkRegex.class.getSimpleName());\n+  private static final String TEST_BASE_PATH =\n+      \"/tmp/TestViewFileSystemLinkRegex\";\n+\n+  @Override\n+  protected FileSystemTestHelper createFileSystemHelper() {\n+    return new FileSystemTestHelper(TEST_BASE_PATH);\n+  }\n+\n+  @BeforeClass\n+  public static void clusterSetupAtBeginning() throws IOException {\n+    SupportsBlocks = true;\n+    clusterConfig = ViewFileSystemTestSetup.createConfig();\n+    clusterConfig.setBoolean(\n+        DFSConfigKeys.DFS_NAMENODE_DELEGATION_TOKEN_ALWAYS_USE_KEY,\n+        true);\n+    cluster = new MiniDFSCluster.Builder(clusterConfig).nnTopology(\n+        MiniDFSNNTopology.simpleFederatedTopology(NAME_SPACES_COUNT))\n+        .numDataNodes(DATA_NODES_COUNT).build();\n+    cluster.waitClusterUp();\n+\n+    for (int i = 0; i < NAME_SPACES_COUNT; i++) {\n+      FS_HDFS[i] = cluster.getFileSystem(i);\n+    }\n+    fsDefault = FS_HDFS[FS_INDEX_DEFAULT];\n+  }\n+\n+  @AfterClass\n+  public static void clusterShutdownAtEnd() throws Exception {\n+    if (cluster != null) {\n+      cluster.shutdown();\n+    }\n+  }\n+\n+  @Override\n+  @Before\n+  public void setUp() throws Exception {\n+    fsTarget = fsDefault;\n+    super.setUp();\n+  }\n+\n+  /**\n+   * Override this so that we don't set the targetTestRoot to any path under the\n+   * root of the FS, and so that we don't try to delete the test dir, but rather\n+   * only its contents.\n+   */\n+  @Override\n+  void initializeTargetTestRoot() throws IOException {\n+    targetTestRoot = fsDefault.makeQualified(new Path(\"/\"));\n+    for (FileStatus status : fsDefault.listStatus(targetTestRoot)) {\n+      fsDefault.delete(status.getPath(), true);\n+    }\n+  }\n+\n+  @Override\n+  void setupMountPoints() {\n+    super.setupMountPoints();\n+  }\n+\n+  @Override\n+  int getExpectedDelegationTokenCount() {\n+    return 1; // all point to the same fs so 1 unique token\n+  }\n+\n+  @Override\n+  int getExpectedDelegationTokenCountWithCredentials() {\n+    return 1;\n+  }\n+\n+  public String buildReplaceInterceptorSettingString(String srcRegex,\n+      String replaceString) {\n+    return\n+        RegexMountPointInterceptorType.REPLACE_RESOLVED_DST_PATH.getConfigName()\n+            + INTERCEPTOR_INTERNAL_SEP + srcRegex + INTERCEPTOR_INTERNAL_SEP\n+            + replaceString;\n+  }\n+\n+  public String linkInterceptorSettings(\n+      List<String> interceptorSettingStrList) {\n+    StringBuilder stringBuilder = new StringBuilder();\n+    int listSize = interceptorSettingStrList.size();\n+    for (int i = 0; i < listSize; ++i) {\n+      stringBuilder.append(interceptorSettingStrList.get(i));\n+      if (i < listSize - 1) {\n+        stringBuilder.append(RegexMountPoint.INTERCEPTOR_SEP);\n+      }\n+    }\n+    return stringBuilder.toString();\n+  }\n+\n+  @Test\n+  public void testConfLinkRegexIndexMapping() throws Exception {\n+    conf.setBoolean(CONFIG_VIEWFS_ENABLE_INNER_CACHE, false);\n+    // (^/(\\w+),/targetTestRoot/$1)\n+    // => /targetTestRoot/testConfLinkRegexIndexMapping1\n+    URI viewFsUri =\n+        new URI(FsConstants.VIEWFS_SCHEME, CLUSTER_NAME, \"/\", null, null);\n+    String regexStr = \"^/(\\\\w+)\";\n+    String dstPathStr = targetTestRoot + \"$1\";\n+    Path srcPath = new Path(\"/testConfLinkRegexIndexMapping1\");\n+    Path expectedResolveResult =\n+        new Path(dstPathStr.replace(\"$1\", \"testConfLinkRegexIndexMapping1\"));\n+    FSDataOutputStream outputStream = fsTarget.create((expectedResolveResult));\n+    fsTarget.listStatus(expectedResolveResult);\n+    outputStream.close();\n+    ConfigUtil.addLinkRegex(conf, CLUSTER_NAME, regexStr, dstPathStr, null);\n+    FileSystem vfs = FileSystem.get(viewFsUri, conf);\n+    Assert.assertTrue(expectedResolveResult.equals(vfs.resolvePath(srcPath)));\n+    Assert.assertEquals(0L, vfs.getFileStatus(srcPath).getLen());\n+\n+    // Test ${1} format\n+    // ^/(\\w+, /targetTestRoot/${1})\n+    // => /targetTestRoot/testConfLinkRegexIndexMapping2\n+    dstPathStr = targetTestRoot + \"${1}\";\n+    srcPath = new Path(\"/testConfLinkRegexIndexMapping2\");\n+    expectedResolveResult =\n+        new Path(dstPathStr.replace(\"${1}\", \"testConfLinkRegexIndexMapping2\"));\n+    outputStream = fsTarget.create(expectedResolveResult);\n+    fsTarget.listStatus(expectedResolveResult);\n+    outputStream.close();\n+    ConfigUtil.addLinkRegex(conf, CLUSTER_NAME, regexStr, dstPathStr, null);\n+    vfs = FileSystem.get(viewFsUri, conf);\n+    Assert.assertTrue(expectedResolveResult.equals(vfs.resolvePath(srcPath)));\n+    Assert.assertEquals(0L, vfs.getFileStatus(srcPath).getLen());\n+\n+    //(^/(\\w+)/file1, /targetTestRoot/$1)\n+    // = > /targetTestRoot/testConfLinkRegexIndexMapping3/file1\n+    dstPathStr = targetTestRoot + \"$1\";\n+    srcPath = new Path(\"/testConfLinkRegexIndexMapping3/file1\");\n+    expectedResolveResult = new Path(\n+        dstPathStr.replace(\"$1\", \"testConfLinkRegexIndexMapping3/file1\"));\n+    outputStream = fsTarget.create(expectedResolveResult);\n+    fsTarget.listStatus(expectedResolveResult);\n+    outputStream.close();\n+    ConfigUtil.addLinkRegex(conf, CLUSTER_NAME, regexStr, dstPathStr, null);\n+    vfs = FileSystem.get(viewFsUri, conf);\n+    Assert.assertTrue(expectedResolveResult.equals(vfs.resolvePath(srcPath)));\n+    Assert.assertEquals(0L, vfs.getFileStatus(srcPath).getLen());\n+\n+    //(^/(\\w+)/file1, /targetTestRoot/$1/)\n+    // = > /targetTestRoot/testConfLinkRegexIndexMapping4/file1\n+    dstPathStr = targetTestRoot + \"$1/\";\n+    srcPath = new Path(\"/testConfLinkRegexIndexMapping4/file1\");\n+    expectedResolveResult = new Path(\n+        dstPathStr.replace(\"$1\", \"testConfLinkRegexIndexMapping4/file1\"));\n+    outputStream = fsTarget.create(expectedResolveResult);\n+    fsTarget.listStatus(expectedResolveResult);\n+    outputStream.close();\n+    ConfigUtil.addLinkRegex(conf, CLUSTER_NAME, regexStr, dstPathStr, null);\n+    vfs = FileSystem.get(viewFsUri, conf);\n+    Assert.assertTrue(expectedResolveResult.equals(vfs.resolvePath(srcPath)));\n+    Assert.assertEquals(0L, vfs.getFileStatus(srcPath).getLen());\n+  }\n+\n+  @Test\n+  public void testConfLinkRegexNamedGroupMapping() throws Exception {\n+    conf.setBoolean(CONFIG_VIEWFS_ENABLE_INNER_CACHE, false);\n+    // ^/(?<firstDir>\\\\w+) = > /targetTestRoot/$firstDir\n+    URI viewFsUri =\n+        new URI(FsConstants.VIEWFS_SCHEME, CLUSTER_NAME, \"/\", null, null);\n+    String regexStr = \"^/(?<firstDir>\\\\w+)\";\n+    String dstPathStr = targetTestRoot + \"$firstDir\";\n+    Path srcPath = new Path(\"/testConfLinkRegexNamedGroupMapping1\");\n+    Path expectedResolveResult = new Path(\n+        dstPathStr.replace(\"$firstDir\", \"testConfLinkRegexNamedGroupMapping1\"));\n+    FSDataOutputStream outputStream = fsTarget.create((expectedResolveResult));\n+    fsTarget.listStatus(expectedResolveResult);\n+    outputStream.close();\n+    ConfigUtil.addLinkRegex(conf, CLUSTER_NAME, regexStr, dstPathStr, null);\n+    FileSystem vfs = FileSystem.get(viewFsUri, conf);\n+    Assert.assertTrue(expectedResolveResult.equals(vfs.resolvePath(srcPath)));\n+    Assert.assertEquals(0L, vfs.getFileStatus(srcPath).getLen());\n+\n+    // Test ${1} format\n+    dstPathStr = targetTestRoot + \"${firstDir}\";\n+    srcPath = new Path(\"/testConfLinkRegexNamedGroupMapping2\");\n+    expectedResolveResult = new Path(dstPathStr\n+        .replace(\"${firstDir}\", \"testConfLinkRegexNamedGroupMapping2\"));\n+    outputStream = fsTarget.create(expectedResolveResult);\n+    fsTarget.listStatus(expectedResolveResult);\n+    outputStream.close();\n+    ConfigUtil.addLinkRegex(conf, CLUSTER_NAME, regexStr, dstPathStr, null);\n+    vfs = FileSystem.get(viewFsUri, conf);\n+    Assert.assertTrue(expectedResolveResult.equals(vfs.resolvePath(srcPath)));\n+    Assert.assertEquals(0L, vfs.getFileStatus(srcPath).getLen());\n+  }\n+\n+  @Test\n+  public void testConfLinkRegexFixedDestMapping() throws Exception {\n+    conf.setBoolean(CONFIG_VIEWFS_ENABLE_INNER_CACHE, false);\n+    URI viewFsUri =\n+        new URI(FsConstants.VIEWFS_SCHEME, CLUSTER_NAME, \"/\", null, null);\n+    String regexStr = \"^/\\\\w+\";\n+    String dstPathStr =\n+        targetTestRoot + \"testConfLinkRegexFixedDestMappingFile\";\n+    Path expectedResolveResult = new Path(dstPathStr);\n+    FSDataOutputStream outputStream = fsTarget.create((expectedResolveResult));\n+    fsTarget.listStatus(expectedResolveResult);\n+    outputStream.close();\n+    ConfigUtil.addLinkRegex(conf, CLUSTER_NAME, regexStr, dstPathStr, null);\n+    FileSystem vfs = FileSystem.get(viewFsUri, conf);\n+    Assert.assertTrue(\n+        expectedResolveResult.equals(vfs.resolvePath(new Path(\"/misc1\"))));\n+    Assert.assertTrue(\n+        expectedResolveResult.equals(vfs.resolvePath(new Path(\"/misc2\"))));\n+  }\n+\n+  @Test\n+  public void testConfLinkRegexWithSingleInterceptor() throws Exception {\n+    conf.setBoolean(CONFIG_VIEWFS_ENABLE_INNER_CACHE, false);\n+    URI viewFsUri =\n+        new URI(FsConstants.VIEWFS_SCHEME, CLUSTER_NAME, \"/\", null, null);\n+    String regexStr = \"^/user/(?<username>\\\\w+)\";\n+    String dstPathStr = targetTestRoot + \"$username\";\n+    // Replace \"_\" with \"-\"\n+    String settingString = buildReplaceInterceptorSettingString(\"_\", \"-\");\n+    Path srcPath = new Path(\"/user/hadoop_user1/hadoop_file1\");\n+    Path expectedResolveResult =\n+        new Path(targetTestRoot, \"hadoop-user1/hadoop_file1\");\n+    FSDataOutputStream outputStream = fsTarget.create((expectedResolveResult));\n+    fsTarget.listStatus(expectedResolveResult);\n+    outputStream.close();\n+    ConfigUtil\n+        .addLinkRegex(conf, CLUSTER_NAME, regexStr, dstPathStr, settingString);\n+    FileSystem vfs = FileSystem.get(viewFsUri, conf);\n+    Assert.assertTrue(expectedResolveResult.equals(vfs.resolvePath(srcPath)));\n+    Assert.assertEquals(0L, vfs.getFileStatus(srcPath).getLen());\n+  }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c58b945a32a978c470be07ef47e9ed7edfff428c"}, "originalPosition": 293}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c58b945a32a978c470be07ef47e9ed7edfff428c", "author": {"user": null}, "url": "https://github.com/apache/hadoop/commit/c58b945a32a978c470be07ef47e9ed7edfff428c", "committedDate": "2020-08-10T21:03:57Z", "message": "HADOOP-15891: provide Regex Based Mount Point In Inode Tree\n\nDifferential Revision: https://phabricator.twitter.biz/D526212"}, "afterCommit": {"oid": "809b9a12153679cc304436013038ddfeeedd8fdb", "author": {"user": {"login": "gdreamer", "name": null}}, "url": "https://github.com/apache/hadoop/commit/809b9a12153679cc304436013038ddfeeedd8fdb", "committedDate": "2020-08-18T03:26:14Z", "message": "HADOOP-15891. address comments."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "809b9a12153679cc304436013038ddfeeedd8fdb", "author": {"user": {"login": "gdreamer", "name": null}}, "url": "https://github.com/apache/hadoop/commit/809b9a12153679cc304436013038ddfeeedd8fdb", "committedDate": "2020-08-18T03:26:14Z", "message": "HADOOP-15891. address comments."}, "afterCommit": {"oid": "31a68cd94f7abe79bb91fc1e223c4f9340dab708", "author": {"user": {"login": "gdreamer", "name": null}}, "url": "https://github.com/apache/hadoop/commit/31a68cd94f7abe79bb91fc1e223c4f9340dab708", "committedDate": "2020-08-18T03:46:13Z", "message": "HADOOP-15891. address comments."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "31a68cd94f7abe79bb91fc1e223c4f9340dab708", "author": {"user": {"login": "gdreamer", "name": null}}, "url": "https://github.com/apache/hadoop/commit/31a68cd94f7abe79bb91fc1e223c4f9340dab708", "committedDate": "2020-08-18T03:46:13Z", "message": "HADOOP-15891. address comments."}, "afterCommit": {"oid": "f9c61ef653133d40e889c6ec81f05cb073d54de8", "author": {"user": {"login": "gdreamer", "name": null}}, "url": "https://github.com/apache/hadoop/commit/f9c61ef653133d40e889c6ec81f05cb073d54de8", "committedDate": "2020-08-18T17:59:42Z", "message": "HADOOP-15891. address comments."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f9c61ef653133d40e889c6ec81f05cb073d54de8", "author": {"user": {"login": "gdreamer", "name": null}}, "url": "https://github.com/apache/hadoop/commit/f9c61ef653133d40e889c6ec81f05cb073d54de8", "committedDate": "2020-08-18T17:59:42Z", "message": "HADOOP-15891. address comments."}, "afterCommit": {"oid": "74b0ac5ed9027f3c99fb7be09f5c9a4da591b5ed", "author": {"user": {"login": "gdreamer", "name": null}}, "url": "https://github.com/apache/hadoop/commit/74b0ac5ed9027f3c99fb7be09f5c9a4da591b5ed", "committedDate": "2020-08-18T19:32:58Z", "message": "HADOOP-15891. address comments."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9ae0673d9a54b136ff749c1c8ec2b18f5b3abaf4", "author": {"user": {"login": "gdreamer", "name": null}}, "url": "https://github.com/apache/hadoop/commit/9ae0673d9a54b136ff749c1c8ec2b18f5b3abaf4", "committedDate": "2020-08-18T22:28:31Z", "message": "HADOOP-15891. fix formats."}, "afterCommit": {"oid": "a36f64e5a4de6d2f120fc822b74b2f74751fdf3e", "author": {"user": {"login": "gdreamer", "name": null}}, "url": "https://github.com/apache/hadoop/commit/a36f64e5a4de6d2f120fc822b74b2f74751fdf3e", "committedDate": "2020-08-19T17:48:40Z", "message": "HADOOP-15891. fix formats."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a36f64e5a4de6d2f120fc822b74b2f74751fdf3e", "author": {"user": {"login": "gdreamer", "name": null}}, "url": "https://github.com/apache/hadoop/commit/a36f64e5a4de6d2f120fc822b74b2f74751fdf3e", "committedDate": "2020-08-19T17:48:40Z", "message": "HADOOP-15891. fix formats."}, "afterCommit": {"oid": "3d9b3db8e9df4d5fe43f20880e54c22f1916fdb4", "author": {"user": {"login": "gdreamer", "name": null}}, "url": "https://github.com/apache/hadoop/commit/3d9b3db8e9df4d5fe43f20880e54c22f1916fdb4", "committedDate": "2020-08-20T01:44:02Z", "message": "HADOOP-15891. fix formats."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc5Mzk2Mzg2", "url": "https://github.com/apache/hadoop/pull/2185#pullrequestreview-479396386", "createdAt": "2020-09-01T04:44:30Z", "commit": {"oid": "3d9b3db8e9df4d5fe43f20880e54c22f1916fdb4"}, "state": "COMMENTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwNDo0NDozMFrOHKhazg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwNjoxNjo0MFrOHKljvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDc5NTM0Mg==", "bodyText": "Below method seems like unused method? Please removed it.", "url": "https://github.com/apache/hadoop/pull/2185#discussion_r480795342", "createdAt": "2020-09-01T04:44:30Z", "author": {"login": "umamaheswararao"}, "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/viewfs/RegexMountPoint.java", "diffHunk": "@@ -0,0 +1,306 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.viewfs;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.regex.PatternSyntaxException;\n+\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.apache.hadoop.classification.InterfaceStability;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.util.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.hadoop.fs.viewfs.InodeTree.SlashPath;\n+\n+/**\n+ * Regex mount point is build to implement regex based mount point.\n+ */\n+@InterfaceAudience.Private\n+@InterfaceStability.Unstable\n+class RegexMountPoint<T> {\n+  private static final Logger LOGGER =\n+      LoggerFactory.getLogger(RegexMountPoint.class.getName());\n+\n+  private InodeTree inodeTree;\n+  private String srcPathRegex;\n+  private Pattern srcPattern;\n+  private String dstPath;\n+  private String interceptorSettingsString;\n+  private List<RegexMountPointInterceptor> interceptorList;\n+\n+  public static final String SETTING_SRCREGEX_SEP = \"#.\";\n+  public static final char INTERCEPTOR_SEP = ';';\n+  public static final char INTERCEPTOR_INTERNAL_SEP = ':';\n+  // ${var},$var\n+  public static final Pattern VAR_PATTERN_IN_DEST =\n+      Pattern.compile(\"\\\\$((\\\\{\\\\w+\\\\})|(\\\\w+))\");\n+\n+  // Same var might have different representations.\n+  // e.g.\n+  // key => $key or key = > ${key}\n+  private Map<String, Set<String>> varInDestPathMap;\n+\n+  public Map<String, Set<String>> getVarInDestPathMap() {\n+    return varInDestPathMap;\n+  }\n+\n+  RegexMountPoint(InodeTree inodeTree, String sourcePathRegex,\n+      String destPath, String settingsStr) {\n+    this.inodeTree = inodeTree;\n+    this.srcPathRegex = sourcePathRegex;\n+    this.dstPath = destPath;\n+    this.interceptorSettingsString = settingsStr;\n+    this.interceptorList = new ArrayList<>();\n+  }\n+\n+  /**\n+   * Initialize regex mount point.\n+   *\n+   * @throws IOException\n+   */\n+  public void initialize() throws IOException {\n+    try {\n+      srcPattern = Pattern.compile(srcPathRegex);\n+    } catch (PatternSyntaxException ex) {\n+      throw new IOException(\n+          \"Failed to initialized mount point due to bad src path regex:\"\n+              + srcPathRegex + \", dstPath:\" + dstPath, ex);\n+    }\n+    varInDestPathMap = getVarListInString(dstPath);\n+    initializeInterceptors();\n+  }\n+\n+  private void initializeInterceptors() throws IOException {\n+    if (interceptorSettingsString == null\n+        || interceptorSettingsString.isEmpty()) {\n+      return;\n+    }\n+    String[] interceptorStrArray =\n+        StringUtils.split(interceptorSettingsString, INTERCEPTOR_SEP);\n+    for (String interceptorStr : interceptorStrArray) {\n+      RegexMountPointInterceptor interceptor =\n+          RegexMountPointInterceptorFactory.create(interceptorStr);\n+      if (interceptor == null) {\n+        throw new IOException(\n+            \"Illegal settings String \" + interceptorSettingsString);\n+      }\n+      interceptor.initialize();\n+      interceptorList.add(interceptor);\n+    }\n+  }\n+\n+  /**\n+   * Get $var1 and $var2 style variables in string.\n+   *\n+   * @param input - the string to be process.\n+   * @return\n+   */\n+  public static Map<String, Set<String>> getVarListInString(String input) {\n+    Map<String, Set<String>> varMap = new HashMap<>();\n+    Matcher matcher = VAR_PATTERN_IN_DEST.matcher(input);\n+    while (matcher.find()) {\n+      // $var or ${var}\n+      String varName = matcher.group(0);\n+      // var or {var}\n+      String strippedVarName = matcher.group(1);\n+      if (strippedVarName.startsWith(\"{\")) {\n+        // {varName} = > varName\n+        strippedVarName =\n+            strippedVarName.substring(1, strippedVarName.length() - 1);\n+      }\n+      varMap.putIfAbsent(strippedVarName, new HashSet<>());\n+      varMap.get(strippedVarName).add(varName);\n+    }\n+    return varMap;\n+  }\n+\n+  public String getSrcPathRegex() {\n+    return srcPathRegex;\n+  }\n+\n+  public Pattern getSrcPattern() {\n+    return srcPattern;\n+  }\n+\n+  public String getDstPath() {\n+    return dstPath;\n+  }\n+\n+  public static Pattern getVarPatternInDest() {\n+    return VAR_PATTERN_IN_DEST;\n+  }\n+\n+  /**\n+   * Get resolved path from regex mount points.\n+   *  E.g. link: ^/user/(?<username>\\\\w+) => s3://$user.apache.com/_${user}\n+   *  srcPath: is /user/hadoop/dir1\n+   *  resolveLastComponent: true\n+   *  then return value is s3://hadoop.apache.com/_hadoop\n+   * @param srcPath - the src path to resolve\n+   * @param resolveLastComponent - whether resolve the path after last `/`\n+   * @return mapped path of the mount point.\n+   */\n+  public InodeTree.ResolveResult<T> resolve(final String srcPath,\n+      final boolean resolveLastComponent) {\n+    String pathStrToResolve = getPathToResolve(srcPath, resolveLastComponent);\n+    for (RegexMountPointInterceptor interceptor : interceptorList) {\n+      pathStrToResolve = interceptor.interceptSource(pathStrToResolve);\n+    }\n+    LOGGER.debug(\"Path to resolve:\" + pathStrToResolve + \", srcPattern:\"\n+        + getSrcPathRegex());\n+    Matcher srcMatcher = getSrcPattern().matcher(pathStrToResolve);\n+    String parsedDestPath = getDstPath();\n+    int mappedCount = 0;\n+    String resolvedPathStr = \"\";\n+    while (srcMatcher.find()) {\n+      resolvedPathStr = pathStrToResolve.substring(0, srcMatcher.end());\n+      Map<String, Set<String>> varMap = getVarInDestPathMap();\n+      for (Map.Entry<String, Set<String>> entry : varMap.entrySet()) {\n+        String regexGroupNameOrIndexStr = entry.getKey();\n+        Set<String> groupRepresentationStrSetInDest = entry.getValue();\n+        parsedDestPath = replaceRegexCaptureGroupInPath(\n+            parsedDestPath, srcMatcher,\n+            regexGroupNameOrIndexStr, groupRepresentationStrSetInDest);\n+      }\n+      ++mappedCount;\n+    }\n+    if (0 == mappedCount) {\n+      return null;\n+    }\n+    Path remainingPath = getRemainingPathStr(srcPath, resolvedPathStr);\n+    for (RegexMountPointInterceptor interceptor : interceptorList) {\n+      parsedDestPath = interceptor.interceptResolvedDestPathStr(parsedDestPath);\n+      remainingPath =\n+          interceptor.interceptRemainingPath(remainingPath);\n+    }\n+    InodeTree.ResolveResult resolveResult = inodeTree\n+        .buildResolveResultForRegexMountPoint(InodeTree.ResultKind.EXTERNAL_DIR,\n+            resolvedPathStr, parsedDestPath, remainingPath);\n+    return resolveResult;\n+  }\n+\n+  private Path getRemainingPathStr(\n+      String srcPath,\n+      String resolvedPathStr) {\n+    String remainingPathStr = srcPath.substring(resolvedPathStr.length());\n+    if (!remainingPathStr.startsWith(\"/\")) {\n+      remainingPathStr = \"/\" + remainingPathStr;\n+    }\n+    return new Path(remainingPathStr);\n+  }\n+\n+  private String getPathToResolve(\n+      String srcPath, boolean resolveLastComponent) {\n+    if (resolveLastComponent) {\n+      return srcPath;\n+    }\n+    int lastSlashIndex = srcPath.lastIndexOf(SlashPath.toString());\n+    if (lastSlashIndex == -1) {\n+      return null;\n+    }\n+    return srcPath.substring(0, lastSlashIndex);\n+  }\n+\n+  /**\n+   * Use capture group named regexGroupNameOrIndexStr in mather to replace\n+   * parsedDestPath.\n+   * E.g. link: ^/user/(?<username>\\\\w+) => s3://$user.apache.com/_${user}\n+   * srcMatcher is from /user/hadoop.\n+   * Then the params will be like following.\n+   * parsedDestPath: s3://$user.apache.com/_${user},\n+   * regexGroupNameOrIndexStr: user\n+   * groupRepresentationStrSetInDest: {user:$user; user:${user}}\n+   * return value will be s3://hadoop.apache.com/_hadoop\n+   * @param parsedDestPath\n+   * @param srcMatcher\n+   * @param regexGroupNameOrIndexStr\n+   * @param groupRepresentationStrSetInDest\n+   * @return return parsedDestPath while ${var},$var replaced or\n+   * parsedDestPath nothing found.\n+   */\n+  private String replaceRegexCaptureGroupInPath(\n+      String parsedDestPath,\n+      Matcher srcMatcher,\n+      String regexGroupNameOrIndexStr,\n+      Set<String> groupRepresentationStrSetInDest) {\n+    String groupValue = getRegexGroupValueFromMather(\n+        srcMatcher, regexGroupNameOrIndexStr);\n+    if (groupValue == null) {\n+      return parsedDestPath;\n+    }\n+    for (String varName : groupRepresentationStrSetInDest) {\n+      parsedDestPath = parsedDestPath.replace(varName, groupValue);\n+      LOGGER.debug(\"parsedDestPath value is:\" + parsedDestPath);\n+    }\n+    return parsedDestPath;\n+  }\n+\n+  /**\n+   * Get matched capture group value from regex matched string. E.g.\n+   * Regex: ^/user/(?<username>\\\\w+), regexGroupNameOrIndexStr: userName\n+   * then /user/hadoop should return hadoop while call\n+   * getRegexGroupValueFromMather(matcher, usersName)\n+   * or getRegexGroupValueFromMather(matcher, 1)\n+   *\n+   * @param srcMatcher - the matcher to be use\n+   * @param regexGroupNameOrIndexStr - the regex group name or index\n+   * @return - Null if no matched group named regexGroupNameOrIndexStr found.\n+   */\n+  private String getRegexGroupValueFromMather(\n+      Matcher srcMatcher, String regexGroupNameOrIndexStr) {\n+    if (regexGroupNameOrIndexStr.matches(\"\\\\d+\")) {\n+      // group index\n+      int groupIndex = Integer.parseUnsignedInt(regexGroupNameOrIndexStr);\n+      if (groupIndex >= 0 && groupIndex <= srcMatcher.groupCount()) {\n+        return srcMatcher.group(groupIndex);\n+      }\n+    } else {\n+      // named group in regex\n+      return srcMatcher.group(regexGroupNameOrIndexStr);\n+    }\n+    return null;\n+  }\n+\n+  /**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d9b3db8e9df4d5fe43f20880e54c22f1916fdb4"}, "originalPosition": 289}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDgzNjkzOQ==", "bodyText": "below comment can be corrected? regex base mount point will not use caching now.\nOtherwise people could confuse and may tend to disable. IIUC, even if they enable this, RegexBasedMountPoints will continue to work right?", "url": "https://github.com/apache/hadoop/pull/2185#discussion_r480836939", "createdAt": "2020-09-01T05:36:33Z", "author": {"login": "umamaheswararao"}, "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/viewfs/Constants.java", "diffHunk": "@@ -86,12 +86,21 @@\n    */\n   String CONFIG_VIEWFS_LINK_MERGE_SLASH = \"linkMergeSlash\";\n \n+  /**\n+   * Config variable for specifying a regex link which uses regular expressions\n+   * as source and target could use group captured in src.\n+   * E.g. (^/(?<firstDir>\\\\w+), /prefix-${firstDir}) =>\n+   *   (/path1/file1 => /prefix-path1/file1)\n+   */\n+  String CONFIG_VIEWFS_LINK_REGEX = \"linkRegex\";\n+\n   FsPermission PERMISSION_555 = new FsPermission((short) 0555);\n \n   String CONFIG_VIEWFS_RENAME_STRATEGY = \"fs.viewfs.rename.strategy\";\n \n   /**\n    * Enable ViewFileSystem to cache all children filesystems in inner cache.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d9b3db8e9df4d5fe43f20880e54c22f1916fdb4"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDg0NzcxOA==", "bodyText": "you may want to remove the below return ? or specify what it's returning.", "url": "https://github.com/apache/hadoop/pull/2185#discussion_r480847718", "createdAt": "2020-09-01T05:53:13Z", "author": {"login": "umamaheswararao"}, "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/viewfs/RegexMountPointInterceptorFactory.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.viewfs;\n+\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.apache.hadoop.classification.InterfaceStability;\n+\n+/**\n+ * The interceptor factory used to create RegexMountPoint interceptors.\n+ */\n+@InterfaceAudience.Private\n+@InterfaceStability.Unstable\n+final class RegexMountPointInterceptorFactory {\n+\n+  private RegexMountPointInterceptorFactory() {\n+\n+  }\n+\n+  /**\n+   * interceptorSettingsString string should be like ${type}:${string},\n+   * e.g. replaceresolveddstpath:word1,word2.\n+   *\n+   * @param interceptorSettingsString", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d9b3db8e9df4d5fe43f20880e54c22f1916fdb4"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDg1MTAyMQ==", "bodyText": "What are you asserting in this case?", "url": "https://github.com/apache/hadoop/pull/2185#discussion_r480851021", "createdAt": "2020-09-01T05:58:12Z", "author": {"login": "umamaheswararao"}, "path": "hadoop-common-project/hadoop-common/src/test/java/org/apache/hadoop/fs/viewfs/TestRegexMountPointResolvedDstPathReplaceInterceptor.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.viewfs;\n+\n+import java.io.IOException;\n+\n+import org.apache.hadoop.fs.Path;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import static org.apache.hadoop.fs.viewfs.RegexMountPointInterceptorType.REPLACE_RESOLVED_DST_PATH;\n+\n+/**\n+ * Test RegexMountPointResolvedDstPathReplaceInterceptor.\n+ */\n+public class TestRegexMountPointResolvedDstPathReplaceInterceptor {\n+\n+  public String createSerializedString(String regex, String replaceString) {\n+    return REPLACE_RESOLVED_DST_PATH.getConfigName()\n+        + RegexMountPoint.INTERCEPTOR_INTERNAL_SEP + regex\n+        + RegexMountPoint.INTERCEPTOR_INTERNAL_SEP + replaceString;\n+  }\n+\n+  @Test\n+  public void testDeserializeFromStringNormalCase() throws IOException {\n+    String srcRegex = \"-\";\n+    String replaceString = \"_\";\n+    String serializedString = createSerializedString(srcRegex, replaceString);\n+    RegexMountPointResolvedDstPathReplaceInterceptor interceptor =\n+        RegexMountPointResolvedDstPathReplaceInterceptor\n+            .deserializeFromString(serializedString);\n+    Assert.assertTrue(interceptor.getSrcRegexString().equals(srcRegex));\n+    Assert.assertTrue(interceptor.getReplaceString().equals(replaceString));\n+    Assert.assertTrue(interceptor.getSrcRegexPattern() == null);\n+    interceptor.initialize();\n+    Assert.assertTrue(\n+        interceptor.getSrcRegexPattern().toString().equals(srcRegex));\n+  }\n+\n+  @Test\n+  public void testDeserializeFromStringBadCase() throws IOException {\n+    String srcRegex = \"-\";\n+    String replaceString = \"_\";\n+    String serializedString = createSerializedString(srcRegex, replaceString);\n+    serializedString = serializedString + \":ddd\";\n+    RegexMountPointResolvedDstPathReplaceInterceptor interceptor =\n+        RegexMountPointResolvedDstPathReplaceInterceptor\n+            .deserializeFromString(serializedString);\n+    Assert.assertEquals(interceptor, null);\n+  }\n+\n+  @Test\n+  public void testSerialization() {\n+    String srcRegex = \"word1\";\n+    String replaceString = \"word2\";\n+    String serializedString = createSerializedString(srcRegex, replaceString);\n+    RegexMountPointResolvedDstPathReplaceInterceptor interceptor =\n+        new RegexMountPointResolvedDstPathReplaceInterceptor(srcRegex,\n+            replaceString);\n+    Assert.assertEquals(interceptor.serializeToString(), serializedString);\n+  }\n+\n+  @Test", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d9b3db8e9df4d5fe43f20880e54c22f1916fdb4"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDg1MjM2Ng==", "bodyText": "You want to use assertEquals instead?", "url": "https://github.com/apache/hadoop/pull/2185#discussion_r480852366", "createdAt": "2020-09-01T06:00:10Z", "author": {"login": "umamaheswararao"}, "path": "hadoop-common-project/hadoop-common/src/test/java/org/apache/hadoop/fs/viewfs/TestRegexMountPointResolvedDstPathReplaceInterceptor.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.viewfs;\n+\n+import java.io.IOException;\n+\n+import org.apache.hadoop.fs.Path;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import static org.apache.hadoop.fs.viewfs.RegexMountPointInterceptorType.REPLACE_RESOLVED_DST_PATH;\n+\n+/**\n+ * Test RegexMountPointResolvedDstPathReplaceInterceptor.\n+ */\n+public class TestRegexMountPointResolvedDstPathReplaceInterceptor {\n+\n+  public String createSerializedString(String regex, String replaceString) {\n+    return REPLACE_RESOLVED_DST_PATH.getConfigName()\n+        + RegexMountPoint.INTERCEPTOR_INTERNAL_SEP + regex\n+        + RegexMountPoint.INTERCEPTOR_INTERNAL_SEP + replaceString;\n+  }\n+\n+  @Test\n+  public void testDeserializeFromStringNormalCase() throws IOException {\n+    String srcRegex = \"-\";\n+    String replaceString = \"_\";\n+    String serializedString = createSerializedString(srcRegex, replaceString);\n+    RegexMountPointResolvedDstPathReplaceInterceptor interceptor =\n+        RegexMountPointResolvedDstPathReplaceInterceptor\n+            .deserializeFromString(serializedString);\n+    Assert.assertTrue(interceptor.getSrcRegexString().equals(srcRegex));\n+    Assert.assertTrue(interceptor.getReplaceString().equals(replaceString));\n+    Assert.assertTrue(interceptor.getSrcRegexPattern() == null);\n+    interceptor.initialize();\n+    Assert.assertTrue(\n+        interceptor.getSrcRegexPattern().toString().equals(srcRegex));\n+  }\n+\n+  @Test\n+  public void testDeserializeFromStringBadCase() throws IOException {\n+    String srcRegex = \"-\";\n+    String replaceString = \"_\";\n+    String serializedString = createSerializedString(srcRegex, replaceString);\n+    serializedString = serializedString + \":ddd\";\n+    RegexMountPointResolvedDstPathReplaceInterceptor interceptor =\n+        RegexMountPointResolvedDstPathReplaceInterceptor\n+            .deserializeFromString(serializedString);\n+    Assert.assertEquals(interceptor, null);\n+  }\n+\n+  @Test\n+  public void testSerialization() {\n+    String srcRegex = \"word1\";\n+    String replaceString = \"word2\";\n+    String serializedString = createSerializedString(srcRegex, replaceString);\n+    RegexMountPointResolvedDstPathReplaceInterceptor interceptor =\n+        new RegexMountPointResolvedDstPathReplaceInterceptor(srcRegex,\n+            replaceString);\n+    Assert.assertEquals(interceptor.serializeToString(), serializedString);\n+  }\n+\n+  @Test\n+  public void testInterceptSource() {\n+    String srcRegex = \"word1\";\n+    String replaceString = \"word2\";\n+    RegexMountPointResolvedDstPathReplaceInterceptor interceptor =\n+        new RegexMountPointResolvedDstPathReplaceInterceptor(srcRegex,\n+            replaceString);\n+    String sourcePath = \"/a/b/l3/dd\";\n+    sourcePath = interceptor.interceptSource(sourcePath);\n+  }\n+\n+  @Test\n+  public void testInterceptResolve() throws IOException {\n+    String pathAfterResolution = \"/user-hadoop\";\n+    Path remainingPath = new Path(\"/ad-data\");\n+\n+    String srcRegex = \"hadoop\";\n+    String replaceString = \"hdfs\";\n+    RegexMountPointResolvedDstPathReplaceInterceptor interceptor =\n+        new RegexMountPointResolvedDstPathReplaceInterceptor(srcRegex,\n+            replaceString);\n+    interceptor.initialize();\n+    Assert.assertTrue(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d9b3db8e9df4d5fe43f20880e54c22f1916fdb4"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDg1Mjg3Ng==", "bodyText": "You may want to use assertEquals directly?", "url": "https://github.com/apache/hadoop/pull/2185#discussion_r480852876", "createdAt": "2020-09-01T06:00:57Z", "author": {"login": "umamaheswararao"}, "path": "hadoop-common-project/hadoop-common/src/test/java/org/apache/hadoop/fs/viewfs/TestRegexMountPointResolvedDstPathReplaceInterceptor.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.viewfs;\n+\n+import java.io.IOException;\n+\n+import org.apache.hadoop.fs.Path;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import static org.apache.hadoop.fs.viewfs.RegexMountPointInterceptorType.REPLACE_RESOLVED_DST_PATH;\n+\n+/**\n+ * Test RegexMountPointResolvedDstPathReplaceInterceptor.\n+ */\n+public class TestRegexMountPointResolvedDstPathReplaceInterceptor {\n+\n+  public String createSerializedString(String regex, String replaceString) {\n+    return REPLACE_RESOLVED_DST_PATH.getConfigName()\n+        + RegexMountPoint.INTERCEPTOR_INTERNAL_SEP + regex\n+        + RegexMountPoint.INTERCEPTOR_INTERNAL_SEP + replaceString;\n+  }\n+\n+  @Test\n+  public void testDeserializeFromStringNormalCase() throws IOException {\n+    String srcRegex = \"-\";\n+    String replaceString = \"_\";\n+    String serializedString = createSerializedString(srcRegex, replaceString);\n+    RegexMountPointResolvedDstPathReplaceInterceptor interceptor =\n+        RegexMountPointResolvedDstPathReplaceInterceptor\n+            .deserializeFromString(serializedString);\n+    Assert.assertTrue(interceptor.getSrcRegexString().equals(srcRegex));\n+    Assert.assertTrue(interceptor.getReplaceString().equals(replaceString));\n+    Assert.assertTrue(interceptor.getSrcRegexPattern() == null);\n+    interceptor.initialize();\n+    Assert.assertTrue(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d9b3db8e9df4d5fe43f20880e54c22f1916fdb4"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDg1NDQyOQ==", "bodyText": "You may want to use assertEquals ? The advantage would be that, when assertion fails it will tell you what's mismatching.  There are lot of asserts like this, please change if possible.", "url": "https://github.com/apache/hadoop/pull/2185#discussion_r480854429", "createdAt": "2020-09-01T06:03:23Z", "author": {"login": "umamaheswararao"}, "path": "hadoop-common-project/hadoop-common/src/test/java/org/apache/hadoop/fs/viewfs/TestRegexMountPoint.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.viewfs;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.hadoop.conf.Configuration;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Test Regex Mount Point.\n+ */\n+public class TestRegexMountPoint {\n+  private static final Logger LOGGER =\n+      LoggerFactory.getLogger(TestRegexMountPoint.class.getName());\n+\n+  private InodeTree inodeTree;\n+  private Configuration conf;\n+\n+  class TestRegexMountPointFileSystem {\n+    public URI getUri() {\n+      return uri;\n+    }\n+\n+    private URI uri;\n+\n+    TestRegexMountPointFileSystem(URI uri) {\n+      String uriStr = uri == null ? \"null\" : uri.toString();\n+      LOGGER.info(\"Create TestRegexMountPointFileSystem Via URI:\" + uriStr);\n+      this.uri = uri;\n+    }\n+  }\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    conf = new Configuration();\n+    ConfigUtil.addLink(conf, TestRegexMountPoint.class.getName(), \"/mnt\",\n+        URI.create(\"file:///\"));\n+\n+    inodeTree = new InodeTree<TestRegexMountPointFileSystem>(conf,\n+        TestRegexMountPoint.class.getName(), null, false) {\n+      @Override\n+      protected TestRegexMountPointFileSystem getTargetFileSystem(\n+          final URI uri) {\n+        return new TestRegexMountPointFileSystem(uri);\n+      }\n+\n+      @Override\n+      protected TestRegexMountPointFileSystem getTargetFileSystem(\n+          final URI uri, boolean enableCache) {\n+        return new TestRegexMountPointFileSystem(uri);\n+      }\n+\n+      @Override\n+      protected TestRegexMountPointFileSystem getTargetFileSystem(\n+          final INodeDir<TestRegexMountPointFileSystem> dir) {\n+        return new TestRegexMountPointFileSystem(null);\n+      }\n+\n+      @Override\n+      protected TestRegexMountPointFileSystem getTargetFileSystem(\n+          final String settings, final URI[] mergeFsURIList) {\n+        return new TestRegexMountPointFileSystem(null);\n+      }\n+    };\n+  }\n+\n+  @After\n+  public void tearDown() throws Exception {\n+    inodeTree = null;\n+  }\n+\n+  @Test\n+  public void testGetVarListInString() throws IOException {\n+    String srcRegex = \"/(\\\\w+)\";\n+    String target = \"/$0/${1}/$1/${2}/${2}\";\n+    RegexMountPoint regexMountPoint =\n+        new RegexMountPoint(inodeTree, srcRegex, target, null);\n+    regexMountPoint.initialize();\n+    Map<String, Set<String>> varMap = regexMountPoint.getVarInDestPathMap();\n+    Assert.assertEquals(varMap.size(), 3);\n+    Assert.assertEquals(varMap.get(\"0\").size(), 1);\n+    Assert.assertTrue(varMap.get(\"0\").contains(\"$0\"));\n+    Assert.assertEquals(varMap.get(\"1\").size(), 2);\n+    Assert.assertTrue(varMap.get(\"1\").contains(\"${1}\"));\n+    Assert.assertTrue(varMap.get(\"1\").contains(\"$1\"));\n+    Assert.assertEquals(varMap.get(\"2\").size(), 1);\n+    Assert.assertTrue(varMap.get(\"2\").contains(\"${2}\"));\n+  }\n+\n+  @Test\n+  public void testResolve() throws IOException {\n+    String regexStr = \"^/user/(?<username>\\\\w+)\";\n+    String dstPathStr = \"/namenode1/testResolve/$username\";\n+    String settingsStr = null;\n+    RegexMountPoint regexMountPoint =\n+        new RegexMountPoint(inodeTree, regexStr, dstPathStr, settingsStr);\n+    regexMountPoint.initialize();\n+    InodeTree.ResolveResult resolveResult =\n+        regexMountPoint.resolve(\"/user/hadoop/file1\", true);\n+    Assert.assertEquals(resolveResult.kind, InodeTree.ResultKind.EXTERNAL_DIR);\n+    Assert.assertTrue(\n+        resolveResult.targetFileSystem\n+            instanceof TestRegexMountPointFileSystem);\n+    Assert.assertTrue(resolveResult.resolvedPath.equals(\"/user/hadoop\"));\n+    Assert.assertTrue(\n+        resolveResult.targetFileSystem\n+            instanceof TestRegexMountPointFileSystem);\n+    Assert.assertTrue(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d9b3db8e9df4d5fe43f20880e54c22f1916fdb4"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDg1NTg0Mw==", "bodyText": "you can use assertNull", "url": "https://github.com/apache/hadoop/pull/2185#discussion_r480855843", "createdAt": "2020-09-01T06:05:32Z", "author": {"login": "umamaheswararao"}, "path": "hadoop-common-project/hadoop-common/src/test/java/org/apache/hadoop/fs/viewfs/TestRegexMountPointInterceptorFactory.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.viewfs;\n+\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/**\n+ * Test Regex Mount Point Interceptor Factory.\n+ */\n+public class TestRegexMountPointInterceptorFactory {\n+\n+  @Test\n+  public void testCreateNormalCase() {\n+    String replaceInterceptorStr =\n+        RegexMountPointInterceptorType.REPLACE_RESOLVED_DST_PATH.getConfigName()\n+            + Character.toString(RegexMountPoint.INTERCEPTOR_INTERNAL_SEP)\n+            + \"src\" + Character\n+            .toString(RegexMountPoint.INTERCEPTOR_INTERNAL_SEP) + \"replace\";\n+    RegexMountPointInterceptor interceptor =\n+        RegexMountPointInterceptorFactory.create(replaceInterceptorStr);\n+    Assert.assertTrue(\n+        interceptor\n+            instanceof RegexMountPointResolvedDstPathReplaceInterceptor);\n+  }\n+\n+  @Test\n+  public void testCreateBadCase() {\n+    String replaceInterceptorStr =\n+        RegexMountPointInterceptorType.REPLACE_RESOLVED_DST_PATH.getConfigName()\n+            + \"___\" + Character\n+            .toString(RegexMountPoint.INTERCEPTOR_INTERNAL_SEP) + \"src\"\n+            + Character.toString(RegexMountPoint.INTERCEPTOR_INTERNAL_SEP)\n+            + \"replace\";\n+    RegexMountPointInterceptor interceptor =\n+        RegexMountPointInterceptorFactory.create(replaceInterceptorStr);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d9b3db8e9df4d5fe43f20880e54c22f1916fdb4"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDg1OTMyNg==", "bodyText": "Seems like we don't do anything here. Could you please add that in Javadoc. Say src will not be intercepted in this impl, it's only for dst?", "url": "https://github.com/apache/hadoop/pull/2185#discussion_r480859326", "createdAt": "2020-09-01T06:10:56Z", "author": {"login": "umamaheswararao"}, "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/viewfs/RegexMountPointResolvedDstPathReplaceInterceptor.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.viewfs;\n+\n+import java.io.IOException;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.regex.PatternSyntaxException;\n+\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.apache.hadoop.classification.InterfaceStability;\n+import org.apache.hadoop.fs.Path;\n+\n+import static org.apache.hadoop.fs.viewfs.RegexMountPointInterceptorType.REPLACE_RESOLVED_DST_PATH;\n+\n+/**\n+ * Implementation of RegexMountPointResolvedDstPathReplaceInterceptor.\n+ */\n+@InterfaceAudience.Private\n+@InterfaceStability.Unstable\n+class RegexMountPointResolvedDstPathReplaceInterceptor\n+    implements RegexMountPointInterceptor {\n+\n+  private String srcRegexString;\n+  private String replaceString;\n+  private Pattern srcRegexPattern;\n+\n+  RegexMountPointResolvedDstPathReplaceInterceptor(String srcRegex,\n+      String replaceString) {\n+    this.srcRegexString = srcRegex;\n+    this.replaceString = replaceString;\n+    this.srcRegexPattern = null;\n+  }\n+\n+  public String getSrcRegexString() {\n+    return srcRegexString;\n+  }\n+\n+  public String getReplaceString() {\n+    return replaceString;\n+  }\n+\n+  public Pattern getSrcRegexPattern() {\n+    return srcRegexPattern;\n+  }\n+\n+  @Override\n+  public void initialize() throws IOException {\n+    try {\n+      srcRegexPattern = Pattern.compile(srcRegexString);\n+    } catch (PatternSyntaxException ex) {\n+      throw new IOException(\n+          \"Initialize interceptor failed, srcRegx:\" + srcRegexString, ex);\n+    }\n+  }\n+\n+  /**\n+   * Intercept source before resolution.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d9b3db8e9df4d5fe43f20880e54c22f1916fdb4"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDg2MTk5Mg==", "bodyText": "same a interceptSrc doc.", "url": "https://github.com/apache/hadoop/pull/2185#discussion_r480861992", "createdAt": "2020-09-01T06:14:52Z", "author": {"login": "umamaheswararao"}, "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/viewfs/RegexMountPointResolvedDstPathReplaceInterceptor.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.viewfs;\n+\n+import java.io.IOException;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.regex.PatternSyntaxException;\n+\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.apache.hadoop.classification.InterfaceStability;\n+import org.apache.hadoop.fs.Path;\n+\n+import static org.apache.hadoop.fs.viewfs.RegexMountPointInterceptorType.REPLACE_RESOLVED_DST_PATH;\n+\n+/**\n+ * Implementation of RegexMountPointResolvedDstPathReplaceInterceptor.\n+ */\n+@InterfaceAudience.Private\n+@InterfaceStability.Unstable\n+class RegexMountPointResolvedDstPathReplaceInterceptor\n+    implements RegexMountPointInterceptor {\n+\n+  private String srcRegexString;\n+  private String replaceString;\n+  private Pattern srcRegexPattern;\n+\n+  RegexMountPointResolvedDstPathReplaceInterceptor(String srcRegex,\n+      String replaceString) {\n+    this.srcRegexString = srcRegex;\n+    this.replaceString = replaceString;\n+    this.srcRegexPattern = null;\n+  }\n+\n+  public String getSrcRegexString() {\n+    return srcRegexString;\n+  }\n+\n+  public String getReplaceString() {\n+    return replaceString;\n+  }\n+\n+  public Pattern getSrcRegexPattern() {\n+    return srcRegexPattern;\n+  }\n+\n+  @Override\n+  public void initialize() throws IOException {\n+    try {\n+      srcRegexPattern = Pattern.compile(srcRegexString);\n+    } catch (PatternSyntaxException ex) {\n+      throw new IOException(\n+          \"Initialize interceptor failed, srcRegx:\" + srcRegexString, ex);\n+    }\n+  }\n+\n+  /**\n+   * Intercept source before resolution.\n+   *\n+   * @param source\n+   * @return\n+   */\n+  @Override\n+  public String interceptSource(String source) {\n+    return source;\n+  }\n+\n+  /**\n+   * Intercept resolved path, e.g.\n+   * Mount point /^(\\\\w+)/, ${1}.hadoop.net\n+   * If incoming path is /user1/home/tmp/job1,\n+   * then the resolved path str will be user1.\n+   *\n+   * @return intercepted string\n+   */\n+  @Override public String interceptResolvedDestPathStr(\n+      String parsedDestPathStr) {\n+    Matcher matcher = srcRegexPattern.matcher(parsedDestPathStr);\n+    return matcher.replaceAll(replaceString);\n+  }\n+\n+  /**\n+   * Intercept remaining path.\n+   *", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d9b3db8e9df4d5fe43f20880e54c22f1916fdb4"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDg2MzE2Nw==", "bodyText": "shouldn't it interceptSrc and remainingPath follow same pattern to intercept as they both split from src path only?\nWhats the issue if I use same interceptSource method? Do we have some concerns? Could you explain me if I miss something here?", "url": "https://github.com/apache/hadoop/pull/2185#discussion_r480863167", "createdAt": "2020-09-01T06:16:40Z", "author": {"login": "umamaheswararao"}, "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/viewfs/RegexMountPointResolvedDstPathReplaceInterceptor.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.viewfs;\n+\n+import java.io.IOException;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.regex.PatternSyntaxException;\n+\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.apache.hadoop.classification.InterfaceStability;\n+import org.apache.hadoop.fs.Path;\n+\n+import static org.apache.hadoop.fs.viewfs.RegexMountPointInterceptorType.REPLACE_RESOLVED_DST_PATH;\n+\n+/**\n+ * Implementation of RegexMountPointResolvedDstPathReplaceInterceptor.\n+ */\n+@InterfaceAudience.Private\n+@InterfaceStability.Unstable\n+class RegexMountPointResolvedDstPathReplaceInterceptor\n+    implements RegexMountPointInterceptor {\n+\n+  private String srcRegexString;\n+  private String replaceString;\n+  private Pattern srcRegexPattern;\n+\n+  RegexMountPointResolvedDstPathReplaceInterceptor(String srcRegex,\n+      String replaceString) {\n+    this.srcRegexString = srcRegex;\n+    this.replaceString = replaceString;\n+    this.srcRegexPattern = null;\n+  }\n+\n+  public String getSrcRegexString() {\n+    return srcRegexString;\n+  }\n+\n+  public String getReplaceString() {\n+    return replaceString;\n+  }\n+\n+  public Pattern getSrcRegexPattern() {\n+    return srcRegexPattern;\n+  }\n+\n+  @Override\n+  public void initialize() throws IOException {\n+    try {\n+      srcRegexPattern = Pattern.compile(srcRegexString);\n+    } catch (PatternSyntaxException ex) {\n+      throw new IOException(\n+          \"Initialize interceptor failed, srcRegx:\" + srcRegexString, ex);\n+    }\n+  }\n+\n+  /**\n+   * Intercept source before resolution.\n+   *\n+   * @param source\n+   * @return\n+   */\n+  @Override\n+  public String interceptSource(String source) {\n+    return source;\n+  }\n+\n+  /**\n+   * Intercept resolved path, e.g.\n+   * Mount point /^(\\\\w+)/, ${1}.hadoop.net\n+   * If incoming path is /user1/home/tmp/job1,\n+   * then the resolved path str will be user1.\n+   *\n+   * @return intercepted string\n+   */\n+  @Override public String interceptResolvedDestPathStr(\n+      String parsedDestPathStr) {\n+    Matcher matcher = srcRegexPattern.matcher(parsedDestPathStr);\n+    return matcher.replaceAll(replaceString);\n+  }\n+\n+  /**\n+   * Intercept remaining path.\n+   *\n+   * @return intercepted path\n+   */\n+  @Override public Path interceptRemainingPath(Path remainingPath) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3d9b3db8e9df4d5fe43f20880e54c22f1916fdb4"}, "originalPosition": 102}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3d9b3db8e9df4d5fe43f20880e54c22f1916fdb4", "author": {"user": {"login": "gdreamer", "name": null}}, "url": "https://github.com/apache/hadoop/commit/3d9b3db8e9df4d5fe43f20880e54c22f1916fdb4", "committedDate": "2020-08-20T01:44:02Z", "message": "HADOOP-15891. fix formats."}, "afterCommit": {"oid": "6a47ea225d20083e05913678cbcbfeeb3a0a272a", "author": {"user": {"login": "gdreamer", "name": null}}, "url": "https://github.com/apache/hadoop/commit/6a47ea225d20083e05913678cbcbfeeb3a0a272a", "committedDate": "2020-09-02T02:00:02Z", "message": "HADOOP-15891. address comments."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6a47ea225d20083e05913678cbcbfeeb3a0a272a", "author": {"user": {"login": "gdreamer", "name": null}}, "url": "https://github.com/apache/hadoop/commit/6a47ea225d20083e05913678cbcbfeeb3a0a272a", "committedDate": "2020-09-02T02:00:02Z", "message": "HADOOP-15891. address comments."}, "afterCommit": {"oid": "2dcf31f19bcc05ee4433bdefdd77776ee450fb1f", "author": {"user": {"login": "gdreamer", "name": null}}, "url": "https://github.com/apache/hadoop/commit/2dcf31f19bcc05ee4433bdefdd77776ee450fb1f", "committedDate": "2020-09-02T07:53:17Z", "message": "HADOOP-15891. address comments."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "01a2419e9c942c0a34c40a14d4074a7420cd4420", "author": {"user": null}, "url": "https://github.com/apache/hadoop/commit/01a2419e9c942c0a34c40a14d4074a7420cd4420", "committedDate": "2020-09-08T20:34:55Z", "message": "HADOOP-15891: provide Regex Based Mount Point In Inode Tree\n\nDifferential Revision: https://phabricator.twitter.biz/D526212"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d66b86b5e5d9fd5b7e8a40f43fedc93c33f44a24", "author": {"user": {"login": "gdreamer", "name": null}}, "url": "https://github.com/apache/hadoop/commit/d66b86b5e5d9fd5b7e8a40f43fedc93c33f44a24", "committedDate": "2020-09-08T20:34:55Z", "message": "HADOOP-15891. address comments."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2f3ae037e3533bc6512d8b497683d36cd559f7ad", "author": {"user": {"login": "gdreamer", "name": null}}, "url": "https://github.com/apache/hadoop/commit/2f3ae037e3533bc6512d8b497683d36cd559f7ad", "committedDate": "2020-09-08T20:34:55Z", "message": "HADOOP-15891. remove inode tree mounpoints resolution cache."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d540c6b0ffa00351f7e232b72a790f7bb52a8a07", "author": {"user": {"login": "gdreamer", "name": null}}, "url": "https://github.com/apache/hadoop/commit/d540c6b0ffa00351f7e232b72a790f7bb52a8a07", "committedDate": "2020-09-08T20:34:55Z", "message": "HADOOP-15891. address comments."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c609d13f77950d082525bb06a931540fe9119cb9", "author": {"user": {"login": "gdreamer", "name": null}}, "url": "https://github.com/apache/hadoop/commit/c609d13f77950d082525bb06a931540fe9119cb9", "committedDate": "2020-09-08T20:34:55Z", "message": "HADOOP-15891: address comments. Add inner cache support."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e25945d5da8ecd58ba3eb1e9f28715291c4273f1", "author": {"user": {"login": "gdreamer", "name": null}}, "url": "https://github.com/apache/hadoop/commit/e25945d5da8ecd58ba3eb1e9f28715291c4273f1", "committedDate": "2020-09-08T20:34:55Z", "message": "Add more comments."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8786ee8fc0e1b1d617eabd398c4d05a1ff656002", "author": {"user": {"login": "gdreamer", "name": null}}, "url": "https://github.com/apache/hadoop/commit/8786ee8fc0e1b1d617eabd398c4d05a1ff656002", "committedDate": "2020-09-08T20:43:56Z", "message": "Fix checkstyle and rebase."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "375a4387534267d2676c0d250802510780d1dbad", "author": {"user": {"login": "gdreamer", "name": null}}, "url": "https://github.com/apache/hadoop/commit/375a4387534267d2676c0d250802510780d1dbad", "committedDate": "2020-09-06T06:24:51Z", "message": "Add more comments."}, "afterCommit": {"oid": "8786ee8fc0e1b1d617eabd398c4d05a1ff656002", "author": {"user": {"login": "gdreamer", "name": null}}, "url": "https://github.com/apache/hadoop/commit/8786ee8fc0e1b1d617eabd398c4d05a1ff656002", "committedDate": "2020-09-08T20:43:56Z", "message": "Fix checkstyle and rebase."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0NjU0ODQ0", "url": "https://github.com/apache/hadoop/pull/2185#pullrequestreview-484654844", "createdAt": "2020-09-09T04:37:32Z", "commit": {"oid": "8786ee8fc0e1b1d617eabd398c4d05a1ff656002"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwNDozNzozM1rOHO2WJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwNTowMDowOVrOHO2u8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTMzMjUxOA==", "bodyText": "Do you see any issue if we make it true? If no issues, we can simply clean it on close right instead of having another config?\nSeems like this is an improvement to existing code. If you want, I am ok to file small JIRA and fix this cleanup thing.( I am assuming it's not necessarily needed with this.)", "url": "https://github.com/apache/hadoop/pull/2185#discussion_r485332518", "createdAt": "2020-09-09T04:37:33Z", "author": {"login": "umamaheswararao"}, "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/viewfs/ViewFileSystem.java", "diffHunk": "@@ -217,6 +239,7 @@ public Path getMountedOnPath() {\n   Path homeDir = null;\n   private boolean enableInnerCache = false;\n   private InnerCache cache;\n+  private boolean evictCacheOnClose = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8786ee8fc0e1b1d617eabd398c4d05a1ff656002"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTMzMjg4MQ==", "bodyText": "Still this asserts can use assertEquals method? Please use them all places.", "url": "https://github.com/apache/hadoop/pull/2185#discussion_r485332881", "createdAt": "2020-09-09T04:39:09Z", "author": {"login": "umamaheswararao"}, "path": "hadoop-common-project/hadoop-common/src/test/java/org/apache/hadoop/fs/viewfs/TestRegexMountPoint.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.viewfs;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.hadoop.conf.Configuration;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Test Regex Mount Point.\n+ */\n+public class TestRegexMountPoint {\n+  private static final Logger LOGGER =\n+      LoggerFactory.getLogger(TestRegexMountPoint.class.getName());\n+\n+  private InodeTree inodeTree;\n+  private Configuration conf;\n+\n+  class TestRegexMountPointFileSystem {\n+    public URI getUri() {\n+      return uri;\n+    }\n+\n+    private URI uri;\n+\n+    TestRegexMountPointFileSystem(URI uri) {\n+      String uriStr = uri == null ? \"null\" : uri.toString();\n+      LOGGER.info(\"Create TestRegexMountPointFileSystem Via URI:\" + uriStr);\n+      this.uri = uri;\n+    }\n+  }\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    conf = new Configuration();\n+    ConfigUtil.addLink(conf, TestRegexMountPoint.class.getName(), \"/mnt\",\n+        URI.create(\"file:///\"));\n+\n+    inodeTree = new InodeTree<TestRegexMountPointFileSystem>(conf,\n+        TestRegexMountPoint.class.getName(), null, false) {\n+      @Override\n+      protected TestRegexMountPointFileSystem getTargetFileSystem(\n+          final URI uri) {\n+        return new TestRegexMountPointFileSystem(uri);\n+      }\n+\n+      @Override\n+      protected TestRegexMountPointFileSystem getTargetFileSystem(\n+          final INodeDir<TestRegexMountPointFileSystem> dir) {\n+        return new TestRegexMountPointFileSystem(null);\n+      }\n+\n+      @Override\n+      protected TestRegexMountPointFileSystem getTargetFileSystem(\n+          final String settings, final URI[] mergeFsURIList) {\n+        return new TestRegexMountPointFileSystem(null);\n+      }\n+    };\n+  }\n+\n+  @After\n+  public void tearDown() throws Exception {\n+    inodeTree = null;\n+  }\n+\n+  @Test\n+  public void testGetVarListInString() throws IOException {\n+    String srcRegex = \"/(\\\\w+)\";\n+    String target = \"/$0/${1}/$1/${2}/${2}\";\n+    RegexMountPoint regexMountPoint =\n+        new RegexMountPoint(inodeTree, srcRegex, target, null);\n+    regexMountPoint.initialize();\n+    Map<String, Set<String>> varMap = regexMountPoint.getVarInDestPathMap();\n+    Assert.assertEquals(varMap.size(), 3);\n+    Assert.assertEquals(varMap.get(\"0\").size(), 1);\n+    Assert.assertTrue(varMap.get(\"0\").contains(\"$0\"));\n+    Assert.assertEquals(varMap.get(\"1\").size(), 2);\n+    Assert.assertTrue(varMap.get(\"1\").contains(\"${1}\"));\n+    Assert.assertTrue(varMap.get(\"1\").contains(\"$1\"));\n+    Assert.assertEquals(varMap.get(\"2\").size(), 1);\n+    Assert.assertTrue(varMap.get(\"2\").contains(\"${2}\"));\n+  }\n+\n+  @Test\n+  public void testResolve() throws IOException {\n+    String regexStr = \"^/user/(?<username>\\\\w+)\";\n+    String dstPathStr = \"/namenode1/testResolve/$username\";\n+    String settingsStr = null;\n+    RegexMountPoint regexMountPoint =\n+        new RegexMountPoint(inodeTree, regexStr, dstPathStr, settingsStr);\n+    regexMountPoint.initialize();\n+    InodeTree.ResolveResult resolveResult =\n+        regexMountPoint.resolve(\"/user/hadoop/file1\", true);\n+    Assert.assertEquals(resolveResult.kind, InodeTree.ResultKind.EXTERNAL_DIR);\n+    Assert.assertTrue(\n+        resolveResult.targetFileSystem\n+            instanceof TestRegexMountPointFileSystem);\n+    Assert.assertTrue(resolveResult.resolvedPath.equals(\"/user/hadoop\"));\n+    Assert.assertTrue(\n+        resolveResult.targetFileSystem\n+            instanceof TestRegexMountPointFileSystem);\n+    Assert.assertTrue(\n+        ((TestRegexMountPointFileSystem) resolveResult.targetFileSystem)\n+            .getUri().toString().equals(\"/namenode1/testResolve/hadoop\"));\n+    Assert.assertTrue(resolveResult.remainingPath.toString().equals(\"/file1\"));\n+  }\n+\n+  @Test\n+  public void testResolveWithInterceptor() throws IOException {\n+    String regexStr = \"^/user/(?<username>\\\\w+)\";\n+    String dstPathStr = \"/namenode1/testResolve/$username\";\n+    // Replace \"_\" with \"-\"\n+    RegexMountPointResolvedDstPathReplaceInterceptor interceptor =\n+        new RegexMountPointResolvedDstPathReplaceInterceptor(\"_\", \"-\");\n+    // replaceresolvedpath:_:-\n+    String settingsStr = interceptor.serializeToString();\n+    RegexMountPoint regexMountPoint =\n+        new RegexMountPoint(inodeTree, regexStr, dstPathStr, settingsStr);\n+    regexMountPoint.initialize();\n+    InodeTree.ResolveResult resolveResult =\n+        regexMountPoint.resolve(\"/user/hadoop_user1/file_index\", true);\n+    Assert.assertEquals(resolveResult.kind, InodeTree.ResultKind.EXTERNAL_DIR);\n+    Assert.assertTrue(\n+        resolveResult.targetFileSystem\n+            instanceof TestRegexMountPointFileSystem);\n+    Assert.assertTrue(resolveResult.resolvedPath.equals(\"/user/hadoop_user1\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8786ee8fc0e1b1d617eabd398c4d05a1ff656002"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTMzMzc4MQ==", "bodyText": "small suggestion here:\nMove above lines out of try block. Then use try(FileSystem vfs = = FileSystem.get(viewFsUri, config)){\n}\nThis should close automatically after block. So, we can remove finally block below?", "url": "https://github.com/apache/hadoop/pull/2185#discussion_r485333781", "createdAt": "2020-09-09T04:42:27Z", "author": {"login": "umamaheswararao"}, "path": "hadoop-hdfs-project/hadoop-hdfs/src/test/java/org/apache/hadoop/fs/viewfs/TestViewFileSystemLinkRegex.java", "diffHunk": "@@ -0,0 +1,473 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.fs.viewfs;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.FSDataOutputStream;\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.FileSystemTestHelper;\n+import org.apache.hadoop.fs.FsConstants;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.hdfs.DFSConfigKeys;\n+import org.apache.hadoop.hdfs.MiniDFSCluster;\n+import org.apache.hadoop.hdfs.MiniDFSNNTopology;\n+import org.apache.hadoop.test.GenericTestUtils;\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.hadoop.fs.viewfs.RegexMountPoint.INTERCEPTOR_INTERNAL_SEP;\n+import static org.junit.Assert.assertSame;\n+\n+/**\n+ * Test linkRegex node type for view file system.\n+ */\n+public class TestViewFileSystemLinkRegex extends ViewFileSystemBaseTest {\n+  public static final Logger LOGGER =\n+      LoggerFactory.getLogger(TestViewFileSystemLinkRegex.class);\n+\n+  private static FileSystem fsDefault;\n+  private static MiniDFSCluster cluster;\n+  private static Configuration clusterConfig;\n+  private static final int NAME_SPACES_COUNT = 3;\n+  private static final int DATA_NODES_COUNT = 3;\n+  private static final int FS_INDEX_DEFAULT = 0;\n+  private static final FileSystem[] FS_HDFS = new FileSystem[NAME_SPACES_COUNT];\n+  private static final String CLUSTER_NAME =\n+      \"TestViewFileSystemLinkRegexCluster\";\n+  private static final File TEST_DIR = GenericTestUtils\n+      .getTestDir(TestViewFileSystemLinkRegex.class.getSimpleName());\n+  private static final String TEST_BASE_PATH =\n+      \"/tmp/TestViewFileSystemLinkRegex\";\n+\n+  @Override\n+  protected FileSystemTestHelper createFileSystemHelper() {\n+    return new FileSystemTestHelper(TEST_BASE_PATH);\n+  }\n+\n+  @BeforeClass\n+  public static void clusterSetupAtBeginning() throws IOException {\n+    SupportsBlocks = true;\n+    clusterConfig = ViewFileSystemTestSetup.createConfig();\n+    clusterConfig.setBoolean(\n+        DFSConfigKeys.DFS_NAMENODE_DELEGATION_TOKEN_ALWAYS_USE_KEY,\n+        true);\n+    cluster = new MiniDFSCluster.Builder(clusterConfig).nnTopology(\n+        MiniDFSNNTopology.simpleFederatedTopology(NAME_SPACES_COUNT))\n+        .numDataNodes(DATA_NODES_COUNT).build();\n+    cluster.waitClusterUp();\n+\n+    for (int i = 0; i < NAME_SPACES_COUNT; i++) {\n+      FS_HDFS[i] = cluster.getFileSystem(i);\n+    }\n+    fsDefault = FS_HDFS[FS_INDEX_DEFAULT];\n+  }\n+\n+  @AfterClass\n+  public static void clusterShutdownAtEnd() throws Exception {\n+    if (cluster != null) {\n+      cluster.shutdown();\n+    }\n+  }\n+\n+  @Override\n+  @Before\n+  public void setUp() throws Exception {\n+    fsTarget = fsDefault;\n+    super.setUp();\n+  }\n+\n+  /**\n+   * Override this so that we don't set the targetTestRoot to any path under the\n+   * root of the FS, and so that we don't try to delete the test dir, but rather\n+   * only its contents.\n+   */\n+  @Override\n+  void initializeTargetTestRoot() throws IOException {\n+    targetTestRoot = fsDefault.makeQualified(new Path(\"/\"));\n+    for (FileStatus status : fsDefault.listStatus(targetTestRoot)) {\n+      fsDefault.delete(status.getPath(), true);\n+    }\n+  }\n+\n+  @Override\n+  void setupMountPoints() {\n+    super.setupMountPoints();\n+  }\n+\n+  @Override\n+  int getExpectedDelegationTokenCount() {\n+    return 1; // all point to the same fs so 1 unique token\n+  }\n+\n+  @Override\n+  int getExpectedDelegationTokenCountWithCredentials() {\n+    return 1;\n+  }\n+\n+  public String buildReplaceInterceptorSettingString(String srcRegex,\n+      String replaceString) {\n+    return\n+        RegexMountPointInterceptorType.REPLACE_RESOLVED_DST_PATH.getConfigName()\n+            + INTERCEPTOR_INTERNAL_SEP + srcRegex + INTERCEPTOR_INTERNAL_SEP\n+            + replaceString;\n+  }\n+\n+  public String linkInterceptorSettings(\n+      List<String> interceptorSettingStrList) {\n+    StringBuilder stringBuilder = new StringBuilder();\n+    int listSize = interceptorSettingStrList.size();\n+    for (int i = 0; i < listSize; ++i) {\n+      stringBuilder.append(interceptorSettingStrList.get(i));\n+      if (i < listSize - 1) {\n+        stringBuilder.append(RegexMountPoint.INTERCEPTOR_SEP);\n+      }\n+    }\n+    return stringBuilder.toString();\n+  }\n+\n+  private void createDirWithChildren(\n+      FileSystem fileSystem, Path dir, List<Path> childrenFiles)\n+      throws IOException {\n+    Assert.assertTrue(fileSystem.mkdirs(dir));\n+    int index = 0;\n+    for (Path childFile : childrenFiles) {\n+      createFile(fileSystem, childFile, index, true);\n+    }\n+  }\n+\n+  private void createFile(\n+      FileSystem fileSystem, Path file, int dataLenToWrite, boolean overwrite)\n+      throws IOException {\n+    FSDataOutputStream outputStream = null;\n+    try {\n+      outputStream = fileSystem.create(file, overwrite);\n+      for (int i = 0; i < dataLenToWrite; ++i) {\n+        outputStream.writeByte(i);\n+      }\n+      outputStream.close();\n+    } finally {\n+      if (outputStream != null) {\n+        outputStream.close();\n+      }\n+    }\n+  }\n+\n+  private void createDirWithChildren(\n+      FileSystem fileSystem, Path dir, int childrenFilesCnt)\n+      throws IOException {\n+    List<Path> childrenFiles = new ArrayList<>(childrenFilesCnt);\n+    for (int i = 0; i < childrenFilesCnt; ++i) {\n+      childrenFiles.add(new Path(dir, \"file\" + i));\n+    }\n+    createDirWithChildren(fileSystem, dir, childrenFiles);\n+  }\n+\n+  /**\n+   * The function used to test regex mountpoints.\n+   * @param config - get mountable config from this conf\n+   * @param regexStr - the src path regex expression that applies to this config\n+   * @param dstPathStr - the string of target path\n+   * @param interceptorSettings - the serialized interceptor string to be\n+   *                           applied while resolving the mapping\n+   * @param dirPathBeforeMountPoint - the src path user passed in to be mapped.\n+   * @param expectedResolveResult - the expected path after resolve\n+   *                             dirPathBeforeMountPoint via regex mountpint.\n+   * @param childrenFilesCnt - the child files under dirPathBeforeMountPoint to\n+   *                         be created\n+   * @throws IOException\n+   * @throws URISyntaxException\n+   */\n+  private void testRegexMountpoint(\n+      Configuration config,\n+      String regexStr,\n+      String dstPathStr,\n+      String interceptorSettings,\n+      Path dirPathBeforeMountPoint,\n+      Path expectedResolveResult,\n+      int childrenFilesCnt)\n+      throws IOException, URISyntaxException {\n+    FileSystem vfs = null;\n+    try {\n+      // Set up test env\n+      createDirWithChildren(\n+          fsTarget, expectedResolveResult, childrenFilesCnt);\n+      ConfigUtil.addLinkRegex(\n+          config, CLUSTER_NAME, regexStr, dstPathStr, interceptorSettings);\n+\n+      // Asserts\n+      URI viewFsUri = new URI(\n+          FsConstants.VIEWFS_SCHEME, CLUSTER_NAME, \"/\", null, null);\n+      vfs = FileSystem.get(viewFsUri, config);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8786ee8fc0e1b1d617eabd398c4d05a1ff656002"}, "originalPosition": 229}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTMzNTU4NA==", "bodyText": "Is the below comment is still valid?", "url": "https://github.com/apache/hadoop/pull/2185#discussion_r485335584", "createdAt": "2020-09-09T04:48:49Z", "author": {"login": "umamaheswararao"}, "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/viewfs/Constants.java", "diffHunk": "@@ -86,12 +86,21 @@\n    */\n   String CONFIG_VIEWFS_LINK_MERGE_SLASH = \"linkMergeSlash\";\n \n+  /**\n+   * Config variable for specifying a regex link which uses regular expressions\n+   * as source and target could use group captured in src.\n+   * E.g. (^/(?<firstDir>\\\\w+), /prefix-${firstDir}) =>\n+   *   (/path1/file1 => /prefix-path1/file1)\n+   */\n+  String CONFIG_VIEWFS_LINK_REGEX = \"linkRegex\";\n+\n   FsPermission PERMISSION_555 = new FsPermission((short) 0555);\n \n   String CONFIG_VIEWFS_RENAME_STRATEGY = \"fs.viewfs.rename.strategy\";\n \n   /**\n    * Enable ViewFileSystem to cache all children filesystems in inner cache.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDgzNjkzOQ=="}, "originalCommit": {"oid": "3d9b3db8e9df4d5fe43f20880e54c22f1916fdb4"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTMzODg2Ng==", "bodyText": "For a regex-base rule mount table entry, we couldn't know what's corresponding path until parsing.\n\nWhatever we know should be added to mountPoints? So, that getMountPoints will return known fs-es? It may be a good idea to add Java doc on API level.\nI am ok to have this in followup JIRA to cover all of this aspects.", "url": "https://github.com/apache/hadoop/pull/2185#discussion_r485338866", "createdAt": "2020-09-09T05:00:09Z", "author": {"login": "umamaheswararao"}, "path": "hadoop-hdfs-project/hadoop-hdfs/src/site/markdown/ViewFs.md", "diffHunk": "@@ -366,6 +366,69 @@ Don't want to change scheme or difficult to copy mount-table configurations to a\n \n Please refer to the [View File System Overload Scheme Guide](./ViewFsOverloadScheme.html)\n \n+Regex Pattern Based Mount Points\n+--------------------------------\n+\n+The view file system mount points were a Key-Value based mapping system. It is not friendly for user cases which mapping config could be abstracted to rules. E.g. Users want to provide a GCS bucket per user and there might be thousands of users in total. The old key-value based approach won't work well for several reasons:\n+\n+1. The mount table is used by FileSystem clients. There's a cost to spread the config to all clients and we should avoid it if possible. The [View File System Overload Scheme Guide](./ViewFsOverloadScheme.html) could help the distribution by central mount table management. But the mount table still have to be updated on every change. The change could be greatly avoided if provide a rule-based mount table.\n+\n+2. The client have to understand all the KVs in the mount table. This is not ideal when the mountable grows to thousands of items. E.g. thousands of file systems might be initialized even users only need one. And the config itself will become bloated at scale.\n+\n+### Understand the Difference\n+\n+In the key-value based mount table, view file system treats every mount point as a partition. There's several file system APIs which will lead to operation on all partitions. E.g. there's an HDFS cluster with multiple mount. Users want to run \u201chadoop fs -put file viewfs://hdfs.namenode.apache.org/tmp/\u201d cmd to copy data from local disk to our HDFS cluster. The cmd will trigger ViewFileSystem to call setVerifyChecksum() method which will initialize the file system for every mount point.\n+For a regex-base rule mount table entry, we couldn't know what's corresponding path until parsing. So the regex based mount table entry will be ignored on such cases. The file system (ChRootedFileSystem) will be created upon accessing. But the underlying file system will be cached by inner cache of ViewFileSystem.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8786ee8fc0e1b1d617eabd398c4d05a1ff656002"}, "originalPosition": 16}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1cb9b50d18cfaba2d2b4dd2fb84913567ab29201", "author": {"user": {"login": "gdreamer", "name": null}}, "url": "https://github.com/apache/hadoop/commit/1cb9b50d18cfaba2d2b4dd2fb84913567ab29201", "committedDate": "2020-09-09T06:00:26Z", "message": "HADOOP-15891: fix comments."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4c543eae3410afb35553a4701ae911919c1f009c", "author": {"user": {"login": "gdreamer", "name": null}}, "url": "https://github.com/apache/hadoop/commit/4c543eae3410afb35553a4701ae911919c1f009c", "committedDate": "2020-09-09T15:54:15Z", "message": "Fix checkstyle."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6c9f1d1cba7e3af133290329ccd4f2281b245ad7", "author": {"user": {"login": "gdreamer", "name": null}}, "url": "https://github.com/apache/hadoop/commit/6c9f1d1cba7e3af133290329ccd4f2281b245ad7", "committedDate": "2020-09-09T15:47:07Z", "message": "Fix checkstyle."}, "afterCommit": {"oid": "4c543eae3410afb35553a4701ae911919c1f009c", "author": {"user": {"login": "gdreamer", "name": null}}, "url": "https://github.com/apache/hadoop/commit/4c543eae3410afb35553a4701ae911919c1f009c", "committedDate": "2020-09-09T15:54:15Z", "message": "Fix checkstyle."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fa30c5ec629e54379368db91dcf51f2414b03d28", "author": {"user": {"login": "gdreamer", "name": null}}, "url": "https://github.com/apache/hadoop/commit/fa30c5ec629e54379368db91dcf51f2414b03d28", "committedDate": "2020-09-09T22:04:54Z", "message": "Fix checkstyle"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg1NTczMzUy", "url": "https://github.com/apache/hadoop/pull/2185#pullrequestreview-485573352", "createdAt": "2020-09-10T04:57:06Z", "commit": {"oid": "fa30c5ec629e54379368db91dcf51f2414b03d28"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwNDo1NzowNlrOHPi80A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQwNDo1NzowNlrOHPi80A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA2MzMxMg==", "bodyText": "This method not used anywhere?", "url": "https://github.com/apache/hadoop/pull/2185#discussion_r486063312", "createdAt": "2020-09-10T04:57:06Z", "author": {"login": "umamaheswararao"}, "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/viewfs/ConfigUtil.java", "diffHunk": "@@ -166,6 +166,42 @@ public static void addLinkNfly(final Configuration conf, final String src,\n     addLinkNfly(conf, getDefaultMountTableName(conf), src, null, targets);\n   }\n \n+\n+  /**\n+   * Add a LinkRegex to the config for the specified mount table.\n+   * @param conf - get mountable config from this conf\n+   * @param mountTableName - the mountable name of the regex config item\n+   * @param srcRegex - the src path regex expression that applies to this config\n+   * @param targetStr - the string of target path\n+   */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa30c5ec629e54379368db91dcf51f2414b03d28"}, "originalPosition": 11}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c494bfe25c6c71d813194c3ed4561866db196f37", "author": {"user": {"login": "gdreamer", "name": null}}, "url": "https://github.com/apache/hadoop/commit/c494bfe25c6c71d813194c3ed4561866db196f37", "committedDate": "2020-09-10T05:18:44Z", "message": "Remove useless method."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "226f8f3358bdcc7742219dc5dbd69e4f1e476d8c", "author": {"user": {"login": "gdreamer", "name": null}}, "url": "https://github.com/apache/hadoop/commit/226f8f3358bdcc7742219dc5dbd69e4f1e476d8c", "committedDate": "2020-09-10T06:19:45Z", "message": "Address comments."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg2NDYzNDQz", "url": "https://github.com/apache/hadoop/pull/2185#pullrequestreview-486463443", "createdAt": "2020-09-11T04:21:19Z", "commit": {"oid": "226f8f3358bdcc7742219dc5dbd69e4f1e476d8c"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3841, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}