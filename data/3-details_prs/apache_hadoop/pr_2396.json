{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA2MTE3MDI1", "number": 2396, "title": "HADOOP-17313. FileSystem.get to support slow-to-instantiate FS clients.", "bodyText": "This adds a semaphore to throttle the number of FileSystem instances which\ncan be created simultaneously, set in \"fs.creation.parallel.count\".\nThis is designed to reduce the impact of many threads in an application calling\nFileSystem.get() on a filesystem which takes time to instantiate -for example\nto an object where HTTPS connections are set up during initialization.\nMany threads trying to do this may create spurious delays by conflicting\nfor access to synchronized blocks, when simply limiting the parallelism\ndiminishes the conflict, so speeds up all threads trying to access\nthe store.\nThe default value, 64, is larger than is likely to deliver any speedup -but\nit does mean that there should be no adverse effects from the change.\nIf a service appears to be blocking on all threads initializing connections to\nabfs, s3a or store, try a smaller (possibly significantly smaller) value.\nContributed by Steve Loughran.", "createdAt": "2020-10-19T16:38:27Z", "url": "https://github.com/apache/hadoop/pull/2396", "merged": true, "mergeCommit": {"oid": "ac7045b75f3d5aa9948494f7f98fc2dfc9399507"}, "closed": true, "closedAt": "2020-11-25T14:31:03Z", "author": {"login": "steveloughran"}, "timelineItems": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdW7oa1gFqTUxODU1MTE5OA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdfXOckgBqjQwMjgzNjEzMzM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE4NTUxMTk4", "url": "https://github.com/apache/hadoop/pull/2396#pullrequestreview-518551198", "createdAt": "2020-10-28T11:12:07Z", "commit": {"oid": "abd2ee20d0a4082e98a53df674206ab1b72f50b2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxMToxMjowN1rOHplBAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxMToxMjowN1rOHplBAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzM2MDEyOA==", "bodyText": "typo?", "url": "https://github.com/apache/hadoop/pull/2396#discussion_r513360128", "createdAt": "2020-10-28T11:12:07Z", "author": {"login": "mehakmeet"}, "path": "hadoop-common-project/hadoop-common/src/test/java/org/apache/hadoop/fs/TestFileSystemCaching.java", "diffHunk": "@@ -336,4 +344,134 @@ public void testCacheIncludesURIUserInfo() throws Throwable {\n     assertNotEquals(keyA, new FileSystem.Cache.Key(\n         new URI(\"wasb://a:password@account.blob.core.windows.net\"), conf));\n   }\n+\n+\n+  /**\n+   * Single semaphore: no surplus FS instances will be created\n+   * and then discarded.\n+   */\n+  @Test\n+  public void testCacheSingleSemaphoredConstruction() throws Exception {\n+    FileSystem.Cache cache = semaphoredCache(1);\n+    createFileSystems(cache, 10);\n+    Assertions.assertThat(cache.getDiscardedInstances())\n+        .describedAs(\"Discarded FS instances\")\n+        .isEqualTo(0);\n+  }\n+\n+  /**\n+   * Dual semaphore: thread 2 will get as far as\n+   * blocking in the initialize() method while awaiting\n+   * thread 1 to complete its initialization.\n+   * <p></p>\n+   * The thread 2 FS instance will be discarded.\n+   * All other threads will block for a cache semaphore,\n+   * so when they are given an opportunity to proceed,\n+   * they will find that an FS instance exists.\n+   */\n+  @Test\n+  public void testCacheDualSemaphoreConstruction() throws Exception {\n+    FileSystem.Cache cache = semaphoredCache(2);\n+    createFileSystems(cache, 10);\n+    Assertions.assertThat(cache.getDiscardedInstances())\n+        .describedAs(\"Discarded FS instances\")\n+        .isEqualTo(1);\n+  }\n+\n+  /**\n+   * Construct the FS instances in a cache with effectively no\n+   * limit on the number of instances which can be created\n+   * simultaneously.\n+   * <p></p>\n+   * This is the effective state before HADOOP-17313.\n+   * <p></p>\n+   * All but one thread's FS instance will be discarded.\n+   */\n+  @Test\n+  public void testCacheLargeSemaphoreConstruction() throws Exception {\n+    FileSystem.Cache cache = semaphoredCache(999);\n+    int count = 10;\n+    createFileSystems(cache, count);\n+    Assertions.assertThat(cache.getDiscardedInstances())\n+        .describedAs(\"Discarded FS instances\")\n+        .isEqualTo(count -1);\n+  }\n+\n+  /**\n+   * Create a cache with a given semaphore size.\n+   * @param semaphores number of semaphores\n+   * @return the cache.\n+   */\n+  private FileSystem.Cache semaphoredCache(final int semaphores) {\n+    final Configuration conf1 = new Configuration();\n+    conf1.setInt(FS_CREATION_PARALLEL_COUNT, semaphores);\n+    FileSystem.Cache cache = new FileSystem.Cache(conf1);\n+    return cache;\n+  }\n+\n+  /**\n+   * Attempt to create {@code count} filesystems in parallel,\n+   * then assert that they are all equal.\n+   * @param cache cache to use\n+   * @param count count of filesystems to instantiate\n+   */\n+  private void createFileSystems(final FileSystem.Cache cache, final int count)\n+      throws URISyntaxException, InterruptedException,\n+             java.util.concurrent.ExecutionException {\n+    final Configuration conf = new Configuration();\n+    conf.set(\"fs.blocking.impl\", BlockingInitializer.NAME);\n+    // only one instance can be created at a time.\n+    URI uri = new URI(\"blocking://a\");\n+    ListeningExecutorService pool =\n+        BlockingThreadPoolExecutorService.newInstance(count * 2, 0,\n+            10, TimeUnit.SECONDS,\n+            \"creation-threads\");\n+\n+    // submit a set of requests to create an FS instance.\n+    // the semaphore will block all but one, and that will block until\n+    // it is allowed to continue\n+    List<ListenableFuture<FileSystem>> futures = new ArrayList<>(count);\n+\n+    // acquire the semaphore so blocking all FS instances from\n+    // being initialized.\n+    Semaphore semaphore = BlockingInitializer.sem;\n+    semaphore.acquire();\n+\n+    // su", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abd2ee20d0a4082e98a53df674206ab1b72f50b2"}, "originalPosition": 132}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE5NTQwNjA5", "url": "https://github.com/apache/hadoop/pull/2396#pullrequestreview-519540609", "createdAt": "2020-10-29T10:48:05Z", "commit": {"oid": "abd2ee20d0a4082e98a53df674206ab1b72f50b2"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxMDo0ODowNVrOHqWLaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxMDo0ODoxNVrOHqWLsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDE2NTYwOQ==", "bodyText": "Should we have this as @VisibleForTesting?", "url": "https://github.com/apache/hadoop/pull/2396#discussion_r514165609", "createdAt": "2020-10-29T10:48:05Z", "author": {"login": "mehakmeet"}, "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/FileSystem.java", "diffHunk": "@@ -3517,33 +3546,86 @@ private FileSystem getInternal(URI uri, Configuration conf, Key key)\n       if (fs != null) {\n         return fs;\n       }\n-\n-      fs = createFileSystem(uri, conf);\n-      final long timeout = conf.getTimeDuration(SERVICE_SHUTDOWN_TIMEOUT,\n-          SERVICE_SHUTDOWN_TIMEOUT_DEFAULT,\n-          ShutdownHookManager.TIME_UNIT_DEFAULT);\n-      synchronized (this) { // refetch the lock again\n-        FileSystem oldfs = map.get(key);\n-        if (oldfs != null) { // a file system is created while lock is releasing\n-          fs.close(); // close the new file system\n-          return oldfs;  // return the old file system\n-        }\n-\n-        // now insert the new file system into the map\n-        if (map.isEmpty()\n-                && !ShutdownHookManager.get().isShutdownInProgress()) {\n-          ShutdownHookManager.get().addShutdownHook(clientFinalizer,\n-              SHUTDOWN_HOOK_PRIORITY, timeout,\n-              ShutdownHookManager.TIME_UNIT_DEFAULT);\n+      // fs not yet created, acquire lock\n+      // to construct an instance.\n+      try (DurationInfo d =\n+              new DurationInfo(LOGGER, false, \"Acquiring creator semaphore for %s\",\n+                  uri)) {\n+        creatorPermits.acquire();\n+      } catch (InterruptedException e) {\n+        // acquisition was interrupted; convert to an IOE.\n+        throw (IOException)new InterruptedIOException(e.toString())\n+            .initCause(e);\n+      }\n+      FileSystem fsToClose = null;\n+      try {\n+        // See if FS was instantiated by another thread while waiting\n+        // for the permit.\n+        synchronized (this) {\n+          fs = map.get(key);\n         }\n-        fs.key = key;\n-        map.put(key, fs);\n-        if (conf.getBoolean(\n-            FS_AUTOMATIC_CLOSE_KEY, FS_AUTOMATIC_CLOSE_DEFAULT)) {\n-          toAutoClose.add(key);\n+        if (fs != null) {\n+          LOGGER.debug(\"Filesystem {} created while awaiting semaphore\", uri);\n+          return fs;\n         }\n-        return fs;\n+        // create the filesystem\n+        fs = createFileSystem(uri, conf);\n+        final long timeout = conf.getTimeDuration(SERVICE_SHUTDOWN_TIMEOUT,\n+            SERVICE_SHUTDOWN_TIMEOUT_DEFAULT,\n+            ShutdownHookManager.TIME_UNIT_DEFAULT);\n+        // any FS to close outside of the synchronized section\n+        synchronized (this) { // lock on the Cache object\n+\n+          // see if there is now an entry for the FS, which happens\n+          // if another thread's creation overlapped with this one.\n+          FileSystem oldfs = map.get(key);\n+          if (oldfs != null) {\n+            // a file system was created in a separate thread.\n+            // save the FS reference to close outside all locks,\n+            // and switch to returning the oldFS\n+            fsToClose = fs;\n+            fs = oldfs;\n+          } else {\n+            // register the clientFinalizer if needed and shutdown isn't\n+            // already active\n+            if (map.isEmpty()\n+                && !ShutdownHookManager.get().isShutdownInProgress()) {\n+              ShutdownHookManager.get().addShutdownHook(clientFinalizer,\n+                  SHUTDOWN_HOOK_PRIORITY, timeout,\n+                  ShutdownHookManager.TIME_UNIT_DEFAULT);\n+            }\n+            // insert the new file system into the map\n+            fs.key = key;\n+            map.put(key, fs);\n+            if (conf.getBoolean(\n+                FS_AUTOMATIC_CLOSE_KEY, FS_AUTOMATIC_CLOSE_DEFAULT)) {\n+              toAutoClose.add(key);\n+            }\n+          }\n+        } // end of synchronized block\n+      } finally {\n+        // release the creator permit.\n+        creatorPermits.release();\n+      }\n+      if (fsToClose != null) {\n+        LOGGER.debug(\"Duplicate FS created for {}; discarding {}\",\n+            uri, fs);\n+        discardedInstances.incrementAndGet();\n+        // close the new file system\n+        // note this will briefly remove and reinstate \"fsToClose\" from\n+        // the map. It is done in a synchronized block so will not be\n+        // visible to others.\n+        fsToClose.close();\n       }\n+      return fs;\n+    }\n+\n+    /**\n+     * Get the count of discarded instances.\n+     * @return the new instance.\n+     */\n+    long getDiscardedInstances() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abd2ee20d0a4082e98a53df674206ab1b72f50b2"}, "originalPosition": 191}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDE2NTY4Mg==", "bodyText": "typo: \"aquire\" -> \"acquire\"", "url": "https://github.com/apache/hadoop/pull/2396#discussion_r514165682", "createdAt": "2020-10-29T10:48:15Z", "author": {"login": "mehakmeet"}, "path": "hadoop-common-project/hadoop-common/src/test/java/org/apache/hadoop/fs/TestFileSystemCaching.java", "diffHunk": "@@ -336,4 +344,134 @@ public void testCacheIncludesURIUserInfo() throws Throwable {\n     assertNotEquals(keyA, new FileSystem.Cache.Key(\n         new URI(\"wasb://a:password@account.blob.core.windows.net\"), conf));\n   }\n+\n+\n+  /**\n+   * Single semaphore: no surplus FS instances will be created\n+   * and then discarded.\n+   */\n+  @Test\n+  public void testCacheSingleSemaphoredConstruction() throws Exception {\n+    FileSystem.Cache cache = semaphoredCache(1);\n+    createFileSystems(cache, 10);\n+    Assertions.assertThat(cache.getDiscardedInstances())\n+        .describedAs(\"Discarded FS instances\")\n+        .isEqualTo(0);\n+  }\n+\n+  /**\n+   * Dual semaphore: thread 2 will get as far as\n+   * blocking in the initialize() method while awaiting\n+   * thread 1 to complete its initialization.\n+   * <p></p>\n+   * The thread 2 FS instance will be discarded.\n+   * All other threads will block for a cache semaphore,\n+   * so when they are given an opportunity to proceed,\n+   * they will find that an FS instance exists.\n+   */\n+  @Test\n+  public void testCacheDualSemaphoreConstruction() throws Exception {\n+    FileSystem.Cache cache = semaphoredCache(2);\n+    createFileSystems(cache, 10);\n+    Assertions.assertThat(cache.getDiscardedInstances())\n+        .describedAs(\"Discarded FS instances\")\n+        .isEqualTo(1);\n+  }\n+\n+  /**\n+   * Construct the FS instances in a cache with effectively no\n+   * limit on the number of instances which can be created\n+   * simultaneously.\n+   * <p></p>\n+   * This is the effective state before HADOOP-17313.\n+   * <p></p>\n+   * All but one thread's FS instance will be discarded.\n+   */\n+  @Test\n+  public void testCacheLargeSemaphoreConstruction() throws Exception {\n+    FileSystem.Cache cache = semaphoredCache(999);\n+    int count = 10;\n+    createFileSystems(cache, count);\n+    Assertions.assertThat(cache.getDiscardedInstances())\n+        .describedAs(\"Discarded FS instances\")\n+        .isEqualTo(count -1);\n+  }\n+\n+  /**\n+   * Create a cache with a given semaphore size.\n+   * @param semaphores number of semaphores\n+   * @return the cache.\n+   */\n+  private FileSystem.Cache semaphoredCache(final int semaphores) {\n+    final Configuration conf1 = new Configuration();\n+    conf1.setInt(FS_CREATION_PARALLEL_COUNT, semaphores);\n+    FileSystem.Cache cache = new FileSystem.Cache(conf1);\n+    return cache;\n+  }\n+\n+  /**\n+   * Attempt to create {@code count} filesystems in parallel,\n+   * then assert that they are all equal.\n+   * @param cache cache to use\n+   * @param count count of filesystems to instantiate\n+   */\n+  private void createFileSystems(final FileSystem.Cache cache, final int count)\n+      throws URISyntaxException, InterruptedException,\n+             java.util.concurrent.ExecutionException {\n+    final Configuration conf = new Configuration();\n+    conf.set(\"fs.blocking.impl\", BlockingInitializer.NAME);\n+    // only one instance can be created at a time.\n+    URI uri = new URI(\"blocking://a\");\n+    ListeningExecutorService pool =\n+        BlockingThreadPoolExecutorService.newInstance(count * 2, 0,\n+            10, TimeUnit.SECONDS,\n+            \"creation-threads\");\n+\n+    // submit a set of requests to create an FS instance.\n+    // the semaphore will block all but one, and that will block until\n+    // it is allowed to continue\n+    List<ListenableFuture<FileSystem>> futures = new ArrayList<>(count);\n+\n+    // acquire the semaphore so blocking all FS instances from\n+    // being initialized.\n+    Semaphore semaphore = BlockingInitializer.sem;\n+    semaphore.acquire();\n+\n+    // su\n+    for (int i = 0; i < count; i++) {\n+      futures.add(pool.submit(\n+          () -> cache.get(uri, conf)));\n+    }\n+    // now let all blocked initializers free\n+    semaphore.release();\n+    // get that first FS\n+    FileSystem createdFS = futures.get(0).get();\n+    // verify all the others are the same instance\n+    for (int i = 1; i < count; i++) {\n+      FileSystem fs = futures.get(i).get();\n+      Assertions.assertThat(fs)\n+          .isSameAs(createdFS);\n+    }\n+  }\n+\n+  /**\n+   * An FS which blocks in initialize() until it can aquire the shared", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abd2ee20d0a4082e98a53df674206ab1b72f50b2"}, "originalPosition": 150}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIxMzQ5NTY3", "url": "https://github.com/apache/hadoop/pull/2396#pullrequestreview-521349567", "createdAt": "2020-11-02T06:04:54Z", "commit": {"oid": "fa4b65df4bd9118bb2caadc9d3b2e6756bf1dfc2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwNjowNDo1NFrOHr3NrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwNjowNDo1NFrOHr3NrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc1NTQzNg==", "bodyText": "What if close() throw IOException ?\nEven it has cached object, it will not return that.", "url": "https://github.com/apache/hadoop/pull/2396#discussion_r515755436", "createdAt": "2020-11-02T06:04:54Z", "author": {"login": "surendralilhore"}, "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/FileSystem.java", "diffHunk": "@@ -3517,33 +3546,86 @@ private FileSystem getInternal(URI uri, Configuration conf, Key key)\n       if (fs != null) {\n         return fs;\n       }\n-\n-      fs = createFileSystem(uri, conf);\n-      final long timeout = conf.getTimeDuration(SERVICE_SHUTDOWN_TIMEOUT,\n-          SERVICE_SHUTDOWN_TIMEOUT_DEFAULT,\n-          ShutdownHookManager.TIME_UNIT_DEFAULT);\n-      synchronized (this) { // refetch the lock again\n-        FileSystem oldfs = map.get(key);\n-        if (oldfs != null) { // a file system is created while lock is releasing\n-          fs.close(); // close the new file system\n-          return oldfs;  // return the old file system\n-        }\n-\n-        // now insert the new file system into the map\n-        if (map.isEmpty()\n-                && !ShutdownHookManager.get().isShutdownInProgress()) {\n-          ShutdownHookManager.get().addShutdownHook(clientFinalizer,\n-              SHUTDOWN_HOOK_PRIORITY, timeout,\n-              ShutdownHookManager.TIME_UNIT_DEFAULT);\n+      // fs not yet created, acquire lock\n+      // to construct an instance.\n+      try (DurationInfo d = new DurationInfo(LOGGER, false,\n+          \"Acquiring creator semaphore for %s\", uri)) {\n+        creatorPermits.acquire();\n+      } catch (InterruptedException e) {\n+        // acquisition was interrupted; convert to an IOE.\n+        throw (IOException)new InterruptedIOException(e.toString())\n+            .initCause(e);\n+      }\n+      FileSystem fsToClose = null;\n+      try {\n+        // See if FS was instantiated by another thread while waiting\n+        // for the permit.\n+        synchronized (this) {\n+          fs = map.get(key);\n         }\n-        fs.key = key;\n-        map.put(key, fs);\n-        if (conf.getBoolean(\n-            FS_AUTOMATIC_CLOSE_KEY, FS_AUTOMATIC_CLOSE_DEFAULT)) {\n-          toAutoClose.add(key);\n+        if (fs != null) {\n+          LOGGER.debug(\"Filesystem {} created while awaiting semaphore\", uri);\n+          return fs;\n         }\n-        return fs;\n+        // create the filesystem\n+        fs = createFileSystem(uri, conf);\n+        final long timeout = conf.getTimeDuration(SERVICE_SHUTDOWN_TIMEOUT,\n+            SERVICE_SHUTDOWN_TIMEOUT_DEFAULT,\n+            ShutdownHookManager.TIME_UNIT_DEFAULT);\n+        // any FS to close outside of the synchronized section\n+        synchronized (this) { // lock on the Cache object\n+\n+          // see if there is now an entry for the FS, which happens\n+          // if another thread's creation overlapped with this one.\n+          FileSystem oldfs = map.get(key);\n+          if (oldfs != null) {\n+            // a file system was created in a separate thread.\n+            // save the FS reference to close outside all locks,\n+            // and switch to returning the oldFS\n+            fsToClose = fs;\n+            fs = oldfs;\n+          } else {\n+            // register the clientFinalizer if needed and shutdown isn't\n+            // already active\n+            if (map.isEmpty()\n+                && !ShutdownHookManager.get().isShutdownInProgress()) {\n+              ShutdownHookManager.get().addShutdownHook(clientFinalizer,\n+                  SHUTDOWN_HOOK_PRIORITY, timeout,\n+                  ShutdownHookManager.TIME_UNIT_DEFAULT);\n+            }\n+            // insert the new file system into the map\n+            fs.key = key;\n+            map.put(key, fs);\n+            if (conf.getBoolean(\n+                FS_AUTOMATIC_CLOSE_KEY, FS_AUTOMATIC_CLOSE_DEFAULT)) {\n+              toAutoClose.add(key);\n+            }\n+          }\n+        } // end of synchronized block\n+      } finally {\n+        // release the creator permit.\n+        creatorPermits.release();\n       }\n+      if (fsToClose != null) {\n+        LOGGER.debug(\"Duplicate FS created for {}; discarding {}\",\n+            uri, fs);\n+        discardedInstances.incrementAndGet();\n+        // close the new file system\n+        // note this will briefly remove and reinstate \"fsToClose\" from\n+        // the map. It is done in a synchronized block so will not be\n+        // visible to others.\n+        fsToClose.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa4b65df4bd9118bb2caadc9d3b2e6756bf1dfc2"}, "originalPosition": 181}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fa4b65df4bd9118bb2caadc9d3b2e6756bf1dfc2", "author": {"user": {"login": "steveloughran", "name": "Steve Loughran"}}, "url": "https://github.com/apache/hadoop/commit/fa4b65df4bd9118bb2caadc9d3b2e6756bf1dfc2", "committedDate": "2020-10-29T17:23:35Z", "message": "HADOOP-17313: FileSystem caching.\n\n* Address Mehakmeet's comments\n* Checkstyles\n* And document in s3 performance file\n\nChange-Id: I9568f980f4e9917448a1d4d1c7c2d070a6f28bad"}, "afterCommit": {"oid": "40f9e9892a1e2d3c6c42002a0d2025837b20e2aa", "author": {"user": {"login": "steveloughran", "name": "Steve Loughran"}}, "url": "https://github.com/apache/hadoop/commit/40f9e9892a1e2d3c6c42002a0d2025837b20e2aa", "committedDate": "2020-11-17T15:20:12Z", "message": "HADOOP-17313. Better handling of close() in FileSystem.get()\n\nif, in FileSystem.get(), a superfluous instance is closed(), exceptions\nthere are swallowed.\n\nAlso: put the deregistration of the class from the cache into a finally\nblock, so even if a subclass's processDeleteOnExit code raises any exception,\nthe filesystem is removed from the cache\n\nChange-Id: I513215fe266bbad7a864481d0505cc9073a7c35a"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "40f9e9892a1e2d3c6c42002a0d2025837b20e2aa", "author": {"user": {"login": "steveloughran", "name": "Steve Loughran"}}, "url": "https://github.com/apache/hadoop/commit/40f9e9892a1e2d3c6c42002a0d2025837b20e2aa", "committedDate": "2020-11-17T15:20:12Z", "message": "HADOOP-17313. Better handling of close() in FileSystem.get()\n\nif, in FileSystem.get(), a superfluous instance is closed(), exceptions\nthere are swallowed.\n\nAlso: put the deregistration of the class from the cache into a finally\nblock, so even if a subclass's processDeleteOnExit code raises any exception,\nthe filesystem is removed from the cache\n\nChange-Id: I513215fe266bbad7a864481d0505cc9073a7c35a"}, "afterCommit": {"oid": "5c41240ae3e5aba1375fcb1402ea0a08b6b646ee", "author": {"user": {"login": "steveloughran", "name": "Steve Loughran"}}, "url": "https://github.com/apache/hadoop/commit/5c41240ae3e5aba1375fcb1402ea0a08b6b646ee", "committedDate": "2020-11-19T14:59:16Z", "message": "HADOOP-17313. Better handling of close() in FileSystem.get()\n\nif, in FileSystem.get(), a superfluous instance is closed(), exceptions\nthere are swallowed.\n\nAlso: put the deregistration of the class from the cache into a finally\nblock, so even if a subclass's processDeleteOnExit code raises any exception,\nthe filesystem is removed from the cache\n\nChange-Id: I513215fe266bbad7a864481d0505cc9073a7c35a"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ae7695463ebcc5978523af20196feba423061d0b", "author": {"user": {"login": "steveloughran", "name": "Steve Loughran"}}, "url": "https://github.com/apache/hadoop/commit/ae7695463ebcc5978523af20196feba423061d0b", "committedDate": "2020-11-23T15:52:01Z", "message": "HADOOP-17313. FileSystem.get to support slow-to-instantiate FS clients.\n\nAdds a semaphore to throttle the #of parallel clients which can be\ncreated simultaneously, set in \"fs.creation.parallel.count\".\n\nChange-Id: I794cecac4a23ae7e1aa376e16b4085ea5ae20086"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b64a1b39d57cbf0282ed486567663d08ca7b4915", "author": {"user": {"login": "steveloughran", "name": "Steve Loughran"}}, "url": "https://github.com/apache/hadoop/commit/b64a1b39d57cbf0282ed486567663d08ca7b4915", "committedDate": "2020-11-23T15:52:01Z", "message": "HADOOP-17313. Semaphored FS instantiation.\n\n* Move FileSystem.close() outside the semaphored block, so\n  it does not hold up other threads.\n* Tests which use the count of discarded instances for their\n  assertions.\n\nChange-Id: I4dfaf6f2a327142048438b1bfa4c4517e595df50"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8e91d96bab9eccdb448cd48e6c4611fecfe1fa9d", "author": {"user": {"login": "steveloughran", "name": "Steve Loughran"}}, "url": "https://github.com/apache/hadoop/commit/8e91d96bab9eccdb448cd48e6c4611fecfe1fa9d", "committedDate": "2020-11-23T15:52:02Z", "message": "HADOOP-17313: FileSystem caching.\n\n* Address Mehakmeet's comments\n* Checkstyles\n* And document in s3 performance file\n\nChange-Id: I9568f980f4e9917448a1d4d1c7c2d070a6f28bad"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "788a73b34e567bc42ea05178e0c6060000be1e0d", "author": {"user": {"login": "steveloughran", "name": "Steve Loughran"}}, "url": "https://github.com/apache/hadoop/commit/788a73b34e567bc42ea05178e0c6060000be1e0d", "committedDate": "2020-11-23T15:52:02Z", "message": "HADOOP-17313. Better handling of close() in FileSystem.get()\n\nif, in FileSystem.get(), a superfluous instance is closed(), exceptions\nthere are swallowed.\n\nAlso: put the deregistration of the class from the cache into a finally\nblock, so even if a subclass's processDeleteOnExit code raises any exception,\nthe filesystem is removed from the cache\n\nChange-Id: I513215fe266bbad7a864481d0505cc9073a7c35a"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5c41240ae3e5aba1375fcb1402ea0a08b6b646ee", "author": {"user": {"login": "steveloughran", "name": "Steve Loughran"}}, "url": "https://github.com/apache/hadoop/commit/5c41240ae3e5aba1375fcb1402ea0a08b6b646ee", "committedDate": "2020-11-19T14:59:16Z", "message": "HADOOP-17313. Better handling of close() in FileSystem.get()\n\nif, in FileSystem.get(), a superfluous instance is closed(), exceptions\nthere are swallowed.\n\nAlso: put the deregistration of the class from the cache into a finally\nblock, so even if a subclass's processDeleteOnExit code raises any exception,\nthe filesystem is removed from the cache\n\nChange-Id: I513215fe266bbad7a864481d0505cc9073a7c35a"}, "afterCommit": {"oid": "788a73b34e567bc42ea05178e0c6060000be1e0d", "author": {"user": {"login": "steveloughran", "name": "Steve Loughran"}}, "url": "https://github.com/apache/hadoop/commit/788a73b34e567bc42ea05178e0c6060000be1e0d", "committedDate": "2020-11-23T15:52:02Z", "message": "HADOOP-17313. Better handling of close() in FileSystem.get()\n\nif, in FileSystem.get(), a superfluous instance is closed(), exceptions\nthere are swallowed.\n\nAlso: put the deregistration of the class from the cache into a finally\nblock, so even if a subclass's processDeleteOnExit code raises any exception,\nthe filesystem is removed from the cache\n\nChange-Id: I513215fe266bbad7a864481d0505cc9073a7c35a"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3480, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}