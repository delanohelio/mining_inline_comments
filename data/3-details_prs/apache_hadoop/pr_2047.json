{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI2ODI4NTI2", "number": 2047, "title": "HDFS-15383. RBF: Add support for router delegation token without watch", "bodyText": "Summary:\nThis patch is targeting improving router's performance\nfor delegation tokens related operations.\nIt achieves the goal by removing watchers from router on\ntokens since based on our experience. The huge number of\nwatches inside Zookeeper is degrading Zookeeper's performance\npretty hard. The current limit is about 1.2-1.5 million.\nSpecific changes:\n\nExplicitly disable the watcher to tokens by not using\nPathChildrenCache or any curator provided cache at all.\nSchedule a sync task between router and Zookeeper at\na configurable interval to make routers sync with their\ntoken information through Zookeeper.\nFor token's change, always make sure to change local cache\nfirst instead of depending on callbacks of the watch event\nwhen using PathChildrenCache.\nThe above three points are trying to make router token cache\nbehaves as close as possible to the case when the PathChildrenCache\nis used. The below point handles one corner case.\nBefore token remover(a background thread) removes token from\nZookeeper, one router will first make sure this token hasn't\nbeen renewed by other peers. This happens only when somehow the\nsync failed for this token that router local cache doesn't have\nthe corret renewal date (expiry date)\n\nTest Plan:\n\nAdd several unit tests covering all common use cases.\nDeployed on two machines and performing all tests.\nPressure testing: create production scale number of tokens (100k)\nand monitor the sync latency.\n\nNOTICE\nPlease create an issue in ASF JIRA before opening a pull request,\nand you need to set the title of the pull request which starts with\nthe corresponding JIRA issue number. (e.g. HADOOP-XXXXX. Fix a typo in YYY.)\nFor more details, please see https://cwiki.apache.org/confluence/display/HADOOP/How+To+Contribute", "createdAt": "2020-06-02T21:03:18Z", "url": "https://github.com/apache/hadoop/pull/2047", "merged": true, "mergeCommit": {"oid": "84110d850e2bc2a9ff4afcc7508fecd81cb5b7e5"}, "closed": true, "closedAt": "2020-06-23T20:12:29Z", "author": {"login": "fengnanli"}, "timelineItems": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcna_7MgH2gAyNDI2ODI4NTI2OjUxMDc0ZDJlYzE5MGQ0OTgwZTBkYmY1MGQ0YmZmOTM1ZDljNTY5ZmI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABctE5GoAFqTQzNDQxODQyMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "51074d2ec190d4980e0dbf50d4bff935d9c569fb", "author": {"user": {"login": "fengnanli", "name": "lfengnan"}}, "url": "https://github.com/apache/hadoop/commit/51074d2ec190d4980e0dbf50d4bff935d9c569fb", "committedDate": "2020-06-02T20:36:29Z", "message": "Add support for router delegation token without watch\n\nSummary:\nThis patch is targeting improving router's performance\nfor delegation tokens related operations.\nIt achieves the goal by removing watchers from router on\ntokens since based on our experience. The huge number of\nwatches inside Zookeeper is degrading Zookeeper's performance\npretty hard. The current limit is about 1.2-1.5 million.\n\nSpecific changes:\n1. Explicitly disable the watcher to tokens by not using\n   PathChildrenCache or any curator provided cache at all.\n2. Schedule a sync task between router and Zookeeper at\n   a configurable interval to make routers sync with their\n   token information through Zookeeper.\n3. For token's change, always make sure to change local cache\n   first instead of depending on callbacks of the watch event\n   when using PathChildrenCache.\nThe above three points are trying to make router token cache\nbehaves as close as possible to the case when the PathChildrenCache\nis used. The below point handles one corner case.\n4. Before token remover(a background thread) removes token from\n   Zookeeper, one router will first make sure this token hasn't\n   been renewed by other peers. This happens only when somehow the\n   sync failed for this token that router local cache doesn't have\n   the corret renewal date (expiry date)\n\nTest Plan:\n1. Add several unit tests covering all common use cases.\n2. Deployed on two machines and performing all tests.\n3. Pressure testing: create production scale number of tokens (100k)\n   and monitor the sync latency."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzMzU4Njc5", "url": "https://github.com/apache/hadoop/pull/2047#pullrequestreview-423358679", "createdAt": "2020-06-03T09:04:24Z", "commit": {"oid": "51074d2ec190d4980e0dbf50d4bff935d9c569fb"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwOTowNDoyNFrOGeS0GA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwOToyNTo0MlrOGeTmBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQxODcxMg==", "bodyText": "a. It is better to keep the same code style.\n  public static final String ZK_DTSM_ROUTER_TOKEN_SYNC_INTERVAL =\n      \"zk-dt-secret-manager.router.token.sync.interval\";\n\n->\n  public static final String ZK_DTSM_ROUTER_TOKEN_SYNC_INTERVAL =\n      ZK_CONF_PREFIX + \"router.token.sync.interval\";\n\nb. IMO, this is common improvement, it should not aimed at Router only, right?", "url": "https://github.com/apache/hadoop/pull/2047#discussion_r434418712", "createdAt": "2020-06-03T09:04:24Z", "author": {"login": "Hexiaoqiao"}, "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/security/token/ZKDelegationTokenSecretManagerImpl.java", "diffHunk": "@@ -19,38 +19,211 @@\n package org.apache.hadoop.hdfs.server.federation.router.security.token;\n \n import org.apache.hadoop.hdfs.security.token.delegation.DelegationTokenIdentifier;\n+import org.apache.hadoop.security.token.Token;\n import org.apache.hadoop.security.token.delegation.AbstractDelegationTokenIdentifier;\n import org.apache.hadoop.security.token.delegation.ZKDelegationTokenSecretManager;\n+import org.apache.hadoop.util.Time;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.ZooKeeper;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.apache.hadoop.conf.Configuration;\n \n+import java.io.ByteArrayInputStream;\n+import java.io.DataInputStream;\n import java.io.IOException;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n \n /**\n  * Zookeeper based router delegation token store implementation.\n  */\n public class ZKDelegationTokenSecretManagerImpl extends\n     ZKDelegationTokenSecretManager<AbstractDelegationTokenIdentifier> {\n \n+  public static final String ZK_DTSM_ROUTER_TOKEN_SYNC_INTERVAL =\n+      \"zk-dt-secret-manager.router.token.sync.interval\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51074d2ec190d4980e0dbf50d4bff935d9c569fb"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQyMTg2MA==", "bodyText": "depracating -> deprecating?", "url": "https://github.com/apache/hadoop/pull/2047#discussion_r434421860", "createdAt": "2020-06-03T09:09:37Z", "author": {"login": "Hexiaoqiao"}, "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/security/token/ZKDelegationTokenSecretManagerImpl.java", "diffHunk": "@@ -19,38 +19,211 @@\n package org.apache.hadoop.hdfs.server.federation.router.security.token;\n \n import org.apache.hadoop.hdfs.security.token.delegation.DelegationTokenIdentifier;\n+import org.apache.hadoop.security.token.Token;\n import org.apache.hadoop.security.token.delegation.AbstractDelegationTokenIdentifier;\n import org.apache.hadoop.security.token.delegation.ZKDelegationTokenSecretManager;\n+import org.apache.hadoop.util.Time;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.ZooKeeper;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.apache.hadoop.conf.Configuration;\n \n+import java.io.ByteArrayInputStream;\n+import java.io.DataInputStream;\n import java.io.IOException;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n \n /**\n  * Zookeeper based router delegation token store implementation.\n  */\n public class ZKDelegationTokenSecretManagerImpl extends\n     ZKDelegationTokenSecretManager<AbstractDelegationTokenIdentifier> {\n \n+  public static final String ZK_DTSM_ROUTER_TOKEN_SYNC_INTERVAL =\n+      \"zk-dt-secret-manager.router.token.sync.interval\";\n+  public static final int ZK_DTSM_ROUTER_TOKEN_SYNC_INTERVAL_DEFAULT = 5;\n+\n   private static final Logger LOG =\n       LoggerFactory.getLogger(ZKDelegationTokenSecretManagerImpl.class);\n \n-  private Configuration conf = null;\n+  private Configuration conf;\n+\n+  private final ScheduledExecutorService scheduler =\n+      Executors.newSingleThreadScheduledExecutor();\n+\n+  // Local cache of delegation tokens, used for depracating tokens from", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51074d2ec190d4980e0dbf50d4bff935d9c569fb"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQyNzM2MQ==", "bodyText": "It looks there are double deserialize operations, it should be better if we can merge them to one IMO.", "url": "https://github.com/apache/hadoop/pull/2047#discussion_r434427361", "createdAt": "2020-06-03T09:18:37Z", "author": {"login": "Hexiaoqiao"}, "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/security/token/ZKDelegationTokenSecretManagerImpl.java", "diffHunk": "@@ -19,38 +19,211 @@\n package org.apache.hadoop.hdfs.server.federation.router.security.token;\n \n import org.apache.hadoop.hdfs.security.token.delegation.DelegationTokenIdentifier;\n+import org.apache.hadoop.security.token.Token;\n import org.apache.hadoop.security.token.delegation.AbstractDelegationTokenIdentifier;\n import org.apache.hadoop.security.token.delegation.ZKDelegationTokenSecretManager;\n+import org.apache.hadoop.util.Time;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.ZooKeeper;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.apache.hadoop.conf.Configuration;\n \n+import java.io.ByteArrayInputStream;\n+import java.io.DataInputStream;\n import java.io.IOException;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n \n /**\n  * Zookeeper based router delegation token store implementation.\n  */\n public class ZKDelegationTokenSecretManagerImpl extends\n     ZKDelegationTokenSecretManager<AbstractDelegationTokenIdentifier> {\n \n+  public static final String ZK_DTSM_ROUTER_TOKEN_SYNC_INTERVAL =\n+      \"zk-dt-secret-manager.router.token.sync.interval\";\n+  public static final int ZK_DTSM_ROUTER_TOKEN_SYNC_INTERVAL_DEFAULT = 5;\n+\n   private static final Logger LOG =\n       LoggerFactory.getLogger(ZKDelegationTokenSecretManagerImpl.class);\n \n-  private Configuration conf = null;\n+  private Configuration conf;\n+\n+  private final ScheduledExecutorService scheduler =\n+      Executors.newSingleThreadScheduledExecutor();\n+\n+  // Local cache of delegation tokens, used for depracating tokens from\n+  // currentTokenMap\n+  private final Set<AbstractDelegationTokenIdentifier> localTokenCache =\n+      new HashSet<>();\n+  // Native zk client for getting all tokens\n+  private ZooKeeper zookeeper;\n+  private final String TOKEN_PATH = \"/\" + zkClient.getNamespace()\n+      + ZK_DTSM_TOKENS_ROOT;\n+  // The flag used to issue an extra check before deletion\n+  // Since cancel token and token remover thread use the same\n+  // API here and one router could have a token that is renewed\n+  // by another router, thus token remover should always check ZK\n+  // to confirm whether it has been renewed or not\n+  private ThreadLocal<Boolean> checkAgainstZkBeforeDeletion =\n+      new ThreadLocal<Boolean>() {\n+        @Override\n+        protected Boolean initialValue() {\n+          return true;\n+        }\n+      };\n \n   public ZKDelegationTokenSecretManagerImpl(Configuration conf) {\n     super(conf);\n     this.conf = conf;\n     try {\n-      super.startThreads();\n+      startThreads();\n     } catch (IOException e) {\n       LOG.error(\"Error starting threads for zkDelegationTokens\", e);\n     }\n     LOG.info(\"Zookeeper delegation token secret manager instantiated\");\n   }\n \n+  @Override\n+  public void startThreads() throws IOException {\n+    super.startThreads();\n+    // start token cache related work when watcher is disabled\n+    if (!isTokenWatcherEnabled()) {\n+      LOG.info(\"Watcher for tokens is disabled in this secret manager\");\n+      try {\n+        // By default set this variable\n+        checkAgainstZkBeforeDeletion.set(true);\n+        // Ensure the token root path exists\n+        if (zkClient.checkExists().forPath(ZK_DTSM_TOKENS_ROOT) == null) {\n+          zkClient.create().creatingParentsIfNeeded()\n+              .withMode(CreateMode.PERSISTENT)\n+              .forPath(ZK_DTSM_TOKENS_ROOT);\n+        }\n+        // Set up zookeeper client\n+        try {\n+          zookeeper = zkClient.getZookeeperClient().getZooKeeper();\n+        } catch (Exception e) {\n+          LOG.info(\"Cannot get zookeeper client \", e);\n+        } finally {\n+          if (zookeeper == null) {\n+            throw new IOException(\"Zookeeper client is null\");\n+          }\n+        }\n+\n+        LOG.info(\"Start loading token cache\");\n+        long start = Time.now();\n+        rebuildTokenCache(true);\n+        LOG.info(\"Loaded token cache in {} milliseconds\", Time.now() - start);\n+\n+        int syncInterval = conf.getInt(ZK_DTSM_ROUTER_TOKEN_SYNC_INTERVAL,\n+            ZK_DTSM_ROUTER_TOKEN_SYNC_INTERVAL_DEFAULT);\n+        scheduler.scheduleAtFixedRate(new Runnable() {\n+          @Override\n+          public void run() {\n+            try {\n+              rebuildTokenCache(false);\n+            } catch (Exception e) {\n+              // ignore\n+            }\n+          }\n+        }, syncInterval, syncInterval, TimeUnit.SECONDS);\n+      } catch (Exception e) {\n+        LOG.error(\"Error rebuilding local cache for zkDelegationTokens \", e);\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void stopThreads() {\n+    super.stopThreads();\n+    scheduler.shutdown();\n+  }\n+\n   @Override\n   public DelegationTokenIdentifier createIdentifier() {\n     return new DelegationTokenIdentifier();\n   }\n+\n+  /**\n+   * This function will rebuild local token cache from zk storage.\n+   * It is first called when the secret manager is initialized and\n+   * then regularly at a configured interval.\n+   *\n+   * @param initial whether this is called during initialization\n+   * @throws IOException\n+   */\n+  private void rebuildTokenCache(boolean initial) throws IOException {\n+    localTokenCache.clear();\n+    // Use bare zookeeper client to get all children since curator will\n+    // wrap the same API with a sorting process. This is time consuming given\n+    // millions of tokens\n+    List<String> zkTokens;\n+    try {\n+      zkTokens = zookeeper.getChildren(TOKEN_PATH, false);\n+    } catch (KeeperException | InterruptedException e) {\n+      throw new IOException(\"Tokens cannot be fetched from path \"\n+          + TOKEN_PATH, e);\n+    }\n+    byte[] data;\n+    for (String tokenPath : zkTokens) {\n+      try {\n+        data = zkClient.getData().forPath(\n+            ZK_DTSM_TOKENS_ROOT + \"/\" + tokenPath);\n+      } catch (KeeperException.NoNodeException e) {\n+        LOG.debug(\"No node in path [\" + tokenPath + \"]\");\n+        continue;\n+      } catch (Exception ex) {\n+        throw new IOException(ex);\n+      }\n+      // Store data to currentTokenMap\n+      processTokenAddOrUpdate(data);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51074d2ec190d4980e0dbf50d4bff935d9c569fb"}, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQzMDMzMQ==", "bodyText": "After this loop, content of loacalTokenCache is equal to currentTokens right? If that, should we set the currentTokens = localTokenCache directly? Please correct me if wrong.", "url": "https://github.com/apache/hadoop/pull/2047#discussion_r434430331", "createdAt": "2020-06-03T09:23:43Z", "author": {"login": "Hexiaoqiao"}, "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/security/token/ZKDelegationTokenSecretManagerImpl.java", "diffHunk": "@@ -19,38 +19,211 @@\n package org.apache.hadoop.hdfs.server.federation.router.security.token;\n \n import org.apache.hadoop.hdfs.security.token.delegation.DelegationTokenIdentifier;\n+import org.apache.hadoop.security.token.Token;\n import org.apache.hadoop.security.token.delegation.AbstractDelegationTokenIdentifier;\n import org.apache.hadoop.security.token.delegation.ZKDelegationTokenSecretManager;\n+import org.apache.hadoop.util.Time;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.ZooKeeper;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.apache.hadoop.conf.Configuration;\n \n+import java.io.ByteArrayInputStream;\n+import java.io.DataInputStream;\n import java.io.IOException;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n \n /**\n  * Zookeeper based router delegation token store implementation.\n  */\n public class ZKDelegationTokenSecretManagerImpl extends\n     ZKDelegationTokenSecretManager<AbstractDelegationTokenIdentifier> {\n \n+  public static final String ZK_DTSM_ROUTER_TOKEN_SYNC_INTERVAL =\n+      \"zk-dt-secret-manager.router.token.sync.interval\";\n+  public static final int ZK_DTSM_ROUTER_TOKEN_SYNC_INTERVAL_DEFAULT = 5;\n+\n   private static final Logger LOG =\n       LoggerFactory.getLogger(ZKDelegationTokenSecretManagerImpl.class);\n \n-  private Configuration conf = null;\n+  private Configuration conf;\n+\n+  private final ScheduledExecutorService scheduler =\n+      Executors.newSingleThreadScheduledExecutor();\n+\n+  // Local cache of delegation tokens, used for depracating tokens from\n+  // currentTokenMap\n+  private final Set<AbstractDelegationTokenIdentifier> localTokenCache =\n+      new HashSet<>();\n+  // Native zk client for getting all tokens\n+  private ZooKeeper zookeeper;\n+  private final String TOKEN_PATH = \"/\" + zkClient.getNamespace()\n+      + ZK_DTSM_TOKENS_ROOT;\n+  // The flag used to issue an extra check before deletion\n+  // Since cancel token and token remover thread use the same\n+  // API here and one router could have a token that is renewed\n+  // by another router, thus token remover should always check ZK\n+  // to confirm whether it has been renewed or not\n+  private ThreadLocal<Boolean> checkAgainstZkBeforeDeletion =\n+      new ThreadLocal<Boolean>() {\n+        @Override\n+        protected Boolean initialValue() {\n+          return true;\n+        }\n+      };\n \n   public ZKDelegationTokenSecretManagerImpl(Configuration conf) {\n     super(conf);\n     this.conf = conf;\n     try {\n-      super.startThreads();\n+      startThreads();\n     } catch (IOException e) {\n       LOG.error(\"Error starting threads for zkDelegationTokens\", e);\n     }\n     LOG.info(\"Zookeeper delegation token secret manager instantiated\");\n   }\n \n+  @Override\n+  public void startThreads() throws IOException {\n+    super.startThreads();\n+    // start token cache related work when watcher is disabled\n+    if (!isTokenWatcherEnabled()) {\n+      LOG.info(\"Watcher for tokens is disabled in this secret manager\");\n+      try {\n+        // By default set this variable\n+        checkAgainstZkBeforeDeletion.set(true);\n+        // Ensure the token root path exists\n+        if (zkClient.checkExists().forPath(ZK_DTSM_TOKENS_ROOT) == null) {\n+          zkClient.create().creatingParentsIfNeeded()\n+              .withMode(CreateMode.PERSISTENT)\n+              .forPath(ZK_DTSM_TOKENS_ROOT);\n+        }\n+        // Set up zookeeper client\n+        try {\n+          zookeeper = zkClient.getZookeeperClient().getZooKeeper();\n+        } catch (Exception e) {\n+          LOG.info(\"Cannot get zookeeper client \", e);\n+        } finally {\n+          if (zookeeper == null) {\n+            throw new IOException(\"Zookeeper client is null\");\n+          }\n+        }\n+\n+        LOG.info(\"Start loading token cache\");\n+        long start = Time.now();\n+        rebuildTokenCache(true);\n+        LOG.info(\"Loaded token cache in {} milliseconds\", Time.now() - start);\n+\n+        int syncInterval = conf.getInt(ZK_DTSM_ROUTER_TOKEN_SYNC_INTERVAL,\n+            ZK_DTSM_ROUTER_TOKEN_SYNC_INTERVAL_DEFAULT);\n+        scheduler.scheduleAtFixedRate(new Runnable() {\n+          @Override\n+          public void run() {\n+            try {\n+              rebuildTokenCache(false);\n+            } catch (Exception e) {\n+              // ignore\n+            }\n+          }\n+        }, syncInterval, syncInterval, TimeUnit.SECONDS);\n+      } catch (Exception e) {\n+        LOG.error(\"Error rebuilding local cache for zkDelegationTokens \", e);\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void stopThreads() {\n+    super.stopThreads();\n+    scheduler.shutdown();\n+  }\n+\n   @Override\n   public DelegationTokenIdentifier createIdentifier() {\n     return new DelegationTokenIdentifier();\n   }\n+\n+  /**\n+   * This function will rebuild local token cache from zk storage.\n+   * It is first called when the secret manager is initialized and\n+   * then regularly at a configured interval.\n+   *\n+   * @param initial whether this is called during initialization\n+   * @throws IOException\n+   */\n+  private void rebuildTokenCache(boolean initial) throws IOException {\n+    localTokenCache.clear();\n+    // Use bare zookeeper client to get all children since curator will\n+    // wrap the same API with a sorting process. This is time consuming given\n+    // millions of tokens\n+    List<String> zkTokens;\n+    try {\n+      zkTokens = zookeeper.getChildren(TOKEN_PATH, false);\n+    } catch (KeeperException | InterruptedException e) {\n+      throw new IOException(\"Tokens cannot be fetched from path \"\n+          + TOKEN_PATH, e);\n+    }\n+    byte[] data;\n+    for (String tokenPath : zkTokens) {\n+      try {\n+        data = zkClient.getData().forPath(\n+            ZK_DTSM_TOKENS_ROOT + \"/\" + tokenPath);\n+      } catch (KeeperException.NoNodeException e) {\n+        LOG.debug(\"No node in path [\" + tokenPath + \"]\");\n+        continue;\n+      } catch (Exception ex) {\n+        throw new IOException(ex);\n+      }\n+      // Store data to currentTokenMap\n+      processTokenAddOrUpdate(data);\n+      // Store data to localTokenCache for sync\n+      AbstractDelegationTokenIdentifier ident = createIdentifier();\n+      DataInputStream din = new DataInputStream(new ByteArrayInputStream(data));\n+      ident.readFields(din);\n+      localTokenCache.add(ident);\n+    }\n+    if (!initial) {\n+      // Sync zkTokens with local cache, specifically\n+      // 1) add/update tokens to local cache from zk, which is done through\n+      //    processTokenAddOrUpdate above\n+      // 2) remove tokens in local cache but not in zk anymore\n+      for (AbstractDelegationTokenIdentifier ident : currentTokens.keySet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51074d2ec190d4980e0dbf50d4bff935d9c569fb"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQzMTQ5NQ==", "bodyText": "lack of license annotation\uff1f", "url": "https://github.com/apache/hadoop/pull/2047#discussion_r434431495", "createdAt": "2020-06-03T09:25:42Z", "author": {"login": "Hexiaoqiao"}, "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/test/java/org/apache/hadoop/hdfs/server/federation/security/token/TestZKDelegationTokenSecretManagerImpl.java", "diffHunk": "@@ -0,0 +1,216 @@\n+package org.apache.hadoop.hdfs.server.federation.security.token;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51074d2ec190d4980e0dbf50d4bff935d9c569fb"}, "originalPosition": 1}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "38dc294ecc480b29c0d7096b4788c1501866460a", "author": {"user": {"login": "fengnanli", "name": "lfengnan"}}, "url": "https://github.com/apache/hadoop/commit/38dc294ecc480b29c0d7096b4788c1501866460a", "committedDate": "2020-06-19T05:14:34Z", "message": "Address comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0MjQwNTgw", "url": "https://github.com/apache/hadoop/pull/2047#pullrequestreview-434240580", "createdAt": "2020-06-19T17:31:50Z", "commit": {"oid": "38dc294ecc480b29c0d7096b4788c1501866460a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0NDE4NDIx", "url": "https://github.com/apache/hadoop/pull/2047#pullrequestreview-434418421", "createdAt": "2020-06-20T10:14:40Z", "commit": {"oid": "38dc294ecc480b29c0d7096b4788c1501866460a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4361, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}