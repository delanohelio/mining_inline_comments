{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIyOTA5NDA1", "number": 2470, "title": "HADOOP-16524. Reloading SSL keystore for both DataNode and NameNode", "bodyText": "Addresses https://issues.apache.org/jira/browse/HADOOP-16524, in addition covering the DataNode use case.\n\nFollowing the existing ReloadingX509TrustManager, a new ReloadingX509KeystoreManager was created.\nExisting code slightly refactored so both trust manager and keystore reloading managers share the monitoring logic within a single java.util.Timer (and therefore a single thread).\nIn HttpServer2, the same strategy as a previously proposed patch (see above) is used with SSLContextFactory.reload, but with the addition of cleanup upon stopping the server.\nA new config parameter which applies to all of the above FileBasedKeyStoresFactory.SSL_STORES_RELOAD_INTERVAL_TPL_KEY supersedes the existing FileBasedKeyStoresFactory.SSL_TRUSTSTORE_RELOAD_INTERVAL_TPL_KEY which only applies to trust store reloading. Setting the value to 0 (default is 10s) to this parameter disables the reloading.\n\nIf this PR is accepted, I would need guidance where/how to update the docs with that new configuration parameter.", "createdAt": "2020-11-18T04:50:15Z", "url": "https://github.com/apache/hadoop/pull/2470", "merged": true, "mergeCommit": {"oid": "e306f594218e4de3d960ecb3cc8876cd03db8b10"}, "closed": true, "closedAt": "2021-01-08T17:10:22Z", "author": {"login": "bolerio"}, "timelineItems": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABddk6ROAH2gAyNTIyOTA5NDA1OmQzNmYwNTQzZTQ0NWFmMTE1ZjVmZWQzZDlmMTQwMDQ3YjcxMTIyZjI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdkpraVAFqTU0ODc2NDk0OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "d36f0543e445af115f5fed3d9f140047b71122f2", "author": {"user": null}, "url": "https://github.com/apache/hadoop/commit/d36f0543e445af115f5fed3d9f140047b71122f2", "committedDate": "2020-11-18T02:41:16Z", "message": "HADOOP-16524. Reloading SSL keystore for both DataNode and NameNode"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQzMjA2MDUz", "url": "https://github.com/apache/hadoop/pull/2470#pullrequestreview-543206053", "createdAt": "2020-12-02T20:21:34Z", "commit": {"oid": "d36f0543e445af115f5fed3d9f140047b71122f2"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQyMDoyMTozNVrOH9soow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQwMDoyODozMVrOH-7XFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ1NjQ4Mw==", "bodyText": "nit: this.configurationChangeMonitor is already Optional.empty? So, change this to be if (storesReloadInterval > 0) {....}?", "url": "https://github.com/apache/hadoop/pull/2470#discussion_r534456483", "createdAt": "2020-12-02T20:21:35Z", "author": {"login": "saintstack"}, "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/http/HttpServer2.java", "diffHunk": "@@ -569,12 +577,45 @@ private ServerConnector createHttpsChannelConnector(\n       }\n \n       setEnabledProtocols(sslContextFactory);\n+\n+      long storesReloadInterval =\n+          conf.getLong(FileBasedKeyStoresFactory.SSL_STORES_RELOAD_INTERVAL_TPL_KEY,\n+              FileBasedKeyStoresFactory.DEFAULT_SSL_STORES_RELOAD_INTERVAL);\n+\n+      this.configurationChangeMonitor = storesReloadInterval > 0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d36f0543e445af115f5fed3d9f140047b71122f2"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ1Nzg1NA==", "bodyText": "Keep the style of the backing class... It doesn't do these big right-shifts on parameters that go to the second line. Be careful w/ line lengths too. The backing file seems to do 80 chars.", "url": "https://github.com/apache/hadoop/pull/2470#discussion_r534457854", "createdAt": "2020-12-02T20:24:11Z", "author": {"login": "saintstack"}, "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/http/HttpServer2.java", "diffHunk": "@@ -569,12 +577,45 @@ private ServerConnector createHttpsChannelConnector(\n       }\n \n       setEnabledProtocols(sslContextFactory);\n+\n+      long storesReloadInterval =\n+          conf.getLong(FileBasedKeyStoresFactory.SSL_STORES_RELOAD_INTERVAL_TPL_KEY,\n+              FileBasedKeyStoresFactory.DEFAULT_SSL_STORES_RELOAD_INTERVAL);\n+\n+      this.configurationChangeMonitor = storesReloadInterval > 0\n+          ? Optional.of(this.makeConfigurationChangeMonitor(storesReloadInterval, sslContextFactory))\n+          : Optional.empty();\n+\n       conn.addFirstConnectionFactory(new SslConnectionFactory(sslContextFactory,\n           HttpVersion.HTTP_1_1.asString()));\n \n       return conn;\n     }\n \n+    private java.util.Timer makeConfigurationChangeMonitor(long reloadInterval,\n+                                                           SslContextFactory.Server sslContextFactory) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d36f0543e445af115f5fed3d9f140047b71122f2"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ1ODgzMQ==", "bodyText": "nit: See the formatting for catch in the rest of the file. It does not do this.", "url": "https://github.com/apache/hadoop/pull/2470#discussion_r534458831", "createdAt": "2020-12-02T20:25:52Z", "author": {"login": "saintstack"}, "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/http/HttpServer2.java", "diffHunk": "@@ -569,12 +577,45 @@ private ServerConnector createHttpsChannelConnector(\n       }\n \n       setEnabledProtocols(sslContextFactory);\n+\n+      long storesReloadInterval =\n+          conf.getLong(FileBasedKeyStoresFactory.SSL_STORES_RELOAD_INTERVAL_TPL_KEY,\n+              FileBasedKeyStoresFactory.DEFAULT_SSL_STORES_RELOAD_INTERVAL);\n+\n+      this.configurationChangeMonitor = storesReloadInterval > 0\n+          ? Optional.of(this.makeConfigurationChangeMonitor(storesReloadInterval, sslContextFactory))\n+          : Optional.empty();\n+\n       conn.addFirstConnectionFactory(new SslConnectionFactory(sslContextFactory,\n           HttpVersion.HTTP_1_1.asString()));\n \n       return conn;\n     }\n \n+    private java.util.Timer makeConfigurationChangeMonitor(long reloadInterval,\n+                                                           SslContextFactory.Server sslContextFactory) {\n+      java.util.Timer timer = new java.util.Timer(\"SSL Certificates Store Monitor\", true);\n+      //\n+      // The Jetty SSLContextFactory provides a 'reload' method which will reload both\n+      // truststore and keystore certificates.\n+      //\n+      timer.schedule(new FileMonitoringTimerTask(\n+              Paths.get(keyStore),\n+              path -> {\n+                LOG.info(\"Reloading certificates from store keystore \" + keyStore);\n+                try {\n+                  sslContextFactory.reload(factory -> { });\n+                }\n+                catch (Exception ex) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d36f0543e445af115f5fed3d9f140047b71122f2"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ1OTc2Mg==", "bodyText": "Why the full qualification of Timer here and as function return? You have imported java.util.Timer so no need of these 'java.util' prefixes?", "url": "https://github.com/apache/hadoop/pull/2470#discussion_r534459762", "createdAt": "2020-12-02T20:27:25Z", "author": {"login": "saintstack"}, "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/http/HttpServer2.java", "diffHunk": "@@ -569,12 +577,45 @@ private ServerConnector createHttpsChannelConnector(\n       }\n \n       setEnabledProtocols(sslContextFactory);\n+\n+      long storesReloadInterval =\n+          conf.getLong(FileBasedKeyStoresFactory.SSL_STORES_RELOAD_INTERVAL_TPL_KEY,\n+              FileBasedKeyStoresFactory.DEFAULT_SSL_STORES_RELOAD_INTERVAL);\n+\n+      this.configurationChangeMonitor = storesReloadInterval > 0\n+          ? Optional.of(this.makeConfigurationChangeMonitor(storesReloadInterval, sslContextFactory))\n+          : Optional.empty();\n+\n       conn.addFirstConnectionFactory(new SslConnectionFactory(sslContextFactory,\n           HttpVersion.HTTP_1_1.asString()));\n \n       return conn;\n     }\n \n+    private java.util.Timer makeConfigurationChangeMonitor(long reloadInterval,\n+                                                           SslContextFactory.Server sslContextFactory) {\n+      java.util.Timer timer = new java.util.Timer(\"SSL Certificates Store Monitor\", true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d36f0543e445af115f5fed3d9f140047b71122f2"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ2MTMyOQ==", "bodyText": "nit: line lengths", "url": "https://github.com/apache/hadoop/pull/2470#discussion_r534461329", "createdAt": "2020-12-02T20:30:12Z", "author": {"login": "saintstack"}, "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/ssl/FileBasedKeyStoresFactory.java", "diffHunk": "@@ -29,20 +29,20 @@\n import javax.net.ssl.KeyManagerFactory;\n import javax.net.ssl.TrustManager;\n import java.io.IOException;\n-import java.io.InputStream;\n-import java.nio.file.Files;\n import java.nio.file.Paths;\n import java.security.GeneralSecurityException;\n import java.security.KeyStore;\n import java.text.MessageFormat;\n+import java.util.Timer;\n \n /**\n  * {@link KeyStoresFactory} implementation that reads the certificates from\n  * keystore files.\n  * <p>\n- * if the trust certificates keystore file changes, the {@link TrustManager}\n- * is refreshed with the new trust certificate entries (using a\n- * {@link ReloadingX509TrustManager} trustmanager).\n+ * If either the truststore or the keystore certificates file changes, it would be refreshed", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d36f0543e445af115f5fed3d9f140047b71122f2"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ2MjMyMw==", "bodyText": "This class is audience private so presuming it ok changing this public static's name.", "url": "https://github.com/apache/hadoop/pull/2470#discussion_r534462323", "createdAt": "2020-12-02T20:32:03Z", "author": {"login": "saintstack"}, "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/ssl/FileBasedKeyStoresFactory.java", "diffHunk": "@@ -77,14 +84,118 @@\n   public static final String DEFAULT_KEYSTORE_TYPE = \"jks\";\n \n   /**\n-   * Reload interval in milliseconds.\n+   * The default time interval in milliseconds used to check if either\n+   * of the truststore or keystore certificates file has changed and needs reloading.\n    */\n-  public static final int DEFAULT_SSL_TRUSTSTORE_RELOAD_INTERVAL = 10000;\n+  public static final int DEFAULT_SSL_STORES_RELOAD_INTERVAL = 10000;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d36f0543e445af115f5fed3d9f140047b71122f2"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTc0NjMyNQ==", "bodyText": "Does the rest of this class do this extreme rightward shifting of parameters?", "url": "https://github.com/apache/hadoop/pull/2470#discussion_r535746325", "createdAt": "2020-12-04T00:28:31Z", "author": {"login": "saintstack"}, "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/ssl/FileBasedKeyStoresFactory.java", "diffHunk": "@@ -77,14 +84,118 @@\n   public static final String DEFAULT_KEYSTORE_TYPE = \"jks\";\n \n   /**\n-   * Reload interval in milliseconds.\n+   * The default time interval in milliseconds used to check if either\n+   * of the truststore or keystore certificates file has changed and needs reloading.\n    */\n-  public static final int DEFAULT_SSL_TRUSTSTORE_RELOAD_INTERVAL = 10000;\n+  public static final int DEFAULT_SSL_STORES_RELOAD_INTERVAL = 10000;\n \n   private Configuration conf;\n   private KeyManager[] keyManagers;\n   private TrustManager[] trustManagers;\n   private ReloadingX509TrustManager trustManager;\n+  private Timer fileMonitoringTimer;\n+\n+\n+  private void createTrustManagersFromConfiguration(SSLFactory.Mode mode,\n+                                                    String truststoreType,\n+                                                    String truststoreLocation,\n+                                                    long storesReloadInterval)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d36f0543e445af115f5fed3d9f140047b71122f2"}, "originalPosition": 61}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0Njc4ODIx", "url": "https://github.com/apache/hadoop/pull/2470#pullrequestreview-544678821", "createdAt": "2020-12-04T06:06:06Z", "commit": {"oid": "d36f0543e445af115f5fed3d9f140047b71122f2"}, "state": "COMMENTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQwNjowNjowNlrOH_CMTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQwNjoyNjoyNVrOH_Coug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg1ODI1NA==", "bodyText": "getPassword will never return null?", "url": "https://github.com/apache/hadoop/pull/2470#discussion_r535858254", "createdAt": "2020-12-04T06:06:06Z", "author": {"login": "saintstack"}, "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/ssl/FileBasedKeyStoresFactory.java", "diffHunk": "@@ -77,14 +84,118 @@\n   public static final String DEFAULT_KEYSTORE_TYPE = \"jks\";\n \n   /**\n-   * Reload interval in milliseconds.\n+   * The default time interval in milliseconds used to check if either\n+   * of the truststore or keystore certificates file has changed and needs reloading.\n    */\n-  public static final int DEFAULT_SSL_TRUSTSTORE_RELOAD_INTERVAL = 10000;\n+  public static final int DEFAULT_SSL_STORES_RELOAD_INTERVAL = 10000;\n \n   private Configuration conf;\n   private KeyManager[] keyManagers;\n   private TrustManager[] trustManagers;\n   private ReloadingX509TrustManager trustManager;\n+  private Timer fileMonitoringTimer;\n+\n+\n+  private void createTrustManagersFromConfiguration(SSLFactory.Mode mode,\n+                                                    String truststoreType,\n+                                                    String truststoreLocation,\n+                                                    long storesReloadInterval)\n+      throws IOException, GeneralSecurityException {\n+    String passwordProperty = resolvePropertyName(mode,\n+        SSL_TRUSTSTORE_PASSWORD_TPL_KEY);\n+    String truststorePassword = getPassword(conf, passwordProperty, \"\");\n+    if (truststorePassword.isEmpty()) {\n+      // An empty trust store password is legal; the trust store password\n+      // is only required when writing to a trust store. Otherwise it's\n+      // an optional integrity check.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d36f0543e445af115f5fed3d9f140047b71122f2"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg1ODYyMA==", "bodyText": "Log the interval found in config here too?", "url": "https://github.com/apache/hadoop/pull/2470#discussion_r535858620", "createdAt": "2020-12-04T06:07:06Z", "author": {"login": "saintstack"}, "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/ssl/FileBasedKeyStoresFactory.java", "diffHunk": "@@ -77,14 +84,118 @@\n   public static final String DEFAULT_KEYSTORE_TYPE = \"jks\";\n \n   /**\n-   * Reload interval in milliseconds.\n+   * The default time interval in milliseconds used to check if either\n+   * of the truststore or keystore certificates file has changed and needs reloading.\n    */\n-  public static final int DEFAULT_SSL_TRUSTSTORE_RELOAD_INTERVAL = 10000;\n+  public static final int DEFAULT_SSL_STORES_RELOAD_INTERVAL = 10000;\n \n   private Configuration conf;\n   private KeyManager[] keyManagers;\n   private TrustManager[] trustManagers;\n   private ReloadingX509TrustManager trustManager;\n+  private Timer fileMonitoringTimer;\n+\n+\n+  private void createTrustManagersFromConfiguration(SSLFactory.Mode mode,\n+                                                    String truststoreType,\n+                                                    String truststoreLocation,\n+                                                    long storesReloadInterval)\n+      throws IOException, GeneralSecurityException {\n+    String passwordProperty = resolvePropertyName(mode,\n+        SSL_TRUSTSTORE_PASSWORD_TPL_KEY);\n+    String truststorePassword = getPassword(conf, passwordProperty, \"\");\n+    if (truststorePassword.isEmpty()) {\n+      // An empty trust store password is legal; the trust store password\n+      // is only required when writing to a trust store. Otherwise it's\n+      // an optional integrity check.\n+      truststorePassword = null;\n+    }\n+\n+    // Check if obsolete truststore specific reload interval is present for backward compatible\n+    long truststoreReloadInterval =\n+        conf.getLong(\n+            resolvePropertyName(mode, SSL_TRUSTSTORE_RELOAD_INTERVAL_TPL_KEY),\n+            storesReloadInterval);\n+\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(mode.toString() + \" TrustStore: \" + truststoreLocation);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d36f0543e445af115f5fed3d9f140047b71122f2"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg2MDYyOQ==", "bodyText": "Do we have to check isEmpty here too?", "url": "https://github.com/apache/hadoop/pull/2470#discussion_r535860629", "createdAt": "2020-12-04T06:12:46Z", "author": {"login": "saintstack"}, "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/ssl/FileBasedKeyStoresFactory.java", "diffHunk": "@@ -77,14 +84,118 @@\n   public static final String DEFAULT_KEYSTORE_TYPE = \"jks\";\n \n   /**\n-   * Reload interval in milliseconds.\n+   * The default time interval in milliseconds used to check if either\n+   * of the truststore or keystore certificates file has changed and needs reloading.\n    */\n-  public static final int DEFAULT_SSL_TRUSTSTORE_RELOAD_INTERVAL = 10000;\n+  public static final int DEFAULT_SSL_STORES_RELOAD_INTERVAL = 10000;\n \n   private Configuration conf;\n   private KeyManager[] keyManagers;\n   private TrustManager[] trustManagers;\n   private ReloadingX509TrustManager trustManager;\n+  private Timer fileMonitoringTimer;\n+\n+\n+  private void createTrustManagersFromConfiguration(SSLFactory.Mode mode,\n+                                                    String truststoreType,\n+                                                    String truststoreLocation,\n+                                                    long storesReloadInterval)\n+      throws IOException, GeneralSecurityException {\n+    String passwordProperty = resolvePropertyName(mode,\n+        SSL_TRUSTSTORE_PASSWORD_TPL_KEY);\n+    String truststorePassword = getPassword(conf, passwordProperty, \"\");\n+    if (truststorePassword.isEmpty()) {\n+      // An empty trust store password is legal; the trust store password\n+      // is only required when writing to a trust store. Otherwise it's\n+      // an optional integrity check.\n+      truststorePassword = null;\n+    }\n+\n+    // Check if obsolete truststore specific reload interval is present for backward compatible\n+    long truststoreReloadInterval =\n+        conf.getLong(\n+            resolvePropertyName(mode, SSL_TRUSTSTORE_RELOAD_INTERVAL_TPL_KEY),\n+            storesReloadInterval);\n+\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(mode.toString() + \" TrustStore: \" + truststoreLocation);\n+    }\n+\n+    trustManager = new ReloadingX509TrustManager(\n+        truststoreType,\n+        truststoreLocation,\n+        truststorePassword);\n+\n+    if (truststoreReloadInterval > 0) {\n+      fileMonitoringTimer.schedule(\n+          new FileMonitoringTimerTask(\n+              Paths.get(truststoreLocation),\n+              path -> trustManager.loadFrom(path),\n+              exception -> LOG.error(ReloadingX509TrustManager.RELOAD_ERROR_MESSAGE, exception)),\n+          truststoreReloadInterval,\n+          truststoreReloadInterval);\n+    }\n+\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug(mode.toString() + \" Loaded TrustStore: \" + truststoreLocation);\n+    }\n+    trustManagers = new TrustManager[]{trustManager};\n+  }\n+\n+  /**\n+   * Implements logic of initializing the KeyManagers with the options\n+   * to reload keystores.\n+   * @param mode client or server\n+   * @param keystoreType The keystore type.\n+   * @param storesReloadInterval The interval to check if the keystore certificates\n+   *                             file has changed.\n+   */\n+  private void createKeyManagersFromConfiguration(SSLFactory.Mode mode,\n+                                                  String keystoreType, long storesReloadInterval)\n+      throws GeneralSecurityException, IOException {\n+    String locationProperty =\n+        resolvePropertyName(mode, SSL_KEYSTORE_LOCATION_TPL_KEY);\n+    String keystoreLocation = conf.get(locationProperty, \"\");\n+    if (keystoreLocation.isEmpty()) {\n+      throw new GeneralSecurityException(\"The property '\" + locationProperty +\n+          \"' has not been set in the ssl configuration file.\");\n+    }\n+    String passwordProperty =\n+        resolvePropertyName(mode, SSL_KEYSTORE_PASSWORD_TPL_KEY);\n+    String keystorePassword = getPassword(conf, passwordProperty, \"\");\n+    if (keystorePassword.isEmpty()) {\n+      throw new GeneralSecurityException(\"The property '\" + passwordProperty +\n+          \"' has not been set in the ssl configuration file.\");\n+    }\n+    String keyPasswordProperty =\n+        resolvePropertyName(mode, SSL_KEYSTORE_KEYPASSWORD_TPL_KEY);\n+    // Key password defaults to the same value as store password for\n+    // compatibility with legacy configurations that did not use a separate\n+    // configuration property for key password.\n+    String keystoreKeyPassword = getPassword(\n+        conf, keyPasswordProperty, keystorePassword);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d36f0543e445af115f5fed3d9f140047b71122f2"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg2MjIwNg==", "bodyText": "Hmm... maybe it does. Ignore the above comment then.", "url": "https://github.com/apache/hadoop/pull/2470#discussion_r535862206", "createdAt": "2020-12-04T06:17:20Z", "author": {"login": "saintstack"}, "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/ssl/FileBasedKeyStoresFactory.java", "diffHunk": "@@ -77,14 +84,118 @@\n   public static final String DEFAULT_KEYSTORE_TYPE = \"jks\";\n \n   /**\n-   * Reload interval in milliseconds.\n+   * The default time interval in milliseconds used to check if either\n+   * of the truststore or keystore certificates file has changed and needs reloading.\n    */\n-  public static final int DEFAULT_SSL_TRUSTSTORE_RELOAD_INTERVAL = 10000;\n+  public static final int DEFAULT_SSL_STORES_RELOAD_INTERVAL = 10000;\n \n   private Configuration conf;\n   private KeyManager[] keyManagers;\n   private TrustManager[] trustManagers;\n   private ReloadingX509TrustManager trustManager;\n+  private Timer fileMonitoringTimer;\n+\n+\n+  private void createTrustManagersFromConfiguration(SSLFactory.Mode mode,\n+                                                    String truststoreType,\n+                                                    String truststoreLocation,\n+                                                    long storesReloadInterval)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTc0NjMyNQ=="}, "originalCommit": {"oid": "d36f0543e445af115f5fed3d9f140047b71122f2"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg2Mjg2NQ==", "bodyText": "No need of the  wrappers.", "url": "https://github.com/apache/hadoop/pull/2470#discussion_r535862865", "createdAt": "2020-12-04T06:19:21Z", "author": {"login": "saintstack"}, "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/ssl/FileMonitoringTimerTask.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.security.ssl;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.nio.file.Path;\n+import java.util.TimerTask;\n+import java.util.function.Consumer;\n+\n+/**\n+ * <p>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d36f0543e445af115f5fed3d9f140047b71122f2"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg2MzcxNA==", "bodyText": "nit: not consistent in where we locate private... sometimes at start (the usual) and other times as second qualifier. (Can we make all these datamembers private?)", "url": "https://github.com/apache/hadoop/pull/2470#discussion_r535863714", "createdAt": "2020-12-04T06:21:29Z", "author": {"login": "saintstack"}, "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/ssl/FileMonitoringTimerTask.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.security.ssl;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.nio.file.Path;\n+import java.util.TimerTask;\n+import java.util.function.Consumer;\n+\n+/**\n+ * <p>\n+ * Implements basic logic to track when a file changes on disk and call the action\n+ * passed to the constructor when it does. An exception handler can optionally also be specified\n+ * in the constructor, otherwise any exception occurring during process will be logged\n+ * using this class' logger.\n+ * </p>\n+ */\n+@InterfaceAudience.Private\n+public class FileMonitoringTimerTask extends TimerTask {\n+\n+    static final Logger LOG = LoggerFactory.getLogger(FileMonitoringTimerTask.class);\n+\n+    @VisibleForTesting\n+    static final String PROCESS_ERROR_MESSAGE =\n+            \"Could not process file change : \";\n+\n+    final private Path filePath;\n+    final private Consumer<Path> onFileChange;\n+    final Consumer<Throwable> onChangeFailure;\n+    private long lastProcessed;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d36f0543e445af115f5fed3d9f140047b71122f2"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg2NDIzMQ==", "bodyText": "The tab offsets seem to be 4 spaces when should be 2 as it is elsewhere in hadoop.", "url": "https://github.com/apache/hadoop/pull/2470#discussion_r535864231", "createdAt": "2020-12-04T06:22:43Z", "author": {"login": "saintstack"}, "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/ssl/FileMonitoringTimerTask.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.security.ssl;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.nio.file.Path;\n+import java.util.TimerTask;\n+import java.util.function.Consumer;\n+\n+/**\n+ * <p>\n+ * Implements basic logic to track when a file changes on disk and call the action\n+ * passed to the constructor when it does. An exception handler can optionally also be specified\n+ * in the constructor, otherwise any exception occurring during process will be logged\n+ * using this class' logger.\n+ * </p>\n+ */\n+@InterfaceAudience.Private\n+public class FileMonitoringTimerTask extends TimerTask {\n+\n+    static final Logger LOG = LoggerFactory.getLogger(FileMonitoringTimerTask.class);\n+\n+    @VisibleForTesting\n+    static final String PROCESS_ERROR_MESSAGE =\n+            \"Could not process file change : \";\n+\n+    final private Path filePath;\n+    final private Consumer<Path> onFileChange;\n+    final Consumer<Throwable> onChangeFailure;\n+    private long lastProcessed;\n+\n+    /**\n+     * Create file monitoring task to be scheduled using a standard Java {@link java.util.Timer}\n+     * instance.\n+     *\n+     * @param filePath The path to the file to monitor.\n+     * @param onFileChange The function to call when the file has changed.\n+     * @param onChangeFailure The function to call when an exception is thrown during the\n+     *                       file change processing.\n+     */\n+    public FileMonitoringTimerTask(Path filePath,\n+                                   Consumer<Path> onFileChange,\n+                                   Consumer<Throwable> onChangeFailure) {\n+        Preconditions.checkNotNull(filePath, \"path to monitor disk file is not set\");\n+        Preconditions.checkNotNull(onFileChange, \"action to monitor disk file is not set\");\n+\n+        this.filePath = filePath;\n+        this.lastProcessed = filePath.toFile().lastModified();\n+        this.onFileChange = onFileChange;\n+        this.onChangeFailure = onChangeFailure;\n+    }\n+\n+    @Override\n+    public void run() {\n+        if (lastProcessed != filePath.toFile().lastModified()) {\n+            try {\n+                onFileChange.accept(filePath);\n+            } catch (Throwable t) {\n+                if (onChangeFailure  != null) {\n+                    onChangeFailure.accept(t);\n+                } else {\n+                    LOG.error(PROCESS_ERROR_MESSAGE + filePath.toString(), t);\n+                }\n+            }\n+            lastProcessed = filePath.toFile().lastModified();\n+        }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d36f0543e445af115f5fed3d9f140047b71122f2"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg2NDU4MQ==", "bodyText": "Yeah, tab seems to be 4 when should be 2 spaces.", "url": "https://github.com/apache/hadoop/pull/2470#discussion_r535864581", "createdAt": "2020-12-04T06:23:54Z", "author": {"login": "saintstack"}, "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/ssl/ReloadingX509KeystoreManager.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.security.ssl;\n+\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.apache.hadoop.classification.InterfaceStability;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.net.ssl.*;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.Socket;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.security.GeneralSecurityException;\n+import java.security.KeyStore;\n+import java.security.Principal;\n+import java.security.PrivateKey;\n+import java.security.cert.X509Certificate;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * An implementation of <code>X509KeyManager</code> that exposes a method,\n+ * {@link #loadFrom(Path)} to reload its configuration. Note that it is necessary\n+ * to implement the <code>X509ExtendedKeyManager</code> to properly delegate\n+ * the additional methods, otherwise the SSL handshake will fail.\n+ */\n+@InterfaceAudience.Private\n+@InterfaceStability.Evolving\n+public class ReloadingX509KeystoreManager extends X509ExtendedKeyManager {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(ReloadingX509TrustManager.class);\n+\n+    static final String RELOAD_ERROR_MESSAGE =\n+            \"Could not load keystore (keep using existing one) : \";\n+\n+    private String type;\n+    private String storePassword;\n+    private String keyPassword;\n+    private AtomicReference<X509ExtendedKeyManager> keyManagerRef;\n+\n+    /**\n+     * Construct a <code>Reloading509KeystoreManager</code>\n+     *\n+     * @param type type of keystore file, typically 'jks'.\n+     * @param location local path to the keystore file.\n+     * @param storePassword password of the keystore file.\n+     * @param keyPassword The password of the key.\n+     * @throws IOException\n+     * @throws GeneralSecurityException\n+     */\n+    public ReloadingX509KeystoreManager(String type, String location,\n+                                        String storePassword, String keyPassword)\n+            throws IOException, GeneralSecurityException {\n+        this.type = type;\n+        this.storePassword = storePassword;\n+        this.keyPassword = keyPassword;\n+        keyManagerRef = new AtomicReference<X509ExtendedKeyManager>();\n+        keyManagerRef.set(loadKeyManager(Paths.get(location)));\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d36f0543e445af115f5fed3d9f140047b71122f2"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg2NDcxNw==", "bodyText": "Can be final?", "url": "https://github.com/apache/hadoop/pull/2470#discussion_r535864717", "createdAt": "2020-12-04T06:24:10Z", "author": {"login": "saintstack"}, "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/ssl/ReloadingX509KeystoreManager.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.security.ssl;\n+\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.apache.hadoop.classification.InterfaceStability;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.net.ssl.*;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.Socket;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.security.GeneralSecurityException;\n+import java.security.KeyStore;\n+import java.security.Principal;\n+import java.security.PrivateKey;\n+import java.security.cert.X509Certificate;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * An implementation of <code>X509KeyManager</code> that exposes a method,\n+ * {@link #loadFrom(Path)} to reload its configuration. Note that it is necessary\n+ * to implement the <code>X509ExtendedKeyManager</code> to properly delegate\n+ * the additional methods, otherwise the SSL handshake will fail.\n+ */\n+@InterfaceAudience.Private\n+@InterfaceStability.Evolving\n+public class ReloadingX509KeystoreManager extends X509ExtendedKeyManager {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(ReloadingX509TrustManager.class);\n+\n+    static final String RELOAD_ERROR_MESSAGE =\n+            \"Could not load keystore (keep using existing one) : \";\n+\n+    private String type;\n+    private String storePassword;\n+    private String keyPassword;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d36f0543e445af115f5fed3d9f140047b71122f2"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg2NDkxMA==", "bodyText": "Line lengths?", "url": "https://github.com/apache/hadoop/pull/2470#discussion_r535864910", "createdAt": "2020-12-04T06:24:44Z", "author": {"login": "saintstack"}, "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/ssl/ReloadingX509KeystoreManager.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.security.ssl;\n+\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.apache.hadoop.classification.InterfaceStability;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.net.ssl.*;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.Socket;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.security.GeneralSecurityException;\n+import java.security.KeyStore;\n+import java.security.Principal;\n+import java.security.PrivateKey;\n+import java.security.cert.X509Certificate;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * An implementation of <code>X509KeyManager</code> that exposes a method,\n+ * {@link #loadFrom(Path)} to reload its configuration. Note that it is necessary\n+ * to implement the <code>X509ExtendedKeyManager</code> to properly delegate\n+ * the additional methods, otherwise the SSL handshake will fail.\n+ */\n+@InterfaceAudience.Private\n+@InterfaceStability.Evolving\n+public class ReloadingX509KeystoreManager extends X509ExtendedKeyManager {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(ReloadingX509TrustManager.class);\n+\n+    static final String RELOAD_ERROR_MESSAGE =\n+            \"Could not load keystore (keep using existing one) : \";\n+\n+    private String type;\n+    private String storePassword;\n+    private String keyPassword;\n+    private AtomicReference<X509ExtendedKeyManager> keyManagerRef;\n+\n+    /**\n+     * Construct a <code>Reloading509KeystoreManager</code>\n+     *\n+     * @param type type of keystore file, typically 'jks'.\n+     * @param location local path to the keystore file.\n+     * @param storePassword password of the keystore file.\n+     * @param keyPassword The password of the key.\n+     * @throws IOException\n+     * @throws GeneralSecurityException\n+     */\n+    public ReloadingX509KeystoreManager(String type, String location,\n+                                        String storePassword, String keyPassword)\n+            throws IOException, GeneralSecurityException {\n+        this.type = type;\n+        this.storePassword = storePassword;\n+        this.keyPassword = keyPassword;\n+        keyManagerRef = new AtomicReference<X509ExtendedKeyManager>();\n+        keyManagerRef.set(loadKeyManager(Paths.get(location)));\n+    }\n+\n+    @Override\n+    public String chooseEngineClientAlias(String[] strings, Principal[] principals, SSLEngine sslEngine) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d36f0543e445af115f5fed3d9f140047b71122f2"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg2NTUzMA==", "bodyText": "What will happen when this comes out? Where will it be caught? Will it cause damage causing process exit or thread exit?", "url": "https://github.com/apache/hadoop/pull/2470#discussion_r535865530", "createdAt": "2020-12-04T06:26:25Z", "author": {"login": "saintstack"}, "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/ssl/ReloadingX509KeystoreManager.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.security.ssl;\n+\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.apache.hadoop.classification.InterfaceStability;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.net.ssl.*;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.Socket;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.security.GeneralSecurityException;\n+import java.security.KeyStore;\n+import java.security.Principal;\n+import java.security.PrivateKey;\n+import java.security.cert.X509Certificate;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+/**\n+ * An implementation of <code>X509KeyManager</code> that exposes a method,\n+ * {@link #loadFrom(Path)} to reload its configuration. Note that it is necessary\n+ * to implement the <code>X509ExtendedKeyManager</code> to properly delegate\n+ * the additional methods, otherwise the SSL handshake will fail.\n+ */\n+@InterfaceAudience.Private\n+@InterfaceStability.Evolving\n+public class ReloadingX509KeystoreManager extends X509ExtendedKeyManager {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(ReloadingX509TrustManager.class);\n+\n+    static final String RELOAD_ERROR_MESSAGE =\n+            \"Could not load keystore (keep using existing one) : \";\n+\n+    private String type;\n+    private String storePassword;\n+    private String keyPassword;\n+    private AtomicReference<X509ExtendedKeyManager> keyManagerRef;\n+\n+    /**\n+     * Construct a <code>Reloading509KeystoreManager</code>\n+     *\n+     * @param type type of keystore file, typically 'jks'.\n+     * @param location local path to the keystore file.\n+     * @param storePassword password of the keystore file.\n+     * @param keyPassword The password of the key.\n+     * @throws IOException\n+     * @throws GeneralSecurityException\n+     */\n+    public ReloadingX509KeystoreManager(String type, String location,\n+                                        String storePassword, String keyPassword)\n+            throws IOException, GeneralSecurityException {\n+        this.type = type;\n+        this.storePassword = storePassword;\n+        this.keyPassword = keyPassword;\n+        keyManagerRef = new AtomicReference<X509ExtendedKeyManager>();\n+        keyManagerRef.set(loadKeyManager(Paths.get(location)));\n+    }\n+\n+    @Override\n+    public String chooseEngineClientAlias(String[] strings, Principal[] principals, SSLEngine sslEngine) {\n+        return keyManagerRef.get().chooseEngineClientAlias(strings, principals, sslEngine);\n+    }\n+\n+    @Override\n+    public String chooseEngineServerAlias(String s, Principal[] principals, SSLEngine sslEngine) {\n+        return keyManagerRef.get().chooseEngineServerAlias(s, principals, sslEngine);\n+    }\n+\n+    @Override\n+    public String[] getClientAliases(String s, Principal[] principals) {\n+        return keyManagerRef.get().getClientAliases(s, principals);\n+    }\n+\n+    @Override\n+    public String chooseClientAlias(String[] strings, Principal[] principals, Socket socket) {\n+        return keyManagerRef.get().chooseClientAlias(strings, principals, socket);\n+    }\n+\n+    @Override\n+    public String[] getServerAliases(String s, Principal[] principals) {\n+        return keyManagerRef.get().getServerAliases(s, principals);\n+    }\n+\n+    @Override\n+    public String chooseServerAlias(String s, Principal[] principals, Socket socket) {\n+        return keyManagerRef.get().chooseServerAlias(s, principals, socket);\n+    }\n+\n+    @Override\n+    public X509Certificate[] getCertificateChain(String s) {\n+        return keyManagerRef.get().getCertificateChain(s);\n+    }\n+\n+    @Override\n+    public PrivateKey getPrivateKey(String s) {\n+        return keyManagerRef.get().getPrivateKey(s);\n+    }\n+\n+    public ReloadingX509KeystoreManager loadFrom(Path path) {\n+        try {\n+            this.keyManagerRef.set(loadKeyManager(path));\n+        } catch (Exception ex) {\n+            // The Consumer.accept interface forces us to convert to unchecked\n+            throw new RuntimeException(ex);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d36f0543e445af115f5fed3d9f140047b71122f2"}, "originalPosition": 124}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "be6b9cc7665a0cf1ee565cf35903137e0109c19e", "author": {"user": null}, "url": "https://github.com/apache/hadoop/commit/be6b9cc7665a0cf1ee565cf35903137e0109c19e", "committedDate": "2020-12-09T02:57:53Z", "message": "addressing PR comments by saintstack"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "142740f0f50fdc36ee358726114e10bb4d206e91", "author": {"user": null}, "url": "https://github.com/apache/hadoop/commit/142740f0f50fdc36ee358726114e10bb4d206e91", "committedDate": "2020-12-09T03:55:56Z", "message": "few more cosmetic fixes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ4NzY0OTQ4", "url": "https://github.com/apache/hadoop/pull/2470#pullrequestreview-548764948", "createdAt": "2020-12-10T02:09:08Z", "commit": {"oid": "142740f0f50fdc36ee358726114e10bb4d206e91"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwMjowOTowOFrOICyJbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQwMjowOTowOFrOICyJbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTc4OTY3Ng==", "bodyText": "Seems like your code habits align w/ the backing file here. I'd leave it as is.", "url": "https://github.com/apache/hadoop/pull/2470#discussion_r539789676", "createdAt": "2020-12-10T02:09:08Z", "author": {"login": "saintstack"}, "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/security/ssl/FileBasedKeyStoresFactory.java", "diffHunk": "@@ -77,14 +84,118 @@\n   public static final String DEFAULT_KEYSTORE_TYPE = \"jks\";\n \n   /**\n-   * Reload interval in milliseconds.\n+   * The default time interval in milliseconds used to check if either\n+   * of the truststore or keystore certificates file has changed and needs reloading.\n    */\n-  public static final int DEFAULT_SSL_TRUSTSTORE_RELOAD_INTERVAL = 10000;\n+  public static final int DEFAULT_SSL_STORES_RELOAD_INTERVAL = 10000;\n \n   private Configuration conf;\n   private KeyManager[] keyManagers;\n   private TrustManager[] trustManagers;\n   private ReloadingX509TrustManager trustManager;\n+  private Timer fileMonitoringTimer;\n+\n+\n+  private void createTrustManagersFromConfiguration(SSLFactory.Mode mode,\n+                                                    String truststoreType,\n+                                                    String truststoreLocation,\n+                                                    long storesReloadInterval)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTc0NjMyNQ=="}, "originalCommit": {"oid": "d36f0543e445af115f5fed3d9f140047b71122f2"}, "originalPosition": 61}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3269, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}