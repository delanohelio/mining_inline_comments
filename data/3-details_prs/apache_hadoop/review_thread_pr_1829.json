{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcwNDgyNzQ2", "number": 1829, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwMDoyMTozOVrODfAkXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxODo0NToyMFrODnM_-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzODQxNzU4OnYy", "diffSide": "RIGHT", "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/INodeAttributeProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwMDoyMTozOVrOFod6mQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQxODo1NzozNlrOFrzl8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk3NzQ5Nw==", "bodyText": "NIT: can you add javadoc for the new public method?", "url": "https://github.com/apache/hadoop/pull/1829#discussion_r377977497", "createdAt": "2020-02-12T00:21:39Z", "author": {"login": "xiaoyuyao"}, "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/INodeAttributeProvider.java", "diffHunk": "@@ -68,6 +277,8 @@ public abstract void checkPermission(String fsOwner, String supergroup,\n         boolean ignoreEmptyDir)\n             throws AccessControlException;\n \n+    void checkPermissionWithContext(AuthorizationContext authzContext)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1d954ba992b7be55b98ee4aaf16ddad655f52d9"}, "originalPosition": 240}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQ3ODM4NQ==", "bodyText": "done.", "url": "https://github.com/apache/hadoop/pull/1829#discussion_r381478385", "createdAt": "2020-02-19T18:57:36Z", "author": {"login": "jojochuang"}, "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/INodeAttributeProvider.java", "diffHunk": "@@ -68,6 +277,8 @@ public abstract void checkPermission(String fsOwner, String supergroup,\n         boolean ignoreEmptyDir)\n             throws AccessControlException;\n \n+    void checkPermissionWithContext(AuthorizationContext authzContext)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk3NzQ5Nw=="}, "originalCommit": {"oid": "d1d954ba992b7be55b98ee4aaf16ddad655f52d9"}, "originalPosition": 240}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzODQyMDM2OnYy", "diffSide": "RIGHT", "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/INodeAttributeProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwMDoyMzowMVrOFod8PQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQxODo1NzozMVrOFrzlyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk3NzkxNw==", "bodyText": "I don't think it is right to return always return true for two different AuthorizationContext instances.", "url": "https://github.com/apache/hadoop/pull/1829#discussion_r377977917", "createdAt": "2020-02-12T00:23:01Z", "author": {"login": "xiaoyuyao"}, "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/INodeAttributeProvider.java", "diffHunk": "@@ -17,19 +17,227 @@\n  */\n package org.apache.hadoop.hdfs.server.namenode;\n \n+import com.google.common.annotations.VisibleForTesting;\n import org.apache.commons.lang3.StringUtils;\n import org.apache.hadoop.classification.InterfaceAudience;\n import org.apache.hadoop.classification.InterfaceStability;\n import org.apache.hadoop.fs.Path;\n import org.apache.hadoop.fs.permission.FsAction;\n import org.apache.hadoop.hdfs.DFSUtil;\n+import org.apache.hadoop.ipc.CallerContext;\n import org.apache.hadoop.security.AccessControlException;\n import org.apache.hadoop.security.UserGroupInformation;\n \n @InterfaceAudience.Public\n @InterfaceStability.Unstable\n public abstract class INodeAttributeProvider {\n \n+  public static class AuthorizationContext {\n+    public String fsOwner;\n+    public String supergroup;\n+    public UserGroupInformation callerUgi;\n+    public INodeAttributes[] inodeAttrs;\n+    public INode[] inodes;\n+    public byte[][] pathByNameArr;\n+    public int snapshotId;\n+    public String path;\n+    public int ancestorIndex;\n+    public boolean doCheckOwner;\n+    public FsAction ancestorAccess;\n+    public FsAction parentAccess;\n+    public FsAction access;\n+    public FsAction subAccess;\n+    public boolean ignoreEmptyDir;\n+    public String operationName;\n+    public CallerContext callerContext;\n+\n+    public static class Builder {\n+      public String fsOwner;\n+      public String supergroup;\n+      public UserGroupInformation callerUgi;\n+      public INodeAttributes[] inodeAttrs;\n+      public INode[] inodes;\n+      public byte[][] pathByNameArr;\n+      public int snapshotId;\n+      public String path;\n+      public int ancestorIndex;\n+      public boolean doCheckOwner;\n+      public FsAction ancestorAccess;\n+      public FsAction parentAccess;\n+      public FsAction access;\n+      public FsAction subAccess;\n+      public boolean ignoreEmptyDir;\n+      public String operationName;\n+      public CallerContext callerContext;\n+\n+      public AuthorizationContext build() {\n+        return new AuthorizationContext(this);\n+      }\n+\n+      public Builder fsOwner(String val) {\n+        this.fsOwner = val;\n+        return this;\n+      }\n+\n+      public Builder supergroup(String val) {\n+        this.supergroup = val;\n+        return this;\n+      }\n+\n+      public Builder callerUgi(UserGroupInformation val) {\n+        this.callerUgi = val;\n+        return this;\n+      }\n+\n+      public Builder inodeAttrs(INodeAttributes[] val) {\n+        this.inodeAttrs = val;\n+        return this;\n+      }\n+\n+      public Builder inodes(INode[] val) {\n+        this.inodes = val;\n+        return this;\n+      }\n+\n+      public Builder pathByNameArr(byte[][] val) {\n+        this.pathByNameArr = val;\n+        return this;\n+      }\n+\n+      public Builder snapshotId(int val) {\n+        this.snapshotId = val;\n+        return this;\n+      }\n+\n+      public Builder path(String val) {\n+        this.path = val;\n+        return this;\n+      }\n+\n+      public Builder ancestorIndex(int val) {\n+        this.ancestorIndex = val;\n+        return this;\n+      }\n+\n+      public Builder doCheckOwner(boolean val) {\n+        this.doCheckOwner = val;\n+        return this;\n+      }\n+\n+      public Builder ancestorAccess(FsAction val) {\n+        this.ancestorAccess = val;\n+        return this;\n+      }\n+\n+      public Builder parentAccess(FsAction val) {\n+        this.parentAccess = val;\n+        return this;\n+      }\n+\n+      public Builder access(FsAction val) {\n+        this.access = val;\n+        return this;\n+      }\n+\n+      public Builder subAccess(FsAction val) {\n+        this.subAccess = val;\n+        return this;\n+      }\n+\n+      public Builder ignoreEmptyDir(boolean val) {\n+        this.ignoreEmptyDir = val;\n+        return this;\n+      }\n+\n+      public Builder operationName(String val) {\n+        this.operationName = val;\n+        return this;\n+      }\n+\n+      public Builder callerContext(CallerContext val) {\n+        this.callerContext = val;\n+        return this;\n+      }\n+    }\n+\n+    public AuthorizationContext(\n+        String fsOwner,\n+        String supergroup,\n+        UserGroupInformation callerUgi,\n+        INodeAttributes[] inodeAttrs,\n+        INode[] inodes,\n+        byte[][] pathByNameArr,\n+        int snapshotId,\n+        String path,\n+        int ancestorIndex,\n+        boolean doCheckOwner,\n+        FsAction ancestorAccess,\n+        FsAction parentAccess,\n+        FsAction access,\n+        FsAction subAccess,\n+        boolean ignoreEmptyDir) {\n+      this.fsOwner = fsOwner;\n+      this.supergroup = supergroup;\n+      this.callerUgi = callerUgi;\n+      this.inodeAttrs = inodeAttrs;\n+      this.inodes = inodes;\n+      this.pathByNameArr = pathByNameArr;\n+      this.snapshotId = snapshotId;\n+      this.path = path;\n+      this.ancestorIndex = ancestorIndex;\n+      this.doCheckOwner = doCheckOwner;\n+      this.ancestorAccess = ancestorAccess;\n+      this.parentAccess = parentAccess;\n+      this.access = access;\n+      this.subAccess = subAccess;\n+      this.ignoreEmptyDir = ignoreEmptyDir;\n+    }\n+\n+    public AuthorizationContext(\n+        String fsOwner,\n+        String supergroup,\n+        UserGroupInformation callerUgi,\n+        INodeAttributes[] inodeAttrs,\n+        INode[] inodes,\n+        byte[][] pathByNameArr,\n+        int snapshotId,\n+        String path,\n+        int ancestorIndex,\n+        boolean doCheckOwner,\n+        FsAction ancestorAccess,\n+        FsAction parentAccess,\n+        FsAction access,\n+        FsAction subAccess,\n+        boolean ignoreEmptyDir,\n+        String operationName,\n+        CallerContext callerContext) {\n+      this(fsOwner, supergroup, callerUgi, inodeAttrs, inodes,\n+          pathByNameArr, snapshotId, path, ancestorIndex, doCheckOwner,\n+          ancestorAccess, parentAccess, access, subAccess, ignoreEmptyDir);\n+      this.operationName = operationName;\n+      this.callerContext = callerContext;\n+    }\n+\n+    public AuthorizationContext(Builder builder) {\n+      this(builder.fsOwner, builder.supergroup, builder.callerUgi,\n+          builder.inodeAttrs, builder.inodes, builder.pathByNameArr,\n+          builder.snapshotId, builder.path, builder.ancestorIndex,\n+          builder.doCheckOwner, builder.ancestorAccess, builder.parentAccess,\n+          builder.access, builder.subAccess, builder.ignoreEmptyDir);\n+      this.operationName = builder.operationName;\n+      this.callerContext = builder.callerContext;\n+    }\n+\n+    @VisibleForTesting\n+    @Override\n+    public boolean equals(Object obj) {\n+      if (!(obj instanceof AuthorizationContext)) {\n+        return false;\n+      }\n+      return true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1d954ba992b7be55b98ee4aaf16ddad655f52d9"}, "originalPosition": 221}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQ3ODM0Ng==", "bodyText": "yes... it was meant only for test. Updated the patch to include the full object equivalence check.", "url": "https://github.com/apache/hadoop/pull/1829#discussion_r381478346", "createdAt": "2020-02-19T18:57:31Z", "author": {"login": "jojochuang"}, "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/INodeAttributeProvider.java", "diffHunk": "@@ -17,19 +17,227 @@\n  */\n package org.apache.hadoop.hdfs.server.namenode;\n \n+import com.google.common.annotations.VisibleForTesting;\n import org.apache.commons.lang3.StringUtils;\n import org.apache.hadoop.classification.InterfaceAudience;\n import org.apache.hadoop.classification.InterfaceStability;\n import org.apache.hadoop.fs.Path;\n import org.apache.hadoop.fs.permission.FsAction;\n import org.apache.hadoop.hdfs.DFSUtil;\n+import org.apache.hadoop.ipc.CallerContext;\n import org.apache.hadoop.security.AccessControlException;\n import org.apache.hadoop.security.UserGroupInformation;\n \n @InterfaceAudience.Public\n @InterfaceStability.Unstable\n public abstract class INodeAttributeProvider {\n \n+  public static class AuthorizationContext {\n+    public String fsOwner;\n+    public String supergroup;\n+    public UserGroupInformation callerUgi;\n+    public INodeAttributes[] inodeAttrs;\n+    public INode[] inodes;\n+    public byte[][] pathByNameArr;\n+    public int snapshotId;\n+    public String path;\n+    public int ancestorIndex;\n+    public boolean doCheckOwner;\n+    public FsAction ancestorAccess;\n+    public FsAction parentAccess;\n+    public FsAction access;\n+    public FsAction subAccess;\n+    public boolean ignoreEmptyDir;\n+    public String operationName;\n+    public CallerContext callerContext;\n+\n+    public static class Builder {\n+      public String fsOwner;\n+      public String supergroup;\n+      public UserGroupInformation callerUgi;\n+      public INodeAttributes[] inodeAttrs;\n+      public INode[] inodes;\n+      public byte[][] pathByNameArr;\n+      public int snapshotId;\n+      public String path;\n+      public int ancestorIndex;\n+      public boolean doCheckOwner;\n+      public FsAction ancestorAccess;\n+      public FsAction parentAccess;\n+      public FsAction access;\n+      public FsAction subAccess;\n+      public boolean ignoreEmptyDir;\n+      public String operationName;\n+      public CallerContext callerContext;\n+\n+      public AuthorizationContext build() {\n+        return new AuthorizationContext(this);\n+      }\n+\n+      public Builder fsOwner(String val) {\n+        this.fsOwner = val;\n+        return this;\n+      }\n+\n+      public Builder supergroup(String val) {\n+        this.supergroup = val;\n+        return this;\n+      }\n+\n+      public Builder callerUgi(UserGroupInformation val) {\n+        this.callerUgi = val;\n+        return this;\n+      }\n+\n+      public Builder inodeAttrs(INodeAttributes[] val) {\n+        this.inodeAttrs = val;\n+        return this;\n+      }\n+\n+      public Builder inodes(INode[] val) {\n+        this.inodes = val;\n+        return this;\n+      }\n+\n+      public Builder pathByNameArr(byte[][] val) {\n+        this.pathByNameArr = val;\n+        return this;\n+      }\n+\n+      public Builder snapshotId(int val) {\n+        this.snapshotId = val;\n+        return this;\n+      }\n+\n+      public Builder path(String val) {\n+        this.path = val;\n+        return this;\n+      }\n+\n+      public Builder ancestorIndex(int val) {\n+        this.ancestorIndex = val;\n+        return this;\n+      }\n+\n+      public Builder doCheckOwner(boolean val) {\n+        this.doCheckOwner = val;\n+        return this;\n+      }\n+\n+      public Builder ancestorAccess(FsAction val) {\n+        this.ancestorAccess = val;\n+        return this;\n+      }\n+\n+      public Builder parentAccess(FsAction val) {\n+        this.parentAccess = val;\n+        return this;\n+      }\n+\n+      public Builder access(FsAction val) {\n+        this.access = val;\n+        return this;\n+      }\n+\n+      public Builder subAccess(FsAction val) {\n+        this.subAccess = val;\n+        return this;\n+      }\n+\n+      public Builder ignoreEmptyDir(boolean val) {\n+        this.ignoreEmptyDir = val;\n+        return this;\n+      }\n+\n+      public Builder operationName(String val) {\n+        this.operationName = val;\n+        return this;\n+      }\n+\n+      public Builder callerContext(CallerContext val) {\n+        this.callerContext = val;\n+        return this;\n+      }\n+    }\n+\n+    public AuthorizationContext(\n+        String fsOwner,\n+        String supergroup,\n+        UserGroupInformation callerUgi,\n+        INodeAttributes[] inodeAttrs,\n+        INode[] inodes,\n+        byte[][] pathByNameArr,\n+        int snapshotId,\n+        String path,\n+        int ancestorIndex,\n+        boolean doCheckOwner,\n+        FsAction ancestorAccess,\n+        FsAction parentAccess,\n+        FsAction access,\n+        FsAction subAccess,\n+        boolean ignoreEmptyDir) {\n+      this.fsOwner = fsOwner;\n+      this.supergroup = supergroup;\n+      this.callerUgi = callerUgi;\n+      this.inodeAttrs = inodeAttrs;\n+      this.inodes = inodes;\n+      this.pathByNameArr = pathByNameArr;\n+      this.snapshotId = snapshotId;\n+      this.path = path;\n+      this.ancestorIndex = ancestorIndex;\n+      this.doCheckOwner = doCheckOwner;\n+      this.ancestorAccess = ancestorAccess;\n+      this.parentAccess = parentAccess;\n+      this.access = access;\n+      this.subAccess = subAccess;\n+      this.ignoreEmptyDir = ignoreEmptyDir;\n+    }\n+\n+    public AuthorizationContext(\n+        String fsOwner,\n+        String supergroup,\n+        UserGroupInformation callerUgi,\n+        INodeAttributes[] inodeAttrs,\n+        INode[] inodes,\n+        byte[][] pathByNameArr,\n+        int snapshotId,\n+        String path,\n+        int ancestorIndex,\n+        boolean doCheckOwner,\n+        FsAction ancestorAccess,\n+        FsAction parentAccess,\n+        FsAction access,\n+        FsAction subAccess,\n+        boolean ignoreEmptyDir,\n+        String operationName,\n+        CallerContext callerContext) {\n+      this(fsOwner, supergroup, callerUgi, inodeAttrs, inodes,\n+          pathByNameArr, snapshotId, path, ancestorIndex, doCheckOwner,\n+          ancestorAccess, parentAccess, access, subAccess, ignoreEmptyDir);\n+      this.operationName = operationName;\n+      this.callerContext = callerContext;\n+    }\n+\n+    public AuthorizationContext(Builder builder) {\n+      this(builder.fsOwner, builder.supergroup, builder.callerUgi,\n+          builder.inodeAttrs, builder.inodes, builder.pathByNameArr,\n+          builder.snapshotId, builder.path, builder.ancestorIndex,\n+          builder.doCheckOwner, builder.ancestorAccess, builder.parentAccess,\n+          builder.access, builder.subAccess, builder.ignoreEmptyDir);\n+      this.operationName = builder.operationName;\n+      this.callerContext = builder.callerContext;\n+    }\n+\n+    @VisibleForTesting\n+    @Override\n+    public boolean equals(Object obj) {\n+      if (!(obj instanceof AuthorizationContext)) {\n+        return false;\n+      }\n+      return true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk3NzkxNw=="}, "originalCommit": {"oid": "d1d954ba992b7be55b98ee4aaf16ddad655f52d9"}, "originalPosition": 221}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzODQyNDY1OnYy", "diffSide": "RIGHT", "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/INodeAttributeProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQwMDoyNToyMVrOFod-7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQxODo1NjoyNFrOFrzjdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk3ODYwNQ==", "bodyText": "can we have only one constructor with the all the parameters to avoid the operationName/callerContext assign in multiple places?", "url": "https://github.com/apache/hadoop/pull/1829#discussion_r377978605", "createdAt": "2020-02-12T00:25:21Z", "author": {"login": "xiaoyuyao"}, "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/INodeAttributeProvider.java", "diffHunk": "@@ -17,19 +17,227 @@\n  */\n package org.apache.hadoop.hdfs.server.namenode;\n \n+import com.google.common.annotations.VisibleForTesting;\n import org.apache.commons.lang3.StringUtils;\n import org.apache.hadoop.classification.InterfaceAudience;\n import org.apache.hadoop.classification.InterfaceStability;\n import org.apache.hadoop.fs.Path;\n import org.apache.hadoop.fs.permission.FsAction;\n import org.apache.hadoop.hdfs.DFSUtil;\n+import org.apache.hadoop.ipc.CallerContext;\n import org.apache.hadoop.security.AccessControlException;\n import org.apache.hadoop.security.UserGroupInformation;\n \n @InterfaceAudience.Public\n @InterfaceStability.Unstable\n public abstract class INodeAttributeProvider {\n \n+  public static class AuthorizationContext {\n+    public String fsOwner;\n+    public String supergroup;\n+    public UserGroupInformation callerUgi;\n+    public INodeAttributes[] inodeAttrs;\n+    public INode[] inodes;\n+    public byte[][] pathByNameArr;\n+    public int snapshotId;\n+    public String path;\n+    public int ancestorIndex;\n+    public boolean doCheckOwner;\n+    public FsAction ancestorAccess;\n+    public FsAction parentAccess;\n+    public FsAction access;\n+    public FsAction subAccess;\n+    public boolean ignoreEmptyDir;\n+    public String operationName;\n+    public CallerContext callerContext;\n+\n+    public static class Builder {\n+      public String fsOwner;\n+      public String supergroup;\n+      public UserGroupInformation callerUgi;\n+      public INodeAttributes[] inodeAttrs;\n+      public INode[] inodes;\n+      public byte[][] pathByNameArr;\n+      public int snapshotId;\n+      public String path;\n+      public int ancestorIndex;\n+      public boolean doCheckOwner;\n+      public FsAction ancestorAccess;\n+      public FsAction parentAccess;\n+      public FsAction access;\n+      public FsAction subAccess;\n+      public boolean ignoreEmptyDir;\n+      public String operationName;\n+      public CallerContext callerContext;\n+\n+      public AuthorizationContext build() {\n+        return new AuthorizationContext(this);\n+      }\n+\n+      public Builder fsOwner(String val) {\n+        this.fsOwner = val;\n+        return this;\n+      }\n+\n+      public Builder supergroup(String val) {\n+        this.supergroup = val;\n+        return this;\n+      }\n+\n+      public Builder callerUgi(UserGroupInformation val) {\n+        this.callerUgi = val;\n+        return this;\n+      }\n+\n+      public Builder inodeAttrs(INodeAttributes[] val) {\n+        this.inodeAttrs = val;\n+        return this;\n+      }\n+\n+      public Builder inodes(INode[] val) {\n+        this.inodes = val;\n+        return this;\n+      }\n+\n+      public Builder pathByNameArr(byte[][] val) {\n+        this.pathByNameArr = val;\n+        return this;\n+      }\n+\n+      public Builder snapshotId(int val) {\n+        this.snapshotId = val;\n+        return this;\n+      }\n+\n+      public Builder path(String val) {\n+        this.path = val;\n+        return this;\n+      }\n+\n+      public Builder ancestorIndex(int val) {\n+        this.ancestorIndex = val;\n+        return this;\n+      }\n+\n+      public Builder doCheckOwner(boolean val) {\n+        this.doCheckOwner = val;\n+        return this;\n+      }\n+\n+      public Builder ancestorAccess(FsAction val) {\n+        this.ancestorAccess = val;\n+        return this;\n+      }\n+\n+      public Builder parentAccess(FsAction val) {\n+        this.parentAccess = val;\n+        return this;\n+      }\n+\n+      public Builder access(FsAction val) {\n+        this.access = val;\n+        return this;\n+      }\n+\n+      public Builder subAccess(FsAction val) {\n+        this.subAccess = val;\n+        return this;\n+      }\n+\n+      public Builder ignoreEmptyDir(boolean val) {\n+        this.ignoreEmptyDir = val;\n+        return this;\n+      }\n+\n+      public Builder operationName(String val) {\n+        this.operationName = val;\n+        return this;\n+      }\n+\n+      public Builder callerContext(CallerContext val) {\n+        this.callerContext = val;\n+        return this;\n+      }\n+    }\n+\n+    public AuthorizationContext(\n+        String fsOwner,\n+        String supergroup,\n+        UserGroupInformation callerUgi,\n+        INodeAttributes[] inodeAttrs,\n+        INode[] inodes,\n+        byte[][] pathByNameArr,\n+        int snapshotId,\n+        String path,\n+        int ancestorIndex,\n+        boolean doCheckOwner,\n+        FsAction ancestorAccess,\n+        FsAction parentAccess,\n+        FsAction access,\n+        FsAction subAccess,\n+        boolean ignoreEmptyDir) {\n+      this.fsOwner = fsOwner;\n+      this.supergroup = supergroup;\n+      this.callerUgi = callerUgi;\n+      this.inodeAttrs = inodeAttrs;\n+      this.inodes = inodes;\n+      this.pathByNameArr = pathByNameArr;\n+      this.snapshotId = snapshotId;\n+      this.path = path;\n+      this.ancestorIndex = ancestorIndex;\n+      this.doCheckOwner = doCheckOwner;\n+      this.ancestorAccess = ancestorAccess;\n+      this.parentAccess = parentAccess;\n+      this.access = access;\n+      this.subAccess = subAccess;\n+      this.ignoreEmptyDir = ignoreEmptyDir;\n+    }\n+\n+    public AuthorizationContext(\n+        String fsOwner,\n+        String supergroup,\n+        UserGroupInformation callerUgi,\n+        INodeAttributes[] inodeAttrs,\n+        INode[] inodes,\n+        byte[][] pathByNameArr,\n+        int snapshotId,\n+        String path,\n+        int ancestorIndex,\n+        boolean doCheckOwner,\n+        FsAction ancestorAccess,\n+        FsAction parentAccess,\n+        FsAction access,\n+        FsAction subAccess,\n+        boolean ignoreEmptyDir,\n+        String operationName,\n+        CallerContext callerContext) {\n+      this(fsOwner, supergroup, callerUgi, inodeAttrs, inodes,\n+          pathByNameArr, snapshotId, path, ancestorIndex, doCheckOwner,\n+          ancestorAccess, parentAccess, access, subAccess, ignoreEmptyDir);\n+      this.operationName = operationName;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d1d954ba992b7be55b98ee4aaf16ddad655f52d9"}, "originalPosition": 201}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTQ3Nzc1MQ==", "bodyText": "removed this constructor. It is not used.", "url": "https://github.com/apache/hadoop/pull/1829#discussion_r381477751", "createdAt": "2020-02-19T18:56:24Z", "author": {"login": "jojochuang"}, "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/INodeAttributeProvider.java", "diffHunk": "@@ -17,19 +17,227 @@\n  */\n package org.apache.hadoop.hdfs.server.namenode;\n \n+import com.google.common.annotations.VisibleForTesting;\n import org.apache.commons.lang3.StringUtils;\n import org.apache.hadoop.classification.InterfaceAudience;\n import org.apache.hadoop.classification.InterfaceStability;\n import org.apache.hadoop.fs.Path;\n import org.apache.hadoop.fs.permission.FsAction;\n import org.apache.hadoop.hdfs.DFSUtil;\n+import org.apache.hadoop.ipc.CallerContext;\n import org.apache.hadoop.security.AccessControlException;\n import org.apache.hadoop.security.UserGroupInformation;\n \n @InterfaceAudience.Public\n @InterfaceStability.Unstable\n public abstract class INodeAttributeProvider {\n \n+  public static class AuthorizationContext {\n+    public String fsOwner;\n+    public String supergroup;\n+    public UserGroupInformation callerUgi;\n+    public INodeAttributes[] inodeAttrs;\n+    public INode[] inodes;\n+    public byte[][] pathByNameArr;\n+    public int snapshotId;\n+    public String path;\n+    public int ancestorIndex;\n+    public boolean doCheckOwner;\n+    public FsAction ancestorAccess;\n+    public FsAction parentAccess;\n+    public FsAction access;\n+    public FsAction subAccess;\n+    public boolean ignoreEmptyDir;\n+    public String operationName;\n+    public CallerContext callerContext;\n+\n+    public static class Builder {\n+      public String fsOwner;\n+      public String supergroup;\n+      public UserGroupInformation callerUgi;\n+      public INodeAttributes[] inodeAttrs;\n+      public INode[] inodes;\n+      public byte[][] pathByNameArr;\n+      public int snapshotId;\n+      public String path;\n+      public int ancestorIndex;\n+      public boolean doCheckOwner;\n+      public FsAction ancestorAccess;\n+      public FsAction parentAccess;\n+      public FsAction access;\n+      public FsAction subAccess;\n+      public boolean ignoreEmptyDir;\n+      public String operationName;\n+      public CallerContext callerContext;\n+\n+      public AuthorizationContext build() {\n+        return new AuthorizationContext(this);\n+      }\n+\n+      public Builder fsOwner(String val) {\n+        this.fsOwner = val;\n+        return this;\n+      }\n+\n+      public Builder supergroup(String val) {\n+        this.supergroup = val;\n+        return this;\n+      }\n+\n+      public Builder callerUgi(UserGroupInformation val) {\n+        this.callerUgi = val;\n+        return this;\n+      }\n+\n+      public Builder inodeAttrs(INodeAttributes[] val) {\n+        this.inodeAttrs = val;\n+        return this;\n+      }\n+\n+      public Builder inodes(INode[] val) {\n+        this.inodes = val;\n+        return this;\n+      }\n+\n+      public Builder pathByNameArr(byte[][] val) {\n+        this.pathByNameArr = val;\n+        return this;\n+      }\n+\n+      public Builder snapshotId(int val) {\n+        this.snapshotId = val;\n+        return this;\n+      }\n+\n+      public Builder path(String val) {\n+        this.path = val;\n+        return this;\n+      }\n+\n+      public Builder ancestorIndex(int val) {\n+        this.ancestorIndex = val;\n+        return this;\n+      }\n+\n+      public Builder doCheckOwner(boolean val) {\n+        this.doCheckOwner = val;\n+        return this;\n+      }\n+\n+      public Builder ancestorAccess(FsAction val) {\n+        this.ancestorAccess = val;\n+        return this;\n+      }\n+\n+      public Builder parentAccess(FsAction val) {\n+        this.parentAccess = val;\n+        return this;\n+      }\n+\n+      public Builder access(FsAction val) {\n+        this.access = val;\n+        return this;\n+      }\n+\n+      public Builder subAccess(FsAction val) {\n+        this.subAccess = val;\n+        return this;\n+      }\n+\n+      public Builder ignoreEmptyDir(boolean val) {\n+        this.ignoreEmptyDir = val;\n+        return this;\n+      }\n+\n+      public Builder operationName(String val) {\n+        this.operationName = val;\n+        return this;\n+      }\n+\n+      public Builder callerContext(CallerContext val) {\n+        this.callerContext = val;\n+        return this;\n+      }\n+    }\n+\n+    public AuthorizationContext(\n+        String fsOwner,\n+        String supergroup,\n+        UserGroupInformation callerUgi,\n+        INodeAttributes[] inodeAttrs,\n+        INode[] inodes,\n+        byte[][] pathByNameArr,\n+        int snapshotId,\n+        String path,\n+        int ancestorIndex,\n+        boolean doCheckOwner,\n+        FsAction ancestorAccess,\n+        FsAction parentAccess,\n+        FsAction access,\n+        FsAction subAccess,\n+        boolean ignoreEmptyDir) {\n+      this.fsOwner = fsOwner;\n+      this.supergroup = supergroup;\n+      this.callerUgi = callerUgi;\n+      this.inodeAttrs = inodeAttrs;\n+      this.inodes = inodes;\n+      this.pathByNameArr = pathByNameArr;\n+      this.snapshotId = snapshotId;\n+      this.path = path;\n+      this.ancestorIndex = ancestorIndex;\n+      this.doCheckOwner = doCheckOwner;\n+      this.ancestorAccess = ancestorAccess;\n+      this.parentAccess = parentAccess;\n+      this.access = access;\n+      this.subAccess = subAccess;\n+      this.ignoreEmptyDir = ignoreEmptyDir;\n+    }\n+\n+    public AuthorizationContext(\n+        String fsOwner,\n+        String supergroup,\n+        UserGroupInformation callerUgi,\n+        INodeAttributes[] inodeAttrs,\n+        INode[] inodes,\n+        byte[][] pathByNameArr,\n+        int snapshotId,\n+        String path,\n+        int ancestorIndex,\n+        boolean doCheckOwner,\n+        FsAction ancestorAccess,\n+        FsAction parentAccess,\n+        FsAction access,\n+        FsAction subAccess,\n+        boolean ignoreEmptyDir,\n+        String operationName,\n+        CallerContext callerContext) {\n+      this(fsOwner, supergroup, callerUgi, inodeAttrs, inodes,\n+          pathByNameArr, snapshotId, path, ancestorIndex, doCheckOwner,\n+          ancestorAccess, parentAccess, access, subAccess, ignoreEmptyDir);\n+      this.operationName = operationName;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk3ODYwNQ=="}, "originalCommit": {"oid": "d1d954ba992b7be55b98ee4aaf16ddad655f52d9"}, "originalPosition": 201}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5NDE0MDU1OnYy", "diffSide": "RIGHT", "path": "hadoop-hdfs-project/hadoop-hdfs/src/test/java/org/apache/hadoop/hdfs/server/namenode/TestINodeAttributeProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxNjowMTowNlrOFwlGQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxNjowMTowNlrOFwlGQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ4Mzc3OA==", "bodyText": "what does this do?", "url": "https://github.com/apache/hadoop/pull/1829#discussion_r386483778", "createdAt": "2020-03-02T16:01:06Z", "author": {"login": "steveloughran"}, "path": "hadoop-hdfs-project/hadoop-hdfs/src/test/java/org/apache/hadoop/hdfs/server/namenode/TestINodeAttributeProvider.java", "diffHunk": "@@ -81,6 +81,20 @@ public void checkPermission(String fsOwner, String supergroup,\n         }\n         CALLED.add(\"checkPermission|\" + ancestorAccess + \"|\" + parentAccess + \"|\" + access);\n       }\n+\n+      @Override\n+      public void checkPermissionWithContext(\n+          AuthorizationContext authzContext) throws AccessControlException {\n+        if (authzContext.ancestorIndex > 1\n+            && authzContext.inodes[1].getLocalName().equals(\"user\")\n+            && authzContext.inodes[2].getLocalName().equals(\"acl\")) {\n+          this.ace.checkPermissionWithContext(authzContext);\n+        }\n+        CALLED.add(\"checkPermission|\" + authzContext.ancestorAccess + \"|\" +\n+            authzContext.parentAccess + \"|\" + authzContext.access);\n+      }\n+\n+      public void abc() {}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7541ec89d78b0bde5b567eccc53bf350bad11d6"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyNDI1MTQ4OnYy", "diffSide": "RIGHT", "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxODoxOToyM1rOF1DUAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQyMjo0MzozOFrOF1LyGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTE3MzEyMQ==", "bodyText": "There are other places that need to be patched with setOperationType After HDFS-7416 refactor, not all permission check is done in FSN.\nHere is the list of missed ones:\nFSDirSymlinkOp#createSymlinkInt()\nNameNodeAdapter#getFileInfo()\nNamenodeFsck#getBlockLocations()\nFSNDNCache#addCacheDirective/removeCacheDirective/modifyCacheDirective/listCacheDirectives/listCachePools", "url": "https://github.com/apache/hadoop/pull/1829#discussion_r391173121", "createdAt": "2020-03-11T18:19:23Z", "author": {"login": "xiaoyuyao"}, "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java", "diffHunk": "@@ -1982,6 +1982,7 @@ void setPermission(String src, FsPermission permission) throws IOException {\n     FileStatus auditStat;\n     checkOperation(OperationCategory.WRITE);\n     final FSPermissionChecker pc = getPermissionChecker();\n+    FSPermissionChecker.setOperationType(operationName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a250c8b20c4a2672e3a553b1b9601794916e12b4"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxMTg5OQ==", "bodyText": "Thanks @xiaoyuyao for the review.\n\n\nFSDirSymlinkOp#createSymlinkInt() is an exception. It doesn't check permission in the FSNamesystem so missed this one. Added.\n\n\nNameNodeAdapter#getFileInfo() is used only in tests.\n\n\nNamenodeFsck#getBlockLocations() --> call it fsckGetBlockLocations to distinguish it from regular open operations.\n\n\nFSNDNCache#addCacheDirective/removeCacheDirective/modifyCacheDirective/listCacheDirectives/listCachePools --> done", "url": "https://github.com/apache/hadoop/pull/1829#discussion_r391311899", "createdAt": "2020-03-11T22:43:38Z", "author": {"login": "jojochuang"}, "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java", "diffHunk": "@@ -1982,6 +1982,7 @@ void setPermission(String src, FsPermission permission) throws IOException {\n     FileStatus auditStat;\n     checkOperation(OperationCategory.WRITE);\n     final FSPermissionChecker pc = getPermissionChecker();\n+    FSPermissionChecker.setOperationType(operationName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTE3MzEyMQ=="}, "originalCommit": {"oid": "a250c8b20c4a2672e3a553b1b9601794916e12b4"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyNDI4OTc1OnYy", "diffSide": "RIGHT", "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/INodeAttributeProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxODozMDo0MlrOF1DtHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxODozMDo0MlrOF1DtHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTE3OTU1MQ==", "bodyText": "NIT: typo: accessessible", "url": "https://github.com/apache/hadoop/pull/1829#discussion_r391179551", "createdAt": "2020-03-11T18:30:42Z", "author": {"login": "xiaoyuyao"}, "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/INodeAttributeProvider.java", "diffHunk": "@@ -68,6 +391,16 @@ public abstract void checkPermission(String fsOwner, String supergroup,\n         boolean ignoreEmptyDir)\n             throws AccessControlException;\n \n+    /**\n+     * Checks permission on a file system object. Has to throw an Exception\n+     * if the filesystem object is not accessessible by the calling Ugi.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a250c8b20c4a2672e3a553b1b9601794916e12b4"}, "originalPosition": 356}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyNDM0MDQwOnYy", "diffSide": "RIGHT", "path": "hadoop-hdfs-project/hadoop-hdfs/src/test/java/org/apache/hadoop/hdfs/server/namenode/TestAuthorizationContext.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQxODo0NToyMFrOF1ENOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQyMjo0Njo1M1rOF1L2bQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTE4Nzc2OQ==", "bodyText": "NIT: do we have a test case when the attributeProvider=null?", "url": "https://github.com/apache/hadoop/pull/1829#discussion_r391187769", "createdAt": "2020-03-11T18:45:20Z", "author": {"login": "xiaoyuyao"}, "path": "hadoop-hdfs-project/hadoop-hdfs/src/test/java/org/apache/hadoop/hdfs/server/namenode/TestAuthorizationContext.java", "diffHunk": "@@ -0,0 +1,167 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hdfs.server.namenode;\n+\n+import org.apache.hadoop.ipc.CallerContext;\n+import org.apache.hadoop.security.UserGroupInformation;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+\n+import static junit.framework.TestCase.assertEquals;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+public class TestAuthorizationContext {\n+\n+  private String fsOwner = \"hdfs\";\n+  private String superGroup = \"hdfs\";\n+  private UserGroupInformation ugi = UserGroupInformation.\n+      createUserForTesting(fsOwner, new String[] {superGroup});\n+\n+  private INodeAttributes[] emptyINodeAttributes = new INodeAttributes[] {};\n+  private INodesInPath iip = mock(INodesInPath.class);\n+  private int snapshotId = 0;\n+  private INode[] inodes = new INode[] {};\n+  private byte[][] components = new byte[][] {};\n+  private String path = \"\";\n+  private int ancestorIndex = inodes.length - 2;\n+\n+  @Before\n+  public void setUp() throws IOException {\n+    when(iip.getPathSnapshotId()).thenReturn(snapshotId);\n+    when(iip.getINodesArray()).thenReturn(inodes);\n+    when(iip.getPathComponents()).thenReturn(components);\n+    when(iip.getPath()).thenReturn(path);\n+  }\n+\n+  @Test\n+  public void testBuilder() {\n+    String opType = \"test\";\n+    CallerContext.setCurrent(new CallerContext.Builder(\n+        \"TestAuthorizationContext\").build());\n+\n+    INodeAttributeProvider.AuthorizationContext.Builder builder =\n+        new INodeAttributeProvider.AuthorizationContext.Builder();\n+    builder.fsOwner(fsOwner).\n+        supergroup(superGroup).\n+        callerUgi(ugi).\n+        inodeAttrs(emptyINodeAttributes).\n+        inodes(inodes).\n+        pathByNameArr(components).\n+        snapshotId(snapshotId).\n+        path(path).\n+        ancestorIndex(ancestorIndex).\n+        doCheckOwner(true).\n+        ancestorAccess(null).\n+        parentAccess(null).\n+        access(null).\n+        subAccess(null).\n+        ignoreEmptyDir(true).\n+        operationName(opType).\n+        callerContext(CallerContext.getCurrent());\n+\n+    INodeAttributeProvider.AuthorizationContext authzContext = builder.build();\n+    assertEquals(authzContext.getFsOwner(), fsOwner);\n+    assertEquals(authzContext.getSupergroup(), superGroup);\n+    assertEquals(authzContext.getCallerUgi(), ugi);\n+    assertEquals(authzContext.getInodeAttrs(), emptyINodeAttributes);\n+    assertEquals(authzContext.getInodes(), inodes);\n+    assertEquals(authzContext.getPathByNameArr(), components);\n+    assertEquals(authzContext.getSnapshotId(), snapshotId);\n+    assertEquals(authzContext.getPath(), path);\n+    assertEquals(authzContext.getAncestorIndex(), ancestorIndex);\n+    assertEquals(authzContext.getOperationName(), opType);\n+    assertEquals(authzContext.getCallerContext(), CallerContext.getCurrent());\n+  }\n+\n+  @Test\n+  public void testLegacyAPI() throws IOException {\n+    INodeAttributeProvider.AccessControlEnforcer\n+        mockEnforcer = mock(INodeAttributeProvider.AccessControlEnforcer.class);\n+    INodeAttributeProvider mockINodeAttributeProvider =\n+        mock(INodeAttributeProvider.class);\n+    when(mockINodeAttributeProvider.getExternalAccessControlEnforcer(any())).\n+        thenReturn(mockEnforcer);\n+\n+    FSPermissionChecker checker = new FSPermissionChecker(\n+        fsOwner, superGroup, ugi, mockINodeAttributeProvider);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a250c8b20c4a2672e3a553b1b9601794916e12b4"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxMzAwNQ==", "bodyText": "this is covered by existing tests when FSDirectory initializes a FSPermissionChecker, so this is good.", "url": "https://github.com/apache/hadoop/pull/1829#discussion_r391313005", "createdAt": "2020-03-11T22:46:53Z", "author": {"login": "jojochuang"}, "path": "hadoop-hdfs-project/hadoop-hdfs/src/test/java/org/apache/hadoop/hdfs/server/namenode/TestAuthorizationContext.java", "diffHunk": "@@ -0,0 +1,167 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hdfs.server.namenode;\n+\n+import org.apache.hadoop.ipc.CallerContext;\n+import org.apache.hadoop.security.UserGroupInformation;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+\n+import static junit.framework.TestCase.assertEquals;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+public class TestAuthorizationContext {\n+\n+  private String fsOwner = \"hdfs\";\n+  private String superGroup = \"hdfs\";\n+  private UserGroupInformation ugi = UserGroupInformation.\n+      createUserForTesting(fsOwner, new String[] {superGroup});\n+\n+  private INodeAttributes[] emptyINodeAttributes = new INodeAttributes[] {};\n+  private INodesInPath iip = mock(INodesInPath.class);\n+  private int snapshotId = 0;\n+  private INode[] inodes = new INode[] {};\n+  private byte[][] components = new byte[][] {};\n+  private String path = \"\";\n+  private int ancestorIndex = inodes.length - 2;\n+\n+  @Before\n+  public void setUp() throws IOException {\n+    when(iip.getPathSnapshotId()).thenReturn(snapshotId);\n+    when(iip.getINodesArray()).thenReturn(inodes);\n+    when(iip.getPathComponents()).thenReturn(components);\n+    when(iip.getPath()).thenReturn(path);\n+  }\n+\n+  @Test\n+  public void testBuilder() {\n+    String opType = \"test\";\n+    CallerContext.setCurrent(new CallerContext.Builder(\n+        \"TestAuthorizationContext\").build());\n+\n+    INodeAttributeProvider.AuthorizationContext.Builder builder =\n+        new INodeAttributeProvider.AuthorizationContext.Builder();\n+    builder.fsOwner(fsOwner).\n+        supergroup(superGroup).\n+        callerUgi(ugi).\n+        inodeAttrs(emptyINodeAttributes).\n+        inodes(inodes).\n+        pathByNameArr(components).\n+        snapshotId(snapshotId).\n+        path(path).\n+        ancestorIndex(ancestorIndex).\n+        doCheckOwner(true).\n+        ancestorAccess(null).\n+        parentAccess(null).\n+        access(null).\n+        subAccess(null).\n+        ignoreEmptyDir(true).\n+        operationName(opType).\n+        callerContext(CallerContext.getCurrent());\n+\n+    INodeAttributeProvider.AuthorizationContext authzContext = builder.build();\n+    assertEquals(authzContext.getFsOwner(), fsOwner);\n+    assertEquals(authzContext.getSupergroup(), superGroup);\n+    assertEquals(authzContext.getCallerUgi(), ugi);\n+    assertEquals(authzContext.getInodeAttrs(), emptyINodeAttributes);\n+    assertEquals(authzContext.getInodes(), inodes);\n+    assertEquals(authzContext.getPathByNameArr(), components);\n+    assertEquals(authzContext.getSnapshotId(), snapshotId);\n+    assertEquals(authzContext.getPath(), path);\n+    assertEquals(authzContext.getAncestorIndex(), ancestorIndex);\n+    assertEquals(authzContext.getOperationName(), opType);\n+    assertEquals(authzContext.getCallerContext(), CallerContext.getCurrent());\n+  }\n+\n+  @Test\n+  public void testLegacyAPI() throws IOException {\n+    INodeAttributeProvider.AccessControlEnforcer\n+        mockEnforcer = mock(INodeAttributeProvider.AccessControlEnforcer.class);\n+    INodeAttributeProvider mockINodeAttributeProvider =\n+        mock(INodeAttributeProvider.class);\n+    when(mockINodeAttributeProvider.getExternalAccessControlEnforcer(any())).\n+        thenReturn(mockEnforcer);\n+\n+    FSPermissionChecker checker = new FSPermissionChecker(\n+        fsOwner, superGroup, ugi, mockINodeAttributeProvider);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTE4Nzc2OQ=="}, "originalCommit": {"oid": "a250c8b20c4a2672e3a553b1b9601794916e12b4"}, "originalPosition": 106}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3696, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}