{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI2ODI4NTI2", "number": 2047, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwOTowNDoyNFrOECEPpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwOToyNTo0MVrOECEuaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNjAyMTUwOnYy", "diffSide": "RIGHT", "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/security/token/ZKDelegationTokenSecretManagerImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwOTowNDoyNFrOGeS0GA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwMDozNDo0MlrOGmEZ4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQxODcxMg==", "bodyText": "a. It is better to keep the same code style.\n  public static final String ZK_DTSM_ROUTER_TOKEN_SYNC_INTERVAL =\n      \"zk-dt-secret-manager.router.token.sync.interval\";\n\n->\n  public static final String ZK_DTSM_ROUTER_TOKEN_SYNC_INTERVAL =\n      ZK_CONF_PREFIX + \"router.token.sync.interval\";\n\nb. IMO, this is common improvement, it should not aimed at Router only, right?", "url": "https://github.com/apache/hadoop/pull/2047#discussion_r434418712", "createdAt": "2020-06-03T09:04:24Z", "author": {"login": "Hexiaoqiao"}, "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/security/token/ZKDelegationTokenSecretManagerImpl.java", "diffHunk": "@@ -19,38 +19,211 @@\n package org.apache.hadoop.hdfs.server.federation.router.security.token;\n \n import org.apache.hadoop.hdfs.security.token.delegation.DelegationTokenIdentifier;\n+import org.apache.hadoop.security.token.Token;\n import org.apache.hadoop.security.token.delegation.AbstractDelegationTokenIdentifier;\n import org.apache.hadoop.security.token.delegation.ZKDelegationTokenSecretManager;\n+import org.apache.hadoop.util.Time;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.ZooKeeper;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.apache.hadoop.conf.Configuration;\n \n+import java.io.ByteArrayInputStream;\n+import java.io.DataInputStream;\n import java.io.IOException;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n \n /**\n  * Zookeeper based router delegation token store implementation.\n  */\n public class ZKDelegationTokenSecretManagerImpl extends\n     ZKDelegationTokenSecretManager<AbstractDelegationTokenIdentifier> {\n \n+  public static final String ZK_DTSM_ROUTER_TOKEN_SYNC_INTERVAL =\n+      \"zk-dt-secret-manager.router.token.sync.interval\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51074d2ec190d4980e0dbf50d4bff935d9c569fb"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU3MTIzNQ==", "bodyText": "Point a) changed.\nPoint b) this class was brought in as a router delegation support effort and was designed for Router initially, hence I put the router name string inside.", "url": "https://github.com/apache/hadoop/pull/2047#discussion_r442571235", "createdAt": "2020-06-19T00:34:42Z", "author": {"login": "fengnanli"}, "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/security/token/ZKDelegationTokenSecretManagerImpl.java", "diffHunk": "@@ -19,38 +19,211 @@\n package org.apache.hadoop.hdfs.server.federation.router.security.token;\n \n import org.apache.hadoop.hdfs.security.token.delegation.DelegationTokenIdentifier;\n+import org.apache.hadoop.security.token.Token;\n import org.apache.hadoop.security.token.delegation.AbstractDelegationTokenIdentifier;\n import org.apache.hadoop.security.token.delegation.ZKDelegationTokenSecretManager;\n+import org.apache.hadoop.util.Time;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.ZooKeeper;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.apache.hadoop.conf.Configuration;\n \n+import java.io.ByteArrayInputStream;\n+import java.io.DataInputStream;\n import java.io.IOException;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n \n /**\n  * Zookeeper based router delegation token store implementation.\n  */\n public class ZKDelegationTokenSecretManagerImpl extends\n     ZKDelegationTokenSecretManager<AbstractDelegationTokenIdentifier> {\n \n+  public static final String ZK_DTSM_ROUTER_TOKEN_SYNC_INTERVAL =\n+      \"zk-dt-secret-manager.router.token.sync.interval\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQxODcxMg=="}, "originalCommit": {"oid": "51074d2ec190d4980e0dbf50d4bff935d9c569fb"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNjA0MTMzOnYy", "diffSide": "RIGHT", "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/security/token/ZKDelegationTokenSecretManagerImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwOTowOTozN1rOGeTAZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwMDozNjoxMlrOGmEbNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQyMTg2MA==", "bodyText": "depracating -> deprecating?", "url": "https://github.com/apache/hadoop/pull/2047#discussion_r434421860", "createdAt": "2020-06-03T09:09:37Z", "author": {"login": "Hexiaoqiao"}, "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/security/token/ZKDelegationTokenSecretManagerImpl.java", "diffHunk": "@@ -19,38 +19,211 @@\n package org.apache.hadoop.hdfs.server.federation.router.security.token;\n \n import org.apache.hadoop.hdfs.security.token.delegation.DelegationTokenIdentifier;\n+import org.apache.hadoop.security.token.Token;\n import org.apache.hadoop.security.token.delegation.AbstractDelegationTokenIdentifier;\n import org.apache.hadoop.security.token.delegation.ZKDelegationTokenSecretManager;\n+import org.apache.hadoop.util.Time;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.ZooKeeper;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.apache.hadoop.conf.Configuration;\n \n+import java.io.ByteArrayInputStream;\n+import java.io.DataInputStream;\n import java.io.IOException;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n \n /**\n  * Zookeeper based router delegation token store implementation.\n  */\n public class ZKDelegationTokenSecretManagerImpl extends\n     ZKDelegationTokenSecretManager<AbstractDelegationTokenIdentifier> {\n \n+  public static final String ZK_DTSM_ROUTER_TOKEN_SYNC_INTERVAL =\n+      \"zk-dt-secret-manager.router.token.sync.interval\";\n+  public static final int ZK_DTSM_ROUTER_TOKEN_SYNC_INTERVAL_DEFAULT = 5;\n+\n   private static final Logger LOG =\n       LoggerFactory.getLogger(ZKDelegationTokenSecretManagerImpl.class);\n \n-  private Configuration conf = null;\n+  private Configuration conf;\n+\n+  private final ScheduledExecutorService scheduler =\n+      Executors.newSingleThreadScheduledExecutor();\n+\n+  // Local cache of delegation tokens, used for depracating tokens from", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51074d2ec190d4980e0dbf50d4bff935d9c569fb"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU3MTU3Mw==", "bodyText": "done", "url": "https://github.com/apache/hadoop/pull/2047#discussion_r442571573", "createdAt": "2020-06-19T00:36:12Z", "author": {"login": "fengnanli"}, "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/security/token/ZKDelegationTokenSecretManagerImpl.java", "diffHunk": "@@ -19,38 +19,211 @@\n package org.apache.hadoop.hdfs.server.federation.router.security.token;\n \n import org.apache.hadoop.hdfs.security.token.delegation.DelegationTokenIdentifier;\n+import org.apache.hadoop.security.token.Token;\n import org.apache.hadoop.security.token.delegation.AbstractDelegationTokenIdentifier;\n import org.apache.hadoop.security.token.delegation.ZKDelegationTokenSecretManager;\n+import org.apache.hadoop.util.Time;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.ZooKeeper;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.apache.hadoop.conf.Configuration;\n \n+import java.io.ByteArrayInputStream;\n+import java.io.DataInputStream;\n import java.io.IOException;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n \n /**\n  * Zookeeper based router delegation token store implementation.\n  */\n public class ZKDelegationTokenSecretManagerImpl extends\n     ZKDelegationTokenSecretManager<AbstractDelegationTokenIdentifier> {\n \n+  public static final String ZK_DTSM_ROUTER_TOKEN_SYNC_INTERVAL =\n+      \"zk-dt-secret-manager.router.token.sync.interval\";\n+  public static final int ZK_DTSM_ROUTER_TOKEN_SYNC_INTERVAL_DEFAULT = 5;\n+\n   private static final Logger LOG =\n       LoggerFactory.getLogger(ZKDelegationTokenSecretManagerImpl.class);\n \n-  private Configuration conf = null;\n+  private Configuration conf;\n+\n+  private final ScheduledExecutorService scheduler =\n+      Executors.newSingleThreadScheduledExecutor();\n+\n+  // Local cache of delegation tokens, used for depracating tokens from", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQyMTg2MA=="}, "originalCommit": {"oid": "51074d2ec190d4980e0dbf50d4bff935d9c569fb"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNjA3NTIzOnYy", "diffSide": "RIGHT", "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/security/token/ZKDelegationTokenSecretManagerImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwOToxODozN1rOGeTV4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwMDo0Nzo1OFrOGmEl6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQyNzM2MQ==", "bodyText": "It looks there are double deserialize operations, it should be better if we can merge them to one IMO.", "url": "https://github.com/apache/hadoop/pull/2047#discussion_r434427361", "createdAt": "2020-06-03T09:18:37Z", "author": {"login": "Hexiaoqiao"}, "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/security/token/ZKDelegationTokenSecretManagerImpl.java", "diffHunk": "@@ -19,38 +19,211 @@\n package org.apache.hadoop.hdfs.server.federation.router.security.token;\n \n import org.apache.hadoop.hdfs.security.token.delegation.DelegationTokenIdentifier;\n+import org.apache.hadoop.security.token.Token;\n import org.apache.hadoop.security.token.delegation.AbstractDelegationTokenIdentifier;\n import org.apache.hadoop.security.token.delegation.ZKDelegationTokenSecretManager;\n+import org.apache.hadoop.util.Time;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.ZooKeeper;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.apache.hadoop.conf.Configuration;\n \n+import java.io.ByteArrayInputStream;\n+import java.io.DataInputStream;\n import java.io.IOException;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n \n /**\n  * Zookeeper based router delegation token store implementation.\n  */\n public class ZKDelegationTokenSecretManagerImpl extends\n     ZKDelegationTokenSecretManager<AbstractDelegationTokenIdentifier> {\n \n+  public static final String ZK_DTSM_ROUTER_TOKEN_SYNC_INTERVAL =\n+      \"zk-dt-secret-manager.router.token.sync.interval\";\n+  public static final int ZK_DTSM_ROUTER_TOKEN_SYNC_INTERVAL_DEFAULT = 5;\n+\n   private static final Logger LOG =\n       LoggerFactory.getLogger(ZKDelegationTokenSecretManagerImpl.class);\n \n-  private Configuration conf = null;\n+  private Configuration conf;\n+\n+  private final ScheduledExecutorService scheduler =\n+      Executors.newSingleThreadScheduledExecutor();\n+\n+  // Local cache of delegation tokens, used for depracating tokens from\n+  // currentTokenMap\n+  private final Set<AbstractDelegationTokenIdentifier> localTokenCache =\n+      new HashSet<>();\n+  // Native zk client for getting all tokens\n+  private ZooKeeper zookeeper;\n+  private final String TOKEN_PATH = \"/\" + zkClient.getNamespace()\n+      + ZK_DTSM_TOKENS_ROOT;\n+  // The flag used to issue an extra check before deletion\n+  // Since cancel token and token remover thread use the same\n+  // API here and one router could have a token that is renewed\n+  // by another router, thus token remover should always check ZK\n+  // to confirm whether it has been renewed or not\n+  private ThreadLocal<Boolean> checkAgainstZkBeforeDeletion =\n+      new ThreadLocal<Boolean>() {\n+        @Override\n+        protected Boolean initialValue() {\n+          return true;\n+        }\n+      };\n \n   public ZKDelegationTokenSecretManagerImpl(Configuration conf) {\n     super(conf);\n     this.conf = conf;\n     try {\n-      super.startThreads();\n+      startThreads();\n     } catch (IOException e) {\n       LOG.error(\"Error starting threads for zkDelegationTokens\", e);\n     }\n     LOG.info(\"Zookeeper delegation token secret manager instantiated\");\n   }\n \n+  @Override\n+  public void startThreads() throws IOException {\n+    super.startThreads();\n+    // start token cache related work when watcher is disabled\n+    if (!isTokenWatcherEnabled()) {\n+      LOG.info(\"Watcher for tokens is disabled in this secret manager\");\n+      try {\n+        // By default set this variable\n+        checkAgainstZkBeforeDeletion.set(true);\n+        // Ensure the token root path exists\n+        if (zkClient.checkExists().forPath(ZK_DTSM_TOKENS_ROOT) == null) {\n+          zkClient.create().creatingParentsIfNeeded()\n+              .withMode(CreateMode.PERSISTENT)\n+              .forPath(ZK_DTSM_TOKENS_ROOT);\n+        }\n+        // Set up zookeeper client\n+        try {\n+          zookeeper = zkClient.getZookeeperClient().getZooKeeper();\n+        } catch (Exception e) {\n+          LOG.info(\"Cannot get zookeeper client \", e);\n+        } finally {\n+          if (zookeeper == null) {\n+            throw new IOException(\"Zookeeper client is null\");\n+          }\n+        }\n+\n+        LOG.info(\"Start loading token cache\");\n+        long start = Time.now();\n+        rebuildTokenCache(true);\n+        LOG.info(\"Loaded token cache in {} milliseconds\", Time.now() - start);\n+\n+        int syncInterval = conf.getInt(ZK_DTSM_ROUTER_TOKEN_SYNC_INTERVAL,\n+            ZK_DTSM_ROUTER_TOKEN_SYNC_INTERVAL_DEFAULT);\n+        scheduler.scheduleAtFixedRate(new Runnable() {\n+          @Override\n+          public void run() {\n+            try {\n+              rebuildTokenCache(false);\n+            } catch (Exception e) {\n+              // ignore\n+            }\n+          }\n+        }, syncInterval, syncInterval, TimeUnit.SECONDS);\n+      } catch (Exception e) {\n+        LOG.error(\"Error rebuilding local cache for zkDelegationTokens \", e);\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void stopThreads() {\n+    super.stopThreads();\n+    scheduler.shutdown();\n+  }\n+\n   @Override\n   public DelegationTokenIdentifier createIdentifier() {\n     return new DelegationTokenIdentifier();\n   }\n+\n+  /**\n+   * This function will rebuild local token cache from zk storage.\n+   * It is first called when the secret manager is initialized and\n+   * then regularly at a configured interval.\n+   *\n+   * @param initial whether this is called during initialization\n+   * @throws IOException\n+   */\n+  private void rebuildTokenCache(boolean initial) throws IOException {\n+    localTokenCache.clear();\n+    // Use bare zookeeper client to get all children since curator will\n+    // wrap the same API with a sorting process. This is time consuming given\n+    // millions of tokens\n+    List<String> zkTokens;\n+    try {\n+      zkTokens = zookeeper.getChildren(TOKEN_PATH, false);\n+    } catch (KeeperException | InterruptedException e) {\n+      throw new IOException(\"Tokens cannot be fetched from path \"\n+          + TOKEN_PATH, e);\n+    }\n+    byte[] data;\n+    for (String tokenPath : zkTokens) {\n+      try {\n+        data = zkClient.getData().forPath(\n+            ZK_DTSM_TOKENS_ROOT + \"/\" + tokenPath);\n+      } catch (KeeperException.NoNodeException e) {\n+        LOG.debug(\"No node in path [\" + tokenPath + \"]\");\n+        continue;\n+      } catch (Exception ex) {\n+        throw new IOException(ex);\n+      }\n+      // Store data to currentTokenMap\n+      processTokenAddOrUpdate(data);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51074d2ec190d4980e0dbf50d4bff935d9c569fb"}, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU3NDMxMg==", "bodyText": "done", "url": "https://github.com/apache/hadoop/pull/2047#discussion_r442574312", "createdAt": "2020-06-19T00:47:58Z", "author": {"login": "fengnanli"}, "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/security/token/ZKDelegationTokenSecretManagerImpl.java", "diffHunk": "@@ -19,38 +19,211 @@\n package org.apache.hadoop.hdfs.server.federation.router.security.token;\n \n import org.apache.hadoop.hdfs.security.token.delegation.DelegationTokenIdentifier;\n+import org.apache.hadoop.security.token.Token;\n import org.apache.hadoop.security.token.delegation.AbstractDelegationTokenIdentifier;\n import org.apache.hadoop.security.token.delegation.ZKDelegationTokenSecretManager;\n+import org.apache.hadoop.util.Time;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.ZooKeeper;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.apache.hadoop.conf.Configuration;\n \n+import java.io.ByteArrayInputStream;\n+import java.io.DataInputStream;\n import java.io.IOException;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n \n /**\n  * Zookeeper based router delegation token store implementation.\n  */\n public class ZKDelegationTokenSecretManagerImpl extends\n     ZKDelegationTokenSecretManager<AbstractDelegationTokenIdentifier> {\n \n+  public static final String ZK_DTSM_ROUTER_TOKEN_SYNC_INTERVAL =\n+      \"zk-dt-secret-manager.router.token.sync.interval\";\n+  public static final int ZK_DTSM_ROUTER_TOKEN_SYNC_INTERVAL_DEFAULT = 5;\n+\n   private static final Logger LOG =\n       LoggerFactory.getLogger(ZKDelegationTokenSecretManagerImpl.class);\n \n-  private Configuration conf = null;\n+  private Configuration conf;\n+\n+  private final ScheduledExecutorService scheduler =\n+      Executors.newSingleThreadScheduledExecutor();\n+\n+  // Local cache of delegation tokens, used for depracating tokens from\n+  // currentTokenMap\n+  private final Set<AbstractDelegationTokenIdentifier> localTokenCache =\n+      new HashSet<>();\n+  // Native zk client for getting all tokens\n+  private ZooKeeper zookeeper;\n+  private final String TOKEN_PATH = \"/\" + zkClient.getNamespace()\n+      + ZK_DTSM_TOKENS_ROOT;\n+  // The flag used to issue an extra check before deletion\n+  // Since cancel token and token remover thread use the same\n+  // API here and one router could have a token that is renewed\n+  // by another router, thus token remover should always check ZK\n+  // to confirm whether it has been renewed or not\n+  private ThreadLocal<Boolean> checkAgainstZkBeforeDeletion =\n+      new ThreadLocal<Boolean>() {\n+        @Override\n+        protected Boolean initialValue() {\n+          return true;\n+        }\n+      };\n \n   public ZKDelegationTokenSecretManagerImpl(Configuration conf) {\n     super(conf);\n     this.conf = conf;\n     try {\n-      super.startThreads();\n+      startThreads();\n     } catch (IOException e) {\n       LOG.error(\"Error starting threads for zkDelegationTokens\", e);\n     }\n     LOG.info(\"Zookeeper delegation token secret manager instantiated\");\n   }\n \n+  @Override\n+  public void startThreads() throws IOException {\n+    super.startThreads();\n+    // start token cache related work when watcher is disabled\n+    if (!isTokenWatcherEnabled()) {\n+      LOG.info(\"Watcher for tokens is disabled in this secret manager\");\n+      try {\n+        // By default set this variable\n+        checkAgainstZkBeforeDeletion.set(true);\n+        // Ensure the token root path exists\n+        if (zkClient.checkExists().forPath(ZK_DTSM_TOKENS_ROOT) == null) {\n+          zkClient.create().creatingParentsIfNeeded()\n+              .withMode(CreateMode.PERSISTENT)\n+              .forPath(ZK_DTSM_TOKENS_ROOT);\n+        }\n+        // Set up zookeeper client\n+        try {\n+          zookeeper = zkClient.getZookeeperClient().getZooKeeper();\n+        } catch (Exception e) {\n+          LOG.info(\"Cannot get zookeeper client \", e);\n+        } finally {\n+          if (zookeeper == null) {\n+            throw new IOException(\"Zookeeper client is null\");\n+          }\n+        }\n+\n+        LOG.info(\"Start loading token cache\");\n+        long start = Time.now();\n+        rebuildTokenCache(true);\n+        LOG.info(\"Loaded token cache in {} milliseconds\", Time.now() - start);\n+\n+        int syncInterval = conf.getInt(ZK_DTSM_ROUTER_TOKEN_SYNC_INTERVAL,\n+            ZK_DTSM_ROUTER_TOKEN_SYNC_INTERVAL_DEFAULT);\n+        scheduler.scheduleAtFixedRate(new Runnable() {\n+          @Override\n+          public void run() {\n+            try {\n+              rebuildTokenCache(false);\n+            } catch (Exception e) {\n+              // ignore\n+            }\n+          }\n+        }, syncInterval, syncInterval, TimeUnit.SECONDS);\n+      } catch (Exception e) {\n+        LOG.error(\"Error rebuilding local cache for zkDelegationTokens \", e);\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void stopThreads() {\n+    super.stopThreads();\n+    scheduler.shutdown();\n+  }\n+\n   @Override\n   public DelegationTokenIdentifier createIdentifier() {\n     return new DelegationTokenIdentifier();\n   }\n+\n+  /**\n+   * This function will rebuild local token cache from zk storage.\n+   * It is first called when the secret manager is initialized and\n+   * then regularly at a configured interval.\n+   *\n+   * @param initial whether this is called during initialization\n+   * @throws IOException\n+   */\n+  private void rebuildTokenCache(boolean initial) throws IOException {\n+    localTokenCache.clear();\n+    // Use bare zookeeper client to get all children since curator will\n+    // wrap the same API with a sorting process. This is time consuming given\n+    // millions of tokens\n+    List<String> zkTokens;\n+    try {\n+      zkTokens = zookeeper.getChildren(TOKEN_PATH, false);\n+    } catch (KeeperException | InterruptedException e) {\n+      throw new IOException(\"Tokens cannot be fetched from path \"\n+          + TOKEN_PATH, e);\n+    }\n+    byte[] data;\n+    for (String tokenPath : zkTokens) {\n+      try {\n+        data = zkClient.getData().forPath(\n+            ZK_DTSM_TOKENS_ROOT + \"/\" + tokenPath);\n+      } catch (KeeperException.NoNodeException e) {\n+        LOG.debug(\"No node in path [\" + tokenPath + \"]\");\n+        continue;\n+      } catch (Exception ex) {\n+        throw new IOException(ex);\n+      }\n+      // Store data to currentTokenMap\n+      processTokenAddOrUpdate(data);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQyNzM2MQ=="}, "originalCommit": {"oid": "51074d2ec190d4980e0dbf50d4bff935d9c569fb"}, "originalPosition": 169}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNjA5MzI1OnYy", "diffSide": "RIGHT", "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/security/token/ZKDelegationTokenSecretManagerImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwOToyMzo0M1rOGeThew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwMDo1ODoyMFrOGmEvWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQzMDMzMQ==", "bodyText": "After this loop, content of loacalTokenCache is equal to currentTokens right? If that, should we set the currentTokens = localTokenCache directly? Please correct me if wrong.", "url": "https://github.com/apache/hadoop/pull/2047#discussion_r434430331", "createdAt": "2020-06-03T09:23:43Z", "author": {"login": "Hexiaoqiao"}, "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/security/token/ZKDelegationTokenSecretManagerImpl.java", "diffHunk": "@@ -19,38 +19,211 @@\n package org.apache.hadoop.hdfs.server.federation.router.security.token;\n \n import org.apache.hadoop.hdfs.security.token.delegation.DelegationTokenIdentifier;\n+import org.apache.hadoop.security.token.Token;\n import org.apache.hadoop.security.token.delegation.AbstractDelegationTokenIdentifier;\n import org.apache.hadoop.security.token.delegation.ZKDelegationTokenSecretManager;\n+import org.apache.hadoop.util.Time;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.ZooKeeper;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.apache.hadoop.conf.Configuration;\n \n+import java.io.ByteArrayInputStream;\n+import java.io.DataInputStream;\n import java.io.IOException;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n \n /**\n  * Zookeeper based router delegation token store implementation.\n  */\n public class ZKDelegationTokenSecretManagerImpl extends\n     ZKDelegationTokenSecretManager<AbstractDelegationTokenIdentifier> {\n \n+  public static final String ZK_DTSM_ROUTER_TOKEN_SYNC_INTERVAL =\n+      \"zk-dt-secret-manager.router.token.sync.interval\";\n+  public static final int ZK_DTSM_ROUTER_TOKEN_SYNC_INTERVAL_DEFAULT = 5;\n+\n   private static final Logger LOG =\n       LoggerFactory.getLogger(ZKDelegationTokenSecretManagerImpl.class);\n \n-  private Configuration conf = null;\n+  private Configuration conf;\n+\n+  private final ScheduledExecutorService scheduler =\n+      Executors.newSingleThreadScheduledExecutor();\n+\n+  // Local cache of delegation tokens, used for depracating tokens from\n+  // currentTokenMap\n+  private final Set<AbstractDelegationTokenIdentifier> localTokenCache =\n+      new HashSet<>();\n+  // Native zk client for getting all tokens\n+  private ZooKeeper zookeeper;\n+  private final String TOKEN_PATH = \"/\" + zkClient.getNamespace()\n+      + ZK_DTSM_TOKENS_ROOT;\n+  // The flag used to issue an extra check before deletion\n+  // Since cancel token and token remover thread use the same\n+  // API here and one router could have a token that is renewed\n+  // by another router, thus token remover should always check ZK\n+  // to confirm whether it has been renewed or not\n+  private ThreadLocal<Boolean> checkAgainstZkBeforeDeletion =\n+      new ThreadLocal<Boolean>() {\n+        @Override\n+        protected Boolean initialValue() {\n+          return true;\n+        }\n+      };\n \n   public ZKDelegationTokenSecretManagerImpl(Configuration conf) {\n     super(conf);\n     this.conf = conf;\n     try {\n-      super.startThreads();\n+      startThreads();\n     } catch (IOException e) {\n       LOG.error(\"Error starting threads for zkDelegationTokens\", e);\n     }\n     LOG.info(\"Zookeeper delegation token secret manager instantiated\");\n   }\n \n+  @Override\n+  public void startThreads() throws IOException {\n+    super.startThreads();\n+    // start token cache related work when watcher is disabled\n+    if (!isTokenWatcherEnabled()) {\n+      LOG.info(\"Watcher for tokens is disabled in this secret manager\");\n+      try {\n+        // By default set this variable\n+        checkAgainstZkBeforeDeletion.set(true);\n+        // Ensure the token root path exists\n+        if (zkClient.checkExists().forPath(ZK_DTSM_TOKENS_ROOT) == null) {\n+          zkClient.create().creatingParentsIfNeeded()\n+              .withMode(CreateMode.PERSISTENT)\n+              .forPath(ZK_DTSM_TOKENS_ROOT);\n+        }\n+        // Set up zookeeper client\n+        try {\n+          zookeeper = zkClient.getZookeeperClient().getZooKeeper();\n+        } catch (Exception e) {\n+          LOG.info(\"Cannot get zookeeper client \", e);\n+        } finally {\n+          if (zookeeper == null) {\n+            throw new IOException(\"Zookeeper client is null\");\n+          }\n+        }\n+\n+        LOG.info(\"Start loading token cache\");\n+        long start = Time.now();\n+        rebuildTokenCache(true);\n+        LOG.info(\"Loaded token cache in {} milliseconds\", Time.now() - start);\n+\n+        int syncInterval = conf.getInt(ZK_DTSM_ROUTER_TOKEN_SYNC_INTERVAL,\n+            ZK_DTSM_ROUTER_TOKEN_SYNC_INTERVAL_DEFAULT);\n+        scheduler.scheduleAtFixedRate(new Runnable() {\n+          @Override\n+          public void run() {\n+            try {\n+              rebuildTokenCache(false);\n+            } catch (Exception e) {\n+              // ignore\n+            }\n+          }\n+        }, syncInterval, syncInterval, TimeUnit.SECONDS);\n+      } catch (Exception e) {\n+        LOG.error(\"Error rebuilding local cache for zkDelegationTokens \", e);\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void stopThreads() {\n+    super.stopThreads();\n+    scheduler.shutdown();\n+  }\n+\n   @Override\n   public DelegationTokenIdentifier createIdentifier() {\n     return new DelegationTokenIdentifier();\n   }\n+\n+  /**\n+   * This function will rebuild local token cache from zk storage.\n+   * It is first called when the secret manager is initialized and\n+   * then regularly at a configured interval.\n+   *\n+   * @param initial whether this is called during initialization\n+   * @throws IOException\n+   */\n+  private void rebuildTokenCache(boolean initial) throws IOException {\n+    localTokenCache.clear();\n+    // Use bare zookeeper client to get all children since curator will\n+    // wrap the same API with a sorting process. This is time consuming given\n+    // millions of tokens\n+    List<String> zkTokens;\n+    try {\n+      zkTokens = zookeeper.getChildren(TOKEN_PATH, false);\n+    } catch (KeeperException | InterruptedException e) {\n+      throw new IOException(\"Tokens cannot be fetched from path \"\n+          + TOKEN_PATH, e);\n+    }\n+    byte[] data;\n+    for (String tokenPath : zkTokens) {\n+      try {\n+        data = zkClient.getData().forPath(\n+            ZK_DTSM_TOKENS_ROOT + \"/\" + tokenPath);\n+      } catch (KeeperException.NoNodeException e) {\n+        LOG.debug(\"No node in path [\" + tokenPath + \"]\");\n+        continue;\n+      } catch (Exception ex) {\n+        throw new IOException(ex);\n+      }\n+      // Store data to currentTokenMap\n+      processTokenAddOrUpdate(data);\n+      // Store data to localTokenCache for sync\n+      AbstractDelegationTokenIdentifier ident = createIdentifier();\n+      DataInputStream din = new DataInputStream(new ByteArrayInputStream(data));\n+      ident.readFields(din);\n+      localTokenCache.add(ident);\n+    }\n+    if (!initial) {\n+      // Sync zkTokens with local cache, specifically\n+      // 1) add/update tokens to local cache from zk, which is done through\n+      //    processTokenAddOrUpdate above\n+      // 2) remove tokens in local cache but not in zk anymore\n+      for (AbstractDelegationTokenIdentifier ident : currentTokens.keySet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51074d2ec190d4980e0dbf50d4bff935d9c569fb"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU3NjczMQ==", "bodyText": "localTokenCache is a set for tokenIdent, currentTokens is the map to store the actual TokenInformation. We will need to construct all of the TokenInformation to do the swap. And the swap needs to be done in a synchronized block. I think the current way is simpler and following the logic inside its parent class.", "url": "https://github.com/apache/hadoop/pull/2047#discussion_r442576731", "createdAt": "2020-06-19T00:58:20Z", "author": {"login": "fengnanli"}, "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/security/token/ZKDelegationTokenSecretManagerImpl.java", "diffHunk": "@@ -19,38 +19,211 @@\n package org.apache.hadoop.hdfs.server.federation.router.security.token;\n \n import org.apache.hadoop.hdfs.security.token.delegation.DelegationTokenIdentifier;\n+import org.apache.hadoop.security.token.Token;\n import org.apache.hadoop.security.token.delegation.AbstractDelegationTokenIdentifier;\n import org.apache.hadoop.security.token.delegation.ZKDelegationTokenSecretManager;\n+import org.apache.hadoop.util.Time;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.ZooKeeper;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.apache.hadoop.conf.Configuration;\n \n+import java.io.ByteArrayInputStream;\n+import java.io.DataInputStream;\n import java.io.IOException;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n \n /**\n  * Zookeeper based router delegation token store implementation.\n  */\n public class ZKDelegationTokenSecretManagerImpl extends\n     ZKDelegationTokenSecretManager<AbstractDelegationTokenIdentifier> {\n \n+  public static final String ZK_DTSM_ROUTER_TOKEN_SYNC_INTERVAL =\n+      \"zk-dt-secret-manager.router.token.sync.interval\";\n+  public static final int ZK_DTSM_ROUTER_TOKEN_SYNC_INTERVAL_DEFAULT = 5;\n+\n   private static final Logger LOG =\n       LoggerFactory.getLogger(ZKDelegationTokenSecretManagerImpl.class);\n \n-  private Configuration conf = null;\n+  private Configuration conf;\n+\n+  private final ScheduledExecutorService scheduler =\n+      Executors.newSingleThreadScheduledExecutor();\n+\n+  // Local cache of delegation tokens, used for depracating tokens from\n+  // currentTokenMap\n+  private final Set<AbstractDelegationTokenIdentifier> localTokenCache =\n+      new HashSet<>();\n+  // Native zk client for getting all tokens\n+  private ZooKeeper zookeeper;\n+  private final String TOKEN_PATH = \"/\" + zkClient.getNamespace()\n+      + ZK_DTSM_TOKENS_ROOT;\n+  // The flag used to issue an extra check before deletion\n+  // Since cancel token and token remover thread use the same\n+  // API here and one router could have a token that is renewed\n+  // by another router, thus token remover should always check ZK\n+  // to confirm whether it has been renewed or not\n+  private ThreadLocal<Boolean> checkAgainstZkBeforeDeletion =\n+      new ThreadLocal<Boolean>() {\n+        @Override\n+        protected Boolean initialValue() {\n+          return true;\n+        }\n+      };\n \n   public ZKDelegationTokenSecretManagerImpl(Configuration conf) {\n     super(conf);\n     this.conf = conf;\n     try {\n-      super.startThreads();\n+      startThreads();\n     } catch (IOException e) {\n       LOG.error(\"Error starting threads for zkDelegationTokens\", e);\n     }\n     LOG.info(\"Zookeeper delegation token secret manager instantiated\");\n   }\n \n+  @Override\n+  public void startThreads() throws IOException {\n+    super.startThreads();\n+    // start token cache related work when watcher is disabled\n+    if (!isTokenWatcherEnabled()) {\n+      LOG.info(\"Watcher for tokens is disabled in this secret manager\");\n+      try {\n+        // By default set this variable\n+        checkAgainstZkBeforeDeletion.set(true);\n+        // Ensure the token root path exists\n+        if (zkClient.checkExists().forPath(ZK_DTSM_TOKENS_ROOT) == null) {\n+          zkClient.create().creatingParentsIfNeeded()\n+              .withMode(CreateMode.PERSISTENT)\n+              .forPath(ZK_DTSM_TOKENS_ROOT);\n+        }\n+        // Set up zookeeper client\n+        try {\n+          zookeeper = zkClient.getZookeeperClient().getZooKeeper();\n+        } catch (Exception e) {\n+          LOG.info(\"Cannot get zookeeper client \", e);\n+        } finally {\n+          if (zookeeper == null) {\n+            throw new IOException(\"Zookeeper client is null\");\n+          }\n+        }\n+\n+        LOG.info(\"Start loading token cache\");\n+        long start = Time.now();\n+        rebuildTokenCache(true);\n+        LOG.info(\"Loaded token cache in {} milliseconds\", Time.now() - start);\n+\n+        int syncInterval = conf.getInt(ZK_DTSM_ROUTER_TOKEN_SYNC_INTERVAL,\n+            ZK_DTSM_ROUTER_TOKEN_SYNC_INTERVAL_DEFAULT);\n+        scheduler.scheduleAtFixedRate(new Runnable() {\n+          @Override\n+          public void run() {\n+            try {\n+              rebuildTokenCache(false);\n+            } catch (Exception e) {\n+              // ignore\n+            }\n+          }\n+        }, syncInterval, syncInterval, TimeUnit.SECONDS);\n+      } catch (Exception e) {\n+        LOG.error(\"Error rebuilding local cache for zkDelegationTokens \", e);\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void stopThreads() {\n+    super.stopThreads();\n+    scheduler.shutdown();\n+  }\n+\n   @Override\n   public DelegationTokenIdentifier createIdentifier() {\n     return new DelegationTokenIdentifier();\n   }\n+\n+  /**\n+   * This function will rebuild local token cache from zk storage.\n+   * It is first called when the secret manager is initialized and\n+   * then regularly at a configured interval.\n+   *\n+   * @param initial whether this is called during initialization\n+   * @throws IOException\n+   */\n+  private void rebuildTokenCache(boolean initial) throws IOException {\n+    localTokenCache.clear();\n+    // Use bare zookeeper client to get all children since curator will\n+    // wrap the same API with a sorting process. This is time consuming given\n+    // millions of tokens\n+    List<String> zkTokens;\n+    try {\n+      zkTokens = zookeeper.getChildren(TOKEN_PATH, false);\n+    } catch (KeeperException | InterruptedException e) {\n+      throw new IOException(\"Tokens cannot be fetched from path \"\n+          + TOKEN_PATH, e);\n+    }\n+    byte[] data;\n+    for (String tokenPath : zkTokens) {\n+      try {\n+        data = zkClient.getData().forPath(\n+            ZK_DTSM_TOKENS_ROOT + \"/\" + tokenPath);\n+      } catch (KeeperException.NoNodeException e) {\n+        LOG.debug(\"No node in path [\" + tokenPath + \"]\");\n+        continue;\n+      } catch (Exception ex) {\n+        throw new IOException(ex);\n+      }\n+      // Store data to currentTokenMap\n+      processTokenAddOrUpdate(data);\n+      // Store data to localTokenCache for sync\n+      AbstractDelegationTokenIdentifier ident = createIdentifier();\n+      DataInputStream din = new DataInputStream(new ByteArrayInputStream(data));\n+      ident.readFields(din);\n+      localTokenCache.add(ident);\n+    }\n+    if (!initial) {\n+      // Sync zkTokens with local cache, specifically\n+      // 1) add/update tokens to local cache from zk, which is done through\n+      //    processTokenAddOrUpdate above\n+      // 2) remove tokens in local cache but not in zk anymore\n+      for (AbstractDelegationTokenIdentifier ident : currentTokens.keySet()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQzMDMzMQ=="}, "originalCommit": {"oid": "51074d2ec190d4980e0dbf50d4bff935d9c569fb"}, "originalPosition": 181}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNjEwMDI0OnYy", "diffSide": "RIGHT", "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/test/java/org/apache/hadoop/hdfs/server/federation/security/token/TestZKDelegationTokenSecretManagerImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwOToyNTo0MlrOGeTmBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwMDo1OTozM1rOGmEwZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQzMTQ5NQ==", "bodyText": "lack of license annotation\uff1f", "url": "https://github.com/apache/hadoop/pull/2047#discussion_r434431495", "createdAt": "2020-06-03T09:25:42Z", "author": {"login": "Hexiaoqiao"}, "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/test/java/org/apache/hadoop/hdfs/server/federation/security/token/TestZKDelegationTokenSecretManagerImpl.java", "diffHunk": "@@ -0,0 +1,216 @@\n+package org.apache.hadoop.hdfs.server.federation.security.token;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51074d2ec190d4980e0dbf50d4bff935d9c569fb"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU3Njk5Nw==", "bodyText": "Sigh.. somehow I missed it. Thanks for pointing out.", "url": "https://github.com/apache/hadoop/pull/2047#discussion_r442576997", "createdAt": "2020-06-19T00:59:33Z", "author": {"login": "fengnanli"}, "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/test/java/org/apache/hadoop/hdfs/server/federation/security/token/TestZKDelegationTokenSecretManagerImpl.java", "diffHunk": "@@ -0,0 +1,216 @@\n+package org.apache.hadoop.hdfs.server.federation.security.token;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQzMTQ5NQ=="}, "originalCommit": {"oid": "51074d2ec190d4980e0dbf50d4bff935d9c569fb"}, "originalPosition": 1}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3579, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}