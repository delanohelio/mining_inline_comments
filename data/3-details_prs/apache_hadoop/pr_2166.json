{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU1MjEzNTAw", "number": 2166, "title": "HDFS-15488. Add a command to list all snapshots for a snaphottable root with snapshot Ids.", "bodyText": "please see https://issues.apache.org/jira/browse/HDFS-15488\nCOMMAND OUTPUT\nsbanerjee-MBP15:hadoop-3.4.0-SNAPSHOT sbanerjee$ bin/hdfs lsSnapshottableDir\ndrwxr-xr-x 0 sbanerjee supergroup 0 2020-07-27 11:52 2 65536 /user\nsbanerjee-MBP15:hadoop-3.4.0-SNAPSHOT sbanerjee$ bin/hdfs lsSnapshot /user\ndrwxr-xr-x 0 sbanerjee supergroup 0 2020-07-27 11:52 1 /user/.snapshot/s1\ndrwxr-xr-x 0 sbanerjee supergroup 0 2020-07-27 11:51 0 /user/.snapshot/s20200727-115156.407", "createdAt": "2020-07-22T16:05:26Z", "url": "https://github.com/apache/hadoop/pull/2166", "merged": true, "mergeCommit": {"oid": "68287371ccc66da80e6a3d7981ae6c7ce7238920"}, "closed": true, "closedAt": "2020-07-29T16:03:26Z", "author": {"login": "bshashikant"}, "timelineItems": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc32GcrAFqTQ1NDQ0NTEzMA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABc5tMOngH2gAyNDU1MjEzNTAwOmRiZmNkYWZkOGNkZTJlYzE4MjU3MmNiN2U1MWQxYmU1ZGQ3NGZkM2U=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU0NDQ1MTMw", "url": "https://github.com/apache/hadoop/pull/2166#pullrequestreview-454445130", "createdAt": "2020-07-23T19:47:50Z", "commit": {"oid": "51fc498d69c0e86fb7cf2bb217ed04ea36100991"}, "state": "COMMENTED", "comments": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QxOTo0Nzo1MFrOG2ZJaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMTowOTo0NlrOG2brUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY4ODI5Ng==", "bodyText": "Should relative path be resolved as well?\n    Path absF = fixRelativePart(path);\nShould Increment Read Statistics as well.\n    statistics.incrementReadOps(1);", "url": "https://github.com/apache/hadoop/pull/2166#discussion_r459688296", "createdAt": "2020-07-23T19:47:50Z", "author": {"login": "ayushtkn"}, "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/DistributedFileSystem.java", "diffHunk": "@@ -2148,6 +2149,15 @@ public Void next(final FileSystem fs, final Path p)\n     return dfs.getSnapshottableDirListing();\n   }\n \n+  /**\n+   * @return all the snapshots for a snapshottable directory\n+   * @throws IOException\n+   */\n+  public SnapshotStatus[] getSnapshotListing(Path snapshotRoot)\n+      throws IOException {\n+    return dfs.getSnapshotListing(getPathName(snapshotRoot));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51fc498d69c0e86fb7cf2bb217ed04ea36100991"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY5MDk0MQ==", "bodyText": "Should be :\nClientProtocol#getSnapshotListing(String)", "url": "https://github.com/apache/hadoop/pull/2166#discussion_r459690941", "createdAt": "2020-07-23T19:53:15Z", "author": {"login": "ayushtkn"}, "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/DFSClient.java", "diffHunk": "@@ -2190,6 +2191,24 @@ public void renameSnapshot(String snapshotDir, String snapshotOldName,\n     }\n   }\n \n+  /**\n+   * Get listing of all the snapshots for a snapshottable directory\n+   *\n+   * @return Information about all the snapshots for a snapshottable directory\n+   * @throws IOException If an I/O error occurred\n+   * @see ClientProtocol#getSnapshotListing()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51fc498d69c0e86fb7cf2bb217ed04ea36100991"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY5MTgxNQ==", "bodyText": "Seems Copy-paste error, Change to\ntry (TraceScope ignored = tracer.newScope(\"getSnapshotListing\")) {", "url": "https://github.com/apache/hadoop/pull/2166#discussion_r459691815", "createdAt": "2020-07-23T19:54:54Z", "author": {"login": "ayushtkn"}, "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/DFSClient.java", "diffHunk": "@@ -2190,6 +2191,24 @@ public void renameSnapshot(String snapshotDir, String snapshotOldName,\n     }\n   }\n \n+  /**\n+   * Get listing of all the snapshots for a snapshottable directory\n+   *\n+   * @return Information about all the snapshots for a snapshottable directory\n+   * @throws IOException If an I/O error occurred\n+   * @see ClientProtocol#getSnapshotListing()\n+   */\n+  public SnapshotStatus[] getSnapshotListing(String snapshotRoot)\n+      throws IOException {\n+    checkOpen();\n+    try (TraceScope ignored = tracer.newScope(\"getSnapshottableDirListing\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51fc498d69c0e86fb7cf2bb217ed04ea36100991"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY5NjE3Ng==", "bodyText": "Keep the argument name consistent, In ClientProtocol & Router its snapshotRoot, better keep same everywhere", "url": "https://github.com/apache/hadoop/pull/2166#discussion_r459696176", "createdAt": "2020-07-23T20:03:16Z", "author": {"login": "ayushtkn"}, "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/NameNodeRpcServer.java", "diffHunk": "@@ -2004,6 +2005,16 @@ public void renameSnapshot(String snapshotRoot, String snapshotOldName,\n     return status;\n   }\n \n+  @Override // Client Protocol\n+  public SnapshotStatus[] getSnapshotListing(String path)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51fc498d69c0e86fb7cf2bb217ed04ea36100991"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY5ODAyNw==", "bodyText": "Should put the path as well in the audit log too\n      logAuditEvent(success, \"listSnapshots\", snapshotRoot);", "url": "https://github.com/apache/hadoop/pull/2166#discussion_r459698027", "createdAt": "2020-07-23T20:06:48Z", "author": {"login": "ayushtkn"}, "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSNamesystem.java", "diffHunk": "@@ -7001,7 +7002,33 @@ void renameSnapshot(\n     logAuditEvent(true, operationName, null, null, null);\n     return status;\n   }\n-  \n+\n+  /**\n+   * Get the list of snapshots for a given snapshottable directory.\n+   *\n+   * @return The list of all the snapshots for a snapshottable directory\n+   * @throws IOException\n+   */\n+  public SnapshotStatus[] getSnapshotListing(String snapshotRoot)\n+      throws IOException {\n+    SnapshotStatus[] status = null;\n+    checkOperation(OperationCategory.READ);\n+    boolean success = false;\n+    readLock();\n+    try {\n+      checkOperation(OperationCategory.READ);\n+      status = FSDirSnapshotOp.getSnapshotListing(dir, snapshotManager,\n+          snapshotRoot);\n+      success = true;\n+    } catch (AccessControlException ace) {\n+      logAuditEvent(success, \"listSnapshots\", null, null, null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51fc498d69c0e86fb7cf2bb217ed04ea36100991"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcwMjE4OQ==", "bodyText": "Can get pc out of fsn lock and pass on from FsNamesystem by getting before taking lock, Would save lock retention time, the FsDirectory lock below is just dummy just asserts whether FSN lock is there or not", "url": "https://github.com/apache/hadoop/pull/2166#discussion_r459702189", "createdAt": "2020-07-23T20:15:16Z", "author": {"login": "ayushtkn"}, "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirSnapshotOp.java", "diffHunk": "@@ -155,6 +156,23 @@ static void renameSnapshot(FSDirectory fsd, FSPermissionChecker pc,\n     }\n   }\n \n+  static SnapshotStatus[] getSnapshotListing(\n+      FSDirectory fsd, SnapshotManager snapshotManager, String path)\n+      throws IOException {\n+    FSPermissionChecker pc = fsd.getPermissionChecker();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51fc498d69c0e86fb7cf2bb217ed04ea36100991"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcwMjc5Ng==", "bodyText": "Can use instead :\nfsd.checkPathAccess(pc,iip,FsAction.READ);", "url": "https://github.com/apache/hadoop/pull/2166#discussion_r459702796", "createdAt": "2020-07-23T20:16:27Z", "author": {"login": "ayushtkn"}, "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/FSDirSnapshotOp.java", "diffHunk": "@@ -155,6 +156,23 @@ static void renameSnapshot(FSDirectory fsd, FSPermissionChecker pc,\n     }\n   }\n \n+  static SnapshotStatus[] getSnapshotListing(\n+      FSDirectory fsd, SnapshotManager snapshotManager, String path)\n+      throws IOException {\n+    FSPermissionChecker pc = fsd.getPermissionChecker();\n+    fsd.readLock();\n+    try {\n+      INodesInPath iip = fsd.getINodesInPath(path, DirOp.READ);\n+      if (fsd.isPermissionEnabled()) {\n+        fsd.checkPermission(pc, iip, false, null, null, FsAction.READ,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51fc498d69c0e86fb7cf2bb217ed04ea36100991"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcwNTkxMg==", "bodyText": "Isn't the size of the list always be equal to the size of snapshotList?, if so and size is already known then no need of having a list and then converting to array, can directly take an array of size same as that of snapshotList", "url": "https://github.com/apache/hadoop/pull/2166#discussion_r459705912", "createdAt": "2020-07-23T20:22:14Z", "author": {"login": "ayushtkn"}, "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/snapshot/SnapshotManager.java", "diffHunk": "@@ -471,7 +473,35 @@ public void write(DataOutput out) throws IOException {\n     return statusList.toArray(\n         new SnapshottableDirectoryStatus[statusList.size()]);\n   }\n-  \n+\n+  /**\n+   * List all the snapshots under a snapshottable directory.\n+   */\n+  public SnapshotStatus[] getSnapshotListing(INodesInPath iip)\n+      throws IOException {\n+    INodeDirectory srcRoot = getSnapshottableRoot(iip);\n+    ReadOnlyList<Snapshot> snapshotList = srcRoot.getDirectorySnapshottableFeature().\n+        getSnapshotList();\n+    if (snapshotList.isEmpty()) {\n+      return null;\n+    }\n+    List<SnapshotStatus> statusList =\n+        new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51fc498d69c0e86fb7cf2bb217ed04ea36100991"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcwNzQ2OQ==", "bodyText": "Do you want to pass null, if there is no snapshots, Can't we pass an empty list?\nIt might create problem for some client checking the size of the array to conclude if there are snapshots or not or performing directly some operations without being too smart of having a null check, his code would break will a NPE. If there is no strong opposition, we may pass an empty array, I think, but I will keep the ball in your court", "url": "https://github.com/apache/hadoop/pull/2166#discussion_r459707469", "createdAt": "2020-07-23T20:25:25Z", "author": {"login": "ayushtkn"}, "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/snapshot/SnapshotManager.java", "diffHunk": "@@ -471,7 +473,35 @@ public void write(DataOutput out) throws IOException {\n     return statusList.toArray(\n         new SnapshottableDirectoryStatus[statusList.size()]);\n   }\n-  \n+\n+  /**\n+   * List all the snapshots under a snapshottable directory.\n+   */\n+  public SnapshotStatus[] getSnapshotListing(INodesInPath iip)\n+      throws IOException {\n+    INodeDirectory srcRoot = getSnapshottableRoot(iip);\n+    ReadOnlyList<Snapshot> snapshotList = srcRoot.getDirectorySnapshottableFeature().\n+        getSnapshotList();\n+    if (snapshotList.isEmpty()) {\n+      return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51fc498d69c0e86fb7cf2bb217ed04ea36100991"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcxNzg0NQ==", "bodyText": "This is messed up.\n\nlocations need to be passed, as of now you are ignoring the passed parameter itself.\ninvokeConcurrent only in case if the Path is of type isAll, you can use rpcServer.isInvokeConcurrent(snapshotRoot)\nOnce you make this change I think RouterRpcServer.merge(.) won't work, you need to write your own util to aggregate.\nThis needs to be covered by a UT as well, TestRouterRpc or TestRouterRPCMultipleDestinationMountTableResolver could be a good place to add one.\n\n** If you have any issue with RBF, let me know, will try to get you the code. :-)", "url": "https://github.com/apache/hadoop/pull/2166#discussion_r459717845", "createdAt": "2020-07-23T20:45:36Z", "author": {"login": "ayushtkn"}, "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/RouterSnapshot.java", "diffHunk": "@@ -157,6 +158,22 @@ public void renameSnapshot(String snapshotRoot, String oldSnapshotName,\n     return RouterRpcServer.merge(ret, SnapshottableDirectoryStatus.class);\n   }\n \n+  public SnapshotStatus[] getSnapshotListing(String snapshotRoot)\n+      throws IOException {\n+    rpcServer.checkOperation(NameNode.OperationCategory.READ);\n+    final List<RemoteLocation> locations =\n+        rpcServer.getLocationsForPath(snapshotRoot, true, false);\n+    RemoteMethod method = new RemoteMethod(\"getSnapshotListing\",\n+        new Class<?>[] {String.class},\n+        new RemoteParam());\n+    Set<FederationNamespaceInfo> nss = namenodeResolver.getNamespaces();\n+    Map<FederationNamespaceInfo, SnapshotStatus[]> ret =\n+        rpcClient.invokeConcurrent(\n+            nss, method, true, false, SnapshotStatus[].class);\n+\n+    return RouterRpcServer.merge(ret, SnapshotStatus.class);\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51fc498d69c0e86fb7cf2bb217ed04ea36100991"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcxOTQ2OA==", "bodyText": "Would be good if there is a error message as well, Something like invalid number of arguments...", "url": "https://github.com/apache/hadoop/pull/2166#discussion_r459719468", "createdAt": "2020-07-23T20:49:02Z", "author": {"login": "ayushtkn"}, "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/snapshot/LsSnapshot.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hdfs.tools.snapshot;\n+\n+import java.io.IOException;\n+\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.conf.Configured;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.hdfs.DistributedFileSystem;\n+import org.apache.hadoop.hdfs.protocol.SnapshotStatus;\n+import org.apache.hadoop.hdfs.protocol.SnapshottableDirectoryStatus;\n+import org.apache.hadoop.util.Tool;\n+import org.apache.hadoop.util.ToolRunner;\n+\n+/**\n+ * A tool used to list all snapshottable directories that are owned by the\n+ * current user. The tool returns all the snapshottable directories if the user\n+ * is a super user.\n+ */\n+@InterfaceAudience.Private\n+public class LsSnapshot extends Configured implements Tool {\n+  @Override\n+  public int run(String[] argv) throws Exception {\n+    String description = \"hdfs lsSnapshot <snapshotDir>: \\n\" +\n+        \"\\tGet the list of snapshots for a snapshottable directory.\\n\";\n+\n+    if(argv.length != 1) {\n+      System.err.println(\"Usage: \\n\" + description);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51fc498d69c0e86fb7cf2bb217ed04ea36100991"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcyMjc3Ng==", "bodyText": "Instead can use\n    DistributedFileSystem dfs = AdminHelper.getDFS(getConf());\nThis shall handle ViewFsOverloadScheme as well.\nThis would throw IllegalArgumentException so it should be inside the try block", "url": "https://github.com/apache/hadoop/pull/2166#discussion_r459722776", "createdAt": "2020-07-23T20:55:41Z", "author": {"login": "ayushtkn"}, "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/snapshot/LsSnapshot.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hdfs.tools.snapshot;\n+\n+import java.io.IOException;\n+\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.conf.Configured;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.hdfs.DistributedFileSystem;\n+import org.apache.hadoop.hdfs.protocol.SnapshotStatus;\n+import org.apache.hadoop.hdfs.protocol.SnapshottableDirectoryStatus;\n+import org.apache.hadoop.util.Tool;\n+import org.apache.hadoop.util.ToolRunner;\n+\n+/**\n+ * A tool used to list all snapshottable directories that are owned by the\n+ * current user. The tool returns all the snapshottable directories if the user\n+ * is a super user.\n+ */\n+@InterfaceAudience.Private\n+public class LsSnapshot extends Configured implements Tool {\n+  @Override\n+  public int run(String[] argv) throws Exception {\n+    String description = \"hdfs lsSnapshot <snapshotDir>: \\n\" +\n+        \"\\tGet the list of snapshots for a snapshottable directory.\\n\";\n+\n+    if(argv.length != 1) {\n+      System.err.println(\"Usage: \\n\" + description);\n+      return 1;\n+    }\n+\n+    FileSystem fs = FileSystem.get(getConf());\n+    if (! (fs instanceof DistributedFileSystem)) {\n+      System.err.println(\n+          \"lsSnapshot can only be used in DistributedFileSystem\");\n+      return 1;\n+    }\n+    DistributedFileSystem dfs = (DistributedFileSystem) fs;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51fc498d69c0e86fb7cf2bb217ed04ea36100991"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcyNjE1MA==", "bodyText": "I don't think we need to print the stack trace on the CLI? Just a line of error should work? Mostly it should trigger for FNF or for SnapshotException if the directory is not snapshottable. if required we can have the exception with trace in the debug log\nApart we should catch Exception as well for any runtime exceptions, propagating the exception in CLI won't look good", "url": "https://github.com/apache/hadoop/pull/2166#discussion_r459726150", "createdAt": "2020-07-23T21:02:09Z", "author": {"login": "ayushtkn"}, "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/tools/snapshot/LsSnapshot.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hdfs.tools.snapshot;\n+\n+import java.io.IOException;\n+\n+import org.apache.hadoop.classification.InterfaceAudience;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.conf.Configured;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.hdfs.DistributedFileSystem;\n+import org.apache.hadoop.hdfs.protocol.SnapshotStatus;\n+import org.apache.hadoop.hdfs.protocol.SnapshottableDirectoryStatus;\n+import org.apache.hadoop.util.Tool;\n+import org.apache.hadoop.util.ToolRunner;\n+\n+/**\n+ * A tool used to list all snapshottable directories that are owned by the\n+ * current user. The tool returns all the snapshottable directories if the user\n+ * is a super user.\n+ */\n+@InterfaceAudience.Private\n+public class LsSnapshot extends Configured implements Tool {\n+  @Override\n+  public int run(String[] argv) throws Exception {\n+    String description = \"hdfs lsSnapshot <snapshotDir>: \\n\" +\n+        \"\\tGet the list of snapshots for a snapshottable directory.\\n\";\n+\n+    if(argv.length != 1) {\n+      System.err.println(\"Usage: \\n\" + description);\n+      return 1;\n+    }\n+\n+    FileSystem fs = FileSystem.get(getConf());\n+    if (! (fs instanceof DistributedFileSystem)) {\n+      System.err.println(\n+          \"lsSnapshot can only be used in DistributedFileSystem\");\n+      return 1;\n+    }\n+    DistributedFileSystem dfs = (DistributedFileSystem) fs;\n+    Path snapshotRoot = new Path(argv[0]);\n+\n+    try {\n+      SnapshotStatus[] stats = dfs.getSnapshotListing(snapshotRoot);\n+      SnapshotStatus.print(stats, System.out);\n+    } catch (IOException e) {\n+      String[] content = e.getLocalizedMessage().split(\"\\n\");\n+      System.err.println(\"lsSnapshot: \" + content[0]);\n+      e.printStackTrace(System.err);\n+      return 1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51fc498d69c0e86fb7cf2bb217ed04ea36100991"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcyNzA4OQ==", "bodyText": "fsn is already there, can change to:\nfsn.getSnapshotManager().setAllowNestedSnapshots(true);", "url": "https://github.com/apache/hadoop/pull/2166#discussion_r459727089", "createdAt": "2020-07-23T21:04:06Z", "author": {"login": "ayushtkn"}, "path": "hadoop-hdfs-project/hadoop-hdfs/src/test/java/org/apache/hadoop/hdfs/server/namenode/snapshot/TestListSnapshot.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hdfs.server.namenode.snapshot;\n+\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.hdfs.DistributedFileSystem;\n+import org.apache.hadoop.hdfs.MiniDFSCluster;\n+import org.apache.hadoop.hdfs.protocol.SnapshotStatus;\n+import org.apache.hadoop.hdfs.protocol.SnapshottableDirectoryStatus;\n+import org.apache.hadoop.hdfs.server.namenode.FSNamesystem;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertEquals;\n+\n+public class TestListSnapshot {\n+\n+  static final short REPLICATION = 3;\n+\n+  private final Path dir1 = new Path(\"/TestSnapshot1\");\n+\n+  Configuration conf;\n+  MiniDFSCluster cluster;\n+  FSNamesystem fsn;\n+  DistributedFileSystem hdfs;\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    conf = new Configuration();\n+    cluster = new MiniDFSCluster.Builder(conf).numDataNodes(REPLICATION)\n+        .build();\n+    cluster.waitActive();\n+    fsn = cluster.getNamesystem();\n+    hdfs = cluster.getFileSystem();\n+    hdfs.mkdirs(dir1);\n+  }\n+\n+  @After\n+  public void tearDown() throws Exception {\n+    if (cluster != null) {\n+      cluster.shutdown();\n+      cluster = null;\n+    }\n+  }\n+\n+  /**\n+   * Test listing all the snapshottable directories\n+   */\n+  @Test(timeout = 60000)\n+  public void testListSnapshot() throws Exception {\n+    cluster.getNamesystem().getSnapshotManager().setAllowNestedSnapshots(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51fc498d69c0e86fb7cf2bb217ed04ea36100991"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcyOTc0NA==", "bodyText": "Can use LambdaTestUtils :\n``LambdaTestUtils.intercept(SnapshotException.class,\n    \"Directory is not a \" + \"snapshottable directory\",\n    () -> hdfs.getSnapshotListing(dir1)); ``", "url": "https://github.com/apache/hadoop/pull/2166#discussion_r459729744", "createdAt": "2020-07-23T21:09:46Z", "author": {"login": "ayushtkn"}, "path": "hadoop-hdfs-project/hadoop-hdfs/src/test/java/org/apache/hadoop/hdfs/server/namenode/snapshot/TestListSnapshot.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hdfs.server.namenode.snapshot;\n+\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.hdfs.DistributedFileSystem;\n+import org.apache.hadoop.hdfs.MiniDFSCluster;\n+import org.apache.hadoop.hdfs.protocol.SnapshotStatus;\n+import org.apache.hadoop.hdfs.protocol.SnapshottableDirectoryStatus;\n+import org.apache.hadoop.hdfs.server.namenode.FSNamesystem;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertEquals;\n+\n+public class TestListSnapshot {\n+\n+  static final short REPLICATION = 3;\n+\n+  private final Path dir1 = new Path(\"/TestSnapshot1\");\n+\n+  Configuration conf;\n+  MiniDFSCluster cluster;\n+  FSNamesystem fsn;\n+  DistributedFileSystem hdfs;\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    conf = new Configuration();\n+    cluster = new MiniDFSCluster.Builder(conf).numDataNodes(REPLICATION)\n+        .build();\n+    cluster.waitActive();\n+    fsn = cluster.getNamesystem();\n+    hdfs = cluster.getFileSystem();\n+    hdfs.mkdirs(dir1);\n+  }\n+\n+  @After\n+  public void tearDown() throws Exception {\n+    if (cluster != null) {\n+      cluster.shutdown();\n+      cluster = null;\n+    }\n+  }\n+\n+  /**\n+   * Test listing all the snapshottable directories\n+   */\n+  @Test(timeout = 60000)\n+  public void testListSnapshot() throws Exception {\n+    cluster.getNamesystem().getSnapshotManager().setAllowNestedSnapshots(true);\n+\n+    // Initially there is no snapshottable directories in the system\n+    SnapshotStatus[] snapshotStatuses = null;\n+    SnapshottableDirectoryStatus[] dirs = hdfs.getSnapshottableDirListing();\n+    assertNull(dirs);\n+    try {\n+      hdfs.getSnapshotListing(dir1);\n+    } catch (Exception e) {\n+      assertTrue(e.getMessage().contains(\n+          \"Directory is not a snapshottable directory\"));\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51fc498d69c0e86fb7cf2bb217ed04ea36100991"}, "originalPosition": 81}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU1NDU3MzQ5", "url": "https://github.com/apache/hadoop/pull/2166#pullrequestreview-455457349", "createdAt": "2020-07-27T03:57:15Z", "commit": {"oid": "51fc498d69c0e86fb7cf2bb217ed04ea36100991"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QwMzo1NzoxNVrOG3S3sw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QwMzo1NzoxNVrOG3S3sw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDYzNDAzNQ==", "bodyText": "SnapshotStatus should extend HDFSFileStatus, so that this can also be used as a status object if required,", "url": "https://github.com/apache/hadoop/pull/2166#discussion_r460634035", "createdAt": "2020-07-27T03:57:15Z", "author": {"login": "mukul1987"}, "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/java/org/apache/hadoop/hdfs/protocol/SnapshotStatus.java", "diffHunk": "@@ -0,0 +1,218 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hdfs.protocol;\n+\n+import java.io.PrintStream;\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+import java.util.EnumSet;\n+\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.fs.permission.FsPermission;\n+import org.apache.hadoop.hdfs.DFSUtilClient;\n+\n+/**\n+ * Metadata about a snapshottable directory\n+ */\n+public class SnapshotStatus {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "51fc498d69c0e86fb7cf2bb217ed04ea36100991"}, "originalPosition": 32}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "989158ab65079d530aa83e5c9b8fab5f0873e818", "author": {"user": {"login": "bshashikant", "name": null}}, "url": "https://github.com/apache/hadoop/commit/989158ab65079d530aa83e5c9b8fab5f0873e818", "committedDate": "2020-07-27T06:08:36Z", "message": "HDFS-15488. Add a command to list all snapshots for a snaphottable root with snapshot Ids."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "04f02d2d9820ce67abc3fe3b918f7dd637a56c51", "author": {"user": {"login": "bshashikant", "name": null}}, "url": "https://github.com/apache/hadoop/commit/04f02d2d9820ce67abc3fe3b918f7dd637a56c51", "committedDate": "2020-07-27T06:31:07Z", "message": "Addressed checkstyle/findbug as well as review comments."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "51fc498d69c0e86fb7cf2bb217ed04ea36100991", "author": {"user": {"login": "bshashikant", "name": null}}, "url": "https://github.com/apache/hadoop/commit/51fc498d69c0e86fb7cf2bb217ed04ea36100991", "committedDate": "2020-07-22T16:03:29Z", "message": "HDFS-15488. Add a command to list all snapshots for a snaphottable root with snapshot Ids."}, "afterCommit": {"oid": "04f02d2d9820ce67abc3fe3b918f7dd637a56c51", "author": {"user": {"login": "bshashikant", "name": null}}, "url": "https://github.com/apache/hadoop/commit/04f02d2d9820ce67abc3fe3b918f7dd637a56c51", "committedDate": "2020-07-27T06:31:07Z", "message": "Addressed checkstyle/findbug as well as review comments."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "69902c9e9bfb6adc16d5976f101877f2a3f2ff9a", "author": {"user": {"login": "bshashikant", "name": null}}, "url": "https://github.com/apache/hadoop/commit/69902c9e9bfb6adc16d5976f101877f2a3f2ff9a", "committedDate": "2020-07-27T06:49:17Z", "message": "Added documentaion."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5bc83f1f685017c7182366e1c3ed3dd8cfa38bd6", "author": {"user": {"login": "bshashikant", "name": null}}, "url": "https://github.com/apache/hadoop/commit/5bc83f1f685017c7182366e1c3ed3dd8cfa38bd6", "committedDate": "2020-07-27T12:39:00Z", "message": "Fixed xml error."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU2MDE1MzQ3", "url": "https://github.com/apache/hadoop/pull/2166#pullrequestreview-456015347", "createdAt": "2020-07-27T18:04:52Z", "commit": {"oid": "5bc83f1f685017c7182366e1c3ed3dd8cfa38bd6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxODowNDo1MlrOG3tqFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxODowNDo1MlrOG3tqFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTA3MjkxNw==", "bodyText": "Here the SnapshotStatus contains parentpath as well, the path will be the one wrt the actual namespace not with respect to mount table. You need to replace the parentpath with path corresponding to the mount entry.\nif mount entry is : /mnt -> /dir in ns0, then if you trigger call on ns0 the path would be something like /dir/sub.. that you need to change to /mnt/sub..\nIn case of InvokeConcurrent you would be able to get Src and Dst from the ret and maybe something like this may work  -\n      response = ret.values().iterator().next();\n      String src = ret.keySet().iterator().next().getSrc();\n      String dst = ret.keySet().iterator().next().getDest();\n      for (SnapshotStatus s : response) {\n        String mountPath =\n            new String(s.getParentFullPath()).replaceFirst(dst, src);\n        s.setParentFullPath(mountPath.getBytes());\n      }\n\nFor the invokeSequential one you won't be having the detail on which location did the call got success, For that you have to get it returned back from RouterRpcClient#L858, I guess to get the location returned you would require a new InvokeSequential method which returns the location as well, may be can refactor and reuse this one...\nThis problem would be there I think in getSnapshottableDirListing() as well. If you want, you can put a TODO and handle the location stuff in a separate follow up jira for both API's.", "url": "https://github.com/apache/hadoop/pull/2166#discussion_r461072917", "createdAt": "2020-07-27T18:04:52Z", "author": {"login": "ayushtkn"}, "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/RouterSnapshot.java", "diffHunk": "@@ -157,6 +158,24 @@ public void renameSnapshot(String snapshotRoot, String oldSnapshotName,\n     return RouterRpcServer.merge(ret, SnapshottableDirectoryStatus.class);\n   }\n \n+  public SnapshotStatus[] getSnapshotListing(String snapshotRoot)\n+      throws IOException {\n+    rpcServer.checkOperation(NameNode.OperationCategory.READ);\n+    final List<RemoteLocation> locations =\n+        rpcServer.getLocationsForPath(snapshotRoot, true, false);\n+    RemoteMethod remoteMethod = new RemoteMethod(\"getSnapshotListing\",\n+        new Class<?>[]{String.class},\n+        new RemoteParam());\n+    if (rpcServer.isInvokeConcurrent(snapshotRoot)) {\n+      Map<RemoteLocation, SnapshotStatus[]> ret = rpcClient.invokeConcurrent(\n+          locations, remoteMethod, true, false, SnapshotStatus[].class);\n+      return ret.values().iterator().next();\n+    } else {\n+      return rpcClient.invokeSequential(\n+          locations, remoteMethod, SnapshotStatus[].class, null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bc83f1f685017c7182366e1c3ed3dd8cfa38bd6"}, "originalPosition": 26}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "972ab57f8c6769f4291456eb37b880b836d29ce2", "author": {"user": {"login": "bshashikant", "name": null}}, "url": "https://github.com/apache/hadoop/commit/972ab57f8c6769f4291456eb37b880b836d29ce2", "committedDate": "2020-07-28T05:38:41Z", "message": "Addressed review comments."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU2MzM5NDcy", "url": "https://github.com/apache/hadoop/pull/2166#pullrequestreview-456339472", "createdAt": "2020-07-28T06:36:07Z", "commit": {"oid": "972ab57f8c6769f4291456eb37b880b836d29ce2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwNjozNjowN1rOG3-llA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwNjozNjowN1rOG3-llA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTM1MDI5Mg==", "bodyText": "The actual location won't be always the first one in the list. RouterRpcClient#L858 iterates over the list and triggers call to them sequentially, if the first location doesn't give the specific response, then second and so on. Adding a line at RouterRpcClient at L872 just before  return ret;, shall make this logic work -\n          Collections.swap(locations, 0, locations.indexOf(loc));\nApart everything seems good here.", "url": "https://github.com/apache/hadoop/pull/2166#discussion_r461350292", "createdAt": "2020-07-28T06:36:07Z", "author": {"login": "ayushtkn"}, "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/main/java/org/apache/hadoop/hdfs/server/federation/router/RouterSnapshot.java", "diffHunk": "@@ -166,14 +167,30 @@ public void renameSnapshot(String snapshotRoot, String oldSnapshotName,\n     RemoteMethod remoteMethod = new RemoteMethod(\"getSnapshotListing\",\n         new Class<?>[]{String.class},\n         new RemoteParam());\n+    SnapshotStatus[] response;\n     if (rpcServer.isInvokeConcurrent(snapshotRoot)) {\n       Map<RemoteLocation, SnapshotStatus[]> ret = rpcClient.invokeConcurrent(\n           locations, remoteMethod, true, false, SnapshotStatus[].class);\n-      return ret.values().iterator().next();\n+      response = ret.values().iterator().next();\n+      String src = ret.keySet().iterator().next().getSrc();\n+      String dst = ret.keySet().iterator().next().getDest();\n+      for (SnapshotStatus s : response) {\n+        String mountPath =\n+            new String(s.getParentFullPath()).replaceFirst(src, dst);\n+        s.setParentFullPath(mountPath.getBytes());\n+      }\n     } else {\n-      return rpcClient.invokeSequential(\n+      response = rpcClient.invokeSequential(\n           locations, remoteMethod, SnapshotStatus[].class, null);\n+      RemoteLocation loc = locations.get(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "972ab57f8c6769f4291456eb37b880b836d29ce2"}, "originalPosition": 29}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU2NTI1MDY2", "url": "https://github.com/apache/hadoop/pull/2166#pullrequestreview-456525066", "createdAt": "2020-07-28T11:03:21Z", "commit": {"oid": "972ab57f8c6769f4291456eb37b880b836d29ce2"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxMTowMzoyMVrOG4HjSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxMToyMToyMlrOG4IHVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ5NzE2Mw==", "bodyText": "Expand wildcard imports.", "url": "https://github.com/apache/hadoop/pull/2166#discussion_r461497163", "createdAt": "2020-07-28T11:03:21Z", "author": {"login": "mukul1987"}, "path": "hadoop-hdfs-project/hadoop-hdfs-rbf/src/test/java/org/apache/hadoop/hdfs/server/federation/router/TestRouterRpc.java", "diffHunk": "@@ -71,29 +71,9 @@\n import org.apache.hadoop.hdfs.MiniDFSCluster.DataNodeProperties;\n import org.apache.hadoop.hdfs.NameNodeProxies;\n import org.apache.hadoop.hdfs.client.HdfsDataOutputStream;\n-import org.apache.hadoop.hdfs.protocol.AddErasureCodingPolicyResponse;\n-import org.apache.hadoop.hdfs.protocol.BlockStoragePolicy;\n-import org.apache.hadoop.hdfs.protocol.CacheDirectiveInfo;\n-import org.apache.hadoop.hdfs.protocol.CachePoolEntry;\n-import org.apache.hadoop.hdfs.protocol.CachePoolInfo;\n-import org.apache.hadoop.hdfs.protocol.ClientProtocol;\n-import org.apache.hadoop.hdfs.protocol.DatanodeInfo;\n-import org.apache.hadoop.hdfs.protocol.DirectoryListing;\n-import org.apache.hadoop.hdfs.protocol.ECBlockGroupStats;\n-import org.apache.hadoop.hdfs.protocol.ErasureCodingPolicy;\n-import org.apache.hadoop.hdfs.protocol.ErasureCodingPolicyInfo;\n-import org.apache.hadoop.hdfs.protocol.ErasureCodingPolicyState;\n-import org.apache.hadoop.hdfs.protocol.HdfsConstants;\n+import org.apache.hadoop.hdfs.protocol.*;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "972ab57f8c6769f4291456eb37b880b836d29ce2"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTUwMDM2OA==", "bodyText": "This snapid should be the id of the snapshot here ?", "url": "https://github.com/apache/hadoop/pull/2166#discussion_r461500368", "createdAt": "2020-07-28T11:09:47Z", "author": {"login": "mukul1987"}, "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/snapshot/SnapshotManager.java", "diffHunk": "@@ -501,7 +509,31 @@ public void write(DataOutput out) throws IOException {\n     return statusList.toArray(\n         new SnapshottableDirectoryStatus[statusList.size()]);\n   }\n-  \n+\n+  /**\n+   * List all the snapshots under a snapshottable directory.\n+   */\n+  public SnapshotStatus[] getSnapshotListing(INodesInPath iip)\n+      throws IOException {\n+    INodeDirectory srcRoot = getSnapshottableRoot(iip);\n+    ReadOnlyList<Snapshot> snapshotList = srcRoot.\n+        getDirectorySnapshottableFeature().getSnapshotList();\n+    SnapshotStatus[] statuses = new SnapshotStatus[snapshotList.size()];\n+    for (int count = 0; count < snapshotList.size(); count++) {\n+      Snapshot s = snapshotList.get(count);\n+      Snapshot.Root dir = s.getRoot();\n+      statuses[count] = new SnapshotStatus(dir.getModificationTime(),\n+          dir.getAccessTime(), dir.getFsPermission(),\n+          EnumSet.noneOf(HdfsFileStatus.Flags.class),\n+          dir.getUserName(), dir.getGroupName(),\n+          dir.getLocalNameBytes(), dir.getId(),\n+          dir.getChildrenNum(Snapshot.CURRENT_STATE_ID),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "972ab57f8c6769f4291456eb37b880b836d29ce2"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTUwMjQ4Nw==", "bodyText": "Can we add a comment here on why the ID here should not be snapID ?\nAnd that childrenNumber can be a wrong value.", "url": "https://github.com/apache/hadoop/pull/2166#discussion_r461502487", "createdAt": "2020-07-28T11:13:38Z", "author": {"login": "mukul1987"}, "path": "hadoop-hdfs-project/hadoop-hdfs/src/main/java/org/apache/hadoop/hdfs/server/namenode/snapshot/SnapshotManager.java", "diffHunk": "@@ -501,7 +509,31 @@ public void write(DataOutput out) throws IOException {\n     return statusList.toArray(\n         new SnapshottableDirectoryStatus[statusList.size()]);\n   }\n-  \n+\n+  /**\n+   * List all the snapshots under a snapshottable directory.\n+   */\n+  public SnapshotStatus[] getSnapshotListing(INodesInPath iip)\n+      throws IOException {\n+    INodeDirectory srcRoot = getSnapshottableRoot(iip);\n+    ReadOnlyList<Snapshot> snapshotList = srcRoot.\n+        getDirectorySnapshottableFeature().getSnapshotList();\n+    SnapshotStatus[] statuses = new SnapshotStatus[snapshotList.size()];\n+    for (int count = 0; count < snapshotList.size(); count++) {\n+      Snapshot s = snapshotList.get(count);\n+      Snapshot.Root dir = s.getRoot();\n+      statuses[count] = new SnapshotStatus(dir.getModificationTime(),\n+          dir.getAccessTime(), dir.getFsPermission(),\n+          EnumSet.noneOf(HdfsFileStatus.Flags.class),\n+          dir.getUserName(), dir.getGroupName(),\n+          dir.getLocalNameBytes(), dir.getId(),\n+          dir.getChildrenNum(Snapshot.CURRENT_STATE_ID),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTUwMDM2OA=="}, "originalCommit": {"oid": "972ab57f8c6769f4291456eb37b880b836d29ce2"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTUwNTMyOQ==", "bodyText": "wildcard imports here.", "url": "https://github.com/apache/hadoop/pull/2166#discussion_r461505329", "createdAt": "2020-07-28T11:19:10Z", "author": {"login": "mukul1987"}, "path": "hadoop-hdfs-project/hadoop-hdfs/src/test/java/org/apache/hadoop/hdfs/server/namenode/snapshot/TestListSnapshot.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hdfs.server.namenode.snapshot;\n+\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.hdfs.DistributedFileSystem;\n+import org.apache.hadoop.hdfs.MiniDFSCluster;\n+import org.apache.hadoop.hdfs.protocol.SnapshotException;\n+import org.apache.hadoop.hdfs.protocol.SnapshotStatus;\n+import org.apache.hadoop.hdfs.protocol.SnapshottableDirectoryStatus;\n+import org.apache.hadoop.hdfs.server.namenode.FSNamesystem;\n+import org.apache.hadoop.test.LambdaTestUtils;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import static org.junit.Assert.*;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "972ab57f8c6769f4291456eb37b880b836d29ce2"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTUwNTY1MA==", "bodyText": "The flag should be set to false ?", "url": "https://github.com/apache/hadoop/pull/2166#discussion_r461505650", "createdAt": "2020-07-28T11:19:47Z", "author": {"login": "mukul1987"}, "path": "hadoop-hdfs-project/hadoop-hdfs/src/test/java/org/apache/hadoop/hdfs/server/namenode/snapshot/TestListSnapshot.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hdfs.server.namenode.snapshot;\n+\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.hdfs.DistributedFileSystem;\n+import org.apache.hadoop.hdfs.MiniDFSCluster;\n+import org.apache.hadoop.hdfs.protocol.SnapshotException;\n+import org.apache.hadoop.hdfs.protocol.SnapshotStatus;\n+import org.apache.hadoop.hdfs.protocol.SnapshottableDirectoryStatus;\n+import org.apache.hadoop.hdfs.server.namenode.FSNamesystem;\n+import org.apache.hadoop.test.LambdaTestUtils;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import static org.junit.Assert.*;\n+\n+/**\n+ * Tests listSnapshot.\n+ */\n+public class TestListSnapshot {\n+\n+  static final short REPLICATION = 3;\n+\n+  private final Path dir1 = new Path(\"/TestSnapshot1\");\n+\n+  Configuration conf;\n+  MiniDFSCluster cluster;\n+  FSNamesystem fsn;\n+  DistributedFileSystem hdfs;\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    conf = new Configuration();\n+    cluster = new MiniDFSCluster.Builder(conf).numDataNodes(REPLICATION)\n+        .build();\n+    cluster.waitActive();\n+    fsn = cluster.getNamesystem();\n+    hdfs = cluster.getFileSystem();\n+    hdfs.mkdirs(dir1);\n+  }\n+\n+  @After\n+  public void tearDown() throws Exception {\n+    if (cluster != null) {\n+      cluster.shutdown();\n+      cluster = null;\n+    }\n+  }\n+\n+  /**\n+   * Test listing all the snapshottable directories.\n+   */\n+  @Test(timeout = 60000)\n+  public void testListSnapshot() throws Exception {\n+    fsn.getSnapshotManager().setAllowNestedSnapshots(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "972ab57f8c6769f4291456eb37b880b836d29ce2"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTUwNjM4OA==", "bodyText": "create 2 snapshots for dir1 ?", "url": "https://github.com/apache/hadoop/pull/2166#discussion_r461506388", "createdAt": "2020-07-28T11:21:22Z", "author": {"login": "mukul1987"}, "path": "hadoop-hdfs-project/hadoop-hdfs/src/test/java/org/apache/hadoop/hdfs/server/namenode/snapshot/TestListSnapshot.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hdfs.server.namenode.snapshot;\n+\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.hdfs.DistributedFileSystem;\n+import org.apache.hadoop.hdfs.MiniDFSCluster;\n+import org.apache.hadoop.hdfs.protocol.SnapshotException;\n+import org.apache.hadoop.hdfs.protocol.SnapshotStatus;\n+import org.apache.hadoop.hdfs.protocol.SnapshottableDirectoryStatus;\n+import org.apache.hadoop.hdfs.server.namenode.FSNamesystem;\n+import org.apache.hadoop.test.LambdaTestUtils;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import static org.junit.Assert.*;\n+\n+/**\n+ * Tests listSnapshot.\n+ */\n+public class TestListSnapshot {\n+\n+  static final short REPLICATION = 3;\n+\n+  private final Path dir1 = new Path(\"/TestSnapshot1\");\n+\n+  Configuration conf;\n+  MiniDFSCluster cluster;\n+  FSNamesystem fsn;\n+  DistributedFileSystem hdfs;\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    conf = new Configuration();\n+    cluster = new MiniDFSCluster.Builder(conf).numDataNodes(REPLICATION)\n+        .build();\n+    cluster.waitActive();\n+    fsn = cluster.getNamesystem();\n+    hdfs = cluster.getFileSystem();\n+    hdfs.mkdirs(dir1);\n+  }\n+\n+  @After\n+  public void tearDown() throws Exception {\n+    if (cluster != null) {\n+      cluster.shutdown();\n+      cluster = null;\n+    }\n+  }\n+\n+  /**\n+   * Test listing all the snapshottable directories.\n+   */\n+  @Test(timeout = 60000)\n+  public void testListSnapshot() throws Exception {\n+    fsn.getSnapshotManager().setAllowNestedSnapshots(true);\n+\n+    // Initially there is no snapshottable directories in the system\n+    SnapshotStatus[] snapshotStatuses = null;\n+    SnapshottableDirectoryStatus[] dirs = hdfs.getSnapshottableDirListing();\n+    assertNull(dirs);\n+    LambdaTestUtils.intercept(SnapshotException.class,\n+        \"Directory is not a \" + \"snapshottable directory\",\n+        () -> hdfs.getSnapshotListing(dir1));\n+    // Make root as snapshottable\n+    final Path root = new Path(\"/\");\n+    hdfs.allowSnapshot(root);\n+    dirs = hdfs.getSnapshottableDirListing();\n+    assertEquals(1, dirs.length);\n+    assertEquals(\"\", dirs[0].getDirStatus().getLocalName());\n+    assertEquals(root, dirs[0].getFullPath());\n+    snapshotStatuses = hdfs.getSnapshotListing(root);\n+    assertTrue(snapshotStatuses.length == 0);\n+    // Make root non-snaphsottable\n+    hdfs.disallowSnapshot(root);\n+    dirs = hdfs.getSnapshottableDirListing();\n+    assertNull(dirs);\n+    snapshotStatuses = hdfs.getSnapshotListing(root);\n+    assertTrue(snapshotStatuses.length == 0);\n+\n+    // Make dir1 as snapshottable\n+    hdfs.allowSnapshot(dir1);\n+    hdfs.createSnapshot(dir1, \"s0\");\n+    snapshotStatuses = hdfs.getSnapshotListing(dir1);\n+    assertEquals(1, snapshotStatuses.length);\n+    assertEquals(\"s0\", snapshotStatuses[0].getDirStatus().\n+        getLocalName());\n+    assertEquals(SnapshotTestHelper.getSnapshotRoot(dir1, \"s0\"),\n+        snapshotStatuses[0].getFullPath());\n+    // snapshot id is zero\n+    assertEquals(0, snapshotStatuses[0].getSnapshotID());\n+    // Create a snapshot for dir2", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "972ab57f8c6769f4291456eb37b880b836d29ce2"}, "originalPosition": 109}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "81f9119d464e633bbf53681858ae6e2daf4bef04", "author": {"user": {"login": "bshashikant", "name": null}}, "url": "https://github.com/apache/hadoop/commit/81f9119d464e633bbf53681858ae6e2daf4bef04", "committedDate": "2020-07-28T14:26:05Z", "message": "Addressed Review comments."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU2ODgwMDE5", "url": "https://github.com/apache/hadoop/pull/2166#pullrequestreview-456880019", "createdAt": "2020-07-28T18:02:25Z", "commit": {"oid": "972ab57f8c6769f4291456eb37b880b836d29ce2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxODowMjoyNlrOG4YSQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxODowMjoyNlrOG4YSQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTc3MTMzMQ==", "bodyText": "we should also dispay if a particular snapshot is deleted/garbage collected or not.", "url": "https://github.com/apache/hadoop/pull/2166#discussion_r461771331", "createdAt": "2020-07-28T18:02:26Z", "author": {"login": "mukul1987"}, "path": "hadoop-hdfs-project/hadoop-hdfs-client/src/main/proto/hdfs.proto", "diffHunk": "@@ -563,13 +563,34 @@ message SnapshottableDirectoryStatusProto {\n   required bytes parent_fullpath = 4;\n }\n \n+/**\n+ * Status of a snapshot directory: besides the normal information for\n+ * a directory status, also include snapshot ID, and\n+ * the full path of the parent directory.\n+ */\n+message SnapshotStatusProto {\n+  required HdfsFileStatusProto dirStatus = 1;\n+\n+  // Fields specific for snapshot directory\n+  required uint32 snapshotID = 2;\n+  required bytes parent_fullpath = 3;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "972ab57f8c6769f4291456eb37b880b836d29ce2"}, "originalPosition": 14}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7f4911ce1f7994a262f924a8a1c37ee565bd4953", "author": {"user": {"login": "bshashikant", "name": null}}, "url": "https://github.com/apache/hadoop/commit/7f4911ce1f7994a262f924a8a1c37ee565bd4953", "committedDate": "2020-07-29T02:05:15Z", "message": "Addressed checkstyle issue."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU3MTU4MzE3", "url": "https://github.com/apache/hadoop/pull/2166#pullrequestreview-457158317", "createdAt": "2020-07-29T02:48:40Z", "commit": {"oid": "7f4911ce1f7994a262f924a8a1c37ee565bd4953"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "722869410635a0572781488e9dd51b064654013a", "author": {"user": {"login": "bshashikant", "name": null}}, "url": "https://github.com/apache/hadoop/commit/722869410635a0572781488e9dd51b064654013a", "committedDate": "2020-07-29T06:47:56Z", "message": "Addressed test failure."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU3NTc0NzYy", "url": "https://github.com/apache/hadoop/pull/2166#pullrequestreview-457574762", "createdAt": "2020-07-29T14:24:23Z", "commit": {"oid": "722869410635a0572781488e9dd51b064654013a"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dbfcdafd8cde2ec182572cb7e51d1be5dd74fd3e", "author": {"user": {"login": "bshashikant", "name": null}}, "url": "https://github.com/apache/hadoop/commit/dbfcdafd8cde2ec182572cb7e51d1be5dd74fd3e", "committedDate": "2020-07-29T15:58:51Z", "message": "Addressed few checkstyle issues."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3787, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}