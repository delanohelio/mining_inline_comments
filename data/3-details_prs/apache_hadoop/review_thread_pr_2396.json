{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA2MTE3MDI1", "number": 2396, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxMToxMjowN1rOEywu0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwNjowNDo1NFrOE0Pffg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNjYyNjcyOnYy", "diffSide": "RIGHT", "path": "hadoop-common-project/hadoop-common/src/test/java/org/apache/hadoop/fs/TestFileSystemCaching.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxMToxMjowN1rOHplBAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxNjo0ODoyNFrOHqlKtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzM2MDEyOA==", "bodyText": "typo?", "url": "https://github.com/apache/hadoop/pull/2396#discussion_r513360128", "createdAt": "2020-10-28T11:12:07Z", "author": {"login": "mehakmeet"}, "path": "hadoop-common-project/hadoop-common/src/test/java/org/apache/hadoop/fs/TestFileSystemCaching.java", "diffHunk": "@@ -336,4 +344,134 @@ public void testCacheIncludesURIUserInfo() throws Throwable {\n     assertNotEquals(keyA, new FileSystem.Cache.Key(\n         new URI(\"wasb://a:password@account.blob.core.windows.net\"), conf));\n   }\n+\n+\n+  /**\n+   * Single semaphore: no surplus FS instances will be created\n+   * and then discarded.\n+   */\n+  @Test\n+  public void testCacheSingleSemaphoredConstruction() throws Exception {\n+    FileSystem.Cache cache = semaphoredCache(1);\n+    createFileSystems(cache, 10);\n+    Assertions.assertThat(cache.getDiscardedInstances())\n+        .describedAs(\"Discarded FS instances\")\n+        .isEqualTo(0);\n+  }\n+\n+  /**\n+   * Dual semaphore: thread 2 will get as far as\n+   * blocking in the initialize() method while awaiting\n+   * thread 1 to complete its initialization.\n+   * <p></p>\n+   * The thread 2 FS instance will be discarded.\n+   * All other threads will block for a cache semaphore,\n+   * so when they are given an opportunity to proceed,\n+   * they will find that an FS instance exists.\n+   */\n+  @Test\n+  public void testCacheDualSemaphoreConstruction() throws Exception {\n+    FileSystem.Cache cache = semaphoredCache(2);\n+    createFileSystems(cache, 10);\n+    Assertions.assertThat(cache.getDiscardedInstances())\n+        .describedAs(\"Discarded FS instances\")\n+        .isEqualTo(1);\n+  }\n+\n+  /**\n+   * Construct the FS instances in a cache with effectively no\n+   * limit on the number of instances which can be created\n+   * simultaneously.\n+   * <p></p>\n+   * This is the effective state before HADOOP-17313.\n+   * <p></p>\n+   * All but one thread's FS instance will be discarded.\n+   */\n+  @Test\n+  public void testCacheLargeSemaphoreConstruction() throws Exception {\n+    FileSystem.Cache cache = semaphoredCache(999);\n+    int count = 10;\n+    createFileSystems(cache, count);\n+    Assertions.assertThat(cache.getDiscardedInstances())\n+        .describedAs(\"Discarded FS instances\")\n+        .isEqualTo(count -1);\n+  }\n+\n+  /**\n+   * Create a cache with a given semaphore size.\n+   * @param semaphores number of semaphores\n+   * @return the cache.\n+   */\n+  private FileSystem.Cache semaphoredCache(final int semaphores) {\n+    final Configuration conf1 = new Configuration();\n+    conf1.setInt(FS_CREATION_PARALLEL_COUNT, semaphores);\n+    FileSystem.Cache cache = new FileSystem.Cache(conf1);\n+    return cache;\n+  }\n+\n+  /**\n+   * Attempt to create {@code count} filesystems in parallel,\n+   * then assert that they are all equal.\n+   * @param cache cache to use\n+   * @param count count of filesystems to instantiate\n+   */\n+  private void createFileSystems(final FileSystem.Cache cache, final int count)\n+      throws URISyntaxException, InterruptedException,\n+             java.util.concurrent.ExecutionException {\n+    final Configuration conf = new Configuration();\n+    conf.set(\"fs.blocking.impl\", BlockingInitializer.NAME);\n+    // only one instance can be created at a time.\n+    URI uri = new URI(\"blocking://a\");\n+    ListeningExecutorService pool =\n+        BlockingThreadPoolExecutorService.newInstance(count * 2, 0,\n+            10, TimeUnit.SECONDS,\n+            \"creation-threads\");\n+\n+    // submit a set of requests to create an FS instance.\n+    // the semaphore will block all but one, and that will block until\n+    // it is allowed to continue\n+    List<ListenableFuture<FileSystem>> futures = new ArrayList<>(count);\n+\n+    // acquire the semaphore so blocking all FS instances from\n+    // being initialized.\n+    Semaphore semaphore = BlockingInitializer.sem;\n+    semaphore.acquire();\n+\n+    // su", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abd2ee20d0a4082e98a53df674206ab1b72f50b2"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQxMTE4OQ==", "bodyText": "cut", "url": "https://github.com/apache/hadoop/pull/2396#discussion_r514411189", "createdAt": "2020-10-29T16:48:24Z", "author": {"login": "steveloughran"}, "path": "hadoop-common-project/hadoop-common/src/test/java/org/apache/hadoop/fs/TestFileSystemCaching.java", "diffHunk": "@@ -336,4 +344,134 @@ public void testCacheIncludesURIUserInfo() throws Throwable {\n     assertNotEquals(keyA, new FileSystem.Cache.Key(\n         new URI(\"wasb://a:password@account.blob.core.windows.net\"), conf));\n   }\n+\n+\n+  /**\n+   * Single semaphore: no surplus FS instances will be created\n+   * and then discarded.\n+   */\n+  @Test\n+  public void testCacheSingleSemaphoredConstruction() throws Exception {\n+    FileSystem.Cache cache = semaphoredCache(1);\n+    createFileSystems(cache, 10);\n+    Assertions.assertThat(cache.getDiscardedInstances())\n+        .describedAs(\"Discarded FS instances\")\n+        .isEqualTo(0);\n+  }\n+\n+  /**\n+   * Dual semaphore: thread 2 will get as far as\n+   * blocking in the initialize() method while awaiting\n+   * thread 1 to complete its initialization.\n+   * <p></p>\n+   * The thread 2 FS instance will be discarded.\n+   * All other threads will block for a cache semaphore,\n+   * so when they are given an opportunity to proceed,\n+   * they will find that an FS instance exists.\n+   */\n+  @Test\n+  public void testCacheDualSemaphoreConstruction() throws Exception {\n+    FileSystem.Cache cache = semaphoredCache(2);\n+    createFileSystems(cache, 10);\n+    Assertions.assertThat(cache.getDiscardedInstances())\n+        .describedAs(\"Discarded FS instances\")\n+        .isEqualTo(1);\n+  }\n+\n+  /**\n+   * Construct the FS instances in a cache with effectively no\n+   * limit on the number of instances which can be created\n+   * simultaneously.\n+   * <p></p>\n+   * This is the effective state before HADOOP-17313.\n+   * <p></p>\n+   * All but one thread's FS instance will be discarded.\n+   */\n+  @Test\n+  public void testCacheLargeSemaphoreConstruction() throws Exception {\n+    FileSystem.Cache cache = semaphoredCache(999);\n+    int count = 10;\n+    createFileSystems(cache, count);\n+    Assertions.assertThat(cache.getDiscardedInstances())\n+        .describedAs(\"Discarded FS instances\")\n+        .isEqualTo(count -1);\n+  }\n+\n+  /**\n+   * Create a cache with a given semaphore size.\n+   * @param semaphores number of semaphores\n+   * @return the cache.\n+   */\n+  private FileSystem.Cache semaphoredCache(final int semaphores) {\n+    final Configuration conf1 = new Configuration();\n+    conf1.setInt(FS_CREATION_PARALLEL_COUNT, semaphores);\n+    FileSystem.Cache cache = new FileSystem.Cache(conf1);\n+    return cache;\n+  }\n+\n+  /**\n+   * Attempt to create {@code count} filesystems in parallel,\n+   * then assert that they are all equal.\n+   * @param cache cache to use\n+   * @param count count of filesystems to instantiate\n+   */\n+  private void createFileSystems(final FileSystem.Cache cache, final int count)\n+      throws URISyntaxException, InterruptedException,\n+             java.util.concurrent.ExecutionException {\n+    final Configuration conf = new Configuration();\n+    conf.set(\"fs.blocking.impl\", BlockingInitializer.NAME);\n+    // only one instance can be created at a time.\n+    URI uri = new URI(\"blocking://a\");\n+    ListeningExecutorService pool =\n+        BlockingThreadPoolExecutorService.newInstance(count * 2, 0,\n+            10, TimeUnit.SECONDS,\n+            \"creation-threads\");\n+\n+    // submit a set of requests to create an FS instance.\n+    // the semaphore will block all but one, and that will block until\n+    // it is allowed to continue\n+    List<ListenableFuture<FileSystem>> futures = new ArrayList<>(count);\n+\n+    // acquire the semaphore so blocking all FS instances from\n+    // being initialized.\n+    Semaphore semaphore = BlockingInitializer.sem;\n+    semaphore.acquire();\n+\n+    // su", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzM2MDEyOA=="}, "originalCommit": {"oid": "abd2ee20d0a4082e98a53df674206ab1b72f50b2"}, "originalPosition": 132}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyMTY2Mjk3OnYy", "diffSide": "RIGHT", "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/FileSystem.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxMDo0ODowNVrOHqWLaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxNjo0OToyN1rOHqlOCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDE2NTYwOQ==", "bodyText": "Should we have this as @VisibleForTesting?", "url": "https://github.com/apache/hadoop/pull/2396#discussion_r514165609", "createdAt": "2020-10-29T10:48:05Z", "author": {"login": "mehakmeet"}, "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/FileSystem.java", "diffHunk": "@@ -3517,33 +3546,86 @@ private FileSystem getInternal(URI uri, Configuration conf, Key key)\n       if (fs != null) {\n         return fs;\n       }\n-\n-      fs = createFileSystem(uri, conf);\n-      final long timeout = conf.getTimeDuration(SERVICE_SHUTDOWN_TIMEOUT,\n-          SERVICE_SHUTDOWN_TIMEOUT_DEFAULT,\n-          ShutdownHookManager.TIME_UNIT_DEFAULT);\n-      synchronized (this) { // refetch the lock again\n-        FileSystem oldfs = map.get(key);\n-        if (oldfs != null) { // a file system is created while lock is releasing\n-          fs.close(); // close the new file system\n-          return oldfs;  // return the old file system\n-        }\n-\n-        // now insert the new file system into the map\n-        if (map.isEmpty()\n-                && !ShutdownHookManager.get().isShutdownInProgress()) {\n-          ShutdownHookManager.get().addShutdownHook(clientFinalizer,\n-              SHUTDOWN_HOOK_PRIORITY, timeout,\n-              ShutdownHookManager.TIME_UNIT_DEFAULT);\n+      // fs not yet created, acquire lock\n+      // to construct an instance.\n+      try (DurationInfo d =\n+              new DurationInfo(LOGGER, false, \"Acquiring creator semaphore for %s\",\n+                  uri)) {\n+        creatorPermits.acquire();\n+      } catch (InterruptedException e) {\n+        // acquisition was interrupted; convert to an IOE.\n+        throw (IOException)new InterruptedIOException(e.toString())\n+            .initCause(e);\n+      }\n+      FileSystem fsToClose = null;\n+      try {\n+        // See if FS was instantiated by another thread while waiting\n+        // for the permit.\n+        synchronized (this) {\n+          fs = map.get(key);\n         }\n-        fs.key = key;\n-        map.put(key, fs);\n-        if (conf.getBoolean(\n-            FS_AUTOMATIC_CLOSE_KEY, FS_AUTOMATIC_CLOSE_DEFAULT)) {\n-          toAutoClose.add(key);\n+        if (fs != null) {\n+          LOGGER.debug(\"Filesystem {} created while awaiting semaphore\", uri);\n+          return fs;\n         }\n-        return fs;\n+        // create the filesystem\n+        fs = createFileSystem(uri, conf);\n+        final long timeout = conf.getTimeDuration(SERVICE_SHUTDOWN_TIMEOUT,\n+            SERVICE_SHUTDOWN_TIMEOUT_DEFAULT,\n+            ShutdownHookManager.TIME_UNIT_DEFAULT);\n+        // any FS to close outside of the synchronized section\n+        synchronized (this) { // lock on the Cache object\n+\n+          // see if there is now an entry for the FS, which happens\n+          // if another thread's creation overlapped with this one.\n+          FileSystem oldfs = map.get(key);\n+          if (oldfs != null) {\n+            // a file system was created in a separate thread.\n+            // save the FS reference to close outside all locks,\n+            // and switch to returning the oldFS\n+            fsToClose = fs;\n+            fs = oldfs;\n+          } else {\n+            // register the clientFinalizer if needed and shutdown isn't\n+            // already active\n+            if (map.isEmpty()\n+                && !ShutdownHookManager.get().isShutdownInProgress()) {\n+              ShutdownHookManager.get().addShutdownHook(clientFinalizer,\n+                  SHUTDOWN_HOOK_PRIORITY, timeout,\n+                  ShutdownHookManager.TIME_UNIT_DEFAULT);\n+            }\n+            // insert the new file system into the map\n+            fs.key = key;\n+            map.put(key, fs);\n+            if (conf.getBoolean(\n+                FS_AUTOMATIC_CLOSE_KEY, FS_AUTOMATIC_CLOSE_DEFAULT)) {\n+              toAutoClose.add(key);\n+            }\n+          }\n+        } // end of synchronized block\n+      } finally {\n+        // release the creator permit.\n+        creatorPermits.release();\n+      }\n+      if (fsToClose != null) {\n+        LOGGER.debug(\"Duplicate FS created for {}; discarding {}\",\n+            uri, fs);\n+        discardedInstances.incrementAndGet();\n+        // close the new file system\n+        // note this will briefly remove and reinstate \"fsToClose\" from\n+        // the map. It is done in a synchronized block so will not be\n+        // visible to others.\n+        fsToClose.close();\n       }\n+      return fs;\n+    }\n+\n+    /**\n+     * Get the count of discarded instances.\n+     * @return the new instance.\n+     */\n+    long getDiscardedInstances() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abd2ee20d0a4082e98a53df674206ab1b72f50b2"}, "originalPosition": 191}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQxMjA0MQ==", "bodyText": "done", "url": "https://github.com/apache/hadoop/pull/2396#discussion_r514412041", "createdAt": "2020-10-29T16:49:27Z", "author": {"login": "steveloughran"}, "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/FileSystem.java", "diffHunk": "@@ -3517,33 +3546,86 @@ private FileSystem getInternal(URI uri, Configuration conf, Key key)\n       if (fs != null) {\n         return fs;\n       }\n-\n-      fs = createFileSystem(uri, conf);\n-      final long timeout = conf.getTimeDuration(SERVICE_SHUTDOWN_TIMEOUT,\n-          SERVICE_SHUTDOWN_TIMEOUT_DEFAULT,\n-          ShutdownHookManager.TIME_UNIT_DEFAULT);\n-      synchronized (this) { // refetch the lock again\n-        FileSystem oldfs = map.get(key);\n-        if (oldfs != null) { // a file system is created while lock is releasing\n-          fs.close(); // close the new file system\n-          return oldfs;  // return the old file system\n-        }\n-\n-        // now insert the new file system into the map\n-        if (map.isEmpty()\n-                && !ShutdownHookManager.get().isShutdownInProgress()) {\n-          ShutdownHookManager.get().addShutdownHook(clientFinalizer,\n-              SHUTDOWN_HOOK_PRIORITY, timeout,\n-              ShutdownHookManager.TIME_UNIT_DEFAULT);\n+      // fs not yet created, acquire lock\n+      // to construct an instance.\n+      try (DurationInfo d =\n+              new DurationInfo(LOGGER, false, \"Acquiring creator semaphore for %s\",\n+                  uri)) {\n+        creatorPermits.acquire();\n+      } catch (InterruptedException e) {\n+        // acquisition was interrupted; convert to an IOE.\n+        throw (IOException)new InterruptedIOException(e.toString())\n+            .initCause(e);\n+      }\n+      FileSystem fsToClose = null;\n+      try {\n+        // See if FS was instantiated by another thread while waiting\n+        // for the permit.\n+        synchronized (this) {\n+          fs = map.get(key);\n         }\n-        fs.key = key;\n-        map.put(key, fs);\n-        if (conf.getBoolean(\n-            FS_AUTOMATIC_CLOSE_KEY, FS_AUTOMATIC_CLOSE_DEFAULT)) {\n-          toAutoClose.add(key);\n+        if (fs != null) {\n+          LOGGER.debug(\"Filesystem {} created while awaiting semaphore\", uri);\n+          return fs;\n         }\n-        return fs;\n+        // create the filesystem\n+        fs = createFileSystem(uri, conf);\n+        final long timeout = conf.getTimeDuration(SERVICE_SHUTDOWN_TIMEOUT,\n+            SERVICE_SHUTDOWN_TIMEOUT_DEFAULT,\n+            ShutdownHookManager.TIME_UNIT_DEFAULT);\n+        // any FS to close outside of the synchronized section\n+        synchronized (this) { // lock on the Cache object\n+\n+          // see if there is now an entry for the FS, which happens\n+          // if another thread's creation overlapped with this one.\n+          FileSystem oldfs = map.get(key);\n+          if (oldfs != null) {\n+            // a file system was created in a separate thread.\n+            // save the FS reference to close outside all locks,\n+            // and switch to returning the oldFS\n+            fsToClose = fs;\n+            fs = oldfs;\n+          } else {\n+            // register the clientFinalizer if needed and shutdown isn't\n+            // already active\n+            if (map.isEmpty()\n+                && !ShutdownHookManager.get().isShutdownInProgress()) {\n+              ShutdownHookManager.get().addShutdownHook(clientFinalizer,\n+                  SHUTDOWN_HOOK_PRIORITY, timeout,\n+                  ShutdownHookManager.TIME_UNIT_DEFAULT);\n+            }\n+            // insert the new file system into the map\n+            fs.key = key;\n+            map.put(key, fs);\n+            if (conf.getBoolean(\n+                FS_AUTOMATIC_CLOSE_KEY, FS_AUTOMATIC_CLOSE_DEFAULT)) {\n+              toAutoClose.add(key);\n+            }\n+          }\n+        } // end of synchronized block\n+      } finally {\n+        // release the creator permit.\n+        creatorPermits.release();\n+      }\n+      if (fsToClose != null) {\n+        LOGGER.debug(\"Duplicate FS created for {}; discarding {}\",\n+            uri, fs);\n+        discardedInstances.incrementAndGet();\n+        // close the new file system\n+        // note this will briefly remove and reinstate \"fsToClose\" from\n+        // the map. It is done in a synchronized block so will not be\n+        // visible to others.\n+        fsToClose.close();\n       }\n+      return fs;\n+    }\n+\n+    /**\n+     * Get the count of discarded instances.\n+     * @return the new instance.\n+     */\n+    long getDiscardedInstances() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDE2NTYwOQ=="}, "originalCommit": {"oid": "abd2ee20d0a4082e98a53df674206ab1b72f50b2"}, "originalPosition": 191}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyMTY2MzQ3OnYy", "diffSide": "RIGHT", "path": "hadoop-common-project/hadoop-common/src/test/java/org/apache/hadoop/fs/TestFileSystemCaching.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxMDo0ODoxNVrOHqWLsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQxMDo0ODoxNVrOHqWLsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDE2NTY4Mg==", "bodyText": "typo: \"aquire\" -> \"acquire\"", "url": "https://github.com/apache/hadoop/pull/2396#discussion_r514165682", "createdAt": "2020-10-29T10:48:15Z", "author": {"login": "mehakmeet"}, "path": "hadoop-common-project/hadoop-common/src/test/java/org/apache/hadoop/fs/TestFileSystemCaching.java", "diffHunk": "@@ -336,4 +344,134 @@ public void testCacheIncludesURIUserInfo() throws Throwable {\n     assertNotEquals(keyA, new FileSystem.Cache.Key(\n         new URI(\"wasb://a:password@account.blob.core.windows.net\"), conf));\n   }\n+\n+\n+  /**\n+   * Single semaphore: no surplus FS instances will be created\n+   * and then discarded.\n+   */\n+  @Test\n+  public void testCacheSingleSemaphoredConstruction() throws Exception {\n+    FileSystem.Cache cache = semaphoredCache(1);\n+    createFileSystems(cache, 10);\n+    Assertions.assertThat(cache.getDiscardedInstances())\n+        .describedAs(\"Discarded FS instances\")\n+        .isEqualTo(0);\n+  }\n+\n+  /**\n+   * Dual semaphore: thread 2 will get as far as\n+   * blocking in the initialize() method while awaiting\n+   * thread 1 to complete its initialization.\n+   * <p></p>\n+   * The thread 2 FS instance will be discarded.\n+   * All other threads will block for a cache semaphore,\n+   * so when they are given an opportunity to proceed,\n+   * they will find that an FS instance exists.\n+   */\n+  @Test\n+  public void testCacheDualSemaphoreConstruction() throws Exception {\n+    FileSystem.Cache cache = semaphoredCache(2);\n+    createFileSystems(cache, 10);\n+    Assertions.assertThat(cache.getDiscardedInstances())\n+        .describedAs(\"Discarded FS instances\")\n+        .isEqualTo(1);\n+  }\n+\n+  /**\n+   * Construct the FS instances in a cache with effectively no\n+   * limit on the number of instances which can be created\n+   * simultaneously.\n+   * <p></p>\n+   * This is the effective state before HADOOP-17313.\n+   * <p></p>\n+   * All but one thread's FS instance will be discarded.\n+   */\n+  @Test\n+  public void testCacheLargeSemaphoreConstruction() throws Exception {\n+    FileSystem.Cache cache = semaphoredCache(999);\n+    int count = 10;\n+    createFileSystems(cache, count);\n+    Assertions.assertThat(cache.getDiscardedInstances())\n+        .describedAs(\"Discarded FS instances\")\n+        .isEqualTo(count -1);\n+  }\n+\n+  /**\n+   * Create a cache with a given semaphore size.\n+   * @param semaphores number of semaphores\n+   * @return the cache.\n+   */\n+  private FileSystem.Cache semaphoredCache(final int semaphores) {\n+    final Configuration conf1 = new Configuration();\n+    conf1.setInt(FS_CREATION_PARALLEL_COUNT, semaphores);\n+    FileSystem.Cache cache = new FileSystem.Cache(conf1);\n+    return cache;\n+  }\n+\n+  /**\n+   * Attempt to create {@code count} filesystems in parallel,\n+   * then assert that they are all equal.\n+   * @param cache cache to use\n+   * @param count count of filesystems to instantiate\n+   */\n+  private void createFileSystems(final FileSystem.Cache cache, final int count)\n+      throws URISyntaxException, InterruptedException,\n+             java.util.concurrent.ExecutionException {\n+    final Configuration conf = new Configuration();\n+    conf.set(\"fs.blocking.impl\", BlockingInitializer.NAME);\n+    // only one instance can be created at a time.\n+    URI uri = new URI(\"blocking://a\");\n+    ListeningExecutorService pool =\n+        BlockingThreadPoolExecutorService.newInstance(count * 2, 0,\n+            10, TimeUnit.SECONDS,\n+            \"creation-threads\");\n+\n+    // submit a set of requests to create an FS instance.\n+    // the semaphore will block all but one, and that will block until\n+    // it is allowed to continue\n+    List<ListenableFuture<FileSystem>> futures = new ArrayList<>(count);\n+\n+    // acquire the semaphore so blocking all FS instances from\n+    // being initialized.\n+    Semaphore semaphore = BlockingInitializer.sem;\n+    semaphore.acquire();\n+\n+    // su\n+    for (int i = 0; i < count; i++) {\n+      futures.add(pool.submit(\n+          () -> cache.get(uri, conf)));\n+    }\n+    // now let all blocked initializers free\n+    semaphore.release();\n+    // get that first FS\n+    FileSystem createdFS = futures.get(0).get();\n+    // verify all the others are the same instance\n+    for (int i = 1; i < count; i++) {\n+      FileSystem fs = futures.get(i).get();\n+      Assertions.assertThat(fs)\n+          .isSameAs(createdFS);\n+    }\n+  }\n+\n+  /**\n+   * An FS which blocks in initialize() until it can aquire the shared", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abd2ee20d0a4082e98a53df674206ab1b72f50b2"}, "originalPosition": 150}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzMjE1MjMwOnYy", "diffSide": "RIGHT", "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/FileSystem.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQwNjowNDo1NFrOHr3NrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQxMzozODoxNVrOHvvSjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc1NTQzNg==", "bodyText": "What if close() throw IOException ?\nEven it has cached object, it will not return that.", "url": "https://github.com/apache/hadoop/pull/2396#discussion_r515755436", "createdAt": "2020-11-02T06:04:54Z", "author": {"login": "surendralilhore"}, "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/FileSystem.java", "diffHunk": "@@ -3517,33 +3546,86 @@ private FileSystem getInternal(URI uri, Configuration conf, Key key)\n       if (fs != null) {\n         return fs;\n       }\n-\n-      fs = createFileSystem(uri, conf);\n-      final long timeout = conf.getTimeDuration(SERVICE_SHUTDOWN_TIMEOUT,\n-          SERVICE_SHUTDOWN_TIMEOUT_DEFAULT,\n-          ShutdownHookManager.TIME_UNIT_DEFAULT);\n-      synchronized (this) { // refetch the lock again\n-        FileSystem oldfs = map.get(key);\n-        if (oldfs != null) { // a file system is created while lock is releasing\n-          fs.close(); // close the new file system\n-          return oldfs;  // return the old file system\n-        }\n-\n-        // now insert the new file system into the map\n-        if (map.isEmpty()\n-                && !ShutdownHookManager.get().isShutdownInProgress()) {\n-          ShutdownHookManager.get().addShutdownHook(clientFinalizer,\n-              SHUTDOWN_HOOK_PRIORITY, timeout,\n-              ShutdownHookManager.TIME_UNIT_DEFAULT);\n+      // fs not yet created, acquire lock\n+      // to construct an instance.\n+      try (DurationInfo d = new DurationInfo(LOGGER, false,\n+          \"Acquiring creator semaphore for %s\", uri)) {\n+        creatorPermits.acquire();\n+      } catch (InterruptedException e) {\n+        // acquisition was interrupted; convert to an IOE.\n+        throw (IOException)new InterruptedIOException(e.toString())\n+            .initCause(e);\n+      }\n+      FileSystem fsToClose = null;\n+      try {\n+        // See if FS was instantiated by another thread while waiting\n+        // for the permit.\n+        synchronized (this) {\n+          fs = map.get(key);\n         }\n-        fs.key = key;\n-        map.put(key, fs);\n-        if (conf.getBoolean(\n-            FS_AUTOMATIC_CLOSE_KEY, FS_AUTOMATIC_CLOSE_DEFAULT)) {\n-          toAutoClose.add(key);\n+        if (fs != null) {\n+          LOGGER.debug(\"Filesystem {} created while awaiting semaphore\", uri);\n+          return fs;\n         }\n-        return fs;\n+        // create the filesystem\n+        fs = createFileSystem(uri, conf);\n+        final long timeout = conf.getTimeDuration(SERVICE_SHUTDOWN_TIMEOUT,\n+            SERVICE_SHUTDOWN_TIMEOUT_DEFAULT,\n+            ShutdownHookManager.TIME_UNIT_DEFAULT);\n+        // any FS to close outside of the synchronized section\n+        synchronized (this) { // lock on the Cache object\n+\n+          // see if there is now an entry for the FS, which happens\n+          // if another thread's creation overlapped with this one.\n+          FileSystem oldfs = map.get(key);\n+          if (oldfs != null) {\n+            // a file system was created in a separate thread.\n+            // save the FS reference to close outside all locks,\n+            // and switch to returning the oldFS\n+            fsToClose = fs;\n+            fs = oldfs;\n+          } else {\n+            // register the clientFinalizer if needed and shutdown isn't\n+            // already active\n+            if (map.isEmpty()\n+                && !ShutdownHookManager.get().isShutdownInProgress()) {\n+              ShutdownHookManager.get().addShutdownHook(clientFinalizer,\n+                  SHUTDOWN_HOOK_PRIORITY, timeout,\n+                  ShutdownHookManager.TIME_UNIT_DEFAULT);\n+            }\n+            // insert the new file system into the map\n+            fs.key = key;\n+            map.put(key, fs);\n+            if (conf.getBoolean(\n+                FS_AUTOMATIC_CLOSE_KEY, FS_AUTOMATIC_CLOSE_DEFAULT)) {\n+              toAutoClose.add(key);\n+            }\n+          }\n+        } // end of synchronized block\n+      } finally {\n+        // release the creator permit.\n+        creatorPermits.release();\n       }\n+      if (fsToClose != null) {\n+        LOGGER.debug(\"Duplicate FS created for {}; discarding {}\",\n+            uri, fs);\n+        discardedInstances.incrementAndGet();\n+        // close the new file system\n+        // note this will briefly remove and reinstate \"fsToClose\" from\n+        // the map. It is done in a synchronized block so will not be\n+        // visible to others.\n+        fsToClose.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa4b65df4bd9118bb2caadc9d3b2e6756bf1dfc2"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODkyMzkzNQ==", "bodyText": "That is an interesting thought. I just left that code as is, but yes, it could fail\nLooking at FileSystem.close, the removal of the entry from the cache should be in a finally clause too, shouldn't it. ouch. Ignoring that for now.\nHow about I go to IOUtils.close() & catch and log on failures.", "url": "https://github.com/apache/hadoop/pull/2396#discussion_r518923935", "createdAt": "2020-11-06T18:17:46Z", "author": {"login": "steveloughran"}, "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/FileSystem.java", "diffHunk": "@@ -3517,33 +3546,86 @@ private FileSystem getInternal(URI uri, Configuration conf, Key key)\n       if (fs != null) {\n         return fs;\n       }\n-\n-      fs = createFileSystem(uri, conf);\n-      final long timeout = conf.getTimeDuration(SERVICE_SHUTDOWN_TIMEOUT,\n-          SERVICE_SHUTDOWN_TIMEOUT_DEFAULT,\n-          ShutdownHookManager.TIME_UNIT_DEFAULT);\n-      synchronized (this) { // refetch the lock again\n-        FileSystem oldfs = map.get(key);\n-        if (oldfs != null) { // a file system is created while lock is releasing\n-          fs.close(); // close the new file system\n-          return oldfs;  // return the old file system\n-        }\n-\n-        // now insert the new file system into the map\n-        if (map.isEmpty()\n-                && !ShutdownHookManager.get().isShutdownInProgress()) {\n-          ShutdownHookManager.get().addShutdownHook(clientFinalizer,\n-              SHUTDOWN_HOOK_PRIORITY, timeout,\n-              ShutdownHookManager.TIME_UNIT_DEFAULT);\n+      // fs not yet created, acquire lock\n+      // to construct an instance.\n+      try (DurationInfo d = new DurationInfo(LOGGER, false,\n+          \"Acquiring creator semaphore for %s\", uri)) {\n+        creatorPermits.acquire();\n+      } catch (InterruptedException e) {\n+        // acquisition was interrupted; convert to an IOE.\n+        throw (IOException)new InterruptedIOException(e.toString())\n+            .initCause(e);\n+      }\n+      FileSystem fsToClose = null;\n+      try {\n+        // See if FS was instantiated by another thread while waiting\n+        // for the permit.\n+        synchronized (this) {\n+          fs = map.get(key);\n         }\n-        fs.key = key;\n-        map.put(key, fs);\n-        if (conf.getBoolean(\n-            FS_AUTOMATIC_CLOSE_KEY, FS_AUTOMATIC_CLOSE_DEFAULT)) {\n-          toAutoClose.add(key);\n+        if (fs != null) {\n+          LOGGER.debug(\"Filesystem {} created while awaiting semaphore\", uri);\n+          return fs;\n         }\n-        return fs;\n+        // create the filesystem\n+        fs = createFileSystem(uri, conf);\n+        final long timeout = conf.getTimeDuration(SERVICE_SHUTDOWN_TIMEOUT,\n+            SERVICE_SHUTDOWN_TIMEOUT_DEFAULT,\n+            ShutdownHookManager.TIME_UNIT_DEFAULT);\n+        // any FS to close outside of the synchronized section\n+        synchronized (this) { // lock on the Cache object\n+\n+          // see if there is now an entry for the FS, which happens\n+          // if another thread's creation overlapped with this one.\n+          FileSystem oldfs = map.get(key);\n+          if (oldfs != null) {\n+            // a file system was created in a separate thread.\n+            // save the FS reference to close outside all locks,\n+            // and switch to returning the oldFS\n+            fsToClose = fs;\n+            fs = oldfs;\n+          } else {\n+            // register the clientFinalizer if needed and shutdown isn't\n+            // already active\n+            if (map.isEmpty()\n+                && !ShutdownHookManager.get().isShutdownInProgress()) {\n+              ShutdownHookManager.get().addShutdownHook(clientFinalizer,\n+                  SHUTDOWN_HOOK_PRIORITY, timeout,\n+                  ShutdownHookManager.TIME_UNIT_DEFAULT);\n+            }\n+            // insert the new file system into the map\n+            fs.key = key;\n+            map.put(key, fs);\n+            if (conf.getBoolean(\n+                FS_AUTOMATIC_CLOSE_KEY, FS_AUTOMATIC_CLOSE_DEFAULT)) {\n+              toAutoClose.add(key);\n+            }\n+          }\n+        } // end of synchronized block\n+      } finally {\n+        // release the creator permit.\n+        creatorPermits.release();\n       }\n+      if (fsToClose != null) {\n+        LOGGER.debug(\"Duplicate FS created for {}; discarding {}\",\n+            uri, fs);\n+        discardedInstances.incrementAndGet();\n+        // close the new file system\n+        // note this will briefly remove and reinstate \"fsToClose\" from\n+        // the map. It is done in a synchronized block so will not be\n+        // visible to others.\n+        fsToClose.close();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc1NTQzNg=="}, "originalCommit": {"oid": "fa4b65df4bd9118bb2caadc9d3b2e6756bf1dfc2"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTU2MjI1NQ==", "bodyText": "Looking at FileSystem.close, the removal of the entry from the cache should be in a finally clause too, shouldn't it. ouch. Ignoring that for now.\n\nI feel not required, processDeleteOnExit() already catching the IOException.\n\nHow about I go to IOUtils.close() & catch and log on failures.\n\nI didn't get this, are you planning to use IOUtils.close() to close filesystem instance ?", "url": "https://github.com/apache/hadoop/pull/2396#discussion_r519562255", "createdAt": "2020-11-09T05:36:13Z", "author": {"login": "surendralilhore"}, "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/FileSystem.java", "diffHunk": "@@ -3517,33 +3546,86 @@ private FileSystem getInternal(URI uri, Configuration conf, Key key)\n       if (fs != null) {\n         return fs;\n       }\n-\n-      fs = createFileSystem(uri, conf);\n-      final long timeout = conf.getTimeDuration(SERVICE_SHUTDOWN_TIMEOUT,\n-          SERVICE_SHUTDOWN_TIMEOUT_DEFAULT,\n-          ShutdownHookManager.TIME_UNIT_DEFAULT);\n-      synchronized (this) { // refetch the lock again\n-        FileSystem oldfs = map.get(key);\n-        if (oldfs != null) { // a file system is created while lock is releasing\n-          fs.close(); // close the new file system\n-          return oldfs;  // return the old file system\n-        }\n-\n-        // now insert the new file system into the map\n-        if (map.isEmpty()\n-                && !ShutdownHookManager.get().isShutdownInProgress()) {\n-          ShutdownHookManager.get().addShutdownHook(clientFinalizer,\n-              SHUTDOWN_HOOK_PRIORITY, timeout,\n-              ShutdownHookManager.TIME_UNIT_DEFAULT);\n+      // fs not yet created, acquire lock\n+      // to construct an instance.\n+      try (DurationInfo d = new DurationInfo(LOGGER, false,\n+          \"Acquiring creator semaphore for %s\", uri)) {\n+        creatorPermits.acquire();\n+      } catch (InterruptedException e) {\n+        // acquisition was interrupted; convert to an IOE.\n+        throw (IOException)new InterruptedIOException(e.toString())\n+            .initCause(e);\n+      }\n+      FileSystem fsToClose = null;\n+      try {\n+        // See if FS was instantiated by another thread while waiting\n+        // for the permit.\n+        synchronized (this) {\n+          fs = map.get(key);\n         }\n-        fs.key = key;\n-        map.put(key, fs);\n-        if (conf.getBoolean(\n-            FS_AUTOMATIC_CLOSE_KEY, FS_AUTOMATIC_CLOSE_DEFAULT)) {\n-          toAutoClose.add(key);\n+        if (fs != null) {\n+          LOGGER.debug(\"Filesystem {} created while awaiting semaphore\", uri);\n+          return fs;\n         }\n-        return fs;\n+        // create the filesystem\n+        fs = createFileSystem(uri, conf);\n+        final long timeout = conf.getTimeDuration(SERVICE_SHUTDOWN_TIMEOUT,\n+            SERVICE_SHUTDOWN_TIMEOUT_DEFAULT,\n+            ShutdownHookManager.TIME_UNIT_DEFAULT);\n+        // any FS to close outside of the synchronized section\n+        synchronized (this) { // lock on the Cache object\n+\n+          // see if there is now an entry for the FS, which happens\n+          // if another thread's creation overlapped with this one.\n+          FileSystem oldfs = map.get(key);\n+          if (oldfs != null) {\n+            // a file system was created in a separate thread.\n+            // save the FS reference to close outside all locks,\n+            // and switch to returning the oldFS\n+            fsToClose = fs;\n+            fs = oldfs;\n+          } else {\n+            // register the clientFinalizer if needed and shutdown isn't\n+            // already active\n+            if (map.isEmpty()\n+                && !ShutdownHookManager.get().isShutdownInProgress()) {\n+              ShutdownHookManager.get().addShutdownHook(clientFinalizer,\n+                  SHUTDOWN_HOOK_PRIORITY, timeout,\n+                  ShutdownHookManager.TIME_UNIT_DEFAULT);\n+            }\n+            // insert the new file system into the map\n+            fs.key = key;\n+            map.put(key, fs);\n+            if (conf.getBoolean(\n+                FS_AUTOMATIC_CLOSE_KEY, FS_AUTOMATIC_CLOSE_DEFAULT)) {\n+              toAutoClose.add(key);\n+            }\n+          }\n+        } // end of synchronized block\n+      } finally {\n+        // release the creator permit.\n+        creatorPermits.release();\n       }\n+      if (fsToClose != null) {\n+        LOGGER.debug(\"Duplicate FS created for {}; discarding {}\",\n+            uri, fs);\n+        discardedInstances.incrementAndGet();\n+        // close the new file system\n+        // note this will briefly remove and reinstate \"fsToClose\" from\n+        // the map. It is done in a synchronized block so will not be\n+        // visible to others.\n+        fsToClose.close();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc1NTQzNg=="}, "originalCommit": {"oid": "fa4b65df4bd9118bb2caadc9d3b2e6756bf1dfc2"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTgxOTkxNw==", "bodyText": "I feel not required, processDeleteOnExit() already catching the IOException.\n\nyes, but look at the subclasses", "url": "https://github.com/apache/hadoop/pull/2396#discussion_r519819917", "createdAt": "2020-11-09T13:38:15Z", "author": {"login": "steveloughran"}, "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/FileSystem.java", "diffHunk": "@@ -3517,33 +3546,86 @@ private FileSystem getInternal(URI uri, Configuration conf, Key key)\n       if (fs != null) {\n         return fs;\n       }\n-\n-      fs = createFileSystem(uri, conf);\n-      final long timeout = conf.getTimeDuration(SERVICE_SHUTDOWN_TIMEOUT,\n-          SERVICE_SHUTDOWN_TIMEOUT_DEFAULT,\n-          ShutdownHookManager.TIME_UNIT_DEFAULT);\n-      synchronized (this) { // refetch the lock again\n-        FileSystem oldfs = map.get(key);\n-        if (oldfs != null) { // a file system is created while lock is releasing\n-          fs.close(); // close the new file system\n-          return oldfs;  // return the old file system\n-        }\n-\n-        // now insert the new file system into the map\n-        if (map.isEmpty()\n-                && !ShutdownHookManager.get().isShutdownInProgress()) {\n-          ShutdownHookManager.get().addShutdownHook(clientFinalizer,\n-              SHUTDOWN_HOOK_PRIORITY, timeout,\n-              ShutdownHookManager.TIME_UNIT_DEFAULT);\n+      // fs not yet created, acquire lock\n+      // to construct an instance.\n+      try (DurationInfo d = new DurationInfo(LOGGER, false,\n+          \"Acquiring creator semaphore for %s\", uri)) {\n+        creatorPermits.acquire();\n+      } catch (InterruptedException e) {\n+        // acquisition was interrupted; convert to an IOE.\n+        throw (IOException)new InterruptedIOException(e.toString())\n+            .initCause(e);\n+      }\n+      FileSystem fsToClose = null;\n+      try {\n+        // See if FS was instantiated by another thread while waiting\n+        // for the permit.\n+        synchronized (this) {\n+          fs = map.get(key);\n         }\n-        fs.key = key;\n-        map.put(key, fs);\n-        if (conf.getBoolean(\n-            FS_AUTOMATIC_CLOSE_KEY, FS_AUTOMATIC_CLOSE_DEFAULT)) {\n-          toAutoClose.add(key);\n+        if (fs != null) {\n+          LOGGER.debug(\"Filesystem {} created while awaiting semaphore\", uri);\n+          return fs;\n         }\n-        return fs;\n+        // create the filesystem\n+        fs = createFileSystem(uri, conf);\n+        final long timeout = conf.getTimeDuration(SERVICE_SHUTDOWN_TIMEOUT,\n+            SERVICE_SHUTDOWN_TIMEOUT_DEFAULT,\n+            ShutdownHookManager.TIME_UNIT_DEFAULT);\n+        // any FS to close outside of the synchronized section\n+        synchronized (this) { // lock on the Cache object\n+\n+          // see if there is now an entry for the FS, which happens\n+          // if another thread's creation overlapped with this one.\n+          FileSystem oldfs = map.get(key);\n+          if (oldfs != null) {\n+            // a file system was created in a separate thread.\n+            // save the FS reference to close outside all locks,\n+            // and switch to returning the oldFS\n+            fsToClose = fs;\n+            fs = oldfs;\n+          } else {\n+            // register the clientFinalizer if needed and shutdown isn't\n+            // already active\n+            if (map.isEmpty()\n+                && !ShutdownHookManager.get().isShutdownInProgress()) {\n+              ShutdownHookManager.get().addShutdownHook(clientFinalizer,\n+                  SHUTDOWN_HOOK_PRIORITY, timeout,\n+                  ShutdownHookManager.TIME_UNIT_DEFAULT);\n+            }\n+            // insert the new file system into the map\n+            fs.key = key;\n+            map.put(key, fs);\n+            if (conf.getBoolean(\n+                FS_AUTOMATIC_CLOSE_KEY, FS_AUTOMATIC_CLOSE_DEFAULT)) {\n+              toAutoClose.add(key);\n+            }\n+          }\n+        } // end of synchronized block\n+      } finally {\n+        // release the creator permit.\n+        creatorPermits.release();\n       }\n+      if (fsToClose != null) {\n+        LOGGER.debug(\"Duplicate FS created for {}; discarding {}\",\n+            uri, fs);\n+        discardedInstances.incrementAndGet();\n+        // close the new file system\n+        // note this will briefly remove and reinstate \"fsToClose\" from\n+        // the map. It is done in a synchronized block so will not be\n+        // visible to others.\n+        fsToClose.close();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc1NTQzNg=="}, "originalCommit": {"oid": "fa4b65df4bd9118bb2caadc9d3b2e6756bf1dfc2"}, "originalPosition": 181}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3223, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}