{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQxMTc2NDkx", "number": 2107, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMjo1Mzo0MFrOEKTbtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNFQwNjoyOTo0OFrOELXDBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MjM5NjA3OnYy", "diffSide": "RIGHT", "path": "hadoop-hdfs-project/hadoop-hdfs/src/test/java/org/apache/hadoop/fs/viewfs/TestViewFsLinkFallback.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMjo1Mzo0MFrOGrRKbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwMDoyNzozM1rOGrS2OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAyMzE1MA==", "bodyText": "where \"the\" path", "url": "https://github.com/apache/hadoop/pull/2107#discussion_r448023150", "createdAt": "2020-06-30T22:53:40Z", "author": {"login": "jojochuang"}, "path": "hadoop-hdfs-project/hadoop-hdfs/src/test/java/org/apache/hadoop/fs/viewfs/TestViewFsLinkFallback.java", "diffHunk": "@@ -294,4 +298,155 @@ public void testMkdirShouldFailWhenFallbackFSNotAvailable()\n     assertTrue(fsTarget.exists(test));\n   }\n \n+  /**\n+   * Tests that the create file should be successful when the parent directory\n+   * is same as the existent fallback directory. The new file should be created\n+   * in fallback.\n+   */\n+  @Test\n+  public void testCreateFileOnInternalMountDirWithSameDirTreeExistInFallback()\n+      throws Exception {\n+    Configuration conf = new Configuration();\n+    ConfigUtil.addLink(conf, \"/user1/hive/warehouse/partition-0\",\n+        new Path(targetTestRoot.toString()).toUri());\n+    Path dir1 = new Path(targetTestRoot,\n+        \"fallbackDir/user1/hive/warehouse/partition-0\");\n+    fsTarget.mkdirs(dir1);\n+    Path fallbackTarget = new Path(targetTestRoot, \"fallbackDir\");\n+    ConfigUtil.addLinkFallback(conf, fallbackTarget.toUri());\n+\n+    AbstractFileSystem vfs =\n+        AbstractFileSystem.get(viewFsDefaultClusterUri, conf);\n+    Path p = new Path(\"/user1/hive/warehouse/test.file\");\n+    Path test = Path.mergePaths(fallbackTarget, p);\n+    assertFalse(fsTarget.exists(test));\n+    assertTrue(fsTarget.exists(test.getParent()));\n+    vfs.create(p, EnumSet.of(CREATE),\n+        Options.CreateOpts.perms(FsPermission.getDefault()));\n+    assertTrue(fsTarget.exists(test));\n+\n+  }\n+\n+  /**\n+   * Tests the making of a new directory which is not matching to any of\n+   * internal directory.\n+   */\n+  @Test\n+  public void testCreateNewFileWithOutMatchingToMountDirOrFallbackDirPath()\n+      throws Exception {\n+    Configuration conf = new Configuration();\n+    ConfigUtil.addLink(conf, \"/user1/hive/warehouse/partition-0\",\n+        new Path(targetTestRoot.toString()).toUri());\n+    Path fallbackTarget = new Path(targetTestRoot, \"fallbackDir\");\n+    fsTarget.mkdirs(fallbackTarget);\n+    ConfigUtil.addLinkFallback(conf, fallbackTarget.toUri());\n+    AbstractFileSystem vfs =\n+        AbstractFileSystem.get(viewFsDefaultClusterUri, conf);\n+    Path p = new Path(\"/user2/test.file\");\n+    Path test = Path.mergePaths(fallbackTarget, p);\n+    assertFalse(fsTarget.exists(test));\n+    // user2 does not exist in fallback\n+    assertFalse(fsTarget.exists(test.getParent()));\n+    vfs.create(p, EnumSet.of(CREATE),\n+        Options.CreateOpts.perms(FsPermission.getDefault()),\n+        Options.CreateOpts.createParent());\n+    // /user2/test.file should be created in fallback\n+    assertTrue(fsTarget.exists(test));\n+  }\n+\n+  /**\n+   * Tests the making of a new file on root which is not matching to any of\n+   * fallback files on root.\n+   */\n+  @Test\n+  public void testCreateFileOnRootWithFallbackEnabled()\n+      throws Exception {\n+    Configuration conf = new Configuration();\n+    Path fallbackTarget = new Path(targetTestRoot, \"fallbackDir\");\n+    fsTarget.mkdirs(fallbackTarget);\n+\n+    ConfigUtil.addLink(conf, \"/user1/hive/\",\n+        new Path(targetTestRoot.toString()).toUri());\n+    ConfigUtil.addLinkFallback(conf, fallbackTarget.toUri());\n+\n+    AbstractFileSystem vfs =\n+        AbstractFileSystem.get(viewFsDefaultClusterUri, conf);\n+    Path p = new Path(\"/test.file\");\n+    Path test = Path.mergePaths(fallbackTarget, p);\n+    assertFalse(fsTarget.exists(test));\n+    vfs.create(p, EnumSet.of(CREATE),\n+        Options.CreateOpts.perms(FsPermission.getDefault()));\n+    // /test.file should be created in fallback\n+    assertTrue(fsTarget.exists(test));\n+\n+  }\n+\n+  /**\n+   * Tests the create of a file on root where the path is matching to an\n+   * existing file on fallback's file on root.\n+   */\n+  @Test (expected = FileAlreadyExistsException.class)\n+  public void testCreateFileOnRootWithFallbackWithFileAlreadyExist()\n+      throws Exception {\n+    Configuration conf = new Configuration();\n+    Path fallbackTarget = new Path(targetTestRoot, \"fallbackDir\");\n+    Path testFile = new Path(fallbackTarget, \"test.file\");\n+    // pre-creating test file in fallback.\n+    fsTarget.createNewFile(testFile);\n+\n+    ConfigUtil.addLink(conf, \"/user1/hive/\",\n+        new Path(targetTestRoot.toString()).toUri());\n+    ConfigUtil.addLinkFallback(conf, fallbackTarget.toUri());\n+\n+    AbstractFileSystem vfs =\n+        AbstractFileSystem.get(viewFsDefaultClusterUri, conf);\n+      Path p = new Path(\"/test.file\");\n+      assertTrue(fsTarget.exists(testFile));\n+    vfs.create(p, EnumSet.of(CREATE),\n+        Options.CreateOpts.perms(FsPermission.getDefault()));\n+  }\n+\n+  /**\n+   * Tests the creating of a file where the path is same as mount link path.\n+   */\n+  @Test(expected= FileAlreadyExistsException.class)\n+  public void testCreateFileWhereThePathIsSameAsItsMountLinkPath()\n+      throws Exception {\n+    Configuration conf = new Configuration();\n+    Path fallbackTarget = new Path(targetTestRoot, \"fallbackDir\");\n+    fsTarget.mkdirs(fallbackTarget);\n+\n+    ConfigUtil.addLink(conf, \"/user1/hive/\",\n+        new Path(targetTestRoot.toString()).toUri());\n+    ConfigUtil.addLinkFallback(conf, fallbackTarget.toUri());\n+\n+    AbstractFileSystem vfs =\n+        AbstractFileSystem.get(viewFsDefaultClusterUri, conf);\n+      Path p = new Path(\"/user1/hive\");\n+      assertFalse(fsTarget.exists(Path.mergePaths(fallbackTarget, p)));\n+    vfs.create(p, EnumSet.of(CREATE),\n+        Options.CreateOpts.perms(FsPermission.getDefault()));\n+  }\n+\n+  /**\n+   * Tests the create of a file where he path is same as one of of the internal", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58598aefa34ee0b0029e425660c89e25fc0b4f4c"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1MDc0NA==", "bodyText": "Done.", "url": "https://github.com/apache/hadoop/pull/2107#discussion_r448050744", "createdAt": "2020-07-01T00:27:33Z", "author": {"login": "umamaheswararao"}, "path": "hadoop-hdfs-project/hadoop-hdfs/src/test/java/org/apache/hadoop/fs/viewfs/TestViewFsLinkFallback.java", "diffHunk": "@@ -294,4 +298,155 @@ public void testMkdirShouldFailWhenFallbackFSNotAvailable()\n     assertTrue(fsTarget.exists(test));\n   }\n \n+  /**\n+   * Tests that the create file should be successful when the parent directory\n+   * is same as the existent fallback directory. The new file should be created\n+   * in fallback.\n+   */\n+  @Test\n+  public void testCreateFileOnInternalMountDirWithSameDirTreeExistInFallback()\n+      throws Exception {\n+    Configuration conf = new Configuration();\n+    ConfigUtil.addLink(conf, \"/user1/hive/warehouse/partition-0\",\n+        new Path(targetTestRoot.toString()).toUri());\n+    Path dir1 = new Path(targetTestRoot,\n+        \"fallbackDir/user1/hive/warehouse/partition-0\");\n+    fsTarget.mkdirs(dir1);\n+    Path fallbackTarget = new Path(targetTestRoot, \"fallbackDir\");\n+    ConfigUtil.addLinkFallback(conf, fallbackTarget.toUri());\n+\n+    AbstractFileSystem vfs =\n+        AbstractFileSystem.get(viewFsDefaultClusterUri, conf);\n+    Path p = new Path(\"/user1/hive/warehouse/test.file\");\n+    Path test = Path.mergePaths(fallbackTarget, p);\n+    assertFalse(fsTarget.exists(test));\n+    assertTrue(fsTarget.exists(test.getParent()));\n+    vfs.create(p, EnumSet.of(CREATE),\n+        Options.CreateOpts.perms(FsPermission.getDefault()));\n+    assertTrue(fsTarget.exists(test));\n+\n+  }\n+\n+  /**\n+   * Tests the making of a new directory which is not matching to any of\n+   * internal directory.\n+   */\n+  @Test\n+  public void testCreateNewFileWithOutMatchingToMountDirOrFallbackDirPath()\n+      throws Exception {\n+    Configuration conf = new Configuration();\n+    ConfigUtil.addLink(conf, \"/user1/hive/warehouse/partition-0\",\n+        new Path(targetTestRoot.toString()).toUri());\n+    Path fallbackTarget = new Path(targetTestRoot, \"fallbackDir\");\n+    fsTarget.mkdirs(fallbackTarget);\n+    ConfigUtil.addLinkFallback(conf, fallbackTarget.toUri());\n+    AbstractFileSystem vfs =\n+        AbstractFileSystem.get(viewFsDefaultClusterUri, conf);\n+    Path p = new Path(\"/user2/test.file\");\n+    Path test = Path.mergePaths(fallbackTarget, p);\n+    assertFalse(fsTarget.exists(test));\n+    // user2 does not exist in fallback\n+    assertFalse(fsTarget.exists(test.getParent()));\n+    vfs.create(p, EnumSet.of(CREATE),\n+        Options.CreateOpts.perms(FsPermission.getDefault()),\n+        Options.CreateOpts.createParent());\n+    // /user2/test.file should be created in fallback\n+    assertTrue(fsTarget.exists(test));\n+  }\n+\n+  /**\n+   * Tests the making of a new file on root which is not matching to any of\n+   * fallback files on root.\n+   */\n+  @Test\n+  public void testCreateFileOnRootWithFallbackEnabled()\n+      throws Exception {\n+    Configuration conf = new Configuration();\n+    Path fallbackTarget = new Path(targetTestRoot, \"fallbackDir\");\n+    fsTarget.mkdirs(fallbackTarget);\n+\n+    ConfigUtil.addLink(conf, \"/user1/hive/\",\n+        new Path(targetTestRoot.toString()).toUri());\n+    ConfigUtil.addLinkFallback(conf, fallbackTarget.toUri());\n+\n+    AbstractFileSystem vfs =\n+        AbstractFileSystem.get(viewFsDefaultClusterUri, conf);\n+    Path p = new Path(\"/test.file\");\n+    Path test = Path.mergePaths(fallbackTarget, p);\n+    assertFalse(fsTarget.exists(test));\n+    vfs.create(p, EnumSet.of(CREATE),\n+        Options.CreateOpts.perms(FsPermission.getDefault()));\n+    // /test.file should be created in fallback\n+    assertTrue(fsTarget.exists(test));\n+\n+  }\n+\n+  /**\n+   * Tests the create of a file on root where the path is matching to an\n+   * existing file on fallback's file on root.\n+   */\n+  @Test (expected = FileAlreadyExistsException.class)\n+  public void testCreateFileOnRootWithFallbackWithFileAlreadyExist()\n+      throws Exception {\n+    Configuration conf = new Configuration();\n+    Path fallbackTarget = new Path(targetTestRoot, \"fallbackDir\");\n+    Path testFile = new Path(fallbackTarget, \"test.file\");\n+    // pre-creating test file in fallback.\n+    fsTarget.createNewFile(testFile);\n+\n+    ConfigUtil.addLink(conf, \"/user1/hive/\",\n+        new Path(targetTestRoot.toString()).toUri());\n+    ConfigUtil.addLinkFallback(conf, fallbackTarget.toUri());\n+\n+    AbstractFileSystem vfs =\n+        AbstractFileSystem.get(viewFsDefaultClusterUri, conf);\n+      Path p = new Path(\"/test.file\");\n+      assertTrue(fsTarget.exists(testFile));\n+    vfs.create(p, EnumSet.of(CREATE),\n+        Options.CreateOpts.perms(FsPermission.getDefault()));\n+  }\n+\n+  /**\n+   * Tests the creating of a file where the path is same as mount link path.\n+   */\n+  @Test(expected= FileAlreadyExistsException.class)\n+  public void testCreateFileWhereThePathIsSameAsItsMountLinkPath()\n+      throws Exception {\n+    Configuration conf = new Configuration();\n+    Path fallbackTarget = new Path(targetTestRoot, \"fallbackDir\");\n+    fsTarget.mkdirs(fallbackTarget);\n+\n+    ConfigUtil.addLink(conf, \"/user1/hive/\",\n+        new Path(targetTestRoot.toString()).toUri());\n+    ConfigUtil.addLinkFallback(conf, fallbackTarget.toUri());\n+\n+    AbstractFileSystem vfs =\n+        AbstractFileSystem.get(viewFsDefaultClusterUri, conf);\n+      Path p = new Path(\"/user1/hive\");\n+      assertFalse(fsTarget.exists(Path.mergePaths(fallbackTarget, p)));\n+    vfs.create(p, EnumSet.of(CREATE),\n+        Options.CreateOpts.perms(FsPermission.getDefault()));\n+  }\n+\n+  /**\n+   * Tests the create of a file where he path is same as one of of the internal", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAyMzE1MA=="}, "originalCommit": {"oid": "58598aefa34ee0b0029e425660c89e25fc0b4f4c"}, "originalPosition": 159}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MjQ4MjY2OnYy", "diffSide": "RIGHT", "path": "hadoop-hdfs-project/hadoop-hdfs/src/test/java/org/apache/hadoop/fs/viewfs/TestViewFileSystemLinkFallback.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMzozNTo0OVrOGrR-Iw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwMDoyNzo0NlrOGrS2cg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAzNjM4Nw==", "bodyText": "give this variable a more meaningful name?", "url": "https://github.com/apache/hadoop/pull/2107#discussion_r448036387", "createdAt": "2020-06-30T23:35:49Z", "author": {"login": "jojochuang"}, "path": "hadoop-hdfs-project/hadoop-hdfs/src/test/java/org/apache/hadoop/fs/viewfs/TestViewFileSystemLinkFallback.java", "diffHunk": "@@ -765,4 +766,154 @@ public void testMkdirsShouldReturnFalseWhenFallbackFSNotAvailable()\n       assertTrue(fsTarget.exists(test));\n     }\n   }\n+\n+  /**\n+   * Tests that the create file should be successful when the parent directory\n+   * is same as the existent fallback directory. The new file should be created\n+   * in fallback.\n+   */\n+  @Test\n+  public void testCreateFileOnInternalMountDirWithSameDirTreeExistInFallback()\n+      throws Exception {\n+    Configuration conf = new Configuration();\n+    ConfigUtil.addLink(conf, \"/user1/hive/warehouse/partition-0\",\n+        new Path(targetTestRoot.toString()).toUri());\n+    Path dir1 = new Path(targetTestRoot,\n+        \"fallbackDir/user1/hive/warehouse/partition-0\");\n+    fsTarget.mkdirs(dir1);\n+    Path fallbackTarget = new Path(targetTestRoot, \"fallbackDir\");\n+    ConfigUtil.addLinkFallback(conf, fallbackTarget.toUri());\n+\n+    try (FileSystem vfs = FileSystem.get(viewFsDefaultClusterUri, conf)) {\n+      Path p = new Path(\"/user1/hive/warehouse/test.file\");\n+      Path test = Path.mergePaths(fallbackTarget, p);\n+      assertFalse(fsTarget.exists(test));\n+      assertTrue(fsTarget.exists(test.getParent()));\n+      vfs.createNewFile(p);\n+      assertTrue(fsTarget.exists(test));\n+    }\n+  }\n+\n+  /**\n+   * Tests the making of a new directory which is not matching to any of\n+   * internal directory.\n+   */\n+  @Test\n+  public void testCreateNewFileWithOutMatchingToMountDirOrFallbackDirPath()\n+      throws Exception {\n+    Configuration conf = new Configuration();\n+    ConfigUtil.addLink(conf, \"/user1/hive/warehouse/partition-0\",\n+        new Path(targetTestRoot.toString()).toUri());\n+    Path fallbackTarget = new Path(targetTestRoot, \"fallbackDir\");\n+    fsTarget.mkdirs(fallbackTarget);\n+    ConfigUtil.addLinkFallback(conf, fallbackTarget.toUri());\n+    try (FileSystem vfs = FileSystem.get(viewFsDefaultClusterUri, conf)) {\n+      Path p = new Path(\"/user2/test.file\");\n+      Path test = Path.mergePaths(fallbackTarget, p);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58598aefa34ee0b0029e425660c89e25fc0b4f4c"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1MDgwMg==", "bodyText": "Done. Thanks", "url": "https://github.com/apache/hadoop/pull/2107#discussion_r448050802", "createdAt": "2020-07-01T00:27:46Z", "author": {"login": "umamaheswararao"}, "path": "hadoop-hdfs-project/hadoop-hdfs/src/test/java/org/apache/hadoop/fs/viewfs/TestViewFileSystemLinkFallback.java", "diffHunk": "@@ -765,4 +766,154 @@ public void testMkdirsShouldReturnFalseWhenFallbackFSNotAvailable()\n       assertTrue(fsTarget.exists(test));\n     }\n   }\n+\n+  /**\n+   * Tests that the create file should be successful when the parent directory\n+   * is same as the existent fallback directory. The new file should be created\n+   * in fallback.\n+   */\n+  @Test\n+  public void testCreateFileOnInternalMountDirWithSameDirTreeExistInFallback()\n+      throws Exception {\n+    Configuration conf = new Configuration();\n+    ConfigUtil.addLink(conf, \"/user1/hive/warehouse/partition-0\",\n+        new Path(targetTestRoot.toString()).toUri());\n+    Path dir1 = new Path(targetTestRoot,\n+        \"fallbackDir/user1/hive/warehouse/partition-0\");\n+    fsTarget.mkdirs(dir1);\n+    Path fallbackTarget = new Path(targetTestRoot, \"fallbackDir\");\n+    ConfigUtil.addLinkFallback(conf, fallbackTarget.toUri());\n+\n+    try (FileSystem vfs = FileSystem.get(viewFsDefaultClusterUri, conf)) {\n+      Path p = new Path(\"/user1/hive/warehouse/test.file\");\n+      Path test = Path.mergePaths(fallbackTarget, p);\n+      assertFalse(fsTarget.exists(test));\n+      assertTrue(fsTarget.exists(test.getParent()));\n+      vfs.createNewFile(p);\n+      assertTrue(fsTarget.exists(test));\n+    }\n+  }\n+\n+  /**\n+   * Tests the making of a new directory which is not matching to any of\n+   * internal directory.\n+   */\n+  @Test\n+  public void testCreateNewFileWithOutMatchingToMountDirOrFallbackDirPath()\n+      throws Exception {\n+    Configuration conf = new Configuration();\n+    ConfigUtil.addLink(conf, \"/user1/hive/warehouse/partition-0\",\n+        new Path(targetTestRoot.toString()).toUri());\n+    Path fallbackTarget = new Path(targetTestRoot, \"fallbackDir\");\n+    fsTarget.mkdirs(fallbackTarget);\n+    ConfigUtil.addLinkFallback(conf, fallbackTarget.toUri());\n+    try (FileSystem vfs = FileSystem.get(viewFsDefaultClusterUri, conf)) {\n+      Path p = new Path(\"/user2/test.file\");\n+      Path test = Path.mergePaths(fallbackTarget, p);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODAzNjM4Nw=="}, "originalCommit": {"oid": "58598aefa34ee0b0029e425660c89e25fc0b4f4c"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MjUzNDQxOnYy", "diffSide": "RIGHT", "path": "hadoop-hdfs-project/hadoop-hdfs/src/test/java/org/apache/hadoop/fs/viewfs/TestViewFileSystemLinkFallback.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwMDowMzoyM1rOGrSc1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMVQwMDoyNzowMlrOGrS1sQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA0NDI0NA==", "bodyText": "Maybe easier to read if written as\n`\nPath fallbackTarget = new Path(targetTestRoot, \"fallbackDir\");\nPath dir1 = new Path(fallbackTarget,\n    \"user1/hive/warehouse/partition-0\");\nfsTarget.mkdirs(dir1);\n\n`", "url": "https://github.com/apache/hadoop/pull/2107#discussion_r448044244", "createdAt": "2020-07-01T00:03:23Z", "author": {"login": "jojochuang"}, "path": "hadoop-hdfs-project/hadoop-hdfs/src/test/java/org/apache/hadoop/fs/viewfs/TestViewFileSystemLinkFallback.java", "diffHunk": "@@ -765,4 +766,154 @@ public void testMkdirsShouldReturnFalseWhenFallbackFSNotAvailable()\n       assertTrue(fsTarget.exists(test));\n     }\n   }\n+\n+  /**\n+   * Tests that the create file should be successful when the parent directory\n+   * is same as the existent fallback directory. The new file should be created\n+   * in fallback.\n+   */\n+  @Test\n+  public void testCreateFileOnInternalMountDirWithSameDirTreeExistInFallback()\n+      throws Exception {\n+    Configuration conf = new Configuration();\n+    ConfigUtil.addLink(conf, \"/user1/hive/warehouse/partition-0\",\n+        new Path(targetTestRoot.toString()).toUri());\n+    Path dir1 = new Path(targetTestRoot,\n+        \"fallbackDir/user1/hive/warehouse/partition-0\");\n+    fsTarget.mkdirs(dir1);\n+    Path fallbackTarget = new Path(targetTestRoot, \"fallbackDir\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b467a0a109647b9901924913d8f9bfef2b16fa6"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA1MDYwOQ==", "bodyText": "Done. Thanks", "url": "https://github.com/apache/hadoop/pull/2107#discussion_r448050609", "createdAt": "2020-07-01T00:27:02Z", "author": {"login": "umamaheswararao"}, "path": "hadoop-hdfs-project/hadoop-hdfs/src/test/java/org/apache/hadoop/fs/viewfs/TestViewFileSystemLinkFallback.java", "diffHunk": "@@ -765,4 +766,154 @@ public void testMkdirsShouldReturnFalseWhenFallbackFSNotAvailable()\n       assertTrue(fsTarget.exists(test));\n     }\n   }\n+\n+  /**\n+   * Tests that the create file should be successful when the parent directory\n+   * is same as the existent fallback directory. The new file should be created\n+   * in fallback.\n+   */\n+  @Test\n+  public void testCreateFileOnInternalMountDirWithSameDirTreeExistInFallback()\n+      throws Exception {\n+    Configuration conf = new Configuration();\n+    ConfigUtil.addLink(conf, \"/user1/hive/warehouse/partition-0\",\n+        new Path(targetTestRoot.toString()).toUri());\n+    Path dir1 = new Path(targetTestRoot,\n+        \"fallbackDir/user1/hive/warehouse/partition-0\");\n+    fsTarget.mkdirs(dir1);\n+    Path fallbackTarget = new Path(targetTestRoot, \"fallbackDir\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA0NDI0NA=="}, "originalCommit": {"oid": "0b467a0a109647b9901924913d8f9bfef2b16fa6"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwMzQ3MTExOnYy", "diffSide": "RIGHT", "path": "hadoop-hdfs-project/hadoop-hdfs/src/test/java/org/apache/hadoop/fs/viewfs/TestViewFileSystemLinkFallback.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNFQwNjoyNDoyNlrOGs6QGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNFQwNzowNDoxOFrOGs6ZjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTc0NDkyMA==", "bodyText": "typo \"expetion\"", "url": "https://github.com/apache/hadoop/pull/2107#discussion_r449744920", "createdAt": "2020-07-04T06:24:26Z", "author": {"login": "ayushtkn"}, "path": "hadoop-hdfs-project/hadoop-hdfs/src/test/java/org/apache/hadoop/fs/viewfs/TestViewFileSystemLinkFallback.java", "diffHunk": "@@ -765,4 +766,151 @@ public void testMkdirsShouldReturnFalseWhenFallbackFSNotAvailable()\n       assertTrue(fsTarget.exists(test));\n     }\n   }\n+\n+  /**\n+   * Tests that the create file should be successful when the parent directory\n+   * is same as the existent fallback directory. The new file should be created\n+   * in fallback.\n+   */\n+  @Test\n+  public void testCreateFileOnInternalMountDirWithSameDirTreeExistInFallback()\n+      throws Exception {\n+    Configuration conf = new Configuration();\n+    ConfigUtil.addLink(conf, \"/user1/hive/warehouse/partition-0\",\n+        new Path(targetTestRoot.toString()).toUri());\n+    Path fallbackTarget = new Path(targetTestRoot, \"fallbackDir\");\n+    Path dir1 = new Path(fallbackTarget, \"user1/hive/warehouse/partition-0\");\n+    fsTarget.mkdirs(dir1);\n+    ConfigUtil.addLinkFallback(conf, fallbackTarget.toUri());\n+\n+    try (FileSystem vfs = FileSystem.get(viewFsDefaultClusterUri, conf)) {\n+      Path vfsTestFile = new Path(\"/user1/hive/warehouse/test.file\");\n+      Path testFileInFallback = Path.mergePaths(fallbackTarget, vfsTestFile);\n+      assertFalse(fsTarget.exists(testFileInFallback));\n+      assertTrue(fsTarget.exists(testFileInFallback.getParent()));\n+      vfs.create(vfsTestFile).close();\n+      assertTrue(fsTarget.exists(testFileInFallback));\n+    }\n+  }\n+\n+  /**\n+   * Tests the making of a new directory which is not matching to any of\n+   * internal directory.\n+   */\n+  @Test\n+  public void testCreateNewFileWithOutMatchingToMountDirOrFallbackDirPath()\n+      throws Exception {\n+    Configuration conf = new Configuration();\n+    ConfigUtil.addLink(conf, \"/user1/hive/warehouse/partition-0\",\n+        new Path(targetTestRoot.toString()).toUri());\n+    Path fallbackTarget = new Path(targetTestRoot, \"fallbackDir\");\n+    fsTarget.mkdirs(fallbackTarget);\n+    ConfigUtil.addLinkFallback(conf, fallbackTarget.toUri());\n+    try (FileSystem vfs = FileSystem.get(viewFsDefaultClusterUri, conf)) {\n+      Path vfsTestFile = new Path(\"/user2/test.file\");\n+      Path testFileInFallback = Path.mergePaths(fallbackTarget, vfsTestFile);\n+      assertFalse(fsTarget.exists(testFileInFallback));\n+      // user2 does not exist in fallback\n+      assertFalse(fsTarget.exists(testFileInFallback.getParent()));\n+      vfs.create(vfsTestFile).close();\n+      // /user2/test.file should be created in fallback\n+      assertTrue(fsTarget.exists(testFileInFallback));\n+    }\n+  }\n+\n+  /**\n+   * Tests the making of a new file on root which is not matching to any of\n+   * fallback files on root.\n+   */\n+  @Test\n+  public void testCreateFileOnRootWithFallbackEnabled() throws Exception {\n+    Configuration conf = new Configuration();\n+    Path fallbackTarget = new Path(targetTestRoot, \"fallbackDir\");\n+    fsTarget.mkdirs(fallbackTarget);\n+\n+    ConfigUtil.addLink(conf, \"/user1/hive/\",\n+        new Path(targetTestRoot.toString()).toUri());\n+    ConfigUtil.addLinkFallback(conf, fallbackTarget.toUri());\n+\n+    try (FileSystem vfs = FileSystem.get(viewFsDefaultClusterUri, conf)) {\n+      Path vfsTestFile = new Path(\"/test.file\");\n+      Path testFileInFallback = Path.mergePaths(fallbackTarget, vfsTestFile);\n+      assertFalse(fsTarget.exists(testFileInFallback));\n+      vfs.create(vfsTestFile).close();\n+      // /test.file should be created in fallback\n+      assertTrue(fsTarget.exists(testFileInFallback));\n+    }\n+  }\n+\n+  /**\n+   * Tests the create of a file on root where the path is matching to an\n+   * existing file on fallback's file on root.\n+   */\n+  @Test (expected = FileAlreadyExistsException.class)\n+  public void testCreateFileOnRootWithFallbackWithFileAlreadyExist()\n+      throws Exception {\n+    Configuration conf = new Configuration();\n+    Path fallbackTarget = new Path(targetTestRoot, \"fallbackDir\");\n+    Path testFile = new Path(fallbackTarget, \"test.file\");\n+    // pre-creating test file in fallback.\n+    fsTarget.create(testFile).close();\n+\n+    ConfigUtil.addLink(conf, \"/user1/hive/\",\n+        new Path(targetTestRoot.toString()).toUri());\n+    ConfigUtil.addLinkFallback(conf, fallbackTarget.toUri());\n+\n+    try (FileSystem vfs = FileSystem.get(viewFsDefaultClusterUri, conf)) {\n+      Path vfsTestFile = new Path(\"/test.file\");\n+      assertTrue(fsTarget.exists(testFile));\n+      vfs.create(vfsTestFile, false).close();\n+    }\n+  }\n+\n+  /**\n+   * Tests the creating of a file where the path is same as mount link path.\n+   */\n+  @Test(expected= FileAlreadyExistsException.class)\n+  public void testCreateFileWhereThePathIsSameAsItsMountLinkPath()\n+      throws Exception {\n+    Configuration conf = new Configuration();\n+    Path fallbackTarget = new Path(targetTestRoot, \"fallbackDir\");\n+    fsTarget.mkdirs(fallbackTarget);\n+\n+    ConfigUtil.addLink(conf, \"/user1/hive/\",\n+        new Path(targetTestRoot.toString()).toUri());\n+    ConfigUtil.addLinkFallback(conf, fallbackTarget.toUri());\n+\n+    try (FileSystem vfs = FileSystem.get(viewFsDefaultClusterUri, conf)) {\n+      Path vfsTestDir = new Path(\"/user1/hive\");\n+      assertFalse(fsTarget.exists(Path.mergePaths(fallbackTarget, vfsTestDir)));\n+      vfs.create(vfsTestDir).close();\n+    }\n+  }\n+\n+  /**\n+   * Tests the create of a file where the path is same as one of of the internal\n+   * dir path should fail.\n+   */\n+  @Test\n+  public void testCreateFileSameAsInternalDirPath() throws Exception {\n+    Configuration conf = new Configuration();\n+    Path fallbackTarget = new Path(targetTestRoot, \"fallbackDir\");\n+    fsTarget.mkdirs(fallbackTarget);\n+    ConfigUtil.addLink(conf, \"/user1/hive/\",\n+        new Path(targetTestRoot.toString()).toUri());\n+    ConfigUtil.addLinkFallback(conf, fallbackTarget.toUri());\n+\n+    try (FileSystem vfs = FileSystem.get(viewFsDefaultClusterUri, conf)) {\n+      Path vfsTestDir = new Path(\"/user1\");\n+      assertFalse(fsTarget.exists(Path.mergePaths(fallbackTarget, vfsTestDir)));\n+      try {\n+        vfs.create(vfsTestDir);\n+        Assert.fail(\"Should fail to create file as this is an internal dir.\");\n+      } catch (NotInMountpointException e){\n+        // This tree is part of internal tree. The above expetion will be thrown", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3225add901ca57103cceb7ab752ad4c9c292790f"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTc0NzM0MQ==", "bodyText": "Thanks. Done.", "url": "https://github.com/apache/hadoop/pull/2107#discussion_r449747341", "createdAt": "2020-07-04T07:04:18Z", "author": {"login": "umamaheswararao"}, "path": "hadoop-hdfs-project/hadoop-hdfs/src/test/java/org/apache/hadoop/fs/viewfs/TestViewFileSystemLinkFallback.java", "diffHunk": "@@ -765,4 +766,151 @@ public void testMkdirsShouldReturnFalseWhenFallbackFSNotAvailable()\n       assertTrue(fsTarget.exists(test));\n     }\n   }\n+\n+  /**\n+   * Tests that the create file should be successful when the parent directory\n+   * is same as the existent fallback directory. The new file should be created\n+   * in fallback.\n+   */\n+  @Test\n+  public void testCreateFileOnInternalMountDirWithSameDirTreeExistInFallback()\n+      throws Exception {\n+    Configuration conf = new Configuration();\n+    ConfigUtil.addLink(conf, \"/user1/hive/warehouse/partition-0\",\n+        new Path(targetTestRoot.toString()).toUri());\n+    Path fallbackTarget = new Path(targetTestRoot, \"fallbackDir\");\n+    Path dir1 = new Path(fallbackTarget, \"user1/hive/warehouse/partition-0\");\n+    fsTarget.mkdirs(dir1);\n+    ConfigUtil.addLinkFallback(conf, fallbackTarget.toUri());\n+\n+    try (FileSystem vfs = FileSystem.get(viewFsDefaultClusterUri, conf)) {\n+      Path vfsTestFile = new Path(\"/user1/hive/warehouse/test.file\");\n+      Path testFileInFallback = Path.mergePaths(fallbackTarget, vfsTestFile);\n+      assertFalse(fsTarget.exists(testFileInFallback));\n+      assertTrue(fsTarget.exists(testFileInFallback.getParent()));\n+      vfs.create(vfsTestFile).close();\n+      assertTrue(fsTarget.exists(testFileInFallback));\n+    }\n+  }\n+\n+  /**\n+   * Tests the making of a new directory which is not matching to any of\n+   * internal directory.\n+   */\n+  @Test\n+  public void testCreateNewFileWithOutMatchingToMountDirOrFallbackDirPath()\n+      throws Exception {\n+    Configuration conf = new Configuration();\n+    ConfigUtil.addLink(conf, \"/user1/hive/warehouse/partition-0\",\n+        new Path(targetTestRoot.toString()).toUri());\n+    Path fallbackTarget = new Path(targetTestRoot, \"fallbackDir\");\n+    fsTarget.mkdirs(fallbackTarget);\n+    ConfigUtil.addLinkFallback(conf, fallbackTarget.toUri());\n+    try (FileSystem vfs = FileSystem.get(viewFsDefaultClusterUri, conf)) {\n+      Path vfsTestFile = new Path(\"/user2/test.file\");\n+      Path testFileInFallback = Path.mergePaths(fallbackTarget, vfsTestFile);\n+      assertFalse(fsTarget.exists(testFileInFallback));\n+      // user2 does not exist in fallback\n+      assertFalse(fsTarget.exists(testFileInFallback.getParent()));\n+      vfs.create(vfsTestFile).close();\n+      // /user2/test.file should be created in fallback\n+      assertTrue(fsTarget.exists(testFileInFallback));\n+    }\n+  }\n+\n+  /**\n+   * Tests the making of a new file on root which is not matching to any of\n+   * fallback files on root.\n+   */\n+  @Test\n+  public void testCreateFileOnRootWithFallbackEnabled() throws Exception {\n+    Configuration conf = new Configuration();\n+    Path fallbackTarget = new Path(targetTestRoot, \"fallbackDir\");\n+    fsTarget.mkdirs(fallbackTarget);\n+\n+    ConfigUtil.addLink(conf, \"/user1/hive/\",\n+        new Path(targetTestRoot.toString()).toUri());\n+    ConfigUtil.addLinkFallback(conf, fallbackTarget.toUri());\n+\n+    try (FileSystem vfs = FileSystem.get(viewFsDefaultClusterUri, conf)) {\n+      Path vfsTestFile = new Path(\"/test.file\");\n+      Path testFileInFallback = Path.mergePaths(fallbackTarget, vfsTestFile);\n+      assertFalse(fsTarget.exists(testFileInFallback));\n+      vfs.create(vfsTestFile).close();\n+      // /test.file should be created in fallback\n+      assertTrue(fsTarget.exists(testFileInFallback));\n+    }\n+  }\n+\n+  /**\n+   * Tests the create of a file on root where the path is matching to an\n+   * existing file on fallback's file on root.\n+   */\n+  @Test (expected = FileAlreadyExistsException.class)\n+  public void testCreateFileOnRootWithFallbackWithFileAlreadyExist()\n+      throws Exception {\n+    Configuration conf = new Configuration();\n+    Path fallbackTarget = new Path(targetTestRoot, \"fallbackDir\");\n+    Path testFile = new Path(fallbackTarget, \"test.file\");\n+    // pre-creating test file in fallback.\n+    fsTarget.create(testFile).close();\n+\n+    ConfigUtil.addLink(conf, \"/user1/hive/\",\n+        new Path(targetTestRoot.toString()).toUri());\n+    ConfigUtil.addLinkFallback(conf, fallbackTarget.toUri());\n+\n+    try (FileSystem vfs = FileSystem.get(viewFsDefaultClusterUri, conf)) {\n+      Path vfsTestFile = new Path(\"/test.file\");\n+      assertTrue(fsTarget.exists(testFile));\n+      vfs.create(vfsTestFile, false).close();\n+    }\n+  }\n+\n+  /**\n+   * Tests the creating of a file where the path is same as mount link path.\n+   */\n+  @Test(expected= FileAlreadyExistsException.class)\n+  public void testCreateFileWhereThePathIsSameAsItsMountLinkPath()\n+      throws Exception {\n+    Configuration conf = new Configuration();\n+    Path fallbackTarget = new Path(targetTestRoot, \"fallbackDir\");\n+    fsTarget.mkdirs(fallbackTarget);\n+\n+    ConfigUtil.addLink(conf, \"/user1/hive/\",\n+        new Path(targetTestRoot.toString()).toUri());\n+    ConfigUtil.addLinkFallback(conf, fallbackTarget.toUri());\n+\n+    try (FileSystem vfs = FileSystem.get(viewFsDefaultClusterUri, conf)) {\n+      Path vfsTestDir = new Path(\"/user1/hive\");\n+      assertFalse(fsTarget.exists(Path.mergePaths(fallbackTarget, vfsTestDir)));\n+      vfs.create(vfsTestDir).close();\n+    }\n+  }\n+\n+  /**\n+   * Tests the create of a file where the path is same as one of of the internal\n+   * dir path should fail.\n+   */\n+  @Test\n+  public void testCreateFileSameAsInternalDirPath() throws Exception {\n+    Configuration conf = new Configuration();\n+    Path fallbackTarget = new Path(targetTestRoot, \"fallbackDir\");\n+    fsTarget.mkdirs(fallbackTarget);\n+    ConfigUtil.addLink(conf, \"/user1/hive/\",\n+        new Path(targetTestRoot.toString()).toUri());\n+    ConfigUtil.addLinkFallback(conf, fallbackTarget.toUri());\n+\n+    try (FileSystem vfs = FileSystem.get(viewFsDefaultClusterUri, conf)) {\n+      Path vfsTestDir = new Path(\"/user1\");\n+      assertFalse(fsTarget.exists(Path.mergePaths(fallbackTarget, vfsTestDir)));\n+      try {\n+        vfs.create(vfsTestDir);\n+        Assert.fail(\"Should fail to create file as this is an internal dir.\");\n+      } catch (NotInMountpointException e){\n+        // This tree is part of internal tree. The above expetion will be thrown", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTc0NDkyMA=="}, "originalCommit": {"oid": "3225add901ca57103cceb7ab752ad4c9c292790f"}, "originalPosition": 153}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwMzQ3Mzk5OnYy", "diffSide": "RIGHT", "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/viewfs/ViewFs.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNFQwNjoyOTo0OFrOGs6RWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNFQwNzowOTo0NFrOGs6a_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTc0NTI0Mg==", "bodyText": "What do you mean by : This should not happen. Ideally client call shouldn't land here or This If check will never get hit(It does get hit, I verified),", "url": "https://github.com/apache/hadoop/pull/2107#discussion_r449745242", "createdAt": "2020-07-04T06:29:48Z", "author": {"login": "ayushtkn"}, "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/viewfs/ViewFs.java", "diffHunk": "@@ -919,6 +921,42 @@ public FSDataOutputStream createInternal(final Path f,\n         FileAlreadyExistsException, FileNotFoundException,\n         ParentNotDirectoryException, UnsupportedFileSystemException,\n         UnresolvedLinkException, IOException {\n+      Preconditions.checkNotNull(f, \"File cannot be null.\");\n+      // Just a sanity check. This should not happen.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3225add901ca57103cceb7ab752ad4c9c292790f"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTc0NzcxMA==", "bodyText": "My comments seems to be too light. \"//\" will trigger this. But ideally that should not happen as users would not create files with /. However if somebody attempts we are ready to shoot. I have removed that comment, as it may be confusing.\nHowever, this will trigger mostly in ViewFs.java, but may not be in ViewFileSystem.java. In ViewFileSystem.java, getDefaultReplication API itself might shade this condition if parent is internal currently. Anyway the current condition should be good enough to handle if some one try with files as \"//\" etc\nThanks for checking.", "url": "https://github.com/apache/hadoop/pull/2107#discussion_r449747710", "createdAt": "2020-07-04T07:09:44Z", "author": {"login": "umamaheswararao"}, "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/viewfs/ViewFs.java", "diffHunk": "@@ -919,6 +921,42 @@ public FSDataOutputStream createInternal(final Path f,\n         FileAlreadyExistsException, FileNotFoundException,\n         ParentNotDirectoryException, UnsupportedFileSystemException,\n         UnresolvedLinkException, IOException {\n+      Preconditions.checkNotNull(f, \"File cannot be null.\");\n+      // Just a sanity check. This should not happen.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTc0NTI0Mg=="}, "originalCommit": {"oid": "3225add901ca57103cceb7ab752ad4c9c292790f"}, "originalPosition": 14}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3474, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}