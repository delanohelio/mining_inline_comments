{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYxOTYyNDYz", "number": 1803, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxMDo1ODo1MFrODXe7pQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxMTowNDo0OVrODXfBsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI1OTUwNjI5OnYy", "diffSide": "RIGHT", "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufHelper.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxMDo1ODo1MFrOFczS7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxMToyNzo1MlrOFcz9Gg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc0NDg3Ng==", "bodyText": "final?", "url": "https://github.com/apache/hadoop/pull/1803#discussion_r365744876", "createdAt": "2020-01-13T10:58:50Z", "author": {"login": "steveloughran"}, "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufHelper.java", "diffHunk": "@@ -46,4 +52,67 @@ public static IOException getRemoteException(ServiceException se) {\n     }\n     return e instanceof IOException ? (IOException) e : new IOException(se);\n   }\n+\n+\n+  /**\n+   * Map used to cache fixed strings to ByteStrings. Since there is no\n+   * automatic expiration policy, only use this for strings from a fixed, small\n+   * set.\n+   * <p/>\n+   * This map should not be accessed directly. Used the getFixedByteString\n+   * methods instead.\n+   */\n+  private static ConcurrentHashMap<Object, ByteString> fixedByteStringCache =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5db4277b8c12e8664405cba47d5b8abcadd3e60"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc1NTY3NA==", "bodyText": "yes. Will make it final.", "url": "https://github.com/apache/hadoop/pull/1803#discussion_r365755674", "createdAt": "2020-01-13T11:27:52Z", "author": {"login": "vinayakumarb"}, "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufHelper.java", "diffHunk": "@@ -46,4 +52,67 @@ public static IOException getRemoteException(ServiceException se) {\n     }\n     return e instanceof IOException ? (IOException) e : new IOException(se);\n   }\n+\n+\n+  /**\n+   * Map used to cache fixed strings to ByteStrings. Since there is no\n+   * automatic expiration policy, only use this for strings from a fixed, small\n+   * set.\n+   * <p/>\n+   * This map should not be accessed directly. Used the getFixedByteString\n+   * methods instead.\n+   */\n+  private static ConcurrentHashMap<Object, ByteString> fixedByteStringCache =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc0NDg3Ng=="}, "originalCommit": {"oid": "e5db4277b8c12e8664405cba47d5b8abcadd3e60"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI1OTUxNTMwOnYy", "diffSide": "RIGHT", "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufHelper.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxMTowMjoyMFrOFczYVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxMjo1NjowNFrOFc195Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc0NjI2MQ==", "bodyText": "I think I'd prefer some explicit description \"tokenFromProto\", but not that fussy about overloading if you prefer that", "url": "https://github.com/apache/hadoop/pull/1803#discussion_r365746261", "createdAt": "2020-01-13T11:02:20Z", "author": {"login": "steveloughran"}, "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufHelper.java", "diffHunk": "@@ -46,4 +52,67 @@ public static IOException getRemoteException(ServiceException se) {\n     }\n     return e instanceof IOException ? (IOException) e : new IOException(se);\n   }\n+\n+\n+  /**\n+   * Map used to cache fixed strings to ByteStrings. Since there is no\n+   * automatic expiration policy, only use this for strings from a fixed, small\n+   * set.\n+   * <p/>\n+   * This map should not be accessed directly. Used the getFixedByteString\n+   * methods instead.\n+   */\n+  private static ConcurrentHashMap<Object, ByteString> fixedByteStringCache =\n+      new ConcurrentHashMap<>();\n+\n+  /**\n+   * Get the ByteString for frequently used fixed and small set strings.\n+   * @param key string\n+   * @return\n+   */\n+  public static ByteString getFixedByteString(Text key) {\n+    ByteString value = fixedByteStringCache.get(key);\n+    if (value == null) {\n+      value = ByteString.copyFromUtf8(key.toString());\n+      fixedByteStringCache.put(new Text(key.copyBytes()), value);\n+    }\n+    return value;\n+  }\n+\n+  /**\n+   * Get the ByteString for frequently used fixed and small set strings.\n+   * @param key string\n+   * @return\n+   */\n+  public static ByteString getFixedByteString(String key) {\n+    ByteString value = fixedByteStringCache.get(key);\n+    if (value == null) {\n+      value = ByteString.copyFromUtf8(key);\n+      fixedByteStringCache.put(key, value);\n+    }\n+    return value;\n+  }\n+\n+  public static ByteString getByteString(byte[] bytes) {\n+    // return singleton to reduce object allocation\n+    return (bytes.length == 0) ? ByteString.EMPTY : ByteString.copyFrom(bytes);\n+  }\n+\n+  public static Token<? extends TokenIdentifier> convert(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5db4277b8c12e8664405cba47d5b8abcadd3e60"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc1NTg5OQ==", "bodyText": "Okay, Will change method name.", "url": "https://github.com/apache/hadoop/pull/1803#discussion_r365755899", "createdAt": "2020-01-13T11:28:28Z", "author": {"login": "vinayakumarb"}, "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufHelper.java", "diffHunk": "@@ -46,4 +52,67 @@ public static IOException getRemoteException(ServiceException se) {\n     }\n     return e instanceof IOException ? (IOException) e : new IOException(se);\n   }\n+\n+\n+  /**\n+   * Map used to cache fixed strings to ByteStrings. Since there is no\n+   * automatic expiration policy, only use this for strings from a fixed, small\n+   * set.\n+   * <p/>\n+   * This map should not be accessed directly. Used the getFixedByteString\n+   * methods instead.\n+   */\n+  private static ConcurrentHashMap<Object, ByteString> fixedByteStringCache =\n+      new ConcurrentHashMap<>();\n+\n+  /**\n+   * Get the ByteString for frequently used fixed and small set strings.\n+   * @param key string\n+   * @return\n+   */\n+  public static ByteString getFixedByteString(Text key) {\n+    ByteString value = fixedByteStringCache.get(key);\n+    if (value == null) {\n+      value = ByteString.copyFromUtf8(key.toString());\n+      fixedByteStringCache.put(new Text(key.copyBytes()), value);\n+    }\n+    return value;\n+  }\n+\n+  /**\n+   * Get the ByteString for frequently used fixed and small set strings.\n+   * @param key string\n+   * @return\n+   */\n+  public static ByteString getFixedByteString(String key) {\n+    ByteString value = fixedByteStringCache.get(key);\n+    if (value == null) {\n+      value = ByteString.copyFromUtf8(key);\n+      fixedByteStringCache.put(key, value);\n+    }\n+    return value;\n+  }\n+\n+  public static ByteString getByteString(byte[] bytes) {\n+    // return singleton to reduce object allocation\n+    return (bytes.length == 0) ? ByteString.EMPTY : ByteString.copyFrom(bytes);\n+  }\n+\n+  public static Token<? extends TokenIdentifier> convert(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc0NjI2MQ=="}, "originalCommit": {"oid": "e5db4277b8c12e8664405cba47d5b8abcadd3e60"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc4ODY0NQ==", "bodyText": "Updated PR. please check.", "url": "https://github.com/apache/hadoop/pull/1803#discussion_r365788645", "createdAt": "2020-01-13T12:56:04Z", "author": {"login": "vinayakumarb"}, "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufHelper.java", "diffHunk": "@@ -46,4 +52,67 @@ public static IOException getRemoteException(ServiceException se) {\n     }\n     return e instanceof IOException ? (IOException) e : new IOException(se);\n   }\n+\n+\n+  /**\n+   * Map used to cache fixed strings to ByteStrings. Since there is no\n+   * automatic expiration policy, only use this for strings from a fixed, small\n+   * set.\n+   * <p/>\n+   * This map should not be accessed directly. Used the getFixedByteString\n+   * methods instead.\n+   */\n+  private static ConcurrentHashMap<Object, ByteString> fixedByteStringCache =\n+      new ConcurrentHashMap<>();\n+\n+  /**\n+   * Get the ByteString for frequently used fixed and small set strings.\n+   * @param key string\n+   * @return\n+   */\n+  public static ByteString getFixedByteString(Text key) {\n+    ByteString value = fixedByteStringCache.get(key);\n+    if (value == null) {\n+      value = ByteString.copyFromUtf8(key.toString());\n+      fixedByteStringCache.put(new Text(key.copyBytes()), value);\n+    }\n+    return value;\n+  }\n+\n+  /**\n+   * Get the ByteString for frequently used fixed and small set strings.\n+   * @param key string\n+   * @return\n+   */\n+  public static ByteString getFixedByteString(String key) {\n+    ByteString value = fixedByteStringCache.get(key);\n+    if (value == null) {\n+      value = ByteString.copyFromUtf8(key);\n+      fixedByteStringCache.put(key, value);\n+    }\n+    return value;\n+  }\n+\n+  public static ByteString getByteString(byte[] bytes) {\n+    // return singleton to reduce object allocation\n+    return (bytes.length == 0) ? ByteString.EMPTY : ByteString.copyFrom(bytes);\n+  }\n+\n+  public static Token<? extends TokenIdentifier> convert(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc0NjI2MQ=="}, "originalCommit": {"oid": "e5db4277b8c12e8664405cba47d5b8abcadd3e60"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI1OTUyMTc5OnYy", "diffSide": "RIGHT", "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufHelper.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxMTowNDo0OVrOFczcPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xM1QxMTozNDoyMlrOFc0GkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc0NzI2MA==", "bodyText": "Is there any risk this will grow to a size it becomes a problem? If not, using a guava cache is overkill, if there is a risk then yes, we would need to", "url": "https://github.com/apache/hadoop/pull/1803#discussion_r365747260", "createdAt": "2020-01-13T11:04:49Z", "author": {"login": "steveloughran"}, "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufHelper.java", "diffHunk": "@@ -46,4 +52,67 @@ public static IOException getRemoteException(ServiceException se) {\n     }\n     return e instanceof IOException ? (IOException) e : new IOException(se);\n   }\n+\n+\n+  /**\n+   * Map used to cache fixed strings to ByteStrings. Since there is no\n+   * automatic expiration policy, only use this for strings from a fixed, small\n+   * set.\n+   * <p/>\n+   * This map should not be accessed directly. Used the getFixedByteString\n+   * methods instead.\n+   */\n+  private static ConcurrentHashMap<Object, ByteString> fixedByteStringCache =\n+      new ConcurrentHashMap<>();\n+\n+  /**\n+   * Get the ByteString for frequently used fixed and small set strings.\n+   * @param key string\n+   * @return\n+   */\n+  public static ByteString getFixedByteString(Text key) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5db4277b8c12e8664405cba47d5b8abcadd3e60"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc1ODA5Ng==", "bodyText": "This is for frequently converting the fixed strings, such as 'token kind' and 'token service' in client side. These numbers will be fixed. ex: HDFS_DELEGATION_TOKEN, HDFS_BLOCK_TOKEN, etc.\nFor the other bytestrings (such as datanode network location) guava cache is used in PBHelperClient with expiry.\nSo it should be fine.", "url": "https://github.com/apache/hadoop/pull/1803#discussion_r365758096", "createdAt": "2020-01-13T11:34:22Z", "author": {"login": "vinayakumarb"}, "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/ipc/ProtobufHelper.java", "diffHunk": "@@ -46,4 +52,67 @@ public static IOException getRemoteException(ServiceException se) {\n     }\n     return e instanceof IOException ? (IOException) e : new IOException(se);\n   }\n+\n+\n+  /**\n+   * Map used to cache fixed strings to ByteStrings. Since there is no\n+   * automatic expiration policy, only use this for strings from a fixed, small\n+   * set.\n+   * <p/>\n+   * This map should not be accessed directly. Used the getFixedByteString\n+   * methods instead.\n+   */\n+  private static ConcurrentHashMap<Object, ByteString> fixedByteStringCache =\n+      new ConcurrentHashMap<>();\n+\n+  /**\n+   * Get the ByteString for frequently used fixed and small set strings.\n+   * @param key string\n+   * @return\n+   */\n+  public static ByteString getFixedByteString(Text key) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTc0NzI2MA=="}, "originalCommit": {"oid": "e5db4277b8c12e8664405cba47d5b8abcadd3e60"}, "originalPosition": 38}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3684, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}