{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg0NTc2Mjgx", "number": 2298, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQwNDo1ODozOFrOEivtIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQwNDo1ODozOFrOEivtIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0ODY4NjQwOnYy", "diffSide": "RIGHT", "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/viewfs/ViewFileSystem.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQwNDo1ODozOFrOHQynSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQwNjoyNjo1OVrOHQzDRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM2ODUyMA==", "bodyText": "(InodeTree.SlashPath.equals(fs.getPath()))\nIn which case this would be true? Provided there is a check in the if condition", "url": "https://github.com/apache/hadoop/pull/2298#discussion_r487368520", "createdAt": "2020-09-12T04:58:38Z", "author": {"login": "ayushtkn"}, "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/viewfs/ViewFileSystem.java", "diffHunk": "@@ -1263,6 +1263,26 @@ public boolean delete(final Path f)\n     public BlockLocation[] getFileBlockLocations(final FileStatus fs,\n         final long start, final long len) throws\n         FileNotFoundException, IOException {\n+\n+      // When application calls listFiles on internalDir, it would return\n+      // RemoteIterator from InternalDirOfViewFs. If there is a fallBack, there\n+      // is a chance of files exists under that internalDir in fallback.\n+      // Iterator#next will call getFileBlockLocations with that files. So, we\n+      // should return getFileBlockLocations on fallback. See HDFS-15532.\n+      if (fs.getPath() != InodeTree.SlashPath && this.fsState\n+          .getRootFallbackLink() != null) {\n+        FileSystem linkedFallbackFs =\n+            this.fsState.getRootFallbackLink().getTargetFileSystem();\n+        Path parent = Path.getPathWithoutSchemeAndAuthority(\n+            new Path(theInternalDir.fullPath));\n+        String leafChild = (InodeTree.SlashPath.equals(fs.getPath())) ?\n+            InodeTree.SlashPath.toString() :\n+            fs.getPath().getName();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cdd0932e33244d928c5e5682addc5146c064d6e7"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM3NTY4Ng==", "bodyText": "Thanks @ayushtkn for review! I have removed this redundant condition.\nI realized that, this bug exist in ViewFs as well. I fixed and added a test case for it. Thanks", "url": "https://github.com/apache/hadoop/pull/2298#discussion_r487375686", "createdAt": "2020-09-12T06:26:59Z", "author": {"login": "umamaheswararao"}, "path": "hadoop-common-project/hadoop-common/src/main/java/org/apache/hadoop/fs/viewfs/ViewFileSystem.java", "diffHunk": "@@ -1263,6 +1263,26 @@ public boolean delete(final Path f)\n     public BlockLocation[] getFileBlockLocations(final FileStatus fs,\n         final long start, final long len) throws\n         FileNotFoundException, IOException {\n+\n+      // When application calls listFiles on internalDir, it would return\n+      // RemoteIterator from InternalDirOfViewFs. If there is a fallBack, there\n+      // is a chance of files exists under that internalDir in fallback.\n+      // Iterator#next will call getFileBlockLocations with that files. So, we\n+      // should return getFileBlockLocations on fallback. See HDFS-15532.\n+      if (fs.getPath() != InodeTree.SlashPath && this.fsState\n+          .getRootFallbackLink() != null) {\n+        FileSystem linkedFallbackFs =\n+            this.fsState.getRootFallbackLink().getTargetFileSystem();\n+        Path parent = Path.getPathWithoutSchemeAndAuthority(\n+            new Path(theInternalDir.fullPath));\n+        String leafChild = (InodeTree.SlashPath.equals(fs.getPath())) ?\n+            InodeTree.SlashPath.toString() :\n+            fs.getPath().getName();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM2ODUyMA=="}, "originalCommit": {"oid": "cdd0932e33244d928c5e5682addc5146c064d6e7"}, "originalPosition": 18}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3287, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}