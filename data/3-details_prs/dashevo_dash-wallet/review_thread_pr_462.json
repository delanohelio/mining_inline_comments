{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU0MDE5OTkw", "number": 462, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwMjoyNzo0M1rOEQcGCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwMzowMTozMlrOEQcc-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1NjcyOTcxOnYy", "diffSide": "RIGHT", "path": "wallet/src/de/schildbach/wallet/ui/WalletFragment.kt", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwMjoyNzo0M1rOG0l0FA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxNjowMzowNVrOG1pUIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc5ODY3Ng==", "bodyText": "Android Studio warns that onChange is never called and this observer never triggered the \"Join DashPay\" button to disappear since an identity was never detected.  When I removed onChange as follows, then the button was not visible when in identity/username existed.\n        AppDatabase.getAppDatabase().blockchainIdentityDataDao().loadBase().observe(viewLifecycleOwner,\n                Observer {\n                        if (it != null) {\n                            noIdentityCreatedOrInProgress = it.creationState == BlockchainIdentityData.CreationState.NONE\n                            showHideJoinDashPayAction()\n                            if (retryCreationIfInProgress && it.creationInProgress) {\n                                retryCreationIfInProgress = false\n                                activity?.startService(createIntentForRetry(requireActivity(), false))\n                            }\n                        }\n\n                }\n        )", "url": "https://github.com/dashevo/dash-wallet/pull/462#discussion_r457798676", "createdAt": "2020-07-21T02:27:43Z", "author": {"login": "HashEngineering"}, "path": "wallet/src/de/schildbach/wallet/ui/WalletFragment.kt", "diffHunk": "@@ -0,0 +1,342 @@\n+package de.schildbach.wallet.ui\n+\n+import android.app.Activity\n+import android.content.ClipDescription\n+import android.content.ClipboardManager\n+import android.content.Context\n+import android.content.Intent\n+import android.os.Bundle\n+import android.view.View\n+import androidx.coordinatorlayout.widget.CoordinatorLayout\n+import androidx.core.content.ContextCompat\n+import androidx.fragment.app.Fragment\n+import androidx.lifecycle.Observer\n+import androidx.lifecycle.ViewModelProvider\n+import androidx.lifecycle.ViewModelProviders\n+import com.google.android.material.appbar.AppBarLayout\n+import com.google.android.material.appbar.AppBarLayout.Behavior.DragCallback\n+import de.schildbach.wallet.AppDatabase\n+import de.schildbach.wallet.Constants\n+import de.schildbach.wallet.WalletApplication\n+import de.schildbach.wallet.data.BlockchainIdentityBaseData\n+import de.schildbach.wallet.data.BlockchainIdentityData\n+import de.schildbach.wallet.data.BlockchainState\n+import de.schildbach.wallet.data.PaymentIntent\n+import de.schildbach.wallet.livedata.Resource\n+import de.schildbach.wallet.livedata.Status\n+import de.schildbach.wallet.ui.CheckPinDialog.Companion.show\n+import de.schildbach.wallet.ui.InputParser.StringInputParser\n+import de.schildbach.wallet.ui.MainActivity.Companion.REQUEST_CODE_SCAN\n+import de.schildbach.wallet.ui.PaymentsFragment.Companion.ACTIVE_TAB_PAY\n+import de.schildbach.wallet.ui.PaymentsFragment.Companion.ACTIVE_TAB_RECEIVE\n+import de.schildbach.wallet.ui.VerifySeedActivity.Companion.createIntent\n+import de.schildbach.wallet.ui.dashpay.CreateIdentityService.Companion.createIntentForRetry\n+import de.schildbach.wallet.ui.dashpay.DashPayViewModel\n+import de.schildbach.wallet.ui.scan.ScanActivity\n+import de.schildbach.wallet.ui.send.SendCoinsInternalActivity\n+import de.schildbach.wallet.ui.send.SweepWalletActivity\n+import de.schildbach.wallet_test.R\n+import kotlinx.android.synthetic.main.home_content.*\n+import kotlinx.android.synthetic.main.quick_actions_layout.*\n+import kotlinx.android.synthetic.main.sync_status_pane.*\n+import org.bitcoinj.core.Coin\n+import org.bitcoinj.core.PrefixedChecksummedBytes\n+import org.bitcoinj.core.Transaction\n+import org.bitcoinj.core.VerificationException\n+import org.bitcoinj.wallet.Wallet\n+import org.bitcoinj.wallet.listeners.WalletCoinsReceivedEventListener\n+import org.bitcoinj.wallet.listeners.WalletCoinsSentEventListener\n+import org.dash.wallet.integration.uphold.ui.UpholdAccountActivity\n+\n+class WalletFragment : Fragment(R.layout.home_content) {\n+\n+    private var clipboardManager: ClipboardManager? = null\n+    private var blockchainState: BlockchainState? = null\n+    private var syncComplete = false\n+    private var dashPayViewModel: DashPayViewModel? = null\n+    private var isPlatformAvailable = false\n+    private var noIdentityCreatedOrInProgress = true\n+    private var retryCreationIfInProgress = true\n+\n+    private val walletApplication by lazy { WalletApplication.getInstance() }\n+    private val wallet by lazy { walletApplication.wallet }\n+    private val config by lazy { walletApplication.configuration }\n+    private val coinsSendReceivedListener = OnCoinsSentReceivedListener()\n+\n+    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n+        super.onViewCreated(view, savedInstanceState)\n+        initView()\n+        initViewModel()\n+        clipboardManager = activity?.getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager?\n+\n+        val appBar: View = app_bar\n+        val params = appBar.layoutParams as CoordinatorLayout.LayoutParams\n+        if (params.behavior == null) {\n+            params.behavior = AppBarLayout.Behavior()\n+        }\n+        val behaviour = params.behavior as AppBarLayout.Behavior?\n+        behaviour!!.setDragCallback(object : DragCallback() {\n+            override fun canDrag(appBarLayout: AppBarLayout): Boolean {\n+                //TODO: WalletFragment and WalletTransactionsFragment can probably be merged.\n+                val walletTransactionsFragment = childFragmentManager\n+                        .findFragmentById(R.id.wallet_transactions_fragment) as WalletTransactionsFragment?\n+                return walletTransactionsFragment != null && !walletTransactionsFragment.isHistoryEmpty\n+            }\n+        })\n+\n+        AppDatabase.getAppDatabase().blockchainStateDao().load().observe(viewLifecycleOwner, object : Observer<BlockchainState?> {\n+            override fun onChanged(t: BlockchainState?) {\n+                blockchainState = t\n+                updateSyncState()\n+                showHideJoinDashPayAction()\n+            }\n+        })\n+        registerOnCoinsSentReceivedListener()\n+    }\n+\n+    override fun onResume() {\n+        super.onResume()\n+        showHideSecureAction()\n+    }\n+\n+    override fun onDestroy() {\n+        unregisterWalletListener()\n+        super.onDestroy()\n+    }\n+\n+    private fun registerOnCoinsSentReceivedListener() {\n+        val mainThreadExecutor = ContextCompat.getMainExecutor(requireContext())\n+        wallet.addCoinsReceivedEventListener(mainThreadExecutor, coinsSendReceivedListener)\n+        wallet.addCoinsSentEventListener(mainThreadExecutor, coinsSendReceivedListener)\n+    }\n+\n+    private fun unregisterWalletListener() {\n+        wallet.removeCoinsReceivedEventListener(coinsSendReceivedListener)\n+        wallet.removeCoinsSentEventListener(coinsSendReceivedListener)\n+    }\n+\n+    private fun updateSyncPaneVisibility(id: Int, visible: Boolean) {\n+        view?.findViewById<View>(id)?.visibility = if (visible) View.VISIBLE else View.GONE\n+    }\n+\n+    private fun updateSyncState() {\n+        if (blockchainState == null) {\n+            return\n+        }\n+        var percentage: Int = blockchainState!!.percentageSync\n+        if (blockchainState!!.replaying && blockchainState!!.percentageSync == 100) {\n+            //This is to prevent showing 100% when using the Rescan blockchain function.\n+            //The first few broadcasted blockchainStates are with percentage sync at 100%\n+            percentage = 0\n+        }\n+        val syncProgressView = sync_status_progress\n+        if (blockchainState != null && blockchainState!!.syncFailed()) {\n+            updateSyncPaneVisibility(R.id.sync_status_pane, true)\n+            sync_progress_pane.visibility = View.GONE\n+            sync_error_pane.visibility = View.VISIBLE\n+            return\n+        }\n+        updateSyncPaneVisibility(R.id.sync_error_pane, false)\n+        updateSyncPaneVisibility(R.id.sync_progress_pane, true)\n+        val syncStatusTitle = sync_status_title\n+        val syncStatusMessage = sync_status_message\n+        syncProgressView.progress = percentage\n+        val syncPercentageView = sync_status_percentage\n+        syncPercentageView.text = \"$percentage%\"\n+        syncComplete = blockchainState!!.isSynced()\n+        if (syncComplete) {\n+            syncPercentageView.setTextColor(resources.getColor(R.color.success_green))\n+            syncStatusTitle.setText(R.string.sync_status_sync_title)\n+            syncStatusMessage.setText(R.string.sync_status_sync_completed)\n+            updateSyncPaneVisibility(R.id.sync_status_pane, false)\n+        } else {\n+            syncPercentageView.setTextColor(resources.getColor(R.color.dash_gray))\n+            updateSyncPaneVisibility(R.id.sync_status_pane, true)\n+            syncStatusTitle.setText(R.string.sync_status_syncing_title)\n+            syncStatusMessage.setText(R.string.sync_status_syncing_sub_title)\n+        }\n+    }\n+\n+    private fun initView() {\n+        initQuickActions()\n+        if (requireActivity() is OnSelectPaymentTabListener) {\n+            pay_btn.setOnClickListener(View.OnClickListener {\n+                (requireActivity() as OnSelectPaymentTabListener).onSelectPaymentTab(ACTIVE_TAB_PAY)\n+            })\n+            receive_btn.setOnClickListener {\n+                (requireActivity() as OnSelectPaymentTabListener).onSelectPaymentTab(ACTIVE_TAB_RECEIVE)\n+            }\n+        }\n+\n+    }\n+\n+    private fun initViewModel() {\n+        //\n+        // Currently this is only used to check the status of Platform before showing\n+        // the Join DashPay (evolution) button on the shortcuts bar.\n+        // If that is the only function that the platform required for, then we can\n+        // conditionally execute this code when a username hasn't been registered.\n+        dashPayViewModel = ViewModelProvider(this)[DashPayViewModel::class.java]\n+        dashPayViewModel!!.isPlatformAvailableLiveData.observe(viewLifecycleOwner, object : Observer<Resource<Boolean?>?> {\n+            override fun onChanged(status: Resource<Boolean?>?) {\n+                if (status?.status === Status.SUCCESS) {\n+                    if (status.data != null) {\n+                        isPlatformAvailable = status.data\n+                    }\n+                } else {\n+                    isPlatformAvailable = false\n+                }\n+                showHideJoinDashPayAction()\n+            }\n+        })\n+        AppDatabase.getAppDatabase().blockchainIdentityDataDao().loadBase().observe(viewLifecycleOwner,\n+                Observer<BlockchainIdentityBaseData?> {\n+                    fun onChanged(blockchainIdentityData: BlockchainIdentityBaseData) {\n+                        if (blockchainIdentityData != null) {\n+                            noIdentityCreatedOrInProgress = blockchainIdentityData.creationState == BlockchainIdentityData.CreationState.NONE\n+                            showHideJoinDashPayAction()\n+                            if (retryCreationIfInProgress && blockchainIdentityData.creationInProgress) {\n+                                retryCreationIfInProgress = false\n+                                activity?.startService(createIntentForRetry(requireActivity(), false))\n+                            }\n+                        }\n+                    }\n+                })", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0320dd9a2b16e4eb92b9f4cfc4960477e19e0fb9"}, "originalPosition": 204}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODkwNDYwOQ==", "bodyText": "Fixed on eb3075f", "url": "https://github.com/dashevo/dash-wallet/pull/462#discussion_r458904609", "createdAt": "2020-07-22T16:03:05Z", "author": {"login": "sambarboza"}, "path": "wallet/src/de/schildbach/wallet/ui/WalletFragment.kt", "diffHunk": "@@ -0,0 +1,342 @@\n+package de.schildbach.wallet.ui\n+\n+import android.app.Activity\n+import android.content.ClipDescription\n+import android.content.ClipboardManager\n+import android.content.Context\n+import android.content.Intent\n+import android.os.Bundle\n+import android.view.View\n+import androidx.coordinatorlayout.widget.CoordinatorLayout\n+import androidx.core.content.ContextCompat\n+import androidx.fragment.app.Fragment\n+import androidx.lifecycle.Observer\n+import androidx.lifecycle.ViewModelProvider\n+import androidx.lifecycle.ViewModelProviders\n+import com.google.android.material.appbar.AppBarLayout\n+import com.google.android.material.appbar.AppBarLayout.Behavior.DragCallback\n+import de.schildbach.wallet.AppDatabase\n+import de.schildbach.wallet.Constants\n+import de.schildbach.wallet.WalletApplication\n+import de.schildbach.wallet.data.BlockchainIdentityBaseData\n+import de.schildbach.wallet.data.BlockchainIdentityData\n+import de.schildbach.wallet.data.BlockchainState\n+import de.schildbach.wallet.data.PaymentIntent\n+import de.schildbach.wallet.livedata.Resource\n+import de.schildbach.wallet.livedata.Status\n+import de.schildbach.wallet.ui.CheckPinDialog.Companion.show\n+import de.schildbach.wallet.ui.InputParser.StringInputParser\n+import de.schildbach.wallet.ui.MainActivity.Companion.REQUEST_CODE_SCAN\n+import de.schildbach.wallet.ui.PaymentsFragment.Companion.ACTIVE_TAB_PAY\n+import de.schildbach.wallet.ui.PaymentsFragment.Companion.ACTIVE_TAB_RECEIVE\n+import de.schildbach.wallet.ui.VerifySeedActivity.Companion.createIntent\n+import de.schildbach.wallet.ui.dashpay.CreateIdentityService.Companion.createIntentForRetry\n+import de.schildbach.wallet.ui.dashpay.DashPayViewModel\n+import de.schildbach.wallet.ui.scan.ScanActivity\n+import de.schildbach.wallet.ui.send.SendCoinsInternalActivity\n+import de.schildbach.wallet.ui.send.SweepWalletActivity\n+import de.schildbach.wallet_test.R\n+import kotlinx.android.synthetic.main.home_content.*\n+import kotlinx.android.synthetic.main.quick_actions_layout.*\n+import kotlinx.android.synthetic.main.sync_status_pane.*\n+import org.bitcoinj.core.Coin\n+import org.bitcoinj.core.PrefixedChecksummedBytes\n+import org.bitcoinj.core.Transaction\n+import org.bitcoinj.core.VerificationException\n+import org.bitcoinj.wallet.Wallet\n+import org.bitcoinj.wallet.listeners.WalletCoinsReceivedEventListener\n+import org.bitcoinj.wallet.listeners.WalletCoinsSentEventListener\n+import org.dash.wallet.integration.uphold.ui.UpholdAccountActivity\n+\n+class WalletFragment : Fragment(R.layout.home_content) {\n+\n+    private var clipboardManager: ClipboardManager? = null\n+    private var blockchainState: BlockchainState? = null\n+    private var syncComplete = false\n+    private var dashPayViewModel: DashPayViewModel? = null\n+    private var isPlatformAvailable = false\n+    private var noIdentityCreatedOrInProgress = true\n+    private var retryCreationIfInProgress = true\n+\n+    private val walletApplication by lazy { WalletApplication.getInstance() }\n+    private val wallet by lazy { walletApplication.wallet }\n+    private val config by lazy { walletApplication.configuration }\n+    private val coinsSendReceivedListener = OnCoinsSentReceivedListener()\n+\n+    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n+        super.onViewCreated(view, savedInstanceState)\n+        initView()\n+        initViewModel()\n+        clipboardManager = activity?.getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager?\n+\n+        val appBar: View = app_bar\n+        val params = appBar.layoutParams as CoordinatorLayout.LayoutParams\n+        if (params.behavior == null) {\n+            params.behavior = AppBarLayout.Behavior()\n+        }\n+        val behaviour = params.behavior as AppBarLayout.Behavior?\n+        behaviour!!.setDragCallback(object : DragCallback() {\n+            override fun canDrag(appBarLayout: AppBarLayout): Boolean {\n+                //TODO: WalletFragment and WalletTransactionsFragment can probably be merged.\n+                val walletTransactionsFragment = childFragmentManager\n+                        .findFragmentById(R.id.wallet_transactions_fragment) as WalletTransactionsFragment?\n+                return walletTransactionsFragment != null && !walletTransactionsFragment.isHistoryEmpty\n+            }\n+        })\n+\n+        AppDatabase.getAppDatabase().blockchainStateDao().load().observe(viewLifecycleOwner, object : Observer<BlockchainState?> {\n+            override fun onChanged(t: BlockchainState?) {\n+                blockchainState = t\n+                updateSyncState()\n+                showHideJoinDashPayAction()\n+            }\n+        })\n+        registerOnCoinsSentReceivedListener()\n+    }\n+\n+    override fun onResume() {\n+        super.onResume()\n+        showHideSecureAction()\n+    }\n+\n+    override fun onDestroy() {\n+        unregisterWalletListener()\n+        super.onDestroy()\n+    }\n+\n+    private fun registerOnCoinsSentReceivedListener() {\n+        val mainThreadExecutor = ContextCompat.getMainExecutor(requireContext())\n+        wallet.addCoinsReceivedEventListener(mainThreadExecutor, coinsSendReceivedListener)\n+        wallet.addCoinsSentEventListener(mainThreadExecutor, coinsSendReceivedListener)\n+    }\n+\n+    private fun unregisterWalletListener() {\n+        wallet.removeCoinsReceivedEventListener(coinsSendReceivedListener)\n+        wallet.removeCoinsSentEventListener(coinsSendReceivedListener)\n+    }\n+\n+    private fun updateSyncPaneVisibility(id: Int, visible: Boolean) {\n+        view?.findViewById<View>(id)?.visibility = if (visible) View.VISIBLE else View.GONE\n+    }\n+\n+    private fun updateSyncState() {\n+        if (blockchainState == null) {\n+            return\n+        }\n+        var percentage: Int = blockchainState!!.percentageSync\n+        if (blockchainState!!.replaying && blockchainState!!.percentageSync == 100) {\n+            //This is to prevent showing 100% when using the Rescan blockchain function.\n+            //The first few broadcasted blockchainStates are with percentage sync at 100%\n+            percentage = 0\n+        }\n+        val syncProgressView = sync_status_progress\n+        if (blockchainState != null && blockchainState!!.syncFailed()) {\n+            updateSyncPaneVisibility(R.id.sync_status_pane, true)\n+            sync_progress_pane.visibility = View.GONE\n+            sync_error_pane.visibility = View.VISIBLE\n+            return\n+        }\n+        updateSyncPaneVisibility(R.id.sync_error_pane, false)\n+        updateSyncPaneVisibility(R.id.sync_progress_pane, true)\n+        val syncStatusTitle = sync_status_title\n+        val syncStatusMessage = sync_status_message\n+        syncProgressView.progress = percentage\n+        val syncPercentageView = sync_status_percentage\n+        syncPercentageView.text = \"$percentage%\"\n+        syncComplete = blockchainState!!.isSynced()\n+        if (syncComplete) {\n+            syncPercentageView.setTextColor(resources.getColor(R.color.success_green))\n+            syncStatusTitle.setText(R.string.sync_status_sync_title)\n+            syncStatusMessage.setText(R.string.sync_status_sync_completed)\n+            updateSyncPaneVisibility(R.id.sync_status_pane, false)\n+        } else {\n+            syncPercentageView.setTextColor(resources.getColor(R.color.dash_gray))\n+            updateSyncPaneVisibility(R.id.sync_status_pane, true)\n+            syncStatusTitle.setText(R.string.sync_status_syncing_title)\n+            syncStatusMessage.setText(R.string.sync_status_syncing_sub_title)\n+        }\n+    }\n+\n+    private fun initView() {\n+        initQuickActions()\n+        if (requireActivity() is OnSelectPaymentTabListener) {\n+            pay_btn.setOnClickListener(View.OnClickListener {\n+                (requireActivity() as OnSelectPaymentTabListener).onSelectPaymentTab(ACTIVE_TAB_PAY)\n+            })\n+            receive_btn.setOnClickListener {\n+                (requireActivity() as OnSelectPaymentTabListener).onSelectPaymentTab(ACTIVE_TAB_RECEIVE)\n+            }\n+        }\n+\n+    }\n+\n+    private fun initViewModel() {\n+        //\n+        // Currently this is only used to check the status of Platform before showing\n+        // the Join DashPay (evolution) button on the shortcuts bar.\n+        // If that is the only function that the platform required for, then we can\n+        // conditionally execute this code when a username hasn't been registered.\n+        dashPayViewModel = ViewModelProvider(this)[DashPayViewModel::class.java]\n+        dashPayViewModel!!.isPlatformAvailableLiveData.observe(viewLifecycleOwner, object : Observer<Resource<Boolean?>?> {\n+            override fun onChanged(status: Resource<Boolean?>?) {\n+                if (status?.status === Status.SUCCESS) {\n+                    if (status.data != null) {\n+                        isPlatformAvailable = status.data\n+                    }\n+                } else {\n+                    isPlatformAvailable = false\n+                }\n+                showHideJoinDashPayAction()\n+            }\n+        })\n+        AppDatabase.getAppDatabase().blockchainIdentityDataDao().loadBase().observe(viewLifecycleOwner,\n+                Observer<BlockchainIdentityBaseData?> {\n+                    fun onChanged(blockchainIdentityData: BlockchainIdentityBaseData) {\n+                        if (blockchainIdentityData != null) {\n+                            noIdentityCreatedOrInProgress = blockchainIdentityData.creationState == BlockchainIdentityData.CreationState.NONE\n+                            showHideJoinDashPayAction()\n+                            if (retryCreationIfInProgress && blockchainIdentityData.creationInProgress) {\n+                                retryCreationIfInProgress = false\n+                                activity?.startService(createIntentForRetry(requireActivity(), false))\n+                            }\n+                        }\n+                    }\n+                })", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc5ODY3Ng=="}, "originalCommit": {"oid": "0320dd9a2b16e4eb92b9f4cfc4960477e19e0fb9"}, "originalPosition": 204}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1NjczNjA2OnYy", "diffSide": "RIGHT", "path": "wallet/src/de/schildbach/wallet/ui/WalletFragment.kt", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwMjozMTowNlrOG0l3pQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QwMjoxNToyOFrOG16NAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc5OTU4OQ==", "bodyText": "I suppose this goes here: walletApplication.processDirectTransaction(tx)", "url": "https://github.com/dashevo/dash-wallet/pull/462#discussion_r457799589", "createdAt": "2020-07-21T02:31:06Z", "author": {"login": "HashEngineering"}, "path": "wallet/src/de/schildbach/wallet/ui/WalletFragment.kt", "diffHunk": "@@ -0,0 +1,342 @@\n+package de.schildbach.wallet.ui\n+\n+import android.app.Activity\n+import android.content.ClipDescription\n+import android.content.ClipboardManager\n+import android.content.Context\n+import android.content.Intent\n+import android.os.Bundle\n+import android.view.View\n+import androidx.coordinatorlayout.widget.CoordinatorLayout\n+import androidx.core.content.ContextCompat\n+import androidx.fragment.app.Fragment\n+import androidx.lifecycle.Observer\n+import androidx.lifecycle.ViewModelProvider\n+import androidx.lifecycle.ViewModelProviders\n+import com.google.android.material.appbar.AppBarLayout\n+import com.google.android.material.appbar.AppBarLayout.Behavior.DragCallback\n+import de.schildbach.wallet.AppDatabase\n+import de.schildbach.wallet.Constants\n+import de.schildbach.wallet.WalletApplication\n+import de.schildbach.wallet.data.BlockchainIdentityBaseData\n+import de.schildbach.wallet.data.BlockchainIdentityData\n+import de.schildbach.wallet.data.BlockchainState\n+import de.schildbach.wallet.data.PaymentIntent\n+import de.schildbach.wallet.livedata.Resource\n+import de.schildbach.wallet.livedata.Status\n+import de.schildbach.wallet.ui.CheckPinDialog.Companion.show\n+import de.schildbach.wallet.ui.InputParser.StringInputParser\n+import de.schildbach.wallet.ui.MainActivity.Companion.REQUEST_CODE_SCAN\n+import de.schildbach.wallet.ui.PaymentsFragment.Companion.ACTIVE_TAB_PAY\n+import de.schildbach.wallet.ui.PaymentsFragment.Companion.ACTIVE_TAB_RECEIVE\n+import de.schildbach.wallet.ui.VerifySeedActivity.Companion.createIntent\n+import de.schildbach.wallet.ui.dashpay.CreateIdentityService.Companion.createIntentForRetry\n+import de.schildbach.wallet.ui.dashpay.DashPayViewModel\n+import de.schildbach.wallet.ui.scan.ScanActivity\n+import de.schildbach.wallet.ui.send.SendCoinsInternalActivity\n+import de.schildbach.wallet.ui.send.SweepWalletActivity\n+import de.schildbach.wallet_test.R\n+import kotlinx.android.synthetic.main.home_content.*\n+import kotlinx.android.synthetic.main.quick_actions_layout.*\n+import kotlinx.android.synthetic.main.sync_status_pane.*\n+import org.bitcoinj.core.Coin\n+import org.bitcoinj.core.PrefixedChecksummedBytes\n+import org.bitcoinj.core.Transaction\n+import org.bitcoinj.core.VerificationException\n+import org.bitcoinj.wallet.Wallet\n+import org.bitcoinj.wallet.listeners.WalletCoinsReceivedEventListener\n+import org.bitcoinj.wallet.listeners.WalletCoinsSentEventListener\n+import org.dash.wallet.integration.uphold.ui.UpholdAccountActivity\n+\n+class WalletFragment : Fragment(R.layout.home_content) {\n+\n+    private var clipboardManager: ClipboardManager? = null\n+    private var blockchainState: BlockchainState? = null\n+    private var syncComplete = false\n+    private var dashPayViewModel: DashPayViewModel? = null\n+    private var isPlatformAvailable = false\n+    private var noIdentityCreatedOrInProgress = true\n+    private var retryCreationIfInProgress = true\n+\n+    private val walletApplication by lazy { WalletApplication.getInstance() }\n+    private val wallet by lazy { walletApplication.wallet }\n+    private val config by lazy { walletApplication.configuration }\n+    private val coinsSendReceivedListener = OnCoinsSentReceivedListener()\n+\n+    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n+        super.onViewCreated(view, savedInstanceState)\n+        initView()\n+        initViewModel()\n+        clipboardManager = activity?.getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager?\n+\n+        val appBar: View = app_bar\n+        val params = appBar.layoutParams as CoordinatorLayout.LayoutParams\n+        if (params.behavior == null) {\n+            params.behavior = AppBarLayout.Behavior()\n+        }\n+        val behaviour = params.behavior as AppBarLayout.Behavior?\n+        behaviour!!.setDragCallback(object : DragCallback() {\n+            override fun canDrag(appBarLayout: AppBarLayout): Boolean {\n+                //TODO: WalletFragment and WalletTransactionsFragment can probably be merged.\n+                val walletTransactionsFragment = childFragmentManager\n+                        .findFragmentById(R.id.wallet_transactions_fragment) as WalletTransactionsFragment?\n+                return walletTransactionsFragment != null && !walletTransactionsFragment.isHistoryEmpty\n+            }\n+        })\n+\n+        AppDatabase.getAppDatabase().blockchainStateDao().load().observe(viewLifecycleOwner, object : Observer<BlockchainState?> {\n+            override fun onChanged(t: BlockchainState?) {\n+                blockchainState = t\n+                updateSyncState()\n+                showHideJoinDashPayAction()\n+            }\n+        })\n+        registerOnCoinsSentReceivedListener()\n+    }\n+\n+    override fun onResume() {\n+        super.onResume()\n+        showHideSecureAction()\n+    }\n+\n+    override fun onDestroy() {\n+        unregisterWalletListener()\n+        super.onDestroy()\n+    }\n+\n+    private fun registerOnCoinsSentReceivedListener() {\n+        val mainThreadExecutor = ContextCompat.getMainExecutor(requireContext())\n+        wallet.addCoinsReceivedEventListener(mainThreadExecutor, coinsSendReceivedListener)\n+        wallet.addCoinsSentEventListener(mainThreadExecutor, coinsSendReceivedListener)\n+    }\n+\n+    private fun unregisterWalletListener() {\n+        wallet.removeCoinsReceivedEventListener(coinsSendReceivedListener)\n+        wallet.removeCoinsSentEventListener(coinsSendReceivedListener)\n+    }\n+\n+    private fun updateSyncPaneVisibility(id: Int, visible: Boolean) {\n+        view?.findViewById<View>(id)?.visibility = if (visible) View.VISIBLE else View.GONE\n+    }\n+\n+    private fun updateSyncState() {\n+        if (blockchainState == null) {\n+            return\n+        }\n+        var percentage: Int = blockchainState!!.percentageSync\n+        if (blockchainState!!.replaying && blockchainState!!.percentageSync == 100) {\n+            //This is to prevent showing 100% when using the Rescan blockchain function.\n+            //The first few broadcasted blockchainStates are with percentage sync at 100%\n+            percentage = 0\n+        }\n+        val syncProgressView = sync_status_progress\n+        if (blockchainState != null && blockchainState!!.syncFailed()) {\n+            updateSyncPaneVisibility(R.id.sync_status_pane, true)\n+            sync_progress_pane.visibility = View.GONE\n+            sync_error_pane.visibility = View.VISIBLE\n+            return\n+        }\n+        updateSyncPaneVisibility(R.id.sync_error_pane, false)\n+        updateSyncPaneVisibility(R.id.sync_progress_pane, true)\n+        val syncStatusTitle = sync_status_title\n+        val syncStatusMessage = sync_status_message\n+        syncProgressView.progress = percentage\n+        val syncPercentageView = sync_status_percentage\n+        syncPercentageView.text = \"$percentage%\"\n+        syncComplete = blockchainState!!.isSynced()\n+        if (syncComplete) {\n+            syncPercentageView.setTextColor(resources.getColor(R.color.success_green))\n+            syncStatusTitle.setText(R.string.sync_status_sync_title)\n+            syncStatusMessage.setText(R.string.sync_status_sync_completed)\n+            updateSyncPaneVisibility(R.id.sync_status_pane, false)\n+        } else {\n+            syncPercentageView.setTextColor(resources.getColor(R.color.dash_gray))\n+            updateSyncPaneVisibility(R.id.sync_status_pane, true)\n+            syncStatusTitle.setText(R.string.sync_status_syncing_title)\n+            syncStatusMessage.setText(R.string.sync_status_syncing_sub_title)\n+        }\n+    }\n+\n+    private fun initView() {\n+        initQuickActions()\n+        if (requireActivity() is OnSelectPaymentTabListener) {\n+            pay_btn.setOnClickListener(View.OnClickListener {\n+                (requireActivity() as OnSelectPaymentTabListener).onSelectPaymentTab(ACTIVE_TAB_PAY)\n+            })\n+            receive_btn.setOnClickListener {\n+                (requireActivity() as OnSelectPaymentTabListener).onSelectPaymentTab(ACTIVE_TAB_RECEIVE)\n+            }\n+        }\n+\n+    }\n+\n+    private fun initViewModel() {\n+        //\n+        // Currently this is only used to check the status of Platform before showing\n+        // the Join DashPay (evolution) button on the shortcuts bar.\n+        // If that is the only function that the platform required for, then we can\n+        // conditionally execute this code when a username hasn't been registered.\n+        dashPayViewModel = ViewModelProvider(this)[DashPayViewModel::class.java]\n+        dashPayViewModel!!.isPlatformAvailableLiveData.observe(viewLifecycleOwner, object : Observer<Resource<Boolean?>?> {\n+            override fun onChanged(status: Resource<Boolean?>?) {\n+                if (status?.status === Status.SUCCESS) {\n+                    if (status.data != null) {\n+                        isPlatformAvailable = status.data\n+                    }\n+                } else {\n+                    isPlatformAvailable = false\n+                }\n+                showHideJoinDashPayAction()\n+            }\n+        })\n+        AppDatabase.getAppDatabase().blockchainIdentityDataDao().loadBase().observe(viewLifecycleOwner,\n+                Observer<BlockchainIdentityBaseData?> {\n+                    fun onChanged(blockchainIdentityData: BlockchainIdentityBaseData) {\n+                        if (blockchainIdentityData != null) {\n+                            noIdentityCreatedOrInProgress = blockchainIdentityData.creationState == BlockchainIdentityData.CreationState.NONE\n+                            showHideJoinDashPayAction()\n+                            if (retryCreationIfInProgress && blockchainIdentityData.creationInProgress) {\n+                                retryCreationIfInProgress = false\n+                                activity?.startService(createIntentForRetry(requireActivity(), false))\n+                            }\n+                        }\n+                    }\n+                })\n+    }\n+\n+    fun showHideJoinDashPayAction() {\n+        if (noIdentityCreatedOrInProgress && syncComplete && isPlatformAvailable) {\n+            val walletBalance: Coin = wallet.getBalance(Wallet.BalanceType.ESTIMATED)\n+            val canAffordIt = (walletBalance.isGreaterThan(Constants.DASH_PAY_FEE)\n+                    || walletBalance == Constants.DASH_PAY_FEE)\n+            val visible = canAffordIt && config.showJoinDashPay\n+            join_dashpay_action.visibility = if (visible) View.VISIBLE else View.GONE\n+        } else {\n+            join_dashpay_action.visibility = View.GONE\n+        }\n+        join_dashpay_action_space.visibility = join_dashpay_action.visibility\n+    }\n+\n+    private fun showHideSecureAction() {\n+        secure_action.visibility = if (config.remindBackupSeed) View.VISIBLE else View.GONE\n+        secure_action_space.visibility = secure_action.visibility\n+    }\n+\n+    private fun handleVerifySeed() {\n+        val checkPinSharedModel = ViewModelProviders.of(this)[CheckPinSharedModel::class.java]\n+        checkPinSharedModel.onCorrectPinCallback.observe(viewLifecycleOwner, Observer<Pair<Int?, String?>?> { data ->\n+            if (data?.second != null) {\n+                startVerifySeedActivity(data.second!!)\n+            }\n+        })\n+        show(requireActivity(), 0)\n+    }\n+\n+    private fun handleScan(clickView: View?) {\n+        ScanActivity.startForResult(requireActivity(), clickView, MainActivity.REQUEST_CODE_SCAN)\n+    }\n+\n+    private fun startVerifySeedActivity(pin: String) {\n+        val intent: Intent = createIntent(requireContext(), pin)\n+        startActivity(intent)\n+    }\n+\n+    private fun handlePaste() {\n+        var input: String? = null\n+        if (clipboardManager!!.hasPrimaryClip()) {\n+            val clip = clipboardManager!!.primaryClip ?: return\n+            val clipDescription = clip.description\n+            if (clipDescription.hasMimeType(ClipDescription.MIMETYPE_TEXT_URILIST)) {\n+                val clipUri = clip.getItemAt(0).uri\n+                if (clipUri != null) {\n+                    input = clipUri.toString()\n+                }\n+            } else if (clipDescription.hasMimeType(ClipDescription.MIMETYPE_TEXT_PLAIN)\n+                    || clipDescription.hasMimeType(ClipDescription.MIMETYPE_TEXT_HTML)) {\n+                val clipText = clip.getItemAt(0).text\n+                if (clipText != null) {\n+                    input = clipText.toString()\n+                }\n+            }\n+        }\n+        if (input != null) {\n+            handleString(input, R.string.scan_to_pay_error_dialog_title, R.string.scan_to_pay_error_dialog_message)\n+        } else {\n+            InputParser.dialog(requireContext(), null, R.string.scan_to_pay_error_dialog_title, R.string.scan_to_pay_error_dialog_message_no_data)\n+        }\n+    }\n+\n+    private fun handleString(input: String, errorDialogTitleResId: Int, cannotClassifyCustomMessageResId: Int) {\n+        object : StringInputParser(input, true) {\n+            override fun handlePaymentIntent(paymentIntent: PaymentIntent) {\n+                SendCoinsInternalActivity.start(requireContext(), paymentIntent, true)\n+            }\n+\n+            override fun handlePrivateKey(key: PrefixedChecksummedBytes) {\n+                SweepWalletActivity.start(requireContext(), key, true)\n+            }\n+\n+            @Throws(VerificationException::class)\n+            override fun handleDirectTransaction(tx: Transaction) {\n+                //TODO: Uncomment\n+                //application.processDirectTransaction(tx);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0320dd9a2b16e4eb92b9f4cfc4960477e19e0fb9"}, "originalPosition": 282}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE4MTMxNQ==", "bodyText": "Fixed on e794cce", "url": "https://github.com/dashevo/dash-wallet/pull/462#discussion_r459181315", "createdAt": "2020-07-23T02:15:28Z", "author": {"login": "sambarboza"}, "path": "wallet/src/de/schildbach/wallet/ui/WalletFragment.kt", "diffHunk": "@@ -0,0 +1,342 @@\n+package de.schildbach.wallet.ui\n+\n+import android.app.Activity\n+import android.content.ClipDescription\n+import android.content.ClipboardManager\n+import android.content.Context\n+import android.content.Intent\n+import android.os.Bundle\n+import android.view.View\n+import androidx.coordinatorlayout.widget.CoordinatorLayout\n+import androidx.core.content.ContextCompat\n+import androidx.fragment.app.Fragment\n+import androidx.lifecycle.Observer\n+import androidx.lifecycle.ViewModelProvider\n+import androidx.lifecycle.ViewModelProviders\n+import com.google.android.material.appbar.AppBarLayout\n+import com.google.android.material.appbar.AppBarLayout.Behavior.DragCallback\n+import de.schildbach.wallet.AppDatabase\n+import de.schildbach.wallet.Constants\n+import de.schildbach.wallet.WalletApplication\n+import de.schildbach.wallet.data.BlockchainIdentityBaseData\n+import de.schildbach.wallet.data.BlockchainIdentityData\n+import de.schildbach.wallet.data.BlockchainState\n+import de.schildbach.wallet.data.PaymentIntent\n+import de.schildbach.wallet.livedata.Resource\n+import de.schildbach.wallet.livedata.Status\n+import de.schildbach.wallet.ui.CheckPinDialog.Companion.show\n+import de.schildbach.wallet.ui.InputParser.StringInputParser\n+import de.schildbach.wallet.ui.MainActivity.Companion.REQUEST_CODE_SCAN\n+import de.schildbach.wallet.ui.PaymentsFragment.Companion.ACTIVE_TAB_PAY\n+import de.schildbach.wallet.ui.PaymentsFragment.Companion.ACTIVE_TAB_RECEIVE\n+import de.schildbach.wallet.ui.VerifySeedActivity.Companion.createIntent\n+import de.schildbach.wallet.ui.dashpay.CreateIdentityService.Companion.createIntentForRetry\n+import de.schildbach.wallet.ui.dashpay.DashPayViewModel\n+import de.schildbach.wallet.ui.scan.ScanActivity\n+import de.schildbach.wallet.ui.send.SendCoinsInternalActivity\n+import de.schildbach.wallet.ui.send.SweepWalletActivity\n+import de.schildbach.wallet_test.R\n+import kotlinx.android.synthetic.main.home_content.*\n+import kotlinx.android.synthetic.main.quick_actions_layout.*\n+import kotlinx.android.synthetic.main.sync_status_pane.*\n+import org.bitcoinj.core.Coin\n+import org.bitcoinj.core.PrefixedChecksummedBytes\n+import org.bitcoinj.core.Transaction\n+import org.bitcoinj.core.VerificationException\n+import org.bitcoinj.wallet.Wallet\n+import org.bitcoinj.wallet.listeners.WalletCoinsReceivedEventListener\n+import org.bitcoinj.wallet.listeners.WalletCoinsSentEventListener\n+import org.dash.wallet.integration.uphold.ui.UpholdAccountActivity\n+\n+class WalletFragment : Fragment(R.layout.home_content) {\n+\n+    private var clipboardManager: ClipboardManager? = null\n+    private var blockchainState: BlockchainState? = null\n+    private var syncComplete = false\n+    private var dashPayViewModel: DashPayViewModel? = null\n+    private var isPlatformAvailable = false\n+    private var noIdentityCreatedOrInProgress = true\n+    private var retryCreationIfInProgress = true\n+\n+    private val walletApplication by lazy { WalletApplication.getInstance() }\n+    private val wallet by lazy { walletApplication.wallet }\n+    private val config by lazy { walletApplication.configuration }\n+    private val coinsSendReceivedListener = OnCoinsSentReceivedListener()\n+\n+    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n+        super.onViewCreated(view, savedInstanceState)\n+        initView()\n+        initViewModel()\n+        clipboardManager = activity?.getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager?\n+\n+        val appBar: View = app_bar\n+        val params = appBar.layoutParams as CoordinatorLayout.LayoutParams\n+        if (params.behavior == null) {\n+            params.behavior = AppBarLayout.Behavior()\n+        }\n+        val behaviour = params.behavior as AppBarLayout.Behavior?\n+        behaviour!!.setDragCallback(object : DragCallback() {\n+            override fun canDrag(appBarLayout: AppBarLayout): Boolean {\n+                //TODO: WalletFragment and WalletTransactionsFragment can probably be merged.\n+                val walletTransactionsFragment = childFragmentManager\n+                        .findFragmentById(R.id.wallet_transactions_fragment) as WalletTransactionsFragment?\n+                return walletTransactionsFragment != null && !walletTransactionsFragment.isHistoryEmpty\n+            }\n+        })\n+\n+        AppDatabase.getAppDatabase().blockchainStateDao().load().observe(viewLifecycleOwner, object : Observer<BlockchainState?> {\n+            override fun onChanged(t: BlockchainState?) {\n+                blockchainState = t\n+                updateSyncState()\n+                showHideJoinDashPayAction()\n+            }\n+        })\n+        registerOnCoinsSentReceivedListener()\n+    }\n+\n+    override fun onResume() {\n+        super.onResume()\n+        showHideSecureAction()\n+    }\n+\n+    override fun onDestroy() {\n+        unregisterWalletListener()\n+        super.onDestroy()\n+    }\n+\n+    private fun registerOnCoinsSentReceivedListener() {\n+        val mainThreadExecutor = ContextCompat.getMainExecutor(requireContext())\n+        wallet.addCoinsReceivedEventListener(mainThreadExecutor, coinsSendReceivedListener)\n+        wallet.addCoinsSentEventListener(mainThreadExecutor, coinsSendReceivedListener)\n+    }\n+\n+    private fun unregisterWalletListener() {\n+        wallet.removeCoinsReceivedEventListener(coinsSendReceivedListener)\n+        wallet.removeCoinsSentEventListener(coinsSendReceivedListener)\n+    }\n+\n+    private fun updateSyncPaneVisibility(id: Int, visible: Boolean) {\n+        view?.findViewById<View>(id)?.visibility = if (visible) View.VISIBLE else View.GONE\n+    }\n+\n+    private fun updateSyncState() {\n+        if (blockchainState == null) {\n+            return\n+        }\n+        var percentage: Int = blockchainState!!.percentageSync\n+        if (blockchainState!!.replaying && blockchainState!!.percentageSync == 100) {\n+            //This is to prevent showing 100% when using the Rescan blockchain function.\n+            //The first few broadcasted blockchainStates are with percentage sync at 100%\n+            percentage = 0\n+        }\n+        val syncProgressView = sync_status_progress\n+        if (blockchainState != null && blockchainState!!.syncFailed()) {\n+            updateSyncPaneVisibility(R.id.sync_status_pane, true)\n+            sync_progress_pane.visibility = View.GONE\n+            sync_error_pane.visibility = View.VISIBLE\n+            return\n+        }\n+        updateSyncPaneVisibility(R.id.sync_error_pane, false)\n+        updateSyncPaneVisibility(R.id.sync_progress_pane, true)\n+        val syncStatusTitle = sync_status_title\n+        val syncStatusMessage = sync_status_message\n+        syncProgressView.progress = percentage\n+        val syncPercentageView = sync_status_percentage\n+        syncPercentageView.text = \"$percentage%\"\n+        syncComplete = blockchainState!!.isSynced()\n+        if (syncComplete) {\n+            syncPercentageView.setTextColor(resources.getColor(R.color.success_green))\n+            syncStatusTitle.setText(R.string.sync_status_sync_title)\n+            syncStatusMessage.setText(R.string.sync_status_sync_completed)\n+            updateSyncPaneVisibility(R.id.sync_status_pane, false)\n+        } else {\n+            syncPercentageView.setTextColor(resources.getColor(R.color.dash_gray))\n+            updateSyncPaneVisibility(R.id.sync_status_pane, true)\n+            syncStatusTitle.setText(R.string.sync_status_syncing_title)\n+            syncStatusMessage.setText(R.string.sync_status_syncing_sub_title)\n+        }\n+    }\n+\n+    private fun initView() {\n+        initQuickActions()\n+        if (requireActivity() is OnSelectPaymentTabListener) {\n+            pay_btn.setOnClickListener(View.OnClickListener {\n+                (requireActivity() as OnSelectPaymentTabListener).onSelectPaymentTab(ACTIVE_TAB_PAY)\n+            })\n+            receive_btn.setOnClickListener {\n+                (requireActivity() as OnSelectPaymentTabListener).onSelectPaymentTab(ACTIVE_TAB_RECEIVE)\n+            }\n+        }\n+\n+    }\n+\n+    private fun initViewModel() {\n+        //\n+        // Currently this is only used to check the status of Platform before showing\n+        // the Join DashPay (evolution) button on the shortcuts bar.\n+        // If that is the only function that the platform required for, then we can\n+        // conditionally execute this code when a username hasn't been registered.\n+        dashPayViewModel = ViewModelProvider(this)[DashPayViewModel::class.java]\n+        dashPayViewModel!!.isPlatformAvailableLiveData.observe(viewLifecycleOwner, object : Observer<Resource<Boolean?>?> {\n+            override fun onChanged(status: Resource<Boolean?>?) {\n+                if (status?.status === Status.SUCCESS) {\n+                    if (status.data != null) {\n+                        isPlatformAvailable = status.data\n+                    }\n+                } else {\n+                    isPlatformAvailable = false\n+                }\n+                showHideJoinDashPayAction()\n+            }\n+        })\n+        AppDatabase.getAppDatabase().blockchainIdentityDataDao().loadBase().observe(viewLifecycleOwner,\n+                Observer<BlockchainIdentityBaseData?> {\n+                    fun onChanged(blockchainIdentityData: BlockchainIdentityBaseData) {\n+                        if (blockchainIdentityData != null) {\n+                            noIdentityCreatedOrInProgress = blockchainIdentityData.creationState == BlockchainIdentityData.CreationState.NONE\n+                            showHideJoinDashPayAction()\n+                            if (retryCreationIfInProgress && blockchainIdentityData.creationInProgress) {\n+                                retryCreationIfInProgress = false\n+                                activity?.startService(createIntentForRetry(requireActivity(), false))\n+                            }\n+                        }\n+                    }\n+                })\n+    }\n+\n+    fun showHideJoinDashPayAction() {\n+        if (noIdentityCreatedOrInProgress && syncComplete && isPlatformAvailable) {\n+            val walletBalance: Coin = wallet.getBalance(Wallet.BalanceType.ESTIMATED)\n+            val canAffordIt = (walletBalance.isGreaterThan(Constants.DASH_PAY_FEE)\n+                    || walletBalance == Constants.DASH_PAY_FEE)\n+            val visible = canAffordIt && config.showJoinDashPay\n+            join_dashpay_action.visibility = if (visible) View.VISIBLE else View.GONE\n+        } else {\n+            join_dashpay_action.visibility = View.GONE\n+        }\n+        join_dashpay_action_space.visibility = join_dashpay_action.visibility\n+    }\n+\n+    private fun showHideSecureAction() {\n+        secure_action.visibility = if (config.remindBackupSeed) View.VISIBLE else View.GONE\n+        secure_action_space.visibility = secure_action.visibility\n+    }\n+\n+    private fun handleVerifySeed() {\n+        val checkPinSharedModel = ViewModelProviders.of(this)[CheckPinSharedModel::class.java]\n+        checkPinSharedModel.onCorrectPinCallback.observe(viewLifecycleOwner, Observer<Pair<Int?, String?>?> { data ->\n+            if (data?.second != null) {\n+                startVerifySeedActivity(data.second!!)\n+            }\n+        })\n+        show(requireActivity(), 0)\n+    }\n+\n+    private fun handleScan(clickView: View?) {\n+        ScanActivity.startForResult(requireActivity(), clickView, MainActivity.REQUEST_CODE_SCAN)\n+    }\n+\n+    private fun startVerifySeedActivity(pin: String) {\n+        val intent: Intent = createIntent(requireContext(), pin)\n+        startActivity(intent)\n+    }\n+\n+    private fun handlePaste() {\n+        var input: String? = null\n+        if (clipboardManager!!.hasPrimaryClip()) {\n+            val clip = clipboardManager!!.primaryClip ?: return\n+            val clipDescription = clip.description\n+            if (clipDescription.hasMimeType(ClipDescription.MIMETYPE_TEXT_URILIST)) {\n+                val clipUri = clip.getItemAt(0).uri\n+                if (clipUri != null) {\n+                    input = clipUri.toString()\n+                }\n+            } else if (clipDescription.hasMimeType(ClipDescription.MIMETYPE_TEXT_PLAIN)\n+                    || clipDescription.hasMimeType(ClipDescription.MIMETYPE_TEXT_HTML)) {\n+                val clipText = clip.getItemAt(0).text\n+                if (clipText != null) {\n+                    input = clipText.toString()\n+                }\n+            }\n+        }\n+        if (input != null) {\n+            handleString(input, R.string.scan_to_pay_error_dialog_title, R.string.scan_to_pay_error_dialog_message)\n+        } else {\n+            InputParser.dialog(requireContext(), null, R.string.scan_to_pay_error_dialog_title, R.string.scan_to_pay_error_dialog_message_no_data)\n+        }\n+    }\n+\n+    private fun handleString(input: String, errorDialogTitleResId: Int, cannotClassifyCustomMessageResId: Int) {\n+        object : StringInputParser(input, true) {\n+            override fun handlePaymentIntent(paymentIntent: PaymentIntent) {\n+                SendCoinsInternalActivity.start(requireContext(), paymentIntent, true)\n+            }\n+\n+            override fun handlePrivateKey(key: PrefixedChecksummedBytes) {\n+                SweepWalletActivity.start(requireContext(), key, true)\n+            }\n+\n+            @Throws(VerificationException::class)\n+            override fun handleDirectTransaction(tx: Transaction) {\n+                //TODO: Uncomment\n+                //application.processDirectTransaction(tx);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc5OTU4OQ=="}, "originalCommit": {"oid": "0320dd9a2b16e4eb92b9f4cfc4960477e19e0fb9"}, "originalPosition": 282}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1NjczODQyOnYy", "diffSide": "RIGHT", "path": "wallet/src/de/schildbach/wallet/ui/MoreFragment.kt", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwMjozMjoyNVrOG0l4-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QwMjoxMzo0OVrOG16LsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc5OTkzMA==", "bodyText": "Do you have a question on why this is here?  On why we can't access Uphold if the blockchain is syncing?", "url": "https://github.com/dashevo/dash-wallet/pull/462#discussion_r457799930", "createdAt": "2020-07-21T02:32:25Z", "author": {"login": "HashEngineering"}, "path": "wallet/src/de/schildbach/wallet/ui/MoreFragment.kt", "diffHunk": "@@ -18,80 +18,59 @@ package de.schildbach.wallet.ui\n \n import android.content.Intent\n import android.os.Bundle\n-import android.view.MenuItem\n-import androidx.appcompat.widget.Toolbar\n+import android.view.View\n+import androidx.fragment.app.Fragment\n import androidx.lifecycle.Observer\n import de.schildbach.wallet.AppDatabase\n import de.schildbach.wallet.WalletApplication\n import de.schildbach.wallet.data.BlockchainState\n-import de.schildbach.wallet.util.showBlockchainSyncingMessage\n import de.schildbach.wallet_test.R\n import kotlinx.android.synthetic.main.activity_more.*\n import org.dash.wallet.integration.uphold.ui.UpholdAccountActivity\n \n-class MoreActivity : GlobalFooterActivity() {\n+class MoreFragment : Fragment(R.layout.activity_more) {\n \n     private var blockchainState: BlockchainState? = null\n \n-    override fun onCreate(savedInstanceState: Bundle?) {\n-        super.onCreate(savedInstanceState)\n-        setContentViewWithFooter(R.layout.activity_more)\n-        activateMoreButton()\n+    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n+        super.onViewCreated(view, savedInstanceState)\n \n-        val toolbar = findViewById<Toolbar>(R.id.toolbar)\n-        setSupportActionBar(toolbar)\n-        val actionBar = supportActionBar\n-        actionBar?.apply {\n-            setDisplayHomeAsUpEnabled(true)\n-            setDisplayShowHomeEnabled(true)\n-        }\n-\n-        setTitle(R.string.more_title)\n-\n-        AppDatabase.getAppDatabase().blockchainStateDao().load().observe(this, Observer {\n+        setupActionBarWithTitle(R.string.more_title)\n+        AppDatabase.getAppDatabase().blockchainStateDao().load().observe(viewLifecycleOwner, Observer {\n             blockchainState = it\n         })\n \n         buy_and_sell.setOnClickListener {\n             if (blockchainState != null && blockchainState?.replaying!!) {\n-                showBlockchainSyncingMessage()\n+                //TODO: ???\n+                //showBlockchainSyncingMessage()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0320dd9a2b16e4eb92b9f4cfc4960477e19e0fb9"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE4MDk3Nw==", "bodyText": "I wasn't finding this method. It's on ActivityExtensions. Fixed on ce35cda.", "url": "https://github.com/dashevo/dash-wallet/pull/462#discussion_r459180977", "createdAt": "2020-07-23T02:13:49Z", "author": {"login": "sambarboza"}, "path": "wallet/src/de/schildbach/wallet/ui/MoreFragment.kt", "diffHunk": "@@ -18,80 +18,59 @@ package de.schildbach.wallet.ui\n \n import android.content.Intent\n import android.os.Bundle\n-import android.view.MenuItem\n-import androidx.appcompat.widget.Toolbar\n+import android.view.View\n+import androidx.fragment.app.Fragment\n import androidx.lifecycle.Observer\n import de.schildbach.wallet.AppDatabase\n import de.schildbach.wallet.WalletApplication\n import de.schildbach.wallet.data.BlockchainState\n-import de.schildbach.wallet.util.showBlockchainSyncingMessage\n import de.schildbach.wallet_test.R\n import kotlinx.android.synthetic.main.activity_more.*\n import org.dash.wallet.integration.uphold.ui.UpholdAccountActivity\n \n-class MoreActivity : GlobalFooterActivity() {\n+class MoreFragment : Fragment(R.layout.activity_more) {\n \n     private var blockchainState: BlockchainState? = null\n \n-    override fun onCreate(savedInstanceState: Bundle?) {\n-        super.onCreate(savedInstanceState)\n-        setContentViewWithFooter(R.layout.activity_more)\n-        activateMoreButton()\n+    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n+        super.onViewCreated(view, savedInstanceState)\n \n-        val toolbar = findViewById<Toolbar>(R.id.toolbar)\n-        setSupportActionBar(toolbar)\n-        val actionBar = supportActionBar\n-        actionBar?.apply {\n-            setDisplayHomeAsUpEnabled(true)\n-            setDisplayShowHomeEnabled(true)\n-        }\n-\n-        setTitle(R.string.more_title)\n-\n-        AppDatabase.getAppDatabase().blockchainStateDao().load().observe(this, Observer {\n+        setupActionBarWithTitle(R.string.more_title)\n+        AppDatabase.getAppDatabase().blockchainStateDao().load().observe(viewLifecycleOwner, Observer {\n             blockchainState = it\n         })\n \n         buy_and_sell.setOnClickListener {\n             if (blockchainState != null && blockchainState?.replaying!!) {\n-                showBlockchainSyncingMessage()\n+                //TODO: ???\n+                //showBlockchainSyncingMessage()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc5OTkzMA=="}, "originalCommit": {"oid": "0320dd9a2b16e4eb92b9f4cfc4960477e19e0fb9"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1Njc4NTQyOnYy", "diffSide": "RIGHT", "path": "wallet/src/de/schildbach/wallet/ui/RequestCoinsActivity.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwMjo1OTo0M1rOG0mUjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwMjo1OTo0M1rOG0mUjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgwNjk4OA==", "bodyText": "here is an unneeded comment", "url": "https://github.com/dashevo/dash-wallet/pull/462#discussion_r457806988", "createdAt": "2020-07-21T02:59:43Z", "author": {"login": "HashEngineering"}, "path": "wallet/src/de/schildbach/wallet/ui/RequestCoinsActivity.java", "diffHunk": "@@ -34,7 +34,8 @@\n     protected void onCreate(final Bundle savedInstanceState) {\n         super.onCreate(savedInstanceState);\n \n-        setContentViewWithFooter(R.layout.request_coins_content);\n+        setContentView(R.layout.request_coins_content);\n+        //setContentViewWithFooter(R.layout.request_coins_content);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0320dd9a2b16e4eb92b9f4cfc4960477e19e0fb9"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1Njc4NzkzOnYy", "diffSide": "RIGHT", "path": "wallet/src/de/schildbach/wallet/ui/PaymentsFragment.kt", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwMzowMTowOFrOG0mV7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QwMjowODo0MFrOG16HXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgwNzM0Mg==", "bodyText": "This is probably a future story?", "url": "https://github.com/dashevo/dash-wallet/pull/462#discussion_r457807342", "createdAt": "2020-07-21T03:01:08Z", "author": {"login": "HashEngineering"}, "path": "wallet/src/de/schildbach/wallet/ui/PaymentsFragment.kt", "diffHunk": "@@ -17,46 +17,50 @@\n package de.schildbach.wallet.ui\n \n import android.content.Context\n-import android.content.Intent\n import android.os.Bundle\n import android.view.Menu\n-import android.view.MenuItem\n-import androidx.appcompat.widget.Toolbar\n+import android.view.MenuInflater\n+import android.view.View\n+import androidx.fragment.app.Fragment\n import com.google.android.material.tabs.TabLayout\n import de.schildbach.wallet_test.R\n import kotlinx.android.synthetic.main.activity_payments.*\n \n-class PaymentsActivity : GlobalFooterActivity() {\n+class PaymentsFragment : Fragment(R.layout.activity_payments) {\n \n     companion object {\n         private const val PREFS_RECENT_TAB = \"recent_tab\"\n-\n-        private const val EXTRA_ACTIVE_TAB = \"extra_active_tab\"\n+        private const val ARGS_ACTIVE_TAB = \"extra_active_tab\"\n \n         const val ACTIVE_TAB_RECENT = -1\n         const val ACTIVE_TAB_PAY = 0\n         const val ACTIVE_TAB_RECEIVE = 1\n \n         @JvmStatic\n-        fun createIntent(context: Context, activeTab: Int): Intent {\n-            val intent = Intent(context, PaymentsActivity::class.java)\n-            intent.putExtra(EXTRA_ACTIVE_TAB, activeTab)\n-            return intent\n+        fun newInstance(activeTab: Int = ACTIVE_TAB_RECENT): PaymentsFragment {\n+            val args = Bundle()\n+            args.putInt(ARGS_ACTIVE_TAB, activeTab)\n+\n+            val instance = PaymentsFragment()\n+            instance.arguments = args\n+            return instance\n         }\n     }\n \n     private var saveRecentTab = false\n \n     override fun onCreate(savedInstanceState: Bundle?) {\n         super.onCreate(savedInstanceState)\n-        setContentViewWithFooter(R.layout.activity_payments)\n-        activateGotoButton()\n+        setHasOptionsMenu(true)\n+    }\n \n-        val toolbar = findViewById<Toolbar>(R.id.toolbar)\n-        setSupportActionBar(toolbar)\n+    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n+        super.onViewCreated(view, savedInstanceState)\n \n-        setTitle(R.string.payments_title)\n+        toolbar.setTitle(R.string.payments_title)\n+        setupActionBarWithTitle(R.string.payments_title, false)\n \n+        //TODO: Implement FragmentViewPager", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0320dd9a2b16e4eb92b9f4cfc4960477e19e0fb9"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE3OTg3MQ==", "bodyText": "Yes, implementing a FragmentViewPager on this screen would allow for smoother switching between Send / Received.", "url": "https://github.com/dashevo/dash-wallet/pull/462#discussion_r459179871", "createdAt": "2020-07-23T02:08:40Z", "author": {"login": "sambarboza"}, "path": "wallet/src/de/schildbach/wallet/ui/PaymentsFragment.kt", "diffHunk": "@@ -17,46 +17,50 @@\n package de.schildbach.wallet.ui\n \n import android.content.Context\n-import android.content.Intent\n import android.os.Bundle\n import android.view.Menu\n-import android.view.MenuItem\n-import androidx.appcompat.widget.Toolbar\n+import android.view.MenuInflater\n+import android.view.View\n+import androidx.fragment.app.Fragment\n import com.google.android.material.tabs.TabLayout\n import de.schildbach.wallet_test.R\n import kotlinx.android.synthetic.main.activity_payments.*\n \n-class PaymentsActivity : GlobalFooterActivity() {\n+class PaymentsFragment : Fragment(R.layout.activity_payments) {\n \n     companion object {\n         private const val PREFS_RECENT_TAB = \"recent_tab\"\n-\n-        private const val EXTRA_ACTIVE_TAB = \"extra_active_tab\"\n+        private const val ARGS_ACTIVE_TAB = \"extra_active_tab\"\n \n         const val ACTIVE_TAB_RECENT = -1\n         const val ACTIVE_TAB_PAY = 0\n         const val ACTIVE_TAB_RECEIVE = 1\n \n         @JvmStatic\n-        fun createIntent(context: Context, activeTab: Int): Intent {\n-            val intent = Intent(context, PaymentsActivity::class.java)\n-            intent.putExtra(EXTRA_ACTIVE_TAB, activeTab)\n-            return intent\n+        fun newInstance(activeTab: Int = ACTIVE_TAB_RECENT): PaymentsFragment {\n+            val args = Bundle()\n+            args.putInt(ARGS_ACTIVE_TAB, activeTab)\n+\n+            val instance = PaymentsFragment()\n+            instance.arguments = args\n+            return instance\n         }\n     }\n \n     private var saveRecentTab = false\n \n     override fun onCreate(savedInstanceState: Bundle?) {\n         super.onCreate(savedInstanceState)\n-        setContentViewWithFooter(R.layout.activity_payments)\n-        activateGotoButton()\n+        setHasOptionsMenu(true)\n+    }\n \n-        val toolbar = findViewById<Toolbar>(R.id.toolbar)\n-        setSupportActionBar(toolbar)\n+    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n+        super.onViewCreated(view, savedInstanceState)\n \n-        setTitle(R.string.payments_title)\n+        toolbar.setTitle(R.string.payments_title)\n+        setupActionBarWithTitle(R.string.payments_title, false)\n \n+        //TODO: Implement FragmentViewPager", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgwNzM0Mg=="}, "originalCommit": {"oid": "0320dd9a2b16e4eb92b9f4cfc4960477e19e0fb9"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1Njc4ODQxOnYy", "diffSide": "RIGHT", "path": "wallet/src/de/schildbach/wallet/ui/WalletFragment.kt", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwMzowMTozMlrOG0mWQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QwMjowOTo0M1rOG16IJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgwNzQyNA==", "bodyText": "Future story?", "url": "https://github.com/dashevo/dash-wallet/pull/462#discussion_r457807424", "createdAt": "2020-07-21T03:01:32Z", "author": {"login": "HashEngineering"}, "path": "wallet/src/de/schildbach/wallet/ui/WalletFragment.kt", "diffHunk": "@@ -0,0 +1,342 @@\n+package de.schildbach.wallet.ui\n+\n+import android.app.Activity\n+import android.content.ClipDescription\n+import android.content.ClipboardManager\n+import android.content.Context\n+import android.content.Intent\n+import android.os.Bundle\n+import android.view.View\n+import androidx.coordinatorlayout.widget.CoordinatorLayout\n+import androidx.core.content.ContextCompat\n+import androidx.fragment.app.Fragment\n+import androidx.lifecycle.Observer\n+import androidx.lifecycle.ViewModelProvider\n+import androidx.lifecycle.ViewModelProviders\n+import com.google.android.material.appbar.AppBarLayout\n+import com.google.android.material.appbar.AppBarLayout.Behavior.DragCallback\n+import de.schildbach.wallet.AppDatabase\n+import de.schildbach.wallet.Constants\n+import de.schildbach.wallet.WalletApplication\n+import de.schildbach.wallet.data.BlockchainIdentityBaseData\n+import de.schildbach.wallet.data.BlockchainIdentityData\n+import de.schildbach.wallet.data.BlockchainState\n+import de.schildbach.wallet.data.PaymentIntent\n+import de.schildbach.wallet.livedata.Resource\n+import de.schildbach.wallet.livedata.Status\n+import de.schildbach.wallet.ui.CheckPinDialog.Companion.show\n+import de.schildbach.wallet.ui.InputParser.StringInputParser\n+import de.schildbach.wallet.ui.MainActivity.Companion.REQUEST_CODE_SCAN\n+import de.schildbach.wallet.ui.PaymentsFragment.Companion.ACTIVE_TAB_PAY\n+import de.schildbach.wallet.ui.PaymentsFragment.Companion.ACTIVE_TAB_RECEIVE\n+import de.schildbach.wallet.ui.VerifySeedActivity.Companion.createIntent\n+import de.schildbach.wallet.ui.dashpay.CreateIdentityService.Companion.createIntentForRetry\n+import de.schildbach.wallet.ui.dashpay.DashPayViewModel\n+import de.schildbach.wallet.ui.scan.ScanActivity\n+import de.schildbach.wallet.ui.send.SendCoinsInternalActivity\n+import de.schildbach.wallet.ui.send.SweepWalletActivity\n+import de.schildbach.wallet_test.R\n+import kotlinx.android.synthetic.main.home_content.*\n+import kotlinx.android.synthetic.main.quick_actions_layout.*\n+import kotlinx.android.synthetic.main.sync_status_pane.*\n+import org.bitcoinj.core.Coin\n+import org.bitcoinj.core.PrefixedChecksummedBytes\n+import org.bitcoinj.core.Transaction\n+import org.bitcoinj.core.VerificationException\n+import org.bitcoinj.wallet.Wallet\n+import org.bitcoinj.wallet.listeners.WalletCoinsReceivedEventListener\n+import org.bitcoinj.wallet.listeners.WalletCoinsSentEventListener\n+import org.dash.wallet.integration.uphold.ui.UpholdAccountActivity\n+\n+class WalletFragment : Fragment(R.layout.home_content) {\n+\n+    private var clipboardManager: ClipboardManager? = null\n+    private var blockchainState: BlockchainState? = null\n+    private var syncComplete = false\n+    private var dashPayViewModel: DashPayViewModel? = null\n+    private var isPlatformAvailable = false\n+    private var noIdentityCreatedOrInProgress = true\n+    private var retryCreationIfInProgress = true\n+\n+    private val walletApplication by lazy { WalletApplication.getInstance() }\n+    private val wallet by lazy { walletApplication.wallet }\n+    private val config by lazy { walletApplication.configuration }\n+    private val coinsSendReceivedListener = OnCoinsSentReceivedListener()\n+\n+    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n+        super.onViewCreated(view, savedInstanceState)\n+        initView()\n+        initViewModel()\n+        clipboardManager = activity?.getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager?\n+\n+        val appBar: View = app_bar\n+        val params = appBar.layoutParams as CoordinatorLayout.LayoutParams\n+        if (params.behavior == null) {\n+            params.behavior = AppBarLayout.Behavior()\n+        }\n+        val behaviour = params.behavior as AppBarLayout.Behavior?\n+        behaviour!!.setDragCallback(object : DragCallback() {\n+            override fun canDrag(appBarLayout: AppBarLayout): Boolean {\n+                //TODO: WalletFragment and WalletTransactionsFragment can probably be merged.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0320dd9a2b16e4eb92b9f4cfc4960477e19e0fb9"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTE4MDA2OA==", "bodyText": "Yes, merging these two fragments would make the code cleaner and possibily smaller, also, these two fragments can't exist separately in our app.", "url": "https://github.com/dashevo/dash-wallet/pull/462#discussion_r459180068", "createdAt": "2020-07-23T02:09:43Z", "author": {"login": "sambarboza"}, "path": "wallet/src/de/schildbach/wallet/ui/WalletFragment.kt", "diffHunk": "@@ -0,0 +1,342 @@\n+package de.schildbach.wallet.ui\n+\n+import android.app.Activity\n+import android.content.ClipDescription\n+import android.content.ClipboardManager\n+import android.content.Context\n+import android.content.Intent\n+import android.os.Bundle\n+import android.view.View\n+import androidx.coordinatorlayout.widget.CoordinatorLayout\n+import androidx.core.content.ContextCompat\n+import androidx.fragment.app.Fragment\n+import androidx.lifecycle.Observer\n+import androidx.lifecycle.ViewModelProvider\n+import androidx.lifecycle.ViewModelProviders\n+import com.google.android.material.appbar.AppBarLayout\n+import com.google.android.material.appbar.AppBarLayout.Behavior.DragCallback\n+import de.schildbach.wallet.AppDatabase\n+import de.schildbach.wallet.Constants\n+import de.schildbach.wallet.WalletApplication\n+import de.schildbach.wallet.data.BlockchainIdentityBaseData\n+import de.schildbach.wallet.data.BlockchainIdentityData\n+import de.schildbach.wallet.data.BlockchainState\n+import de.schildbach.wallet.data.PaymentIntent\n+import de.schildbach.wallet.livedata.Resource\n+import de.schildbach.wallet.livedata.Status\n+import de.schildbach.wallet.ui.CheckPinDialog.Companion.show\n+import de.schildbach.wallet.ui.InputParser.StringInputParser\n+import de.schildbach.wallet.ui.MainActivity.Companion.REQUEST_CODE_SCAN\n+import de.schildbach.wallet.ui.PaymentsFragment.Companion.ACTIVE_TAB_PAY\n+import de.schildbach.wallet.ui.PaymentsFragment.Companion.ACTIVE_TAB_RECEIVE\n+import de.schildbach.wallet.ui.VerifySeedActivity.Companion.createIntent\n+import de.schildbach.wallet.ui.dashpay.CreateIdentityService.Companion.createIntentForRetry\n+import de.schildbach.wallet.ui.dashpay.DashPayViewModel\n+import de.schildbach.wallet.ui.scan.ScanActivity\n+import de.schildbach.wallet.ui.send.SendCoinsInternalActivity\n+import de.schildbach.wallet.ui.send.SweepWalletActivity\n+import de.schildbach.wallet_test.R\n+import kotlinx.android.synthetic.main.home_content.*\n+import kotlinx.android.synthetic.main.quick_actions_layout.*\n+import kotlinx.android.synthetic.main.sync_status_pane.*\n+import org.bitcoinj.core.Coin\n+import org.bitcoinj.core.PrefixedChecksummedBytes\n+import org.bitcoinj.core.Transaction\n+import org.bitcoinj.core.VerificationException\n+import org.bitcoinj.wallet.Wallet\n+import org.bitcoinj.wallet.listeners.WalletCoinsReceivedEventListener\n+import org.bitcoinj.wallet.listeners.WalletCoinsSentEventListener\n+import org.dash.wallet.integration.uphold.ui.UpholdAccountActivity\n+\n+class WalletFragment : Fragment(R.layout.home_content) {\n+\n+    private var clipboardManager: ClipboardManager? = null\n+    private var blockchainState: BlockchainState? = null\n+    private var syncComplete = false\n+    private var dashPayViewModel: DashPayViewModel? = null\n+    private var isPlatformAvailable = false\n+    private var noIdentityCreatedOrInProgress = true\n+    private var retryCreationIfInProgress = true\n+\n+    private val walletApplication by lazy { WalletApplication.getInstance() }\n+    private val wallet by lazy { walletApplication.wallet }\n+    private val config by lazy { walletApplication.configuration }\n+    private val coinsSendReceivedListener = OnCoinsSentReceivedListener()\n+\n+    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {\n+        super.onViewCreated(view, savedInstanceState)\n+        initView()\n+        initViewModel()\n+        clipboardManager = activity?.getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager?\n+\n+        val appBar: View = app_bar\n+        val params = appBar.layoutParams as CoordinatorLayout.LayoutParams\n+        if (params.behavior == null) {\n+            params.behavior = AppBarLayout.Behavior()\n+        }\n+        val behaviour = params.behavior as AppBarLayout.Behavior?\n+        behaviour!!.setDragCallback(object : DragCallback() {\n+            override fun canDrag(appBarLayout: AppBarLayout): Boolean {\n+                //TODO: WalletFragment and WalletTransactionsFragment can probably be merged.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgwNzQyNA=="}, "originalCommit": {"oid": "0320dd9a2b16e4eb92b9f4cfc4960477e19e0fb9"}, "originalPosition": 80}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 558, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}