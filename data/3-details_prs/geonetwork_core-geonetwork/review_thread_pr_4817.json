{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQyNzg0ODk5", "number": 4817, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxMzo0MDoxM1rOEqUqwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwNzo0MToyN1rOExFv_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyODE0MjcyOnYy", "diffSide": "RIGHT", "path": "domain/src/main/java/org/fao/geonet/repository/GroupRepositoryCustom.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxMzo0MDoxM1rOHcdjIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQyMDozNDo1NFrOHdY8Jw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTYwNjMwNA==", "bodyText": "Is this required or can be updated the code that uses this method to use Integer.parseInt?", "url": "https://github.com/geonetwork/core-geonetwork/pull/4817#discussion_r499606304", "createdAt": "2020-10-05T13:40:13Z", "author": {"login": "josegar74"}, "path": "domain/src/main/java/org/fao/geonet/repository/GroupRepositoryCustom.java", "diffHunk": "@@ -36,6 +37,16 @@\n  * @author Jesse\n  */\n public interface GroupRepositoryCustom {\n+    /**\n+     * Find the group with the given groupId (where groupId is a string).  The string will be converted\n+     * to an integer for making the query.\n+     *\n+     * @param groupId the groupid.\n+     * @return the group with the given groupid\n+     */\n+    @Nullable\n+    Group findOne(@Nonnull String groupId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "41d89b2b3dd6b38775af1a3256a5b3c6071bd92c"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDU3OTM2Nw==", "bodyText": "Looks like I did not need it at all as it was starting with an numeric id.\nReverted the changes and fixed code to use numeric id.", "url": "https://github.com/geonetwork/core-geonetwork/pull/4817#discussion_r500579367", "createdAt": "2020-10-06T20:34:54Z", "author": {"login": "ianwallen"}, "path": "domain/src/main/java/org/fao/geonet/repository/GroupRepositoryCustom.java", "diffHunk": "@@ -36,6 +37,16 @@\n  * @author Jesse\n  */\n public interface GroupRepositoryCustom {\n+    /**\n+     * Find the group with the given groupId (where groupId is a string).  The string will be converted\n+     * to an integer for making the query.\n+     *\n+     * @param groupId the groupid.\n+     * @return the group with the given groupid\n+     */\n+    @Nullable\n+    Group findOne(@Nonnull String groupId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTYwNjMwNA=="}, "originalCommit": {"oid": "41d89b2b3dd6b38775af1a3256a5b3c6071bd92c"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyODE5ODA5OnYy", "diffSide": "RIGHT", "path": "listeners/src/main/java/org/fao/geonet/listener/metadata/draft/DraftUtilities.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxMzo1MjozMFrOHceFWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQyMDozNDo0NlrOHdY77w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTYxNTA2Ng==", "bodyText": "Indentation", "url": "https://github.com/geonetwork/core-geonetwork/pull/4817#discussion_r499615066", "createdAt": "2020-10-05T13:52:30Z", "author": {"login": "josegar74"}, "path": "listeners/src/main/java/org/fao/geonet/listener/metadata/draft/DraftUtilities.java", "diffHunk": "@@ -111,12 +112,17 @@ public AbstractMetadata replaceMetadataWithDraft(AbstractMetadata md, AbstractMe\n             st.setOwner(old.getOwner());\n             st.setPreviousState(old.getPreviousState());\n             st.setStatusValue(old.getStatusValue());\n-            MetadataStatusId id = new MetadataStatusId();\n-            id.setChangeDate(old.getId().getChangeDate());\n-            id.setStatusId(old.getId().getStatusId());\n-            id.setUserId(old.getId().getUserId());\n-            id.setMetadataId(md.getId());\n-            st.setId(id);\n+            st.setChangeDate(old.getChangeDate());\n+            st.setUserId(old.getUserId());\n+            st.setMetadataId(md.getId());\n+            st.setUuid(md.getUuid());\n+            try {\n+            st.setTitles(metadataUtils.extractTitles(Integer.toString(md.getId())));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "41d89b2b3dd6b38775af1a3256a5b3c6071bd92c"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDU3OTMxMQ==", "bodyText": "fixed", "url": "https://github.com/geonetwork/core-geonetwork/pull/4817#discussion_r500579311", "createdAt": "2020-10-06T20:34:46Z", "author": {"login": "ianwallen"}, "path": "listeners/src/main/java/org/fao/geonet/listener/metadata/draft/DraftUtilities.java", "diffHunk": "@@ -111,12 +112,17 @@ public AbstractMetadata replaceMetadataWithDraft(AbstractMetadata md, AbstractMe\n             st.setOwner(old.getOwner());\n             st.setPreviousState(old.getPreviousState());\n             st.setStatusValue(old.getStatusValue());\n-            MetadataStatusId id = new MetadataStatusId();\n-            id.setChangeDate(old.getId().getChangeDate());\n-            id.setStatusId(old.getId().getStatusId());\n-            id.setUserId(old.getId().getUserId());\n-            id.setMetadataId(md.getId());\n-            st.setId(id);\n+            st.setChangeDate(old.getChangeDate());\n+            st.setUserId(old.getUserId());\n+            st.setMetadataId(md.getId());\n+            st.setUuid(md.getUuid());\n+            try {\n+            st.setTitles(metadataUtils.extractTitles(Integer.toString(md.getId())));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTYxNTA2Ng=="}, "originalCommit": {"oid": "41d89b2b3dd6b38775af1a3256a5b3c6071bd92c"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyODIyODg5OnYy", "diffSide": "RIGHT", "path": "schemas/dublin-core/src/main/plugin/dublin-core/extract-titles.xsl", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxMzo1OToxNFrOHceYCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQyMDozNDozNVrOHdY7ig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTYxOTg0OA==", "bodyText": "The cardinality of dc:language and dc:title can be higher than 1, not critical as in most cases will be only 1 value, but to check to get the first entry.", "url": "https://github.com/geonetwork/core-geonetwork/pull/4817#discussion_r499619848", "createdAt": "2020-10-05T13:59:14Z", "author": {"login": "josegar74"}, "path": "schemas/dublin-core/src/main/plugin/dublin-core/extract-titles.xsl", "diffHunk": "@@ -0,0 +1,39 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<!--\n+  ~ Copyright (C) 2001-2016 Food and Agriculture Organization of the\n+  ~ United Nations (FAO-UN), United Nations World Food Programme (WFP)\n+  ~ and United Nations Environment Programme (UNEP)\n+  ~\n+  ~ This program is free software; you can redistribute it and/or modify\n+  ~ it under the terms of the GNU General Public License as published by\n+  ~ the Free Software Foundation; either version 2 of the License, or (at\n+  ~ your option) any later version.\n+  ~\n+  ~ This program is distributed in the hope that it will be useful, but\n+  ~ WITHOUT ANY WARRANTY; without even the implied warranty of\n+  ~ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+  ~ General Public License for more details.\n+  ~\n+  ~ You should have received a copy of the GNU General Public License\n+  ~ along with this program; if not, write to the Free Software\n+  ~ Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA\n+  ~\n+  ~ Contact: Jeroen Ticheler - FAO - Viale delle Terme di Caracalla 2,\n+  ~ Rome - Italy. email: geonetwork@osgeo.org\n+  -->\n+\n+<xsl:stylesheet xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\n+                xmlns:dc=\"http://purl.org/dc/elements/1.1/\"\n+                version=\"1.0\">\n+\n+  <xsl:template match=\"simpledc\">\n+    <titles>\n+      <title>\n+        <xsl:attribute name=\"lang\"><xsl:value-of select=\"dc:language\"/></xsl:attribute>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "41d89b2b3dd6b38775af1a3256a5b3c6071bd92c"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDU3OTIxMA==", "bodyText": "Fixed", "url": "https://github.com/geonetwork/core-geonetwork/pull/4817#discussion_r500579210", "createdAt": "2020-10-06T20:34:35Z", "author": {"login": "ianwallen"}, "path": "schemas/dublin-core/src/main/plugin/dublin-core/extract-titles.xsl", "diffHunk": "@@ -0,0 +1,39 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<!--\n+  ~ Copyright (C) 2001-2016 Food and Agriculture Organization of the\n+  ~ United Nations (FAO-UN), United Nations World Food Programme (WFP)\n+  ~ and United Nations Environment Programme (UNEP)\n+  ~\n+  ~ This program is free software; you can redistribute it and/or modify\n+  ~ it under the terms of the GNU General Public License as published by\n+  ~ the Free Software Foundation; either version 2 of the License, or (at\n+  ~ your option) any later version.\n+  ~\n+  ~ This program is distributed in the hope that it will be useful, but\n+  ~ WITHOUT ANY WARRANTY; without even the implied warranty of\n+  ~ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+  ~ General Public License for more details.\n+  ~\n+  ~ You should have received a copy of the GNU General Public License\n+  ~ along with this program; if not, write to the Free Software\n+  ~ Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA\n+  ~\n+  ~ Contact: Jeroen Ticheler - FAO - Viale delle Terme di Caracalla 2,\n+  ~ Rome - Italy. email: geonetwork@osgeo.org\n+  -->\n+\n+<xsl:stylesheet xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\n+                xmlns:dc=\"http://purl.org/dc/elements/1.1/\"\n+                version=\"1.0\">\n+\n+  <xsl:template match=\"simpledc\">\n+    <titles>\n+      <title>\n+        <xsl:attribute name=\"lang\"><xsl:value-of select=\"dc:language\"/></xsl:attribute>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTYxOTg0OA=="}, "originalCommit": {"oid": "41d89b2b3dd6b38775af1a3256a5b3c6071bd92c"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyODI5NzM2OnYy", "diffSide": "RIGHT", "path": "services/src/main/java/org/fao/geonet/api/records/MetadataWorkflowApi.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNDoxNDo1M1rOHcfCMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQyMToxOTozNlrOHewzKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTYzMDY0MQ==", "bodyText": "To check to refactor with the code https://github.com/geonetwork/core-geonetwork/pull/4817/files#diff-668fdf0a09c1a8afb5771c9e85715598R496-R506, seem the same code", "url": "https://github.com/geonetwork/core-geonetwork/pull/4817#discussion_r499630641", "createdAt": "2020-10-05T14:14:53Z", "author": {"login": "josegar74"}, "path": "services/src/main/java/org/fao/geonet/api/records/MetadataWorkflowApi.java", "diffHunk": "@@ -419,23 +442,268 @@ public MetadataStatus convertParameter(int id, MetadataStatusParameter parameter\n         return metadataStatus;\n     }\n \n+    @ApiOperation(\n+            value = \"Get saved content from the status record before changes\",\n+            notes = \"\",\n+            nickname = \"showStatusBefore\")\n+    @RequestMapping(\n+            value = \"/{metadataUuid}/status/{statusId:[0-9]+}.{userId:[0-9]+}.{changeDate}/before\",\n+            method = RequestMethod.GET,\n+            produces = {\n+                    MediaType.APPLICATION_XML_VALUE\n+            })\n+\n+    @PreAuthorize(\"hasRole('Editor')\")\n+    @ApiResponses(value = {\n+            @ApiResponse(code = 200, message = \"Previous version of the record.\"),\n+            @ApiResponse(code = 403, message = ApiParams.API_RESPONSE_NOT_ALLOWED_CAN_EDIT)\n+    })\n+    @ResponseStatus(HttpStatus.OK)\n+    @ResponseBody\n+    public String showStatusBefore(\n+            @ApiParam(value = API_PARAM_RECORD_UUID, required = true) @PathVariable String metadataUuid,\n+            @ApiParam(value = \"Status identifier\", required = true) @PathVariable int statusId,\n+            @ApiParam(value = \"User identifier\", required = true) @PathVariable int userId,\n+            @ApiParam(value = \"Change date\", required = true) @PathVariable String changeDate,\n+            @ApiIgnore @ApiParam(hidden = true) HttpSession httpSession, HttpServletRequest request\n+    )\n+            throws Exception {\n+\n+        MetadataStatus metadataStatus;\n+\n+        metadataStatus = metadataStatusRepository\n+                .findOneByUuidAndStatusValue_IdAndUserIdAndChangeDate(metadataUuid, statusId, userId, new ISODate(changeDate));\n+\n+        if (metadataStatus == null) {\n+            throw new ResourceNotFoundException(\n+                    String.format(\"Can't find metadata status for record '%d', user '%s' at date '%s'. Previous state cannot be viewed\", metadataUuid,\n+                            userId, changeDate));\n+        }\n+\n+        if (!StatusValueType.event.equals(metadataStatus.getStatusValue().getType()) || !ArrayUtils.contains(supportedRestoreStatuses, statusId)) {\n+            throw new NotAllowedException(\"Unsupported action on status type '\" + metadataStatus.getStatusValue().getType() + \"' for metadata '\" + metadataStatus.getUuid() + \"'. Supports status type '\" +\n+                    StatusValueType.event + \"' with the status id '\" + Arrays.toString(supportedRestoreStatuses) + \"'.\");\n+        }\n+\n+        if (metadataStatus.getPreviousState() == null) {\n+            throw new ResourceNotFoundException(\n+                    String.format(\"No data exists for previous state on metadata record '%d', user '%s' at date '%s'. Previous state cannot be viewed\", metadataUuid,\n+                            userId, changeDate));\n+        }\n+\n+        String fullMetadataText = metadataStatus.getPreviousState();\n+\n+        // If record exists then check if user has access.\n+        try {\n+            ApiUtils.canEditRecord(metadataUuid, request);\n+        } catch (SecurityException e) {\n+            Log.debug(API.LOG_MODULE_NAME, e.getMessage(), e);\n+            throw new NotAllowedException(ApiParams.API_RESPONSE_NOT_ALLOWED_CAN_VIEW);\n+        } catch (ResourceNotFoundException e) {\n+            // If metadata record does not exists then it was deleted so\n+            // we will only allow the administrator, owner to view the contents\n+            checkCanViewStatus(fullMetadataText, metadataStatus, httpSession, request);\n+        }\n+\n+        return fullMetadataText;\n+    }\n+\n+    @ApiOperation(\n+            value = \"Get saved content from the status record after changes\",\n+            notes = \"\",\n+            nickname = \"showStatusAfter\")\n+    @RequestMapping(value = \"/{metadataUuid}/status/{statusId:[0-9]+}.{userId:[0-9]+}.{changeDate}/after\",\n+            method = RequestMethod.GET,\n+            produces = {\n+                    MediaType.APPLICATION_XML_VALUE\n+            })\n+\n+    @PreAuthorize(\"hasRole('Editor')\")\n+    @ApiResponses(value = {\n+            @ApiResponse(code = 200, message = \"Version of the record after changes.\"),\n+            @ApiResponse(code = 403, message = ApiParams.API_RESPONSE_NOT_ALLOWED_CAN_EDIT)\n+    })\n+    @ResponseStatus(HttpStatus.OK)\n+    @ResponseBody\n+    public String showStatusAfter(\n+            @ApiParam(value = API_PARAM_RECORD_UUID, required = true) @PathVariable String metadataUuid,\n+            @ApiParam(value = \"Status identifier\", required = true) @PathVariable int statusId,\n+            @ApiParam(value = \"User identifier\", required = true) @PathVariable int userId,\n+            @ApiParam(value = \"Change date\", required = true) @PathVariable String changeDate,\n+            @ApiIgnore @ApiParam(hidden = true) HttpSession httpSession, HttpServletRequest request\n+    )\n+            throws Exception {\n+        MetadataStatus metadataStatus;\n+\n+        metadataStatus = metadataStatusRepository\n+                .findOneByUuidAndStatusValue_IdAndUserIdAndChangeDate(metadataUuid, statusId, userId, new ISODate(changeDate));\n+\n+        if (metadataStatus == null) {\n+            throw new ResourceNotFoundException(\n+                    String.format(\"Can't find metadata status for record '%d', user '%s' at date '%s'. Changes cannot be viewed\", metadataUuid,\n+                            userId, changeDate));\n+        }\n+\n+        if (!StatusValueType.event.equals(metadataStatus.getStatusValue().getType()) || !ArrayUtils.contains(supportedRestoreStatuses, statusId)) {\n+            throw new NotAllowedException(\"Unsupported action on status type '\" + metadataStatus.getStatusValue().getType() + \"' for metadata '\" + metadataStatus.getUuid() + \"'. Supports status type '\" +\n+                    StatusValueType.event + \"' with the status id '\" + Arrays.toString(supportedRestoreStatuses) + \"'.\");\n+        }\n+\n+        if (metadataStatus.getCurrentState() == null) {\n+            throw new ResourceNotFoundException(\n+                    String.format(\"No data exists for metadata record '%d', user '%s' at date '%s'. Changes state cannot be viewed\", metadataUuid,\n+                            userId, changeDate));\n+        }\n+\n+        String fullMetadataText = metadataStatus.getCurrentState();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "41d89b2b3dd6b38775af1a3256a5b3c6071bd92c"}, "originalPosition": 430}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjAxODg1Nw==", "bodyText": "refactored code for before/after api so that that they use common code.", "url": "https://github.com/geonetwork/core-geonetwork/pull/4817#discussion_r502018857", "createdAt": "2020-10-08T21:19:36Z", "author": {"login": "ianwallen"}, "path": "services/src/main/java/org/fao/geonet/api/records/MetadataWorkflowApi.java", "diffHunk": "@@ -419,23 +442,268 @@ public MetadataStatus convertParameter(int id, MetadataStatusParameter parameter\n         return metadataStatus;\n     }\n \n+    @ApiOperation(\n+            value = \"Get saved content from the status record before changes\",\n+            notes = \"\",\n+            nickname = \"showStatusBefore\")\n+    @RequestMapping(\n+            value = \"/{metadataUuid}/status/{statusId:[0-9]+}.{userId:[0-9]+}.{changeDate}/before\",\n+            method = RequestMethod.GET,\n+            produces = {\n+                    MediaType.APPLICATION_XML_VALUE\n+            })\n+\n+    @PreAuthorize(\"hasRole('Editor')\")\n+    @ApiResponses(value = {\n+            @ApiResponse(code = 200, message = \"Previous version of the record.\"),\n+            @ApiResponse(code = 403, message = ApiParams.API_RESPONSE_NOT_ALLOWED_CAN_EDIT)\n+    })\n+    @ResponseStatus(HttpStatus.OK)\n+    @ResponseBody\n+    public String showStatusBefore(\n+            @ApiParam(value = API_PARAM_RECORD_UUID, required = true) @PathVariable String metadataUuid,\n+            @ApiParam(value = \"Status identifier\", required = true) @PathVariable int statusId,\n+            @ApiParam(value = \"User identifier\", required = true) @PathVariable int userId,\n+            @ApiParam(value = \"Change date\", required = true) @PathVariable String changeDate,\n+            @ApiIgnore @ApiParam(hidden = true) HttpSession httpSession, HttpServletRequest request\n+    )\n+            throws Exception {\n+\n+        MetadataStatus metadataStatus;\n+\n+        metadataStatus = metadataStatusRepository\n+                .findOneByUuidAndStatusValue_IdAndUserIdAndChangeDate(metadataUuid, statusId, userId, new ISODate(changeDate));\n+\n+        if (metadataStatus == null) {\n+            throw new ResourceNotFoundException(\n+                    String.format(\"Can't find metadata status for record '%d', user '%s' at date '%s'. Previous state cannot be viewed\", metadataUuid,\n+                            userId, changeDate));\n+        }\n+\n+        if (!StatusValueType.event.equals(metadataStatus.getStatusValue().getType()) || !ArrayUtils.contains(supportedRestoreStatuses, statusId)) {\n+            throw new NotAllowedException(\"Unsupported action on status type '\" + metadataStatus.getStatusValue().getType() + \"' for metadata '\" + metadataStatus.getUuid() + \"'. Supports status type '\" +\n+                    StatusValueType.event + \"' with the status id '\" + Arrays.toString(supportedRestoreStatuses) + \"'.\");\n+        }\n+\n+        if (metadataStatus.getPreviousState() == null) {\n+            throw new ResourceNotFoundException(\n+                    String.format(\"No data exists for previous state on metadata record '%d', user '%s' at date '%s'. Previous state cannot be viewed\", metadataUuid,\n+                            userId, changeDate));\n+        }\n+\n+        String fullMetadataText = metadataStatus.getPreviousState();\n+\n+        // If record exists then check if user has access.\n+        try {\n+            ApiUtils.canEditRecord(metadataUuid, request);\n+        } catch (SecurityException e) {\n+            Log.debug(API.LOG_MODULE_NAME, e.getMessage(), e);\n+            throw new NotAllowedException(ApiParams.API_RESPONSE_NOT_ALLOWED_CAN_VIEW);\n+        } catch (ResourceNotFoundException e) {\n+            // If metadata record does not exists then it was deleted so\n+            // we will only allow the administrator, owner to view the contents\n+            checkCanViewStatus(fullMetadataText, metadataStatus, httpSession, request);\n+        }\n+\n+        return fullMetadataText;\n+    }\n+\n+    @ApiOperation(\n+            value = \"Get saved content from the status record after changes\",\n+            notes = \"\",\n+            nickname = \"showStatusAfter\")\n+    @RequestMapping(value = \"/{metadataUuid}/status/{statusId:[0-9]+}.{userId:[0-9]+}.{changeDate}/after\",\n+            method = RequestMethod.GET,\n+            produces = {\n+                    MediaType.APPLICATION_XML_VALUE\n+            })\n+\n+    @PreAuthorize(\"hasRole('Editor')\")\n+    @ApiResponses(value = {\n+            @ApiResponse(code = 200, message = \"Version of the record after changes.\"),\n+            @ApiResponse(code = 403, message = ApiParams.API_RESPONSE_NOT_ALLOWED_CAN_EDIT)\n+    })\n+    @ResponseStatus(HttpStatus.OK)\n+    @ResponseBody\n+    public String showStatusAfter(\n+            @ApiParam(value = API_PARAM_RECORD_UUID, required = true) @PathVariable String metadataUuid,\n+            @ApiParam(value = \"Status identifier\", required = true) @PathVariable int statusId,\n+            @ApiParam(value = \"User identifier\", required = true) @PathVariable int userId,\n+            @ApiParam(value = \"Change date\", required = true) @PathVariable String changeDate,\n+            @ApiIgnore @ApiParam(hidden = true) HttpSession httpSession, HttpServletRequest request\n+    )\n+            throws Exception {\n+        MetadataStatus metadataStatus;\n+\n+        metadataStatus = metadataStatusRepository\n+                .findOneByUuidAndStatusValue_IdAndUserIdAndChangeDate(metadataUuid, statusId, userId, new ISODate(changeDate));\n+\n+        if (metadataStatus == null) {\n+            throw new ResourceNotFoundException(\n+                    String.format(\"Can't find metadata status for record '%d', user '%s' at date '%s'. Changes cannot be viewed\", metadataUuid,\n+                            userId, changeDate));\n+        }\n+\n+        if (!StatusValueType.event.equals(metadataStatus.getStatusValue().getType()) || !ArrayUtils.contains(supportedRestoreStatuses, statusId)) {\n+            throw new NotAllowedException(\"Unsupported action on status type '\" + metadataStatus.getStatusValue().getType() + \"' for metadata '\" + metadataStatus.getUuid() + \"'. Supports status type '\" +\n+                    StatusValueType.event + \"' with the status id '\" + Arrays.toString(supportedRestoreStatuses) + \"'.\");\n+        }\n+\n+        if (metadataStatus.getCurrentState() == null) {\n+            throw new ResourceNotFoundException(\n+                    String.format(\"No data exists for metadata record '%d', user '%s' at date '%s'. Changes state cannot be viewed\", metadataUuid,\n+                            userId, changeDate));\n+        }\n+\n+        String fullMetadataText = metadataStatus.getCurrentState();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTYzMDY0MQ=="}, "originalCommit": {"oid": "41d89b2b3dd6b38775af1a3256a5b3c6071bd92c"}, "originalPosition": 430}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyODMwMDg0OnYy", "diffSide": "RIGHT", "path": "services/src/main/java/org/fao/geonet/api/records/MetadataWorkflowApi.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNDoxNTo0MFrOHcfEag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQyMToxOTo0NVrOHewzdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTYzMTIxMA==", "bodyText": "To check to refactor with the code https://github.com/geonetwork/core-geonetwork/pull/4817/files#diff-668fdf0a09c1a8afb5771c9e85715598R496-R506, seem the same code", "url": "https://github.com/geonetwork/core-geonetwork/pull/4817#discussion_r499631210", "createdAt": "2020-10-05T14:15:40Z", "author": {"login": "josegar74"}, "path": "services/src/main/java/org/fao/geonet/api/records/MetadataWorkflowApi.java", "diffHunk": "@@ -419,23 +442,268 @@ public MetadataStatus convertParameter(int id, MetadataStatusParameter parameter\n         return metadataStatus;\n     }\n \n+    @ApiOperation(\n+            value = \"Get saved content from the status record before changes\",\n+            notes = \"\",\n+            nickname = \"showStatusBefore\")\n+    @RequestMapping(\n+            value = \"/{metadataUuid}/status/{statusId:[0-9]+}.{userId:[0-9]+}.{changeDate}/before\",\n+            method = RequestMethod.GET,\n+            produces = {\n+                    MediaType.APPLICATION_XML_VALUE\n+            })\n+\n+    @PreAuthorize(\"hasRole('Editor')\")\n+    @ApiResponses(value = {\n+            @ApiResponse(code = 200, message = \"Previous version of the record.\"),\n+            @ApiResponse(code = 403, message = ApiParams.API_RESPONSE_NOT_ALLOWED_CAN_EDIT)\n+    })\n+    @ResponseStatus(HttpStatus.OK)\n+    @ResponseBody\n+    public String showStatusBefore(\n+            @ApiParam(value = API_PARAM_RECORD_UUID, required = true) @PathVariable String metadataUuid,\n+            @ApiParam(value = \"Status identifier\", required = true) @PathVariable int statusId,\n+            @ApiParam(value = \"User identifier\", required = true) @PathVariable int userId,\n+            @ApiParam(value = \"Change date\", required = true) @PathVariable String changeDate,\n+            @ApiIgnore @ApiParam(hidden = true) HttpSession httpSession, HttpServletRequest request\n+    )\n+            throws Exception {\n+\n+        MetadataStatus metadataStatus;\n+\n+        metadataStatus = metadataStatusRepository\n+                .findOneByUuidAndStatusValue_IdAndUserIdAndChangeDate(metadataUuid, statusId, userId, new ISODate(changeDate));\n+\n+        if (metadataStatus == null) {\n+            throw new ResourceNotFoundException(\n+                    String.format(\"Can't find metadata status for record '%d', user '%s' at date '%s'. Previous state cannot be viewed\", metadataUuid,\n+                            userId, changeDate));\n+        }\n+\n+        if (!StatusValueType.event.equals(metadataStatus.getStatusValue().getType()) || !ArrayUtils.contains(supportedRestoreStatuses, statusId)) {\n+            throw new NotAllowedException(\"Unsupported action on status type '\" + metadataStatus.getStatusValue().getType() + \"' for metadata '\" + metadataStatus.getUuid() + \"'. Supports status type '\" +\n+                    StatusValueType.event + \"' with the status id '\" + Arrays.toString(supportedRestoreStatuses) + \"'.\");\n+        }\n+\n+        if (metadataStatus.getPreviousState() == null) {\n+            throw new ResourceNotFoundException(\n+                    String.format(\"No data exists for previous state on metadata record '%d', user '%s' at date '%s'. Previous state cannot be viewed\", metadataUuid,\n+                            userId, changeDate));\n+        }\n+\n+        String fullMetadataText = metadataStatus.getPreviousState();\n+\n+        // If record exists then check if user has access.\n+        try {\n+            ApiUtils.canEditRecord(metadataUuid, request);\n+        } catch (SecurityException e) {\n+            Log.debug(API.LOG_MODULE_NAME, e.getMessage(), e);\n+            throw new NotAllowedException(ApiParams.API_RESPONSE_NOT_ALLOWED_CAN_VIEW);\n+        } catch (ResourceNotFoundException e) {\n+            // If metadata record does not exists then it was deleted so\n+            // we will only allow the administrator, owner to view the contents\n+            checkCanViewStatus(fullMetadataText, metadataStatus, httpSession, request);\n+        }\n+\n+        return fullMetadataText;\n+    }\n+\n+    @ApiOperation(\n+            value = \"Get saved content from the status record after changes\",\n+            notes = \"\",\n+            nickname = \"showStatusAfter\")\n+    @RequestMapping(value = \"/{metadataUuid}/status/{statusId:[0-9]+}.{userId:[0-9]+}.{changeDate}/after\",\n+            method = RequestMethod.GET,\n+            produces = {\n+                    MediaType.APPLICATION_XML_VALUE\n+            })\n+\n+    @PreAuthorize(\"hasRole('Editor')\")\n+    @ApiResponses(value = {\n+            @ApiResponse(code = 200, message = \"Version of the record after changes.\"),\n+            @ApiResponse(code = 403, message = ApiParams.API_RESPONSE_NOT_ALLOWED_CAN_EDIT)\n+    })\n+    @ResponseStatus(HttpStatus.OK)\n+    @ResponseBody\n+    public String showStatusAfter(\n+            @ApiParam(value = API_PARAM_RECORD_UUID, required = true) @PathVariable String metadataUuid,\n+            @ApiParam(value = \"Status identifier\", required = true) @PathVariable int statusId,\n+            @ApiParam(value = \"User identifier\", required = true) @PathVariable int userId,\n+            @ApiParam(value = \"Change date\", required = true) @PathVariable String changeDate,\n+            @ApiIgnore @ApiParam(hidden = true) HttpSession httpSession, HttpServletRequest request\n+    )\n+            throws Exception {\n+        MetadataStatus metadataStatus;\n+\n+        metadataStatus = metadataStatusRepository\n+                .findOneByUuidAndStatusValue_IdAndUserIdAndChangeDate(metadataUuid, statusId, userId, new ISODate(changeDate));\n+\n+        if (metadataStatus == null) {\n+            throw new ResourceNotFoundException(\n+                    String.format(\"Can't find metadata status for record '%d', user '%s' at date '%s'. Changes cannot be viewed\", metadataUuid,\n+                            userId, changeDate));\n+        }\n+\n+        if (!StatusValueType.event.equals(metadataStatus.getStatusValue().getType()) || !ArrayUtils.contains(supportedRestoreStatuses, statusId)) {\n+            throw new NotAllowedException(\"Unsupported action on status type '\" + metadataStatus.getStatusValue().getType() + \"' for metadata '\" + metadataStatus.getUuid() + \"'. Supports status type '\" +\n+                    StatusValueType.event + \"' with the status id '\" + Arrays.toString(supportedRestoreStatuses) + \"'.\");\n+        }\n+\n+        if (metadataStatus.getCurrentState() == null) {\n+            throw new ResourceNotFoundException(\n+                    String.format(\"No data exists for metadata record '%d', user '%s' at date '%s'. Changes state cannot be viewed\", metadataUuid,\n+                            userId, changeDate));\n+        }\n+\n+        String fullMetadataText = metadataStatus.getCurrentState();\n+\n+        // If record exists then check if user has access.\n+        try {\n+            ApiUtils.canEditRecord(metadataUuid, request);\n+        } catch (SecurityException e) {\n+            Log.debug(API.LOG_MODULE_NAME, e.getMessage(), e);\n+            throw new NotAllowedException(ApiParams.API_RESPONSE_NOT_ALLOWED_CAN_VIEW);\n+        } catch (ResourceNotFoundException e) {\n+            // If metadata record does not exists then it was deleted so\n+            // we will only allow the administrator, owner to view the contents\n+            checkCanViewStatus(fullMetadataText, metadataStatus, httpSession, request);\n+        }\n+\n+        return fullMetadataText;\n+    }\n+\n+    @ApiOperation(\n+            value = \"Restore saved content from a status record\",\n+            notes = \"\",\n+            nickname = \"restoreAtStatusSave\")\n+    @RequestMapping(\n+            value = \"/{metadataUuid}/status/{statusId:[0-9]+}.{userId:[0-9]+}.{changeDate}/restore\",\n+            method = RequestMethod.POST\n+            )\n+    @PreAuthorize(\"hasRole('Editor')\")\n+    @ApiResponses(value = {\n+            @ApiResponse(code = 200, message = \"Record restored.\"),\n+            @ApiResponse(code = 403, message = ApiParams.API_RESPONSE_NOT_ALLOWED_CAN_EDIT)\n+    })\n+    @ResponseStatus(HttpStatus.OK)\n+    @ResponseBody\n+    public void restoreAtStatusSave(\n+            @ApiParam(value = API_PARAM_RECORD_UUID, required = true) @PathVariable String metadataUuid,\n+            @ApiParam(value = \"Status identifier\", required = true) @PathVariable int statusId,\n+            @ApiParam(value = \"User identifier\", required = true) @PathVariable int userId,\n+            @ApiParam(value = \"Change date\", required = true) @PathVariable String changeDate,\n+            @ApiIgnore @ApiParam(hidden = true) HttpSession httpSession, HttpServletRequest request\n+            )\n+                    throws Exception {\n+\n+        ApplicationContext applicationContext = ApplicationContextHolder.get();\n+        DataManager dataMan = applicationContext.getBean(DataManager.class);\n+\n+        MetadataStatus metadataStatus = metadataStatusRepository\n+                .findOneByUuidAndStatusValue_IdAndUserIdAndChangeDate(metadataUuid, statusId, userId, new ISODate(changeDate));\n+\n+        if (metadataStatus == null) {\n+            throw new ResourceNotFoundException(\n+                    String.format(\"Can't find metadata status for record '%d', user '%s' at date '%s'. Record cannot be restored\", metadataUuid,\n+                            userId, changeDate));\n+        }\n+\n+        if (!StatusValueType.event.equals(metadataStatus.getStatusValue().getType()) || !ArrayUtils.contains(supportedRestoreStatuses, statusId)) {\n+            throw new NotAllowedException(\"The recover for this element is not supported. Supports status type '\" +\n+                    StatusValueType.event + \"' with the status id '\" + Arrays.toString(supportedRestoreStatuses) +\n+                    \"'. Received status type '\" + metadataStatus.getStatusValue().getType() + \"' with status id '\" + statusId + \"'\");\n+        }\n+\n+        if (metadataStatus.getPreviousState() == null) {\n+            throw new ResourceNotFoundException(\n+                    String.format(\"No data exists for previous state on metadata record '%d', user '%s' at date '%s'. Record cannot be restrored\", metadataUuid,\n+                            userId, changeDate));\n+        }\n+\n+        AbstractMetadata metadata = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "41d89b2b3dd6b38775af1a3256a5b3c6071bd92c"}, "originalPosition": 495}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjAxODkzNQ==", "bodyText": "refactored code for before/after api so that that they use common code.", "url": "https://github.com/geonetwork/core-geonetwork/pull/4817#discussion_r502018935", "createdAt": "2020-10-08T21:19:45Z", "author": {"login": "ianwallen"}, "path": "services/src/main/java/org/fao/geonet/api/records/MetadataWorkflowApi.java", "diffHunk": "@@ -419,23 +442,268 @@ public MetadataStatus convertParameter(int id, MetadataStatusParameter parameter\n         return metadataStatus;\n     }\n \n+    @ApiOperation(\n+            value = \"Get saved content from the status record before changes\",\n+            notes = \"\",\n+            nickname = \"showStatusBefore\")\n+    @RequestMapping(\n+            value = \"/{metadataUuid}/status/{statusId:[0-9]+}.{userId:[0-9]+}.{changeDate}/before\",\n+            method = RequestMethod.GET,\n+            produces = {\n+                    MediaType.APPLICATION_XML_VALUE\n+            })\n+\n+    @PreAuthorize(\"hasRole('Editor')\")\n+    @ApiResponses(value = {\n+            @ApiResponse(code = 200, message = \"Previous version of the record.\"),\n+            @ApiResponse(code = 403, message = ApiParams.API_RESPONSE_NOT_ALLOWED_CAN_EDIT)\n+    })\n+    @ResponseStatus(HttpStatus.OK)\n+    @ResponseBody\n+    public String showStatusBefore(\n+            @ApiParam(value = API_PARAM_RECORD_UUID, required = true) @PathVariable String metadataUuid,\n+            @ApiParam(value = \"Status identifier\", required = true) @PathVariable int statusId,\n+            @ApiParam(value = \"User identifier\", required = true) @PathVariable int userId,\n+            @ApiParam(value = \"Change date\", required = true) @PathVariable String changeDate,\n+            @ApiIgnore @ApiParam(hidden = true) HttpSession httpSession, HttpServletRequest request\n+    )\n+            throws Exception {\n+\n+        MetadataStatus metadataStatus;\n+\n+        metadataStatus = metadataStatusRepository\n+                .findOneByUuidAndStatusValue_IdAndUserIdAndChangeDate(metadataUuid, statusId, userId, new ISODate(changeDate));\n+\n+        if (metadataStatus == null) {\n+            throw new ResourceNotFoundException(\n+                    String.format(\"Can't find metadata status for record '%d', user '%s' at date '%s'. Previous state cannot be viewed\", metadataUuid,\n+                            userId, changeDate));\n+        }\n+\n+        if (!StatusValueType.event.equals(metadataStatus.getStatusValue().getType()) || !ArrayUtils.contains(supportedRestoreStatuses, statusId)) {\n+            throw new NotAllowedException(\"Unsupported action on status type '\" + metadataStatus.getStatusValue().getType() + \"' for metadata '\" + metadataStatus.getUuid() + \"'. Supports status type '\" +\n+                    StatusValueType.event + \"' with the status id '\" + Arrays.toString(supportedRestoreStatuses) + \"'.\");\n+        }\n+\n+        if (metadataStatus.getPreviousState() == null) {\n+            throw new ResourceNotFoundException(\n+                    String.format(\"No data exists for previous state on metadata record '%d', user '%s' at date '%s'. Previous state cannot be viewed\", metadataUuid,\n+                            userId, changeDate));\n+        }\n+\n+        String fullMetadataText = metadataStatus.getPreviousState();\n+\n+        // If record exists then check if user has access.\n+        try {\n+            ApiUtils.canEditRecord(metadataUuid, request);\n+        } catch (SecurityException e) {\n+            Log.debug(API.LOG_MODULE_NAME, e.getMessage(), e);\n+            throw new NotAllowedException(ApiParams.API_RESPONSE_NOT_ALLOWED_CAN_VIEW);\n+        } catch (ResourceNotFoundException e) {\n+            // If metadata record does not exists then it was deleted so\n+            // we will only allow the administrator, owner to view the contents\n+            checkCanViewStatus(fullMetadataText, metadataStatus, httpSession, request);\n+        }\n+\n+        return fullMetadataText;\n+    }\n+\n+    @ApiOperation(\n+            value = \"Get saved content from the status record after changes\",\n+            notes = \"\",\n+            nickname = \"showStatusAfter\")\n+    @RequestMapping(value = \"/{metadataUuid}/status/{statusId:[0-9]+}.{userId:[0-9]+}.{changeDate}/after\",\n+            method = RequestMethod.GET,\n+            produces = {\n+                    MediaType.APPLICATION_XML_VALUE\n+            })\n+\n+    @PreAuthorize(\"hasRole('Editor')\")\n+    @ApiResponses(value = {\n+            @ApiResponse(code = 200, message = \"Version of the record after changes.\"),\n+            @ApiResponse(code = 403, message = ApiParams.API_RESPONSE_NOT_ALLOWED_CAN_EDIT)\n+    })\n+    @ResponseStatus(HttpStatus.OK)\n+    @ResponseBody\n+    public String showStatusAfter(\n+            @ApiParam(value = API_PARAM_RECORD_UUID, required = true) @PathVariable String metadataUuid,\n+            @ApiParam(value = \"Status identifier\", required = true) @PathVariable int statusId,\n+            @ApiParam(value = \"User identifier\", required = true) @PathVariable int userId,\n+            @ApiParam(value = \"Change date\", required = true) @PathVariable String changeDate,\n+            @ApiIgnore @ApiParam(hidden = true) HttpSession httpSession, HttpServletRequest request\n+    )\n+            throws Exception {\n+        MetadataStatus metadataStatus;\n+\n+        metadataStatus = metadataStatusRepository\n+                .findOneByUuidAndStatusValue_IdAndUserIdAndChangeDate(metadataUuid, statusId, userId, new ISODate(changeDate));\n+\n+        if (metadataStatus == null) {\n+            throw new ResourceNotFoundException(\n+                    String.format(\"Can't find metadata status for record '%d', user '%s' at date '%s'. Changes cannot be viewed\", metadataUuid,\n+                            userId, changeDate));\n+        }\n+\n+        if (!StatusValueType.event.equals(metadataStatus.getStatusValue().getType()) || !ArrayUtils.contains(supportedRestoreStatuses, statusId)) {\n+            throw new NotAllowedException(\"Unsupported action on status type '\" + metadataStatus.getStatusValue().getType() + \"' for metadata '\" + metadataStatus.getUuid() + \"'. Supports status type '\" +\n+                    StatusValueType.event + \"' with the status id '\" + Arrays.toString(supportedRestoreStatuses) + \"'.\");\n+        }\n+\n+        if (metadataStatus.getCurrentState() == null) {\n+            throw new ResourceNotFoundException(\n+                    String.format(\"No data exists for metadata record '%d', user '%s' at date '%s'. Changes state cannot be viewed\", metadataUuid,\n+                            userId, changeDate));\n+        }\n+\n+        String fullMetadataText = metadataStatus.getCurrentState();\n+\n+        // If record exists then check if user has access.\n+        try {\n+            ApiUtils.canEditRecord(metadataUuid, request);\n+        } catch (SecurityException e) {\n+            Log.debug(API.LOG_MODULE_NAME, e.getMessage(), e);\n+            throw new NotAllowedException(ApiParams.API_RESPONSE_NOT_ALLOWED_CAN_VIEW);\n+        } catch (ResourceNotFoundException e) {\n+            // If metadata record does not exists then it was deleted so\n+            // we will only allow the administrator, owner to view the contents\n+            checkCanViewStatus(fullMetadataText, metadataStatus, httpSession, request);\n+        }\n+\n+        return fullMetadataText;\n+    }\n+\n+    @ApiOperation(\n+            value = \"Restore saved content from a status record\",\n+            notes = \"\",\n+            nickname = \"restoreAtStatusSave\")\n+    @RequestMapping(\n+            value = \"/{metadataUuid}/status/{statusId:[0-9]+}.{userId:[0-9]+}.{changeDate}/restore\",\n+            method = RequestMethod.POST\n+            )\n+    @PreAuthorize(\"hasRole('Editor')\")\n+    @ApiResponses(value = {\n+            @ApiResponse(code = 200, message = \"Record restored.\"),\n+            @ApiResponse(code = 403, message = ApiParams.API_RESPONSE_NOT_ALLOWED_CAN_EDIT)\n+    })\n+    @ResponseStatus(HttpStatus.OK)\n+    @ResponseBody\n+    public void restoreAtStatusSave(\n+            @ApiParam(value = API_PARAM_RECORD_UUID, required = true) @PathVariable String metadataUuid,\n+            @ApiParam(value = \"Status identifier\", required = true) @PathVariable int statusId,\n+            @ApiParam(value = \"User identifier\", required = true) @PathVariable int userId,\n+            @ApiParam(value = \"Change date\", required = true) @PathVariable String changeDate,\n+            @ApiIgnore @ApiParam(hidden = true) HttpSession httpSession, HttpServletRequest request\n+            )\n+                    throws Exception {\n+\n+        ApplicationContext applicationContext = ApplicationContextHolder.get();\n+        DataManager dataMan = applicationContext.getBean(DataManager.class);\n+\n+        MetadataStatus metadataStatus = metadataStatusRepository\n+                .findOneByUuidAndStatusValue_IdAndUserIdAndChangeDate(metadataUuid, statusId, userId, new ISODate(changeDate));\n+\n+        if (metadataStatus == null) {\n+            throw new ResourceNotFoundException(\n+                    String.format(\"Can't find metadata status for record '%d', user '%s' at date '%s'. Record cannot be restored\", metadataUuid,\n+                            userId, changeDate));\n+        }\n+\n+        if (!StatusValueType.event.equals(metadataStatus.getStatusValue().getType()) || !ArrayUtils.contains(supportedRestoreStatuses, statusId)) {\n+            throw new NotAllowedException(\"The recover for this element is not supported. Supports status type '\" +\n+                    StatusValueType.event + \"' with the status id '\" + Arrays.toString(supportedRestoreStatuses) +\n+                    \"'. Received status type '\" + metadataStatus.getStatusValue().getType() + \"' with status id '\" + statusId + \"'\");\n+        }\n+\n+        if (metadataStatus.getPreviousState() == null) {\n+            throw new ResourceNotFoundException(\n+                    String.format(\"No data exists for previous state on metadata record '%d', user '%s' at date '%s'. Record cannot be restrored\", metadataUuid,\n+                            userId, changeDate));\n+        }\n+\n+        AbstractMetadata metadata = null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTYzMTIxMA=="}, "originalCommit": {"oid": "41d89b2b3dd6b38775af1a3256a5b3c6071bd92c"}, "originalPosition": 495}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyODMzMTY1OnYy", "diffSide": "RIGHT", "path": "web-ui/src/main/resources/catalog/components/history/GnHistoryService.js", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNDoyMjoyNVrOHcfXug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxNjoxMDowNFrOHel_TA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTYzNjE1NA==", "bodyText": "Not sure how this works with the workflow enabled and the draft metadata copies, as there're 2 metadata with different id, but same uuid.", "url": "https://github.com/geonetwork/core-geonetwork/pull/4817#discussion_r499636154", "createdAt": "2020-10-05T14:22:25Z", "author": {"login": "josegar74"}, "path": "web-ui/src/main/resources/catalog/components/history/GnHistoryService.js", "diffHunk": "@@ -35,17 +35,22 @@\n         '$http', '$filter',\n       function($http, $filter) {\n         this.delete = function (step) {\n-          return $http.delete('../api/records/' + step.id.metadataId + '/status/' +\n-            step.id.statusId + '.' + step.id.userId + '.' + step.id.changeDate.dateAndTime);\n+          return $http.delete('../api/records/' + step.uuid + '/status/' +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "41d89b2b3dd6b38775af1a3256a5b3c6071bd92c"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTg0MTc0MA==", "bodyText": "I have reverted this back to use the id.", "url": "https://github.com/geonetwork/core-geonetwork/pull/4817#discussion_r501841740", "createdAt": "2020-10-08T16:10:04Z", "author": {"login": "ianwallen"}, "path": "web-ui/src/main/resources/catalog/components/history/GnHistoryService.js", "diffHunk": "@@ -35,17 +35,22 @@\n         '$http', '$filter',\n       function($http, $filter) {\n         this.delete = function (step) {\n-          return $http.delete('../api/records/' + step.id.metadataId + '/status/' +\n-            step.id.statusId + '.' + step.id.userId + '.' + step.id.changeDate.dateAndTime);\n+          return $http.delete('../api/records/' + step.uuid + '/status/' +", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTYzNjE1NA=="}, "originalCommit": {"oid": "41d89b2b3dd6b38775af1a3256a5b3c6071bd92c"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5OTA4NzQwOnYy", "diffSide": "RIGHT", "path": "services/src/main/java/org/fao/geonet/api/records/MetadataWorkflowApi.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwNzozODowOVrOHnCNeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwNzozODowOVrOHnCNeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY5MjczMA==", "bodyText": "To check if this code can be changed by AccessManager.getGroups", "url": "https://github.com/geonetwork/core-geonetwork/pull/4817#discussion_r510692730", "createdAt": "2020-10-23T07:38:09Z", "author": {"login": "josegar74"}, "path": "services/src/main/java/org/fao/geonet/api/records/MetadataWorkflowApi.java", "diffHunk": "@@ -497,41 +687,219 @@ public MetadataStatus convertParameter(int id, MetadataStatusParameter parameter\n \n     private String extractCurrentStatus(MetadataStatus s) {\n         switch (Integer.toString(s.getStatusValue().getId())) {\n-        case StatusValue.Events.ATTACHMENTADDED:\n-            return s.getCurrentState();\n-        case StatusValue.Events.RECORDOWNERCHANGE:\n-            return ObjectJSONUtils.extractFieldFromJSONString(s.getCurrentState(), \"owner\", \"name\");\n-        case StatusValue.Events.RECORDGROUPOWNERCHANGE:\n-            return ObjectJSONUtils.extractFieldFromJSONString(s.getCurrentState(), \"owner\", \"name\");\n-        case StatusValue.Events.RECORDPROCESSINGCHANGE:\n-            return ObjectJSONUtils.extractFieldFromJSONString(s.getCurrentState(), \"process\");\n-        case StatusValue.Events.RECORDCATEGORYCHANGE:\n-            List<String> categories = ObjectJSONUtils.extractListOfFieldFromJSONString(s.getCurrentState(), \"category\",\n-                    \"name\");\n-            StringBuffer categoriesAsString = new StringBuffer(\"[ \");\n-            for (String categoryName : categories) {\n-                categoriesAsString.append(categoryName + \" \");\n-            }\n-            categoriesAsString.append(\"]\");\n-            return categoriesAsString.toString();\n-        case StatusValue.Events.RECORDVALIDATIONTRIGGERED:\n-            return s.getCurrentState().equals(\"1\") ? \"OK\" : \"KO\";\n-        default:\n-            return \"\";\n+            case StatusValue.Events.ATTACHMENTADDED:\n+                return s.getCurrentState();\n+            case StatusValue.Events.RECORDOWNERCHANGE:\n+                return ObjectJSONUtils.extractFieldFromJSONString(s.getCurrentState(), \"owner\", \"name\");\n+            case StatusValue.Events.RECORDGROUPOWNERCHANGE:\n+                return ObjectJSONUtils.extractFieldFromJSONString(s.getCurrentState(), \"owner\", \"name\");\n+            case StatusValue.Events.RECORDPROCESSINGCHANGE:\n+                return ObjectJSONUtils.extractFieldFromJSONString(s.getCurrentState(), \"process\");\n+            case StatusValue.Events.RECORDCATEGORYCHANGE:\n+                List<String> categories = ObjectJSONUtils.extractListOfFieldFromJSONString(s.getCurrentState(), \"category\",\n+                        \"name\");\n+                StringBuffer categoriesAsString = new StringBuffer(\"[ \");\n+                for (String categoryName : categories) {\n+                    categoriesAsString.append(categoryName + \" \");\n+                }\n+                categoriesAsString.append(\"]\");\n+                return categoriesAsString.toString();\n+            case StatusValue.Events.RECORDVALIDATIONTRIGGERED:\n+                return s.getCurrentState().equals(\"1\") ? \"OK\" : \"KO\";\n+            default:\n+                return \"\";\n         }\n     }\n \n     private String extractPreviousStatus(MetadataStatus s) {\n         switch (Integer.toString(s.getStatusValue().getId())) {\n-        case StatusValue.Events.ATTACHMENTDELETED:\n-            return s.getPreviousState();\n-        case StatusValue.Events.RECORDOWNERCHANGE:\n-            return ObjectJSONUtils.extractFieldFromJSONString(s.getPreviousState(), \"owner\", \"name\");\n-        case StatusValue.Events.RECORDGROUPOWNERCHANGE:\n-            return ObjectJSONUtils.extractFieldFromJSONString(s.getPreviousState(), \"owner\", \"name\");\n-        default:\n-            return \"\";\n+            case StatusValue.Events.ATTACHMENTDELETED:\n+                return s.getPreviousState();\n+            case StatusValue.Events.RECORDOWNERCHANGE:\n+                return ObjectJSONUtils.extractFieldFromJSONString(s.getPreviousState(), \"owner\", \"name\");\n+            case StatusValue.Events.RECORDGROUPOWNERCHANGE:\n+                return ObjectJSONUtils.extractFieldFromJSONString(s.getPreviousState(), \"owner\", \"name\");\n+            default:\n+                return \"\";\n+        }\n+    }\n+\n+    private void checkCanViewStatus(String metadata, MetadataStatus metadataStatus, HttpSession httpSession, HttpServletRequest request) throws Exception {\n+        Element xmlElement = null;\n+        try {\n+            xmlElement = Xml.loadString(metadata, false);\n+        } catch (JDOMParseException ex) {\n+            throw new IllegalArgumentException(\n+                    String.format(\"XML fragment is invalid. Error is %s\", ex.getMessage()));\n+        }\n+\n+        Element info = xmlElement.getChild(Edit.RootChild.INFO, Edit.NAMESPACE);\n+        if (info == null) {\n+            throw new IllegalArgumentException(\"Can't locate required geonet:info which is required for the recovery. May need to manually re-import the data\");\n+        }\n+\n+        String groupOwnerName = info.getChildText(Edit.Info.Elem.GROUPOWNERNAME);\n+\n+        String groupId = null;\n+        if (groupOwnerName != null) {\n+            Group groupEntity = groupRepository.findByName(groupOwnerName);\n+            if (groupEntity != null) {\n+                groupId = String.valueOf(groupEntity.getId());\n+            }\n+        }\n+\n+        UserSession user = ApiUtils.getUserSession(httpSession);\n+        if (user.getProfile() != Profile.Administrator) {\n+            if (groupId != null) {\n+                final Specifications<UserGroup> spec = where(UserGroupSpecs.hasProfile(Profile.Editor))\n+                        .and(UserGroupSpecs.hasUserId(user.getUserIdAsInt()))\n+                        .and(UserGroupSpecs.hasGroupId(Integer.valueOf(groupId)));\n+\n+                final List<UserGroup> userGroups = userGroupRepository.findAll(spec);\n+\n+                if (userGroups.size() == 0) {\n+                    throw new SecurityException(\n+                            String.format(\"You can't view history from this group (\" + groupOwnerName + \"). User MUST be an Editor in that group\"));\n+                }\n+            } else {\n+                throw new SecurityException(\n+                        String.format(\"Error identify group where this metadata belong to. Only administrator can restore this record\"));\n+            }\n         }\n     }\n \n+    private int reloadRecord(MetadataStatus metadataStatus, Element md, IMetadataManager iMetadataManager, HttpSession httpSession, HttpServletRequest request) throws Exception {\n+\n+        Element info = md.getChild(Edit.RootChild.INFO, Edit.NAMESPACE);\n+        if (info == null) {\n+            throw new IllegalArgumentException(\"Can't location geonet:info which is required for the recovery. May need to manually re-import the data\");\n+        }\n+\n+        md = metadataUtils.removeMetadataInfo(md);\n+\n+        String groupOwnerName = info.getChildText(Edit.Info.Elem.GROUPOWNERNAME);\n+\n+        String groupId = null;\n+        if (groupOwnerName != null) {\n+            Group groupEntity = groupRepository.findByName(groupOwnerName);\n+            if (groupEntity != null) {\n+                groupId = String.valueOf(groupEntity.getId());\n+            }\n+        }\n+\n+        UserSession user = ApiUtils.getUserSession(httpSession);\n+        if (user.getProfile() != Profile.Administrator) {\n+            if (groupId != null) {\n+                final Specifications<UserGroup> spec = where(UserGroupSpecs.hasProfile(Profile.Editor))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73accd2229c4e308868c2e1791a3c0e7e88dd9e3"}, "originalPosition": 696}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5OTA4NzkxOnYy", "diffSide": "RIGHT", "path": "services/src/main/java/org/fao/geonet/api/records/MetadataWorkflowApi.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwNzozODoxOFrOHnCNxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwNzozODoxOFrOHnCNxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY5MjgwNw==", "bodyText": "To check if this code can be changed by AccessManager.getGroups", "url": "https://github.com/geonetwork/core-geonetwork/pull/4817#discussion_r510692807", "createdAt": "2020-10-23T07:38:18Z", "author": {"login": "josegar74"}, "path": "services/src/main/java/org/fao/geonet/api/records/MetadataWorkflowApi.java", "diffHunk": "@@ -497,41 +687,219 @@ public MetadataStatus convertParameter(int id, MetadataStatusParameter parameter\n \n     private String extractCurrentStatus(MetadataStatus s) {\n         switch (Integer.toString(s.getStatusValue().getId())) {\n-        case StatusValue.Events.ATTACHMENTADDED:\n-            return s.getCurrentState();\n-        case StatusValue.Events.RECORDOWNERCHANGE:\n-            return ObjectJSONUtils.extractFieldFromJSONString(s.getCurrentState(), \"owner\", \"name\");\n-        case StatusValue.Events.RECORDGROUPOWNERCHANGE:\n-            return ObjectJSONUtils.extractFieldFromJSONString(s.getCurrentState(), \"owner\", \"name\");\n-        case StatusValue.Events.RECORDPROCESSINGCHANGE:\n-            return ObjectJSONUtils.extractFieldFromJSONString(s.getCurrentState(), \"process\");\n-        case StatusValue.Events.RECORDCATEGORYCHANGE:\n-            List<String> categories = ObjectJSONUtils.extractListOfFieldFromJSONString(s.getCurrentState(), \"category\",\n-                    \"name\");\n-            StringBuffer categoriesAsString = new StringBuffer(\"[ \");\n-            for (String categoryName : categories) {\n-                categoriesAsString.append(categoryName + \" \");\n-            }\n-            categoriesAsString.append(\"]\");\n-            return categoriesAsString.toString();\n-        case StatusValue.Events.RECORDVALIDATIONTRIGGERED:\n-            return s.getCurrentState().equals(\"1\") ? \"OK\" : \"KO\";\n-        default:\n-            return \"\";\n+            case StatusValue.Events.ATTACHMENTADDED:\n+                return s.getCurrentState();\n+            case StatusValue.Events.RECORDOWNERCHANGE:\n+                return ObjectJSONUtils.extractFieldFromJSONString(s.getCurrentState(), \"owner\", \"name\");\n+            case StatusValue.Events.RECORDGROUPOWNERCHANGE:\n+                return ObjectJSONUtils.extractFieldFromJSONString(s.getCurrentState(), \"owner\", \"name\");\n+            case StatusValue.Events.RECORDPROCESSINGCHANGE:\n+                return ObjectJSONUtils.extractFieldFromJSONString(s.getCurrentState(), \"process\");\n+            case StatusValue.Events.RECORDCATEGORYCHANGE:\n+                List<String> categories = ObjectJSONUtils.extractListOfFieldFromJSONString(s.getCurrentState(), \"category\",\n+                        \"name\");\n+                StringBuffer categoriesAsString = new StringBuffer(\"[ \");\n+                for (String categoryName : categories) {\n+                    categoriesAsString.append(categoryName + \" \");\n+                }\n+                categoriesAsString.append(\"]\");\n+                return categoriesAsString.toString();\n+            case StatusValue.Events.RECORDVALIDATIONTRIGGERED:\n+                return s.getCurrentState().equals(\"1\") ? \"OK\" : \"KO\";\n+            default:\n+                return \"\";\n         }\n     }\n \n     private String extractPreviousStatus(MetadataStatus s) {\n         switch (Integer.toString(s.getStatusValue().getId())) {\n-        case StatusValue.Events.ATTACHMENTDELETED:\n-            return s.getPreviousState();\n-        case StatusValue.Events.RECORDOWNERCHANGE:\n-            return ObjectJSONUtils.extractFieldFromJSONString(s.getPreviousState(), \"owner\", \"name\");\n-        case StatusValue.Events.RECORDGROUPOWNERCHANGE:\n-            return ObjectJSONUtils.extractFieldFromJSONString(s.getPreviousState(), \"owner\", \"name\");\n-        default:\n-            return \"\";\n+            case StatusValue.Events.ATTACHMENTDELETED:\n+                return s.getPreviousState();\n+            case StatusValue.Events.RECORDOWNERCHANGE:\n+                return ObjectJSONUtils.extractFieldFromJSONString(s.getPreviousState(), \"owner\", \"name\");\n+            case StatusValue.Events.RECORDGROUPOWNERCHANGE:\n+                return ObjectJSONUtils.extractFieldFromJSONString(s.getPreviousState(), \"owner\", \"name\");\n+            default:\n+                return \"\";\n+        }\n+    }\n+\n+    private void checkCanViewStatus(String metadata, MetadataStatus metadataStatus, HttpSession httpSession, HttpServletRequest request) throws Exception {\n+        Element xmlElement = null;\n+        try {\n+            xmlElement = Xml.loadString(metadata, false);\n+        } catch (JDOMParseException ex) {\n+            throw new IllegalArgumentException(\n+                    String.format(\"XML fragment is invalid. Error is %s\", ex.getMessage()));\n+        }\n+\n+        Element info = xmlElement.getChild(Edit.RootChild.INFO, Edit.NAMESPACE);\n+        if (info == null) {\n+            throw new IllegalArgumentException(\"Can't locate required geonet:info which is required for the recovery. May need to manually re-import the data\");\n+        }\n+\n+        String groupOwnerName = info.getChildText(Edit.Info.Elem.GROUPOWNERNAME);\n+\n+        String groupId = null;\n+        if (groupOwnerName != null) {\n+            Group groupEntity = groupRepository.findByName(groupOwnerName);\n+            if (groupEntity != null) {\n+                groupId = String.valueOf(groupEntity.getId());\n+            }\n+        }\n+\n+        UserSession user = ApiUtils.getUserSession(httpSession);\n+        if (user.getProfile() != Profile.Administrator) {\n+            if (groupId != null) {\n+                final Specifications<UserGroup> spec = where(UserGroupSpecs.hasProfile(Profile.Editor))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73accd2229c4e308868c2e1791a3c0e7e88dd9e3"}, "originalPosition": 657}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE5OTA5ODg1OnYy", "diffSide": "RIGHT", "path": "web/src/main/webapp/WEB-INF/classes/setup/sql/migrate/v3110/UpdateMetadataStatus.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwNzo0MToyN1rOHnCULA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwNzo0MToyN1rOHnCULA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY5NDQ0NA==", "bodyText": "Remove commented code", "url": "https://github.com/geonetwork/core-geonetwork/pull/4817#discussion_r510694444", "createdAt": "2020-10-23T07:41:27Z", "author": {"login": "josegar74"}, "path": "web/src/main/webapp/WEB-INF/classes/setup/sql/migrate/v3110/UpdateMetadataStatus.java", "diffHunk": "@@ -0,0 +1,421 @@\n+/*\n+ * Copyright (C) 2001-2018 Food and Agriculture Organization of the\n+ * United Nations (FAO-UN), United Nations World Food Programme (WFP)\n+ * and United Nations Environment Programme (UNEP)\n+ *\n+ * This program is free software; you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation; either version 2 of the License, or (at\n+ * your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful, but\n+ * WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with this program; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA\n+ *\n+ * Contact: Jeroen Ticheler - FAO - Viale delle Terme di Caracalla 2,\n+ * Rome - Italy. email: geonetwork@osgeo.org\n+ */\n+\n+package v3110;\n+\n+import org.fao.geonet.DatabaseMigrationTask;\n+import org.fao.geonet.domain.MetadataStatus;\n+import org.fao.geonet.domain.MetadataStatus_;\n+import org.fao.geonet.kernel.datamanager.IMetadataUtils;\n+import org.fao.geonet.constants.Geonet;\n+import org.fao.geonet.repository.MetadataStatusRepository;\n+import org.fao.geonet.utils.Log;\n+import org.hibernate.dialect.Dialect;\n+import org.hibernate.engine.jdbc.dialect.internal.StandardDialectResolver;\n+import org.hibernate.engine.jdbc.dialect.spi.DatabaseMetaDataDialectResolutionInfoAdapter;\n+import org.hibernate.engine.jdbc.dialect.spi.DialectResolutionInfo;\n+import org.springframework.context.ApplicationContext;\n+import org.springframework.data.domain.Page;\n+import org.springframework.data.domain.PageRequest;\n+import org.springframework.data.domain.Pageable;\n+import org.springframework.data.domain.Sort;\n+\n+import java.sql.*;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+/**\n+ * Class to be executed during the migration which will update some new not null columns\n+ * on the metadataStatus table.\n+ *\n+ * Note: After this step is complete most of the changes should be in place however their may still be\n+ * some missing JPA settings that would initially fail due to these NOT NULL columns.\n+ *\n+ * It is recommended that after the initial startup and migration execution that the system be stopped and\n+ * restarted to ensure that all JPA settings are applied correctly.\n+ */\n+public class UpdateMetadataStatus extends DatabaseMigrationTask {\n+\n+    private MetadataStatusRepository metadataStatusRepository;\n+    private IMetadataUtils metadataUtils;\n+\n+    /**\n+     * Override the setContext so do the autowire of the other fields.\n+     * @param applicationContext\n+     */\n+    @Override\n+    public void setContext(ApplicationContext applicationContext)  {\n+        super.setContext(applicationContext);\n+        metadataUtils = applicationContext.getBean(IMetadataUtils.class);\n+        metadataStatusRepository = applicationContext.getBean(MetadataStatusRepository.class);\n+    }\n+\n+    /**\n+     * Maing flow for the updating of the ID. UUID and TITLES fields\n+     * @param connection\n+     * @throws SQLException\n+     */\n+        @Override\n+    public void update(Connection connection) throws SQLException {\n+\n+        final MetadataStatus metadataStatusObject = new MetadataStatus();\n+\n+            DialectResolutionInfo dialectResolutionInfo = new DatabaseMetaDataDialectResolutionInfoAdapter(connection.getMetaData());\n+            Dialect dialect = new StandardDialectResolver().resolveDialect(dialectResolutionInfo);\n+\n+            Log.debug(Geonet.DB, \"UpdateMetadataStatus\");\n+\n+            // First add the id and uuid as nullable.\n+            addMissingColumn(connection, dialect);\n+\n+            // Now update the id to sequence values so that all id's are not null.\n+            updatePKValue(connection, dialect);\n+\n+            // Now update uuid and titles for the existing records\n+            updateOtherNewFields();\n+            // commit the changes\n+            connection.commit();\n+\n+            // finallize the change\n+            finalizeChanges(connection, dialect);\n+    }\n+\n+    /**\n+     *  JPA will not be able to create the ID and UUID because they are not null\n+     *  So we need to add them as nullable initially until we update all the data in the tables.\n+     *\n+     * @param connection\n+     * @param dialect - specific to each database - i.e. oracke, h2, postgresl...\n+     * @throws SQLException\n+     */\n+    private void addMissingColumn(final Connection connection, Dialect dialect ) throws SQLException {\n+        try (Statement statement = connection.createStatement()) {\n+            statement.execute(\"ALTER TABLE \" + MetadataStatus.TABLE_NAME + \" \" + dialect.getAddColumnString() + \"  \" + MetadataStatus_.id.getName() + \" INTEGER NULL\");\n+        } catch (Exception e) {\n+            // If there was an error then we will log the error and continue.\n+            // Most likely cause is that the column already exists which should be fine.\n+            Log.error(Geonet.DB, \"  Exception while adding new \" + MetadataStatus_.id.getName() + \" column to \" + MetadataStatus.TABLE_NAME + \". \" + \n+                    \"Error is: \" + e.getMessage());\n+            Log.debug(Geonet.DB, e);\n+        }\n+        try (Statement statement = connection.createStatement()) {\n+            statement.execute(\"ALTER TABLE \" + MetadataStatus.TABLE_NAME + \" \" + dialect.getAddColumnString() + \"  \" + MetadataStatus_.uuid.getName() + \" VARCHAR(255) NULL\");\n+        } catch (Exception e) {\n+            // If there was an erro then we will log the error and continue.\n+            // Most likely cause is that the column already exists which should be fine.\n+            Log.error(Geonet.DB, \"  Exception while adding new \" + MetadataStatus_.uuid.getName() + \" column to \" + MetadataStatus.TABLE_NAME + \". \" +\n+                    \"Error is: \" + e.getMessage());\n+            Log.debug(Geonet.DB, e);\n+        }\n+\n+        connection.commit();\n+    }\n+\n+    /**\n+     * Update the ID (primary key field) for the database to be equal to the sequence values.\n+     * @param connection\n+     * @param dialect - specific to each database - i.e. oracke, h2, postgresl...\n+     * @throws SQLException\n+     */\n+\n+    private void updatePKValue(final Connection connection, Dialect dialect) throws SQLException {\n+\n+        String HIBERNATE_SEQUENCE = getDatabaseObjectName(connection, \"HIBERNATE_SEQUENCE\");\n+\n+        Statement statement = null;\n+        Integer rowcount = null;\n+        try {\n+            statement = connection.createStatement();\n+            try {\n+                rowcount = statement.executeUpdate(\"update \" + MetadataStatus.TABLE_NAME +\n+                        \" set \" + MetadataStatus_.id.getName() + \" = \" + dialect.getSelectSequenceNextValString(MetadataStatus.ID_SEQ_NAME) +\n+                        \" where \" + MetadataStatus_.id.getName() + \" IS NULL\");\n+            } catch (SQLException e1) {\n+                try {\n+                    connection.rollback();\n+                    if (statement != null) {\n+                        statement.close();\n+                    }\n+                    statement = connection.createStatement();\n+                    rowcount = statement.executeUpdate(\"update \" + MetadataStatus.TABLE_NAME +\n+                            \" set \" + MetadataStatus_.id.getName() + \" = \" + dialect.getSelectSequenceNextValString(HIBERNATE_SEQUENCE) +\n+                            \" where \" + MetadataStatus_.id.getName() + \" IS NULL\");\n+                } catch (SQLException e2) {\n+                    throw new SQLException(\"Error updating table \\\"\" + MetadataStatus.TABLE_NAME + \".\" + MetadataStatus_.id.getName() +\n+                            \"\\\" values to sequence value using sequence \\\"\" + MetadataStatus.ID_SEQ_NAME + \"\\\" and \\\"\" + HIBERNATE_SEQUENCE + \"\\\"\\n\" + e1.getMessage() + \"\\n\", e2);\n+                }\n+            }\n+        } finally {\n+            if (statement != null) {\n+                statement.close();\n+            }\n+        }\n+\n+        // Need to commit changes or they it will not be available to JPA calls.\n+        connection.commit();\n+\n+        Log.info(Geonet.DB, \"Migration: Updated \" + rowcount + \" primary key values for '\" + MetadataStatus.TABLE_NAME + \"'\");\n+    }\n+\n+    /**\n+     * Update the new UUID and Titles field based on existing data.\n+     * @throws SQLException\n+     */\n+    private void updateOtherNewFields() throws SQLException {\n+\n+        Pageable pageRequest = new PageRequest(0, 1000, new Sort(\"id\"));\n+        int totalRowCount = 0;\n+        int updateRowCount = 0;\n+        int uuidRowCount = 0;\n+        int titleRowCount = 0;\n+        Map<Integer, LinkedHashMap<String, String>> titlesMap = new HashMap<>();\n+        Map<Integer, String> uuidMap = new HashMap<>();\n+        //List<Language> languages = languageRepository.findAll();\n+        Page<MetadataStatus> page;\n+        do {\n+            page = metadataStatusRepository.findAll(pageRequest);\n+            if (page != null && page.hasContent()) {\n+                for (MetadataStatus metadataStatus : page.getContent()) {\n+                    totalRowCount++;\n+                    if (metadataStatus.getUuid() == null || metadataStatus.getUuid().length() == 0 ||\n+                            metadataStatus.getTitles() == null || metadataStatus.getTitles().size() == 0) {\n+\n+                        boolean changeflag = false;\n+                        if (metadataStatus.getUuid() == null || metadataStatus.getUuid().length() == 0) {\n+                            String uuid = uuidMap.get(metadataStatus.getMetadataId());\n+                            if (uuid == null) {\n+                                try {\n+                                    uuid = metadataUtils.getMetadataUuid(Integer.toString(metadataStatus.getMetadataId()));\n+                                    if (uuid != null) {\n+                                        uuidMap.put(metadataStatus.getMetadataId(), uuid);\n+                                    }\n+                                } catch (Exception e) {\n+                                    Log.error(Geonet.DATA_MANAGER, String.format(\n+                                            \"Error locating uuid for metadata id: %d\", +metadataStatus.getMetadataId()), e);\n+                                }\n+                                if (uuid == null || uuid.length() == 0) {\n+                                    Log.error(Geonet.DATA_MANAGER, String.format(\n+                                            \"Could not located uuid for metadata id: %d\", + metadataStatus.getMetadataId()));\n+                                }\n+                            }\n+                            if (uuid != null && uuid.length() > 0) {\n+                                metadataStatus.setUuid(uuid);\n+                                uuidRowCount++;\n+                                changeflag = true;\n+                            }\n+                        }\n+                        if (metadataStatus.getTitles() == null || metadataStatus.getTitles().size() == 0) {\n+                            LinkedHashMap<String, String> titles = titlesMap.get(metadataStatus.getMetadataId());\n+                            // Try to get the titles from the schema.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73accd2229c4e308868c2e1791a3c0e7e88dd9e3"}, "originalPosition": 230}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4133, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}