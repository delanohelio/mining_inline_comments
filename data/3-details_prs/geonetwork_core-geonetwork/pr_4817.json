{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQyNzg0ODk5", "number": 4817, "title": "Allow to restore a metadata record from deleted records (Part 3)", "bodyText": "This pull request is a continuance of pull request #4751. It contains the changes from that pull request and I will merge the changes once pull request #4751 has been completed.  Marking this as WIP until #4751 has been completed.\nChanges in this pull request\n\nChanged the primary key for the metadatastatus table so that it is a single key instead of a multikey.  Kept the multikey fields as a unique index.\nWith new PK added, a new relatedmetadatastatusid field was also added so that a restored item can point to the parent for which the restore was done from (see #4750 )\nTo support being able to view the history listing of deleted items (which no longer exists in index), the UUID and Titles were also added to the metadata status table.   The title field  is stored as a json representation of a hashmap containing the language and titles.\nTo support getting the multilingual titles from the metadata, the metadata plugin now require a new extract-titles.xsl file to get the tilles.  If it does not exists, it will only use the index values so if a record is deleted and the index entry does not exists then it will not be possible to get the title so it will be empty in the status listing.\nAdded groupownname to geonet:info to assist with the recovery as we needed to be able to restore the record to the same group that it was deleted from.\nUpdated API parameters and results to support new table changes.\n\nDatabase Migration\nThe expected database upgrade process should look something like the following\n\nStart geonetwork\nJPA will attempt to apply all the database changes and there will be errors.\u00a0 The errors are caused because JPA cannot figure out how to change the primary keys. So it simply attempts to add a new PK for ID but there is already the old PK.  Also since it cannot create the PK. it also fails attempting to create a foreign key for the relatedmetadatastatusid.\nThe migration java class(UpdateMetadataStatus) will attempt to update the primary key by adding fields as null, update data, and then make it not null and then drop/recreate the pk.\u00a0 The drop recreate PK may generate some errors as well as it attempts to drop the constraint, index pk (hopefully this will cover all database vendors). I in the end the pk should be removed. and re-created.\nAfter the system has started, it is recommended that the system be shut down and restarted. This will fix the missing foreign keys and possibly other missing changes that failed on first startup.  It should not be a required task as the system should still be able to work without the foreign key.\nOn the next system restart, JPA should finish any missing changes.\u00a0 We should not see database errors any errors on the second restart. Also the tables should have all been changed after this point and the migration should be complete.\u00a0\u00a0\n\nTodo\n\n -  Change some status API's to support new single metadata status ID key.\n -  Migration - primary key issue  - did not figure out how to remove old primary key from table - current attempt fails on h2 database.\n\nWhats next\n\nUpdated user interface so it is possible to see the linkage from a restored item using the new relatedmetadatastatus.\nImprove restore so that other items, (such as categories, rating, permissions, resources...),  are included in the restore.\nMigration - title issue - see question below - I was not able to get the current titles. If not part of the migration then old data will contain null titles.  This is not really required but will provide a smoother upgrade path.\n\nDependencies\n#4751 (contains previous versioning work which is included in this PR but is a smaller subset of changes.  If this PR is approved then #4751 can be closed.)\n#4781 (new key uses new sequence logic - so this is moreless required for consistency)\n** Questions **\nFor migration\nShould we make the titles mandatory? This would require looping thought all metadata status and fetching and assigning the current titles. This will be difficult to do in the future once some records have been deleted.\nShould we fail if the extra-titles.xls fail to parse or get the titles, or should we just allow null titles?  If required then all schema pluging will not be backwards compatible and will need extra-titles.xls\nI attempted to get the titles as part of the migration however it fails as the schema's don't seem to be loaded prior to migration. I also attempted to get the titles from the index however the index was also not available at the time of migration so I used getTitle from the metadata which is mostly null and I think it is depreciated. (see commented code in migration script for details https://github.com/geonetwork/core-geonetwork/pull/4817/files#diff-6453eb82272709dfbed89c0ba612c9f9R214-R260)", "createdAt": "2020-07-01T15:44:13Z", "url": "https://github.com/geonetwork/core-geonetwork/pull/4817", "merged": true, "mergeCommit": {"oid": "3fd0c87214fce344b4e91933efe5a3a9a6f29da4"}, "closed": true, "closedAt": "2020-11-11T07:41:18Z", "author": {"login": "ianwallen"}, "timelineItems": {"totalCount": 32, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABbkD0-jgH2gAyNDQyNzg0ODk5OmUyZDUzMmE5NWNhNTIxNGVkMTU0MWI3YmIwODMwMjdlM2M1MzYyOGI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdZnSq9AH2gAyNDQyNzg0ODk5OjM1NTRlNTZmYjc5ZmM2MzM2MmVhNTNkNjc1ZWU1Mjg1NzgwMWFmZTA=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "e2d532a95ca5214ed1541b7bb083027e3c53628b", "author": {"user": null}, "url": "https://github.com/geonetwork/core-geonetwork/commit/e2d532a95ca5214ed1541b7bb083027e3c53628b", "committedDate": "2019-11-06T13:43:47Z", "message": "Restore from history functionality"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "171a19244848fa0eae1614d698c237ac5c5bd7ac", "author": {"user": null}, "url": "https://github.com/geonetwork/core-geonetwork/commit/171a19244848fa0eae1614d698c237ac5c5bd7ac", "committedDate": "2019-11-11T16:34:46Z", "message": "Behavior when draft exists"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0e740644fedcefe8f9457cba28323cdc327038d2", "author": {"user": {"login": "ianwallen", "name": "Ian"}}, "url": "https://github.com/geonetwork/core-geonetwork/commit/0e740644fedcefe8f9457cba28323cdc327038d2", "committedDate": "2020-06-02T14:26:06Z", "message": "Merge branch 'master' of https://github.com/geonetwork/core-geonetwork into restorehistory\n\n# Conflicts:\n#\tweb-ui/src/main/resources/catalog/locales/en-core.json\n#\tweb/src/main/webapp/WEB-INF/classes/setup/sql/migrate/v390/migrate-default.sql"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "28037420226c475812f557ab848405cb5deb1c38", "author": {"user": {"login": "ianwallen", "name": "Ian"}}, "url": "https://github.com/geonetwork/core-geonetwork/commit/28037420226c475812f557ab848405cb5deb1c38", "committedDate": "2020-06-02T14:37:50Z", "message": "Fixed migration merge"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a5e97b66a5f5f28c0b83309acf257a86ce7a0bfb", "author": {"user": {"login": "ianwallen", "name": "Ian"}}, "url": "https://github.com/geonetwork/core-geonetwork/commit/a5e97b66a5f5f28c0b83309acf257a86ce7a0bfb", "committedDate": "2020-06-10T20:00:28Z", "message": "Removed MetadataStatusId Serialization and Deserialization and used existing format of /{metadataUuid}/status/{statusId:[0-9]+}.{userId:[0-9]+}.{changeDate}\nRemoved rollback option as a rollback is the same as a restore.  Also removed logic to delete status of rollback status.\nRenamed view to view previous version and changed version and added new showStatusAfter api to support this.\nDatabase\nAdded missing fre language for insert\nMove migration inserts to 3110 and also added missing translation."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cccf33dc4988cdc9924ccebde601e4fb3854d580", "author": {"user": {"login": "ianwallen", "name": "Ian"}}, "url": "https://github.com/geonetwork/core-geonetwork/commit/cccf33dc4988cdc9924ccebde601e4fb3854d580", "committedDate": "2020-06-12T11:29:23Z", "message": "Merge branch 'master' of https://github.com/geonetwork/core-geonetwork into restorehistory\n\n# Conflicts:\n#\tservices/src/main/java/org/fao/geonet/api/records/model/MetadataStatusResponse.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "423e3f2de8f0b58f43fb3cd889f4a72ec0791a66", "author": {"user": {"login": "ianwallen", "name": "Ian"}}, "url": "https://github.com/geonetwork/core-geonetwork/commit/423e3f2de8f0b58f43fb3cd889f4a72ec0791a66", "committedDate": "2020-06-29T13:45:26Z", "message": "Merge branch 'master' of https://github.com/geonetwork/core-geonetwork into restorehistory\n\n# Conflicts:\n#\tweb/src/main/webapp/WEB-INF/classes/setup/sql/migrate/v3110/migrate-default.sql"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8ebec258d842aae3973e32d68f955d7eceb505e6", "author": {"user": {"login": "ianwallen", "name": "Ian"}}, "url": "https://github.com/geonetwork/core-geonetwork/commit/8ebec258d842aae3973e32d68f955d7eceb505e6", "committedDate": "2020-07-01T16:35:33Z", "message": "Allow capability to recover deleted records\nChanged PK key for metadatastatus so that it is a single key.\nAdded groupownname to geonet:info to assist with the recovery.\nAdd metadataStatus entry for deleted objects.\n    Added UUID and Titles to the status so that the data is available for deleted records as well."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b59430fe0e51f73ca7eae080d60946d25e3e5fee", "author": {"user": {"login": "ianwallen", "name": "Ian"}}, "url": "https://github.com/geonetwork/core-geonetwork/commit/b59430fe0e51f73ca7eae080d60946d25e3e5fee", "committedDate": "2020-07-01T15:41:06Z", "message": "Allow capability to recover deleted records\nChanged PK key for metadatastatus so that it is a single key.\nAdded groupownname to geonet:info to assist with the recovery.\nAdd metadataStatus entry for deleted objects.\n    Added UUID and Titles to the status so that the data is available for deleted records as well."}, "afterCommit": {"oid": "8ebec258d842aae3973e32d68f955d7eceb505e6", "author": {"user": {"login": "ianwallen", "name": "Ian"}}, "url": "https://github.com/geonetwork/core-geonetwork/commit/8ebec258d842aae3973e32d68f955d7eceb505e6", "committedDate": "2020-07-01T16:35:33Z", "message": "Allow capability to recover deleted records\nChanged PK key for metadatastatus so that it is a single key.\nAdded groupownname to geonet:info to assist with the recovery.\nAdd metadataStatus entry for deleted objects.\n    Added UUID and Titles to the status so that the data is available for deleted records as well."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d2f1c58cdd1e94995dfb63b538379cc2d8890c51", "author": {"user": {"login": "ianwallen", "name": "Ian"}}, "url": "https://github.com/geonetwork/core-geonetwork/commit/d2f1c58cdd1e94995dfb63b538379cc2d8890c51", "committedDate": "2020-07-01T21:08:11Z", "message": "removed duplicate status_id which is the same as the statusvalue."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3717110450b83b29724acd3f96056715480ddd6e", "author": {"user": {"login": "ianwallen", "name": "Ian"}}, "url": "https://github.com/geonetwork/core-geonetwork/commit/3717110450b83b29724acd3f96056715480ddd6e", "committedDate": "2020-07-03T18:31:02Z", "message": "Fixed improper resolved conflict which accidentally converted file to ascci causing script to fail."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b0298b8f557226e985b84e71ead774a47ae9c98e", "author": {"user": {"login": "ianwallen", "name": "Ian"}}, "url": "https://github.com/geonetwork/core-geonetwork/commit/b0298b8f557226e985b84e71ead774a47ae9c98e", "committedDate": "2020-07-03T18:34:40Z", "message": "Updated migration script\nattempted to load titles but failed."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2f81e98203baccb1071648f8d6e0472bc664bb01", "author": {"user": {"login": "ianwallen", "name": "Ian"}}, "url": "https://github.com/geonetwork/core-geonetwork/commit/2f81e98203baccb1071648f8d6e0472bc664bb01", "committedDate": "2020-08-06T13:01:46Z", "message": "Merge branch 'master' of https://github.com/geonetwork/core-geonetwork into restorehistory_pk_fix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e89ab67da98182068a521cfc1d5beabb98f4cd99", "author": {"user": {"login": "ianwallen", "name": "Ian"}}, "url": "https://github.com/geonetwork/core-geonetwork/commit/e89ab67da98182068a521cfc1d5beabb98f4cd99", "committedDate": "2020-08-07T22:56:35Z", "message": "More versioning changes\nChanged titles to LinkedHashMap so that the order is static.\nUpdated status search api so that we can query based on id and uuid.\nUpdated API results\n   Changed RelatedMetadataStatus to only return the id instead of the object.\n   Return titles as a json object (applied temp hack until we upgrade jpa)\n   renamed *statusEmpty to *stateEmpty for consistency\n   Fixed bug with some fields being null when they should have values.\n   Removed *statusDetail as we already had the *state fields from the parent.  If we want them named statusDetail then we should rename the fields in MetadataStatus.\nAlso updated migration script to attempt to fix primary key issue - but may need more work."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "779274618d9126f1ba2f47a8cb17ba3a60068f5e", "author": {"user": {"login": "ianwallen", "name": "Ian"}}, "url": "https://github.com/geonetwork/core-geonetwork/commit/779274618d9126f1ba2f47a8cb17ba3a60068f5e", "committedDate": "2020-08-11T14:37:28Z", "message": "Added @Type annotations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aced878f3962039b8a289eb540682cb4fab40653", "author": {"user": {"login": "ianwallen", "name": "Ian"}}, "url": "https://github.com/geonetwork/core-geonetwork/commit/aced878f3962039b8a289eb540682cb4fab40653", "committedDate": "2020-09-04T10:33:04Z", "message": "Merge branch 'master' of https://github.com/geonetwork/core-geonetwork into restorehistory_pk_fix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aecc4cea12d266521f7eff79968131b80f0feaa3", "author": {"user": {"login": "ianwallen", "name": "Ian"}}, "url": "https://github.com/geonetwork/core-geonetwork/commit/aecc4cea12d266521f7eff79968131b80f0feaa3", "committedDate": "2020-09-14T17:04:35Z", "message": "Fixed H2 migration primary key issues and also completed the rest field migrations issues (except for the the titles)\n    Removed multikey Unique key on metadata status.  It was confusing H2 as it was using the same index for the PK and unique key making it difficult to remove the primary key.\nAdded missing commands in the oracle and mysql scripts."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "41d89b2b3dd6b38775af1a3256a5b3c6071bd92c", "author": {"user": {"login": "ianwallen", "name": "Ian"}}, "url": "https://github.com/geonetwork/core-geonetwork/commit/41d89b2b3dd6b38775af1a3256a5b3c6071bd92c", "committedDate": "2020-09-15T11:01:41Z", "message": "Merge branch 'master' of https://github.com/geonetwork/core-geonetwork into restorehistory_pk_fix\n\n# Conflicts:\n#\tweb/src/main/webapp/WEB-INF/classes/setup/sql/migrate/v3110/migrate-default.sql"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAyMDY2NDM4", "url": "https://github.com/geonetwork/core-geonetwork/pull/4817#pullrequestreview-502066438", "createdAt": "2020-10-05T13:40:13Z", "commit": {"oid": "41d89b2b3dd6b38775af1a3256a5b3c6071bd92c"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxMzo0MDoxM1rOHcdjIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNDoyMjoyNVrOHcfXug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTYwNjMwNA==", "bodyText": "Is this required or can be updated the code that uses this method to use Integer.parseInt?", "url": "https://github.com/geonetwork/core-geonetwork/pull/4817#discussion_r499606304", "createdAt": "2020-10-05T13:40:13Z", "author": {"login": "josegar74"}, "path": "domain/src/main/java/org/fao/geonet/repository/GroupRepositoryCustom.java", "diffHunk": "@@ -36,6 +37,16 @@\n  * @author Jesse\n  */\n public interface GroupRepositoryCustom {\n+    /**\n+     * Find the group with the given groupId (where groupId is a string).  The string will be converted\n+     * to an integer for making the query.\n+     *\n+     * @param groupId the groupid.\n+     * @return the group with the given groupid\n+     */\n+    @Nullable\n+    Group findOne(@Nonnull String groupId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "41d89b2b3dd6b38775af1a3256a5b3c6071bd92c"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTYxNTA2Ng==", "bodyText": "Indentation", "url": "https://github.com/geonetwork/core-geonetwork/pull/4817#discussion_r499615066", "createdAt": "2020-10-05T13:52:30Z", "author": {"login": "josegar74"}, "path": "listeners/src/main/java/org/fao/geonet/listener/metadata/draft/DraftUtilities.java", "diffHunk": "@@ -111,12 +112,17 @@ public AbstractMetadata replaceMetadataWithDraft(AbstractMetadata md, AbstractMe\n             st.setOwner(old.getOwner());\n             st.setPreviousState(old.getPreviousState());\n             st.setStatusValue(old.getStatusValue());\n-            MetadataStatusId id = new MetadataStatusId();\n-            id.setChangeDate(old.getId().getChangeDate());\n-            id.setStatusId(old.getId().getStatusId());\n-            id.setUserId(old.getId().getUserId());\n-            id.setMetadataId(md.getId());\n-            st.setId(id);\n+            st.setChangeDate(old.getChangeDate());\n+            st.setUserId(old.getUserId());\n+            st.setMetadataId(md.getId());\n+            st.setUuid(md.getUuid());\n+            try {\n+            st.setTitles(metadataUtils.extractTitles(Integer.toString(md.getId())));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "41d89b2b3dd6b38775af1a3256a5b3c6071bd92c"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTYxOTg0OA==", "bodyText": "The cardinality of dc:language and dc:title can be higher than 1, not critical as in most cases will be only 1 value, but to check to get the first entry.", "url": "https://github.com/geonetwork/core-geonetwork/pull/4817#discussion_r499619848", "createdAt": "2020-10-05T13:59:14Z", "author": {"login": "josegar74"}, "path": "schemas/dublin-core/src/main/plugin/dublin-core/extract-titles.xsl", "diffHunk": "@@ -0,0 +1,39 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<!--\n+  ~ Copyright (C) 2001-2016 Food and Agriculture Organization of the\n+  ~ United Nations (FAO-UN), United Nations World Food Programme (WFP)\n+  ~ and United Nations Environment Programme (UNEP)\n+  ~\n+  ~ This program is free software; you can redistribute it and/or modify\n+  ~ it under the terms of the GNU General Public License as published by\n+  ~ the Free Software Foundation; either version 2 of the License, or (at\n+  ~ your option) any later version.\n+  ~\n+  ~ This program is distributed in the hope that it will be useful, but\n+  ~ WITHOUT ANY WARRANTY; without even the implied warranty of\n+  ~ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+  ~ General Public License for more details.\n+  ~\n+  ~ You should have received a copy of the GNU General Public License\n+  ~ along with this program; if not, write to the Free Software\n+  ~ Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA\n+  ~\n+  ~ Contact: Jeroen Ticheler - FAO - Viale delle Terme di Caracalla 2,\n+  ~ Rome - Italy. email: geonetwork@osgeo.org\n+  -->\n+\n+<xsl:stylesheet xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"\n+                xmlns:dc=\"http://purl.org/dc/elements/1.1/\"\n+                version=\"1.0\">\n+\n+  <xsl:template match=\"simpledc\">\n+    <titles>\n+      <title>\n+        <xsl:attribute name=\"lang\"><xsl:value-of select=\"dc:language\"/></xsl:attribute>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "41d89b2b3dd6b38775af1a3256a5b3c6071bd92c"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTYzMDY0MQ==", "bodyText": "To check to refactor with the code https://github.com/geonetwork/core-geonetwork/pull/4817/files#diff-668fdf0a09c1a8afb5771c9e85715598R496-R506, seem the same code", "url": "https://github.com/geonetwork/core-geonetwork/pull/4817#discussion_r499630641", "createdAt": "2020-10-05T14:14:53Z", "author": {"login": "josegar74"}, "path": "services/src/main/java/org/fao/geonet/api/records/MetadataWorkflowApi.java", "diffHunk": "@@ -419,23 +442,268 @@ public MetadataStatus convertParameter(int id, MetadataStatusParameter parameter\n         return metadataStatus;\n     }\n \n+    @ApiOperation(\n+            value = \"Get saved content from the status record before changes\",\n+            notes = \"\",\n+            nickname = \"showStatusBefore\")\n+    @RequestMapping(\n+            value = \"/{metadataUuid}/status/{statusId:[0-9]+}.{userId:[0-9]+}.{changeDate}/before\",\n+            method = RequestMethod.GET,\n+            produces = {\n+                    MediaType.APPLICATION_XML_VALUE\n+            })\n+\n+    @PreAuthorize(\"hasRole('Editor')\")\n+    @ApiResponses(value = {\n+            @ApiResponse(code = 200, message = \"Previous version of the record.\"),\n+            @ApiResponse(code = 403, message = ApiParams.API_RESPONSE_NOT_ALLOWED_CAN_EDIT)\n+    })\n+    @ResponseStatus(HttpStatus.OK)\n+    @ResponseBody\n+    public String showStatusBefore(\n+            @ApiParam(value = API_PARAM_RECORD_UUID, required = true) @PathVariable String metadataUuid,\n+            @ApiParam(value = \"Status identifier\", required = true) @PathVariable int statusId,\n+            @ApiParam(value = \"User identifier\", required = true) @PathVariable int userId,\n+            @ApiParam(value = \"Change date\", required = true) @PathVariable String changeDate,\n+            @ApiIgnore @ApiParam(hidden = true) HttpSession httpSession, HttpServletRequest request\n+    )\n+            throws Exception {\n+\n+        MetadataStatus metadataStatus;\n+\n+        metadataStatus = metadataStatusRepository\n+                .findOneByUuidAndStatusValue_IdAndUserIdAndChangeDate(metadataUuid, statusId, userId, new ISODate(changeDate));\n+\n+        if (metadataStatus == null) {\n+            throw new ResourceNotFoundException(\n+                    String.format(\"Can't find metadata status for record '%d', user '%s' at date '%s'. Previous state cannot be viewed\", metadataUuid,\n+                            userId, changeDate));\n+        }\n+\n+        if (!StatusValueType.event.equals(metadataStatus.getStatusValue().getType()) || !ArrayUtils.contains(supportedRestoreStatuses, statusId)) {\n+            throw new NotAllowedException(\"Unsupported action on status type '\" + metadataStatus.getStatusValue().getType() + \"' for metadata '\" + metadataStatus.getUuid() + \"'. Supports status type '\" +\n+                    StatusValueType.event + \"' with the status id '\" + Arrays.toString(supportedRestoreStatuses) + \"'.\");\n+        }\n+\n+        if (metadataStatus.getPreviousState() == null) {\n+            throw new ResourceNotFoundException(\n+                    String.format(\"No data exists for previous state on metadata record '%d', user '%s' at date '%s'. Previous state cannot be viewed\", metadataUuid,\n+                            userId, changeDate));\n+        }\n+\n+        String fullMetadataText = metadataStatus.getPreviousState();\n+\n+        // If record exists then check if user has access.\n+        try {\n+            ApiUtils.canEditRecord(metadataUuid, request);\n+        } catch (SecurityException e) {\n+            Log.debug(API.LOG_MODULE_NAME, e.getMessage(), e);\n+            throw new NotAllowedException(ApiParams.API_RESPONSE_NOT_ALLOWED_CAN_VIEW);\n+        } catch (ResourceNotFoundException e) {\n+            // If metadata record does not exists then it was deleted so\n+            // we will only allow the administrator, owner to view the contents\n+            checkCanViewStatus(fullMetadataText, metadataStatus, httpSession, request);\n+        }\n+\n+        return fullMetadataText;\n+    }\n+\n+    @ApiOperation(\n+            value = \"Get saved content from the status record after changes\",\n+            notes = \"\",\n+            nickname = \"showStatusAfter\")\n+    @RequestMapping(value = \"/{metadataUuid}/status/{statusId:[0-9]+}.{userId:[0-9]+}.{changeDate}/after\",\n+            method = RequestMethod.GET,\n+            produces = {\n+                    MediaType.APPLICATION_XML_VALUE\n+            })\n+\n+    @PreAuthorize(\"hasRole('Editor')\")\n+    @ApiResponses(value = {\n+            @ApiResponse(code = 200, message = \"Version of the record after changes.\"),\n+            @ApiResponse(code = 403, message = ApiParams.API_RESPONSE_NOT_ALLOWED_CAN_EDIT)\n+    })\n+    @ResponseStatus(HttpStatus.OK)\n+    @ResponseBody\n+    public String showStatusAfter(\n+            @ApiParam(value = API_PARAM_RECORD_UUID, required = true) @PathVariable String metadataUuid,\n+            @ApiParam(value = \"Status identifier\", required = true) @PathVariable int statusId,\n+            @ApiParam(value = \"User identifier\", required = true) @PathVariable int userId,\n+            @ApiParam(value = \"Change date\", required = true) @PathVariable String changeDate,\n+            @ApiIgnore @ApiParam(hidden = true) HttpSession httpSession, HttpServletRequest request\n+    )\n+            throws Exception {\n+        MetadataStatus metadataStatus;\n+\n+        metadataStatus = metadataStatusRepository\n+                .findOneByUuidAndStatusValue_IdAndUserIdAndChangeDate(metadataUuid, statusId, userId, new ISODate(changeDate));\n+\n+        if (metadataStatus == null) {\n+            throw new ResourceNotFoundException(\n+                    String.format(\"Can't find metadata status for record '%d', user '%s' at date '%s'. Changes cannot be viewed\", metadataUuid,\n+                            userId, changeDate));\n+        }\n+\n+        if (!StatusValueType.event.equals(metadataStatus.getStatusValue().getType()) || !ArrayUtils.contains(supportedRestoreStatuses, statusId)) {\n+            throw new NotAllowedException(\"Unsupported action on status type '\" + metadataStatus.getStatusValue().getType() + \"' for metadata '\" + metadataStatus.getUuid() + \"'. Supports status type '\" +\n+                    StatusValueType.event + \"' with the status id '\" + Arrays.toString(supportedRestoreStatuses) + \"'.\");\n+        }\n+\n+        if (metadataStatus.getCurrentState() == null) {\n+            throw new ResourceNotFoundException(\n+                    String.format(\"No data exists for metadata record '%d', user '%s' at date '%s'. Changes state cannot be viewed\", metadataUuid,\n+                            userId, changeDate));\n+        }\n+\n+        String fullMetadataText = metadataStatus.getCurrentState();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "41d89b2b3dd6b38775af1a3256a5b3c6071bd92c"}, "originalPosition": 430}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTYzMTIxMA==", "bodyText": "To check to refactor with the code https://github.com/geonetwork/core-geonetwork/pull/4817/files#diff-668fdf0a09c1a8afb5771c9e85715598R496-R506, seem the same code", "url": "https://github.com/geonetwork/core-geonetwork/pull/4817#discussion_r499631210", "createdAt": "2020-10-05T14:15:40Z", "author": {"login": "josegar74"}, "path": "services/src/main/java/org/fao/geonet/api/records/MetadataWorkflowApi.java", "diffHunk": "@@ -419,23 +442,268 @@ public MetadataStatus convertParameter(int id, MetadataStatusParameter parameter\n         return metadataStatus;\n     }\n \n+    @ApiOperation(\n+            value = \"Get saved content from the status record before changes\",\n+            notes = \"\",\n+            nickname = \"showStatusBefore\")\n+    @RequestMapping(\n+            value = \"/{metadataUuid}/status/{statusId:[0-9]+}.{userId:[0-9]+}.{changeDate}/before\",\n+            method = RequestMethod.GET,\n+            produces = {\n+                    MediaType.APPLICATION_XML_VALUE\n+            })\n+\n+    @PreAuthorize(\"hasRole('Editor')\")\n+    @ApiResponses(value = {\n+            @ApiResponse(code = 200, message = \"Previous version of the record.\"),\n+            @ApiResponse(code = 403, message = ApiParams.API_RESPONSE_NOT_ALLOWED_CAN_EDIT)\n+    })\n+    @ResponseStatus(HttpStatus.OK)\n+    @ResponseBody\n+    public String showStatusBefore(\n+            @ApiParam(value = API_PARAM_RECORD_UUID, required = true) @PathVariable String metadataUuid,\n+            @ApiParam(value = \"Status identifier\", required = true) @PathVariable int statusId,\n+            @ApiParam(value = \"User identifier\", required = true) @PathVariable int userId,\n+            @ApiParam(value = \"Change date\", required = true) @PathVariable String changeDate,\n+            @ApiIgnore @ApiParam(hidden = true) HttpSession httpSession, HttpServletRequest request\n+    )\n+            throws Exception {\n+\n+        MetadataStatus metadataStatus;\n+\n+        metadataStatus = metadataStatusRepository\n+                .findOneByUuidAndStatusValue_IdAndUserIdAndChangeDate(metadataUuid, statusId, userId, new ISODate(changeDate));\n+\n+        if (metadataStatus == null) {\n+            throw new ResourceNotFoundException(\n+                    String.format(\"Can't find metadata status for record '%d', user '%s' at date '%s'. Previous state cannot be viewed\", metadataUuid,\n+                            userId, changeDate));\n+        }\n+\n+        if (!StatusValueType.event.equals(metadataStatus.getStatusValue().getType()) || !ArrayUtils.contains(supportedRestoreStatuses, statusId)) {\n+            throw new NotAllowedException(\"Unsupported action on status type '\" + metadataStatus.getStatusValue().getType() + \"' for metadata '\" + metadataStatus.getUuid() + \"'. Supports status type '\" +\n+                    StatusValueType.event + \"' with the status id '\" + Arrays.toString(supportedRestoreStatuses) + \"'.\");\n+        }\n+\n+        if (metadataStatus.getPreviousState() == null) {\n+            throw new ResourceNotFoundException(\n+                    String.format(\"No data exists for previous state on metadata record '%d', user '%s' at date '%s'. Previous state cannot be viewed\", metadataUuid,\n+                            userId, changeDate));\n+        }\n+\n+        String fullMetadataText = metadataStatus.getPreviousState();\n+\n+        // If record exists then check if user has access.\n+        try {\n+            ApiUtils.canEditRecord(metadataUuid, request);\n+        } catch (SecurityException e) {\n+            Log.debug(API.LOG_MODULE_NAME, e.getMessage(), e);\n+            throw new NotAllowedException(ApiParams.API_RESPONSE_NOT_ALLOWED_CAN_VIEW);\n+        } catch (ResourceNotFoundException e) {\n+            // If metadata record does not exists then it was deleted so\n+            // we will only allow the administrator, owner to view the contents\n+            checkCanViewStatus(fullMetadataText, metadataStatus, httpSession, request);\n+        }\n+\n+        return fullMetadataText;\n+    }\n+\n+    @ApiOperation(\n+            value = \"Get saved content from the status record after changes\",\n+            notes = \"\",\n+            nickname = \"showStatusAfter\")\n+    @RequestMapping(value = \"/{metadataUuid}/status/{statusId:[0-9]+}.{userId:[0-9]+}.{changeDate}/after\",\n+            method = RequestMethod.GET,\n+            produces = {\n+                    MediaType.APPLICATION_XML_VALUE\n+            })\n+\n+    @PreAuthorize(\"hasRole('Editor')\")\n+    @ApiResponses(value = {\n+            @ApiResponse(code = 200, message = \"Version of the record after changes.\"),\n+            @ApiResponse(code = 403, message = ApiParams.API_RESPONSE_NOT_ALLOWED_CAN_EDIT)\n+    })\n+    @ResponseStatus(HttpStatus.OK)\n+    @ResponseBody\n+    public String showStatusAfter(\n+            @ApiParam(value = API_PARAM_RECORD_UUID, required = true) @PathVariable String metadataUuid,\n+            @ApiParam(value = \"Status identifier\", required = true) @PathVariable int statusId,\n+            @ApiParam(value = \"User identifier\", required = true) @PathVariable int userId,\n+            @ApiParam(value = \"Change date\", required = true) @PathVariable String changeDate,\n+            @ApiIgnore @ApiParam(hidden = true) HttpSession httpSession, HttpServletRequest request\n+    )\n+            throws Exception {\n+        MetadataStatus metadataStatus;\n+\n+        metadataStatus = metadataStatusRepository\n+                .findOneByUuidAndStatusValue_IdAndUserIdAndChangeDate(metadataUuid, statusId, userId, new ISODate(changeDate));\n+\n+        if (metadataStatus == null) {\n+            throw new ResourceNotFoundException(\n+                    String.format(\"Can't find metadata status for record '%d', user '%s' at date '%s'. Changes cannot be viewed\", metadataUuid,\n+                            userId, changeDate));\n+        }\n+\n+        if (!StatusValueType.event.equals(metadataStatus.getStatusValue().getType()) || !ArrayUtils.contains(supportedRestoreStatuses, statusId)) {\n+            throw new NotAllowedException(\"Unsupported action on status type '\" + metadataStatus.getStatusValue().getType() + \"' for metadata '\" + metadataStatus.getUuid() + \"'. Supports status type '\" +\n+                    StatusValueType.event + \"' with the status id '\" + Arrays.toString(supportedRestoreStatuses) + \"'.\");\n+        }\n+\n+        if (metadataStatus.getCurrentState() == null) {\n+            throw new ResourceNotFoundException(\n+                    String.format(\"No data exists for metadata record '%d', user '%s' at date '%s'. Changes state cannot be viewed\", metadataUuid,\n+                            userId, changeDate));\n+        }\n+\n+        String fullMetadataText = metadataStatus.getCurrentState();\n+\n+        // If record exists then check if user has access.\n+        try {\n+            ApiUtils.canEditRecord(metadataUuid, request);\n+        } catch (SecurityException e) {\n+            Log.debug(API.LOG_MODULE_NAME, e.getMessage(), e);\n+            throw new NotAllowedException(ApiParams.API_RESPONSE_NOT_ALLOWED_CAN_VIEW);\n+        } catch (ResourceNotFoundException e) {\n+            // If metadata record does not exists then it was deleted so\n+            // we will only allow the administrator, owner to view the contents\n+            checkCanViewStatus(fullMetadataText, metadataStatus, httpSession, request);\n+        }\n+\n+        return fullMetadataText;\n+    }\n+\n+    @ApiOperation(\n+            value = \"Restore saved content from a status record\",\n+            notes = \"\",\n+            nickname = \"restoreAtStatusSave\")\n+    @RequestMapping(\n+            value = \"/{metadataUuid}/status/{statusId:[0-9]+}.{userId:[0-9]+}.{changeDate}/restore\",\n+            method = RequestMethod.POST\n+            )\n+    @PreAuthorize(\"hasRole('Editor')\")\n+    @ApiResponses(value = {\n+            @ApiResponse(code = 200, message = \"Record restored.\"),\n+            @ApiResponse(code = 403, message = ApiParams.API_RESPONSE_NOT_ALLOWED_CAN_EDIT)\n+    })\n+    @ResponseStatus(HttpStatus.OK)\n+    @ResponseBody\n+    public void restoreAtStatusSave(\n+            @ApiParam(value = API_PARAM_RECORD_UUID, required = true) @PathVariable String metadataUuid,\n+            @ApiParam(value = \"Status identifier\", required = true) @PathVariable int statusId,\n+            @ApiParam(value = \"User identifier\", required = true) @PathVariable int userId,\n+            @ApiParam(value = \"Change date\", required = true) @PathVariable String changeDate,\n+            @ApiIgnore @ApiParam(hidden = true) HttpSession httpSession, HttpServletRequest request\n+            )\n+                    throws Exception {\n+\n+        ApplicationContext applicationContext = ApplicationContextHolder.get();\n+        DataManager dataMan = applicationContext.getBean(DataManager.class);\n+\n+        MetadataStatus metadataStatus = metadataStatusRepository\n+                .findOneByUuidAndStatusValue_IdAndUserIdAndChangeDate(metadataUuid, statusId, userId, new ISODate(changeDate));\n+\n+        if (metadataStatus == null) {\n+            throw new ResourceNotFoundException(\n+                    String.format(\"Can't find metadata status for record '%d', user '%s' at date '%s'. Record cannot be restored\", metadataUuid,\n+                            userId, changeDate));\n+        }\n+\n+        if (!StatusValueType.event.equals(metadataStatus.getStatusValue().getType()) || !ArrayUtils.contains(supportedRestoreStatuses, statusId)) {\n+            throw new NotAllowedException(\"The recover for this element is not supported. Supports status type '\" +\n+                    StatusValueType.event + \"' with the status id '\" + Arrays.toString(supportedRestoreStatuses) +\n+                    \"'. Received status type '\" + metadataStatus.getStatusValue().getType() + \"' with status id '\" + statusId + \"'\");\n+        }\n+\n+        if (metadataStatus.getPreviousState() == null) {\n+            throw new ResourceNotFoundException(\n+                    String.format(\"No data exists for previous state on metadata record '%d', user '%s' at date '%s'. Record cannot be restrored\", metadataUuid,\n+                            userId, changeDate));\n+        }\n+\n+        AbstractMetadata metadata = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "41d89b2b3dd6b38775af1a3256a5b3c6071bd92c"}, "originalPosition": 495}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTYzNjE1NA==", "bodyText": "Not sure how this works with the workflow enabled and the draft metadata copies, as there're 2 metadata with different id, but same uuid.", "url": "https://github.com/geonetwork/core-geonetwork/pull/4817#discussion_r499636154", "createdAt": "2020-10-05T14:22:25Z", "author": {"login": "josegar74"}, "path": "web-ui/src/main/resources/catalog/components/history/GnHistoryService.js", "diffHunk": "@@ -35,17 +35,22 @@\n         '$http', '$filter',\n       function($http, $filter) {\n         this.delete = function (step) {\n-          return $http.delete('../api/records/' + step.id.metadataId + '/status/' +\n-            step.id.statusId + '.' + step.id.userId + '.' + step.id.changeDate.dateAndTime);\n+          return $http.delete('../api/records/' + step.uuid + '/status/' +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "41d89b2b3dd6b38775af1a3256a5b3c6071bd92c"}, "originalPosition": 6}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2ce1d69ec12e741e03e7725731a4e3ef363160a8", "author": {"user": {"login": "ianwallen", "name": "Ian"}}, "url": "https://github.com/geonetwork/core-geonetwork/commit/2ce1d69ec12e741e03e7725731a4e3ef363160a8", "committedDate": "2020-10-06T20:33:50Z", "message": "Revert grouprepository findOne as it was not required.\nFixed indentation\nGet first language in case there are multiple for the dc:language."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "da9721301c688b6579519fc66f4502aa846d2498", "author": {"user": {"login": "ianwallen", "name": "Ian"}}, "url": "https://github.com/geonetwork/core-geonetwork/commit/da9721301c688b6579519fc66f4502aa846d2498", "committedDate": "2020-10-07T14:38:58Z", "message": "Merge branch 'master' of https://github.com/geonetwork/core-geonetwork into restorehistory_pk_fix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "21b5b30540940648e71f056e7f9dbb756d2111df", "author": {"user": {"login": "ianwallen", "name": "Ian"}}, "url": "https://github.com/geonetwork/core-geonetwork/commit/21b5b30540940648e71f056e7f9dbb756d2111df", "committedDate": "2020-10-08T15:28:09Z", "message": "Another fix for groupowner - for sample data which does not belong to a group.\nRenamed deleteAllByMetadataId back to deleteAllById_MetadataId - There are lots of others that should be renamed and this will be done as separate pr.\nRevert api calls using uuid as it could cause issues with drafts.\n    Updated api to support metadataUuid being a metadata id or uuid"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9a8f80fc696fa93d4bbc39972bbe0b35a90033a8", "author": {"user": {"login": "ianwallen", "name": "Ian"}}, "url": "https://github.com/geonetwork/core-geonetwork/commit/9a8f80fc696fa93d4bbc39972bbe0b35a90033a8", "committedDate": "2020-10-08T16:07:03Z", "message": "Removed sequence name from annotation - issue will be resolved in version 4 of geonetwork (see https://github.com/geonetwork/core-geonetwork/pull/5003)\nupdate migration to support sequence or hybernate_sequence"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cd0ece6fe57126036e2e6128e9df77b2b9df483a", "author": {"user": {"login": "ianwallen", "name": "Ian"}}, "url": "https://github.com/geonetwork/core-geonetwork/commit/cd0ece6fe57126036e2e6128e9df77b2b9df483a", "committedDate": "2020-10-08T21:18:27Z", "message": "Refactor - cleanup duplicate code for showing before/after versions."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3c0bbe48728259c8fcefea3235e295da4bdaaa88", "author": {"user": {"login": "ianwallen", "name": "Ian"}}, "url": "https://github.com/geonetwork/core-geonetwork/commit/3c0bbe48728259c8fcefea3235e295da4bdaaa88", "committedDate": "2020-10-09T11:38:30Z", "message": "Fix encoding issue. - File should be UTF-8"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e6274d205f7de08c837fd2a5de6ad0c39de12cc1", "author": {"user": {"login": "ianwallen", "name": "Ian"}}, "url": "https://github.com/geonetwork/core-geonetwork/commit/e6274d205f7de08c837fd2a5de6ad0c39de12cc1", "committedDate": "2020-10-09T11:40:10Z", "message": "Titles will be null on migration so allow for null values. Otherwise jpa calls may fail."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f2670b19538a30733f6a131f369818c03b05491a", "author": {"user": {"login": "ianwallen", "name": "Ian"}}, "url": "https://github.com/geonetwork/core-geonetwork/commit/f2670b19538a30733f6a131f369818c03b05491a", "committedDate": "2020-10-14T11:41:31Z", "message": "Added some corrections so that the migration works with PostgreSQL"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "73accd2229c4e308868c2e1791a3c0e7e88dd9e3", "author": {"user": {"login": "ianwallen", "name": "Ian"}}, "url": "https://github.com/geonetwork/core-geonetwork/commit/73accd2229c4e308868c2e1791a3c0e7e88dd9e3", "committedDate": "2020-10-14T15:06:25Z", "message": "Added xsl to extra titles for iso19115-3.2018"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1NDE1NDU0", "url": "https://github.com/geonetwork/core-geonetwork/pull/4817#pullrequestreview-515415454", "createdAt": "2020-10-23T07:38:09Z", "commit": {"oid": "73accd2229c4e308868c2e1791a3c0e7e88dd9e3"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwNzozODowOVrOHnCNeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwNzo0MToyN1rOHnCULA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY5MjczMA==", "bodyText": "To check if this code can be changed by AccessManager.getGroups", "url": "https://github.com/geonetwork/core-geonetwork/pull/4817#discussion_r510692730", "createdAt": "2020-10-23T07:38:09Z", "author": {"login": "josegar74"}, "path": "services/src/main/java/org/fao/geonet/api/records/MetadataWorkflowApi.java", "diffHunk": "@@ -497,41 +687,219 @@ public MetadataStatus convertParameter(int id, MetadataStatusParameter parameter\n \n     private String extractCurrentStatus(MetadataStatus s) {\n         switch (Integer.toString(s.getStatusValue().getId())) {\n-        case StatusValue.Events.ATTACHMENTADDED:\n-            return s.getCurrentState();\n-        case StatusValue.Events.RECORDOWNERCHANGE:\n-            return ObjectJSONUtils.extractFieldFromJSONString(s.getCurrentState(), \"owner\", \"name\");\n-        case StatusValue.Events.RECORDGROUPOWNERCHANGE:\n-            return ObjectJSONUtils.extractFieldFromJSONString(s.getCurrentState(), \"owner\", \"name\");\n-        case StatusValue.Events.RECORDPROCESSINGCHANGE:\n-            return ObjectJSONUtils.extractFieldFromJSONString(s.getCurrentState(), \"process\");\n-        case StatusValue.Events.RECORDCATEGORYCHANGE:\n-            List<String> categories = ObjectJSONUtils.extractListOfFieldFromJSONString(s.getCurrentState(), \"category\",\n-                    \"name\");\n-            StringBuffer categoriesAsString = new StringBuffer(\"[ \");\n-            for (String categoryName : categories) {\n-                categoriesAsString.append(categoryName + \" \");\n-            }\n-            categoriesAsString.append(\"]\");\n-            return categoriesAsString.toString();\n-        case StatusValue.Events.RECORDVALIDATIONTRIGGERED:\n-            return s.getCurrentState().equals(\"1\") ? \"OK\" : \"KO\";\n-        default:\n-            return \"\";\n+            case StatusValue.Events.ATTACHMENTADDED:\n+                return s.getCurrentState();\n+            case StatusValue.Events.RECORDOWNERCHANGE:\n+                return ObjectJSONUtils.extractFieldFromJSONString(s.getCurrentState(), \"owner\", \"name\");\n+            case StatusValue.Events.RECORDGROUPOWNERCHANGE:\n+                return ObjectJSONUtils.extractFieldFromJSONString(s.getCurrentState(), \"owner\", \"name\");\n+            case StatusValue.Events.RECORDPROCESSINGCHANGE:\n+                return ObjectJSONUtils.extractFieldFromJSONString(s.getCurrentState(), \"process\");\n+            case StatusValue.Events.RECORDCATEGORYCHANGE:\n+                List<String> categories = ObjectJSONUtils.extractListOfFieldFromJSONString(s.getCurrentState(), \"category\",\n+                        \"name\");\n+                StringBuffer categoriesAsString = new StringBuffer(\"[ \");\n+                for (String categoryName : categories) {\n+                    categoriesAsString.append(categoryName + \" \");\n+                }\n+                categoriesAsString.append(\"]\");\n+                return categoriesAsString.toString();\n+            case StatusValue.Events.RECORDVALIDATIONTRIGGERED:\n+                return s.getCurrentState().equals(\"1\") ? \"OK\" : \"KO\";\n+            default:\n+                return \"\";\n         }\n     }\n \n     private String extractPreviousStatus(MetadataStatus s) {\n         switch (Integer.toString(s.getStatusValue().getId())) {\n-        case StatusValue.Events.ATTACHMENTDELETED:\n-            return s.getPreviousState();\n-        case StatusValue.Events.RECORDOWNERCHANGE:\n-            return ObjectJSONUtils.extractFieldFromJSONString(s.getPreviousState(), \"owner\", \"name\");\n-        case StatusValue.Events.RECORDGROUPOWNERCHANGE:\n-            return ObjectJSONUtils.extractFieldFromJSONString(s.getPreviousState(), \"owner\", \"name\");\n-        default:\n-            return \"\";\n+            case StatusValue.Events.ATTACHMENTDELETED:\n+                return s.getPreviousState();\n+            case StatusValue.Events.RECORDOWNERCHANGE:\n+                return ObjectJSONUtils.extractFieldFromJSONString(s.getPreviousState(), \"owner\", \"name\");\n+            case StatusValue.Events.RECORDGROUPOWNERCHANGE:\n+                return ObjectJSONUtils.extractFieldFromJSONString(s.getPreviousState(), \"owner\", \"name\");\n+            default:\n+                return \"\";\n+        }\n+    }\n+\n+    private void checkCanViewStatus(String metadata, MetadataStatus metadataStatus, HttpSession httpSession, HttpServletRequest request) throws Exception {\n+        Element xmlElement = null;\n+        try {\n+            xmlElement = Xml.loadString(metadata, false);\n+        } catch (JDOMParseException ex) {\n+            throw new IllegalArgumentException(\n+                    String.format(\"XML fragment is invalid. Error is %s\", ex.getMessage()));\n+        }\n+\n+        Element info = xmlElement.getChild(Edit.RootChild.INFO, Edit.NAMESPACE);\n+        if (info == null) {\n+            throw new IllegalArgumentException(\"Can't locate required geonet:info which is required for the recovery. May need to manually re-import the data\");\n+        }\n+\n+        String groupOwnerName = info.getChildText(Edit.Info.Elem.GROUPOWNERNAME);\n+\n+        String groupId = null;\n+        if (groupOwnerName != null) {\n+            Group groupEntity = groupRepository.findByName(groupOwnerName);\n+            if (groupEntity != null) {\n+                groupId = String.valueOf(groupEntity.getId());\n+            }\n+        }\n+\n+        UserSession user = ApiUtils.getUserSession(httpSession);\n+        if (user.getProfile() != Profile.Administrator) {\n+            if (groupId != null) {\n+                final Specifications<UserGroup> spec = where(UserGroupSpecs.hasProfile(Profile.Editor))\n+                        .and(UserGroupSpecs.hasUserId(user.getUserIdAsInt()))\n+                        .and(UserGroupSpecs.hasGroupId(Integer.valueOf(groupId)));\n+\n+                final List<UserGroup> userGroups = userGroupRepository.findAll(spec);\n+\n+                if (userGroups.size() == 0) {\n+                    throw new SecurityException(\n+                            String.format(\"You can't view history from this group (\" + groupOwnerName + \"). User MUST be an Editor in that group\"));\n+                }\n+            } else {\n+                throw new SecurityException(\n+                        String.format(\"Error identify group where this metadata belong to. Only administrator can restore this record\"));\n+            }\n         }\n     }\n \n+    private int reloadRecord(MetadataStatus metadataStatus, Element md, IMetadataManager iMetadataManager, HttpSession httpSession, HttpServletRequest request) throws Exception {\n+\n+        Element info = md.getChild(Edit.RootChild.INFO, Edit.NAMESPACE);\n+        if (info == null) {\n+            throw new IllegalArgumentException(\"Can't location geonet:info which is required for the recovery. May need to manually re-import the data\");\n+        }\n+\n+        md = metadataUtils.removeMetadataInfo(md);\n+\n+        String groupOwnerName = info.getChildText(Edit.Info.Elem.GROUPOWNERNAME);\n+\n+        String groupId = null;\n+        if (groupOwnerName != null) {\n+            Group groupEntity = groupRepository.findByName(groupOwnerName);\n+            if (groupEntity != null) {\n+                groupId = String.valueOf(groupEntity.getId());\n+            }\n+        }\n+\n+        UserSession user = ApiUtils.getUserSession(httpSession);\n+        if (user.getProfile() != Profile.Administrator) {\n+            if (groupId != null) {\n+                final Specifications<UserGroup> spec = where(UserGroupSpecs.hasProfile(Profile.Editor))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73accd2229c4e308868c2e1791a3c0e7e88dd9e3"}, "originalPosition": 696}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY5MjgwNw==", "bodyText": "To check if this code can be changed by AccessManager.getGroups", "url": "https://github.com/geonetwork/core-geonetwork/pull/4817#discussion_r510692807", "createdAt": "2020-10-23T07:38:18Z", "author": {"login": "josegar74"}, "path": "services/src/main/java/org/fao/geonet/api/records/MetadataWorkflowApi.java", "diffHunk": "@@ -497,41 +687,219 @@ public MetadataStatus convertParameter(int id, MetadataStatusParameter parameter\n \n     private String extractCurrentStatus(MetadataStatus s) {\n         switch (Integer.toString(s.getStatusValue().getId())) {\n-        case StatusValue.Events.ATTACHMENTADDED:\n-            return s.getCurrentState();\n-        case StatusValue.Events.RECORDOWNERCHANGE:\n-            return ObjectJSONUtils.extractFieldFromJSONString(s.getCurrentState(), \"owner\", \"name\");\n-        case StatusValue.Events.RECORDGROUPOWNERCHANGE:\n-            return ObjectJSONUtils.extractFieldFromJSONString(s.getCurrentState(), \"owner\", \"name\");\n-        case StatusValue.Events.RECORDPROCESSINGCHANGE:\n-            return ObjectJSONUtils.extractFieldFromJSONString(s.getCurrentState(), \"process\");\n-        case StatusValue.Events.RECORDCATEGORYCHANGE:\n-            List<String> categories = ObjectJSONUtils.extractListOfFieldFromJSONString(s.getCurrentState(), \"category\",\n-                    \"name\");\n-            StringBuffer categoriesAsString = new StringBuffer(\"[ \");\n-            for (String categoryName : categories) {\n-                categoriesAsString.append(categoryName + \" \");\n-            }\n-            categoriesAsString.append(\"]\");\n-            return categoriesAsString.toString();\n-        case StatusValue.Events.RECORDVALIDATIONTRIGGERED:\n-            return s.getCurrentState().equals(\"1\") ? \"OK\" : \"KO\";\n-        default:\n-            return \"\";\n+            case StatusValue.Events.ATTACHMENTADDED:\n+                return s.getCurrentState();\n+            case StatusValue.Events.RECORDOWNERCHANGE:\n+                return ObjectJSONUtils.extractFieldFromJSONString(s.getCurrentState(), \"owner\", \"name\");\n+            case StatusValue.Events.RECORDGROUPOWNERCHANGE:\n+                return ObjectJSONUtils.extractFieldFromJSONString(s.getCurrentState(), \"owner\", \"name\");\n+            case StatusValue.Events.RECORDPROCESSINGCHANGE:\n+                return ObjectJSONUtils.extractFieldFromJSONString(s.getCurrentState(), \"process\");\n+            case StatusValue.Events.RECORDCATEGORYCHANGE:\n+                List<String> categories = ObjectJSONUtils.extractListOfFieldFromJSONString(s.getCurrentState(), \"category\",\n+                        \"name\");\n+                StringBuffer categoriesAsString = new StringBuffer(\"[ \");\n+                for (String categoryName : categories) {\n+                    categoriesAsString.append(categoryName + \" \");\n+                }\n+                categoriesAsString.append(\"]\");\n+                return categoriesAsString.toString();\n+            case StatusValue.Events.RECORDVALIDATIONTRIGGERED:\n+                return s.getCurrentState().equals(\"1\") ? \"OK\" : \"KO\";\n+            default:\n+                return \"\";\n         }\n     }\n \n     private String extractPreviousStatus(MetadataStatus s) {\n         switch (Integer.toString(s.getStatusValue().getId())) {\n-        case StatusValue.Events.ATTACHMENTDELETED:\n-            return s.getPreviousState();\n-        case StatusValue.Events.RECORDOWNERCHANGE:\n-            return ObjectJSONUtils.extractFieldFromJSONString(s.getPreviousState(), \"owner\", \"name\");\n-        case StatusValue.Events.RECORDGROUPOWNERCHANGE:\n-            return ObjectJSONUtils.extractFieldFromJSONString(s.getPreviousState(), \"owner\", \"name\");\n-        default:\n-            return \"\";\n+            case StatusValue.Events.ATTACHMENTDELETED:\n+                return s.getPreviousState();\n+            case StatusValue.Events.RECORDOWNERCHANGE:\n+                return ObjectJSONUtils.extractFieldFromJSONString(s.getPreviousState(), \"owner\", \"name\");\n+            case StatusValue.Events.RECORDGROUPOWNERCHANGE:\n+                return ObjectJSONUtils.extractFieldFromJSONString(s.getPreviousState(), \"owner\", \"name\");\n+            default:\n+                return \"\";\n+        }\n+    }\n+\n+    private void checkCanViewStatus(String metadata, MetadataStatus metadataStatus, HttpSession httpSession, HttpServletRequest request) throws Exception {\n+        Element xmlElement = null;\n+        try {\n+            xmlElement = Xml.loadString(metadata, false);\n+        } catch (JDOMParseException ex) {\n+            throw new IllegalArgumentException(\n+                    String.format(\"XML fragment is invalid. Error is %s\", ex.getMessage()));\n+        }\n+\n+        Element info = xmlElement.getChild(Edit.RootChild.INFO, Edit.NAMESPACE);\n+        if (info == null) {\n+            throw new IllegalArgumentException(\"Can't locate required geonet:info which is required for the recovery. May need to manually re-import the data\");\n+        }\n+\n+        String groupOwnerName = info.getChildText(Edit.Info.Elem.GROUPOWNERNAME);\n+\n+        String groupId = null;\n+        if (groupOwnerName != null) {\n+            Group groupEntity = groupRepository.findByName(groupOwnerName);\n+            if (groupEntity != null) {\n+                groupId = String.valueOf(groupEntity.getId());\n+            }\n+        }\n+\n+        UserSession user = ApiUtils.getUserSession(httpSession);\n+        if (user.getProfile() != Profile.Administrator) {\n+            if (groupId != null) {\n+                final Specifications<UserGroup> spec = where(UserGroupSpecs.hasProfile(Profile.Editor))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73accd2229c4e308868c2e1791a3c0e7e88dd9e3"}, "originalPosition": 657}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY5NDQ0NA==", "bodyText": "Remove commented code", "url": "https://github.com/geonetwork/core-geonetwork/pull/4817#discussion_r510694444", "createdAt": "2020-10-23T07:41:27Z", "author": {"login": "josegar74"}, "path": "web/src/main/webapp/WEB-INF/classes/setup/sql/migrate/v3110/UpdateMetadataStatus.java", "diffHunk": "@@ -0,0 +1,421 @@\n+/*\n+ * Copyright (C) 2001-2018 Food and Agriculture Organization of the\n+ * United Nations (FAO-UN), United Nations World Food Programme (WFP)\n+ * and United Nations Environment Programme (UNEP)\n+ *\n+ * This program is free software; you can redistribute it and/or modify\n+ * it under the terms of the GNU General Public License as published by\n+ * the Free Software Foundation; either version 2 of the License, or (at\n+ * your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful, but\n+ * WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU General Public License\n+ * along with this program; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA\n+ *\n+ * Contact: Jeroen Ticheler - FAO - Viale delle Terme di Caracalla 2,\n+ * Rome - Italy. email: geonetwork@osgeo.org\n+ */\n+\n+package v3110;\n+\n+import org.fao.geonet.DatabaseMigrationTask;\n+import org.fao.geonet.domain.MetadataStatus;\n+import org.fao.geonet.domain.MetadataStatus_;\n+import org.fao.geonet.kernel.datamanager.IMetadataUtils;\n+import org.fao.geonet.constants.Geonet;\n+import org.fao.geonet.repository.MetadataStatusRepository;\n+import org.fao.geonet.utils.Log;\n+import org.hibernate.dialect.Dialect;\n+import org.hibernate.engine.jdbc.dialect.internal.StandardDialectResolver;\n+import org.hibernate.engine.jdbc.dialect.spi.DatabaseMetaDataDialectResolutionInfoAdapter;\n+import org.hibernate.engine.jdbc.dialect.spi.DialectResolutionInfo;\n+import org.springframework.context.ApplicationContext;\n+import org.springframework.data.domain.Page;\n+import org.springframework.data.domain.PageRequest;\n+import org.springframework.data.domain.Pageable;\n+import org.springframework.data.domain.Sort;\n+\n+import java.sql.*;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+/**\n+ * Class to be executed during the migration which will update some new not null columns\n+ * on the metadataStatus table.\n+ *\n+ * Note: After this step is complete most of the changes should be in place however their may still be\n+ * some missing JPA settings that would initially fail due to these NOT NULL columns.\n+ *\n+ * It is recommended that after the initial startup and migration execution that the system be stopped and\n+ * restarted to ensure that all JPA settings are applied correctly.\n+ */\n+public class UpdateMetadataStatus extends DatabaseMigrationTask {\n+\n+    private MetadataStatusRepository metadataStatusRepository;\n+    private IMetadataUtils metadataUtils;\n+\n+    /**\n+     * Override the setContext so do the autowire of the other fields.\n+     * @param applicationContext\n+     */\n+    @Override\n+    public void setContext(ApplicationContext applicationContext)  {\n+        super.setContext(applicationContext);\n+        metadataUtils = applicationContext.getBean(IMetadataUtils.class);\n+        metadataStatusRepository = applicationContext.getBean(MetadataStatusRepository.class);\n+    }\n+\n+    /**\n+     * Maing flow for the updating of the ID. UUID and TITLES fields\n+     * @param connection\n+     * @throws SQLException\n+     */\n+        @Override\n+    public void update(Connection connection) throws SQLException {\n+\n+        final MetadataStatus metadataStatusObject = new MetadataStatus();\n+\n+            DialectResolutionInfo dialectResolutionInfo = new DatabaseMetaDataDialectResolutionInfoAdapter(connection.getMetaData());\n+            Dialect dialect = new StandardDialectResolver().resolveDialect(dialectResolutionInfo);\n+\n+            Log.debug(Geonet.DB, \"UpdateMetadataStatus\");\n+\n+            // First add the id and uuid as nullable.\n+            addMissingColumn(connection, dialect);\n+\n+            // Now update the id to sequence values so that all id's are not null.\n+            updatePKValue(connection, dialect);\n+\n+            // Now update uuid and titles for the existing records\n+            updateOtherNewFields();\n+            // commit the changes\n+            connection.commit();\n+\n+            // finallize the change\n+            finalizeChanges(connection, dialect);\n+    }\n+\n+    /**\n+     *  JPA will not be able to create the ID and UUID because they are not null\n+     *  So we need to add them as nullable initially until we update all the data in the tables.\n+     *\n+     * @param connection\n+     * @param dialect - specific to each database - i.e. oracke, h2, postgresl...\n+     * @throws SQLException\n+     */\n+    private void addMissingColumn(final Connection connection, Dialect dialect ) throws SQLException {\n+        try (Statement statement = connection.createStatement()) {\n+            statement.execute(\"ALTER TABLE \" + MetadataStatus.TABLE_NAME + \" \" + dialect.getAddColumnString() + \"  \" + MetadataStatus_.id.getName() + \" INTEGER NULL\");\n+        } catch (Exception e) {\n+            // If there was an error then we will log the error and continue.\n+            // Most likely cause is that the column already exists which should be fine.\n+            Log.error(Geonet.DB, \"  Exception while adding new \" + MetadataStatus_.id.getName() + \" column to \" + MetadataStatus.TABLE_NAME + \". \" + \n+                    \"Error is: \" + e.getMessage());\n+            Log.debug(Geonet.DB, e);\n+        }\n+        try (Statement statement = connection.createStatement()) {\n+            statement.execute(\"ALTER TABLE \" + MetadataStatus.TABLE_NAME + \" \" + dialect.getAddColumnString() + \"  \" + MetadataStatus_.uuid.getName() + \" VARCHAR(255) NULL\");\n+        } catch (Exception e) {\n+            // If there was an erro then we will log the error and continue.\n+            // Most likely cause is that the column already exists which should be fine.\n+            Log.error(Geonet.DB, \"  Exception while adding new \" + MetadataStatus_.uuid.getName() + \" column to \" + MetadataStatus.TABLE_NAME + \". \" +\n+                    \"Error is: \" + e.getMessage());\n+            Log.debug(Geonet.DB, e);\n+        }\n+\n+        connection.commit();\n+    }\n+\n+    /**\n+     * Update the ID (primary key field) for the database to be equal to the sequence values.\n+     * @param connection\n+     * @param dialect - specific to each database - i.e. oracke, h2, postgresl...\n+     * @throws SQLException\n+     */\n+\n+    private void updatePKValue(final Connection connection, Dialect dialect) throws SQLException {\n+\n+        String HIBERNATE_SEQUENCE = getDatabaseObjectName(connection, \"HIBERNATE_SEQUENCE\");\n+\n+        Statement statement = null;\n+        Integer rowcount = null;\n+        try {\n+            statement = connection.createStatement();\n+            try {\n+                rowcount = statement.executeUpdate(\"update \" + MetadataStatus.TABLE_NAME +\n+                        \" set \" + MetadataStatus_.id.getName() + \" = \" + dialect.getSelectSequenceNextValString(MetadataStatus.ID_SEQ_NAME) +\n+                        \" where \" + MetadataStatus_.id.getName() + \" IS NULL\");\n+            } catch (SQLException e1) {\n+                try {\n+                    connection.rollback();\n+                    if (statement != null) {\n+                        statement.close();\n+                    }\n+                    statement = connection.createStatement();\n+                    rowcount = statement.executeUpdate(\"update \" + MetadataStatus.TABLE_NAME +\n+                            \" set \" + MetadataStatus_.id.getName() + \" = \" + dialect.getSelectSequenceNextValString(HIBERNATE_SEQUENCE) +\n+                            \" where \" + MetadataStatus_.id.getName() + \" IS NULL\");\n+                } catch (SQLException e2) {\n+                    throw new SQLException(\"Error updating table \\\"\" + MetadataStatus.TABLE_NAME + \".\" + MetadataStatus_.id.getName() +\n+                            \"\\\" values to sequence value using sequence \\\"\" + MetadataStatus.ID_SEQ_NAME + \"\\\" and \\\"\" + HIBERNATE_SEQUENCE + \"\\\"\\n\" + e1.getMessage() + \"\\n\", e2);\n+                }\n+            }\n+        } finally {\n+            if (statement != null) {\n+                statement.close();\n+            }\n+        }\n+\n+        // Need to commit changes or they it will not be available to JPA calls.\n+        connection.commit();\n+\n+        Log.info(Geonet.DB, \"Migration: Updated \" + rowcount + \" primary key values for '\" + MetadataStatus.TABLE_NAME + \"'\");\n+    }\n+\n+    /**\n+     * Update the new UUID and Titles field based on existing data.\n+     * @throws SQLException\n+     */\n+    private void updateOtherNewFields() throws SQLException {\n+\n+        Pageable pageRequest = new PageRequest(0, 1000, new Sort(\"id\"));\n+        int totalRowCount = 0;\n+        int updateRowCount = 0;\n+        int uuidRowCount = 0;\n+        int titleRowCount = 0;\n+        Map<Integer, LinkedHashMap<String, String>> titlesMap = new HashMap<>();\n+        Map<Integer, String> uuidMap = new HashMap<>();\n+        //List<Language> languages = languageRepository.findAll();\n+        Page<MetadataStatus> page;\n+        do {\n+            page = metadataStatusRepository.findAll(pageRequest);\n+            if (page != null && page.hasContent()) {\n+                for (MetadataStatus metadataStatus : page.getContent()) {\n+                    totalRowCount++;\n+                    if (metadataStatus.getUuid() == null || metadataStatus.getUuid().length() == 0 ||\n+                            metadataStatus.getTitles() == null || metadataStatus.getTitles().size() == 0) {\n+\n+                        boolean changeflag = false;\n+                        if (metadataStatus.getUuid() == null || metadataStatus.getUuid().length() == 0) {\n+                            String uuid = uuidMap.get(metadataStatus.getMetadataId());\n+                            if (uuid == null) {\n+                                try {\n+                                    uuid = metadataUtils.getMetadataUuid(Integer.toString(metadataStatus.getMetadataId()));\n+                                    if (uuid != null) {\n+                                        uuidMap.put(metadataStatus.getMetadataId(), uuid);\n+                                    }\n+                                } catch (Exception e) {\n+                                    Log.error(Geonet.DATA_MANAGER, String.format(\n+                                            \"Error locating uuid for metadata id: %d\", +metadataStatus.getMetadataId()), e);\n+                                }\n+                                if (uuid == null || uuid.length() == 0) {\n+                                    Log.error(Geonet.DATA_MANAGER, String.format(\n+                                            \"Could not located uuid for metadata id: %d\", + metadataStatus.getMetadataId()));\n+                                }\n+                            }\n+                            if (uuid != null && uuid.length() > 0) {\n+                                metadataStatus.setUuid(uuid);\n+                                uuidRowCount++;\n+                                changeflag = true;\n+                            }\n+                        }\n+                        if (metadataStatus.getTitles() == null || metadataStatus.getTitles().size() == 0) {\n+                            LinkedHashMap<String, String> titles = titlesMap.get(metadataStatus.getMetadataId());\n+                            // Try to get the titles from the schema.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "73accd2229c4e308868c2e1791a3c0e7e88dd9e3"}, "originalPosition": 230}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1be3cb73c9f3e1afbb84d8a7d2168ab029c0abe0", "author": {"user": {"login": "ianwallen", "name": "Ian"}}, "url": "https://github.com/geonetwork/core-geonetwork/commit/1be3cb73c9f3e1afbb84d8a7d2168ab029c0abe0", "committedDate": "2020-10-24T11:23:42Z", "message": "Update permission check to use AccessManager.getGroups\nRemoved comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyNDI0Njkw", "url": "https://github.com/geonetwork/core-geonetwork/pull/4817#pullrequestreview-522424690", "createdAt": "2020-11-03T11:56:07Z", "commit": {"oid": "1be3cb73c9f3e1afbb84d8a7d2168ab029c0abe0"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3554e56fb79fc63362ea53d675ee52857801afe0", "author": {"user": {"login": "ianwallen", "name": "Ian"}}, "url": "https://github.com/geonetwork/core-geonetwork/commit/3554e56fb79fc63362ea53d675ee52857801afe0", "committedDate": "2020-11-05T19:12:02Z", "message": "Merge branch 'master' of https://github.com/geonetwork/core-geonetwork into restorehistory_pk_fix\n\n# Conflicts:\n#\tweb/src/main/webapp/WEB-INF/classes/setup/sql/migrate/v3110/migrate-default.sql\n#\tweb/src/main/webapp/WEB-INF/classes/setup/sql/migrate/v3110/migrate-mysql.sql\n#\tweb/src/main/webapp/WEB-INF/classes/setup/sql/migrate/v3110/migrate-oracle.sql"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1596, "cost": 1, "resetAt": "2021-11-01T14:20:25Z"}}}