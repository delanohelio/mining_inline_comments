{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTEyOTQzMzQy", "number": 5142, "title": "Fix for polar extents (issue #4810)", "bodyText": "This should fix issue #4810 (Query by south pole area doesn't give any results).\nIf the search map has been set to a polar projection and the user draws a search extent that completely includes the north/south pole ([0, 90] or [0, -90]), the transformed WGS 1984 (EPSG:4326) extent never includes the pole itself and the extent self-intersects.\nTo illustrate, let's say that the user draws this extent on a search map that has been set to EPSG:3996 (IBCAO Polar Stereographic):\n\nCurrently, this will result in the following (self-intersecting) EPSG:4326 search polygon, which likely will not include any search results:\n\nThis patch will actually densify the amount of points along the edges and make a \"cut\" in the extent before it's transformed:\n\nWhich results in the following correct EPSG:4326 search polygon:\n\nThe patch has been tested on several shapes with different stereographic projections. Shapes that work best are regular extent boxes or simple/convex polygons. Multipart or donut polygons are not supported for now (it will only use the first outer ring).\nSome tested projections that all produce good results:\n\nEPSG:3031 (WGS 84 / Antarctic Polar Stereographic)\nEPSG:3411 (NSIDC Sea Ice Polar Stereographic North)\nEPSG:3412 (NSIDC Sea Ice Polar Stereographic South)\nEPSG:3413 (WGS 84 / NSIDC Sea Ice Polar Stereographic North)\nEPSG:3976 (WGS 84 / NSIDC Sea Ice Polar Stereographic South)\nEPSG:3995 (WGS 84 / Arctic Polar Stereographic)\nEPSG:3996 (WGS 84 / IBCAO Polar Stereographic)\nEPSG:5940 (WGS 84 / EPSG Russia Polar Stereographic)\nEPSG:42301 (NAD27 / Polar Stereographic / CM=-98)\n\nNotes\n\nThis patch will also densify (add extra points) to any input shape that does not have a EPSG:4326 (WGS 1984) or EPSG:3857 (Web Mercator) projection, so that a potentially better output search shape will be returned. This especially applies to areas closer towards the poles.\nThe patch does not add any new JS dependencies to the project.", "createdAt": "2020-10-30T11:50:50Z", "url": "https://github.com/geonetwork/core-geonetwork/pull/5142", "merged": true, "mergeCommit": {"oid": "b1ffddfd4101d0bb996f4db6cb1ef74874026891"}, "closed": true, "closedAt": "2020-11-06T13:24:41Z", "author": {"login": "GeoSander"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdXki60gH2gAyNTEyOTQzMzQyOjY0YzhkMzg2NTZhN2JiZTQ5MzBkNTdhY2ZkNTE1MGQzNDU1M2QzOTc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdZlWazgFqTUyNDQ2NzY3NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "64c8d38656a7bbe4930d57acfd5150d34553d397", "author": {"user": {"login": "GeoSander", "name": "Sander Schaminee"}}, "url": "https://github.com/geonetwork/core-geonetwork/commit/64c8d38656a7bbe4930d57acfd5150d34553d397", "committedDate": "2020-10-30T10:52:13Z", "message": "Fix for polar extents (issue #4810)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2fb973144ab08444f08a9c6f861f92382e4d9faa", "author": {"user": {"login": "GeoSander", "name": "Sander Schaminee"}}, "url": "https://github.com/geonetwork/core-geonetwork/commit/2fb973144ab08444f08a9c6f861f92382e4d9faa", "committedDate": "2020-11-02T22:50:35Z", "message": "Fix for polar extents (issue #4810)"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "64c8d38656a7bbe4930d57acfd5150d34553d397", "author": {"user": {"login": "GeoSander", "name": "Sander Schaminee"}}, "url": "https://github.com/geonetwork/core-geonetwork/commit/64c8d38656a7bbe4930d57acfd5150d34553d397", "committedDate": "2020-10-30T10:52:13Z", "message": "Fix for polar extents (issue #4810)"}, "afterCommit": {"oid": "2fb973144ab08444f08a9c6f861f92382e4d9faa", "author": {"user": {"login": "GeoSander", "name": "Sander Schaminee"}}, "url": "https://github.com/geonetwork/core-geonetwork/commit/2fb973144ab08444f08a9c6f861f92382e4d9faa", "committedDate": "2020-11-02T22:50:35Z", "message": "Fix for polar extents (issue #4810)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4b5567bcf4e9ec5f74381042e52875a46bde2ab0", "author": {"user": {"login": "GeoSander", "name": "Sander Schaminee"}}, "url": "https://github.com/geonetwork/core-geonetwork/commit/4b5567bcf4e9ec5f74381042e52875a46bde2ab0", "committedDate": "2020-11-03T09:18:13Z", "message": "Properly set point of origin"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "408392f1a03ca82b66ff76f42787e096b5529eee", "author": {"user": {"login": "GeoSander", "name": "Sander Schaminee"}}, "url": "https://github.com/geonetwork/core-geonetwork/commit/408392f1a03ca82b66ff76f42787e096b5529eee", "committedDate": "2020-11-03T14:50:04Z", "message": "Use datum line, fix longitudinal ordering"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTIyNjc5ODM3", "url": "https://github.com/geonetwork/core-geonetwork/pull/5142#pullrequestreview-522679837", "createdAt": "2020-11-03T16:37:16Z", "commit": {"oid": "408392f1a03ca82b66ff76f42787e096b5529eee"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxNjozNzoxNlrOHs3K4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwNzo0MTozNFrOHtMI9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgwMzI5OQ==", "bodyText": "es6 will not work, sorry :/ please turn all let and const into var", "url": "https://github.com/geonetwork/core-geonetwork/pull/5142#discussion_r516803299", "createdAt": "2020-11-03T16:37:16Z", "author": {"login": "jahow"}, "path": "web-ui/src/main/resources/catalog/components/search/map/MapFieldDirective.js", "diffHunk": "@@ -134,20 +134,253 @@\n               var updateField = function(geom) {\n                 feature.setGeometry(geom);\n \n-                // Write the extent as 4326 WKT polygon\n-                var lonlatFeat, writer, wkt;\n+                // Get projection code of current map view\n+                var proj = scope.map.getView().getProjection().getCode();\n+\n+                /**\n+                 * Transforms the given longitude-latitude pair to XY coordinates in the current projection.\n+                 * @param {number} lon \n+                 * @param {number} lat \n+                 */\n+                var getXY = function(lon, lat) {\n+                  return (new ol.geom.Point([lon, lat])).transform('EPSG:4326', proj).getFirstCoordinate();\n+                }\n+\n+                // Define polar coordinates in current projection\n+                var southPole = getXY(0, -90);\n+                var northPole = getXY(0, 90);\n+\n+                /**\n+                 * Checks if the feature geometry contains the north or south pole.\n+                 * Returns the polar coordinate in the current map projection when found or null otherwise.\n+                 * NOTE: Will not trigger if pole is on the edge.\n+                 * @param {ol.feature} feat\n+                 */\n+                var getInsidePole = function(feat) {\n+                  let geom = feat.getGeometry();\n+                  if (geom.intersectsCoordinate(southPole)) {\n+                    return southPole;\n+                  } else if (geom.intersectsCoordinate(northPole)) {\n+                    return northPole;\n+                  }\n+                }\n+\n+                /**\n+                 * Adds points to line segments.\n+                 * Specify the amount of segment parts to create (default = 4).\n+                 * The number of points that will be added is (parts - 1).\n+                 * @param {ol.feature} feat\n+                 * @param {int} parts\n+                 */\n+                var densifyEdges = function(feat, parts=4) {\n+                  let outCoords = [];\n+                  let inCoords = feat.getGeometry().getCoordinates()[0];\n+                  // No need to densify if shape already has a reasonable amount of points\n+                  if (inCoords.length > 4 * parts) return;\n+                  for (let i = 0; i < inCoords.length - 1; i++) {\n+                    let p0, p1, x0, y0, dX;\n+                    p0 = inCoords[i];\n+                    p1 = inCoords[i+1];\n+                    x0 = p0[0];\n+                    y0 = p0[1];\n+                    dX = (p1[0] - x0) / parts;\n+                    dY = (p1[1] - y0) / parts;\n+                    outCoords.push(p0);\n+                    for (let j = 1; j < parts; j++) {\n+                      // Add coords\n+                      outCoords.push([x0 + (j * dX), y0 + (j * dY)]);\n+                    }\n+                  }\n+                  // Add first coord to close polygon\n+                  outCoords.push(inCoords[0]);\n+                  feat.setGeometry(new ol.geom.Polygon([outCoords]));\n+                }\n+\n+                /**\n+                 * Given three colinear points (p1, p2, p3), check if p2 lies on line segment p1-p3.\n+                 */ \n+                var onSegment = function(p1, p2, p3) {\n+                  if (p2[0] <= Math.max(p1[0], p3[0]) && p2[0] >= Math.min(p1[0], p3[0]) && \n+                      p2[1] <= Math.max(p1[1], p3[1]) && p2[1] >= Math.min(p1[1], p3[1])) {\n+                        return true;\n+                  }\n+                  return false;\n+                }\n+\n+                /**\n+                 * Finds the orientation of an ordered triplet (p1, p2, p3). \n+                 * Returns one of the following values: \n+                 * 0 : Colinear points \n+                 * 1 : Clockwise points \n+                 * 2 : Counterclockwise \n+                 *\n+                 * See https://www.geeksforgeeks.org/orientation-3-ordered-points/amp for details of below formula.\n+                 */ \n+                var getOrientation = function(p1, p2, p3) {\n+                  let value = ((p2[1] - p1[1]) * (p3[0] - p2[0])) - ((p2[0] - p1[0]) * (p3[1] - p2[1]));\n+                  if (value > 0) return 1;\n+                  else if (value < 0) return 2;\n+                  return 0;\n+                }\n+\n+                /**\n+                 * Returns true if the line segments 'line1' and 'line2' (with points A and B) intersect. \n+                 */\n+                var linesIntersect = function(line1A, line1B, line2A, line2B) {\n+                  // Find the 4 orientations required for the general and special cases \n+                  let o1 = getOrientation(line1A, line1B, line2A);\n+                  let o2 = getOrientation(line1A, line1B, line2B);\n+                  let o3 = getOrientation(line2A, line2B, line1A);\n+                  let o4 = getOrientation(line2A, line2B, line1B);\n+\n+                  // General case\n+                  if ((o1 !== o2) && (o3 !== o4)) return true;\n+\n+                  // Special cases:\n+                  // Line1(A,B) and Line2(A) are colinear and Line2(A) lies on Line1\n+                  if ((o1 === 0) && onSegment(line1A, line2A, line1B)) return true;\n+                  // Line1(A,B) and Line2(B) are colinear and Line2(B) lies on Line1\n+                  if ((o2 === 0) && onSegment(line1A, line2B, line1B)) return true;\n+                  // Line2(A,B) and Line1(A) are colinear and Line1(A) lies on Line2\n+                  if ((o3 === 0) && onSegment(line2A, line1A, line2B)) return true;\n+                  // Line2(A,B) and Line1(B) are colinear and Line1(B) lies on Line2\n+                  if ((o4 === 0) && onSegment(line2A, line1B, line2B)) return true;\n+                  // Nothing intersects\n+                  return false;                  \n+                }\n+\n+                /**\n+                 * Calculates the intersection point between 'line1' and 'line2'.\n+                 * Assumes that the lines actually intersect (use linesIntersect() to verify).\n+                 */\n+                var getIntersection = function(line1A, line1B, line2A, line2B) {\n+                  // Line 1 represented as a1x + b1y = c1 \n+                  let a1 = line1B[1] - line1A[1]; \n+                  let b1 = line1A[0] - line1B[0]; \n+                  let c1 = a1 * line1A[0] + b1 * line1A[1]; \n+       \n+                  // Line 2 represented as a2x + b2y = c2 \n+                  let a2 = line2B[1] - line2A[1]; \n+                  let b2 = line2A[0] - line2B[0]; \n+                  let c2 = a2 * line2A[0] + b2 * line2A[1]; \n+                \n+                  let determinant = a1 * b2 - a2 * b1;                \n+                  let x = (b2 * c1 - b1 * c2) / determinant; \n+                  let y = (a1 * c2 - a2 * c1) / determinant; \n+                  return [x, y];\n+                }\n+\n+                /**\n+                 * Makes a \"cut\" at the datum line from the geometry edge up or down to the polar coordinate.\n+                 * The feature geometry is also transformed to WGS 1984 (EPSG:4326).\n+                 * NOTE: This is not suitable for complex or multipart polygons!\n+                 * \n+                 *           North pole polygon                   South pole polygon\n+                 *          +======+===========+                 +------------------+\n+                 *          |      |           |                 |                  |\n+                 *          |      o           |                 |            o     |\n+                 *          |                  |                 |            |     |\n+                 *          +------------------+                 +============+=====+\n+                 * \n+                 *   === -> \"cut side\" \n+                 *   o   -> polar coordinate\n+                 * @param {ol.feature} feat\n+                 * @param polarCoord\n+                 */\n+                var modifyPolarExtent = function(feat, polarCoord) {\n+                  const atNorthPole = polarCoord == northPole;\n+                  const polarLat = atNorthPole ? 90 : -90;\n+                  const parts = feat.getGeometry().getCoordinates();\n+\n+                  // Set the point of origin at equator (where datum line towards polar coordinate starts)\n+                  let originCoord = getXY(180, 0);\n+\n+                  // Show some warnings/info (when in debug mode)\n+                  console.log('Search extent contains ' + (atNorthPole ? 'north' : 'south') + ' pole');\n+                  if (parts.length > 1) {\n+                    console.warn('Multi-polygon polar search extents are not supported: this will produce unexpected results');\n+                  }\n+\n+                  // Find (1st) polar-side line segment that crosses the \"datum\".\n+                  // NOTE: this also works for non-square shapes, but NOT for shapes that cross the datum line multiple times!\n+                  let coords = parts[0];\n+                  let intersectionPointIndex = -1;\n+                  let lineStart = null;\n+                  let lineEnd = null;\n+                  for (let i = 0; i < coords.length - 1; i++) {\n+                    const p1 = coords[i];\n+                    const p2 = coords[i + 1];\n+                    if (linesIntersect(p1, p2, originCoord, polarCoord)) {\n+                      intersectionPointIndex = i + 1;\n+                      lineStart = p1;\n+                      lineEnd = p2;\n+                      break;\n+                    }\n+                  }\n+                  \n+                  if (lineStart !== null) {\n+                    // Calculate intersection point between extent segment and datum line\n+                    let intersectionPoint = getIntersection(lineStart, lineEnd, originCoord, polarCoord);\n+                    coords.splice(intersectionPointIndex, 0, intersectionPoint);\n+                    feat.setGeometry(new ol.geom.Polygon([coords]));\n+                  }\n+\n+                  // Transform to WGS 1984 (EPSG:4326)\n+                  feat.getGeometry().transform(proj, 'EPSG:4326');\n+                  \n+                  if (intersectionPointIndex >= 0) {\n+                    // Get all (transformed) coordinates and previous and next longitudes\n+                    coords = feat.getGeometry().getCoordinates()[0];\n+                    const prevLon = coords[intersectionPointIndex - 1][0];\n+                    const nextLon = coords[intersectionPointIndex + 1][0];\n+                    // Determine polar longitudes (order)\n+                    const polarLon1 = prevLon < 0 && nextLon > 0 ? -180 : 180;\n+                    const polarLon2 = -polarLon1;\n+                    // Get longitude of inserted coordinate, negate if needed (ensure correct hemisphere)\n+                    let insertedLon = coords[intersectionPointIndex][0];\n+                    if ((insertedLon > 0 && polarLon1 < 0) || (insertedLon < 0 && polarLon1 > 0)) {\n+                      insertedLon = -insertedLon;\n+                      coords[intersectionPointIndex][0] = insertedLon;\n+                    }                \n+                    // Get latitude of inserted coordinate\n+                    const insertedLat = coords[intersectionPointIndex][1];\n+                    // Insert 3 coordinates (2 at either side of the pole) to create the \"cut\"\n+                    coords.splice(intersectionPointIndex + 1, 0, [polarLon1, polarLat], [polarLon2, polarLat], [-insertedLon, insertedLat]);\n+                    feat.setGeometry(new ol.geom.Polygon([coords]));\n+                  }\n+                }\n+\n+\n+                // Transform extent to WGS 1984 (EPSG:4326)\n+                var lonlatFeat, writer, proj, wkt;\n                 lonlatFeat = feature.clone();\n-                lonlatFeat.getGeometry().transform(\n-                    scope.map.getView().getProjection().getCode(),\n-                    'EPSG:4326');\n+                if (proj !== 'EPSG:4326') {\n+                  if (proj !== 'EPSG:3857') {\n+                    // Densify edges so we get a more accurate reprojection (relates to issue #4810)\n+                    densifyEdges(lonlatFeat);\n+                  }\n+                  // Check if original extent includes a pole\n+                  let polarCoord = getInsidePole(feature);\n+                  if (polarCoord) \n+                  {\n+                    // Original extent includes a north or south pole: manipulate extent.\n+                    // Solves issue #4810: Query by south pole area doesn't give any results.\n+                    modifyPolarExtent(lonlatFeat, polarCoord);\n+                  } else {\n+                    // No pole included so a basic transformation to WGS 1984 (EPSG:4326) will do\n+                    lonlatFeat.getGeometry().transform(proj, 'EPSG:4326');\n+                  }\n+                }\n+\n+                // Write the extent as 4326 WKT polygon\n                 writer = new ol.format.WKT();\n                 wkt = writer.writeFeature(lonlatFeat);\n                 bboxSet(parent, wkt);\n               };\n \n               // If given extent coords are given through attributes,\n               // display the bbox on the map\n-              var coords = scope.$eval(attrs['gnDrawBboxExtent']);\n+              let coords = scope.$eval(attrs['gnDrawBboxExtent']);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "408392f1a03ca82b66ff76f42787e096b5529eee"}, "originalPosition": 256}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzEzOTMyNA==", "bodyText": "This should be removed", "url": "https://github.com/geonetwork/core-geonetwork/pull/5142#discussion_r517139324", "createdAt": "2020-11-04T07:23:44Z", "author": {"login": "jahow"}, "path": "web-ui/src/main/resources/catalog/components/search/map/MapFieldDirective.js", "diffHunk": "@@ -134,20 +134,253 @@\n               var updateField = function(geom) {\n                 feature.setGeometry(geom);\n \n-                // Write the extent as 4326 WKT polygon\n-                var lonlatFeat, writer, wkt;\n+                // Get projection code of current map view\n+                var proj = scope.map.getView().getProjection().getCode();\n+\n+                /**\n+                 * Transforms the given longitude-latitude pair to XY coordinates in the current projection.\n+                 * @param {number} lon \n+                 * @param {number} lat \n+                 */\n+                var getXY = function(lon, lat) {\n+                  return (new ol.geom.Point([lon, lat])).transform('EPSG:4326', proj).getFirstCoordinate();\n+                }\n+\n+                // Define polar coordinates in current projection\n+                var southPole = getXY(0, -90);\n+                var northPole = getXY(0, 90);\n+\n+                /**\n+                 * Checks if the feature geometry contains the north or south pole.\n+                 * Returns the polar coordinate in the current map projection when found or null otherwise.\n+                 * NOTE: Will not trigger if pole is on the edge.\n+                 * @param {ol.feature} feat\n+                 */\n+                var getInsidePole = function(feat) {\n+                  let geom = feat.getGeometry();\n+                  if (geom.intersectsCoordinate(southPole)) {\n+                    return southPole;\n+                  } else if (geom.intersectsCoordinate(northPole)) {\n+                    return northPole;\n+                  }\n+                }\n+\n+                /**\n+                 * Adds points to line segments.\n+                 * Specify the amount of segment parts to create (default = 4).\n+                 * The number of points that will be added is (parts - 1).\n+                 * @param {ol.feature} feat\n+                 * @param {int} parts\n+                 */\n+                var densifyEdges = function(feat, parts=4) {\n+                  let outCoords = [];\n+                  let inCoords = feat.getGeometry().getCoordinates()[0];\n+                  // No need to densify if shape already has a reasonable amount of points\n+                  if (inCoords.length > 4 * parts) return;\n+                  for (let i = 0; i < inCoords.length - 1; i++) {\n+                    let p0, p1, x0, y0, dX;\n+                    p0 = inCoords[i];\n+                    p1 = inCoords[i+1];\n+                    x0 = p0[0];\n+                    y0 = p0[1];\n+                    dX = (p1[0] - x0) / parts;\n+                    dY = (p1[1] - y0) / parts;\n+                    outCoords.push(p0);\n+                    for (let j = 1; j < parts; j++) {\n+                      // Add coords\n+                      outCoords.push([x0 + (j * dX), y0 + (j * dY)]);\n+                    }\n+                  }\n+                  // Add first coord to close polygon\n+                  outCoords.push(inCoords[0]);\n+                  feat.setGeometry(new ol.geom.Polygon([outCoords]));\n+                }\n+\n+                /**\n+                 * Given three colinear points (p1, p2, p3), check if p2 lies on line segment p1-p3.\n+                 */ \n+                var onSegment = function(p1, p2, p3) {\n+                  if (p2[0] <= Math.max(p1[0], p3[0]) && p2[0] >= Math.min(p1[0], p3[0]) && \n+                      p2[1] <= Math.max(p1[1], p3[1]) && p2[1] >= Math.min(p1[1], p3[1])) {\n+                        return true;\n+                  }\n+                  return false;\n+                }\n+\n+                /**\n+                 * Finds the orientation of an ordered triplet (p1, p2, p3). \n+                 * Returns one of the following values: \n+                 * 0 : Colinear points \n+                 * 1 : Clockwise points \n+                 * 2 : Counterclockwise \n+                 *\n+                 * See https://www.geeksforgeeks.org/orientation-3-ordered-points/amp for details of below formula.\n+                 */ \n+                var getOrientation = function(p1, p2, p3) {\n+                  let value = ((p2[1] - p1[1]) * (p3[0] - p2[0])) - ((p2[0] - p1[0]) * (p3[1] - p2[1]));\n+                  if (value > 0) return 1;\n+                  else if (value < 0) return 2;\n+                  return 0;\n+                }\n+\n+                /**\n+                 * Returns true if the line segments 'line1' and 'line2' (with points A and B) intersect. \n+                 */\n+                var linesIntersect = function(line1A, line1B, line2A, line2B) {\n+                  // Find the 4 orientations required for the general and special cases \n+                  let o1 = getOrientation(line1A, line1B, line2A);\n+                  let o2 = getOrientation(line1A, line1B, line2B);\n+                  let o3 = getOrientation(line2A, line2B, line1A);\n+                  let o4 = getOrientation(line2A, line2B, line1B);\n+\n+                  // General case\n+                  if ((o1 !== o2) && (o3 !== o4)) return true;\n+\n+                  // Special cases:\n+                  // Line1(A,B) and Line2(A) are colinear and Line2(A) lies on Line1\n+                  if ((o1 === 0) && onSegment(line1A, line2A, line1B)) return true;\n+                  // Line1(A,B) and Line2(B) are colinear and Line2(B) lies on Line1\n+                  if ((o2 === 0) && onSegment(line1A, line2B, line1B)) return true;\n+                  // Line2(A,B) and Line1(A) are colinear and Line1(A) lies on Line2\n+                  if ((o3 === 0) && onSegment(line2A, line1A, line2B)) return true;\n+                  // Line2(A,B) and Line1(B) are colinear and Line1(B) lies on Line2\n+                  if ((o4 === 0) && onSegment(line2A, line1B, line2B)) return true;\n+                  // Nothing intersects\n+                  return false;                  \n+                }\n+\n+                /**\n+                 * Calculates the intersection point between 'line1' and 'line2'.\n+                 * Assumes that the lines actually intersect (use linesIntersect() to verify).\n+                 */\n+                var getIntersection = function(line1A, line1B, line2A, line2B) {\n+                  // Line 1 represented as a1x + b1y = c1 \n+                  let a1 = line1B[1] - line1A[1]; \n+                  let b1 = line1A[0] - line1B[0]; \n+                  let c1 = a1 * line1A[0] + b1 * line1A[1]; \n+       \n+                  // Line 2 represented as a2x + b2y = c2 \n+                  let a2 = line2B[1] - line2A[1]; \n+                  let b2 = line2A[0] - line2B[0]; \n+                  let c2 = a2 * line2A[0] + b2 * line2A[1]; \n+                \n+                  let determinant = a1 * b2 - a2 * b1;                \n+                  let x = (b2 * c1 - b1 * c2) / determinant; \n+                  let y = (a1 * c2 - a2 * c1) / determinant; \n+                  return [x, y];\n+                }\n+\n+                /**\n+                 * Makes a \"cut\" at the datum line from the geometry edge up or down to the polar coordinate.\n+                 * The feature geometry is also transformed to WGS 1984 (EPSG:4326).\n+                 * NOTE: This is not suitable for complex or multipart polygons!\n+                 * \n+                 *           North pole polygon                   South pole polygon\n+                 *          +======+===========+                 +------------------+\n+                 *          |      |           |                 |                  |\n+                 *          |      o           |                 |            o     |\n+                 *          |                  |                 |            |     |\n+                 *          +------------------+                 +============+=====+\n+                 * \n+                 *   === -> \"cut side\" \n+                 *   o   -> polar coordinate\n+                 * @param {ol.feature} feat\n+                 * @param polarCoord\n+                 */\n+                var modifyPolarExtent = function(feat, polarCoord) {\n+                  const atNorthPole = polarCoord == northPole;\n+                  const polarLat = atNorthPole ? 90 : -90;\n+                  const parts = feat.getGeometry().getCoordinates();\n+\n+                  // Set the point of origin at equator (where datum line towards polar coordinate starts)\n+                  let originCoord = getXY(180, 0);\n+\n+                  // Show some warnings/info (when in debug mode)\n+                  console.log('Search extent contains ' + (atNorthPole ? 'north' : 'south') + ' pole');", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "408392f1a03ca82b66ff76f42787e096b5529eee"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE0MjY0OA==", "bodyText": "I think all those utilities should not be added here, but in another service. This adds way too much code inside a simple scope method.", "url": "https://github.com/geonetwork/core-geonetwork/pull/5142#discussion_r517142648", "createdAt": "2020-11-04T07:31:59Z", "author": {"login": "jahow"}, "path": "web-ui/src/main/resources/catalog/components/search/map/MapFieldDirective.js", "diffHunk": "@@ -134,20 +134,253 @@\n               var updateField = function(geom) {\n                 feature.setGeometry(geom);\n \n-                // Write the extent as 4326 WKT polygon\n-                var lonlatFeat, writer, wkt;\n+                // Get projection code of current map view\n+                var proj = scope.map.getView().getProjection().getCode();\n+\n+                /**\n+                 * Transforms the given longitude-latitude pair to XY coordinates in the current projection.\n+                 * @param {number} lon \n+                 * @param {number} lat \n+                 */\n+                var getXY = function(lon, lat) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "408392f1a03ca82b66ff76f42787e096b5529eee"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE0NTkyMw==", "bodyText": "this can be written as ol.proj.fromLonLat([0, -90], proj)", "url": "https://github.com/geonetwork/core-geonetwork/pull/5142#discussion_r517145923", "createdAt": "2020-11-04T07:39:29Z", "author": {"login": "jahow"}, "path": "web-ui/src/main/resources/catalog/components/search/map/MapFieldDirective.js", "diffHunk": "@@ -134,20 +134,253 @@\n               var updateField = function(geom) {\n                 feature.setGeometry(geom);\n \n-                // Write the extent as 4326 WKT polygon\n-                var lonlatFeat, writer, wkt;\n+                // Get projection code of current map view\n+                var proj = scope.map.getView().getProjection().getCode();\n+\n+                /**\n+                 * Transforms the given longitude-latitude pair to XY coordinates in the current projection.\n+                 * @param {number} lon \n+                 * @param {number} lat \n+                 */\n+                var getXY = function(lon, lat) {\n+                  return (new ol.geom.Point([lon, lat])).transform('EPSG:4326', proj).getFirstCoordinate();\n+                }\n+\n+                // Define polar coordinates in current projection\n+                var southPole = getXY(0, -90);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "408392f1a03ca82b66ff76f42787e096b5529eee"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE0NjMyMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            var densifyEdges = function(feat, parts=4) {\n          \n          \n            \n                            var densifyEdges = function(feat, parts) {", "url": "https://github.com/geonetwork/core-geonetwork/pull/5142#discussion_r517146322", "createdAt": "2020-11-04T07:40:19Z", "author": {"login": "jahow"}, "path": "web-ui/src/main/resources/catalog/components/search/map/MapFieldDirective.js", "diffHunk": "@@ -134,20 +134,253 @@\n               var updateField = function(geom) {\n                 feature.setGeometry(geom);\n \n-                // Write the extent as 4326 WKT polygon\n-                var lonlatFeat, writer, wkt;\n+                // Get projection code of current map view\n+                var proj = scope.map.getView().getProjection().getCode();\n+\n+                /**\n+                 * Transforms the given longitude-latitude pair to XY coordinates in the current projection.\n+                 * @param {number} lon \n+                 * @param {number} lat \n+                 */\n+                var getXY = function(lon, lat) {\n+                  return (new ol.geom.Point([lon, lat])).transform('EPSG:4326', proj).getFirstCoordinate();\n+                }\n+\n+                // Define polar coordinates in current projection\n+                var southPole = getXY(0, -90);\n+                var northPole = getXY(0, 90);\n+\n+                /**\n+                 * Checks if the feature geometry contains the north or south pole.\n+                 * Returns the polar coordinate in the current map projection when found or null otherwise.\n+                 * NOTE: Will not trigger if pole is on the edge.\n+                 * @param {ol.feature} feat\n+                 */\n+                var getInsidePole = function(feat) {\n+                  let geom = feat.getGeometry();\n+                  if (geom.intersectsCoordinate(southPole)) {\n+                    return southPole;\n+                  } else if (geom.intersectsCoordinate(northPole)) {\n+                    return northPole;\n+                  }\n+                }\n+\n+                /**\n+                 * Adds points to line segments.\n+                 * Specify the amount of segment parts to create (default = 4).\n+                 * The number of points that will be added is (parts - 1).\n+                 * @param {ol.feature} feat\n+                 * @param {int} parts\n+                 */\n+                var densifyEdges = function(feat, parts=4) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "408392f1a03ca82b66ff76f42787e096b5529eee"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE0Njg3MQ==", "bodyText": "This will not work for linestrings right? maybe this should be documented better, the header only mentions \"line segments\"", "url": "https://github.com/geonetwork/core-geonetwork/pull/5142#discussion_r517146871", "createdAt": "2020-11-04T07:41:34Z", "author": {"login": "jahow"}, "path": "web-ui/src/main/resources/catalog/components/search/map/MapFieldDirective.js", "diffHunk": "@@ -134,20 +134,253 @@\n               var updateField = function(geom) {\n                 feature.setGeometry(geom);\n \n-                // Write the extent as 4326 WKT polygon\n-                var lonlatFeat, writer, wkt;\n+                // Get projection code of current map view\n+                var proj = scope.map.getView().getProjection().getCode();\n+\n+                /**\n+                 * Transforms the given longitude-latitude pair to XY coordinates in the current projection.\n+                 * @param {number} lon \n+                 * @param {number} lat \n+                 */\n+                var getXY = function(lon, lat) {\n+                  return (new ol.geom.Point([lon, lat])).transform('EPSG:4326', proj).getFirstCoordinate();\n+                }\n+\n+                // Define polar coordinates in current projection\n+                var southPole = getXY(0, -90);\n+                var northPole = getXY(0, 90);\n+\n+                /**\n+                 * Checks if the feature geometry contains the north or south pole.\n+                 * Returns the polar coordinate in the current map projection when found or null otherwise.\n+                 * NOTE: Will not trigger if pole is on the edge.\n+                 * @param {ol.feature} feat\n+                 */\n+                var getInsidePole = function(feat) {\n+                  let geom = feat.getGeometry();\n+                  if (geom.intersectsCoordinate(southPole)) {\n+                    return southPole;\n+                  } else if (geom.intersectsCoordinate(northPole)) {\n+                    return northPole;\n+                  }\n+                }\n+\n+                /**\n+                 * Adds points to line segments.\n+                 * Specify the amount of segment parts to create (default = 4).\n+                 * The number of points that will be added is (parts - 1).\n+                 * @param {ol.feature} feat\n+                 * @param {int} parts\n+                 */\n+                var densifyEdges = function(feat, parts=4) {\n+                  let outCoords = [];\n+                  let inCoords = feat.getGeometry().getCoordinates()[0];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "408392f1a03ca82b66ff76f42787e096b5529eee"}, "originalPosition": 46}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f147f9d7372b525977f17ebd7497f2fba29cb78c", "author": {"user": {"login": "GeoSander", "name": "Sander Schaminee"}}, "url": "https://github.com/geonetwork/core-geonetwork/commit/f147f9d7372b525977f17ebd7497f2fba29cb78c", "committedDate": "2020-11-05T12:16:44Z", "message": "Moved geometry functions to new MapFieldService"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6c620064d2f1cb5504e092d07eb4e462e41f0053", "author": {"user": {"login": "GeoSander", "name": "Sander Schaminee"}}, "url": "https://github.com/geonetwork/core-geonetwork/commit/6c620064d2f1cb5504e092d07eb4e462e41f0053", "committedDate": "2020-11-05T12:21:08Z", "message": "Applied formatting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "299181f71fd1170943670b2213c852b90648399c", "author": {"user": {"login": "GeoSander", "name": "Sander Schaminee"}}, "url": "https://github.com/geonetwork/core-geonetwork/commit/299181f71fd1170943670b2213c852b90648399c", "committedDate": "2020-11-05T12:29:09Z", "message": "Merge remote-tracking branch 'upstream/master' into master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "83e06a479c2f919f62e27760dd8dfcdad8980795", "author": {"user": {"login": "GeoSander", "name": "Sander Schaminee"}}, "url": "https://github.com/geonetwork/core-geonetwork/commit/83e06a479c2f919f62e27760dd8dfcdad8980795", "committedDate": "2020-11-05T15:54:28Z", "message": "Moved transform functionality to GeometryService"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI0NDY3Njc0", "url": "https://github.com/geonetwork/core-geonetwork/pull/5142#pullrequestreview-524467674", "createdAt": "2020-11-05T16:56:19Z", "commit": {"oid": "83e06a479c2f919f62e27760dd8dfcdad8980795"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1771, "cost": 1, "resetAt": "2021-11-01T14:20:25Z"}}}