{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTEyOTQzMzQy", "number": 5142, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxNjozNzoxNlrOE043KQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwNzo0MTozNFrOE1Gn4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzODkzMDMzOnYy", "diffSide": "RIGHT", "path": "web-ui/src/main/resources/catalog/components/search/map/MapFieldDirective.js", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxNjozNzoxNlrOHs3K4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwODo1NjowNlrOHtOgPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgwMzI5OQ==", "bodyText": "es6 will not work, sorry :/ please turn all let and const into var", "url": "https://github.com/geonetwork/core-geonetwork/pull/5142#discussion_r516803299", "createdAt": "2020-11-03T16:37:16Z", "author": {"login": "jahow"}, "path": "web-ui/src/main/resources/catalog/components/search/map/MapFieldDirective.js", "diffHunk": "@@ -134,20 +134,253 @@\n               var updateField = function(geom) {\n                 feature.setGeometry(geom);\n \n-                // Write the extent as 4326 WKT polygon\n-                var lonlatFeat, writer, wkt;\n+                // Get projection code of current map view\n+                var proj = scope.map.getView().getProjection().getCode();\n+\n+                /**\n+                 * Transforms the given longitude-latitude pair to XY coordinates in the current projection.\n+                 * @param {number} lon \n+                 * @param {number} lat \n+                 */\n+                var getXY = function(lon, lat) {\n+                  return (new ol.geom.Point([lon, lat])).transform('EPSG:4326', proj).getFirstCoordinate();\n+                }\n+\n+                // Define polar coordinates in current projection\n+                var southPole = getXY(0, -90);\n+                var northPole = getXY(0, 90);\n+\n+                /**\n+                 * Checks if the feature geometry contains the north or south pole.\n+                 * Returns the polar coordinate in the current map projection when found or null otherwise.\n+                 * NOTE: Will not trigger if pole is on the edge.\n+                 * @param {ol.feature} feat\n+                 */\n+                var getInsidePole = function(feat) {\n+                  let geom = feat.getGeometry();\n+                  if (geom.intersectsCoordinate(southPole)) {\n+                    return southPole;\n+                  } else if (geom.intersectsCoordinate(northPole)) {\n+                    return northPole;\n+                  }\n+                }\n+\n+                /**\n+                 * Adds points to line segments.\n+                 * Specify the amount of segment parts to create (default = 4).\n+                 * The number of points that will be added is (parts - 1).\n+                 * @param {ol.feature} feat\n+                 * @param {int} parts\n+                 */\n+                var densifyEdges = function(feat, parts=4) {\n+                  let outCoords = [];\n+                  let inCoords = feat.getGeometry().getCoordinates()[0];\n+                  // No need to densify if shape already has a reasonable amount of points\n+                  if (inCoords.length > 4 * parts) return;\n+                  for (let i = 0; i < inCoords.length - 1; i++) {\n+                    let p0, p1, x0, y0, dX;\n+                    p0 = inCoords[i];\n+                    p1 = inCoords[i+1];\n+                    x0 = p0[0];\n+                    y0 = p0[1];\n+                    dX = (p1[0] - x0) / parts;\n+                    dY = (p1[1] - y0) / parts;\n+                    outCoords.push(p0);\n+                    for (let j = 1; j < parts; j++) {\n+                      // Add coords\n+                      outCoords.push([x0 + (j * dX), y0 + (j * dY)]);\n+                    }\n+                  }\n+                  // Add first coord to close polygon\n+                  outCoords.push(inCoords[0]);\n+                  feat.setGeometry(new ol.geom.Polygon([outCoords]));\n+                }\n+\n+                /**\n+                 * Given three colinear points (p1, p2, p3), check if p2 lies on line segment p1-p3.\n+                 */ \n+                var onSegment = function(p1, p2, p3) {\n+                  if (p2[0] <= Math.max(p1[0], p3[0]) && p2[0] >= Math.min(p1[0], p3[0]) && \n+                      p2[1] <= Math.max(p1[1], p3[1]) && p2[1] >= Math.min(p1[1], p3[1])) {\n+                        return true;\n+                  }\n+                  return false;\n+                }\n+\n+                /**\n+                 * Finds the orientation of an ordered triplet (p1, p2, p3). \n+                 * Returns one of the following values: \n+                 * 0 : Colinear points \n+                 * 1 : Clockwise points \n+                 * 2 : Counterclockwise \n+                 *\n+                 * See https://www.geeksforgeeks.org/orientation-3-ordered-points/amp for details of below formula.\n+                 */ \n+                var getOrientation = function(p1, p2, p3) {\n+                  let value = ((p2[1] - p1[1]) * (p3[0] - p2[0])) - ((p2[0] - p1[0]) * (p3[1] - p2[1]));\n+                  if (value > 0) return 1;\n+                  else if (value < 0) return 2;\n+                  return 0;\n+                }\n+\n+                /**\n+                 * Returns true if the line segments 'line1' and 'line2' (with points A and B) intersect. \n+                 */\n+                var linesIntersect = function(line1A, line1B, line2A, line2B) {\n+                  // Find the 4 orientations required for the general and special cases \n+                  let o1 = getOrientation(line1A, line1B, line2A);\n+                  let o2 = getOrientation(line1A, line1B, line2B);\n+                  let o3 = getOrientation(line2A, line2B, line1A);\n+                  let o4 = getOrientation(line2A, line2B, line1B);\n+\n+                  // General case\n+                  if ((o1 !== o2) && (o3 !== o4)) return true;\n+\n+                  // Special cases:\n+                  // Line1(A,B) and Line2(A) are colinear and Line2(A) lies on Line1\n+                  if ((o1 === 0) && onSegment(line1A, line2A, line1B)) return true;\n+                  // Line1(A,B) and Line2(B) are colinear and Line2(B) lies on Line1\n+                  if ((o2 === 0) && onSegment(line1A, line2B, line1B)) return true;\n+                  // Line2(A,B) and Line1(A) are colinear and Line1(A) lies on Line2\n+                  if ((o3 === 0) && onSegment(line2A, line1A, line2B)) return true;\n+                  // Line2(A,B) and Line1(B) are colinear and Line1(B) lies on Line2\n+                  if ((o4 === 0) && onSegment(line2A, line1B, line2B)) return true;\n+                  // Nothing intersects\n+                  return false;                  \n+                }\n+\n+                /**\n+                 * Calculates the intersection point between 'line1' and 'line2'.\n+                 * Assumes that the lines actually intersect (use linesIntersect() to verify).\n+                 */\n+                var getIntersection = function(line1A, line1B, line2A, line2B) {\n+                  // Line 1 represented as a1x + b1y = c1 \n+                  let a1 = line1B[1] - line1A[1]; \n+                  let b1 = line1A[0] - line1B[0]; \n+                  let c1 = a1 * line1A[0] + b1 * line1A[1]; \n+       \n+                  // Line 2 represented as a2x + b2y = c2 \n+                  let a2 = line2B[1] - line2A[1]; \n+                  let b2 = line2A[0] - line2B[0]; \n+                  let c2 = a2 * line2A[0] + b2 * line2A[1]; \n+                \n+                  let determinant = a1 * b2 - a2 * b1;                \n+                  let x = (b2 * c1 - b1 * c2) / determinant; \n+                  let y = (a1 * c2 - a2 * c1) / determinant; \n+                  return [x, y];\n+                }\n+\n+                /**\n+                 * Makes a \"cut\" at the datum line from the geometry edge up or down to the polar coordinate.\n+                 * The feature geometry is also transformed to WGS 1984 (EPSG:4326).\n+                 * NOTE: This is not suitable for complex or multipart polygons!\n+                 * \n+                 *           North pole polygon                   South pole polygon\n+                 *          +======+===========+                 +------------------+\n+                 *          |      |           |                 |                  |\n+                 *          |      o           |                 |            o     |\n+                 *          |                  |                 |            |     |\n+                 *          +------------------+                 +============+=====+\n+                 * \n+                 *   === -> \"cut side\" \n+                 *   o   -> polar coordinate\n+                 * @param {ol.feature} feat\n+                 * @param polarCoord\n+                 */\n+                var modifyPolarExtent = function(feat, polarCoord) {\n+                  const atNorthPole = polarCoord == northPole;\n+                  const polarLat = atNorthPole ? 90 : -90;\n+                  const parts = feat.getGeometry().getCoordinates();\n+\n+                  // Set the point of origin at equator (where datum line towards polar coordinate starts)\n+                  let originCoord = getXY(180, 0);\n+\n+                  // Show some warnings/info (when in debug mode)\n+                  console.log('Search extent contains ' + (atNorthPole ? 'north' : 'south') + ' pole');\n+                  if (parts.length > 1) {\n+                    console.warn('Multi-polygon polar search extents are not supported: this will produce unexpected results');\n+                  }\n+\n+                  // Find (1st) polar-side line segment that crosses the \"datum\".\n+                  // NOTE: this also works for non-square shapes, but NOT for shapes that cross the datum line multiple times!\n+                  let coords = parts[0];\n+                  let intersectionPointIndex = -1;\n+                  let lineStart = null;\n+                  let lineEnd = null;\n+                  for (let i = 0; i < coords.length - 1; i++) {\n+                    const p1 = coords[i];\n+                    const p2 = coords[i + 1];\n+                    if (linesIntersect(p1, p2, originCoord, polarCoord)) {\n+                      intersectionPointIndex = i + 1;\n+                      lineStart = p1;\n+                      lineEnd = p2;\n+                      break;\n+                    }\n+                  }\n+                  \n+                  if (lineStart !== null) {\n+                    // Calculate intersection point between extent segment and datum line\n+                    let intersectionPoint = getIntersection(lineStart, lineEnd, originCoord, polarCoord);\n+                    coords.splice(intersectionPointIndex, 0, intersectionPoint);\n+                    feat.setGeometry(new ol.geom.Polygon([coords]));\n+                  }\n+\n+                  // Transform to WGS 1984 (EPSG:4326)\n+                  feat.getGeometry().transform(proj, 'EPSG:4326');\n+                  \n+                  if (intersectionPointIndex >= 0) {\n+                    // Get all (transformed) coordinates and previous and next longitudes\n+                    coords = feat.getGeometry().getCoordinates()[0];\n+                    const prevLon = coords[intersectionPointIndex - 1][0];\n+                    const nextLon = coords[intersectionPointIndex + 1][0];\n+                    // Determine polar longitudes (order)\n+                    const polarLon1 = prevLon < 0 && nextLon > 0 ? -180 : 180;\n+                    const polarLon2 = -polarLon1;\n+                    // Get longitude of inserted coordinate, negate if needed (ensure correct hemisphere)\n+                    let insertedLon = coords[intersectionPointIndex][0];\n+                    if ((insertedLon > 0 && polarLon1 < 0) || (insertedLon < 0 && polarLon1 > 0)) {\n+                      insertedLon = -insertedLon;\n+                      coords[intersectionPointIndex][0] = insertedLon;\n+                    }                \n+                    // Get latitude of inserted coordinate\n+                    const insertedLat = coords[intersectionPointIndex][1];\n+                    // Insert 3 coordinates (2 at either side of the pole) to create the \"cut\"\n+                    coords.splice(intersectionPointIndex + 1, 0, [polarLon1, polarLat], [polarLon2, polarLat], [-insertedLon, insertedLat]);\n+                    feat.setGeometry(new ol.geom.Polygon([coords]));\n+                  }\n+                }\n+\n+\n+                // Transform extent to WGS 1984 (EPSG:4326)\n+                var lonlatFeat, writer, proj, wkt;\n                 lonlatFeat = feature.clone();\n-                lonlatFeat.getGeometry().transform(\n-                    scope.map.getView().getProjection().getCode(),\n-                    'EPSG:4326');\n+                if (proj !== 'EPSG:4326') {\n+                  if (proj !== 'EPSG:3857') {\n+                    // Densify edges so we get a more accurate reprojection (relates to issue #4810)\n+                    densifyEdges(lonlatFeat);\n+                  }\n+                  // Check if original extent includes a pole\n+                  let polarCoord = getInsidePole(feature);\n+                  if (polarCoord) \n+                  {\n+                    // Original extent includes a north or south pole: manipulate extent.\n+                    // Solves issue #4810: Query by south pole area doesn't give any results.\n+                    modifyPolarExtent(lonlatFeat, polarCoord);\n+                  } else {\n+                    // No pole included so a basic transformation to WGS 1984 (EPSG:4326) will do\n+                    lonlatFeat.getGeometry().transform(proj, 'EPSG:4326');\n+                  }\n+                }\n+\n+                // Write the extent as 4326 WKT polygon\n                 writer = new ol.format.WKT();\n                 wkt = writer.writeFeature(lonlatFeat);\n                 bboxSet(parent, wkt);\n               };\n \n               // If given extent coords are given through attributes,\n               // display the bbox on the map\n-              var coords = scope.$eval(attrs['gnDrawBboxExtent']);\n+              let coords = scope.$eval(attrs['gnDrawBboxExtent']);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "408392f1a03ca82b66ff76f42787e096b5529eee"}, "originalPosition": 256}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE4NTU5Ng==", "bodyText": "I know, Paul mentioned that yes.", "url": "https://github.com/geonetwork/core-geonetwork/pull/5142#discussion_r517185596", "createdAt": "2020-11-04T08:56:06Z", "author": {"login": "GeoSander"}, "path": "web-ui/src/main/resources/catalog/components/search/map/MapFieldDirective.js", "diffHunk": "@@ -134,20 +134,253 @@\n               var updateField = function(geom) {\n                 feature.setGeometry(geom);\n \n-                // Write the extent as 4326 WKT polygon\n-                var lonlatFeat, writer, wkt;\n+                // Get projection code of current map view\n+                var proj = scope.map.getView().getProjection().getCode();\n+\n+                /**\n+                 * Transforms the given longitude-latitude pair to XY coordinates in the current projection.\n+                 * @param {number} lon \n+                 * @param {number} lat \n+                 */\n+                var getXY = function(lon, lat) {\n+                  return (new ol.geom.Point([lon, lat])).transform('EPSG:4326', proj).getFirstCoordinate();\n+                }\n+\n+                // Define polar coordinates in current projection\n+                var southPole = getXY(0, -90);\n+                var northPole = getXY(0, 90);\n+\n+                /**\n+                 * Checks if the feature geometry contains the north or south pole.\n+                 * Returns the polar coordinate in the current map projection when found or null otherwise.\n+                 * NOTE: Will not trigger if pole is on the edge.\n+                 * @param {ol.feature} feat\n+                 */\n+                var getInsidePole = function(feat) {\n+                  let geom = feat.getGeometry();\n+                  if (geom.intersectsCoordinate(southPole)) {\n+                    return southPole;\n+                  } else if (geom.intersectsCoordinate(northPole)) {\n+                    return northPole;\n+                  }\n+                }\n+\n+                /**\n+                 * Adds points to line segments.\n+                 * Specify the amount of segment parts to create (default = 4).\n+                 * The number of points that will be added is (parts - 1).\n+                 * @param {ol.feature} feat\n+                 * @param {int} parts\n+                 */\n+                var densifyEdges = function(feat, parts=4) {\n+                  let outCoords = [];\n+                  let inCoords = feat.getGeometry().getCoordinates()[0];\n+                  // No need to densify if shape already has a reasonable amount of points\n+                  if (inCoords.length > 4 * parts) return;\n+                  for (let i = 0; i < inCoords.length - 1; i++) {\n+                    let p0, p1, x0, y0, dX;\n+                    p0 = inCoords[i];\n+                    p1 = inCoords[i+1];\n+                    x0 = p0[0];\n+                    y0 = p0[1];\n+                    dX = (p1[0] - x0) / parts;\n+                    dY = (p1[1] - y0) / parts;\n+                    outCoords.push(p0);\n+                    for (let j = 1; j < parts; j++) {\n+                      // Add coords\n+                      outCoords.push([x0 + (j * dX), y0 + (j * dY)]);\n+                    }\n+                  }\n+                  // Add first coord to close polygon\n+                  outCoords.push(inCoords[0]);\n+                  feat.setGeometry(new ol.geom.Polygon([outCoords]));\n+                }\n+\n+                /**\n+                 * Given three colinear points (p1, p2, p3), check if p2 lies on line segment p1-p3.\n+                 */ \n+                var onSegment = function(p1, p2, p3) {\n+                  if (p2[0] <= Math.max(p1[0], p3[0]) && p2[0] >= Math.min(p1[0], p3[0]) && \n+                      p2[1] <= Math.max(p1[1], p3[1]) && p2[1] >= Math.min(p1[1], p3[1])) {\n+                        return true;\n+                  }\n+                  return false;\n+                }\n+\n+                /**\n+                 * Finds the orientation of an ordered triplet (p1, p2, p3). \n+                 * Returns one of the following values: \n+                 * 0 : Colinear points \n+                 * 1 : Clockwise points \n+                 * 2 : Counterclockwise \n+                 *\n+                 * See https://www.geeksforgeeks.org/orientation-3-ordered-points/amp for details of below formula.\n+                 */ \n+                var getOrientation = function(p1, p2, p3) {\n+                  let value = ((p2[1] - p1[1]) * (p3[0] - p2[0])) - ((p2[0] - p1[0]) * (p3[1] - p2[1]));\n+                  if (value > 0) return 1;\n+                  else if (value < 0) return 2;\n+                  return 0;\n+                }\n+\n+                /**\n+                 * Returns true if the line segments 'line1' and 'line2' (with points A and B) intersect. \n+                 */\n+                var linesIntersect = function(line1A, line1B, line2A, line2B) {\n+                  // Find the 4 orientations required for the general and special cases \n+                  let o1 = getOrientation(line1A, line1B, line2A);\n+                  let o2 = getOrientation(line1A, line1B, line2B);\n+                  let o3 = getOrientation(line2A, line2B, line1A);\n+                  let o4 = getOrientation(line2A, line2B, line1B);\n+\n+                  // General case\n+                  if ((o1 !== o2) && (o3 !== o4)) return true;\n+\n+                  // Special cases:\n+                  // Line1(A,B) and Line2(A) are colinear and Line2(A) lies on Line1\n+                  if ((o1 === 0) && onSegment(line1A, line2A, line1B)) return true;\n+                  // Line1(A,B) and Line2(B) are colinear and Line2(B) lies on Line1\n+                  if ((o2 === 0) && onSegment(line1A, line2B, line1B)) return true;\n+                  // Line2(A,B) and Line1(A) are colinear and Line1(A) lies on Line2\n+                  if ((o3 === 0) && onSegment(line2A, line1A, line2B)) return true;\n+                  // Line2(A,B) and Line1(B) are colinear and Line1(B) lies on Line2\n+                  if ((o4 === 0) && onSegment(line2A, line1B, line2B)) return true;\n+                  // Nothing intersects\n+                  return false;                  \n+                }\n+\n+                /**\n+                 * Calculates the intersection point between 'line1' and 'line2'.\n+                 * Assumes that the lines actually intersect (use linesIntersect() to verify).\n+                 */\n+                var getIntersection = function(line1A, line1B, line2A, line2B) {\n+                  // Line 1 represented as a1x + b1y = c1 \n+                  let a1 = line1B[1] - line1A[1]; \n+                  let b1 = line1A[0] - line1B[0]; \n+                  let c1 = a1 * line1A[0] + b1 * line1A[1]; \n+       \n+                  // Line 2 represented as a2x + b2y = c2 \n+                  let a2 = line2B[1] - line2A[1]; \n+                  let b2 = line2A[0] - line2B[0]; \n+                  let c2 = a2 * line2A[0] + b2 * line2A[1]; \n+                \n+                  let determinant = a1 * b2 - a2 * b1;                \n+                  let x = (b2 * c1 - b1 * c2) / determinant; \n+                  let y = (a1 * c2 - a2 * c1) / determinant; \n+                  return [x, y];\n+                }\n+\n+                /**\n+                 * Makes a \"cut\" at the datum line from the geometry edge up or down to the polar coordinate.\n+                 * The feature geometry is also transformed to WGS 1984 (EPSG:4326).\n+                 * NOTE: This is not suitable for complex or multipart polygons!\n+                 * \n+                 *           North pole polygon                   South pole polygon\n+                 *          +======+===========+                 +------------------+\n+                 *          |      |           |                 |                  |\n+                 *          |      o           |                 |            o     |\n+                 *          |                  |                 |            |     |\n+                 *          +------------------+                 +============+=====+\n+                 * \n+                 *   === -> \"cut side\" \n+                 *   o   -> polar coordinate\n+                 * @param {ol.feature} feat\n+                 * @param polarCoord\n+                 */\n+                var modifyPolarExtent = function(feat, polarCoord) {\n+                  const atNorthPole = polarCoord == northPole;\n+                  const polarLat = atNorthPole ? 90 : -90;\n+                  const parts = feat.getGeometry().getCoordinates();\n+\n+                  // Set the point of origin at equator (where datum line towards polar coordinate starts)\n+                  let originCoord = getXY(180, 0);\n+\n+                  // Show some warnings/info (when in debug mode)\n+                  console.log('Search extent contains ' + (atNorthPole ? 'north' : 'south') + ' pole');\n+                  if (parts.length > 1) {\n+                    console.warn('Multi-polygon polar search extents are not supported: this will produce unexpected results');\n+                  }\n+\n+                  // Find (1st) polar-side line segment that crosses the \"datum\".\n+                  // NOTE: this also works for non-square shapes, but NOT for shapes that cross the datum line multiple times!\n+                  let coords = parts[0];\n+                  let intersectionPointIndex = -1;\n+                  let lineStart = null;\n+                  let lineEnd = null;\n+                  for (let i = 0; i < coords.length - 1; i++) {\n+                    const p1 = coords[i];\n+                    const p2 = coords[i + 1];\n+                    if (linesIntersect(p1, p2, originCoord, polarCoord)) {\n+                      intersectionPointIndex = i + 1;\n+                      lineStart = p1;\n+                      lineEnd = p2;\n+                      break;\n+                    }\n+                  }\n+                  \n+                  if (lineStart !== null) {\n+                    // Calculate intersection point between extent segment and datum line\n+                    let intersectionPoint = getIntersection(lineStart, lineEnd, originCoord, polarCoord);\n+                    coords.splice(intersectionPointIndex, 0, intersectionPoint);\n+                    feat.setGeometry(new ol.geom.Polygon([coords]));\n+                  }\n+\n+                  // Transform to WGS 1984 (EPSG:4326)\n+                  feat.getGeometry().transform(proj, 'EPSG:4326');\n+                  \n+                  if (intersectionPointIndex >= 0) {\n+                    // Get all (transformed) coordinates and previous and next longitudes\n+                    coords = feat.getGeometry().getCoordinates()[0];\n+                    const prevLon = coords[intersectionPointIndex - 1][0];\n+                    const nextLon = coords[intersectionPointIndex + 1][0];\n+                    // Determine polar longitudes (order)\n+                    const polarLon1 = prevLon < 0 && nextLon > 0 ? -180 : 180;\n+                    const polarLon2 = -polarLon1;\n+                    // Get longitude of inserted coordinate, negate if needed (ensure correct hemisphere)\n+                    let insertedLon = coords[intersectionPointIndex][0];\n+                    if ((insertedLon > 0 && polarLon1 < 0) || (insertedLon < 0 && polarLon1 > 0)) {\n+                      insertedLon = -insertedLon;\n+                      coords[intersectionPointIndex][0] = insertedLon;\n+                    }                \n+                    // Get latitude of inserted coordinate\n+                    const insertedLat = coords[intersectionPointIndex][1];\n+                    // Insert 3 coordinates (2 at either side of the pole) to create the \"cut\"\n+                    coords.splice(intersectionPointIndex + 1, 0, [polarLon1, polarLat], [polarLon2, polarLat], [-insertedLon, insertedLat]);\n+                    feat.setGeometry(new ol.geom.Polygon([coords]));\n+                  }\n+                }\n+\n+\n+                // Transform extent to WGS 1984 (EPSG:4326)\n+                var lonlatFeat, writer, proj, wkt;\n                 lonlatFeat = feature.clone();\n-                lonlatFeat.getGeometry().transform(\n-                    scope.map.getView().getProjection().getCode(),\n-                    'EPSG:4326');\n+                if (proj !== 'EPSG:4326') {\n+                  if (proj !== 'EPSG:3857') {\n+                    // Densify edges so we get a more accurate reprojection (relates to issue #4810)\n+                    densifyEdges(lonlatFeat);\n+                  }\n+                  // Check if original extent includes a pole\n+                  let polarCoord = getInsidePole(feature);\n+                  if (polarCoord) \n+                  {\n+                    // Original extent includes a north or south pole: manipulate extent.\n+                    // Solves issue #4810: Query by south pole area doesn't give any results.\n+                    modifyPolarExtent(lonlatFeat, polarCoord);\n+                  } else {\n+                    // No pole included so a basic transformation to WGS 1984 (EPSG:4326) will do\n+                    lonlatFeat.getGeometry().transform(proj, 'EPSG:4326');\n+                  }\n+                }\n+\n+                // Write the extent as 4326 WKT polygon\n                 writer = new ol.format.WKT();\n                 wkt = writer.writeFeature(lonlatFeat);\n                 bboxSet(parent, wkt);\n               };\n \n               // If given extent coords are given through attributes,\n               // display the bbox on the map\n-              var coords = scope.$eval(attrs['gnDrawBboxExtent']);\n+              let coords = scope.$eval(attrs['gnDrawBboxExtent']);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjgwMzI5OQ=="}, "originalCommit": {"oid": "408392f1a03ca82b66ff76f42787e096b5529eee"}, "originalPosition": 256}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0MTEzMzgyOnYy", "diffSide": "RIGHT", "path": "web-ui/src/main/resources/catalog/components/search/map/MapFieldDirective.js", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwNzoyMzo0NFrOHtLrfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwOTo0NTowOFrOHtQXqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzEzOTMyNA==", "bodyText": "This should be removed", "url": "https://github.com/geonetwork/core-geonetwork/pull/5142#discussion_r517139324", "createdAt": "2020-11-04T07:23:44Z", "author": {"login": "jahow"}, "path": "web-ui/src/main/resources/catalog/components/search/map/MapFieldDirective.js", "diffHunk": "@@ -134,20 +134,253 @@\n               var updateField = function(geom) {\n                 feature.setGeometry(geom);\n \n-                // Write the extent as 4326 WKT polygon\n-                var lonlatFeat, writer, wkt;\n+                // Get projection code of current map view\n+                var proj = scope.map.getView().getProjection().getCode();\n+\n+                /**\n+                 * Transforms the given longitude-latitude pair to XY coordinates in the current projection.\n+                 * @param {number} lon \n+                 * @param {number} lat \n+                 */\n+                var getXY = function(lon, lat) {\n+                  return (new ol.geom.Point([lon, lat])).transform('EPSG:4326', proj).getFirstCoordinate();\n+                }\n+\n+                // Define polar coordinates in current projection\n+                var southPole = getXY(0, -90);\n+                var northPole = getXY(0, 90);\n+\n+                /**\n+                 * Checks if the feature geometry contains the north or south pole.\n+                 * Returns the polar coordinate in the current map projection when found or null otherwise.\n+                 * NOTE: Will not trigger if pole is on the edge.\n+                 * @param {ol.feature} feat\n+                 */\n+                var getInsidePole = function(feat) {\n+                  let geom = feat.getGeometry();\n+                  if (geom.intersectsCoordinate(southPole)) {\n+                    return southPole;\n+                  } else if (geom.intersectsCoordinate(northPole)) {\n+                    return northPole;\n+                  }\n+                }\n+\n+                /**\n+                 * Adds points to line segments.\n+                 * Specify the amount of segment parts to create (default = 4).\n+                 * The number of points that will be added is (parts - 1).\n+                 * @param {ol.feature} feat\n+                 * @param {int} parts\n+                 */\n+                var densifyEdges = function(feat, parts=4) {\n+                  let outCoords = [];\n+                  let inCoords = feat.getGeometry().getCoordinates()[0];\n+                  // No need to densify if shape already has a reasonable amount of points\n+                  if (inCoords.length > 4 * parts) return;\n+                  for (let i = 0; i < inCoords.length - 1; i++) {\n+                    let p0, p1, x0, y0, dX;\n+                    p0 = inCoords[i];\n+                    p1 = inCoords[i+1];\n+                    x0 = p0[0];\n+                    y0 = p0[1];\n+                    dX = (p1[0] - x0) / parts;\n+                    dY = (p1[1] - y0) / parts;\n+                    outCoords.push(p0);\n+                    for (let j = 1; j < parts; j++) {\n+                      // Add coords\n+                      outCoords.push([x0 + (j * dX), y0 + (j * dY)]);\n+                    }\n+                  }\n+                  // Add first coord to close polygon\n+                  outCoords.push(inCoords[0]);\n+                  feat.setGeometry(new ol.geom.Polygon([outCoords]));\n+                }\n+\n+                /**\n+                 * Given three colinear points (p1, p2, p3), check if p2 lies on line segment p1-p3.\n+                 */ \n+                var onSegment = function(p1, p2, p3) {\n+                  if (p2[0] <= Math.max(p1[0], p3[0]) && p2[0] >= Math.min(p1[0], p3[0]) && \n+                      p2[1] <= Math.max(p1[1], p3[1]) && p2[1] >= Math.min(p1[1], p3[1])) {\n+                        return true;\n+                  }\n+                  return false;\n+                }\n+\n+                /**\n+                 * Finds the orientation of an ordered triplet (p1, p2, p3). \n+                 * Returns one of the following values: \n+                 * 0 : Colinear points \n+                 * 1 : Clockwise points \n+                 * 2 : Counterclockwise \n+                 *\n+                 * See https://www.geeksforgeeks.org/orientation-3-ordered-points/amp for details of below formula.\n+                 */ \n+                var getOrientation = function(p1, p2, p3) {\n+                  let value = ((p2[1] - p1[1]) * (p3[0] - p2[0])) - ((p2[0] - p1[0]) * (p3[1] - p2[1]));\n+                  if (value > 0) return 1;\n+                  else if (value < 0) return 2;\n+                  return 0;\n+                }\n+\n+                /**\n+                 * Returns true if the line segments 'line1' and 'line2' (with points A and B) intersect. \n+                 */\n+                var linesIntersect = function(line1A, line1B, line2A, line2B) {\n+                  // Find the 4 orientations required for the general and special cases \n+                  let o1 = getOrientation(line1A, line1B, line2A);\n+                  let o2 = getOrientation(line1A, line1B, line2B);\n+                  let o3 = getOrientation(line2A, line2B, line1A);\n+                  let o4 = getOrientation(line2A, line2B, line1B);\n+\n+                  // General case\n+                  if ((o1 !== o2) && (o3 !== o4)) return true;\n+\n+                  // Special cases:\n+                  // Line1(A,B) and Line2(A) are colinear and Line2(A) lies on Line1\n+                  if ((o1 === 0) && onSegment(line1A, line2A, line1B)) return true;\n+                  // Line1(A,B) and Line2(B) are colinear and Line2(B) lies on Line1\n+                  if ((o2 === 0) && onSegment(line1A, line2B, line1B)) return true;\n+                  // Line2(A,B) and Line1(A) are colinear and Line1(A) lies on Line2\n+                  if ((o3 === 0) && onSegment(line2A, line1A, line2B)) return true;\n+                  // Line2(A,B) and Line1(B) are colinear and Line1(B) lies on Line2\n+                  if ((o4 === 0) && onSegment(line2A, line1B, line2B)) return true;\n+                  // Nothing intersects\n+                  return false;                  \n+                }\n+\n+                /**\n+                 * Calculates the intersection point between 'line1' and 'line2'.\n+                 * Assumes that the lines actually intersect (use linesIntersect() to verify).\n+                 */\n+                var getIntersection = function(line1A, line1B, line2A, line2B) {\n+                  // Line 1 represented as a1x + b1y = c1 \n+                  let a1 = line1B[1] - line1A[1]; \n+                  let b1 = line1A[0] - line1B[0]; \n+                  let c1 = a1 * line1A[0] + b1 * line1A[1]; \n+       \n+                  // Line 2 represented as a2x + b2y = c2 \n+                  let a2 = line2B[1] - line2A[1]; \n+                  let b2 = line2A[0] - line2B[0]; \n+                  let c2 = a2 * line2A[0] + b2 * line2A[1]; \n+                \n+                  let determinant = a1 * b2 - a2 * b1;                \n+                  let x = (b2 * c1 - b1 * c2) / determinant; \n+                  let y = (a1 * c2 - a2 * c1) / determinant; \n+                  return [x, y];\n+                }\n+\n+                /**\n+                 * Makes a \"cut\" at the datum line from the geometry edge up or down to the polar coordinate.\n+                 * The feature geometry is also transformed to WGS 1984 (EPSG:4326).\n+                 * NOTE: This is not suitable for complex or multipart polygons!\n+                 * \n+                 *           North pole polygon                   South pole polygon\n+                 *          +======+===========+                 +------------------+\n+                 *          |      |           |                 |                  |\n+                 *          |      o           |                 |            o     |\n+                 *          |                  |                 |            |     |\n+                 *          +------------------+                 +============+=====+\n+                 * \n+                 *   === -> \"cut side\" \n+                 *   o   -> polar coordinate\n+                 * @param {ol.feature} feat\n+                 * @param polarCoord\n+                 */\n+                var modifyPolarExtent = function(feat, polarCoord) {\n+                  const atNorthPole = polarCoord == northPole;\n+                  const polarLat = atNorthPole ? 90 : -90;\n+                  const parts = feat.getGeometry().getCoordinates();\n+\n+                  // Set the point of origin at equator (where datum line towards polar coordinate starts)\n+                  let originCoord = getXY(180, 0);\n+\n+                  // Show some warnings/info (when in debug mode)\n+                  console.log('Search extent contains ' + (atNorthPole ? 'north' : 'south') + ' pole');", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "408392f1a03ca82b66ff76f42787e096b5529eee"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE4NTE0OA==", "bodyText": "Removed? You mean replaced by library calls or moved to a service?", "url": "https://github.com/geonetwork/core-geonetwork/pull/5142#discussion_r517185148", "createdAt": "2020-11-04T08:55:22Z", "author": {"login": "GeoSander"}, "path": "web-ui/src/main/resources/catalog/components/search/map/MapFieldDirective.js", "diffHunk": "@@ -134,20 +134,253 @@\n               var updateField = function(geom) {\n                 feature.setGeometry(geom);\n \n-                // Write the extent as 4326 WKT polygon\n-                var lonlatFeat, writer, wkt;\n+                // Get projection code of current map view\n+                var proj = scope.map.getView().getProjection().getCode();\n+\n+                /**\n+                 * Transforms the given longitude-latitude pair to XY coordinates in the current projection.\n+                 * @param {number} lon \n+                 * @param {number} lat \n+                 */\n+                var getXY = function(lon, lat) {\n+                  return (new ol.geom.Point([lon, lat])).transform('EPSG:4326', proj).getFirstCoordinate();\n+                }\n+\n+                // Define polar coordinates in current projection\n+                var southPole = getXY(0, -90);\n+                var northPole = getXY(0, 90);\n+\n+                /**\n+                 * Checks if the feature geometry contains the north or south pole.\n+                 * Returns the polar coordinate in the current map projection when found or null otherwise.\n+                 * NOTE: Will not trigger if pole is on the edge.\n+                 * @param {ol.feature} feat\n+                 */\n+                var getInsidePole = function(feat) {\n+                  let geom = feat.getGeometry();\n+                  if (geom.intersectsCoordinate(southPole)) {\n+                    return southPole;\n+                  } else if (geom.intersectsCoordinate(northPole)) {\n+                    return northPole;\n+                  }\n+                }\n+\n+                /**\n+                 * Adds points to line segments.\n+                 * Specify the amount of segment parts to create (default = 4).\n+                 * The number of points that will be added is (parts - 1).\n+                 * @param {ol.feature} feat\n+                 * @param {int} parts\n+                 */\n+                var densifyEdges = function(feat, parts=4) {\n+                  let outCoords = [];\n+                  let inCoords = feat.getGeometry().getCoordinates()[0];\n+                  // No need to densify if shape already has a reasonable amount of points\n+                  if (inCoords.length > 4 * parts) return;\n+                  for (let i = 0; i < inCoords.length - 1; i++) {\n+                    let p0, p1, x0, y0, dX;\n+                    p0 = inCoords[i];\n+                    p1 = inCoords[i+1];\n+                    x0 = p0[0];\n+                    y0 = p0[1];\n+                    dX = (p1[0] - x0) / parts;\n+                    dY = (p1[1] - y0) / parts;\n+                    outCoords.push(p0);\n+                    for (let j = 1; j < parts; j++) {\n+                      // Add coords\n+                      outCoords.push([x0 + (j * dX), y0 + (j * dY)]);\n+                    }\n+                  }\n+                  // Add first coord to close polygon\n+                  outCoords.push(inCoords[0]);\n+                  feat.setGeometry(new ol.geom.Polygon([outCoords]));\n+                }\n+\n+                /**\n+                 * Given three colinear points (p1, p2, p3), check if p2 lies on line segment p1-p3.\n+                 */ \n+                var onSegment = function(p1, p2, p3) {\n+                  if (p2[0] <= Math.max(p1[0], p3[0]) && p2[0] >= Math.min(p1[0], p3[0]) && \n+                      p2[1] <= Math.max(p1[1], p3[1]) && p2[1] >= Math.min(p1[1], p3[1])) {\n+                        return true;\n+                  }\n+                  return false;\n+                }\n+\n+                /**\n+                 * Finds the orientation of an ordered triplet (p1, p2, p3). \n+                 * Returns one of the following values: \n+                 * 0 : Colinear points \n+                 * 1 : Clockwise points \n+                 * 2 : Counterclockwise \n+                 *\n+                 * See https://www.geeksforgeeks.org/orientation-3-ordered-points/amp for details of below formula.\n+                 */ \n+                var getOrientation = function(p1, p2, p3) {\n+                  let value = ((p2[1] - p1[1]) * (p3[0] - p2[0])) - ((p2[0] - p1[0]) * (p3[1] - p2[1]));\n+                  if (value > 0) return 1;\n+                  else if (value < 0) return 2;\n+                  return 0;\n+                }\n+\n+                /**\n+                 * Returns true if the line segments 'line1' and 'line2' (with points A and B) intersect. \n+                 */\n+                var linesIntersect = function(line1A, line1B, line2A, line2B) {\n+                  // Find the 4 orientations required for the general and special cases \n+                  let o1 = getOrientation(line1A, line1B, line2A);\n+                  let o2 = getOrientation(line1A, line1B, line2B);\n+                  let o3 = getOrientation(line2A, line2B, line1A);\n+                  let o4 = getOrientation(line2A, line2B, line1B);\n+\n+                  // General case\n+                  if ((o1 !== o2) && (o3 !== o4)) return true;\n+\n+                  // Special cases:\n+                  // Line1(A,B) and Line2(A) are colinear and Line2(A) lies on Line1\n+                  if ((o1 === 0) && onSegment(line1A, line2A, line1B)) return true;\n+                  // Line1(A,B) and Line2(B) are colinear and Line2(B) lies on Line1\n+                  if ((o2 === 0) && onSegment(line1A, line2B, line1B)) return true;\n+                  // Line2(A,B) and Line1(A) are colinear and Line1(A) lies on Line2\n+                  if ((o3 === 0) && onSegment(line2A, line1A, line2B)) return true;\n+                  // Line2(A,B) and Line1(B) are colinear and Line1(B) lies on Line2\n+                  if ((o4 === 0) && onSegment(line2A, line1B, line2B)) return true;\n+                  // Nothing intersects\n+                  return false;                  \n+                }\n+\n+                /**\n+                 * Calculates the intersection point between 'line1' and 'line2'.\n+                 * Assumes that the lines actually intersect (use linesIntersect() to verify).\n+                 */\n+                var getIntersection = function(line1A, line1B, line2A, line2B) {\n+                  // Line 1 represented as a1x + b1y = c1 \n+                  let a1 = line1B[1] - line1A[1]; \n+                  let b1 = line1A[0] - line1B[0]; \n+                  let c1 = a1 * line1A[0] + b1 * line1A[1]; \n+       \n+                  // Line 2 represented as a2x + b2y = c2 \n+                  let a2 = line2B[1] - line2A[1]; \n+                  let b2 = line2A[0] - line2B[0]; \n+                  let c2 = a2 * line2A[0] + b2 * line2A[1]; \n+                \n+                  let determinant = a1 * b2 - a2 * b1;                \n+                  let x = (b2 * c1 - b1 * c2) / determinant; \n+                  let y = (a1 * c2 - a2 * c1) / determinant; \n+                  return [x, y];\n+                }\n+\n+                /**\n+                 * Makes a \"cut\" at the datum line from the geometry edge up or down to the polar coordinate.\n+                 * The feature geometry is also transformed to WGS 1984 (EPSG:4326).\n+                 * NOTE: This is not suitable for complex or multipart polygons!\n+                 * \n+                 *           North pole polygon                   South pole polygon\n+                 *          +======+===========+                 +------------------+\n+                 *          |      |           |                 |                  |\n+                 *          |      o           |                 |            o     |\n+                 *          |                  |                 |            |     |\n+                 *          +------------------+                 +============+=====+\n+                 * \n+                 *   === -> \"cut side\" \n+                 *   o   -> polar coordinate\n+                 * @param {ol.feature} feat\n+                 * @param polarCoord\n+                 */\n+                var modifyPolarExtent = function(feat, polarCoord) {\n+                  const atNorthPole = polarCoord == northPole;\n+                  const polarLat = atNorthPole ? 90 : -90;\n+                  const parts = feat.getGeometry().getCoordinates();\n+\n+                  // Set the point of origin at equator (where datum line towards polar coordinate starts)\n+                  let originCoord = getXY(180, 0);\n+\n+                  // Show some warnings/info (when in debug mode)\n+                  console.log('Search extent contains ' + (atNorthPole ? 'north' : 'south') + ' pole');", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzEzOTMyNA=="}, "originalCommit": {"oid": "408392f1a03ca82b66ff76f42787e096b5529eee"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzIwNzU1Ng==", "bodyText": "No, I mean the console.log call should be removed altogether. It can be useful in debug mode but as it is currently it will always show even in production mode.", "url": "https://github.com/geonetwork/core-geonetwork/pull/5142#discussion_r517207556", "createdAt": "2020-11-04T09:31:25Z", "author": {"login": "jahow"}, "path": "web-ui/src/main/resources/catalog/components/search/map/MapFieldDirective.js", "diffHunk": "@@ -134,20 +134,253 @@\n               var updateField = function(geom) {\n                 feature.setGeometry(geom);\n \n-                // Write the extent as 4326 WKT polygon\n-                var lonlatFeat, writer, wkt;\n+                // Get projection code of current map view\n+                var proj = scope.map.getView().getProjection().getCode();\n+\n+                /**\n+                 * Transforms the given longitude-latitude pair to XY coordinates in the current projection.\n+                 * @param {number} lon \n+                 * @param {number} lat \n+                 */\n+                var getXY = function(lon, lat) {\n+                  return (new ol.geom.Point([lon, lat])).transform('EPSG:4326', proj).getFirstCoordinate();\n+                }\n+\n+                // Define polar coordinates in current projection\n+                var southPole = getXY(0, -90);\n+                var northPole = getXY(0, 90);\n+\n+                /**\n+                 * Checks if the feature geometry contains the north or south pole.\n+                 * Returns the polar coordinate in the current map projection when found or null otherwise.\n+                 * NOTE: Will not trigger if pole is on the edge.\n+                 * @param {ol.feature} feat\n+                 */\n+                var getInsidePole = function(feat) {\n+                  let geom = feat.getGeometry();\n+                  if (geom.intersectsCoordinate(southPole)) {\n+                    return southPole;\n+                  } else if (geom.intersectsCoordinate(northPole)) {\n+                    return northPole;\n+                  }\n+                }\n+\n+                /**\n+                 * Adds points to line segments.\n+                 * Specify the amount of segment parts to create (default = 4).\n+                 * The number of points that will be added is (parts - 1).\n+                 * @param {ol.feature} feat\n+                 * @param {int} parts\n+                 */\n+                var densifyEdges = function(feat, parts=4) {\n+                  let outCoords = [];\n+                  let inCoords = feat.getGeometry().getCoordinates()[0];\n+                  // No need to densify if shape already has a reasonable amount of points\n+                  if (inCoords.length > 4 * parts) return;\n+                  for (let i = 0; i < inCoords.length - 1; i++) {\n+                    let p0, p1, x0, y0, dX;\n+                    p0 = inCoords[i];\n+                    p1 = inCoords[i+1];\n+                    x0 = p0[0];\n+                    y0 = p0[1];\n+                    dX = (p1[0] - x0) / parts;\n+                    dY = (p1[1] - y0) / parts;\n+                    outCoords.push(p0);\n+                    for (let j = 1; j < parts; j++) {\n+                      // Add coords\n+                      outCoords.push([x0 + (j * dX), y0 + (j * dY)]);\n+                    }\n+                  }\n+                  // Add first coord to close polygon\n+                  outCoords.push(inCoords[0]);\n+                  feat.setGeometry(new ol.geom.Polygon([outCoords]));\n+                }\n+\n+                /**\n+                 * Given three colinear points (p1, p2, p3), check if p2 lies on line segment p1-p3.\n+                 */ \n+                var onSegment = function(p1, p2, p3) {\n+                  if (p2[0] <= Math.max(p1[0], p3[0]) && p2[0] >= Math.min(p1[0], p3[0]) && \n+                      p2[1] <= Math.max(p1[1], p3[1]) && p2[1] >= Math.min(p1[1], p3[1])) {\n+                        return true;\n+                  }\n+                  return false;\n+                }\n+\n+                /**\n+                 * Finds the orientation of an ordered triplet (p1, p2, p3). \n+                 * Returns one of the following values: \n+                 * 0 : Colinear points \n+                 * 1 : Clockwise points \n+                 * 2 : Counterclockwise \n+                 *\n+                 * See https://www.geeksforgeeks.org/orientation-3-ordered-points/amp for details of below formula.\n+                 */ \n+                var getOrientation = function(p1, p2, p3) {\n+                  let value = ((p2[1] - p1[1]) * (p3[0] - p2[0])) - ((p2[0] - p1[0]) * (p3[1] - p2[1]));\n+                  if (value > 0) return 1;\n+                  else if (value < 0) return 2;\n+                  return 0;\n+                }\n+\n+                /**\n+                 * Returns true if the line segments 'line1' and 'line2' (with points A and B) intersect. \n+                 */\n+                var linesIntersect = function(line1A, line1B, line2A, line2B) {\n+                  // Find the 4 orientations required for the general and special cases \n+                  let o1 = getOrientation(line1A, line1B, line2A);\n+                  let o2 = getOrientation(line1A, line1B, line2B);\n+                  let o3 = getOrientation(line2A, line2B, line1A);\n+                  let o4 = getOrientation(line2A, line2B, line1B);\n+\n+                  // General case\n+                  if ((o1 !== o2) && (o3 !== o4)) return true;\n+\n+                  // Special cases:\n+                  // Line1(A,B) and Line2(A) are colinear and Line2(A) lies on Line1\n+                  if ((o1 === 0) && onSegment(line1A, line2A, line1B)) return true;\n+                  // Line1(A,B) and Line2(B) are colinear and Line2(B) lies on Line1\n+                  if ((o2 === 0) && onSegment(line1A, line2B, line1B)) return true;\n+                  // Line2(A,B) and Line1(A) are colinear and Line1(A) lies on Line2\n+                  if ((o3 === 0) && onSegment(line2A, line1A, line2B)) return true;\n+                  // Line2(A,B) and Line1(B) are colinear and Line1(B) lies on Line2\n+                  if ((o4 === 0) && onSegment(line2A, line1B, line2B)) return true;\n+                  // Nothing intersects\n+                  return false;                  \n+                }\n+\n+                /**\n+                 * Calculates the intersection point between 'line1' and 'line2'.\n+                 * Assumes that the lines actually intersect (use linesIntersect() to verify).\n+                 */\n+                var getIntersection = function(line1A, line1B, line2A, line2B) {\n+                  // Line 1 represented as a1x + b1y = c1 \n+                  let a1 = line1B[1] - line1A[1]; \n+                  let b1 = line1A[0] - line1B[0]; \n+                  let c1 = a1 * line1A[0] + b1 * line1A[1]; \n+       \n+                  // Line 2 represented as a2x + b2y = c2 \n+                  let a2 = line2B[1] - line2A[1]; \n+                  let b2 = line2A[0] - line2B[0]; \n+                  let c2 = a2 * line2A[0] + b2 * line2A[1]; \n+                \n+                  let determinant = a1 * b2 - a2 * b1;                \n+                  let x = (b2 * c1 - b1 * c2) / determinant; \n+                  let y = (a1 * c2 - a2 * c1) / determinant; \n+                  return [x, y];\n+                }\n+\n+                /**\n+                 * Makes a \"cut\" at the datum line from the geometry edge up or down to the polar coordinate.\n+                 * The feature geometry is also transformed to WGS 1984 (EPSG:4326).\n+                 * NOTE: This is not suitable for complex or multipart polygons!\n+                 * \n+                 *           North pole polygon                   South pole polygon\n+                 *          +======+===========+                 +------------------+\n+                 *          |      |           |                 |                  |\n+                 *          |      o           |                 |            o     |\n+                 *          |                  |                 |            |     |\n+                 *          +------------------+                 +============+=====+\n+                 * \n+                 *   === -> \"cut side\" \n+                 *   o   -> polar coordinate\n+                 * @param {ol.feature} feat\n+                 * @param polarCoord\n+                 */\n+                var modifyPolarExtent = function(feat, polarCoord) {\n+                  const atNorthPole = polarCoord == northPole;\n+                  const polarLat = atNorthPole ? 90 : -90;\n+                  const parts = feat.getGeometry().getCoordinates();\n+\n+                  // Set the point of origin at equator (where datum line towards polar coordinate starts)\n+                  let originCoord = getXY(180, 0);\n+\n+                  // Show some warnings/info (when in debug mode)\n+                  console.log('Search extent contains ' + (atNorthPole ? 'north' : 'south') + ' pole');", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzEzOTMyNA=="}, "originalCommit": {"oid": "408392f1a03ca82b66ff76f42787e096b5529eee"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzIxNjE3MQ==", "bodyText": "Ah right. Earlier it showed an entire block of code :)\nThink I forgot to replace it with console.debug. Would that be okay for you or do you really want to remove it altogether?", "url": "https://github.com/geonetwork/core-geonetwork/pull/5142#discussion_r517216171", "createdAt": "2020-11-04T09:45:08Z", "author": {"login": "GeoSander"}, "path": "web-ui/src/main/resources/catalog/components/search/map/MapFieldDirective.js", "diffHunk": "@@ -134,20 +134,253 @@\n               var updateField = function(geom) {\n                 feature.setGeometry(geom);\n \n-                // Write the extent as 4326 WKT polygon\n-                var lonlatFeat, writer, wkt;\n+                // Get projection code of current map view\n+                var proj = scope.map.getView().getProjection().getCode();\n+\n+                /**\n+                 * Transforms the given longitude-latitude pair to XY coordinates in the current projection.\n+                 * @param {number} lon \n+                 * @param {number} lat \n+                 */\n+                var getXY = function(lon, lat) {\n+                  return (new ol.geom.Point([lon, lat])).transform('EPSG:4326', proj).getFirstCoordinate();\n+                }\n+\n+                // Define polar coordinates in current projection\n+                var southPole = getXY(0, -90);\n+                var northPole = getXY(0, 90);\n+\n+                /**\n+                 * Checks if the feature geometry contains the north or south pole.\n+                 * Returns the polar coordinate in the current map projection when found or null otherwise.\n+                 * NOTE: Will not trigger if pole is on the edge.\n+                 * @param {ol.feature} feat\n+                 */\n+                var getInsidePole = function(feat) {\n+                  let geom = feat.getGeometry();\n+                  if (geom.intersectsCoordinate(southPole)) {\n+                    return southPole;\n+                  } else if (geom.intersectsCoordinate(northPole)) {\n+                    return northPole;\n+                  }\n+                }\n+\n+                /**\n+                 * Adds points to line segments.\n+                 * Specify the amount of segment parts to create (default = 4).\n+                 * The number of points that will be added is (parts - 1).\n+                 * @param {ol.feature} feat\n+                 * @param {int} parts\n+                 */\n+                var densifyEdges = function(feat, parts=4) {\n+                  let outCoords = [];\n+                  let inCoords = feat.getGeometry().getCoordinates()[0];\n+                  // No need to densify if shape already has a reasonable amount of points\n+                  if (inCoords.length > 4 * parts) return;\n+                  for (let i = 0; i < inCoords.length - 1; i++) {\n+                    let p0, p1, x0, y0, dX;\n+                    p0 = inCoords[i];\n+                    p1 = inCoords[i+1];\n+                    x0 = p0[0];\n+                    y0 = p0[1];\n+                    dX = (p1[0] - x0) / parts;\n+                    dY = (p1[1] - y0) / parts;\n+                    outCoords.push(p0);\n+                    for (let j = 1; j < parts; j++) {\n+                      // Add coords\n+                      outCoords.push([x0 + (j * dX), y0 + (j * dY)]);\n+                    }\n+                  }\n+                  // Add first coord to close polygon\n+                  outCoords.push(inCoords[0]);\n+                  feat.setGeometry(new ol.geom.Polygon([outCoords]));\n+                }\n+\n+                /**\n+                 * Given three colinear points (p1, p2, p3), check if p2 lies on line segment p1-p3.\n+                 */ \n+                var onSegment = function(p1, p2, p3) {\n+                  if (p2[0] <= Math.max(p1[0], p3[0]) && p2[0] >= Math.min(p1[0], p3[0]) && \n+                      p2[1] <= Math.max(p1[1], p3[1]) && p2[1] >= Math.min(p1[1], p3[1])) {\n+                        return true;\n+                  }\n+                  return false;\n+                }\n+\n+                /**\n+                 * Finds the orientation of an ordered triplet (p1, p2, p3). \n+                 * Returns one of the following values: \n+                 * 0 : Colinear points \n+                 * 1 : Clockwise points \n+                 * 2 : Counterclockwise \n+                 *\n+                 * See https://www.geeksforgeeks.org/orientation-3-ordered-points/amp for details of below formula.\n+                 */ \n+                var getOrientation = function(p1, p2, p3) {\n+                  let value = ((p2[1] - p1[1]) * (p3[0] - p2[0])) - ((p2[0] - p1[0]) * (p3[1] - p2[1]));\n+                  if (value > 0) return 1;\n+                  else if (value < 0) return 2;\n+                  return 0;\n+                }\n+\n+                /**\n+                 * Returns true if the line segments 'line1' and 'line2' (with points A and B) intersect. \n+                 */\n+                var linesIntersect = function(line1A, line1B, line2A, line2B) {\n+                  // Find the 4 orientations required for the general and special cases \n+                  let o1 = getOrientation(line1A, line1B, line2A);\n+                  let o2 = getOrientation(line1A, line1B, line2B);\n+                  let o3 = getOrientation(line2A, line2B, line1A);\n+                  let o4 = getOrientation(line2A, line2B, line1B);\n+\n+                  // General case\n+                  if ((o1 !== o2) && (o3 !== o4)) return true;\n+\n+                  // Special cases:\n+                  // Line1(A,B) and Line2(A) are colinear and Line2(A) lies on Line1\n+                  if ((o1 === 0) && onSegment(line1A, line2A, line1B)) return true;\n+                  // Line1(A,B) and Line2(B) are colinear and Line2(B) lies on Line1\n+                  if ((o2 === 0) && onSegment(line1A, line2B, line1B)) return true;\n+                  // Line2(A,B) and Line1(A) are colinear and Line1(A) lies on Line2\n+                  if ((o3 === 0) && onSegment(line2A, line1A, line2B)) return true;\n+                  // Line2(A,B) and Line1(B) are colinear and Line1(B) lies on Line2\n+                  if ((o4 === 0) && onSegment(line2A, line1B, line2B)) return true;\n+                  // Nothing intersects\n+                  return false;                  \n+                }\n+\n+                /**\n+                 * Calculates the intersection point between 'line1' and 'line2'.\n+                 * Assumes that the lines actually intersect (use linesIntersect() to verify).\n+                 */\n+                var getIntersection = function(line1A, line1B, line2A, line2B) {\n+                  // Line 1 represented as a1x + b1y = c1 \n+                  let a1 = line1B[1] - line1A[1]; \n+                  let b1 = line1A[0] - line1B[0]; \n+                  let c1 = a1 * line1A[0] + b1 * line1A[1]; \n+       \n+                  // Line 2 represented as a2x + b2y = c2 \n+                  let a2 = line2B[1] - line2A[1]; \n+                  let b2 = line2A[0] - line2B[0]; \n+                  let c2 = a2 * line2A[0] + b2 * line2A[1]; \n+                \n+                  let determinant = a1 * b2 - a2 * b1;                \n+                  let x = (b2 * c1 - b1 * c2) / determinant; \n+                  let y = (a1 * c2 - a2 * c1) / determinant; \n+                  return [x, y];\n+                }\n+\n+                /**\n+                 * Makes a \"cut\" at the datum line from the geometry edge up or down to the polar coordinate.\n+                 * The feature geometry is also transformed to WGS 1984 (EPSG:4326).\n+                 * NOTE: This is not suitable for complex or multipart polygons!\n+                 * \n+                 *           North pole polygon                   South pole polygon\n+                 *          +======+===========+                 +------------------+\n+                 *          |      |           |                 |                  |\n+                 *          |      o           |                 |            o     |\n+                 *          |                  |                 |            |     |\n+                 *          +------------------+                 +============+=====+\n+                 * \n+                 *   === -> \"cut side\" \n+                 *   o   -> polar coordinate\n+                 * @param {ol.feature} feat\n+                 * @param polarCoord\n+                 */\n+                var modifyPolarExtent = function(feat, polarCoord) {\n+                  const atNorthPole = polarCoord == northPole;\n+                  const polarLat = atNorthPole ? 90 : -90;\n+                  const parts = feat.getGeometry().getCoordinates();\n+\n+                  // Set the point of origin at equator (where datum line towards polar coordinate starts)\n+                  let originCoord = getXY(180, 0);\n+\n+                  // Show some warnings/info (when in debug mode)\n+                  console.log('Search extent contains ' + (atNorthPole ? 'north' : 'south') + ' pole');", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzEzOTMyNA=="}, "originalCommit": {"oid": "408392f1a03ca82b66ff76f42787e096b5529eee"}, "originalPosition": 168}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0MTE1NjE5OnYy", "diffSide": "RIGHT", "path": "web-ui/src/main/resources/catalog/components/search/map/MapFieldDirective.js", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwNzozMTo1OVrOHtL4eA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwOToyODoxMlrOHtPtwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE0MjY0OA==", "bodyText": "I think all those utilities should not be added here, but in another service. This adds way too much code inside a simple scope method.", "url": "https://github.com/geonetwork/core-geonetwork/pull/5142#discussion_r517142648", "createdAt": "2020-11-04T07:31:59Z", "author": {"login": "jahow"}, "path": "web-ui/src/main/resources/catalog/components/search/map/MapFieldDirective.js", "diffHunk": "@@ -134,20 +134,253 @@\n               var updateField = function(geom) {\n                 feature.setGeometry(geom);\n \n-                // Write the extent as 4326 WKT polygon\n-                var lonlatFeat, writer, wkt;\n+                // Get projection code of current map view\n+                var proj = scope.map.getView().getProjection().getCode();\n+\n+                /**\n+                 * Transforms the given longitude-latitude pair to XY coordinates in the current projection.\n+                 * @param {number} lon \n+                 * @param {number} lat \n+                 */\n+                var getXY = function(lon, lat) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "408392f1a03ca82b66ff76f42787e096b5529eee"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE4MjQyNw==", "bodyText": "You've got a valid point there. Any suggestions where to put it?", "url": "https://github.com/geonetwork/core-geonetwork/pull/5142#discussion_r517182427", "createdAt": "2020-11-04T08:50:45Z", "author": {"login": "GeoSander"}, "path": "web-ui/src/main/resources/catalog/components/search/map/MapFieldDirective.js", "diffHunk": "@@ -134,20 +134,253 @@\n               var updateField = function(geom) {\n                 feature.setGeometry(geom);\n \n-                // Write the extent as 4326 WKT polygon\n-                var lonlatFeat, writer, wkt;\n+                // Get projection code of current map view\n+                var proj = scope.map.getView().getProjection().getCode();\n+\n+                /**\n+                 * Transforms the given longitude-latitude pair to XY coordinates in the current projection.\n+                 * @param {number} lon \n+                 * @param {number} lat \n+                 */\n+                var getXY = function(lon, lat) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE0MjY0OA=="}, "originalCommit": {"oid": "408392f1a03ca82b66ff76f42787e096b5529eee"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE5MTU0MQ==", "bodyText": "Well, there is a GeometryService.js file which could be a good place for these. You'd then have to import GeometryService in this directive.", "url": "https://github.com/geonetwork/core-geonetwork/pull/5142#discussion_r517191541", "createdAt": "2020-11-04T09:05:59Z", "author": {"login": "jahow"}, "path": "web-ui/src/main/resources/catalog/components/search/map/MapFieldDirective.js", "diffHunk": "@@ -134,20 +134,253 @@\n               var updateField = function(geom) {\n                 feature.setGeometry(geom);\n \n-                // Write the extent as 4326 WKT polygon\n-                var lonlatFeat, writer, wkt;\n+                // Get projection code of current map view\n+                var proj = scope.map.getView().getProjection().getCode();\n+\n+                /**\n+                 * Transforms the given longitude-latitude pair to XY coordinates in the current projection.\n+                 * @param {number} lon \n+                 * @param {number} lat \n+                 */\n+                var getXY = function(lon, lat) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE0MjY0OA=="}, "originalCommit": {"oid": "408392f1a03ca82b66ff76f42787e096b5529eee"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE5Mjk4MQ==", "bodyText": "Another option is adding a service right next to the directive, e.g. MapFieldDirectiveMapFieldService. Maybe better as it keeps the code close.", "url": "https://github.com/geonetwork/core-geonetwork/pull/5142#discussion_r517192981", "createdAt": "2020-11-04T09:08:29Z", "author": {"login": "jahow"}, "path": "web-ui/src/main/resources/catalog/components/search/map/MapFieldDirective.js", "diffHunk": "@@ -134,20 +134,253 @@\n               var updateField = function(geom) {\n                 feature.setGeometry(geom);\n \n-                // Write the extent as 4326 WKT polygon\n-                var lonlatFeat, writer, wkt;\n+                // Get projection code of current map view\n+                var proj = scope.map.getView().getProjection().getCode();\n+\n+                /**\n+                 * Transforms the given longitude-latitude pair to XY coordinates in the current projection.\n+                 * @param {number} lon \n+                 * @param {number} lat \n+                 */\n+                var getXY = function(lon, lat) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE0MjY0OA=="}, "originalCommit": {"oid": "408392f1a03ca82b66ff76f42787e096b5529eee"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzIwNTQ0MA==", "bodyText": "You mean MapFieldService, I guess? If we won't intend to use the functionality anywhere else in the future (e.g. for the main map), that probably makes sense yes.", "url": "https://github.com/geonetwork/core-geonetwork/pull/5142#discussion_r517205440", "createdAt": "2020-11-04T09:28:12Z", "author": {"login": "GeoSander"}, "path": "web-ui/src/main/resources/catalog/components/search/map/MapFieldDirective.js", "diffHunk": "@@ -134,20 +134,253 @@\n               var updateField = function(geom) {\n                 feature.setGeometry(geom);\n \n-                // Write the extent as 4326 WKT polygon\n-                var lonlatFeat, writer, wkt;\n+                // Get projection code of current map view\n+                var proj = scope.map.getView().getProjection().getCode();\n+\n+                /**\n+                 * Transforms the given longitude-latitude pair to XY coordinates in the current projection.\n+                 * @param {number} lon \n+                 * @param {number} lat \n+                 */\n+                var getXY = function(lon, lat) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE0MjY0OA=="}, "originalCommit": {"oid": "408392f1a03ca82b66ff76f42787e096b5529eee"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0MTE3ODM3OnYy", "diffSide": "RIGHT", "path": "web-ui/src/main/resources/catalog/components/search/map/MapFieldDirective.js", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwNzozOToyOVrOHtMFQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwODo1MToxNFrOHtOVHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE0NTkyMw==", "bodyText": "this can be written as ol.proj.fromLonLat([0, -90], proj)", "url": "https://github.com/geonetwork/core-geonetwork/pull/5142#discussion_r517145923", "createdAt": "2020-11-04T07:39:29Z", "author": {"login": "jahow"}, "path": "web-ui/src/main/resources/catalog/components/search/map/MapFieldDirective.js", "diffHunk": "@@ -134,20 +134,253 @@\n               var updateField = function(geom) {\n                 feature.setGeometry(geom);\n \n-                // Write the extent as 4326 WKT polygon\n-                var lonlatFeat, writer, wkt;\n+                // Get projection code of current map view\n+                var proj = scope.map.getView().getProjection().getCode();\n+\n+                /**\n+                 * Transforms the given longitude-latitude pair to XY coordinates in the current projection.\n+                 * @param {number} lon \n+                 * @param {number} lat \n+                 */\n+                var getXY = function(lon, lat) {\n+                  return (new ol.geom.Point([lon, lat])).transform('EPSG:4326', proj).getFirstCoordinate();\n+                }\n+\n+                // Define polar coordinates in current projection\n+                var southPole = getXY(0, -90);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "408392f1a03ca82b66ff76f42787e096b5529eee"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE4Mjc0OA==", "bodyText": "Ah, was looking for that, thanks. Will change.", "url": "https://github.com/geonetwork/core-geonetwork/pull/5142#discussion_r517182748", "createdAt": "2020-11-04T08:51:14Z", "author": {"login": "GeoSander"}, "path": "web-ui/src/main/resources/catalog/components/search/map/MapFieldDirective.js", "diffHunk": "@@ -134,20 +134,253 @@\n               var updateField = function(geom) {\n                 feature.setGeometry(geom);\n \n-                // Write the extent as 4326 WKT polygon\n-                var lonlatFeat, writer, wkt;\n+                // Get projection code of current map view\n+                var proj = scope.map.getView().getProjection().getCode();\n+\n+                /**\n+                 * Transforms the given longitude-latitude pair to XY coordinates in the current projection.\n+                 * @param {number} lon \n+                 * @param {number} lat \n+                 */\n+                var getXY = function(lon, lat) {\n+                  return (new ol.geom.Point([lon, lat])).transform('EPSG:4326', proj).getFirstCoordinate();\n+                }\n+\n+                // Define polar coordinates in current projection\n+                var southPole = getXY(0, -90);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE0NTkyMw=="}, "originalCommit": {"oid": "408392f1a03ca82b66ff76f42787e096b5529eee"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0MTE4MTExOnYy", "diffSide": "RIGHT", "path": "web-ui/src/main/resources/catalog/components/search/map/MapFieldDirective.js", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwNzo0MDoxOVrOHtMG0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwNzo0MDoxOVrOHtMG0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE0NjMyMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            var densifyEdges = function(feat, parts=4) {\n          \n          \n            \n                            var densifyEdges = function(feat, parts) {", "url": "https://github.com/geonetwork/core-geonetwork/pull/5142#discussion_r517146322", "createdAt": "2020-11-04T07:40:19Z", "author": {"login": "jahow"}, "path": "web-ui/src/main/resources/catalog/components/search/map/MapFieldDirective.js", "diffHunk": "@@ -134,20 +134,253 @@\n               var updateField = function(geom) {\n                 feature.setGeometry(geom);\n \n-                // Write the extent as 4326 WKT polygon\n-                var lonlatFeat, writer, wkt;\n+                // Get projection code of current map view\n+                var proj = scope.map.getView().getProjection().getCode();\n+\n+                /**\n+                 * Transforms the given longitude-latitude pair to XY coordinates in the current projection.\n+                 * @param {number} lon \n+                 * @param {number} lat \n+                 */\n+                var getXY = function(lon, lat) {\n+                  return (new ol.geom.Point([lon, lat])).transform('EPSG:4326', proj).getFirstCoordinate();\n+                }\n+\n+                // Define polar coordinates in current projection\n+                var southPole = getXY(0, -90);\n+                var northPole = getXY(0, 90);\n+\n+                /**\n+                 * Checks if the feature geometry contains the north or south pole.\n+                 * Returns the polar coordinate in the current map projection when found or null otherwise.\n+                 * NOTE: Will not trigger if pole is on the edge.\n+                 * @param {ol.feature} feat\n+                 */\n+                var getInsidePole = function(feat) {\n+                  let geom = feat.getGeometry();\n+                  if (geom.intersectsCoordinate(southPole)) {\n+                    return southPole;\n+                  } else if (geom.intersectsCoordinate(northPole)) {\n+                    return northPole;\n+                  }\n+                }\n+\n+                /**\n+                 * Adds points to line segments.\n+                 * Specify the amount of segment parts to create (default = 4).\n+                 * The number of points that will be added is (parts - 1).\n+                 * @param {ol.feature} feat\n+                 * @param {int} parts\n+                 */\n+                var densifyEdges = function(feat, parts=4) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "408392f1a03ca82b66ff76f42787e096b5529eee"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0MTE4NDk2OnYy", "diffSide": "RIGHT", "path": "web-ui/src/main/resources/catalog/components/search/map/MapFieldDirective.js", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwNzo0MTozNFrOHtMI9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQwOToyOTo0MFrOHtPxbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE0Njg3MQ==", "bodyText": "This will not work for linestrings right? maybe this should be documented better, the header only mentions \"line segments\"", "url": "https://github.com/geonetwork/core-geonetwork/pull/5142#discussion_r517146871", "createdAt": "2020-11-04T07:41:34Z", "author": {"login": "jahow"}, "path": "web-ui/src/main/resources/catalog/components/search/map/MapFieldDirective.js", "diffHunk": "@@ -134,20 +134,253 @@\n               var updateField = function(geom) {\n                 feature.setGeometry(geom);\n \n-                // Write the extent as 4326 WKT polygon\n-                var lonlatFeat, writer, wkt;\n+                // Get projection code of current map view\n+                var proj = scope.map.getView().getProjection().getCode();\n+\n+                /**\n+                 * Transforms the given longitude-latitude pair to XY coordinates in the current projection.\n+                 * @param {number} lon \n+                 * @param {number} lat \n+                 */\n+                var getXY = function(lon, lat) {\n+                  return (new ol.geom.Point([lon, lat])).transform('EPSG:4326', proj).getFirstCoordinate();\n+                }\n+\n+                // Define polar coordinates in current projection\n+                var southPole = getXY(0, -90);\n+                var northPole = getXY(0, 90);\n+\n+                /**\n+                 * Checks if the feature geometry contains the north or south pole.\n+                 * Returns the polar coordinate in the current map projection when found or null otherwise.\n+                 * NOTE: Will not trigger if pole is on the edge.\n+                 * @param {ol.feature} feat\n+                 */\n+                var getInsidePole = function(feat) {\n+                  let geom = feat.getGeometry();\n+                  if (geom.intersectsCoordinate(southPole)) {\n+                    return southPole;\n+                  } else if (geom.intersectsCoordinate(northPole)) {\n+                    return northPole;\n+                  }\n+                }\n+\n+                /**\n+                 * Adds points to line segments.\n+                 * Specify the amount of segment parts to create (default = 4).\n+                 * The number of points that will be added is (parts - 1).\n+                 * @param {ol.feature} feat\n+                 * @param {int} parts\n+                 */\n+                var densifyEdges = function(feat, parts=4) {\n+                  let outCoords = [];\n+                  let inCoords = feat.getGeometry().getCoordinates()[0];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "408392f1a03ca82b66ff76f42787e096b5529eee"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE4NDUwNA==", "bodyText": "For lines, this issue does not apply. Lines will reproject just fine.\nBut does the user even have the possibility to draw a line for a search query? Does that even make sense? People are interested in areas usually?", "url": "https://github.com/geonetwork/core-geonetwork/pull/5142#discussion_r517184504", "createdAt": "2020-11-04T08:54:18Z", "author": {"login": "GeoSander"}, "path": "web-ui/src/main/resources/catalog/components/search/map/MapFieldDirective.js", "diffHunk": "@@ -134,20 +134,253 @@\n               var updateField = function(geom) {\n                 feature.setGeometry(geom);\n \n-                // Write the extent as 4326 WKT polygon\n-                var lonlatFeat, writer, wkt;\n+                // Get projection code of current map view\n+                var proj = scope.map.getView().getProjection().getCode();\n+\n+                /**\n+                 * Transforms the given longitude-latitude pair to XY coordinates in the current projection.\n+                 * @param {number} lon \n+                 * @param {number} lat \n+                 */\n+                var getXY = function(lon, lat) {\n+                  return (new ol.geom.Point([lon, lat])).transform('EPSG:4326', proj).getFirstCoordinate();\n+                }\n+\n+                // Define polar coordinates in current projection\n+                var southPole = getXY(0, -90);\n+                var northPole = getXY(0, 90);\n+\n+                /**\n+                 * Checks if the feature geometry contains the north or south pole.\n+                 * Returns the polar coordinate in the current map projection when found or null otherwise.\n+                 * NOTE: Will not trigger if pole is on the edge.\n+                 * @param {ol.feature} feat\n+                 */\n+                var getInsidePole = function(feat) {\n+                  let geom = feat.getGeometry();\n+                  if (geom.intersectsCoordinate(southPole)) {\n+                    return southPole;\n+                  } else if (geom.intersectsCoordinate(northPole)) {\n+                    return northPole;\n+                  }\n+                }\n+\n+                /**\n+                 * Adds points to line segments.\n+                 * Specify the amount of segment parts to create (default = 4).\n+                 * The number of points that will be added is (parts - 1).\n+                 * @param {ol.feature} feat\n+                 * @param {int} parts\n+                 */\n+                var densifyEdges = function(feat, parts=4) {\n+                  let outCoords = [];\n+                  let inCoords = feat.getGeometry().getCoordinates()[0];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE0Njg3MQ=="}, "originalCommit": {"oid": "408392f1a03ca82b66ff76f42787e096b5529eee"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE4OTMyNw==", "bodyText": "Oh no, queries will always use polygons, I was just suggesting to make that clearer in the function documentation :)", "url": "https://github.com/geonetwork/core-geonetwork/pull/5142#discussion_r517189327", "createdAt": "2020-11-04T09:02:19Z", "author": {"login": "jahow"}, "path": "web-ui/src/main/resources/catalog/components/search/map/MapFieldDirective.js", "diffHunk": "@@ -134,20 +134,253 @@\n               var updateField = function(geom) {\n                 feature.setGeometry(geom);\n \n-                // Write the extent as 4326 WKT polygon\n-                var lonlatFeat, writer, wkt;\n+                // Get projection code of current map view\n+                var proj = scope.map.getView().getProjection().getCode();\n+\n+                /**\n+                 * Transforms the given longitude-latitude pair to XY coordinates in the current projection.\n+                 * @param {number} lon \n+                 * @param {number} lat \n+                 */\n+                var getXY = function(lon, lat) {\n+                  return (new ol.geom.Point([lon, lat])).transform('EPSG:4326', proj).getFirstCoordinate();\n+                }\n+\n+                // Define polar coordinates in current projection\n+                var southPole = getXY(0, -90);\n+                var northPole = getXY(0, 90);\n+\n+                /**\n+                 * Checks if the feature geometry contains the north or south pole.\n+                 * Returns the polar coordinate in the current map projection when found or null otherwise.\n+                 * NOTE: Will not trigger if pole is on the edge.\n+                 * @param {ol.feature} feat\n+                 */\n+                var getInsidePole = function(feat) {\n+                  let geom = feat.getGeometry();\n+                  if (geom.intersectsCoordinate(southPole)) {\n+                    return southPole;\n+                  } else if (geom.intersectsCoordinate(northPole)) {\n+                    return northPole;\n+                  }\n+                }\n+\n+                /**\n+                 * Adds points to line segments.\n+                 * Specify the amount of segment parts to create (default = 4).\n+                 * The number of points that will be added is (parts - 1).\n+                 * @param {ol.feature} feat\n+                 * @param {int} parts\n+                 */\n+                var densifyEdges = function(feat, parts=4) {\n+                  let outCoords = [];\n+                  let inCoords = feat.getGeometry().getCoordinates()[0];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE0Njg3MQ=="}, "originalCommit": {"oid": "408392f1a03ca82b66ff76f42787e096b5529eee"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzIwNjM4MA==", "bodyText": "Ok, will change!", "url": "https://github.com/geonetwork/core-geonetwork/pull/5142#discussion_r517206380", "createdAt": "2020-11-04T09:29:40Z", "author": {"login": "GeoSander"}, "path": "web-ui/src/main/resources/catalog/components/search/map/MapFieldDirective.js", "diffHunk": "@@ -134,20 +134,253 @@\n               var updateField = function(geom) {\n                 feature.setGeometry(geom);\n \n-                // Write the extent as 4326 WKT polygon\n-                var lonlatFeat, writer, wkt;\n+                // Get projection code of current map view\n+                var proj = scope.map.getView().getProjection().getCode();\n+\n+                /**\n+                 * Transforms the given longitude-latitude pair to XY coordinates in the current projection.\n+                 * @param {number} lon \n+                 * @param {number} lat \n+                 */\n+                var getXY = function(lon, lat) {\n+                  return (new ol.geom.Point([lon, lat])).transform('EPSG:4326', proj).getFirstCoordinate();\n+                }\n+\n+                // Define polar coordinates in current projection\n+                var southPole = getXY(0, -90);\n+                var northPole = getXY(0, 90);\n+\n+                /**\n+                 * Checks if the feature geometry contains the north or south pole.\n+                 * Returns the polar coordinate in the current map projection when found or null otherwise.\n+                 * NOTE: Will not trigger if pole is on the edge.\n+                 * @param {ol.feature} feat\n+                 */\n+                var getInsidePole = function(feat) {\n+                  let geom = feat.getGeometry();\n+                  if (geom.intersectsCoordinate(southPole)) {\n+                    return southPole;\n+                  } else if (geom.intersectsCoordinate(northPole)) {\n+                    return northPole;\n+                  }\n+                }\n+\n+                /**\n+                 * Adds points to line segments.\n+                 * Specify the amount of segment parts to create (default = 4).\n+                 * The number of points that will be added is (parts - 1).\n+                 * @param {ol.feature} feat\n+                 * @param {int} parts\n+                 */\n+                var densifyEdges = function(feat, parts=4) {\n+                  let outCoords = [];\n+                  let inCoords = feat.getGeometry().getCoordinates()[0];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE0Njg3MQ=="}, "originalCommit": {"oid": "408392f1a03ca82b66ff76f42787e096b5529eee"}, "originalPosition": 46}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4273, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}