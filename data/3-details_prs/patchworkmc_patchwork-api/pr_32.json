{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY1MDExMTYx", "number": 32, "title": "ObfuscationReflectionHelper", "bodyText": "This was sitting in my git stash and I forgot it existed. I'll have to go through and test again to make sure it works, but reviews are welcome now.", "createdAt": "2020-01-20T21:38:03Z", "url": "https://github.com/PatchworkMC/patchwork-api/pull/32", "merged": true, "mergeCommit": {"oid": "787394417909dad34f38d45ccd0b6c21a398cbff"}, "closed": true, "closedAt": "2020-02-14T04:11:58Z", "author": {"login": "TheGlitch76"}, "timelineItems": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb8TjNDAH2gAyMzY1MDExMTYxOjU4MGRkMDgzNDQ1MmE4N2ZlZmU0YTIwYzVhYzVlMzNhNTk4NmU2MDU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcEHlN9AFqTM1ODcwMzE4NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "580dd0834452a87fefe4a20c5ac5e33a5986e605", "author": {"user": {"login": "TheGlitch76", "name": "Glitch"}}, "url": "https://github.com/PatchworkMC/patchwork-api/commit/580dd0834452a87fefe4a20c5ac5e33a5986e605", "committedDate": "2020-01-20T21:37:02Z", "message": "ObfuscationReflectionHelper"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1NTUwMDg0", "url": "https://github.com/PatchworkMC/patchwork-api/pull/32#pullrequestreview-345550084", "createdAt": "2020-01-20T22:04:50Z", "commit": {"oid": "580dd0834452a87fefe4a20c5ac5e33a5986e605"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMFQyMjowNzowNVrOFfqI7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMFQyMjoxOTowNlrOFfqS-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc0MDU5MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            **/\n          \n          \n            \n             */", "url": "https://github.com/PatchworkMC/patchwork-api/pull/32#discussion_r368740590", "createdAt": "2020-01-20T22:07:05Z", "author": {"login": "coderbot16"}, "path": "patchwork-fml/src/main/java/cpw/mods/modlauncher/api/INameMappingService.java", "diffHunk": "@@ -0,0 +1,27 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2019, 2019\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package cpw.mods.modlauncher.api;\n+\n+/**\n+ * Only serves to expose the Domain enum.\n+**/", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "580dd0834452a87fefe4a20c5ac5e33a5986e605"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc0MDc4NA==", "bodyText": "Could this cause issues if Fabric is launched using ModLauncher? I would assume the true class would get loaded in that case, however.", "url": "https://github.com/PatchworkMC/patchwork-api/pull/32#discussion_r368740784", "createdAt": "2020-01-20T22:07:54Z", "author": {"login": "coderbot16"}, "path": "patchwork-fml/src/main/java/cpw/mods/modlauncher/api/INameMappingService.java", "diffHunk": "@@ -0,0 +1,27 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2019, 2019\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package cpw.mods.modlauncher.api;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "580dd0834452a87fefe4a20c5ac5e33a5986e605"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc0MTM0NQ==", "bodyText": "Can't this be replaced with Objects.requireNonNull?", "url": "https://github.com/PatchworkMC/patchwork-api/pull/32#discussion_r368741345", "createdAt": "2020-01-20T22:10:21Z", "author": {"login": "coderbot16"}, "path": "patchwork-fml/src/main/java/net/minecraftforge/fml/common/ObfuscationReflectionHelper.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2019, 2019\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package net.minecraftforge.fml.common;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.util.StringJoiner;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.Preconditions;\n+import cpw.mods.modlauncher.api.INameMappingService;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.Marker;\n+import org.apache.logging.log4j.MarkerManager;\n+\n+import com.patchworkmc.impl.fml.PatchworkMappingResolver;\n+\n+/**\n+ * Some reflection helper code.\n+ * This may not work properly in Java 9 with its new, more restrictive, reflection management.\n+ * As such, if issues are encountered, please report them and we can see what we can do to expand\n+ * the compatibility.\n+ *\n+ * <p>In other cases, AccessTransformers may be used.</p>\n+ *\n+ * <p>All field and method names should be passed in as intermediary names, and this will automatically resolve if Yarn mappings are detected.</p>\n+ *\n+ */\n+@SuppressWarnings({ \"serial\", \"unchecked\", \"unused\", \"WeakerAccess\" })\n+public class ObfuscationReflectionHelper {\n+\tprivate static final Logger LOGGER = LogManager.getLogger();\n+\tprivate static final Marker REFLECTION = MarkerManager.getMarker(\"REFLECTION\");\n+\n+\t/**\n+\t * Remaps a class name using {@link PatchworkMappingResolver#remapName(INameMappingService.Domain, Class, String)}.\n+\t * Throws an exception for non-class domains.\n+\t *\n+\t * @param domain The {@link INameMappingService.Domain} to use to remap the name.\n+\t * @param name   The name to try and remap.\n+\t * @return The remapped name, or the original name if it couldn't be remapped.\n+\t * @throws UnsupportedOperationException if the {@code domain} is not {@link INameMappingService.Domain#CLASS}\n+\t * @deprecated Patchwork: use {@link PatchworkMappingResolver} instead\n+\t */\n+\t@Deprecated\n+\t@Nonnull\n+\tpublic static String remapName(INameMappingService.Domain domain, String name) {\n+\t\tif (domain == INameMappingService.Domain.CLASS) {\n+\t\t\treturn PatchworkMappingResolver.remapName(domain, null, name);\n+\t\t} else {\n+\t\t\t// This would need a special remapping system, if someone uses it then it can be implemented\n+\t\t\tthrow new UnsupportedOperationException(\"FIXME: Unable to lookup member of type \" + domain.name() + \" with name \" + name + \".\");\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Gets the value a field with the specified index in the given class.\n+\t * Note: For performance, use {@link #findField(Class, int)} if you are getting the value more than once.\n+\t *\n+\t * <p>Throws an exception if the field is not found or the value of the field cannot be gotten.</p>\n+\t *\n+\t * @param classToAccess The class to find the field on.\n+\t * @param instance      The instance of the {@code classToAccess}.\n+\t * @param fieldIndex    The index of the field in the {@code classToAccess}.\n+\t * @param <T>           The type of the value.\n+\t * @param <E>           The type of the {@code classToAccess}.\n+\t * @return The value of the field with the specified index in the {@code classToAccess}.\n+\t * @throws UnableToAccessFieldException If there was a problem getting the field or the value.\n+\t * @deprecated Use {@link #getPrivateValue(Class, Object, String)} because field indices change a lot more often than field names do.\n+\t * Forge: TODO Remove in 1.15\n+\t */\n+\t@Deprecated\n+\t@Nullable\n+\tpublic static <T, E> T getPrivateValue(Class<? super E> classToAccess, E instance, int fieldIndex) {\n+\t\ttry {\n+\t\t\treturn (T) findField(classToAccess, fieldIndex).get(instance);\n+\t\t} catch (Exception e) {\n+\t\t\tLOGGER.error(REFLECTION, \"There was a problem getting field index {} from {}\", fieldIndex, classToAccess.getName(), e);\n+\t\t\tthrow new UnableToAccessFieldException(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Gets the value a field with the specified name in the given class.\n+\t * Note: For performance, use {@link #findField(Class, String)} if you are getting the value more than once.\n+\t *\n+\t * <p>Throws an exception if the field is not found or the value of the field cannot be gotten.</p>\n+\t *\n+\t * @param classToAccess The class to find the field on.\n+\t * @param instance      The instance of the {@code classToAccess}.\n+\t * @param fieldName     The intermediary (unmapped) name of the field to find (e.g. \"field_5821\").\n+\t * @param <T>           The type of the value.\n+\t * @param <E>           The type of the {@code classToAccess}.\n+\t * @return The value of the field with the specified name in the {@code classToAccess}.\n+\t * @throws UnableToAccessFieldException If there was a problem getting the field.\n+\t * @throws UnableToAccessFieldException If there was a problem getting the value.\n+\t */\n+\t@Nullable\n+\tpublic static <T, E> T getPrivateValue(Class<? super E> classToAccess, E instance, String fieldName) {\n+\t\ttry {\n+\t\t\treturn (T) findField(classToAccess, fieldName).get(instance);\n+\t\t} catch (UnableToFindFieldException e) {\n+\t\t\tLOGGER.error(REFLECTION, \"Unable to locate field {} ({}) on type {}\", fieldName,\n+\t\t\t\t\tPatchworkMappingResolver.remapName(INameMappingService.Domain.FIELD, classToAccess, fieldName), classToAccess.getName(), e);\n+\t\t\tthrow e;\n+\t\t} catch (IllegalAccessException e) {\n+\t\t\tLOGGER.error(REFLECTION, \"Unable to access field {} ({}) on type {}\", fieldName,\n+\t\t\t\t\tPatchworkMappingResolver.remapName(INameMappingService.Domain.FIELD, classToAccess, fieldName), classToAccess.getName(), e);\n+\t\t\tthrow new UnableToAccessFieldException(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Sets the value a field with the specified index in the given class.\n+\t * Note: For performance, use {@link #findField(Class, int)} if you are setting the value more than once.\n+\t *\n+\t * <p>Throws an exception if the field is not found or the value of the field cannot be set.</p>\n+\t *\n+\t * @param classToAccess The class to find the field on.\n+\t * @param instance      The instance of the {@code classToAccess}.\n+\t * @param value         The new value for the field\n+\t * @param fieldIndex    The index of the field in the {@code classToAccess}.\n+\t * @param <T>           The type of the value.\n+\t * @param <E>           The type of the {@code classToAccess}.\n+\t * @throws UnableToAccessFieldException If there was a problem setting the value of the field.\n+\t * @deprecated Use {@link #setPrivateValue(Class, Object, Object, String)} because field indices change a lot more often than field names do.\n+\t * Forge: TODO Remove in 1.15\n+\t */\n+\t@Deprecated\n+\tpublic static <T, E> void setPrivateValue(@Nonnull final Class<? super T> classToAccess, @Nonnull final T instance, @Nullable final E value, int fieldIndex) {\n+\t\ttry {\n+\t\t\tfindField(classToAccess, fieldIndex).set(instance, value);\n+\t\t} catch (IllegalAccessException e) {\n+\t\t\tLOGGER.error(\"There was a problem setting field index {} on type {}\", fieldIndex, classToAccess.getName(), e);\n+\t\t\tthrow new UnableToAccessFieldException(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Sets the value a field with the specified name in the given class.\n+\t * Note: For performance, use {@link #findField(Class, String)} if you are setting the value more than once.\n+\t *\n+\t * <p>Throws an exception if the field is not found or the value of the field cannot be set.</p>\n+\t *\n+\t * @param classToAccess The class to find the field on.\n+\t * @param instance      The instance of the {@code classToAccess}.\n+\t * @param value         The new value for the field\n+\t * @param fieldName     The name of the field in the {@code classToAccess}.\n+\t * @param <T>           The type of the value.\n+\t * @param <E>           The type of the {@code classToAccess}.\n+\t * @throws UnableToFindFieldException   If there was a problem getting the field.\n+\t * @throws UnableToAccessFieldException If there was a problem setting the value of the field.\n+\t */\n+\tpublic static <T, E> void setPrivateValue(@Nonnull final Class<? super T> classToAccess, @Nonnull final T instance,\n+\t\t\t\t@Nullable final E value, @Nonnull final String fieldName) {\n+\t\ttry {\n+\t\t\tfindField(classToAccess, fieldName).set(instance, value);\n+\t\t} catch (UnableToFindFieldException e) {\n+\t\t\tLOGGER.error(\"Unable to locate any field {} on type {}\", fieldName, classToAccess.getName(), e);\n+\t\t\tthrow e;\n+\t\t} catch (IllegalAccessException e) {\n+\t\t\tLOGGER.error(\"Unable to set any field {} on type {}\", fieldName, classToAccess.getName(), e);\n+\t\t\tthrow new UnableToAccessFieldException(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Finds a method with the specified name and parameters in the given class and makes it accessible.\n+\t * Note: For performance, store the returned value and avoid calling this repeatedly.\n+\t *\n+\t * <p>Throws an exception if the method is not found.</p>\n+\t *\n+\t * @param clazz          The class to find the method on.\n+\t * @param methodName     The intermediary (unmapped) name of the method to find (e.g. \"method_342\").\n+\t * @param parameterTypes The parameter types of the method to find.\n+\t * @return The method with the specified name and parameters in the given class.\n+\t * @throws NullPointerException        If {@code clazz} is null.\n+\t * @throws NullPointerException        If {@code methodName} is null.\n+\t * @throws IllegalArgumentException    If {@code methodName} is empty.\n+\t * @throws NullPointerException        If {@code parameterTypes} is null.\n+\t * @throws UnableToFindMethodException If the method could not be found.\n+\t */\n+\t@Nonnull\n+\tpublic static Method findMethod(@Nonnull final Class<?> clazz, @Nonnull final String methodName, @Nonnull final Class<?>... parameterTypes) {\n+\t\tPreconditions.checkNotNull(clazz, \"Class to find method on cannot be null.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "580dd0834452a87fefe4a20c5ac5e33a5986e605"}, "originalPosition": 205}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc0MTUwOA==", "bodyText": "This line seems a little long, maybe split it up? Maybe method instead of m too.", "url": "https://github.com/PatchworkMC/patchwork-api/pull/32#discussion_r368741508", "createdAt": "2020-01-20T22:11:03Z", "author": {"login": "coderbot16"}, "path": "patchwork-fml/src/main/java/net/minecraftforge/fml/common/ObfuscationReflectionHelper.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2019, 2019\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package net.minecraftforge.fml.common;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.util.StringJoiner;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.Preconditions;\n+import cpw.mods.modlauncher.api.INameMappingService;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.Marker;\n+import org.apache.logging.log4j.MarkerManager;\n+\n+import com.patchworkmc.impl.fml.PatchworkMappingResolver;\n+\n+/**\n+ * Some reflection helper code.\n+ * This may not work properly in Java 9 with its new, more restrictive, reflection management.\n+ * As such, if issues are encountered, please report them and we can see what we can do to expand\n+ * the compatibility.\n+ *\n+ * <p>In other cases, AccessTransformers may be used.</p>\n+ *\n+ * <p>All field and method names should be passed in as intermediary names, and this will automatically resolve if Yarn mappings are detected.</p>\n+ *\n+ */\n+@SuppressWarnings({ \"serial\", \"unchecked\", \"unused\", \"WeakerAccess\" })\n+public class ObfuscationReflectionHelper {\n+\tprivate static final Logger LOGGER = LogManager.getLogger();\n+\tprivate static final Marker REFLECTION = MarkerManager.getMarker(\"REFLECTION\");\n+\n+\t/**\n+\t * Remaps a class name using {@link PatchworkMappingResolver#remapName(INameMappingService.Domain, Class, String)}.\n+\t * Throws an exception for non-class domains.\n+\t *\n+\t * @param domain The {@link INameMappingService.Domain} to use to remap the name.\n+\t * @param name   The name to try and remap.\n+\t * @return The remapped name, or the original name if it couldn't be remapped.\n+\t * @throws UnsupportedOperationException if the {@code domain} is not {@link INameMappingService.Domain#CLASS}\n+\t * @deprecated Patchwork: use {@link PatchworkMappingResolver} instead\n+\t */\n+\t@Deprecated\n+\t@Nonnull\n+\tpublic static String remapName(INameMappingService.Domain domain, String name) {\n+\t\tif (domain == INameMappingService.Domain.CLASS) {\n+\t\t\treturn PatchworkMappingResolver.remapName(domain, null, name);\n+\t\t} else {\n+\t\t\t// This would need a special remapping system, if someone uses it then it can be implemented\n+\t\t\tthrow new UnsupportedOperationException(\"FIXME: Unable to lookup member of type \" + domain.name() + \" with name \" + name + \".\");\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Gets the value a field with the specified index in the given class.\n+\t * Note: For performance, use {@link #findField(Class, int)} if you are getting the value more than once.\n+\t *\n+\t * <p>Throws an exception if the field is not found or the value of the field cannot be gotten.</p>\n+\t *\n+\t * @param classToAccess The class to find the field on.\n+\t * @param instance      The instance of the {@code classToAccess}.\n+\t * @param fieldIndex    The index of the field in the {@code classToAccess}.\n+\t * @param <T>           The type of the value.\n+\t * @param <E>           The type of the {@code classToAccess}.\n+\t * @return The value of the field with the specified index in the {@code classToAccess}.\n+\t * @throws UnableToAccessFieldException If there was a problem getting the field or the value.\n+\t * @deprecated Use {@link #getPrivateValue(Class, Object, String)} because field indices change a lot more often than field names do.\n+\t * Forge: TODO Remove in 1.15\n+\t */\n+\t@Deprecated\n+\t@Nullable\n+\tpublic static <T, E> T getPrivateValue(Class<? super E> classToAccess, E instance, int fieldIndex) {\n+\t\ttry {\n+\t\t\treturn (T) findField(classToAccess, fieldIndex).get(instance);\n+\t\t} catch (Exception e) {\n+\t\t\tLOGGER.error(REFLECTION, \"There was a problem getting field index {} from {}\", fieldIndex, classToAccess.getName(), e);\n+\t\t\tthrow new UnableToAccessFieldException(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Gets the value a field with the specified name in the given class.\n+\t * Note: For performance, use {@link #findField(Class, String)} if you are getting the value more than once.\n+\t *\n+\t * <p>Throws an exception if the field is not found or the value of the field cannot be gotten.</p>\n+\t *\n+\t * @param classToAccess The class to find the field on.\n+\t * @param instance      The instance of the {@code classToAccess}.\n+\t * @param fieldName     The intermediary (unmapped) name of the field to find (e.g. \"field_5821\").\n+\t * @param <T>           The type of the value.\n+\t * @param <E>           The type of the {@code classToAccess}.\n+\t * @return The value of the field with the specified name in the {@code classToAccess}.\n+\t * @throws UnableToAccessFieldException If there was a problem getting the field.\n+\t * @throws UnableToAccessFieldException If there was a problem getting the value.\n+\t */\n+\t@Nullable\n+\tpublic static <T, E> T getPrivateValue(Class<? super E> classToAccess, E instance, String fieldName) {\n+\t\ttry {\n+\t\t\treturn (T) findField(classToAccess, fieldName).get(instance);\n+\t\t} catch (UnableToFindFieldException e) {\n+\t\t\tLOGGER.error(REFLECTION, \"Unable to locate field {} ({}) on type {}\", fieldName,\n+\t\t\t\t\tPatchworkMappingResolver.remapName(INameMappingService.Domain.FIELD, classToAccess, fieldName), classToAccess.getName(), e);\n+\t\t\tthrow e;\n+\t\t} catch (IllegalAccessException e) {\n+\t\t\tLOGGER.error(REFLECTION, \"Unable to access field {} ({}) on type {}\", fieldName,\n+\t\t\t\t\tPatchworkMappingResolver.remapName(INameMappingService.Domain.FIELD, classToAccess, fieldName), classToAccess.getName(), e);\n+\t\t\tthrow new UnableToAccessFieldException(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Sets the value a field with the specified index in the given class.\n+\t * Note: For performance, use {@link #findField(Class, int)} if you are setting the value more than once.\n+\t *\n+\t * <p>Throws an exception if the field is not found or the value of the field cannot be set.</p>\n+\t *\n+\t * @param classToAccess The class to find the field on.\n+\t * @param instance      The instance of the {@code classToAccess}.\n+\t * @param value         The new value for the field\n+\t * @param fieldIndex    The index of the field in the {@code classToAccess}.\n+\t * @param <T>           The type of the value.\n+\t * @param <E>           The type of the {@code classToAccess}.\n+\t * @throws UnableToAccessFieldException If there was a problem setting the value of the field.\n+\t * @deprecated Use {@link #setPrivateValue(Class, Object, Object, String)} because field indices change a lot more often than field names do.\n+\t * Forge: TODO Remove in 1.15\n+\t */\n+\t@Deprecated\n+\tpublic static <T, E> void setPrivateValue(@Nonnull final Class<? super T> classToAccess, @Nonnull final T instance, @Nullable final E value, int fieldIndex) {\n+\t\ttry {\n+\t\t\tfindField(classToAccess, fieldIndex).set(instance, value);\n+\t\t} catch (IllegalAccessException e) {\n+\t\t\tLOGGER.error(\"There was a problem setting field index {} on type {}\", fieldIndex, classToAccess.getName(), e);\n+\t\t\tthrow new UnableToAccessFieldException(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Sets the value a field with the specified name in the given class.\n+\t * Note: For performance, use {@link #findField(Class, String)} if you are setting the value more than once.\n+\t *\n+\t * <p>Throws an exception if the field is not found or the value of the field cannot be set.</p>\n+\t *\n+\t * @param classToAccess The class to find the field on.\n+\t * @param instance      The instance of the {@code classToAccess}.\n+\t * @param value         The new value for the field\n+\t * @param fieldName     The name of the field in the {@code classToAccess}.\n+\t * @param <T>           The type of the value.\n+\t * @param <E>           The type of the {@code classToAccess}.\n+\t * @throws UnableToFindFieldException   If there was a problem getting the field.\n+\t * @throws UnableToAccessFieldException If there was a problem setting the value of the field.\n+\t */\n+\tpublic static <T, E> void setPrivateValue(@Nonnull final Class<? super T> classToAccess, @Nonnull final T instance,\n+\t\t\t\t@Nullable final E value, @Nonnull final String fieldName) {\n+\t\ttry {\n+\t\t\tfindField(classToAccess, fieldName).set(instance, value);\n+\t\t} catch (UnableToFindFieldException e) {\n+\t\t\tLOGGER.error(\"Unable to locate any field {} on type {}\", fieldName, classToAccess.getName(), e);\n+\t\t\tthrow e;\n+\t\t} catch (IllegalAccessException e) {\n+\t\t\tLOGGER.error(\"Unable to set any field {} on type {}\", fieldName, classToAccess.getName(), e);\n+\t\t\tthrow new UnableToAccessFieldException(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Finds a method with the specified name and parameters in the given class and makes it accessible.\n+\t * Note: For performance, store the returned value and avoid calling this repeatedly.\n+\t *\n+\t * <p>Throws an exception if the method is not found.</p>\n+\t *\n+\t * @param clazz          The class to find the method on.\n+\t * @param methodName     The intermediary (unmapped) name of the method to find (e.g. \"method_342\").\n+\t * @param parameterTypes The parameter types of the method to find.\n+\t * @return The method with the specified name and parameters in the given class.\n+\t * @throws NullPointerException        If {@code clazz} is null.\n+\t * @throws NullPointerException        If {@code methodName} is null.\n+\t * @throws IllegalArgumentException    If {@code methodName} is empty.\n+\t * @throws NullPointerException        If {@code parameterTypes} is null.\n+\t * @throws UnableToFindMethodException If the method could not be found.\n+\t */\n+\t@Nonnull\n+\tpublic static Method findMethod(@Nonnull final Class<?> clazz, @Nonnull final String methodName, @Nonnull final Class<?>... parameterTypes) {\n+\t\tPreconditions.checkNotNull(clazz, \"Class to find method on cannot be null.\");\n+\t\tPreconditions.checkNotNull(methodName, \"Name of method to find cannot be null.\");\n+\t\tPreconditions.checkArgument(!methodName.isEmpty(), \"Name of method to find cannot be empty.\");\n+\t\tPreconditions.checkNotNull(parameterTypes, \"Parameter types of method to find cannot be null.\");\n+\n+\t\ttry {\n+\t\t\tMethod m = clazz.getDeclaredMethod(PatchworkMappingResolver.remapName(INameMappingService.Domain.METHOD, clazz, methodName), parameterTypes);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "580dd0834452a87fefe4a20c5ac5e33a5986e605"}, "originalPosition": 211}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc0MTU2OA==", "bodyText": "Objects.requireNonNull again", "url": "https://github.com/PatchworkMC/patchwork-api/pull/32#discussion_r368741568", "createdAt": "2020-01-20T22:11:20Z", "author": {"login": "coderbot16"}, "path": "patchwork-fml/src/main/java/net/minecraftforge/fml/common/ObfuscationReflectionHelper.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2019, 2019\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package net.minecraftforge.fml.common;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.util.StringJoiner;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.Preconditions;\n+import cpw.mods.modlauncher.api.INameMappingService;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.Marker;\n+import org.apache.logging.log4j.MarkerManager;\n+\n+import com.patchworkmc.impl.fml.PatchworkMappingResolver;\n+\n+/**\n+ * Some reflection helper code.\n+ * This may not work properly in Java 9 with its new, more restrictive, reflection management.\n+ * As such, if issues are encountered, please report them and we can see what we can do to expand\n+ * the compatibility.\n+ *\n+ * <p>In other cases, AccessTransformers may be used.</p>\n+ *\n+ * <p>All field and method names should be passed in as intermediary names, and this will automatically resolve if Yarn mappings are detected.</p>\n+ *\n+ */\n+@SuppressWarnings({ \"serial\", \"unchecked\", \"unused\", \"WeakerAccess\" })\n+public class ObfuscationReflectionHelper {\n+\tprivate static final Logger LOGGER = LogManager.getLogger();\n+\tprivate static final Marker REFLECTION = MarkerManager.getMarker(\"REFLECTION\");\n+\n+\t/**\n+\t * Remaps a class name using {@link PatchworkMappingResolver#remapName(INameMappingService.Domain, Class, String)}.\n+\t * Throws an exception for non-class domains.\n+\t *\n+\t * @param domain The {@link INameMappingService.Domain} to use to remap the name.\n+\t * @param name   The name to try and remap.\n+\t * @return The remapped name, or the original name if it couldn't be remapped.\n+\t * @throws UnsupportedOperationException if the {@code domain} is not {@link INameMappingService.Domain#CLASS}\n+\t * @deprecated Patchwork: use {@link PatchworkMappingResolver} instead\n+\t */\n+\t@Deprecated\n+\t@Nonnull\n+\tpublic static String remapName(INameMappingService.Domain domain, String name) {\n+\t\tif (domain == INameMappingService.Domain.CLASS) {\n+\t\t\treturn PatchworkMappingResolver.remapName(domain, null, name);\n+\t\t} else {\n+\t\t\t// This would need a special remapping system, if someone uses it then it can be implemented\n+\t\t\tthrow new UnsupportedOperationException(\"FIXME: Unable to lookup member of type \" + domain.name() + \" with name \" + name + \".\");\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Gets the value a field with the specified index in the given class.\n+\t * Note: For performance, use {@link #findField(Class, int)} if you are getting the value more than once.\n+\t *\n+\t * <p>Throws an exception if the field is not found or the value of the field cannot be gotten.</p>\n+\t *\n+\t * @param classToAccess The class to find the field on.\n+\t * @param instance      The instance of the {@code classToAccess}.\n+\t * @param fieldIndex    The index of the field in the {@code classToAccess}.\n+\t * @param <T>           The type of the value.\n+\t * @param <E>           The type of the {@code classToAccess}.\n+\t * @return The value of the field with the specified index in the {@code classToAccess}.\n+\t * @throws UnableToAccessFieldException If there was a problem getting the field or the value.\n+\t * @deprecated Use {@link #getPrivateValue(Class, Object, String)} because field indices change a lot more often than field names do.\n+\t * Forge: TODO Remove in 1.15\n+\t */\n+\t@Deprecated\n+\t@Nullable\n+\tpublic static <T, E> T getPrivateValue(Class<? super E> classToAccess, E instance, int fieldIndex) {\n+\t\ttry {\n+\t\t\treturn (T) findField(classToAccess, fieldIndex).get(instance);\n+\t\t} catch (Exception e) {\n+\t\t\tLOGGER.error(REFLECTION, \"There was a problem getting field index {} from {}\", fieldIndex, classToAccess.getName(), e);\n+\t\t\tthrow new UnableToAccessFieldException(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Gets the value a field with the specified name in the given class.\n+\t * Note: For performance, use {@link #findField(Class, String)} if you are getting the value more than once.\n+\t *\n+\t * <p>Throws an exception if the field is not found or the value of the field cannot be gotten.</p>\n+\t *\n+\t * @param classToAccess The class to find the field on.\n+\t * @param instance      The instance of the {@code classToAccess}.\n+\t * @param fieldName     The intermediary (unmapped) name of the field to find (e.g. \"field_5821\").\n+\t * @param <T>           The type of the value.\n+\t * @param <E>           The type of the {@code classToAccess}.\n+\t * @return The value of the field with the specified name in the {@code classToAccess}.\n+\t * @throws UnableToAccessFieldException If there was a problem getting the field.\n+\t * @throws UnableToAccessFieldException If there was a problem getting the value.\n+\t */\n+\t@Nullable\n+\tpublic static <T, E> T getPrivateValue(Class<? super E> classToAccess, E instance, String fieldName) {\n+\t\ttry {\n+\t\t\treturn (T) findField(classToAccess, fieldName).get(instance);\n+\t\t} catch (UnableToFindFieldException e) {\n+\t\t\tLOGGER.error(REFLECTION, \"Unable to locate field {} ({}) on type {}\", fieldName,\n+\t\t\t\t\tPatchworkMappingResolver.remapName(INameMappingService.Domain.FIELD, classToAccess, fieldName), classToAccess.getName(), e);\n+\t\t\tthrow e;\n+\t\t} catch (IllegalAccessException e) {\n+\t\t\tLOGGER.error(REFLECTION, \"Unable to access field {} ({}) on type {}\", fieldName,\n+\t\t\t\t\tPatchworkMappingResolver.remapName(INameMappingService.Domain.FIELD, classToAccess, fieldName), classToAccess.getName(), e);\n+\t\t\tthrow new UnableToAccessFieldException(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Sets the value a field with the specified index in the given class.\n+\t * Note: For performance, use {@link #findField(Class, int)} if you are setting the value more than once.\n+\t *\n+\t * <p>Throws an exception if the field is not found or the value of the field cannot be set.</p>\n+\t *\n+\t * @param classToAccess The class to find the field on.\n+\t * @param instance      The instance of the {@code classToAccess}.\n+\t * @param value         The new value for the field\n+\t * @param fieldIndex    The index of the field in the {@code classToAccess}.\n+\t * @param <T>           The type of the value.\n+\t * @param <E>           The type of the {@code classToAccess}.\n+\t * @throws UnableToAccessFieldException If there was a problem setting the value of the field.\n+\t * @deprecated Use {@link #setPrivateValue(Class, Object, Object, String)} because field indices change a lot more often than field names do.\n+\t * Forge: TODO Remove in 1.15\n+\t */\n+\t@Deprecated\n+\tpublic static <T, E> void setPrivateValue(@Nonnull final Class<? super T> classToAccess, @Nonnull final T instance, @Nullable final E value, int fieldIndex) {\n+\t\ttry {\n+\t\t\tfindField(classToAccess, fieldIndex).set(instance, value);\n+\t\t} catch (IllegalAccessException e) {\n+\t\t\tLOGGER.error(\"There was a problem setting field index {} on type {}\", fieldIndex, classToAccess.getName(), e);\n+\t\t\tthrow new UnableToAccessFieldException(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Sets the value a field with the specified name in the given class.\n+\t * Note: For performance, use {@link #findField(Class, String)} if you are setting the value more than once.\n+\t *\n+\t * <p>Throws an exception if the field is not found or the value of the field cannot be set.</p>\n+\t *\n+\t * @param classToAccess The class to find the field on.\n+\t * @param instance      The instance of the {@code classToAccess}.\n+\t * @param value         The new value for the field\n+\t * @param fieldName     The name of the field in the {@code classToAccess}.\n+\t * @param <T>           The type of the value.\n+\t * @param <E>           The type of the {@code classToAccess}.\n+\t * @throws UnableToFindFieldException   If there was a problem getting the field.\n+\t * @throws UnableToAccessFieldException If there was a problem setting the value of the field.\n+\t */\n+\tpublic static <T, E> void setPrivateValue(@Nonnull final Class<? super T> classToAccess, @Nonnull final T instance,\n+\t\t\t\t@Nullable final E value, @Nonnull final String fieldName) {\n+\t\ttry {\n+\t\t\tfindField(classToAccess, fieldName).set(instance, value);\n+\t\t} catch (UnableToFindFieldException e) {\n+\t\t\tLOGGER.error(\"Unable to locate any field {} on type {}\", fieldName, classToAccess.getName(), e);\n+\t\t\tthrow e;\n+\t\t} catch (IllegalAccessException e) {\n+\t\t\tLOGGER.error(\"Unable to set any field {} on type {}\", fieldName, classToAccess.getName(), e);\n+\t\t\tthrow new UnableToAccessFieldException(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Finds a method with the specified name and parameters in the given class and makes it accessible.\n+\t * Note: For performance, store the returned value and avoid calling this repeatedly.\n+\t *\n+\t * <p>Throws an exception if the method is not found.</p>\n+\t *\n+\t * @param clazz          The class to find the method on.\n+\t * @param methodName     The intermediary (unmapped) name of the method to find (e.g. \"method_342\").\n+\t * @param parameterTypes The parameter types of the method to find.\n+\t * @return The method with the specified name and parameters in the given class.\n+\t * @throws NullPointerException        If {@code clazz} is null.\n+\t * @throws NullPointerException        If {@code methodName} is null.\n+\t * @throws IllegalArgumentException    If {@code methodName} is empty.\n+\t * @throws NullPointerException        If {@code parameterTypes} is null.\n+\t * @throws UnableToFindMethodException If the method could not be found.\n+\t */\n+\t@Nonnull\n+\tpublic static Method findMethod(@Nonnull final Class<?> clazz, @Nonnull final String methodName, @Nonnull final Class<?>... parameterTypes) {\n+\t\tPreconditions.checkNotNull(clazz, \"Class to find method on cannot be null.\");\n+\t\tPreconditions.checkNotNull(methodName, \"Name of method to find cannot be null.\");\n+\t\tPreconditions.checkArgument(!methodName.isEmpty(), \"Name of method to find cannot be empty.\");\n+\t\tPreconditions.checkNotNull(parameterTypes, \"Parameter types of method to find cannot be null.\");\n+\n+\t\ttry {\n+\t\t\tMethod m = clazz.getDeclaredMethod(PatchworkMappingResolver.remapName(INameMappingService.Domain.METHOD, clazz, methodName), parameterTypes);\n+\t\t\tm.setAccessible(true);\n+\t\t\treturn m;\n+\t\t} catch (Exception e) {\n+\t\t\tthrow new UnableToFindMethodException(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Finds a constructor with the specified parameter types in the given class and makes it accessible.\n+\t * Note: For performance, store the returned value and avoid calling this repeatedly.\n+\t *\n+\t * <p>Throws an exception if the constructor is not found.</p>\n+\t *\n+\t * @param clazz          The class to find the constructor in.\n+\t * @param parameterTypes The parameter types of the constructor.\n+\t * @param <T>            The type.\n+\t * @return The constructor with the specified parameters in the given class.\n+\t * @throws NullPointerException        If {@code clazz} is null.\n+\t * @throws NullPointerException        If {@code parameterTypes} is null.\n+\t * @throws UnknownConstructorException If the constructor could not be found.\n+\t */\n+\t@Nonnull\n+\tpublic static <T> Constructor<T> findConstructor(@Nonnull final Class<T> clazz, @Nonnull final Class<?>... parameterTypes) {\n+\t\tPreconditions.checkNotNull(clazz, \"Class to find constructor on cannot be null.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "580dd0834452a87fefe4a20c5ac5e33a5986e605"}, "originalPosition": 235}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc0MTgyNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t * <p>Throws an exception if the constructor is not found.</p>\n          \n          \n            \n            \t * <p>Throws an exception if the constructor was not found.</p>", "url": "https://github.com/PatchworkMC/patchwork-api/pull/32#discussion_r368741827", "createdAt": "2020-01-20T22:12:39Z", "author": {"login": "coderbot16"}, "path": "patchwork-fml/src/main/java/net/minecraftforge/fml/common/ObfuscationReflectionHelper.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2019, 2019\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package net.minecraftforge.fml.common;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.util.StringJoiner;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.Preconditions;\n+import cpw.mods.modlauncher.api.INameMappingService;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.Marker;\n+import org.apache.logging.log4j.MarkerManager;\n+\n+import com.patchworkmc.impl.fml.PatchworkMappingResolver;\n+\n+/**\n+ * Some reflection helper code.\n+ * This may not work properly in Java 9 with its new, more restrictive, reflection management.\n+ * As such, if issues are encountered, please report them and we can see what we can do to expand\n+ * the compatibility.\n+ *\n+ * <p>In other cases, AccessTransformers may be used.</p>\n+ *\n+ * <p>All field and method names should be passed in as intermediary names, and this will automatically resolve if Yarn mappings are detected.</p>\n+ *\n+ */\n+@SuppressWarnings({ \"serial\", \"unchecked\", \"unused\", \"WeakerAccess\" })\n+public class ObfuscationReflectionHelper {\n+\tprivate static final Logger LOGGER = LogManager.getLogger();\n+\tprivate static final Marker REFLECTION = MarkerManager.getMarker(\"REFLECTION\");\n+\n+\t/**\n+\t * Remaps a class name using {@link PatchworkMappingResolver#remapName(INameMappingService.Domain, Class, String)}.\n+\t * Throws an exception for non-class domains.\n+\t *\n+\t * @param domain The {@link INameMappingService.Domain} to use to remap the name.\n+\t * @param name   The name to try and remap.\n+\t * @return The remapped name, or the original name if it couldn't be remapped.\n+\t * @throws UnsupportedOperationException if the {@code domain} is not {@link INameMappingService.Domain#CLASS}\n+\t * @deprecated Patchwork: use {@link PatchworkMappingResolver} instead\n+\t */\n+\t@Deprecated\n+\t@Nonnull\n+\tpublic static String remapName(INameMappingService.Domain domain, String name) {\n+\t\tif (domain == INameMappingService.Domain.CLASS) {\n+\t\t\treturn PatchworkMappingResolver.remapName(domain, null, name);\n+\t\t} else {\n+\t\t\t// This would need a special remapping system, if someone uses it then it can be implemented\n+\t\t\tthrow new UnsupportedOperationException(\"FIXME: Unable to lookup member of type \" + domain.name() + \" with name \" + name + \".\");\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Gets the value a field with the specified index in the given class.\n+\t * Note: For performance, use {@link #findField(Class, int)} if you are getting the value more than once.\n+\t *\n+\t * <p>Throws an exception if the field is not found or the value of the field cannot be gotten.</p>\n+\t *\n+\t * @param classToAccess The class to find the field on.\n+\t * @param instance      The instance of the {@code classToAccess}.\n+\t * @param fieldIndex    The index of the field in the {@code classToAccess}.\n+\t * @param <T>           The type of the value.\n+\t * @param <E>           The type of the {@code classToAccess}.\n+\t * @return The value of the field with the specified index in the {@code classToAccess}.\n+\t * @throws UnableToAccessFieldException If there was a problem getting the field or the value.\n+\t * @deprecated Use {@link #getPrivateValue(Class, Object, String)} because field indices change a lot more often than field names do.\n+\t * Forge: TODO Remove in 1.15\n+\t */\n+\t@Deprecated\n+\t@Nullable\n+\tpublic static <T, E> T getPrivateValue(Class<? super E> classToAccess, E instance, int fieldIndex) {\n+\t\ttry {\n+\t\t\treturn (T) findField(classToAccess, fieldIndex).get(instance);\n+\t\t} catch (Exception e) {\n+\t\t\tLOGGER.error(REFLECTION, \"There was a problem getting field index {} from {}\", fieldIndex, classToAccess.getName(), e);\n+\t\t\tthrow new UnableToAccessFieldException(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Gets the value a field with the specified name in the given class.\n+\t * Note: For performance, use {@link #findField(Class, String)} if you are getting the value more than once.\n+\t *\n+\t * <p>Throws an exception if the field is not found or the value of the field cannot be gotten.</p>\n+\t *\n+\t * @param classToAccess The class to find the field on.\n+\t * @param instance      The instance of the {@code classToAccess}.\n+\t * @param fieldName     The intermediary (unmapped) name of the field to find (e.g. \"field_5821\").\n+\t * @param <T>           The type of the value.\n+\t * @param <E>           The type of the {@code classToAccess}.\n+\t * @return The value of the field with the specified name in the {@code classToAccess}.\n+\t * @throws UnableToAccessFieldException If there was a problem getting the field.\n+\t * @throws UnableToAccessFieldException If there was a problem getting the value.\n+\t */\n+\t@Nullable\n+\tpublic static <T, E> T getPrivateValue(Class<? super E> classToAccess, E instance, String fieldName) {\n+\t\ttry {\n+\t\t\treturn (T) findField(classToAccess, fieldName).get(instance);\n+\t\t} catch (UnableToFindFieldException e) {\n+\t\t\tLOGGER.error(REFLECTION, \"Unable to locate field {} ({}) on type {}\", fieldName,\n+\t\t\t\t\tPatchworkMappingResolver.remapName(INameMappingService.Domain.FIELD, classToAccess, fieldName), classToAccess.getName(), e);\n+\t\t\tthrow e;\n+\t\t} catch (IllegalAccessException e) {\n+\t\t\tLOGGER.error(REFLECTION, \"Unable to access field {} ({}) on type {}\", fieldName,\n+\t\t\t\t\tPatchworkMappingResolver.remapName(INameMappingService.Domain.FIELD, classToAccess, fieldName), classToAccess.getName(), e);\n+\t\t\tthrow new UnableToAccessFieldException(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Sets the value a field with the specified index in the given class.\n+\t * Note: For performance, use {@link #findField(Class, int)} if you are setting the value more than once.\n+\t *\n+\t * <p>Throws an exception if the field is not found or the value of the field cannot be set.</p>\n+\t *\n+\t * @param classToAccess The class to find the field on.\n+\t * @param instance      The instance of the {@code classToAccess}.\n+\t * @param value         The new value for the field\n+\t * @param fieldIndex    The index of the field in the {@code classToAccess}.\n+\t * @param <T>           The type of the value.\n+\t * @param <E>           The type of the {@code classToAccess}.\n+\t * @throws UnableToAccessFieldException If there was a problem setting the value of the field.\n+\t * @deprecated Use {@link #setPrivateValue(Class, Object, Object, String)} because field indices change a lot more often than field names do.\n+\t * Forge: TODO Remove in 1.15\n+\t */\n+\t@Deprecated\n+\tpublic static <T, E> void setPrivateValue(@Nonnull final Class<? super T> classToAccess, @Nonnull final T instance, @Nullable final E value, int fieldIndex) {\n+\t\ttry {\n+\t\t\tfindField(classToAccess, fieldIndex).set(instance, value);\n+\t\t} catch (IllegalAccessException e) {\n+\t\t\tLOGGER.error(\"There was a problem setting field index {} on type {}\", fieldIndex, classToAccess.getName(), e);\n+\t\t\tthrow new UnableToAccessFieldException(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Sets the value a field with the specified name in the given class.\n+\t * Note: For performance, use {@link #findField(Class, String)} if you are setting the value more than once.\n+\t *\n+\t * <p>Throws an exception if the field is not found or the value of the field cannot be set.</p>\n+\t *\n+\t * @param classToAccess The class to find the field on.\n+\t * @param instance      The instance of the {@code classToAccess}.\n+\t * @param value         The new value for the field\n+\t * @param fieldName     The name of the field in the {@code classToAccess}.\n+\t * @param <T>           The type of the value.\n+\t * @param <E>           The type of the {@code classToAccess}.\n+\t * @throws UnableToFindFieldException   If there was a problem getting the field.\n+\t * @throws UnableToAccessFieldException If there was a problem setting the value of the field.\n+\t */\n+\tpublic static <T, E> void setPrivateValue(@Nonnull final Class<? super T> classToAccess, @Nonnull final T instance,\n+\t\t\t\t@Nullable final E value, @Nonnull final String fieldName) {\n+\t\ttry {\n+\t\t\tfindField(classToAccess, fieldName).set(instance, value);\n+\t\t} catch (UnableToFindFieldException e) {\n+\t\t\tLOGGER.error(\"Unable to locate any field {} on type {}\", fieldName, classToAccess.getName(), e);\n+\t\t\tthrow e;\n+\t\t} catch (IllegalAccessException e) {\n+\t\t\tLOGGER.error(\"Unable to set any field {} on type {}\", fieldName, classToAccess.getName(), e);\n+\t\t\tthrow new UnableToAccessFieldException(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Finds a method with the specified name and parameters in the given class and makes it accessible.\n+\t * Note: For performance, store the returned value and avoid calling this repeatedly.\n+\t *\n+\t * <p>Throws an exception if the method is not found.</p>\n+\t *\n+\t * @param clazz          The class to find the method on.\n+\t * @param methodName     The intermediary (unmapped) name of the method to find (e.g. \"method_342\").\n+\t * @param parameterTypes The parameter types of the method to find.\n+\t * @return The method with the specified name and parameters in the given class.\n+\t * @throws NullPointerException        If {@code clazz} is null.\n+\t * @throws NullPointerException        If {@code methodName} is null.\n+\t * @throws IllegalArgumentException    If {@code methodName} is empty.\n+\t * @throws NullPointerException        If {@code parameterTypes} is null.\n+\t * @throws UnableToFindMethodException If the method could not be found.\n+\t */\n+\t@Nonnull\n+\tpublic static Method findMethod(@Nonnull final Class<?> clazz, @Nonnull final String methodName, @Nonnull final Class<?>... parameterTypes) {\n+\t\tPreconditions.checkNotNull(clazz, \"Class to find method on cannot be null.\");\n+\t\tPreconditions.checkNotNull(methodName, \"Name of method to find cannot be null.\");\n+\t\tPreconditions.checkArgument(!methodName.isEmpty(), \"Name of method to find cannot be empty.\");\n+\t\tPreconditions.checkNotNull(parameterTypes, \"Parameter types of method to find cannot be null.\");\n+\n+\t\ttry {\n+\t\t\tMethod m = clazz.getDeclaredMethod(PatchworkMappingResolver.remapName(INameMappingService.Domain.METHOD, clazz, methodName), parameterTypes);\n+\t\t\tm.setAccessible(true);\n+\t\t\treturn m;\n+\t\t} catch (Exception e) {\n+\t\t\tthrow new UnableToFindMethodException(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Finds a constructor with the specified parameter types in the given class and makes it accessible.\n+\t * Note: For performance, store the returned value and avoid calling this repeatedly.\n+\t *\n+\t * <p>Throws an exception if the constructor is not found.</p>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "580dd0834452a87fefe4a20c5ac5e33a5986e605"}, "originalPosition": 223}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc0MTkzNA==", "bodyText": "This line seems a little long too; maybe field instead?", "url": "https://github.com/PatchworkMC/patchwork-api/pull/32#discussion_r368741934", "createdAt": "2020-01-20T22:13:10Z", "author": {"login": "coderbot16"}, "path": "patchwork-fml/src/main/java/net/minecraftforge/fml/common/ObfuscationReflectionHelper.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2019, 2019\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package net.minecraftforge.fml.common;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.util.StringJoiner;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.Preconditions;\n+import cpw.mods.modlauncher.api.INameMappingService;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.Marker;\n+import org.apache.logging.log4j.MarkerManager;\n+\n+import com.patchworkmc.impl.fml.PatchworkMappingResolver;\n+\n+/**\n+ * Some reflection helper code.\n+ * This may not work properly in Java 9 with its new, more restrictive, reflection management.\n+ * As such, if issues are encountered, please report them and we can see what we can do to expand\n+ * the compatibility.\n+ *\n+ * <p>In other cases, AccessTransformers may be used.</p>\n+ *\n+ * <p>All field and method names should be passed in as intermediary names, and this will automatically resolve if Yarn mappings are detected.</p>\n+ *\n+ */\n+@SuppressWarnings({ \"serial\", \"unchecked\", \"unused\", \"WeakerAccess\" })\n+public class ObfuscationReflectionHelper {\n+\tprivate static final Logger LOGGER = LogManager.getLogger();\n+\tprivate static final Marker REFLECTION = MarkerManager.getMarker(\"REFLECTION\");\n+\n+\t/**\n+\t * Remaps a class name using {@link PatchworkMappingResolver#remapName(INameMappingService.Domain, Class, String)}.\n+\t * Throws an exception for non-class domains.\n+\t *\n+\t * @param domain The {@link INameMappingService.Domain} to use to remap the name.\n+\t * @param name   The name to try and remap.\n+\t * @return The remapped name, or the original name if it couldn't be remapped.\n+\t * @throws UnsupportedOperationException if the {@code domain} is not {@link INameMappingService.Domain#CLASS}\n+\t * @deprecated Patchwork: use {@link PatchworkMappingResolver} instead\n+\t */\n+\t@Deprecated\n+\t@Nonnull\n+\tpublic static String remapName(INameMappingService.Domain domain, String name) {\n+\t\tif (domain == INameMappingService.Domain.CLASS) {\n+\t\t\treturn PatchworkMappingResolver.remapName(domain, null, name);\n+\t\t} else {\n+\t\t\t// This would need a special remapping system, if someone uses it then it can be implemented\n+\t\t\tthrow new UnsupportedOperationException(\"FIXME: Unable to lookup member of type \" + domain.name() + \" with name \" + name + \".\");\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Gets the value a field with the specified index in the given class.\n+\t * Note: For performance, use {@link #findField(Class, int)} if you are getting the value more than once.\n+\t *\n+\t * <p>Throws an exception if the field is not found or the value of the field cannot be gotten.</p>\n+\t *\n+\t * @param classToAccess The class to find the field on.\n+\t * @param instance      The instance of the {@code classToAccess}.\n+\t * @param fieldIndex    The index of the field in the {@code classToAccess}.\n+\t * @param <T>           The type of the value.\n+\t * @param <E>           The type of the {@code classToAccess}.\n+\t * @return The value of the field with the specified index in the {@code classToAccess}.\n+\t * @throws UnableToAccessFieldException If there was a problem getting the field or the value.\n+\t * @deprecated Use {@link #getPrivateValue(Class, Object, String)} because field indices change a lot more often than field names do.\n+\t * Forge: TODO Remove in 1.15\n+\t */\n+\t@Deprecated\n+\t@Nullable\n+\tpublic static <T, E> T getPrivateValue(Class<? super E> classToAccess, E instance, int fieldIndex) {\n+\t\ttry {\n+\t\t\treturn (T) findField(classToAccess, fieldIndex).get(instance);\n+\t\t} catch (Exception e) {\n+\t\t\tLOGGER.error(REFLECTION, \"There was a problem getting field index {} from {}\", fieldIndex, classToAccess.getName(), e);\n+\t\t\tthrow new UnableToAccessFieldException(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Gets the value a field with the specified name in the given class.\n+\t * Note: For performance, use {@link #findField(Class, String)} if you are getting the value more than once.\n+\t *\n+\t * <p>Throws an exception if the field is not found or the value of the field cannot be gotten.</p>\n+\t *\n+\t * @param classToAccess The class to find the field on.\n+\t * @param instance      The instance of the {@code classToAccess}.\n+\t * @param fieldName     The intermediary (unmapped) name of the field to find (e.g. \"field_5821\").\n+\t * @param <T>           The type of the value.\n+\t * @param <E>           The type of the {@code classToAccess}.\n+\t * @return The value of the field with the specified name in the {@code classToAccess}.\n+\t * @throws UnableToAccessFieldException If there was a problem getting the field.\n+\t * @throws UnableToAccessFieldException If there was a problem getting the value.\n+\t */\n+\t@Nullable\n+\tpublic static <T, E> T getPrivateValue(Class<? super E> classToAccess, E instance, String fieldName) {\n+\t\ttry {\n+\t\t\treturn (T) findField(classToAccess, fieldName).get(instance);\n+\t\t} catch (UnableToFindFieldException e) {\n+\t\t\tLOGGER.error(REFLECTION, \"Unable to locate field {} ({}) on type {}\", fieldName,\n+\t\t\t\t\tPatchworkMappingResolver.remapName(INameMappingService.Domain.FIELD, classToAccess, fieldName), classToAccess.getName(), e);\n+\t\t\tthrow e;\n+\t\t} catch (IllegalAccessException e) {\n+\t\t\tLOGGER.error(REFLECTION, \"Unable to access field {} ({}) on type {}\", fieldName,\n+\t\t\t\t\tPatchworkMappingResolver.remapName(INameMappingService.Domain.FIELD, classToAccess, fieldName), classToAccess.getName(), e);\n+\t\t\tthrow new UnableToAccessFieldException(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Sets the value a field with the specified index in the given class.\n+\t * Note: For performance, use {@link #findField(Class, int)} if you are setting the value more than once.\n+\t *\n+\t * <p>Throws an exception if the field is not found or the value of the field cannot be set.</p>\n+\t *\n+\t * @param classToAccess The class to find the field on.\n+\t * @param instance      The instance of the {@code classToAccess}.\n+\t * @param value         The new value for the field\n+\t * @param fieldIndex    The index of the field in the {@code classToAccess}.\n+\t * @param <T>           The type of the value.\n+\t * @param <E>           The type of the {@code classToAccess}.\n+\t * @throws UnableToAccessFieldException If there was a problem setting the value of the field.\n+\t * @deprecated Use {@link #setPrivateValue(Class, Object, Object, String)} because field indices change a lot more often than field names do.\n+\t * Forge: TODO Remove in 1.15\n+\t */\n+\t@Deprecated\n+\tpublic static <T, E> void setPrivateValue(@Nonnull final Class<? super T> classToAccess, @Nonnull final T instance, @Nullable final E value, int fieldIndex) {\n+\t\ttry {\n+\t\t\tfindField(classToAccess, fieldIndex).set(instance, value);\n+\t\t} catch (IllegalAccessException e) {\n+\t\t\tLOGGER.error(\"There was a problem setting field index {} on type {}\", fieldIndex, classToAccess.getName(), e);\n+\t\t\tthrow new UnableToAccessFieldException(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Sets the value a field with the specified name in the given class.\n+\t * Note: For performance, use {@link #findField(Class, String)} if you are setting the value more than once.\n+\t *\n+\t * <p>Throws an exception if the field is not found or the value of the field cannot be set.</p>\n+\t *\n+\t * @param classToAccess The class to find the field on.\n+\t * @param instance      The instance of the {@code classToAccess}.\n+\t * @param value         The new value for the field\n+\t * @param fieldName     The name of the field in the {@code classToAccess}.\n+\t * @param <T>           The type of the value.\n+\t * @param <E>           The type of the {@code classToAccess}.\n+\t * @throws UnableToFindFieldException   If there was a problem getting the field.\n+\t * @throws UnableToAccessFieldException If there was a problem setting the value of the field.\n+\t */\n+\tpublic static <T, E> void setPrivateValue(@Nonnull final Class<? super T> classToAccess, @Nonnull final T instance,\n+\t\t\t\t@Nullable final E value, @Nonnull final String fieldName) {\n+\t\ttry {\n+\t\t\tfindField(classToAccess, fieldName).set(instance, value);\n+\t\t} catch (UnableToFindFieldException e) {\n+\t\t\tLOGGER.error(\"Unable to locate any field {} on type {}\", fieldName, classToAccess.getName(), e);\n+\t\t\tthrow e;\n+\t\t} catch (IllegalAccessException e) {\n+\t\t\tLOGGER.error(\"Unable to set any field {} on type {}\", fieldName, classToAccess.getName(), e);\n+\t\t\tthrow new UnableToAccessFieldException(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Finds a method with the specified name and parameters in the given class and makes it accessible.\n+\t * Note: For performance, store the returned value and avoid calling this repeatedly.\n+\t *\n+\t * <p>Throws an exception if the method is not found.</p>\n+\t *\n+\t * @param clazz          The class to find the method on.\n+\t * @param methodName     The intermediary (unmapped) name of the method to find (e.g. \"method_342\").\n+\t * @param parameterTypes The parameter types of the method to find.\n+\t * @return The method with the specified name and parameters in the given class.\n+\t * @throws NullPointerException        If {@code clazz} is null.\n+\t * @throws NullPointerException        If {@code methodName} is null.\n+\t * @throws IllegalArgumentException    If {@code methodName} is empty.\n+\t * @throws NullPointerException        If {@code parameterTypes} is null.\n+\t * @throws UnableToFindMethodException If the method could not be found.\n+\t */\n+\t@Nonnull\n+\tpublic static Method findMethod(@Nonnull final Class<?> clazz, @Nonnull final String methodName, @Nonnull final Class<?>... parameterTypes) {\n+\t\tPreconditions.checkNotNull(clazz, \"Class to find method on cannot be null.\");\n+\t\tPreconditions.checkNotNull(methodName, \"Name of method to find cannot be null.\");\n+\t\tPreconditions.checkArgument(!methodName.isEmpty(), \"Name of method to find cannot be empty.\");\n+\t\tPreconditions.checkNotNull(parameterTypes, \"Parameter types of method to find cannot be null.\");\n+\n+\t\ttry {\n+\t\t\tMethod m = clazz.getDeclaredMethod(PatchworkMappingResolver.remapName(INameMappingService.Domain.METHOD, clazz, methodName), parameterTypes);\n+\t\t\tm.setAccessible(true);\n+\t\t\treturn m;\n+\t\t} catch (Exception e) {\n+\t\t\tthrow new UnableToFindMethodException(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Finds a constructor with the specified parameter types in the given class and makes it accessible.\n+\t * Note: For performance, store the returned value and avoid calling this repeatedly.\n+\t *\n+\t * <p>Throws an exception if the constructor is not found.</p>\n+\t *\n+\t * @param clazz          The class to find the constructor in.\n+\t * @param parameterTypes The parameter types of the constructor.\n+\t * @param <T>            The type.\n+\t * @return The constructor with the specified parameters in the given class.\n+\t * @throws NullPointerException        If {@code clazz} is null.\n+\t * @throws NullPointerException        If {@code parameterTypes} is null.\n+\t * @throws UnknownConstructorException If the constructor could not be found.\n+\t */\n+\t@Nonnull\n+\tpublic static <T> Constructor<T> findConstructor(@Nonnull final Class<T> clazz, @Nonnull final Class<?>... parameterTypes) {\n+\t\tPreconditions.checkNotNull(clazz, \"Class to find constructor on cannot be null.\");\n+\t\tPreconditions.checkNotNull(parameterTypes, \"Parameter types of constructor to find cannot be null.\");\n+\n+\t\ttry {\n+\t\t\tConstructor<T> constructor = clazz.getDeclaredConstructor(parameterTypes);\n+\t\t\tconstructor.setAccessible(true);\n+\t\t\treturn constructor;\n+\t\t} catch (final NoSuchMethodException e) {\n+\t\t\tfinal StringBuilder desc = new StringBuilder();\n+\t\t\tdesc.append(clazz.getSimpleName());\n+\n+\t\t\tStringJoiner joiner = new StringJoiner(\", \", \"(\", \")\");\n+\n+\t\t\tfor (Class<?> type : parameterTypes) {\n+\t\t\t\tjoiner.add(type.getSimpleName());\n+\t\t\t}\n+\n+\t\t\tdesc.append(joiner);\n+\n+\t\t\tthrow new UnknownConstructorException(\"Could not find constructor '\" + desc + \"' in \" + clazz);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Finds a field with the specified name in the given class and makes it accessible.\n+\t * Note: For performance, store the returned value and avoid calling this repeatedly.\n+\t *\n+\t * <p>Throws an exception if the field is not found.</p>\n+\t *\n+\t * @param clazz     The class to find the field on.\n+\t * @param fieldName The intermediary (unmapped) name of the field to find (e.g. \"field_1817\").\n+\t * @param <T>       The type.\n+\t * @return The constructor with the specified parameters in the given class.\n+\t * @throws NullPointerException       If {@code clazz} is null.\n+\t * @throws NullPointerException       If {@code fieldName} is null.\n+\t * @throws IllegalArgumentException   If {@code fieldName} is empty.\n+\t * @throws UnableToFindFieldException If the field could not be found.\n+\t */\n+\t@Nonnull\n+\tpublic static <T> Field findField(@Nonnull final Class<? super T> clazz, @Nonnull final String fieldName) {\n+\t\tPreconditions.checkNotNull(clazz, \"Class to find field on cannot be null.\");\n+\t\tPreconditions.checkNotNull(fieldName, \"Name of field to find cannot be null.\");\n+\t\tPreconditions.checkArgument(!fieldName.isEmpty(), \"Name of field to find cannot be empty.\");\n+\n+\t\ttry {\n+\t\t\tField f = clazz.getDeclaredField(PatchworkMappingResolver.remapName(INameMappingService.Domain.FIELD, clazz, fieldName));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "580dd0834452a87fefe4a20c5ac5e33a5986e605"}, "originalPosition": 280}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc0MjQ0Nw==", "bodyText": "Mixins? This comment isn't super relevant to Patchwork, since ATs don't exist at runtime (unless we're talking about FabricASM)", "url": "https://github.com/PatchworkMC/patchwork-api/pull/32#discussion_r368742447", "createdAt": "2020-01-20T22:15:32Z", "author": {"login": "coderbot16"}, "path": "patchwork-fml/src/main/java/net/minecraftforge/fml/common/ObfuscationReflectionHelper.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2019, 2019\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package net.minecraftforge.fml.common;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.util.StringJoiner;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.Preconditions;\n+import cpw.mods.modlauncher.api.INameMappingService;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.Marker;\n+import org.apache.logging.log4j.MarkerManager;\n+\n+import com.patchworkmc.impl.fml.PatchworkMappingResolver;\n+\n+/**\n+ * Some reflection helper code.\n+ * This may not work properly in Java 9 with its new, more restrictive, reflection management.\n+ * As such, if issues are encountered, please report them and we can see what we can do to expand\n+ * the compatibility.\n+ *\n+ * <p>In other cases, AccessTransformers may be used.</p>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "580dd0834452a87fefe4a20c5ac5e33a5986e605"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc0MjU3MQ==", "bodyText": "These warnings are scary, if they're only relevant for a few lines maybe move them to a more restricted scope?", "url": "https://github.com/PatchworkMC/patchwork-api/pull/32#discussion_r368742571", "createdAt": "2020-01-20T22:16:10Z", "author": {"login": "coderbot16"}, "path": "patchwork-fml/src/main/java/net/minecraftforge/fml/common/ObfuscationReflectionHelper.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2019, 2019\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package net.minecraftforge.fml.common;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.util.StringJoiner;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.Preconditions;\n+import cpw.mods.modlauncher.api.INameMappingService;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.Marker;\n+import org.apache.logging.log4j.MarkerManager;\n+\n+import com.patchworkmc.impl.fml.PatchworkMappingResolver;\n+\n+/**\n+ * Some reflection helper code.\n+ * This may not work properly in Java 9 with its new, more restrictive, reflection management.\n+ * As such, if issues are encountered, please report them and we can see what we can do to expand\n+ * the compatibility.\n+ *\n+ * <p>In other cases, AccessTransformers may be used.</p>\n+ *\n+ * <p>All field and method names should be passed in as intermediary names, and this will automatically resolve if Yarn mappings are detected.</p>\n+ *\n+ */\n+@SuppressWarnings({ \"serial\", \"unchecked\", \"unused\", \"WeakerAccess\" })", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "580dd0834452a87fefe4a20c5ac5e33a5986e605"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc0MjkwNg==", "bodyText": "Does this actually print the exception?", "url": "https://github.com/PatchworkMC/patchwork-api/pull/32#discussion_r368742906", "createdAt": "2020-01-20T22:17:47Z", "author": {"login": "coderbot16"}, "path": "patchwork-fml/src/main/java/net/minecraftforge/fml/common/ObfuscationReflectionHelper.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2019, 2019\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package net.minecraftforge.fml.common;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.util.StringJoiner;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.Preconditions;\n+import cpw.mods.modlauncher.api.INameMappingService;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.Marker;\n+import org.apache.logging.log4j.MarkerManager;\n+\n+import com.patchworkmc.impl.fml.PatchworkMappingResolver;\n+\n+/**\n+ * Some reflection helper code.\n+ * This may not work properly in Java 9 with its new, more restrictive, reflection management.\n+ * As such, if issues are encountered, please report them and we can see what we can do to expand\n+ * the compatibility.\n+ *\n+ * <p>In other cases, AccessTransformers may be used.</p>\n+ *\n+ * <p>All field and method names should be passed in as intermediary names, and this will automatically resolve if Yarn mappings are detected.</p>\n+ *\n+ */\n+@SuppressWarnings({ \"serial\", \"unchecked\", \"unused\", \"WeakerAccess\" })\n+public class ObfuscationReflectionHelper {\n+\tprivate static final Logger LOGGER = LogManager.getLogger();\n+\tprivate static final Marker REFLECTION = MarkerManager.getMarker(\"REFLECTION\");\n+\n+\t/**\n+\t * Remaps a class name using {@link PatchworkMappingResolver#remapName(INameMappingService.Domain, Class, String)}.\n+\t * Throws an exception for non-class domains.\n+\t *\n+\t * @param domain The {@link INameMappingService.Domain} to use to remap the name.\n+\t * @param name   The name to try and remap.\n+\t * @return The remapped name, or the original name if it couldn't be remapped.\n+\t * @throws UnsupportedOperationException if the {@code domain} is not {@link INameMappingService.Domain#CLASS}\n+\t * @deprecated Patchwork: use {@link PatchworkMappingResolver} instead\n+\t */\n+\t@Deprecated\n+\t@Nonnull\n+\tpublic static String remapName(INameMappingService.Domain domain, String name) {\n+\t\tif (domain == INameMappingService.Domain.CLASS) {\n+\t\t\treturn PatchworkMappingResolver.remapName(domain, null, name);\n+\t\t} else {\n+\t\t\t// This would need a special remapping system, if someone uses it then it can be implemented\n+\t\t\tthrow new UnsupportedOperationException(\"FIXME: Unable to lookup member of type \" + domain.name() + \" with name \" + name + \".\");\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Gets the value a field with the specified index in the given class.\n+\t * Note: For performance, use {@link #findField(Class, int)} if you are getting the value more than once.\n+\t *\n+\t * <p>Throws an exception if the field is not found or the value of the field cannot be gotten.</p>\n+\t *\n+\t * @param classToAccess The class to find the field on.\n+\t * @param instance      The instance of the {@code classToAccess}.\n+\t * @param fieldIndex    The index of the field in the {@code classToAccess}.\n+\t * @param <T>           The type of the value.\n+\t * @param <E>           The type of the {@code classToAccess}.\n+\t * @return The value of the field with the specified index in the {@code classToAccess}.\n+\t * @throws UnableToAccessFieldException If there was a problem getting the field or the value.\n+\t * @deprecated Use {@link #getPrivateValue(Class, Object, String)} because field indices change a lot more often than field names do.\n+\t * Forge: TODO Remove in 1.15\n+\t */\n+\t@Deprecated\n+\t@Nullable\n+\tpublic static <T, E> T getPrivateValue(Class<? super E> classToAccess, E instance, int fieldIndex) {\n+\t\ttry {\n+\t\t\treturn (T) findField(classToAccess, fieldIndex).get(instance);\n+\t\t} catch (Exception e) {\n+\t\t\tLOGGER.error(REFLECTION, \"There was a problem getting field index {} from {}\", fieldIndex, classToAccess.getName(), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "580dd0834452a87fefe4a20c5ac5e33a5986e605"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc0MzA4Mg==", "bodyText": "descriptor?", "url": "https://github.com/PatchworkMC/patchwork-api/pull/32#discussion_r368743082", "createdAt": "2020-01-20T22:18:38Z", "author": {"login": "coderbot16"}, "path": "patchwork-fml/src/main/java/com/patchworkmc/impl/fml/PatchworkMappingResolver.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2019, 2019\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package com.patchworkmc.impl.fml;\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+\n+import cpw.mods.modlauncher.api.INameMappingService;\n+\n+import net.fabricmc.loader.api.FabricLoader;\n+import net.fabricmc.loader.api.MappingResolver;\n+\n+public class PatchworkMappingResolver {\n+\tpublic static final String INTERMEDIARY = \"intermediary\";\n+\tpublic static final String NAMED = \"named\";\n+\n+\tpublic static String remapName(INameMappingService.Domain domain, Class clazz, String name) {\n+\t\tMappingResolver resolver = FabricLoader.getInstance().getMappingResolver();\n+\n+\t\tif (resolver.getCurrentRuntimeNamespace().equals(INTERMEDIARY)) {\n+\t\t\treturn name;\n+\t\t}\n+\n+\t\t// Special-case for classes\n+\t\tif (domain == INameMappingService.Domain.CLASS) {\n+\t\t\treturn resolver.mapClassName(NAMED, name);\n+\t\t}\n+\n+\t\tString className = resolver.mapClassName(INTERMEDIARY, clazz.getName());\n+\n+\t\t// Verify format\n+\t\tif (name.chars().filter(ch -> ch == '_').count() != 1) {\n+\t\t\tthrow new IllegalArgumentException(\"Expected valid intermediary name, got \" + name);\n+\t\t}\n+\n+\t\t// since intermediary is always unique, we can just iterate through all members\n+\t\t// and find the one with the right name to get its descriptor\n+\t\tswitch (domain) {\n+\t\tcase METHOD:\n+\t\t\tString methodDescriptor = null;\n+\n+\t\t\tfor (Method method : clazz.getDeclaredMethods()) {\n+\t\t\t\t// If the field name remapped to intermediary is the one we're looking for, store its descriptor and return\n+\t\t\t\tif (resolver.mapMethodName(INTERMEDIARY, className, method.getName(),\n+\t\t\t\t\t\tgetMethodDescriptor(method, false)).equals(name)) {\n+\t\t\t\t\t// We need to remap the descriptor to intermediary in case it contains named Minecraft classes\n+\t\t\t\t\tmethodDescriptor = getMethodDescriptor(method, true);\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\treturn resolver.mapMethodName(NAMED, className, name, methodDescriptor);\n+\t\tcase FIELD:\n+\t\t\tString fieldDescriptor = null;\n+\n+\t\t\tfor (Field field : clazz.getDeclaredFields()) {\n+\t\t\t\t// If the field name remapped to intermediary is the one we're looking for, store its descriptor and return\n+\t\t\t\tif (resolver.mapFieldName(INTERMEDIARY, className, field.getName(),\n+\t\t\t\t\t\tgetDescriptorForClass(field.getType(), false)).equals(name)) {\n+\t\t\t\t\t// We need to remap the descriptor to intermediary in case it contains named Minecraft classes\n+\t\t\t\t\tfieldDescriptor = getDescriptorForClass(field.getType(), true);\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\treturn resolver.mapFieldName(NAMED, className, name, fieldDescriptor);\n+\t\tdefault:\n+\t\t\tthrow new IllegalArgumentException(\"Someone's been tampering with enums! Got unexpected type \" + domain.name());\n+\t\t}\n+\t}\n+\n+\t// this is a stackoverflow response but with remapping\n+\tprivate static String getDescriptorForClass(final Class<?> c, boolean remapToIntermediary) {\n+\t\tif (c.isPrimitive()) {\n+\t\t\t// This could technically be turned into a map lookup, but that seems like overengineering considering this will never change\n+\t\t\tif (c == byte.class) {\n+\t\t\t\treturn \"B\";\n+\t\t\t} else if (c == char.class) {\n+\t\t\t\treturn \"C\";\n+\t\t\t} else if (c == double.class) {\n+\t\t\t\treturn \"D\";\n+\t\t\t} else if (c == float.class) {\n+\t\t\t\treturn \"F\";\n+\t\t\t} else if (c == int.class) {\n+\t\t\t\treturn \"I\";\n+\t\t\t} else if (c == long.class) {\n+\t\t\t\treturn \"J\";\n+\t\t\t} else if (c == short.class) {\n+\t\t\t\treturn \"S\";\n+\t\t\t} else if (c == boolean.class) {\n+\t\t\t\treturn \"Z\";\n+\t\t\t} else if (c == void.class) {\n+\t\t\t\treturn \"V\";\n+\t\t\t} else {\n+\t\t\t\tthrow new RuntimeException(\"Unrecognized primitive \" + c);\n+\t\t\t}\n+\t\t} else {\n+\t\t\tString className = c.getName();\n+\n+\t\t\tif (remapToIntermediary) {\n+\t\t\t\tclassName = FabricLoader.getInstance().getMappingResolver().mapClassName(INTERMEDIARY, className);\n+\t\t\t}\n+\n+\t\t\tif (c.isArray()) {\n+\t\t\t\treturn className.replace('.', '/');\n+\t\t\t} else {\n+\t\t\t\treturn ('L' + className + ';').replace('.', '/');\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate static String getMethodDescriptor(Method m, boolean remapToIntermediary) {\n+\t\tStringBuilder sb = new StringBuilder();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "580dd0834452a87fefe4a20c5ac5e33a5986e605"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc0MzEwNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tprivate static String getMethodDescriptor(Method m, boolean remapToIntermediary) {\n          \n          \n            \n            \tprivate static String getMethodDescriptor(Method method, boolean remapToIntermediary) {", "url": "https://github.com/PatchworkMC/patchwork-api/pull/32#discussion_r368743104", "createdAt": "2020-01-20T22:18:46Z", "author": {"login": "coderbot16"}, "path": "patchwork-fml/src/main/java/com/patchworkmc/impl/fml/PatchworkMappingResolver.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2019, 2019\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package com.patchworkmc.impl.fml;\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+\n+import cpw.mods.modlauncher.api.INameMappingService;\n+\n+import net.fabricmc.loader.api.FabricLoader;\n+import net.fabricmc.loader.api.MappingResolver;\n+\n+public class PatchworkMappingResolver {\n+\tpublic static final String INTERMEDIARY = \"intermediary\";\n+\tpublic static final String NAMED = \"named\";\n+\n+\tpublic static String remapName(INameMappingService.Domain domain, Class clazz, String name) {\n+\t\tMappingResolver resolver = FabricLoader.getInstance().getMappingResolver();\n+\n+\t\tif (resolver.getCurrentRuntimeNamespace().equals(INTERMEDIARY)) {\n+\t\t\treturn name;\n+\t\t}\n+\n+\t\t// Special-case for classes\n+\t\tif (domain == INameMappingService.Domain.CLASS) {\n+\t\t\treturn resolver.mapClassName(NAMED, name);\n+\t\t}\n+\n+\t\tString className = resolver.mapClassName(INTERMEDIARY, clazz.getName());\n+\n+\t\t// Verify format\n+\t\tif (name.chars().filter(ch -> ch == '_').count() != 1) {\n+\t\t\tthrow new IllegalArgumentException(\"Expected valid intermediary name, got \" + name);\n+\t\t}\n+\n+\t\t// since intermediary is always unique, we can just iterate through all members\n+\t\t// and find the one with the right name to get its descriptor\n+\t\tswitch (domain) {\n+\t\tcase METHOD:\n+\t\t\tString methodDescriptor = null;\n+\n+\t\t\tfor (Method method : clazz.getDeclaredMethods()) {\n+\t\t\t\t// If the field name remapped to intermediary is the one we're looking for, store its descriptor and return\n+\t\t\t\tif (resolver.mapMethodName(INTERMEDIARY, className, method.getName(),\n+\t\t\t\t\t\tgetMethodDescriptor(method, false)).equals(name)) {\n+\t\t\t\t\t// We need to remap the descriptor to intermediary in case it contains named Minecraft classes\n+\t\t\t\t\tmethodDescriptor = getMethodDescriptor(method, true);\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\treturn resolver.mapMethodName(NAMED, className, name, methodDescriptor);\n+\t\tcase FIELD:\n+\t\t\tString fieldDescriptor = null;\n+\n+\t\t\tfor (Field field : clazz.getDeclaredFields()) {\n+\t\t\t\t// If the field name remapped to intermediary is the one we're looking for, store its descriptor and return\n+\t\t\t\tif (resolver.mapFieldName(INTERMEDIARY, className, field.getName(),\n+\t\t\t\t\t\tgetDescriptorForClass(field.getType(), false)).equals(name)) {\n+\t\t\t\t\t// We need to remap the descriptor to intermediary in case it contains named Minecraft classes\n+\t\t\t\t\tfieldDescriptor = getDescriptorForClass(field.getType(), true);\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\treturn resolver.mapFieldName(NAMED, className, name, fieldDescriptor);\n+\t\tdefault:\n+\t\t\tthrow new IllegalArgumentException(\"Someone's been tampering with enums! Got unexpected type \" + domain.name());\n+\t\t}\n+\t}\n+\n+\t// this is a stackoverflow response but with remapping\n+\tprivate static String getDescriptorForClass(final Class<?> c, boolean remapToIntermediary) {\n+\t\tif (c.isPrimitive()) {\n+\t\t\t// This could technically be turned into a map lookup, but that seems like overengineering considering this will never change\n+\t\t\tif (c == byte.class) {\n+\t\t\t\treturn \"B\";\n+\t\t\t} else if (c == char.class) {\n+\t\t\t\treturn \"C\";\n+\t\t\t} else if (c == double.class) {\n+\t\t\t\treturn \"D\";\n+\t\t\t} else if (c == float.class) {\n+\t\t\t\treturn \"F\";\n+\t\t\t} else if (c == int.class) {\n+\t\t\t\treturn \"I\";\n+\t\t\t} else if (c == long.class) {\n+\t\t\t\treturn \"J\";\n+\t\t\t} else if (c == short.class) {\n+\t\t\t\treturn \"S\";\n+\t\t\t} else if (c == boolean.class) {\n+\t\t\t\treturn \"Z\";\n+\t\t\t} else if (c == void.class) {\n+\t\t\t\treturn \"V\";\n+\t\t\t} else {\n+\t\t\t\tthrow new RuntimeException(\"Unrecognized primitive \" + c);\n+\t\t\t}\n+\t\t} else {\n+\t\t\tString className = c.getName();\n+\n+\t\t\tif (remapToIntermediary) {\n+\t\t\t\tclassName = FabricLoader.getInstance().getMappingResolver().mapClassName(INTERMEDIARY, className);\n+\t\t\t}\n+\n+\t\t\tif (c.isArray()) {\n+\t\t\t\treturn className.replace('.', '/');\n+\t\t\t} else {\n+\t\t\t\treturn ('L' + className + ';').replace('.', '/');\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate static String getMethodDescriptor(Method m, boolean remapToIntermediary) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "580dd0834452a87fefe4a20c5ac5e33a5986e605"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODc0MzE2MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tprivate static String getDescriptorForClass(final Class<?> c, boolean remapToIntermediary) {\n          \n          \n            \n            \tprivate static String getDescriptorForClass(final Class<?> clazz, boolean remapToIntermediary) {", "url": "https://github.com/PatchworkMC/patchwork-api/pull/32#discussion_r368743161", "createdAt": "2020-01-20T22:19:06Z", "author": {"login": "coderbot16"}, "path": "patchwork-fml/src/main/java/com/patchworkmc/impl/fml/PatchworkMappingResolver.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2019, 2019\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package com.patchworkmc.impl.fml;\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+\n+import cpw.mods.modlauncher.api.INameMappingService;\n+\n+import net.fabricmc.loader.api.FabricLoader;\n+import net.fabricmc.loader.api.MappingResolver;\n+\n+public class PatchworkMappingResolver {\n+\tpublic static final String INTERMEDIARY = \"intermediary\";\n+\tpublic static final String NAMED = \"named\";\n+\n+\tpublic static String remapName(INameMappingService.Domain domain, Class clazz, String name) {\n+\t\tMappingResolver resolver = FabricLoader.getInstance().getMappingResolver();\n+\n+\t\tif (resolver.getCurrentRuntimeNamespace().equals(INTERMEDIARY)) {\n+\t\t\treturn name;\n+\t\t}\n+\n+\t\t// Special-case for classes\n+\t\tif (domain == INameMappingService.Domain.CLASS) {\n+\t\t\treturn resolver.mapClassName(NAMED, name);\n+\t\t}\n+\n+\t\tString className = resolver.mapClassName(INTERMEDIARY, clazz.getName());\n+\n+\t\t// Verify format\n+\t\tif (name.chars().filter(ch -> ch == '_').count() != 1) {\n+\t\t\tthrow new IllegalArgumentException(\"Expected valid intermediary name, got \" + name);\n+\t\t}\n+\n+\t\t// since intermediary is always unique, we can just iterate through all members\n+\t\t// and find the one with the right name to get its descriptor\n+\t\tswitch (domain) {\n+\t\tcase METHOD:\n+\t\t\tString methodDescriptor = null;\n+\n+\t\t\tfor (Method method : clazz.getDeclaredMethods()) {\n+\t\t\t\t// If the field name remapped to intermediary is the one we're looking for, store its descriptor and return\n+\t\t\t\tif (resolver.mapMethodName(INTERMEDIARY, className, method.getName(),\n+\t\t\t\t\t\tgetMethodDescriptor(method, false)).equals(name)) {\n+\t\t\t\t\t// We need to remap the descriptor to intermediary in case it contains named Minecraft classes\n+\t\t\t\t\tmethodDescriptor = getMethodDescriptor(method, true);\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\treturn resolver.mapMethodName(NAMED, className, name, methodDescriptor);\n+\t\tcase FIELD:\n+\t\t\tString fieldDescriptor = null;\n+\n+\t\t\tfor (Field field : clazz.getDeclaredFields()) {\n+\t\t\t\t// If the field name remapped to intermediary is the one we're looking for, store its descriptor and return\n+\t\t\t\tif (resolver.mapFieldName(INTERMEDIARY, className, field.getName(),\n+\t\t\t\t\t\tgetDescriptorForClass(field.getType(), false)).equals(name)) {\n+\t\t\t\t\t// We need to remap the descriptor to intermediary in case it contains named Minecraft classes\n+\t\t\t\t\tfieldDescriptor = getDescriptorForClass(field.getType(), true);\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\treturn resolver.mapFieldName(NAMED, className, name, fieldDescriptor);\n+\t\tdefault:\n+\t\t\tthrow new IllegalArgumentException(\"Someone's been tampering with enums! Got unexpected type \" + domain.name());\n+\t\t}\n+\t}\n+\n+\t// this is a stackoverflow response but with remapping\n+\tprivate static String getDescriptorForClass(final Class<?> c, boolean remapToIntermediary) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "580dd0834452a87fefe4a20c5ac5e33a5986e605"}, "originalPosition": 90}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3953feadcec609eedc6d3ce499daa3a42e82c432", "author": {"user": {"login": "TheGlitch76", "name": "Glitch"}}, "url": "https://github.com/PatchworkMC/patchwork-api/commit/3953feadcec609eedc6d3ce499daa3a42e82c432", "committedDate": "2020-01-23T17:41:08Z", "message": "Reviews"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4MzU1NTEy", "url": "https://github.com/PatchworkMC/patchwork-api/pull/32#pullrequestreview-348355512", "createdAt": "2020-01-26T02:25:49Z", "commit": {"oid": "3953feadcec609eedc6d3ce499daa3a42e82c432"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNlQwMjoyNTo1MFrOFhyKRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNlQwMjoyNjowMlrOFhyKVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk2OTE1OQ==", "bodyText": "Should probably null-check here", "url": "https://github.com/PatchworkMC/patchwork-api/pull/32#discussion_r370969159", "createdAt": "2020-01-26T02:25:50Z", "author": {"login": "coderbot16"}, "path": "patchwork-fml/src/main/java/com/patchworkmc/impl/fml/PatchworkMappingResolver.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2019, 2019\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package com.patchworkmc.impl.fml;\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+\n+import cpw.mods.modlauncher.api.INameMappingService;\n+\n+import net.fabricmc.loader.api.FabricLoader;\n+import net.fabricmc.loader.api.MappingResolver;\n+\n+public class PatchworkMappingResolver {\n+\tpublic static final String INTERMEDIARY = \"intermediary\";\n+\tpublic static final String NAMED = \"named\";\n+\n+\tpublic static String remapName(INameMappingService.Domain domain, Class clazz, String name) {\n+\t\tMappingResolver resolver = FabricLoader.getInstance().getMappingResolver();\n+\n+\t\tif (resolver.getCurrentRuntimeNamespace().equals(INTERMEDIARY)) {\n+\t\t\treturn name;\n+\t\t}\n+\n+\t\t// Special-case for classes\n+\t\tif (domain == INameMappingService.Domain.CLASS) {\n+\t\t\treturn resolver.mapClassName(NAMED, name);\n+\t\t}\n+\n+\t\tString className = resolver.mapClassName(INTERMEDIARY, clazz.getName());\n+\n+\t\t// Verify format\n+\t\tif (name.chars().filter(ch -> ch == '_').count() != 1) {\n+\t\t\tthrow new IllegalArgumentException(\"Expected valid intermediary name, got \" + name);\n+\t\t}\n+\n+\t\t// since intermediary is always unique, we can just iterate through all members\n+\t\t// and find the one with the right name to get its descriptor\n+\t\tswitch (domain) {\n+\t\tcase METHOD:\n+\t\t\tString methodDescriptor = null;\n+\n+\t\t\tfor (Method method : clazz.getDeclaredMethods()) {\n+\t\t\t\t// If the field name remapped to intermediary is the one we're looking for, store its descriptor and return\n+\t\t\t\tif (resolver.mapMethodName(INTERMEDIARY, className, method.getName(),\n+\t\t\t\t\t\tgetMethodDescriptor(method, false)).equals(name)) {\n+\t\t\t\t\t// We need to remap the descriptor to intermediary in case it contains named Minecraft classes\n+\t\t\t\t\tmethodDescriptor = getMethodDescriptor(method, true);\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3953feadcec609eedc6d3ce499daa3a42e82c432"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk2OTE3NA==", "bodyText": "Null check here too", "url": "https://github.com/PatchworkMC/patchwork-api/pull/32#discussion_r370969174", "createdAt": "2020-01-26T02:26:02Z", "author": {"login": "coderbot16"}, "path": "patchwork-fml/src/main/java/com/patchworkmc/impl/fml/PatchworkMappingResolver.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2019, 2019\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package com.patchworkmc.impl.fml;\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+\n+import cpw.mods.modlauncher.api.INameMappingService;\n+\n+import net.fabricmc.loader.api.FabricLoader;\n+import net.fabricmc.loader.api.MappingResolver;\n+\n+public class PatchworkMappingResolver {\n+\tpublic static final String INTERMEDIARY = \"intermediary\";\n+\tpublic static final String NAMED = \"named\";\n+\n+\tpublic static String remapName(INameMappingService.Domain domain, Class clazz, String name) {\n+\t\tMappingResolver resolver = FabricLoader.getInstance().getMappingResolver();\n+\n+\t\tif (resolver.getCurrentRuntimeNamespace().equals(INTERMEDIARY)) {\n+\t\t\treturn name;\n+\t\t}\n+\n+\t\t// Special-case for classes\n+\t\tif (domain == INameMappingService.Domain.CLASS) {\n+\t\t\treturn resolver.mapClassName(NAMED, name);\n+\t\t}\n+\n+\t\tString className = resolver.mapClassName(INTERMEDIARY, clazz.getName());\n+\n+\t\t// Verify format\n+\t\tif (name.chars().filter(ch -> ch == '_').count() != 1) {\n+\t\t\tthrow new IllegalArgumentException(\"Expected valid intermediary name, got \" + name);\n+\t\t}\n+\n+\t\t// since intermediary is always unique, we can just iterate through all members\n+\t\t// and find the one with the right name to get its descriptor\n+\t\tswitch (domain) {\n+\t\tcase METHOD:\n+\t\t\tString methodDescriptor = null;\n+\n+\t\t\tfor (Method method : clazz.getDeclaredMethods()) {\n+\t\t\t\t// If the field name remapped to intermediary is the one we're looking for, store its descriptor and return\n+\t\t\t\tif (resolver.mapMethodName(INTERMEDIARY, className, method.getName(),\n+\t\t\t\t\t\tgetMethodDescriptor(method, false)).equals(name)) {\n+\t\t\t\t\t// We need to remap the descriptor to intermediary in case it contains named Minecraft classes\n+\t\t\t\t\tmethodDescriptor = getMethodDescriptor(method, true);\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\treturn resolver.mapMethodName(NAMED, className, name, methodDescriptor);\n+\t\tcase FIELD:\n+\t\t\tString fieldDescriptor = null;\n+\n+\t\t\tfor (Field field : clazz.getDeclaredFields()) {\n+\t\t\t\t// If the field name remapped to intermediary is the one we're looking for, store its descriptor and return\n+\t\t\t\tif (resolver.mapFieldName(INTERMEDIARY, className, field.getName(),\n+\t\t\t\t\t\tgetDescriptorForClass(field.getType(), false)).equals(name)) {\n+\t\t\t\t\t// We need to remap the descriptor to intermediary in case it contains named Minecraft classes\n+\t\t\t\t\tfieldDescriptor = getDescriptorForClass(field.getType(), true);\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3953feadcec609eedc6d3ce499daa3a42e82c432"}, "originalPosition": 82}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5cd6746a4b46db28fd9afe9db8a4710ae8dfade6", "author": {"user": {"login": "TheGlitch76", "name": "Glitch"}}, "url": "https://github.com/PatchworkMC/patchwork-api/commit/5cd6746a4b46db28fd9afe9db8a4710ae8dfade6", "committedDate": "2020-01-26T23:23:19Z", "message": "Complete refactor of method used to remap names"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c517d60ad166259a5be5f09dc3a14b8aef684d35", "author": {"user": {"login": "TheGlitch76", "name": "Glitch"}}, "url": "https://github.com/PatchworkMC/patchwork-api/commit/c517d60ad166259a5be5f09dc3a14b8aef684d35", "committedDate": "2020-01-30T01:35:04Z", "message": "Merge branch 'master' of github.com:PatchworkMC/patchwork-api into feature/obf-reflection-helper"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c49d4ae2e4ba7f9bd552d537b85373111e34a02c", "author": {"user": {"login": "TheGlitch76", "name": "Glitch"}}, "url": "https://github.com/PatchworkMC/patchwork-api/commit/c49d4ae2e4ba7f9bd552d537b85373111e34a02c", "committedDate": "2020-01-30T01:35:46Z", "message": "It's 2020"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxMjg3MDQz", "url": "https://github.com/PatchworkMC/patchwork-api/pull/32#pullrequestreview-351287043", "createdAt": "2020-01-31T04:24:38Z", "commit": {"oid": "c49d4ae2e4ba7f9bd552d537b85373111e34a02c"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQwNDoyNDozOFrOFkBGZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0zMVQwNDozMjozMVrOFkBLEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzMxMTA3OA==", "bodyText": "Blank lines before documentation comments\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t/**\n          \n          \n            \n            \n          \n          \n            \n            \t/**", "url": "https://github.com/PatchworkMC/patchwork-api/pull/32#discussion_r373311078", "createdAt": "2020-01-31T04:24:38Z", "author": {"login": "coderbot16"}, "path": "patchwork-fml/src/main/java/net/minecraftforge/fml/common/ObfuscationReflectionHelper.java", "diffHunk": "@@ -0,0 +1,375 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2020, 2019-2020\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package net.minecraftforge.fml.common;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.util.StringJoiner;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.Preconditions;\n+import cpw.mods.modlauncher.api.INameMappingService;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.Marker;\n+import org.apache.logging.log4j.MarkerManager;\n+\n+import net.fabricmc.loader.api.FabricLoader;\n+import net.fabricmc.loader.launch.common.FabricLauncherBase;\n+import net.fabricmc.mapping.tree.ClassDef;\n+import net.fabricmc.mapping.tree.FieldDef;\n+import net.fabricmc.mapping.tree.MethodDef;\n+import net.fabricmc.mapping.tree.TinyTree;\n+\n+/**\n+ * Some reflection helper code.\n+ * This may not work properly in Java 9 with its new, more restrictive, reflection management.\n+ * As such, if issues are encountered, please report them and we can see what we can do to expand\n+ * the compatibility.\n+ *\n+ * <p>In other cases, accesssor mixins may be used.</p>\n+ *\n+ * <p>All field and method names should be passed in as intermediary names, and this will automatically resolve if Yarn mappings are detected.</p>\n+ *\n+ */\n+public class ObfuscationReflectionHelper {\n+\tprivate static final Logger LOGGER = LogManager.getLogger();\n+\tprivate static final Marker REFLECTION = MarkerManager.getMarker(\"REFLECTION\");\n+\tprivate static final TinyTree MAPPINGS = FabricLauncherBase.getLauncher().getMappingConfiguration().getMappings();\n+\tprivate static final String INTERMEDIARY = \"intermediary\";\n+\tprivate static final String NAMED = \"named\";\n+\t/**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c49d4ae2e4ba7f9bd552d537b85373111e34a02c"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzMxMTA5NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             *", "url": "https://github.com/PatchworkMC/patchwork-api/pull/32#discussion_r373311095", "createdAt": "2020-01-31T04:24:44Z", "author": {"login": "coderbot16"}, "path": "patchwork-fml/src/main/java/net/minecraftforge/fml/common/ObfuscationReflectionHelper.java", "diffHunk": "@@ -0,0 +1,375 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2020, 2019-2020\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package net.minecraftforge.fml.common;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.util.StringJoiner;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.Preconditions;\n+import cpw.mods.modlauncher.api.INameMappingService;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.Marker;\n+import org.apache.logging.log4j.MarkerManager;\n+\n+import net.fabricmc.loader.api.FabricLoader;\n+import net.fabricmc.loader.launch.common.FabricLauncherBase;\n+import net.fabricmc.mapping.tree.ClassDef;\n+import net.fabricmc.mapping.tree.FieldDef;\n+import net.fabricmc.mapping.tree.MethodDef;\n+import net.fabricmc.mapping.tree.TinyTree;\n+\n+/**\n+ * Some reflection helper code.\n+ * This may not work properly in Java 9 with its new, more restrictive, reflection management.\n+ * As such, if issues are encountered, please report them and we can see what we can do to expand\n+ * the compatibility.\n+ *\n+ * <p>In other cases, accesssor mixins may be used.</p>\n+ *\n+ * <p>All field and method names should be passed in as intermediary names, and this will automatically resolve if Yarn mappings are detected.</p>\n+ *", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c49d4ae2e4ba7f9bd552d537b85373111e34a02c"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzMxMTM3Ng==", "bodyText": "It could make more sense just to check for intermediary, there's no guarantee that someone won't show up with some yarn-at-runtime mod or something. We're remapping from intermediary anyways.", "url": "https://github.com/PatchworkMC/patchwork-api/pull/32#discussion_r373311376", "createdAt": "2020-01-31T04:26:37Z", "author": {"login": "coderbot16"}, "path": "patchwork-fml/src/main/java/net/minecraftforge/fml/common/ObfuscationReflectionHelper.java", "diffHunk": "@@ -0,0 +1,375 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2020, 2019-2020\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package net.minecraftforge.fml.common;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.util.StringJoiner;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.Preconditions;\n+import cpw.mods.modlauncher.api.INameMappingService;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.Marker;\n+import org.apache.logging.log4j.MarkerManager;\n+\n+import net.fabricmc.loader.api.FabricLoader;\n+import net.fabricmc.loader.launch.common.FabricLauncherBase;\n+import net.fabricmc.mapping.tree.ClassDef;\n+import net.fabricmc.mapping.tree.FieldDef;\n+import net.fabricmc.mapping.tree.MethodDef;\n+import net.fabricmc.mapping.tree.TinyTree;\n+\n+/**\n+ * Some reflection helper code.\n+ * This may not work properly in Java 9 with its new, more restrictive, reflection management.\n+ * As such, if issues are encountered, please report them and we can see what we can do to expand\n+ * the compatibility.\n+ *\n+ * <p>In other cases, accesssor mixins may be used.</p>\n+ *\n+ * <p>All field and method names should be passed in as intermediary names, and this will automatically resolve if Yarn mappings are detected.</p>\n+ *\n+ */\n+public class ObfuscationReflectionHelper {\n+\tprivate static final Logger LOGGER = LogManager.getLogger();\n+\tprivate static final Marker REFLECTION = MarkerManager.getMarker(\"REFLECTION\");\n+\tprivate static final TinyTree MAPPINGS = FabricLauncherBase.getLauncher().getMappingConfiguration().getMappings();\n+\tprivate static final String INTERMEDIARY = \"intermediary\";\n+\tprivate static final String NAMED = \"named\";\n+\t/**\n+\t * Remaps a name from intermediary to whatever is currently being used at runtime.\n+\t *\n+\t * @param domain The {@link INameMappingService.Domain} to use to remap the name.\n+\t * @param name   The name to try and remap.\n+\t * @return The remapped name, or the original name if it couldn't be remapped.\n+\t */\n+\t@Nonnull\n+\tpublic static String remapName(INameMappingService.Domain domain, String name) {\n+\t\tif (!FabricLoader.getInstance().isDevelopmentEnvironment()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c49d4ae2e4ba7f9bd552d537b85373111e34a02c"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzMxMTQ2NQ==", "bodyText": "I feel that we should at least put some note here about the fact that we're reaching around in internal Fabric APIs, maybe a TODO or something.", "url": "https://github.com/PatchworkMC/patchwork-api/pull/32#discussion_r373311465", "createdAt": "2020-01-31T04:27:13Z", "author": {"login": "coderbot16"}, "path": "patchwork-fml/src/main/java/net/minecraftforge/fml/common/ObfuscationReflectionHelper.java", "diffHunk": "@@ -0,0 +1,375 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2020, 2019-2020\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package net.minecraftforge.fml.common;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.util.StringJoiner;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.Preconditions;\n+import cpw.mods.modlauncher.api.INameMappingService;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.Marker;\n+import org.apache.logging.log4j.MarkerManager;\n+\n+import net.fabricmc.loader.api.FabricLoader;\n+import net.fabricmc.loader.launch.common.FabricLauncherBase;\n+import net.fabricmc.mapping.tree.ClassDef;\n+import net.fabricmc.mapping.tree.FieldDef;\n+import net.fabricmc.mapping.tree.MethodDef;\n+import net.fabricmc.mapping.tree.TinyTree;\n+\n+/**\n+ * Some reflection helper code.\n+ * This may not work properly in Java 9 with its new, more restrictive, reflection management.\n+ * As such, if issues are encountered, please report them and we can see what we can do to expand\n+ * the compatibility.\n+ *\n+ * <p>In other cases, accesssor mixins may be used.</p>\n+ *\n+ * <p>All field and method names should be passed in as intermediary names, and this will automatically resolve if Yarn mappings are detected.</p>\n+ *\n+ */\n+public class ObfuscationReflectionHelper {\n+\tprivate static final Logger LOGGER = LogManager.getLogger();\n+\tprivate static final Marker REFLECTION = MarkerManager.getMarker(\"REFLECTION\");\n+\tprivate static final TinyTree MAPPINGS = FabricLauncherBase.getLauncher().getMappingConfiguration().getMappings();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c49d4ae2e4ba7f9bd552d537b85373111e34a02c"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzMxMTkxMw==", "bodyText": "We already know the class here, I don't think we should scan over every single method def in every single class instead of just looking through that class directly.", "url": "https://github.com/PatchworkMC/patchwork-api/pull/32#discussion_r373311913", "createdAt": "2020-01-31T04:30:13Z", "author": {"login": "coderbot16"}, "path": "patchwork-fml/src/main/java/net/minecraftforge/fml/common/ObfuscationReflectionHelper.java", "diffHunk": "@@ -0,0 +1,375 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2020, 2019-2020\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package net.minecraftforge.fml.common;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.util.StringJoiner;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.Preconditions;\n+import cpw.mods.modlauncher.api.INameMappingService;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.Marker;\n+import org.apache.logging.log4j.MarkerManager;\n+\n+import net.fabricmc.loader.api.FabricLoader;\n+import net.fabricmc.loader.launch.common.FabricLauncherBase;\n+import net.fabricmc.mapping.tree.ClassDef;\n+import net.fabricmc.mapping.tree.FieldDef;\n+import net.fabricmc.mapping.tree.MethodDef;\n+import net.fabricmc.mapping.tree.TinyTree;\n+\n+/**\n+ * Some reflection helper code.\n+ * This may not work properly in Java 9 with its new, more restrictive, reflection management.\n+ * As such, if issues are encountered, please report them and we can see what we can do to expand\n+ * the compatibility.\n+ *\n+ * <p>In other cases, accesssor mixins may be used.</p>\n+ *\n+ * <p>All field and method names should be passed in as intermediary names, and this will automatically resolve if Yarn mappings are detected.</p>\n+ *\n+ */\n+public class ObfuscationReflectionHelper {\n+\tprivate static final Logger LOGGER = LogManager.getLogger();\n+\tprivate static final Marker REFLECTION = MarkerManager.getMarker(\"REFLECTION\");\n+\tprivate static final TinyTree MAPPINGS = FabricLauncherBase.getLauncher().getMappingConfiguration().getMappings();\n+\tprivate static final String INTERMEDIARY = \"intermediary\";\n+\tprivate static final String NAMED = \"named\";\n+\t/**\n+\t * Remaps a name from intermediary to whatever is currently being used at runtime.\n+\t *\n+\t * @param domain The {@link INameMappingService.Domain} to use to remap the name.\n+\t * @param name   The name to try and remap.\n+\t * @return The remapped name, or the original name if it couldn't be remapped.\n+\t */\n+\t@Nonnull\n+\tpublic static String remapName(INameMappingService.Domain domain, String name) {\n+\t\tif (!FabricLoader.getInstance().isDevelopmentEnvironment()) {\n+\t\t\treturn name;\n+\t\t}\n+\n+\t\tfor (ClassDef classDef : MAPPINGS.getClasses()) {\n+\t\t\tswitch (domain) {\n+\t\t\tcase CLASS:\n+\t\t\t\tif (classDef.getName(INTERMEDIARY).equals(name)) {\n+\t\t\t\t\treturn classDef.getName(NAMED);\n+\t\t\t\t}\n+\n+\t\t\t\tbreak;\n+\t\t\tcase METHOD:\n+\t\t\t\tfor (MethodDef methodDef : classDef.getMethods()) {\n+\t\t\t\t\tif (methodDef.getName(INTERMEDIARY).equals(name)) {\n+\t\t\t\t\t\treturn methodDef.getName(NAMED);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tbreak;\n+\t\t\tcase FIELD:\n+\t\t\t\tfor (FieldDef fieldDef : classDef.getFields()) {\n+\t\t\t\t\tif (fieldDef.getName(INTERMEDIARY).equals(name)) {\n+\t\t\t\t\t\treturn fieldDef.getName(NAMED);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tthrow new IllegalArgumentException(\"Someones tampered with enums! Got unexpected type \" + domain.name());\n+\t\t\t}\n+\t\t}\n+\n+\t\t// It couldn't be found.\n+\t\treturn name;\n+\t}\n+\n+\t/**\n+\t * Gets the value a field with the specified index in the given class.\n+\t * Note: For performance, use {@link #findField(Class, int)} if you are getting the value more than once.\n+\t *\n+\t * <p>Throws an exception if the field is not found or the value of the field cannot be gotten.</p>\n+\t *\n+\t * @param classToAccess The class to find the field on.\n+\t * @param instance      The instance of the {@code classToAccess}.\n+\t * @param fieldIndex    The index of the field in the {@code classToAccess}.\n+\t * @param <T>           The type of the value.\n+\t * @param <E>           The type of the {@code classToAccess}.\n+\t * @return The value of the field with the specified index in the {@code classToAccess}.\n+\t * @throws UnableToAccessFieldException If there was a problem getting the field or the value.\n+\t * @deprecated Use {@link #getPrivateValue(Class, Object, String)} because field indices change a lot more often than field names do.\n+\t * Forge: TODO Remove in 1.15\n+\t */\n+\t@Deprecated\n+\t@Nullable\n+\tpublic static <T, E> T getPrivateValue(Class<? super E> classToAccess, E instance, int fieldIndex) {\n+\t\ttry {\n+\t\t\t//noinspection unchecked\n+\t\t\treturn (T) findField(classToAccess, fieldIndex).get(instance);\n+\t\t} catch (Exception e) {\n+\t\t\tLOGGER.error(REFLECTION, \"There was a problem getting field index {} from {}\", fieldIndex, classToAccess.getName(), e);\n+\t\t\tthrow new UnableToAccessFieldException(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Gets the value a field with the specified name in the given class.\n+\t * Note: For performance, use {@link #findField(Class, String)} if you are getting the value more than once.\n+\t *\n+\t * <p>Throws an exception if the field is not found or the value of the field cannot be gotten.</p>\n+\t *\n+\t * @param classToAccess The class to find the field on.\n+\t * @param instance      The instance of the {@code classToAccess}.\n+\t * @param fieldName     The intermediary (unmapped) name of the field to find (e.g. \"field_5821\").\n+\t * @param <T>           The type of the value.\n+\t * @param <E>           The type of the {@code classToAccess}.\n+\t * @return The value of the field with the specified name in the {@code classToAccess}.\n+\t * @throws UnableToAccessFieldException If there was a problem getting the field.\n+\t * @throws UnableToAccessFieldException If there was a problem getting the value.\n+\t */\n+\t@Nullable\n+\tpublic static <T, E> T getPrivateValue(Class<? super E> classToAccess, E instance, String fieldName) {\n+\t\ttry {\n+\t\t\t//noinspection unchecked\n+\t\t\treturn (T) findField(classToAccess, fieldName).get(instance);\n+\t\t} catch (UnableToFindFieldException e) {\n+\t\t\tLOGGER.error(REFLECTION, \"Unable to locate field {} ({}) on type {}\", fieldName,\n+\t\t\t\t\tremapName(INameMappingService.Domain.FIELD, fieldName), classToAccess.getName(), e);\n+\t\t\tthrow e;\n+\t\t} catch (IllegalAccessException e) {\n+\t\t\tLOGGER.error(REFLECTION, \"Unable to access field {} ({}) on type {}\", fieldName,\n+\t\t\t\t\tremapName(INameMappingService.Domain.FIELD, fieldName), classToAccess.getName(), e);\n+\t\t\tthrow new UnableToAccessFieldException(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Sets the value a field with the specified index in the given class.\n+\t * Note: For performance, use {@link #findField(Class, int)} if you are setting the value more than once.\n+\t *\n+\t * <p>Throws an exception if the field is not found or the value of the field cannot be set.</p>\n+\t *\n+\t * @param classToAccess The class to find the field on.\n+\t * @param instance      The instance of the {@code classToAccess}.\n+\t * @param value         The new value for the field\n+\t * @param fieldIndex    The index of the field in the {@code classToAccess}.\n+\t * @param <T>           The type of the value.\n+\t * @param <E>           The type of the {@code classToAccess}.\n+\t * @throws UnableToAccessFieldException If there was a problem setting the value of the field.\n+\t * @deprecated Use {@link #setPrivateValue(Class, Object, Object, String)} because field indices change a lot more often than field names do.\n+\t * Forge: TODO Remove in 1.15\n+\t */\n+\t@Deprecated\n+\tpublic static <T, E> void setPrivateValue(@Nonnull final Class<? super T> classToAccess, @Nonnull final T instance, @Nullable final E value, int fieldIndex) {\n+\t\ttry {\n+\t\t\tfindField(classToAccess, fieldIndex).set(instance, value);\n+\t\t} catch (IllegalAccessException e) {\n+\t\t\tLOGGER.error(\"There was a problem setting field index {} on type {}\", fieldIndex, classToAccess.getName(), e);\n+\t\t\tthrow new UnableToAccessFieldException(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Sets the value a field with the specified name in the given class.\n+\t * Note: For performance, use {@link #findField(Class, String)} if you are setting the value more than once.\n+\t *\n+\t * <p>Throws an exception if the field is not found or the value of the field cannot be set.</p>\n+\t *\n+\t * @param classToAccess The class to find the field on.\n+\t * @param instance      The instance of the {@code classToAccess}.\n+\t * @param value         The new value for the field\n+\t * @param fieldName     The name of the field in the {@code classToAccess}.\n+\t * @param <T>           The type of the value.\n+\t * @param <E>           The type of the {@code classToAccess}.\n+\t * @throws UnableToFindFieldException   If there was a problem getting the field.\n+\t * @throws UnableToAccessFieldException If there was a problem setting the value of the field.\n+\t */\n+\tpublic static <T, E> void setPrivateValue(@Nonnull final Class<? super T> classToAccess, @Nonnull final T instance,\n+\t\t\t\t@Nullable final E value, @Nonnull final String fieldName) {\n+\t\ttry {\n+\t\t\tfindField(classToAccess, fieldName).set(instance, value);\n+\t\t} catch (UnableToFindFieldException e) {\n+\t\t\tLOGGER.error(\"Unable to locate any field {} on type {}\", fieldName, classToAccess.getName(), e);\n+\t\t\tthrow e;\n+\t\t} catch (IllegalAccessException e) {\n+\t\t\tLOGGER.error(\"Unable to set any field {} on type {}\", fieldName, classToAccess.getName(), e);\n+\t\t\tthrow new UnableToAccessFieldException(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Finds a method with the specified name and parameters in the given class and makes it accessible.\n+\t * Note: For performance, store the returned value and avoid calling this repeatedly.\n+\t *\n+\t * <p>Throws an exception if the method is not found.</p>\n+\t *\n+\t * @param clazz          The class to find the method on.\n+\t * @param methodName     The intermediary (unmapped) name of the method to find (e.g. \"method_342\").\n+\t * @param parameterTypes The parameter types of the method to find.\n+\t * @return The method with the specified name and parameters in the given class.\n+\t * @throws NullPointerException        If {@code clazz} is null.\n+\t * @throws NullPointerException        If {@code methodName} is null.\n+\t * @throws IllegalArgumentException    If {@code methodName} is empty.\n+\t * @throws NullPointerException        If {@code parameterTypes} is null.\n+\t * @throws UnableToFindMethodException If the method could not be found.\n+\t */\n+\t@Nonnull\n+\tpublic static Method findMethod(@Nonnull final Class<?> clazz, @Nonnull final String methodName, @Nonnull final Class<?>... parameterTypes) {\n+\t\tPreconditions.checkNotNull(clazz, \"Class to find method on cannot be null.\");\n+\t\tPreconditions.checkNotNull(methodName, \"Name of method to find cannot be null.\");\n+\t\tPreconditions.checkArgument(!methodName.isEmpty(), \"Name of method to find cannot be empty.\");\n+\t\tPreconditions.checkNotNull(parameterTypes, \"Parameter types of method to find cannot be null.\");\n+\n+\t\ttry {\n+\t\t\tString name = remapName(INameMappingService.Domain.METHOD, methodName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c49d4ae2e4ba7f9bd552d537b85373111e34a02c"}, "originalPosition": 244}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzMxMTk1Ng==", "bodyText": "Same here, but for fields instead.", "url": "https://github.com/PatchworkMC/patchwork-api/pull/32#discussion_r373311956", "createdAt": "2020-01-31T04:30:29Z", "author": {"login": "coderbot16"}, "path": "patchwork-fml/src/main/java/net/minecraftforge/fml/common/ObfuscationReflectionHelper.java", "diffHunk": "@@ -0,0 +1,375 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2020, 2019-2020\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package net.minecraftforge.fml.common;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.util.StringJoiner;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.Preconditions;\n+import cpw.mods.modlauncher.api.INameMappingService;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.Marker;\n+import org.apache.logging.log4j.MarkerManager;\n+\n+import net.fabricmc.loader.api.FabricLoader;\n+import net.fabricmc.loader.launch.common.FabricLauncherBase;\n+import net.fabricmc.mapping.tree.ClassDef;\n+import net.fabricmc.mapping.tree.FieldDef;\n+import net.fabricmc.mapping.tree.MethodDef;\n+import net.fabricmc.mapping.tree.TinyTree;\n+\n+/**\n+ * Some reflection helper code.\n+ * This may not work properly in Java 9 with its new, more restrictive, reflection management.\n+ * As such, if issues are encountered, please report them and we can see what we can do to expand\n+ * the compatibility.\n+ *\n+ * <p>In other cases, accesssor mixins may be used.</p>\n+ *\n+ * <p>All field and method names should be passed in as intermediary names, and this will automatically resolve if Yarn mappings are detected.</p>\n+ *\n+ */\n+public class ObfuscationReflectionHelper {\n+\tprivate static final Logger LOGGER = LogManager.getLogger();\n+\tprivate static final Marker REFLECTION = MarkerManager.getMarker(\"REFLECTION\");\n+\tprivate static final TinyTree MAPPINGS = FabricLauncherBase.getLauncher().getMappingConfiguration().getMappings();\n+\tprivate static final String INTERMEDIARY = \"intermediary\";\n+\tprivate static final String NAMED = \"named\";\n+\t/**\n+\t * Remaps a name from intermediary to whatever is currently being used at runtime.\n+\t *\n+\t * @param domain The {@link INameMappingService.Domain} to use to remap the name.\n+\t * @param name   The name to try and remap.\n+\t * @return The remapped name, or the original name if it couldn't be remapped.\n+\t */\n+\t@Nonnull\n+\tpublic static String remapName(INameMappingService.Domain domain, String name) {\n+\t\tif (!FabricLoader.getInstance().isDevelopmentEnvironment()) {\n+\t\t\treturn name;\n+\t\t}\n+\n+\t\tfor (ClassDef classDef : MAPPINGS.getClasses()) {\n+\t\t\tswitch (domain) {\n+\t\t\tcase CLASS:\n+\t\t\t\tif (classDef.getName(INTERMEDIARY).equals(name)) {\n+\t\t\t\t\treturn classDef.getName(NAMED);\n+\t\t\t\t}\n+\n+\t\t\t\tbreak;\n+\t\t\tcase METHOD:\n+\t\t\t\tfor (MethodDef methodDef : classDef.getMethods()) {\n+\t\t\t\t\tif (methodDef.getName(INTERMEDIARY).equals(name)) {\n+\t\t\t\t\t\treturn methodDef.getName(NAMED);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tbreak;\n+\t\t\tcase FIELD:\n+\t\t\t\tfor (FieldDef fieldDef : classDef.getFields()) {\n+\t\t\t\t\tif (fieldDef.getName(INTERMEDIARY).equals(name)) {\n+\t\t\t\t\t\treturn fieldDef.getName(NAMED);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tthrow new IllegalArgumentException(\"Someones tampered with enums! Got unexpected type \" + domain.name());\n+\t\t\t}\n+\t\t}\n+\n+\t\t// It couldn't be found.\n+\t\treturn name;\n+\t}\n+\n+\t/**\n+\t * Gets the value a field with the specified index in the given class.\n+\t * Note: For performance, use {@link #findField(Class, int)} if you are getting the value more than once.\n+\t *\n+\t * <p>Throws an exception if the field is not found or the value of the field cannot be gotten.</p>\n+\t *\n+\t * @param classToAccess The class to find the field on.\n+\t * @param instance      The instance of the {@code classToAccess}.\n+\t * @param fieldIndex    The index of the field in the {@code classToAccess}.\n+\t * @param <T>           The type of the value.\n+\t * @param <E>           The type of the {@code classToAccess}.\n+\t * @return The value of the field with the specified index in the {@code classToAccess}.\n+\t * @throws UnableToAccessFieldException If there was a problem getting the field or the value.\n+\t * @deprecated Use {@link #getPrivateValue(Class, Object, String)} because field indices change a lot more often than field names do.\n+\t * Forge: TODO Remove in 1.15\n+\t */\n+\t@Deprecated\n+\t@Nullable\n+\tpublic static <T, E> T getPrivateValue(Class<? super E> classToAccess, E instance, int fieldIndex) {\n+\t\ttry {\n+\t\t\t//noinspection unchecked\n+\t\t\treturn (T) findField(classToAccess, fieldIndex).get(instance);\n+\t\t} catch (Exception e) {\n+\t\t\tLOGGER.error(REFLECTION, \"There was a problem getting field index {} from {}\", fieldIndex, classToAccess.getName(), e);\n+\t\t\tthrow new UnableToAccessFieldException(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Gets the value a field with the specified name in the given class.\n+\t * Note: For performance, use {@link #findField(Class, String)} if you are getting the value more than once.\n+\t *\n+\t * <p>Throws an exception if the field is not found or the value of the field cannot be gotten.</p>\n+\t *\n+\t * @param classToAccess The class to find the field on.\n+\t * @param instance      The instance of the {@code classToAccess}.\n+\t * @param fieldName     The intermediary (unmapped) name of the field to find (e.g. \"field_5821\").\n+\t * @param <T>           The type of the value.\n+\t * @param <E>           The type of the {@code classToAccess}.\n+\t * @return The value of the field with the specified name in the {@code classToAccess}.\n+\t * @throws UnableToAccessFieldException If there was a problem getting the field.\n+\t * @throws UnableToAccessFieldException If there was a problem getting the value.\n+\t */\n+\t@Nullable\n+\tpublic static <T, E> T getPrivateValue(Class<? super E> classToAccess, E instance, String fieldName) {\n+\t\ttry {\n+\t\t\t//noinspection unchecked\n+\t\t\treturn (T) findField(classToAccess, fieldName).get(instance);\n+\t\t} catch (UnableToFindFieldException e) {\n+\t\t\tLOGGER.error(REFLECTION, \"Unable to locate field {} ({}) on type {}\", fieldName,\n+\t\t\t\t\tremapName(INameMappingService.Domain.FIELD, fieldName), classToAccess.getName(), e);\n+\t\t\tthrow e;\n+\t\t} catch (IllegalAccessException e) {\n+\t\t\tLOGGER.error(REFLECTION, \"Unable to access field {} ({}) on type {}\", fieldName,\n+\t\t\t\t\tremapName(INameMappingService.Domain.FIELD, fieldName), classToAccess.getName(), e);\n+\t\t\tthrow new UnableToAccessFieldException(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Sets the value a field with the specified index in the given class.\n+\t * Note: For performance, use {@link #findField(Class, int)} if you are setting the value more than once.\n+\t *\n+\t * <p>Throws an exception if the field is not found or the value of the field cannot be set.</p>\n+\t *\n+\t * @param classToAccess The class to find the field on.\n+\t * @param instance      The instance of the {@code classToAccess}.\n+\t * @param value         The new value for the field\n+\t * @param fieldIndex    The index of the field in the {@code classToAccess}.\n+\t * @param <T>           The type of the value.\n+\t * @param <E>           The type of the {@code classToAccess}.\n+\t * @throws UnableToAccessFieldException If there was a problem setting the value of the field.\n+\t * @deprecated Use {@link #setPrivateValue(Class, Object, Object, String)} because field indices change a lot more often than field names do.\n+\t * Forge: TODO Remove in 1.15\n+\t */\n+\t@Deprecated\n+\tpublic static <T, E> void setPrivateValue(@Nonnull final Class<? super T> classToAccess, @Nonnull final T instance, @Nullable final E value, int fieldIndex) {\n+\t\ttry {\n+\t\t\tfindField(classToAccess, fieldIndex).set(instance, value);\n+\t\t} catch (IllegalAccessException e) {\n+\t\t\tLOGGER.error(\"There was a problem setting field index {} on type {}\", fieldIndex, classToAccess.getName(), e);\n+\t\t\tthrow new UnableToAccessFieldException(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Sets the value a field with the specified name in the given class.\n+\t * Note: For performance, use {@link #findField(Class, String)} if you are setting the value more than once.\n+\t *\n+\t * <p>Throws an exception if the field is not found or the value of the field cannot be set.</p>\n+\t *\n+\t * @param classToAccess The class to find the field on.\n+\t * @param instance      The instance of the {@code classToAccess}.\n+\t * @param value         The new value for the field\n+\t * @param fieldName     The name of the field in the {@code classToAccess}.\n+\t * @param <T>           The type of the value.\n+\t * @param <E>           The type of the {@code classToAccess}.\n+\t * @throws UnableToFindFieldException   If there was a problem getting the field.\n+\t * @throws UnableToAccessFieldException If there was a problem setting the value of the field.\n+\t */\n+\tpublic static <T, E> void setPrivateValue(@Nonnull final Class<? super T> classToAccess, @Nonnull final T instance,\n+\t\t\t\t@Nullable final E value, @Nonnull final String fieldName) {\n+\t\ttry {\n+\t\t\tfindField(classToAccess, fieldName).set(instance, value);\n+\t\t} catch (UnableToFindFieldException e) {\n+\t\t\tLOGGER.error(\"Unable to locate any field {} on type {}\", fieldName, classToAccess.getName(), e);\n+\t\t\tthrow e;\n+\t\t} catch (IllegalAccessException e) {\n+\t\t\tLOGGER.error(\"Unable to set any field {} on type {}\", fieldName, classToAccess.getName(), e);\n+\t\t\tthrow new UnableToAccessFieldException(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Finds a method with the specified name and parameters in the given class and makes it accessible.\n+\t * Note: For performance, store the returned value and avoid calling this repeatedly.\n+\t *\n+\t * <p>Throws an exception if the method is not found.</p>\n+\t *\n+\t * @param clazz          The class to find the method on.\n+\t * @param methodName     The intermediary (unmapped) name of the method to find (e.g. \"method_342\").\n+\t * @param parameterTypes The parameter types of the method to find.\n+\t * @return The method with the specified name and parameters in the given class.\n+\t * @throws NullPointerException        If {@code clazz} is null.\n+\t * @throws NullPointerException        If {@code methodName} is null.\n+\t * @throws IllegalArgumentException    If {@code methodName} is empty.\n+\t * @throws NullPointerException        If {@code parameterTypes} is null.\n+\t * @throws UnableToFindMethodException If the method could not be found.\n+\t */\n+\t@Nonnull\n+\tpublic static Method findMethod(@Nonnull final Class<?> clazz, @Nonnull final String methodName, @Nonnull final Class<?>... parameterTypes) {\n+\t\tPreconditions.checkNotNull(clazz, \"Class to find method on cannot be null.\");\n+\t\tPreconditions.checkNotNull(methodName, \"Name of method to find cannot be null.\");\n+\t\tPreconditions.checkArgument(!methodName.isEmpty(), \"Name of method to find cannot be empty.\");\n+\t\tPreconditions.checkNotNull(parameterTypes, \"Parameter types of method to find cannot be null.\");\n+\n+\t\ttry {\n+\t\t\tString name = remapName(INameMappingService.Domain.METHOD, methodName);\n+\t\t\tMethod method = clazz.getDeclaredMethod(name, parameterTypes);\n+\t\t\tmethod.setAccessible(true);\n+\t\t\treturn method;\n+\t\t} catch (Exception e) {\n+\t\t\tthrow new UnableToFindMethodException(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Finds a constructor with the specified parameter types in the given class and makes it accessible.\n+\t * Note: For performance, store the returned value and avoid calling this repeatedly.\n+\t *\n+\t * <p>Throws an exception if the constructor is not found.</p>\n+\t *\n+\t * @param clazz          The class to find the constructor in.\n+\t * @param parameterTypes The parameter types of the constructor.\n+\t * @param <T>            The type.\n+\t * @return The constructor with the specified parameters in the given class.\n+\t * @throws NullPointerException        If {@code clazz} is null.\n+\t * @throws NullPointerException        If {@code parameterTypes} is null.\n+\t * @throws UnknownConstructorException If the constructor could not be found.\n+\t */\n+\t@Nonnull\n+\tpublic static <T> Constructor<T> findConstructor(@Nonnull final Class<T> clazz, @Nonnull final Class<?>... parameterTypes) {\n+\t\tPreconditions.checkNotNull(clazz, \"Class to find constructor on cannot be null.\");\n+\t\tPreconditions.checkNotNull(parameterTypes, \"Parameter types of constructor to find cannot be null.\");\n+\n+\t\ttry {\n+\t\t\tConstructor<T> constructor = clazz.getDeclaredConstructor(parameterTypes);\n+\t\t\tconstructor.setAccessible(true);\n+\t\t\treturn constructor;\n+\t\t} catch (final NoSuchMethodException e) {\n+\t\t\tfinal StringBuilder desc = new StringBuilder();\n+\t\t\tdesc.append(clazz.getSimpleName());\n+\n+\t\t\tStringJoiner joiner = new StringJoiner(\", \", \"(\", \")\");\n+\n+\t\t\tfor (Class<?> type : parameterTypes) {\n+\t\t\t\tjoiner.add(type.getSimpleName());\n+\t\t\t}\n+\n+\t\t\tdesc.append(joiner);\n+\n+\t\t\tthrow new UnknownConstructorException(\"Could not find constructor '\" + desc + \"' in \" + clazz);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Finds a field with the specified name in the given class and makes it accessible.\n+\t * Note: For performance, store the returned value and avoid calling this repeatedly.\n+\t *\n+\t * <p>Throws an exception if the field was not found.</p>\n+\t *\n+\t * @param clazz     The class to find the field on.\n+\t * @param fieldName The intermediary (unmapped) name of the field to find (e.g. \"field_1817\").\n+\t * @param <T>       The type.\n+\t * @return The constructor with the specified parameters in the given class.\n+\t * @throws NullPointerException       If {@code clazz} is null.\n+\t * @throws NullPointerException       If {@code fieldName} is null.\n+\t * @throws IllegalArgumentException   If {@code fieldName} is empty.\n+\t * @throws UnableToFindFieldException If the field could not be found.\n+\t */\n+\t@Nonnull\n+\tpublic static <T> Field findField(@Nonnull final Class<? super T> clazz, @Nonnull final String fieldName) {\n+\t\tPreconditions.checkNotNull(clazz, \"Class to find field on cannot be null.\");\n+\t\tPreconditions.checkNotNull(fieldName, \"Name of field to find cannot be null.\");\n+\t\tPreconditions.checkArgument(!fieldName.isEmpty(), \"Name of field to find cannot be empty.\");\n+\n+\t\ttry {\n+\t\t\tString name = remapName(INameMappingService.Domain.FIELD, fieldName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c49d4ae2e4ba7f9bd552d537b85373111e34a02c"}, "originalPosition": 314}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzMxMjI3NQ==", "bodyText": "I don't really like looking up the name here again, even if it's just on the error path...", "url": "https://github.com/PatchworkMC/patchwork-api/pull/32#discussion_r373312275", "createdAt": "2020-01-31T04:32:31Z", "author": {"login": "coderbot16"}, "path": "patchwork-fml/src/main/java/net/minecraftforge/fml/common/ObfuscationReflectionHelper.java", "diffHunk": "@@ -0,0 +1,375 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2020, 2019-2020\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package net.minecraftforge.fml.common;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.util.StringJoiner;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.Preconditions;\n+import cpw.mods.modlauncher.api.INameMappingService;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.Marker;\n+import org.apache.logging.log4j.MarkerManager;\n+\n+import net.fabricmc.loader.api.FabricLoader;\n+import net.fabricmc.loader.launch.common.FabricLauncherBase;\n+import net.fabricmc.mapping.tree.ClassDef;\n+import net.fabricmc.mapping.tree.FieldDef;\n+import net.fabricmc.mapping.tree.MethodDef;\n+import net.fabricmc.mapping.tree.TinyTree;\n+\n+/**\n+ * Some reflection helper code.\n+ * This may not work properly in Java 9 with its new, more restrictive, reflection management.\n+ * As such, if issues are encountered, please report them and we can see what we can do to expand\n+ * the compatibility.\n+ *\n+ * <p>In other cases, accesssor mixins may be used.</p>\n+ *\n+ * <p>All field and method names should be passed in as intermediary names, and this will automatically resolve if Yarn mappings are detected.</p>\n+ *\n+ */\n+public class ObfuscationReflectionHelper {\n+\tprivate static final Logger LOGGER = LogManager.getLogger();\n+\tprivate static final Marker REFLECTION = MarkerManager.getMarker(\"REFLECTION\");\n+\tprivate static final TinyTree MAPPINGS = FabricLauncherBase.getLauncher().getMappingConfiguration().getMappings();\n+\tprivate static final String INTERMEDIARY = \"intermediary\";\n+\tprivate static final String NAMED = \"named\";\n+\t/**\n+\t * Remaps a name from intermediary to whatever is currently being used at runtime.\n+\t *\n+\t * @param domain The {@link INameMappingService.Domain} to use to remap the name.\n+\t * @param name   The name to try and remap.\n+\t * @return The remapped name, or the original name if it couldn't be remapped.\n+\t */\n+\t@Nonnull\n+\tpublic static String remapName(INameMappingService.Domain domain, String name) {\n+\t\tif (!FabricLoader.getInstance().isDevelopmentEnvironment()) {\n+\t\t\treturn name;\n+\t\t}\n+\n+\t\tfor (ClassDef classDef : MAPPINGS.getClasses()) {\n+\t\t\tswitch (domain) {\n+\t\t\tcase CLASS:\n+\t\t\t\tif (classDef.getName(INTERMEDIARY).equals(name)) {\n+\t\t\t\t\treturn classDef.getName(NAMED);\n+\t\t\t\t}\n+\n+\t\t\t\tbreak;\n+\t\t\tcase METHOD:\n+\t\t\t\tfor (MethodDef methodDef : classDef.getMethods()) {\n+\t\t\t\t\tif (methodDef.getName(INTERMEDIARY).equals(name)) {\n+\t\t\t\t\t\treturn methodDef.getName(NAMED);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tbreak;\n+\t\t\tcase FIELD:\n+\t\t\t\tfor (FieldDef fieldDef : classDef.getFields()) {\n+\t\t\t\t\tif (fieldDef.getName(INTERMEDIARY).equals(name)) {\n+\t\t\t\t\t\treturn fieldDef.getName(NAMED);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tthrow new IllegalArgumentException(\"Someones tampered with enums! Got unexpected type \" + domain.name());\n+\t\t\t}\n+\t\t}\n+\n+\t\t// It couldn't be found.\n+\t\treturn name;\n+\t}\n+\n+\t/**\n+\t * Gets the value a field with the specified index in the given class.\n+\t * Note: For performance, use {@link #findField(Class, int)} if you are getting the value more than once.\n+\t *\n+\t * <p>Throws an exception if the field is not found or the value of the field cannot be gotten.</p>\n+\t *\n+\t * @param classToAccess The class to find the field on.\n+\t * @param instance      The instance of the {@code classToAccess}.\n+\t * @param fieldIndex    The index of the field in the {@code classToAccess}.\n+\t * @param <T>           The type of the value.\n+\t * @param <E>           The type of the {@code classToAccess}.\n+\t * @return The value of the field with the specified index in the {@code classToAccess}.\n+\t * @throws UnableToAccessFieldException If there was a problem getting the field or the value.\n+\t * @deprecated Use {@link #getPrivateValue(Class, Object, String)} because field indices change a lot more often than field names do.\n+\t * Forge: TODO Remove in 1.15\n+\t */\n+\t@Deprecated\n+\t@Nullable\n+\tpublic static <T, E> T getPrivateValue(Class<? super E> classToAccess, E instance, int fieldIndex) {\n+\t\ttry {\n+\t\t\t//noinspection unchecked\n+\t\t\treturn (T) findField(classToAccess, fieldIndex).get(instance);\n+\t\t} catch (Exception e) {\n+\t\t\tLOGGER.error(REFLECTION, \"There was a problem getting field index {} from {}\", fieldIndex, classToAccess.getName(), e);\n+\t\t\tthrow new UnableToAccessFieldException(e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Gets the value a field with the specified name in the given class.\n+\t * Note: For performance, use {@link #findField(Class, String)} if you are getting the value more than once.\n+\t *\n+\t * <p>Throws an exception if the field is not found or the value of the field cannot be gotten.</p>\n+\t *\n+\t * @param classToAccess The class to find the field on.\n+\t * @param instance      The instance of the {@code classToAccess}.\n+\t * @param fieldName     The intermediary (unmapped) name of the field to find (e.g. \"field_5821\").\n+\t * @param <T>           The type of the value.\n+\t * @param <E>           The type of the {@code classToAccess}.\n+\t * @return The value of the field with the specified name in the {@code classToAccess}.\n+\t * @throws UnableToAccessFieldException If there was a problem getting the field.\n+\t * @throws UnableToAccessFieldException If there was a problem getting the value.\n+\t */\n+\t@Nullable\n+\tpublic static <T, E> T getPrivateValue(Class<? super E> classToAccess, E instance, String fieldName) {\n+\t\ttry {\n+\t\t\t//noinspection unchecked\n+\t\t\treturn (T) findField(classToAccess, fieldName).get(instance);\n+\t\t} catch (UnableToFindFieldException e) {\n+\t\t\tLOGGER.error(REFLECTION, \"Unable to locate field {} ({}) on type {}\", fieldName,\n+\t\t\t\t\tremapName(INameMappingService.Domain.FIELD, fieldName), classToAccess.getName(), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c49d4ae2e4ba7f9bd552d537b85373111e34a02c"}, "originalPosition": 157}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7829737eda62df30d2f392db6c8db0cf08be453b", "author": {"user": {"login": "TheGlitch76", "name": "Glitch"}}, "url": "https://github.com/PatchworkMC/patchwork-api/commit/7829737eda62df30d2f392db6c8db0cf08be453b", "committedDate": "2020-02-01T22:57:41Z", "message": "Reviews"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b6f865272c34528c38ecbde7b6baa16731d0ad29", "author": {"user": {"login": "TheGlitch76", "name": "Glitch"}}, "url": "https://github.com/PatchworkMC/patchwork-api/commit/b6f865272c34528c38ecbde7b6baa16731d0ad29", "committedDate": "2020-02-01T23:32:36Z", "message": "Clean up ternary operators a bit"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUxOTEwOTA5", "url": "https://github.com/PatchworkMC/patchwork-api/pull/32#pullrequestreview-351910909", "createdAt": "2020-02-01T23:59:35Z", "commit": {"oid": "b6f865272c34528c38ecbde7b6baa16731d0ad29"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wMVQyMzo1OTozNlrOFkfhGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wMVQyMzo1OTo1OFrOFkfhIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgwOTQzNQ==", "bodyText": "If this is a class, you can do a map lookup like in the other class outside of the loop", "url": "https://github.com/PatchworkMC/patchwork-api/pull/32#discussion_r373809435", "createdAt": "2020-02-01T23:59:36Z", "author": {"login": "coderbot16"}, "path": "patchwork-fml/src/main/java/net/minecraftforge/fml/common/ObfuscationReflectionHelper.java", "diffHunk": "@@ -0,0 +1,393 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2020, 2019-2020\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package net.minecraftforge.fml.common;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.util.StringJoiner;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.Preconditions;\n+import cpw.mods.modlauncher.api.INameMappingService;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.Marker;\n+import org.apache.logging.log4j.MarkerManager;\n+\n+import net.fabricmc.loader.api.FabricLoader;\n+import net.fabricmc.loader.launch.common.FabricLauncherBase;\n+import net.fabricmc.mapping.tree.ClassDef;\n+import net.fabricmc.mapping.tree.Mapped;\n+import net.fabricmc.mapping.tree.TinyTree;\n+\n+/**\n+ * Some reflection helper code.\n+ * This may not work properly in Java 9 with its new, more restrictive, reflection management.\n+ * As such, if issues are encountered, please report them and we can see what we can do to expand\n+ * the compatibility.\n+ *\n+ * <p>In other cases, accesssor mixins may be used.</p>\n+ *\n+ * <p>All field and method names should be passed in as intermediary names, and this will automatically resolve if Yarn mappings are detected.</p>\n+ */\n+public class ObfuscationReflectionHelper {\n+\tprivate static final Logger LOGGER = LogManager.getLogger();\n+\tprivate static final Marker REFLECTION = MarkerManager.getMarker(\"REFLECTION\");\n+\t// We're technically messing with Loader's internal APIs here, if Loader ever gets a better mapping resolution system this class should be refactored.\n+\tprivate static final TinyTree MAPPINGS = FabricLauncherBase.getLauncher().getMappingConfiguration().getMappings();\n+\tprivate static final String INTERMEDIARY = \"intermediary\";\n+\tprivate static final String NAMED = \"named\";\n+\n+\t/**\n+\t * Remaps a name from intermediary to whatever is currently being used at runtime.\n+\t *\n+\t * @param domain The {@link INameMappingService.Domain} to use to remap the name.\n+\t * @param name   The name to try and remap.\n+\t * @return The remapped name, or the original name if it couldn't be remapped.\n+\t */\n+\t@Nonnull\n+\tpublic static String remapName(INameMappingService.Domain domain, String name) {\n+\t\tif (FabricLoader.getInstance().getMappingResolver().getCurrentRuntimeNamespace().equals(INTERMEDIARY)) {\n+\t\t\treturn name;\n+\t\t}\n+\n+\t\tfor (ClassDef classDef : MAPPINGS.getClasses()) {\n+\t\t\tif (domain == INameMappingService.Domain.CLASS) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6f865272c34528c38ecbde7b6baa16731d0ad29"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzgwOTQ0MA==", "bodyText": "This should come first", "url": "https://github.com/PatchworkMC/patchwork-api/pull/32#discussion_r373809440", "createdAt": "2020-02-01T23:59:58Z", "author": {"login": "coderbot16"}, "path": "patchwork-fml/src/main/java/net/minecraftforge/fml/common/ObfuscationReflectionHelper.java", "diffHunk": "@@ -0,0 +1,393 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2020, 2019-2020\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package net.minecraftforge.fml.common;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.util.StringJoiner;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.Preconditions;\n+import cpw.mods.modlauncher.api.INameMappingService;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.Marker;\n+import org.apache.logging.log4j.MarkerManager;\n+\n+import net.fabricmc.loader.api.FabricLoader;\n+import net.fabricmc.loader.launch.common.FabricLauncherBase;\n+import net.fabricmc.mapping.tree.ClassDef;\n+import net.fabricmc.mapping.tree.Mapped;\n+import net.fabricmc.mapping.tree.TinyTree;\n+\n+/**\n+ * Some reflection helper code.\n+ * This may not work properly in Java 9 with its new, more restrictive, reflection management.\n+ * As such, if issues are encountered, please report them and we can see what we can do to expand\n+ * the compatibility.\n+ *\n+ * <p>In other cases, accesssor mixins may be used.</p>\n+ *\n+ * <p>All field and method names should be passed in as intermediary names, and this will automatically resolve if Yarn mappings are detected.</p>\n+ */\n+public class ObfuscationReflectionHelper {\n+\tprivate static final Logger LOGGER = LogManager.getLogger();\n+\tprivate static final Marker REFLECTION = MarkerManager.getMarker(\"REFLECTION\");\n+\t// We're technically messing with Loader's internal APIs here, if Loader ever gets a better mapping resolution system this class should be refactored.\n+\tprivate static final TinyTree MAPPINGS = FabricLauncherBase.getLauncher().getMappingConfiguration().getMappings();\n+\tprivate static final String INTERMEDIARY = \"intermediary\";\n+\tprivate static final String NAMED = \"named\";\n+\n+\t/**\n+\t * Remaps a name from intermediary to whatever is currently being used at runtime.\n+\t *\n+\t * @param domain The {@link INameMappingService.Domain} to use to remap the name.\n+\t * @param name   The name to try and remap.\n+\t * @return The remapped name, or the original name if it couldn't be remapped.\n+\t */\n+\t@Nonnull\n+\tpublic static String remapName(INameMappingService.Domain domain, String name) {\n+\t\tif (FabricLoader.getInstance().getMappingResolver().getCurrentRuntimeNamespace().equals(INTERMEDIARY)) {\n+\t\t\treturn name;\n+\t\t}\n+\n+\t\tfor (ClassDef classDef : MAPPINGS.getClasses()) {\n+\t\t\tif (domain == INameMappingService.Domain.CLASS) {\n+\t\t\t\tif (classDef.getName(INTERMEDIARY).equals(name)) {\n+\t\t\t\t\treturn classDef.getName(NAMED);\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tboolean domainIsMethod = domain == INameMappingService.Domain.METHOD;\n+\n+\t\t\t\tfor (Mapped mapped : domainIsMethod ? classDef.getMethods() : classDef.getFields()) {\n+\t\t\t\t\tif (mapped.getName(INTERMEDIARY).equals(name)) {\n+\t\t\t\t\t\treturn mapped.getName(NAMED);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\t// It couldn't be found.\n+\t\treturn name;\n+\t}\n+\n+\t/**\n+\t * Like {@link ObfuscationReflectionHelper#remapName(INameMappingService.Domain, String)}, but only iterates through members of the target class.\n+\t * @param domain The {@link INameMappingService.Domain} to look up.\n+\t * @param clazz The class that contains the {@code name} to look up.\n+\t * @param name The name to remap.\n+\t * @return The remapped name, or the original name if it couldn't be remapped.\n+\t */\n+\tpublic static String remapNameFast(INameMappingService.Domain domain, Class<?> clazz, String name) {\n+\t\tif (domain == INameMappingService.Domain.CLASS) {\n+\t\t\tremapName(domain, name);\n+\t\t}\n+\n+\t\tif (FabricLoader.getInstance().getMappingResolver().getCurrentRuntimeNamespace().equals(INTERMEDIARY)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b6f865272c34528c38ecbde7b6baa16731d0ad29"}, "originalPosition": 106}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b2e04067ca2f8c02fa4cef2e86e04f419c58f652", "author": {"user": {"login": "TheGlitch76", "name": "Glitch"}}, "url": "https://github.com/PatchworkMC/patchwork-api/commit/b2e04067ca2f8c02fa4cef2e86e04f419c58f652", "committedDate": "2020-02-02T23:28:05Z", "message": "Reviews pt. 3"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a83665bf47b61c28eb5e1ec87e128b7109284a86", "author": {"user": {"login": "TheGlitch76", "name": "Glitch"}}, "url": "https://github.com/PatchworkMC/patchwork-api/commit/a83665bf47b61c28eb5e1ec87e128b7109284a86", "committedDate": "2020-02-02T23:47:39Z", "message": "Deduplicate code + add some javadoc formatting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e09b0ed6fbca34179617e1cb856070560abe49fb", "author": {"user": {"login": "TheGlitch76", "name": "Glitch"}}, "url": "https://github.com/PatchworkMC/patchwork-api/commit/e09b0ed6fbca34179617e1cb856070560abe49fb", "committedDate": "2020-02-03T01:00:32Z", "message": "Move helper methods to PatchworkMappingService"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b8f049b4e479ca0a6c13d6c167f10f03ce380c21", "author": {"user": {"login": "TheGlitch76", "name": "Glitch"}}, "url": "https://github.com/PatchworkMC/patchwork-api/commit/b8f049b4e479ca0a6c13d6c167f10f03ce380c21", "committedDate": "2020-02-03T02:58:16Z", "message": "Move static final fields to PatchworkMappingService"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUyMDA1Nzkz", "url": "https://github.com/PatchworkMC/patchwork-api/pull/32#pullrequestreview-352005793", "createdAt": "2020-02-03T03:28:24Z", "commit": {"oid": "b8f049b4e479ca0a6c13d6c167f10f03ce380c21"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QwMzoyODoyNFrOFklpLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QwMzo0Mjo1M1rOFklwmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkwOTgwNQ==", "bodyText": "These should be private", "url": "https://github.com/PatchworkMC/patchwork-api/pull/32#discussion_r373909805", "createdAt": "2020-02-03T03:28:24Z", "author": {"login": "coderbot16"}, "path": "patchwork-fml/src/main/java/com/patchworkmc/impl/fml/PatchworkMappingService.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2020, 2019-2020\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package com.patchworkmc.impl.fml;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import cpw.mods.modlauncher.api.INameMappingService;\n+\n+import net.fabricmc.loader.api.FabricLoader;\n+import net.fabricmc.loader.launch.common.FabricLauncherBase;\n+import net.fabricmc.mapping.tree.ClassDef;\n+import net.fabricmc.mapping.tree.Mapped;\n+import net.fabricmc.mapping.tree.TinyTree;\n+\n+public class PatchworkMappingService {\n+\tpublic static final TinyTree MAPPINGS = FabricLauncherBase.getLauncher().getMappingConfiguration().getMappings();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8f049b4e479ca0a6c13d6c167f10f03ce380c21"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkwOTk3NQ==", "bodyText": "This should be private", "url": "https://github.com/PatchworkMC/patchwork-api/pull/32#discussion_r373909975", "createdAt": "2020-02-03T03:29:56Z", "author": {"login": "coderbot16"}, "path": "patchwork-fml/src/main/java/com/patchworkmc/impl/fml/PatchworkMappingService.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2020, 2019-2020\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package com.patchworkmc.impl.fml;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import cpw.mods.modlauncher.api.INameMappingService;\n+\n+import net.fabricmc.loader.api.FabricLoader;\n+import net.fabricmc.loader.launch.common.FabricLauncherBase;\n+import net.fabricmc.mapping.tree.ClassDef;\n+import net.fabricmc.mapping.tree.Mapped;\n+import net.fabricmc.mapping.tree.TinyTree;\n+\n+public class PatchworkMappingService {\n+\tpublic static final TinyTree MAPPINGS = FabricLauncherBase.getLauncher().getMappingConfiguration().getMappings();\n+\tpublic static final String INTERMEDIARY = \"intermediary\";\n+\tpublic static final String NAMED = \"named\";\n+\n+\tprivate PatchworkMappingService() {\n+\t\t// NO-OP\n+\t}\n+\n+\t/**\n+\t * Remaps a name from intermediary to whatever is currently being used at runtime.\n+\t *\n+\t * @param domain    The {@link INameMappingService.Domain} to look up.\n+\t * @param name      The name to try and remap.\n+\t * @return The remapped name, or the original name if it couldn't be remapped.\n+\t */\n+\t@Nonnull\n+\tpublic static String remapName(INameMappingService.Domain domain, String name) {\n+\t\tif (FabricLoader.getInstance().getMappingResolver().getCurrentRuntimeNamespace().equals(INTERMEDIARY)) {\n+\t\t\treturn name;\n+\t\t}\n+\n+\t\tif (domain == INameMappingService.Domain.CLASS) {\n+\t\t\treturn MAPPINGS.getDefaultNamespaceClassMap().get(name).getName(NAMED);\n+\t\t}\n+\n+\t\tString remappedName;\n+\n+\t\tfor (ClassDef classDef : MAPPINGS.getClasses()) {\n+\t\t\tremappedName = PatchworkMappingService.remapNameInternal(domain, classDef, name);\n+\n+\t\t\tif (remappedName != null) {\n+\t\t\t\treturn remappedName;\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn name;\n+\t}\n+\n+\t/**\n+\t * Like {@link PatchworkMappingService#remapName(INameMappingService.Domain, String)}, but only iterates through members of the target class.\n+\t * @param domain    The {@link INameMappingService.Domain} to look up.\n+\t * @param clazz     The class that contains the {@code name} to look up.\n+\t * @param name      The name to remap.\n+\t * @return The remapped name, or the original name if it couldn't be remapped.\n+\t */\n+\t@Nonnull\n+\tpublic static String remapNameFast(INameMappingService.Domain domain, Class<?> clazz, String name) {\n+\t\tClassDef classDef = MAPPINGS.getDefaultNamespaceClassMap().get(clazz.getName());\n+\t\tString remappedName = remapNameInternal(domain, classDef, name);\n+\n+\t\treturn remappedName != null ? remappedName : name;\n+\t}\n+\n+\t/**\n+\t * Like {@link PatchworkMappingService#remapNameFast(INameMappingService.Domain, Class, String)}, but takes a {@link ClassDef} instead of a {@link Class}.\n+\t * @param domain    The {@link INameMappingService.Domain} to look up.\n+\t * @param classDef  The classDef that contains the {@code name} to look up.\n+\t * @param name      The name to remap.\n+\t * @return The remapped name, or null if it couldn't be remapped.\n+\t */\n+\t@Nullable\n+\tpublic static String remapNameInternal(INameMappingService.Domain domain, ClassDef classDef, String name) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8f049b4e479ca0a6c13d6c167f10f03ce380c21"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkxMDAxOA==", "bodyText": "This should get moved to PatchworkMappingService", "url": "https://github.com/PatchworkMC/patchwork-api/pull/32#discussion_r373910018", "createdAt": "2020-02-03T03:30:17Z", "author": {"login": "coderbot16"}, "path": "patchwork-fml/src/main/java/net/minecraftforge/fml/common/ObfuscationReflectionHelper.java", "diffHunk": "@@ -0,0 +1,338 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2020, 2019-2020\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package net.minecraftforge.fml.common;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.util.StringJoiner;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import com.google.common.base.Preconditions;\n+import cpw.mods.modlauncher.api.INameMappingService;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.Marker;\n+import org.apache.logging.log4j.MarkerManager;\n+\n+import com.patchworkmc.impl.fml.PatchworkMappingService;\n+\n+/**\n+ * Some reflection helper code.\n+ * This may not work properly in Java 9 with its new, more restrictive, reflection management.\n+ * As such, if issues are encountered, please report them and we can see what we can do to expand\n+ * the compatibility.\n+ *\n+ * <p>In other cases, accesssor mixins may be used.</p>\n+ *\n+ * <p>All field and method names should be passed in as intermediary names, and this will automatically resolve if Yarn mappings are detected.</p>\n+ */\n+public class ObfuscationReflectionHelper {\n+\tprivate static final Logger LOGGER = LogManager.getLogger();\n+\tprivate static final Marker REFLECTION = MarkerManager.getMarker(\"REFLECTION\");\n+\t// We're technically messing with Loader's internal APIs here, if Loader ever gets a better mapping resolution system this class should be refactored.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8f049b4e479ca0a6c13d6c167f10f03ce380c21"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzkxMTcwNw==", "bodyText": "This should have the intermediary check too (avoid executing any remap code in prod), and also I think we should deduplicate it into a private helper function (isIntermediary or something similar?)", "url": "https://github.com/PatchworkMC/patchwork-api/pull/32#discussion_r373911707", "createdAt": "2020-02-03T03:42:53Z", "author": {"login": "coderbot16"}, "path": "patchwork-fml/src/main/java/com/patchworkmc/impl/fml/PatchworkMappingService.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Minecraft Forge, Patchwork Project\n+ * Copyright (c) 2016-2020, 2019-2020\n+ *\n+ * This library is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation version 2.1\n+ * of the License.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public\n+ * License along with this library; if not, write to the Free Software\n+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n+ */\n+\n+package com.patchworkmc.impl.fml;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+import cpw.mods.modlauncher.api.INameMappingService;\n+\n+import net.fabricmc.loader.api.FabricLoader;\n+import net.fabricmc.loader.launch.common.FabricLauncherBase;\n+import net.fabricmc.mapping.tree.ClassDef;\n+import net.fabricmc.mapping.tree.Mapped;\n+import net.fabricmc.mapping.tree.TinyTree;\n+\n+public class PatchworkMappingService {\n+\tpublic static final TinyTree MAPPINGS = FabricLauncherBase.getLauncher().getMappingConfiguration().getMappings();\n+\tpublic static final String INTERMEDIARY = \"intermediary\";\n+\tpublic static final String NAMED = \"named\";\n+\n+\tprivate PatchworkMappingService() {\n+\t\t// NO-OP\n+\t}\n+\n+\t/**\n+\t * Remaps a name from intermediary to whatever is currently being used at runtime.\n+\t *\n+\t * @param domain    The {@link INameMappingService.Domain} to look up.\n+\t * @param name      The name to try and remap.\n+\t * @return The remapped name, or the original name if it couldn't be remapped.\n+\t */\n+\t@Nonnull\n+\tpublic static String remapName(INameMappingService.Domain domain, String name) {\n+\t\tif (FabricLoader.getInstance().getMappingResolver().getCurrentRuntimeNamespace().equals(INTERMEDIARY)) {\n+\t\t\treturn name;\n+\t\t}\n+\n+\t\tif (domain == INameMappingService.Domain.CLASS) {\n+\t\t\treturn MAPPINGS.getDefaultNamespaceClassMap().get(name).getName(NAMED);\n+\t\t}\n+\n+\t\tString remappedName;\n+\n+\t\tfor (ClassDef classDef : MAPPINGS.getClasses()) {\n+\t\t\tremappedName = PatchworkMappingService.remapNameInternal(domain, classDef, name);\n+\n+\t\t\tif (remappedName != null) {\n+\t\t\t\treturn remappedName;\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn name;\n+\t}\n+\n+\t/**\n+\t * Like {@link PatchworkMappingService#remapName(INameMappingService.Domain, String)}, but only iterates through members of the target class.\n+\t * @param domain    The {@link INameMappingService.Domain} to look up.\n+\t * @param clazz     The class that contains the {@code name} to look up.\n+\t * @param name      The name to remap.\n+\t * @return The remapped name, or the original name if it couldn't be remapped.\n+\t */\n+\t@Nonnull\n+\tpublic static String remapNameFast(INameMappingService.Domain domain, Class<?> clazz, String name) {\n+\t\tClassDef classDef = MAPPINGS.getDefaultNamespaceClassMap().get(clazz.getName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8f049b4e479ca0a6c13d6c167f10f03ce380c21"}, "originalPosition": 81}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "35a460a383c9d9ddf1f37dce7159de11f422538e", "author": {"user": {"login": "TheGlitch76", "name": "Glitch"}}, "url": "https://github.com/PatchworkMC/patchwork-api/commit/35a460a383c9d9ddf1f37dce7159de11f422538e", "committedDate": "2020-02-03T18:34:03Z", "message": "Final (hopefully) reviews"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4NzAzMTg0", "url": "https://github.com/PatchworkMC/patchwork-api/pull/32#pullrequestreview-358703184", "createdAt": "2020-02-14T04:11:46Z", "commit": {"oid": "35a460a383c9d9ddf1f37dce7159de11f422538e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1021, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}