{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQ2NTY3Mzkw", "number": 3426, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wM1QwMzozNzo0OVrOFV_Q-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wM1QwNDo1MzowNlrOFWAJmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU4NjAwOTU1OnYy", "diffSide": "LEFT", "path": "ethereum/datastructures/src/main/java/tech/pegasys/teku/datastructures/blocks/BeaconBlock.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wM1QwMzozNzo0OVrOIevrVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wM1QwOTo0MDo1MVrOIe5P-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTEwOTMzMg==", "bodyText": "Am I right in thinking that we now get the toString automatically from one of the super types?", "url": "https://github.com/ConsenSys/teku/pull/3426#discussion_r569109332", "createdAt": "2021-02-03T03:37:49Z", "author": {"login": "ajsutton"}, "path": "ethereum/datastructures/src/main/java/tech/pegasys/teku/datastructures/blocks/BeaconBlock.java", "diffHunk": "@@ -177,34 +158,11 @@ public Bytes32 getRoot() {\n \n   @Override\n   public Bytes32 hash_tree_root() {\n-    return hashTreeRoot.get();\n+    return hashTreeRoot();\n   }\n \n   @Override\n   public Optional<BeaconBlock> getBeaconBlock() {\n     return Optional.of(this);\n   }\n-\n-  public Bytes32 calculateRoot() {\n-    return HashTreeUtil.merkleize(\n-        Arrays.asList(\n-            HashTreeUtil.hash_tree_root(SSZTypes.BASIC, SSZ.encodeUInt64(slot.longValue())),\n-            HashTreeUtil.hash_tree_root(\n-                SSZTypes.BASIC, SSZ.encodeUInt64(proposer_index.longValue())),\n-            HashTreeUtil.hash_tree_root(SSZTypes.VECTOR_OF_BASIC, parent_root),\n-            HashTreeUtil.hash_tree_root(SSZTypes.VECTOR_OF_BASIC, state_root),\n-            body.hash_tree_root()));\n-  }\n-\n-  @Override\n-  public String toString() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5df17b31e3ead5b3c7ef21b1f977ae00536f12be"}, "originalPosition": 274}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTI2NjE2OA==", "bodyText": "Yep, here: https://github.com/Nashatyrev/artemis/blob/cfff007c0c3bb986c734e6c166860b840ba34c45/ssz/src/main/java/tech/pegasys/teku/ssz/backing/view/ContainerViewReadImpl.java#L78-L86", "url": "https://github.com/ConsenSys/teku/pull/3426#discussion_r569266168", "createdAt": "2021-02-03T09:40:51Z", "author": {"login": "Nashatyrev"}, "path": "ethereum/datastructures/src/main/java/tech/pegasys/teku/datastructures/blocks/BeaconBlock.java", "diffHunk": "@@ -177,34 +158,11 @@ public Bytes32 getRoot() {\n \n   @Override\n   public Bytes32 hash_tree_root() {\n-    return hashTreeRoot.get();\n+    return hashTreeRoot();\n   }\n \n   @Override\n   public Optional<BeaconBlock> getBeaconBlock() {\n     return Optional.of(this);\n   }\n-\n-  public Bytes32 calculateRoot() {\n-    return HashTreeUtil.merkleize(\n-        Arrays.asList(\n-            HashTreeUtil.hash_tree_root(SSZTypes.BASIC, SSZ.encodeUInt64(slot.longValue())),\n-            HashTreeUtil.hash_tree_root(\n-                SSZTypes.BASIC, SSZ.encodeUInt64(proposer_index.longValue())),\n-            HashTreeUtil.hash_tree_root(SSZTypes.VECTOR_OF_BASIC, parent_root),\n-            HashTreeUtil.hash_tree_root(SSZTypes.VECTOR_OF_BASIC, state_root),\n-            body.hash_tree_root()));\n-  }\n-\n-  @Override\n-  public String toString() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTEwOTMzMg=="}, "originalCommit": {"oid": "5df17b31e3ead5b3c7ef21b1f977ae00536f12be"}, "originalPosition": 274}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU4NjAzMzI1OnYy", "diffSide": "RIGHT", "path": "ethereum/datastructures/src/main/java/tech/pegasys/teku/datastructures/blocks/SignedBeaconBlock.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wM1QwMzo0OToyOVrOIev4kA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wM1QyMzoxNzozNVrOIfbC_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTExMjcyMA==", "bodyText": "Would be good to add a comment explaining what should be used instead now that this is deprecated. I am a little confused why people would need to specify a SszType and not just use this constructor (happened in another class as well).", "url": "https://github.com/ConsenSys/teku/pull/3426#discussion_r569112720", "createdAt": "2021-02-03T03:49:29Z", "author": {"login": "ajsutton"}, "path": "ethereum/datastructures/src/main/java/tech/pegasys/teku/datastructures/blocks/SignedBeaconBlock.java", "diffHunk": "@@ -13,88 +13,102 @@\n \n package tech.pegasys.teku.datastructures.blocks;\n \n-import com.google.common.base.MoreObjects;\n-import com.google.common.base.Suppliers;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Objects;\n import java.util.Optional;\n-import java.util.function.Supplier;\n-import jdk.jfr.Label;\n-import org.apache.tuweni.bytes.Bytes;\n import org.apache.tuweni.bytes.Bytes32;\n import tech.pegasys.teku.bls.BLSSignature;\n-import tech.pegasys.teku.datastructures.util.HashTreeUtil;\n-import tech.pegasys.teku.datastructures.util.HashTreeUtil.SSZTypes;\n import tech.pegasys.teku.datastructures.util.Merkleizable;\n-import tech.pegasys.teku.datastructures.util.SimpleOffsetSerializer;\n+import tech.pegasys.teku.datastructures.util.SpecDependent;\n import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n import tech.pegasys.teku.ssz.SSZTypes.SSZContainer;\n+import tech.pegasys.teku.ssz.backing.VectorViewRead;\n+import tech.pegasys.teku.ssz.backing.containers.Container2;\n+import tech.pegasys.teku.ssz.backing.containers.ContainerType2;\n+import tech.pegasys.teku.ssz.backing.tree.TreeNode;\n+import tech.pegasys.teku.ssz.backing.type.ComplexViewTypes;\n+import tech.pegasys.teku.ssz.backing.view.BasicViews.ByteView;\n+import tech.pegasys.teku.ssz.backing.view.ViewUtils;\n import tech.pegasys.teku.ssz.sos.SimpleOffsetSerializable;\n+import tech.pegasys.teku.ssz.sos.SszTypeDescriptor;\n \n public class SignedBeaconBlock\n+    extends Container2<SignedBeaconBlock, BeaconBlock, VectorViewRead<ByteView>>\n     implements BeaconBlockSummary, Merkleizable, SimpleOffsetSerializable, SSZContainer {\n \n-  private final BeaconBlock message;\n-  private final BLSSignature signature;\n+  public static class SignedBeaconBlockType\n+      extends ContainerType2<SignedBeaconBlock, BeaconBlock, VectorViewRead<ByteView>> {\n \n-  @Label(\"sos-ignore\")\n-  private final Supplier<Bytes32> hashTreeRoot = Suppliers.memoize(this::calculateRoot);\n+    public SignedBeaconBlockType() {\n+      super(\n+          \"SignedBeaconBlock\",\n+          namedType(\"message\", BeaconBlock.TYPE.get()),\n+          namedType(\"signature\", ComplexViewTypes.BYTES_96_TYPE));\n+    }\n \n-  public SignedBeaconBlock(final BeaconBlock message, final BLSSignature signature) {\n-    this.message = message;\n-    this.signature = signature;\n+    @Override\n+    public SignedBeaconBlock createFromBackingNode(TreeNode node) {\n+      return new SignedBeaconBlock(this, node);\n+    }\n   }\n \n-  public BeaconBlock getMessage() {\n-    return message;\n+  @SszTypeDescriptor\n+  public static SignedBeaconBlockType getSszType() {\n+    return TYPE.get();\n   }\n \n-  public BLSSignature getSignature() {\n-    return signature;\n+  public static final SpecDependent<SignedBeaconBlockType> TYPE =\n+      SpecDependent.of(SignedBeaconBlockType::new);\n+\n+  private BLSSignature signatureCache;\n+\n+  private SignedBeaconBlock(SignedBeaconBlockType type, TreeNode backingNode) {\n+    super(type, backingNode);\n   }\n \n-  @Override\n-  public int getSSZFieldCount() {\n-    return message.getSSZFieldCount() + signature.getSSZFieldCount();\n+  @Deprecated", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5df17b31e3ead5b3c7ef21b1f977ae00536f12be"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTQ3ODg0OQ==", "bodyText": "Yes, good question!\nFrom on side: SignedBeaconBlockType depends on BeaconBlockType which depends on BeaconBlockBodyType which in turn depends on Spec. SignedBeaconBlock instance should be bounded to its type on construction and we should basically derive SignedBeaconBlockType from the Spec and pass it to SignedBeaconBlock constructor. Else we are ending up using a static SignedBeaconBlockType instance which we are trying to eliminate.\nFrom the other side: we have a BeaconBlock and may get it's type and create SignedBeaconBlockType dynamically. However ViewType classes were originally designed to be more or less long living since they could be expensive in construction and memory heavy. So per-instance type construction could yield perf/memory issues.\nI didn't found any fast an elegant solution for this. One idea was to add a reference from ViewType to Spec (as soon as a type could be Spec-dependent). In that case we could derive the type. But I would suggest to address this in further Spec work", "url": "https://github.com/ConsenSys/teku/pull/3426#discussion_r569478849", "createdAt": "2021-02-03T14:53:33Z", "author": {"login": "Nashatyrev"}, "path": "ethereum/datastructures/src/main/java/tech/pegasys/teku/datastructures/blocks/SignedBeaconBlock.java", "diffHunk": "@@ -13,88 +13,102 @@\n \n package tech.pegasys.teku.datastructures.blocks;\n \n-import com.google.common.base.MoreObjects;\n-import com.google.common.base.Suppliers;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Objects;\n import java.util.Optional;\n-import java.util.function.Supplier;\n-import jdk.jfr.Label;\n-import org.apache.tuweni.bytes.Bytes;\n import org.apache.tuweni.bytes.Bytes32;\n import tech.pegasys.teku.bls.BLSSignature;\n-import tech.pegasys.teku.datastructures.util.HashTreeUtil;\n-import tech.pegasys.teku.datastructures.util.HashTreeUtil.SSZTypes;\n import tech.pegasys.teku.datastructures.util.Merkleizable;\n-import tech.pegasys.teku.datastructures.util.SimpleOffsetSerializer;\n+import tech.pegasys.teku.datastructures.util.SpecDependent;\n import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n import tech.pegasys.teku.ssz.SSZTypes.SSZContainer;\n+import tech.pegasys.teku.ssz.backing.VectorViewRead;\n+import tech.pegasys.teku.ssz.backing.containers.Container2;\n+import tech.pegasys.teku.ssz.backing.containers.ContainerType2;\n+import tech.pegasys.teku.ssz.backing.tree.TreeNode;\n+import tech.pegasys.teku.ssz.backing.type.ComplexViewTypes;\n+import tech.pegasys.teku.ssz.backing.view.BasicViews.ByteView;\n+import tech.pegasys.teku.ssz.backing.view.ViewUtils;\n import tech.pegasys.teku.ssz.sos.SimpleOffsetSerializable;\n+import tech.pegasys.teku.ssz.sos.SszTypeDescriptor;\n \n public class SignedBeaconBlock\n+    extends Container2<SignedBeaconBlock, BeaconBlock, VectorViewRead<ByteView>>\n     implements BeaconBlockSummary, Merkleizable, SimpleOffsetSerializable, SSZContainer {\n \n-  private final BeaconBlock message;\n-  private final BLSSignature signature;\n+  public static class SignedBeaconBlockType\n+      extends ContainerType2<SignedBeaconBlock, BeaconBlock, VectorViewRead<ByteView>> {\n \n-  @Label(\"sos-ignore\")\n-  private final Supplier<Bytes32> hashTreeRoot = Suppliers.memoize(this::calculateRoot);\n+    public SignedBeaconBlockType() {\n+      super(\n+          \"SignedBeaconBlock\",\n+          namedType(\"message\", BeaconBlock.TYPE.get()),\n+          namedType(\"signature\", ComplexViewTypes.BYTES_96_TYPE));\n+    }\n \n-  public SignedBeaconBlock(final BeaconBlock message, final BLSSignature signature) {\n-    this.message = message;\n-    this.signature = signature;\n+    @Override\n+    public SignedBeaconBlock createFromBackingNode(TreeNode node) {\n+      return new SignedBeaconBlock(this, node);\n+    }\n   }\n \n-  public BeaconBlock getMessage() {\n-    return message;\n+  @SszTypeDescriptor\n+  public static SignedBeaconBlockType getSszType() {\n+    return TYPE.get();\n   }\n \n-  public BLSSignature getSignature() {\n-    return signature;\n+  public static final SpecDependent<SignedBeaconBlockType> TYPE =\n+      SpecDependent.of(SignedBeaconBlockType::new);\n+\n+  private BLSSignature signatureCache;\n+\n+  private SignedBeaconBlock(SignedBeaconBlockType type, TreeNode backingNode) {\n+    super(type, backingNode);\n   }\n \n-  @Override\n-  public int getSSZFieldCount() {\n-    return message.getSSZFieldCount() + signature.getSSZFieldCount();\n+  @Deprecated", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTExMjcyMA=="}, "originalCommit": {"oid": "5df17b31e3ead5b3c7ef21b1f977ae00536f12be"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTgxOTkwMg==", "bodyText": "Ok makes sense.", "url": "https://github.com/ConsenSys/teku/pull/3426#discussion_r569819902", "createdAt": "2021-02-03T23:17:35Z", "author": {"login": "ajsutton"}, "path": "ethereum/datastructures/src/main/java/tech/pegasys/teku/datastructures/blocks/SignedBeaconBlock.java", "diffHunk": "@@ -13,88 +13,102 @@\n \n package tech.pegasys.teku.datastructures.blocks;\n \n-import com.google.common.base.MoreObjects;\n-import com.google.common.base.Suppliers;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Objects;\n import java.util.Optional;\n-import java.util.function.Supplier;\n-import jdk.jfr.Label;\n-import org.apache.tuweni.bytes.Bytes;\n import org.apache.tuweni.bytes.Bytes32;\n import tech.pegasys.teku.bls.BLSSignature;\n-import tech.pegasys.teku.datastructures.util.HashTreeUtil;\n-import tech.pegasys.teku.datastructures.util.HashTreeUtil.SSZTypes;\n import tech.pegasys.teku.datastructures.util.Merkleizable;\n-import tech.pegasys.teku.datastructures.util.SimpleOffsetSerializer;\n+import tech.pegasys.teku.datastructures.util.SpecDependent;\n import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n import tech.pegasys.teku.ssz.SSZTypes.SSZContainer;\n+import tech.pegasys.teku.ssz.backing.VectorViewRead;\n+import tech.pegasys.teku.ssz.backing.containers.Container2;\n+import tech.pegasys.teku.ssz.backing.containers.ContainerType2;\n+import tech.pegasys.teku.ssz.backing.tree.TreeNode;\n+import tech.pegasys.teku.ssz.backing.type.ComplexViewTypes;\n+import tech.pegasys.teku.ssz.backing.view.BasicViews.ByteView;\n+import tech.pegasys.teku.ssz.backing.view.ViewUtils;\n import tech.pegasys.teku.ssz.sos.SimpleOffsetSerializable;\n+import tech.pegasys.teku.ssz.sos.SszTypeDescriptor;\n \n public class SignedBeaconBlock\n+    extends Container2<SignedBeaconBlock, BeaconBlock, VectorViewRead<ByteView>>\n     implements BeaconBlockSummary, Merkleizable, SimpleOffsetSerializable, SSZContainer {\n \n-  private final BeaconBlock message;\n-  private final BLSSignature signature;\n+  public static class SignedBeaconBlockType\n+      extends ContainerType2<SignedBeaconBlock, BeaconBlock, VectorViewRead<ByteView>> {\n \n-  @Label(\"sos-ignore\")\n-  private final Supplier<Bytes32> hashTreeRoot = Suppliers.memoize(this::calculateRoot);\n+    public SignedBeaconBlockType() {\n+      super(\n+          \"SignedBeaconBlock\",\n+          namedType(\"message\", BeaconBlock.TYPE.get()),\n+          namedType(\"signature\", ComplexViewTypes.BYTES_96_TYPE));\n+    }\n \n-  public SignedBeaconBlock(final BeaconBlock message, final BLSSignature signature) {\n-    this.message = message;\n-    this.signature = signature;\n+    @Override\n+    public SignedBeaconBlock createFromBackingNode(TreeNode node) {\n+      return new SignedBeaconBlock(this, node);\n+    }\n   }\n \n-  public BeaconBlock getMessage() {\n-    return message;\n+  @SszTypeDescriptor\n+  public static SignedBeaconBlockType getSszType() {\n+    return TYPE.get();\n   }\n \n-  public BLSSignature getSignature() {\n-    return signature;\n+  public static final SpecDependent<SignedBeaconBlockType> TYPE =\n+      SpecDependent.of(SignedBeaconBlockType::new);\n+\n+  private BLSSignature signatureCache;\n+\n+  private SignedBeaconBlock(SignedBeaconBlockType type, TreeNode backingNode) {\n+    super(type, backingNode);\n   }\n \n-  @Override\n-  public int getSSZFieldCount() {\n-    return message.getSSZFieldCount() + signature.getSSZFieldCount();\n+  @Deprecated", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTExMjcyMA=="}, "originalCommit": {"oid": "5df17b31e3ead5b3c7ef21b1f977ae00536f12be"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU4NjEzNDk2OnYy", "diffSide": "RIGHT", "path": "ethereum/datastructures/src/main/java/tech/pegasys/teku/datastructures/networking/libp2p/rpc/BeaconBlocksByRootRequestMessage.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wM1QwNDo0MzoyN1rOIewylA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wM1QxNDoxNjowOVrOIfERXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTEyNzU3Mg==", "bodyText": "Note that block by root requests aren't actually encoded as an SSZ list - they just concatenate the block roots. We have BeaconBlocksByRootRequestMessageEncoder to handle this and never actually SSZ encode or decode them.  They only implemented SSZContainer to make the type system happy originally (and it looks like that's not actually required anymore).", "url": "https://github.com/ConsenSys/teku/pull/3426#discussion_r569127572", "createdAt": "2021-02-03T04:43:27Z", "author": {"login": "ajsutton"}, "path": "ethereum/datastructures/src/main/java/tech/pegasys/teku/datastructures/networking/libp2p/rpc/BeaconBlocksByRootRequestMessage.java", "diffHunk": "@@ -17,55 +17,66 @@\n \n import com.google.common.base.MoreObjects;\n import java.util.List;\n-import java.util.Objects;\n import org.apache.tuweni.bytes.Bytes32;\n import tech.pegasys.teku.ssz.SSZTypes.SSZContainer;\n-import tech.pegasys.teku.ssz.SSZTypes.SSZList;\n-import tech.pegasys.teku.ssz.SSZTypes.SSZMutableList;\n+import tech.pegasys.teku.ssz.backing.ListViewRead;\n+import tech.pegasys.teku.ssz.backing.containers.Container1;\n+import tech.pegasys.teku.ssz.backing.containers.ContainerType1;\n+import tech.pegasys.teku.ssz.backing.tree.TreeNode;\n+import tech.pegasys.teku.ssz.backing.type.BasicViewTypes;\n+import tech.pegasys.teku.ssz.backing.type.ListViewType;\n+import tech.pegasys.teku.ssz.backing.view.BasicViews.Bytes32View;\n+import tech.pegasys.teku.ssz.backing.view.ViewUtils;\n+import tech.pegasys.teku.ssz.sos.SszTypeDescriptor;\n \n-public class BeaconBlocksByRootRequestMessage implements RpcRequest, SSZContainer {\n+public class BeaconBlocksByRootRequestMessage\n+    extends Container1<BeaconBlocksByRootRequestMessage, ListViewRead<Bytes32View>>\n+    implements RpcRequest, SSZContainer {\n \n-  private final SSZMutableList<Bytes32> blockRoots =\n-      SSZList.createMutable(Bytes32.class, MAX_REQUEST_BLOCKS);\n+  public static class BeaconBlocksByRootRequestMessageType\n+      extends ContainerType1<BeaconBlocksByRootRequestMessage, ListViewRead<Bytes32View>> {\n \n-  public BeaconBlocksByRootRequestMessage(final List<Bytes32> blockRoots) {\n-    this.blockRoots.addAll(blockRoots);\n-  }\n+    public BeaconBlocksByRootRequestMessageType() {\n+      super(\n+          \"BeaconBlocksByRootRequestMessage\",\n+          namedType(\n+              \"blockRoots\", new ListViewType<>(BasicViewTypes.BYTES32_TYPE, MAX_REQUEST_BLOCKS)));\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5df17b31e3ead5b3c7ef21b1f977ae00536f12be"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTI3MTYxMg==", "bodyText": "Yep, I also missed that case during refactoring, but it was caught here: LengthPrefixedEncodingTest.encodePayload_shouldEncodeBlocksByRootRequest() .\nFixed with this commit: 076c75c", "url": "https://github.com/ConsenSys/teku/pull/3426#discussion_r569271612", "createdAt": "2021-02-03T09:48:14Z", "author": {"login": "Nashatyrev"}, "path": "ethereum/datastructures/src/main/java/tech/pegasys/teku/datastructures/networking/libp2p/rpc/BeaconBlocksByRootRequestMessage.java", "diffHunk": "@@ -17,55 +17,66 @@\n \n import com.google.common.base.MoreObjects;\n import java.util.List;\n-import java.util.Objects;\n import org.apache.tuweni.bytes.Bytes32;\n import tech.pegasys.teku.ssz.SSZTypes.SSZContainer;\n-import tech.pegasys.teku.ssz.SSZTypes.SSZList;\n-import tech.pegasys.teku.ssz.SSZTypes.SSZMutableList;\n+import tech.pegasys.teku.ssz.backing.ListViewRead;\n+import tech.pegasys.teku.ssz.backing.containers.Container1;\n+import tech.pegasys.teku.ssz.backing.containers.ContainerType1;\n+import tech.pegasys.teku.ssz.backing.tree.TreeNode;\n+import tech.pegasys.teku.ssz.backing.type.BasicViewTypes;\n+import tech.pegasys.teku.ssz.backing.type.ListViewType;\n+import tech.pegasys.teku.ssz.backing.view.BasicViews.Bytes32View;\n+import tech.pegasys.teku.ssz.backing.view.ViewUtils;\n+import tech.pegasys.teku.ssz.sos.SszTypeDescriptor;\n \n-public class BeaconBlocksByRootRequestMessage implements RpcRequest, SSZContainer {\n+public class BeaconBlocksByRootRequestMessage\n+    extends Container1<BeaconBlocksByRootRequestMessage, ListViewRead<Bytes32View>>\n+    implements RpcRequest, SSZContainer {\n \n-  private final SSZMutableList<Bytes32> blockRoots =\n-      SSZList.createMutable(Bytes32.class, MAX_REQUEST_BLOCKS);\n+  public static class BeaconBlocksByRootRequestMessageType\n+      extends ContainerType1<BeaconBlocksByRootRequestMessage, ListViewRead<Bytes32View>> {\n \n-  public BeaconBlocksByRootRequestMessage(final List<Bytes32> blockRoots) {\n-    this.blockRoots.addAll(blockRoots);\n-  }\n+    public BeaconBlocksByRootRequestMessageType() {\n+      super(\n+          \"BeaconBlocksByRootRequestMessage\",\n+          namedType(\n+              \"blockRoots\", new ListViewType<>(BasicViewTypes.BYTES32_TYPE, MAX_REQUEST_BLOCKS)));\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTEyNzU3Mg=="}, "originalCommit": {"oid": "5df17b31e3ead5b3c7ef21b1f977ae00536f12be"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTM1NzU1Nw==", "bodyText": "They only implemented SSZContainer to make the type system happy originally (and it looks like that's not actually required anymore).\n\nYeah, right. We may now do this in a bit more canonical manner: 20e6eb6", "url": "https://github.com/ConsenSys/teku/pull/3426#discussion_r569357557", "createdAt": "2021-02-03T12:01:16Z", "author": {"login": "Nashatyrev"}, "path": "ethereum/datastructures/src/main/java/tech/pegasys/teku/datastructures/networking/libp2p/rpc/BeaconBlocksByRootRequestMessage.java", "diffHunk": "@@ -17,55 +17,66 @@\n \n import com.google.common.base.MoreObjects;\n import java.util.List;\n-import java.util.Objects;\n import org.apache.tuweni.bytes.Bytes32;\n import tech.pegasys.teku.ssz.SSZTypes.SSZContainer;\n-import tech.pegasys.teku.ssz.SSZTypes.SSZList;\n-import tech.pegasys.teku.ssz.SSZTypes.SSZMutableList;\n+import tech.pegasys.teku.ssz.backing.ListViewRead;\n+import tech.pegasys.teku.ssz.backing.containers.Container1;\n+import tech.pegasys.teku.ssz.backing.containers.ContainerType1;\n+import tech.pegasys.teku.ssz.backing.tree.TreeNode;\n+import tech.pegasys.teku.ssz.backing.type.BasicViewTypes;\n+import tech.pegasys.teku.ssz.backing.type.ListViewType;\n+import tech.pegasys.teku.ssz.backing.view.BasicViews.Bytes32View;\n+import tech.pegasys.teku.ssz.backing.view.ViewUtils;\n+import tech.pegasys.teku.ssz.sos.SszTypeDescriptor;\n \n-public class BeaconBlocksByRootRequestMessage implements RpcRequest, SSZContainer {\n+public class BeaconBlocksByRootRequestMessage\n+    extends Container1<BeaconBlocksByRootRequestMessage, ListViewRead<Bytes32View>>\n+    implements RpcRequest, SSZContainer {\n \n-  private final SSZMutableList<Bytes32> blockRoots =\n-      SSZList.createMutable(Bytes32.class, MAX_REQUEST_BLOCKS);\n+  public static class BeaconBlocksByRootRequestMessageType\n+      extends ContainerType1<BeaconBlocksByRootRequestMessage, ListViewRead<Bytes32View>> {\n \n-  public BeaconBlocksByRootRequestMessage(final List<Bytes32> blockRoots) {\n-    this.blockRoots.addAll(blockRoots);\n-  }\n+    public BeaconBlocksByRootRequestMessageType() {\n+      super(\n+          \"BeaconBlocksByRootRequestMessage\",\n+          namedType(\n+              \"blockRoots\", new ListViewType<>(BasicViewTypes.BYTES32_TYPE, MAX_REQUEST_BLOCKS)));\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTEyNzU3Mg=="}, "originalCommit": {"oid": "5df17b31e3ead5b3c7ef21b1f977ae00536f12be"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTQ0Njc0OA==", "bodyText": "That reminds me to check that on deserialization we are failing fast without reading the whole list when ssz is too long for that list.\nFixed some cases and added a test here: 3a298b8", "url": "https://github.com/ConsenSys/teku/pull/3426#discussion_r569446748", "createdAt": "2021-02-03T14:16:09Z", "author": {"login": "Nashatyrev"}, "path": "ethereum/datastructures/src/main/java/tech/pegasys/teku/datastructures/networking/libp2p/rpc/BeaconBlocksByRootRequestMessage.java", "diffHunk": "@@ -17,55 +17,66 @@\n \n import com.google.common.base.MoreObjects;\n import java.util.List;\n-import java.util.Objects;\n import org.apache.tuweni.bytes.Bytes32;\n import tech.pegasys.teku.ssz.SSZTypes.SSZContainer;\n-import tech.pegasys.teku.ssz.SSZTypes.SSZList;\n-import tech.pegasys.teku.ssz.SSZTypes.SSZMutableList;\n+import tech.pegasys.teku.ssz.backing.ListViewRead;\n+import tech.pegasys.teku.ssz.backing.containers.Container1;\n+import tech.pegasys.teku.ssz.backing.containers.ContainerType1;\n+import tech.pegasys.teku.ssz.backing.tree.TreeNode;\n+import tech.pegasys.teku.ssz.backing.type.BasicViewTypes;\n+import tech.pegasys.teku.ssz.backing.type.ListViewType;\n+import tech.pegasys.teku.ssz.backing.view.BasicViews.Bytes32View;\n+import tech.pegasys.teku.ssz.backing.view.ViewUtils;\n+import tech.pegasys.teku.ssz.sos.SszTypeDescriptor;\n \n-public class BeaconBlocksByRootRequestMessage implements RpcRequest, SSZContainer {\n+public class BeaconBlocksByRootRequestMessage\n+    extends Container1<BeaconBlocksByRootRequestMessage, ListViewRead<Bytes32View>>\n+    implements RpcRequest, SSZContainer {\n \n-  private final SSZMutableList<Bytes32> blockRoots =\n-      SSZList.createMutable(Bytes32.class, MAX_REQUEST_BLOCKS);\n+  public static class BeaconBlocksByRootRequestMessageType\n+      extends ContainerType1<BeaconBlocksByRootRequestMessage, ListViewRead<Bytes32View>> {\n \n-  public BeaconBlocksByRootRequestMessage(final List<Bytes32> blockRoots) {\n-    this.blockRoots.addAll(blockRoots);\n-  }\n+    public BeaconBlocksByRootRequestMessageType() {\n+      super(\n+          \"BeaconBlocksByRootRequestMessage\",\n+          namedType(\n+              \"blockRoots\", new ListViewType<>(BasicViewTypes.BYTES32_TYPE, MAX_REQUEST_BLOCKS)));\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTEyNzU3Mg=="}, "originalCommit": {"oid": "5df17b31e3ead5b3c7ef21b1f977ae00536f12be"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU4NjE1NDUwOnYy", "diffSide": "RIGHT", "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/ssz/BeaconBlocksByRootRequestMessageEncoder.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wM1QwNDo1MzowNlrOIew9fQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wM1QyMzoyNDozNlrOIfbOdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTEzMDM2NQ==", "bodyText": "I don't think this is right as it will wind up serialising as a list rather than a vector.  Could be missing something though.", "url": "https://github.com/ConsenSys/teku/pull/3426#discussion_r569130365", "createdAt": "2021-02-03T04:53:06Z", "author": {"login": "ajsutton"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/ssz/BeaconBlocksByRootRequestMessageEncoder.java", "diffHunk": "@@ -38,7 +37,7 @@\n \n   @Override\n   public Bytes encode(final BeaconBlocksByRootRequestMessage message) {\n-    return SSZ.encode(writer -> writer.writeFixedBytesVector(message.getBlockRoots().asList()));\n+    return message.getBlockRoots().sszSerialize();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5df17b31e3ead5b3c7ef21b1f977ae00536f12be"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTI3NzY5MQ==", "bodyText": "List and Vector are serialized identically.\nBTW, if I'm not missing anything there was an old SSZ spec version when a List was prepended by its length in SSZ", "url": "https://github.com/ConsenSys/teku/pull/3426#discussion_r569277691", "createdAt": "2021-02-03T09:56:41Z", "author": {"login": "Nashatyrev"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/ssz/BeaconBlocksByRootRequestMessageEncoder.java", "diffHunk": "@@ -38,7 +37,7 @@\n \n   @Override\n   public Bytes encode(final BeaconBlocksByRootRequestMessage message) {\n-    return SSZ.encode(writer -> writer.writeFixedBytesVector(message.getBlockRoots().asList()));\n+    return message.getBlockRoots().sszSerialize();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTEzMDM2NQ=="}, "originalCommit": {"oid": "5df17b31e3ead5b3c7ef21b1f977ae00536f12be"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTMzOTQ2MA==", "bodyText": "BTW spec defines it as List[Root, MAX_REQUEST_BLOCKS] so it's officially a List :)", "url": "https://github.com/ConsenSys/teku/pull/3426#discussion_r569339460", "createdAt": "2021-02-03T11:30:33Z", "author": {"login": "Nashatyrev"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/ssz/BeaconBlocksByRootRequestMessageEncoder.java", "diffHunk": "@@ -38,7 +37,7 @@\n \n   @Override\n   public Bytes encode(final BeaconBlocksByRootRequestMessage message) {\n-    return SSZ.encode(writer -> writer.writeFixedBytesVector(message.getBlockRoots().asList()));\n+    return message.getBlockRoots().sszSerialize();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTEzMDM2NQ=="}, "originalCommit": {"oid": "5df17b31e3ead5b3c7ef21b1f977ae00536f12be"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTgyMjgzOQ==", "bodyText": "hmm, wonder why I could never get it to work before then...  Anyway, confirmed it is producing a concatenated list of block roots like we need so all good.", "url": "https://github.com/ConsenSys/teku/pull/3426#discussion_r569822839", "createdAt": "2021-02-03T23:24:36Z", "author": {"login": "ajsutton"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/ssz/BeaconBlocksByRootRequestMessageEncoder.java", "diffHunk": "@@ -38,7 +37,7 @@\n \n   @Override\n   public Bytes encode(final BeaconBlocksByRootRequestMessage message) {\n-    return SSZ.encode(writer -> writer.writeFixedBytesVector(message.getBlockRoots().asList()));\n+    return message.getBlockRoots().sszSerialize();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTEzMDM2NQ=="}, "originalCommit": {"oid": "5df17b31e3ead5b3c7ef21b1f977ae00536f12be"}, "originalPosition": 13}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1810, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}