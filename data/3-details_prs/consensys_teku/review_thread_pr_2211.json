{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM5MzU5Mjcy", "number": 2211, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwMDozMzo0NFrOEI95Bw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwMjowMjo0OFrOEI-slw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3ODM4MDg3OnYy", "diffSide": "RIGHT", "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/stategenerator/AsyncChainStateGenerator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwMDozMzo0NFrOGpQJDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxNTo1NDowNVrOGpmCog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTkwOTI2MA==", "bodyText": "checkNotNull?", "url": "https://github.com/ConsenSys/teku/pull/2211#discussion_r445909260", "createdAt": "2020-06-26T00:33:44Z", "author": {"login": "ajsutton"}, "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/stategenerator/AsyncChainStateGenerator.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.core.stategenerator;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+\n+import com.google.common.collect.Lists;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.core.lookup.BlockProvider;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.hashtree.HashTree;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.util.async.SafeFuture;\n+\n+class AsyncChainStateGenerator {\n+  public static final int DEFAULT_BLOCK_BATCH_SIZE = 250;\n+\n+  private final HashTree blockTree;\n+  private final BlockProvider blockProvider;\n+  private final StateProvider stateProvider;\n+  private final int blockBatchSize;\n+\n+  private AsyncChainStateGenerator(\n+      final HashTree blockTree,\n+      final BlockProvider blockProvider,\n+      final StateProvider stateProvider,\n+      final int blockBatchSize) {\n+    this.blockTree = blockTree;\n+    this.blockProvider = blockProvider;\n+    this.stateProvider = stateProvider;\n+    this.blockBatchSize = blockBatchSize;\n+  }\n+\n+  public static AsyncChainStateGenerator create(\n+      final HashTree blockTree,\n+      final BlockProvider blockProvider,\n+      final StateProvider stateProvider) {\n+    return new AsyncChainStateGenerator(\n+        blockTree, blockProvider, stateProvider, DEFAULT_BLOCK_BATCH_SIZE);\n+  }\n+\n+  public SafeFuture<BeaconState> generateTargetState(final Bytes32 targetRoot) {\n+    if (!blockTree.contains(targetRoot)) {\n+      return SafeFuture.failedFuture(\n+          new IllegalArgumentException(\"Target root is unknown: \" + targetRoot));\n+    }\n+\n+    final SafeFuture<BeaconState> lastState = new SafeFuture<>();\n+    generateStates(\n+            targetRoot,\n+            (block, state) -> {\n+              if (block.getRoot().equals(targetRoot)) {\n+                lastState.complete(state);\n+              }\n+            })\n+        .finish(\n+            // Make sure future is completed\n+            () ->\n+                lastState.completeExceptionally(\n+                    new IllegalStateException(\"Failed to generate state for \" + targetRoot)),\n+            lastState::completeExceptionally);\n+\n+    return lastState;\n+  }\n+\n+  public SafeFuture<?> generateStates(final Bytes32 targetRoot, final StateHandler handler) {\n+    return SafeFuture.of(\n+        () -> {\n+          // Build chain from target root to the first ancestor with a known state\n+          final AtomicReference<BeaconState> baseState = new AtomicReference<>(null);\n+          final List<Bytes32> chain =\n+              blockTree.collectChainRoots(\n+                  targetRoot,\n+                  (currentRoot) -> {\n+                    stateProvider.getState(currentRoot).ifPresent(baseState::set);\n+                    return baseState.get() == null;\n+                  });\n+\n+          if (baseState.get() == null) {\n+            throw new IllegalArgumentException(\"Unable to find base state to build on\");\n+          }\n+\n+          if (chain.size() == 0) {\n+            throw new IllegalStateException(\"Failed to retrieve chain\");\n+          }\n+\n+          // Process chain in batches\n+          final List<List<Bytes32>> blockBatches = Lists.partition(chain, blockBatchSize);\n+          // Request and process each batch of blocks in order\n+          SafeFuture<BeaconState> future =\n+              processBlockBatch(blockBatches.get(0), baseState.get(), handler);\n+          for (int i = 1; i < blockBatches.size(); i++) {\n+            final List<Bytes32> blockBatch = blockBatches.get(i);\n+            future = future.thenCompose(state -> processBlockBatch(blockBatch, state, handler));\n+          }\n+          return future;\n+        });\n+  }\n+\n+  private SafeFuture<BeaconState> processBlockBatch(\n+      final List<Bytes32> blockRoots, final BeaconState startState, final StateHandler handler) {\n+    checkArgument(startState != null, \"Must provide start state\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "843b5148550f1e8da1b35b9f80d6996750e73f26"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjI2ODA2Ng==", "bodyText": "I kind of prefer throwing an IllegalArgumentException \ud83e\udd37", "url": "https://github.com/ConsenSys/teku/pull/2211#discussion_r446268066", "createdAt": "2020-06-26T15:54:05Z", "author": {"login": "mbaxter"}, "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/stategenerator/AsyncChainStateGenerator.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.core.stategenerator;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+\n+import com.google.common.collect.Lists;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.core.lookup.BlockProvider;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.hashtree.HashTree;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.util.async.SafeFuture;\n+\n+class AsyncChainStateGenerator {\n+  public static final int DEFAULT_BLOCK_BATCH_SIZE = 250;\n+\n+  private final HashTree blockTree;\n+  private final BlockProvider blockProvider;\n+  private final StateProvider stateProvider;\n+  private final int blockBatchSize;\n+\n+  private AsyncChainStateGenerator(\n+      final HashTree blockTree,\n+      final BlockProvider blockProvider,\n+      final StateProvider stateProvider,\n+      final int blockBatchSize) {\n+    this.blockTree = blockTree;\n+    this.blockProvider = blockProvider;\n+    this.stateProvider = stateProvider;\n+    this.blockBatchSize = blockBatchSize;\n+  }\n+\n+  public static AsyncChainStateGenerator create(\n+      final HashTree blockTree,\n+      final BlockProvider blockProvider,\n+      final StateProvider stateProvider) {\n+    return new AsyncChainStateGenerator(\n+        blockTree, blockProvider, stateProvider, DEFAULT_BLOCK_BATCH_SIZE);\n+  }\n+\n+  public SafeFuture<BeaconState> generateTargetState(final Bytes32 targetRoot) {\n+    if (!blockTree.contains(targetRoot)) {\n+      return SafeFuture.failedFuture(\n+          new IllegalArgumentException(\"Target root is unknown: \" + targetRoot));\n+    }\n+\n+    final SafeFuture<BeaconState> lastState = new SafeFuture<>();\n+    generateStates(\n+            targetRoot,\n+            (block, state) -> {\n+              if (block.getRoot().equals(targetRoot)) {\n+                lastState.complete(state);\n+              }\n+            })\n+        .finish(\n+            // Make sure future is completed\n+            () ->\n+                lastState.completeExceptionally(\n+                    new IllegalStateException(\"Failed to generate state for \" + targetRoot)),\n+            lastState::completeExceptionally);\n+\n+    return lastState;\n+  }\n+\n+  public SafeFuture<?> generateStates(final Bytes32 targetRoot, final StateHandler handler) {\n+    return SafeFuture.of(\n+        () -> {\n+          // Build chain from target root to the first ancestor with a known state\n+          final AtomicReference<BeaconState> baseState = new AtomicReference<>(null);\n+          final List<Bytes32> chain =\n+              blockTree.collectChainRoots(\n+                  targetRoot,\n+                  (currentRoot) -> {\n+                    stateProvider.getState(currentRoot).ifPresent(baseState::set);\n+                    return baseState.get() == null;\n+                  });\n+\n+          if (baseState.get() == null) {\n+            throw new IllegalArgumentException(\"Unable to find base state to build on\");\n+          }\n+\n+          if (chain.size() == 0) {\n+            throw new IllegalStateException(\"Failed to retrieve chain\");\n+          }\n+\n+          // Process chain in batches\n+          final List<List<Bytes32>> blockBatches = Lists.partition(chain, blockBatchSize);\n+          // Request and process each batch of blocks in order\n+          SafeFuture<BeaconState> future =\n+              processBlockBatch(blockBatches.get(0), baseState.get(), handler);\n+          for (int i = 1; i < blockBatches.size(); i++) {\n+            final List<Bytes32> blockBatch = blockBatches.get(i);\n+            future = future.thenCompose(state -> processBlockBatch(blockBatch, state, handler));\n+          }\n+          return future;\n+        });\n+  }\n+\n+  private SafeFuture<BeaconState> processBlockBatch(\n+      final List<Bytes32> blockRoots, final BeaconState startState, final StateHandler handler) {\n+    checkArgument(startState != null, \"Must provide start state\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTkwOTI2MA=="}, "originalCommit": {"oid": "843b5148550f1e8da1b35b9f80d6996750e73f26"}, "originalPosition": 117}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3ODM4OTUzOnYy", "diffSide": "RIGHT", "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/stategenerator/BlockProcessor.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwMDozOToxNVrOGpQOSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwMDozOToxNVrOGpQOSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTkxMDYwMg==", "bodyText": "We should probably just make this a field instead of creating a new instance for every block.", "url": "https://github.com/ConsenSys/teku/pull/2211#discussion_r445910602", "createdAt": "2020-06-26T00:39:15Z", "author": {"login": "ajsutton"}, "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/stategenerator/BlockProcessor.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.core.stategenerator;\n+\n+import tech.pegasys.teku.core.StateTransition;\n+import tech.pegasys.teku.core.StateTransitionException;\n+import tech.pegasys.teku.core.blockvalidator.NopBlockValidator;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+\n+class BlockProcessor {\n+\n+  public BeaconState process(final BeaconState preState, final SignedBeaconBlock block) {\n+    StateTransition stateTransition = new StateTransition(new NopBlockValidator());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "843b5148550f1e8da1b35b9f80d6996750e73f26"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3ODM5MjUxOnYy", "diffSide": "RIGHT", "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/stategenerator/BlockProcessor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwMDo0MTowNlrOGpQQJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxNTozNjo1M1rOGpldXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTkxMTA3Ng==", "bodyText": "Isn't this the same check that assertBlockAndStateMatch is doing?", "url": "https://github.com/ConsenSys/teku/pull/2211#discussion_r445911076", "createdAt": "2020-06-26T00:41:06Z", "author": {"login": "ajsutton"}, "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/stategenerator/BlockProcessor.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.core.stategenerator;\n+\n+import tech.pegasys.teku.core.StateTransition;\n+import tech.pegasys.teku.core.StateTransitionException;\n+import tech.pegasys.teku.core.blockvalidator.NopBlockValidator;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+\n+class BlockProcessor {\n+\n+  public BeaconState process(final BeaconState preState, final SignedBeaconBlock block) {\n+    StateTransition stateTransition = new StateTransition(new NopBlockValidator());\n+    try {\n+      final BeaconState postState = stateTransition.initiate(preState, block);\n+      assertBlockAndStateMatch(block, postState);\n+      // Validate that state matches expectation\n+      if (!block.getMessage().getState_root().equals(postState.hash_tree_root())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "843b5148550f1e8da1b35b9f80d6996750e73f26"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjI1ODUyNg==", "bodyText": "indeed \ud83d\ude02", "url": "https://github.com/ConsenSys/teku/pull/2211#discussion_r446258526", "createdAt": "2020-06-26T15:36:53Z", "author": {"login": "mbaxter"}, "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/stategenerator/BlockProcessor.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.core.stategenerator;\n+\n+import tech.pegasys.teku.core.StateTransition;\n+import tech.pegasys.teku.core.StateTransitionException;\n+import tech.pegasys.teku.core.blockvalidator.NopBlockValidator;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+\n+class BlockProcessor {\n+\n+  public BeaconState process(final BeaconState preState, final SignedBeaconBlock block) {\n+    StateTransition stateTransition = new StateTransition(new NopBlockValidator());\n+    try {\n+      final BeaconState postState = stateTransition.initiate(preState, block);\n+      assertBlockAndStateMatch(block, postState);\n+      // Validate that state matches expectation\n+      if (!block.getMessage().getState_root().equals(postState.hash_tree_root())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTkxMTA3Ng=="}, "originalCommit": {"oid": "843b5148550f1e8da1b35b9f80d6996750e73f26"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3ODQxMTI5OnYy", "diffSide": "RIGHT", "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/stategenerator/StateGenerator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwMDo1Mzo1MVrOGpQcDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwMDo1Mzo1MVrOGpQcDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTkxNDEyNw==", "bodyText": "There isn't a good one that I know of.", "url": "https://github.com/ConsenSys/teku/pull/2211#discussion_r445914127", "createdAt": "2020-06-26T00:53:51Z", "author": {"login": "ajsutton"}, "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/stategenerator/StateGenerator.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.core.stategenerator;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static tech.pegasys.teku.core.stategenerator.AsyncChainStateGenerator.DEFAULT_BLOCK_BATCH_SIZE;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.Lists;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.core.lookup.BlockProvider;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.blocks.SignedBlockAndState;\n+import tech.pegasys.teku.datastructures.hashtree.HashTree;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.datastructures.state.BlockRootAndState;\n+import tech.pegasys.teku.util.async.SafeFuture;\n+\n+public class StateGenerator {\n+  public static final int DEFAULT_STATE_CACHE_SIZE = 50;\n+\n+  private final BlockProcessor blockProcessor = new BlockProcessor();\n+  private final HashTree blockTree;\n+  private final BlockProvider blockProvider;\n+  private final AsyncChainStateGenerator chainStateGenerator;\n+\n+  private final StateCache stateCache;\n+  private final int blockBatchSize;\n+\n+  private StateGenerator(\n+      final HashTree blockTree,\n+      final BlockProvider blockProvider,\n+      final AsyncChainStateGenerator chainStateGenerator,\n+      final StateCache stateCache,\n+      final int blockBatchSize) {\n+    checkArgument(blockBatchSize > 0, \"Must provide a block batch size > 0\");\n+    checkArgument(\n+        stateCache.containsKnownState(blockTree.getRootHash()), \"Root state must be available\");\n+\n+    this.blockTree = blockTree;\n+    this.blockProvider = blockProvider;\n+    this.stateCache = stateCache;\n+    this.blockBatchSize = blockBatchSize;\n+    this.chainStateGenerator = chainStateGenerator;\n+  }\n+\n+  public static StateGenerator create(\n+      final HashTree blockTree,\n+      final SignedBlockAndState rootBlockAndState,\n+      final BlockProvider blockProvider) {\n+    return create(blockTree, rootBlockAndState, blockProvider, Collections.emptyMap());\n+  }\n+\n+  public static StateGenerator create(\n+      final HashTree blockTree,\n+      final SignedBlockAndState rootBlockAndState,\n+      final BlockProvider blockProvider,\n+      final Map<Bytes32, BeaconState> knownStates) {\n+    return create(\n+        blockTree,\n+        rootBlockAndState,\n+        blockProvider,\n+        knownStates,\n+        DEFAULT_BLOCK_BATCH_SIZE,\n+        DEFAULT_STATE_CACHE_SIZE);\n+  }\n+\n+  public static StateGenerator create(\n+      final HashTree blockTree,\n+      final SignedBlockAndState rootBlockAndState,\n+      final BlockProvider blockProvider,\n+      final Map<Bytes32, BeaconState> knownStates,\n+      final int blockBatchSize,\n+      final int stateCacheSize) {\n+    checkArgument(\n+        rootBlockAndState.getRoot().equals(blockTree.getRootHash()),\n+        \"Provided root block must match the root of the provided block tree\");\n+\n+    final Map<Bytes32, BeaconState> availableStates = new HashMap<>(knownStates);\n+    availableStates.put(rootBlockAndState.getRoot(), rootBlockAndState.getState());\n+    final StateCache stateCache = new StateCache(stateCacheSize, availableStates);\n+\n+    final AsyncChainStateGenerator chainStateGenerator =\n+        AsyncChainStateGenerator.create(blockTree, blockProvider, stateCache::get);\n+    return new StateGenerator(\n+        blockTree, blockProvider, chainStateGenerator, stateCache, blockBatchSize);\n+  }\n+\n+  public SafeFuture<BeaconState> regenerateStateForBlock(final Bytes32 blockRoot) {\n+    return chainStateGenerator.generateTargetState(blockRoot);\n+  }\n+\n+  public SafeFuture<Void> regenerateAllStates(final StateHandler stateHandler) {\n+    return regenerateAllStatesInternal(stateHandler).thenAccept(__ -> stateCache.clear());\n+  }\n+\n+  @VisibleForTesting\n+  SafeFuture<?> regenerateAllStatesInternal(final StateHandler stateHandler) {\n+    final List<Bytes32> blockRoots = blockTree.preOrderStream().collect(Collectors.toList());\n+    if (blockRoots.size() == 0) {\n+      return SafeFuture.completedFuture(null);\n+    }\n+\n+    // Break up blocks into batches\n+    // TODO - is there a way to partition the stream directly?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "843b5148550f1e8da1b35b9f80d6996750e73f26"}, "originalPosition": 122}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3ODQ2MTU1OnYy", "diffSide": "RIGHT", "path": "ethereum/core/src/testFixtures/java/tech/pegasys/teku/core/ChainBuilder.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwMToyNzo0NlrOGpQ6vA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwMToyNzo0NlrOGpQ6vA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTkyMTk4MA==", "bodyText": "Nice. I really don't know why we hadn't thought of that earlier...", "url": "https://github.com/ConsenSys/teku/pull/2211#discussion_r445921980", "createdAt": "2020-06-26T01:27:46Z", "author": {"login": "ajsutton"}, "path": "ethereum/core/src/testFixtures/java/tech/pegasys/teku/core/ChainBuilder.java", "diffHunk": "@@ -53,6 +54,8 @@\n \n /** A utility for building small, valid chains of blocks with states for testing */\n public class ChainBuilder {\n+  private static final List<BLSKeyPair> DEFAULT_VALIDATOR_KEYS =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "843b5148550f1e8da1b35b9f80d6996750e73f26"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3ODQ5OTE2OnYy", "diffSide": "RIGHT", "path": "storage/src/main/java/tech/pegasys/teku/storage/server/rocksdb/RocksDbDatabase.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwMTo1Mzo1NVrOGpRRyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxNTozNzo1NVrOGplfdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTkyNzg4Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    .map(root -> hotDao.getHotBlock(root).orElse(null))\n          \n          \n            \n                    .filter(Objects::nonNull)\n          \n          \n            \n                    .flatMap(root -> hotDao.getHotBlock(root).stream())", "url": "https://github.com/ConsenSys/teku/pull/2211#discussion_r445927883", "createdAt": "2020-06-26T01:53:55Z", "author": {"login": "ajsutton"}, "path": "storage/src/main/java/tech/pegasys/teku/storage/server/rocksdb/RocksDbDatabase.java", "diffHunk": "@@ -220,6 +230,14 @@ public void update(final StorageUpdate event) {\n     return hotDao.getHotBlock(root).or(() -> finalizedDao.getFinalizedBlock(root));\n   }\n \n+  @Override\n+  public Map<Bytes32, SignedBeaconBlock> getHotBlocks(final Set<Bytes32> blockRoots) {\n+    return blockRoots.stream()\n+        .map(root -> hotDao.getHotBlock(root).orElse(null))\n+        .filter(Objects::nonNull)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "843b5148550f1e8da1b35b9f80d6996750e73f26"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjI1OTA2Mw==", "bodyText": "nice tip!! \ud83c\udf89", "url": "https://github.com/ConsenSys/teku/pull/2211#discussion_r446259063", "createdAt": "2020-06-26T15:37:55Z", "author": {"login": "mbaxter"}, "path": "storage/src/main/java/tech/pegasys/teku/storage/server/rocksdb/RocksDbDatabase.java", "diffHunk": "@@ -220,6 +230,14 @@ public void update(final StorageUpdate event) {\n     return hotDao.getHotBlock(root).or(() -> finalizedDao.getFinalizedBlock(root));\n   }\n \n+  @Override\n+  public Map<Bytes32, SignedBeaconBlock> getHotBlocks(final Set<Bytes32> blockRoots) {\n+    return blockRoots.stream()\n+        .map(root -> hotDao.getHotBlock(root).orElse(null))\n+        .filter(Objects::nonNull)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTkyNzg4Mw=="}, "originalCommit": {"oid": "843b5148550f1e8da1b35b9f80d6996750e73f26"}, "originalPosition": 150}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3ODUwMjg4OnYy", "diffSide": "RIGHT", "path": "storage/src/main/java/tech/pegasys/teku/storage/server/rocksdb/RocksDbDatabase.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwMTo1NjoxMlrOGpRUEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwMTo1NjoxMlrOGpRUEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTkyODQ2NQ==", "bodyText": "I suspect the next step is actually to avoid regenerating states at this point.  We only store snapshots anyway so could just leave a bigger gap than usual between snapshots if finalisation is delayed (and potentially fill that gap if we do wind up having to generate the states for an API request in the future).\nMakes sense to leave that for the future though.", "url": "https://github.com/ConsenSys/teku/pull/2211#discussion_r445928465", "createdAt": "2020-06-26T01:56:12Z", "author": {"login": "ajsutton"}, "path": "storage/src/main/java/tech/pegasys/teku/storage/server/rocksdb/RocksDbDatabase.java", "diffHunk": "@@ -289,36 +306,67 @@ private void doUpdate(final StorageUpdate update) {\n     }\n   }\n \n-  private void putFinalizedStates(\n-      FinalizedUpdater updater,\n+  private void updateFinalizedData(\n+      Map<Bytes32, Bytes32> finalizedChildToParentMap,\n       final Map<Bytes32, SignedBeaconBlock> finalizedBlocks,\n       final Map<Bytes32, BeaconState> finalizedStates) {\n-    if (finalizedBlocks.isEmpty()) {\n+    if (finalizedChildToParentMap.isEmpty()) {\n+      // Nothing to do\n       return;\n     }\n \n-    switch (stateStorageMode) {\n-      case ARCHIVE:\n-        // Get previously finalized block to build on top of\n-        final Bytes32 baseBlockRoot = hotDao.getFinalizedCheckpoint().orElseThrow().getRoot();\n-        final SignedBeaconBlock baseBlock =\n-            finalizedDao.getFinalizedBlock(baseBlockRoot).orElseThrow();\n-        final BeaconState baseState = hotDao.getLatestFinalizedState().orElseThrow();\n-\n-        final BlockTree blockTree =\n-            BlockTree.builder().rootBlock(baseBlock).blocks(finalizedBlocks.values()).build();\n-        final StateGenerator stateGenerator =\n-            StateGenerator.create(blockTree, baseState, finalizedStates);\n-        stateGenerator.regenerateAllStates(updater::addFinalizedState);\n-        break;\n-      case PRUNE:\n-        // Don't persist finalized state\n-        break;\n-      default:\n-        throw new UnsupportedOperationException(\"Unhandled storage mode: \" + stateStorageMode);\n+    try (final FinalizedUpdater updater = finalizedDao.finalizedUpdater()) {\n+      final BlockProvider blockProvider =\n+          BlockProvider.withKnownBlocks(\n+              roots -> SafeFuture.completedFuture(getHotBlocks(roots)), finalizedBlocks);\n+\n+      switch (stateStorageMode) {\n+        case ARCHIVE:\n+          // Get previously finalized block to build on top of\n+          final SignedBlockAndState baseBlock = getFinalizedBlockAndState();\n+\n+          final HashTree blockTree =\n+              HashTree.builder()\n+                  .rootHash(baseBlock.getRoot())\n+                  .childAndParentRoots(finalizedChildToParentMap)\n+                  .build();\n+\n+          final StateGenerator stateGenerator =\n+              StateGenerator.create(blockTree, baseBlock, blockProvider, finalizedStates);\n+          // TODO - don't join, create synchronous API for synchronous blockProvider\n+          stateGenerator\n+              .regenerateAllStates(\n+                  (block, state) -> {\n+                    updater.addFinalizedBlock(block);\n+                    updater.addFinalizedState(block.getRoot(), state);\n+                  })\n+              .join();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "843b5148550f1e8da1b35b9f80d6996750e73f26"}, "originalPosition": 235}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3ODUwNjU3OnYy", "diffSide": "RIGHT", "path": "storage/src/main/java/tech/pegasys/teku/storage/server/rocksdb/dataaccess/RocksDbHotDao.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwMTo1ODozNVrOGpRWTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwMTo1ODozNVrOGpRWTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTkyOTAzNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              Stream<SignedBeaconBlock> streamHotBlocks();\n          \n          \n            \n              @MustBeClosed\n          \n          \n            \n              Stream<SignedBeaconBlock> streamHotBlocks();", "url": "https://github.com/ConsenSys/teku/pull/2211#discussion_r445929036", "createdAt": "2020-06-26T01:58:35Z", "author": {"login": "ajsutton"}, "path": "storage/src/main/java/tech/pegasys/teku/storage/server/rocksdb/dataaccess/RocksDbHotDao.java", "diffHunk": "@@ -43,6 +44,8 @@\n \n   Map<Bytes32, SignedBeaconBlock> getHotBlocks();\n \n+  Stream<SignedBeaconBlock> streamHotBlocks();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "843b5148550f1e8da1b35b9f80d6996750e73f26"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3ODUxMjg3OnYy", "diffSide": "RIGHT", "path": "storage/src/main/java/tech/pegasys/teku/storage/store/Store.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwMjowMjo0OFrOGpRaKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxNTo1MDozMFrOGpl62A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTkzMDAyNw==", "bodyText": "Doesn't this mean we wind up holding the finalised block and state from startup in memory permanently?", "url": "https://github.com/ConsenSys/teku/pull/2211#discussion_r445930027", "createdAt": "2020-06-26T02:02:48Z", "author": {"login": "ajsutton"}, "path": "storage/src/main/java/tech/pegasys/teku/storage/store/Store.java", "diffHunk": "@@ -104,45 +110,68 @@\n     stateRequestCachedCounter = stateRequestCounter.labels(\"cached\");\n     stateRequestRegenerateCounter = stateRequestCounter.labels(\"regenerate\");\n     stateRequestMissCounter = stateRequestCounter.labels(\"miss\");\n+\n     this.time = time;\n     this.genesis_time = genesis_time;\n     this.justified_checkpoint = justified_checkpoint;\n     this.finalized_checkpoint = finalized_checkpoint;\n     this.best_justified_checkpoint = best_justified_checkpoint;\n-    this.blocks = new ConcurrentHashMap<>(blocks);\n+    this.blocks =\n+        ConcurrentLimitedMap.create(\n+            pruningOptions.getBlockCacheSize(), LimitStrategy.DROP_LEAST_RECENTLY_ACCESSED);\n     this.block_states =\n-        ConcurrentLimitedMap.create(stateCacheSize, LimitStrategy.DROP_LEAST_RECENTLY_ACCESSED);\n-    this.checkpoint_states = new ConcurrentHashMap<>(checkpoint_states);\n+        LimitedMap.create(\n+            pruningOptions.getStateCacheSize(), LimitStrategy.DROP_LEAST_RECENTLY_ACCESSED);\n+    this.checkpoint_states = new HashMap<>(checkpoint_states);\n+\n+    this.blockProvider =\n+        BlockProvider.combined(\n+            fromMap(Map.of(finalizedBlockAndState.getRoot(), finalizedBlockAndState.getBlock())),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "843b5148550f1e8da1b35b9f80d6996750e73f26"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjI2NjA3Mg==", "bodyText": "good catch!  adding a helper utility to provide the latest finalized block dynamically", "url": "https://github.com/ConsenSys/teku/pull/2211#discussion_r446266072", "createdAt": "2020-06-26T15:50:30Z", "author": {"login": "mbaxter"}, "path": "storage/src/main/java/tech/pegasys/teku/storage/store/Store.java", "diffHunk": "@@ -104,45 +110,68 @@\n     stateRequestCachedCounter = stateRequestCounter.labels(\"cached\");\n     stateRequestRegenerateCounter = stateRequestCounter.labels(\"regenerate\");\n     stateRequestMissCounter = stateRequestCounter.labels(\"miss\");\n+\n     this.time = time;\n     this.genesis_time = genesis_time;\n     this.justified_checkpoint = justified_checkpoint;\n     this.finalized_checkpoint = finalized_checkpoint;\n     this.best_justified_checkpoint = best_justified_checkpoint;\n-    this.blocks = new ConcurrentHashMap<>(blocks);\n+    this.blocks =\n+        ConcurrentLimitedMap.create(\n+            pruningOptions.getBlockCacheSize(), LimitStrategy.DROP_LEAST_RECENTLY_ACCESSED);\n     this.block_states =\n-        ConcurrentLimitedMap.create(stateCacheSize, LimitStrategy.DROP_LEAST_RECENTLY_ACCESSED);\n-    this.checkpoint_states = new ConcurrentHashMap<>(checkpoint_states);\n+        LimitedMap.create(\n+            pruningOptions.getStateCacheSize(), LimitStrategy.DROP_LEAST_RECENTLY_ACCESSED);\n+    this.checkpoint_states = new HashMap<>(checkpoint_states);\n+\n+    this.blockProvider =\n+        BlockProvider.combined(\n+            fromMap(Map.of(finalizedBlockAndState.getRoot(), finalizedBlockAndState.getBlock())),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTkzMDAyNw=="}, "originalCommit": {"oid": "843b5148550f1e8da1b35b9f80d6996750e73f26"}, "originalPosition": 118}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3630, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}