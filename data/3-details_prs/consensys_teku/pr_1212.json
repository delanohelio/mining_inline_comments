{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc4MDIxMzE0", "number": 1212, "title": "Key Store for storing BLS12-381 private keys", "bodyText": "PR Description\nKey Store implementation using EIP-2335\n\nRead/Write Json Key Store using Jackson\nValidate Password\nDecrypting BLS12-381 private key\nEncrypting BLS12-381 private key and password (thus creating Key Store)\n\nFixed Issue(s)\nfixes #1174", "createdAt": "2020-02-20T23:06:30Z", "url": "https://github.com/ConsenSys/teku/pull/1212", "merged": true, "mergeCommit": {"oid": "db6e416193b4bf09904c91f9c6b4b7669efa7152"}, "closed": true, "closedAt": "2020-02-27T23:21:04Z", "author": {"login": "usmansaleem"}, "timelineItems": {"totalCount": 48, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcGEw87gH2gAyMzc4MDIxMzE0OjI0MGY0MjBmZjkzZDA4NGJlZWQwM2Q5NDQ0ZDZmOTJiM2M4NjliNmU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcIjngHAH2gAyMzc4MDIxMzE0Ojc5NzFiZGRhY2EwZjIxOWIzYTk4NmYwZWQzMjc3YWIyMmI2MzU2NDE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "240f420ff93d084beed03d9444d6f92b3c869b6e", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/240f420ff93d084beed03d9444d6f92b3c869b6e", "committedDate": "2020-02-20T06:02:43Z", "message": "json des\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2f6cd5af8dd15134c74c197da3f96522ba21ff91", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/2f6cd5af8dd15134c74c197da3f96522ba21ff91", "committedDate": "2020-02-20T07:43:47Z", "message": "read and write bls keystore from json to java\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2f3b1eddbf8aa9b957136e51658c3b4f95578410", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/2f3b1eddbf8aa9b957136e51658c3b4f95578410", "committedDate": "2020-02-20T07:49:08Z", "message": "Merge remote-tracking branch 'upstream/master' into feature/bls_keystore\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d401a71cff179fa9bcd4bee001622f7ecac77d36", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/d401a71cff179fa9bcd4bee001622f7ecac77d36", "committedDate": "2020-02-20T13:26:29Z", "message": "validate keystore password\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "36a56a6152cdd59973d2085aa1b92b95ce9edf3f", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/36a56a6152cdd59973d2085aa1b92b95ce9edf3f", "committedDate": "2020-02-20T22:49:08Z", "message": "Use Objects.equals\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "89b0b68e73cd6ac6453ad22d153c53de5adbb990", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/89b0b68e73cd6ac6453ad22d153c53de5adbb990", "committedDate": "2020-02-20T23:00:13Z", "message": "Parameterize tests\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8eb70121edf04cbc5865a4e46b03c78c90f5d835", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/8eb70121edf04cbc5865a4e46b03c78c90f5d835", "committedDate": "2020-02-20T23:06:53Z", "message": "Merge remote-tracking branch 'upstream/master' into feature/bls_keystore\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "243e86f145d194c7e9adfef74f006025c61948ed", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/243e86f145d194c7e9adfef74f006025c61948ed", "committedDate": "2020-02-20T23:22:33Z", "message": "fixing test\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f30daa762c4739120c244612c2c4c50411cf7832", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/f30daa762c4739120c244612c2c4c50411cf7832", "committedDate": "2020-02-20T23:22:41Z", "message": "Adding toString\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7f369e232aa5505dbc77cc5b92258b4a8c689d1c", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/7f369e232aa5505dbc77cc5b92258b4a8c689d1c", "committedDate": "2020-02-21T01:16:59Z", "message": "separate function enum\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "deb547b15ebf3031aa07e4e1daa39e4d2cdec6e7", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/deb547b15ebf3031aa07e4e1daa39e4d2cdec6e7", "committedDate": "2020-02-21T02:09:59Z", "message": "moving bls keystore to separate module\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8e652cb4782ec2c7e100fae5ea9f402c4e08ce77", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/8e652cb4782ec2c7e100fae5ea9f402c4e08ce77", "committedDate": "2020-02-21T04:29:13Z", "message": "move decryption key derivation in kdfParams\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "35cc38874ba1ca27fca987c2b4419c4b6ee7622b", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/35cc38874ba1ca27fca987c2b4419c4b6ee7622b", "committedDate": "2020-02-21T04:43:06Z", "message": "minor refactoring\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "041f80f9d54abfdbe867a51bdafecc649fb0bd6e", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/041f80f9d54abfdbe867a51bdafecc649fb0bd6e", "committedDate": "2020-02-21T05:18:48Z", "message": "salt as Bytes32\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a5a3fce22b5f0dcf34ec3087b5d19dd91f15503a", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/a5a3fce22b5f0dcf34ec3087b5d19dd91f15503a", "committedDate": "2020-02-21T06:53:13Z", "message": "encrypt keystore\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "93efe00562fd72882fdd876f820a33a2c26a8d49", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/93efe00562fd72882fdd876f820a33a2c26a8d49", "committedDate": "2020-02-21T08:04:41Z", "message": "Encrypt given secret and create keystore\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3cd477c024e7e0d94701f6579586355299079ac4", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/3cd477c024e7e0d94701f6579586355299079ac4", "committedDate": "2020-02-21T08:04:55Z", "message": "Merge remote-tracking branch 'upstream/master' into feature/bls_keystore\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1f2e01a8323f3471e3c913631fb2763e50e8a80c", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/1f2e01a8323f3471e3c913631fb2763e50e8a80c", "committedDate": "2020-02-22T07:37:45Z", "message": "supress unused warning\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e0e2143833e556cce58ef2014ac9825b4fa1769c", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/e0e2143833e556cce58ef2014ac9825b4fa1769c", "committedDate": "2020-02-22T07:38:05Z", "message": "Merge remote-tracking branch 'upstream/master' into feature/bls_keystore\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f6b7635147749b2700f4f643f5e95917bef89fa4", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/f6b7635147749b2700f4f643f5e95917bef89fa4", "committedDate": "2020-02-22T08:35:18Z", "message": "minor refactoring and adding end user callable encrypt method\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "37b1f329330f12a3b7624ca74f3a8f111ce18e68", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/37b1f329330f12a3b7624ca74f3a8f111ce18e68", "committedDate": "2020-02-22T10:08:15Z", "message": "spotless fix\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fb2c3d6d5ebdbbb0ca8a525502ce1cd72d7e61aa", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/fb2c3d6d5ebdbbb0ca8a525502ce1cd72d7e61aa", "committedDate": "2020-02-23T01:23:00Z", "message": "removing unused method\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1479ed1c39ba58f8fc2b027da101b5d87f944b3f", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/1479ed1c39ba58f8fc2b027da101b5d87f944b3f", "committedDate": "2020-02-23T01:29:25Z", "message": "final keyword\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eb83c84ed962ed4021d6400430bc9e409e7607a0", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/eb83c84ed962ed4021d6400430bc9e409e7607a0", "committedDate": "2020-02-24T00:00:29Z", "message": "refactoring\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aaecb341ef5fbfab7c8bef58d18473bf126c6689", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/aaecb341ef5fbfab7c8bef58d18473bf126c6689", "committedDate": "2020-02-24T05:09:07Z", "message": "refactoring\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "29d9e6b87011dd25922c86e72364f53aeefdf86b", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/29d9e6b87011dd25922c86e72364f53aeefdf86b", "committedDate": "2020-02-24T05:20:09Z", "message": "refactoring\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "baf6b00ff9bdb682f2c8bd33ca015074777003ed", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/baf6b00ff9bdb682f2c8bd33ca015074777003ed", "committedDate": "2020-02-24T05:20:52Z", "message": "Merge remote-tracking branch 'upstream/master' into feature/bls_keystore\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzMjA2MDM4", "url": "https://github.com/ConsenSys/teku/pull/1212#pullrequestreview-363206038", "createdAt": "2020-02-24T07:46:24Z", "commit": {"oid": "baf6b00ff9bdb682f2c8bd33ca015074777003ed"}, "state": "COMMENTED", "comments": {"totalCount": 29, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQwNzo0NjoyNFrOFtXk5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQyMzo1Nzo1MVrOFt0KRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzExNjUxNw==", "bodyText": "This should be testRuntimeOnly I think. But I think you probably want:\ntestRuntimeOnly project(path: ':logging', configuration: 'testSupportArtifacts')\nand you'll get a proper log4j config for your tests as well.", "url": "https://github.com/ConsenSys/teku/pull/1212#discussion_r383116517", "createdAt": "2020-02-24T07:46:24Z", "author": {"login": "ajsutton"}, "path": "data/keystore/build.gradle", "diffHunk": "@@ -0,0 +1,19 @@\n+jar {\n+    baseName 'artemis-data-keystore'\n+    manifest {\n+        attributes('Implementation-Title': baseName,\n+                'Implementation-Version': project.version)\n+    }\n+}\n+\n+dependencies {\n+    implementation project(\":util\")\n+\n+    implementation 'com.fasterxml.jackson.core:jackson-databind'\n+    implementation 'org.bouncycastle:bcprov-jdk15on'\n+    implementation 'com.google.guava:guava'\n+    implementation 'org.apache.logging.log4j:log4j-api'\n+    implementation 'org.apache.tuweni:tuweni-bytes'\n+    implementation 'org.apache.tuweni:tuweni-crypto'\n+    runtime 'org.apache.logging.log4j:log4j-core'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "baf6b00ff9bdb682f2c8bd33ca015074777003ed"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzExNzIwNg==", "bodyText": "Teku uses Guava's Preconditions.checkNotNull and can you please include an error message.", "url": "https://github.com/ConsenSys/teku/pull/1212#discussion_r383117206", "createdAt": "2020-02-24T07:48:47Z", "author": {"login": "ajsutton"}, "path": "data/keystore/src/main/java/tech/pegasys/artemis/bls/keystore/DecryptionKeyGenerator.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.bls.keystore;\n+\n+import java.util.Objects;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.bouncycastle.crypto.Digest;\n+import org.bouncycastle.crypto.generators.PKCS5S2ParametersGenerator;\n+import org.bouncycastle.crypto.generators.SCrypt;\n+import org.bouncycastle.crypto.params.KeyParameter;\n+import org.bouncycastle.crypto.util.DigestFactory;\n+import tech.pegasys.artemis.bls.keystore.model.KdfParam;\n+import tech.pegasys.artemis.bls.keystore.model.Pbkdf2Param;\n+import tech.pegasys.artemis.bls.keystore.model.SCryptParam;\n+\n+public class DecryptionKeyGenerator {\n+  public static Bytes generate(final byte[] password, final KdfParam kdfParam) {\n+    Objects.requireNonNull(password);\n+    Objects.requireNonNull(kdfParam);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "baf6b00ff9bdb682f2c8bd33ca015074777003ed"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzExOTAzNw==", "bodyText": "How did we wind up using a generic type all the way through down to here and then suddenly split into separate code paths with an instanceof?\nSeems like instead of static methods here we should have just had an abstract instance method on KdfParam. Or make DecryptionKeyGenerator an interface with a generic param type and two implementations - one for SCryptParam and one for Pbkdf2Param.  Basically, we should be taking advantage of the compiler's type safety.", "url": "https://github.com/ConsenSys/teku/pull/1212#discussion_r383119037", "createdAt": "2020-02-24T07:55:26Z", "author": {"login": "ajsutton"}, "path": "data/keystore/src/main/java/tech/pegasys/artemis/bls/keystore/DecryptionKeyGenerator.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.bls.keystore;\n+\n+import java.util.Objects;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.bouncycastle.crypto.Digest;\n+import org.bouncycastle.crypto.generators.PKCS5S2ParametersGenerator;\n+import org.bouncycastle.crypto.generators.SCrypt;\n+import org.bouncycastle.crypto.params.KeyParameter;\n+import org.bouncycastle.crypto.util.DigestFactory;\n+import tech.pegasys.artemis.bls.keystore.model.KdfParam;\n+import tech.pegasys.artemis.bls.keystore.model.Pbkdf2Param;\n+import tech.pegasys.artemis.bls.keystore.model.SCryptParam;\n+\n+public class DecryptionKeyGenerator {\n+  public static Bytes generate(final byte[] password, final KdfParam kdfParam) {\n+    Objects.requireNonNull(password);\n+    Objects.requireNonNull(kdfParam);\n+\n+    return kdfParam instanceof SCryptParam\n+        ? generate(password, (SCryptParam) kdfParam)\n+        : generate(password, (Pbkdf2Param) kdfParam);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "baf6b00ff9bdb682f2c8bd33ca015074777003ed"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzEyMTAxMA==", "bodyText": "Why do we support ChecksumFunction.SHA512 when it's never used in production code?", "url": "https://github.com/ConsenSys/teku/pull/1212#discussion_r383121010", "createdAt": "2020-02-24T08:02:00Z", "author": {"login": "ajsutton"}, "path": "data/keystore/src/main/java/tech/pegasys/artemis/bls/keystore/KeyStore.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.bls.keystore;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static javax.crypto.Cipher.DECRYPT_MODE;\n+import static javax.crypto.Cipher.ENCRYPT_MODE;\n+import static org.apache.tuweni.crypto.Hash.digestUsingAlgorithm;\n+import static org.apache.tuweni.crypto.Hash.sha2_256;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import java.security.GeneralSecurityException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Objects;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes48;\n+import org.bouncycastle.jce.provider.BouncyCastleProvider;\n+import tech.pegasys.artemis.bls.keystore.builder.ChecksumBuilder;\n+import tech.pegasys.artemis.bls.keystore.builder.CipherBuilder;\n+import tech.pegasys.artemis.bls.keystore.builder.KdfBuilder;\n+import tech.pegasys.artemis.bls.keystore.builder.KeyStoreDataBuilder;\n+import tech.pegasys.artemis.bls.keystore.model.Checksum;\n+import tech.pegasys.artemis.bls.keystore.model.ChecksumFunction;\n+import tech.pegasys.artemis.bls.keystore.model.Cipher;\n+import tech.pegasys.artemis.bls.keystore.model.Crypto;\n+import tech.pegasys.artemis.bls.keystore.model.Kdf;\n+import tech.pegasys.artemis.bls.keystore.model.KdfParam;\n+import tech.pegasys.artemis.bls.keystore.model.KeyStoreData;\n+import tech.pegasys.artemis.util.mikuli.PublicKey;\n+import tech.pegasys.artemis.util.mikuli.SecretKey;\n+\n+/**\n+ * BLS Key Store implementation EIP-2335\n+ *\n+ * @see <a href=\"https://github.com/ethereum/EIPs/blob/master/EIPS/eip-2335.md\">EIP-2335</a>\n+ */\n+public class KeyStore {\n+  private static final BouncyCastleProvider BC = new BouncyCastleProvider();\n+  private final KeyStoreData keyStoreData;\n+\n+  public KeyStore(final KeyStoreData keyStoreData) {\n+    this.keyStoreData = keyStoreData;\n+  }\n+\n+  public KeyStoreData getKeyStoreData() {\n+    return keyStoreData;\n+  }\n+\n+  /**\n+   * Encrypt the given BLS12-381 key with specified password.\n+   *\n+   * @param blsPrivateKey BLS12-381 private key in Bytes\n+   * @param password The password to use for encryption\n+   * @param path Path as defined in EIP-2334. Can be empty String.\n+   * @param kdfParam crypto function such as scrypt or PBKDF2 and related parameters such as dklen,\n+   *     salt etc.\n+   * @param cipher cipher function and parameters such as iv. Message is ignored.\n+   * @return The constructed KeyStore with encrypted BLS Private Key as cipher.message and other\n+   *     details as defined by the EIP-2335 standard.\n+   */\n+  public static KeyStore encrypt(\n+      final Bytes blsPrivateKey,\n+      final String password,\n+      final String path,\n+      final KdfParam kdfParam,\n+      final Cipher cipher) {\n+\n+    final Crypto crypto =\n+        encryptUsingCipherFunction(\n+            blsPrivateKey, password, kdfParam, cipher, ChecksumFunction.SHA256);\n+    final Bytes pubKey =\n+        new PublicKey(SecretKey.fromBytes(Bytes48.leftPad(blsPrivateKey))).toBytesCompressed();\n+    final KeyStoreData keyStoreData =\n+        KeyStoreDataBuilder.aKeyStoreData()\n+            .withCrypto(crypto)\n+            .withPath(path)\n+            .withPubkey(pubKey)\n+            .build();\n+\n+    return new KeyStore(keyStoreData);\n+  }\n+\n+  @VisibleForTesting\n+  static Crypto encryptUsingCipherFunction(\n+      final Bytes secret,\n+      final String password,\n+      final KdfParam kdfParam,\n+      final Cipher cipher,\n+      final ChecksumFunction checksumFunction) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "baf6b00ff9bdb682f2c8bd33ca015074777003ed"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU2OTEwMw==", "bodyText": "nit: checkNotNull", "url": "https://github.com/ConsenSys/teku/pull/1212#discussion_r383569103", "createdAt": "2020-02-24T23:09:48Z", "author": {"login": "ajsutton"}, "path": "data/keystore/src/main/java/tech/pegasys/artemis/bls/keystore/KeyStore.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.bls.keystore;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static javax.crypto.Cipher.DECRYPT_MODE;\n+import static javax.crypto.Cipher.ENCRYPT_MODE;\n+import static org.apache.tuweni.crypto.Hash.digestUsingAlgorithm;\n+import static org.apache.tuweni.crypto.Hash.sha2_256;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import java.security.GeneralSecurityException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Objects;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes48;\n+import org.bouncycastle.jce.provider.BouncyCastleProvider;\n+import tech.pegasys.artemis.bls.keystore.builder.ChecksumBuilder;\n+import tech.pegasys.artemis.bls.keystore.builder.CipherBuilder;\n+import tech.pegasys.artemis.bls.keystore.builder.KdfBuilder;\n+import tech.pegasys.artemis.bls.keystore.builder.KeyStoreDataBuilder;\n+import tech.pegasys.artemis.bls.keystore.model.Checksum;\n+import tech.pegasys.artemis.bls.keystore.model.ChecksumFunction;\n+import tech.pegasys.artemis.bls.keystore.model.Cipher;\n+import tech.pegasys.artemis.bls.keystore.model.Crypto;\n+import tech.pegasys.artemis.bls.keystore.model.Kdf;\n+import tech.pegasys.artemis.bls.keystore.model.KdfParam;\n+import tech.pegasys.artemis.bls.keystore.model.KeyStoreData;\n+import tech.pegasys.artemis.util.mikuli.PublicKey;\n+import tech.pegasys.artemis.util.mikuli.SecretKey;\n+\n+/**\n+ * BLS Key Store implementation EIP-2335\n+ *\n+ * @see <a href=\"https://github.com/ethereum/EIPs/blob/master/EIPS/eip-2335.md\">EIP-2335</a>\n+ */\n+public class KeyStore {\n+  private static final BouncyCastleProvider BC = new BouncyCastleProvider();\n+  private final KeyStoreData keyStoreData;\n+\n+  public KeyStore(final KeyStoreData keyStoreData) {\n+    this.keyStoreData = keyStoreData;\n+  }\n+\n+  public KeyStoreData getKeyStoreData() {\n+    return keyStoreData;\n+  }\n+\n+  /**\n+   * Encrypt the given BLS12-381 key with specified password.\n+   *\n+   * @param blsPrivateKey BLS12-381 private key in Bytes\n+   * @param password The password to use for encryption\n+   * @param path Path as defined in EIP-2334. Can be empty String.\n+   * @param kdfParam crypto function such as scrypt or PBKDF2 and related parameters such as dklen,\n+   *     salt etc.\n+   * @param cipher cipher function and parameters such as iv. Message is ignored.\n+   * @return The constructed KeyStore with encrypted BLS Private Key as cipher.message and other\n+   *     details as defined by the EIP-2335 standard.\n+   */\n+  public static KeyStore encrypt(\n+      final Bytes blsPrivateKey,\n+      final String password,\n+      final String path,\n+      final KdfParam kdfParam,\n+      final Cipher cipher) {\n+\n+    final Crypto crypto =\n+        encryptUsingCipherFunction(\n+            blsPrivateKey, password, kdfParam, cipher, ChecksumFunction.SHA256);\n+    final Bytes pubKey =\n+        new PublicKey(SecretKey.fromBytes(Bytes48.leftPad(blsPrivateKey))).toBytesCompressed();\n+    final KeyStoreData keyStoreData =\n+        KeyStoreDataBuilder.aKeyStoreData()\n+            .withCrypto(crypto)\n+            .withPath(path)\n+            .withPubkey(pubKey)\n+            .build();\n+\n+    return new KeyStore(keyStoreData);\n+  }\n+\n+  @VisibleForTesting\n+  static Crypto encryptUsingCipherFunction(\n+      final Bytes secret,\n+      final String password,\n+      final KdfParam kdfParam,\n+      final Cipher cipher,\n+      final ChecksumFunction checksumFunction) {\n+    checkArgument(\n+        kdfParam.getDerivedKeyLength() > 16, \"aes-128-ctr requires kdf dklen greater than 16\");\n+\n+    final Bytes decryptionKey = DecryptionKeyGenerator.generate(password.getBytes(UTF_8), kdfParam);\n+    final Bytes cipherMessage =\n+        applyCipherFunction(\n+            decryptionKey, cipher.getCipherParam().getIv(), true, secret.toArrayUnsafe());\n+    final Bytes checksumMessage =\n+        calculateChecksum(kdfParam, checksumFunction, decryptionKey, cipherMessage);\n+    final Checksum checksum =\n+        ChecksumBuilder.aChecksum()\n+            .withChecksumFunction(checksumFunction)\n+            .withMessage(checksumMessage)\n+            .build();\n+    final Cipher encryptedCipher =\n+        CipherBuilder.aCipher()\n+            .withCipherFunction(cipher.getCipherFunction())\n+            .withCipherParam(cipher.getCipherParam())\n+            .withMessage(cipherMessage)\n+            .build();\n+    final Kdf kdf = KdfBuilder.aKdf().withParam(kdfParam).build();\n+    return new Crypto(kdf, checksum, encryptedCipher);\n+  }\n+\n+  public Bytes decrypt(final String password) {\n+    Objects.requireNonNull(password);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "baf6b00ff9bdb682f2c8bd33ca015074777003ed"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU2OTc0Mw==", "bodyText": "We should be consistent in calling this dklen or derivedKeyLength not mix the two.", "url": "https://github.com/ConsenSys/teku/pull/1212#discussion_r383569743", "createdAt": "2020-02-24T23:11:37Z", "author": {"login": "ajsutton"}, "path": "data/keystore/src/main/java/tech/pegasys/artemis/bls/keystore/model/KdfParam.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.bls.keystore.model;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.base.MoreObjects;\n+import org.apache.tuweni.bytes.Bytes32;\n+\n+public abstract class KdfParam extends Param {\n+  private final Integer dklen;\n+  private final Bytes32 salt;\n+\n+  public KdfParam(final Integer dklen, final Bytes32 salt) {\n+    this.dklen = dklen;\n+    this.salt = salt;\n+  }\n+\n+  @JsonProperty(value = \"dklen\")\n+  public Integer getDerivedKeyLength() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "baf6b00ff9bdb682f2c8bd33ca015074777003ed"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU3MjkwOQ==", "bodyText": "We probably shouldn't be throwing a generic Exception through this class.  Likely we need a custom exception so that the Jackson specific exceptions remain encapsulated (ie users of this class shouldn't care if we're using Jackson or gson or some other json parsing library).", "url": "https://github.com/ConsenSys/teku/pull/1212#discussion_r383572909", "createdAt": "2020-02-24T23:20:49Z", "author": {"login": "ajsutton"}, "path": "data/keystore/src/main/java/tech/pegasys/artemis/bls/keystore/KeyStoreLoader.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.bls.keystore;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.artemis.bls.keystore.model.KeyStoreData;\n+\n+/** Provide utility methods to load/store BLS KeyStore from json format */\n+public class KeyStoreLoader {\n+  private static final ObjectMapper OBJECT_MAPPER =\n+      new ObjectMapper().registerModule(new KeyStoreBytesModule());\n+\n+  public static KeyStore loadFromJson(final String json) throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "baf6b00ff9bdb682f2c8bd33ca015074777003ed"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU3MzA2OQ==", "bodyText": "nit: Preconditions.checkNotNull through this class.", "url": "https://github.com/ConsenSys/teku/pull/1212#discussion_r383573069", "createdAt": "2020-02-24T23:21:14Z", "author": {"login": "ajsutton"}, "path": "data/keystore/src/main/java/tech/pegasys/artemis/bls/keystore/KeyStoreLoader.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.bls.keystore;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.artemis.bls.keystore.model.KeyStoreData;\n+\n+/** Provide utility methods to load/store BLS KeyStore from json format */\n+public class KeyStoreLoader {\n+  private static final ObjectMapper OBJECT_MAPPER =\n+      new ObjectMapper().registerModule(new KeyStoreBytesModule());\n+\n+  public static KeyStore loadFromJson(final String json) throws Exception {\n+    requireNonNull(json);\n+    final KeyStoreData keyStoreData = OBJECT_MAPPER.readValue(json, KeyStoreData.class);\n+    checkArgument(keyStoreData.getVersion() == 4, \"Key Store version 4 is supported.\");\n+    return new KeyStore(keyStoreData);\n+  }\n+\n+  public static KeyStore loadFromFile(final Path keystoreFile) throws Exception {\n+    requireNonNull(keystoreFile);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "baf6b00ff9bdb682f2c8bd33ca015074777003ed"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU3NDk1MQ==", "bodyText": "I'm not sure that an IllegalArgumentException is the right thing to do when the format is unsupported. It probably should be the same exception as we wind up throwing for invalid content (with clear message) so it's clear the user input was invalid vs a programmer error passing in values that should never have been passed to this function.\nBasically the CLI is going to need to identify these failures as something it should report back to the user in a nice way and it can't do that if it gets very generic exception types.\nApplies to the other version checks in this file too.", "url": "https://github.com/ConsenSys/teku/pull/1212#discussion_r383574951", "createdAt": "2020-02-24T23:26:43Z", "author": {"login": "ajsutton"}, "path": "data/keystore/src/main/java/tech/pegasys/artemis/bls/keystore/KeyStoreLoader.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.bls.keystore;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.artemis.bls.keystore.model.KeyStoreData;\n+\n+/** Provide utility methods to load/store BLS KeyStore from json format */\n+public class KeyStoreLoader {\n+  private static final ObjectMapper OBJECT_MAPPER =\n+      new ObjectMapper().registerModule(new KeyStoreBytesModule());\n+\n+  public static KeyStore loadFromJson(final String json) throws Exception {\n+    requireNonNull(json);\n+    final KeyStoreData keyStoreData = OBJECT_MAPPER.readValue(json, KeyStoreData.class);\n+    checkArgument(keyStoreData.getVersion() == 4, \"Key Store version 4 is supported.\");\n+    return new KeyStore(keyStoreData);\n+  }\n+\n+  public static KeyStore loadFromFile(final Path keystoreFile) throws Exception {\n+    requireNonNull(keystoreFile);\n+    final KeyStoreData keyStoreData =\n+        OBJECT_MAPPER.readValue(keystoreFile.toFile(), KeyStoreData.class);\n+    checkArgument(keyStoreData.getVersion() == 4, \"Key Store version 4 is supported.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "baf6b00ff9bdb682f2c8bd33ca015074777003ed"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU3NTYzMQ==", "bodyText": "I'd split this into its own package private class.", "url": "https://github.com/ConsenSys/teku/pull/1212#discussion_r383575631", "createdAt": "2020-02-24T23:28:47Z", "author": {"login": "ajsutton"}, "path": "data/keystore/src/main/java/tech/pegasys/artemis/bls/keystore/KeyStoreLoader.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.bls.keystore;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.artemis.bls.keystore.model.KeyStoreData;\n+\n+/** Provide utility methods to load/store BLS KeyStore from json format */\n+public class KeyStoreLoader {\n+  private static final ObjectMapper OBJECT_MAPPER =\n+      new ObjectMapper().registerModule(new KeyStoreBytesModule());\n+\n+  public static KeyStore loadFromJson(final String json) throws Exception {\n+    requireNonNull(json);\n+    final KeyStoreData keyStoreData = OBJECT_MAPPER.readValue(json, KeyStoreData.class);\n+    checkArgument(keyStoreData.getVersion() == 4, \"Key Store version 4 is supported.\");\n+    return new KeyStore(keyStoreData);\n+  }\n+\n+  public static KeyStore loadFromFile(final Path keystoreFile) throws Exception {\n+    requireNonNull(keystoreFile);\n+    final KeyStoreData keyStoreData =\n+        OBJECT_MAPPER.readValue(keystoreFile.toFile(), KeyStoreData.class);\n+    checkArgument(keyStoreData.getVersion() == 4, \"Key Store version 4 is supported.\");\n+    return new KeyStore(keyStoreData);\n+  }\n+\n+  public static String toJson(final KeyStoreData keyStoreData) throws Exception {\n+    requireNonNull(keyStoreData);\n+    checkArgument(keyStoreData.getVersion() == 4, \"Key Store version 4 is supported.\");\n+    return KeyStoreLoader.OBJECT_MAPPER\n+        .writerWithDefaultPrettyPrinter()\n+        .writeValueAsString(keyStoreData);\n+  }\n+\n+  private static class KeyStoreBytesModule extends SimpleModule {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "baf6b00ff9bdb682f2c8bd33ca015074777003ed"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU3NTg1MQ==", "bodyText": "Are these serialisers the same as the ones needed by the REST API?  Should they be reused?", "url": "https://github.com/ConsenSys/teku/pull/1212#discussion_r383575851", "createdAt": "2020-02-24T23:29:29Z", "author": {"login": "ajsutton"}, "path": "data/keystore/src/main/java/tech/pegasys/artemis/bls/keystore/KeyStoreLoader.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.bls.keystore;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.artemis.bls.keystore.model.KeyStoreData;\n+\n+/** Provide utility methods to load/store BLS KeyStore from json format */\n+public class KeyStoreLoader {\n+  private static final ObjectMapper OBJECT_MAPPER =\n+      new ObjectMapper().registerModule(new KeyStoreBytesModule());\n+\n+  public static KeyStore loadFromJson(final String json) throws Exception {\n+    requireNonNull(json);\n+    final KeyStoreData keyStoreData = OBJECT_MAPPER.readValue(json, KeyStoreData.class);\n+    checkArgument(keyStoreData.getVersion() == 4, \"Key Store version 4 is supported.\");\n+    return new KeyStore(keyStoreData);\n+  }\n+\n+  public static KeyStore loadFromFile(final Path keystoreFile) throws Exception {\n+    requireNonNull(keystoreFile);\n+    final KeyStoreData keyStoreData =\n+        OBJECT_MAPPER.readValue(keystoreFile.toFile(), KeyStoreData.class);\n+    checkArgument(keyStoreData.getVersion() == 4, \"Key Store version 4 is supported.\");\n+    return new KeyStore(keyStoreData);\n+  }\n+\n+  public static String toJson(final KeyStoreData keyStoreData) throws Exception {\n+    requireNonNull(keyStoreData);\n+    checkArgument(keyStoreData.getVersion() == 4, \"Key Store version 4 is supported.\");\n+    return KeyStoreLoader.OBJECT_MAPPER\n+        .writerWithDefaultPrettyPrinter()\n+        .writeValueAsString(keyStoreData);\n+  }\n+\n+  private static class KeyStoreBytesModule extends SimpleModule {\n+    public KeyStoreBytesModule() {\n+      super(\"KeystoreBytes\");\n+      addSerializer(Bytes.class, new BytesSerializer());\n+      addDeserializer(Bytes.class, new BytesDeserializer());\n+      addSerializer(Bytes32.class, new Bytes32Serializer());\n+      addDeserializer(Bytes32.class, new Bytes32Deserializer());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "baf6b00ff9bdb682f2c8bd33ca015074777003ed"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU3NjE5MQ==", "bodyText": "This builder doesn't really seem warranted.  I'd just call the 3-arg constructor directly.", "url": "https://github.com/ConsenSys/teku/pull/1212#discussion_r383576191", "createdAt": "2020-02-24T23:30:34Z", "author": {"login": "ajsutton"}, "path": "data/keystore/src/main/java/tech/pegasys/artemis/bls/keystore/builder/ChecksumBuilder.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.bls.keystore.builder;\n+\n+import java.util.Objects;\n+import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.artemis.bls.keystore.model.Checksum;\n+import tech.pegasys.artemis.bls.keystore.model.ChecksumFunction;\n+import tech.pegasys.artemis.bls.keystore.model.Param;\n+\n+public final class ChecksumBuilder {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "baf6b00ff9bdb682f2c8bd33ca015074777003ed"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU3NzM4Mg==", "bodyText": "This builder doesn't seem worth it either.", "url": "https://github.com/ConsenSys/teku/pull/1212#discussion_r383577382", "createdAt": "2020-02-24T23:34:03Z", "author": {"login": "ajsutton"}, "path": "data/keystore/src/main/java/tech/pegasys/artemis/bls/keystore/builder/CipherBuilder.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.bls.keystore.builder;\n+\n+import java.util.Objects;\n+import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.artemis.bls.keystore.model.Cipher;\n+import tech.pegasys.artemis.bls.keystore.model.CipherFunction;\n+import tech.pegasys.artemis.bls.keystore.model.CipherParam;\n+\n+public final class CipherBuilder {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "baf6b00ff9bdb682f2c8bd33ca015074777003ed"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU3Nzg1MA==", "bodyText": "This builder is definitely not worth it.", "url": "https://github.com/ConsenSys/teku/pull/1212#discussion_r383577850", "createdAt": "2020-02-24T23:35:32Z", "author": {"login": "ajsutton"}, "path": "data/keystore/src/main/java/tech/pegasys/artemis/bls/keystore/builder/CipherParamBuilder.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.bls.keystore.builder;\n+\n+import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.artemis.bls.keystore.model.CipherParam;\n+\n+public final class CipherParamBuilder {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "baf6b00ff9bdb682f2c8bd33ca015074777003ed"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU3ODEwOA==", "bodyText": "We shouldn't be doing instanceof here.  KdfParam should just have a getCryptoFunction method.", "url": "https://github.com/ConsenSys/teku/pull/1212#discussion_r383578108", "createdAt": "2020-02-24T23:36:25Z", "author": {"login": "ajsutton"}, "path": "data/keystore/src/main/java/tech/pegasys/artemis/bls/keystore/builder/KdfBuilder.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.bls.keystore.builder;\n+\n+import java.util.Objects;\n+import tech.pegasys.artemis.bls.keystore.model.CryptoFunction;\n+import tech.pegasys.artemis.bls.keystore.model.Kdf;\n+import tech.pegasys.artemis.bls.keystore.model.KdfParam;\n+import tech.pegasys.artemis.bls.keystore.model.SCryptParam;\n+\n+public final class KdfBuilder {\n+  private CryptoFunction cryptoFunction;\n+  private KdfParam param;\n+\n+  private KdfBuilder() {}\n+\n+  public static KdfBuilder aKdf() {\n+    return new KdfBuilder();\n+  }\n+\n+  public KdfBuilder withParam(final KdfParam param) {\n+    this.param = param;\n+    return this;\n+  }\n+\n+  public Kdf build() {\n+    Objects.requireNonNull(param);\n+    cryptoFunction = param instanceof SCryptParam ? CryptoFunction.SCRYPT : CryptoFunction.PBKDF2;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "baf6b00ff9bdb682f2c8bd33ca015074777003ed"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU3ODI2MA==", "bodyText": "Once you get rid of the instanceof this builder doesn't seem worth it.", "url": "https://github.com/ConsenSys/teku/pull/1212#discussion_r383578260", "createdAt": "2020-02-24T23:36:54Z", "author": {"login": "ajsutton"}, "path": "data/keystore/src/main/java/tech/pegasys/artemis/bls/keystore/builder/KdfBuilder.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.bls.keystore.builder;\n+\n+import java.util.Objects;\n+import tech.pegasys.artemis.bls.keystore.model.CryptoFunction;\n+import tech.pegasys.artemis.bls.keystore.model.Kdf;\n+import tech.pegasys.artemis.bls.keystore.model.KdfParam;\n+import tech.pegasys.artemis.bls.keystore.model.SCryptParam;\n+\n+public final class KdfBuilder {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "baf6b00ff9bdb682f2c8bd33ca015074777003ed"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU3ODM5MQ==", "bodyText": "Just set \"\" as the initial value for path rather than checking for null here.", "url": "https://github.com/ConsenSys/teku/pull/1212#discussion_r383578391", "createdAt": "2020-02-24T23:37:22Z", "author": {"login": "ajsutton"}, "path": "data/keystore/src/main/java/tech/pegasys/artemis/bls/keystore/builder/KeyStoreDataBuilder.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.bls.keystore.builder;\n+\n+import java.util.Objects;\n+import java.util.UUID;\n+import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.artemis.bls.keystore.model.Crypto;\n+import tech.pegasys.artemis.bls.keystore.model.KeyStoreData;\n+\n+public final class KeyStoreDataBuilder {\n+  private Crypto crypto;\n+  private Bytes pubkey;\n+  private String path;\n+  private UUID uuid;\n+\n+  private KeyStoreDataBuilder() {}\n+\n+  public static KeyStoreDataBuilder aKeyStoreData() {\n+    return new KeyStoreDataBuilder();\n+  }\n+\n+  public KeyStoreDataBuilder withCrypto(Crypto crypto) {\n+    this.crypto = crypto;\n+    return this;\n+  }\n+\n+  public KeyStoreDataBuilder withPubkey(Bytes pubkey) {\n+    this.pubkey = pubkey;\n+    return this;\n+  }\n+\n+  public KeyStoreDataBuilder withPath(String path) {\n+    this.path = path;\n+    return this;\n+  }\n+\n+  public KeyStoreDataBuilder withUuid(UUID uuid) {\n+    this.uuid = uuid;\n+    return this;\n+  }\n+\n+  public KeyStoreData build() {\n+    Objects.requireNonNull(crypto);\n+    Objects.requireNonNull(pubkey);\n+    if (uuid == null) {\n+      uuid = UUID.randomUUID();\n+    }\n+\n+    if (path == null) {\n+      path = \"\";\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "baf6b00ff9bdb682f2c8bd33ca015074777003ed"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU3ODQ3MQ==", "bodyText": "What's the magic 4 for? Probably should be a constant.", "url": "https://github.com/ConsenSys/teku/pull/1212#discussion_r383578471", "createdAt": "2020-02-24T23:37:37Z", "author": {"login": "ajsutton"}, "path": "data/keystore/src/main/java/tech/pegasys/artemis/bls/keystore/builder/KeyStoreDataBuilder.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.bls.keystore.builder;\n+\n+import java.util.Objects;\n+import java.util.UUID;\n+import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.artemis.bls.keystore.model.Crypto;\n+import tech.pegasys.artemis.bls.keystore.model.KeyStoreData;\n+\n+public final class KeyStoreDataBuilder {\n+  private Crypto crypto;\n+  private Bytes pubkey;\n+  private String path;\n+  private UUID uuid;\n+\n+  private KeyStoreDataBuilder() {}\n+\n+  public static KeyStoreDataBuilder aKeyStoreData() {\n+    return new KeyStoreDataBuilder();\n+  }\n+\n+  public KeyStoreDataBuilder withCrypto(Crypto crypto) {\n+    this.crypto = crypto;\n+    return this;\n+  }\n+\n+  public KeyStoreDataBuilder withPubkey(Bytes pubkey) {\n+    this.pubkey = pubkey;\n+    return this;\n+  }\n+\n+  public KeyStoreDataBuilder withPath(String path) {\n+    this.path = path;\n+    return this;\n+  }\n+\n+  public KeyStoreDataBuilder withUuid(UUID uuid) {\n+    this.uuid = uuid;\n+    return this;\n+  }\n+\n+  public KeyStoreData build() {\n+    Objects.requireNonNull(crypto);\n+    Objects.requireNonNull(pubkey);\n+    if (uuid == null) {\n+      uuid = UUID.randomUUID();\n+    }\n+\n+    if (path == null) {\n+      path = \"\";\n+    }\n+    return new KeyStoreData(crypto, pubkey, path, uuid, 4);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "baf6b00ff9bdb682f2c8bd33ca015074777003ed"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU3ODYxNw==", "bodyText": "I suspect this is the magic 4 from below that should be a constant somewhere.", "url": "https://github.com/ConsenSys/teku/pull/1212#discussion_r383578617", "createdAt": "2020-02-24T23:38:04Z", "author": {"login": "ajsutton"}, "path": "data/keystore/src/main/java/tech/pegasys/artemis/bls/keystore/KeyStoreLoader.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.bls.keystore;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.JsonSerializer;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.module.SimpleModule;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.artemis.bls.keystore.model.KeyStoreData;\n+\n+/** Provide utility methods to load/store BLS KeyStore from json format */\n+public class KeyStoreLoader {\n+  private static final ObjectMapper OBJECT_MAPPER =\n+      new ObjectMapper().registerModule(new KeyStoreBytesModule());\n+\n+  public static KeyStore loadFromJson(final String json) throws Exception {\n+    requireNonNull(json);\n+    final KeyStoreData keyStoreData = OBJECT_MAPPER.readValue(json, KeyStoreData.class);\n+    checkArgument(keyStoreData.getVersion() == 4, \"Key Store version 4 is supported.\");\n+    return new KeyStore(keyStoreData);\n+  }\n+\n+  public static KeyStore loadFromFile(final Path keystoreFile) throws Exception {\n+    requireNonNull(keystoreFile);\n+    final KeyStoreData keyStoreData =\n+        OBJECT_MAPPER.readValue(keystoreFile.toFile(), KeyStoreData.class);\n+    checkArgument(keyStoreData.getVersion() == 4, \"Key Store version 4 is supported.\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU3NDk1MQ=="}, "originalCommit": {"oid": "baf6b00ff9bdb682f2c8bd33ca015074777003ed"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU4MDMyNQ==", "bodyText": "Weird to have a default value and be required. Is this just Jackson's API being weird or have we got something wrong here?", "url": "https://github.com/ConsenSys/teku/pull/1212#discussion_r383580325", "createdAt": "2020-02-24T23:43:48Z", "author": {"login": "ajsutton"}, "path": "data/keystore/src/main/java/tech/pegasys/artemis/bls/keystore/model/KeyStoreData.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.bls.keystore.model;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.base.MoreObjects;\n+import java.util.UUID;\n+import org.apache.tuweni.bytes.Bytes;\n+\n+/**\n+ * BLS Key Store with Jackson Bindings as per json schema.\n+ *\n+ * @see <a href=\"https://github.com/ethereum/EIPs/blob/master/EIPS/eip-2335.md\">EIP-2335</a>\n+ */\n+public class KeyStoreData {\n+  private final Crypto crypto;\n+  private final Bytes pubkey;\n+  private final String path;\n+  private final UUID uuid;\n+  private final Integer version;\n+\n+  public KeyStoreData(\n+      @JsonProperty(value = \"crypto\", required = true) final Crypto crypto,\n+      @JsonProperty(value = \"pubkey\", required = true) final Bytes pubkey,\n+      @JsonProperty(value = \"path\", required = true) final String path,\n+      @JsonProperty(value = \"uuid\", required = true) final UUID uuid,\n+      @JsonProperty(value = \"version\", required = true, defaultValue = \"4\") final Integer version) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "baf6b00ff9bdb682f2c8bd33ca015074777003ed"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU4MTUwOA==", "bodyText": "Can we use a method name that actually says something about what we're testing.  I think the intent is to check key values are 32 bytes long regardless of the function used.", "url": "https://github.com/ConsenSys/teku/pull/1212#discussion_r383581508", "createdAt": "2020-02-24T23:47:30Z", "author": {"login": "ajsutton"}, "path": "data/keystore/src/test/java/tech/pegasys/artemis/bls/keystore/DecryptionKeyGeneratorTest.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.bls.keystore;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import java.util.stream.Stream;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import tech.pegasys.artemis.bls.keystore.builder.Pbkdf2ParamBuilder;\n+import tech.pegasys.artemis.bls.keystore.builder.SCryptParamBuilder;\n+import tech.pegasys.artemis.bls.keystore.model.KdfParam;\n+import tech.pegasys.artemis.bls.keystore.model.Pbkdf2Param;\n+import tech.pegasys.artemis.bls.keystore.model.Pbkdf2PseudoRandomFunction;\n+import tech.pegasys.artemis.bls.keystore.model.SCryptParam;\n+\n+class DecryptionKeyGeneratorTest {\n+  private static final Bytes32 SALT =\n+      Bytes32.fromHexString(\"d4e56740f876aef8c010b86a40d5f56745a118d0906a34e69aec8c0db1cb8fa3\");\n+\n+  @Test\n+  void defaultDkLen() {\n+    final SCryptParam kdfParam = SCryptParamBuilder.aSCryptParam().withSalt(SALT).build();\n+    final Bytes decryptionKey =\n+        DecryptionKeyGenerator.generate(Bytes.random(264).toArrayUnsafe(), kdfParam);\n+    assertEquals(32, decryptionKey.size());\n+  }\n+\n+  @SuppressWarnings(\"UnusedMethod\")\n+  private static Stream<Arguments> basicKdfParam() {\n+    return Stream.of(\n+        Arguments.of(SCryptParamBuilder.aSCryptParam().withDklen(128).build()),\n+        Arguments.of(Pbkdf2ParamBuilder.aPbkdf2Param().withDklen(128).build()));\n+  }\n+\n+  @ParameterizedTest\n+  @MethodSource(\"basicKdfParam\")\n+  void nonDefaultDkLen(final KdfParam kdfParam) {\n+    final Bytes decryptionKey =\n+        DecryptionKeyGenerator.generate(\"testpassword\".getBytes(UTF_8), kdfParam);\n+    assertEquals(128, decryptionKey.size());\n+  }\n+\n+  @ParameterizedTest\n+  @EnumSource(Pbkdf2PseudoRandomFunction.class)\n+  void pbkdf2Prf(final Pbkdf2PseudoRandomFunction prf) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "baf6b00ff9bdb682f2c8bd33ca015074777003ed"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU4MjA4OA==", "bodyText": "I'm not convinced the two different options really warrant using parameterised tests here.  I'd just have one test for each of the two KdfParam types - makes it much simpler to understand and almost the same amount of code.", "url": "https://github.com/ConsenSys/teku/pull/1212#discussion_r383582088", "createdAt": "2020-02-24T23:49:22Z", "author": {"login": "ajsutton"}, "path": "data/keystore/src/test/java/tech/pegasys/artemis/bls/keystore/DecryptionKeyGeneratorTest.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.bls.keystore;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import java.util.stream.Stream;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import tech.pegasys.artemis.bls.keystore.builder.Pbkdf2ParamBuilder;\n+import tech.pegasys.artemis.bls.keystore.builder.SCryptParamBuilder;\n+import tech.pegasys.artemis.bls.keystore.model.KdfParam;\n+import tech.pegasys.artemis.bls.keystore.model.Pbkdf2Param;\n+import tech.pegasys.artemis.bls.keystore.model.Pbkdf2PseudoRandomFunction;\n+import tech.pegasys.artemis.bls.keystore.model.SCryptParam;\n+\n+class DecryptionKeyGeneratorTest {\n+  private static final Bytes32 SALT =\n+      Bytes32.fromHexString(\"d4e56740f876aef8c010b86a40d5f56745a118d0906a34e69aec8c0db1cb8fa3\");\n+\n+  @Test\n+  void defaultDkLen() {\n+    final SCryptParam kdfParam = SCryptParamBuilder.aSCryptParam().withSalt(SALT).build();\n+    final Bytes decryptionKey =\n+        DecryptionKeyGenerator.generate(Bytes.random(264).toArrayUnsafe(), kdfParam);\n+    assertEquals(32, decryptionKey.size());\n+  }\n+\n+  @SuppressWarnings(\"UnusedMethod\")\n+  private static Stream<Arguments> basicKdfParam() {\n+    return Stream.of(\n+        Arguments.of(SCryptParamBuilder.aSCryptParam().withDklen(128).build()),\n+        Arguments.of(Pbkdf2ParamBuilder.aPbkdf2Param().withDklen(128).build()));\n+  }\n+\n+  @ParameterizedTest\n+  @MethodSource(\"basicKdfParam\")\n+  void nonDefaultDkLen(final KdfParam kdfParam) {\n+    final Bytes decryptionKey =\n+        DecryptionKeyGenerator.generate(\"testpassword\".getBytes(UTF_8), kdfParam);\n+    assertEquals(128, decryptionKey.size());\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "baf6b00ff9bdb682f2c8bd33ca015074777003ed"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU4MjkwMA==", "bodyText": "It would be way simpler to read if we just extract a private method for the assertions and had two separate test methods for each test keystone path.  Avoids all the complexity of wrapping and unwrapping through the parameterised test machinery.", "url": "https://github.com/ConsenSys/teku/pull/1212#discussion_r383582900", "createdAt": "2020-02-24T23:51:46Z", "author": {"login": "ajsutton"}, "path": "data/keystore/src/test/java/tech/pegasys/artemis/bls/keystore/KeyStoreTest.java", "diffHunk": "@@ -0,0 +1,262 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.bls.keystore;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static tech.pegasys.artemis.bls.keystore.model.CipherFunction.AES_128_CTR;\n+import static tech.pegasys.artemis.bls.keystore.model.CryptoFunction.PBKDF2;\n+import static tech.pegasys.artemis.bls.keystore.model.CryptoFunction.SCRYPT;\n+\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.google.common.io.Resources;\n+import java.net.URISyntaxException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.stream.Stream;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import tech.pegasys.artemis.bls.keystore.builder.CipherBuilder;\n+import tech.pegasys.artemis.bls.keystore.builder.CipherParamBuilder;\n+import tech.pegasys.artemis.bls.keystore.builder.Pbkdf2ParamBuilder;\n+import tech.pegasys.artemis.bls.keystore.builder.SCryptParamBuilder;\n+import tech.pegasys.artemis.bls.keystore.model.ChecksumFunction;\n+import tech.pegasys.artemis.bls.keystore.model.Cipher;\n+import tech.pegasys.artemis.bls.keystore.model.CipherParam;\n+import tech.pegasys.artemis.bls.keystore.model.Crypto;\n+import tech.pegasys.artemis.bls.keystore.model.CryptoFunction;\n+import tech.pegasys.artemis.bls.keystore.model.KdfParam;\n+import tech.pegasys.artemis.bls.keystore.model.KeyStoreData;\n+import tech.pegasys.artemis.bls.keystore.model.Pbkdf2Param;\n+import tech.pegasys.artemis.bls.keystore.model.SCryptParam;\n+\n+class KeyStoreTest {\n+  private static final String PASSWORD = \"testpassword\";\n+  private static final Bytes BLS_PRIVATE_KEY =\n+      Bytes.fromHexString(\"0x000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f\");\n+  private static final Bytes32 SALT =\n+      Bytes32.fromHexString(\"d4e56740f876aef8c010b86a40d5f56745a118d0906a34e69aec8c0db1cb8fa3\");\n+  private static final Bytes AES_IV_PARAM = Bytes.fromHexString(\"264daa3f303d7259501c93d997d84fe6\");\n+\n+  private static final String scryptTestVectorJsonResource = \"scryptTestVector.json\";\n+  private static final String pbkdf2TestVectorJsonResource = \"pbkdf2TestVector.json\";\n+  private static final String missingKdfParamTestVectorJsonResource =\n+      \"missingKdfSectionTestVector.json\";\n+  private static final String unsupportedChecksumFunctionJsonResource =\n+      \"unsupportedChecksumFunction.json\";\n+\n+  @SuppressWarnings(\"UnusedMethod\")\n+  private static Stream<Arguments> keystorePaths() {\n+    try {\n+      final Path scryptTestVectorPath =\n+          Paths.get(Resources.getResource(scryptTestVectorJsonResource).toURI());\n+      final Path pbkdf2TestVectorPath =\n+          Paths.get(Resources.getResource(pbkdf2TestVectorJsonResource).toURI());\n+      return Stream.of(Arguments.of(scryptTestVectorPath), Arguments.of(pbkdf2TestVectorPath));\n+    } catch (URISyntaxException e) {\n+      throw new IllegalStateException(e);\n+    }\n+  }\n+\n+  @SuppressWarnings(\"UnusedMethod\")\n+  private static Stream<Arguments> invalidKeyStorePaths() {\n+    try {\n+      final Path scryptTestVectorPath =\n+          Paths.get(Resources.getResource(missingKdfParamTestVectorJsonResource).toURI());\n+      final Path pbkdf2TestVectorPath =\n+          Paths.get(Resources.getResource(unsupportedChecksumFunctionJsonResource).toURI());\n+      return Stream.of(Arguments.of(scryptTestVectorPath), Arguments.of(pbkdf2TestVectorPath));\n+    } catch (URISyntaxException e) {\n+      throw new IllegalStateException(e);\n+    }\n+  }\n+\n+  @SuppressWarnings(\"UnusedMethod\")\n+  private static Stream<Arguments> kdfParams() {\n+    // KdfParam, expected checksum, expected encrypted cipher message\n+    return Stream.of(\n+        Arguments.of(\n+            SCryptParamBuilder.aSCryptParam().withSalt(SALT).build(),\n+            Bytes.fromHexString(\"149aafa27b041f3523c53d7acba1905fa6b1c90f9fef137568101f44b531a3cb\"),\n+            Bytes.fromHexString(\n+                \"54ecc8863c0550351eee5720f3be6a5d4a016025aa91cd6436cfec938d6a8d30\")),\n+        Arguments.of(\n+            Pbkdf2ParamBuilder.aPbkdf2Param().withSalt(SALT).build(),\n+            Bytes.fromHexString(\"18b148af8e52920318084560fd766f9d09587b4915258dec0676cba5b0da09d8\"),\n+            Bytes.fromHexString(\n+                \"a9249e0ca7315836356e4c7440361ff22b9fe71e2e2ed34fc1eb03976924ed48\")));\n+  }\n+\n+  @SuppressWarnings(\"UnusedMethod\")\n+  private static Stream<Arguments> basicKdfParam() {\n+    return Stream.of(\n+        Arguments.of(\n+            SCryptParamBuilder.aSCryptParam().build(), CipherParamBuilder.aCipherParam().build()),\n+        Arguments.of(\n+            Pbkdf2ParamBuilder.aPbkdf2Param().build(), CipherParamBuilder.aCipherParam().build()));\n+  }\n+\n+  @ParameterizedTest\n+  @MethodSource(\"keystorePaths\")\n+  void loadKeyStoreAndDecryptKey(final Path keyStorePath) throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "baf6b00ff9bdb682f2c8bd33ca015074777003ed"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU4MzA1Mg==", "bodyText": "Would be much better without using parameterised tests.", "url": "https://github.com/ConsenSys/teku/pull/1212#discussion_r383583052", "createdAt": "2020-02-24T23:52:18Z", "author": {"login": "ajsutton"}, "path": "data/keystore/src/test/java/tech/pegasys/artemis/bls/keystore/KeyStoreTest.java", "diffHunk": "@@ -0,0 +1,262 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.bls.keystore;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static tech.pegasys.artemis.bls.keystore.model.CipherFunction.AES_128_CTR;\n+import static tech.pegasys.artemis.bls.keystore.model.CryptoFunction.PBKDF2;\n+import static tech.pegasys.artemis.bls.keystore.model.CryptoFunction.SCRYPT;\n+\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.google.common.io.Resources;\n+import java.net.URISyntaxException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.stream.Stream;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import tech.pegasys.artemis.bls.keystore.builder.CipherBuilder;\n+import tech.pegasys.artemis.bls.keystore.builder.CipherParamBuilder;\n+import tech.pegasys.artemis.bls.keystore.builder.Pbkdf2ParamBuilder;\n+import tech.pegasys.artemis.bls.keystore.builder.SCryptParamBuilder;\n+import tech.pegasys.artemis.bls.keystore.model.ChecksumFunction;\n+import tech.pegasys.artemis.bls.keystore.model.Cipher;\n+import tech.pegasys.artemis.bls.keystore.model.CipherParam;\n+import tech.pegasys.artemis.bls.keystore.model.Crypto;\n+import tech.pegasys.artemis.bls.keystore.model.CryptoFunction;\n+import tech.pegasys.artemis.bls.keystore.model.KdfParam;\n+import tech.pegasys.artemis.bls.keystore.model.KeyStoreData;\n+import tech.pegasys.artemis.bls.keystore.model.Pbkdf2Param;\n+import tech.pegasys.artemis.bls.keystore.model.SCryptParam;\n+\n+class KeyStoreTest {\n+  private static final String PASSWORD = \"testpassword\";\n+  private static final Bytes BLS_PRIVATE_KEY =\n+      Bytes.fromHexString(\"0x000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f\");\n+  private static final Bytes32 SALT =\n+      Bytes32.fromHexString(\"d4e56740f876aef8c010b86a40d5f56745a118d0906a34e69aec8c0db1cb8fa3\");\n+  private static final Bytes AES_IV_PARAM = Bytes.fromHexString(\"264daa3f303d7259501c93d997d84fe6\");\n+\n+  private static final String scryptTestVectorJsonResource = \"scryptTestVector.json\";\n+  private static final String pbkdf2TestVectorJsonResource = \"pbkdf2TestVector.json\";\n+  private static final String missingKdfParamTestVectorJsonResource =\n+      \"missingKdfSectionTestVector.json\";\n+  private static final String unsupportedChecksumFunctionJsonResource =\n+      \"unsupportedChecksumFunction.json\";\n+\n+  @SuppressWarnings(\"UnusedMethod\")\n+  private static Stream<Arguments> keystorePaths() {\n+    try {\n+      final Path scryptTestVectorPath =\n+          Paths.get(Resources.getResource(scryptTestVectorJsonResource).toURI());\n+      final Path pbkdf2TestVectorPath =\n+          Paths.get(Resources.getResource(pbkdf2TestVectorJsonResource).toURI());\n+      return Stream.of(Arguments.of(scryptTestVectorPath), Arguments.of(pbkdf2TestVectorPath));\n+    } catch (URISyntaxException e) {\n+      throw new IllegalStateException(e);\n+    }\n+  }\n+\n+  @SuppressWarnings(\"UnusedMethod\")\n+  private static Stream<Arguments> invalidKeyStorePaths() {\n+    try {\n+      final Path scryptTestVectorPath =\n+          Paths.get(Resources.getResource(missingKdfParamTestVectorJsonResource).toURI());\n+      final Path pbkdf2TestVectorPath =\n+          Paths.get(Resources.getResource(unsupportedChecksumFunctionJsonResource).toURI());\n+      return Stream.of(Arguments.of(scryptTestVectorPath), Arguments.of(pbkdf2TestVectorPath));\n+    } catch (URISyntaxException e) {\n+      throw new IllegalStateException(e);\n+    }\n+  }\n+\n+  @SuppressWarnings(\"UnusedMethod\")\n+  private static Stream<Arguments> kdfParams() {\n+    // KdfParam, expected checksum, expected encrypted cipher message\n+    return Stream.of(\n+        Arguments.of(\n+            SCryptParamBuilder.aSCryptParam().withSalt(SALT).build(),\n+            Bytes.fromHexString(\"149aafa27b041f3523c53d7acba1905fa6b1c90f9fef137568101f44b531a3cb\"),\n+            Bytes.fromHexString(\n+                \"54ecc8863c0550351eee5720f3be6a5d4a016025aa91cd6436cfec938d6a8d30\")),\n+        Arguments.of(\n+            Pbkdf2ParamBuilder.aPbkdf2Param().withSalt(SALT).build(),\n+            Bytes.fromHexString(\"18b148af8e52920318084560fd766f9d09587b4915258dec0676cba5b0da09d8\"),\n+            Bytes.fromHexString(\n+                \"a9249e0ca7315836356e4c7440361ff22b9fe71e2e2ed34fc1eb03976924ed48\")));\n+  }\n+\n+  @SuppressWarnings(\"UnusedMethod\")\n+  private static Stream<Arguments> basicKdfParam() {\n+    return Stream.of(\n+        Arguments.of(\n+            SCryptParamBuilder.aSCryptParam().build(), CipherParamBuilder.aCipherParam().build()),\n+        Arguments.of(\n+            Pbkdf2ParamBuilder.aPbkdf2Param().build(), CipherParamBuilder.aCipherParam().build()));\n+  }\n+\n+  @ParameterizedTest\n+  @MethodSource(\"keystorePaths\")\n+  void loadKeyStoreAndDecryptKey(final Path keyStorePath) throws Exception {\n+    final KeyStore keyStore = KeyStoreLoader.loadFromFile(keyStorePath);\n+    final KeyStoreData keyStoreData = keyStore.getKeyStoreData();\n+    assertNotNull(keyStoreData);\n+    final KdfParam param = keyStoreData.getCrypto().getKdf().getParam();\n+    assertNotNull(param);\n+    if (keyStoreData.getCrypto().getKdf().getCryptoFunction() == SCRYPT) {\n+      assertTrue(param instanceof SCryptParam);\n+    } else if (keyStoreData.getCrypto().getKdf().getCryptoFunction() == PBKDF2) {\n+      assertTrue(param instanceof Pbkdf2Param);\n+    } else {\n+      fail(\"Unsupported crypto function\");\n+    }\n+    assertTrue(keyStore.validatePassword(PASSWORD));\n+    assertFalse(keyStore.validatePassword(\"test\"));\n+\n+    final Bytes decryptedKey = keyStore.decrypt(PASSWORD);\n+    assertEquals(BLS_PRIVATE_KEY, decryptedKey);\n+  }\n+\n+  @ParameterizedTest\n+  @MethodSource(\"invalidKeyStorePaths\")\n+  void loadingKeyStoreWithInvalidKdfParamsThrowsException(final Path invalidJsonPath) {\n+    assertThrows(JsonMappingException.class, () -> KeyStoreLoader.loadFromFile(invalidJsonPath));\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "baf6b00ff9bdb682f2c8bd33ca015074777003ed"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU4MzQ4Nw==", "bodyText": "This probably does make sense being parameterised as we're getting multiple tests out of the same set of parameters.", "url": "https://github.com/ConsenSys/teku/pull/1212#discussion_r383583487", "createdAt": "2020-02-24T23:53:43Z", "author": {"login": "ajsutton"}, "path": "data/keystore/src/test/java/tech/pegasys/artemis/bls/keystore/KeyStoreTest.java", "diffHunk": "@@ -0,0 +1,262 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.bls.keystore;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static tech.pegasys.artemis.bls.keystore.model.CipherFunction.AES_128_CTR;\n+import static tech.pegasys.artemis.bls.keystore.model.CryptoFunction.PBKDF2;\n+import static tech.pegasys.artemis.bls.keystore.model.CryptoFunction.SCRYPT;\n+\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.google.common.io.Resources;\n+import java.net.URISyntaxException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.stream.Stream;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import tech.pegasys.artemis.bls.keystore.builder.CipherBuilder;\n+import tech.pegasys.artemis.bls.keystore.builder.CipherParamBuilder;\n+import tech.pegasys.artemis.bls.keystore.builder.Pbkdf2ParamBuilder;\n+import tech.pegasys.artemis.bls.keystore.builder.SCryptParamBuilder;\n+import tech.pegasys.artemis.bls.keystore.model.ChecksumFunction;\n+import tech.pegasys.artemis.bls.keystore.model.Cipher;\n+import tech.pegasys.artemis.bls.keystore.model.CipherParam;\n+import tech.pegasys.artemis.bls.keystore.model.Crypto;\n+import tech.pegasys.artemis.bls.keystore.model.CryptoFunction;\n+import tech.pegasys.artemis.bls.keystore.model.KdfParam;\n+import tech.pegasys.artemis.bls.keystore.model.KeyStoreData;\n+import tech.pegasys.artemis.bls.keystore.model.Pbkdf2Param;\n+import tech.pegasys.artemis.bls.keystore.model.SCryptParam;\n+\n+class KeyStoreTest {\n+  private static final String PASSWORD = \"testpassword\";\n+  private static final Bytes BLS_PRIVATE_KEY =\n+      Bytes.fromHexString(\"0x000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f\");\n+  private static final Bytes32 SALT =\n+      Bytes32.fromHexString(\"d4e56740f876aef8c010b86a40d5f56745a118d0906a34e69aec8c0db1cb8fa3\");\n+  private static final Bytes AES_IV_PARAM = Bytes.fromHexString(\"264daa3f303d7259501c93d997d84fe6\");\n+\n+  private static final String scryptTestVectorJsonResource = \"scryptTestVector.json\";\n+  private static final String pbkdf2TestVectorJsonResource = \"pbkdf2TestVector.json\";\n+  private static final String missingKdfParamTestVectorJsonResource =\n+      \"missingKdfSectionTestVector.json\";\n+  private static final String unsupportedChecksumFunctionJsonResource =\n+      \"unsupportedChecksumFunction.json\";\n+\n+  @SuppressWarnings(\"UnusedMethod\")\n+  private static Stream<Arguments> keystorePaths() {\n+    try {\n+      final Path scryptTestVectorPath =\n+          Paths.get(Resources.getResource(scryptTestVectorJsonResource).toURI());\n+      final Path pbkdf2TestVectorPath =\n+          Paths.get(Resources.getResource(pbkdf2TestVectorJsonResource).toURI());\n+      return Stream.of(Arguments.of(scryptTestVectorPath), Arguments.of(pbkdf2TestVectorPath));\n+    } catch (URISyntaxException e) {\n+      throw new IllegalStateException(e);\n+    }\n+  }\n+\n+  @SuppressWarnings(\"UnusedMethod\")\n+  private static Stream<Arguments> invalidKeyStorePaths() {\n+    try {\n+      final Path scryptTestVectorPath =\n+          Paths.get(Resources.getResource(missingKdfParamTestVectorJsonResource).toURI());\n+      final Path pbkdf2TestVectorPath =\n+          Paths.get(Resources.getResource(unsupportedChecksumFunctionJsonResource).toURI());\n+      return Stream.of(Arguments.of(scryptTestVectorPath), Arguments.of(pbkdf2TestVectorPath));\n+    } catch (URISyntaxException e) {\n+      throw new IllegalStateException(e);\n+    }\n+  }\n+\n+  @SuppressWarnings(\"UnusedMethod\")\n+  private static Stream<Arguments> kdfParams() {\n+    // KdfParam, expected checksum, expected encrypted cipher message\n+    return Stream.of(\n+        Arguments.of(\n+            SCryptParamBuilder.aSCryptParam().withSalt(SALT).build(),\n+            Bytes.fromHexString(\"149aafa27b041f3523c53d7acba1905fa6b1c90f9fef137568101f44b531a3cb\"),\n+            Bytes.fromHexString(\n+                \"54ecc8863c0550351eee5720f3be6a5d4a016025aa91cd6436cfec938d6a8d30\")),\n+        Arguments.of(\n+            Pbkdf2ParamBuilder.aPbkdf2Param().withSalt(SALT).build(),\n+            Bytes.fromHexString(\"18b148af8e52920318084560fd766f9d09587b4915258dec0676cba5b0da09d8\"),\n+            Bytes.fromHexString(\n+                \"a9249e0ca7315836356e4c7440361ff22b9fe71e2e2ed34fc1eb03976924ed48\")));\n+  }\n+\n+  @SuppressWarnings(\"UnusedMethod\")\n+  private static Stream<Arguments> basicKdfParam() {\n+    return Stream.of(\n+        Arguments.of(\n+            SCryptParamBuilder.aSCryptParam().build(), CipherParamBuilder.aCipherParam().build()),\n+        Arguments.of(\n+            Pbkdf2ParamBuilder.aPbkdf2Param().build(), CipherParamBuilder.aCipherParam().build()));\n+  }\n+\n+  @ParameterizedTest\n+  @MethodSource(\"keystorePaths\")\n+  void loadKeyStoreAndDecryptKey(final Path keyStorePath) throws Exception {\n+    final KeyStore keyStore = KeyStoreLoader.loadFromFile(keyStorePath);\n+    final KeyStoreData keyStoreData = keyStore.getKeyStoreData();\n+    assertNotNull(keyStoreData);\n+    final KdfParam param = keyStoreData.getCrypto().getKdf().getParam();\n+    assertNotNull(param);\n+    if (keyStoreData.getCrypto().getKdf().getCryptoFunction() == SCRYPT) {\n+      assertTrue(param instanceof SCryptParam);\n+    } else if (keyStoreData.getCrypto().getKdf().getCryptoFunction() == PBKDF2) {\n+      assertTrue(param instanceof Pbkdf2Param);\n+    } else {\n+      fail(\"Unsupported crypto function\");\n+    }\n+    assertTrue(keyStore.validatePassword(PASSWORD));\n+    assertFalse(keyStore.validatePassword(\"test\"));\n+\n+    final Bytes decryptedKey = keyStore.decrypt(PASSWORD);\n+    assertEquals(BLS_PRIVATE_KEY, decryptedKey);\n+  }\n+\n+  @ParameterizedTest\n+  @MethodSource(\"invalidKeyStorePaths\")\n+  void loadingKeyStoreWithInvalidKdfParamsThrowsException(final Path invalidJsonPath) {\n+    assertThrows(JsonMappingException.class, () -> KeyStoreLoader.loadFromFile(invalidJsonPath));\n+  }\n+\n+  @ParameterizedTest\n+  @MethodSource(\"kdfParams\")\n+  void encryptWithKdfAndCipherFunction(\n+      final KdfParam kdfParam, final Bytes expectedChecksum, final Bytes encryptedCipherMessage) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "baf6b00ff9bdb682f2c8bd33ca015074777003ed"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU4MzgyMQ==", "bodyText": "This seems like an incredibly weak assertion.  I would have expected we'd have some known inputs and expected outputs.", "url": "https://github.com/ConsenSys/teku/pull/1212#discussion_r383583821", "createdAt": "2020-02-24T23:54:43Z", "author": {"login": "ajsutton"}, "path": "data/keystore/src/test/java/tech/pegasys/artemis/bls/keystore/KeyStoreTest.java", "diffHunk": "@@ -0,0 +1,262 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.bls.keystore;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static tech.pegasys.artemis.bls.keystore.model.CipherFunction.AES_128_CTR;\n+import static tech.pegasys.artemis.bls.keystore.model.CryptoFunction.PBKDF2;\n+import static tech.pegasys.artemis.bls.keystore.model.CryptoFunction.SCRYPT;\n+\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.google.common.io.Resources;\n+import java.net.URISyntaxException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.stream.Stream;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import tech.pegasys.artemis.bls.keystore.builder.CipherBuilder;\n+import tech.pegasys.artemis.bls.keystore.builder.CipherParamBuilder;\n+import tech.pegasys.artemis.bls.keystore.builder.Pbkdf2ParamBuilder;\n+import tech.pegasys.artemis.bls.keystore.builder.SCryptParamBuilder;\n+import tech.pegasys.artemis.bls.keystore.model.ChecksumFunction;\n+import tech.pegasys.artemis.bls.keystore.model.Cipher;\n+import tech.pegasys.artemis.bls.keystore.model.CipherParam;\n+import tech.pegasys.artemis.bls.keystore.model.Crypto;\n+import tech.pegasys.artemis.bls.keystore.model.CryptoFunction;\n+import tech.pegasys.artemis.bls.keystore.model.KdfParam;\n+import tech.pegasys.artemis.bls.keystore.model.KeyStoreData;\n+import tech.pegasys.artemis.bls.keystore.model.Pbkdf2Param;\n+import tech.pegasys.artemis.bls.keystore.model.SCryptParam;\n+\n+class KeyStoreTest {\n+  private static final String PASSWORD = \"testpassword\";\n+  private static final Bytes BLS_PRIVATE_KEY =\n+      Bytes.fromHexString(\"0x000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f\");\n+  private static final Bytes32 SALT =\n+      Bytes32.fromHexString(\"d4e56740f876aef8c010b86a40d5f56745a118d0906a34e69aec8c0db1cb8fa3\");\n+  private static final Bytes AES_IV_PARAM = Bytes.fromHexString(\"264daa3f303d7259501c93d997d84fe6\");\n+\n+  private static final String scryptTestVectorJsonResource = \"scryptTestVector.json\";\n+  private static final String pbkdf2TestVectorJsonResource = \"pbkdf2TestVector.json\";\n+  private static final String missingKdfParamTestVectorJsonResource =\n+      \"missingKdfSectionTestVector.json\";\n+  private static final String unsupportedChecksumFunctionJsonResource =\n+      \"unsupportedChecksumFunction.json\";\n+\n+  @SuppressWarnings(\"UnusedMethod\")\n+  private static Stream<Arguments> keystorePaths() {\n+    try {\n+      final Path scryptTestVectorPath =\n+          Paths.get(Resources.getResource(scryptTestVectorJsonResource).toURI());\n+      final Path pbkdf2TestVectorPath =\n+          Paths.get(Resources.getResource(pbkdf2TestVectorJsonResource).toURI());\n+      return Stream.of(Arguments.of(scryptTestVectorPath), Arguments.of(pbkdf2TestVectorPath));\n+    } catch (URISyntaxException e) {\n+      throw new IllegalStateException(e);\n+    }\n+  }\n+\n+  @SuppressWarnings(\"UnusedMethod\")\n+  private static Stream<Arguments> invalidKeyStorePaths() {\n+    try {\n+      final Path scryptTestVectorPath =\n+          Paths.get(Resources.getResource(missingKdfParamTestVectorJsonResource).toURI());\n+      final Path pbkdf2TestVectorPath =\n+          Paths.get(Resources.getResource(unsupportedChecksumFunctionJsonResource).toURI());\n+      return Stream.of(Arguments.of(scryptTestVectorPath), Arguments.of(pbkdf2TestVectorPath));\n+    } catch (URISyntaxException e) {\n+      throw new IllegalStateException(e);\n+    }\n+  }\n+\n+  @SuppressWarnings(\"UnusedMethod\")\n+  private static Stream<Arguments> kdfParams() {\n+    // KdfParam, expected checksum, expected encrypted cipher message\n+    return Stream.of(\n+        Arguments.of(\n+            SCryptParamBuilder.aSCryptParam().withSalt(SALT).build(),\n+            Bytes.fromHexString(\"149aafa27b041f3523c53d7acba1905fa6b1c90f9fef137568101f44b531a3cb\"),\n+            Bytes.fromHexString(\n+                \"54ecc8863c0550351eee5720f3be6a5d4a016025aa91cd6436cfec938d6a8d30\")),\n+        Arguments.of(\n+            Pbkdf2ParamBuilder.aPbkdf2Param().withSalt(SALT).build(),\n+            Bytes.fromHexString(\"18b148af8e52920318084560fd766f9d09587b4915258dec0676cba5b0da09d8\"),\n+            Bytes.fromHexString(\n+                \"a9249e0ca7315836356e4c7440361ff22b9fe71e2e2ed34fc1eb03976924ed48\")));\n+  }\n+\n+  @SuppressWarnings(\"UnusedMethod\")\n+  private static Stream<Arguments> basicKdfParam() {\n+    return Stream.of(\n+        Arguments.of(\n+            SCryptParamBuilder.aSCryptParam().build(), CipherParamBuilder.aCipherParam().build()),\n+        Arguments.of(\n+            Pbkdf2ParamBuilder.aPbkdf2Param().build(), CipherParamBuilder.aCipherParam().build()));\n+  }\n+\n+  @ParameterizedTest\n+  @MethodSource(\"keystorePaths\")\n+  void loadKeyStoreAndDecryptKey(final Path keyStorePath) throws Exception {\n+    final KeyStore keyStore = KeyStoreLoader.loadFromFile(keyStorePath);\n+    final KeyStoreData keyStoreData = keyStore.getKeyStoreData();\n+    assertNotNull(keyStoreData);\n+    final KdfParam param = keyStoreData.getCrypto().getKdf().getParam();\n+    assertNotNull(param);\n+    if (keyStoreData.getCrypto().getKdf().getCryptoFunction() == SCRYPT) {\n+      assertTrue(param instanceof SCryptParam);\n+    } else if (keyStoreData.getCrypto().getKdf().getCryptoFunction() == PBKDF2) {\n+      assertTrue(param instanceof Pbkdf2Param);\n+    } else {\n+      fail(\"Unsupported crypto function\");\n+    }\n+    assertTrue(keyStore.validatePassword(PASSWORD));\n+    assertFalse(keyStore.validatePassword(\"test\"));\n+\n+    final Bytes decryptedKey = keyStore.decrypt(PASSWORD);\n+    assertEquals(BLS_PRIVATE_KEY, decryptedKey);\n+  }\n+\n+  @ParameterizedTest\n+  @MethodSource(\"invalidKeyStorePaths\")\n+  void loadingKeyStoreWithInvalidKdfParamsThrowsException(final Path invalidJsonPath) {\n+    assertThrows(JsonMappingException.class, () -> KeyStoreLoader.loadFromFile(invalidJsonPath));\n+  }\n+\n+  @ParameterizedTest\n+  @MethodSource(\"kdfParams\")\n+  void encryptWithKdfAndCipherFunction(\n+      final KdfParam kdfParam, final Bytes expectedChecksum, final Bytes encryptedCipherMessage) {\n+    final CipherParam cipherParam = CipherParamBuilder.aCipherParam().withIv(AES_IV_PARAM).build();\n+    final Cipher cipher =\n+        CipherBuilder.aCipher()\n+            .withCipherParam(cipherParam)\n+            .withCipherFunction(AES_128_CTR)\n+            .build();\n+    final Crypto crypto =\n+        KeyStore.encryptUsingCipherFunction(\n+            BLS_PRIVATE_KEY, PASSWORD, kdfParam, cipher, ChecksumFunction.SHA256);\n+\n+    assertEquals(expectedChecksum, crypto.getChecksum().getMessage());\n+    assertEquals(encryptedCipherMessage, crypto.getCipher().getMessage());\n+  }\n+\n+  @ParameterizedTest\n+  @MethodSource(\"basicKdfParam\")\n+  void encryptWithRandomSaltAndIv(final KdfParam kdfParam, final CipherParam cipherParam) {\n+    final Cipher cipher =\n+        CipherBuilder.aCipher()\n+            .withCipherParam(cipherParam)\n+            .withCipherFunction(AES_128_CTR)\n+            .build();\n+    final KeyStore encryptedKeyStore =\n+        KeyStore.encrypt(BLS_PRIVATE_KEY, \"test\", \"\", kdfParam, cipher);\n+    assertTrue(encryptedKeyStore.validatePassword(\"test\"));\n+    final Bytes decryptedKey = encryptedKeyStore.decrypt(\"test\");\n+    assertEquals(BLS_PRIVATE_KEY, decryptedKey);\n+  }\n+\n+  @ParameterizedTest\n+  @EnumSource(CryptoFunction.class)\n+  void encryptLargeDataWithRandomSaltAndIv(final CryptoFunction cryptoFunction) {\n+    final KdfParam kdfParam =\n+        cryptoFunction == SCRYPT\n+            ? SCryptParamBuilder.aSCryptParam().build()\n+            : Pbkdf2ParamBuilder.aPbkdf2Param().build();\n+    final CipherParam cipherParam = CipherParamBuilder.aCipherParam().build();\n+    final Cipher cipher =\n+        CipherBuilder.aCipher()\n+            .withCipherParam(cipherParam)\n+            .withCipherFunction(AES_128_CTR)\n+            .build();\n+    final Bytes largeData = Bytes.random(1024);\n+    final Crypto crypto =\n+        KeyStore.encryptUsingCipherFunction(\n+            largeData, PASSWORD, kdfParam, cipher, ChecksumFunction.SHA256);\n+    assertEquals(32, crypto.getChecksum().getMessage().size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "baf6b00ff9bdb682f2c8bd33ca015074777003ed"}, "originalPosition": 196}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU4Mzk3NQ==", "bodyText": "Random in tests is a bad idea.  We should at least use an explicit seed to ensure the test is repeatable.", "url": "https://github.com/ConsenSys/teku/pull/1212#discussion_r383583975", "createdAt": "2020-02-24T23:55:12Z", "author": {"login": "ajsutton"}, "path": "data/keystore/src/test/java/tech/pegasys/artemis/bls/keystore/KeyStoreTest.java", "diffHunk": "@@ -0,0 +1,262 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.bls.keystore;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static tech.pegasys.artemis.bls.keystore.model.CipherFunction.AES_128_CTR;\n+import static tech.pegasys.artemis.bls.keystore.model.CryptoFunction.PBKDF2;\n+import static tech.pegasys.artemis.bls.keystore.model.CryptoFunction.SCRYPT;\n+\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.google.common.io.Resources;\n+import java.net.URISyntaxException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.stream.Stream;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import tech.pegasys.artemis.bls.keystore.builder.CipherBuilder;\n+import tech.pegasys.artemis.bls.keystore.builder.CipherParamBuilder;\n+import tech.pegasys.artemis.bls.keystore.builder.Pbkdf2ParamBuilder;\n+import tech.pegasys.artemis.bls.keystore.builder.SCryptParamBuilder;\n+import tech.pegasys.artemis.bls.keystore.model.ChecksumFunction;\n+import tech.pegasys.artemis.bls.keystore.model.Cipher;\n+import tech.pegasys.artemis.bls.keystore.model.CipherParam;\n+import tech.pegasys.artemis.bls.keystore.model.Crypto;\n+import tech.pegasys.artemis.bls.keystore.model.CryptoFunction;\n+import tech.pegasys.artemis.bls.keystore.model.KdfParam;\n+import tech.pegasys.artemis.bls.keystore.model.KeyStoreData;\n+import tech.pegasys.artemis.bls.keystore.model.Pbkdf2Param;\n+import tech.pegasys.artemis.bls.keystore.model.SCryptParam;\n+\n+class KeyStoreTest {\n+  private static final String PASSWORD = \"testpassword\";\n+  private static final Bytes BLS_PRIVATE_KEY =\n+      Bytes.fromHexString(\"0x000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f\");\n+  private static final Bytes32 SALT =\n+      Bytes32.fromHexString(\"d4e56740f876aef8c010b86a40d5f56745a118d0906a34e69aec8c0db1cb8fa3\");\n+  private static final Bytes AES_IV_PARAM = Bytes.fromHexString(\"264daa3f303d7259501c93d997d84fe6\");\n+\n+  private static final String scryptTestVectorJsonResource = \"scryptTestVector.json\";\n+  private static final String pbkdf2TestVectorJsonResource = \"pbkdf2TestVector.json\";\n+  private static final String missingKdfParamTestVectorJsonResource =\n+      \"missingKdfSectionTestVector.json\";\n+  private static final String unsupportedChecksumFunctionJsonResource =\n+      \"unsupportedChecksumFunction.json\";\n+\n+  @SuppressWarnings(\"UnusedMethod\")\n+  private static Stream<Arguments> keystorePaths() {\n+    try {\n+      final Path scryptTestVectorPath =\n+          Paths.get(Resources.getResource(scryptTestVectorJsonResource).toURI());\n+      final Path pbkdf2TestVectorPath =\n+          Paths.get(Resources.getResource(pbkdf2TestVectorJsonResource).toURI());\n+      return Stream.of(Arguments.of(scryptTestVectorPath), Arguments.of(pbkdf2TestVectorPath));\n+    } catch (URISyntaxException e) {\n+      throw new IllegalStateException(e);\n+    }\n+  }\n+\n+  @SuppressWarnings(\"UnusedMethod\")\n+  private static Stream<Arguments> invalidKeyStorePaths() {\n+    try {\n+      final Path scryptTestVectorPath =\n+          Paths.get(Resources.getResource(missingKdfParamTestVectorJsonResource).toURI());\n+      final Path pbkdf2TestVectorPath =\n+          Paths.get(Resources.getResource(unsupportedChecksumFunctionJsonResource).toURI());\n+      return Stream.of(Arguments.of(scryptTestVectorPath), Arguments.of(pbkdf2TestVectorPath));\n+    } catch (URISyntaxException e) {\n+      throw new IllegalStateException(e);\n+    }\n+  }\n+\n+  @SuppressWarnings(\"UnusedMethod\")\n+  private static Stream<Arguments> kdfParams() {\n+    // KdfParam, expected checksum, expected encrypted cipher message\n+    return Stream.of(\n+        Arguments.of(\n+            SCryptParamBuilder.aSCryptParam().withSalt(SALT).build(),\n+            Bytes.fromHexString(\"149aafa27b041f3523c53d7acba1905fa6b1c90f9fef137568101f44b531a3cb\"),\n+            Bytes.fromHexString(\n+                \"54ecc8863c0550351eee5720f3be6a5d4a016025aa91cd6436cfec938d6a8d30\")),\n+        Arguments.of(\n+            Pbkdf2ParamBuilder.aPbkdf2Param().withSalt(SALT).build(),\n+            Bytes.fromHexString(\"18b148af8e52920318084560fd766f9d09587b4915258dec0676cba5b0da09d8\"),\n+            Bytes.fromHexString(\n+                \"a9249e0ca7315836356e4c7440361ff22b9fe71e2e2ed34fc1eb03976924ed48\")));\n+  }\n+\n+  @SuppressWarnings(\"UnusedMethod\")\n+  private static Stream<Arguments> basicKdfParam() {\n+    return Stream.of(\n+        Arguments.of(\n+            SCryptParamBuilder.aSCryptParam().build(), CipherParamBuilder.aCipherParam().build()),\n+        Arguments.of(\n+            Pbkdf2ParamBuilder.aPbkdf2Param().build(), CipherParamBuilder.aCipherParam().build()));\n+  }\n+\n+  @ParameterizedTest\n+  @MethodSource(\"keystorePaths\")\n+  void loadKeyStoreAndDecryptKey(final Path keyStorePath) throws Exception {\n+    final KeyStore keyStore = KeyStoreLoader.loadFromFile(keyStorePath);\n+    final KeyStoreData keyStoreData = keyStore.getKeyStoreData();\n+    assertNotNull(keyStoreData);\n+    final KdfParam param = keyStoreData.getCrypto().getKdf().getParam();\n+    assertNotNull(param);\n+    if (keyStoreData.getCrypto().getKdf().getCryptoFunction() == SCRYPT) {\n+      assertTrue(param instanceof SCryptParam);\n+    } else if (keyStoreData.getCrypto().getKdf().getCryptoFunction() == PBKDF2) {\n+      assertTrue(param instanceof Pbkdf2Param);\n+    } else {\n+      fail(\"Unsupported crypto function\");\n+    }\n+    assertTrue(keyStore.validatePassword(PASSWORD));\n+    assertFalse(keyStore.validatePassword(\"test\"));\n+\n+    final Bytes decryptedKey = keyStore.decrypt(PASSWORD);\n+    assertEquals(BLS_PRIVATE_KEY, decryptedKey);\n+  }\n+\n+  @ParameterizedTest\n+  @MethodSource(\"invalidKeyStorePaths\")\n+  void loadingKeyStoreWithInvalidKdfParamsThrowsException(final Path invalidJsonPath) {\n+    assertThrows(JsonMappingException.class, () -> KeyStoreLoader.loadFromFile(invalidJsonPath));\n+  }\n+\n+  @ParameterizedTest\n+  @MethodSource(\"kdfParams\")\n+  void encryptWithKdfAndCipherFunction(\n+      final KdfParam kdfParam, final Bytes expectedChecksum, final Bytes encryptedCipherMessage) {\n+    final CipherParam cipherParam = CipherParamBuilder.aCipherParam().withIv(AES_IV_PARAM).build();\n+    final Cipher cipher =\n+        CipherBuilder.aCipher()\n+            .withCipherParam(cipherParam)\n+            .withCipherFunction(AES_128_CTR)\n+            .build();\n+    final Crypto crypto =\n+        KeyStore.encryptUsingCipherFunction(\n+            BLS_PRIVATE_KEY, PASSWORD, kdfParam, cipher, ChecksumFunction.SHA256);\n+\n+    assertEquals(expectedChecksum, crypto.getChecksum().getMessage());\n+    assertEquals(encryptedCipherMessage, crypto.getCipher().getMessage());\n+  }\n+\n+  @ParameterizedTest\n+  @MethodSource(\"basicKdfParam\")\n+  void encryptWithRandomSaltAndIv(final KdfParam kdfParam, final CipherParam cipherParam) {\n+    final Cipher cipher =\n+        CipherBuilder.aCipher()\n+            .withCipherParam(cipherParam)\n+            .withCipherFunction(AES_128_CTR)\n+            .build();\n+    final KeyStore encryptedKeyStore =\n+        KeyStore.encrypt(BLS_PRIVATE_KEY, \"test\", \"\", kdfParam, cipher);\n+    assertTrue(encryptedKeyStore.validatePassword(\"test\"));\n+    final Bytes decryptedKey = encryptedKeyStore.decrypt(\"test\");\n+    assertEquals(BLS_PRIVATE_KEY, decryptedKey);\n+  }\n+\n+  @ParameterizedTest\n+  @EnumSource(CryptoFunction.class)\n+  void encryptLargeDataWithRandomSaltAndIv(final CryptoFunction cryptoFunction) {\n+    final KdfParam kdfParam =\n+        cryptoFunction == SCRYPT\n+            ? SCryptParamBuilder.aSCryptParam().build()\n+            : Pbkdf2ParamBuilder.aPbkdf2Param().build();\n+    final CipherParam cipherParam = CipherParamBuilder.aCipherParam().build();\n+    final Cipher cipher =\n+        CipherBuilder.aCipher()\n+            .withCipherParam(cipherParam)\n+            .withCipherFunction(AES_128_CTR)\n+            .build();\n+    final Bytes largeData = Bytes.random(1024);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "baf6b00ff9bdb682f2c8bd33ca015074777003ed"}, "originalPosition": 192}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU4NDQxNw==", "bodyText": "This also seems like too weak an assertion, suggesting we're not really testing the function.", "url": "https://github.com/ConsenSys/teku/pull/1212#discussion_r383584417", "createdAt": "2020-02-24T23:56:28Z", "author": {"login": "ajsutton"}, "path": "data/keystore/src/test/java/tech/pegasys/artemis/bls/keystore/KeyStoreTest.java", "diffHunk": "@@ -0,0 +1,262 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.bls.keystore;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static tech.pegasys.artemis.bls.keystore.model.CipherFunction.AES_128_CTR;\n+import static tech.pegasys.artemis.bls.keystore.model.CryptoFunction.PBKDF2;\n+import static tech.pegasys.artemis.bls.keystore.model.CryptoFunction.SCRYPT;\n+\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.google.common.io.Resources;\n+import java.net.URISyntaxException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.stream.Stream;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import tech.pegasys.artemis.bls.keystore.builder.CipherBuilder;\n+import tech.pegasys.artemis.bls.keystore.builder.CipherParamBuilder;\n+import tech.pegasys.artemis.bls.keystore.builder.Pbkdf2ParamBuilder;\n+import tech.pegasys.artemis.bls.keystore.builder.SCryptParamBuilder;\n+import tech.pegasys.artemis.bls.keystore.model.ChecksumFunction;\n+import tech.pegasys.artemis.bls.keystore.model.Cipher;\n+import tech.pegasys.artemis.bls.keystore.model.CipherParam;\n+import tech.pegasys.artemis.bls.keystore.model.Crypto;\n+import tech.pegasys.artemis.bls.keystore.model.CryptoFunction;\n+import tech.pegasys.artemis.bls.keystore.model.KdfParam;\n+import tech.pegasys.artemis.bls.keystore.model.KeyStoreData;\n+import tech.pegasys.artemis.bls.keystore.model.Pbkdf2Param;\n+import tech.pegasys.artemis.bls.keystore.model.SCryptParam;\n+\n+class KeyStoreTest {\n+  private static final String PASSWORD = \"testpassword\";\n+  private static final Bytes BLS_PRIVATE_KEY =\n+      Bytes.fromHexString(\"0x000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f\");\n+  private static final Bytes32 SALT =\n+      Bytes32.fromHexString(\"d4e56740f876aef8c010b86a40d5f56745a118d0906a34e69aec8c0db1cb8fa3\");\n+  private static final Bytes AES_IV_PARAM = Bytes.fromHexString(\"264daa3f303d7259501c93d997d84fe6\");\n+\n+  private static final String scryptTestVectorJsonResource = \"scryptTestVector.json\";\n+  private static final String pbkdf2TestVectorJsonResource = \"pbkdf2TestVector.json\";\n+  private static final String missingKdfParamTestVectorJsonResource =\n+      \"missingKdfSectionTestVector.json\";\n+  private static final String unsupportedChecksumFunctionJsonResource =\n+      \"unsupportedChecksumFunction.json\";\n+\n+  @SuppressWarnings(\"UnusedMethod\")\n+  private static Stream<Arguments> keystorePaths() {\n+    try {\n+      final Path scryptTestVectorPath =\n+          Paths.get(Resources.getResource(scryptTestVectorJsonResource).toURI());\n+      final Path pbkdf2TestVectorPath =\n+          Paths.get(Resources.getResource(pbkdf2TestVectorJsonResource).toURI());\n+      return Stream.of(Arguments.of(scryptTestVectorPath), Arguments.of(pbkdf2TestVectorPath));\n+    } catch (URISyntaxException e) {\n+      throw new IllegalStateException(e);\n+    }\n+  }\n+\n+  @SuppressWarnings(\"UnusedMethod\")\n+  private static Stream<Arguments> invalidKeyStorePaths() {\n+    try {\n+      final Path scryptTestVectorPath =\n+          Paths.get(Resources.getResource(missingKdfParamTestVectorJsonResource).toURI());\n+      final Path pbkdf2TestVectorPath =\n+          Paths.get(Resources.getResource(unsupportedChecksumFunctionJsonResource).toURI());\n+      return Stream.of(Arguments.of(scryptTestVectorPath), Arguments.of(pbkdf2TestVectorPath));\n+    } catch (URISyntaxException e) {\n+      throw new IllegalStateException(e);\n+    }\n+  }\n+\n+  @SuppressWarnings(\"UnusedMethod\")\n+  private static Stream<Arguments> kdfParams() {\n+    // KdfParam, expected checksum, expected encrypted cipher message\n+    return Stream.of(\n+        Arguments.of(\n+            SCryptParamBuilder.aSCryptParam().withSalt(SALT).build(),\n+            Bytes.fromHexString(\"149aafa27b041f3523c53d7acba1905fa6b1c90f9fef137568101f44b531a3cb\"),\n+            Bytes.fromHexString(\n+                \"54ecc8863c0550351eee5720f3be6a5d4a016025aa91cd6436cfec938d6a8d30\")),\n+        Arguments.of(\n+            Pbkdf2ParamBuilder.aPbkdf2Param().withSalt(SALT).build(),\n+            Bytes.fromHexString(\"18b148af8e52920318084560fd766f9d09587b4915258dec0676cba5b0da09d8\"),\n+            Bytes.fromHexString(\n+                \"a9249e0ca7315836356e4c7440361ff22b9fe71e2e2ed34fc1eb03976924ed48\")));\n+  }\n+\n+  @SuppressWarnings(\"UnusedMethod\")\n+  private static Stream<Arguments> basicKdfParam() {\n+    return Stream.of(\n+        Arguments.of(\n+            SCryptParamBuilder.aSCryptParam().build(), CipherParamBuilder.aCipherParam().build()),\n+        Arguments.of(\n+            Pbkdf2ParamBuilder.aPbkdf2Param().build(), CipherParamBuilder.aCipherParam().build()));\n+  }\n+\n+  @ParameterizedTest\n+  @MethodSource(\"keystorePaths\")\n+  void loadKeyStoreAndDecryptKey(final Path keyStorePath) throws Exception {\n+    final KeyStore keyStore = KeyStoreLoader.loadFromFile(keyStorePath);\n+    final KeyStoreData keyStoreData = keyStore.getKeyStoreData();\n+    assertNotNull(keyStoreData);\n+    final KdfParam param = keyStoreData.getCrypto().getKdf().getParam();\n+    assertNotNull(param);\n+    if (keyStoreData.getCrypto().getKdf().getCryptoFunction() == SCRYPT) {\n+      assertTrue(param instanceof SCryptParam);\n+    } else if (keyStoreData.getCrypto().getKdf().getCryptoFunction() == PBKDF2) {\n+      assertTrue(param instanceof Pbkdf2Param);\n+    } else {\n+      fail(\"Unsupported crypto function\");\n+    }\n+    assertTrue(keyStore.validatePassword(PASSWORD));\n+    assertFalse(keyStore.validatePassword(\"test\"));\n+\n+    final Bytes decryptedKey = keyStore.decrypt(PASSWORD);\n+    assertEquals(BLS_PRIVATE_KEY, decryptedKey);\n+  }\n+\n+  @ParameterizedTest\n+  @MethodSource(\"invalidKeyStorePaths\")\n+  void loadingKeyStoreWithInvalidKdfParamsThrowsException(final Path invalidJsonPath) {\n+    assertThrows(JsonMappingException.class, () -> KeyStoreLoader.loadFromFile(invalidJsonPath));\n+  }\n+\n+  @ParameterizedTest\n+  @MethodSource(\"kdfParams\")\n+  void encryptWithKdfAndCipherFunction(\n+      final KdfParam kdfParam, final Bytes expectedChecksum, final Bytes encryptedCipherMessage) {\n+    final CipherParam cipherParam = CipherParamBuilder.aCipherParam().withIv(AES_IV_PARAM).build();\n+    final Cipher cipher =\n+        CipherBuilder.aCipher()\n+            .withCipherParam(cipherParam)\n+            .withCipherFunction(AES_128_CTR)\n+            .build();\n+    final Crypto crypto =\n+        KeyStore.encryptUsingCipherFunction(\n+            BLS_PRIVATE_KEY, PASSWORD, kdfParam, cipher, ChecksumFunction.SHA256);\n+\n+    assertEquals(expectedChecksum, crypto.getChecksum().getMessage());\n+    assertEquals(encryptedCipherMessage, crypto.getCipher().getMessage());\n+  }\n+\n+  @ParameterizedTest\n+  @MethodSource(\"basicKdfParam\")\n+  void encryptWithRandomSaltAndIv(final KdfParam kdfParam, final CipherParam cipherParam) {\n+    final Cipher cipher =\n+        CipherBuilder.aCipher()\n+            .withCipherParam(cipherParam)\n+            .withCipherFunction(AES_128_CTR)\n+            .build();\n+    final KeyStore encryptedKeyStore =\n+        KeyStore.encrypt(BLS_PRIVATE_KEY, \"test\", \"\", kdfParam, cipher);\n+    assertTrue(encryptedKeyStore.validatePassword(\"test\"));\n+    final Bytes decryptedKey = encryptedKeyStore.decrypt(\"test\");\n+    assertEquals(BLS_PRIVATE_KEY, decryptedKey);\n+  }\n+\n+  @ParameterizedTest\n+  @EnumSource(CryptoFunction.class)\n+  void encryptLargeDataWithRandomSaltAndIv(final CryptoFunction cryptoFunction) {\n+    final KdfParam kdfParam =\n+        cryptoFunction == SCRYPT\n+            ? SCryptParamBuilder.aSCryptParam().build()\n+            : Pbkdf2ParamBuilder.aPbkdf2Param().build();\n+    final CipherParam cipherParam = CipherParamBuilder.aCipherParam().build();\n+    final Cipher cipher =\n+        CipherBuilder.aCipher()\n+            .withCipherParam(cipherParam)\n+            .withCipherFunction(AES_128_CTR)\n+            .build();\n+    final Bytes largeData = Bytes.random(1024);\n+    final Crypto crypto =\n+        KeyStore.encryptUsingCipherFunction(\n+            largeData, PASSWORD, kdfParam, cipher, ChecksumFunction.SHA256);\n+    assertEquals(32, crypto.getChecksum().getMessage().size());\n+  }\n+\n+  @ParameterizedTest\n+  @EnumSource(CryptoFunction.class)\n+  void encryptSmallDataWithRandomSaltAndIv(final CryptoFunction cryptoFunction) {\n+    final KdfParam kdfParam =\n+        cryptoFunction == SCRYPT\n+            ? SCryptParamBuilder.aSCryptParam().build()\n+            : Pbkdf2ParamBuilder.aPbkdf2Param().build();\n+    final CipherParam cipherParam = CipherParamBuilder.aCipherParam().build();\n+    final Cipher cipher =\n+        CipherBuilder.aCipher()\n+            .withCipherParam(cipherParam)\n+            .withCipherFunction(AES_128_CTR)\n+            .build();\n+    final Bytes smallData = Bytes.random(8);\n+    final Crypto crypto =\n+        KeyStore.encryptUsingCipherFunction(\n+            smallData, PASSWORD, kdfParam, cipher, ChecksumFunction.SHA256);\n+    assertEquals(32, crypto.getChecksum().getMessage().size());\n+  }\n+\n+  @ParameterizedTest\n+  @EnumSource(CryptoFunction.class)\n+  void checksumFunctionSha512(final CryptoFunction cryptoFunction) {\n+    final KdfParam kdfParam =\n+        cryptoFunction == SCRYPT\n+            ? SCryptParamBuilder.aSCryptParam().build()\n+            : Pbkdf2ParamBuilder.aPbkdf2Param().build();\n+    final CipherParam cipherParam = CipherParamBuilder.aCipherParam().build();\n+    final Cipher cipher =\n+        CipherBuilder.aCipher()\n+            .withCipherParam(cipherParam)\n+            .withCipherFunction(AES_128_CTR)\n+            .build();\n+    final Bytes smallData = Bytes.random(8);\n+    final Crypto crypto =\n+        KeyStore.encryptUsingCipherFunction(\n+            smallData, PASSWORD, kdfParam, cipher, ChecksumFunction.SHA512);\n+    assertEquals(64, crypto.getChecksum().getMessage().size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "baf6b00ff9bdb682f2c8bd33ca015074777003ed"}, "originalPosition": 236}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU4NDgzNg==", "bodyText": "We should be using assertj for all these assertions.  At which point you can use:\nAssertions.assertThatThrownBy(() -> ...).isInstanceOf(IllegalArgumentException.class).hasMessage(\"...\")\nAll the assertEquals should be assertThat(...).isEqualTo(...) as well.", "url": "https://github.com/ConsenSys/teku/pull/1212#discussion_r383584836", "createdAt": "2020-02-24T23:57:51Z", "author": {"login": "ajsutton"}, "path": "data/keystore/src/test/java/tech/pegasys/artemis/bls/keystore/KeyStoreTest.java", "diffHunk": "@@ -0,0 +1,262 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.bls.keystore;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static tech.pegasys.artemis.bls.keystore.model.CipherFunction.AES_128_CTR;\n+import static tech.pegasys.artemis.bls.keystore.model.CryptoFunction.PBKDF2;\n+import static tech.pegasys.artemis.bls.keystore.model.CryptoFunction.SCRYPT;\n+\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.google.common.io.Resources;\n+import java.net.URISyntaxException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.stream.Stream;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import tech.pegasys.artemis.bls.keystore.builder.CipherBuilder;\n+import tech.pegasys.artemis.bls.keystore.builder.CipherParamBuilder;\n+import tech.pegasys.artemis.bls.keystore.builder.Pbkdf2ParamBuilder;\n+import tech.pegasys.artemis.bls.keystore.builder.SCryptParamBuilder;\n+import tech.pegasys.artemis.bls.keystore.model.ChecksumFunction;\n+import tech.pegasys.artemis.bls.keystore.model.Cipher;\n+import tech.pegasys.artemis.bls.keystore.model.CipherParam;\n+import tech.pegasys.artemis.bls.keystore.model.Crypto;\n+import tech.pegasys.artemis.bls.keystore.model.CryptoFunction;\n+import tech.pegasys.artemis.bls.keystore.model.KdfParam;\n+import tech.pegasys.artemis.bls.keystore.model.KeyStoreData;\n+import tech.pegasys.artemis.bls.keystore.model.Pbkdf2Param;\n+import tech.pegasys.artemis.bls.keystore.model.SCryptParam;\n+\n+class KeyStoreTest {\n+  private static final String PASSWORD = \"testpassword\";\n+  private static final Bytes BLS_PRIVATE_KEY =\n+      Bytes.fromHexString(\"0x000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f\");\n+  private static final Bytes32 SALT =\n+      Bytes32.fromHexString(\"d4e56740f876aef8c010b86a40d5f56745a118d0906a34e69aec8c0db1cb8fa3\");\n+  private static final Bytes AES_IV_PARAM = Bytes.fromHexString(\"264daa3f303d7259501c93d997d84fe6\");\n+\n+  private static final String scryptTestVectorJsonResource = \"scryptTestVector.json\";\n+  private static final String pbkdf2TestVectorJsonResource = \"pbkdf2TestVector.json\";\n+  private static final String missingKdfParamTestVectorJsonResource =\n+      \"missingKdfSectionTestVector.json\";\n+  private static final String unsupportedChecksumFunctionJsonResource =\n+      \"unsupportedChecksumFunction.json\";\n+\n+  @SuppressWarnings(\"UnusedMethod\")\n+  private static Stream<Arguments> keystorePaths() {\n+    try {\n+      final Path scryptTestVectorPath =\n+          Paths.get(Resources.getResource(scryptTestVectorJsonResource).toURI());\n+      final Path pbkdf2TestVectorPath =\n+          Paths.get(Resources.getResource(pbkdf2TestVectorJsonResource).toURI());\n+      return Stream.of(Arguments.of(scryptTestVectorPath), Arguments.of(pbkdf2TestVectorPath));\n+    } catch (URISyntaxException e) {\n+      throw new IllegalStateException(e);\n+    }\n+  }\n+\n+  @SuppressWarnings(\"UnusedMethod\")\n+  private static Stream<Arguments> invalidKeyStorePaths() {\n+    try {\n+      final Path scryptTestVectorPath =\n+          Paths.get(Resources.getResource(missingKdfParamTestVectorJsonResource).toURI());\n+      final Path pbkdf2TestVectorPath =\n+          Paths.get(Resources.getResource(unsupportedChecksumFunctionJsonResource).toURI());\n+      return Stream.of(Arguments.of(scryptTestVectorPath), Arguments.of(pbkdf2TestVectorPath));\n+    } catch (URISyntaxException e) {\n+      throw new IllegalStateException(e);\n+    }\n+  }\n+\n+  @SuppressWarnings(\"UnusedMethod\")\n+  private static Stream<Arguments> kdfParams() {\n+    // KdfParam, expected checksum, expected encrypted cipher message\n+    return Stream.of(\n+        Arguments.of(\n+            SCryptParamBuilder.aSCryptParam().withSalt(SALT).build(),\n+            Bytes.fromHexString(\"149aafa27b041f3523c53d7acba1905fa6b1c90f9fef137568101f44b531a3cb\"),\n+            Bytes.fromHexString(\n+                \"54ecc8863c0550351eee5720f3be6a5d4a016025aa91cd6436cfec938d6a8d30\")),\n+        Arguments.of(\n+            Pbkdf2ParamBuilder.aPbkdf2Param().withSalt(SALT).build(),\n+            Bytes.fromHexString(\"18b148af8e52920318084560fd766f9d09587b4915258dec0676cba5b0da09d8\"),\n+            Bytes.fromHexString(\n+                \"a9249e0ca7315836356e4c7440361ff22b9fe71e2e2ed34fc1eb03976924ed48\")));\n+  }\n+\n+  @SuppressWarnings(\"UnusedMethod\")\n+  private static Stream<Arguments> basicKdfParam() {\n+    return Stream.of(\n+        Arguments.of(\n+            SCryptParamBuilder.aSCryptParam().build(), CipherParamBuilder.aCipherParam().build()),\n+        Arguments.of(\n+            Pbkdf2ParamBuilder.aPbkdf2Param().build(), CipherParamBuilder.aCipherParam().build()));\n+  }\n+\n+  @ParameterizedTest\n+  @MethodSource(\"keystorePaths\")\n+  void loadKeyStoreAndDecryptKey(final Path keyStorePath) throws Exception {\n+    final KeyStore keyStore = KeyStoreLoader.loadFromFile(keyStorePath);\n+    final KeyStoreData keyStoreData = keyStore.getKeyStoreData();\n+    assertNotNull(keyStoreData);\n+    final KdfParam param = keyStoreData.getCrypto().getKdf().getParam();\n+    assertNotNull(param);\n+    if (keyStoreData.getCrypto().getKdf().getCryptoFunction() == SCRYPT) {\n+      assertTrue(param instanceof SCryptParam);\n+    } else if (keyStoreData.getCrypto().getKdf().getCryptoFunction() == PBKDF2) {\n+      assertTrue(param instanceof Pbkdf2Param);\n+    } else {\n+      fail(\"Unsupported crypto function\");\n+    }\n+    assertTrue(keyStore.validatePassword(PASSWORD));\n+    assertFalse(keyStore.validatePassword(\"test\"));\n+\n+    final Bytes decryptedKey = keyStore.decrypt(PASSWORD);\n+    assertEquals(BLS_PRIVATE_KEY, decryptedKey);\n+  }\n+\n+  @ParameterizedTest\n+  @MethodSource(\"invalidKeyStorePaths\")\n+  void loadingKeyStoreWithInvalidKdfParamsThrowsException(final Path invalidJsonPath) {\n+    assertThrows(JsonMappingException.class, () -> KeyStoreLoader.loadFromFile(invalidJsonPath));\n+  }\n+\n+  @ParameterizedTest\n+  @MethodSource(\"kdfParams\")\n+  void encryptWithKdfAndCipherFunction(\n+      final KdfParam kdfParam, final Bytes expectedChecksum, final Bytes encryptedCipherMessage) {\n+    final CipherParam cipherParam = CipherParamBuilder.aCipherParam().withIv(AES_IV_PARAM).build();\n+    final Cipher cipher =\n+        CipherBuilder.aCipher()\n+            .withCipherParam(cipherParam)\n+            .withCipherFunction(AES_128_CTR)\n+            .build();\n+    final Crypto crypto =\n+        KeyStore.encryptUsingCipherFunction(\n+            BLS_PRIVATE_KEY, PASSWORD, kdfParam, cipher, ChecksumFunction.SHA256);\n+\n+    assertEquals(expectedChecksum, crypto.getChecksum().getMessage());\n+    assertEquals(encryptedCipherMessage, crypto.getCipher().getMessage());\n+  }\n+\n+  @ParameterizedTest\n+  @MethodSource(\"basicKdfParam\")\n+  void encryptWithRandomSaltAndIv(final KdfParam kdfParam, final CipherParam cipherParam) {\n+    final Cipher cipher =\n+        CipherBuilder.aCipher()\n+            .withCipherParam(cipherParam)\n+            .withCipherFunction(AES_128_CTR)\n+            .build();\n+    final KeyStore encryptedKeyStore =\n+        KeyStore.encrypt(BLS_PRIVATE_KEY, \"test\", \"\", kdfParam, cipher);\n+    assertTrue(encryptedKeyStore.validatePassword(\"test\"));\n+    final Bytes decryptedKey = encryptedKeyStore.decrypt(\"test\");\n+    assertEquals(BLS_PRIVATE_KEY, decryptedKey);\n+  }\n+\n+  @ParameterizedTest\n+  @EnumSource(CryptoFunction.class)\n+  void encryptLargeDataWithRandomSaltAndIv(final CryptoFunction cryptoFunction) {\n+    final KdfParam kdfParam =\n+        cryptoFunction == SCRYPT\n+            ? SCryptParamBuilder.aSCryptParam().build()\n+            : Pbkdf2ParamBuilder.aPbkdf2Param().build();\n+    final CipherParam cipherParam = CipherParamBuilder.aCipherParam().build();\n+    final Cipher cipher =\n+        CipherBuilder.aCipher()\n+            .withCipherParam(cipherParam)\n+            .withCipherFunction(AES_128_CTR)\n+            .build();\n+    final Bytes largeData = Bytes.random(1024);\n+    final Crypto crypto =\n+        KeyStore.encryptUsingCipherFunction(\n+            largeData, PASSWORD, kdfParam, cipher, ChecksumFunction.SHA256);\n+    assertEquals(32, crypto.getChecksum().getMessage().size());\n+  }\n+\n+  @ParameterizedTest\n+  @EnumSource(CryptoFunction.class)\n+  void encryptSmallDataWithRandomSaltAndIv(final CryptoFunction cryptoFunction) {\n+    final KdfParam kdfParam =\n+        cryptoFunction == SCRYPT\n+            ? SCryptParamBuilder.aSCryptParam().build()\n+            : Pbkdf2ParamBuilder.aPbkdf2Param().build();\n+    final CipherParam cipherParam = CipherParamBuilder.aCipherParam().build();\n+    final Cipher cipher =\n+        CipherBuilder.aCipher()\n+            .withCipherParam(cipherParam)\n+            .withCipherFunction(AES_128_CTR)\n+            .build();\n+    final Bytes smallData = Bytes.random(8);\n+    final Crypto crypto =\n+        KeyStore.encryptUsingCipherFunction(\n+            smallData, PASSWORD, kdfParam, cipher, ChecksumFunction.SHA256);\n+    assertEquals(32, crypto.getChecksum().getMessage().size());\n+  }\n+\n+  @ParameterizedTest\n+  @EnumSource(CryptoFunction.class)\n+  void checksumFunctionSha512(final CryptoFunction cryptoFunction) {\n+    final KdfParam kdfParam =\n+        cryptoFunction == SCRYPT\n+            ? SCryptParamBuilder.aSCryptParam().build()\n+            : Pbkdf2ParamBuilder.aPbkdf2Param().build();\n+    final CipherParam cipherParam = CipherParamBuilder.aCipherParam().build();\n+    final Cipher cipher =\n+        CipherBuilder.aCipher()\n+            .withCipherParam(cipherParam)\n+            .withCipherFunction(AES_128_CTR)\n+            .build();\n+    final Bytes smallData = Bytes.random(8);\n+    final Crypto crypto =\n+        KeyStore.encryptUsingCipherFunction(\n+            smallData, PASSWORD, kdfParam, cipher, ChecksumFunction.SHA512);\n+    assertEquals(64, crypto.getChecksum().getMessage().size());\n+  }\n+\n+  @ParameterizedTest\n+  @EnumSource(CryptoFunction.class)\n+  void encryptionWithInvalidDkLenShouldFail(final CryptoFunction cryptoFunction) {\n+    final KdfParam kdfParam =\n+        cryptoFunction == SCRYPT\n+            ? SCryptParamBuilder.aSCryptParam().withDklen(15).build()\n+            : Pbkdf2ParamBuilder.aPbkdf2Param().withDklen(15).build();\n+    final CipherParam cipherParam = CipherParamBuilder.aCipherParam().build();\n+    final Cipher cipher =\n+        CipherBuilder.aCipher()\n+            .withCipherParam(cipherParam)\n+            .withCipherFunction(AES_128_CTR)\n+            .build();\n+    final Bytes data = Bytes.random(8);\n+    final IllegalArgumentException illegalArgumentException =\n+        assertThrows(\n+            IllegalArgumentException.class,\n+            () ->\n+                KeyStore.encryptUsingCipherFunction(\n+                    data, PASSWORD, kdfParam, cipher, ChecksumFunction.SHA256));\n+    assertEquals(\n+        \"aes-128-ctr requires kdf dklen greater than 16\", illegalArgumentException.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "baf6b00ff9bdb682f2c8bd33ca015074777003ed"}, "originalPosition": 260}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzODc4NzA4", "url": "https://github.com/ConsenSys/teku/pull/1212#pullrequestreview-363878708", "createdAt": "2020-02-25T05:28:58Z", "commit": {"oid": "baf6b00ff9bdb682f2c8bd33ca015074777003ed"}, "state": "COMMENTED", "comments": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQwNToyODo1OFrOFt5F7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQwNjo1NjoxOFrOFt6gnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY2NTY0NQ==", "bodyText": "Why is this non-static but the encrypt is static? I would expect them both be consistent in how they are used.", "url": "https://github.com/ConsenSys/teku/pull/1212#discussion_r383665645", "createdAt": "2020-02-25T05:28:58Z", "author": {"login": "jframe"}, "path": "data/keystore/src/main/java/tech/pegasys/artemis/bls/keystore/KeyStore.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.bls.keystore;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static javax.crypto.Cipher.DECRYPT_MODE;\n+import static javax.crypto.Cipher.ENCRYPT_MODE;\n+import static org.apache.tuweni.crypto.Hash.digestUsingAlgorithm;\n+import static org.apache.tuweni.crypto.Hash.sha2_256;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import java.security.GeneralSecurityException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Objects;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes48;\n+import org.bouncycastle.jce.provider.BouncyCastleProvider;\n+import tech.pegasys.artemis.bls.keystore.builder.ChecksumBuilder;\n+import tech.pegasys.artemis.bls.keystore.builder.CipherBuilder;\n+import tech.pegasys.artemis.bls.keystore.builder.KdfBuilder;\n+import tech.pegasys.artemis.bls.keystore.builder.KeyStoreDataBuilder;\n+import tech.pegasys.artemis.bls.keystore.model.Checksum;\n+import tech.pegasys.artemis.bls.keystore.model.ChecksumFunction;\n+import tech.pegasys.artemis.bls.keystore.model.Cipher;\n+import tech.pegasys.artemis.bls.keystore.model.Crypto;\n+import tech.pegasys.artemis.bls.keystore.model.Kdf;\n+import tech.pegasys.artemis.bls.keystore.model.KdfParam;\n+import tech.pegasys.artemis.bls.keystore.model.KeyStoreData;\n+import tech.pegasys.artemis.util.mikuli.PublicKey;\n+import tech.pegasys.artemis.util.mikuli.SecretKey;\n+\n+/**\n+ * BLS Key Store implementation EIP-2335\n+ *\n+ * @see <a href=\"https://github.com/ethereum/EIPs/blob/master/EIPS/eip-2335.md\">EIP-2335</a>\n+ */\n+public class KeyStore {\n+  private static final BouncyCastleProvider BC = new BouncyCastleProvider();\n+  private final KeyStoreData keyStoreData;\n+\n+  public KeyStore(final KeyStoreData keyStoreData) {\n+    this.keyStoreData = keyStoreData;\n+  }\n+\n+  public KeyStoreData getKeyStoreData() {\n+    return keyStoreData;\n+  }\n+\n+  /**\n+   * Encrypt the given BLS12-381 key with specified password.\n+   *\n+   * @param blsPrivateKey BLS12-381 private key in Bytes\n+   * @param password The password to use for encryption\n+   * @param path Path as defined in EIP-2334. Can be empty String.\n+   * @param kdfParam crypto function such as scrypt or PBKDF2 and related parameters such as dklen,\n+   *     salt etc.\n+   * @param cipher cipher function and parameters such as iv. Message is ignored.\n+   * @return The constructed KeyStore with encrypted BLS Private Key as cipher.message and other\n+   *     details as defined by the EIP-2335 standard.\n+   */\n+  public static KeyStore encrypt(\n+      final Bytes blsPrivateKey,\n+      final String password,\n+      final String path,\n+      final KdfParam kdfParam,\n+      final Cipher cipher) {\n+\n+    final Crypto crypto =\n+        encryptUsingCipherFunction(\n+            blsPrivateKey, password, kdfParam, cipher, ChecksumFunction.SHA256);\n+    final Bytes pubKey =\n+        new PublicKey(SecretKey.fromBytes(Bytes48.leftPad(blsPrivateKey))).toBytesCompressed();\n+    final KeyStoreData keyStoreData =\n+        KeyStoreDataBuilder.aKeyStoreData()\n+            .withCrypto(crypto)\n+            .withPath(path)\n+            .withPubkey(pubKey)\n+            .build();\n+\n+    return new KeyStore(keyStoreData);\n+  }\n+\n+  @VisibleForTesting\n+  static Crypto encryptUsingCipherFunction(\n+      final Bytes secret,\n+      final String password,\n+      final KdfParam kdfParam,\n+      final Cipher cipher,\n+      final ChecksumFunction checksumFunction) {\n+    checkArgument(\n+        kdfParam.getDerivedKeyLength() > 16, \"aes-128-ctr requires kdf dklen greater than 16\");\n+\n+    final Bytes decryptionKey = DecryptionKeyGenerator.generate(password.getBytes(UTF_8), kdfParam);\n+    final Bytes cipherMessage =\n+        applyCipherFunction(\n+            decryptionKey, cipher.getCipherParam().getIv(), true, secret.toArrayUnsafe());\n+    final Bytes checksumMessage =\n+        calculateChecksum(kdfParam, checksumFunction, decryptionKey, cipherMessage);\n+    final Checksum checksum =\n+        ChecksumBuilder.aChecksum()\n+            .withChecksumFunction(checksumFunction)\n+            .withMessage(checksumMessage)\n+            .build();\n+    final Cipher encryptedCipher =\n+        CipherBuilder.aCipher()\n+            .withCipherFunction(cipher.getCipherFunction())\n+            .withCipherParam(cipher.getCipherParam())\n+            .withMessage(cipherMessage)\n+            .build();\n+    final Kdf kdf = KdfBuilder.aKdf().withParam(kdfParam).build();\n+    return new Crypto(kdf, checksum, encryptedCipher);\n+  }\n+\n+  public Bytes decrypt(final String password) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "baf6b00ff9bdb682f2c8bd33ca015074777003ed"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY2NjEyMA==", "bodyText": "nit: derived key length would be friendlier in an error message", "url": "https://github.com/ConsenSys/teku/pull/1212#discussion_r383666120", "createdAt": "2020-02-25T05:31:05Z", "author": {"login": "jframe"}, "path": "data/keystore/src/main/java/tech/pegasys/artemis/bls/keystore/KeyStore.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.bls.keystore;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static javax.crypto.Cipher.DECRYPT_MODE;\n+import static javax.crypto.Cipher.ENCRYPT_MODE;\n+import static org.apache.tuweni.crypto.Hash.digestUsingAlgorithm;\n+import static org.apache.tuweni.crypto.Hash.sha2_256;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import java.security.GeneralSecurityException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Objects;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes48;\n+import org.bouncycastle.jce.provider.BouncyCastleProvider;\n+import tech.pegasys.artemis.bls.keystore.builder.ChecksumBuilder;\n+import tech.pegasys.artemis.bls.keystore.builder.CipherBuilder;\n+import tech.pegasys.artemis.bls.keystore.builder.KdfBuilder;\n+import tech.pegasys.artemis.bls.keystore.builder.KeyStoreDataBuilder;\n+import tech.pegasys.artemis.bls.keystore.model.Checksum;\n+import tech.pegasys.artemis.bls.keystore.model.ChecksumFunction;\n+import tech.pegasys.artemis.bls.keystore.model.Cipher;\n+import tech.pegasys.artemis.bls.keystore.model.Crypto;\n+import tech.pegasys.artemis.bls.keystore.model.Kdf;\n+import tech.pegasys.artemis.bls.keystore.model.KdfParam;\n+import tech.pegasys.artemis.bls.keystore.model.KeyStoreData;\n+import tech.pegasys.artemis.util.mikuli.PublicKey;\n+import tech.pegasys.artemis.util.mikuli.SecretKey;\n+\n+/**\n+ * BLS Key Store implementation EIP-2335\n+ *\n+ * @see <a href=\"https://github.com/ethereum/EIPs/blob/master/EIPS/eip-2335.md\">EIP-2335</a>\n+ */\n+public class KeyStore {\n+  private static final BouncyCastleProvider BC = new BouncyCastleProvider();\n+  private final KeyStoreData keyStoreData;\n+\n+  public KeyStore(final KeyStoreData keyStoreData) {\n+    this.keyStoreData = keyStoreData;\n+  }\n+\n+  public KeyStoreData getKeyStoreData() {\n+    return keyStoreData;\n+  }\n+\n+  /**\n+   * Encrypt the given BLS12-381 key with specified password.\n+   *\n+   * @param blsPrivateKey BLS12-381 private key in Bytes\n+   * @param password The password to use for encryption\n+   * @param path Path as defined in EIP-2334. Can be empty String.\n+   * @param kdfParam crypto function such as scrypt or PBKDF2 and related parameters such as dklen,\n+   *     salt etc.\n+   * @param cipher cipher function and parameters such as iv. Message is ignored.\n+   * @return The constructed KeyStore with encrypted BLS Private Key as cipher.message and other\n+   *     details as defined by the EIP-2335 standard.\n+   */\n+  public static KeyStore encrypt(\n+      final Bytes blsPrivateKey,\n+      final String password,\n+      final String path,\n+      final KdfParam kdfParam,\n+      final Cipher cipher) {\n+\n+    final Crypto crypto =\n+        encryptUsingCipherFunction(\n+            blsPrivateKey, password, kdfParam, cipher, ChecksumFunction.SHA256);\n+    final Bytes pubKey =\n+        new PublicKey(SecretKey.fromBytes(Bytes48.leftPad(blsPrivateKey))).toBytesCompressed();\n+    final KeyStoreData keyStoreData =\n+        KeyStoreDataBuilder.aKeyStoreData()\n+            .withCrypto(crypto)\n+            .withPath(path)\n+            .withPubkey(pubKey)\n+            .build();\n+\n+    return new KeyStore(keyStoreData);\n+  }\n+\n+  @VisibleForTesting\n+  static Crypto encryptUsingCipherFunction(\n+      final Bytes secret,\n+      final String password,\n+      final KdfParam kdfParam,\n+      final Cipher cipher,\n+      final ChecksumFunction checksumFunction) {\n+    checkArgument(\n+        kdfParam.getDerivedKeyLength() > 16, \"aes-128-ctr requires kdf dklen greater than 16\");\n+\n+    final Bytes decryptionKey = DecryptionKeyGenerator.generate(password.getBytes(UTF_8), kdfParam);\n+    final Bytes cipherMessage =\n+        applyCipherFunction(\n+            decryptionKey, cipher.getCipherParam().getIv(), true, secret.toArrayUnsafe());\n+    final Bytes checksumMessage =\n+        calculateChecksum(kdfParam, checksumFunction, decryptionKey, cipherMessage);\n+    final Checksum checksum =\n+        ChecksumBuilder.aChecksum()\n+            .withChecksumFunction(checksumFunction)\n+            .withMessage(checksumMessage)\n+            .build();\n+    final Cipher encryptedCipher =\n+        CipherBuilder.aCipher()\n+            .withCipherFunction(cipher.getCipherFunction())\n+            .withCipherParam(cipher.getCipherParam())\n+            .withMessage(cipherMessage)\n+            .build();\n+    final Kdf kdf = KdfBuilder.aKdf().withParam(kdfParam).build();\n+    return new Crypto(kdf, checksum, encryptedCipher);\n+  }\n+\n+  public Bytes decrypt(final String password) {\n+    Objects.requireNonNull(password);\n+    final KdfParam kdfParam = keyStoreData.getCrypto().getKdf().getParam();\n+    checkArgument(\n+        kdfParam.getDerivedKeyLength() > 16, \"aes-128-ctr requires kdf dklen greater than 16\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "baf6b00ff9bdb682f2c8bd33ca015074777003ed"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY2NzAwNw==", "bodyText": "Is there any benefit in a seperate validatePassword function instead of just calling this in decrypt before decrypting the key? Otherwise the API usage would have to be valdiatePassword followed by a decrypt(password).", "url": "https://github.com/ConsenSys/teku/pull/1212#discussion_r383667007", "createdAt": "2020-02-25T05:34:51Z", "author": {"login": "jframe"}, "path": "data/keystore/src/main/java/tech/pegasys/artemis/bls/keystore/KeyStore.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.bls.keystore;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static javax.crypto.Cipher.DECRYPT_MODE;\n+import static javax.crypto.Cipher.ENCRYPT_MODE;\n+import static org.apache.tuweni.crypto.Hash.digestUsingAlgorithm;\n+import static org.apache.tuweni.crypto.Hash.sha2_256;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import java.security.GeneralSecurityException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Objects;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes48;\n+import org.bouncycastle.jce.provider.BouncyCastleProvider;\n+import tech.pegasys.artemis.bls.keystore.builder.ChecksumBuilder;\n+import tech.pegasys.artemis.bls.keystore.builder.CipherBuilder;\n+import tech.pegasys.artemis.bls.keystore.builder.KdfBuilder;\n+import tech.pegasys.artemis.bls.keystore.builder.KeyStoreDataBuilder;\n+import tech.pegasys.artemis.bls.keystore.model.Checksum;\n+import tech.pegasys.artemis.bls.keystore.model.ChecksumFunction;\n+import tech.pegasys.artemis.bls.keystore.model.Cipher;\n+import tech.pegasys.artemis.bls.keystore.model.Crypto;\n+import tech.pegasys.artemis.bls.keystore.model.Kdf;\n+import tech.pegasys.artemis.bls.keystore.model.KdfParam;\n+import tech.pegasys.artemis.bls.keystore.model.KeyStoreData;\n+import tech.pegasys.artemis.util.mikuli.PublicKey;\n+import tech.pegasys.artemis.util.mikuli.SecretKey;\n+\n+/**\n+ * BLS Key Store implementation EIP-2335\n+ *\n+ * @see <a href=\"https://github.com/ethereum/EIPs/blob/master/EIPS/eip-2335.md\">EIP-2335</a>\n+ */\n+public class KeyStore {\n+  private static final BouncyCastleProvider BC = new BouncyCastleProvider();\n+  private final KeyStoreData keyStoreData;\n+\n+  public KeyStore(final KeyStoreData keyStoreData) {\n+    this.keyStoreData = keyStoreData;\n+  }\n+\n+  public KeyStoreData getKeyStoreData() {\n+    return keyStoreData;\n+  }\n+\n+  /**\n+   * Encrypt the given BLS12-381 key with specified password.\n+   *\n+   * @param blsPrivateKey BLS12-381 private key in Bytes\n+   * @param password The password to use for encryption\n+   * @param path Path as defined in EIP-2334. Can be empty String.\n+   * @param kdfParam crypto function such as scrypt or PBKDF2 and related parameters such as dklen,\n+   *     salt etc.\n+   * @param cipher cipher function and parameters such as iv. Message is ignored.\n+   * @return The constructed KeyStore with encrypted BLS Private Key as cipher.message and other\n+   *     details as defined by the EIP-2335 standard.\n+   */\n+  public static KeyStore encrypt(\n+      final Bytes blsPrivateKey,\n+      final String password,\n+      final String path,\n+      final KdfParam kdfParam,\n+      final Cipher cipher) {\n+\n+    final Crypto crypto =\n+        encryptUsingCipherFunction(\n+            blsPrivateKey, password, kdfParam, cipher, ChecksumFunction.SHA256);\n+    final Bytes pubKey =\n+        new PublicKey(SecretKey.fromBytes(Bytes48.leftPad(blsPrivateKey))).toBytesCompressed();\n+    final KeyStoreData keyStoreData =\n+        KeyStoreDataBuilder.aKeyStoreData()\n+            .withCrypto(crypto)\n+            .withPath(path)\n+            .withPubkey(pubKey)\n+            .build();\n+\n+    return new KeyStore(keyStoreData);\n+  }\n+\n+  @VisibleForTesting\n+  static Crypto encryptUsingCipherFunction(\n+      final Bytes secret,\n+      final String password,\n+      final KdfParam kdfParam,\n+      final Cipher cipher,\n+      final ChecksumFunction checksumFunction) {\n+    checkArgument(\n+        kdfParam.getDerivedKeyLength() > 16, \"aes-128-ctr requires kdf dklen greater than 16\");\n+\n+    final Bytes decryptionKey = DecryptionKeyGenerator.generate(password.getBytes(UTF_8), kdfParam);\n+    final Bytes cipherMessage =\n+        applyCipherFunction(\n+            decryptionKey, cipher.getCipherParam().getIv(), true, secret.toArrayUnsafe());\n+    final Bytes checksumMessage =\n+        calculateChecksum(kdfParam, checksumFunction, decryptionKey, cipherMessage);\n+    final Checksum checksum =\n+        ChecksumBuilder.aChecksum()\n+            .withChecksumFunction(checksumFunction)\n+            .withMessage(checksumMessage)\n+            .build();\n+    final Cipher encryptedCipher =\n+        CipherBuilder.aCipher()\n+            .withCipherFunction(cipher.getCipherFunction())\n+            .withCipherParam(cipher.getCipherParam())\n+            .withMessage(cipherMessage)\n+            .build();\n+    final Kdf kdf = KdfBuilder.aKdf().withParam(kdfParam).build();\n+    return new Crypto(kdf, checksum, encryptedCipher);\n+  }\n+\n+  public Bytes decrypt(final String password) {\n+    Objects.requireNonNull(password);\n+    final KdfParam kdfParam = keyStoreData.getCrypto().getKdf().getParam();\n+    checkArgument(\n+        kdfParam.getDerivedKeyLength() > 16, \"aes-128-ctr requires kdf dklen greater than 16\");\n+\n+    final Bytes decryptionKey = DecryptionKeyGenerator.generate(password.getBytes(UTF_8), kdfParam);\n+\n+    if (!validateChecksum(decryptionKey)) {\n+      throw new RuntimeException(\"Invalid checksum\");\n+    }\n+\n+    final Bytes iv = keyStoreData.getCrypto().getCipher().getCipherParam().getIv();\n+    final Bytes encryptedMessage = keyStoreData.getCrypto().getCipher().getMessage();\n+    return applyCipherFunction(decryptionKey, iv, false, encryptedMessage.toArrayUnsafe());\n+  }\n+\n+  public boolean validatePassword(final String password) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "baf6b00ff9bdb682f2c8bd33ca015074777003ed"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY2ODI3NA==", "bodyText": "This could create a dk_slice greater than 16 bytes. My reading of the spec this should be exactly 16 bytes\nDK_slice = decryption_key[16:32]", "url": "https://github.com/ConsenSys/teku/pull/1212#discussion_r383668274", "createdAt": "2020-02-25T05:40:12Z", "author": {"login": "jframe"}, "path": "data/keystore/src/main/java/tech/pegasys/artemis/bls/keystore/KeyStore.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.bls.keystore;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static javax.crypto.Cipher.DECRYPT_MODE;\n+import static javax.crypto.Cipher.ENCRYPT_MODE;\n+import static org.apache.tuweni.crypto.Hash.digestUsingAlgorithm;\n+import static org.apache.tuweni.crypto.Hash.sha2_256;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import java.security.GeneralSecurityException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Objects;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes48;\n+import org.bouncycastle.jce.provider.BouncyCastleProvider;\n+import tech.pegasys.artemis.bls.keystore.builder.ChecksumBuilder;\n+import tech.pegasys.artemis.bls.keystore.builder.CipherBuilder;\n+import tech.pegasys.artemis.bls.keystore.builder.KdfBuilder;\n+import tech.pegasys.artemis.bls.keystore.builder.KeyStoreDataBuilder;\n+import tech.pegasys.artemis.bls.keystore.model.Checksum;\n+import tech.pegasys.artemis.bls.keystore.model.ChecksumFunction;\n+import tech.pegasys.artemis.bls.keystore.model.Cipher;\n+import tech.pegasys.artemis.bls.keystore.model.Crypto;\n+import tech.pegasys.artemis.bls.keystore.model.Kdf;\n+import tech.pegasys.artemis.bls.keystore.model.KdfParam;\n+import tech.pegasys.artemis.bls.keystore.model.KeyStoreData;\n+import tech.pegasys.artemis.util.mikuli.PublicKey;\n+import tech.pegasys.artemis.util.mikuli.SecretKey;\n+\n+/**\n+ * BLS Key Store implementation EIP-2335\n+ *\n+ * @see <a href=\"https://github.com/ethereum/EIPs/blob/master/EIPS/eip-2335.md\">EIP-2335</a>\n+ */\n+public class KeyStore {\n+  private static final BouncyCastleProvider BC = new BouncyCastleProvider();\n+  private final KeyStoreData keyStoreData;\n+\n+  public KeyStore(final KeyStoreData keyStoreData) {\n+    this.keyStoreData = keyStoreData;\n+  }\n+\n+  public KeyStoreData getKeyStoreData() {\n+    return keyStoreData;\n+  }\n+\n+  /**\n+   * Encrypt the given BLS12-381 key with specified password.\n+   *\n+   * @param blsPrivateKey BLS12-381 private key in Bytes\n+   * @param password The password to use for encryption\n+   * @param path Path as defined in EIP-2334. Can be empty String.\n+   * @param kdfParam crypto function such as scrypt or PBKDF2 and related parameters such as dklen,\n+   *     salt etc.\n+   * @param cipher cipher function and parameters such as iv. Message is ignored.\n+   * @return The constructed KeyStore with encrypted BLS Private Key as cipher.message and other\n+   *     details as defined by the EIP-2335 standard.\n+   */\n+  public static KeyStore encrypt(\n+      final Bytes blsPrivateKey,\n+      final String password,\n+      final String path,\n+      final KdfParam kdfParam,\n+      final Cipher cipher) {\n+\n+    final Crypto crypto =\n+        encryptUsingCipherFunction(\n+            blsPrivateKey, password, kdfParam, cipher, ChecksumFunction.SHA256);\n+    final Bytes pubKey =\n+        new PublicKey(SecretKey.fromBytes(Bytes48.leftPad(blsPrivateKey))).toBytesCompressed();\n+    final KeyStoreData keyStoreData =\n+        KeyStoreDataBuilder.aKeyStoreData()\n+            .withCrypto(crypto)\n+            .withPath(path)\n+            .withPubkey(pubKey)\n+            .build();\n+\n+    return new KeyStore(keyStoreData);\n+  }\n+\n+  @VisibleForTesting\n+  static Crypto encryptUsingCipherFunction(\n+      final Bytes secret,\n+      final String password,\n+      final KdfParam kdfParam,\n+      final Cipher cipher,\n+      final ChecksumFunction checksumFunction) {\n+    checkArgument(\n+        kdfParam.getDerivedKeyLength() > 16, \"aes-128-ctr requires kdf dklen greater than 16\");\n+\n+    final Bytes decryptionKey = DecryptionKeyGenerator.generate(password.getBytes(UTF_8), kdfParam);\n+    final Bytes cipherMessage =\n+        applyCipherFunction(\n+            decryptionKey, cipher.getCipherParam().getIv(), true, secret.toArrayUnsafe());\n+    final Bytes checksumMessage =\n+        calculateChecksum(kdfParam, checksumFunction, decryptionKey, cipherMessage);\n+    final Checksum checksum =\n+        ChecksumBuilder.aChecksum()\n+            .withChecksumFunction(checksumFunction)\n+            .withMessage(checksumMessage)\n+            .build();\n+    final Cipher encryptedCipher =\n+        CipherBuilder.aCipher()\n+            .withCipherFunction(cipher.getCipherFunction())\n+            .withCipherParam(cipher.getCipherParam())\n+            .withMessage(cipherMessage)\n+            .build();\n+    final Kdf kdf = KdfBuilder.aKdf().withParam(kdfParam).build();\n+    return new Crypto(kdf, checksum, encryptedCipher);\n+  }\n+\n+  public Bytes decrypt(final String password) {\n+    Objects.requireNonNull(password);\n+    final KdfParam kdfParam = keyStoreData.getCrypto().getKdf().getParam();\n+    checkArgument(\n+        kdfParam.getDerivedKeyLength() > 16, \"aes-128-ctr requires kdf dklen greater than 16\");\n+\n+    final Bytes decryptionKey = DecryptionKeyGenerator.generate(password.getBytes(UTF_8), kdfParam);\n+\n+    if (!validateChecksum(decryptionKey)) {\n+      throw new RuntimeException(\"Invalid checksum\");\n+    }\n+\n+    final Bytes iv = keyStoreData.getCrypto().getCipher().getCipherParam().getIv();\n+    final Bytes encryptedMessage = keyStoreData.getCrypto().getCipher().getMessage();\n+    return applyCipherFunction(decryptionKey, iv, false, encryptedMessage.toArrayUnsafe());\n+  }\n+\n+  public boolean validatePassword(final String password) {\n+    final Bytes decryptionKey =\n+        DecryptionKeyGenerator.generate(\n+            password.getBytes(UTF_8), keyStoreData.getCrypto().getKdf().getParam());\n+    return validateChecksum(decryptionKey);\n+  }\n+\n+  private boolean validateChecksum(final Bytes decryptionKey) {\n+    final Bytes checksum =\n+        calculateChecksum(\n+            keyStoreData.getCrypto().getKdf().getParam(),\n+            keyStoreData.getCrypto().getChecksum().getChecksumFunction(),\n+            decryptionKey,\n+            keyStoreData.getCrypto().getCipher().getMessage());\n+    return Objects.equals(checksum, keyStoreData.getCrypto().getChecksum().getMessage());\n+  }\n+\n+  private static Bytes calculateChecksum(\n+      final KdfParam kdfParam,\n+      final ChecksumFunction checksumFunction,\n+      final Bytes decryptionKey,\n+      final Bytes cipherMessage) {\n+    // aes-128-ctr needs first 16 bytes for its key. The rest of the key is used to create checksum\n+    final Bytes dkSliceSecondHalf = decryptionKey.slice(16, kdfParam.getDerivedKeyLength() - 16);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "baf6b00ff9bdb682f2c8bd33ca015074777003ed"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY2ODcwMw==", "bodyText": "Although it does the same thing under the hood this would be clearer using Bytes.concatenate(dkSliceSecondHalf, cipherMessage)", "url": "https://github.com/ConsenSys/teku/pull/1212#discussion_r383668703", "createdAt": "2020-02-25T05:41:54Z", "author": {"login": "jframe"}, "path": "data/keystore/src/main/java/tech/pegasys/artemis/bls/keystore/KeyStore.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.bls.keystore;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static javax.crypto.Cipher.DECRYPT_MODE;\n+import static javax.crypto.Cipher.ENCRYPT_MODE;\n+import static org.apache.tuweni.crypto.Hash.digestUsingAlgorithm;\n+import static org.apache.tuweni.crypto.Hash.sha2_256;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import java.security.GeneralSecurityException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Objects;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes48;\n+import org.bouncycastle.jce.provider.BouncyCastleProvider;\n+import tech.pegasys.artemis.bls.keystore.builder.ChecksumBuilder;\n+import tech.pegasys.artemis.bls.keystore.builder.CipherBuilder;\n+import tech.pegasys.artemis.bls.keystore.builder.KdfBuilder;\n+import tech.pegasys.artemis.bls.keystore.builder.KeyStoreDataBuilder;\n+import tech.pegasys.artemis.bls.keystore.model.Checksum;\n+import tech.pegasys.artemis.bls.keystore.model.ChecksumFunction;\n+import tech.pegasys.artemis.bls.keystore.model.Cipher;\n+import tech.pegasys.artemis.bls.keystore.model.Crypto;\n+import tech.pegasys.artemis.bls.keystore.model.Kdf;\n+import tech.pegasys.artemis.bls.keystore.model.KdfParam;\n+import tech.pegasys.artemis.bls.keystore.model.KeyStoreData;\n+import tech.pegasys.artemis.util.mikuli.PublicKey;\n+import tech.pegasys.artemis.util.mikuli.SecretKey;\n+\n+/**\n+ * BLS Key Store implementation EIP-2335\n+ *\n+ * @see <a href=\"https://github.com/ethereum/EIPs/blob/master/EIPS/eip-2335.md\">EIP-2335</a>\n+ */\n+public class KeyStore {\n+  private static final BouncyCastleProvider BC = new BouncyCastleProvider();\n+  private final KeyStoreData keyStoreData;\n+\n+  public KeyStore(final KeyStoreData keyStoreData) {\n+    this.keyStoreData = keyStoreData;\n+  }\n+\n+  public KeyStoreData getKeyStoreData() {\n+    return keyStoreData;\n+  }\n+\n+  /**\n+   * Encrypt the given BLS12-381 key with specified password.\n+   *\n+   * @param blsPrivateKey BLS12-381 private key in Bytes\n+   * @param password The password to use for encryption\n+   * @param path Path as defined in EIP-2334. Can be empty String.\n+   * @param kdfParam crypto function such as scrypt or PBKDF2 and related parameters such as dklen,\n+   *     salt etc.\n+   * @param cipher cipher function and parameters such as iv. Message is ignored.\n+   * @return The constructed KeyStore with encrypted BLS Private Key as cipher.message and other\n+   *     details as defined by the EIP-2335 standard.\n+   */\n+  public static KeyStore encrypt(\n+      final Bytes blsPrivateKey,\n+      final String password,\n+      final String path,\n+      final KdfParam kdfParam,\n+      final Cipher cipher) {\n+\n+    final Crypto crypto =\n+        encryptUsingCipherFunction(\n+            blsPrivateKey, password, kdfParam, cipher, ChecksumFunction.SHA256);\n+    final Bytes pubKey =\n+        new PublicKey(SecretKey.fromBytes(Bytes48.leftPad(blsPrivateKey))).toBytesCompressed();\n+    final KeyStoreData keyStoreData =\n+        KeyStoreDataBuilder.aKeyStoreData()\n+            .withCrypto(crypto)\n+            .withPath(path)\n+            .withPubkey(pubKey)\n+            .build();\n+\n+    return new KeyStore(keyStoreData);\n+  }\n+\n+  @VisibleForTesting\n+  static Crypto encryptUsingCipherFunction(\n+      final Bytes secret,\n+      final String password,\n+      final KdfParam kdfParam,\n+      final Cipher cipher,\n+      final ChecksumFunction checksumFunction) {\n+    checkArgument(\n+        kdfParam.getDerivedKeyLength() > 16, \"aes-128-ctr requires kdf dklen greater than 16\");\n+\n+    final Bytes decryptionKey = DecryptionKeyGenerator.generate(password.getBytes(UTF_8), kdfParam);\n+    final Bytes cipherMessage =\n+        applyCipherFunction(\n+            decryptionKey, cipher.getCipherParam().getIv(), true, secret.toArrayUnsafe());\n+    final Bytes checksumMessage =\n+        calculateChecksum(kdfParam, checksumFunction, decryptionKey, cipherMessage);\n+    final Checksum checksum =\n+        ChecksumBuilder.aChecksum()\n+            .withChecksumFunction(checksumFunction)\n+            .withMessage(checksumMessage)\n+            .build();\n+    final Cipher encryptedCipher =\n+        CipherBuilder.aCipher()\n+            .withCipherFunction(cipher.getCipherFunction())\n+            .withCipherParam(cipher.getCipherParam())\n+            .withMessage(cipherMessage)\n+            .build();\n+    final Kdf kdf = KdfBuilder.aKdf().withParam(kdfParam).build();\n+    return new Crypto(kdf, checksum, encryptedCipher);\n+  }\n+\n+  public Bytes decrypt(final String password) {\n+    Objects.requireNonNull(password);\n+    final KdfParam kdfParam = keyStoreData.getCrypto().getKdf().getParam();\n+    checkArgument(\n+        kdfParam.getDerivedKeyLength() > 16, \"aes-128-ctr requires kdf dklen greater than 16\");\n+\n+    final Bytes decryptionKey = DecryptionKeyGenerator.generate(password.getBytes(UTF_8), kdfParam);\n+\n+    if (!validateChecksum(decryptionKey)) {\n+      throw new RuntimeException(\"Invalid checksum\");\n+    }\n+\n+    final Bytes iv = keyStoreData.getCrypto().getCipher().getCipherParam().getIv();\n+    final Bytes encryptedMessage = keyStoreData.getCrypto().getCipher().getMessage();\n+    return applyCipherFunction(decryptionKey, iv, false, encryptedMessage.toArrayUnsafe());\n+  }\n+\n+  public boolean validatePassword(final String password) {\n+    final Bytes decryptionKey =\n+        DecryptionKeyGenerator.generate(\n+            password.getBytes(UTF_8), keyStoreData.getCrypto().getKdf().getParam());\n+    return validateChecksum(decryptionKey);\n+  }\n+\n+  private boolean validateChecksum(final Bytes decryptionKey) {\n+    final Bytes checksum =\n+        calculateChecksum(\n+            keyStoreData.getCrypto().getKdf().getParam(),\n+            keyStoreData.getCrypto().getChecksum().getChecksumFunction(),\n+            decryptionKey,\n+            keyStoreData.getCrypto().getCipher().getMessage());\n+    return Objects.equals(checksum, keyStoreData.getCrypto().getChecksum().getMessage());\n+  }\n+\n+  private static Bytes calculateChecksum(\n+      final KdfParam kdfParam,\n+      final ChecksumFunction checksumFunction,\n+      final Bytes decryptionKey,\n+      final Bytes cipherMessage) {\n+    // aes-128-ctr needs first 16 bytes for its key. The rest of the key is used to create checksum\n+    final Bytes dkSliceSecondHalf = decryptionKey.slice(16, kdfParam.getDerivedKeyLength() - 16);\n+    final Bytes preImage = Bytes.wrap(dkSliceSecondHalf, cipherMessage);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "baf6b00ff9bdb682f2c8bd33ca015074777003ed"}, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY3MTI0NQ==", "bodyText": "What will happen if non-aes cipher is used? looks like we try unconditionally encrypt/decrypt using AES", "url": "https://github.com/ConsenSys/teku/pull/1212#discussion_r383671245", "createdAt": "2020-02-25T05:52:33Z", "author": {"login": "jframe"}, "path": "data/keystore/src/main/java/tech/pegasys/artemis/bls/keystore/KeyStore.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.bls.keystore;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static javax.crypto.Cipher.DECRYPT_MODE;\n+import static javax.crypto.Cipher.ENCRYPT_MODE;\n+import static org.apache.tuweni.crypto.Hash.digestUsingAlgorithm;\n+import static org.apache.tuweni.crypto.Hash.sha2_256;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import java.security.GeneralSecurityException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Objects;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes48;\n+import org.bouncycastle.jce.provider.BouncyCastleProvider;\n+import tech.pegasys.artemis.bls.keystore.builder.ChecksumBuilder;\n+import tech.pegasys.artemis.bls.keystore.builder.CipherBuilder;\n+import tech.pegasys.artemis.bls.keystore.builder.KdfBuilder;\n+import tech.pegasys.artemis.bls.keystore.builder.KeyStoreDataBuilder;\n+import tech.pegasys.artemis.bls.keystore.model.Checksum;\n+import tech.pegasys.artemis.bls.keystore.model.ChecksumFunction;\n+import tech.pegasys.artemis.bls.keystore.model.Cipher;\n+import tech.pegasys.artemis.bls.keystore.model.Crypto;\n+import tech.pegasys.artemis.bls.keystore.model.Kdf;\n+import tech.pegasys.artemis.bls.keystore.model.KdfParam;\n+import tech.pegasys.artemis.bls.keystore.model.KeyStoreData;\n+import tech.pegasys.artemis.util.mikuli.PublicKey;\n+import tech.pegasys.artemis.util.mikuli.SecretKey;\n+\n+/**\n+ * BLS Key Store implementation EIP-2335\n+ *\n+ * @see <a href=\"https://github.com/ethereum/EIPs/blob/master/EIPS/eip-2335.md\">EIP-2335</a>\n+ */\n+public class KeyStore {\n+  private static final BouncyCastleProvider BC = new BouncyCastleProvider();\n+  private final KeyStoreData keyStoreData;\n+\n+  public KeyStore(final KeyStoreData keyStoreData) {\n+    this.keyStoreData = keyStoreData;\n+  }\n+\n+  public KeyStoreData getKeyStoreData() {\n+    return keyStoreData;\n+  }\n+\n+  /**\n+   * Encrypt the given BLS12-381 key with specified password.\n+   *\n+   * @param blsPrivateKey BLS12-381 private key in Bytes\n+   * @param password The password to use for encryption\n+   * @param path Path as defined in EIP-2334. Can be empty String.\n+   * @param kdfParam crypto function such as scrypt or PBKDF2 and related parameters such as dklen,\n+   *     salt etc.\n+   * @param cipher cipher function and parameters such as iv. Message is ignored.\n+   * @return The constructed KeyStore with encrypted BLS Private Key as cipher.message and other\n+   *     details as defined by the EIP-2335 standard.\n+   */\n+  public static KeyStore encrypt(\n+      final Bytes blsPrivateKey,\n+      final String password,\n+      final String path,\n+      final KdfParam kdfParam,\n+      final Cipher cipher) {\n+\n+    final Crypto crypto =\n+        encryptUsingCipherFunction(\n+            blsPrivateKey, password, kdfParam, cipher, ChecksumFunction.SHA256);\n+    final Bytes pubKey =\n+        new PublicKey(SecretKey.fromBytes(Bytes48.leftPad(blsPrivateKey))).toBytesCompressed();\n+    final KeyStoreData keyStoreData =\n+        KeyStoreDataBuilder.aKeyStoreData()\n+            .withCrypto(crypto)\n+            .withPath(path)\n+            .withPubkey(pubKey)\n+            .build();\n+\n+    return new KeyStore(keyStoreData);\n+  }\n+\n+  @VisibleForTesting\n+  static Crypto encryptUsingCipherFunction(\n+      final Bytes secret,\n+      final String password,\n+      final KdfParam kdfParam,\n+      final Cipher cipher,\n+      final ChecksumFunction checksumFunction) {\n+    checkArgument(\n+        kdfParam.getDerivedKeyLength() > 16, \"aes-128-ctr requires kdf dklen greater than 16\");\n+\n+    final Bytes decryptionKey = DecryptionKeyGenerator.generate(password.getBytes(UTF_8), kdfParam);\n+    final Bytes cipherMessage =\n+        applyCipherFunction(\n+            decryptionKey, cipher.getCipherParam().getIv(), true, secret.toArrayUnsafe());\n+    final Bytes checksumMessage =\n+        calculateChecksum(kdfParam, checksumFunction, decryptionKey, cipherMessage);\n+    final Checksum checksum =\n+        ChecksumBuilder.aChecksum()\n+            .withChecksumFunction(checksumFunction)\n+            .withMessage(checksumMessage)\n+            .build();\n+    final Cipher encryptedCipher =\n+        CipherBuilder.aCipher()\n+            .withCipherFunction(cipher.getCipherFunction())\n+            .withCipherParam(cipher.getCipherParam())\n+            .withMessage(cipherMessage)\n+            .build();\n+    final Kdf kdf = KdfBuilder.aKdf().withParam(kdfParam).build();\n+    return new Crypto(kdf, checksum, encryptedCipher);\n+  }\n+\n+  public Bytes decrypt(final String password) {\n+    Objects.requireNonNull(password);\n+    final KdfParam kdfParam = keyStoreData.getCrypto().getKdf().getParam();\n+    checkArgument(\n+        kdfParam.getDerivedKeyLength() > 16, \"aes-128-ctr requires kdf dklen greater than 16\");\n+\n+    final Bytes decryptionKey = DecryptionKeyGenerator.generate(password.getBytes(UTF_8), kdfParam);\n+\n+    if (!validateChecksum(decryptionKey)) {\n+      throw new RuntimeException(\"Invalid checksum\");\n+    }\n+\n+    final Bytes iv = keyStoreData.getCrypto().getCipher().getCipherParam().getIv();\n+    final Bytes encryptedMessage = keyStoreData.getCrypto().getCipher().getMessage();\n+    return applyCipherFunction(decryptionKey, iv, false, encryptedMessage.toArrayUnsafe());\n+  }\n+\n+  public boolean validatePassword(final String password) {\n+    final Bytes decryptionKey =\n+        DecryptionKeyGenerator.generate(\n+            password.getBytes(UTF_8), keyStoreData.getCrypto().getKdf().getParam());\n+    return validateChecksum(decryptionKey);\n+  }\n+\n+  private boolean validateChecksum(final Bytes decryptionKey) {\n+    final Bytes checksum =\n+        calculateChecksum(\n+            keyStoreData.getCrypto().getKdf().getParam(),\n+            keyStoreData.getCrypto().getChecksum().getChecksumFunction(),\n+            decryptionKey,\n+            keyStoreData.getCrypto().getCipher().getMessage());\n+    return Objects.equals(checksum, keyStoreData.getCrypto().getChecksum().getMessage());\n+  }\n+\n+  private static Bytes calculateChecksum(\n+      final KdfParam kdfParam,\n+      final ChecksumFunction checksumFunction,\n+      final Bytes decryptionKey,\n+      final Bytes cipherMessage) {\n+    // aes-128-ctr needs first 16 bytes for its key. The rest of the key is used to create checksum\n+    final Bytes dkSliceSecondHalf = decryptionKey.slice(16, kdfParam.getDerivedKeyLength() - 16);\n+    final Bytes preImage = Bytes.wrap(dkSliceSecondHalf, cipherMessage);\n+    switch (checksumFunction) {\n+      case SHA256:\n+        return sha2_256(preImage);\n+      case SHA512:\n+        return sha2_512(preImage);\n+      default:\n+        throw new IllegalArgumentException(\"checksum function not supported: \" + checksumFunction);\n+    }\n+  }\n+\n+  private static Bytes applyCipherFunction(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "baf6b00ff9bdb682f2c8bd33ca015074777003ed"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY3MTU3MA==", "bodyText": "The call to update is unnecessary you can just call doFinal with the entire message", "url": "https://github.com/ConsenSys/teku/pull/1212#discussion_r383671570", "createdAt": "2020-02-25T05:53:53Z", "author": {"login": "jframe"}, "path": "data/keystore/src/main/java/tech/pegasys/artemis/bls/keystore/KeyStore.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.bls.keystore;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static javax.crypto.Cipher.DECRYPT_MODE;\n+import static javax.crypto.Cipher.ENCRYPT_MODE;\n+import static org.apache.tuweni.crypto.Hash.digestUsingAlgorithm;\n+import static org.apache.tuweni.crypto.Hash.sha2_256;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import java.security.GeneralSecurityException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Objects;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes48;\n+import org.bouncycastle.jce.provider.BouncyCastleProvider;\n+import tech.pegasys.artemis.bls.keystore.builder.ChecksumBuilder;\n+import tech.pegasys.artemis.bls.keystore.builder.CipherBuilder;\n+import tech.pegasys.artemis.bls.keystore.builder.KdfBuilder;\n+import tech.pegasys.artemis.bls.keystore.builder.KeyStoreDataBuilder;\n+import tech.pegasys.artemis.bls.keystore.model.Checksum;\n+import tech.pegasys.artemis.bls.keystore.model.ChecksumFunction;\n+import tech.pegasys.artemis.bls.keystore.model.Cipher;\n+import tech.pegasys.artemis.bls.keystore.model.Crypto;\n+import tech.pegasys.artemis.bls.keystore.model.Kdf;\n+import tech.pegasys.artemis.bls.keystore.model.KdfParam;\n+import tech.pegasys.artemis.bls.keystore.model.KeyStoreData;\n+import tech.pegasys.artemis.util.mikuli.PublicKey;\n+import tech.pegasys.artemis.util.mikuli.SecretKey;\n+\n+/**\n+ * BLS Key Store implementation EIP-2335\n+ *\n+ * @see <a href=\"https://github.com/ethereum/EIPs/blob/master/EIPS/eip-2335.md\">EIP-2335</a>\n+ */\n+public class KeyStore {\n+  private static final BouncyCastleProvider BC = new BouncyCastleProvider();\n+  private final KeyStoreData keyStoreData;\n+\n+  public KeyStore(final KeyStoreData keyStoreData) {\n+    this.keyStoreData = keyStoreData;\n+  }\n+\n+  public KeyStoreData getKeyStoreData() {\n+    return keyStoreData;\n+  }\n+\n+  /**\n+   * Encrypt the given BLS12-381 key with specified password.\n+   *\n+   * @param blsPrivateKey BLS12-381 private key in Bytes\n+   * @param password The password to use for encryption\n+   * @param path Path as defined in EIP-2334. Can be empty String.\n+   * @param kdfParam crypto function such as scrypt or PBKDF2 and related parameters such as dklen,\n+   *     salt etc.\n+   * @param cipher cipher function and parameters such as iv. Message is ignored.\n+   * @return The constructed KeyStore with encrypted BLS Private Key as cipher.message and other\n+   *     details as defined by the EIP-2335 standard.\n+   */\n+  public static KeyStore encrypt(\n+      final Bytes blsPrivateKey,\n+      final String password,\n+      final String path,\n+      final KdfParam kdfParam,\n+      final Cipher cipher) {\n+\n+    final Crypto crypto =\n+        encryptUsingCipherFunction(\n+            blsPrivateKey, password, kdfParam, cipher, ChecksumFunction.SHA256);\n+    final Bytes pubKey =\n+        new PublicKey(SecretKey.fromBytes(Bytes48.leftPad(blsPrivateKey))).toBytesCompressed();\n+    final KeyStoreData keyStoreData =\n+        KeyStoreDataBuilder.aKeyStoreData()\n+            .withCrypto(crypto)\n+            .withPath(path)\n+            .withPubkey(pubKey)\n+            .build();\n+\n+    return new KeyStore(keyStoreData);\n+  }\n+\n+  @VisibleForTesting\n+  static Crypto encryptUsingCipherFunction(\n+      final Bytes secret,\n+      final String password,\n+      final KdfParam kdfParam,\n+      final Cipher cipher,\n+      final ChecksumFunction checksumFunction) {\n+    checkArgument(\n+        kdfParam.getDerivedKeyLength() > 16, \"aes-128-ctr requires kdf dklen greater than 16\");\n+\n+    final Bytes decryptionKey = DecryptionKeyGenerator.generate(password.getBytes(UTF_8), kdfParam);\n+    final Bytes cipherMessage =\n+        applyCipherFunction(\n+            decryptionKey, cipher.getCipherParam().getIv(), true, secret.toArrayUnsafe());\n+    final Bytes checksumMessage =\n+        calculateChecksum(kdfParam, checksumFunction, decryptionKey, cipherMessage);\n+    final Checksum checksum =\n+        ChecksumBuilder.aChecksum()\n+            .withChecksumFunction(checksumFunction)\n+            .withMessage(checksumMessage)\n+            .build();\n+    final Cipher encryptedCipher =\n+        CipherBuilder.aCipher()\n+            .withCipherFunction(cipher.getCipherFunction())\n+            .withCipherParam(cipher.getCipherParam())\n+            .withMessage(cipherMessage)\n+            .build();\n+    final Kdf kdf = KdfBuilder.aKdf().withParam(kdfParam).build();\n+    return new Crypto(kdf, checksum, encryptedCipher);\n+  }\n+\n+  public Bytes decrypt(final String password) {\n+    Objects.requireNonNull(password);\n+    final KdfParam kdfParam = keyStoreData.getCrypto().getKdf().getParam();\n+    checkArgument(\n+        kdfParam.getDerivedKeyLength() > 16, \"aes-128-ctr requires kdf dklen greater than 16\");\n+\n+    final Bytes decryptionKey = DecryptionKeyGenerator.generate(password.getBytes(UTF_8), kdfParam);\n+\n+    if (!validateChecksum(decryptionKey)) {\n+      throw new RuntimeException(\"Invalid checksum\");\n+    }\n+\n+    final Bytes iv = keyStoreData.getCrypto().getCipher().getCipherParam().getIv();\n+    final Bytes encryptedMessage = keyStoreData.getCrypto().getCipher().getMessage();\n+    return applyCipherFunction(decryptionKey, iv, false, encryptedMessage.toArrayUnsafe());\n+  }\n+\n+  public boolean validatePassword(final String password) {\n+    final Bytes decryptionKey =\n+        DecryptionKeyGenerator.generate(\n+            password.getBytes(UTF_8), keyStoreData.getCrypto().getKdf().getParam());\n+    return validateChecksum(decryptionKey);\n+  }\n+\n+  private boolean validateChecksum(final Bytes decryptionKey) {\n+    final Bytes checksum =\n+        calculateChecksum(\n+            keyStoreData.getCrypto().getKdf().getParam(),\n+            keyStoreData.getCrypto().getChecksum().getChecksumFunction(),\n+            decryptionKey,\n+            keyStoreData.getCrypto().getCipher().getMessage());\n+    return Objects.equals(checksum, keyStoreData.getCrypto().getChecksum().getMessage());\n+  }\n+\n+  private static Bytes calculateChecksum(\n+      final KdfParam kdfParam,\n+      final ChecksumFunction checksumFunction,\n+      final Bytes decryptionKey,\n+      final Bytes cipherMessage) {\n+    // aes-128-ctr needs first 16 bytes for its key. The rest of the key is used to create checksum\n+    final Bytes dkSliceSecondHalf = decryptionKey.slice(16, kdfParam.getDerivedKeyLength() - 16);\n+    final Bytes preImage = Bytes.wrap(dkSliceSecondHalf, cipherMessage);\n+    switch (checksumFunction) {\n+      case SHA256:\n+        return sha2_256(preImage);\n+      case SHA512:\n+        return sha2_512(preImage);\n+      default:\n+        throw new IllegalArgumentException(\"checksum function not supported: \" + checksumFunction);\n+    }\n+  }\n+\n+  private static Bytes applyCipherFunction(\n+      final Bytes decryptionKey, final Bytes iv, boolean encryptMode, final byte[] inputMessage) {\n+    // aes-128-ctr requires a key size of 16. Use first 16 bytes of decryption key as AES key,\n+    // rest of the decryption key will be used to create checksum later on\n+    final SecretKeySpec secretKey =\n+        new SecretKeySpec(decryptionKey.slice(0, 16).toArrayUnsafe(), \"AES\");\n+\n+    final IvParameterSpec ivParameterSpec = new IvParameterSpec(iv.toArrayUnsafe());\n+    Bytes cipherMessage = Bytes.EMPTY;\n+    try {\n+      final javax.crypto.Cipher cipher = javax.crypto.Cipher.getInstance(\"AES/CTR/NoPadding\", BC);\n+      cipher.init(encryptMode ? ENCRYPT_MODE : DECRYPT_MODE, secretKey, ivParameterSpec);\n+\n+      int blockSize = cipher.getBlockSize(); // AES cipher block size is 16.\n+      int blockIndex = 0;\n+      while (blockIndex < inputMessage.length - blockSize) {\n+        cipherMessage =\n+            Bytes.wrap(\n+                cipherMessage, Bytes.wrap(cipher.update(inputMessage, blockIndex, blockSize)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "baf6b00ff9bdb682f2c8bd33ca015074777003ed"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY3MTgxMw==", "bodyText": "Is there a more specific exception that can be used?", "url": "https://github.com/ConsenSys/teku/pull/1212#discussion_r383671813", "createdAt": "2020-02-25T05:54:50Z", "author": {"login": "jframe"}, "path": "data/keystore/src/main/java/tech/pegasys/artemis/bls/keystore/KeyStore.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.bls.keystore;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static javax.crypto.Cipher.DECRYPT_MODE;\n+import static javax.crypto.Cipher.ENCRYPT_MODE;\n+import static org.apache.tuweni.crypto.Hash.digestUsingAlgorithm;\n+import static org.apache.tuweni.crypto.Hash.sha2_256;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import java.security.GeneralSecurityException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Objects;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes48;\n+import org.bouncycastle.jce.provider.BouncyCastleProvider;\n+import tech.pegasys.artemis.bls.keystore.builder.ChecksumBuilder;\n+import tech.pegasys.artemis.bls.keystore.builder.CipherBuilder;\n+import tech.pegasys.artemis.bls.keystore.builder.KdfBuilder;\n+import tech.pegasys.artemis.bls.keystore.builder.KeyStoreDataBuilder;\n+import tech.pegasys.artemis.bls.keystore.model.Checksum;\n+import tech.pegasys.artemis.bls.keystore.model.ChecksumFunction;\n+import tech.pegasys.artemis.bls.keystore.model.Cipher;\n+import tech.pegasys.artemis.bls.keystore.model.Crypto;\n+import tech.pegasys.artemis.bls.keystore.model.Kdf;\n+import tech.pegasys.artemis.bls.keystore.model.KdfParam;\n+import tech.pegasys.artemis.bls.keystore.model.KeyStoreData;\n+import tech.pegasys.artemis.util.mikuli.PublicKey;\n+import tech.pegasys.artemis.util.mikuli.SecretKey;\n+\n+/**\n+ * BLS Key Store implementation EIP-2335\n+ *\n+ * @see <a href=\"https://github.com/ethereum/EIPs/blob/master/EIPS/eip-2335.md\">EIP-2335</a>\n+ */\n+public class KeyStore {\n+  private static final BouncyCastleProvider BC = new BouncyCastleProvider();\n+  private final KeyStoreData keyStoreData;\n+\n+  public KeyStore(final KeyStoreData keyStoreData) {\n+    this.keyStoreData = keyStoreData;\n+  }\n+\n+  public KeyStoreData getKeyStoreData() {\n+    return keyStoreData;\n+  }\n+\n+  /**\n+   * Encrypt the given BLS12-381 key with specified password.\n+   *\n+   * @param blsPrivateKey BLS12-381 private key in Bytes\n+   * @param password The password to use for encryption\n+   * @param path Path as defined in EIP-2334. Can be empty String.\n+   * @param kdfParam crypto function such as scrypt or PBKDF2 and related parameters such as dklen,\n+   *     salt etc.\n+   * @param cipher cipher function and parameters such as iv. Message is ignored.\n+   * @return The constructed KeyStore with encrypted BLS Private Key as cipher.message and other\n+   *     details as defined by the EIP-2335 standard.\n+   */\n+  public static KeyStore encrypt(\n+      final Bytes blsPrivateKey,\n+      final String password,\n+      final String path,\n+      final KdfParam kdfParam,\n+      final Cipher cipher) {\n+\n+    final Crypto crypto =\n+        encryptUsingCipherFunction(\n+            blsPrivateKey, password, kdfParam, cipher, ChecksumFunction.SHA256);\n+    final Bytes pubKey =\n+        new PublicKey(SecretKey.fromBytes(Bytes48.leftPad(blsPrivateKey))).toBytesCompressed();\n+    final KeyStoreData keyStoreData =\n+        KeyStoreDataBuilder.aKeyStoreData()\n+            .withCrypto(crypto)\n+            .withPath(path)\n+            .withPubkey(pubKey)\n+            .build();\n+\n+    return new KeyStore(keyStoreData);\n+  }\n+\n+  @VisibleForTesting\n+  static Crypto encryptUsingCipherFunction(\n+      final Bytes secret,\n+      final String password,\n+      final KdfParam kdfParam,\n+      final Cipher cipher,\n+      final ChecksumFunction checksumFunction) {\n+    checkArgument(\n+        kdfParam.getDerivedKeyLength() > 16, \"aes-128-ctr requires kdf dklen greater than 16\");\n+\n+    final Bytes decryptionKey = DecryptionKeyGenerator.generate(password.getBytes(UTF_8), kdfParam);\n+    final Bytes cipherMessage =\n+        applyCipherFunction(\n+            decryptionKey, cipher.getCipherParam().getIv(), true, secret.toArrayUnsafe());\n+    final Bytes checksumMessage =\n+        calculateChecksum(kdfParam, checksumFunction, decryptionKey, cipherMessage);\n+    final Checksum checksum =\n+        ChecksumBuilder.aChecksum()\n+            .withChecksumFunction(checksumFunction)\n+            .withMessage(checksumMessage)\n+            .build();\n+    final Cipher encryptedCipher =\n+        CipherBuilder.aCipher()\n+            .withCipherFunction(cipher.getCipherFunction())\n+            .withCipherParam(cipher.getCipherParam())\n+            .withMessage(cipherMessage)\n+            .build();\n+    final Kdf kdf = KdfBuilder.aKdf().withParam(kdfParam).build();\n+    return new Crypto(kdf, checksum, encryptedCipher);\n+  }\n+\n+  public Bytes decrypt(final String password) {\n+    Objects.requireNonNull(password);\n+    final KdfParam kdfParam = keyStoreData.getCrypto().getKdf().getParam();\n+    checkArgument(\n+        kdfParam.getDerivedKeyLength() > 16, \"aes-128-ctr requires kdf dklen greater than 16\");\n+\n+    final Bytes decryptionKey = DecryptionKeyGenerator.generate(password.getBytes(UTF_8), kdfParam);\n+\n+    if (!validateChecksum(decryptionKey)) {\n+      throw new RuntimeException(\"Invalid checksum\");\n+    }\n+\n+    final Bytes iv = keyStoreData.getCrypto().getCipher().getCipherParam().getIv();\n+    final Bytes encryptedMessage = keyStoreData.getCrypto().getCipher().getMessage();\n+    return applyCipherFunction(decryptionKey, iv, false, encryptedMessage.toArrayUnsafe());\n+  }\n+\n+  public boolean validatePassword(final String password) {\n+    final Bytes decryptionKey =\n+        DecryptionKeyGenerator.generate(\n+            password.getBytes(UTF_8), keyStoreData.getCrypto().getKdf().getParam());\n+    return validateChecksum(decryptionKey);\n+  }\n+\n+  private boolean validateChecksum(final Bytes decryptionKey) {\n+    final Bytes checksum =\n+        calculateChecksum(\n+            keyStoreData.getCrypto().getKdf().getParam(),\n+            keyStoreData.getCrypto().getChecksum().getChecksumFunction(),\n+            decryptionKey,\n+            keyStoreData.getCrypto().getCipher().getMessage());\n+    return Objects.equals(checksum, keyStoreData.getCrypto().getChecksum().getMessage());\n+  }\n+\n+  private static Bytes calculateChecksum(\n+      final KdfParam kdfParam,\n+      final ChecksumFunction checksumFunction,\n+      final Bytes decryptionKey,\n+      final Bytes cipherMessage) {\n+    // aes-128-ctr needs first 16 bytes for its key. The rest of the key is used to create checksum\n+    final Bytes dkSliceSecondHalf = decryptionKey.slice(16, kdfParam.getDerivedKeyLength() - 16);\n+    final Bytes preImage = Bytes.wrap(dkSliceSecondHalf, cipherMessage);\n+    switch (checksumFunction) {\n+      case SHA256:\n+        return sha2_256(preImage);\n+      case SHA512:\n+        return sha2_512(preImage);\n+      default:\n+        throw new IllegalArgumentException(\"checksum function not supported: \" + checksumFunction);\n+    }\n+  }\n+\n+  private static Bytes applyCipherFunction(\n+      final Bytes decryptionKey, final Bytes iv, boolean encryptMode, final byte[] inputMessage) {\n+    // aes-128-ctr requires a key size of 16. Use first 16 bytes of decryption key as AES key,\n+    // rest of the decryption key will be used to create checksum later on\n+    final SecretKeySpec secretKey =\n+        new SecretKeySpec(decryptionKey.slice(0, 16).toArrayUnsafe(), \"AES\");\n+\n+    final IvParameterSpec ivParameterSpec = new IvParameterSpec(iv.toArrayUnsafe());\n+    Bytes cipherMessage = Bytes.EMPTY;\n+    try {\n+      final javax.crypto.Cipher cipher = javax.crypto.Cipher.getInstance(\"AES/CTR/NoPadding\", BC);\n+      cipher.init(encryptMode ? ENCRYPT_MODE : DECRYPT_MODE, secretKey, ivParameterSpec);\n+\n+      int blockSize = cipher.getBlockSize(); // AES cipher block size is 16.\n+      int blockIndex = 0;\n+      while (blockIndex < inputMessage.length - blockSize) {\n+        cipherMessage =\n+            Bytes.wrap(\n+                cipherMessage, Bytes.wrap(cipher.update(inputMessage, blockIndex, blockSize)));\n+        blockIndex += blockSize;\n+      }\n+\n+      return Bytes.wrap(\n+          cipherMessage,\n+          Bytes.wrap(cipher.doFinal(inputMessage, blockIndex, inputMessage.length - blockIndex)));\n+    } catch (final GeneralSecurityException e) {\n+      throw new RuntimeException(\"Error applying aes-128-ctr cipher function\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "baf6b00ff9bdb682f2c8bd33ca015074777003ed"}, "originalPosition": 206}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY3MzUzMQ==", "bodyText": "Looks like this only ever used in the tests and so should be moved out of prod code", "url": "https://github.com/ConsenSys/teku/pull/1212#discussion_r383673531", "createdAt": "2020-02-25T06:01:37Z", "author": {"login": "jframe"}, "path": "data/keystore/src/main/java/tech/pegasys/artemis/bls/keystore/builder/Pbkdf2ParamBuilder.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.bls.keystore.builder;\n+\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.artemis.bls.keystore.model.Pbkdf2Param;\n+import tech.pegasys.artemis.bls.keystore.model.Pbkdf2PseudoRandomFunction;\n+\n+public final class Pbkdf2ParamBuilder {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "baf6b00ff9bdb682f2c8bd33ca015074777003ed"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY3Mzc3Ng==", "bodyText": "Don't think it makes sense to have this as a default", "url": "https://github.com/ConsenSys/teku/pull/1212#discussion_r383673776", "createdAt": "2020-02-25T06:02:24Z", "author": {"login": "jframe"}, "path": "data/keystore/src/main/java/tech/pegasys/artemis/bls/keystore/builder/Pbkdf2ParamBuilder.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.bls.keystore.builder;\n+\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.artemis.bls.keystore.model.Pbkdf2Param;\n+import tech.pegasys.artemis.bls.keystore.model.Pbkdf2PseudoRandomFunction;\n+\n+public final class Pbkdf2ParamBuilder {\n+  private Integer dklen = 32;\n+  private Bytes32 salt;\n+  private Integer iterativeCount = 262144;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "baf6b00ff9bdb682f2c8bd33ca015074777003ed"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY3NDA3NA==", "bodyText": "This also looks like it belongs in the test package", "url": "https://github.com/ConsenSys/teku/pull/1212#discussion_r383674074", "createdAt": "2020-02-25T06:03:31Z", "author": {"login": "jframe"}, "path": "data/keystore/src/main/java/tech/pegasys/artemis/bls/keystore/builder/SCryptParamBuilder.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.bls.keystore.builder;\n+\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.artemis.bls.keystore.model.SCryptParam;\n+\n+public final class SCryptParamBuilder {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "baf6b00ff9bdb682f2c8bd33ca015074777003ed"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY4MzY2Nw==", "bodyText": "Is salt always 32 bytes?", "url": "https://github.com/ConsenSys/teku/pull/1212#discussion_r383683667", "createdAt": "2020-02-25T06:38:56Z", "author": {"login": "jframe"}, "path": "data/keystore/src/main/java/tech/pegasys/artemis/bls/keystore/model/KdfParam.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.bls.keystore.model;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.base.MoreObjects;\n+import org.apache.tuweni.bytes.Bytes32;\n+\n+public abstract class KdfParam extends Param {\n+  private final Integer dklen;\n+  private final Bytes32 salt;\n+\n+  public KdfParam(final Integer dklen, final Bytes32 salt) {\n+    this.dklen = dklen;\n+    this.salt = salt;\n+  }\n+\n+  @JsonProperty(value = \"dklen\")\n+  public Integer getDerivedKeyLength() {\n+    return dklen;\n+  }\n+\n+  @JsonProperty(value = \"salt\")\n+  public Bytes32 getSalt() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "baf6b00ff9bdb682f2c8bd33ca015074777003ed"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY4NDg2MA==", "bodyText": "If this is just representing an empty param can just rename this to emptyParam to make it clearer", "url": "https://github.com/ConsenSys/teku/pull/1212#discussion_r383684860", "createdAt": "2020-02-25T06:43:12Z", "author": {"login": "jframe"}, "path": "data/keystore/src/main/java/tech/pegasys/artemis/bls/keystore/model/Param.java", "diffHunk": "@@ -0,0 +1,27 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.bls.keystore.model;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n+\n+/** Placeholder for empty params */\n+@JsonIgnoreProperties(ignoreUnknown = true)\n+public class Param {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "baf6b00ff9bdb682f2c8bd33ca015074777003ed"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY4Njc1Mg==", "bodyText": "Can this be renamed to indicate that is creating kdf params with large dkLens", "url": "https://github.com/ConsenSys/teku/pull/1212#discussion_r383686752", "createdAt": "2020-02-25T06:49:22Z", "author": {"login": "jframe"}, "path": "data/keystore/src/test/java/tech/pegasys/artemis/bls/keystore/DecryptionKeyGeneratorTest.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.bls.keystore;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+import java.util.stream.Stream;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import tech.pegasys.artemis.bls.keystore.builder.Pbkdf2ParamBuilder;\n+import tech.pegasys.artemis.bls.keystore.builder.SCryptParamBuilder;\n+import tech.pegasys.artemis.bls.keystore.model.KdfParam;\n+import tech.pegasys.artemis.bls.keystore.model.Pbkdf2Param;\n+import tech.pegasys.artemis.bls.keystore.model.Pbkdf2PseudoRandomFunction;\n+import tech.pegasys.artemis.bls.keystore.model.SCryptParam;\n+\n+class DecryptionKeyGeneratorTest {\n+  private static final Bytes32 SALT =\n+      Bytes32.fromHexString(\"d4e56740f876aef8c010b86a40d5f56745a118d0906a34e69aec8c0db1cb8fa3\");\n+\n+  @Test\n+  void defaultDkLen() {\n+    final SCryptParam kdfParam = SCryptParamBuilder.aSCryptParam().withSalt(SALT).build();\n+    final Bytes decryptionKey =\n+        DecryptionKeyGenerator.generate(Bytes.random(264).toArrayUnsafe(), kdfParam);\n+    assertEquals(32, decryptionKey.size());\n+  }\n+\n+  @SuppressWarnings(\"UnusedMethod\")\n+  private static Stream<Arguments> basicKdfParam() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "baf6b00ff9bdb682f2c8bd33ca015074777003ed"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY4ODAxMg==", "bodyText": "Rather there wasn't conditional assertions in the test. Perhaps just split out to two seperate tests one for scrypt and one for pbkdf2.", "url": "https://github.com/ConsenSys/teku/pull/1212#discussion_r383688012", "createdAt": "2020-02-25T06:53:33Z", "author": {"login": "jframe"}, "path": "data/keystore/src/test/java/tech/pegasys/artemis/bls/keystore/KeyStoreTest.java", "diffHunk": "@@ -0,0 +1,262 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.bls.keystore;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static tech.pegasys.artemis.bls.keystore.model.CipherFunction.AES_128_CTR;\n+import static tech.pegasys.artemis.bls.keystore.model.CryptoFunction.PBKDF2;\n+import static tech.pegasys.artemis.bls.keystore.model.CryptoFunction.SCRYPT;\n+\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.google.common.io.Resources;\n+import java.net.URISyntaxException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.stream.Stream;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import tech.pegasys.artemis.bls.keystore.builder.CipherBuilder;\n+import tech.pegasys.artemis.bls.keystore.builder.CipherParamBuilder;\n+import tech.pegasys.artemis.bls.keystore.builder.Pbkdf2ParamBuilder;\n+import tech.pegasys.artemis.bls.keystore.builder.SCryptParamBuilder;\n+import tech.pegasys.artemis.bls.keystore.model.ChecksumFunction;\n+import tech.pegasys.artemis.bls.keystore.model.Cipher;\n+import tech.pegasys.artemis.bls.keystore.model.CipherParam;\n+import tech.pegasys.artemis.bls.keystore.model.Crypto;\n+import tech.pegasys.artemis.bls.keystore.model.CryptoFunction;\n+import tech.pegasys.artemis.bls.keystore.model.KdfParam;\n+import tech.pegasys.artemis.bls.keystore.model.KeyStoreData;\n+import tech.pegasys.artemis.bls.keystore.model.Pbkdf2Param;\n+import tech.pegasys.artemis.bls.keystore.model.SCryptParam;\n+\n+class KeyStoreTest {\n+  private static final String PASSWORD = \"testpassword\";\n+  private static final Bytes BLS_PRIVATE_KEY =\n+      Bytes.fromHexString(\"0x000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f\");\n+  private static final Bytes32 SALT =\n+      Bytes32.fromHexString(\"d4e56740f876aef8c010b86a40d5f56745a118d0906a34e69aec8c0db1cb8fa3\");\n+  private static final Bytes AES_IV_PARAM = Bytes.fromHexString(\"264daa3f303d7259501c93d997d84fe6\");\n+\n+  private static final String scryptTestVectorJsonResource = \"scryptTestVector.json\";\n+  private static final String pbkdf2TestVectorJsonResource = \"pbkdf2TestVector.json\";\n+  private static final String missingKdfParamTestVectorJsonResource =\n+      \"missingKdfSectionTestVector.json\";\n+  private static final String unsupportedChecksumFunctionJsonResource =\n+      \"unsupportedChecksumFunction.json\";\n+\n+  @SuppressWarnings(\"UnusedMethod\")\n+  private static Stream<Arguments> keystorePaths() {\n+    try {\n+      final Path scryptTestVectorPath =\n+          Paths.get(Resources.getResource(scryptTestVectorJsonResource).toURI());\n+      final Path pbkdf2TestVectorPath =\n+          Paths.get(Resources.getResource(pbkdf2TestVectorJsonResource).toURI());\n+      return Stream.of(Arguments.of(scryptTestVectorPath), Arguments.of(pbkdf2TestVectorPath));\n+    } catch (URISyntaxException e) {\n+      throw new IllegalStateException(e);\n+    }\n+  }\n+\n+  @SuppressWarnings(\"UnusedMethod\")\n+  private static Stream<Arguments> invalidKeyStorePaths() {\n+    try {\n+      final Path scryptTestVectorPath =\n+          Paths.get(Resources.getResource(missingKdfParamTestVectorJsonResource).toURI());\n+      final Path pbkdf2TestVectorPath =\n+          Paths.get(Resources.getResource(unsupportedChecksumFunctionJsonResource).toURI());\n+      return Stream.of(Arguments.of(scryptTestVectorPath), Arguments.of(pbkdf2TestVectorPath));\n+    } catch (URISyntaxException e) {\n+      throw new IllegalStateException(e);\n+    }\n+  }\n+\n+  @SuppressWarnings(\"UnusedMethod\")\n+  private static Stream<Arguments> kdfParams() {\n+    // KdfParam, expected checksum, expected encrypted cipher message\n+    return Stream.of(\n+        Arguments.of(\n+            SCryptParamBuilder.aSCryptParam().withSalt(SALT).build(),\n+            Bytes.fromHexString(\"149aafa27b041f3523c53d7acba1905fa6b1c90f9fef137568101f44b531a3cb\"),\n+            Bytes.fromHexString(\n+                \"54ecc8863c0550351eee5720f3be6a5d4a016025aa91cd6436cfec938d6a8d30\")),\n+        Arguments.of(\n+            Pbkdf2ParamBuilder.aPbkdf2Param().withSalt(SALT).build(),\n+            Bytes.fromHexString(\"18b148af8e52920318084560fd766f9d09587b4915258dec0676cba5b0da09d8\"),\n+            Bytes.fromHexString(\n+                \"a9249e0ca7315836356e4c7440361ff22b9fe71e2e2ed34fc1eb03976924ed48\")));\n+  }\n+\n+  @SuppressWarnings(\"UnusedMethod\")\n+  private static Stream<Arguments> basicKdfParam() {\n+    return Stream.of(\n+        Arguments.of(\n+            SCryptParamBuilder.aSCryptParam().build(), CipherParamBuilder.aCipherParam().build()),\n+        Arguments.of(\n+            Pbkdf2ParamBuilder.aPbkdf2Param().build(), CipherParamBuilder.aCipherParam().build()));\n+  }\n+\n+  @ParameterizedTest\n+  @MethodSource(\"keystorePaths\")\n+  void loadKeyStoreAndDecryptKey(final Path keyStorePath) throws Exception {\n+    final KeyStore keyStore = KeyStoreLoader.loadFromFile(keyStorePath);\n+    final KeyStoreData keyStoreData = keyStore.getKeyStoreData();\n+    assertNotNull(keyStoreData);\n+    final KdfParam param = keyStoreData.getCrypto().getKdf().getParam();\n+    assertNotNull(param);\n+    if (keyStoreData.getCrypto().getKdf().getCryptoFunction() == SCRYPT) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "baf6b00ff9bdb682f2c8bd33ca015074777003ed"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY4ODg2MA==", "bodyText": "Perhaps missingKdfParamsTestVector as it's the params that are missing", "url": "https://github.com/ConsenSys/teku/pull/1212#discussion_r383688860", "createdAt": "2020-02-25T06:56:18Z", "author": {"login": "jframe"}, "path": "data/keystore/src/test/resources/missingKdfSectionTestVector.json", "diffHunk": "@@ -0,0 +1,24 @@\n+{", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "baf6b00ff9bdb682f2c8bd33ca015074777003ed"}, "originalPosition": 1}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f7d32d6ef361d376bb683b79759eac8aaa79b1f9", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/f7d32d6ef361d376bb683b79759eac8aaa79b1f9", "committedDate": "2020-02-26T00:01:29Z", "message": "initial refactor after review suggestions\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "da9c2436fc5cbf7a3089dca67acde9f14bfc4d79", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/da9c2436fc5cbf7a3089dca67acde9f14bfc4d79", "committedDate": "2020-02-26T02:22:46Z", "message": "initial refactor after review suggestions\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "86a71d5e72d6e99c19fa7e73374518f0aca5120b", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/86a71d5e72d6e99c19fa7e73374518f0aca5120b", "committedDate": "2020-02-26T02:23:02Z", "message": "Merge remote-tracking branch 'upstream/master' into feature/bls_keystore\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "db7c3c4dc949fc88853531c40dc2b5acf98ea92f", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/db7c3c4dc949fc88853531c40dc2b5acf98ea92f", "committedDate": "2020-02-26T04:57:43Z", "message": "Adding tests for custom exception\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "36ce8ce0728635c680ddd0ed31823dcc5ffe4365", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/36ce8ce0728635c680ddd0ed31823dcc5ffe4365", "committedDate": "2020-02-26T06:24:44Z", "message": "finalizing unit test\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dfa0794e9ed9ebf59861c386c196a46cbe37b910", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/dfa0794e9ed9ebf59861c386c196a46cbe37b910", "committedDate": "2020-02-26T06:25:10Z", "message": "Merge remote-tracking branch 'upstream/master' into feature/bls_keystore\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3236e7af600534019d8eaece1c35d86116565016", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/3236e7af600534019d8eaece1c35d86116565016", "committedDate": "2020-02-26T06:43:06Z", "message": "updating jar name\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1MjIzNDcz", "url": "https://github.com/ConsenSys/teku/pull/1212#pullrequestreview-365223473", "createdAt": "2020-02-26T20:37:09Z", "commit": {"oid": "3236e7af600534019d8eaece1c35d86116565016"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMDozNzowOVrOFu7Tqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMDozNzowOVrOFu7Tqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc1MDUwNg==", "bodyText": "This class really shouldn't exist.  A precondition check is there to provide early warning that a developer has stuffed up (ie it should never fail).  If we need to throw a custom exception, then this is really a part of the business logic, not a precondition.  We shouldn't hide that and make it look like a precondition check.\nParticularly checkNotNull should be a precondition check and just use Preconditions from guava - something is very wrong if you're passing null where you shouldn't.  The checkArgument cases probably need to be reviewed on a case by case basis depending on whether they're checking user input (which makes it business logic) or fixed input (precondition check).", "url": "https://github.com/ConsenSys/teku/pull/1212#discussion_r384750506", "createdAt": "2020-02-26T20:37:09Z", "author": {"login": "ajsutton"}, "path": "data/keystore/src/main/java/tech/pegasys/artemis/bls/keystore/KeyStorePreConditions.java", "diffHunk": "@@ -0,0 +1,31 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.bls.keystore;\n+\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+\n+/** Similar to guava Preconditions but throws our custom exception */\n+public class KeyStorePreConditions {\n+  public static <T extends @NonNull Object> void checkNotNull(T reference, String errorMessage) {\n+    if (reference == null) {\n+      throw new KeyStoreValidationException(errorMessage);\n+    }\n+  }\n+\n+  public static void checkArgument(boolean expression, String errorMessage) {\n+    if (!expression) {\n+      throw new KeyStoreValidationException(errorMessage);\n+    }\n+  }\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3236e7af600534019d8eaece1c35d86116565016"}, "originalPosition": 31}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d1cdfcf6c6e14515d340fa07432bd26fc38900e7", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/d1cdfcf6c6e14515d340fa07432bd26fc38900e7", "committedDate": "2020-02-27T00:53:18Z", "message": "Review suggestions - removing KeyStorePreConditions and introducing validate method\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "338fa8a01fbbc90fa519eb653f37c1f56f2c79a2", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/338fa8a01fbbc90fa519eb653f37c1f56f2c79a2", "committedDate": "2020-02-27T01:17:46Z", "message": "Merge remote-tracking branch 'upstream/master' into feature/bls_keystore\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1MzI2MDk2", "url": "https://github.com/ConsenSys/teku/pull/1212#pullrequestreview-365326096", "createdAt": "2020-02-26T23:46:52Z", "commit": {"oid": "3236e7af600534019d8eaece1c35d86116565016"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMzo0Njo1MlrOFvAgKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwMzowODozM1rOFvD5GA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgzNTYyNw==", "bodyText": "Can you add a test for saving to file", "url": "https://github.com/ConsenSys/teku/pull/1212#discussion_r384835627", "createdAt": "2020-02-26T23:46:52Z", "author": {"login": "jframe"}, "path": "data/keystore/src/main/java/tech/pegasys/artemis/bls/keystore/KeyStoreLoader.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.bls.keystore;\n+\n+import com.fasterxml.jackson.core.JsonParseException;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.exc.InvalidTypeIdException;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import tech.pegasys.artemis.bls.keystore.model.KdfParam;\n+import tech.pegasys.artemis.bls.keystore.model.KeyStoreData;\n+\n+/** Provide utility methods to load/store BLS KeyStore from json format */\n+public class KeyStoreLoader {\n+  private static final Logger LOG = LogManager.getLogger();\n+  private static final ObjectMapper OBJECT_MAPPER =\n+      new ObjectMapper().registerModule(new KeyStoreBytesModule());\n+\n+  public static KeyStoreData loadFromFile(final Path keystoreFile)\n+      throws KeyStoreValidationException {\n+    KeyStorePreConditions.checkNotNull(keystoreFile, \"KeyStore path cannot be null\");\n+\n+    try {\n+      final KeyStoreData keyStoreData =\n+          OBJECT_MAPPER.readValue(keystoreFile.toFile(), KeyStoreData.class);\n+\n+      if (keyStoreData.getVersion() != KeyStoreData.KEYSTORE_VERSION) {\n+        throw new KeyStoreValidationException(\n+            String.format(\n+                \"Error in parsing keystore: The KeyStore version %d is not supported\",\n+                keyStoreData.getVersion()));\n+      }\n+\n+      return keyStoreData;\n+    } catch (final JsonParseException e) {\n+      throw new KeyStoreValidationException(\"Error in parsing keystore: Invalid Json format\", e);\n+    } catch (final JsonMappingException e) {\n+      throw convertToKeyStoreValidationException(e);\n+    } catch (final IOException e) {\n+      LOG.error(\"Error in parsing keystore: \" + e.getMessage());\n+      throw new KeyStoreValidationException(\"Error in parsing keystore: \" + e.getMessage(), e);\n+    }\n+  }\n+\n+  private static KeyStoreValidationException convertToKeyStoreValidationException(\n+      final JsonMappingException e) {\n+    final String cause;\n+    if (e.getCause() instanceof KeyStoreValidationException) {\n+      cause = e.getCause().getMessage();\n+    } else if (e instanceof InvalidTypeIdException) {\n+      cause = getKdfFunctionErrorMessage((InvalidTypeIdException) e);\n+    } else {\n+      cause = \"Missing required json elements\";\n+    }\n+    return new KeyStoreValidationException(\n+        String.format(\"Error in parsing keystore: %s\", cause), e);\n+  }\n+\n+  private static String getKdfFunctionErrorMessage(final InvalidTypeIdException e) {\n+    if (e.getBaseType().getRawClass() == KdfParam.class) {\n+      return \"Kdf function [\" + e.getTypeId() + \"] is not supported.\";\n+    }\n+    return \"Missing required json elements\";\n+  }\n+\n+  public static void saveToFile(final Path keystoreFile, final KeyStoreData keyStoreData) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3236e7af600534019d8eaece1c35d86116565016"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDgzOTczOQ==", "bodyText": "Not liking the application logic sitting in the model, rather it was part of the keystore logic outside of the model. Is this the only way to avoid instanceof checks in the KeyStore though?", "url": "https://github.com/ConsenSys/teku/pull/1212#discussion_r384839739", "createdAt": "2020-02-26T23:59:54Z", "author": {"login": "jframe"}, "path": "data/keystore/src/main/java/tech/pegasys/artemis/bls/keystore/model/Pbkdf2Param.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.bls.keystore.model;\n+\n+import static tech.pegasys.artemis.bls.keystore.KeyStorePreConditions.checkArgument;\n+import static tech.pegasys.artemis.bls.keystore.KeyStorePreConditions.checkNotNull;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.base.MoreObjects;\n+import java.nio.charset.StandardCharsets;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.bouncycastle.crypto.generators.PKCS5S2ParametersGenerator;\n+import org.bouncycastle.crypto.params.KeyParameter;\n+import org.bouncycastle.crypto.util.DigestFactory;\n+import tech.pegasys.artemis.bls.keystore.KeyStoreValidationException;\n+\n+public class Pbkdf2Param extends KdfParam {\n+\n+  private final Integer c;\n+  private final Pbkdf2PseudoRandomFunction prf;\n+\n+  /**\n+   * PBKDF2 Key Derivation Function\n+   *\n+   * @param dklen The length of key to generate\n+   * @param c The iteration count\n+   * @param prf The pseudo random function i.e. hash digest to use.\n+   * @param salt The salt to use\n+   */\n+  @JsonCreator\n+  public Pbkdf2Param(\n+      @JsonProperty(value = \"dklen\", required = true) final int dklen,\n+      @JsonProperty(value = \"c\", required = true) final int c,\n+      @JsonProperty(value = \"prf\", required = true) final Pbkdf2PseudoRandomFunction prf,\n+      @JsonProperty(value = \"salt\", required = true) final Bytes salt) {\n+    super(dklen, salt);\n+    this.c = c;\n+    this.prf = prf;\n+    validateParams();\n+  }\n+\n+  @Override\n+  protected void validateParams() throws KeyStoreValidationException {\n+    super.validateParams();\n+    checkArgument(c >= 1, \"Iterative Count parameter c must be >= 1\");\n+  }\n+\n+  @JsonProperty(value = \"c\")\n+  public Integer getC() {\n+    return c;\n+  }\n+\n+  @JsonProperty(value = \"prf\")\n+  public Pbkdf2PseudoRandomFunction getPrf() {\n+    return prf;\n+  }\n+\n+  @Override\n+  public KdfFunction getKdfFunction() {\n+    return KdfFunction.PBKDF2;\n+  }\n+\n+  @Override\n+  public Bytes generateDecryptionKey(final String password) {\n+    checkNotNull(password, \"Password is required\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3236e7af600534019d8eaece1c35d86116565016"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg4OTYyNw==", "bodyText": "Do we need to specify the jar properties at all? Looks like this isn't need from what other modules are doing.", "url": "https://github.com/ConsenSys/teku/pull/1212#discussion_r384889627", "createdAt": "2020-02-27T03:01:39Z", "author": {"login": "jframe"}, "path": "data/keystore/build.gradle", "diffHunk": "@@ -0,0 +1,21 @@\n+jar {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "338fa8a01fbbc90fa519eb653f37c1f56f2c79a2"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg5MTE2MA==", "bodyText": "Is there any reason you can't use the Bytes.equals method instead of Object.equals?", "url": "https://github.com/ConsenSys/teku/pull/1212#discussion_r384891160", "createdAt": "2020-02-27T03:08:33Z", "author": {"login": "jframe"}, "path": "data/keystore/src/main/java/tech/pegasys/artemis/bls/keystore/KeyStore.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.bls.keystore;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+import static javax.crypto.Cipher.DECRYPT_MODE;\n+import static javax.crypto.Cipher.ENCRYPT_MODE;\n+import static org.apache.tuweni.bytes.Bytes.concatenate;\n+import static org.apache.tuweni.crypto.Hash.sha2_256;\n+\n+import java.security.GeneralSecurityException;\n+import java.util.Objects;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes48;\n+import org.bouncycastle.jce.provider.BouncyCastleProvider;\n+import tech.pegasys.artemis.bls.keystore.model.Checksum;\n+import tech.pegasys.artemis.bls.keystore.model.Cipher;\n+import tech.pegasys.artemis.bls.keystore.model.Crypto;\n+import tech.pegasys.artemis.bls.keystore.model.Kdf;\n+import tech.pegasys.artemis.bls.keystore.model.KdfParam;\n+import tech.pegasys.artemis.bls.keystore.model.KeyStoreData;\n+import tech.pegasys.artemis.util.mikuli.PublicKey;\n+import tech.pegasys.artemis.util.mikuli.SecretKey;\n+\n+/**\n+ * BLS Key Store implementation EIP-2335\n+ *\n+ * @see <a href=\"https://github.com/ethereum/EIPs/blob/master/EIPS/eip-2335.md\">EIP-2335</a>\n+ */\n+public class KeyStore {\n+  private static final BouncyCastleProvider BC = new BouncyCastleProvider();\n+\n+  /**\n+   * Encrypt the given BLS12-381 key with specified password.\n+   *\n+   * @param blsPrivateKey BLS12-381 private key in Bytes\n+   * @param password The password to use for encryption\n+   * @param path Path as defined in EIP-2334. Can be empty String.\n+   * @param kdfParam crypto function such as scrypt or PBKDF2 and related parameters such as dklen,\n+   *     salt etc.\n+   * @param cipher cipher function and iv parameter to use.\n+   * @return The constructed KeyStore with encrypted BLS Private Key as cipher.message and other\n+   *     details as defined by the EIP-2335 standard.\n+   */\n+  public static KeyStoreData encrypt(\n+      final Bytes blsPrivateKey,\n+      final String password,\n+      final String path,\n+      final KdfParam kdfParam,\n+      final Cipher cipher) {\n+\n+    checkNotNull(blsPrivateKey, \"PrivateKey cannot be null\");\n+    checkNotNull(password, \"Password cannot be null\");\n+    checkNotNull(path, \"Path cannot be null\");\n+    checkNotNull(kdfParam, \"KDFParam cannot be null\");\n+    checkNotNull(cipher, \"Cipher cannot be null\");\n+\n+    kdfParam.validate();\n+    cipher.validate();\n+\n+    final Crypto crypto = encryptUsingCipherFunction(blsPrivateKey, password, kdfParam, cipher);\n+    final Bytes pubKey =\n+        new PublicKey(SecretKey.fromBytes(Bytes48.leftPad(blsPrivateKey))).toBytesCompressed();\n+    return new KeyStoreData(crypto, pubKey, path);\n+  }\n+\n+  private static Crypto encryptUsingCipherFunction(\n+      final Bytes secret, final String password, final KdfParam kdfParam, final Cipher cipher) {\n+    final Bytes decryptionKey = kdfParam.generateDecryptionKey(password);\n+    final Bytes cipherMessage =\n+        applyCipherFunction(decryptionKey, cipher, true, secret.toArrayUnsafe());\n+    final Bytes checksumMessage = calculateSHA256Checksum(decryptionKey, cipherMessage);\n+    final Checksum checksum = new Checksum(checksumMessage);\n+    final Cipher encryptedCipher =\n+        new Cipher(cipher.getCipherFunction(), cipher.getCipherParam(), cipherMessage);\n+    final Kdf kdf = new Kdf(kdfParam);\n+    return new Crypto(kdf, checksum, encryptedCipher);\n+  }\n+\n+  /**\n+   * Validates password without decrypting the key as defined in specifications\n+   *\n+   * @param password The password to validate\n+   * @param keyStoreData The Key Store against which password to validate\n+   * @return true if password is valid, false otherwise.\n+   */\n+  public static boolean validatePassword(final String password, final KeyStoreData keyStoreData) {\n+    checkNotNull(password, \"Password cannot be null\");\n+    checkNotNull(keyStoreData, \"KeyStoreData cannot be null\");\n+\n+    final Bytes decryptionKey =\n+        keyStoreData.getCrypto().getKdf().getParam().generateDecryptionKey(password);\n+    return validateChecksum(decryptionKey, keyStoreData);\n+  }\n+\n+  /**\n+   * Decrypts BLS private key from the given KeyStore\n+   *\n+   * @param password The password to use for decryption\n+   * @param keyStoreData The given Key Store\n+   * @return decrypted BLS private key in Bytes\n+   */\n+  public static Bytes decrypt(final String password, final KeyStoreData keyStoreData) {\n+    checkNotNull(password, \"Password cannot be null\");\n+    checkNotNull(keyStoreData, \"KeyStoreData cannot be null\");\n+\n+    final Bytes decryptionKey =\n+        keyStoreData.getCrypto().getKdf().getParam().generateDecryptionKey(password);\n+\n+    if (!validateChecksum(decryptionKey, keyStoreData)) {\n+      throw new KeyStoreValidationException(\n+          \"Failed to decrypt KeyStore, checksum validation failed.\");\n+    }\n+\n+    final Cipher cipher = keyStoreData.getCrypto().getCipher();\n+    final byte[] encryptedMessage = cipher.getMessage().toArrayUnsafe();\n+    return applyCipherFunction(decryptionKey, cipher, false, encryptedMessage);\n+  }\n+\n+  private static boolean validateChecksum(\n+      final Bytes decryptionKey, final KeyStoreData keyStoreData) {\n+    final Bytes checksum =\n+        calculateSHA256Checksum(decryptionKey, keyStoreData.getCrypto().getCipher().getMessage());\n+    return Objects.equals(checksum, keyStoreData.getCrypto().getChecksum().getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "338fa8a01fbbc90fa519eb653f37c1f56f2c79a2"}, "originalPosition": 137}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1MzkzMDY0", "url": "https://github.com/ConsenSys/teku/pull/1212#pullrequestreview-365393064", "createdAt": "2020-02-27T03:24:10Z", "commit": {"oid": "338fa8a01fbbc90fa519eb653f37c1f56f2c79a2"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwMzoyNDoxMFrOFvEGmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwMzozNjo1N1rOFvEROg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg5NDYxOQ==", "bodyText": "We shouldn't specify any of this.  The jar config is handled by the top level gradle build file and setup automatically for every sub module.", "url": "https://github.com/ConsenSys/teku/pull/1212#discussion_r384894619", "createdAt": "2020-02-27T03:24:10Z", "author": {"login": "ajsutton"}, "path": "data/keystore/build.gradle", "diffHunk": "@@ -0,0 +1,21 @@\n+jar {\n+    baseName 'teku-data-keystore'\n+    manifest {\n+        attributes('Implementation-Title': baseName,\n+                'Implementation-Version': project.version)\n+    }\n+}\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "338fa8a01fbbc90fa519eb653f37c1f56f2c79a2"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg5NTI2NQ==", "bodyText": "Why are we re-throwing the same exception type?  Seems like we should just not catch it and let the original bubble up.", "url": "https://github.com/ConsenSys/teku/pull/1212#discussion_r384895265", "createdAt": "2020-02-27T03:26:58Z", "author": {"login": "ajsutton"}, "path": "data/keystore/src/main/java/tech/pegasys/artemis/bls/keystore/KeyStoreLoader.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.bls.keystore;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.fasterxml.jackson.core.JsonParseException;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.exc.InvalidTypeIdException;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import tech.pegasys.artemis.bls.keystore.model.KdfParam;\n+import tech.pegasys.artemis.bls.keystore.model.KeyStoreData;\n+\n+/** Provide utility methods to load/store BLS KeyStore from json format */\n+public class KeyStoreLoader {\n+  private static final Logger LOG = LogManager.getLogger();\n+  private static final ObjectMapper OBJECT_MAPPER =\n+      new ObjectMapper().registerModule(new KeyStoreBytesModule());\n+\n+  public static KeyStoreData loadFromFile(final Path keystoreFile)\n+      throws KeyStoreValidationException {\n+    checkNotNull(keystoreFile, \"KeyStore path cannot be null\");\n+\n+    try {\n+      final KeyStoreData keyStoreData =\n+          OBJECT_MAPPER.readValue(keystoreFile.toFile(), KeyStoreData.class);\n+      keyStoreData.validate();\n+      return keyStoreData;\n+    } catch (final KeyStoreValidationException e) {\n+      throw new KeyStoreValidationException(\"Error in parsing keystore: \" + e.getMessage(), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "338fa8a01fbbc90fa519eb653f37c1f56f2c79a2"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg5NTQ5Ng==", "bodyText": "Probably need a better error message here - This isn't an error in parsing the keystore - this was a failure to read the keystore.  If one of the reasons is a FileNotFoundException (which extends IOException) we may want to handle that specifically to provide a clear message that the file path was wrong.", "url": "https://github.com/ConsenSys/teku/pull/1212#discussion_r384895496", "createdAt": "2020-02-27T03:27:58Z", "author": {"login": "ajsutton"}, "path": "data/keystore/src/main/java/tech/pegasys/artemis/bls/keystore/KeyStoreLoader.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.bls.keystore;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.fasterxml.jackson.core.JsonParseException;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.exc.InvalidTypeIdException;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import tech.pegasys.artemis.bls.keystore.model.KdfParam;\n+import tech.pegasys.artemis.bls.keystore.model.KeyStoreData;\n+\n+/** Provide utility methods to load/store BLS KeyStore from json format */\n+public class KeyStoreLoader {\n+  private static final Logger LOG = LogManager.getLogger();\n+  private static final ObjectMapper OBJECT_MAPPER =\n+      new ObjectMapper().registerModule(new KeyStoreBytesModule());\n+\n+  public static KeyStoreData loadFromFile(final Path keystoreFile)\n+      throws KeyStoreValidationException {\n+    checkNotNull(keystoreFile, \"KeyStore path cannot be null\");\n+\n+    try {\n+      final KeyStoreData keyStoreData =\n+          OBJECT_MAPPER.readValue(keystoreFile.toFile(), KeyStoreData.class);\n+      keyStoreData.validate();\n+      return keyStoreData;\n+    } catch (final KeyStoreValidationException e) {\n+      throw new KeyStoreValidationException(\"Error in parsing keystore: \" + e.getMessage(), e);\n+    } catch (final JsonParseException e) {\n+      throw new KeyStoreValidationException(\"Error in parsing keystore: Invalid Json format\", e);\n+    } catch (final JsonMappingException e) {\n+      throw convertToKeyStoreValidationException(e);\n+    } catch (final IOException e) {\n+      LOG.error(\"Error in parsing keystore: \" + e.getMessage());\n+      throw new KeyStoreValidationException(\"Error in parsing keystore: \" + e.getMessage(), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "338fa8a01fbbc90fa519eb653f37c1f56f2c79a2"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg5NTc5NQ==", "bodyText": "Why are we getting KeyStoreValidationException wrapped in a JsonMappingException?  Shouldn't we just allow it to parse and then validate would fail?", "url": "https://github.com/ConsenSys/teku/pull/1212#discussion_r384895795", "createdAt": "2020-02-27T03:29:27Z", "author": {"login": "ajsutton"}, "path": "data/keystore/src/main/java/tech/pegasys/artemis/bls/keystore/KeyStoreLoader.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.bls.keystore;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.fasterxml.jackson.core.JsonParseException;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.exc.InvalidTypeIdException;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import tech.pegasys.artemis.bls.keystore.model.KdfParam;\n+import tech.pegasys.artemis.bls.keystore.model.KeyStoreData;\n+\n+/** Provide utility methods to load/store BLS KeyStore from json format */\n+public class KeyStoreLoader {\n+  private static final Logger LOG = LogManager.getLogger();\n+  private static final ObjectMapper OBJECT_MAPPER =\n+      new ObjectMapper().registerModule(new KeyStoreBytesModule());\n+\n+  public static KeyStoreData loadFromFile(final Path keystoreFile)\n+      throws KeyStoreValidationException {\n+    checkNotNull(keystoreFile, \"KeyStore path cannot be null\");\n+\n+    try {\n+      final KeyStoreData keyStoreData =\n+          OBJECT_MAPPER.readValue(keystoreFile.toFile(), KeyStoreData.class);\n+      keyStoreData.validate();\n+      return keyStoreData;\n+    } catch (final KeyStoreValidationException e) {\n+      throw new KeyStoreValidationException(\"Error in parsing keystore: \" + e.getMessage(), e);\n+    } catch (final JsonParseException e) {\n+      throw new KeyStoreValidationException(\"Error in parsing keystore: Invalid Json format\", e);\n+    } catch (final JsonMappingException e) {\n+      throw convertToKeyStoreValidationException(e);\n+    } catch (final IOException e) {\n+      LOG.error(\"Error in parsing keystore: \" + e.getMessage());\n+      throw new KeyStoreValidationException(\"Error in parsing keystore: \" + e.getMessage(), e);\n+    }\n+  }\n+\n+  private static KeyStoreValidationException convertToKeyStoreValidationException(\n+      final JsonMappingException e) {\n+    final String cause;\n+    if (e.getCause() instanceof KeyStoreValidationException) {\n+      cause = e.getCause().getMessage();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "338fa8a01fbbc90fa519eb653f37c1f56f2c79a2"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg5NTkxNw==", "bodyText": "Which elements are missing?", "url": "https://github.com/ConsenSys/teku/pull/1212#discussion_r384895917", "createdAt": "2020-02-27T03:30:04Z", "author": {"login": "ajsutton"}, "path": "data/keystore/src/main/java/tech/pegasys/artemis/bls/keystore/KeyStoreLoader.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.bls.keystore;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.fasterxml.jackson.core.JsonParseException;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.exc.InvalidTypeIdException;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import tech.pegasys.artemis.bls.keystore.model.KdfParam;\n+import tech.pegasys.artemis.bls.keystore.model.KeyStoreData;\n+\n+/** Provide utility methods to load/store BLS KeyStore from json format */\n+public class KeyStoreLoader {\n+  private static final Logger LOG = LogManager.getLogger();\n+  private static final ObjectMapper OBJECT_MAPPER =\n+      new ObjectMapper().registerModule(new KeyStoreBytesModule());\n+\n+  public static KeyStoreData loadFromFile(final Path keystoreFile)\n+      throws KeyStoreValidationException {\n+    checkNotNull(keystoreFile, \"KeyStore path cannot be null\");\n+\n+    try {\n+      final KeyStoreData keyStoreData =\n+          OBJECT_MAPPER.readValue(keystoreFile.toFile(), KeyStoreData.class);\n+      keyStoreData.validate();\n+      return keyStoreData;\n+    } catch (final KeyStoreValidationException e) {\n+      throw new KeyStoreValidationException(\"Error in parsing keystore: \" + e.getMessage(), e);\n+    } catch (final JsonParseException e) {\n+      throw new KeyStoreValidationException(\"Error in parsing keystore: Invalid Json format\", e);\n+    } catch (final JsonMappingException e) {\n+      throw convertToKeyStoreValidationException(e);\n+    } catch (final IOException e) {\n+      LOG.error(\"Error in parsing keystore: \" + e.getMessage());\n+      throw new KeyStoreValidationException(\"Error in parsing keystore: \" + e.getMessage(), e);\n+    }\n+  }\n+\n+  private static KeyStoreValidationException convertToKeyStoreValidationException(\n+      final JsonMappingException e) {\n+    final String cause;\n+    if (e.getCause() instanceof KeyStoreValidationException) {\n+      cause = e.getCause().getMessage();\n+    } else if (e instanceof InvalidTypeIdException) {\n+      cause = getKdfFunctionErrorMessage((InvalidTypeIdException) e);\n+    } else {\n+      cause = \"Missing required json elements\";\n+    }\n+    return new KeyStoreValidationException(\n+        String.format(\"Error in parsing keystore: %s\", cause), e);\n+  }\n+\n+  private static String getKdfFunctionErrorMessage(final InvalidTypeIdException e) {\n+    if (e.getBaseType().getRawClass() == KdfParam.class) {\n+      return \"Kdf function [\" + e.getTypeId() + \"] is not supported.\";\n+    }\n+    return \"Missing required json elements\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "338fa8a01fbbc90fa519eb653f37c1f56f2c79a2"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg5NjE5Mw==", "bodyText": "Seems weird to be throwing a validation exception here.  Nothing was invalid, we had an IO error.", "url": "https://github.com/ConsenSys/teku/pull/1212#discussion_r384896193", "createdAt": "2020-02-27T03:31:25Z", "author": {"login": "ajsutton"}, "path": "data/keystore/src/main/java/tech/pegasys/artemis/bls/keystore/KeyStoreLoader.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.bls.keystore;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.fasterxml.jackson.core.JsonParseException;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.exc.InvalidTypeIdException;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import tech.pegasys.artemis.bls.keystore.model.KdfParam;\n+import tech.pegasys.artemis.bls.keystore.model.KeyStoreData;\n+\n+/** Provide utility methods to load/store BLS KeyStore from json format */\n+public class KeyStoreLoader {\n+  private static final Logger LOG = LogManager.getLogger();\n+  private static final ObjectMapper OBJECT_MAPPER =\n+      new ObjectMapper().registerModule(new KeyStoreBytesModule());\n+\n+  public static KeyStoreData loadFromFile(final Path keystoreFile)\n+      throws KeyStoreValidationException {\n+    checkNotNull(keystoreFile, \"KeyStore path cannot be null\");\n+\n+    try {\n+      final KeyStoreData keyStoreData =\n+          OBJECT_MAPPER.readValue(keystoreFile.toFile(), KeyStoreData.class);\n+      keyStoreData.validate();\n+      return keyStoreData;\n+    } catch (final KeyStoreValidationException e) {\n+      throw new KeyStoreValidationException(\"Error in parsing keystore: \" + e.getMessage(), e);\n+    } catch (final JsonParseException e) {\n+      throw new KeyStoreValidationException(\"Error in parsing keystore: Invalid Json format\", e);\n+    } catch (final JsonMappingException e) {\n+      throw convertToKeyStoreValidationException(e);\n+    } catch (final IOException e) {\n+      LOG.error(\"Error in parsing keystore: \" + e.getMessage());\n+      throw new KeyStoreValidationException(\"Error in parsing keystore: \" + e.getMessage(), e);\n+    }\n+  }\n+\n+  private static KeyStoreValidationException convertToKeyStoreValidationException(\n+      final JsonMappingException e) {\n+    final String cause;\n+    if (e.getCause() instanceof KeyStoreValidationException) {\n+      cause = e.getCause().getMessage();\n+    } else if (e instanceof InvalidTypeIdException) {\n+      cause = getKdfFunctionErrorMessage((InvalidTypeIdException) e);\n+    } else {\n+      cause = \"Missing required json elements\";\n+    }\n+    return new KeyStoreValidationException(\n+        String.format(\"Error in parsing keystore: %s\", cause), e);\n+  }\n+\n+  private static String getKdfFunctionErrorMessage(final InvalidTypeIdException e) {\n+    if (e.getBaseType().getRawClass() == KdfParam.class) {\n+      return \"Kdf function [\" + e.getTypeId() + \"] is not supported.\";\n+    }\n+    return \"Missing required json elements\";\n+  }\n+\n+  public static void saveToFile(final Path keystoreFile, final KeyStoreData keyStoreData) {\n+    checkNotNull(keystoreFile, \"KeyStore path cannot be null\");\n+    checkNotNull(keyStoreData, \"KeyStore data cannot be null\");\n+\n+    try {\n+      Files.writeString(keystoreFile, toJson(keyStoreData), StandardCharsets.UTF_8);\n+    } catch (IOException e) {\n+      throw new KeyStoreValidationException(\n+          \"Error in writing KeyStore to file: \" + e.getMessage(), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "338fa8a01fbbc90fa519eb653f37c1f56f2c79a2"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg5NzE3OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    String.format(\"Error in parsing keystore: %s\", cause), e);\n          \n          \n            \n                    \"Error in parsing keystore: \" + cause.getMessage(), e);\n          \n      \n    \n    \n  \n\nString.format just makes things harder to read when you're appending to the end of a string. :). And we want the cause message.", "url": "https://github.com/ConsenSys/teku/pull/1212#discussion_r384897178", "createdAt": "2020-02-27T03:36:13Z", "author": {"login": "ajsutton"}, "path": "data/keystore/src/main/java/tech/pegasys/artemis/bls/keystore/KeyStoreLoader.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.bls.keystore;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.fasterxml.jackson.core.JsonParseException;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.exc.InvalidTypeIdException;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import tech.pegasys.artemis.bls.keystore.model.KdfParam;\n+import tech.pegasys.artemis.bls.keystore.model.KeyStoreData;\n+\n+/** Provide utility methods to load/store BLS KeyStore from json format */\n+public class KeyStoreLoader {\n+  private static final Logger LOG = LogManager.getLogger();\n+  private static final ObjectMapper OBJECT_MAPPER =\n+      new ObjectMapper().registerModule(new KeyStoreBytesModule());\n+\n+  public static KeyStoreData loadFromFile(final Path keystoreFile)\n+      throws KeyStoreValidationException {\n+    checkNotNull(keystoreFile, \"KeyStore path cannot be null\");\n+\n+    try {\n+      final KeyStoreData keyStoreData =\n+          OBJECT_MAPPER.readValue(keystoreFile.toFile(), KeyStoreData.class);\n+      keyStoreData.validate();\n+      return keyStoreData;\n+    } catch (final KeyStoreValidationException e) {\n+      throw new KeyStoreValidationException(\"Error in parsing keystore: \" + e.getMessage(), e);\n+    } catch (final JsonParseException e) {\n+      throw new KeyStoreValidationException(\"Error in parsing keystore: Invalid Json format\", e);\n+    } catch (final JsonMappingException e) {\n+      throw convertToKeyStoreValidationException(e);\n+    } catch (final IOException e) {\n+      LOG.error(\"Error in parsing keystore: \" + e.getMessage());\n+      throw new KeyStoreValidationException(\"Error in parsing keystore: \" + e.getMessage(), e);\n+    }\n+  }\n+\n+  private static KeyStoreValidationException convertToKeyStoreValidationException(\n+      final JsonMappingException e) {\n+    final String cause;\n+    if (e.getCause() instanceof KeyStoreValidationException) {\n+      cause = e.getCause().getMessage();\n+    } else if (e instanceof InvalidTypeIdException) {\n+      cause = getKdfFunctionErrorMessage((InvalidTypeIdException) e);\n+    } else {\n+      cause = \"Missing required json elements\";\n+    }\n+    return new KeyStoreValidationException(\n+        String.format(\"Error in parsing keystore: %s\", cause), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "338fa8a01fbbc90fa519eb653f37c1f56f2c79a2"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg5NzMzOA==", "bodyText": "Looks like this could be private and then it wouldn't need the checkNotNull (no need to recheck things we pass ourselves).", "url": "https://github.com/ConsenSys/teku/pull/1212#discussion_r384897338", "createdAt": "2020-02-27T03:36:57Z", "author": {"login": "ajsutton"}, "path": "data/keystore/src/main/java/tech/pegasys/artemis/bls/keystore/KeyStoreLoader.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.bls.keystore;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.fasterxml.jackson.core.JsonParseException;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.exc.InvalidTypeIdException;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import tech.pegasys.artemis.bls.keystore.model.KdfParam;\n+import tech.pegasys.artemis.bls.keystore.model.KeyStoreData;\n+\n+/** Provide utility methods to load/store BLS KeyStore from json format */\n+public class KeyStoreLoader {\n+  private static final Logger LOG = LogManager.getLogger();\n+  private static final ObjectMapper OBJECT_MAPPER =\n+      new ObjectMapper().registerModule(new KeyStoreBytesModule());\n+\n+  public static KeyStoreData loadFromFile(final Path keystoreFile)\n+      throws KeyStoreValidationException {\n+    checkNotNull(keystoreFile, \"KeyStore path cannot be null\");\n+\n+    try {\n+      final KeyStoreData keyStoreData =\n+          OBJECT_MAPPER.readValue(keystoreFile.toFile(), KeyStoreData.class);\n+      keyStoreData.validate();\n+      return keyStoreData;\n+    } catch (final KeyStoreValidationException e) {\n+      throw new KeyStoreValidationException(\"Error in parsing keystore: \" + e.getMessage(), e);\n+    } catch (final JsonParseException e) {\n+      throw new KeyStoreValidationException(\"Error in parsing keystore: Invalid Json format\", e);\n+    } catch (final JsonMappingException e) {\n+      throw convertToKeyStoreValidationException(e);\n+    } catch (final IOException e) {\n+      LOG.error(\"Error in parsing keystore: \" + e.getMessage());\n+      throw new KeyStoreValidationException(\"Error in parsing keystore: \" + e.getMessage(), e);\n+    }\n+  }\n+\n+  private static KeyStoreValidationException convertToKeyStoreValidationException(\n+      final JsonMappingException e) {\n+    final String cause;\n+    if (e.getCause() instanceof KeyStoreValidationException) {\n+      cause = e.getCause().getMessage();\n+    } else if (e instanceof InvalidTypeIdException) {\n+      cause = getKdfFunctionErrorMessage((InvalidTypeIdException) e);\n+    } else {\n+      cause = \"Missing required json elements\";\n+    }\n+    return new KeyStoreValidationException(\n+        String.format(\"Error in parsing keystore: %s\", cause), e);\n+  }\n+\n+  private static String getKdfFunctionErrorMessage(final InvalidTypeIdException e) {\n+    if (e.getBaseType().getRawClass() == KdfParam.class) {\n+      return \"Kdf function [\" + e.getTypeId() + \"] is not supported.\";\n+    }\n+    return \"Missing required json elements\";\n+  }\n+\n+  public static void saveToFile(final Path keystoreFile, final KeyStoreData keyStoreData) {\n+    checkNotNull(keystoreFile, \"KeyStore path cannot be null\");\n+    checkNotNull(keyStoreData, \"KeyStore data cannot be null\");\n+\n+    try {\n+      Files.writeString(keystoreFile, toJson(keyStoreData), StandardCharsets.UTF_8);\n+    } catch (IOException e) {\n+      throw new KeyStoreValidationException(\n+          \"Error in writing KeyStore to file: \" + e.getMessage(), e);\n+    }\n+  }\n+\n+  public static String toJson(final KeyStoreData keyStoreData) {\n+    checkNotNull(keyStoreData, \"KeyStore data cannot be null\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "338fa8a01fbbc90fa519eb653f37c1f56f2c79a2"}, "originalPosition": 93}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fe5cdf85ef40f963cb12216e39462ff967a8cb69", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/fe5cdf85ef40f963cb12216e39462ff967a8cb69", "committedDate": "2020-02-27T03:50:00Z", "message": "removing jar section from build.gradle\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f88f05f2a3a71abb1f68a916d015590562f2dc3f", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/f88f05f2a3a71abb1f68a916d015590562f2dc3f", "committedDate": "2020-02-27T04:30:08Z", "message": "review suggestions - cleaning up exception handling and messages\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "46121203678eff3a31c6db32ed007c5341e47488", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/46121203678eff3a31c6db32ed007c5341e47488", "committedDate": "2020-02-27T04:54:05Z", "message": "review suggestions - adding unit test cases for saving keystore to a file\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7ff0ff04d7cbc8912d59cac65c99c4ceffff92c1", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/7ff0ff04d7cbc8912d59cac65c99c4ceffff92c1", "committedDate": "2020-02-27T04:54:29Z", "message": "Merge remote-tracking branch 'upstream/master' into feature/bls_keystore\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2MDU3MzIy", "url": "https://github.com/ConsenSys/teku/pull/1212#pullrequestreview-366057322", "createdAt": "2020-02-27T22:53:19Z", "commit": {"oid": "7ff0ff04d7cbc8912d59cac65c99c4ceffff92c1"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QyMjo1MzoxOVrOFvkC_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QyMjo1MzoxOVrOFvkC_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQxNzk4MQ==", "bodyText": "It would be worth including the keystoreFile in this error message so users know which file we tried to load.", "url": "https://github.com/ConsenSys/teku/pull/1212#discussion_r385417981", "createdAt": "2020-02-27T22:53:19Z", "author": {"login": "ajsutton"}, "path": "data/keystore/src/main/java/tech/pegasys/artemis/bls/keystore/KeyStoreLoader.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.bls.keystore;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.fasterxml.jackson.core.JsonParseException;\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.fasterxml.jackson.databind.JsonMappingException;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.exc.InvalidTypeIdException;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import tech.pegasys.artemis.bls.keystore.model.KdfParam;\n+import tech.pegasys.artemis.bls.keystore.model.KeyStoreData;\n+\n+/** Provide utility methods to load/store BLS KeyStore from json format */\n+public class KeyStoreLoader {\n+  private static final Logger LOG = LogManager.getLogger();\n+  private static final ObjectMapper OBJECT_MAPPER =\n+      new ObjectMapper().registerModule(new KeyStoreBytesModule());\n+\n+  public static KeyStoreData loadFromFile(final Path keystoreFile)\n+      throws KeyStoreValidationException {\n+    checkNotNull(keystoreFile, \"KeyStore path cannot be null\");\n+\n+    try {\n+      final KeyStoreData keyStoreData =\n+          OBJECT_MAPPER.readValue(keystoreFile.toFile(), KeyStoreData.class);\n+      keyStoreData.validate();\n+      return keyStoreData;\n+    } catch (final JsonParseException e) {\n+      throw new KeyStoreValidationException(\"Invalid KeyStore: \" + e.getMessage(), e);\n+    } catch (final JsonMappingException e) {\n+      throw convertToKeyStoreValidationException(e);\n+    } catch (final FileNotFoundException e) {\n+      throw new KeyStoreValidationException(\"KeyStore file not found\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ff0ff04d7cbc8912d59cac65c99c4ceffff92c1"}, "originalPosition": 53}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "572daa7d8bb154d0c296ea89919ae09f9f9de52f", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/572daa7d8bb154d0c296ea89919ae09f9f9de52f", "committedDate": "2020-02-27T23:07:02Z", "message": "filenotfoundexception adding file name to exception message\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7971bddaca0f219b3a986f0ed3277ab22b635641", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/7971bddaca0f219b3a986f0ed3277ab22b635641", "committedDate": "2020-02-27T23:07:18Z", "message": "Merge remote-tracking branch 'upstream/master' into feature/bls_keystore\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4088, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}