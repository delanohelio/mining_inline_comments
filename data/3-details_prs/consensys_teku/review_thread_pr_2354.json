{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ5MTcxMjQy", "number": 2354, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwMToyNzoyOFrOEOfU3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwMTozMjowOFrOEOfYZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNjI4NzY3OnYy", "diffSide": "RIGHT", "path": "storage/src/main/java/tech/pegasys/teku/storage/server/rocksdb/RocksDbDatabase.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwMToyNzoyOFrOGxq5Dg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwMTo1NzowMlrOGxrYsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDczNjE0Mg==", "bodyText": "This doesn't feel right - I'd have expected new hot state roots to be added as part of aStorageUpdate event since they'll only be added as part of importing a block and thus should be stored in the same transaction as the rest of the updates.\nIn any case, we definitely wouldn't want to store them one at a time - it's much more efficient to store them in a batch.\nUltimately though this doesn't affect the disk layout so we could start with this to make these tests work then move to something else in later PRs when we're actually capturing the data during state transition.", "url": "https://github.com/ConsenSys/teku/pull/2354#discussion_r454736142", "createdAt": "2020-07-15T01:27:28Z", "author": {"login": "ajsutton"}, "path": "storage/src/main/java/tech/pegasys/teku/storage/server/rocksdb/RocksDbDatabase.java", "diffHunk": "@@ -252,6 +254,32 @@ public void update(final StorageUpdate event) {\n     return finalizedDao.streamFinalizedBlocks(startSlot, endSlot);\n   }\n \n+  @Override\n+  public List<Bytes32> getStateRootsBeforeSlot(final UnsignedLong slot) {\n+    return hotDao.getStateRootsBeforeSlot(slot);\n+  }\n+\n+  @Override\n+  public void addHotStateRoot(final Bytes32 stateRoot, final SlotAndBlockRoot slotAndBlockRoot) {\n+    try (final HotUpdater updater = hotDao.hotUpdater()) {\n+      updater.addHotStateRoot(stateRoot, slotAndBlockRoot);\n+      updater.commit();\n+    }\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47b810083826a33ffa4b8ac5733e92a814072d91"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc0NDI0MA==", "bodyText": "yep agreed, this shows store, purge, retrieve, and we can work out the messy details once we actually start storing data I guess.", "url": "https://github.com/ConsenSys/teku/pull/2354#discussion_r454744240", "createdAt": "2020-07-15T01:57:02Z", "author": {"login": "rolfyone"}, "path": "storage/src/main/java/tech/pegasys/teku/storage/server/rocksdb/RocksDbDatabase.java", "diffHunk": "@@ -252,6 +254,32 @@ public void update(final StorageUpdate event) {\n     return finalizedDao.streamFinalizedBlocks(startSlot, endSlot);\n   }\n \n+  @Override\n+  public List<Bytes32> getStateRootsBeforeSlot(final UnsignedLong slot) {\n+    return hotDao.getStateRootsBeforeSlot(slot);\n+  }\n+\n+  @Override\n+  public void addHotStateRoot(final Bytes32 stateRoot, final SlotAndBlockRoot slotAndBlockRoot) {\n+    try (final HotUpdater updater = hotDao.hotUpdater()) {\n+      updater.addHotStateRoot(stateRoot, slotAndBlockRoot);\n+      updater.commit();\n+    }\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDczNjE0Mg=="}, "originalCommit": {"oid": "47b810083826a33ffa4b8ac5733e92a814072d91"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgzNjI5NjY4OnYy", "diffSide": "RIGHT", "path": "storage/src/main/java/tech/pegasys/teku/storage/server/rocksdb/dataaccess/V3RocksDbDao.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwMTozMjowOFrOGxq-HQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwMTo1NzozNlrOGxrZQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDczNzQzNw==", "bodyText": "If it becomes time consuming or difficult to support state roots on v3 databases we can skip it and only do it for v4/5.  Nothing critical depends on the lookup so it's reasonable for new features to only be available in the most recent database format.", "url": "https://github.com/ConsenSys/teku/pull/2354#discussion_r454737437", "createdAt": "2020-07-15T01:32:08Z", "author": {"login": "ajsutton"}, "path": "storage/src/main/java/tech/pegasys/teku/storage/server/rocksdb/dataaccess/V3RocksDbDao.java", "diffHunk": "@@ -113,6 +116,22 @@ public V3RocksDbDao(final RocksDbAccessor db) {\n     return db.getAll(V3Schema.HOT_BLOCKS_BY_ROOT);\n   }\n \n+  @Override\n+  public List<Bytes32> getStateRootsBeforeSlot(final UnsignedLong slot) {\n+    try (Stream<ColumnEntry<Bytes32, SlotAndBlockRoot>> stream =\n+        db.stream(V3Schema.STATE_ROOT_TO_SLOT_AND_BLOCK_ROOT)) {\n+      return stream\n+          .filter((column) -> column.getValue().getSlot().compareTo(slot) < 0)\n+          .map(ColumnEntry::getKey)\n+          .collect(Collectors.toList());\n+    }\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47b810083826a33ffa4b8ac5733e92a814072d91"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc0NDM4NA==", "bodyText": "all good, currently its identical code...", "url": "https://github.com/ConsenSys/teku/pull/2354#discussion_r454744384", "createdAt": "2020-07-15T01:57:36Z", "author": {"login": "rolfyone"}, "path": "storage/src/main/java/tech/pegasys/teku/storage/server/rocksdb/dataaccess/V3RocksDbDao.java", "diffHunk": "@@ -113,6 +116,22 @@ public V3RocksDbDao(final RocksDbAccessor db) {\n     return db.getAll(V3Schema.HOT_BLOCKS_BY_ROOT);\n   }\n \n+  @Override\n+  public List<Bytes32> getStateRootsBeforeSlot(final UnsignedLong slot) {\n+    try (Stream<ColumnEntry<Bytes32, SlotAndBlockRoot>> stream =\n+        db.stream(V3Schema.STATE_ROOT_TO_SLOT_AND_BLOCK_ROOT)) {\n+      return stream\n+          .filter((column) -> column.getValue().getSlot().compareTo(slot) < 0)\n+          .map(ColumnEntry::getKey)\n+          .collect(Collectors.toList());\n+    }\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDczNzQzNw=="}, "originalCommit": {"oid": "47b810083826a33ffa4b8ac5733e92a814072d91"}, "originalPosition": 32}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3540, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}