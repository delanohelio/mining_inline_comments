{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI1MTM0NTg0", "number": 2005, "reviewThreads": {"totalCount": 34, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNDozOTozM1rOEA6zjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQyMDoxODozM1rOEHtygA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5Mzk4OTI2OnYy", "diffSide": "RIGHT", "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/RpcResponseChunkDecoder.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNDozOTozM1rOGcfq1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxNzozMzozMVrOGdTknw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjUzMjE4MA==", "bodyText": "Don't we want to decode regardless of the responseCode?\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  if (respCode == 0 && compressed) {\n          \n          \n            \n                  if (compressed) {", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r432532180", "createdAt": "2020-05-29T14:39:33Z", "author": {"login": "mbaxter"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/RpcResponseChunkDecoder.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.networking.eth2.rpc.core.encodings;\n+\n+import static java.lang.Integer.min;\n+\n+import io.libp2p.etc.types.ByteBufExtKt;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.handler.codec.compression.SnappyFrameDecoder;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Netty decoder which decodes ssz_snappy or raw ssz Eth2 RPC response chunks from inbound response\n+ * stream\n+ */\n+public class RpcResponseChunkDecoder extends SnappyFrameDecoder {\n+\n+  private final boolean compressed;\n+  private int respCode;\n+  private long remainingRawLength = 0;\n+  private boolean decodePayload = false;\n+  private final List<ByteBuf> rawDataFrames = new ArrayList<>();\n+\n+  /**\n+   * Create a new decoder\n+   *\n+   * @param compressed {@code true} if the stream is Snappy compressed, {@code false} if the stream\n+   *     is plain ssz\n+   */\n+  public RpcResponseChunkDecoder(boolean compressed) {\n+    super(true);\n+    this.compressed = compressed;\n+  }\n+\n+  @Override\n+  protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {\n+    if (!decodePayload) {\n+      if (in.readableBytes() < 2) {\n+        // wait for more byte to read resp code and length fields\n+        return;\n+      }\n+      int rollbackIndex = in.readerIndex();\n+\n+      byte respCode = in.readByte();\n+      long length = ByteBufExtKt.readUvarint(in);\n+      if (length < 0) {\n+        // wait for more byte to read length field\n+        in.readerIndex(rollbackIndex);\n+        return;\n+      }\n+      this.respCode = respCode;\n+      this.remainingRawLength = length;\n+      decodePayload = true;\n+    } else {\n+      ArrayList<Object> rawOut = new ArrayList<>();\n+      if (respCode == 0 && compressed) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7177049a53d76a82f97fc335e8169ca8ba6e306"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgzOTMzNA==", "bodyText": "As I understand from the spec the error payload is not compressed. Is it wrong assumption?", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r432839334", "createdAt": "2020-05-30T12:52:11Z", "author": {"login": "Nashatyrev"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/RpcResponseChunkDecoder.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.networking.eth2.rpc.core.encodings;\n+\n+import static java.lang.Integer.min;\n+\n+import io.libp2p.etc.types.ByteBufExtKt;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.handler.codec.compression.SnappyFrameDecoder;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Netty decoder which decodes ssz_snappy or raw ssz Eth2 RPC response chunks from inbound response\n+ * stream\n+ */\n+public class RpcResponseChunkDecoder extends SnappyFrameDecoder {\n+\n+  private final boolean compressed;\n+  private int respCode;\n+  private long remainingRawLength = 0;\n+  private boolean decodePayload = false;\n+  private final List<ByteBuf> rawDataFrames = new ArrayList<>();\n+\n+  /**\n+   * Create a new decoder\n+   *\n+   * @param compressed {@code true} if the stream is Snappy compressed, {@code false} if the stream\n+   *     is plain ssz\n+   */\n+  public RpcResponseChunkDecoder(boolean compressed) {\n+    super(true);\n+    this.compressed = compressed;\n+  }\n+\n+  @Override\n+  protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {\n+    if (!decodePayload) {\n+      if (in.readableBytes() < 2) {\n+        // wait for more byte to read resp code and length fields\n+        return;\n+      }\n+      int rollbackIndex = in.readerIndex();\n+\n+      byte respCode = in.readByte();\n+      long length = ByteBufExtKt.readUvarint(in);\n+      if (length < 0) {\n+        // wait for more byte to read length field\n+        in.readerIndex(rollbackIndex);\n+        return;\n+      }\n+      this.respCode = respCode;\n+      this.remainingRawLength = length;\n+      decodePayload = true;\n+    } else {\n+      ArrayList<Object> rawOut = new ArrayList<>();\n+      if (respCode == 0 && compressed) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjUzMjE4MA=="}, "originalCommit": {"oid": "c7177049a53d76a82f97fc335e8169ca8ba6e306"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzI4ODQzMw==", "bodyText": "Yeah, the error payload is treated like any other payload, so if we're using compression the errors should be compressed as well.", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r433288433", "createdAt": "2020-06-01T15:03:11Z", "author": {"login": "mbaxter"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/RpcResponseChunkDecoder.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.networking.eth2.rpc.core.encodings;\n+\n+import static java.lang.Integer.min;\n+\n+import io.libp2p.etc.types.ByteBufExtKt;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.handler.codec.compression.SnappyFrameDecoder;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Netty decoder which decodes ssz_snappy or raw ssz Eth2 RPC response chunks from inbound response\n+ * stream\n+ */\n+public class RpcResponseChunkDecoder extends SnappyFrameDecoder {\n+\n+  private final boolean compressed;\n+  private int respCode;\n+  private long remainingRawLength = 0;\n+  private boolean decodePayload = false;\n+  private final List<ByteBuf> rawDataFrames = new ArrayList<>();\n+\n+  /**\n+   * Create a new decoder\n+   *\n+   * @param compressed {@code true} if the stream is Snappy compressed, {@code false} if the stream\n+   *     is plain ssz\n+   */\n+  public RpcResponseChunkDecoder(boolean compressed) {\n+    super(true);\n+    this.compressed = compressed;\n+  }\n+\n+  @Override\n+  protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {\n+    if (!decodePayload) {\n+      if (in.readableBytes() < 2) {\n+        // wait for more byte to read resp code and length fields\n+        return;\n+      }\n+      int rollbackIndex = in.readerIndex();\n+\n+      byte respCode = in.readByte();\n+      long length = ByteBufExtKt.readUvarint(in);\n+      if (length < 0) {\n+        // wait for more byte to read length field\n+        in.readerIndex(rollbackIndex);\n+        return;\n+      }\n+      this.respCode = respCode;\n+      this.remainingRawLength = length;\n+      decodePayload = true;\n+    } else {\n+      ArrayList<Object> rawOut = new ArrayList<>();\n+      if (respCode == 0 && compressed) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjUzMjE4MA=="}, "originalCommit": {"oid": "c7177049a53d76a82f97fc335e8169ca8ba6e306"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM4MjU1OQ==", "bodyText": "Yep, sounds totally reasonable. I'm now not sure what insisted me think differently", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r433382559", "createdAt": "2020-06-01T17:33:31Z", "author": {"login": "Nashatyrev"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/RpcResponseChunkDecoder.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.networking.eth2.rpc.core.encodings;\n+\n+import static java.lang.Integer.min;\n+\n+import io.libp2p.etc.types.ByteBufExtKt;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.handler.codec.compression.SnappyFrameDecoder;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Netty decoder which decodes ssz_snappy or raw ssz Eth2 RPC response chunks from inbound response\n+ * stream\n+ */\n+public class RpcResponseChunkDecoder extends SnappyFrameDecoder {\n+\n+  private final boolean compressed;\n+  private int respCode;\n+  private long remainingRawLength = 0;\n+  private boolean decodePayload = false;\n+  private final List<ByteBuf> rawDataFrames = new ArrayList<>();\n+\n+  /**\n+   * Create a new decoder\n+   *\n+   * @param compressed {@code true} if the stream is Snappy compressed, {@code false} if the stream\n+   *     is plain ssz\n+   */\n+  public RpcResponseChunkDecoder(boolean compressed) {\n+    super(true);\n+    this.compressed = compressed;\n+  }\n+\n+  @Override\n+  protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {\n+    if (!decodePayload) {\n+      if (in.readableBytes() < 2) {\n+        // wait for more byte to read resp code and length fields\n+        return;\n+      }\n+      int rollbackIndex = in.readerIndex();\n+\n+      byte respCode = in.readByte();\n+      long length = ByteBufExtKt.readUvarint(in);\n+      if (length < 0) {\n+        // wait for more byte to read length field\n+        in.readerIndex(rollbackIndex);\n+        return;\n+      }\n+      this.respCode = respCode;\n+      this.remainingRawLength = length;\n+      decodePayload = true;\n+    } else {\n+      ArrayList<Object> rawOut = new ArrayList<>();\n+      if (respCode == 0 && compressed) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjUzMjE4MA=="}, "originalCommit": {"oid": "c7177049a53d76a82f97fc335e8169ca8ba6e306"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NDAyMTM1OnYy", "diffSide": "RIGHT", "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/RpcResponseChunkDecoder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNDo0NzoyNFrOGcf_Ew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQxMzo0Nzo1OVrOGcypEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjUzNzM2Mw==", "bodyText": "Should this be a while?:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  if (!rawOut.isEmpty()) {\n          \n          \n            \n                  while (!rawOut.isEmpty()) {", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r432537363", "createdAt": "2020-05-29T14:47:24Z", "author": {"login": "mbaxter"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/RpcResponseChunkDecoder.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.networking.eth2.rpc.core.encodings;\n+\n+import static java.lang.Integer.min;\n+\n+import io.libp2p.etc.types.ByteBufExtKt;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.handler.codec.compression.SnappyFrameDecoder;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Netty decoder which decodes ssz_snappy or raw ssz Eth2 RPC response chunks from inbound response\n+ * stream\n+ */\n+public class RpcResponseChunkDecoder extends SnappyFrameDecoder {\n+\n+  private final boolean compressed;\n+  private int respCode;\n+  private long remainingRawLength = 0;\n+  private boolean decodePayload = false;\n+  private final List<ByteBuf> rawDataFrames = new ArrayList<>();\n+\n+  /**\n+   * Create a new decoder\n+   *\n+   * @param compressed {@code true} if the stream is Snappy compressed, {@code false} if the stream\n+   *     is plain ssz\n+   */\n+  public RpcResponseChunkDecoder(boolean compressed) {\n+    super(true);\n+    this.compressed = compressed;\n+  }\n+\n+  @Override\n+  protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {\n+    if (!decodePayload) {\n+      if (in.readableBytes() < 2) {\n+        // wait for more byte to read resp code and length fields\n+        return;\n+      }\n+      int rollbackIndex = in.readerIndex();\n+\n+      byte respCode = in.readByte();\n+      long length = ByteBufExtKt.readUvarint(in);\n+      if (length < 0) {\n+        // wait for more byte to read length field\n+        in.readerIndex(rollbackIndex);\n+        return;\n+      }\n+      this.respCode = respCode;\n+      this.remainingRawLength = length;\n+      decodePayload = true;\n+    } else {\n+      ArrayList<Object> rawOut = new ArrayList<>();\n+      if (respCode == 0 && compressed) {\n+        super.decode(ctx, in, rawOut);\n+      } else {\n+        rawOut.add(in.readSlice(min(in.readableBytes(), (int) remainingRawLength)).retain());\n+      }\n+\n+      if (remainingRawLength == 0) {\n+        // special case for chunk with 0 length\n+        rawOut.add(Unpooled.EMPTY_BUFFER);\n+      }\n+\n+      if (!rawOut.isEmpty()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c7177049a53d76a82f97fc335e8169ca8ba6e306"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg0MzAyNg==", "bodyText": "It decodes only 1 frame per round. If it's not the case then we have big problems :)", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r432843026", "createdAt": "2020-05-30T13:47:59Z", "author": {"login": "Nashatyrev"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/RpcResponseChunkDecoder.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.networking.eth2.rpc.core.encodings;\n+\n+import static java.lang.Integer.min;\n+\n+import io.libp2p.etc.types.ByteBufExtKt;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.handler.codec.compression.SnappyFrameDecoder;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Netty decoder which decodes ssz_snappy or raw ssz Eth2 RPC response chunks from inbound response\n+ * stream\n+ */\n+public class RpcResponseChunkDecoder extends SnappyFrameDecoder {\n+\n+  private final boolean compressed;\n+  private int respCode;\n+  private long remainingRawLength = 0;\n+  private boolean decodePayload = false;\n+  private final List<ByteBuf> rawDataFrames = new ArrayList<>();\n+\n+  /**\n+   * Create a new decoder\n+   *\n+   * @param compressed {@code true} if the stream is Snappy compressed, {@code false} if the stream\n+   *     is plain ssz\n+   */\n+  public RpcResponseChunkDecoder(boolean compressed) {\n+    super(true);\n+    this.compressed = compressed;\n+  }\n+\n+  @Override\n+  protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {\n+    if (!decodePayload) {\n+      if (in.readableBytes() < 2) {\n+        // wait for more byte to read resp code and length fields\n+        return;\n+      }\n+      int rollbackIndex = in.readerIndex();\n+\n+      byte respCode = in.readByte();\n+      long length = ByteBufExtKt.readUvarint(in);\n+      if (length < 0) {\n+        // wait for more byte to read length field\n+        in.readerIndex(rollbackIndex);\n+        return;\n+      }\n+      this.respCode = respCode;\n+      this.remainingRawLength = length;\n+      decodePayload = true;\n+    } else {\n+      ArrayList<Object> rawOut = new ArrayList<>();\n+      if (respCode == 0 && compressed) {\n+        super.decode(ctx, in, rawOut);\n+      } else {\n+        rawOut.add(in.readSlice(min(in.readableBytes(), (int) remainingRawLength)).retain());\n+      }\n+\n+      if (remainingRawLength == 0) {\n+        // special case for chunk with 0 length\n+        rawOut.add(Unpooled.EMPTY_BUFFER);\n+      }\n+\n+      if (!rawOut.isEmpty()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjUzNzM2Mw=="}, "originalCommit": {"oid": "c7177049a53d76a82f97fc335e8169ca8ba6e306"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1NjE5MjkzOnYy", "diffSide": "RIGHT", "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/LengthPrefixedPayloadDecoder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxNzo0MzoyNVrOGl5xEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxNzo0MzoyNVrOGl5xEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM5Njk0Nw==", "bodyText": "(nit) We usually put internal classes at the bottom of the file.", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r442396947", "createdAt": "2020-06-18T17:43:25Z", "author": {"login": "mbaxter"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/LengthPrefixedPayloadDecoder.java", "diffHunk": "@@ -14,102 +14,130 @@\n package tech.pegasys.teku.networking.eth2.rpc.core.encodings;\n \n import static tech.pegasys.teku.util.config.Constants.MAX_CHUNK_SIZE;\n-import static tech.pegasys.teku.util.iostreams.IOStreamConstants.END_OF_STREAM;\n \n-import com.google.protobuf.CodedInputStream;\n-import java.io.ByteArrayOutputStream;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n+import io.libp2p.etc.types.ByteBufExtKt;\n+import io.netty.buffer.ByteBuf;\n+import java.util.Optional;\n import org.apache.tuweni.bytes.Bytes;\n import tech.pegasys.teku.networking.eth2.rpc.core.RpcException;\n import tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.Compressor;\n+import tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.Compressor.Decompressor;\n import tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.exceptions.CompressionException;\n-import tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.exceptions.PayloadLargerThanExpectedException;\n-import tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.exceptions.PayloadSmallerThanExpectedException;\n \n-class LengthPrefixedPayloadDecoder<T> {\n-  private static final Logger LOG = LogManager.getLogger();\n+class LengthPrefixedPayloadDecoder<T> implements RpcByteBufDecoder<T> {\n \n-  static final Bytes MAX_CHUNK_SIZE_PREFIX = ProtobufEncoder.encodeVarInt(MAX_CHUNK_SIZE);\n+  private static class VarIntDecoder extends AbstractByteBufDecoder<Long> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d789946533d88950e8a8c76db5202d65149ef39"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1NjIyNTg5OnYy", "diffSide": "RIGHT", "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/AbstractByteBufDecoder.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxNzo1MzoxNFrOGl6GrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNjowMzo1MlrOGnHUqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQwMjQ3Ng==", "bodyText": "Seems like RpcException.EXTRA_DATA_APPENDED would be a better error here?", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r442402476", "createdAt": "2020-06-18T17:53:14Z", "author": {"login": "mbaxter"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/AbstractByteBufDecoder.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.networking.eth2.rpc.core.encodings;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.CompositeByteBuf;\n+import io.netty.buffer.Unpooled;\n+import java.util.Optional;\n+import tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.exceptions.PayloadSmallerThanExpectedException;\n+\n+/**\n+ * Abstract {@link ByteBufDecoder} implementation which handles unprocessed {@link ByteBuf}s\n+ *\n+ * <p>This class is a standalone analog of Netty {@link io.netty.handler.codec.ByteToMessageDecoder}\n+ */\n+public abstract class AbstractByteBufDecoder<TMessage>\n+    implements ByteBufDecoder<TMessage, RuntimeException> {\n+\n+  private CompositeByteBuf compositeByteBuf = Unpooled.compositeBuffer();\n+\n+  @Override\n+  public synchronized Optional<TMessage> decodeOneMessage(ByteBuf in) {\n+    if (!in.isReadable()) {\n+      return Optional.empty();\n+    }\n+    compositeByteBuf.addComponent(true, in.retainedSlice());\n+    try {\n+      Optional<TMessage> outBuf;\n+      while (true) {\n+        int readerIndex = compositeByteBuf.readerIndex();\n+        outBuf = decodeOneImpl(compositeByteBuf);\n+        if (outBuf.isPresent()\n+            || readerIndex == compositeByteBuf.readerIndex()\n+            || compositeByteBuf.readableBytes() == 0) {\n+          break;\n+        }\n+      }\n+      if (outBuf.isPresent()) {\n+        in.skipBytes(in.readableBytes() - compositeByteBuf.readableBytes());\n+        compositeByteBuf.release();\n+        compositeByteBuf = Unpooled.compositeBuffer();\n+      } else {\n+        in.skipBytes(in.readableBytes());\n+      }\n+      return outBuf;\n+    } catch (Throwable t) {\n+      compositeByteBuf.release();\n+      compositeByteBuf = Unpooled.compositeBuffer();\n+      throw t;\n+    }\n+  }\n+\n+  @Override\n+  public void complete() {\n+    if (compositeByteBuf.isReadable()) {\n+      compositeByteBuf.release();\n+      throw new PayloadSmallerThanExpectedException(\n+          \"Rpc stream complete, but unprocessed data left: \" + compositeByteBuf.readableBytes());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d789946533d88950e8a8c76db5202d65149ef39"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY2NzYyNw==", "bodyText": "Honestly I slightly messed up exceptions handling.\nDid a small refactor here. Can you please review?", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r443667627", "createdAt": "2020-06-22T16:03:52Z", "author": {"login": "Nashatyrev"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/AbstractByteBufDecoder.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.networking.eth2.rpc.core.encodings;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.CompositeByteBuf;\n+import io.netty.buffer.Unpooled;\n+import java.util.Optional;\n+import tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.exceptions.PayloadSmallerThanExpectedException;\n+\n+/**\n+ * Abstract {@link ByteBufDecoder} implementation which handles unprocessed {@link ByteBuf}s\n+ *\n+ * <p>This class is a standalone analog of Netty {@link io.netty.handler.codec.ByteToMessageDecoder}\n+ */\n+public abstract class AbstractByteBufDecoder<TMessage>\n+    implements ByteBufDecoder<TMessage, RuntimeException> {\n+\n+  private CompositeByteBuf compositeByteBuf = Unpooled.compositeBuffer();\n+\n+  @Override\n+  public synchronized Optional<TMessage> decodeOneMessage(ByteBuf in) {\n+    if (!in.isReadable()) {\n+      return Optional.empty();\n+    }\n+    compositeByteBuf.addComponent(true, in.retainedSlice());\n+    try {\n+      Optional<TMessage> outBuf;\n+      while (true) {\n+        int readerIndex = compositeByteBuf.readerIndex();\n+        outBuf = decodeOneImpl(compositeByteBuf);\n+        if (outBuf.isPresent()\n+            || readerIndex == compositeByteBuf.readerIndex()\n+            || compositeByteBuf.readableBytes() == 0) {\n+          break;\n+        }\n+      }\n+      if (outBuf.isPresent()) {\n+        in.skipBytes(in.readableBytes() - compositeByteBuf.readableBytes());\n+        compositeByteBuf.release();\n+        compositeByteBuf = Unpooled.compositeBuffer();\n+      } else {\n+        in.skipBytes(in.readableBytes());\n+      }\n+      return outBuf;\n+    } catch (Throwable t) {\n+      compositeByteBuf.release();\n+      compositeByteBuf = Unpooled.compositeBuffer();\n+      throw t;\n+    }\n+  }\n+\n+  @Override\n+  public void complete() {\n+    if (compositeByteBuf.isReadable()) {\n+      compositeByteBuf.release();\n+      throw new PayloadSmallerThanExpectedException(\n+          \"Rpc stream complete, but unprocessed data left: \" + compositeByteBuf.readableBytes());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQwMjQ3Ng=="}, "originalCommit": {"oid": "9d789946533d88950e8a8c76db5202d65149ef39"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1NjI5OTc1OnYy", "diffSide": "RIGHT", "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/LengthPrefixedPayloadDecoder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxODoxNTo0N1rOGl62WQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMTowNTo1MVrOGm8A7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQxNDY4MQ==", "bodyText": "What about:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      // making a copy here since the Bytes.wrapByteBuf(buf).slice(...)\n          \n          \n            \n                      // would be broken after [in] buffer is released\n          \n          \n            \n                      byte[] arr = new byte[ret.get().readableBytes()];\n          \n          \n            \n                      ret.get().readBytes(arr);\n          \n          \n            \n                      Bytes bytes = Bytes.wrap(arr);\n          \n          \n            \n                      Bytes bytes = Bytes.wrapByteBuf(ret.get()).copy();", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r442414681", "createdAt": "2020-06-18T18:15:47Z", "author": {"login": "mbaxter"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/LengthPrefixedPayloadDecoder.java", "diffHunk": "@@ -14,102 +14,130 @@\n package tech.pegasys.teku.networking.eth2.rpc.core.encodings;\n \n import static tech.pegasys.teku.util.config.Constants.MAX_CHUNK_SIZE;\n-import static tech.pegasys.teku.util.iostreams.IOStreamConstants.END_OF_STREAM;\n \n-import com.google.protobuf.CodedInputStream;\n-import java.io.ByteArrayOutputStream;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n+import io.libp2p.etc.types.ByteBufExtKt;\n+import io.netty.buffer.ByteBuf;\n+import java.util.Optional;\n import org.apache.tuweni.bytes.Bytes;\n import tech.pegasys.teku.networking.eth2.rpc.core.RpcException;\n import tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.Compressor;\n+import tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.Compressor.Decompressor;\n import tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.exceptions.CompressionException;\n-import tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.exceptions.PayloadLargerThanExpectedException;\n-import tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.exceptions.PayloadSmallerThanExpectedException;\n \n-class LengthPrefixedPayloadDecoder<T> {\n-  private static final Logger LOG = LogManager.getLogger();\n+class LengthPrefixedPayloadDecoder<T> implements RpcByteBufDecoder<T> {\n \n-  static final Bytes MAX_CHUNK_SIZE_PREFIX = ProtobufEncoder.encodeVarInt(MAX_CHUNK_SIZE);\n+  private static class VarIntDecoder extends AbstractByteBufDecoder<Long> {\n+    @Override\n+    protected Optional<Long> decodeOneImpl(ByteBuf in) {\n+      long length = ByteBufExtKt.readUvarint(in);\n+      if (length < 0) {\n+        // wait for more byte to read length field\n+        return Optional.empty();\n+      }\n+      return Optional.of(length);\n+    }\n+  }\n \n   private final RpcPayloadEncoder<T> payloadEncoder;\n   private final Compressor compressor;\n+  private Optional<Decompressor> decompressor = Optional.empty();\n+  private Optional<VarIntDecoder> varIntDecoder = Optional.empty();\n+  private boolean decoded = false;\n+  private boolean disposed = false;\n \n   public LengthPrefixedPayloadDecoder(\n       final RpcPayloadEncoder<T> payloadEncoder, final Compressor compressor) {\n     this.payloadEncoder = payloadEncoder;\n     this.compressor = compressor;\n   }\n \n-  public T decodePayload(final InputStream inputStream) throws RpcException {\n-    try {\n-      final int uncompressedPayloadSize = processLengthPrefixHeader(inputStream);\n-      return processPayload(inputStream, uncompressedPayloadSize);\n-    } catch (PayloadSmallerThanExpectedException e) {\n-      throw RpcException.PAYLOAD_TRUNCATED;\n-    } catch (PayloadLargerThanExpectedException e) {\n-      throw RpcException.EXTRA_DATA_APPENDED;\n-    } catch (CompressionException e) {\n-      LOG.debug(\"Failed to uncompress rpc payload\", e);\n-      throw RpcException.FAILED_TO_UNCOMPRESS_MESSAGE;\n-    } catch (IOException e) {\n-      LOG.error(\"Unable to decode rpc payload\", e);\n-      throw RpcException.SERVER_ERROR;\n+  @Override\n+  public Optional<T> decodeOneMessage(final ByteBuf in) throws RpcException {\n+    if (decoded || disposed) {\n+      throw new IllegalStateException(\"Trying to reuse disposable LengthPrefixedPayloadDecoder\");\n+    }\n+    if (decompressor.isEmpty()) {\n+      readLengthPrefixHeader(in)\n+          .ifPresent(len -> decompressor = Optional.of(compressor.createDecompressor(len)));\n+    }\n+    if (decompressor.isPresent()) {\n+      Optional<ByteBuf> ret = decompressor.get().decodeOneMessage(in);\n+      if (ret.isPresent()) {\n+        decompressor = Optional.empty();\n+        try {\n+          // making a copy here since the Bytes.wrapByteBuf(buf).slice(...)\n+          // would be broken after [in] buffer is released\n+          byte[] arr = new byte[ret.get().readableBytes()];\n+          ret.get().readBytes(arr);\n+          Bytes bytes = Bytes.wrap(arr);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d789946533d88950e8a8c76db5202d65149ef39"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ4MjM1MQ==", "bodyText": "I've found a bug in Bytes.wrapByteBuf() so changed all its usages to a safer variant", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r443482351", "createdAt": "2020-06-22T11:05:51Z", "author": {"login": "Nashatyrev"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/LengthPrefixedPayloadDecoder.java", "diffHunk": "@@ -14,102 +14,130 @@\n package tech.pegasys.teku.networking.eth2.rpc.core.encodings;\n \n import static tech.pegasys.teku.util.config.Constants.MAX_CHUNK_SIZE;\n-import static tech.pegasys.teku.util.iostreams.IOStreamConstants.END_OF_STREAM;\n \n-import com.google.protobuf.CodedInputStream;\n-import java.io.ByteArrayOutputStream;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n+import io.libp2p.etc.types.ByteBufExtKt;\n+import io.netty.buffer.ByteBuf;\n+import java.util.Optional;\n import org.apache.tuweni.bytes.Bytes;\n import tech.pegasys.teku.networking.eth2.rpc.core.RpcException;\n import tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.Compressor;\n+import tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.Compressor.Decompressor;\n import tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.exceptions.CompressionException;\n-import tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.exceptions.PayloadLargerThanExpectedException;\n-import tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.exceptions.PayloadSmallerThanExpectedException;\n \n-class LengthPrefixedPayloadDecoder<T> {\n-  private static final Logger LOG = LogManager.getLogger();\n+class LengthPrefixedPayloadDecoder<T> implements RpcByteBufDecoder<T> {\n \n-  static final Bytes MAX_CHUNK_SIZE_PREFIX = ProtobufEncoder.encodeVarInt(MAX_CHUNK_SIZE);\n+  private static class VarIntDecoder extends AbstractByteBufDecoder<Long> {\n+    @Override\n+    protected Optional<Long> decodeOneImpl(ByteBuf in) {\n+      long length = ByteBufExtKt.readUvarint(in);\n+      if (length < 0) {\n+        // wait for more byte to read length field\n+        return Optional.empty();\n+      }\n+      return Optional.of(length);\n+    }\n+  }\n \n   private final RpcPayloadEncoder<T> payloadEncoder;\n   private final Compressor compressor;\n+  private Optional<Decompressor> decompressor = Optional.empty();\n+  private Optional<VarIntDecoder> varIntDecoder = Optional.empty();\n+  private boolean decoded = false;\n+  private boolean disposed = false;\n \n   public LengthPrefixedPayloadDecoder(\n       final RpcPayloadEncoder<T> payloadEncoder, final Compressor compressor) {\n     this.payloadEncoder = payloadEncoder;\n     this.compressor = compressor;\n   }\n \n-  public T decodePayload(final InputStream inputStream) throws RpcException {\n-    try {\n-      final int uncompressedPayloadSize = processLengthPrefixHeader(inputStream);\n-      return processPayload(inputStream, uncompressedPayloadSize);\n-    } catch (PayloadSmallerThanExpectedException e) {\n-      throw RpcException.PAYLOAD_TRUNCATED;\n-    } catch (PayloadLargerThanExpectedException e) {\n-      throw RpcException.EXTRA_DATA_APPENDED;\n-    } catch (CompressionException e) {\n-      LOG.debug(\"Failed to uncompress rpc payload\", e);\n-      throw RpcException.FAILED_TO_UNCOMPRESS_MESSAGE;\n-    } catch (IOException e) {\n-      LOG.error(\"Unable to decode rpc payload\", e);\n-      throw RpcException.SERVER_ERROR;\n+  @Override\n+  public Optional<T> decodeOneMessage(final ByteBuf in) throws RpcException {\n+    if (decoded || disposed) {\n+      throw new IllegalStateException(\"Trying to reuse disposable LengthPrefixedPayloadDecoder\");\n+    }\n+    if (decompressor.isEmpty()) {\n+      readLengthPrefixHeader(in)\n+          .ifPresent(len -> decompressor = Optional.of(compressor.createDecompressor(len)));\n+    }\n+    if (decompressor.isPresent()) {\n+      Optional<ByteBuf> ret = decompressor.get().decodeOneMessage(in);\n+      if (ret.isPresent()) {\n+        decompressor = Optional.empty();\n+        try {\n+          // making a copy here since the Bytes.wrapByteBuf(buf).slice(...)\n+          // would be broken after [in] buffer is released\n+          byte[] arr = new byte[ret.get().readableBytes()];\n+          ret.get().readBytes(arr);\n+          Bytes bytes = Bytes.wrap(arr);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQxNDY4MQ=="}, "originalCommit": {"oid": "9d789946533d88950e8a8c76db5202d65149ef39"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1NjM3MTcyOnYy", "diffSide": "RIGHT", "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/compression/snappy/SnappyFrameDecoder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxODozNzozMFrOGl7kMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxODozNzozMFrOGl7kMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQyNjQxOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * https://github.com/netty/netty/blob/4.1/codec/src/main/java/io/netty/handler/codec/compression/SnappyFramedDecoder.java\n          \n          \n            \n             * https://github.com/netty/netty/blob/4.1/codec/src/main/java/io/netty/handler/codec/compression/SnappyFrameDecoder.java", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r442426419", "createdAt": "2020-06-18T18:37:30Z", "author": {"login": "mbaxter"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/compression/snappy/SnappyFrameDecoder.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.snappy;\n+\n+import static tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.snappy.SnappyUtil.validateChecksum;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.handler.codec.compression.CompressionException;\n+import io.netty.handler.codec.compression.Snappy;\n+import java.util.Optional;\n+import tech.pegasys.teku.networking.eth2.rpc.core.encodings.AbstractByteBufDecoder;\n+\n+/**\n+ * This class is mostly borrowed from the Netty implementation:\n+ * https://github.com/netty/netty/blob/4.1/codec/src/main/java/io/netty/handler/codec/compression/SnappyFramedDecoder.java", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d789946533d88950e8a8c76db5202d65149ef39"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1NjM3NzgxOnYy", "diffSide": "RIGHT", "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/compression/snappy/SnappyFrameDecoder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxODozOToyNlrOGl7n-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMTowOToxOVrOGm8HOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQyNzM4Nw==", "bodyText": "Looks like we're enabling these checks by default", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r442427387", "createdAt": "2020-06-18T18:39:26Z", "author": {"login": "mbaxter"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/compression/snappy/SnappyFrameDecoder.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.snappy;\n+\n+import static tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.snappy.SnappyUtil.validateChecksum;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.handler.codec.compression.CompressionException;\n+import io.netty.handler.codec.compression.Snappy;\n+import java.util.Optional;\n+import tech.pegasys.teku.networking.eth2.rpc.core.encodings.AbstractByteBufDecoder;\n+\n+/**\n+ * This class is mostly borrowed from the Netty implementation:\n+ * https://github.com/netty/netty/blob/4.1/codec/src/main/java/io/netty/handler/codec/compression/SnappyFramedDecoder.java\n+ *\n+ * <p>Uncompresses a {@link ByteBuf} encoded with the Snappy framing format.\n+ *\n+ * <p>See <a href=\"https://github.com/google/snappy/blob/master/framing_format.txt\">Snappy framing\n+ * format</a>.\n+ *\n+ * <p>Note that by default, validation of the checksum header in each chunk is DISABLED for\n+ * performance improvements. If performance is less of an issue, or if you would prefer the safety\n+ * that checksum validation brings, please use the {@link #SnappyFrameDecoder(boolean)} constructor\n+ * with the argument set to {@code true}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d789946533d88950e8a8c76db5202d65149ef39"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ4Mzk2MQ==", "bodyText": "Right! This comment just left from the original implementation. Removed it.", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r443483961", "createdAt": "2020-06-22T11:09:19Z", "author": {"login": "Nashatyrev"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/compression/snappy/SnappyFrameDecoder.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.snappy;\n+\n+import static tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.snappy.SnappyUtil.validateChecksum;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.handler.codec.compression.CompressionException;\n+import io.netty.handler.codec.compression.Snappy;\n+import java.util.Optional;\n+import tech.pegasys.teku.networking.eth2.rpc.core.encodings.AbstractByteBufDecoder;\n+\n+/**\n+ * This class is mostly borrowed from the Netty implementation:\n+ * https://github.com/netty/netty/blob/4.1/codec/src/main/java/io/netty/handler/codec/compression/SnappyFramedDecoder.java\n+ *\n+ * <p>Uncompresses a {@link ByteBuf} encoded with the Snappy framing format.\n+ *\n+ * <p>See <a href=\"https://github.com/google/snappy/blob/master/framing_format.txt\">Snappy framing\n+ * format</a>.\n+ *\n+ * <p>Note that by default, validation of the checksum header in each chunk is DISABLED for\n+ * performance improvements. If performance is less of an issue, or if you would prefer the safety\n+ * that checksum validation brings, please use the {@link #SnappyFrameDecoder(boolean)} constructor\n+ * with the argument set to {@code true}.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQyNzM4Nw=="}, "originalCommit": {"oid": "9d789946533d88950e8a8c76db5202d65149ef39"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1NjM4MTYxOnYy", "diffSide": "RIGHT", "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/compression/snappy/SnappyFrameDecoder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxODo0MDozNFrOGl7qcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxODo0MDozNFrOGl7qcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQyODAxNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * Creates a new snappy-framed decoder with validation of checksums turned OFF. To turn checksum\n          \n          \n            \n               * validation on, please use the alternate {@link #SnappyFrameDecoder(boolean)} constructor.\n          \n          \n            \n               */\n          \n          \n            \n               * Creates a new snappy-framed decoder with validation of checksums turned on. To turn checksum\n          \n          \n            \n               * validation off, please use the alternate {@link #SnappyFrameDecoder(boolean)} constructor.\n          \n          \n            \n               */", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r442428016", "createdAt": "2020-06-18T18:40:34Z", "author": {"login": "mbaxter"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/compression/snappy/SnappyFrameDecoder.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.snappy;\n+\n+import static tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.snappy.SnappyUtil.validateChecksum;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.handler.codec.compression.CompressionException;\n+import io.netty.handler.codec.compression.Snappy;\n+import java.util.Optional;\n+import tech.pegasys.teku.networking.eth2.rpc.core.encodings.AbstractByteBufDecoder;\n+\n+/**\n+ * This class is mostly borrowed from the Netty implementation:\n+ * https://github.com/netty/netty/blob/4.1/codec/src/main/java/io/netty/handler/codec/compression/SnappyFramedDecoder.java\n+ *\n+ * <p>Uncompresses a {@link ByteBuf} encoded with the Snappy framing format.\n+ *\n+ * <p>See <a href=\"https://github.com/google/snappy/blob/master/framing_format.txt\">Snappy framing\n+ * format</a>.\n+ *\n+ * <p>Note that by default, validation of the checksum header in each chunk is DISABLED for\n+ * performance improvements. If performance is less of an issue, or if you would prefer the safety\n+ * that checksum validation brings, please use the {@link #SnappyFrameDecoder(boolean)} constructor\n+ * with the argument set to {@code true}.\n+ */\n+public class SnappyFrameDecoder extends AbstractByteBufDecoder<ByteBuf> {\n+\n+  private enum ChunkType {\n+    STREAM_IDENTIFIER,\n+    COMPRESSED_DATA,\n+    UNCOMPRESSED_DATA,\n+    RESERVED_UNSKIPPABLE,\n+    RESERVED_SKIPPABLE\n+  }\n+\n+  private static final int SNAPPY_IDENTIFIER_LEN = 6;\n+  private static final int MAX_UNCOMPRESSED_DATA_SIZE = 65536 + 4;\n+\n+  private final Snappy snappy = new Snappy();\n+  private final boolean validateChecksums;\n+\n+  private boolean started;\n+  private boolean corrupted;\n+\n+  /**\n+   * Creates a new snappy-framed decoder with validation of checksums turned OFF. To turn checksum\n+   * validation on, please use the alternate {@link #SnappyFrameDecoder(boolean)} constructor.\n+   */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d789946533d88950e8a8c76db5202d65149ef39"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1NjQ3MDUzOnYy", "diffSide": "RIGHT", "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/compression/snappy/SnappyFrameDecoder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxOTowNjo0OFrOGl8h_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMToyMDozNlrOGm8bzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ0MjIzNw==", "bodyText": "Shouldn't we make sure that started == false?  I put together a quick test and it looks like we'll accept extra snappy headers prepended to the message.", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r442442237", "createdAt": "2020-06-18T19:06:48Z", "author": {"login": "mbaxter"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/compression/snappy/SnappyFrameDecoder.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.snappy;\n+\n+import static tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.snappy.SnappyUtil.validateChecksum;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.handler.codec.compression.CompressionException;\n+import io.netty.handler.codec.compression.Snappy;\n+import java.util.Optional;\n+import tech.pegasys.teku.networking.eth2.rpc.core.encodings.AbstractByteBufDecoder;\n+\n+/**\n+ * This class is mostly borrowed from the Netty implementation:\n+ * https://github.com/netty/netty/blob/4.1/codec/src/main/java/io/netty/handler/codec/compression/SnappyFramedDecoder.java\n+ *\n+ * <p>Uncompresses a {@link ByteBuf} encoded with the Snappy framing format.\n+ *\n+ * <p>See <a href=\"https://github.com/google/snappy/blob/master/framing_format.txt\">Snappy framing\n+ * format</a>.\n+ *\n+ * <p>Note that by default, validation of the checksum header in each chunk is DISABLED for\n+ * performance improvements. If performance is less of an issue, or if you would prefer the safety\n+ * that checksum validation brings, please use the {@link #SnappyFrameDecoder(boolean)} constructor\n+ * with the argument set to {@code true}.\n+ */\n+public class SnappyFrameDecoder extends AbstractByteBufDecoder<ByteBuf> {\n+\n+  private enum ChunkType {\n+    STREAM_IDENTIFIER,\n+    COMPRESSED_DATA,\n+    UNCOMPRESSED_DATA,\n+    RESERVED_UNSKIPPABLE,\n+    RESERVED_SKIPPABLE\n+  }\n+\n+  private static final int SNAPPY_IDENTIFIER_LEN = 6;\n+  private static final int MAX_UNCOMPRESSED_DATA_SIZE = 65536 + 4;\n+\n+  private final Snappy snappy = new Snappy();\n+  private final boolean validateChecksums;\n+\n+  private boolean started;\n+  private boolean corrupted;\n+\n+  /**\n+   * Creates a new snappy-framed decoder with validation of checksums turned OFF. To turn checksum\n+   * validation on, please use the alternate {@link #SnappyFrameDecoder(boolean)} constructor.\n+   */\n+  public SnappyFrameDecoder() {\n+    this(true);\n+  }\n+\n+  /**\n+   * Creates a new snappy-framed decoder with validation of checksums as specified.\n+   *\n+   * @param validateChecksums If true, the checksum field will be validated against the actual\n+   *     uncompressed data, and if the checksums do not match, a suitable {@link\n+   *     CompressionException} will be thrown\n+   */\n+  public SnappyFrameDecoder(boolean validateChecksums) {\n+    this.validateChecksums = validateChecksums;\n+  }\n+\n+  @Override\n+  protected Optional<ByteBuf> decodeOneImpl(ByteBuf in) {\n+    if (corrupted) {\n+      in.skipBytes(in.readableBytes());\n+      return Optional.empty();\n+    }\n+\n+    ByteBuf ret = null;\n+\n+    try {\n+      int idx = in.readerIndex();\n+      final int inSize = in.readableBytes();\n+      if (inSize < 4) {\n+        // We need to be at least able to read the chunk type identifier (one byte),\n+        // and the length of the chunk (3 bytes) in order to proceed\n+        return Optional.empty();\n+      }\n+\n+      final int chunkTypeVal = in.getUnsignedByte(idx);\n+      final ChunkType chunkType = mapChunkType((byte) chunkTypeVal);\n+      final int chunkLength = in.getUnsignedMediumLE(idx + 1);\n+\n+      switch (chunkType) {\n+        case STREAM_IDENTIFIER:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d789946533d88950e8a8c76db5202d65149ef39"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ4OTIyOA==", "bodyText": "Good catch \ud83d\udc4d  This is from original Netty class. Fixed", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r443489228", "createdAt": "2020-06-22T11:20:36Z", "author": {"login": "Nashatyrev"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/compression/snappy/SnappyFrameDecoder.java", "diffHunk": "@@ -0,0 +1,232 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.snappy;\n+\n+import static tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.snappy.SnappyUtil.validateChecksum;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.handler.codec.compression.CompressionException;\n+import io.netty.handler.codec.compression.Snappy;\n+import java.util.Optional;\n+import tech.pegasys.teku.networking.eth2.rpc.core.encodings.AbstractByteBufDecoder;\n+\n+/**\n+ * This class is mostly borrowed from the Netty implementation:\n+ * https://github.com/netty/netty/blob/4.1/codec/src/main/java/io/netty/handler/codec/compression/SnappyFramedDecoder.java\n+ *\n+ * <p>Uncompresses a {@link ByteBuf} encoded with the Snappy framing format.\n+ *\n+ * <p>See <a href=\"https://github.com/google/snappy/blob/master/framing_format.txt\">Snappy framing\n+ * format</a>.\n+ *\n+ * <p>Note that by default, validation of the checksum header in each chunk is DISABLED for\n+ * performance improvements. If performance is less of an issue, or if you would prefer the safety\n+ * that checksum validation brings, please use the {@link #SnappyFrameDecoder(boolean)} constructor\n+ * with the argument set to {@code true}.\n+ */\n+public class SnappyFrameDecoder extends AbstractByteBufDecoder<ByteBuf> {\n+\n+  private enum ChunkType {\n+    STREAM_IDENTIFIER,\n+    COMPRESSED_DATA,\n+    UNCOMPRESSED_DATA,\n+    RESERVED_UNSKIPPABLE,\n+    RESERVED_SKIPPABLE\n+  }\n+\n+  private static final int SNAPPY_IDENTIFIER_LEN = 6;\n+  private static final int MAX_UNCOMPRESSED_DATA_SIZE = 65536 + 4;\n+\n+  private final Snappy snappy = new Snappy();\n+  private final boolean validateChecksums;\n+\n+  private boolean started;\n+  private boolean corrupted;\n+\n+  /**\n+   * Creates a new snappy-framed decoder with validation of checksums turned OFF. To turn checksum\n+   * validation on, please use the alternate {@link #SnappyFrameDecoder(boolean)} constructor.\n+   */\n+  public SnappyFrameDecoder() {\n+    this(true);\n+  }\n+\n+  /**\n+   * Creates a new snappy-framed decoder with validation of checksums as specified.\n+   *\n+   * @param validateChecksums If true, the checksum field will be validated against the actual\n+   *     uncompressed data, and if the checksums do not match, a suitable {@link\n+   *     CompressionException} will be thrown\n+   */\n+  public SnappyFrameDecoder(boolean validateChecksums) {\n+    this.validateChecksums = validateChecksums;\n+  }\n+\n+  @Override\n+  protected Optional<ByteBuf> decodeOneImpl(ByteBuf in) {\n+    if (corrupted) {\n+      in.skipBytes(in.readableBytes());\n+      return Optional.empty();\n+    }\n+\n+    ByteBuf ret = null;\n+\n+    try {\n+      int idx = in.readerIndex();\n+      final int inSize = in.readableBytes();\n+      if (inSize < 4) {\n+        // We need to be at least able to read the chunk type identifier (one byte),\n+        // and the length of the chunk (3 bytes) in order to proceed\n+        return Optional.empty();\n+      }\n+\n+      final int chunkTypeVal = in.getUnsignedByte(idx);\n+      final ChunkType chunkType = mapChunkType((byte) chunkTypeVal);\n+      final int chunkLength = in.getUnsignedMediumLE(idx + 1);\n+\n+      switch (chunkType) {\n+        case STREAM_IDENTIFIER:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ0MjIzNw=="}, "originalCommit": {"oid": "9d789946533d88950e8a8c76db5202d65149ef39"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1NjU5Mzc2OnYy", "diffSide": "RIGHT", "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/compression/snappy/SnappyUtil.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxOTo0Mzo0M1rOGl9vow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMToyMTo1MlrOGm8eBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ2MjExNQ==", "bodyText": "Why not just use the netty Snappy implementations of this utils?", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r442462115", "createdAt": "2020-06-18T19:43:43Z", "author": {"login": "mbaxter"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/compression/snappy/SnappyUtil.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.snappy;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.handler.codec.compression.DecompressionException;\n+import java.util.zip.CRC32C;\n+\n+class SnappyUtil {\n+\n+  static int calculateChecksum(ByteBuf data) {\n+    return calculateChecksum(data, data.readerIndex(), data.readableBytes());\n+  }\n+\n+  static int calculateChecksum(ByteBuf data, int offset, int length) {\n+    CRC32C crc32 = new CRC32C();\n+    try {\n+      for (int i = offset; i < offset + length; i++) {\n+        crc32.update(data.getByte(i));\n+      }\n+      return maskChecksum((int) crc32.getValue());\n+    } finally {\n+      crc32.reset();\n+    }\n+  }\n+\n+  static int maskChecksum(int checksum) {\n+    return (checksum >>> 15 | checksum << 17) + 0xa282ead8;\n+  }\n+\n+  static void validateChecksum(int expectedChecksum, ByteBuf data, int offset, int length) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d789946533d88950e8a8c76db5202d65149ef39"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ4OTc5OA==", "bodyText": "This method is package private there \ud83d\ude1e", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r443489798", "createdAt": "2020-06-22T11:21:52Z", "author": {"login": "Nashatyrev"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/compression/snappy/SnappyUtil.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.snappy;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.handler.codec.compression.DecompressionException;\n+import java.util.zip.CRC32C;\n+\n+class SnappyUtil {\n+\n+  static int calculateChecksum(ByteBuf data) {\n+    return calculateChecksum(data, data.readerIndex(), data.readableBytes());\n+  }\n+\n+  static int calculateChecksum(ByteBuf data, int offset, int length) {\n+    CRC32C crc32 = new CRC32C();\n+    try {\n+      for (int i = offset; i < offset + length; i++) {\n+        crc32.update(data.getByte(i));\n+      }\n+      return maskChecksum((int) crc32.getValue());\n+    } finally {\n+      crc32.reset();\n+    }\n+  }\n+\n+  static int maskChecksum(int checksum) {\n+    return (checksum >>> 15 | checksum << 17) + 0xa282ead8;\n+  }\n+\n+  static void validateChecksum(int expectedChecksum, ByteBuf data, int offset, int length) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ2MjExNQ=="}, "originalCommit": {"oid": "9d789946533d88950e8a8c76db5202d65149ef39"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1NjY1ODkwOnYy", "diffSide": "RIGHT", "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/Eth2OutgoingRequestHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMDowNDowMlrOGl-YqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMzowMDo0MFrOGm_jnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ3MjYxNg==", "bodyText": "I think we can simplify this by handling the \"first byte\" logic here:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    List<TResponse> maybeResponses =\n          \n          \n            \n                        responseDecoder.decodeNextResponses(data, this::onFirstByteReceived);\n          \n          \n            \n                    if (data.isReadable()) {\n          \n          \n            \n                        onFirstByteReceived();\n          \n          \n            \n                    }\n          \n          \n            \n                    List<TResponse> maybeResponses = responseDecoder.decodeNextResponses(data);", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r442472616", "createdAt": "2020-06-18T20:04:02Z", "author": {"login": "mbaxter"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/Eth2OutgoingRequestHandler.java", "diffHunk": "@@ -76,37 +76,29 @@ public void handleInitialPayloadSent(final RpcStream stream) {\n   }\n \n   @Override\n-  public void processInput(\n-      final NodeId nodeId, final RpcStream rpcStream, final InputStream input) {\n+  public void active(NodeId nodeId, RpcStream rpcStream) {}\n+\n+  @Override\n+  public void processData(final NodeId nodeId, final RpcStream rpcStream, final ByteBuf data) {\n     try {\n       this.rpcStream = rpcStream;\n \n-      Optional<TResponse> maybeResponse =\n-          responseDecoder.decodeNextResponse(input, this::onFirstByteReceived);\n-      while (!isClosed.get() && maybeResponse.isPresent()) {\n-        final TResponse response = maybeResponse.get();\n-        responseProcessor.processResponse(response);\n-\n-        final int chunksReceived = currentChunkCount.incrementAndGet();\n-        if (chunksReceived >= maximumResponseChunks) {\n-          // Make sure there aren't any trailing unconsumed bytes\n-          if (input.available() > 0) {\n-            LOG.debug(\n-                \"Encountered unconsumed data after last expected response chunk was processed.\");\n-            cancelRequest(rpcStream, RpcException.EXTRA_DATA_APPENDED);\n-          } else {\n-            completeRequest(rpcStream);\n-          }\n-          break;\n+      if (!isClosed.get()) {\n+        List<TResponse> maybeResponses =\n+            responseDecoder.decodeNextResponses(data, this::onFirstByteReceived);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d789946533d88950e8a8c76db5202d65149ef39"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzU0MDM4MA==", "bodyText": "Yep, good suggestion \ud83d\udc4d", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r443540380", "createdAt": "2020-06-22T13:00:40Z", "author": {"login": "Nashatyrev"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/Eth2OutgoingRequestHandler.java", "diffHunk": "@@ -76,37 +76,29 @@ public void handleInitialPayloadSent(final RpcStream stream) {\n   }\n \n   @Override\n-  public void processInput(\n-      final NodeId nodeId, final RpcStream rpcStream, final InputStream input) {\n+  public void active(NodeId nodeId, RpcStream rpcStream) {}\n+\n+  @Override\n+  public void processData(final NodeId nodeId, final RpcStream rpcStream, final ByteBuf data) {\n     try {\n       this.rpcStream = rpcStream;\n \n-      Optional<TResponse> maybeResponse =\n-          responseDecoder.decodeNextResponse(input, this::onFirstByteReceived);\n-      while (!isClosed.get() && maybeResponse.isPresent()) {\n-        final TResponse response = maybeResponse.get();\n-        responseProcessor.processResponse(response);\n-\n-        final int chunksReceived = currentChunkCount.incrementAndGet();\n-        if (chunksReceived >= maximumResponseChunks) {\n-          // Make sure there aren't any trailing unconsumed bytes\n-          if (input.available() > 0) {\n-            LOG.debug(\n-                \"Encountered unconsumed data after last expected response chunk was processed.\");\n-            cancelRequest(rpcStream, RpcException.EXTRA_DATA_APPENDED);\n-          } else {\n-            completeRequest(rpcStream);\n-          }\n-          break;\n+      if (!isClosed.get()) {\n+        List<TResponse> maybeResponses =\n+            responseDecoder.decodeNextResponses(data, this::onFirstByteReceived);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ3MjYxNg=="}, "originalCommit": {"oid": "9d789946533d88950e8a8c76db5202d65149ef39"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1NjY3NzE4OnYy", "diffSide": "RIGHT", "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/LengthPrefixedPayloadDecoder.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMDoxMDoxNFrOGl-kdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNjowNTowOVrOGnHX9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ3NTYzNg==", "bodyText": "We should catch the specific exception we're expecting here", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r442475636", "createdAt": "2020-06-18T20:10:14Z", "author": {"login": "mbaxter"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/LengthPrefixedPayloadDecoder.java", "diffHunk": "@@ -14,102 +14,130 @@\n package tech.pegasys.teku.networking.eth2.rpc.core.encodings;\n \n import static tech.pegasys.teku.util.config.Constants.MAX_CHUNK_SIZE;\n-import static tech.pegasys.teku.util.iostreams.IOStreamConstants.END_OF_STREAM;\n \n-import com.google.protobuf.CodedInputStream;\n-import java.io.ByteArrayOutputStream;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n+import io.libp2p.etc.types.ByteBufExtKt;\n+import io.netty.buffer.ByteBuf;\n+import java.util.Optional;\n import org.apache.tuweni.bytes.Bytes;\n import tech.pegasys.teku.networking.eth2.rpc.core.RpcException;\n import tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.Compressor;\n+import tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.Compressor.Decompressor;\n import tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.exceptions.CompressionException;\n-import tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.exceptions.PayloadLargerThanExpectedException;\n-import tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.exceptions.PayloadSmallerThanExpectedException;\n \n-class LengthPrefixedPayloadDecoder<T> {\n-  private static final Logger LOG = LogManager.getLogger();\n+class LengthPrefixedPayloadDecoder<T> implements RpcByteBufDecoder<T> {\n \n-  static final Bytes MAX_CHUNK_SIZE_PREFIX = ProtobufEncoder.encodeVarInt(MAX_CHUNK_SIZE);\n+  private static class VarIntDecoder extends AbstractByteBufDecoder<Long> {\n+    @Override\n+    protected Optional<Long> decodeOneImpl(ByteBuf in) {\n+      long length = ByteBufExtKt.readUvarint(in);\n+      if (length < 0) {\n+        // wait for more byte to read length field\n+        return Optional.empty();\n+      }\n+      return Optional.of(length);\n+    }\n+  }\n \n   private final RpcPayloadEncoder<T> payloadEncoder;\n   private final Compressor compressor;\n+  private Optional<Decompressor> decompressor = Optional.empty();\n+  private Optional<VarIntDecoder> varIntDecoder = Optional.empty();\n+  private boolean decoded = false;\n+  private boolean disposed = false;\n \n   public LengthPrefixedPayloadDecoder(\n       final RpcPayloadEncoder<T> payloadEncoder, final Compressor compressor) {\n     this.payloadEncoder = payloadEncoder;\n     this.compressor = compressor;\n   }\n \n-  public T decodePayload(final InputStream inputStream) throws RpcException {\n-    try {\n-      final int uncompressedPayloadSize = processLengthPrefixHeader(inputStream);\n-      return processPayload(inputStream, uncompressedPayloadSize);\n-    } catch (PayloadSmallerThanExpectedException e) {\n-      throw RpcException.PAYLOAD_TRUNCATED;\n-    } catch (PayloadLargerThanExpectedException e) {\n-      throw RpcException.EXTRA_DATA_APPENDED;\n-    } catch (CompressionException e) {\n-      LOG.debug(\"Failed to uncompress rpc payload\", e);\n-      throw RpcException.FAILED_TO_UNCOMPRESS_MESSAGE;\n-    } catch (IOException e) {\n-      LOG.error(\"Unable to decode rpc payload\", e);\n-      throw RpcException.SERVER_ERROR;\n+  @Override\n+  public Optional<T> decodeOneMessage(final ByteBuf in) throws RpcException {\n+    if (decoded || disposed) {\n+      throw new IllegalStateException(\"Trying to reuse disposable LengthPrefixedPayloadDecoder\");\n+    }\n+    if (decompressor.isEmpty()) {\n+      readLengthPrefixHeader(in)\n+          .ifPresent(len -> decompressor = Optional.of(compressor.createDecompressor(len)));\n+    }\n+    if (decompressor.isPresent()) {\n+      Optional<ByteBuf> ret = decompressor.get().decodeOneMessage(in);\n+      if (ret.isPresent()) {\n+        decompressor = Optional.empty();\n+        try {\n+          // making a copy here since the Bytes.wrapByteBuf(buf).slice(...)\n+          // would be broken after [in] buffer is released\n+          byte[] arr = new byte[ret.get().readableBytes()];\n+          ret.get().readBytes(arr);\n+          Bytes bytes = Bytes.wrap(arr);\n+          decoded = true;\n+          return Optional.of(payloadEncoder.decode(bytes));\n+        } finally {\n+          ret.get().release();\n+        }\n+      } else {\n+        return Optional.empty();\n+      }\n+    } else {\n+      return Optional.empty();\n     }\n   }\n \n-  /** Decode the length-prefix header, which contains the length of the uncompressed payload */\n-  private int processLengthPrefixHeader(final InputStream inputStream)\n-      throws RpcException, IOException {\n-    // Collect length prefix raw bytes\n-    final ByteArrayOutputStream headerBytes = new ByteArrayOutputStream();\n-\n-    boolean foundTerminatingCharacter = false;\n-    int nextByte;\n-    while ((nextByte = inputStream.read()) != END_OF_STREAM) {\n-      if (headerBytes.size() >= MAX_CHUNK_SIZE_PREFIX.size()) {\n-        // Any protobuf length requiring more bytes than this will also be bigger.\n-        throw RpcException.CHUNK_TOO_LONG;\n+  @Override\n+  public void complete() throws RpcException {\n+    if (disposed) {\n+      throw new IllegalStateException(\"Trying to reuse disposable LengthPrefixedPayloadDecoder\");\n+    }\n+    disposed = true;\n+    RpcException err = null;\n+    if (varIntDecoder.isPresent()) {\n+      try {\n+        varIntDecoder.ifPresent(AbstractByteBufDecoder::complete);\n+      } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d789946533d88950e8a8c76db5202d65149ef39"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY2ODQ3MQ==", "bodyText": "Added comments here. There is no much sense catching specific exceptions here, sine the complete() is called just to release resources. We already know that the message was truncated", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r443668471", "createdAt": "2020-06-22T16:05:09Z", "author": {"login": "Nashatyrev"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/LengthPrefixedPayloadDecoder.java", "diffHunk": "@@ -14,102 +14,130 @@\n package tech.pegasys.teku.networking.eth2.rpc.core.encodings;\n \n import static tech.pegasys.teku.util.config.Constants.MAX_CHUNK_SIZE;\n-import static tech.pegasys.teku.util.iostreams.IOStreamConstants.END_OF_STREAM;\n \n-import com.google.protobuf.CodedInputStream;\n-import java.io.ByteArrayOutputStream;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import org.apache.logging.log4j.LogManager;\n-import org.apache.logging.log4j.Logger;\n+import io.libp2p.etc.types.ByteBufExtKt;\n+import io.netty.buffer.ByteBuf;\n+import java.util.Optional;\n import org.apache.tuweni.bytes.Bytes;\n import tech.pegasys.teku.networking.eth2.rpc.core.RpcException;\n import tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.Compressor;\n+import tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.Compressor.Decompressor;\n import tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.exceptions.CompressionException;\n-import tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.exceptions.PayloadLargerThanExpectedException;\n-import tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.exceptions.PayloadSmallerThanExpectedException;\n \n-class LengthPrefixedPayloadDecoder<T> {\n-  private static final Logger LOG = LogManager.getLogger();\n+class LengthPrefixedPayloadDecoder<T> implements RpcByteBufDecoder<T> {\n \n-  static final Bytes MAX_CHUNK_SIZE_PREFIX = ProtobufEncoder.encodeVarInt(MAX_CHUNK_SIZE);\n+  private static class VarIntDecoder extends AbstractByteBufDecoder<Long> {\n+    @Override\n+    protected Optional<Long> decodeOneImpl(ByteBuf in) {\n+      long length = ByteBufExtKt.readUvarint(in);\n+      if (length < 0) {\n+        // wait for more byte to read length field\n+        return Optional.empty();\n+      }\n+      return Optional.of(length);\n+    }\n+  }\n \n   private final RpcPayloadEncoder<T> payloadEncoder;\n   private final Compressor compressor;\n+  private Optional<Decompressor> decompressor = Optional.empty();\n+  private Optional<VarIntDecoder> varIntDecoder = Optional.empty();\n+  private boolean decoded = false;\n+  private boolean disposed = false;\n \n   public LengthPrefixedPayloadDecoder(\n       final RpcPayloadEncoder<T> payloadEncoder, final Compressor compressor) {\n     this.payloadEncoder = payloadEncoder;\n     this.compressor = compressor;\n   }\n \n-  public T decodePayload(final InputStream inputStream) throws RpcException {\n-    try {\n-      final int uncompressedPayloadSize = processLengthPrefixHeader(inputStream);\n-      return processPayload(inputStream, uncompressedPayloadSize);\n-    } catch (PayloadSmallerThanExpectedException e) {\n-      throw RpcException.PAYLOAD_TRUNCATED;\n-    } catch (PayloadLargerThanExpectedException e) {\n-      throw RpcException.EXTRA_DATA_APPENDED;\n-    } catch (CompressionException e) {\n-      LOG.debug(\"Failed to uncompress rpc payload\", e);\n-      throw RpcException.FAILED_TO_UNCOMPRESS_MESSAGE;\n-    } catch (IOException e) {\n-      LOG.error(\"Unable to decode rpc payload\", e);\n-      throw RpcException.SERVER_ERROR;\n+  @Override\n+  public Optional<T> decodeOneMessage(final ByteBuf in) throws RpcException {\n+    if (decoded || disposed) {\n+      throw new IllegalStateException(\"Trying to reuse disposable LengthPrefixedPayloadDecoder\");\n+    }\n+    if (decompressor.isEmpty()) {\n+      readLengthPrefixHeader(in)\n+          .ifPresent(len -> decompressor = Optional.of(compressor.createDecompressor(len)));\n+    }\n+    if (decompressor.isPresent()) {\n+      Optional<ByteBuf> ret = decompressor.get().decodeOneMessage(in);\n+      if (ret.isPresent()) {\n+        decompressor = Optional.empty();\n+        try {\n+          // making a copy here since the Bytes.wrapByteBuf(buf).slice(...)\n+          // would be broken after [in] buffer is released\n+          byte[] arr = new byte[ret.get().readableBytes()];\n+          ret.get().readBytes(arr);\n+          Bytes bytes = Bytes.wrap(arr);\n+          decoded = true;\n+          return Optional.of(payloadEncoder.decode(bytes));\n+        } finally {\n+          ret.get().release();\n+        }\n+      } else {\n+        return Optional.empty();\n+      }\n+    } else {\n+      return Optional.empty();\n     }\n   }\n \n-  /** Decode the length-prefix header, which contains the length of the uncompressed payload */\n-  private int processLengthPrefixHeader(final InputStream inputStream)\n-      throws RpcException, IOException {\n-    // Collect length prefix raw bytes\n-    final ByteArrayOutputStream headerBytes = new ByteArrayOutputStream();\n-\n-    boolean foundTerminatingCharacter = false;\n-    int nextByte;\n-    while ((nextByte = inputStream.read()) != END_OF_STREAM) {\n-      if (headerBytes.size() >= MAX_CHUNK_SIZE_PREFIX.size()) {\n-        // Any protobuf length requiring more bytes than this will also be bigger.\n-        throw RpcException.CHUNK_TOO_LONG;\n+  @Override\n+  public void complete() throws RpcException {\n+    if (disposed) {\n+      throw new IllegalStateException(\"Trying to reuse disposable LengthPrefixedPayloadDecoder\");\n+    }\n+    disposed = true;\n+    RpcException err = null;\n+    if (varIntDecoder.isPresent()) {\n+      try {\n+        varIntDecoder.ifPresent(AbstractByteBufDecoder::complete);\n+      } catch (Exception e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ3NTYzNg=="}, "originalCommit": {"oid": "9d789946533d88950e8a8c76db5202d65149ef39"}, "originalPosition": 121}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1NjgzNjkwOnYy", "diffSide": "RIGHT", "path": "networking/p2p/src/main/java/tech/pegasys/teku/networking/p2p/libp2p/rpc/RpcHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMTowNTowM1rOGmALLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxNDo0ODo1MVrOGnEJMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUwMTkzNQ==", "bodyText": "We're not guaranteed to receive this event right?  Don't we need to make sure complete is always called so that resources are definitely released in all cases?", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r442501935", "createdAt": "2020-06-18T21:05:03Z", "author": {"login": "mbaxter"}, "path": "networking/p2p/src/main/java/tech/pegasys/teku/networking/p2p/libp2p/rpc/RpcHandler.java", "diffHunk": "@@ -232,36 +188,23 @@ public void handlerRemoved(ChannelHandlerContext ctx) throws IllegalArgumentExce\n       close();\n     }\n \n-    private void close() {\n-      SafeFuture.of(p2pChannel.closeFuture())\n-          .whenComplete(\n-              (res, err) -> {\n-                if (err != null) {\n-                  LOG.warn(\"Failed to close p2pChannel.\", err);\n-                }\n-                closeOutputStream();\n-              })\n-          .reportExceptions();\n+    @Override\n+    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n+      if (evt instanceof RemoteWriteClosed) {\n+        rpcRequestHandler.complete(nodeId, rpcStream);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d789946533d88950e8a8c76db5202d65149ef39"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzYxNTUzOQ==", "bodyText": "Yes, very good point \ud83d\udc4d\nIndeed this user event is not guaranteed and we should make sure the complete() is called on stream EOF.\nI fixed this here: b25386b", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r443615539", "createdAt": "2020-06-22T14:48:51Z", "author": {"login": "Nashatyrev"}, "path": "networking/p2p/src/main/java/tech/pegasys/teku/networking/p2p/libp2p/rpc/RpcHandler.java", "diffHunk": "@@ -232,36 +188,23 @@ public void handlerRemoved(ChannelHandlerContext ctx) throws IllegalArgumentExce\n       close();\n     }\n \n-    private void close() {\n-      SafeFuture.of(p2pChannel.closeFuture())\n-          .whenComplete(\n-              (res, err) -> {\n-                if (err != null) {\n-                  LOG.warn(\"Failed to close p2pChannel.\", err);\n-                }\n-                closeOutputStream();\n-              })\n-          .reportExceptions();\n+    @Override\n+    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception {\n+      if (evt instanceof RemoteWriteClosed) {\n+        rpcRequestHandler.complete(nodeId, rpcStream);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUwMTkzNQ=="}, "originalCommit": {"oid": "9d789946533d88950e8a8c76db5202d65149ef39"}, "originalPosition": 140}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1Njg0MTMzOnYy", "diffSide": "RIGHT", "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/Eth2IncomingRequestHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMTowNjozM1rOGmAN9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMTowNjozM1rOGmAN9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUwMjY0NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  LOG.debug(\"RPC Request stream ends prematurely\", e);\n          \n          \n            \n                  LOG.debug(\"RPC Request stream closed prematurely\", e);", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r442502645", "createdAt": "2020-06-18T21:06:33Z", "author": {"login": "mbaxter"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/Eth2IncomingRequestHandler.java", "diffHunk": "@@ -59,19 +59,32 @@ public Eth2IncomingRequestHandler(\n   }\n \n   @Override\n-  public void processInput(\n-      final NodeId nodeId, final RpcStream rpcStream, final InputStream input) {\n-\n+  public void active(NodeId nodeId, RpcStream rpcStream) {\n     ensureRequestReceivedWithinTimeLimit(rpcStream);\n+  }\n \n-    final ResponseCallback<TResponse> callback = new RpcResponseCallback<>(rpcStream, rpcEncoder);\n+  @Override\n+  public void processData(final NodeId nodeId, final RpcStream rpcStream, final ByteBuf data) {\n     try {\n       Optional<Eth2Peer> peer = peerLookup.getConnectedPeer(nodeId);\n-      final TRequest request = requestDecoder.decodeRequest(input);\n-      handleRequest(peer, request, callback);\n+      requestDecoder\n+          .decodeRequest(data)\n+          .ifPresent(\n+              request ->\n+                  handleRequest(peer, request, new RpcResponseCallback<>(rpcStream, rpcEncoder)));\n     } catch (final RpcException e) {\n       requestHandled.set(true);\n-      callback.completeWithErrorResponse(e);\n+      new RpcResponseCallback<>(rpcStream, rpcEncoder).completeWithErrorResponse(e);\n+    }\n+  }\n+\n+  @Override\n+  public void complete(NodeId nodeId, RpcStream rpcStream) {\n+    try {\n+      requestDecoder.complete();\n+    } catch (RpcException e) {\n+      new RpcResponseCallback<>(rpcStream, rpcEncoder).completeWithErrorResponse(e);\n+      LOG.debug(\"RPC Request stream ends prematurely\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d789946533d88950e8a8c76db5202d65149ef39"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1Njg0NDc5OnYy", "diffSide": "RIGHT", "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/Eth2IncomingRequestHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMTowNzo0MlrOGmAQHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMTowNzo0MlrOGmAQHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUwMzE5OA==", "bodyText": "nice \ud83d\udcaf", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r442503198", "createdAt": "2020-06-18T21:07:42Z", "author": {"login": "mbaxter"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/Eth2IncomingRequestHandler.java", "diffHunk": "@@ -97,8 +110,9 @@ private void ensureRequestReceivedWithinTimeLimit(final RpcStream stream) {\n             (__) -> {\n               if (!requestHandled.get()) {\n                 LOG.debug(\n-                    \"Failed to receive incoming request data within {} sec. Close stream.\",\n-                    timeout.getSeconds());\n+                    \"Failed to receive incoming request data within {} sec for method {}. Close stream.\",\n+                    timeout.getSeconds(),\n+                    method);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d789946533d88950e8a8c76db5202d65149ef39"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1Njg3NTYwOnYy", "diffSide": "RIGHT", "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/RpcResponseDecoder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMToxODoyMVrOGmAjeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMzowMTo1MlrOGm_mOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUwODE1NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                firstByteListener.ifPresent(FirstByteReceivedListener::onFirstByteReceived);\n          \n          \n            \n            \n          \n          \n            \n                if (!data.isReadable()) {\n          \n          \n            \n                  return Optional.empty();\n          \n          \n            \n                }\n          \n          \n            \n                if (!data.isReadable()) {\n          \n          \n            \n                  return Optional.empty();\n          \n          \n            \n                }\n          \n          \n            \n                firstByteListener.ifPresent(FirstByteReceivedListener::onFirstByteReceived);", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r442508154", "createdAt": "2020-06-18T21:18:21Z", "author": {"login": "mbaxter"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/RpcResponseDecoder.java", "diffHunk": "@@ -31,62 +29,96 @@\n  * @param <T>\n  */\n public class RpcResponseDecoder<T> {\n-  private static final Logger LOG = LogManager.getLogger();\n-\n+  private Optional<Integer> respCodeMaybe = Optional.empty();\n+  private Optional<RpcByteBufDecoder<T>> payloadDecoder = Optional.empty();\n+  private Optional<RpcByteBufDecoder<String>> errorDecoder = Optional.empty();\n   private final Class<T> responseType;\n   private final RpcEncoding encoding;\n \n-  protected RpcResponseDecoder(final Class<T> responseType, final RpcEncoding encoding) {\n+  public RpcResponseDecoder(Class<T> responseType, RpcEncoding encoding) {\n     this.responseType = responseType;\n     this.encoding = encoding;\n   }\n \n-  public Optional<T> decodeNextResponse(final InputStream input) throws RpcException {\n-    return decodeNextResponse(input, Optional.empty());\n+  public List<T> decodeNextResponses(final ByteBuf data) throws RpcException {\n+    return decodeNextResponses(data, Optional.empty());\n   }\n \n-  public Optional<T> decodeNextResponse(\n-      final InputStream input, final FirstByteReceivedListener firstByteReceivedListener)\n+  public List<T> decodeNextResponses(\n+      final ByteBuf data, final FirstByteReceivedListener firstByteReceivedListener)\n       throws RpcException {\n-    return decodeNextResponse(input, Optional.of(firstByteReceivedListener));\n+    return decodeNextResponses(data, Optional.of(firstByteReceivedListener));\n   }\n \n-  private Optional<T> decodeNextResponse(\n-      final InputStream input, Optional<FirstByteReceivedListener> firstByteListener)\n+  private List<T> decodeNextResponses(\n+      final ByteBuf data, Optional<FirstByteReceivedListener> firstByteListener)\n       throws RpcException {\n-    try {\n-      final OptionalInt maybeStatus = getNextStatusCode(input);\n-      if (maybeStatus.isEmpty()) {\n-        // Empty status indicates we're finished reading responses\n-        return Optional.empty();\n-      }\n-      firstByteListener.ifPresent(FirstByteReceivedListener::onFirstByteReceived);\n-      final int status = maybeStatus.getAsInt();\n-      if (status == SUCCESS_RESPONSE_CODE) {\n-        final T response = encoding.decodePayload(input, responseType);\n-        return Optional.of(response);\n+    List<T> ret = new ArrayList<>();\n+    while (true) {\n+      Optional<T> responseMaybe = decodeNextResponse(data, firstByteListener);\n+      if (responseMaybe.isPresent()) {\n+        ret.add(responseMaybe.get());\n       } else {\n-        throw decodeError(input, status);\n+        break;\n       }\n-    } catch (IOException e) {\n-      LOG.error(\"Unexpected error while reading rpc responses\", e);\n-      throw RpcException.SERVER_ERROR;\n     }\n+\n+    return ret;\n   }\n \n-  private RpcException decodeError(final InputStream input, final int statusCode)\n+  private Optional<T> decodeNextResponse(\n+      final ByteBuf data, Optional<FirstByteReceivedListener> firstByteListener)\n       throws RpcException {\n-    final String errorMessage = encoding.decodePayload(input, String.class);\n-    return new RpcException(toByteExactUnsigned(statusCode), errorMessage);\n-  }\n+    firstByteListener.ifPresent(FirstByteReceivedListener::onFirstByteReceived);\n+\n+    if (!data.isReadable()) {\n+      return Optional.empty();\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d789946533d88950e8a8c76db5202d65149ef39"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzU0MTA1MQ==", "bodyText": "Not relevant any more", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r443541051", "createdAt": "2020-06-22T13:01:52Z", "author": {"login": "Nashatyrev"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/RpcResponseDecoder.java", "diffHunk": "@@ -31,62 +29,96 @@\n  * @param <T>\n  */\n public class RpcResponseDecoder<T> {\n-  private static final Logger LOG = LogManager.getLogger();\n-\n+  private Optional<Integer> respCodeMaybe = Optional.empty();\n+  private Optional<RpcByteBufDecoder<T>> payloadDecoder = Optional.empty();\n+  private Optional<RpcByteBufDecoder<String>> errorDecoder = Optional.empty();\n   private final Class<T> responseType;\n   private final RpcEncoding encoding;\n \n-  protected RpcResponseDecoder(final Class<T> responseType, final RpcEncoding encoding) {\n+  public RpcResponseDecoder(Class<T> responseType, RpcEncoding encoding) {\n     this.responseType = responseType;\n     this.encoding = encoding;\n   }\n \n-  public Optional<T> decodeNextResponse(final InputStream input) throws RpcException {\n-    return decodeNextResponse(input, Optional.empty());\n+  public List<T> decodeNextResponses(final ByteBuf data) throws RpcException {\n+    return decodeNextResponses(data, Optional.empty());\n   }\n \n-  public Optional<T> decodeNextResponse(\n-      final InputStream input, final FirstByteReceivedListener firstByteReceivedListener)\n+  public List<T> decodeNextResponses(\n+      final ByteBuf data, final FirstByteReceivedListener firstByteReceivedListener)\n       throws RpcException {\n-    return decodeNextResponse(input, Optional.of(firstByteReceivedListener));\n+    return decodeNextResponses(data, Optional.of(firstByteReceivedListener));\n   }\n \n-  private Optional<T> decodeNextResponse(\n-      final InputStream input, Optional<FirstByteReceivedListener> firstByteListener)\n+  private List<T> decodeNextResponses(\n+      final ByteBuf data, Optional<FirstByteReceivedListener> firstByteListener)\n       throws RpcException {\n-    try {\n-      final OptionalInt maybeStatus = getNextStatusCode(input);\n-      if (maybeStatus.isEmpty()) {\n-        // Empty status indicates we're finished reading responses\n-        return Optional.empty();\n-      }\n-      firstByteListener.ifPresent(FirstByteReceivedListener::onFirstByteReceived);\n-      final int status = maybeStatus.getAsInt();\n-      if (status == SUCCESS_RESPONSE_CODE) {\n-        final T response = encoding.decodePayload(input, responseType);\n-        return Optional.of(response);\n+    List<T> ret = new ArrayList<>();\n+    while (true) {\n+      Optional<T> responseMaybe = decodeNextResponse(data, firstByteListener);\n+      if (responseMaybe.isPresent()) {\n+        ret.add(responseMaybe.get());\n       } else {\n-        throw decodeError(input, status);\n+        break;\n       }\n-    } catch (IOException e) {\n-      LOG.error(\"Unexpected error while reading rpc responses\", e);\n-      throw RpcException.SERVER_ERROR;\n     }\n+\n+    return ret;\n   }\n \n-  private RpcException decodeError(final InputStream input, final int statusCode)\n+  private Optional<T> decodeNextResponse(\n+      final ByteBuf data, Optional<FirstByteReceivedListener> firstByteListener)\n       throws RpcException {\n-    final String errorMessage = encoding.decodePayload(input, String.class);\n-    return new RpcException(toByteExactUnsigned(statusCode), errorMessage);\n-  }\n+    firstByteListener.ifPresent(FirstByteReceivedListener::onFirstByteReceived);\n+\n+    if (!data.isReadable()) {\n+      return Optional.empty();\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUwODE1NA=="}, "originalCommit": {"oid": "9d789946533d88950e8a8c76db5202d65149ef39"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1Njg4OTQ1OnYy", "diffSide": "RIGHT", "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/AbstractByteBufDecoder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMToyMzowN1rOGmAr_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMTozMjowN1rOGm8wVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUxMDMzNQ==", "bodyText": "If all of the ByteBuf's are coming in on the netty thread, do we need this to be synchronized?", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r442510335", "createdAt": "2020-06-18T21:23:07Z", "author": {"login": "mbaxter"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/AbstractByteBufDecoder.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.networking.eth2.rpc.core.encodings;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.CompositeByteBuf;\n+import io.netty.buffer.Unpooled;\n+import java.util.Optional;\n+import tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.exceptions.PayloadSmallerThanExpectedException;\n+\n+/**\n+ * Abstract {@link ByteBufDecoder} implementation which handles unprocessed {@link ByteBuf}s\n+ *\n+ * <p>This class is a standalone analog of Netty {@link io.netty.handler.codec.ByteToMessageDecoder}\n+ */\n+public abstract class AbstractByteBufDecoder<TMessage>\n+    implements ByteBufDecoder<TMessage, RuntimeException> {\n+\n+  private CompositeByteBuf compositeByteBuf = Unpooled.compositeBuffer();\n+\n+  @Override\n+  public synchronized Optional<TMessage> decodeOneMessage(ByteBuf in) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d789946533d88950e8a8c76db5202d65149ef39"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ5NDQ4NA==", "bodyText": "Right. In our context there is no need in synchronization. Adjusted", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r443494484", "createdAt": "2020-06-22T11:32:07Z", "author": {"login": "Nashatyrev"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/AbstractByteBufDecoder.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.networking.eth2.rpc.core.encodings;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.CompositeByteBuf;\n+import io.netty.buffer.Unpooled;\n+import java.util.Optional;\n+import tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.exceptions.PayloadSmallerThanExpectedException;\n+\n+/**\n+ * Abstract {@link ByteBufDecoder} implementation which handles unprocessed {@link ByteBuf}s\n+ *\n+ * <p>This class is a standalone analog of Netty {@link io.netty.handler.codec.ByteToMessageDecoder}\n+ */\n+public abstract class AbstractByteBufDecoder<TMessage>\n+    implements ByteBufDecoder<TMessage, RuntimeException> {\n+\n+  private CompositeByteBuf compositeByteBuf = Unpooled.compositeBuffer();\n+\n+  @Override\n+  public synchronized Optional<TMessage> decodeOneMessage(ByteBuf in) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUxMDMzNQ=="}, "originalCommit": {"oid": "9d789946533d88950e8a8c76db5202d65149ef39"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1NzAyMTQzOnYy", "diffSide": "RIGHT", "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/compression/noop/NoopFrameDecoder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMjoxNjoyOVrOGmB_hA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMTozNDoxOVrOGm80Ew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUzMTcxNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public class NoopFrameDecoder extends AbstractByteBufDecoder<ByteBuf> {\n          \n          \n            \n            public class NoopDecoder extends AbstractByteBufDecoder<ByteBuf> {", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r442531716", "createdAt": "2020-06-18T22:16:29Z", "author": {"login": "mbaxter"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/compression/noop/NoopFrameDecoder.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.noop;\n+\n+import io.netty.buffer.ByteBuf;\n+import java.util.Optional;\n+import tech.pegasys.teku.networking.eth2.rpc.core.encodings.AbstractByteBufDecoder;\n+\n+public class NoopFrameDecoder extends AbstractByteBufDecoder<ByteBuf> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d789946533d88950e8a8c76db5202d65149ef39"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ5NTQ0Mw==", "bodyText": "Yep, nothing with 'frames' here \ud83d\udc4d", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r443495443", "createdAt": "2020-06-22T11:34:19Z", "author": {"login": "Nashatyrev"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/compression/noop/NoopFrameDecoder.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.noop;\n+\n+import io.netty.buffer.ByteBuf;\n+import java.util.Optional;\n+import tech.pegasys.teku.networking.eth2.rpc.core.encodings.AbstractByteBufDecoder;\n+\n+public class NoopFrameDecoder extends AbstractByteBufDecoder<ByteBuf> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUzMTcxNg=="}, "originalCommit": {"oid": "9d789946533d88950e8a8c76db5202d65149ef39"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1NzAyMzg5OnYy", "diffSide": "RIGHT", "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/compression/snappy/SnappyFrameEncoder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMjoxNzo0MVrOGmCBEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMjoxNzo0MVrOGmCBEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUzMjExNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * https://github.com/netty/netty/blob/4.1/codec/src/main/java/io/netty/handler/codec/compression/SnappyFramedEncoder.java\n          \n          \n            \n             * https://github.com/netty/netty/blob/4.1/codec/src/main/java/io/netty/handler/codec/compression/SnappyFrameEncoder.java", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r442532115", "createdAt": "2020-06-18T22:17:41Z", "author": {"login": "mbaxter"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/compression/snappy/SnappyFrameEncoder.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.snappy;\n+\n+import static tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.snappy.SnappyUtil.calculateChecksum;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.handler.codec.compression.Snappy;\n+import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.exceptions.CompressionException;\n+\n+/**\n+ * This class is mostly borrowed from the Netty implementation:\n+ * https://github.com/netty/netty/blob/4.1/codec/src/main/java/io/netty/handler/codec/compression/SnappyFramedEncoder.java", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d789946533d88950e8a8c76db5202d65149ef39"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1NzAzMjc3OnYy", "diffSide": "RIGHT", "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/compression/snappy/SnappyFrameEncoder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMjoyMjoxNVrOGmCGxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMTozNjoxMFrOGm83cA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUzMzU3NA==", "bodyText": "Never seen this \ud83e\udd14 What about just:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  for (; ; ) {\n          \n          \n            \n                  while(true) {", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r442533574", "createdAt": "2020-06-18T22:22:15Z", "author": {"login": "mbaxter"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/compression/snappy/SnappyFrameEncoder.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.snappy;\n+\n+import static tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.snappy.SnappyUtil.calculateChecksum;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.handler.codec.compression.Snappy;\n+import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.exceptions.CompressionException;\n+\n+/**\n+ * This class is mostly borrowed from the Netty implementation:\n+ * https://github.com/netty/netty/blob/4.1/codec/src/main/java/io/netty/handler/codec/compression/SnappyFramedEncoder.java\n+ *\n+ * <p>Compresses a {@link ByteBuf} using the Snappy framing format.\n+ *\n+ * <p>See <a href=\"https://github.com/google/snappy/blob/master/framing_format.txt\">Snappy framing\n+ * format</a>.\n+ */\n+public class SnappyFrameEncoder {\n+  /**\n+   * The minimum amount that we'll consider actually attempting to compress. This value is preamble\n+   * + the minimum length our Snappy service will compress (instead of just emitting a literal).\n+   */\n+  private static final int MIN_COMPRESSIBLE_LENGTH = 18;\n+\n+  /**\n+   * All streams should start with the \"Stream identifier\", containing chunk type 0xff, a length\n+   * field of 0x6, and 'sNaPpY' in ASCII.\n+   */\n+  private static final byte[] STREAM_START = {\n+    (byte) 0xff, 0x06, 0x00, 0x00, 0x73, 0x4e, 0x61, 0x50, 0x70, 0x59\n+  };\n+\n+  private final Snappy snappy = new Snappy();\n+  private boolean started;\n+\n+  public Bytes encode(Bytes in) {\n+    ByteBuf inBuf = Unpooled.wrappedBuffer(in.toArrayUnsafe());\n+    ByteBuf outBuf = Unpooled.buffer(in.size() / 2);\n+    try {\n+      encode(inBuf, outBuf);\n+      byte[] bytes = new byte[outBuf.readableBytes()];\n+      outBuf.readBytes(bytes);\n+      return Bytes.wrap(bytes);\n+    } finally {\n+      inBuf.release();\n+      outBuf.release();\n+    }\n+  }\n+\n+  public void encode(ByteBuf in, ByteBuf out) {\n+    if (!in.isReadable()) {\n+      return;\n+    }\n+\n+    if (!started) {\n+      started = true;\n+      out.writeBytes(STREAM_START);\n+    }\n+\n+    int dataLength = in.readableBytes();\n+    if (dataLength > MIN_COMPRESSIBLE_LENGTH) {\n+      for (; ; ) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d789946533d88950e8a8c76db5202d65149ef39"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ5NjMwNA==", "bodyText": "Fixed.\nThis is from original code and I suppose it's a C style", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r443496304", "createdAt": "2020-06-22T11:36:10Z", "author": {"login": "Nashatyrev"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/compression/snappy/SnappyFrameEncoder.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.snappy;\n+\n+import static tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.snappy.SnappyUtil.calculateChecksum;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import io.netty.handler.codec.compression.Snappy;\n+import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.teku.networking.eth2.rpc.core.encodings.compression.exceptions.CompressionException;\n+\n+/**\n+ * This class is mostly borrowed from the Netty implementation:\n+ * https://github.com/netty/netty/blob/4.1/codec/src/main/java/io/netty/handler/codec/compression/SnappyFramedEncoder.java\n+ *\n+ * <p>Compresses a {@link ByteBuf} using the Snappy framing format.\n+ *\n+ * <p>See <a href=\"https://github.com/google/snappy/blob/master/framing_format.txt\">Snappy framing\n+ * format</a>.\n+ */\n+public class SnappyFrameEncoder {\n+  /**\n+   * The minimum amount that we'll consider actually attempting to compress. This value is preamble\n+   * + the minimum length our Snappy service will compress (instead of just emitting a literal).\n+   */\n+  private static final int MIN_COMPRESSIBLE_LENGTH = 18;\n+\n+  /**\n+   * All streams should start with the \"Stream identifier\", containing chunk type 0xff, a length\n+   * field of 0x6, and 'sNaPpY' in ASCII.\n+   */\n+  private static final byte[] STREAM_START = {\n+    (byte) 0xff, 0x06, 0x00, 0x00, 0x73, 0x4e, 0x61, 0x50, 0x70, 0x59\n+  };\n+\n+  private final Snappy snappy = new Snappy();\n+  private boolean started;\n+\n+  public Bytes encode(Bytes in) {\n+    ByteBuf inBuf = Unpooled.wrappedBuffer(in.toArrayUnsafe());\n+    ByteBuf outBuf = Unpooled.buffer(in.size() / 2);\n+    try {\n+      encode(inBuf, outBuf);\n+      byte[] bytes = new byte[outBuf.readableBytes()];\n+      outBuf.readBytes(bytes);\n+      return Bytes.wrap(bytes);\n+    } finally {\n+      inBuf.release();\n+      outBuf.release();\n+    }\n+  }\n+\n+  public void encode(ByteBuf in, ByteBuf out) {\n+    if (!in.isReadable()) {\n+      return;\n+    }\n+\n+    if (!started) {\n+      started = true;\n+      out.writeBytes(STREAM_START);\n+    }\n+\n+    int dataLength = in.readableBytes();\n+    if (dataLength > MIN_COMPRESSIBLE_LENGTH) {\n+      for (; ; ) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUzMzU3NA=="}, "originalCommit": {"oid": "9d789946533d88950e8a8c76db5202d65149ef39"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1NzA1NjYwOnYy", "diffSide": "RIGHT", "path": "networking/eth2/src/test/java/tech/pegasys/teku/networking/eth2/rpc/Utils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMjozNDoyM1rOGmCV_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMTo1NDo1MVrOGm9aZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUzNzQ2OA==", "bodyText": "Nice test util - some more comments on what's happening here would be helpful :D", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r442537468", "createdAt": "2020-06-18T22:34:23Z", "author": {"login": "mbaxter"}, "path": "networking/eth2/src/test/java/tech/pegasys/teku/networking/eth2/rpc/Utils.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.networking.eth2.rpc;\n+\n+import static java.lang.Integer.max;\n+import static java.lang.Integer.min;\n+\n+import com.google.common.collect.Streams;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.apache.tuweni.bytes.Bytes;\n+\n+public class Utils {\n+\n+  public static List<List<ByteBuf>> generateTestSlices(Bytes... chunks) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d789946533d88950e8a8c76db5202d65149ef39"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzUwNTI1Mg==", "bodyText": "Done: 01d9e5e", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r443505252", "createdAt": "2020-06-22T11:54:51Z", "author": {"login": "Nashatyrev"}, "path": "networking/eth2/src/test/java/tech/pegasys/teku/networking/eth2/rpc/Utils.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.networking.eth2.rpc;\n+\n+import static java.lang.Integer.max;\n+import static java.lang.Integer.min;\n+\n+import com.google.common.collect.Streams;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.apache.tuweni.bytes.Bytes;\n+\n+public class Utils {\n+\n+  public static List<List<ByteBuf>> generateTestSlices(Bytes... chunks) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUzNzQ2OA=="}, "originalCommit": {"oid": "9d789946533d88950e8a8c76db5202d65149ef39"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1NzA1Nzk5OnYy", "diffSide": "RIGHT", "path": "networking/eth2/src/test/java/tech/pegasys/teku/networking/eth2/rpc/core/AbstractRequestHandlerTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMjozNToxMVrOGmCW1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMjozNToxMVrOGmCW1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUzNzY4Ng==", "bodyText": "Stray comments", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r442537686", "createdAt": "2020-06-18T22:35:11Z", "author": {"login": "mbaxter"}, "path": "networking/eth2/src/test/java/tech/pegasys/teku/networking/eth2/rpc/core/AbstractRequestHandlerTest.java", "diffHunk": "@@ -63,8 +55,8 @@\n   protected final Eth2Peer peer = mock(Eth2Peer.class);\n   protected T reqHandler;\n \n-  private Thread inputHandlerThread;\n-  private final AtomicBoolean inputHandlerDone = new AtomicBoolean(false);\n+  //  private Thread inputHandlerThread;\n+  //  private final AtomicBoolean inputHandlerDone = new AtomicBoolean(false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d789946533d88950e8a8c76db5202d65149ef39"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1NzA2MTE2OnYy", "diffSide": "RIGHT", "path": "networking/eth2/src/test/java/tech/pegasys/teku/networking/eth2/rpc/core/AbstractRequestHandlerTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMjozNjo0M1rOGmCY1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMjozNjo0M1rOGmCY1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUzODE5OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              protected void deliverBytes(final Bytes bytes, final int waitUntilBytesConsumed) {\n          \n          \n            \n              protected void deliverBytes(final Bytes bytes) {", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r442538199", "createdAt": "2020-06-18T22:36:43Z", "author": {"login": "mbaxter"}, "path": "networking/eth2/src/test/java/tech/pegasys/teku/networking/eth2/rpc/core/AbstractRequestHandlerTest.java", "diffHunk": "@@ -123,14 +90,7 @@ protected void deliverBytes(final Bytes bytes) throws IOException {\n     deliverBytes(bytes, bytes.size());\n   }\n \n-  protected void deliverBytes(final Bytes bytes, final int waitUntilBytesConsumed)\n-      throws IOException {\n-    checkArgument(\n-        waitUntilBytesConsumed <= bytes.size(), \"Cannot wait for more bytes than those supplied.\");\n-    inputStream.deliverBytes(bytes);\n-    final int maxRemainingBytes = bytes.size() - waitUntilBytesConsumed;\n-    Waiter.waitFor(\n-        () ->\n-            assertThat(inputStream.countUnconsumedBytes()).isLessThanOrEqualTo(maxRemainingBytes));\n+  protected void deliverBytes(final Bytes bytes, final int waitUntilBytesConsumed) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d789946533d88950e8a8c76db5202d65149ef39"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1NzA2ODI2OnYy", "diffSide": "RIGHT", "path": "networking/eth2/src/test/java/tech/pegasys/teku/networking/eth2/rpc/core/RpcRequestDecoderTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMjo0MDoyNVrOGmCdXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMjo0MDoyNVrOGmCdXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUzOTM1OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public void shouldParseSingleResponseReceivedInSinglePacket() throws Exception {\n          \n          \n            \n              public void shouldParseSingleResponse() throws Exception {", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r442539358", "createdAt": "2020-06-18T22:40:25Z", "author": {"login": "mbaxter"}, "path": "networking/eth2/src/test/java/tech/pegasys/teku/networking/eth2/rpc/core/RpcRequestDecoderTest.java", "diffHunk": "@@ -16,29 +16,54 @@\n import static org.assertj.core.api.Assertions.assertThat;\n import static org.assertj.core.api.Assertions.assertThatThrownBy;\n \n+import io.netty.buffer.ByteBuf;\n+import java.util.ArrayList;\n+import java.util.List;\n import org.apache.tuweni.bytes.Bytes;\n import org.junit.jupiter.api.Test;\n import tech.pegasys.teku.datastructures.networking.libp2p.rpc.BeaconBlocksByRootRequestMessage;\n \n class RpcRequestDecoderTest extends RpcDecoderTestBase {\n \n-  private final RpcRequestDecoder<BeaconBlocksByRootRequestMessage> decoder =\n-      METHOD.createRequestDecoder();\n-\n   @Test\n   public void shouldParseSingleResponseReceivedInSinglePacket() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d789946533d88950e8a8c76db5202d65149ef39"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1NzA3MzIyOnYy", "diffSide": "RIGHT", "path": "networking/eth2/src/test/java/tech/pegasys/teku/networking/eth2/rpc/Utils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMjo0Mjo1N1rOGmCgkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMjo0Mjo1N1rOGmCgkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU0MDE3Nw==", "bodyText": "(nit) This class should probably go in the testFixtures directory", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r442540177", "createdAt": "2020-06-18T22:42:57Z", "author": {"login": "mbaxter"}, "path": "networking/eth2/src/test/java/tech/pegasys/teku/networking/eth2/rpc/Utils.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.networking.eth2.rpc;\n+\n+import static java.lang.Integer.max;\n+import static java.lang.Integer.min;\n+\n+import com.google.common.collect.Streams;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.apache.tuweni.bytes.Bytes;\n+\n+public class Utils {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d789946533d88950e8a8c76db5202d65149ef39"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1NzA4NzE5OnYy", "diffSide": "RIGHT", "path": "networking/eth2/src/test/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/LengthPrefixedEncodingTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMjo1MDoxMVrOGmCpag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMjo1MDoxMVrOGmCpag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU0MjQ0Mg==", "bodyText": "(nit) Could probably improve readability by just having an instance variable for the status decoder that we use throughout:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                assertThatThrownBy(() -> encoding.createDecoder(StatusMessage.class).decodeOneMessage(input))\n          \n          \n            \n                assertThatThrownBy(() -> statusDecoder.decodeOneMessage(input))", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r442542442", "createdAt": "2020-06-18T22:50:11Z", "author": {"login": "mbaxter"}, "path": "networking/eth2/src/test/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/LengthPrefixedEncodingTest.java", "diffHunk": "@@ -41,65 +42,109 @@\n \n   @Test\n   public void decodePayload_shouldReturnErrorWhenLengthPrefixIsTooLong() {\n-    assertThatThrownBy(\n-            () ->\n-                encoding.decodePayload(\n-                    inputStream(\"0xAAAAAAAAAAAAAAAAAAAA80\"), StatusMessage.class))\n+    ByteBuf input = inputByteBuffer(\"0xAAAAAAAAAAAAAAAAAAAA80\");\n+    assertThatThrownBy(() -> encoding.createDecoder(StatusMessage.class).decodeOneMessage(input))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d789946533d88950e8a8c76db5202d65149ef39"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1NzA5MDc4OnYy", "diffSide": "RIGHT", "path": "networking/eth2/src/test/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/LengthPrefixedEncodingTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMjo1MjowNVrOGmCrpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMjoxMDoxMlrOGm93dQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU0MzAxNQ==", "bodyText": "Why not:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    .isInstanceOf(RpcException.class)\n          \n          \n            \n                    .hasMessageContaining(\"payload smaller\");\n          \n          \n            \n                    .isEqualTo(RpcException.PAYLOAD_TRUNCATED);\n          \n      \n    \n    \n  \n\n?", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r442543015", "createdAt": "2020-06-18T22:52:05Z", "author": {"login": "mbaxter"}, "path": "networking/eth2/src/test/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/LengthPrefixedEncodingTest.java", "diffHunk": "@@ -41,65 +42,109 @@\n \n   @Test\n   public void decodePayload_shouldReturnErrorWhenLengthPrefixIsTooLong() {\n-    assertThatThrownBy(\n-            () ->\n-                encoding.decodePayload(\n-                    inputStream(\"0xAAAAAAAAAAAAAAAAAAAA80\"), StatusMessage.class))\n+    ByteBuf input = inputByteBuffer(\"0xAAAAAAAAAAAAAAAAAAAA80\");\n+    assertThatThrownBy(() -> encoding.createDecoder(StatusMessage.class).decodeOneMessage(input))\n         .isEqualTo(RpcException.CHUNK_TOO_LONG);\n+    input.release();\n+    assertThat(input.refCnt()).isEqualTo(0);\n   }\n \n   @Test\n   public void decodePayload_shouldReturnErrorWhenNoPayloadIsPresent() {\n-    final InputStream invalidMessage = inputStream(ONE_BYTE_LENGTH_PREFIX);\n-    assertThatThrownBy(() -> encoding.decodePayload(invalidMessage, StatusMessage.class))\n-        .isEqualTo(RpcException.PAYLOAD_TRUNCATED);\n+    ByteBuf input = inputByteBuffer(ONE_BYTE_LENGTH_PREFIX);\n+    assertThatThrownBy(\n+            () -> {\n+              RpcByteBufDecoder<StatusMessage> decoder =\n+                  encoding.createDecoder(StatusMessage.class);\n+\n+              assertThat(decoder.decodeOneMessage(input)).isEmpty();\n+              decoder.complete();\n+            })\n+        .isInstanceOf(RpcException.class)\n+        .hasMessageContaining(\"payload smaller\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d789946533d88950e8a8c76db5202d65149ef39"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzUxMjY5Mw==", "bodyText": "Changed back for now.\nI just started replacing static exceptions instances but decided to make a separate PR for this later.\nJust filed an issue on that: #2190", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r443512693", "createdAt": "2020-06-22T12:10:12Z", "author": {"login": "Nashatyrev"}, "path": "networking/eth2/src/test/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/LengthPrefixedEncodingTest.java", "diffHunk": "@@ -41,65 +42,109 @@\n \n   @Test\n   public void decodePayload_shouldReturnErrorWhenLengthPrefixIsTooLong() {\n-    assertThatThrownBy(\n-            () ->\n-                encoding.decodePayload(\n-                    inputStream(\"0xAAAAAAAAAAAAAAAAAAAA80\"), StatusMessage.class))\n+    ByteBuf input = inputByteBuffer(\"0xAAAAAAAAAAAAAAAAAAAA80\");\n+    assertThatThrownBy(() -> encoding.createDecoder(StatusMessage.class).decodeOneMessage(input))\n         .isEqualTo(RpcException.CHUNK_TOO_LONG);\n+    input.release();\n+    assertThat(input.refCnt()).isEqualTo(0);\n   }\n \n   @Test\n   public void decodePayload_shouldReturnErrorWhenNoPayloadIsPresent() {\n-    final InputStream invalidMessage = inputStream(ONE_BYTE_LENGTH_PREFIX);\n-    assertThatThrownBy(() -> encoding.decodePayload(invalidMessage, StatusMessage.class))\n-        .isEqualTo(RpcException.PAYLOAD_TRUNCATED);\n+    ByteBuf input = inputByteBuffer(ONE_BYTE_LENGTH_PREFIX);\n+    assertThatThrownBy(\n+            () -> {\n+              RpcByteBufDecoder<StatusMessage> decoder =\n+                  encoding.createDecoder(StatusMessage.class);\n+\n+              assertThat(decoder.decodeOneMessage(input)).isEmpty();\n+              decoder.complete();\n+            })\n+        .isInstanceOf(RpcException.class)\n+        .hasMessageContaining(\"payload smaller\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU0MzAxNQ=="}, "originalCommit": {"oid": "9d789946533d88950e8a8c76db5202d65149ef39"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1NzA5MjAxOnYy", "diffSide": "RIGHT", "path": "networking/eth2/src/test/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/LengthPrefixedEncodingTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMjo1Mjo0MVrOGmCsZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMjo1Mjo0MVrOGmCsZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU0MzIwNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    .isInstanceOf(RpcException.class)\n          \n          \n            \n                    .hasMessageContaining(\"payload smaller\");\n          \n          \n            \n                    .isEqualTo(RpcException.PAYLOAD_TRUNCATED);", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r442543206", "createdAt": "2020-06-18T22:52:41Z", "author": {"login": "mbaxter"}, "path": "networking/eth2/src/test/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/LengthPrefixedEncodingTest.java", "diffHunk": "@@ -41,65 +42,109 @@\n \n   @Test\n   public void decodePayload_shouldReturnErrorWhenLengthPrefixIsTooLong() {\n-    assertThatThrownBy(\n-            () ->\n-                encoding.decodePayload(\n-                    inputStream(\"0xAAAAAAAAAAAAAAAAAAAA80\"), StatusMessage.class))\n+    ByteBuf input = inputByteBuffer(\"0xAAAAAAAAAAAAAAAAAAAA80\");\n+    assertThatThrownBy(() -> encoding.createDecoder(StatusMessage.class).decodeOneMessage(input))\n         .isEqualTo(RpcException.CHUNK_TOO_LONG);\n+    input.release();\n+    assertThat(input.refCnt()).isEqualTo(0);\n   }\n \n   @Test\n   public void decodePayload_shouldReturnErrorWhenNoPayloadIsPresent() {\n-    final InputStream invalidMessage = inputStream(ONE_BYTE_LENGTH_PREFIX);\n-    assertThatThrownBy(() -> encoding.decodePayload(invalidMessage, StatusMessage.class))\n-        .isEqualTo(RpcException.PAYLOAD_TRUNCATED);\n+    ByteBuf input = inputByteBuffer(ONE_BYTE_LENGTH_PREFIX);\n+    assertThatThrownBy(\n+            () -> {\n+              RpcByteBufDecoder<StatusMessage> decoder =\n+                  encoding.createDecoder(StatusMessage.class);\n+\n+              assertThat(decoder.decodeOneMessage(input)).isEmpty();\n+              decoder.complete();\n+            })\n+        .isInstanceOf(RpcException.class)\n+        .hasMessageContaining(\"payload smaller\");\n+    input.release();\n+    assertThat(input.refCnt()).isEqualTo(0);\n   }\n \n   @Test\n   public void decodePayload_shouldReturnErrorWhenPayloadTooShort() {\n     final Bytes correctMessage = createValidStatusMessage();\n     final int truncatedSize = correctMessage.size() - 5;\n-    final InputStream partialMessage = inputStream(correctMessage.slice(0, truncatedSize));\n-    assertThatThrownBy(() -> encoding.decodePayload(partialMessage, StatusMessage.class))\n-        .isEqualTo(RpcException.PAYLOAD_TRUNCATED);\n+    ByteBuf input = inputByteBuffer(correctMessage.slice(0, truncatedSize));\n+    assertThatThrownBy(\n+            () -> {\n+              RpcByteBufDecoder<StatusMessage> decoder =\n+                  encoding.createDecoder(StatusMessage.class);\n+              assertThat(decoder.decodeOneMessage(input)).isEmpty();\n+              decoder.complete();\n+            })\n+        .isInstanceOf(RpcException.class)\n+        .hasMessageContaining(\"payload smaller\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d789946533d88950e8a8c76db5202d65149ef39"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1NzExNTM3OnYy", "diffSide": "LEFT", "path": "networking/p2p/src/main/java/tech/pegasys/teku/networking/p2p/libp2p/gossip/GossipHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMzowNTozNVrOGmC7BA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMjoxMToyNFrOGm95qw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU0Njk0OA==", "bodyText": "What's wrong with the existing line?", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r442546948", "createdAt": "2020-06-18T23:05:35Z", "author": {"login": "mbaxter"}, "path": "networking/p2p/src/main/java/tech/pegasys/teku/networking/p2p/libp2p/gossip/GossipHandler.java", "diffHunk": "@@ -64,7 +64,9 @@ public GossipHandler(\n           GOSSIP_MAX_SIZE);\n       return VALIDATION_FAILED;\n     }\n-    Bytes bytes = Bytes.wrapByteBuf(message.getData()).copy();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d789946533d88950e8a8c76db5202d65149ef39"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzUxMzI1OQ==", "bodyText": "Mentioned the Bytes.wrapByteBuf bug above", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r443513259", "createdAt": "2020-06-22T12:11:24Z", "author": {"login": "Nashatyrev"}, "path": "networking/p2p/src/main/java/tech/pegasys/teku/networking/p2p/libp2p/gossip/GossipHandler.java", "diffHunk": "@@ -64,7 +64,9 @@ public GossipHandler(\n           GOSSIP_MAX_SIZE);\n       return VALIDATION_FAILED;\n     }\n-    Bytes bytes = Bytes.wrapByteBuf(message.getData()).copy();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU0Njk0OA=="}, "originalCommit": {"oid": "9d789946533d88950e8a8c76db5202d65149ef39"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1NzEyMTA3OnYy", "diffSide": "RIGHT", "path": "teku/src/test/java/tech/pegasys/teku/cli/BeaconNodeCommandTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMzowODo0OVrOGmC-pQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMjoxMjoyNlrOGm97xA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU0Nzg3Nw==", "bodyText": "What's this for?", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r442547877", "createdAt": "2020-06-18T23:08:49Z", "author": {"login": "mbaxter"}, "path": "teku/src/test/java/tech/pegasys/teku/cli/BeaconNodeCommandTest.java", "diffHunk": "@@ -203,7 +203,9 @@ private Path createConfigFile() throws IOException {\n     final URL configFile = this.getClass().getResource(\"/complete_config.yaml\");\n     final String updatedConfig =\n         Resources.toString(configFile, UTF_8)\n-            .replace(\"data-path: \\\".\\\"\", \"data-path: \\\"\" + dataPath.toString() + \"\\\"\");\n+            .replace(\n+                \"data-path: \\\".\\\"\",\n+                \"data-path: \\\"\" + dataPath.toString().replace(\"\\\\\", \"\\\\\\\\\") + \"\\\"\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d789946533d88950e8a8c76db5202d65149ef39"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzUxMzQxNA==", "bodyText": "This the test fix for Windows", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r443513414", "createdAt": "2020-06-22T12:11:45Z", "author": {"login": "Nashatyrev"}, "path": "teku/src/test/java/tech/pegasys/teku/cli/BeaconNodeCommandTest.java", "diffHunk": "@@ -203,7 +203,9 @@ private Path createConfigFile() throws IOException {\n     final URL configFile = this.getClass().getResource(\"/complete_config.yaml\");\n     final String updatedConfig =\n         Resources.toString(configFile, UTF_8)\n-            .replace(\"data-path: \\\".\\\"\", \"data-path: \\\"\" + dataPath.toString() + \"\\\"\");\n+            .replace(\n+                \"data-path: \\\".\\\"\",\n+                \"data-path: \\\"\" + dataPath.toString().replace(\"\\\\\", \"\\\\\\\\\") + \"\\\"\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU0Nzg3Nw=="}, "originalCommit": {"oid": "9d789946533d88950e8a8c76db5202d65149ef39"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzUxMzc5Ng==", "bodyText": "The \\ in win paths should be escaped in the YAML", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r443513796", "createdAt": "2020-06-22T12:12:26Z", "author": {"login": "Nashatyrev"}, "path": "teku/src/test/java/tech/pegasys/teku/cli/BeaconNodeCommandTest.java", "diffHunk": "@@ -203,7 +203,9 @@ private Path createConfigFile() throws IOException {\n     final URL configFile = this.getClass().getResource(\"/complete_config.yaml\");\n     final String updatedConfig =\n         Resources.toString(configFile, UTF_8)\n-            .replace(\"data-path: \\\".\\\"\", \"data-path: \\\"\" + dataPath.toString() + \"\\\"\");\n+            .replace(\n+                \"data-path: \\\".\\\"\",\n+                \"data-path: \\\"\" + dataPath.toString().replace(\"\\\\\", \"\\\\\\\\\") + \"\\\"\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjU0Nzg3Nw=="}, "originalCommit": {"oid": "9d789946533d88950e8a8c76db5202d65149ef39"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2NTE1OTQxOnYy", "diffSide": "RIGHT", "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/AbstractByteBufDecoder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxOTo0NTowNlrOGnOiwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxOTo0NTowNlrOGnOiwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzc4NTkyMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              protected abstract void throwDataTruncatedException(int dataLeft) throws TException;\n          \n          \n            \n              protected abstract void throwUnprocessedDataException(int dataLeft) throws TException;", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r443785920", "createdAt": "2020-06-22T19:45:06Z", "author": {"login": "mbaxter"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/AbstractByteBufDecoder.java", "diffHunk": "@@ -65,14 +64,15 @@\n   }\n \n   @Override\n-  public void complete() {\n+  public void complete() throws TException {\n     if (compositeByteBuf.isReadable()) {\n       compositeByteBuf.release();\n-      throw new PayloadSmallerThanExpectedException(\n-          \"Rpc stream complete, but unprocessed data left: \" + compositeByteBuf.readableBytes());\n+      throwDataTruncatedException(compositeByteBuf.readableBytes());\n     }\n   }\n \n+  protected abstract void throwDataTruncatedException(int dataLeft) throws TException;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e32f47d8c72dbda75549ea8bd232d528e98b0f3b"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2NTIyNzYzOnYy", "diffSide": "RIGHT", "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/compression/snappy/SnappyFrameDecoder.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQyMDowOToxMFrOGnPOlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QxMDo0MzowOVrOGnjm6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzc5NzE0MA==", "bodyText": "I think this should throw the opposite error - we think we're done processing the response but there's extra data in the pipeline, so the payload was larger than we expected:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                throw new PayloadSmallerThanExpectedException(\n          \n          \n            \n                throw new PayloadLargerThanExpectedException(", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r443797140", "createdAt": "2020-06-22T20:09:10Z", "author": {"login": "mbaxter"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/compression/snappy/SnappyFrameDecoder.java", "diffHunk": "@@ -194,14 +195,20 @@ public SnappyFrameDecoder(boolean validateChecksums) {\n           snappy.reset();\n           break;\n       }\n-    } catch (Exception e) {\n+    } catch (CompressionException e) {\n       corrupted = true;\n       throw e;\n     }\n     return Optional.ofNullable(ret);\n   }\n \n-  private static void checkByte(byte actual, byte expect) {\n+  @Override\n+  protected void throwDataTruncatedException(int dataLeft) throws CompressionException {\n+    throw new PayloadSmallerThanExpectedException(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e32f47d8c72dbda75549ea8bd232d528e98b0f3b"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDEzMTA1MQ==", "bodyText": "No, here it means that we were requesting the next message to be decoded, there was just a part of this message which was stored and then the stream was prematurely completed. So the last message appeared truncated", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r444131051", "createdAt": "2020-06-23T10:43:09Z", "author": {"login": "Nashatyrev"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/compression/snappy/SnappyFrameDecoder.java", "diffHunk": "@@ -194,14 +195,20 @@ public SnappyFrameDecoder(boolean validateChecksums) {\n           snappy.reset();\n           break;\n       }\n-    } catch (Exception e) {\n+    } catch (CompressionException e) {\n       corrupted = true;\n       throw e;\n     }\n     return Optional.ofNullable(ret);\n   }\n \n-  private static void checkByte(byte actual, byte expect) {\n+  @Override\n+  protected void throwDataTruncatedException(int dataLeft) throws CompressionException {\n+    throw new PayloadSmallerThanExpectedException(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzc5NzE0MA=="}, "originalCommit": {"oid": "e32f47d8c72dbda75549ea8bd232d528e98b0f3b"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2NTI0Mjc2OnYy", "diffSide": "RIGHT", "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/compression/snappy/SnappyFrameDecoder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQyMDoxNDoxOFrOGnPYKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQyMDoxNDoxOFrOGnPYKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzc5OTU5NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      \"Unexpected stream identifier contents. Mismatched snappy \" + \"protocol version?\");\n          \n          \n            \n                      \"Unexpected stream identifier contents. Mismatched snappy protocol version?\");", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r443799595", "createdAt": "2020-06-22T20:14:18Z", "author": {"login": "mbaxter"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/compression/snappy/SnappyFrameDecoder.java", "diffHunk": "@@ -194,14 +195,20 @@ public SnappyFrameDecoder(boolean validateChecksums) {\n           snappy.reset();\n           break;\n       }\n-    } catch (Exception e) {\n+    } catch (CompressionException e) {\n       corrupted = true;\n       throw e;\n     }\n     return Optional.ofNullable(ret);\n   }\n \n-  private static void checkByte(byte actual, byte expect) {\n+  @Override\n+  protected void throwDataTruncatedException(int dataLeft) throws CompressionException {\n+    throw new PayloadSmallerThanExpectedException(\n+        \"Snappy stream complete, but unprocessed data left: \" + dataLeft);\n+  }\n+\n+  private static void checkByte(byte actual, byte expect) throws CompressionException {\n     if (actual != expect) {\n       throw new CompressionException(\n           \"Unexpected stream identifier contents. Mismatched snappy \" + \"protocol version?\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e32f47d8c72dbda75549ea8bd232d528e98b0f3b"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2NTI1Njk2OnYy", "diffSide": "RIGHT", "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/compression/noop/NoopDecoder.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQyMDoxODozM1rOGnPg_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QxMDo0MzoyM1rOGnjnXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgwMTg1Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                throw new PayloadSmallerThanExpectedException(\n          \n          \n            \n                throw new PayloadLargerThanExpectedException(", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r443801853", "createdAt": "2020-06-22T20:18:33Z", "author": {"login": "mbaxter"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/compression/noop/NoopDecoder.java", "diffHunk": "@@ -31,4 +33,10 @@ public NoopDecoder(int expectedBytes) {\n     }\n     return Optional.of(in.readRetainedSlice(expectedBytes));\n   }\n+\n+  @Override\n+  protected void throwDataTruncatedException(int dataLeft) throws CompressionException {\n+    throw new PayloadSmallerThanExpectedException(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e32f47d8c72dbda75549ea8bd232d528e98b0f3b"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDEzMTE2NA==", "bodyText": "Commented above", "url": "https://github.com/ConsenSys/teku/pull/2005#discussion_r444131164", "createdAt": "2020-06-23T10:43:23Z", "author": {"login": "Nashatyrev"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/core/encodings/compression/noop/NoopDecoder.java", "diffHunk": "@@ -31,4 +33,10 @@ public NoopDecoder(int expectedBytes) {\n     }\n     return Optional.of(in.readRetainedSlice(expectedBytes));\n   }\n+\n+  @Override\n+  protected void throwDataTruncatedException(int dataLeft) throws CompressionException {\n+    throw new PayloadSmallerThanExpectedException(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzgwMTg1Mw=="}, "originalCommit": {"oid": "e32f47d8c72dbda75549ea8bd232d528e98b0f3b"}, "originalPosition": 19}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3686, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}