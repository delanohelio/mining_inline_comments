{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDgyOTA2OTM5", "number": 2772, "title": "Output validator performance", "bodyText": "PR Description\nOutput validator performance as:\n2020-09-16 14:43:50.134-04:00 | SlotEventsChannel-4 | INFO  | PerformanceTracker | \n ===== Attestation Performance Information ===== \n - Number of sent attestations: 64\n - Number of sent attestations included on chain: 64\n - %age of inclusion at: 100%\n - Inclusion distances: average: 1.000000, min: 1, max: 1\n - %age with correct target at: 100%\n - %age with correct head block root at: 100%\n2020-09-16 14:43:50.137-04:00 | SlotEventsChannel-4 | INFO  | PerformanceTracker | \n ===== Block Performance Information ===== \n - Number of sent blocks: 16\n - Number of sent blocks included on chain: 16\n - %age of inclusion at: 100%\n\nFixed Issue(s)\n\n\nFixes #2631\n\n Number of attestations made\n Number included on chain\n %age included on chain\n %age with correct target\n %age with correct head/block root\n min/average/max inclusion distances\n Number of blocks proposed\n Number included on chain\n Stretch goal: calculate and display the attestation effectiveness using the same algorithm as beaconcha.in (which accounts for skip slots in inclusion distance) (Decided to do this in another PR due to complexity)\n\nDocumentation\n\n I thought about documentation and added the documentation label to this PR if updates are required.", "createdAt": "2020-09-09T14:58:40Z", "url": "https://github.com/ConsenSys/teku/pull/2772", "merged": true, "mergeCommit": {"oid": "8477b1b28ea3feb0def92b1dad0e0035a169708e"}, "closed": true, "closedAt": "2020-10-01T22:51:49Z", "author": {"login": "cemozerr"}, "timelineItems": {"totalCount": 84, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdHL8cggH2gAyNDgyOTA2OTM5OmNlNDI4ZjMwOGQwYmZlODg4NjljZWQyZDExMjIwZjNhYjE4NGU3YWM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdOZHRugH2gAyNDgyOTA2OTM5OjY0YmFhOTJiYWM3MDA1NzM4NTM4ZTk4MjJhNzJiMTk3YjEwODYxNzY=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "ce428f308d0bfe88869ced2d11220f3ab184e7ac", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/ce428f308d0bfe88869ced2d11220f3ab184e7ac", "committedDate": "2020-09-09T13:09:41Z", "message": "Initialize PerformanceTracker"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f5ea00d94291d41739f7e74f6056f2b3c3fa32ce", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/f5ea00d94291d41739f7e74f6056f2b3c3fa32ce", "committedDate": "2020-09-09T14:54:51Z", "message": "Calculate attestation and block inclusion info"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8cf92562945167a36f418b176fdc82483a78ee44", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/8cf92562945167a36f418b176fdc82483a78ee44", "committedDate": "2020-09-09T14:56:05Z", "message": "Run spotless"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ce9457787da6385464615276bab43345cb1f5b72", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/ce9457787da6385464615276bab43345cb1f5b72", "committedDate": "2020-09-09T14:56:23Z", "message": "Fix error"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aa2e20ca15b4ab91b28d8b84d5ba89fda9bdfd96", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/aa2e20ca15b4ab91b28d8b84d5ba89fda9bdfd96", "committedDate": "2020-09-09T14:59:16Z", "message": "Merge branch 'master' into outputValidatorPerformance"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "38bdb3ee2d4e59a8c6e7a36e36c3b2631e2ee898", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/38bdb3ee2d4e59a8c6e7a36e36c3b2631e2ee898", "committedDate": "2020-09-15T19:06:32Z", "message": "Get attestations with their inclusion slot"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e4ad2a48af2810d249b2638b8f2a0b527e574e94", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/e4ad2a48af2810d249b2638b8f2a0b527e574e94", "committedDate": "2020-09-15T19:06:32Z", "message": "Get blocks/attesations in range"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "76f1dab9cf0b27e21099c85b08bda66202daa58d", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/76f1dab9cf0b27e21099c85b08bda66202daa58d", "committedDate": "2020-09-15T19:06:32Z", "message": "Add inclusion distances and correct target/headblock"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "774525df739dc5846b1c557c4a5598cbd1412061", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/774525df739dc5846b1c557c4a5598cbd1412061", "committedDate": "2020-09-15T19:06:32Z", "message": "Run spotless"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cb110434294cc6c4c011d2552aee5796d5b8d838", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/cb110434294cc6c4c011d2552aee5796d5b8d838", "committedDate": "2020-09-15T19:06:32Z", "message": "Run spotless"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eac591ca085f6efc0822c73d9438dcdc7e777f3f", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/eac591ca085f6efc0822c73d9438dcdc7e777f3f", "committedDate": "2020-09-15T19:06:54Z", "message": "Merge branch 'master' into outputValidatorPerformance"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ec4ec46e26d1d340d048f0d1905856da7e84b213", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/ec4ec46e26d1d340d048f0d1905856da7e84b213", "committedDate": "2020-09-15T20:21:13Z", "message": "Refactor PerformanceTracker"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8fd0b3178c8eb882513b06dfee8c191829ebcf1b", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/8fd0b3178c8eb882513b06dfee8c191829ebcf1b", "committedDate": "2020-09-15T20:21:13Z", "message": "Run spotless"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3b75f1fcf599c160da60f085a69224361c614a8e", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/3b75f1fcf599c160da60f085a69224361c614a8e", "committedDate": "2020-09-15T20:21:27Z", "message": "Merge branch 'master' into outputValidatorPerformance"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "810017e2dba9482ac78f78de50825ea93b03cad3", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/810017e2dba9482ac78f78de50825ea93b03cad3", "committedDate": "2020-09-15T20:57:09Z", "message": "Switch sorted map to navigable map"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bd392b2ab39ff0fbd3b98d4f1bb9e97b29daefaf", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/bd392b2ab39ff0fbd3b98d4f1bb9e97b29daefaf", "committedDate": "2020-09-15T21:07:02Z", "message": "Do not use deprecated method"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a76c52e517b7338c244d10916735c77505bf3929", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/a76c52e517b7338c244d10916735c77505bf3929", "committedDate": "2020-09-16T18:34:58Z", "message": "Integrate and debug PerformanceTracker"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "55c770faa461247c011e9d3ef1d8183c32efc801", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/55c770faa461247c011e9d3ef1d8183c32efc801", "committedDate": "2020-09-16T18:47:44Z", "message": "Log via STATUS_LOG"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "081b6ff6faf7838350de0533bcd4360b0735192a", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/081b6ff6faf7838350de0533bcd4360b0735192a", "committedDate": "2020-09-16T21:40:52Z", "message": "Dependency inject STATUS_LOG"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "489a60b4964337f0643952136cd89d41e4bc3688", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/489a60b4964337f0643952136cd89d41e4bc3688", "committedDate": "2020-09-17T17:19:05Z", "message": "Run spotless"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dd881365e7e5b041d9919f4dac482cca2bcb98a3", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/dd881365e7e5b041d9919f4dac482cca2bcb98a3", "committedDate": "2020-09-17T21:30:23Z", "message": "Add tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6757f44ed86f3b69f828986b913d0acd2858885f", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/6757f44ed86f3b69f828986b913d0acd2858885f", "committedDate": "2020-09-18T16:39:28Z", "message": "Add head/target root tests and CLI toggling"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "26d2542b116362f9c0fa51bb37f1a5b9f2003fc5", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/26d2542b116362f9c0fa51bb37f1a5b9f2003fc5", "committedDate": "2020-09-18T16:40:08Z", "message": "Run spotless"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "571237ec510ef5fde681126ef7fa1d54034951a5", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/571237ec510ef5fde681126ef7fa1d54034951a5", "committedDate": "2020-09-18T16:44:40Z", "message": "Merge branch 'master' into outputValidatorPerformance\n\n# Conflicts:\n#\tutil/src/main/java/tech/pegasys/teku/util/config/GlobalConfigurationBuilder.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "56e725d377dfb1f567f81f236d88df55a3bc6d07", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/56e725d377dfb1f567f81f236d88df55a3bc6d07", "committedDate": "2020-09-18T17:10:26Z", "message": "Clear redundant objects"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "580646b2e41d7f8ba8de60f9102223286f63061b", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/580646b2e41d7f8ba8de60f9102223286f63061b", "committedDate": "2020-09-18T18:55:50Z", "message": "Abstract PerformanceTracker interface"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3c06ccb17849c19b6e9d46ae8554cff819f92e82", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/3c06ccb17849c19b6e9d46ae8554cff819f92e82", "committedDate": "2020-09-18T18:59:09Z", "message": "Run spotless"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ebdb7f74c09edf4e3193ddc0ffb4d4b18c549701", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/ebdb7f74c09edf4e3193ddc0ffb4d4b18c549701", "committedDate": "2020-09-18T20:16:25Z", "message": "Do not print attestation performance information until ready"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c5ac8cef7cf05f5ac3a032e65fe0f418b1e89df7", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/c5ac8cef7cf05f5ac3a032e65fe0f418b1e89df7", "committedDate": "2020-09-18T20:17:29Z", "message": "Run spotless"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9fd35664816acb36fff728e0a4a3a34755722a0d", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/9fd35664816acb36fff728e0a4a3a34755722a0d", "committedDate": "2020-09-18T21:20:17Z", "message": "Fix tests and make cosmetic change to CLI"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "52b97835a9d52e6773bd5ee42154e504079e42d0", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/52b97835a9d52e6773bd5ee42154e504079e42d0", "committedDate": "2020-09-18T21:20:48Z", "message": "Run spotless"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7f18b8a6c31cb04699d8a400fe56cebaeb06e9fe", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/7f18b8a6c31cb04699d8a400fe56cebaeb06e9fe", "committedDate": "2020-09-21T16:10:56Z", "message": "Merge branch 'master' into outputValidatorPerformance\n\n# Conflicts:\n#\tteku/src/main/java/tech/pegasys/teku/cli/BeaconNodeCommand.java\n#\tteku/src/main/java/tech/pegasys/teku/cli/options/ValidatorOptions.java\n#\tteku/src/main/java/tech/pegasys/teku/cli/subcommand/ValidatorClientCommand.java\n#\tutil/src/main/java/tech/pegasys/teku/util/config/GlobalConfiguration.java\n#\tutil/src/main/java/tech/pegasys/teku/util/config/GlobalConfigurationBuilder.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e89b4ab26d2ee042e785db8f01b30742ce99f9bf", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/e89b4ab26d2ee042e785db8f01b30742ce99f9bf", "committedDate": "2020-09-21T16:13:38Z", "message": "Fix merge errors"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d73ffe1813d544bb3c419336d4a7a7a568e4fe8d", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/d73ffe1813d544bb3c419336d4a7a7a568e4fe8d", "committedDate": "2020-09-21T16:21:50Z", "message": "Run spotless"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8c2bafcd94ffbffcf7567f67be8000a18ac81490", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/8c2bafcd94ffbffcf7567f67be8000a18ac81490", "committedDate": "2020-09-21T16:27:50Z", "message": "Change variable declaration order"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyOTUyMDc1", "url": "https://github.com/ConsenSys/teku/pull/2772#pullrequestreview-492952075", "createdAt": "2020-09-21T20:23:04Z", "commit": {"oid": "8c2bafcd94ffbffcf7567f67be8000a18ac81490"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQyMDoyMzowNVrOHVhFbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQyMDoyMzowNVrOHVhFbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMyNDIwNA==", "bodyText": "nit, i'd probably use currentSlot", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r492324204", "createdAt": "2020-09-21T20:23:05Z", "author": {"login": "rolfyone"}, "path": "storage/src/testFixtures/java/tech/pegasys/teku/storage/client/ChainUpdater.java", "diffHunk": "@@ -99,6 +99,16 @@ public SignedBlockAndState advanceChain(final long slot) {\n     return advanceChain(UInt64.valueOf(slot));\n   }\n \n+  public SignedBlockAndState advanceChainUntil(final long slot) {\n+    long currSlot = chainBuilder.getLatestSlot().longValue();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c2bafcd94ffbffcf7567f67be8000a18ac81490"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyOTU0Mzk2", "url": "https://github.com/ConsenSys/teku/pull/2772#pullrequestreview-492954396", "createdAt": "2020-09-21T20:26:33Z", "commit": {"oid": "8c2bafcd94ffbffcf7567f67be8000a18ac81490"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQyMDoyNjozM1rOHVhMWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQyMDoyNjozM1rOHVhMWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMyNTk3Ng==", "bodyText": "much better off using\nfallbackValue = \"true\",\narity = \"0..1\"\n\nso that --validator-performance-tracking-enabled works to turn it on, and accepts =false to explicitly turn off. lots of examples in p2pOptions, loggingOptions...", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r492325976", "createdAt": "2020-09-21T20:26:33Z", "author": {"login": "rolfyone"}, "path": "teku/src/main/java/tech/pegasys/teku/cli/options/ValidatorOptions.java", "diffHunk": "@@ -81,6 +81,17 @@\n       arity = \"1\")\n   private Bytes32 graffiti;\n \n+  @Option(\n+      names = {\"--validator-performance-tracking-enabled\"},\n+      paramLabel = \"<BOOLEAN>\",\n+      description = \"Enable validator performance tracking and logging\",\n+      arity = \"1\")\n+  private boolean validatorPerformanceTrackingEnabled = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c2bafcd94ffbffcf7567f67be8000a18ac81490"}, "originalPosition": 9}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyOTYxMDI5", "url": "https://github.com/ConsenSys/teku/pull/2772#pullrequestreview-492961029", "createdAt": "2020-09-21T20:36:37Z", "commit": {"oid": "8c2bafcd94ffbffcf7567f67be8000a18ac81490"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQyMDozNjozN1rOHVhgcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQyMDozNjozN1rOHVhgcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMzMTEyMQ==", "bodyText": "is this just an expensive modulo operation?\nif (slot.mod(SLOTS_PER_EPOCH).isGreaterThan(ZERO)) {\nreturn;\n}", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r492331121", "createdAt": "2020-09-21T20:36:37Z", "author": {"login": "rolfyone"}, "path": "validator/coordinator/src/main/java/tech/pegasys/teku/validator/coordinator/performance/RecentChainDataPerformanceTracker.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.coordinator.performance;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_epoch_at_slot;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_start_slot_at_epoch;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root_at_slot;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.IntSummaryStatistics;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.operations.Attestation;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.infrastructure.async.SafeFuture;\n+import tech.pegasys.teku.infrastructure.logging.StatusLogger;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.storage.client.RecentChainData;\n+\n+public class RecentChainDataPerformanceTracker implements PerformanceTracker {\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<SignedBeaconBlock>> sentBlocksByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<Attestation>> sentAttestationsByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  static final UInt64 BLOCK_PERFORMANCE_EVALUATION_INTERVAL = UInt64.valueOf(2); // epochs\n+\n+  private final RecentChainData recentChainData;\n+  private final StatusLogger statusLogger;\n+  private Optional<UInt64> nodeStartEpoch = Optional.empty();\n+\n+  public RecentChainDataPerformanceTracker(\n+      RecentChainData recentChainData, StatusLogger statusLogger) {\n+    this.recentChainData = recentChainData;\n+    this.statusLogger = statusLogger;\n+  }\n+\n+  @Override\n+  public void start(UInt64 nodeStartSlot) {\n+    this.nodeStartEpoch = Optional.of(compute_epoch_at_slot(nodeStartSlot));\n+  }\n+\n+  @Override\n+  public void onSlot(UInt64 slot) {\n+    if (nodeStartEpoch.isEmpty()) {\n+      return;\n+    }\n+\n+    UInt64 currentEpoch = compute_epoch_at_slot(slot);\n+    if (!compute_start_slot_at_epoch(currentEpoch).equals(slot)) {\n+      return;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c2bafcd94ffbffcf7567f67be8000a18ac81490"}, "originalPosition": 79}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyOTY0Mzgx", "url": "https://github.com/ConsenSys/teku/pull/2772#pullrequestreview-492964381", "createdAt": "2020-09-21T20:41:47Z", "commit": {"oid": "8c2bafcd94ffbffcf7567f67be8000a18ac81490"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQyMDo0MTo0N1rOHVhqoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQyMDo0MTo0N1rOHVhqoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMzMzcyOQ==", "bodyText": "nit: using long interface, the arithmetic can be currentEpoch.minus(2)", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r492333729", "createdAt": "2020-09-21T20:41:47Z", "author": {"login": "rolfyone"}, "path": "validator/coordinator/src/main/java/tech/pegasys/teku/validator/coordinator/performance/RecentChainDataPerformanceTracker.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.coordinator.performance;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_epoch_at_slot;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_start_slot_at_epoch;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root_at_slot;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.IntSummaryStatistics;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.operations.Attestation;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.infrastructure.async.SafeFuture;\n+import tech.pegasys.teku.infrastructure.logging.StatusLogger;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.storage.client.RecentChainData;\n+\n+public class RecentChainDataPerformanceTracker implements PerformanceTracker {\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<SignedBeaconBlock>> sentBlocksByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<Attestation>> sentAttestationsByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  static final UInt64 BLOCK_PERFORMANCE_EVALUATION_INTERVAL = UInt64.valueOf(2); // epochs\n+\n+  private final RecentChainData recentChainData;\n+  private final StatusLogger statusLogger;\n+  private Optional<UInt64> nodeStartEpoch = Optional.empty();\n+\n+  public RecentChainDataPerformanceTracker(\n+      RecentChainData recentChainData, StatusLogger statusLogger) {\n+    this.recentChainData = recentChainData;\n+    this.statusLogger = statusLogger;\n+  }\n+\n+  @Override\n+  public void start(UInt64 nodeStartSlot) {\n+    this.nodeStartEpoch = Optional.of(compute_epoch_at_slot(nodeStartSlot));\n+  }\n+\n+  @Override\n+  public void onSlot(UInt64 slot) {\n+    if (nodeStartEpoch.isEmpty()) {\n+      return;\n+    }\n+\n+    UInt64 currentEpoch = compute_epoch_at_slot(slot);\n+    if (!compute_start_slot_at_epoch(currentEpoch).equals(slot)) {\n+      return;\n+    }\n+\n+    // Output attestation performance information for current epoch - 2 since attestations can be\n+    // included in both the epoch they were produced in or in the one following.\n+    if (currentEpoch.isGreaterThanOrEqualTo(nodeStartEpoch.get().plus(UInt64.valueOf(2)))) {\n+      statusLogger.performance(\n+          getAttestationPerformanceForEpoch(currentEpoch, currentEpoch.minus(UInt64.valueOf(2)))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c2bafcd94ffbffcf7567f67be8000a18ac81490"}, "originalPosition": 85}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyOTc0MDU3", "url": "https://github.com/ConsenSys/teku/pull/2772#pullrequestreview-492974057", "createdAt": "2020-09-21T20:56:33Z", "commit": {"oid": "8c2bafcd94ffbffcf7567f67be8000a18ac81490"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQyMDo1NjozM1rOHViIGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQyMDo1NjozM1rOHViIGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM0MTI3Mw==", "bodyText": "looks like a function with taking 2 integers to get the attestation you need. might be worth a private function to clean up this portion so you don't get lost in setup...", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r492341273", "createdAt": "2020-09-21T20:56:33Z", "author": {"login": "rolfyone"}, "path": "validator/coordinator/src/test/java/tech/pegasys/teku/validator/coordinator/performance/PerformanceTrackerTest.java", "diffHunk": "@@ -0,0 +1,258 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.coordinator.performance;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_start_slot_at_epoch;\n+import static tech.pegasys.teku.validator.coordinator.performance.RecentChainDataPerformanceTracker.BLOCK_PERFORMANCE_EVALUATION_INTERVAL;\n+\n+import com.google.common.eventbus.EventBus;\n+import java.util.List;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import tech.pegasys.teku.bls.BLSKeyGenerator;\n+import tech.pegasys.teku.bls.BLSKeyPair;\n+import tech.pegasys.teku.core.AttestationGenerator;\n+import tech.pegasys.teku.core.ChainBuilder;\n+import tech.pegasys.teku.datastructures.blocks.SignedBlockAndState;\n+import tech.pegasys.teku.datastructures.operations.Attestation;\n+import tech.pegasys.teku.datastructures.util.DataStructureUtil;\n+import tech.pegasys.teku.infrastructure.logging.StatusLogger;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.storage.client.ChainUpdater;\n+import tech.pegasys.teku.storage.client.MemoryOnlyRecentChainData;\n+import tech.pegasys.teku.storage.client.RecentChainData;\n+import tech.pegasys.teku.util.config.Constants;\n+\n+public class PerformanceTrackerTest {\n+\n+  private final DataStructureUtil dataStructureUtil = new DataStructureUtil();\n+  private final StatusLogger log = mock(StatusLogger.class);\n+  private final RecentChainData recentChainData =\n+      MemoryOnlyRecentChainData.create(mock(EventBus.class));\n+  private RecentChainDataPerformanceTracker performanceTracker =\n+      new RecentChainDataPerformanceTracker(recentChainData, log);\n+  private static final List<BLSKeyPair> VALIDATOR_KEYS = BLSKeyGenerator.generateKeyPairs(64);\n+  private final ChainBuilder chainBuilder = ChainBuilder.create(VALIDATOR_KEYS);\n+  private final ChainUpdater chainUpdater = new ChainUpdater(recentChainData, chainBuilder);\n+\n+  @BeforeAll\n+  static void setUp() {\n+    Constants.SLOTS_PER_EPOCH = 4;\n+  }\n+\n+  @BeforeEach\n+  void beforeEach() {\n+    chainUpdater.initializeGenesis();\n+    performanceTracker.start(UInt64.ZERO);\n+  }\n+\n+  @Test\n+  void shouldDisplayPerfectBlockInclusion() {\n+    chainUpdater.updateBestBlock(chainUpdater.advanceChainUntil(10));\n+    performanceTracker.saveSentBlock(chainUpdater.chainBuilder.getBlockAtSlot(1));\n+    performanceTracker.saveSentBlock(chainUpdater.chainBuilder.getBlockAtSlot(2));\n+    performanceTracker.onSlot(compute_start_slot_at_epoch(BLOCK_PERFORMANCE_EVALUATION_INTERVAL));\n+    BlockPerformance expectedBlockPerformance = new BlockPerformance(2, 2);\n+    verify(log).performance(expectedBlockPerformance.toString());\n+  }\n+\n+  @Test\n+  void shouldDisplayOneMissedBlock() {\n+    chainUpdater.updateBestBlock(chainUpdater.advanceChainUntil(10));\n+    performanceTracker.saveSentBlock(chainUpdater.chainBuilder.getBlockAtSlot(1));\n+    performanceTracker.saveSentBlock(chainUpdater.chainBuilder.getBlockAtSlot(2));\n+    performanceTracker.saveSentBlock(dataStructureUtil.randomSignedBeaconBlock(3));\n+    performanceTracker.onSlot(compute_start_slot_at_epoch(BLOCK_PERFORMANCE_EVALUATION_INTERVAL));\n+    BlockPerformance expectedBlockPerformance = new BlockPerformance(2, 3);\n+    verify(log).performance(expectedBlockPerformance.toString());\n+  }\n+\n+  @Test\n+  void shouldDisplayPerfectAttestationInclusion() {\n+    chainUpdater.updateBestBlock(chainUpdater.advanceChainUntil(1));\n+\n+    ChainBuilder.BlockOptions block1Options = ChainBuilder.BlockOptions.create();\n+    Attestation attestation1 =\n+        chainBuilder\n+            .streamValidAttestationsForBlockAtSlot(2)\n+            .filter(\n+                a ->\n+                    a.getData()\n+                        .getBeacon_block_root()\n+                        .equals(chainBuilder.getBlockAtSlot(1).getRoot()))\n+            .findFirst()\n+            .get();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c2bafcd94ffbffcf7567f67be8000a18ac81490"}, "originalPosition": 99}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyODA3NzM4", "url": "https://github.com/ConsenSys/teku/pull/2772#pullrequestreview-492807738", "createdAt": "2020-09-21T16:56:02Z", "commit": {"oid": "8c2bafcd94ffbffcf7567f67be8000a18ac81490"}, "state": "COMMENTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNjo1NjowMlrOHVaE_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQyMTo1NTo0NlrOHVjxJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjIwOTQwNA==", "bodyText": "Would be nice to get a couple of unit tests for this new method.", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r492209404", "createdAt": "2020-09-21T16:56:02Z", "author": {"login": "mbaxter"}, "path": "infrastructure/unsigned/src/main/java/tech/pegasys/teku/infrastructure/unsigned/UInt64.java", "diffHunk": "@@ -113,6 +113,15 @@ public UInt64 increment() {\n     return plus(1);\n   }\n \n+  /**\n+   * Decrement this value by one and return the result.\n+   *\n+   * @return The result of decrementing this value by 1.\n+   */\n+  public UInt64 decrement() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c2bafcd94ffbffcf7567f67be8000a18ac81490"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjIxMDIwNg==", "bodyText": "Do we need this log message?", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r492210206", "createdAt": "2020-09-21T16:57:25Z", "author": {"login": "mbaxter"}, "path": "services/beaconchain/src/main/java/tech/pegasys/teku/services/beaconchain/BeaconChainController.java", "diffHunk": "@@ -268,11 +272,24 @@ public void initAll() {\n     initSlotProcessor();\n     initMetrics();\n     initSyncStateTracker();\n+    initPerformanceTracker();\n     initValidatorApiHandler();\n     initRestAPI();\n     initOperationsReOrgManager();\n   }\n \n+  private void initPerformanceTracker() {\n+    LOG.debug(\"BeaconChainController.initPerformanceTracker()\");\n+    if (config.isValidatorPerformanceTrackingEnabled()) {\n+      performanceTracker = new RecentChainDataPerformanceTracker(recentChainData, STATUS_LOG);\n+      eventChannels.subscribe(SlotEventsChannel.class, performanceTracker);\n+    } else {\n+      performanceTracker = new NoOpPerformanceTracker();\n+      LOG.info(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c2bafcd94ffbffcf7567f67be8000a18ac81490"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMwNDI1OA==", "bodyText": "Do we not want to track aggregate attestations?", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r492304258", "createdAt": "2020-09-21T19:44:32Z", "author": {"login": "mbaxter"}, "path": "validator/coordinator/src/main/java/tech/pegasys/teku/validator/coordinator/ValidatorApiHandler.java", "diffHunk": "@@ -351,12 +356,13 @@ public void sendAggregateAndProof(final SignedAggregateAndProof aggregateAndProo\n     attestationManager\n         .onAttestation(ValidateableAttestation.fromSignedAggregate(aggregateAndProof))\n         .finish(\n-            result ->\n-                result.ifInvalid(\n-                    reason ->\n-                        VALIDATOR_LOGGER.producedInvalidAggregate(\n-                            aggregateAndProof.getMessage().getAggregate().getData().getSlot(),\n-                            reason)),\n+            result -> {\n+              result.ifInvalid(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c2bafcd94ffbffcf7567f67be8000a18ac81490"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMwNTI0OQ==", "bodyText": "Should we track the result here, so we can get stats on invalid attestations produced?", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r492305249", "createdAt": "2020-09-21T19:46:18Z", "author": {"login": "mbaxter"}, "path": "validator/coordinator/src/main/java/tech/pegasys/teku/validator/coordinator/ValidatorApiHandler.java", "diffHunk": "@@ -324,6 +328,7 @@ public void sendSignedAttestation(\n                           expectedValidatorIndex,\n                           reason));\n               dutyMetrics.onAttestationPublished(attestation.getData().getSlot());\n+              performanceTracker.saveSentAttestation(attestation);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c2bafcd94ffbffcf7567f67be8000a18ac81490"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMwODM4Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        + \" - Number of sent attestations: %d\\n\"\n          \n          \n            \n                        + \" - Number of attestations included on chain: %d\\n\"\n          \n          \n            \n                        + \" - %%age of inclusion at: %d%%\\n\"\n          \n          \n            \n                        + \" - Inclusion distances: average: %f, min: %d, max: %d\\n\"\n          \n          \n            \n                        + \" - %%age with correct target at: %d%%\\n\"\n          \n          \n            \n                        + \" - %%age with correct head block root at: %d%%\",\n          \n          \n            \n                        + \" - Number of sent attestations: %d\\n\"\n          \n          \n            \n                        + \" - Number of sent attestations included on chain: %d\\n\"\n          \n          \n            \n                        + \" - Percentage of sent attestations included on chain: %d%%\\n\"\n          \n          \n            \n                        + \" - Inclusion distances: average: %f, min: %d, max: %d\\n\"\n          \n          \n            \n                        + \" - Percentage of sent attestations with correct target at: %d%%\\n\"\n          \n          \n            \n                        + \" - Percentage of sent attestations with correct head block root at: %d%%\",", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r492308386", "createdAt": "2020-09-21T19:52:22Z", "author": {"login": "mbaxter"}, "path": "validator/coordinator/src/main/java/tech/pegasys/teku/validator/coordinator/performance/AttestationPerformance.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.coordinator.performance;\n+\n+import static tech.pegasys.teku.validator.coordinator.performance.RecentChainDataPerformanceTracker.getPercentage;\n+\n+import com.google.common.base.Objects;\n+\n+public class AttestationPerformance {\n+  private final int numberOfSentAttestations;\n+  private final int numberOfIncludedAttestations;\n+  private final int inclusionDistanceMax;\n+  private final int inclusionDistanceMin;\n+  private final double inclusionDistanceAverage;\n+  private final double correctTargetCount;\n+  private final double correctHeadBlockCount;\n+\n+  public AttestationPerformance(\n+      int numberOfSentAttestations,\n+      int numberOfIncludedAttestations,\n+      int inclusionDistanceMax,\n+      int inclusionDistanceMin,\n+      double inclusionDistanceAverage,\n+      double correctTargetCount,\n+      double correctHeadBlockCount) {\n+    this.numberOfSentAttestations = numberOfSentAttestations;\n+    this.numberOfIncludedAttestations = numberOfIncludedAttestations;\n+    this.inclusionDistanceMax = inclusionDistanceMax;\n+    this.inclusionDistanceMin = inclusionDistanceMin;\n+    this.inclusionDistanceAverage = inclusionDistanceAverage;\n+    this.correctTargetCount = correctTargetCount;\n+    this.correctHeadBlockCount = correctHeadBlockCount;\n+  }\n+\n+  public static AttestationPerformance empty() {\n+    return new AttestationPerformance(0, 0, 0, 0, 0, 0, 0);\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (this == o) return true;\n+    if (!(o instanceof AttestationPerformance)) return false;\n+    AttestationPerformance that = (AttestationPerformance) o;\n+    return numberOfSentAttestations == that.numberOfSentAttestations\n+        && numberOfIncludedAttestations == that.numberOfIncludedAttestations\n+        && inclusionDistanceMax == that.inclusionDistanceMax\n+        && inclusionDistanceMin == that.inclusionDistanceMin\n+        && Double.compare(that.inclusionDistanceAverage, inclusionDistanceAverage) == 0\n+        && Double.compare(that.correctTargetCount, correctTargetCount) == 0\n+        && Double.compare(that.correctHeadBlockCount, correctHeadBlockCount) == 0;\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return Objects.hashCode(\n+        numberOfSentAttestations,\n+        numberOfIncludedAttestations,\n+        inclusionDistanceMax,\n+        inclusionDistanceMin,\n+        inclusionDistanceAverage,\n+        correctTargetCount,\n+        correctHeadBlockCount);\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return String.format(\n+        \"\\n ===== Attestation Performance Information ===== \\n\"\n+            + \" - Number of sent attestations: %d\\n\"\n+            + \" - Number of attestations included on chain: %d\\n\"\n+            + \" - %%age of inclusion at: %d%%\\n\"\n+            + \" - Inclusion distances: average: %f, min: %d, max: %d\\n\"\n+            + \" - %%age with correct target at: %d%%\\n\"\n+            + \" - %%age with correct head block root at: %d%%\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c2bafcd94ffbffcf7567f67be8000a18ac81490"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMwOTIzMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        + \" - Number of sent blocks: %d\\n\"\n          \n          \n            \n                        + \" - Number of blocks included on chain: %d\\n\"\n          \n          \n            \n                        + \" - %%age of inclusion at: %d%%\",\n          \n          \n            \n                        + \" - Number of sent blocks: %d\\n\"\n          \n          \n            \n                        + \" - Number of sent blocks included on chain: %d\\n\"\n          \n          \n            \n                        + \" - Percentage of sent blocks included on chain: %d%%\",", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r492309232", "createdAt": "2020-09-21T19:54:11Z", "author": {"login": "mbaxter"}, "path": "validator/coordinator/src/main/java/tech/pegasys/teku/validator/coordinator/performance/BlockPerformance.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.coordinator.performance;\n+\n+import static tech.pegasys.teku.validator.coordinator.performance.RecentChainDataPerformanceTracker.getPercentage;\n+\n+import com.google.common.base.Objects;\n+\n+public class BlockPerformance {\n+  private final int numberOfIncludedBlocks;\n+  private final int numberOfSentBlocks;\n+\n+  public BlockPerformance(int numberOfIncludedBlocks, int numberOfSentBlocks) {\n+    this.numberOfIncludedBlocks = numberOfIncludedBlocks;\n+    this.numberOfSentBlocks = numberOfSentBlocks;\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (this == o) return true;\n+    if (!(o instanceof BlockPerformance)) return false;\n+    BlockPerformance that = (BlockPerformance) o;\n+    return numberOfIncludedBlocks == that.numberOfIncludedBlocks\n+        && numberOfSentBlocks == that.numberOfSentBlocks;\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return Objects.hashCode(numberOfIncludedBlocks, numberOfSentBlocks);\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return String.format(\n+        \"\\n ===== Block Performance Information ===== \\n\"\n+            + \" - Number of sent blocks: %d\\n\"\n+            + \" - Number of blocks included on chain: %d\\n\"\n+            + \" - %%age of inclusion at: %d%%\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c2bafcd94ffbffcf7567f67be8000a18ac81490"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMwOTc1NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public class RecentChainDataPerformanceTracker implements PerformanceTracker {\n          \n          \n            \n            public class DefaultPerformanceTracker implements PerformanceTracker {", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r492309755", "createdAt": "2020-09-21T19:55:10Z", "author": {"login": "mbaxter"}, "path": "validator/coordinator/src/main/java/tech/pegasys/teku/validator/coordinator/performance/RecentChainDataPerformanceTracker.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.coordinator.performance;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_epoch_at_slot;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_start_slot_at_epoch;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root_at_slot;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.IntSummaryStatistics;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.operations.Attestation;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.infrastructure.async.SafeFuture;\n+import tech.pegasys.teku.infrastructure.logging.StatusLogger;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.storage.client.RecentChainData;\n+\n+public class RecentChainDataPerformanceTracker implements PerformanceTracker {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c2bafcd94ffbffcf7567f67be8000a18ac81490"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMxMDMwOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (currentEpoch.isGreaterThanOrEqualTo(nodeStartEpoch.get().plus(UInt64.valueOf(2)))) {\n          \n          \n            \n                if (currentEpoch.isGreaterThanOrEqualTo(nodeStartEpoch.get().plus(2))) {", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r492310308", "createdAt": "2020-09-21T19:56:14Z", "author": {"login": "mbaxter"}, "path": "validator/coordinator/src/main/java/tech/pegasys/teku/validator/coordinator/performance/RecentChainDataPerformanceTracker.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.coordinator.performance;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_epoch_at_slot;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_start_slot_at_epoch;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root_at_slot;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.IntSummaryStatistics;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.operations.Attestation;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.infrastructure.async.SafeFuture;\n+import tech.pegasys.teku.infrastructure.logging.StatusLogger;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.storage.client.RecentChainData;\n+\n+public class RecentChainDataPerformanceTracker implements PerformanceTracker {\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<SignedBeaconBlock>> sentBlocksByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<Attestation>> sentAttestationsByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  static final UInt64 BLOCK_PERFORMANCE_EVALUATION_INTERVAL = UInt64.valueOf(2); // epochs\n+\n+  private final RecentChainData recentChainData;\n+  private final StatusLogger statusLogger;\n+  private Optional<UInt64> nodeStartEpoch = Optional.empty();\n+\n+  public RecentChainDataPerformanceTracker(\n+      RecentChainData recentChainData, StatusLogger statusLogger) {\n+    this.recentChainData = recentChainData;\n+    this.statusLogger = statusLogger;\n+  }\n+\n+  @Override\n+  public void start(UInt64 nodeStartSlot) {\n+    this.nodeStartEpoch = Optional.of(compute_epoch_at_slot(nodeStartSlot));\n+  }\n+\n+  @Override\n+  public void onSlot(UInt64 slot) {\n+    if (nodeStartEpoch.isEmpty()) {\n+      return;\n+    }\n+\n+    UInt64 currentEpoch = compute_epoch_at_slot(slot);\n+    if (!compute_start_slot_at_epoch(currentEpoch).equals(slot)) {\n+      return;\n+    }\n+\n+    // Output attestation performance information for current epoch - 2 since attestations can be\n+    // included in both the epoch they were produced in or in the one following.\n+    if (currentEpoch.isGreaterThanOrEqualTo(nodeStartEpoch.get().plus(UInt64.valueOf(2)))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c2bafcd94ffbffcf7567f67be8000a18ac81490"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMxNjEzMQ==", "bodyText": "This looks like an expensive check.  What about calling recentChainData.getBlockRootBySlot(block.getSlot()) for each block and checking for a match?", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r492316131", "createdAt": "2020-09-21T20:07:18Z", "author": {"login": "mbaxter"}, "path": "validator/coordinator/src/main/java/tech/pegasys/teku/validator/coordinator/performance/RecentChainDataPerformanceTracker.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.coordinator.performance;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_epoch_at_slot;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_start_slot_at_epoch;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root_at_slot;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.IntSummaryStatistics;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.operations.Attestation;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.infrastructure.async.SafeFuture;\n+import tech.pegasys.teku.infrastructure.logging.StatusLogger;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.storage.client.RecentChainData;\n+\n+public class RecentChainDataPerformanceTracker implements PerformanceTracker {\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<SignedBeaconBlock>> sentBlocksByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<Attestation>> sentAttestationsByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  static final UInt64 BLOCK_PERFORMANCE_EVALUATION_INTERVAL = UInt64.valueOf(2); // epochs\n+\n+  private final RecentChainData recentChainData;\n+  private final StatusLogger statusLogger;\n+  private Optional<UInt64> nodeStartEpoch = Optional.empty();\n+\n+  public RecentChainDataPerformanceTracker(\n+      RecentChainData recentChainData, StatusLogger statusLogger) {\n+    this.recentChainData = recentChainData;\n+    this.statusLogger = statusLogger;\n+  }\n+\n+  @Override\n+  public void start(UInt64 nodeStartSlot) {\n+    this.nodeStartEpoch = Optional.of(compute_epoch_at_slot(nodeStartSlot));\n+  }\n+\n+  @Override\n+  public void onSlot(UInt64 slot) {\n+    if (nodeStartEpoch.isEmpty()) {\n+      return;\n+    }\n+\n+    UInt64 currentEpoch = compute_epoch_at_slot(slot);\n+    if (!compute_start_slot_at_epoch(currentEpoch).equals(slot)) {\n+      return;\n+    }\n+\n+    // Output attestation performance information for current epoch - 2 since attestations can be\n+    // included in both the epoch they were produced in or in the one following.\n+    if (currentEpoch.isGreaterThanOrEqualTo(nodeStartEpoch.get().plus(UInt64.valueOf(2)))) {\n+      statusLogger.performance(\n+          getAttestationPerformanceForEpoch(currentEpoch, currentEpoch.minus(UInt64.valueOf(2)))\n+              .toString());\n+    }\n+\n+    // Output block performance information for the past BLOCK_PERFORMANCE_INTERVAL epochs\n+    if (currentEpoch.isGreaterThanOrEqualTo(BLOCK_PERFORMANCE_EVALUATION_INTERVAL)) {\n+      if (currentEpoch.mod(BLOCK_PERFORMANCE_EVALUATION_INTERVAL).equals(UInt64.ZERO)) {\n+        statusLogger.performance(\n+            getBlockPerformanceForEpochs(\n+                    currentEpoch.minus(BLOCK_PERFORMANCE_EVALUATION_INTERVAL), currentEpoch)\n+                .toString());\n+      }\n+    }\n+\n+    UInt64 epoch =\n+        currentEpoch\n+            .minus(BLOCK_PERFORMANCE_EVALUATION_INTERVAL)\n+            .min(currentEpoch.minus(UInt64.valueOf(2)));\n+    clearReduntantSavedSentObjects(epoch);\n+  }\n+\n+  private BlockPerformance getBlockPerformanceForEpochs(\n+      UInt64 startEpochInclusive, UInt64 endEpochExclusive) {\n+    Set<BeaconBlock> blockInEpoch = getBlocksInEpochs(startEpochInclusive, endEpochExclusive);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c2bafcd94ffbffcf7567f67be8000a18ac81490"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMyMTYwMQ==", "bodyText": "Might be good to have the 2-epoch value saved as a constant since it's used throughout\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                UInt64 analysisRangeEndEpoch = analyzedEpoch.plus(UInt64.valueOf(2));\n          \n          \n            \n                UInt64 analysisRangeEndEpoch = analyzedEpoch.plus(ATTESTATION_INCLUSION_RANGE);", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r492321601", "createdAt": "2020-09-21T20:17:49Z", "author": {"login": "mbaxter"}, "path": "validator/coordinator/src/main/java/tech/pegasys/teku/validator/coordinator/performance/RecentChainDataPerformanceTracker.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.coordinator.performance;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_epoch_at_slot;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_start_slot_at_epoch;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root_at_slot;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.IntSummaryStatistics;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.operations.Attestation;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.infrastructure.async.SafeFuture;\n+import tech.pegasys.teku.infrastructure.logging.StatusLogger;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.storage.client.RecentChainData;\n+\n+public class RecentChainDataPerformanceTracker implements PerformanceTracker {\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<SignedBeaconBlock>> sentBlocksByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<Attestation>> sentAttestationsByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  static final UInt64 BLOCK_PERFORMANCE_EVALUATION_INTERVAL = UInt64.valueOf(2); // epochs\n+\n+  private final RecentChainData recentChainData;\n+  private final StatusLogger statusLogger;\n+  private Optional<UInt64> nodeStartEpoch = Optional.empty();\n+\n+  public RecentChainDataPerformanceTracker(\n+      RecentChainData recentChainData, StatusLogger statusLogger) {\n+    this.recentChainData = recentChainData;\n+    this.statusLogger = statusLogger;\n+  }\n+\n+  @Override\n+  public void start(UInt64 nodeStartSlot) {\n+    this.nodeStartEpoch = Optional.of(compute_epoch_at_slot(nodeStartSlot));\n+  }\n+\n+  @Override\n+  public void onSlot(UInt64 slot) {\n+    if (nodeStartEpoch.isEmpty()) {\n+      return;\n+    }\n+\n+    UInt64 currentEpoch = compute_epoch_at_slot(slot);\n+    if (!compute_start_slot_at_epoch(currentEpoch).equals(slot)) {\n+      return;\n+    }\n+\n+    // Output attestation performance information for current epoch - 2 since attestations can be\n+    // included in both the epoch they were produced in or in the one following.\n+    if (currentEpoch.isGreaterThanOrEqualTo(nodeStartEpoch.get().plus(UInt64.valueOf(2)))) {\n+      statusLogger.performance(\n+          getAttestationPerformanceForEpoch(currentEpoch, currentEpoch.minus(UInt64.valueOf(2)))\n+              .toString());\n+    }\n+\n+    // Output block performance information for the past BLOCK_PERFORMANCE_INTERVAL epochs\n+    if (currentEpoch.isGreaterThanOrEqualTo(BLOCK_PERFORMANCE_EVALUATION_INTERVAL)) {\n+      if (currentEpoch.mod(BLOCK_PERFORMANCE_EVALUATION_INTERVAL).equals(UInt64.ZERO)) {\n+        statusLogger.performance(\n+            getBlockPerformanceForEpochs(\n+                    currentEpoch.minus(BLOCK_PERFORMANCE_EVALUATION_INTERVAL), currentEpoch)\n+                .toString());\n+      }\n+    }\n+\n+    UInt64 epoch =\n+        currentEpoch\n+            .minus(BLOCK_PERFORMANCE_EVALUATION_INTERVAL)\n+            .min(currentEpoch.minus(UInt64.valueOf(2)));\n+    clearReduntantSavedSentObjects(epoch);\n+  }\n+\n+  private BlockPerformance getBlockPerformanceForEpochs(\n+      UInt64 startEpochInclusive, UInt64 endEpochExclusive) {\n+    Set<BeaconBlock> blockInEpoch = getBlocksInEpochs(startEpochInclusive, endEpochExclusive);\n+    List<SignedBeaconBlock> sentBlocks =\n+        sentBlocksByEpoch.subMap(startEpochInclusive, true, endEpochExclusive, false).values()\n+            .stream()\n+            .flatMap(Collection::stream)\n+            .collect(Collectors.toList());\n+    long numberOfIncludedBlocks =\n+        sentBlocks.stream()\n+            .map(SignedBeaconBlock::getMessage)\n+            .filter(blockInEpoch::contains)\n+            .count();\n+\n+    return new BlockPerformance((int) numberOfIncludedBlocks, sentBlocks.size());\n+  }\n+\n+  private AttestationPerformance getAttestationPerformanceForEpoch(\n+      UInt64 currentEpoch, UInt64 analyzedEpoch) {\n+    checkArgument(\n+        analyzedEpoch.isLessThanOrEqualTo(currentEpoch.minus(UInt64.valueOf(2))),\n+        \"Epoch to analyze attestation performance must be at least 2 epochs less than the current epoch\");\n+    // Attestations can be included in either the epoch they were produced in or in\n+    // the following epoch. Thus, the most recent epoch for which we can evaluate attestation\n+    // performance is current epoch - 2.\n+    UInt64 analysisRangeEndEpoch = analyzedEpoch.plus(UInt64.valueOf(2));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c2bafcd94ffbffcf7567f67be8000a18ac81490"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM2MTgwMQ==", "bodyText": "We already have a utility recentChainData.getBlockRootBySlot - we could add a similar one for checking the root at an epoch boundary:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  if (attestationTargetRoot.equals(get_block_root(state, analyzedEpoch))) {\n          \n          \n            \n                  final Optional<Bytes32> rootAtEpoch = recentChainData.getBlockRootByEpoch(state, analyzedEpoch);\n          \n          \n            \n                  if (rootAtEpoch.map(r -> r.equals(attestationTargetRoot).orElse(false)) {\n          \n      \n    \n    \n  \n\nAlthough, maybe we could run into an issue with data getting pruned out from under us?", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r492361801", "createdAt": "2020-09-21T21:40:25Z", "author": {"login": "mbaxter"}, "path": "validator/coordinator/src/main/java/tech/pegasys/teku/validator/coordinator/performance/RecentChainDataPerformanceTracker.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.coordinator.performance;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_epoch_at_slot;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_start_slot_at_epoch;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root_at_slot;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.IntSummaryStatistics;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.operations.Attestation;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.infrastructure.async.SafeFuture;\n+import tech.pegasys.teku.infrastructure.logging.StatusLogger;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.storage.client.RecentChainData;\n+\n+public class RecentChainDataPerformanceTracker implements PerformanceTracker {\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<SignedBeaconBlock>> sentBlocksByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<Attestation>> sentAttestationsByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  static final UInt64 BLOCK_PERFORMANCE_EVALUATION_INTERVAL = UInt64.valueOf(2); // epochs\n+\n+  private final RecentChainData recentChainData;\n+  private final StatusLogger statusLogger;\n+  private Optional<UInt64> nodeStartEpoch = Optional.empty();\n+\n+  public RecentChainDataPerformanceTracker(\n+      RecentChainData recentChainData, StatusLogger statusLogger) {\n+    this.recentChainData = recentChainData;\n+    this.statusLogger = statusLogger;\n+  }\n+\n+  @Override\n+  public void start(UInt64 nodeStartSlot) {\n+    this.nodeStartEpoch = Optional.of(compute_epoch_at_slot(nodeStartSlot));\n+  }\n+\n+  @Override\n+  public void onSlot(UInt64 slot) {\n+    if (nodeStartEpoch.isEmpty()) {\n+      return;\n+    }\n+\n+    UInt64 currentEpoch = compute_epoch_at_slot(slot);\n+    if (!compute_start_slot_at_epoch(currentEpoch).equals(slot)) {\n+      return;\n+    }\n+\n+    // Output attestation performance information for current epoch - 2 since attestations can be\n+    // included in both the epoch they were produced in or in the one following.\n+    if (currentEpoch.isGreaterThanOrEqualTo(nodeStartEpoch.get().plus(UInt64.valueOf(2)))) {\n+      statusLogger.performance(\n+          getAttestationPerformanceForEpoch(currentEpoch, currentEpoch.minus(UInt64.valueOf(2)))\n+              .toString());\n+    }\n+\n+    // Output block performance information for the past BLOCK_PERFORMANCE_INTERVAL epochs\n+    if (currentEpoch.isGreaterThanOrEqualTo(BLOCK_PERFORMANCE_EVALUATION_INTERVAL)) {\n+      if (currentEpoch.mod(BLOCK_PERFORMANCE_EVALUATION_INTERVAL).equals(UInt64.ZERO)) {\n+        statusLogger.performance(\n+            getBlockPerformanceForEpochs(\n+                    currentEpoch.minus(BLOCK_PERFORMANCE_EVALUATION_INTERVAL), currentEpoch)\n+                .toString());\n+      }\n+    }\n+\n+    UInt64 epoch =\n+        currentEpoch\n+            .minus(BLOCK_PERFORMANCE_EVALUATION_INTERVAL)\n+            .min(currentEpoch.minus(UInt64.valueOf(2)));\n+    clearReduntantSavedSentObjects(epoch);\n+  }\n+\n+  private BlockPerformance getBlockPerformanceForEpochs(\n+      UInt64 startEpochInclusive, UInt64 endEpochExclusive) {\n+    Set<BeaconBlock> blockInEpoch = getBlocksInEpochs(startEpochInclusive, endEpochExclusive);\n+    List<SignedBeaconBlock> sentBlocks =\n+        sentBlocksByEpoch.subMap(startEpochInclusive, true, endEpochExclusive, false).values()\n+            .stream()\n+            .flatMap(Collection::stream)\n+            .collect(Collectors.toList());\n+    long numberOfIncludedBlocks =\n+        sentBlocks.stream()\n+            .map(SignedBeaconBlock::getMessage)\n+            .filter(blockInEpoch::contains)\n+            .count();\n+\n+    return new BlockPerformance((int) numberOfIncludedBlocks, sentBlocks.size());\n+  }\n+\n+  private AttestationPerformance getAttestationPerformanceForEpoch(\n+      UInt64 currentEpoch, UInt64 analyzedEpoch) {\n+    checkArgument(\n+        analyzedEpoch.isLessThanOrEqualTo(currentEpoch.minus(UInt64.valueOf(2))),\n+        \"Epoch to analyze attestation performance must be at least 2 epochs less than the current epoch\");\n+    // Attestations can be included in either the epoch they were produced in or in\n+    // the following epoch. Thus, the most recent epoch for which we can evaluate attestation\n+    // performance is current epoch - 2.\n+    UInt64 analysisRangeEndEpoch = analyzedEpoch.plus(UInt64.valueOf(2));\n+\n+    // Get included attestations for the given epochs in a map from slot to attestations\n+    // included in block.\n+    Map<UInt64, List<Attestation>> attestations =\n+        getAttestationsIncludedInEpochs(analyzedEpoch, analysisRangeEndEpoch);\n+\n+    // Get sent attestations in range\n+    Set<Attestation> sentAttestations =\n+        sentAttestationsByEpoch.getOrDefault(analyzedEpoch, new HashSet<>());\n+    UInt64 analyzedEpochStartSlot = compute_start_slot_at_epoch(analyzedEpoch);\n+    UInt64 rangeEndSlot = compute_start_slot_at_epoch(analysisRangeEndEpoch);\n+    BeaconState state = recentChainData.getBestState().orElseThrow();\n+\n+    int correctTargetCount = 0;\n+    int correctHeadBlockCount = 0;\n+    List<Integer> inclusionDistances = new ArrayList<>();\n+\n+    for (Attestation sentAttestation : sentAttestations) {\n+      // Check if the sent attestation is included in any block in the appropriate range.\n+      // Appropriate range being: [ attestation_production_epoch, attestation_production_epoch + 1 ]\n+      UInt64 attestationSlot = sentAttestation.getData().getSlot();\n+      for (UInt64 currSlot = analyzedEpochStartSlot;\n+          currSlot.isLessThan(rangeEndSlot);\n+          currSlot = currSlot.increment()) {\n+        if (attestations.containsKey(currSlot)) {\n+          if (checkIfAttestationIsIncludedInList(sentAttestation, attestations.get(currSlot))) {\n+            inclusionDistances.add(currSlot.minus(attestationSlot).intValue());\n+          }\n+        }\n+      }\n+\n+      // Check if the attestation had correct target\n+      Bytes32 attestationTargetRoot = sentAttestation.getData().getTarget().getRoot();\n+      if (attestationTargetRoot.equals(get_block_root(state, analyzedEpoch))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c2bafcd94ffbffcf7567f67be8000a18ac81490"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjM2ODE2NA==", "bodyText": "Wondering if instead of looking up all of the recent attestations here, we should instead be listening for blocks as they're imported and saving any relevant information as we go?  Maybe we could do something like keep a mapping from epoch -> attestationDataHash -> BlockHashAndAttesterBits[]?", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r492368164", "createdAt": "2020-09-21T21:55:46Z", "author": {"login": "mbaxter"}, "path": "validator/coordinator/src/main/java/tech/pegasys/teku/validator/coordinator/performance/RecentChainDataPerformanceTracker.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.coordinator.performance;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_epoch_at_slot;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_start_slot_at_epoch;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root_at_slot;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.IntSummaryStatistics;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.operations.Attestation;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.infrastructure.async.SafeFuture;\n+import tech.pegasys.teku.infrastructure.logging.StatusLogger;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.storage.client.RecentChainData;\n+\n+public class RecentChainDataPerformanceTracker implements PerformanceTracker {\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<SignedBeaconBlock>> sentBlocksByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<Attestation>> sentAttestationsByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  static final UInt64 BLOCK_PERFORMANCE_EVALUATION_INTERVAL = UInt64.valueOf(2); // epochs\n+\n+  private final RecentChainData recentChainData;\n+  private final StatusLogger statusLogger;\n+  private Optional<UInt64> nodeStartEpoch = Optional.empty();\n+\n+  public RecentChainDataPerformanceTracker(\n+      RecentChainData recentChainData, StatusLogger statusLogger) {\n+    this.recentChainData = recentChainData;\n+    this.statusLogger = statusLogger;\n+  }\n+\n+  @Override\n+  public void start(UInt64 nodeStartSlot) {\n+    this.nodeStartEpoch = Optional.of(compute_epoch_at_slot(nodeStartSlot));\n+  }\n+\n+  @Override\n+  public void onSlot(UInt64 slot) {\n+    if (nodeStartEpoch.isEmpty()) {\n+      return;\n+    }\n+\n+    UInt64 currentEpoch = compute_epoch_at_slot(slot);\n+    if (!compute_start_slot_at_epoch(currentEpoch).equals(slot)) {\n+      return;\n+    }\n+\n+    // Output attestation performance information for current epoch - 2 since attestations can be\n+    // included in both the epoch they were produced in or in the one following.\n+    if (currentEpoch.isGreaterThanOrEqualTo(nodeStartEpoch.get().plus(UInt64.valueOf(2)))) {\n+      statusLogger.performance(\n+          getAttestationPerformanceForEpoch(currentEpoch, currentEpoch.minus(UInt64.valueOf(2)))\n+              .toString());\n+    }\n+\n+    // Output block performance information for the past BLOCK_PERFORMANCE_INTERVAL epochs\n+    if (currentEpoch.isGreaterThanOrEqualTo(BLOCK_PERFORMANCE_EVALUATION_INTERVAL)) {\n+      if (currentEpoch.mod(BLOCK_PERFORMANCE_EVALUATION_INTERVAL).equals(UInt64.ZERO)) {\n+        statusLogger.performance(\n+            getBlockPerformanceForEpochs(\n+                    currentEpoch.minus(BLOCK_PERFORMANCE_EVALUATION_INTERVAL), currentEpoch)\n+                .toString());\n+      }\n+    }\n+\n+    UInt64 epoch =\n+        currentEpoch\n+            .minus(BLOCK_PERFORMANCE_EVALUATION_INTERVAL)\n+            .min(currentEpoch.minus(UInt64.valueOf(2)));\n+    clearReduntantSavedSentObjects(epoch);\n+  }\n+\n+  private BlockPerformance getBlockPerformanceForEpochs(\n+      UInt64 startEpochInclusive, UInt64 endEpochExclusive) {\n+    Set<BeaconBlock> blockInEpoch = getBlocksInEpochs(startEpochInclusive, endEpochExclusive);\n+    List<SignedBeaconBlock> sentBlocks =\n+        sentBlocksByEpoch.subMap(startEpochInclusive, true, endEpochExclusive, false).values()\n+            .stream()\n+            .flatMap(Collection::stream)\n+            .collect(Collectors.toList());\n+    long numberOfIncludedBlocks =\n+        sentBlocks.stream()\n+            .map(SignedBeaconBlock::getMessage)\n+            .filter(blockInEpoch::contains)\n+            .count();\n+\n+    return new BlockPerformance((int) numberOfIncludedBlocks, sentBlocks.size());\n+  }\n+\n+  private AttestationPerformance getAttestationPerformanceForEpoch(\n+      UInt64 currentEpoch, UInt64 analyzedEpoch) {\n+    checkArgument(\n+        analyzedEpoch.isLessThanOrEqualTo(currentEpoch.minus(UInt64.valueOf(2))),\n+        \"Epoch to analyze attestation performance must be at least 2 epochs less than the current epoch\");\n+    // Attestations can be included in either the epoch they were produced in or in\n+    // the following epoch. Thus, the most recent epoch for which we can evaluate attestation\n+    // performance is current epoch - 2.\n+    UInt64 analysisRangeEndEpoch = analyzedEpoch.plus(UInt64.valueOf(2));\n+\n+    // Get included attestations for the given epochs in a map from slot to attestations\n+    // included in block.\n+    Map<UInt64, List<Attestation>> attestations =\n+        getAttestationsIncludedInEpochs(analyzedEpoch, analysisRangeEndEpoch);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c2bafcd94ffbffcf7567f67be8000a18ac81490"}, "originalPosition": 136}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f469b35e83c22d7ab7b0a2df3c1c93d6f11b9b50", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/f469b35e83c22d7ab7b0a2df3c1c93d6f11b9b50", "committedDate": "2020-09-22T18:00:24Z", "message": "Add tests for decrement"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8a4db11ba636157ec0e122fd9e33cac4a007e8b3", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/8a4db11ba636157ec0e122fd9e33cac4a007e8b3", "committedDate": "2020-09-22T18:02:03Z", "message": "Remove redundant log message"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e4c6de184e605b1e1585bdceb4470f6cbc29154c", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/e4c6de184e605b1e1585bdceb4470f6cbc29154c", "committedDate": "2020-09-22T18:10:31Z", "message": "Change output string"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8a295e1d36e1acc788ac2fcd901d9ce9db402c94", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/8a295e1d36e1acc788ac2fcd901d9ce9db402c94", "committedDate": "2020-09-22T18:11:16Z", "message": "Change performance tracker class name"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "24976f97a7a4690f1de94018189675a4d9dedb92", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/24976f97a7a4690f1de94018189675a4d9dedb92", "committedDate": "2020-09-22T19:34:04Z", "message": "Switch to combined chain data client"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b5386bb5f7f07c8f65c9ec850812f607ec563ea1", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/b5386bb5f7f07c8f65c9ec850812f607ec563ea1", "committedDate": "2020-09-22T19:34:52Z", "message": "Chage block performance string"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "63b6e0549870f583da9e67d8ac8813cd5927924d", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/63b6e0549870f583da9e67d8ac8813cd5927924d", "committedDate": "2020-09-22T19:43:07Z", "message": "Save two epoch value as constant"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2c2acea3ada0f3470a6c1a26b9cfa90203b6e72e", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/2c2acea3ada0f3470a6c1a26b9cfa90203b6e72e", "committedDate": "2020-09-22T21:27:34Z", "message": "Change currSlot to current and add CLI fallback value"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5c00e1c4bcf7719c3cee58a61141ac3061a8f40b", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/5c00e1c4bcf7719c3cee58a61141ac3061a8f40b", "committedDate": "2020-09-22T21:40:09Z", "message": "Clean up test code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7be71de390007e37d3d00b227e6cda85ee8298b7", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/7be71de390007e37d3d00b227e6cda85ee8298b7", "committedDate": "2020-09-22T21:40:48Z", "message": "Run spotless"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cdd18be23d9957ae947ef3456a122438df49e37f", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/cdd18be23d9957ae947ef3456a122438df49e37f", "committedDate": "2020-09-22T21:45:18Z", "message": "Merge branch 'master' into outputValidatorPerformance"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f767397a919e8eb1e86a8201697a03c492aed4e0", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/f767397a919e8eb1e86a8201697a03c492aed4e0", "committedDate": "2020-09-23T14:28:57Z", "message": "Merge branch 'master' into outputValidatorPerformance"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk0ODQ3NjA4", "url": "https://github.com/ConsenSys/teku/pull/2772#pullrequestreview-494847608", "createdAt": "2020-09-23T16:37:13Z", "commit": {"oid": "f767397a919e8eb1e86a8201697a03c492aed4e0"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxNjozNzoxNFrOHW3KKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yM1QxODozMzo0OVrOHW7ccg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzczNDQ0MA==", "bodyText": "(optional) Might be nice to optimize this by just pulling the root.", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r493734440", "createdAt": "2020-09-23T16:37:14Z", "author": {"login": "mbaxter"}, "path": "validator/coordinator/src/main/java/tech/pegasys/teku/validator/coordinator/performance/DefaultPerformanceTracker.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.coordinator.performance;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_epoch_at_slot;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_start_slot_at_epoch;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root_at_slot;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.IntSummaryStatistics;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.operations.Attestation;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.infrastructure.logging.StatusLogger;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.storage.client.CombinedChainDataClient;\n+import tech.pegasys.teku.util.config.Constants;\n+\n+public class DefaultPerformanceTracker implements PerformanceTracker {\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<SignedBeaconBlock>> sentBlocksByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<Attestation>> sentAttestationsByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  static final UInt64 BLOCK_PERFORMANCE_EVALUATION_INTERVAL = UInt64.valueOf(2); // epochs\n+\n+  static final UInt64 ATTESTATION_INCLUSION_RANGE = UInt64.valueOf(2);\n+\n+  private final CombinedChainDataClient combinedChainDataClient;\n+  private final StatusLogger statusLogger;\n+  private Optional<UInt64> nodeStartEpoch = Optional.empty();\n+\n+  public DefaultPerformanceTracker(\n+      CombinedChainDataClient combinedChainDataClient, StatusLogger statusLogger) {\n+    this.combinedChainDataClient = combinedChainDataClient;\n+    this.statusLogger = statusLogger;\n+  }\n+\n+  @Override\n+  public void start(UInt64 nodeStartSlot) {\n+    this.nodeStartEpoch = Optional.of(compute_epoch_at_slot(nodeStartSlot));\n+  }\n+\n+  @Override\n+  public void onSlot(UInt64 slot) {\n+    if (nodeStartEpoch.isEmpty()) {\n+      return;\n+    }\n+\n+    if (slot.mod(Constants.SLOTS_PER_EPOCH).isGreaterThan(UInt64.ZERO)) {\n+      return;\n+    }\n+\n+    UInt64 currentEpoch = compute_epoch_at_slot(slot);\n+    // Output attestation performance information for current epoch - 2 since attestations can be\n+    // included in both the epoch they were produced in or in the one following.\n+    if (currentEpoch.isGreaterThanOrEqualTo(\n+        nodeStartEpoch.get().plus(ATTESTATION_INCLUSION_RANGE))) {\n+      statusLogger.performance(\n+          getAttestationPerformanceForEpoch(\n+                  currentEpoch, currentEpoch.minus(ATTESTATION_INCLUSION_RANGE))\n+              .toString());\n+    }\n+\n+    // Output block performance information for the past BLOCK_PERFORMANCE_INTERVAL epochs\n+    if (currentEpoch.isGreaterThanOrEqualTo(BLOCK_PERFORMANCE_EVALUATION_INTERVAL)) {\n+      if (currentEpoch.mod(BLOCK_PERFORMANCE_EVALUATION_INTERVAL).equals(UInt64.ZERO)) {\n+        statusLogger.performance(\n+            getBlockPerformanceForEpochs(\n+                    currentEpoch.minus(BLOCK_PERFORMANCE_EVALUATION_INTERVAL), currentEpoch)\n+                .toString());\n+      }\n+    }\n+\n+    UInt64 epoch =\n+        currentEpoch\n+            .minus(BLOCK_PERFORMANCE_EVALUATION_INTERVAL)\n+            .min(currentEpoch.minus(ATTESTATION_INCLUSION_RANGE));\n+    clearReduntantSavedSentObjects(epoch);\n+  }\n+\n+  private BlockPerformance getBlockPerformanceForEpochs(\n+      UInt64 startEpochInclusive, UInt64 endEpochExclusive) {\n+    List<SignedBeaconBlock> sentBlocks =\n+        sentBlocksByEpoch.subMap(startEpochInclusive, true, endEpochExclusive, false).values()\n+            .stream()\n+            .flatMap(Collection::stream)\n+            .collect(Collectors.toList());\n+\n+    long numberOfIncludedBlocks =\n+        sentBlocks.stream()\n+            .filter(\n+                sentBlock ->\n+                    combinedChainDataClient\n+                        .getBlockAtSlotExact(sentBlock.getSlot())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f767397a919e8eb1e86a8201697a03c492aed4e0"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzc1MDQ0Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Set<BeaconBlock> blockRootsInEpoch = new HashSet<>();\n          \n          \n            \n                Set<BeaconBlock> blocksInEpoch = new HashSet<>();", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r493750446", "createdAt": "2020-09-23T17:03:02Z", "author": {"login": "mbaxter"}, "path": "validator/coordinator/src/main/java/tech/pegasys/teku/validator/coordinator/performance/DefaultPerformanceTracker.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.coordinator.performance;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_epoch_at_slot;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_start_slot_at_epoch;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root_at_slot;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.IntSummaryStatistics;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.operations.Attestation;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.infrastructure.logging.StatusLogger;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.storage.client.CombinedChainDataClient;\n+import tech.pegasys.teku.util.config.Constants;\n+\n+public class DefaultPerformanceTracker implements PerformanceTracker {\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<SignedBeaconBlock>> sentBlocksByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<Attestation>> sentAttestationsByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  static final UInt64 BLOCK_PERFORMANCE_EVALUATION_INTERVAL = UInt64.valueOf(2); // epochs\n+\n+  static final UInt64 ATTESTATION_INCLUSION_RANGE = UInt64.valueOf(2);\n+\n+  private final CombinedChainDataClient combinedChainDataClient;\n+  private final StatusLogger statusLogger;\n+  private Optional<UInt64> nodeStartEpoch = Optional.empty();\n+\n+  public DefaultPerformanceTracker(\n+      CombinedChainDataClient combinedChainDataClient, StatusLogger statusLogger) {\n+    this.combinedChainDataClient = combinedChainDataClient;\n+    this.statusLogger = statusLogger;\n+  }\n+\n+  @Override\n+  public void start(UInt64 nodeStartSlot) {\n+    this.nodeStartEpoch = Optional.of(compute_epoch_at_slot(nodeStartSlot));\n+  }\n+\n+  @Override\n+  public void onSlot(UInt64 slot) {\n+    if (nodeStartEpoch.isEmpty()) {\n+      return;\n+    }\n+\n+    if (slot.mod(Constants.SLOTS_PER_EPOCH).isGreaterThan(UInt64.ZERO)) {\n+      return;\n+    }\n+\n+    UInt64 currentEpoch = compute_epoch_at_slot(slot);\n+    // Output attestation performance information for current epoch - 2 since attestations can be\n+    // included in both the epoch they were produced in or in the one following.\n+    if (currentEpoch.isGreaterThanOrEqualTo(\n+        nodeStartEpoch.get().plus(ATTESTATION_INCLUSION_RANGE))) {\n+      statusLogger.performance(\n+          getAttestationPerformanceForEpoch(\n+                  currentEpoch, currentEpoch.minus(ATTESTATION_INCLUSION_RANGE))\n+              .toString());\n+    }\n+\n+    // Output block performance information for the past BLOCK_PERFORMANCE_INTERVAL epochs\n+    if (currentEpoch.isGreaterThanOrEqualTo(BLOCK_PERFORMANCE_EVALUATION_INTERVAL)) {\n+      if (currentEpoch.mod(BLOCK_PERFORMANCE_EVALUATION_INTERVAL).equals(UInt64.ZERO)) {\n+        statusLogger.performance(\n+            getBlockPerformanceForEpochs(\n+                    currentEpoch.minus(BLOCK_PERFORMANCE_EVALUATION_INTERVAL), currentEpoch)\n+                .toString());\n+      }\n+    }\n+\n+    UInt64 epoch =\n+        currentEpoch\n+            .minus(BLOCK_PERFORMANCE_EVALUATION_INTERVAL)\n+            .min(currentEpoch.minus(ATTESTATION_INCLUSION_RANGE));\n+    clearReduntantSavedSentObjects(epoch);\n+  }\n+\n+  private BlockPerformance getBlockPerformanceForEpochs(\n+      UInt64 startEpochInclusive, UInt64 endEpochExclusive) {\n+    List<SignedBeaconBlock> sentBlocks =\n+        sentBlocksByEpoch.subMap(startEpochInclusive, true, endEpochExclusive, false).values()\n+            .stream()\n+            .flatMap(Collection::stream)\n+            .collect(Collectors.toList());\n+\n+    long numberOfIncludedBlocks =\n+        sentBlocks.stream()\n+            .filter(\n+                sentBlock ->\n+                    combinedChainDataClient\n+                        .getBlockAtSlotExact(sentBlock.getSlot())\n+                        .join()\n+                        .map(block -> block.equals(sentBlock))\n+                        .orElse(false))\n+            .count();\n+\n+    return new BlockPerformance((int) numberOfIncludedBlocks, sentBlocks.size());\n+  }\n+\n+  private AttestationPerformance getAttestationPerformanceForEpoch(\n+      UInt64 currentEpoch, UInt64 analyzedEpoch) {\n+    checkArgument(\n+        analyzedEpoch.isLessThanOrEqualTo(currentEpoch.minus(ATTESTATION_INCLUSION_RANGE)),\n+        \"Epoch to analyze attestation performance must be at least 2 epochs less than the current epoch\");\n+    // Attestations can be included in either the epoch they were produced in or in\n+    // the following epoch. Thus, the most recent epoch for which we can evaluate attestation\n+    // performance is current epoch - 2.\n+    UInt64 analysisRangeEndEpoch = analyzedEpoch.plus(ATTESTATION_INCLUSION_RANGE);\n+\n+    // Get included attestations for the given epochs in a map from slot to attestations\n+    // included in block.\n+    Map<UInt64, List<Attestation>> attestations =\n+        getAttestationsIncludedInEpochs(analyzedEpoch, analysisRangeEndEpoch);\n+\n+    // Get sent attestations in range\n+    Set<Attestation> sentAttestations =\n+        sentAttestationsByEpoch.getOrDefault(analyzedEpoch, new HashSet<>());\n+    UInt64 analyzedEpochStartSlot = compute_start_slot_at_epoch(analyzedEpoch);\n+    UInt64 rangeEndSlot = compute_start_slot_at_epoch(analysisRangeEndEpoch);\n+    BeaconState state = combinedChainDataClient.getBestState().orElseThrow();\n+\n+    int correctTargetCount = 0;\n+    int correctHeadBlockCount = 0;\n+    List<Integer> inclusionDistances = new ArrayList<>();\n+\n+    for (Attestation sentAttestation : sentAttestations) {\n+      // Check if the sent attestation is included in any block in the appropriate range.\n+      // Appropriate range being: [ attestation_production_epoch, attestation_production_epoch + 1 ]\n+      UInt64 attestationSlot = sentAttestation.getData().getSlot();\n+      for (UInt64 currSlot = analyzedEpochStartSlot;\n+          currSlot.isLessThan(rangeEndSlot);\n+          currSlot = currSlot.increment()) {\n+        if (attestations.containsKey(currSlot)) {\n+          if (checkIfAttestationIsIncludedInList(sentAttestation, attestations.get(currSlot))) {\n+            inclusionDistances.add(currSlot.minus(attestationSlot).intValue());\n+          }\n+        }\n+      }\n+\n+      // Check if the attestation had correct target\n+      Bytes32 attestationTargetRoot = sentAttestation.getData().getTarget().getRoot();\n+      if (attestationTargetRoot.equals(get_block_root(state, analyzedEpoch))) {\n+        correctTargetCount++;\n+\n+        // Check if the attestation had correct head block root\n+        Bytes32 attestationHeadBlockRoot = sentAttestation.getData().getBeacon_block_root();\n+        if (attestationHeadBlockRoot.equals(get_block_root_at_slot(state, attestationSlot))) {\n+          correctHeadBlockCount++;\n+        }\n+      }\n+    }\n+\n+    IntSummaryStatistics inclusionDistanceStatistics =\n+        inclusionDistances.stream().collect(Collectors.summarizingInt(Integer::intValue));\n+\n+    // IntSummaryStatistics returns Integer.MIN and MAX when the summarizend integer list is empty.\n+    return sentAttestations.size() > 0\n+        ? new AttestationPerformance(\n+            sentAttestations.size(),\n+            (int) inclusionDistanceStatistics.getCount(),\n+            inclusionDistanceStatistics.getMax(),\n+            inclusionDistanceStatistics.getMin(),\n+            inclusionDistanceStatistics.getAverage(),\n+            correctTargetCount,\n+            correctHeadBlockCount)\n+        : AttestationPerformance.empty();\n+  }\n+\n+  private boolean checkIfAttestationIsIncludedInList(\n+      Attestation sentAttestation, List<Attestation> aggregateAttestations) {\n+    for (Attestation aggregateAttestation : aggregateAttestations) {\n+      if (checkIfAttestationIsIncludedIn(sentAttestation, aggregateAttestation)) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private boolean checkIfAttestationIsIncludedIn(\n+      Attestation sentAttestation, Attestation aggregateAttestation) {\n+    return sentAttestation.getData().equals(aggregateAttestation.getData())\n+        && aggregateAttestation\n+            .getAggregation_bits()\n+            .isSuperSetOf(sentAttestation.getAggregation_bits());\n+  }\n+\n+  private Set<BeaconBlock> getBlocksInEpochs(UInt64 startEpochInclusive, UInt64 endEpochExclusive) {\n+    UInt64 epochStartSlot = compute_start_slot_at_epoch(startEpochInclusive);\n+    UInt64 endEpochStartSlot = compute_start_slot_at_epoch(endEpochExclusive);\n+\n+    Set<BeaconBlock> blockRootsInEpoch = new HashSet<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f767397a919e8eb1e86a8201697a03c492aed4e0"}, "originalPosition": 223}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzc1MzgwMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  for (UInt64 currSlot = analyzedEpochStartSlot;\n          \n          \n            \n                  for (UInt64 currSlot = attestationSlot.plus(1);", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r493753802", "createdAt": "2020-09-23T17:08:43Z", "author": {"login": "mbaxter"}, "path": "validator/coordinator/src/main/java/tech/pegasys/teku/validator/coordinator/performance/DefaultPerformanceTracker.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.coordinator.performance;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_epoch_at_slot;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_start_slot_at_epoch;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root_at_slot;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.IntSummaryStatistics;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.operations.Attestation;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.infrastructure.logging.StatusLogger;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.storage.client.CombinedChainDataClient;\n+import tech.pegasys.teku.util.config.Constants;\n+\n+public class DefaultPerformanceTracker implements PerformanceTracker {\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<SignedBeaconBlock>> sentBlocksByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<Attestation>> sentAttestationsByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  static final UInt64 BLOCK_PERFORMANCE_EVALUATION_INTERVAL = UInt64.valueOf(2); // epochs\n+\n+  static final UInt64 ATTESTATION_INCLUSION_RANGE = UInt64.valueOf(2);\n+\n+  private final CombinedChainDataClient combinedChainDataClient;\n+  private final StatusLogger statusLogger;\n+  private Optional<UInt64> nodeStartEpoch = Optional.empty();\n+\n+  public DefaultPerformanceTracker(\n+      CombinedChainDataClient combinedChainDataClient, StatusLogger statusLogger) {\n+    this.combinedChainDataClient = combinedChainDataClient;\n+    this.statusLogger = statusLogger;\n+  }\n+\n+  @Override\n+  public void start(UInt64 nodeStartSlot) {\n+    this.nodeStartEpoch = Optional.of(compute_epoch_at_slot(nodeStartSlot));\n+  }\n+\n+  @Override\n+  public void onSlot(UInt64 slot) {\n+    if (nodeStartEpoch.isEmpty()) {\n+      return;\n+    }\n+\n+    if (slot.mod(Constants.SLOTS_PER_EPOCH).isGreaterThan(UInt64.ZERO)) {\n+      return;\n+    }\n+\n+    UInt64 currentEpoch = compute_epoch_at_slot(slot);\n+    // Output attestation performance information for current epoch - 2 since attestations can be\n+    // included in both the epoch they were produced in or in the one following.\n+    if (currentEpoch.isGreaterThanOrEqualTo(\n+        nodeStartEpoch.get().plus(ATTESTATION_INCLUSION_RANGE))) {\n+      statusLogger.performance(\n+          getAttestationPerformanceForEpoch(\n+                  currentEpoch, currentEpoch.minus(ATTESTATION_INCLUSION_RANGE))\n+              .toString());\n+    }\n+\n+    // Output block performance information for the past BLOCK_PERFORMANCE_INTERVAL epochs\n+    if (currentEpoch.isGreaterThanOrEqualTo(BLOCK_PERFORMANCE_EVALUATION_INTERVAL)) {\n+      if (currentEpoch.mod(BLOCK_PERFORMANCE_EVALUATION_INTERVAL).equals(UInt64.ZERO)) {\n+        statusLogger.performance(\n+            getBlockPerformanceForEpochs(\n+                    currentEpoch.minus(BLOCK_PERFORMANCE_EVALUATION_INTERVAL), currentEpoch)\n+                .toString());\n+      }\n+    }\n+\n+    UInt64 epoch =\n+        currentEpoch\n+            .minus(BLOCK_PERFORMANCE_EVALUATION_INTERVAL)\n+            .min(currentEpoch.minus(ATTESTATION_INCLUSION_RANGE));\n+    clearReduntantSavedSentObjects(epoch);\n+  }\n+\n+  private BlockPerformance getBlockPerformanceForEpochs(\n+      UInt64 startEpochInclusive, UInt64 endEpochExclusive) {\n+    List<SignedBeaconBlock> sentBlocks =\n+        sentBlocksByEpoch.subMap(startEpochInclusive, true, endEpochExclusive, false).values()\n+            .stream()\n+            .flatMap(Collection::stream)\n+            .collect(Collectors.toList());\n+\n+    long numberOfIncludedBlocks =\n+        sentBlocks.stream()\n+            .filter(\n+                sentBlock ->\n+                    combinedChainDataClient\n+                        .getBlockAtSlotExact(sentBlock.getSlot())\n+                        .join()\n+                        .map(block -> block.equals(sentBlock))\n+                        .orElse(false))\n+            .count();\n+\n+    return new BlockPerformance((int) numberOfIncludedBlocks, sentBlocks.size());\n+  }\n+\n+  private AttestationPerformance getAttestationPerformanceForEpoch(\n+      UInt64 currentEpoch, UInt64 analyzedEpoch) {\n+    checkArgument(\n+        analyzedEpoch.isLessThanOrEqualTo(currentEpoch.minus(ATTESTATION_INCLUSION_RANGE)),\n+        \"Epoch to analyze attestation performance must be at least 2 epochs less than the current epoch\");\n+    // Attestations can be included in either the epoch they were produced in or in\n+    // the following epoch. Thus, the most recent epoch for which we can evaluate attestation\n+    // performance is current epoch - 2.\n+    UInt64 analysisRangeEndEpoch = analyzedEpoch.plus(ATTESTATION_INCLUSION_RANGE);\n+\n+    // Get included attestations for the given epochs in a map from slot to attestations\n+    // included in block.\n+    Map<UInt64, List<Attestation>> attestations =\n+        getAttestationsIncludedInEpochs(analyzedEpoch, analysisRangeEndEpoch);\n+\n+    // Get sent attestations in range\n+    Set<Attestation> sentAttestations =\n+        sentAttestationsByEpoch.getOrDefault(analyzedEpoch, new HashSet<>());\n+    UInt64 analyzedEpochStartSlot = compute_start_slot_at_epoch(analyzedEpoch);\n+    UInt64 rangeEndSlot = compute_start_slot_at_epoch(analysisRangeEndEpoch);\n+    BeaconState state = combinedChainDataClient.getBestState().orElseThrow();\n+\n+    int correctTargetCount = 0;\n+    int correctHeadBlockCount = 0;\n+    List<Integer> inclusionDistances = new ArrayList<>();\n+\n+    for (Attestation sentAttestation : sentAttestations) {\n+      // Check if the sent attestation is included in any block in the appropriate range.\n+      // Appropriate range being: [ attestation_production_epoch, attestation_production_epoch + 1 ]\n+      UInt64 attestationSlot = sentAttestation.getData().getSlot();\n+      for (UInt64 currSlot = analyzedEpochStartSlot;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f767397a919e8eb1e86a8201697a03c492aed4e0"}, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzc1NTgxMQ==", "bodyText": "(nit) Might make sense to pull this farther down where it's actually used (after we loop through all of the attestations).", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r493755811", "createdAt": "2020-09-23T17:12:06Z", "author": {"login": "mbaxter"}, "path": "validator/coordinator/src/main/java/tech/pegasys/teku/validator/coordinator/performance/DefaultPerformanceTracker.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.coordinator.performance;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_epoch_at_slot;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_start_slot_at_epoch;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root_at_slot;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.IntSummaryStatistics;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.operations.Attestation;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.infrastructure.logging.StatusLogger;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.storage.client.CombinedChainDataClient;\n+import tech.pegasys.teku.util.config.Constants;\n+\n+public class DefaultPerformanceTracker implements PerformanceTracker {\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<SignedBeaconBlock>> sentBlocksByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<Attestation>> sentAttestationsByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  static final UInt64 BLOCK_PERFORMANCE_EVALUATION_INTERVAL = UInt64.valueOf(2); // epochs\n+\n+  static final UInt64 ATTESTATION_INCLUSION_RANGE = UInt64.valueOf(2);\n+\n+  private final CombinedChainDataClient combinedChainDataClient;\n+  private final StatusLogger statusLogger;\n+  private Optional<UInt64> nodeStartEpoch = Optional.empty();\n+\n+  public DefaultPerformanceTracker(\n+      CombinedChainDataClient combinedChainDataClient, StatusLogger statusLogger) {\n+    this.combinedChainDataClient = combinedChainDataClient;\n+    this.statusLogger = statusLogger;\n+  }\n+\n+  @Override\n+  public void start(UInt64 nodeStartSlot) {\n+    this.nodeStartEpoch = Optional.of(compute_epoch_at_slot(nodeStartSlot));\n+  }\n+\n+  @Override\n+  public void onSlot(UInt64 slot) {\n+    if (nodeStartEpoch.isEmpty()) {\n+      return;\n+    }\n+\n+    if (slot.mod(Constants.SLOTS_PER_EPOCH).isGreaterThan(UInt64.ZERO)) {\n+      return;\n+    }\n+\n+    UInt64 currentEpoch = compute_epoch_at_slot(slot);\n+    // Output attestation performance information for current epoch - 2 since attestations can be\n+    // included in both the epoch they were produced in or in the one following.\n+    if (currentEpoch.isGreaterThanOrEqualTo(\n+        nodeStartEpoch.get().plus(ATTESTATION_INCLUSION_RANGE))) {\n+      statusLogger.performance(\n+          getAttestationPerformanceForEpoch(\n+                  currentEpoch, currentEpoch.minus(ATTESTATION_INCLUSION_RANGE))\n+              .toString());\n+    }\n+\n+    // Output block performance information for the past BLOCK_PERFORMANCE_INTERVAL epochs\n+    if (currentEpoch.isGreaterThanOrEqualTo(BLOCK_PERFORMANCE_EVALUATION_INTERVAL)) {\n+      if (currentEpoch.mod(BLOCK_PERFORMANCE_EVALUATION_INTERVAL).equals(UInt64.ZERO)) {\n+        statusLogger.performance(\n+            getBlockPerformanceForEpochs(\n+                    currentEpoch.minus(BLOCK_PERFORMANCE_EVALUATION_INTERVAL), currentEpoch)\n+                .toString());\n+      }\n+    }\n+\n+    UInt64 epoch =\n+        currentEpoch\n+            .minus(BLOCK_PERFORMANCE_EVALUATION_INTERVAL)\n+            .min(currentEpoch.minus(ATTESTATION_INCLUSION_RANGE));\n+    clearReduntantSavedSentObjects(epoch);\n+  }\n+\n+  private BlockPerformance getBlockPerformanceForEpochs(\n+      UInt64 startEpochInclusive, UInt64 endEpochExclusive) {\n+    List<SignedBeaconBlock> sentBlocks =\n+        sentBlocksByEpoch.subMap(startEpochInclusive, true, endEpochExclusive, false).values()\n+            .stream()\n+            .flatMap(Collection::stream)\n+            .collect(Collectors.toList());\n+\n+    long numberOfIncludedBlocks =\n+        sentBlocks.stream()\n+            .filter(\n+                sentBlock ->\n+                    combinedChainDataClient\n+                        .getBlockAtSlotExact(sentBlock.getSlot())\n+                        .join()\n+                        .map(block -> block.equals(sentBlock))\n+                        .orElse(false))\n+            .count();\n+\n+    return new BlockPerformance((int) numberOfIncludedBlocks, sentBlocks.size());\n+  }\n+\n+  private AttestationPerformance getAttestationPerformanceForEpoch(\n+      UInt64 currentEpoch, UInt64 analyzedEpoch) {\n+    checkArgument(\n+        analyzedEpoch.isLessThanOrEqualTo(currentEpoch.minus(ATTESTATION_INCLUSION_RANGE)),\n+        \"Epoch to analyze attestation performance must be at least 2 epochs less than the current epoch\");\n+    // Attestations can be included in either the epoch they were produced in or in\n+    // the following epoch. Thus, the most recent epoch for which we can evaluate attestation\n+    // performance is current epoch - 2.\n+    UInt64 analysisRangeEndEpoch = analyzedEpoch.plus(ATTESTATION_INCLUSION_RANGE);\n+\n+    // Get included attestations for the given epochs in a map from slot to attestations\n+    // included in block.\n+    Map<UInt64, List<Attestation>> attestations =\n+        getAttestationsIncludedInEpochs(analyzedEpoch, analysisRangeEndEpoch);\n+\n+    // Get sent attestations in range\n+    Set<Attestation> sentAttestations =\n+        sentAttestationsByEpoch.getOrDefault(analyzedEpoch, new HashSet<>());\n+    UInt64 analyzedEpochStartSlot = compute_start_slot_at_epoch(analyzedEpoch);\n+    UInt64 rangeEndSlot = compute_start_slot_at_epoch(analysisRangeEndEpoch);\n+    BeaconState state = combinedChainDataClient.getBestState().orElseThrow();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f767397a919e8eb1e86a8201697a03c492aed4e0"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzc3MTY4MQ==", "bodyText": "Let's say we're running 1000 validators.  In the worst case we'd be looping over 2000 attestations (1 attestation per validator per epoch), and then looping through 8192 attestations looking for matches, which is 16,384,000 operations.  That seems like a lot of processing ...\nWhat if we do some preprocessing on the list of attestations to build a map from attestationDataHash -> slot -> aggregationBitSet?  Then the inner loop will have at most 64 elements.", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r493771681", "createdAt": "2020-09-23T17:38:09Z", "author": {"login": "mbaxter"}, "path": "validator/coordinator/src/main/java/tech/pegasys/teku/validator/coordinator/performance/DefaultPerformanceTracker.java", "diffHunk": "@@ -0,0 +1,268 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.coordinator.performance;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_epoch_at_slot;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_start_slot_at_epoch;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root_at_slot;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.IntSummaryStatistics;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.operations.Attestation;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.infrastructure.logging.StatusLogger;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.storage.client.CombinedChainDataClient;\n+import tech.pegasys.teku.util.config.Constants;\n+\n+public class DefaultPerformanceTracker implements PerformanceTracker {\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<SignedBeaconBlock>> sentBlocksByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<Attestation>> sentAttestationsByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  static final UInt64 BLOCK_PERFORMANCE_EVALUATION_INTERVAL = UInt64.valueOf(2); // epochs\n+\n+  static final UInt64 ATTESTATION_INCLUSION_RANGE = UInt64.valueOf(2);\n+\n+  private final CombinedChainDataClient combinedChainDataClient;\n+  private final StatusLogger statusLogger;\n+  private Optional<UInt64> nodeStartEpoch = Optional.empty();\n+\n+  public DefaultPerformanceTracker(\n+      CombinedChainDataClient combinedChainDataClient, StatusLogger statusLogger) {\n+    this.combinedChainDataClient = combinedChainDataClient;\n+    this.statusLogger = statusLogger;\n+  }\n+\n+  @Override\n+  public void start(UInt64 nodeStartSlot) {\n+    this.nodeStartEpoch = Optional.of(compute_epoch_at_slot(nodeStartSlot));\n+  }\n+\n+  @Override\n+  public void onSlot(UInt64 slot) {\n+    if (nodeStartEpoch.isEmpty()) {\n+      return;\n+    }\n+\n+    if (slot.mod(Constants.SLOTS_PER_EPOCH).isGreaterThan(UInt64.ZERO)) {\n+      return;\n+    }\n+\n+    UInt64 currentEpoch = compute_epoch_at_slot(slot);\n+    // Output attestation performance information for current epoch - 2 since attestations can be\n+    // included in both the epoch they were produced in or in the one following.\n+    if (currentEpoch.isGreaterThanOrEqualTo(\n+        nodeStartEpoch.get().plus(ATTESTATION_INCLUSION_RANGE))) {\n+      statusLogger.performance(\n+          getAttestationPerformanceForEpoch(\n+                  currentEpoch, currentEpoch.minus(ATTESTATION_INCLUSION_RANGE))\n+              .toString());\n+    }\n+\n+    // Output block performance information for the past BLOCK_PERFORMANCE_INTERVAL epochs\n+    if (currentEpoch.isGreaterThanOrEqualTo(BLOCK_PERFORMANCE_EVALUATION_INTERVAL)) {\n+      if (currentEpoch.mod(BLOCK_PERFORMANCE_EVALUATION_INTERVAL).equals(UInt64.ZERO)) {\n+        statusLogger.performance(\n+            getBlockPerformanceForEpochs(\n+                    currentEpoch.minus(BLOCK_PERFORMANCE_EVALUATION_INTERVAL), currentEpoch)\n+                .toString());\n+      }\n+    }\n+\n+    UInt64 epoch =\n+        currentEpoch\n+            .minus(BLOCK_PERFORMANCE_EVALUATION_INTERVAL)\n+            .min(currentEpoch.minus(ATTESTATION_INCLUSION_RANGE));\n+    clearReduntantSavedSentObjects(epoch);\n+  }\n+\n+  private BlockPerformance getBlockPerformanceForEpochs(\n+      UInt64 startEpochInclusive, UInt64 endEpochExclusive) {\n+    List<SignedBeaconBlock> sentBlocks =\n+        sentBlocksByEpoch.subMap(startEpochInclusive, true, endEpochExclusive, false).values()\n+            .stream()\n+            .flatMap(Collection::stream)\n+            .collect(Collectors.toList());\n+\n+    long numberOfIncludedBlocks =\n+        sentBlocks.stream()\n+            .filter(\n+                sentBlock ->\n+                    combinedChainDataClient\n+                        .getBlockAtSlotExact(sentBlock.getSlot())\n+                        .join()\n+                        .map(block -> block.equals(sentBlock))\n+                        .orElse(false))\n+            .count();\n+\n+    return new BlockPerformance((int) numberOfIncludedBlocks, sentBlocks.size());\n+  }\n+\n+  private AttestationPerformance getAttestationPerformanceForEpoch(\n+      UInt64 currentEpoch, UInt64 analyzedEpoch) {\n+    checkArgument(\n+        analyzedEpoch.isLessThanOrEqualTo(currentEpoch.minus(ATTESTATION_INCLUSION_RANGE)),\n+        \"Epoch to analyze attestation performance must be at least 2 epochs less than the current epoch\");\n+    // Attestations can be included in either the epoch they were produced in or in\n+    // the following epoch. Thus, the most recent epoch for which we can evaluate attestation\n+    // performance is current epoch - 2.\n+    UInt64 analysisRangeEndEpoch = analyzedEpoch.plus(ATTESTATION_INCLUSION_RANGE);\n+\n+    // Get included attestations for the given epochs in a map from slot to attestations\n+    // included in block.\n+    Map<UInt64, List<Attestation>> attestations =\n+        getAttestationsIncludedInEpochs(analyzedEpoch, analysisRangeEndEpoch);\n+\n+    // Get sent attestations in range\n+    Set<Attestation> sentAttestations =\n+        sentAttestationsByEpoch.getOrDefault(analyzedEpoch, new HashSet<>());\n+    UInt64 analyzedEpochStartSlot = compute_start_slot_at_epoch(analyzedEpoch);\n+    UInt64 rangeEndSlot = compute_start_slot_at_epoch(analysisRangeEndEpoch);\n+    BeaconState state = combinedChainDataClient.getBestState().orElseThrow();\n+\n+    int correctTargetCount = 0;\n+    int correctHeadBlockCount = 0;\n+    List<Integer> inclusionDistances = new ArrayList<>();\n+\n+    for (Attestation sentAttestation : sentAttestations) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f767397a919e8eb1e86a8201697a03c492aed4e0"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzgwMzIxMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              void decrement_shouldThrowArithmeticExceptionWhenResultOverflows() {\n          \n          \n            \n              void decrement_shouldThrowArithmeticExceptionWhenResultUnderflows() {", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r493803211", "createdAt": "2020-09-23T18:31:18Z", "author": {"login": "mbaxter"}, "path": "infrastructure/unsigned/src/test/java/tech/pegasys/teku/infrastructure/unsigned/UInt64Test.java", "diffHunk": "@@ -239,6 +239,17 @@ void increment_shouldThrowArithmeticExceptionWhenResultOverflows() {\n     assertThatThrownBy(UInt64.MAX_VALUE::increment).isInstanceOf(ArithmeticException.class);\n   }\n \n+  @Test\n+  void decrement() {\n+    assertThat(UInt64.ONE.decrement()).isEqualTo(UInt64.ZERO);\n+    assertThat(UInt64.valueOf(3).decrement().decrement()).isEqualTo(UInt64.ONE);\n+  }\n+\n+  @Test\n+  void decrement_shouldThrowArithmeticExceptionWhenResultOverflows() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f767397a919e8eb1e86a8201697a03c492aed4e0"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzgwNDY1OA==", "bodyText": "We should probably add a few tests for this to ValidatorOptionsTest", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r493804658", "createdAt": "2020-09-23T18:33:49Z", "author": {"login": "mbaxter"}, "path": "teku/src/main/java/tech/pegasys/teku/cli/options/ValidatorOptions.java", "diffHunk": "@@ -81,6 +81,18 @@\n       arity = \"1\")\n   private Bytes32 graffiti;\n \n+  @Option(\n+      names = {\"--validator-performance-tracking-enabled\"},\n+      paramLabel = \"<BOOLEAN>\",\n+      description = \"Enable validator performance tracking and logging\",\n+      fallbackValue = \"true\",\n+      arity = \"0..1\")\n+  private boolean validatorPerformanceTrackingEnabled = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f767397a919e8eb1e86a8201697a03c492aed4e0"}, "originalPosition": 10}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eb2e2d0af642d31c95a7f7070b5467c9037a2607", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/eb2e2d0af642d31c95a7f7070b5467c9037a2607", "committedDate": "2020-09-23T18:57:44Z", "message": "Fix the arithmetic exception"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "97abe576fbed4493b7faca159a7c4dfedfffa28e", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/97abe576fbed4493b7faca159a7c4dfedfffa28e", "committedDate": "2020-09-23T19:17:56Z", "message": "Only count duplicate inclusions once"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "79a7c1c995aae80e0939ea5b7848faf57a97af5d", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/79a7c1c995aae80e0939ea5b7848faf57a97af5d", "committedDate": "2020-09-23T19:36:10Z", "message": "Add tests for duplicate attestation counting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "304efd8b0568cdfbe93db3300322b3a6b3ccb529", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/304efd8b0568cdfbe93db3300322b3a6b3ccb529", "committedDate": "2020-09-23T19:36:41Z", "message": "Run spotless"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0babef8d89d115b75779c94deab5df80ff2315a8", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/0babef8d89d115b75779c94deab5df80ff2315a8", "committedDate": "2020-09-24T14:20:41Z", "message": "Pre-process attestations to avoid expensive inclusion checks"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e99a715a62e87fd4d91caf41822ee1fd22252abf", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/e99a715a62e87fd4d91caf41822ee1fd22252abf", "committedDate": "2020-09-24T14:50:52Z", "message": "Make sure to find the minimum inclusion distance for duplicate attestations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "988d494b8fae63572b4312c76a52dee4cd89bc0c", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/988d494b8fae63572b4312c76a52dee4cd89bc0c", "committedDate": "2020-09-24T14:51:19Z", "message": "Run spotless"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2f26a335609563ebda91fdcdc8df2d13fc62e35f", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/2f26a335609563ebda91fdcdc8df2d13fc62e35f", "committedDate": "2020-09-24T15:12:36Z", "message": "Add validator option test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0ead970b8a0f22074226ef9b0636e60803456abf", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/0ead970b8a0f22074226ef9b0636e60803456abf", "committedDate": "2020-09-24T15:13:00Z", "message": "Run spotless"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1b489f4afd4d88dc22ba450f8c89e262847d4005", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/1b489f4afd4d88dc22ba450f8c89e262847d4005", "committedDate": "2020-09-24T18:29:14Z", "message": "Add validator performance metrics"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ee3f9231d7a81eabc70aa5277d9c886617aef7c9", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/ee3f9231d7a81eabc70aa5277d9c886617aef7c9", "committedDate": "2020-09-24T18:30:04Z", "message": "Run spotless"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "28256385cba9b4bdd235bf63e7f8650c44392221", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/28256385cba9b4bdd235bf63e7f8650c44392221", "committedDate": "2020-09-24T18:41:00Z", "message": "Merge branch 'master' into outputValidatorPerformance"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "10c2471cf03bc5cd0937086fb6ce6b7d3e1f1bc7", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/10c2471cf03bc5cd0937086fb6ce6b7d3e1f1bc7", "committedDate": "2020-09-24T18:59:06Z", "message": "Only report block performance if non-zero blocks were produced"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3e48ef815be489c4c41c06cdda3ec5954568f3db", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/3e48ef815be489c4c41c06cdda3ec5954568f3db", "committedDate": "2020-09-29T18:23:19Z", "message": "Fix all zeros error"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "75205376ae73b01fc23951e18e64e122d8f18872", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/75205376ae73b01fc23951e18e64e122d8f18872", "committedDate": "2020-09-29T18:24:12Z", "message": "Run spotless"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d89d94da8c77ca9a35442f63be9a21eab8e3033e", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/d89d94da8c77ca9a35442f63be9a21eab8e3033e", "committedDate": "2020-09-29T19:38:00Z", "message": "Remove testing logs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "31e73429067a80f5007c221213727ebdb371d272", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/31e73429067a80f5007c221213727ebdb371d272", "committedDate": "2020-09-29T19:40:50Z", "message": "Merge remote-tracking branch 'remotes/origin/master' into outputValidatorPerformance\n\n# Conflicts:\n#\tservices/beaconchain/src/main/java/tech/pegasys/teku/services/beaconchain/BeaconChainController.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a0cb333ccbd8cbeef08a461819390b58f991415d", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/a0cb333ccbd8cbeef08a461819390b58f991415d", "committedDate": "2020-09-29T20:45:11Z", "message": "Merge branch 'master' into outputValidatorPerformance"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDk4ODc1MTUy", "url": "https://github.com/ConsenSys/teku/pull/2772#pullrequestreview-498875152", "createdAt": "2020-09-29T20:40:07Z", "commit": {"oid": "31e73429067a80f5007c221213727ebdb371d272"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQyMDo0MDowN1rOHaAhzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQyMToyMToxNFrOHaCkLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzAzMzY3Nw==", "bodyText": "I'd suggest using an AtomicReference<UInt64> so we don't have to mess with the long value conversion:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (currentEpoch.longValue() <= latestAnalyzedEpoch.getAndSet(currentEpoch.longValue())) {\n          \n          \n            \n                if (currentEpoch.isLessThanOrEqualTo(latestAnalyzedEpoch.getAndSet(currentEpoch))) {", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r497033677", "createdAt": "2020-09-29T20:40:07Z", "author": {"login": "mbaxter"}, "path": "validator/coordinator/src/main/java/tech/pegasys/teku/validator/coordinator/performance/DefaultPerformanceTracker.java", "diffHunk": "@@ -0,0 +1,269 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.coordinator.performance;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_epoch_at_slot;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_start_slot_at_epoch;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root_at_slot;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.IntSummaryStatistics;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.operations.Attestation;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.infrastructure.logging.StatusLogger;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.ssz.SSZTypes.Bitlist;\n+import tech.pegasys.teku.storage.client.CombinedChainDataClient;\n+import tech.pegasys.teku.util.config.Constants;\n+\n+public class DefaultPerformanceTracker implements PerformanceTracker {\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<SignedBeaconBlock>> producedBlocksByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<Attestation>> producedAttestationsByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  static final UInt64 BLOCK_PERFORMANCE_EVALUATION_INTERVAL = UInt64.valueOf(2); // epochs\n+\n+  static final UInt64 ATTESTATION_INCLUSION_RANGE = UInt64.valueOf(2);\n+\n+  private final CombinedChainDataClient combinedChainDataClient;\n+  private final StatusLogger statusLogger;\n+  private final ValidatorPerformanceMetrics validatorPerformanceMetrics;\n+\n+  private Optional<UInt64> nodeStartEpoch = Optional.empty();\n+  private AtomicLong latestAnalyzedEpoch = new AtomicLong(0);\n+\n+  public DefaultPerformanceTracker(\n+      CombinedChainDataClient combinedChainDataClient,\n+      StatusLogger statusLogger,\n+      ValidatorPerformanceMetrics validatorPerformanceMetrics) {\n+    this.combinedChainDataClient = combinedChainDataClient;\n+    this.statusLogger = statusLogger;\n+    this.validatorPerformanceMetrics = validatorPerformanceMetrics;\n+  }\n+\n+  @Override\n+  public void start(UInt64 nodeStartSlot) {\n+    this.nodeStartEpoch = Optional.of(compute_epoch_at_slot(nodeStartSlot));\n+  }\n+\n+  @Override\n+  public void onSlot(UInt64 slot) {\n+    if (nodeStartEpoch.isEmpty()) {\n+      return;\n+    }\n+\n+    if (slot.mod(Constants.SLOTS_PER_EPOCH).isGreaterThan(UInt64.ZERO)) {\n+      return;\n+    }\n+\n+    UInt64 currentEpoch = compute_epoch_at_slot(slot);\n+    if (currentEpoch.longValue() <= latestAnalyzedEpoch.getAndSet(currentEpoch.longValue())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "31e73429067a80f5007c221213727ebdb371d272"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzAzOTE3OA==", "bodyText": "Even better, you can use getAndUpdate to make sure latestAnalyzedEpoch only ever increases:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (currentEpoch.longValue() <= latestAnalyzedEpoch.getAndSet(currentEpoch.longValue())) {\n          \n          \n            \n                if (currentEpoch.isLessThanOrEqualTo(latestAnalyzedEpoch.getAndUpdate(val -> val.isLessThan(currentEpoch) ? currentEpoch : val))) {", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r497039178", "createdAt": "2020-09-29T20:45:30Z", "author": {"login": "mbaxter"}, "path": "validator/coordinator/src/main/java/tech/pegasys/teku/validator/coordinator/performance/DefaultPerformanceTracker.java", "diffHunk": "@@ -0,0 +1,269 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.coordinator.performance;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_epoch_at_slot;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_start_slot_at_epoch;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root_at_slot;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.IntSummaryStatistics;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.operations.Attestation;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.infrastructure.logging.StatusLogger;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.ssz.SSZTypes.Bitlist;\n+import tech.pegasys.teku.storage.client.CombinedChainDataClient;\n+import tech.pegasys.teku.util.config.Constants;\n+\n+public class DefaultPerformanceTracker implements PerformanceTracker {\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<SignedBeaconBlock>> producedBlocksByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<Attestation>> producedAttestationsByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  static final UInt64 BLOCK_PERFORMANCE_EVALUATION_INTERVAL = UInt64.valueOf(2); // epochs\n+\n+  static final UInt64 ATTESTATION_INCLUSION_RANGE = UInt64.valueOf(2);\n+\n+  private final CombinedChainDataClient combinedChainDataClient;\n+  private final StatusLogger statusLogger;\n+  private final ValidatorPerformanceMetrics validatorPerformanceMetrics;\n+\n+  private Optional<UInt64> nodeStartEpoch = Optional.empty();\n+  private AtomicLong latestAnalyzedEpoch = new AtomicLong(0);\n+\n+  public DefaultPerformanceTracker(\n+      CombinedChainDataClient combinedChainDataClient,\n+      StatusLogger statusLogger,\n+      ValidatorPerformanceMetrics validatorPerformanceMetrics) {\n+    this.combinedChainDataClient = combinedChainDataClient;\n+    this.statusLogger = statusLogger;\n+    this.validatorPerformanceMetrics = validatorPerformanceMetrics;\n+  }\n+\n+  @Override\n+  public void start(UInt64 nodeStartSlot) {\n+    this.nodeStartEpoch = Optional.of(compute_epoch_at_slot(nodeStartSlot));\n+  }\n+\n+  @Override\n+  public void onSlot(UInt64 slot) {\n+    if (nodeStartEpoch.isEmpty()) {\n+      return;\n+    }\n+\n+    if (slot.mod(Constants.SLOTS_PER_EPOCH).isGreaterThan(UInt64.ZERO)) {\n+      return;\n+    }\n+\n+    UInt64 currentEpoch = compute_epoch_at_slot(slot);\n+    if (currentEpoch.longValue() <= latestAnalyzedEpoch.getAndSet(currentEpoch.longValue())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzAzMzY3Nw=="}, "originalCommit": {"oid": "31e73429067a80f5007c221213727ebdb371d272"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA0Nzc4NQ==", "bodyText": "We can be a bit more efficient here if we pull blocks with getBlockInEffectAtSlot in a while loop and manually update the current slot.  That will avoid extra calls when blocks are skipped.", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r497047785", "createdAt": "2020-09-29T20:53:55Z", "author": {"login": "mbaxter"}, "path": "validator/coordinator/src/main/java/tech/pegasys/teku/validator/coordinator/performance/DefaultPerformanceTracker.java", "diffHunk": "@@ -0,0 +1,269 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.coordinator.performance;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_epoch_at_slot;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_start_slot_at_epoch;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root_at_slot;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.IntSummaryStatistics;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.operations.Attestation;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.infrastructure.logging.StatusLogger;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.ssz.SSZTypes.Bitlist;\n+import tech.pegasys.teku.storage.client.CombinedChainDataClient;\n+import tech.pegasys.teku.util.config.Constants;\n+\n+public class DefaultPerformanceTracker implements PerformanceTracker {\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<SignedBeaconBlock>> producedBlocksByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<Attestation>> producedAttestationsByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  static final UInt64 BLOCK_PERFORMANCE_EVALUATION_INTERVAL = UInt64.valueOf(2); // epochs\n+\n+  static final UInt64 ATTESTATION_INCLUSION_RANGE = UInt64.valueOf(2);\n+\n+  private final CombinedChainDataClient combinedChainDataClient;\n+  private final StatusLogger statusLogger;\n+  private final ValidatorPerformanceMetrics validatorPerformanceMetrics;\n+\n+  private Optional<UInt64> nodeStartEpoch = Optional.empty();\n+  private AtomicLong latestAnalyzedEpoch = new AtomicLong(0);\n+\n+  public DefaultPerformanceTracker(\n+      CombinedChainDataClient combinedChainDataClient,\n+      StatusLogger statusLogger,\n+      ValidatorPerformanceMetrics validatorPerformanceMetrics) {\n+    this.combinedChainDataClient = combinedChainDataClient;\n+    this.statusLogger = statusLogger;\n+    this.validatorPerformanceMetrics = validatorPerformanceMetrics;\n+  }\n+\n+  @Override\n+  public void start(UInt64 nodeStartSlot) {\n+    this.nodeStartEpoch = Optional.of(compute_epoch_at_slot(nodeStartSlot));\n+  }\n+\n+  @Override\n+  public void onSlot(UInt64 slot) {\n+    if (nodeStartEpoch.isEmpty()) {\n+      return;\n+    }\n+\n+    if (slot.mod(Constants.SLOTS_PER_EPOCH).isGreaterThan(UInt64.ZERO)) {\n+      return;\n+    }\n+\n+    UInt64 currentEpoch = compute_epoch_at_slot(slot);\n+    if (currentEpoch.longValue() <= latestAnalyzedEpoch.getAndSet(currentEpoch.longValue())) {\n+      return;\n+    }\n+\n+    // Output attestation performance information for current epoch - 2 since attestations can be\n+    // included in both the epoch they were produced in or in the one following.\n+    if (currentEpoch.isGreaterThanOrEqualTo(\n+        nodeStartEpoch.get().plus(ATTESTATION_INCLUSION_RANGE))) {\n+      UInt64 analyzedEpoch = currentEpoch.minus(ATTESTATION_INCLUSION_RANGE);\n+      AttestationPerformance attestationPerformance =\n+          getAttestationPerformanceForEpoch(currentEpoch, analyzedEpoch);\n+      statusLogger.performance(attestationPerformance.toString());\n+      producedAttestationsByEpoch.headMap(analyzedEpoch, true).clear();\n+      validatorPerformanceMetrics.updateAttestationPerformanceMetrics(attestationPerformance);\n+    }\n+\n+    // Output block performance information for the past BLOCK_PERFORMANCE_INTERVAL epochs\n+    if (currentEpoch.isGreaterThanOrEqualTo(BLOCK_PERFORMANCE_EVALUATION_INTERVAL)) {\n+      if (currentEpoch.mod(BLOCK_PERFORMANCE_EVALUATION_INTERVAL).equals(UInt64.ZERO)) {\n+        UInt64 oldestAnalyzedEpoch = currentEpoch.minus(BLOCK_PERFORMANCE_EVALUATION_INTERVAL);\n+        BlockPerformance blockPerformance =\n+            getBlockPerformanceForEpochs(oldestAnalyzedEpoch, currentEpoch);\n+        if (blockPerformance.numberOfProducedBlocks > 0) {\n+          statusLogger.performance(blockPerformance.toString());\n+          producedBlocksByEpoch.headMap(oldestAnalyzedEpoch, true).clear();\n+          validatorPerformanceMetrics.updateBlockPerformanceMetrics(blockPerformance);\n+        }\n+      }\n+    }\n+  }\n+\n+  private BlockPerformance getBlockPerformanceForEpochs(\n+      UInt64 startEpochInclusive, UInt64 endEpochExclusive) {\n+    List<SignedBeaconBlock> producedBlocks =\n+        producedBlocksByEpoch.subMap(startEpochInclusive, true, endEpochExclusive, false).values()\n+            .stream()\n+            .flatMap(Collection::stream)\n+            .collect(Collectors.toList());\n+\n+    long numberOfIncludedBlocks =\n+        producedBlocks.stream()\n+            .filter(\n+                sentBlock ->\n+                    combinedChainDataClient\n+                        .getBlockAtSlotExact(sentBlock.getSlot())\n+                        .join()\n+                        .map(block -> block.equals(sentBlock))\n+                        .orElse(false))\n+            .count();\n+\n+    return new BlockPerformance((int) numberOfIncludedBlocks, producedBlocks.size());\n+  }\n+\n+  private AttestationPerformance getAttestationPerformanceForEpoch(\n+      UInt64 currentEpoch, UInt64 analyzedEpoch) {\n+    checkArgument(\n+        analyzedEpoch.isLessThanOrEqualTo(currentEpoch.minus(ATTESTATION_INCLUSION_RANGE)),\n+        \"Epoch to analyze attestation performance must be at least 2 epochs less than the current epoch\");\n+    // Attestations can be included in either the epoch they were produced in or in\n+    // the following epoch. Thus, the most recent epoch for which we can evaluate attestation\n+    // performance is current epoch - 2.\n+    UInt64 analysisRangeEndEpoch = analyzedEpoch.plus(ATTESTATION_INCLUSION_RANGE);\n+\n+    // Get included attestations for the given epochs in a map from slot to attestations\n+    // included in block.\n+    Map<UInt64, List<Attestation>> attestationsIncludedOnChain =\n+        getAttestationsIncludedInEpochs(analyzedEpoch, analysisRangeEndEpoch);\n+\n+    // Get sent attestations in range\n+    Set<Attestation> producedAttestations =\n+        producedAttestationsByEpoch.getOrDefault(analyzedEpoch, new HashSet<>());\n+    BeaconState state = combinedChainDataClient.getBestState().orElseThrow();\n+\n+    int correctTargetCount = 0;\n+    int correctHeadBlockCount = 0;\n+    List<Integer> inclusionDistances = new ArrayList<>();\n+\n+    // Pre-process attestations included on chain to group them by\n+    // data hash to inclusion slot to aggregation bitlist\n+    Map<Bytes32, NavigableMap<UInt64, Bitlist>> slotAndBitlistsByAttestationDataHash =\n+        new HashMap<>();\n+    for (UInt64 slot : attestationsIncludedOnChain.keySet()) {\n+      for (Attestation attestation : attestationsIncludedOnChain.get(slot)) {\n+        Bytes32 attestationDataHash = attestation.getData().hash_tree_root();\n+        NavigableMap<UInt64, Bitlist> slotToBitlists =\n+            slotAndBitlistsByAttestationDataHash.computeIfAbsent(\n+                attestationDataHash, __ -> new TreeMap<>());\n+        slotToBitlists.put(slot, attestation.getAggregation_bits());\n+      }\n+    }\n+\n+    for (Attestation sentAttestation : producedAttestations) {\n+      Bytes32 sentAttestationDataHash = sentAttestation.getData().hash_tree_root();\n+      UInt64 sentAttestationSlot = sentAttestation.getData().getSlot();\n+      if (!slotAndBitlistsByAttestationDataHash.containsKey(sentAttestationDataHash)) continue;\n+      NavigableMap<UInt64, Bitlist> slotAndBitlists =\n+          slotAndBitlistsByAttestationDataHash.get(sentAttestationDataHash);\n+      for (UInt64 slot : slotAndBitlists.keySet()) {\n+        if (slotAndBitlists.get(slot).isSuperSetOf(sentAttestation.getAggregation_bits())) {\n+          inclusionDistances.add(slot.minus(sentAttestationSlot).intValue());\n+          break;\n+        }\n+      }\n+\n+      // Check if the attestation had correct target\n+      Bytes32 attestationTargetRoot = sentAttestation.getData().getTarget().getRoot();\n+      if (attestationTargetRoot.equals(get_block_root(state, analyzedEpoch))) {\n+        correctTargetCount++;\n+\n+        // Check if the attestation had correct head block root\n+        Bytes32 attestationHeadBlockRoot = sentAttestation.getData().getBeacon_block_root();\n+        if (attestationHeadBlockRoot.equals(get_block_root_at_slot(state, sentAttestationSlot))) {\n+          correctHeadBlockCount++;\n+        }\n+      }\n+    }\n+\n+    IntSummaryStatistics inclusionDistanceStatistics =\n+        inclusionDistances.stream().collect(Collectors.summarizingInt(Integer::intValue));\n+\n+    // IntSummaryStatistics returns Integer.MIN and MAX when the summarized integer list is empty.\n+    return producedAttestations.size() > 0\n+        ? new AttestationPerformance(\n+            producedAttestations.size(),\n+            (int) inclusionDistanceStatistics.getCount(),\n+            inclusionDistanceStatistics.getMax(),\n+            inclusionDistanceStatistics.getMin(),\n+            inclusionDistanceStatistics.getAverage(),\n+            correctTargetCount,\n+            correctHeadBlockCount)\n+        : AttestationPerformance.empty();\n+  }\n+\n+  private Set<BeaconBlock> getBlocksInEpochs(UInt64 startEpochInclusive, UInt64 endEpochExclusive) {\n+    UInt64 epochStartSlot = compute_start_slot_at_epoch(startEpochInclusive);\n+    UInt64 endEpochStartSlot = compute_start_slot_at_epoch(endEpochExclusive);\n+\n+    Set<BeaconBlock> blocksInEpoch = new HashSet<>();\n+    for (UInt64 currSlot = epochStartSlot;\n+        currSlot.isLessThan(endEpochStartSlot);\n+        currSlot = currSlot.increment()) {\n+      combinedChainDataClient\n+          .getBlockAtSlotExact(currSlot)\n+          .join()\n+          .ifPresent(signedBlock -> blocksInEpoch.add(signedBlock.getMessage()));\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a0cb333ccbd8cbeef08a461819390b58f991415d"}, "originalPosition": 237}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA2MjYzMQ==", "bodyText": "Can't we have multiple attestations with the same attestation data and different bits sets?  I think we need to accumulate all of the bits into a single Bitlist instead of overwriting.", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r497062631", "createdAt": "2020-09-29T21:12:22Z", "author": {"login": "mbaxter"}, "path": "validator/coordinator/src/main/java/tech/pegasys/teku/validator/coordinator/performance/DefaultPerformanceTracker.java", "diffHunk": "@@ -0,0 +1,269 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.coordinator.performance;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_epoch_at_slot;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_start_slot_at_epoch;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root_at_slot;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.IntSummaryStatistics;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.operations.Attestation;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.infrastructure.logging.StatusLogger;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.ssz.SSZTypes.Bitlist;\n+import tech.pegasys.teku.storage.client.CombinedChainDataClient;\n+import tech.pegasys.teku.util.config.Constants;\n+\n+public class DefaultPerformanceTracker implements PerformanceTracker {\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<SignedBeaconBlock>> producedBlocksByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<Attestation>> producedAttestationsByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  static final UInt64 BLOCK_PERFORMANCE_EVALUATION_INTERVAL = UInt64.valueOf(2); // epochs\n+\n+  static final UInt64 ATTESTATION_INCLUSION_RANGE = UInt64.valueOf(2);\n+\n+  private final CombinedChainDataClient combinedChainDataClient;\n+  private final StatusLogger statusLogger;\n+  private final ValidatorPerformanceMetrics validatorPerformanceMetrics;\n+\n+  private Optional<UInt64> nodeStartEpoch = Optional.empty();\n+  private AtomicLong latestAnalyzedEpoch = new AtomicLong(0);\n+\n+  public DefaultPerformanceTracker(\n+      CombinedChainDataClient combinedChainDataClient,\n+      StatusLogger statusLogger,\n+      ValidatorPerformanceMetrics validatorPerformanceMetrics) {\n+    this.combinedChainDataClient = combinedChainDataClient;\n+    this.statusLogger = statusLogger;\n+    this.validatorPerformanceMetrics = validatorPerformanceMetrics;\n+  }\n+\n+  @Override\n+  public void start(UInt64 nodeStartSlot) {\n+    this.nodeStartEpoch = Optional.of(compute_epoch_at_slot(nodeStartSlot));\n+  }\n+\n+  @Override\n+  public void onSlot(UInt64 slot) {\n+    if (nodeStartEpoch.isEmpty()) {\n+      return;\n+    }\n+\n+    if (slot.mod(Constants.SLOTS_PER_EPOCH).isGreaterThan(UInt64.ZERO)) {\n+      return;\n+    }\n+\n+    UInt64 currentEpoch = compute_epoch_at_slot(slot);\n+    if (currentEpoch.longValue() <= latestAnalyzedEpoch.getAndSet(currentEpoch.longValue())) {\n+      return;\n+    }\n+\n+    // Output attestation performance information for current epoch - 2 since attestations can be\n+    // included in both the epoch they were produced in or in the one following.\n+    if (currentEpoch.isGreaterThanOrEqualTo(\n+        nodeStartEpoch.get().plus(ATTESTATION_INCLUSION_RANGE))) {\n+      UInt64 analyzedEpoch = currentEpoch.minus(ATTESTATION_INCLUSION_RANGE);\n+      AttestationPerformance attestationPerformance =\n+          getAttestationPerformanceForEpoch(currentEpoch, analyzedEpoch);\n+      statusLogger.performance(attestationPerformance.toString());\n+      producedAttestationsByEpoch.headMap(analyzedEpoch, true).clear();\n+      validatorPerformanceMetrics.updateAttestationPerformanceMetrics(attestationPerformance);\n+    }\n+\n+    // Output block performance information for the past BLOCK_PERFORMANCE_INTERVAL epochs\n+    if (currentEpoch.isGreaterThanOrEqualTo(BLOCK_PERFORMANCE_EVALUATION_INTERVAL)) {\n+      if (currentEpoch.mod(BLOCK_PERFORMANCE_EVALUATION_INTERVAL).equals(UInt64.ZERO)) {\n+        UInt64 oldestAnalyzedEpoch = currentEpoch.minus(BLOCK_PERFORMANCE_EVALUATION_INTERVAL);\n+        BlockPerformance blockPerformance =\n+            getBlockPerformanceForEpochs(oldestAnalyzedEpoch, currentEpoch);\n+        if (blockPerformance.numberOfProducedBlocks > 0) {\n+          statusLogger.performance(blockPerformance.toString());\n+          producedBlocksByEpoch.headMap(oldestAnalyzedEpoch, true).clear();\n+          validatorPerformanceMetrics.updateBlockPerformanceMetrics(blockPerformance);\n+        }\n+      }\n+    }\n+  }\n+\n+  private BlockPerformance getBlockPerformanceForEpochs(\n+      UInt64 startEpochInclusive, UInt64 endEpochExclusive) {\n+    List<SignedBeaconBlock> producedBlocks =\n+        producedBlocksByEpoch.subMap(startEpochInclusive, true, endEpochExclusive, false).values()\n+            .stream()\n+            .flatMap(Collection::stream)\n+            .collect(Collectors.toList());\n+\n+    long numberOfIncludedBlocks =\n+        producedBlocks.stream()\n+            .filter(\n+                sentBlock ->\n+                    combinedChainDataClient\n+                        .getBlockAtSlotExact(sentBlock.getSlot())\n+                        .join()\n+                        .map(block -> block.equals(sentBlock))\n+                        .orElse(false))\n+            .count();\n+\n+    return new BlockPerformance((int) numberOfIncludedBlocks, producedBlocks.size());\n+  }\n+\n+  private AttestationPerformance getAttestationPerformanceForEpoch(\n+      UInt64 currentEpoch, UInt64 analyzedEpoch) {\n+    checkArgument(\n+        analyzedEpoch.isLessThanOrEqualTo(currentEpoch.minus(ATTESTATION_INCLUSION_RANGE)),\n+        \"Epoch to analyze attestation performance must be at least 2 epochs less than the current epoch\");\n+    // Attestations can be included in either the epoch they were produced in or in\n+    // the following epoch. Thus, the most recent epoch for which we can evaluate attestation\n+    // performance is current epoch - 2.\n+    UInt64 analysisRangeEndEpoch = analyzedEpoch.plus(ATTESTATION_INCLUSION_RANGE);\n+\n+    // Get included attestations for the given epochs in a map from slot to attestations\n+    // included in block.\n+    Map<UInt64, List<Attestation>> attestationsIncludedOnChain =\n+        getAttestationsIncludedInEpochs(analyzedEpoch, analysisRangeEndEpoch);\n+\n+    // Get sent attestations in range\n+    Set<Attestation> producedAttestations =\n+        producedAttestationsByEpoch.getOrDefault(analyzedEpoch, new HashSet<>());\n+    BeaconState state = combinedChainDataClient.getBestState().orElseThrow();\n+\n+    int correctTargetCount = 0;\n+    int correctHeadBlockCount = 0;\n+    List<Integer> inclusionDistances = new ArrayList<>();\n+\n+    // Pre-process attestations included on chain to group them by\n+    // data hash to inclusion slot to aggregation bitlist\n+    Map<Bytes32, NavigableMap<UInt64, Bitlist>> slotAndBitlistsByAttestationDataHash =\n+        new HashMap<>();\n+    for (UInt64 slot : attestationsIncludedOnChain.keySet()) {\n+      for (Attestation attestation : attestationsIncludedOnChain.get(slot)) {\n+        Bytes32 attestationDataHash = attestation.getData().hash_tree_root();\n+        NavigableMap<UInt64, Bitlist> slotToBitlists =\n+            slotAndBitlistsByAttestationDataHash.computeIfAbsent(\n+                attestationDataHash, __ -> new TreeMap<>());\n+        slotToBitlists.put(slot, attestation.getAggregation_bits());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a0cb333ccbd8cbeef08a461819390b58f991415d"}, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA2MzE1NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  if (!slotAndBitlistsByAttestationDataHash.containsKey(sentAttestationDataHash)) continue;\n          \n          \n            \n                  if (!slotAndBitlistsByAttestationDataHash.containsKey(sentAttestationDataHash)) {\n          \n          \n            \n                    continue;\n          \n          \n            \n                  }", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r497063155", "createdAt": "2020-09-29T21:13:25Z", "author": {"login": "mbaxter"}, "path": "validator/coordinator/src/main/java/tech/pegasys/teku/validator/coordinator/performance/DefaultPerformanceTracker.java", "diffHunk": "@@ -0,0 +1,269 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.coordinator.performance;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_epoch_at_slot;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_start_slot_at_epoch;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root_at_slot;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.IntSummaryStatistics;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.operations.Attestation;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.infrastructure.logging.StatusLogger;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.ssz.SSZTypes.Bitlist;\n+import tech.pegasys.teku.storage.client.CombinedChainDataClient;\n+import tech.pegasys.teku.util.config.Constants;\n+\n+public class DefaultPerformanceTracker implements PerformanceTracker {\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<SignedBeaconBlock>> producedBlocksByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<Attestation>> producedAttestationsByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  static final UInt64 BLOCK_PERFORMANCE_EVALUATION_INTERVAL = UInt64.valueOf(2); // epochs\n+\n+  static final UInt64 ATTESTATION_INCLUSION_RANGE = UInt64.valueOf(2);\n+\n+  private final CombinedChainDataClient combinedChainDataClient;\n+  private final StatusLogger statusLogger;\n+  private final ValidatorPerformanceMetrics validatorPerformanceMetrics;\n+\n+  private Optional<UInt64> nodeStartEpoch = Optional.empty();\n+  private AtomicLong latestAnalyzedEpoch = new AtomicLong(0);\n+\n+  public DefaultPerformanceTracker(\n+      CombinedChainDataClient combinedChainDataClient,\n+      StatusLogger statusLogger,\n+      ValidatorPerformanceMetrics validatorPerformanceMetrics) {\n+    this.combinedChainDataClient = combinedChainDataClient;\n+    this.statusLogger = statusLogger;\n+    this.validatorPerformanceMetrics = validatorPerformanceMetrics;\n+  }\n+\n+  @Override\n+  public void start(UInt64 nodeStartSlot) {\n+    this.nodeStartEpoch = Optional.of(compute_epoch_at_slot(nodeStartSlot));\n+  }\n+\n+  @Override\n+  public void onSlot(UInt64 slot) {\n+    if (nodeStartEpoch.isEmpty()) {\n+      return;\n+    }\n+\n+    if (slot.mod(Constants.SLOTS_PER_EPOCH).isGreaterThan(UInt64.ZERO)) {\n+      return;\n+    }\n+\n+    UInt64 currentEpoch = compute_epoch_at_slot(slot);\n+    if (currentEpoch.longValue() <= latestAnalyzedEpoch.getAndSet(currentEpoch.longValue())) {\n+      return;\n+    }\n+\n+    // Output attestation performance information for current epoch - 2 since attestations can be\n+    // included in both the epoch they were produced in or in the one following.\n+    if (currentEpoch.isGreaterThanOrEqualTo(\n+        nodeStartEpoch.get().plus(ATTESTATION_INCLUSION_RANGE))) {\n+      UInt64 analyzedEpoch = currentEpoch.minus(ATTESTATION_INCLUSION_RANGE);\n+      AttestationPerformance attestationPerformance =\n+          getAttestationPerformanceForEpoch(currentEpoch, analyzedEpoch);\n+      statusLogger.performance(attestationPerformance.toString());\n+      producedAttestationsByEpoch.headMap(analyzedEpoch, true).clear();\n+      validatorPerformanceMetrics.updateAttestationPerformanceMetrics(attestationPerformance);\n+    }\n+\n+    // Output block performance information for the past BLOCK_PERFORMANCE_INTERVAL epochs\n+    if (currentEpoch.isGreaterThanOrEqualTo(BLOCK_PERFORMANCE_EVALUATION_INTERVAL)) {\n+      if (currentEpoch.mod(BLOCK_PERFORMANCE_EVALUATION_INTERVAL).equals(UInt64.ZERO)) {\n+        UInt64 oldestAnalyzedEpoch = currentEpoch.minus(BLOCK_PERFORMANCE_EVALUATION_INTERVAL);\n+        BlockPerformance blockPerformance =\n+            getBlockPerformanceForEpochs(oldestAnalyzedEpoch, currentEpoch);\n+        if (blockPerformance.numberOfProducedBlocks > 0) {\n+          statusLogger.performance(blockPerformance.toString());\n+          producedBlocksByEpoch.headMap(oldestAnalyzedEpoch, true).clear();\n+          validatorPerformanceMetrics.updateBlockPerformanceMetrics(blockPerformance);\n+        }\n+      }\n+    }\n+  }\n+\n+  private BlockPerformance getBlockPerformanceForEpochs(\n+      UInt64 startEpochInclusive, UInt64 endEpochExclusive) {\n+    List<SignedBeaconBlock> producedBlocks =\n+        producedBlocksByEpoch.subMap(startEpochInclusive, true, endEpochExclusive, false).values()\n+            .stream()\n+            .flatMap(Collection::stream)\n+            .collect(Collectors.toList());\n+\n+    long numberOfIncludedBlocks =\n+        producedBlocks.stream()\n+            .filter(\n+                sentBlock ->\n+                    combinedChainDataClient\n+                        .getBlockAtSlotExact(sentBlock.getSlot())\n+                        .join()\n+                        .map(block -> block.equals(sentBlock))\n+                        .orElse(false))\n+            .count();\n+\n+    return new BlockPerformance((int) numberOfIncludedBlocks, producedBlocks.size());\n+  }\n+\n+  private AttestationPerformance getAttestationPerformanceForEpoch(\n+      UInt64 currentEpoch, UInt64 analyzedEpoch) {\n+    checkArgument(\n+        analyzedEpoch.isLessThanOrEqualTo(currentEpoch.minus(ATTESTATION_INCLUSION_RANGE)),\n+        \"Epoch to analyze attestation performance must be at least 2 epochs less than the current epoch\");\n+    // Attestations can be included in either the epoch they were produced in or in\n+    // the following epoch. Thus, the most recent epoch for which we can evaluate attestation\n+    // performance is current epoch - 2.\n+    UInt64 analysisRangeEndEpoch = analyzedEpoch.plus(ATTESTATION_INCLUSION_RANGE);\n+\n+    // Get included attestations for the given epochs in a map from slot to attestations\n+    // included in block.\n+    Map<UInt64, List<Attestation>> attestationsIncludedOnChain =\n+        getAttestationsIncludedInEpochs(analyzedEpoch, analysisRangeEndEpoch);\n+\n+    // Get sent attestations in range\n+    Set<Attestation> producedAttestations =\n+        producedAttestationsByEpoch.getOrDefault(analyzedEpoch, new HashSet<>());\n+    BeaconState state = combinedChainDataClient.getBestState().orElseThrow();\n+\n+    int correctTargetCount = 0;\n+    int correctHeadBlockCount = 0;\n+    List<Integer> inclusionDistances = new ArrayList<>();\n+\n+    // Pre-process attestations included on chain to group them by\n+    // data hash to inclusion slot to aggregation bitlist\n+    Map<Bytes32, NavigableMap<UInt64, Bitlist>> slotAndBitlistsByAttestationDataHash =\n+        new HashMap<>();\n+    for (UInt64 slot : attestationsIncludedOnChain.keySet()) {\n+      for (Attestation attestation : attestationsIncludedOnChain.get(slot)) {\n+        Bytes32 attestationDataHash = attestation.getData().hash_tree_root();\n+        NavigableMap<UInt64, Bitlist> slotToBitlists =\n+            slotAndBitlistsByAttestationDataHash.computeIfAbsent(\n+                attestationDataHash, __ -> new TreeMap<>());\n+        slotToBitlists.put(slot, attestation.getAggregation_bits());\n+      }\n+    }\n+\n+    for (Attestation sentAttestation : producedAttestations) {\n+      Bytes32 sentAttestationDataHash = sentAttestation.getData().hash_tree_root();\n+      UInt64 sentAttestationSlot = sentAttestation.getData().getSlot();\n+      if (!slotAndBitlistsByAttestationDataHash.containsKey(sentAttestationDataHash)) continue;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a0cb333ccbd8cbeef08a461819390b58f991415d"}, "originalPosition": 186}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzA2NzA1NQ==", "bodyText": "Is this distinction between SettableIntGauge and SettableDoubleGauge actually useful?  Looks like under the hood the ints are converted to doubles anyway ...", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r497067055", "createdAt": "2020-09-29T21:21:14Z", "author": {"login": "mbaxter"}, "path": "infrastructure/metrics/src/main/java/tech/pegasys/teku/infrastructure/metrics/SettableIntGauge.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * Copyright 2019 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.infrastructure.metrics;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.hyperledger.besu.plugin.services.MetricsSystem;\n+import org.hyperledger.besu.plugin.services.metrics.MetricCategory;\n+\n+public class SettableIntGauge {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a0cb333ccbd8cbeef08a461819390b58f991415d"}, "originalPosition": 20}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7167d3cd589a9045a8b1a208f54e8905200ceaca", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/7167d3cd589a9045a8b1a208f54e8905200ceaca", "committedDate": "2020-10-01T16:17:12Z", "message": "Use AtomicReference instead of an AtomicLong"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d33102fde88535bae15a2180694e5be600783177", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/d33102fde88535bae15a2180694e5be600783177", "committedDate": "2020-10-01T16:17:12Z", "message": "Resolve comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3f1eec3f436541ee42a38488ecef0017986dc027", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/3f1eec3f436541ee42a38488ecef0017986dc027", "committedDate": "2020-10-01T16:17:12Z", "message": "Run spotless"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwNjQ0NzA3", "url": "https://github.com/ConsenSys/teku/pull/2772#pullrequestreview-500644707", "createdAt": "2020-10-01T19:14:52Z", "commit": {"oid": "3f1eec3f436541ee42a38488ecef0017986dc027"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxOToxNDo1M1rOHbXrPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQxOToyMTo1MFrOHbX4IA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ2MTUwMQ==", "bodyText": "I think we're now potentially processing blocks multiple times if there are skipped slots.  We need to update the slot based on the returned block's slot:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  if (currSlot.equals(UInt64.ZERO)) {\n          \n          \n            \n                    break;\n          \n          \n            \n                  }\n          \n          \n            \n                  currSlot = currSlot.decrement();\n          \n          \n            \n                  if (block.getSlot().equals(UInt64.ZERO)) {\n          \n          \n            \n                    break;\n          \n          \n            \n                  }\n          \n          \n            \n                  currSlot = block.getSlot().decrement();\n          \n      \n    \n    \n  \n\nWe should add a test that makes sure our calculations are correct when there are skipped slots.", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r498461501", "createdAt": "2020-10-01T19:14:53Z", "author": {"login": "mbaxter"}, "path": "validator/coordinator/src/main/java/tech/pegasys/teku/validator/coordinator/performance/DefaultPerformanceTracker.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.coordinator.performance;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_epoch_at_slot;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_start_slot_at_epoch;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root_at_slot;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.IntSummaryStatistics;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.operations.Attestation;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.infrastructure.logging.StatusLogger;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.ssz.SSZTypes.Bitlist;\n+import tech.pegasys.teku.storage.client.CombinedChainDataClient;\n+import tech.pegasys.teku.util.config.Constants;\n+\n+public class DefaultPerformanceTracker implements PerformanceTracker {\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<SignedBeaconBlock>> producedBlocksByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<Attestation>> producedAttestationsByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  static final UInt64 BLOCK_PERFORMANCE_EVALUATION_INTERVAL = UInt64.valueOf(2); // epochs\n+\n+  static final UInt64 ATTESTATION_INCLUSION_RANGE = UInt64.valueOf(2);\n+\n+  private final CombinedChainDataClient combinedChainDataClient;\n+  private final StatusLogger statusLogger;\n+  private final ValidatorPerformanceMetrics validatorPerformanceMetrics;\n+\n+  private Optional<UInt64> nodeStartEpoch = Optional.empty();\n+  private AtomicReference<UInt64> latestAnalyzedEpoch = new AtomicReference<>(UInt64.ZERO);\n+\n+  public DefaultPerformanceTracker(\n+      CombinedChainDataClient combinedChainDataClient,\n+      StatusLogger statusLogger,\n+      ValidatorPerformanceMetrics validatorPerformanceMetrics) {\n+    this.combinedChainDataClient = combinedChainDataClient;\n+    this.statusLogger = statusLogger;\n+    this.validatorPerformanceMetrics = validatorPerformanceMetrics;\n+  }\n+\n+  @Override\n+  public void start(UInt64 nodeStartSlot) {\n+    this.nodeStartEpoch = Optional.of(compute_epoch_at_slot(nodeStartSlot));\n+  }\n+\n+  @Override\n+  public void onSlot(UInt64 slot) {\n+    if (nodeStartEpoch.isEmpty()) {\n+      return;\n+    }\n+\n+    if (slot.mod(Constants.SLOTS_PER_EPOCH).isGreaterThan(UInt64.ZERO)) {\n+      return;\n+    }\n+\n+    UInt64 currentEpoch = compute_epoch_at_slot(slot);\n+    if (currentEpoch.isLessThanOrEqualTo(\n+        latestAnalyzedEpoch.getAndUpdate(\n+            val -> val.isLessThan(currentEpoch) ? currentEpoch : val))) {\n+      return;\n+    }\n+\n+    // Output attestation performance information for current epoch - 2 since attestations can be\n+    // included in both the epoch they were produced in or in the one following.\n+    if (currentEpoch.isGreaterThanOrEqualTo(\n+        nodeStartEpoch.get().plus(ATTESTATION_INCLUSION_RANGE))) {\n+      UInt64 analyzedEpoch = currentEpoch.minus(ATTESTATION_INCLUSION_RANGE);\n+      AttestationPerformance attestationPerformance =\n+          getAttestationPerformanceForEpoch(currentEpoch, analyzedEpoch);\n+      statusLogger.performance(attestationPerformance.toString());\n+      producedAttestationsByEpoch.headMap(analyzedEpoch, true).clear();\n+      validatorPerformanceMetrics.updateAttestationPerformanceMetrics(attestationPerformance);\n+    }\n+\n+    // Output block performance information for the past BLOCK_PERFORMANCE_INTERVAL epochs\n+    if (currentEpoch.isGreaterThanOrEqualTo(BLOCK_PERFORMANCE_EVALUATION_INTERVAL)) {\n+      if (currentEpoch.mod(BLOCK_PERFORMANCE_EVALUATION_INTERVAL).equals(UInt64.ZERO)) {\n+        UInt64 oldestAnalyzedEpoch = currentEpoch.minus(BLOCK_PERFORMANCE_EVALUATION_INTERVAL);\n+        BlockPerformance blockPerformance =\n+            getBlockPerformanceForEpochs(oldestAnalyzedEpoch, currentEpoch);\n+        if (blockPerformance.numberOfProducedBlocks > 0) {\n+          statusLogger.performance(blockPerformance.toString());\n+          producedBlocksByEpoch.headMap(oldestAnalyzedEpoch, true).clear();\n+          validatorPerformanceMetrics.updateBlockPerformanceMetrics(blockPerformance);\n+        }\n+      }\n+    }\n+  }\n+\n+  private BlockPerformance getBlockPerformanceForEpochs(\n+      UInt64 startEpochInclusive, UInt64 endEpochExclusive) {\n+    List<SignedBeaconBlock> producedBlocks =\n+        producedBlocksByEpoch.subMap(startEpochInclusive, true, endEpochExclusive, false).values()\n+            .stream()\n+            .flatMap(Collection::stream)\n+            .collect(Collectors.toList());\n+\n+    long numberOfIncludedBlocks =\n+        producedBlocks.stream()\n+            .filter(\n+                sentBlock ->\n+                    combinedChainDataClient\n+                        .getBlockAtSlotExact(sentBlock.getSlot())\n+                        .join()\n+                        .map(block -> block.equals(sentBlock))\n+                        .orElse(false))\n+            .count();\n+\n+    return new BlockPerformance((int) numberOfIncludedBlocks, producedBlocks.size());\n+  }\n+\n+  private AttestationPerformance getAttestationPerformanceForEpoch(\n+      UInt64 currentEpoch, UInt64 analyzedEpoch) {\n+    checkArgument(\n+        analyzedEpoch.isLessThanOrEqualTo(currentEpoch.minus(ATTESTATION_INCLUSION_RANGE)),\n+        \"Epoch to analyze attestation performance must be at least 2 epochs less than the current epoch\");\n+    // Attestations can be included in either the epoch they were produced in or in\n+    // the following epoch. Thus, the most recent epoch for which we can evaluate attestation\n+    // performance is current epoch - 2.\n+    UInt64 analysisRangeEndEpoch = analyzedEpoch.plus(ATTESTATION_INCLUSION_RANGE);\n+\n+    // Get included attestations for the given epochs in a map from slot to attestations\n+    // included in block.\n+    Map<UInt64, List<Attestation>> attestationsIncludedOnChain =\n+        getAttestationsIncludedInEpochs(analyzedEpoch, analysisRangeEndEpoch);\n+\n+    // Get sent attestations in range\n+    Set<Attestation> producedAttestations =\n+        producedAttestationsByEpoch.getOrDefault(analyzedEpoch, new HashSet<>());\n+    BeaconState state = combinedChainDataClient.getBestState().orElseThrow();\n+\n+    int correctTargetCount = 0;\n+    int correctHeadBlockCount = 0;\n+    List<Integer> inclusionDistances = new ArrayList<>();\n+\n+    // Pre-process attestations included on chain to group them by\n+    // data hash to inclusion slot to aggregation bitlist\n+    Map<Bytes32, NavigableMap<UInt64, Bitlist>> slotAndBitlistsByAttestationDataHash =\n+        new HashMap<>();\n+    for (UInt64 slot : attestationsIncludedOnChain.keySet()) {\n+      for (Attestation attestation : attestationsIncludedOnChain.get(slot)) {\n+        Bytes32 attestationDataHash = attestation.getData().hash_tree_root();\n+        NavigableMap<UInt64, Bitlist> slotToBitlists =\n+            slotAndBitlistsByAttestationDataHash.computeIfAbsent(\n+                attestationDataHash, __ -> new TreeMap<>());\n+        Bitlist bitlistToInsert = attestation.getAggregation_bits().copy();\n+        Bitlist alreadySetBits = slotToBitlists.get(slot);\n+        if (alreadySetBits != null) {\n+          bitlistToInsert.setAllBits(alreadySetBits);\n+        }\n+        slotToBitlists.put(slot, bitlistToInsert);\n+      }\n+    }\n+\n+    for (Attestation sentAttestation : producedAttestations) {\n+      Bytes32 sentAttestationDataHash = sentAttestation.getData().hash_tree_root();\n+      UInt64 sentAttestationSlot = sentAttestation.getData().getSlot();\n+      if (!slotAndBitlistsByAttestationDataHash.containsKey(sentAttestationDataHash)) {\n+        continue;\n+      }\n+      NavigableMap<UInt64, Bitlist> slotAndBitlists =\n+          slotAndBitlistsByAttestationDataHash.get(sentAttestationDataHash);\n+      for (UInt64 slot : slotAndBitlists.keySet()) {\n+        if (slotAndBitlists.get(slot).isSuperSetOf(sentAttestation.getAggregation_bits())) {\n+          inclusionDistances.add(slot.minus(sentAttestationSlot).intValue());\n+          break;\n+        }\n+      }\n+\n+      // Check if the attestation had correct target\n+      Bytes32 attestationTargetRoot = sentAttestation.getData().getTarget().getRoot();\n+      if (attestationTargetRoot.equals(get_block_root(state, analyzedEpoch))) {\n+        correctTargetCount++;\n+\n+        // Check if the attestation had correct head block root\n+        Bytes32 attestationHeadBlockRoot = sentAttestation.getData().getBeacon_block_root();\n+        if (attestationHeadBlockRoot.equals(get_block_root_at_slot(state, sentAttestationSlot))) {\n+          correctHeadBlockCount++;\n+        }\n+      }\n+    }\n+\n+    IntSummaryStatistics inclusionDistanceStatistics =\n+        inclusionDistances.stream().collect(Collectors.summarizingInt(Integer::intValue));\n+\n+    // IntSummaryStatistics returns Integer.MIN and MAX when the summarized integer list is empty.\n+    return producedAttestations.size() > 0\n+        ? new AttestationPerformance(\n+            producedAttestations.size(),\n+            (int) inclusionDistanceStatistics.getCount(),\n+            inclusionDistanceStatistics.getMax(),\n+            inclusionDistanceStatistics.getMin(),\n+            inclusionDistanceStatistics.getAverage(),\n+            correctTargetCount,\n+            correctHeadBlockCount)\n+        : AttestationPerformance.empty();\n+  }\n+\n+  private Set<BeaconBlock> getBlocksInEpochs(UInt64 startEpochInclusive, UInt64 endEpochExclusive) {\n+    UInt64 epochStartSlot = compute_start_slot_at_epoch(startEpochInclusive);\n+    UInt64 inclusiveEndEpochEndSlot = compute_start_slot_at_epoch(endEpochExclusive).decrement();\n+\n+    Set<BeaconBlock> blocksInEpoch = new HashSet<>();\n+    UInt64 currSlot = inclusiveEndEpochEndSlot;\n+    while (currSlot.isGreaterThanOrEqualTo(epochStartSlot)) {\n+      // PerformanceTracker should not be running if chain data is not available.\n+      BeaconBlock block =\n+          combinedChainDataClient\n+              .getBlockInEffectAtSlot(currSlot)\n+              .join()\n+              .orElseThrow()\n+              .getMessage();\n+      blocksInEpoch.add(block);\n+      if (currSlot.equals(UInt64.ZERO)) {\n+        break;\n+      }\n+      currSlot = currSlot.decrement();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3f1eec3f436541ee42a38488ecef0017986dc027"}, "originalPosition": 252}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ2NDgwMA==", "bodyText": "(nit) Might be a bit simpler (and perform less copying) with something like:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Bitlist bitlistToInsert = attestation.getAggregation_bits().copy();\n          \n          \n            \n                    Bitlist alreadySetBits = slotToBitlists.get(slot);\n          \n          \n            \n                    if (alreadySetBits != null) {\n          \n          \n            \n                      bitlistToInsert.setAllBits(alreadySetBits);\n          \n          \n            \n                    }\n          \n          \n            \n                    slotToBitlists.put(slot, bitlistToInsert);\n          \n          \n            \n                    Bitlist bitlist = slotToBitlists.computeIfAbsent(slot, attestation.getAggregation_bits()::copy);\n          \n          \n            \n                    bitlistToInsert.setAllBits(attestation.getAggregation_bits());", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r498464800", "createdAt": "2020-10-01T19:21:50Z", "author": {"login": "mbaxter"}, "path": "validator/coordinator/src/main/java/tech/pegasys/teku/validator/coordinator/performance/DefaultPerformanceTracker.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.validator.coordinator.performance;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_epoch_at_slot;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_start_slot_at_epoch;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root_at_slot;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.IntSummaryStatistics;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.operations.Attestation;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.infrastructure.logging.StatusLogger;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.ssz.SSZTypes.Bitlist;\n+import tech.pegasys.teku.storage.client.CombinedChainDataClient;\n+import tech.pegasys.teku.util.config.Constants;\n+\n+public class DefaultPerformanceTracker implements PerformanceTracker {\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<SignedBeaconBlock>> producedBlocksByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  final NavigableMap<UInt64, Set<Attestation>> producedAttestationsByEpoch = new TreeMap<>();\n+\n+  @VisibleForTesting\n+  static final UInt64 BLOCK_PERFORMANCE_EVALUATION_INTERVAL = UInt64.valueOf(2); // epochs\n+\n+  static final UInt64 ATTESTATION_INCLUSION_RANGE = UInt64.valueOf(2);\n+\n+  private final CombinedChainDataClient combinedChainDataClient;\n+  private final StatusLogger statusLogger;\n+  private final ValidatorPerformanceMetrics validatorPerformanceMetrics;\n+\n+  private Optional<UInt64> nodeStartEpoch = Optional.empty();\n+  private AtomicReference<UInt64> latestAnalyzedEpoch = new AtomicReference<>(UInt64.ZERO);\n+\n+  public DefaultPerformanceTracker(\n+      CombinedChainDataClient combinedChainDataClient,\n+      StatusLogger statusLogger,\n+      ValidatorPerformanceMetrics validatorPerformanceMetrics) {\n+    this.combinedChainDataClient = combinedChainDataClient;\n+    this.statusLogger = statusLogger;\n+    this.validatorPerformanceMetrics = validatorPerformanceMetrics;\n+  }\n+\n+  @Override\n+  public void start(UInt64 nodeStartSlot) {\n+    this.nodeStartEpoch = Optional.of(compute_epoch_at_slot(nodeStartSlot));\n+  }\n+\n+  @Override\n+  public void onSlot(UInt64 slot) {\n+    if (nodeStartEpoch.isEmpty()) {\n+      return;\n+    }\n+\n+    if (slot.mod(Constants.SLOTS_PER_EPOCH).isGreaterThan(UInt64.ZERO)) {\n+      return;\n+    }\n+\n+    UInt64 currentEpoch = compute_epoch_at_slot(slot);\n+    if (currentEpoch.isLessThanOrEqualTo(\n+        latestAnalyzedEpoch.getAndUpdate(\n+            val -> val.isLessThan(currentEpoch) ? currentEpoch : val))) {\n+      return;\n+    }\n+\n+    // Output attestation performance information for current epoch - 2 since attestations can be\n+    // included in both the epoch they were produced in or in the one following.\n+    if (currentEpoch.isGreaterThanOrEqualTo(\n+        nodeStartEpoch.get().plus(ATTESTATION_INCLUSION_RANGE))) {\n+      UInt64 analyzedEpoch = currentEpoch.minus(ATTESTATION_INCLUSION_RANGE);\n+      AttestationPerformance attestationPerformance =\n+          getAttestationPerformanceForEpoch(currentEpoch, analyzedEpoch);\n+      statusLogger.performance(attestationPerformance.toString());\n+      producedAttestationsByEpoch.headMap(analyzedEpoch, true).clear();\n+      validatorPerformanceMetrics.updateAttestationPerformanceMetrics(attestationPerformance);\n+    }\n+\n+    // Output block performance information for the past BLOCK_PERFORMANCE_INTERVAL epochs\n+    if (currentEpoch.isGreaterThanOrEqualTo(BLOCK_PERFORMANCE_EVALUATION_INTERVAL)) {\n+      if (currentEpoch.mod(BLOCK_PERFORMANCE_EVALUATION_INTERVAL).equals(UInt64.ZERO)) {\n+        UInt64 oldestAnalyzedEpoch = currentEpoch.minus(BLOCK_PERFORMANCE_EVALUATION_INTERVAL);\n+        BlockPerformance blockPerformance =\n+            getBlockPerformanceForEpochs(oldestAnalyzedEpoch, currentEpoch);\n+        if (blockPerformance.numberOfProducedBlocks > 0) {\n+          statusLogger.performance(blockPerformance.toString());\n+          producedBlocksByEpoch.headMap(oldestAnalyzedEpoch, true).clear();\n+          validatorPerformanceMetrics.updateBlockPerformanceMetrics(blockPerformance);\n+        }\n+      }\n+    }\n+  }\n+\n+  private BlockPerformance getBlockPerformanceForEpochs(\n+      UInt64 startEpochInclusive, UInt64 endEpochExclusive) {\n+    List<SignedBeaconBlock> producedBlocks =\n+        producedBlocksByEpoch.subMap(startEpochInclusive, true, endEpochExclusive, false).values()\n+            .stream()\n+            .flatMap(Collection::stream)\n+            .collect(Collectors.toList());\n+\n+    long numberOfIncludedBlocks =\n+        producedBlocks.stream()\n+            .filter(\n+                sentBlock ->\n+                    combinedChainDataClient\n+                        .getBlockAtSlotExact(sentBlock.getSlot())\n+                        .join()\n+                        .map(block -> block.equals(sentBlock))\n+                        .orElse(false))\n+            .count();\n+\n+    return new BlockPerformance((int) numberOfIncludedBlocks, producedBlocks.size());\n+  }\n+\n+  private AttestationPerformance getAttestationPerformanceForEpoch(\n+      UInt64 currentEpoch, UInt64 analyzedEpoch) {\n+    checkArgument(\n+        analyzedEpoch.isLessThanOrEqualTo(currentEpoch.minus(ATTESTATION_INCLUSION_RANGE)),\n+        \"Epoch to analyze attestation performance must be at least 2 epochs less than the current epoch\");\n+    // Attestations can be included in either the epoch they were produced in or in\n+    // the following epoch. Thus, the most recent epoch for which we can evaluate attestation\n+    // performance is current epoch - 2.\n+    UInt64 analysisRangeEndEpoch = analyzedEpoch.plus(ATTESTATION_INCLUSION_RANGE);\n+\n+    // Get included attestations for the given epochs in a map from slot to attestations\n+    // included in block.\n+    Map<UInt64, List<Attestation>> attestationsIncludedOnChain =\n+        getAttestationsIncludedInEpochs(analyzedEpoch, analysisRangeEndEpoch);\n+\n+    // Get sent attestations in range\n+    Set<Attestation> producedAttestations =\n+        producedAttestationsByEpoch.getOrDefault(analyzedEpoch, new HashSet<>());\n+    BeaconState state = combinedChainDataClient.getBestState().orElseThrow();\n+\n+    int correctTargetCount = 0;\n+    int correctHeadBlockCount = 0;\n+    List<Integer> inclusionDistances = new ArrayList<>();\n+\n+    // Pre-process attestations included on chain to group them by\n+    // data hash to inclusion slot to aggregation bitlist\n+    Map<Bytes32, NavigableMap<UInt64, Bitlist>> slotAndBitlistsByAttestationDataHash =\n+        new HashMap<>();\n+    for (UInt64 slot : attestationsIncludedOnChain.keySet()) {\n+      for (Attestation attestation : attestationsIncludedOnChain.get(slot)) {\n+        Bytes32 attestationDataHash = attestation.getData().hash_tree_root();\n+        NavigableMap<UInt64, Bitlist> slotToBitlists =\n+            slotAndBitlistsByAttestationDataHash.computeIfAbsent(\n+                attestationDataHash, __ -> new TreeMap<>());\n+        Bitlist bitlistToInsert = attestation.getAggregation_bits().copy();\n+        Bitlist alreadySetBits = slotToBitlists.get(slot);\n+        if (alreadySetBits != null) {\n+          bitlistToInsert.setAllBits(alreadySetBits);\n+        }\n+        slotToBitlists.put(slot, bitlistToInsert);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3f1eec3f436541ee42a38488ecef0017986dc027"}, "originalPosition": 186}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3ff3dfc3a02a6305dc3c23ff3f64aa725ace86ec", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/3ff3dfc3a02a6305dc3c23ff3f64aa725ace86ec", "committedDate": "2020-10-01T20:14:48Z", "message": "Simplify setting bitlist for slot"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "015ea5a09df08cbaa72d7f1c3e3644b5663ed21d", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/015ea5a09df08cbaa72d7f1c3e3644b5663ed21d", "committedDate": "2020-10-01T20:31:31Z", "message": "Resolve comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "989bd8af564998660428212de7554ebcd72c0886", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/989bd8af564998660428212de7554ebcd72c0886", "committedDate": "2020-10-01T20:31:59Z", "message": "Merge branch 'master' into outputValidatorPerformance"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwNzQxODM5", "url": "https://github.com/ConsenSys/teku/pull/2772#pullrequestreview-500741839", "createdAt": "2020-10-01T21:48:29Z", "commit": {"oid": "989bd8af564998660428212de7554ebcd72c0886"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQyMTo0ODozMFrOHbb3Tw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQyMTo0ODozMFrOHbb3Tw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODUzMDEyNw==", "bodyText": "Looks like we don't need this rename anymore :D", "url": "https://github.com/ConsenSys/teku/pull/2772#discussion_r498530127", "createdAt": "2020-10-01T21:48:30Z", "author": {"login": "mbaxter"}, "path": "infrastructure/metrics/src/main/java/tech/pegasys/teku/infrastructure/metrics/SettableDoubleGauge.java", "diffHunk": "@@ -17,19 +17,19 @@\n import org.hyperledger.besu.plugin.services.MetricsSystem;\n import org.hyperledger.besu.plugin.services.metrics.MetricCategory;\n \n-public class SettableGauge {\n+public class SettableDoubleGauge {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "989bd8af564998660428212de7554ebcd72c0886"}, "originalPosition": 5}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7e850e92935c923722c6cbc3f02f6b5f34577573", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/7e850e92935c923722c6cbc3f02f6b5f34577573", "committedDate": "2020-10-01T22:27:29Z", "message": "Revert redundant name change"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0b9904ef053319636254e5254cf92ad554187150", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/0b9904ef053319636254e5254cf92ad554187150", "committedDate": "2020-10-01T22:00:27Z", "message": "Merge branch 'master' into outputValidatorPerformance"}, "afterCommit": {"oid": "7e850e92935c923722c6cbc3f02f6b5f34577573", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/7e850e92935c923722c6cbc3f02f6b5f34577573", "committedDate": "2020-10-01T22:27:29Z", "message": "Revert redundant name change"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "64baa92bac7005738538e9822a72b197b1086176", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/64baa92bac7005738538e9822a72b197b1086176", "committedDate": "2020-10-01T22:27:45Z", "message": "Merge branch 'master' into outputValidatorPerformance"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3416, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}