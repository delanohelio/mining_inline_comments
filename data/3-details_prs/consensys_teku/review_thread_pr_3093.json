{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTExMDgwMjI1", "number": 3093, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQwOTo1MzowMVrOEyu2Zg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxMDoyODoxNVrOEyvuqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNjMxODQ2OnYy", "diffSide": "RIGHT", "path": "storage/src/main/java/tech/pegasys/teku/storage/server/rocksdb/RocksDbDatabase.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQwOTo1MzowMVrOHpiCWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxNDo1MzoyM1rOHpuJzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzMxMTMyMw==", "bodyText": "I'm a bit confused with different method names here: one return erliest 'Finalized' another returns earliest 'Historical'. Does it makes sense to give them the same name? Or I missing something?", "url": "https://github.com/ConsenSys/teku/pull/3093#discussion_r513311323", "createdAt": "2020-10-28T09:53:01Z", "author": {"login": "Nashatyrev"}, "path": "storage/src/main/java/tech/pegasys/teku/storage/server/rocksdb/RocksDbDatabase.java", "diffHunk": "@@ -318,6 +318,11 @@ public WeakSubjectivityState getWeakSubjectivityState() {\n     return finalizedDao.getFinalizedBlockAtSlot(slot);\n   }\n \n+  @Override\n+  public Optional<UInt64> getEarliestHistoricalBlockSlot() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbc56dbd644cdbeafae0aa2390f6d287d432ae39"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUwOTgzOQ==", "bodyText": "I thought it might be confusing to have an API named getEarliestFinalizedBlockSlot because it sounds like there's an earliest finalized block on chain, when really we're just want to know the earliest available block.  Probably a better name would be getEarliestAvailableBlockSlot - will update.", "url": "https://github.com/ConsenSys/teku/pull/3093#discussion_r513509839", "createdAt": "2020-10-28T14:53:23Z", "author": {"login": "mbaxter"}, "path": "storage/src/main/java/tech/pegasys/teku/storage/server/rocksdb/RocksDbDatabase.java", "diffHunk": "@@ -318,6 +318,11 @@ public WeakSubjectivityState getWeakSubjectivityState() {\n     return finalizedDao.getFinalizedBlockAtSlot(slot);\n   }\n \n+  @Override\n+  public Optional<UInt64> getEarliestHistoricalBlockSlot() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzMxMTMyMw=="}, "originalCommit": {"oid": "bbc56dbd644cdbeafae0aa2390f6d287d432ae39"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNjQ1MDc3OnYy", "diffSide": "RIGHT", "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/beaconchain/methods/BeaconBlocksByRangeMessageHandler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxMDoyNToxNFrOHpjUaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxNDo1NTozOFrOHpuRtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzMzMjMzMQ==", "bodyText": "Just to make sure: are we neglecting the case when we might have some blocks matching the request? I mean the case where earliestSlot < endSlot", "url": "https://github.com/ConsenSys/teku/pull/3093#discussion_r513332331", "createdAt": "2020-10-28T10:25:14Z", "author": {"login": "Nashatyrev"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/beaconchain/methods/BeaconBlocksByRangeMessageHandler.java", "diffHunk": "@@ -105,24 +105,45 @@ public void onIncomingMessage(\n     final UInt64 count = maxRequestSize.min(message.getCount());\n     final UInt64 endSlot = message.getStartSlot().plus(message.getStep().times(count)).minus(ONE);\n \n-    final UInt64 headBlockSlot =\n-        combinedChainDataClient.getBestBlock().map(SignedBeaconBlock::getSlot).orElse(ZERO);\n-    final NavigableMap<UInt64, Bytes32> hotRoots;\n-    if (combinedChainDataClient.isFinalized(endSlot)) {\n-      // All blocks are finalized so skip scanning the protoarray\n-      hotRoots = new TreeMap<>();\n-    } else {\n-      hotRoots =\n-          combinedChainDataClient.getAncestorRoots(\n-              message.getStartSlot(), message.getStep(), count);\n-    }\n-    // Don't send anything past the last slot found in protoarray to ensure blocks are consistent\n-    // If we didn't find any blocks in protoarray, every block in the range must be finalized\n-    // so we don't need to worry about inconsistent blocks\n-    final UInt64 headSlot = hotRoots.isEmpty() ? headBlockSlot : hotRoots.lastKey();\n-    return sendNextBlock(\n-        new RequestState(\n-            message.getStartSlot(), message.getStep(), count, headSlot, hotRoots, callback));\n+    return combinedChainDataClient\n+        .getEarliestHistoricalBlockSlot()\n+        .thenCompose(\n+            earliestSlot -> {\n+              if (earliestSlot.map(s -> s.isGreaterThan(message.getStartSlot())).orElse(true)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f45dcbc7f09c04a6f9861b0067a514d6436027c"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUxMTg2MA==", "bodyText": "Yeah, that's right.  If we return only later blocks within the range, the response could be interpreted to mean that the earlier slots are skipped blocks, when we don't know that.", "url": "https://github.com/ConsenSys/teku/pull/3093#discussion_r513511860", "createdAt": "2020-10-28T14:55:38Z", "author": {"login": "mbaxter"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/beaconchain/methods/BeaconBlocksByRangeMessageHandler.java", "diffHunk": "@@ -105,24 +105,45 @@ public void onIncomingMessage(\n     final UInt64 count = maxRequestSize.min(message.getCount());\n     final UInt64 endSlot = message.getStartSlot().plus(message.getStep().times(count)).minus(ONE);\n \n-    final UInt64 headBlockSlot =\n-        combinedChainDataClient.getBestBlock().map(SignedBeaconBlock::getSlot).orElse(ZERO);\n-    final NavigableMap<UInt64, Bytes32> hotRoots;\n-    if (combinedChainDataClient.isFinalized(endSlot)) {\n-      // All blocks are finalized so skip scanning the protoarray\n-      hotRoots = new TreeMap<>();\n-    } else {\n-      hotRoots =\n-          combinedChainDataClient.getAncestorRoots(\n-              message.getStartSlot(), message.getStep(), count);\n-    }\n-    // Don't send anything past the last slot found in protoarray to ensure blocks are consistent\n-    // If we didn't find any blocks in protoarray, every block in the range must be finalized\n-    // so we don't need to worry about inconsistent blocks\n-    final UInt64 headSlot = hotRoots.isEmpty() ? headBlockSlot : hotRoots.lastKey();\n-    return sendNextBlock(\n-        new RequestState(\n-            message.getStartSlot(), message.getStep(), count, headSlot, hotRoots, callback));\n+    return combinedChainDataClient\n+        .getEarliestHistoricalBlockSlot()\n+        .thenCompose(\n+            earliestSlot -> {\n+              if (earliestSlot.map(s -> s.isGreaterThan(message.getStartSlot())).orElse(true)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzMzMjMzMQ=="}, "originalCommit": {"oid": "0f45dcbc7f09c04a6f9861b0067a514d6436027c"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNjQ2MjQ4OnYy", "diffSide": "RIGHT", "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/beaconchain/methods/BeaconBlocksByRangeMessageHandler.java", "isResolved": false, "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxMDoyODoxNVrOHpjbyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxNzoyOToxM1rOHp1n7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzMzNDIxNw==", "bodyText": "Can you please comment why do we need to return the error instead of empty set? Doesn't this error mean that we totally have no any historical blocks (aka light client)?", "url": "https://github.com/ConsenSys/teku/pull/3093#discussion_r513334217", "createdAt": "2020-10-28T10:28:15Z", "author": {"login": "Nashatyrev"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/beaconchain/methods/BeaconBlocksByRangeMessageHandler.java", "diffHunk": "@@ -105,24 +105,47 @@ public void onIncomingMessage(\n     final UInt64 count = maxRequestSize.min(message.getCount());\n     final UInt64 endSlot = message.getStartSlot().plus(message.getStep().times(count)).minus(ONE);\n \n-    final UInt64 headBlockSlot =\n-        combinedChainDataClient.getBestBlock().map(SignedBeaconBlock::getSlot).orElse(ZERO);\n-    final NavigableMap<UInt64, Bytes32> hotRoots;\n-    if (combinedChainDataClient.isFinalized(endSlot)) {\n-      // All blocks are finalized so skip scanning the protoarray\n-      hotRoots = new TreeMap<>();\n-    } else {\n-      hotRoots =\n-          combinedChainDataClient.getAncestorRoots(\n-              message.getStartSlot(), message.getStep(), count);\n-    }\n-    // Don't send anything past the last slot found in protoarray to ensure blocks are consistent\n-    // If we didn't find any blocks in protoarray, every block in the range must be finalized\n-    // so we don't need to worry about inconsistent blocks\n-    final UInt64 headSlot = hotRoots.isEmpty() ? headBlockSlot : hotRoots.lastKey();\n-    return sendNextBlock(\n-        new RequestState(\n-            message.getStartSlot(), message.getStep(), count, headSlot, hotRoots, callback));\n+    return combinedChainDataClient\n+        .getEarliestHistoricalBlockSlot()\n+        .thenCompose(\n+            earliestSlot -> {\n+              if (earliestSlot.map(s -> s.isGreaterThan(message.getStartSlot())).orElse(true)) {\n+                // We're missing the first block so return an error\n+                return SafeFuture.failedFuture(\n+                    new RpcException.HistoricalDataUnavailableException(\n+                        \"Requested historical blocks are currently unavailable\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ee0eb110892f13c6b6c06aca94e9c2982ff6dd16"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUxNTE1Ng==", "bodyText": "Initially I had this returning an empty set.  But the problem is similar to the one mentioned above:  the receiving node could interpret this to mean that all of the blocks in this range were skipped.  It will be easier to write sync logic if we can disambiguate missing data from skipped blocks.", "url": "https://github.com/ConsenSys/teku/pull/3093#discussion_r513515156", "createdAt": "2020-10-28T14:59:26Z", "author": {"login": "mbaxter"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/beaconchain/methods/BeaconBlocksByRangeMessageHandler.java", "diffHunk": "@@ -105,24 +105,47 @@ public void onIncomingMessage(\n     final UInt64 count = maxRequestSize.min(message.getCount());\n     final UInt64 endSlot = message.getStartSlot().plus(message.getStep().times(count)).minus(ONE);\n \n-    final UInt64 headBlockSlot =\n-        combinedChainDataClient.getBestBlock().map(SignedBeaconBlock::getSlot).orElse(ZERO);\n-    final NavigableMap<UInt64, Bytes32> hotRoots;\n-    if (combinedChainDataClient.isFinalized(endSlot)) {\n-      // All blocks are finalized so skip scanning the protoarray\n-      hotRoots = new TreeMap<>();\n-    } else {\n-      hotRoots =\n-          combinedChainDataClient.getAncestorRoots(\n-              message.getStartSlot(), message.getStep(), count);\n-    }\n-    // Don't send anything past the last slot found in protoarray to ensure blocks are consistent\n-    // If we didn't find any blocks in protoarray, every block in the range must be finalized\n-    // so we don't need to worry about inconsistent blocks\n-    final UInt64 headSlot = hotRoots.isEmpty() ? headBlockSlot : hotRoots.lastKey();\n-    return sendNextBlock(\n-        new RequestState(\n-            message.getStartSlot(), message.getStep(), count, headSlot, hotRoots, callback));\n+    return combinedChainDataClient\n+        .getEarliestHistoricalBlockSlot()\n+        .thenCompose(\n+            earliestSlot -> {\n+              if (earliestSlot.map(s -> s.isGreaterThan(message.getStartSlot())).orElse(true)) {\n+                // We're missing the first block so return an error\n+                return SafeFuture.failedFuture(\n+                    new RpcException.HistoricalDataUnavailableException(\n+                        \"Requested historical blocks are currently unavailable\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzMzNDIxNw=="}, "originalCommit": {"oid": "ee0eb110892f13c6b6c06aca94e9c2982ff6dd16"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUyOTAwOA==", "bodyText": "We'll hit this case if we start up from a recent state.  Initially, we won't have any blocks prior to that state.  Planning to implement a backwards sync that will pull historical blocks prior to this state, but it will still take time to get all of those blocks so we need to handle the case where they're missing.", "url": "https://github.com/ConsenSys/teku/pull/3093#discussion_r513529008", "createdAt": "2020-10-28T15:16:29Z", "author": {"login": "mbaxter"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/beaconchain/methods/BeaconBlocksByRangeMessageHandler.java", "diffHunk": "@@ -105,24 +105,47 @@ public void onIncomingMessage(\n     final UInt64 count = maxRequestSize.min(message.getCount());\n     final UInt64 endSlot = message.getStartSlot().plus(message.getStep().times(count)).minus(ONE);\n \n-    final UInt64 headBlockSlot =\n-        combinedChainDataClient.getBestBlock().map(SignedBeaconBlock::getSlot).orElse(ZERO);\n-    final NavigableMap<UInt64, Bytes32> hotRoots;\n-    if (combinedChainDataClient.isFinalized(endSlot)) {\n-      // All blocks are finalized so skip scanning the protoarray\n-      hotRoots = new TreeMap<>();\n-    } else {\n-      hotRoots =\n-          combinedChainDataClient.getAncestorRoots(\n-              message.getStartSlot(), message.getStep(), count);\n-    }\n-    // Don't send anything past the last slot found in protoarray to ensure blocks are consistent\n-    // If we didn't find any blocks in protoarray, every block in the range must be finalized\n-    // so we don't need to worry about inconsistent blocks\n-    final UInt64 headSlot = hotRoots.isEmpty() ? headBlockSlot : hotRoots.lastKey();\n-    return sendNextBlock(\n-        new RequestState(\n-            message.getStartSlot(), message.getStep(), count, headSlot, hotRoots, callback));\n+    return combinedChainDataClient\n+        .getEarliestHistoricalBlockSlot()\n+        .thenCompose(\n+            earliestSlot -> {\n+              if (earliestSlot.map(s -> s.isGreaterThan(message.getStartSlot())).orElse(true)) {\n+                // We're missing the first block so return an error\n+                return SafeFuture.failedFuture(\n+                    new RpcException.HistoricalDataUnavailableException(\n+                        \"Requested historical blocks are currently unavailable\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzMzNDIxNw=="}, "originalCommit": {"oid": "ee0eb110892f13c6b6c06aca94e9c2982ff6dd16"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUzODE4OA==", "bodyText": "Generally I think that a requesting client shouldn't interpret the absence of blocks in a response as 'empty slots'. I think that one may consider the slots are indeed empty when it has two chained blocks (child -> parent) bounding those slots. (i.e. if and only if one see block[100] <- block[90] he may consider slots 91...99 as empty)\nI didn't find any strict rules in the spec with respect to this situation, but my hypothesis is that we should response with empty list. The similar (though not exact the same) way we would response with empty list if we are still syncing and have no requested blocks yet. IMO generally responding with error should denote some exceptional situation.\nAnyways this case seems worth clarifying in the spec", "url": "https://github.com/ConsenSys/teku/pull/3093#discussion_r513538188", "createdAt": "2020-10-28T15:28:00Z", "author": {"login": "Nashatyrev"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/beaconchain/methods/BeaconBlocksByRangeMessageHandler.java", "diffHunk": "@@ -105,24 +105,47 @@ public void onIncomingMessage(\n     final UInt64 count = maxRequestSize.min(message.getCount());\n     final UInt64 endSlot = message.getStartSlot().plus(message.getStep().times(count)).minus(ONE);\n \n-    final UInt64 headBlockSlot =\n-        combinedChainDataClient.getBestBlock().map(SignedBeaconBlock::getSlot).orElse(ZERO);\n-    final NavigableMap<UInt64, Bytes32> hotRoots;\n-    if (combinedChainDataClient.isFinalized(endSlot)) {\n-      // All blocks are finalized so skip scanning the protoarray\n-      hotRoots = new TreeMap<>();\n-    } else {\n-      hotRoots =\n-          combinedChainDataClient.getAncestorRoots(\n-              message.getStartSlot(), message.getStep(), count);\n-    }\n-    // Don't send anything past the last slot found in protoarray to ensure blocks are consistent\n-    // If we didn't find any blocks in protoarray, every block in the range must be finalized\n-    // so we don't need to worry about inconsistent blocks\n-    final UInt64 headSlot = hotRoots.isEmpty() ? headBlockSlot : hotRoots.lastKey();\n-    return sendNextBlock(\n-        new RequestState(\n-            message.getStartSlot(), message.getStep(), count, headSlot, hotRoots, callback));\n+    return combinedChainDataClient\n+        .getEarliestHistoricalBlockSlot()\n+        .thenCompose(\n+            earliestSlot -> {\n+              if (earliestSlot.map(s -> s.isGreaterThan(message.getStartSlot())).orElse(true)) {\n+                // We're missing the first block so return an error\n+                return SafeFuture.failedFuture(\n+                    new RpcException.HistoricalDataUnavailableException(\n+                        \"Requested historical blocks are currently unavailable\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzMzNDIxNw=="}, "originalCommit": {"oid": "ee0eb110892f13c6b6c06aca94e9c2982ff6dd16"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU0MDM3OA==", "bodyText": "BTW the exact chosen code 128 makes me think that probably other client uses it the same way?", "url": "https://github.com/ConsenSys/teku/pull/3093#discussion_r513540378", "createdAt": "2020-10-28T15:30:43Z", "author": {"login": "Nashatyrev"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/beaconchain/methods/BeaconBlocksByRangeMessageHandler.java", "diffHunk": "@@ -105,24 +105,47 @@ public void onIncomingMessage(\n     final UInt64 count = maxRequestSize.min(message.getCount());\n     final UInt64 endSlot = message.getStartSlot().plus(message.getStep().times(count)).minus(ONE);\n \n-    final UInt64 headBlockSlot =\n-        combinedChainDataClient.getBestBlock().map(SignedBeaconBlock::getSlot).orElse(ZERO);\n-    final NavigableMap<UInt64, Bytes32> hotRoots;\n-    if (combinedChainDataClient.isFinalized(endSlot)) {\n-      // All blocks are finalized so skip scanning the protoarray\n-      hotRoots = new TreeMap<>();\n-    } else {\n-      hotRoots =\n-          combinedChainDataClient.getAncestorRoots(\n-              message.getStartSlot(), message.getStep(), count);\n-    }\n-    // Don't send anything past the last slot found in protoarray to ensure blocks are consistent\n-    // If we didn't find any blocks in protoarray, every block in the range must be finalized\n-    // so we don't need to worry about inconsistent blocks\n-    final UInt64 headSlot = hotRoots.isEmpty() ? headBlockSlot : hotRoots.lastKey();\n-    return sendNextBlock(\n-        new RequestState(\n-            message.getStartSlot(), message.getStep(), count, headSlot, hotRoots, callback));\n+    return combinedChainDataClient\n+        .getEarliestHistoricalBlockSlot()\n+        .thenCompose(\n+            earliestSlot -> {\n+              if (earliestSlot.map(s -> s.isGreaterThan(message.getStartSlot())).orElse(true)) {\n+                // We're missing the first block so return an error\n+                return SafeFuture.failedFuture(\n+                    new RpcException.HistoricalDataUnavailableException(\n+                        \"Requested historical blocks are currently unavailable\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzMzNDIxNw=="}, "originalCommit": {"oid": "ee0eb110892f13c6b6c06aca94e9c2982ff6dd16"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU1Njc3MA==", "bodyText": "Yeah, we should clarify this in the spec - planning to open an issue or a PR.\nThe practical difference wrt the initial sync and missing recent blocks is that we have the Status message from our peers that tells us how far the chain has synced.  But there is no information on how much historical chain data is available.  I think ideally we would start sending the range of available blocks in the Status message, but we don't have that at the moment.", "url": "https://github.com/ConsenSys/teku/pull/3093#discussion_r513556770", "createdAt": "2020-10-28T15:50:52Z", "author": {"login": "mbaxter"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/beaconchain/methods/BeaconBlocksByRangeMessageHandler.java", "diffHunk": "@@ -105,24 +105,47 @@ public void onIncomingMessage(\n     final UInt64 count = maxRequestSize.min(message.getCount());\n     final UInt64 endSlot = message.getStartSlot().plus(message.getStep().times(count)).minus(ONE);\n \n-    final UInt64 headBlockSlot =\n-        combinedChainDataClient.getBestBlock().map(SignedBeaconBlock::getSlot).orElse(ZERO);\n-    final NavigableMap<UInt64, Bytes32> hotRoots;\n-    if (combinedChainDataClient.isFinalized(endSlot)) {\n-      // All blocks are finalized so skip scanning the protoarray\n-      hotRoots = new TreeMap<>();\n-    } else {\n-      hotRoots =\n-          combinedChainDataClient.getAncestorRoots(\n-              message.getStartSlot(), message.getStep(), count);\n-    }\n-    // Don't send anything past the last slot found in protoarray to ensure blocks are consistent\n-    // If we didn't find any blocks in protoarray, every block in the range must be finalized\n-    // so we don't need to worry about inconsistent blocks\n-    final UInt64 headSlot = hotRoots.isEmpty() ? headBlockSlot : hotRoots.lastKey();\n-    return sendNextBlock(\n-        new RequestState(\n-            message.getStartSlot(), message.getStep(), count, headSlot, hotRoots, callback));\n+    return combinedChainDataClient\n+        .getEarliestHistoricalBlockSlot()\n+        .thenCompose(\n+            earliestSlot -> {\n+              if (earliestSlot.map(s -> s.isGreaterThan(message.getStartSlot())).orElse(true)) {\n+                // We're missing the first block so return an error\n+                return SafeFuture.failedFuture(\n+                    new RpcException.HistoricalDataUnavailableException(\n+                        \"Requested historical blocks are currently unavailable\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzMzNDIxNw=="}, "originalCommit": {"oid": "ee0eb110892f13c6b6c06aca94e9c2982ff6dd16"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU1ODEyNg==", "bodyText": "128 is the start of the custom error code range:\n\nClients MAY use response codes above 128 to indicate alternative, erroneous request-specific responses.\nThe range [3, 127] is RESERVED for future usages, and should be treated as error if not recognized expressly.", "url": "https://github.com/ConsenSys/teku/pull/3093#discussion_r513558126", "createdAt": "2020-10-28T15:52:34Z", "author": {"login": "mbaxter"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/beaconchain/methods/BeaconBlocksByRangeMessageHandler.java", "diffHunk": "@@ -105,24 +105,47 @@ public void onIncomingMessage(\n     final UInt64 count = maxRequestSize.min(message.getCount());\n     final UInt64 endSlot = message.getStartSlot().plus(message.getStep().times(count)).minus(ONE);\n \n-    final UInt64 headBlockSlot =\n-        combinedChainDataClient.getBestBlock().map(SignedBeaconBlock::getSlot).orElse(ZERO);\n-    final NavigableMap<UInt64, Bytes32> hotRoots;\n-    if (combinedChainDataClient.isFinalized(endSlot)) {\n-      // All blocks are finalized so skip scanning the protoarray\n-      hotRoots = new TreeMap<>();\n-    } else {\n-      hotRoots =\n-          combinedChainDataClient.getAncestorRoots(\n-              message.getStartSlot(), message.getStep(), count);\n-    }\n-    // Don't send anything past the last slot found in protoarray to ensure blocks are consistent\n-    // If we didn't find any blocks in protoarray, every block in the range must be finalized\n-    // so we don't need to worry about inconsistent blocks\n-    final UInt64 headSlot = hotRoots.isEmpty() ? headBlockSlot : hotRoots.lastKey();\n-    return sendNextBlock(\n-        new RequestState(\n-            message.getStartSlot(), message.getStep(), count, headSlot, hotRoots, callback));\n+    return combinedChainDataClient\n+        .getEarliestHistoricalBlockSlot()\n+        .thenCompose(\n+            earliestSlot -> {\n+              if (earliestSlot.map(s -> s.isGreaterThan(message.getStartSlot())).orElse(true)) {\n+                // We're missing the first block so return an error\n+                return SafeFuture.failedFuture(\n+                    new RpcException.HistoricalDataUnavailableException(\n+                        \"Requested historical blocks are currently unavailable\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzMzNDIxNw=="}, "originalCommit": {"oid": "ee0eb110892f13c6b6c06aca94e9c2982ff6dd16"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU2MjI4NQ==", "bodyText": "Just one more comment: I suppose that a client is free to respond with any subset of valid blocks which satisfy request criteria", "url": "https://github.com/ConsenSys/teku/pull/3093#discussion_r513562285", "createdAt": "2020-10-28T15:57:38Z", "author": {"login": "Nashatyrev"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/beaconchain/methods/BeaconBlocksByRangeMessageHandler.java", "diffHunk": "@@ -105,24 +105,47 @@ public void onIncomingMessage(\n     final UInt64 count = maxRequestSize.min(message.getCount());\n     final UInt64 endSlot = message.getStartSlot().plus(message.getStep().times(count)).minus(ONE);\n \n-    final UInt64 headBlockSlot =\n-        combinedChainDataClient.getBestBlock().map(SignedBeaconBlock::getSlot).orElse(ZERO);\n-    final NavigableMap<UInt64, Bytes32> hotRoots;\n-    if (combinedChainDataClient.isFinalized(endSlot)) {\n-      // All blocks are finalized so skip scanning the protoarray\n-      hotRoots = new TreeMap<>();\n-    } else {\n-      hotRoots =\n-          combinedChainDataClient.getAncestorRoots(\n-              message.getStartSlot(), message.getStep(), count);\n-    }\n-    // Don't send anything past the last slot found in protoarray to ensure blocks are consistent\n-    // If we didn't find any blocks in protoarray, every block in the range must be finalized\n-    // so we don't need to worry about inconsistent blocks\n-    final UInt64 headSlot = hotRoots.isEmpty() ? headBlockSlot : hotRoots.lastKey();\n-    return sendNextBlock(\n-        new RequestState(\n-            message.getStartSlot(), message.getStep(), count, headSlot, hotRoots, callback));\n+    return combinedChainDataClient\n+        .getEarliestHistoricalBlockSlot()\n+        .thenCompose(\n+            earliestSlot -> {\n+              if (earliestSlot.map(s -> s.isGreaterThan(message.getStartSlot())).orElse(true)) {\n+                // We're missing the first block so return an error\n+                return SafeFuture.failedFuture(\n+                    new RpcException.HistoricalDataUnavailableException(\n+                        \"Requested historical blocks are currently unavailable\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzMzNDIxNw=="}, "originalCommit": {"oid": "ee0eb110892f13c6b6c06aca94e9c2982ff6dd16"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU3MDE5NQ==", "bodyText": "The spec has the following constraints:\n\nClients MUST respond with at least the first block that exists in the range, if they have it, and no more than MAX_REQUEST_BLOCKS blocks.\nThe following blocks, where they exist, MUST be sent in consecutive order.\n\nWhich I interpret to mean that you need to start at the first block in the range, but that isn't 100% clear.", "url": "https://github.com/ConsenSys/teku/pull/3093#discussion_r513570195", "createdAt": "2020-10-28T16:06:57Z", "author": {"login": "mbaxter"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/beaconchain/methods/BeaconBlocksByRangeMessageHandler.java", "diffHunk": "@@ -105,24 +105,47 @@ public void onIncomingMessage(\n     final UInt64 count = maxRequestSize.min(message.getCount());\n     final UInt64 endSlot = message.getStartSlot().plus(message.getStep().times(count)).minus(ONE);\n \n-    final UInt64 headBlockSlot =\n-        combinedChainDataClient.getBestBlock().map(SignedBeaconBlock::getSlot).orElse(ZERO);\n-    final NavigableMap<UInt64, Bytes32> hotRoots;\n-    if (combinedChainDataClient.isFinalized(endSlot)) {\n-      // All blocks are finalized so skip scanning the protoarray\n-      hotRoots = new TreeMap<>();\n-    } else {\n-      hotRoots =\n-          combinedChainDataClient.getAncestorRoots(\n-              message.getStartSlot(), message.getStep(), count);\n-    }\n-    // Don't send anything past the last slot found in protoarray to ensure blocks are consistent\n-    // If we didn't find any blocks in protoarray, every block in the range must be finalized\n-    // so we don't need to worry about inconsistent blocks\n-    final UInt64 headSlot = hotRoots.isEmpty() ? headBlockSlot : hotRoots.lastKey();\n-    return sendNextBlock(\n-        new RequestState(\n-            message.getStartSlot(), message.getStep(), count, headSlot, hotRoots, callback));\n+    return combinedChainDataClient\n+        .getEarliestHistoricalBlockSlot()\n+        .thenCompose(\n+            earliestSlot -> {\n+              if (earliestSlot.map(s -> s.isGreaterThan(message.getStartSlot())).orElse(true)) {\n+                // We're missing the first block so return an error\n+                return SafeFuture.failedFuture(\n+                    new RpcException.HistoricalDataUnavailableException(\n+                        \"Requested historical blocks are currently unavailable\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzMzNDIxNw=="}, "originalCommit": {"oid": "ee0eb110892f13c6b6c06aca94e9c2982ff6dd16"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzMjIzNw==", "bodyText": "Which I interpret to mean that you need to start at the first block in the range, but that isn't 100% clear.\n\nYep looks like this statement may allow different treatments\n..., if they have it, ... :)", "url": "https://github.com/ConsenSys/teku/pull/3093#discussion_r513632237", "createdAt": "2020-10-28T17:29:13Z", "author": {"login": "Nashatyrev"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/rpc/beaconchain/methods/BeaconBlocksByRangeMessageHandler.java", "diffHunk": "@@ -105,24 +105,47 @@ public void onIncomingMessage(\n     final UInt64 count = maxRequestSize.min(message.getCount());\n     final UInt64 endSlot = message.getStartSlot().plus(message.getStep().times(count)).minus(ONE);\n \n-    final UInt64 headBlockSlot =\n-        combinedChainDataClient.getBestBlock().map(SignedBeaconBlock::getSlot).orElse(ZERO);\n-    final NavigableMap<UInt64, Bytes32> hotRoots;\n-    if (combinedChainDataClient.isFinalized(endSlot)) {\n-      // All blocks are finalized so skip scanning the protoarray\n-      hotRoots = new TreeMap<>();\n-    } else {\n-      hotRoots =\n-          combinedChainDataClient.getAncestorRoots(\n-              message.getStartSlot(), message.getStep(), count);\n-    }\n-    // Don't send anything past the last slot found in protoarray to ensure blocks are consistent\n-    // If we didn't find any blocks in protoarray, every block in the range must be finalized\n-    // so we don't need to worry about inconsistent blocks\n-    final UInt64 headSlot = hotRoots.isEmpty() ? headBlockSlot : hotRoots.lastKey();\n-    return sendNextBlock(\n-        new RequestState(\n-            message.getStartSlot(), message.getStep(), count, headSlot, hotRoots, callback));\n+    return combinedChainDataClient\n+        .getEarliestHistoricalBlockSlot()\n+        .thenCompose(\n+            earliestSlot -> {\n+              if (earliestSlot.map(s -> s.isGreaterThan(message.getStartSlot())).orElse(true)) {\n+                // We're missing the first block so return an error\n+                return SafeFuture.failedFuture(\n+                    new RpcException.HistoricalDataUnavailableException(\n+                        \"Requested historical blocks are currently unavailable\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzMzNDIxNw=="}, "originalCommit": {"oid": "ee0eb110892f13c6b6c06aca94e9c2982ff6dd16"}, "originalPosition": 30}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3106, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}