{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI5NjkwNDc2", "number": 3336, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxODo0MzoxMlrOE_Si9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxOToxMjowM1rOE_TNzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0Nzk5NjA2OnYy", "diffSide": "RIGHT", "path": "ssz/src/main/java/tech/pegasys/teku/ssz/backing/tree/GIndexUtil.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxODo0MzoxMlrOH86xmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxODo0MzoxMlrOH86xmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzYzOTU3Ng==", "bodyText": "Should we assert childDepth >= 0 as well?", "url": "https://github.com/ConsenSys/teku/pull/3336#discussion_r533639576", "createdAt": "2020-12-01T18:43:12Z", "author": {"login": "mbaxter"}, "path": "ssz/src/main/java/tech/pegasys/teku/ssz/backing/tree/GIndexUtil.java", "diffHunk": "@@ -0,0 +1,281 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.ssz.backing.tree;\n+\n+import static java.lang.Integer.min;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+\n+/**\n+ * Util methods for binary tree generalized indexes manipulations See\n+ * https://github.com/ethereum/eth2.0-specs/blob/v1.0.0/ssz/merkle-proofs.md#generalized-merkle-tree-index\n+ * for more info on generalized indexes\n+ *\n+ * <p>Here the general index is represented by <code>long</code> which is treated as unsigned uint64\n+ * Thus the only illegal generalized index value is <code>0</code>\n+ */\n+class GIndexUtil {\n+\n+  /** See {@link #gIdxCompare(long, long)} */\n+  public enum NodeRelation {\n+    Left,\n+    Right,\n+    Successor,\n+    Predecessor,\n+    Same;\n+\n+    /** <code>gIdxCompare(idx1, idx2) == gIdxCompare(idx2, idx1).inverse()</code> */\n+    public NodeRelation inverse() {\n+      switch (this) {\n+        case Left:\n+          return Right;\n+        case Right:\n+          return Left;\n+        case Predecessor:\n+          return Successor;\n+        case Successor:\n+          return Predecessor;\n+        case Same:\n+          return Same;\n+        default:\n+          throw new IllegalArgumentException(\"Unknown: \" + this);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * The generalized index of either a root tree node or an index of a node relative to the node\n+   * itself. Effectively this is <code>1L</code>\n+   */\n+  static final long SELF_G_INDEX = 1;\n+\n+  /**\n+   * The generalized index (normally an index of non-existing node) of the leftmost possible node\n+   * Effectively this is {@link Long#MIN_VALUE} or <code>0b10000...000L</code> in binary form\n+   */\n+  static final long LEFTMOST_G_INDEX = gIdxLeftmostFrom(SELF_G_INDEX);\n+  /**\n+   * The generalized index (normally an index of non-existing node) of the rightmost possible node\n+   * Effectively this is <code>-1L</code> or <code>0b11111...111L</code> in binary form\n+   */\n+  static final long RIGHTMOST_G_INDEX = gIdxRightmostFrom(SELF_G_INDEX);\n+\n+  /**\n+   * Indicates that a relative generalized index refers to the node itself\n+   *\n+   * @see #SELF_G_INDEX\n+   */\n+  public static boolean gIdxIsSelf(long generalizedIndex) {\n+    checkGIndex(generalizedIndex);\n+    return generalizedIndex == SELF_G_INDEX;\n+  }\n+\n+  /**\n+   * Indicates how the node with generalized index <code>idx1</code> relates to the node with\n+   * generalized index <code>idx2</code>:\n+   *\n+   * <ul>\n+   *   <li>{@link NodeRelation#Left}: idx1 is to the left of idx2\n+   *   <li>{@link NodeRelation#Right}: idx1 is to the right of idx2\n+   *   <li>{@link NodeRelation#Successor}: idx1 is the successor of idx2\n+   *   <li>{@link NodeRelation#Predecessor}: idx1 is the predecessor of idx2\n+   *   <li>{@link NodeRelation#Same}: idx1 is equal to idx2\n+   * </ul>\n+   */\n+  public static NodeRelation gIdxCompare(long idx1, long idx2) {\n+    checkGIndex(idx1);\n+    checkGIndex(idx2);\n+    long anchor1 = Long.highestOneBit(idx1);\n+    long anchor2 = Long.highestOneBit(idx2);\n+    int depth1 = Long.bitCount(anchor1 - 1);\n+    int depth2 = Long.bitCount(anchor2 - 1);\n+    int minDepth = min(depth1, depth2);\n+    long minDepthIdx1 = idx1 >>> (depth1 - minDepth);\n+    long minDepthIdx2 = idx2 >>> (depth2 - minDepth);\n+    if (minDepthIdx1 == minDepthIdx2) {\n+      if (depth1 < depth2) {\n+        return NodeRelation.Predecessor;\n+      } else if (depth1 > depth2) {\n+        return NodeRelation.Successor;\n+      } else {\n+        return NodeRelation.Same;\n+      }\n+    } else {\n+      if (minDepthIdx1 < minDepthIdx2) {\n+        return NodeRelation.Left;\n+      } else {\n+        return NodeRelation.Right;\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Returns the depth of the node denoted by the supplied generalized index. E.g. the depth of the\n+   * {@link #SELF_G_INDEX} would be 0\n+   */\n+  public static int gIdxGetDepth(long generalizedIndex) {\n+    checkGIndex(generalizedIndex);\n+    long anchor = Long.highestOneBit(generalizedIndex);\n+    return Long.bitCount(anchor - 1);\n+  }\n+\n+  /**\n+   * Returns the generalized index of the left child of the node with specified generalized index\n+   * E.g. the result when passing {@link #SELF_G_INDEX} would be <code>10</code>\n+   */\n+  public static long gIdxLeftGIndex(long generalizedIndex) {\n+    return gIdxChildGIndex(generalizedIndex, 0, 1);\n+  }\n+\n+  /**\n+   * Returns the generalized index of the right child of the node with specified generalized index\n+   * E.g. the result when passing {@link #SELF_G_INDEX} would be <code>11</code>\n+   */\n+  public static long gIdxRightGIndex(long generalizedIndex) {\n+    return gIdxChildGIndex(generalizedIndex, 1, 1);\n+  }\n+\n+  /**\n+   * More generic variant of methods {@link #gIdxLeftGIndex(long)} {@link #gIdxRightGIndex(long)}\n+   * Calculates the generalized index of a node's <code>childIdx</code> successor at depth <code>\n+   * childDepth</code> (depth relative to the original node). Note that <code>childIdx</code> is not\n+   * the generalized index but index number of child.\n+   *\n+   * <p>For example:\n+   *\n+   * <ul>\n+   *   <li><code>gIdxChildGIndex(SELF_G_INDEX, 0, 2) == 100</code>\n+   *   <li><code>gIdxChildGIndex(SELF_G_INDEX, 1, 2) == 101</code>\n+   *   <li><code>gIdxChildGIndex(SELF_G_INDEX, 2, 2) == 110</code>\n+   *   <li><code>gIdxChildGIndex(SELF_G_INDEX, 3, 2) == 111</code>\n+   *   <li><code>gIdxChildGIndex(SELF_G_INDEX, 4, 2) is invalid cause there are just 4 successors\n+   *   at depth 2</code>\n+   *   <li><code>gIdxChildGIndex(anyIndex, 0, 1) == gIdxLeftGIndex(anyIndex)</code>\n+   *   <li><code>gIdxChildGIndex(anyIndex, 1, 1) == gIdxRightGIndex(anyIndex)</code>\n+   * </ul>\n+   */\n+  public static long gIdxChildGIndex(long generalizedIndex, int childIdx, int childDepth) {\n+    checkGIndex(generalizedIndex);\n+    assert childDepth >= 0 && childDepth < 64;\n+    assert childIdx >= 0;\n+    assert childIdx < (1 << childDepth);\n+    assert gIdxGetDepth(generalizedIndex) + childDepth < 64;\n+    return (generalizedIndex << childDepth) | childIdx;\n+  }\n+\n+  /**\n+   * Returns the generalized index (normally an index of non-existing node) of the leftmost possible\n+   * successor of this node\n+   *\n+   * <p>For example:\n+   *\n+   * <ul>\n+   *   <li><code>gIdxLeftmostFrom(0b1100) == 0b110000000...00L</code>\n+   *   <li><code>gIdxLeftmostFrom(0b1101) == 0b110100000...00L</code>\n+   * </ul>\n+   */\n+  public static long gIdxLeftmostFrom(long fromGeneralizedIndex) {\n+    checkGIndex(fromGeneralizedIndex);\n+    long highestOneBit = Long.highestOneBit(fromGeneralizedIndex);\n+    if (highestOneBit < 0) {\n+      return fromGeneralizedIndex;\n+    } else {\n+      int nodeDepth = Long.bitCount(highestOneBit - 1);\n+      return fromGeneralizedIndex << (63 - nodeDepth);\n+    }\n+  }\n+\n+  /**\n+   * Returns the generalized index (normally an index of non-existing node) of the rightmost\n+   * possible successor of this node\n+   *\n+   * <p>For example:\n+   *\n+   * <ul>\n+   *   <li><code>gIdxRightmostFrom(0b1100) == 0b110011111...11L</code>\n+   *   <li><code>gIdxRightmostFrom(0b1101) == 0b110111111...11L</code>\n+   * </ul>\n+   */\n+  public static long gIdxRightmostFrom(long fromGeneralizedIndex) {\n+    checkGIndex(fromGeneralizedIndex);\n+    long highestOneBit = Long.highestOneBit(fromGeneralizedIndex);\n+    if (highestOneBit < 0) {\n+      return fromGeneralizedIndex;\n+    } else {\n+      int nodeDepth = Long.bitCount(highestOneBit - 1);\n+      int shiftN = 63 - nodeDepth;\n+      return (fromGeneralizedIndex << shiftN) | ((1L << shiftN) - 1);\n+    }\n+  }\n+\n+  /**\n+   * Returns the index number (not a generalized index) of a node at depth <code>childDepth</code>\n+   * which is a predecessor of or equal to the node at <code>generalizedIndex</code>\n+   *\n+   * <p>For example:\n+   *\n+   * <ul>\n+   *   <li><code>gIdxGetChildIndex(LEFTMOST_G_INDEX, anyDepth) == 0</code>\n+   *   <li><code>gIdxGetChildIndex(0b1100, 2) == 2</code>\n+   *   <li><code>gIdxGetChildIndex(0b1101, 2) == 2</code>\n+   *   <li><code>gIdxGetChildIndex(0b1110, 2) == 3</code>\n+   *   <li><code>gIdxGetChildIndex(0b1111, 2) == 3</code>\n+   *   <li><code>gIdxGetChildIndex(0b11, 2)</code> call would be invalid cause node with index 0b11\n+   *       is at depth 1\n+   * </ul>\n+   */\n+  public static int gIdxGetChildIndex(long generalizedIndex, int childDepth) {\n+    checkGIndex(generalizedIndex);\n+    assert childDepth < 64;\n+\n+    long anchor = Long.highestOneBit(generalizedIndex);\n+    int indexBitCount = Long.bitCount(anchor - 1);\n+    assert indexBitCount >= childDepth;\n+    long generalizedIndexWithoutAnchor = generalizedIndex ^ anchor;\n+    return (int) (generalizedIndexWithoutAnchor >>> (indexBitCount - childDepth));\n+  }\n+\n+  /**\n+   * Returns the generalized index of the node at <code>generalizedIndex</code> relative to its\n+   * predecessor at depth <code>childDepth</code> For example:\n+   *\n+   * <ul>\n+   *   <li><code>gIdxGetRelativeGIndex(0b1100, 2) == 0b10</code>\n+   *   <li><code>gIdxGetChildIndex(0b1101, 2) == 0b11</code>\n+   *   <li><code>gIdxGetChildIndex(0b1110, 2) == 0b10</code>\n+   *   <li><code>gIdxGetChildIndex(0b1111, 3) == SELF_G_INDEX</code>\n+   *   <li><code>gIdxGetChildIndex(0b11, 2)</code> call would be invalid cause node with index 0b11\n+   *       is at depth 1\n+   * </ul>\n+   */\n+  public static long gIdxGetRelativeGIndex(long generalizedIndex, int childDepth) {\n+    checkGIndex(generalizedIndex);\n+    assert childDepth < 64;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac3d3bf2376bb91b2e8937efaeda5d8339e9d319"}, "originalPosition": 264}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0ODEwNTcyOnYy", "diffSide": "RIGHT", "path": "ssz/src/main/java/tech/pegasys/teku/ssz/backing/tree/TreeUpdates.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxOToxMjowM1rOH8710w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxMToyNjozMVrOH9WhMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY1NzA0Mw==", "bodyText": "Looks like this is unused", "url": "https://github.com/ConsenSys/teku/pull/3336#discussion_r533657043", "createdAt": "2020-12-01T19:12:03Z", "author": {"login": "mbaxter"}, "path": "ssz/src/main/java/tech/pegasys/teku/ssz/backing/tree/TreeUpdates.java", "diffHunk": "@@ -105,25 +116,52 @@ private TreeUpdates(List<Long> gIndexes, List<TreeNode> nodes, long prefix, int\n     int idx = Collections.binarySearch(gIndexes, pivotGIndex);\n     int insIdx = idx < 0 ? -idx - 1 : idx;\n     return Pair.of(\n-        new TreeUpdates(\n+        TreeUpdates.create(\n             gIndexes.subList(0, insIdx), nodes.subList(0, insIdx), lPrefix, heightFromLeaf - 1),\n-        new TreeUpdates(\n+        TreeUpdates.create(\n             gIndexes.subList(insIdx, gIndexes.size()),\n             nodes.subList(insIdx, nodes.size()),\n             rPrefix,\n             heightFromLeaf - 1));\n   }\n \n+  public List<TreeUpdates> splitToDepth(int depth) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac3d3bf2376bb91b2e8937efaeda5d8339e9d319"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDA5NDEzMA==", "bodyText": "Yep, removing it for now", "url": "https://github.com/ConsenSys/teku/pull/3336#discussion_r534094130", "createdAt": "2020-12-02T11:26:31Z", "author": {"login": "Nashatyrev"}, "path": "ssz/src/main/java/tech/pegasys/teku/ssz/backing/tree/TreeUpdates.java", "diffHunk": "@@ -105,25 +116,52 @@ private TreeUpdates(List<Long> gIndexes, List<TreeNode> nodes, long prefix, int\n     int idx = Collections.binarySearch(gIndexes, pivotGIndex);\n     int insIdx = idx < 0 ? -idx - 1 : idx;\n     return Pair.of(\n-        new TreeUpdates(\n+        TreeUpdates.create(\n             gIndexes.subList(0, insIdx), nodes.subList(0, insIdx), lPrefix, heightFromLeaf - 1),\n-        new TreeUpdates(\n+        TreeUpdates.create(\n             gIndexes.subList(insIdx, gIndexes.size()),\n             nodes.subList(insIdx, nodes.size()),\n             rPrefix,\n             heightFromLeaf - 1));\n   }\n \n+  public List<TreeUpdates> splitToDepth(int depth) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY1NzA0Mw=="}, "originalCommit": {"oid": "ac3d3bf2376bb91b2e8937efaeda5d8339e9d319"}, "originalPosition": 41}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2898, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}