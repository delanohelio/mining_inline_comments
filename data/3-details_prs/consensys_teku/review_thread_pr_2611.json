{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY5NzUzNzA4", "number": 2611, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMzoyOTo1NlrOEZsdpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMzo0NToxNFrOEZsqdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1Mzc4MzQwOnYy", "diffSide": "RIGHT", "path": "services/beaconchain/src/main/java/tech/pegasys/teku/services/beaconchain/BeaconChainController.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMzoyOTo1NlrOHCqG1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQwMjo1NzoyNlrOHCuhLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjU0OTA3OQ==", "bodyText": "I'm still in two minds but I wonder if we should just make StoreOptions an interface that TekuConfiguration implements, then we don't have to rebuild a different config object, but still narrow down what gets passed in.  It already does it for MetricsConfig which I think was mostly driven by module dependencies but it seems to work (and eventually TekuConfiguration could just hold multiple separate objects so you getMetricsConfig out of it instead of using it directly.\nHappy to go either way with this at the moment though.", "url": "https://github.com/ConsenSys/teku/pull/2611#discussion_r472549079", "createdAt": "2020-08-18T23:29:56Z", "author": {"login": "ajsutton"}, "path": "services/beaconchain/src/main/java/tech/pegasys/teku/services/beaconchain/BeaconChainController.java", "diffHunk": "@@ -175,8 +176,13 @@ private void startServices() {\n   }\n \n   private SafeFuture<?> initialize() {\n+    final StoreOptions storeOptions =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e10b5d5ab59986c1b4b8f0b3c9a7666d052e22a"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjU4ODc3Ng==", "bodyText": "I don't think that works because it would create circular dependencies:  storage depends on util, so util can't depend on storage.", "url": "https://github.com/ConsenSys/teku/pull/2611#discussion_r472588776", "createdAt": "2020-08-19T01:52:03Z", "author": {"login": "mbaxter"}, "path": "services/beaconchain/src/main/java/tech/pegasys/teku/services/beaconchain/BeaconChainController.java", "diffHunk": "@@ -175,8 +176,13 @@ private void startServices() {\n   }\n \n   private SafeFuture<?> initialize() {\n+    final StoreOptions storeOptions =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjU0OTA3OQ=="}, "originalCommit": {"oid": "1e10b5d5ab59986c1b4b8f0b3c9a7666d052e22a"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjYyMTM1OQ==", "bodyText": "Ugh.  Yeah we'd probably have to define StoreConfig in util.  Not worth the fight now I don't think.", "url": "https://github.com/ConsenSys/teku/pull/2611#discussion_r472621359", "createdAt": "2020-08-19T02:57:26Z", "author": {"login": "ajsutton"}, "path": "services/beaconchain/src/main/java/tech/pegasys/teku/services/beaconchain/BeaconChainController.java", "diffHunk": "@@ -175,8 +176,13 @@ private void startServices() {\n   }\n \n   private SafeFuture<?> initialize() {\n+    final StoreOptions storeOptions =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjU0OTA3OQ=="}, "originalCommit": {"oid": "1e10b5d5ab59986c1b4b8f0b3c9a7666d052e22a"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MzgwMTU1OnYy", "diffSide": "RIGHT", "path": "storage/src/main/java/tech/pegasys/teku/storage/store/BlockTree.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMzozODowNFrOHCqRGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQwMTo0OToxN1rOHCse_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjU1MTcwNQ==", "bodyText": "Isn't this:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                return hashTree\n          \n          \n            \n                    .getParent(blockRoot)\n          \n          \n            \n                    .map(\n          \n          \n            \n                        parentRoot -> {\n          \n          \n            \n                          final UInt64 blockEpoch = getEpoch(blockRoot);\n          \n          \n            \n                          final UInt64 parentEpoch =\n          \n          \n            \n                              Optional.of(parentRoot)\n          \n          \n            \n                                  .filter(this::contains)\n          \n          \n            \n                                  .map(this::getEpoch)\n          \n          \n            \n                                  .orElse(blockEpoch);\n          \n          \n            \n                          return blockEpoch.isGreaterThan(parentEpoch);\n          \n          \n            \n                        })\n          \n          \n            \n                    .orElse(false);\n          \n          \n            \n                return hashTree\n          \n          \n            \n                    .getParent(blockRoot)\n          \n          \n            \n                    .filter(this::contains)\n          \n          \n            \n                    .map(this::getEpoch)\n          \n          \n            \n                    .map(parentEpoch -> getEpoch(blockRoot).isGreaterThan(parentEpoch))\n          \n          \n            \n                    .orElse(false);\n          \n      \n    \n    \n  \n\nMy reading of both versions being that it's the root at epoch boundary if this is the first block that exists for this epoch (so block's epoch is greater than the parent's epoch).", "url": "https://github.com/ConsenSys/teku/pull/2611#discussion_r472551705", "createdAt": "2020-08-18T23:38:04Z", "author": {"login": "ajsutton"}, "path": "storage/src/main/java/tech/pegasys/teku/storage/store/BlockTree.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.storage.store;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_epoch_at_slot;\n+\n+import com.google.common.collect.Sets;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.hashtree.HashTree;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+\n+public class BlockTree {\n+  private final HashTree hashTree;\n+  final Map<Bytes32, UInt64> blockRootToSlot;\n+\n+  private BlockTree(final HashTree hashTree, final Map<Bytes32, UInt64> blockRootToSlot) {\n+    validate(hashTree, blockRootToSlot);\n+    this.hashTree = hashTree;\n+    this.blockRootToSlot = blockRootToSlot;\n+  }\n+\n+  public static BlockTree create(\n+      final HashTree hashTree, final Map<Bytes32, UInt64> blockRootToSlot) {\n+    return new BlockTree(hashTree, blockRootToSlot);\n+  }\n+\n+  private void validate(final HashTree hashTree, final Map<Bytes32, UInt64> blockRootToSlot) {\n+    checkArgument(\n+        hashTree.size() == blockRootToSlot.size(),\n+        \"Slot lookup and hash tree must contain the same number of elements\");\n+    checkArgument(\n+        Sets.difference(hashTree.getAllRoots(), blockRootToSlot.keySet()).isEmpty(),\n+        \"Slot lookup and hash tree must contain the same roots\");\n+  }\n+\n+  public BlockTree updated(final Bytes32 newRoot, Collection<SignedBeaconBlock> newBlocks) {\n+    final HashTree updatedHashTree = hashTree.withRoot(newRoot).blocks(newBlocks).build();\n+\n+    // Create new root to slot mapping\n+    final Map<Bytes32, UInt64> updatedBlockRootToSlot = new HashMap<>(blockRootToSlot);\n+    newBlocks.forEach(b -> updatedBlockRootToSlot.put(b.getRoot(), b.getSlot()));\n+    updatedBlockRootToSlot.keySet().removeIf(next -> !updatedHashTree.contains(next));\n+\n+    return new BlockTree(updatedHashTree, updatedBlockRootToSlot);\n+  }\n+\n+  public HashTree getHashTree() {\n+    return hashTree;\n+  }\n+\n+  public Bytes32 getRootHash() {\n+    return hashTree.getRootHash();\n+  }\n+\n+  public boolean contains(final Bytes32 blockRoot) {\n+    return hashTree.contains(blockRoot);\n+  }\n+\n+  public Set<Bytes32> getAllRoots() {\n+    return hashTree.getAllRoots();\n+  }\n+\n+  /**\n+   * @return A list of block roots ordered to guarantee that parent roots will be sorted earlier\n+   *     than child roots\n+   */\n+  public List<Bytes32> getOrderedBlockRoots() {\n+    return hashTree.breadthFirstStream().collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Returns true if the block root is at an internal epoch boundary. The rootHash is not considered\n+   * an epoch boundary. A block is at an epoch boundary if it is the first block within an epoch.\n+   *\n+   * @param blockRoot The block root to check.\n+   * @return True if the block root is at an internal epoch boundary.\n+   */\n+  public boolean isRootAtEpochBoundary(Bytes32 blockRoot) {\n+    assertBlockIsInTree(blockRoot);\n+    return hashTree\n+        .getParent(blockRoot)\n+        .map(\n+            parentRoot -> {\n+              final UInt64 blockEpoch = getEpoch(blockRoot);\n+              final UInt64 parentEpoch =\n+                  Optional.of(parentRoot)\n+                      .filter(this::contains)\n+                      .map(this::getEpoch)\n+                      .orElse(blockEpoch);\n+              return blockEpoch.isGreaterThan(parentEpoch);\n+            })\n+        .orElse(false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e10b5d5ab59986c1b4b8f0b3c9a7666d052e22a"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjU4ODAzMA==", "bodyText": "yeah - your version is much simpler \ud83d\udc4d", "url": "https://github.com/ConsenSys/teku/pull/2611#discussion_r472588030", "createdAt": "2020-08-19T01:49:17Z", "author": {"login": "mbaxter"}, "path": "storage/src/main/java/tech/pegasys/teku/storage/store/BlockTree.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.storage.store;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_epoch_at_slot;\n+\n+import com.google.common.collect.Sets;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.hashtree.HashTree;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+\n+public class BlockTree {\n+  private final HashTree hashTree;\n+  final Map<Bytes32, UInt64> blockRootToSlot;\n+\n+  private BlockTree(final HashTree hashTree, final Map<Bytes32, UInt64> blockRootToSlot) {\n+    validate(hashTree, blockRootToSlot);\n+    this.hashTree = hashTree;\n+    this.blockRootToSlot = blockRootToSlot;\n+  }\n+\n+  public static BlockTree create(\n+      final HashTree hashTree, final Map<Bytes32, UInt64> blockRootToSlot) {\n+    return new BlockTree(hashTree, blockRootToSlot);\n+  }\n+\n+  private void validate(final HashTree hashTree, final Map<Bytes32, UInt64> blockRootToSlot) {\n+    checkArgument(\n+        hashTree.size() == blockRootToSlot.size(),\n+        \"Slot lookup and hash tree must contain the same number of elements\");\n+    checkArgument(\n+        Sets.difference(hashTree.getAllRoots(), blockRootToSlot.keySet()).isEmpty(),\n+        \"Slot lookup and hash tree must contain the same roots\");\n+  }\n+\n+  public BlockTree updated(final Bytes32 newRoot, Collection<SignedBeaconBlock> newBlocks) {\n+    final HashTree updatedHashTree = hashTree.withRoot(newRoot).blocks(newBlocks).build();\n+\n+    // Create new root to slot mapping\n+    final Map<Bytes32, UInt64> updatedBlockRootToSlot = new HashMap<>(blockRootToSlot);\n+    newBlocks.forEach(b -> updatedBlockRootToSlot.put(b.getRoot(), b.getSlot()));\n+    updatedBlockRootToSlot.keySet().removeIf(next -> !updatedHashTree.contains(next));\n+\n+    return new BlockTree(updatedHashTree, updatedBlockRootToSlot);\n+  }\n+\n+  public HashTree getHashTree() {\n+    return hashTree;\n+  }\n+\n+  public Bytes32 getRootHash() {\n+    return hashTree.getRootHash();\n+  }\n+\n+  public boolean contains(final Bytes32 blockRoot) {\n+    return hashTree.contains(blockRoot);\n+  }\n+\n+  public Set<Bytes32> getAllRoots() {\n+    return hashTree.getAllRoots();\n+  }\n+\n+  /**\n+   * @return A list of block roots ordered to guarantee that parent roots will be sorted earlier\n+   *     than child roots\n+   */\n+  public List<Bytes32> getOrderedBlockRoots() {\n+    return hashTree.breadthFirstStream().collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Returns true if the block root is at an internal epoch boundary. The rootHash is not considered\n+   * an epoch boundary. A block is at an epoch boundary if it is the first block within an epoch.\n+   *\n+   * @param blockRoot The block root to check.\n+   * @return True if the block root is at an internal epoch boundary.\n+   */\n+  public boolean isRootAtEpochBoundary(Bytes32 blockRoot) {\n+    assertBlockIsInTree(blockRoot);\n+    return hashTree\n+        .getParent(blockRoot)\n+        .map(\n+            parentRoot -> {\n+              final UInt64 blockEpoch = getEpoch(blockRoot);\n+              final UInt64 parentEpoch =\n+                  Optional.of(parentRoot)\n+                      .filter(this::contains)\n+                      .map(this::getEpoch)\n+                      .orElse(blockEpoch);\n+              return blockEpoch.isGreaterThan(parentEpoch);\n+            })\n+        .orElse(false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjU1MTcwNQ=="}, "originalCommit": {"oid": "1e10b5d5ab59986c1b4b8f0b3c9a7666d052e22a"}, "originalPosition": 113}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MzgxNjIyOnYy", "diffSide": "RIGHT", "path": "storage/src/main/java/tech/pegasys/teku/storage/store/StoreOptions.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMzo0NToxNFrOHCqZWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMzo0NToxNFrOHCqZWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjU1MzgxNw==", "bodyText": "Maybe call this one StoreConfig to differentiate from the CLI StoreOptions?", "url": "https://github.com/ConsenSys/teku/pull/2611#discussion_r472553817", "createdAt": "2020-08-18T23:45:14Z", "author": {"login": "ajsutton"}, "path": "storage/src/main/java/tech/pegasys/teku/storage/store/StoreOptions.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.storage.store;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+\n+import java.util.Objects;\n+import tech.pegasys.teku.util.config.Constants;\n+\n+public class StoreOptions {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e10b5d5ab59986c1b4b8f0b3c9a7666d052e22a"}, "originalPosition": 21}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3316, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}