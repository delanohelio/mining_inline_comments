{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU3Mjg2OTk3", "number": 2453, "reviewThreads": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwMToxMTozMVrOETe2CA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxNjo1OTowNFrOETxA8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4ODYzNzUyOnYy", "diffSide": "RIGHT", "path": "bls/src/main/java/tech/pegasys/teku/bls/BLSPublicKey.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwMToxMTozMVrOG5Pgnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxMzo1MDozN1rOG5j6tg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY3NjEyNw==", "bodyText": "Is there any risk that two keys with different bytes could wind up being the same G1 point when parsed (ie that two different byte representations could actually be the same key)?", "url": "https://github.com/ConsenSys/teku/pull/2453#discussion_r462676127", "createdAt": "2020-07-30T01:11:31Z", "author": {"login": "ajsutton"}, "path": "bls/src/main/java/tech/pegasys/teku/bls/BLSPublicKey.java", "diffHunk": "@@ -155,11 +167,11 @@ public boolean equals(Object obj) {\n     }\n \n     BLSPublicKey other = (BLSPublicKey) obj;\n-    return Objects.equals(this.getPublicKey(), other.getPublicKey());\n+    return Objects.equals(this.toBytesCompressed(), other.toBytesCompressed());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa8ec9862ed4dcda26ef467d981198c71be8c84d"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk2NjIyMg==", "bodyText": "No, the compressed representation is unambiguous.", "url": "https://github.com/ConsenSys/teku/pull/2453#discussion_r462966222", "createdAt": "2020-07-30T12:39:58Z", "author": {"login": "benjaminion"}, "path": "bls/src/main/java/tech/pegasys/teku/bls/BLSPublicKey.java", "diffHunk": "@@ -155,11 +167,11 @@ public boolean equals(Object obj) {\n     }\n \n     BLSPublicKey other = (BLSPublicKey) obj;\n-    return Objects.equals(this.getPublicKey(), other.getPublicKey());\n+    return Objects.equals(this.toBytesCompressed(), other.toBytesCompressed());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY3NjEyNw=="}, "originalCommit": {"oid": "fa8ec9862ed4dcda26ef467d981198c71be8c84d"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzAxMDQ4Ng==", "bodyText": "Thanks @benjaminion ! Was not 100% sure about this", "url": "https://github.com/ConsenSys/teku/pull/2453#discussion_r463010486", "createdAt": "2020-07-30T13:50:37Z", "author": {"login": "Nashatyrev"}, "path": "bls/src/main/java/tech/pegasys/teku/bls/BLSPublicKey.java", "diffHunk": "@@ -155,11 +167,11 @@ public boolean equals(Object obj) {\n     }\n \n     BLSPublicKey other = (BLSPublicKey) obj;\n-    return Objects.equals(this.getPublicKey(), other.getPublicKey());\n+    return Objects.equals(this.toBytesCompressed(), other.toBytesCompressed());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY3NjEyNw=="}, "originalCommit": {"oid": "fa8ec9862ed4dcda26ef467d981198c71be8c84d"}, "originalPosition": 153}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4ODY2MjU1OnYy", "diffSide": "RIGHT", "path": "bls/src/main/java/tech/pegasys/teku/bls/BLS.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwMToyNTo0OFrOG5PvMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQyMToyODo1MVrOG50esA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY3OTg1OA==", "bodyText": "nit:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private static BLS12381 BlsImpl;\n          \n          \n            \n              private static final BLS12381 blsImpl;\n          \n      \n    \n    \n  \n\nAlso see comment on MikuliBLS12381.INSTANCE.", "url": "https://github.com/ConsenSys/teku/pull/2453#discussion_r462679858", "createdAt": "2020-07-30T01:25:48Z", "author": {"login": "ajsutton"}, "path": "bls/src/main/java/tech/pegasys/teku/bls/BLS.java", "diffHunk": "@@ -43,7 +44,17 @@\n \n   private static final Logger LOG = LogManager.getLogger();\n \n-  private static BLS12381 BlsImpl = MikuliBLS12381.INSTANCE;\n+  private static BLS12381 BlsImpl;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa8ec9862ed4dcda26ef467d981198c71be8c84d"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzA1MTkxOA==", "bodyText": "Good, made it final. Though I was going to make the implementation pluggable at runtime, but this would be another PR\n\nAlso see comment on MikuliBLS12381.INSTANCE\n\nDid you mean BlstBLS12381.INSTANCE ?", "url": "https://github.com/ConsenSys/teku/pull/2453#discussion_r463051918", "createdAt": "2020-07-30T14:47:24Z", "author": {"login": "Nashatyrev"}, "path": "bls/src/main/java/tech/pegasys/teku/bls/BLS.java", "diffHunk": "@@ -43,7 +44,17 @@\n \n   private static final Logger LOG = LogManager.getLogger();\n \n-  private static BLS12381 BlsImpl = MikuliBLS12381.INSTANCE;\n+  private static BLS12381 BlsImpl;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY3OTg1OA=="}, "originalCommit": {"oid": "fa8ec9862ed4dcda26ef467d981198c71be8c84d"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzI4MTg0MA==", "bodyText": "Yes I did sorry.  About being careful with loading the native lib as part of class initialisation.", "url": "https://github.com/ConsenSys/teku/pull/2453#discussion_r463281840", "createdAt": "2020-07-30T21:28:51Z", "author": {"login": "ajsutton"}, "path": "bls/src/main/java/tech/pegasys/teku/bls/BLS.java", "diffHunk": "@@ -43,7 +44,17 @@\n \n   private static final Logger LOG = LogManager.getLogger();\n \n-  private static BLS12381 BlsImpl = MikuliBLS12381.INSTANCE;\n+  private static BLS12381 BlsImpl;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY3OTg1OA=="}, "originalCommit": {"oid": "fa8ec9862ed4dcda26ef467d981198c71be8c84d"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4ODY2OTMyOnYy", "diffSide": "RIGHT", "path": "bls/src/main/java/tech/pegasys/teku/bls/impl/blst/BlstBLS12381.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwMToyOTozNVrOG5PzIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxNDo1MDoyNVrOG5mlCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY4MDg2NQ==", "bodyText": "This depends on class loading and initialisation behaviour which has been very unpredictable in the past (maybe the JVM spec has improved to make it more predictable now - not sure).  It may be worth making INSTANCE be an Optional that only has a value if the library was loaded successfully:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public static BlstBLS12381 INSTANCE = new BlstBLS12381();\n          \n          \n            \n            \n          \n          \n            \n              private static final int BATCH_RANDOM_BYTES = 8;\n          \n          \n            \n            \n          \n          \n            \n              static {\n          \n          \n            \n                try {\n          \n          \n            \n                  NativeUtils.loadLibraryFromJar(\"/\" + System.mapLibraryName(\"jblst\"));\n          \n          \n            \n                } catch (IOException e) {\n          \n          \n            \n                  throw new RuntimeException(e);\n          \n          \n            \n                }\n          \n          \n            \n              }\n          \n          \n            \n              private static final Logger LOG = LogManager.getLogger();\n          \n          \n            \n              \n          \n          \n            \n              public static final Optional<BlstBLS12381> INSTANCE;\n          \n          \n            \n            \n          \n          \n            \n              private static final int BATCH_RANDOM_BYTES = 8;\n          \n          \n            \n            \n          \n          \n            \n              static {\n          \n          \n            \n                boolean libraryLoaded;\n          \n          \n            \n                try {\n          \n          \n            \n                  NativeUtils.loadLibraryFromJar(\"/\" + System.mapLibraryName(\"jblst\"));\n          \n          \n            \n                  libraryLoaded = true;\n          \n          \n            \n                  LOG.info(\"Successfully loaded native BLS library\");\n          \n          \n            \n                } catch (IOException e) {\n          \n          \n            \n                  LOG.warn(\"Couldn't load native BLS library: \" + e);\n          \n          \n            \n                  libraryLoaded = false;\n          \n          \n            \n                }\n          \n          \n            \n                INSTANCE = libraryLoaded ? Optional.of(new BlstBLS12381()) : Optional.empty();\n          \n          \n            \n              }", "url": "https://github.com/ConsenSys/teku/pull/2453#discussion_r462680865", "createdAt": "2020-07-30T01:29:35Z", "author": {"login": "ajsutton"}, "path": "bls/src/main/java/tech/pegasys/teku/bls/impl/blst/BlstBLS12381.java", "diffHunk": "@@ -0,0 +1,256 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.bls.impl.blst;\n+\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.apache.tuweni.bytes.Bytes48;\n+import tech.pegasys.teku.bls.BatchSemiAggregate;\n+import tech.pegasys.teku.bls.impl.BLS12381;\n+import tech.pegasys.teku.bls.impl.KeyPair;\n+import tech.pegasys.teku.bls.impl.PublicKey;\n+import tech.pegasys.teku.bls.impl.Signature;\n+import tech.pegasys.teku.bls.impl.blst.swig.BLST_ERROR;\n+import tech.pegasys.teku.bls.impl.blst.swig.blst;\n+import tech.pegasys.teku.bls.impl.blst.swig.p2;\n+import tech.pegasys.teku.bls.impl.blst.swig.p2_affine;\n+import tech.pegasys.teku.bls.impl.blst.swig.pairing;\n+\n+public class BlstBLS12381 implements BLS12381 {\n+\n+  public static BlstBLS12381 INSTANCE = new BlstBLS12381();\n+\n+  private static final int BATCH_RANDOM_BYTES = 8;\n+\n+  static {\n+    try {\n+      NativeUtils.loadLibraryFromJar(\"/\" + System.mapLibraryName(\"jblst\"));\n+    } catch (IOException e) {\n+      throw new RuntimeException(e);\n+    }\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa8ec9862ed4dcda26ef467d981198c71be8c84d"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzA1NDA5MQ==", "bodyText": "Yeah, you are right, probably throwing exception from static initializer is not the best choice. Initially I was assuming that this is a critical error, but now I think that it's pretty normal situation (e.g. on Raspberry PI or other platforms not supported by blst).\nSee d17224f fix", "url": "https://github.com/ConsenSys/teku/pull/2453#discussion_r463054091", "createdAt": "2020-07-30T14:50:25Z", "author": {"login": "Nashatyrev"}, "path": "bls/src/main/java/tech/pegasys/teku/bls/impl/blst/BlstBLS12381.java", "diffHunk": "@@ -0,0 +1,256 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.bls.impl.blst;\n+\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.apache.tuweni.bytes.Bytes48;\n+import tech.pegasys.teku.bls.BatchSemiAggregate;\n+import tech.pegasys.teku.bls.impl.BLS12381;\n+import tech.pegasys.teku.bls.impl.KeyPair;\n+import tech.pegasys.teku.bls.impl.PublicKey;\n+import tech.pegasys.teku.bls.impl.Signature;\n+import tech.pegasys.teku.bls.impl.blst.swig.BLST_ERROR;\n+import tech.pegasys.teku.bls.impl.blst.swig.blst;\n+import tech.pegasys.teku.bls.impl.blst.swig.p2;\n+import tech.pegasys.teku.bls.impl.blst.swig.p2_affine;\n+import tech.pegasys.teku.bls.impl.blst.swig.pairing;\n+\n+public class BlstBLS12381 implements BLS12381 {\n+\n+  public static BlstBLS12381 INSTANCE = new BlstBLS12381();\n+\n+  private static final int BATCH_RANDOM_BYTES = 8;\n+\n+  static {\n+    try {\n+      NativeUtils.loadLibraryFromJar(\"/\" + System.mapLibraryName(\"jblst\"));\n+    } catch (IOException e) {\n+      throw new RuntimeException(e);\n+    }\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY4MDg2NQ=="}, "originalCommit": {"oid": "fa8ec9862ed4dcda26ef467d981198c71be8c84d"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4ODY4ODQ0OnYy", "diffSide": "RIGHT", "path": "bls/src/main/java/tech/pegasys/teku/bls/impl/blst/BlstBLS12381.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwMTozODozM1rOG5P-1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxNjowODoyN1rOG5p6Wg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY4Mzg2MA==", "bodyText": "If it's at all possible to have the SWIG bindings make these classes Autocloseable that would be awesome.  In any case we should ensure they are deleted regardless of any potential exceptions or errors that occur so would have to use try/finally blocks.  It will get really ugly without Autocloseable.\nWe're also winding up with a native memory leak because the wrapped BlstSignature returned has a reference to p2SignatureAffine but no way to close it and delete that native object.  The finalize method isn't guaranteed to be called in any kind of timely manner so we can't really depend on it.\nIf we have to depend on automatic cleanup (which may well be the case for things like public keys and signatures that are used outside of the Blst specific code and currently expect to be fully on-heap), we should use java.lang.ref.Cleaner to do it which is the recommended instead of finalize.\nMaybe use AutoCloseable if possible for the local variables we need to release and then use Cleaner for the things that are actually returned from this class.", "url": "https://github.com/ConsenSys/teku/pull/2453#discussion_r462683860", "createdAt": "2020-07-30T01:38:33Z", "author": {"login": "ajsutton"}, "path": "bls/src/main/java/tech/pegasys/teku/bls/impl/blst/BlstBLS12381.java", "diffHunk": "@@ -0,0 +1,256 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.bls.impl.blst;\n+\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.apache.tuweni.bytes.Bytes48;\n+import tech.pegasys.teku.bls.BatchSemiAggregate;\n+import tech.pegasys.teku.bls.impl.BLS12381;\n+import tech.pegasys.teku.bls.impl.KeyPair;\n+import tech.pegasys.teku.bls.impl.PublicKey;\n+import tech.pegasys.teku.bls.impl.Signature;\n+import tech.pegasys.teku.bls.impl.blst.swig.BLST_ERROR;\n+import tech.pegasys.teku.bls.impl.blst.swig.blst;\n+import tech.pegasys.teku.bls.impl.blst.swig.p2;\n+import tech.pegasys.teku.bls.impl.blst.swig.p2_affine;\n+import tech.pegasys.teku.bls.impl.blst.swig.pairing;\n+\n+public class BlstBLS12381 implements BLS12381 {\n+\n+  public static BlstBLS12381 INSTANCE = new BlstBLS12381();\n+\n+  private static final int BATCH_RANDOM_BYTES = 8;\n+\n+  static {\n+    try {\n+      NativeUtils.loadLibraryFromJar(\"/\" + System.mapLibraryName(\"jblst\"));\n+    } catch (IOException e) {\n+      throw new RuntimeException(e);\n+    }\n+  }\n+\n+  private static Random getRND() {\n+    // Milagro RAND has some issues with generating 'small' random numbers\n+    // and is not thread safe\n+    // Using non-secure random due to the JDK Linux secure random issue:\n+    // https://bugs.java.com/bugdatabase/view_bug.do?bug_id=6521844\n+    // A potential attack here has a very limited application and is not feasible\n+    // Thus using non-secure random doesn't significantly mitigate the security\n+    return ThreadLocalRandom.current();\n+  }\n+\n+  public static BlstSignature sign(BlstSecretKey secretKey, Bytes message) {\n+    p2 p2Signature = new p2();\n+    p2 hash = HashToCurve.hashToG2(message);\n+    blst.sign_pk_in_g1(p2Signature, hash, secretKey.getScalarVal());\n+    p2_affine p2SignatureAffine = new p2_affine();\n+    blst.p2_to_affine(p2SignatureAffine, p2Signature);\n+    p2Signature.delete();\n+    hash.delete();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa8ec9862ed4dcda26ef467d981198c71be8c84d"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzEwODY5OA==", "bodyText": "I didn't find Autocloseable feature in SWIG unfortunately. Indeed that would look better.\nRevised places with temporary native wrapper instances and add try/catch/finally where appropriate: 913e484\nI'll add a general comment later on my thoughts regarding finalize and cleaning native structs", "url": "https://github.com/ConsenSys/teku/pull/2453#discussion_r463108698", "createdAt": "2020-07-30T16:08:27Z", "author": {"login": "Nashatyrev"}, "path": "bls/src/main/java/tech/pegasys/teku/bls/impl/blst/BlstBLS12381.java", "diffHunk": "@@ -0,0 +1,256 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.bls.impl.blst;\n+\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.apache.tuweni.bytes.Bytes48;\n+import tech.pegasys.teku.bls.BatchSemiAggregate;\n+import tech.pegasys.teku.bls.impl.BLS12381;\n+import tech.pegasys.teku.bls.impl.KeyPair;\n+import tech.pegasys.teku.bls.impl.PublicKey;\n+import tech.pegasys.teku.bls.impl.Signature;\n+import tech.pegasys.teku.bls.impl.blst.swig.BLST_ERROR;\n+import tech.pegasys.teku.bls.impl.blst.swig.blst;\n+import tech.pegasys.teku.bls.impl.blst.swig.p2;\n+import tech.pegasys.teku.bls.impl.blst.swig.p2_affine;\n+import tech.pegasys.teku.bls.impl.blst.swig.pairing;\n+\n+public class BlstBLS12381 implements BLS12381 {\n+\n+  public static BlstBLS12381 INSTANCE = new BlstBLS12381();\n+\n+  private static final int BATCH_RANDOM_BYTES = 8;\n+\n+  static {\n+    try {\n+      NativeUtils.loadLibraryFromJar(\"/\" + System.mapLibraryName(\"jblst\"));\n+    } catch (IOException e) {\n+      throw new RuntimeException(e);\n+    }\n+  }\n+\n+  private static Random getRND() {\n+    // Milagro RAND has some issues with generating 'small' random numbers\n+    // and is not thread safe\n+    // Using non-secure random due to the JDK Linux secure random issue:\n+    // https://bugs.java.com/bugdatabase/view_bug.do?bug_id=6521844\n+    // A potential attack here has a very limited application and is not feasible\n+    // Thus using non-secure random doesn't significantly mitigate the security\n+    return ThreadLocalRandom.current();\n+  }\n+\n+  public static BlstSignature sign(BlstSecretKey secretKey, Bytes message) {\n+    p2 p2Signature = new p2();\n+    p2 hash = HashToCurve.hashToG2(message);\n+    blst.sign_pk_in_g1(p2Signature, hash, secretKey.getScalarVal());\n+    p2_affine p2SignatureAffine = new p2_affine();\n+    blst.p2_to_affine(p2SignatureAffine, p2Signature);\n+    p2Signature.delete();\n+    hash.delete();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY4Mzg2MA=="}, "originalCommit": {"oid": "fa8ec9862ed4dcda26ef467d981198c71be8c84d"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4ODgzOTE5OnYy", "diffSide": "RIGHT", "path": "bls/src/main/java/tech/pegasys/teku/bls/impl/blst/BlstBLS12381.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwMzowMzo1MVrOG5RXXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxMzozNDoxM1rOG5jPeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjcwNjUyNQ==", "bodyText": "This comment is a little scary. Does it still apply?", "url": "https://github.com/ConsenSys/teku/pull/2453#discussion_r462706525", "createdAt": "2020-07-30T03:03:51Z", "author": {"login": "ajsutton"}, "path": "bls/src/main/java/tech/pegasys/teku/bls/impl/blst/BlstBLS12381.java", "diffHunk": "@@ -0,0 +1,256 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.bls.impl.blst;\n+\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.apache.tuweni.bytes.Bytes48;\n+import tech.pegasys.teku.bls.BatchSemiAggregate;\n+import tech.pegasys.teku.bls.impl.BLS12381;\n+import tech.pegasys.teku.bls.impl.KeyPair;\n+import tech.pegasys.teku.bls.impl.PublicKey;\n+import tech.pegasys.teku.bls.impl.Signature;\n+import tech.pegasys.teku.bls.impl.blst.swig.BLST_ERROR;\n+import tech.pegasys.teku.bls.impl.blst.swig.blst;\n+import tech.pegasys.teku.bls.impl.blst.swig.p2;\n+import tech.pegasys.teku.bls.impl.blst.swig.p2_affine;\n+import tech.pegasys.teku.bls.impl.blst.swig.pairing;\n+\n+public class BlstBLS12381 implements BLS12381 {\n+\n+  public static BlstBLS12381 INSTANCE = new BlstBLS12381();\n+\n+  private static final int BATCH_RANDOM_BYTES = 8;\n+\n+  static {\n+    try {\n+      NativeUtils.loadLibraryFromJar(\"/\" + System.mapLibraryName(\"jblst\"));\n+    } catch (IOException e) {\n+      throw new RuntimeException(e);\n+    }\n+  }\n+\n+  private static Random getRND() {\n+    // Milagro RAND has some issues with generating 'small' random numbers\n+    // and is not thread safe\n+    // Using non-secure random due to the JDK Linux secure random issue:\n+    // https://bugs.java.com/bugdatabase/view_bug.do?bug_id=6521844\n+    // A potential attack here has a very limited application and is not feasible\n+    // Thus using non-secure random doesn't significantly mitigate the security\n+    return ThreadLocalRandom.current();\n+  }\n+\n+  public static BlstSignature sign(BlstSecretKey secretKey, Bytes message) {\n+    p2 p2Signature = new p2();\n+    p2 hash = HashToCurve.hashToG2(message);\n+    blst.sign_pk_in_g1(p2Signature, hash, secretKey.getScalarVal());\n+    p2_affine p2SignatureAffine = new p2_affine();\n+    blst.p2_to_affine(p2SignatureAffine, p2Signature);\n+    p2Signature.delete();\n+    hash.delete();\n+    return new BlstSignature(p2SignatureAffine, true);\n+  }\n+\n+  public static boolean verify(BlstPublicKey publicKey, Bytes message, BlstSignature signature) {\n+    if (publicKey.isInfinity() || signature.isInfinity()) {\n+      return publicKey.isInfinity() && signature.isInfinity();\n+    }\n+    BLST_ERROR res =\n+        blst.core_verify_pk_in_g1(\n+            publicKey.ecPoint,\n+            signature.ec2Point,\n+            1,\n+            message.toArrayUnsafe(),\n+            HashToCurve.ETH2_DST.toArrayUnsafe(),\n+            new byte[0]);\n+    return res == BLST_ERROR.BLST_SUCCESS;\n+  }\n+\n+  @Override\n+  public KeyPair generateKeyPair(Random random) {\n+    BlstSecretKey secretKey = BlstSecretKey.generateNew(random);\n+    return new KeyPair(secretKey);\n+  }\n+\n+  @Override\n+  public BlstPublicKey publicKeyFromCompressed(Bytes48 compressedPublicKeyBytes) {\n+    return BlstPublicKey.fromBytes(compressedPublicKeyBytes);\n+  }\n+\n+  @Override\n+  public BlstSignature signatureFromCompressed(Bytes compressedSignatureBytes) {\n+    return BlstSignature.fromBytes(compressedSignatureBytes);\n+  }\n+\n+  @Override\n+  public BlstSecretKey secretKeyFromBytes(Bytes32 secretKeyBytes) {\n+    return BlstSecretKey.fromBytes(secretKeyBytes);\n+  }\n+\n+  @Override\n+  public BlstPublicKey aggregatePublicKeys(List<? extends PublicKey> publicKeys) {\n+    return BlstPublicKey.aggregate(\n+        publicKeys.stream().map(k -> (BlstPublicKey) k).collect(Collectors.toList()));\n+  }\n+\n+  @Override\n+  public BlstSignature aggregateSignatures(List<? extends Signature> signatures) {\n+    return BlstSignature.aggregate(\n+        signatures.stream().map(s -> (BlstSignature) s).collect(Collectors.toList()));\n+  }\n+\n+  pairing blstPrepareVerifyAggregated(\n+      BlstPublicKey pubKey, Bytes message, pairing ctx, BlstSignature blstSignature) {\n+\n+    p2 g2Hash = HashToCurve.hashToG2(message);\n+    p2_affine p2Affine = new p2_affine();\n+    blst.p2_to_affine(p2Affine, g2Hash);\n+\n+    if (ctx == null) {\n+      ctx = new pairing();\n+      blst.pairing_init(ctx);\n+    }\n+\n+    try {\n+      BLST_ERROR ret =\n+          blst.pairing_aggregate_pk_in_g1(\n+              ctx,\n+              pubKey.ecPoint,\n+              blstSignature == null ? null : blstSignature.ec2Point,\n+              1,\n+              message.toArrayUnsafe(),\n+              HashToCurve.ETH2_DST.toArrayUnsafe(),\n+              null);\n+      if (ret != BLST_ERROR.BLST_SUCCESS) throw new IllegalArgumentException(\"Error: \" + ret);\n+    } catch (Exception e) {\n+      ctx.delete();\n+      throw e;\n+    } finally {\n+      g2Hash.delete();\n+      p2Affine.delete(); // not sure if its copied inside pairing_mul_n_aggregate_pk_in_g1", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa8ec9862ed4dcda26ef467d981198c71be8c84d"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk5OTQxOA==", "bodyText": "Right, removed it. Blst dev assured me that arguments are not referenced in pairing_context", "url": "https://github.com/ConsenSys/teku/pull/2453#discussion_r462999418", "createdAt": "2020-07-30T13:34:13Z", "author": {"login": "Nashatyrev"}, "path": "bls/src/main/java/tech/pegasys/teku/bls/impl/blst/BlstBLS12381.java", "diffHunk": "@@ -0,0 +1,256 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.bls.impl.blst;\n+\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.apache.tuweni.bytes.Bytes48;\n+import tech.pegasys.teku.bls.BatchSemiAggregate;\n+import tech.pegasys.teku.bls.impl.BLS12381;\n+import tech.pegasys.teku.bls.impl.KeyPair;\n+import tech.pegasys.teku.bls.impl.PublicKey;\n+import tech.pegasys.teku.bls.impl.Signature;\n+import tech.pegasys.teku.bls.impl.blst.swig.BLST_ERROR;\n+import tech.pegasys.teku.bls.impl.blst.swig.blst;\n+import tech.pegasys.teku.bls.impl.blst.swig.p2;\n+import tech.pegasys.teku.bls.impl.blst.swig.p2_affine;\n+import tech.pegasys.teku.bls.impl.blst.swig.pairing;\n+\n+public class BlstBLS12381 implements BLS12381 {\n+\n+  public static BlstBLS12381 INSTANCE = new BlstBLS12381();\n+\n+  private static final int BATCH_RANDOM_BYTES = 8;\n+\n+  static {\n+    try {\n+      NativeUtils.loadLibraryFromJar(\"/\" + System.mapLibraryName(\"jblst\"));\n+    } catch (IOException e) {\n+      throw new RuntimeException(e);\n+    }\n+  }\n+\n+  private static Random getRND() {\n+    // Milagro RAND has some issues with generating 'small' random numbers\n+    // and is not thread safe\n+    // Using non-secure random due to the JDK Linux secure random issue:\n+    // https://bugs.java.com/bugdatabase/view_bug.do?bug_id=6521844\n+    // A potential attack here has a very limited application and is not feasible\n+    // Thus using non-secure random doesn't significantly mitigate the security\n+    return ThreadLocalRandom.current();\n+  }\n+\n+  public static BlstSignature sign(BlstSecretKey secretKey, Bytes message) {\n+    p2 p2Signature = new p2();\n+    p2 hash = HashToCurve.hashToG2(message);\n+    blst.sign_pk_in_g1(p2Signature, hash, secretKey.getScalarVal());\n+    p2_affine p2SignatureAffine = new p2_affine();\n+    blst.p2_to_affine(p2SignatureAffine, p2Signature);\n+    p2Signature.delete();\n+    hash.delete();\n+    return new BlstSignature(p2SignatureAffine, true);\n+  }\n+\n+  public static boolean verify(BlstPublicKey publicKey, Bytes message, BlstSignature signature) {\n+    if (publicKey.isInfinity() || signature.isInfinity()) {\n+      return publicKey.isInfinity() && signature.isInfinity();\n+    }\n+    BLST_ERROR res =\n+        blst.core_verify_pk_in_g1(\n+            publicKey.ecPoint,\n+            signature.ec2Point,\n+            1,\n+            message.toArrayUnsafe(),\n+            HashToCurve.ETH2_DST.toArrayUnsafe(),\n+            new byte[0]);\n+    return res == BLST_ERROR.BLST_SUCCESS;\n+  }\n+\n+  @Override\n+  public KeyPair generateKeyPair(Random random) {\n+    BlstSecretKey secretKey = BlstSecretKey.generateNew(random);\n+    return new KeyPair(secretKey);\n+  }\n+\n+  @Override\n+  public BlstPublicKey publicKeyFromCompressed(Bytes48 compressedPublicKeyBytes) {\n+    return BlstPublicKey.fromBytes(compressedPublicKeyBytes);\n+  }\n+\n+  @Override\n+  public BlstSignature signatureFromCompressed(Bytes compressedSignatureBytes) {\n+    return BlstSignature.fromBytes(compressedSignatureBytes);\n+  }\n+\n+  @Override\n+  public BlstSecretKey secretKeyFromBytes(Bytes32 secretKeyBytes) {\n+    return BlstSecretKey.fromBytes(secretKeyBytes);\n+  }\n+\n+  @Override\n+  public BlstPublicKey aggregatePublicKeys(List<? extends PublicKey> publicKeys) {\n+    return BlstPublicKey.aggregate(\n+        publicKeys.stream().map(k -> (BlstPublicKey) k).collect(Collectors.toList()));\n+  }\n+\n+  @Override\n+  public BlstSignature aggregateSignatures(List<? extends Signature> signatures) {\n+    return BlstSignature.aggregate(\n+        signatures.stream().map(s -> (BlstSignature) s).collect(Collectors.toList()));\n+  }\n+\n+  pairing blstPrepareVerifyAggregated(\n+      BlstPublicKey pubKey, Bytes message, pairing ctx, BlstSignature blstSignature) {\n+\n+    p2 g2Hash = HashToCurve.hashToG2(message);\n+    p2_affine p2Affine = new p2_affine();\n+    blst.p2_to_affine(p2Affine, g2Hash);\n+\n+    if (ctx == null) {\n+      ctx = new pairing();\n+      blst.pairing_init(ctx);\n+    }\n+\n+    try {\n+      BLST_ERROR ret =\n+          blst.pairing_aggregate_pk_in_g1(\n+              ctx,\n+              pubKey.ecPoint,\n+              blstSignature == null ? null : blstSignature.ec2Point,\n+              1,\n+              message.toArrayUnsafe(),\n+              HashToCurve.ETH2_DST.toArrayUnsafe(),\n+              null);\n+      if (ret != BLST_ERROR.BLST_SUCCESS) throw new IllegalArgumentException(\"Error: \" + ret);\n+    } catch (Exception e) {\n+      ctx.delete();\n+      throw e;\n+    } finally {\n+      g2Hash.delete();\n+      p2Affine.delete(); // not sure if its copied inside pairing_mul_n_aggregate_pk_in_g1", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjcwNjUyNQ=="}, "originalCommit": {"oid": "fa8ec9862ed4dcda26ef467d981198c71be8c84d"}, "originalPosition": 147}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4ODg0Mjg5OnYy", "diffSide": "RIGHT", "path": "bls/src/main/java/tech/pegasys/teku/bls/impl/blst/BlstBLS12381.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwMzowNTo1OFrOG5RZaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxMzozNzoyM1rOG5jXxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjcwNzA0OQ==", "bodyText": "This is only called from within BlstSignature could it be moved to a private method there? Releasing a parameter is a little scary so would be nice if it could be inlined.", "url": "https://github.com/ConsenSys/teku/pull/2453#discussion_r462707049", "createdAt": "2020-07-30T03:05:58Z", "author": {"login": "ajsutton"}, "path": "bls/src/main/java/tech/pegasys/teku/bls/impl/blst/BlstBLS12381.java", "diffHunk": "@@ -0,0 +1,256 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.bls.impl.blst;\n+\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.apache.tuweni.bytes.Bytes48;\n+import tech.pegasys.teku.bls.BatchSemiAggregate;\n+import tech.pegasys.teku.bls.impl.BLS12381;\n+import tech.pegasys.teku.bls.impl.KeyPair;\n+import tech.pegasys.teku.bls.impl.PublicKey;\n+import tech.pegasys.teku.bls.impl.Signature;\n+import tech.pegasys.teku.bls.impl.blst.swig.BLST_ERROR;\n+import tech.pegasys.teku.bls.impl.blst.swig.blst;\n+import tech.pegasys.teku.bls.impl.blst.swig.p2;\n+import tech.pegasys.teku.bls.impl.blst.swig.p2_affine;\n+import tech.pegasys.teku.bls.impl.blst.swig.pairing;\n+\n+public class BlstBLS12381 implements BLS12381 {\n+\n+  public static BlstBLS12381 INSTANCE = new BlstBLS12381();\n+\n+  private static final int BATCH_RANDOM_BYTES = 8;\n+\n+  static {\n+    try {\n+      NativeUtils.loadLibraryFromJar(\"/\" + System.mapLibraryName(\"jblst\"));\n+    } catch (IOException e) {\n+      throw new RuntimeException(e);\n+    }\n+  }\n+\n+  private static Random getRND() {\n+    // Milagro RAND has some issues with generating 'small' random numbers\n+    // and is not thread safe\n+    // Using non-secure random due to the JDK Linux secure random issue:\n+    // https://bugs.java.com/bugdatabase/view_bug.do?bug_id=6521844\n+    // A potential attack here has a very limited application and is not feasible\n+    // Thus using non-secure random doesn't significantly mitigate the security\n+    return ThreadLocalRandom.current();\n+  }\n+\n+  public static BlstSignature sign(BlstSecretKey secretKey, Bytes message) {\n+    p2 p2Signature = new p2();\n+    p2 hash = HashToCurve.hashToG2(message);\n+    blst.sign_pk_in_g1(p2Signature, hash, secretKey.getScalarVal());\n+    p2_affine p2SignatureAffine = new p2_affine();\n+    blst.p2_to_affine(p2SignatureAffine, p2Signature);\n+    p2Signature.delete();\n+    hash.delete();\n+    return new BlstSignature(p2SignatureAffine, true);\n+  }\n+\n+  public static boolean verify(BlstPublicKey publicKey, Bytes message, BlstSignature signature) {\n+    if (publicKey.isInfinity() || signature.isInfinity()) {\n+      return publicKey.isInfinity() && signature.isInfinity();\n+    }\n+    BLST_ERROR res =\n+        blst.core_verify_pk_in_g1(\n+            publicKey.ecPoint,\n+            signature.ec2Point,\n+            1,\n+            message.toArrayUnsafe(),\n+            HashToCurve.ETH2_DST.toArrayUnsafe(),\n+            new byte[0]);\n+    return res == BLST_ERROR.BLST_SUCCESS;\n+  }\n+\n+  @Override\n+  public KeyPair generateKeyPair(Random random) {\n+    BlstSecretKey secretKey = BlstSecretKey.generateNew(random);\n+    return new KeyPair(secretKey);\n+  }\n+\n+  @Override\n+  public BlstPublicKey publicKeyFromCompressed(Bytes48 compressedPublicKeyBytes) {\n+    return BlstPublicKey.fromBytes(compressedPublicKeyBytes);\n+  }\n+\n+  @Override\n+  public BlstSignature signatureFromCompressed(Bytes compressedSignatureBytes) {\n+    return BlstSignature.fromBytes(compressedSignatureBytes);\n+  }\n+\n+  @Override\n+  public BlstSecretKey secretKeyFromBytes(Bytes32 secretKeyBytes) {\n+    return BlstSecretKey.fromBytes(secretKeyBytes);\n+  }\n+\n+  @Override\n+  public BlstPublicKey aggregatePublicKeys(List<? extends PublicKey> publicKeys) {\n+    return BlstPublicKey.aggregate(\n+        publicKeys.stream().map(k -> (BlstPublicKey) k).collect(Collectors.toList()));\n+  }\n+\n+  @Override\n+  public BlstSignature aggregateSignatures(List<? extends Signature> signatures) {\n+    return BlstSignature.aggregate(\n+        signatures.stream().map(s -> (BlstSignature) s).collect(Collectors.toList()));\n+  }\n+\n+  pairing blstPrepareVerifyAggregated(\n+      BlstPublicKey pubKey, Bytes message, pairing ctx, BlstSignature blstSignature) {\n+\n+    p2 g2Hash = HashToCurve.hashToG2(message);\n+    p2_affine p2Affine = new p2_affine();\n+    blst.p2_to_affine(p2Affine, g2Hash);\n+\n+    if (ctx == null) {\n+      ctx = new pairing();\n+      blst.pairing_init(ctx);\n+    }\n+\n+    try {\n+      BLST_ERROR ret =\n+          blst.pairing_aggregate_pk_in_g1(\n+              ctx,\n+              pubKey.ecPoint,\n+              blstSignature == null ? null : blstSignature.ec2Point,\n+              1,\n+              message.toArrayUnsafe(),\n+              HashToCurve.ETH2_DST.toArrayUnsafe(),\n+              null);\n+      if (ret != BLST_ERROR.BLST_SUCCESS) throw new IllegalArgumentException(\"Error: \" + ret);\n+    } catch (Exception e) {\n+      ctx.delete();\n+      throw e;\n+    } finally {\n+      g2Hash.delete();\n+      p2Affine.delete(); // not sure if its copied inside pairing_mul_n_aggregate_pk_in_g1\n+    }\n+\n+    return ctx;\n+  }\n+\n+  boolean blstCompleteVerifyAggregated(pairing ctx) {\n+    try {\n+      blst.pairing_commit(ctx);\n+      return blst.pairing_finalverify(ctx, null) > 0;\n+    } finally {\n+      ctx.delete();\n+    }\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa8ec9862ed4dcda26ef467d981198c71be8c84d"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzAwMTU0MA==", "bodyText": "Right, makes sense \ud83d\udc4d", "url": "https://github.com/ConsenSys/teku/pull/2453#discussion_r463001540", "createdAt": "2020-07-30T13:37:23Z", "author": {"login": "Nashatyrev"}, "path": "bls/src/main/java/tech/pegasys/teku/bls/impl/blst/BlstBLS12381.java", "diffHunk": "@@ -0,0 +1,256 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.bls.impl.blst;\n+\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.apache.tuweni.bytes.Bytes48;\n+import tech.pegasys.teku.bls.BatchSemiAggregate;\n+import tech.pegasys.teku.bls.impl.BLS12381;\n+import tech.pegasys.teku.bls.impl.KeyPair;\n+import tech.pegasys.teku.bls.impl.PublicKey;\n+import tech.pegasys.teku.bls.impl.Signature;\n+import tech.pegasys.teku.bls.impl.blst.swig.BLST_ERROR;\n+import tech.pegasys.teku.bls.impl.blst.swig.blst;\n+import tech.pegasys.teku.bls.impl.blst.swig.p2;\n+import tech.pegasys.teku.bls.impl.blst.swig.p2_affine;\n+import tech.pegasys.teku.bls.impl.blst.swig.pairing;\n+\n+public class BlstBLS12381 implements BLS12381 {\n+\n+  public static BlstBLS12381 INSTANCE = new BlstBLS12381();\n+\n+  private static final int BATCH_RANDOM_BYTES = 8;\n+\n+  static {\n+    try {\n+      NativeUtils.loadLibraryFromJar(\"/\" + System.mapLibraryName(\"jblst\"));\n+    } catch (IOException e) {\n+      throw new RuntimeException(e);\n+    }\n+  }\n+\n+  private static Random getRND() {\n+    // Milagro RAND has some issues with generating 'small' random numbers\n+    // and is not thread safe\n+    // Using non-secure random due to the JDK Linux secure random issue:\n+    // https://bugs.java.com/bugdatabase/view_bug.do?bug_id=6521844\n+    // A potential attack here has a very limited application and is not feasible\n+    // Thus using non-secure random doesn't significantly mitigate the security\n+    return ThreadLocalRandom.current();\n+  }\n+\n+  public static BlstSignature sign(BlstSecretKey secretKey, Bytes message) {\n+    p2 p2Signature = new p2();\n+    p2 hash = HashToCurve.hashToG2(message);\n+    blst.sign_pk_in_g1(p2Signature, hash, secretKey.getScalarVal());\n+    p2_affine p2SignatureAffine = new p2_affine();\n+    blst.p2_to_affine(p2SignatureAffine, p2Signature);\n+    p2Signature.delete();\n+    hash.delete();\n+    return new BlstSignature(p2SignatureAffine, true);\n+  }\n+\n+  public static boolean verify(BlstPublicKey publicKey, Bytes message, BlstSignature signature) {\n+    if (publicKey.isInfinity() || signature.isInfinity()) {\n+      return publicKey.isInfinity() && signature.isInfinity();\n+    }\n+    BLST_ERROR res =\n+        blst.core_verify_pk_in_g1(\n+            publicKey.ecPoint,\n+            signature.ec2Point,\n+            1,\n+            message.toArrayUnsafe(),\n+            HashToCurve.ETH2_DST.toArrayUnsafe(),\n+            new byte[0]);\n+    return res == BLST_ERROR.BLST_SUCCESS;\n+  }\n+\n+  @Override\n+  public KeyPair generateKeyPair(Random random) {\n+    BlstSecretKey secretKey = BlstSecretKey.generateNew(random);\n+    return new KeyPair(secretKey);\n+  }\n+\n+  @Override\n+  public BlstPublicKey publicKeyFromCompressed(Bytes48 compressedPublicKeyBytes) {\n+    return BlstPublicKey.fromBytes(compressedPublicKeyBytes);\n+  }\n+\n+  @Override\n+  public BlstSignature signatureFromCompressed(Bytes compressedSignatureBytes) {\n+    return BlstSignature.fromBytes(compressedSignatureBytes);\n+  }\n+\n+  @Override\n+  public BlstSecretKey secretKeyFromBytes(Bytes32 secretKeyBytes) {\n+    return BlstSecretKey.fromBytes(secretKeyBytes);\n+  }\n+\n+  @Override\n+  public BlstPublicKey aggregatePublicKeys(List<? extends PublicKey> publicKeys) {\n+    return BlstPublicKey.aggregate(\n+        publicKeys.stream().map(k -> (BlstPublicKey) k).collect(Collectors.toList()));\n+  }\n+\n+  @Override\n+  public BlstSignature aggregateSignatures(List<? extends Signature> signatures) {\n+    return BlstSignature.aggregate(\n+        signatures.stream().map(s -> (BlstSignature) s).collect(Collectors.toList()));\n+  }\n+\n+  pairing blstPrepareVerifyAggregated(\n+      BlstPublicKey pubKey, Bytes message, pairing ctx, BlstSignature blstSignature) {\n+\n+    p2 g2Hash = HashToCurve.hashToG2(message);\n+    p2_affine p2Affine = new p2_affine();\n+    blst.p2_to_affine(p2Affine, g2Hash);\n+\n+    if (ctx == null) {\n+      ctx = new pairing();\n+      blst.pairing_init(ctx);\n+    }\n+\n+    try {\n+      BLST_ERROR ret =\n+          blst.pairing_aggregate_pk_in_g1(\n+              ctx,\n+              pubKey.ecPoint,\n+              blstSignature == null ? null : blstSignature.ec2Point,\n+              1,\n+              message.toArrayUnsafe(),\n+              HashToCurve.ETH2_DST.toArrayUnsafe(),\n+              null);\n+      if (ret != BLST_ERROR.BLST_SUCCESS) throw new IllegalArgumentException(\"Error: \" + ret);\n+    } catch (Exception e) {\n+      ctx.delete();\n+      throw e;\n+    } finally {\n+      g2Hash.delete();\n+      p2Affine.delete(); // not sure if its copied inside pairing_mul_n_aggregate_pk_in_g1\n+    }\n+\n+    return ctx;\n+  }\n+\n+  boolean blstCompleteVerifyAggregated(pairing ctx) {\n+    try {\n+      blst.pairing_commit(ctx);\n+      return blst.pairing_finalverify(ctx, null) > 0;\n+    } finally {\n+      ctx.delete();\n+    }\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjcwNzA0OQ=="}, "originalCommit": {"oid": "fa8ec9862ed4dcda26ef467d981198c71be8c84d"}, "originalPosition": 160}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4ODg1ODYwOnYy", "diffSide": "RIGHT", "path": "bls/src/main/java/tech/pegasys/teku/bls/impl/blst/BlstBLS12381.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwMzoxNDozOVrOG5RiIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxMzo0ODoxMlrOG5j0KQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjcwOTI4MQ==", "bodyText": "Shouldn't this return anyInvalidDummy?  ie if we have an invalid BlstInfiniteSemiAggregate and a BlstFiniteSemiAggregate we'd return false so why return true if we don't have a finite aggregate?", "url": "https://github.com/ConsenSys/teku/pull/2453#discussion_r462709281", "createdAt": "2020-07-30T03:14:39Z", "author": {"login": "ajsutton"}, "path": "bls/src/main/java/tech/pegasys/teku/bls/impl/blst/BlstBLS12381.java", "diffHunk": "@@ -0,0 +1,256 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.bls.impl.blst;\n+\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.apache.tuweni.bytes.Bytes48;\n+import tech.pegasys.teku.bls.BatchSemiAggregate;\n+import tech.pegasys.teku.bls.impl.BLS12381;\n+import tech.pegasys.teku.bls.impl.KeyPair;\n+import tech.pegasys.teku.bls.impl.PublicKey;\n+import tech.pegasys.teku.bls.impl.Signature;\n+import tech.pegasys.teku.bls.impl.blst.swig.BLST_ERROR;\n+import tech.pegasys.teku.bls.impl.blst.swig.blst;\n+import tech.pegasys.teku.bls.impl.blst.swig.p2;\n+import tech.pegasys.teku.bls.impl.blst.swig.p2_affine;\n+import tech.pegasys.teku.bls.impl.blst.swig.pairing;\n+\n+public class BlstBLS12381 implements BLS12381 {\n+\n+  public static BlstBLS12381 INSTANCE = new BlstBLS12381();\n+\n+  private static final int BATCH_RANDOM_BYTES = 8;\n+\n+  static {\n+    try {\n+      NativeUtils.loadLibraryFromJar(\"/\" + System.mapLibraryName(\"jblst\"));\n+    } catch (IOException e) {\n+      throw new RuntimeException(e);\n+    }\n+  }\n+\n+  private static Random getRND() {\n+    // Milagro RAND has some issues with generating 'small' random numbers\n+    // and is not thread safe\n+    // Using non-secure random due to the JDK Linux secure random issue:\n+    // https://bugs.java.com/bugdatabase/view_bug.do?bug_id=6521844\n+    // A potential attack here has a very limited application and is not feasible\n+    // Thus using non-secure random doesn't significantly mitigate the security\n+    return ThreadLocalRandom.current();\n+  }\n+\n+  public static BlstSignature sign(BlstSecretKey secretKey, Bytes message) {\n+    p2 p2Signature = new p2();\n+    p2 hash = HashToCurve.hashToG2(message);\n+    blst.sign_pk_in_g1(p2Signature, hash, secretKey.getScalarVal());\n+    p2_affine p2SignatureAffine = new p2_affine();\n+    blst.p2_to_affine(p2SignatureAffine, p2Signature);\n+    p2Signature.delete();\n+    hash.delete();\n+    return new BlstSignature(p2SignatureAffine, true);\n+  }\n+\n+  public static boolean verify(BlstPublicKey publicKey, Bytes message, BlstSignature signature) {\n+    if (publicKey.isInfinity() || signature.isInfinity()) {\n+      return publicKey.isInfinity() && signature.isInfinity();\n+    }\n+    BLST_ERROR res =\n+        blst.core_verify_pk_in_g1(\n+            publicKey.ecPoint,\n+            signature.ec2Point,\n+            1,\n+            message.toArrayUnsafe(),\n+            HashToCurve.ETH2_DST.toArrayUnsafe(),\n+            new byte[0]);\n+    return res == BLST_ERROR.BLST_SUCCESS;\n+  }\n+\n+  @Override\n+  public KeyPair generateKeyPair(Random random) {\n+    BlstSecretKey secretKey = BlstSecretKey.generateNew(random);\n+    return new KeyPair(secretKey);\n+  }\n+\n+  @Override\n+  public BlstPublicKey publicKeyFromCompressed(Bytes48 compressedPublicKeyBytes) {\n+    return BlstPublicKey.fromBytes(compressedPublicKeyBytes);\n+  }\n+\n+  @Override\n+  public BlstSignature signatureFromCompressed(Bytes compressedSignatureBytes) {\n+    return BlstSignature.fromBytes(compressedSignatureBytes);\n+  }\n+\n+  @Override\n+  public BlstSecretKey secretKeyFromBytes(Bytes32 secretKeyBytes) {\n+    return BlstSecretKey.fromBytes(secretKeyBytes);\n+  }\n+\n+  @Override\n+  public BlstPublicKey aggregatePublicKeys(List<? extends PublicKey> publicKeys) {\n+    return BlstPublicKey.aggregate(\n+        publicKeys.stream().map(k -> (BlstPublicKey) k).collect(Collectors.toList()));\n+  }\n+\n+  @Override\n+  public BlstSignature aggregateSignatures(List<? extends Signature> signatures) {\n+    return BlstSignature.aggregate(\n+        signatures.stream().map(s -> (BlstSignature) s).collect(Collectors.toList()));\n+  }\n+\n+  pairing blstPrepareVerifyAggregated(\n+      BlstPublicKey pubKey, Bytes message, pairing ctx, BlstSignature blstSignature) {\n+\n+    p2 g2Hash = HashToCurve.hashToG2(message);\n+    p2_affine p2Affine = new p2_affine();\n+    blst.p2_to_affine(p2Affine, g2Hash);\n+\n+    if (ctx == null) {\n+      ctx = new pairing();\n+      blst.pairing_init(ctx);\n+    }\n+\n+    try {\n+      BLST_ERROR ret =\n+          blst.pairing_aggregate_pk_in_g1(\n+              ctx,\n+              pubKey.ecPoint,\n+              blstSignature == null ? null : blstSignature.ec2Point,\n+              1,\n+              message.toArrayUnsafe(),\n+              HashToCurve.ETH2_DST.toArrayUnsafe(),\n+              null);\n+      if (ret != BLST_ERROR.BLST_SUCCESS) throw new IllegalArgumentException(\"Error: \" + ret);\n+    } catch (Exception e) {\n+      ctx.delete();\n+      throw e;\n+    } finally {\n+      g2Hash.delete();\n+      p2Affine.delete(); // not sure if its copied inside pairing_mul_n_aggregate_pk_in_g1\n+    }\n+\n+    return ctx;\n+  }\n+\n+  boolean blstCompleteVerifyAggregated(pairing ctx) {\n+    try {\n+      blst.pairing_commit(ctx);\n+      return blst.pairing_finalverify(ctx, null) > 0;\n+    } finally {\n+      ctx.delete();\n+    }\n+  }\n+\n+  @Override\n+  public BatchSemiAggregate prepareBatchVerify(\n+      int index, List<? extends PublicKey> publicKeys, Bytes message, Signature signature) {\n+\n+    BlstPublicKey aggrPubKey = aggregatePublicKeys(publicKeys);\n+    BlstSignature blstSignature = (BlstSignature) signature;\n+    if (aggrPubKey.isInfinity() || blstSignature.isInfinity()) {\n+      return new BlstInfiniteSemiAggregate(aggrPubKey.isInfinity() && blstSignature.isInfinity());\n+    }\n+    return blstPrepareBatchVerify(aggrPubKey, message, blstSignature);\n+  }\n+\n+  BatchSemiAggregate blstPrepareBatchVerify(\n+      BlstPublicKey pubKey, Bytes message, BlstSignature blstSignature) {\n+\n+    p2 g2Hash = HashToCurve.hashToG2(message);\n+    p2_affine p2Affine = new p2_affine();\n+    blst.p2_to_affine(p2Affine, g2Hash);\n+\n+    pairing ctx = new pairing();\n+    try {\n+      blst.pairing_init(ctx);\n+      BLST_ERROR ret =\n+          blst.pairing_mul_n_aggregate_pk_in_g1(\n+              ctx,\n+              pubKey.ecPoint,\n+              blstSignature.ec2Point,\n+              p2Affine,\n+              nextBatchRandomMultiplier(),\n+              BATCH_RANDOM_BYTES * 8);\n+      if (ret != BLST_ERROR.BLST_SUCCESS) throw new IllegalArgumentException(\"Error: \" + ret);\n+    } catch (Exception e) {\n+      ctx.delete();\n+      throw e;\n+    } finally {\n+      g2Hash.delete();\n+      p2Affine.delete(); // not sure if its copied inside pairing_mul_n_aggregate_pk_in_g1\n+    }\n+    blst.pairing_commit(ctx);\n+\n+    return new BlstFiniteSemiAggregate(ctx);\n+  }\n+\n+  @Override\n+  public BatchSemiAggregate prepareBatchVerify2(\n+      int index,\n+      List<? extends PublicKey> publicKeys1,\n+      Bytes message1,\n+      Signature signature1,\n+      List<? extends PublicKey> publicKeys2,\n+      Bytes message2,\n+      Signature signature2) {\n+    BatchSemiAggregate aggregate1 = prepareBatchVerify(index, publicKeys1, message1, signature1);\n+    BatchSemiAggregate aggregate2 =\n+        prepareBatchVerify(index + 1, publicKeys2, message2, signature2);\n+\n+    return BlstFiniteSemiAggregate.merge(aggregate1, aggregate2);\n+  }\n+\n+  @Override\n+  public boolean completeBatchVerify(List<? extends BatchSemiAggregate> preparedList) {\n+    boolean anyInvalidDummy =\n+        preparedList.stream()\n+            .filter(a -> a instanceof BlstInfiniteSemiAggregate)\n+            .map(a -> (BlstInfiniteSemiAggregate) a)\n+            .anyMatch(a -> !a.isValid());\n+\n+    List<BlstFiniteSemiAggregate> blstList =\n+        preparedList.stream()\n+            .filter(a -> a instanceof BlstFiniteSemiAggregate)\n+            .map(b -> (BlstFiniteSemiAggregate) b)\n+            .collect(Collectors.toList());\n+\n+    if (blstList.isEmpty()) {\n+      return true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa8ec9862ed4dcda26ef467d981198c71be8c84d"}, "originalPosition": 236}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzAwODgwOQ==", "bodyText": "Thanks good catch! Fixed that way: 7447b6f", "url": "https://github.com/ConsenSys/teku/pull/2453#discussion_r463008809", "createdAt": "2020-07-30T13:48:12Z", "author": {"login": "Nashatyrev"}, "path": "bls/src/main/java/tech/pegasys/teku/bls/impl/blst/BlstBLS12381.java", "diffHunk": "@@ -0,0 +1,256 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.bls.impl.blst;\n+\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.ThreadLocalRandom;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.apache.tuweni.bytes.Bytes48;\n+import tech.pegasys.teku.bls.BatchSemiAggregate;\n+import tech.pegasys.teku.bls.impl.BLS12381;\n+import tech.pegasys.teku.bls.impl.KeyPair;\n+import tech.pegasys.teku.bls.impl.PublicKey;\n+import tech.pegasys.teku.bls.impl.Signature;\n+import tech.pegasys.teku.bls.impl.blst.swig.BLST_ERROR;\n+import tech.pegasys.teku.bls.impl.blst.swig.blst;\n+import tech.pegasys.teku.bls.impl.blst.swig.p2;\n+import tech.pegasys.teku.bls.impl.blst.swig.p2_affine;\n+import tech.pegasys.teku.bls.impl.blst.swig.pairing;\n+\n+public class BlstBLS12381 implements BLS12381 {\n+\n+  public static BlstBLS12381 INSTANCE = new BlstBLS12381();\n+\n+  private static final int BATCH_RANDOM_BYTES = 8;\n+\n+  static {\n+    try {\n+      NativeUtils.loadLibraryFromJar(\"/\" + System.mapLibraryName(\"jblst\"));\n+    } catch (IOException e) {\n+      throw new RuntimeException(e);\n+    }\n+  }\n+\n+  private static Random getRND() {\n+    // Milagro RAND has some issues with generating 'small' random numbers\n+    // and is not thread safe\n+    // Using non-secure random due to the JDK Linux secure random issue:\n+    // https://bugs.java.com/bugdatabase/view_bug.do?bug_id=6521844\n+    // A potential attack here has a very limited application and is not feasible\n+    // Thus using non-secure random doesn't significantly mitigate the security\n+    return ThreadLocalRandom.current();\n+  }\n+\n+  public static BlstSignature sign(BlstSecretKey secretKey, Bytes message) {\n+    p2 p2Signature = new p2();\n+    p2 hash = HashToCurve.hashToG2(message);\n+    blst.sign_pk_in_g1(p2Signature, hash, secretKey.getScalarVal());\n+    p2_affine p2SignatureAffine = new p2_affine();\n+    blst.p2_to_affine(p2SignatureAffine, p2Signature);\n+    p2Signature.delete();\n+    hash.delete();\n+    return new BlstSignature(p2SignatureAffine, true);\n+  }\n+\n+  public static boolean verify(BlstPublicKey publicKey, Bytes message, BlstSignature signature) {\n+    if (publicKey.isInfinity() || signature.isInfinity()) {\n+      return publicKey.isInfinity() && signature.isInfinity();\n+    }\n+    BLST_ERROR res =\n+        blst.core_verify_pk_in_g1(\n+            publicKey.ecPoint,\n+            signature.ec2Point,\n+            1,\n+            message.toArrayUnsafe(),\n+            HashToCurve.ETH2_DST.toArrayUnsafe(),\n+            new byte[0]);\n+    return res == BLST_ERROR.BLST_SUCCESS;\n+  }\n+\n+  @Override\n+  public KeyPair generateKeyPair(Random random) {\n+    BlstSecretKey secretKey = BlstSecretKey.generateNew(random);\n+    return new KeyPair(secretKey);\n+  }\n+\n+  @Override\n+  public BlstPublicKey publicKeyFromCompressed(Bytes48 compressedPublicKeyBytes) {\n+    return BlstPublicKey.fromBytes(compressedPublicKeyBytes);\n+  }\n+\n+  @Override\n+  public BlstSignature signatureFromCompressed(Bytes compressedSignatureBytes) {\n+    return BlstSignature.fromBytes(compressedSignatureBytes);\n+  }\n+\n+  @Override\n+  public BlstSecretKey secretKeyFromBytes(Bytes32 secretKeyBytes) {\n+    return BlstSecretKey.fromBytes(secretKeyBytes);\n+  }\n+\n+  @Override\n+  public BlstPublicKey aggregatePublicKeys(List<? extends PublicKey> publicKeys) {\n+    return BlstPublicKey.aggregate(\n+        publicKeys.stream().map(k -> (BlstPublicKey) k).collect(Collectors.toList()));\n+  }\n+\n+  @Override\n+  public BlstSignature aggregateSignatures(List<? extends Signature> signatures) {\n+    return BlstSignature.aggregate(\n+        signatures.stream().map(s -> (BlstSignature) s).collect(Collectors.toList()));\n+  }\n+\n+  pairing blstPrepareVerifyAggregated(\n+      BlstPublicKey pubKey, Bytes message, pairing ctx, BlstSignature blstSignature) {\n+\n+    p2 g2Hash = HashToCurve.hashToG2(message);\n+    p2_affine p2Affine = new p2_affine();\n+    blst.p2_to_affine(p2Affine, g2Hash);\n+\n+    if (ctx == null) {\n+      ctx = new pairing();\n+      blst.pairing_init(ctx);\n+    }\n+\n+    try {\n+      BLST_ERROR ret =\n+          blst.pairing_aggregate_pk_in_g1(\n+              ctx,\n+              pubKey.ecPoint,\n+              blstSignature == null ? null : blstSignature.ec2Point,\n+              1,\n+              message.toArrayUnsafe(),\n+              HashToCurve.ETH2_DST.toArrayUnsafe(),\n+              null);\n+      if (ret != BLST_ERROR.BLST_SUCCESS) throw new IllegalArgumentException(\"Error: \" + ret);\n+    } catch (Exception e) {\n+      ctx.delete();\n+      throw e;\n+    } finally {\n+      g2Hash.delete();\n+      p2Affine.delete(); // not sure if its copied inside pairing_mul_n_aggregate_pk_in_g1\n+    }\n+\n+    return ctx;\n+  }\n+\n+  boolean blstCompleteVerifyAggregated(pairing ctx) {\n+    try {\n+      blst.pairing_commit(ctx);\n+      return blst.pairing_finalverify(ctx, null) > 0;\n+    } finally {\n+      ctx.delete();\n+    }\n+  }\n+\n+  @Override\n+  public BatchSemiAggregate prepareBatchVerify(\n+      int index, List<? extends PublicKey> publicKeys, Bytes message, Signature signature) {\n+\n+    BlstPublicKey aggrPubKey = aggregatePublicKeys(publicKeys);\n+    BlstSignature blstSignature = (BlstSignature) signature;\n+    if (aggrPubKey.isInfinity() || blstSignature.isInfinity()) {\n+      return new BlstInfiniteSemiAggregate(aggrPubKey.isInfinity() && blstSignature.isInfinity());\n+    }\n+    return blstPrepareBatchVerify(aggrPubKey, message, blstSignature);\n+  }\n+\n+  BatchSemiAggregate blstPrepareBatchVerify(\n+      BlstPublicKey pubKey, Bytes message, BlstSignature blstSignature) {\n+\n+    p2 g2Hash = HashToCurve.hashToG2(message);\n+    p2_affine p2Affine = new p2_affine();\n+    blst.p2_to_affine(p2Affine, g2Hash);\n+\n+    pairing ctx = new pairing();\n+    try {\n+      blst.pairing_init(ctx);\n+      BLST_ERROR ret =\n+          blst.pairing_mul_n_aggregate_pk_in_g1(\n+              ctx,\n+              pubKey.ecPoint,\n+              blstSignature.ec2Point,\n+              p2Affine,\n+              nextBatchRandomMultiplier(),\n+              BATCH_RANDOM_BYTES * 8);\n+      if (ret != BLST_ERROR.BLST_SUCCESS) throw new IllegalArgumentException(\"Error: \" + ret);\n+    } catch (Exception e) {\n+      ctx.delete();\n+      throw e;\n+    } finally {\n+      g2Hash.delete();\n+      p2Affine.delete(); // not sure if its copied inside pairing_mul_n_aggregate_pk_in_g1\n+    }\n+    blst.pairing_commit(ctx);\n+\n+    return new BlstFiniteSemiAggregate(ctx);\n+  }\n+\n+  @Override\n+  public BatchSemiAggregate prepareBatchVerify2(\n+      int index,\n+      List<? extends PublicKey> publicKeys1,\n+      Bytes message1,\n+      Signature signature1,\n+      List<? extends PublicKey> publicKeys2,\n+      Bytes message2,\n+      Signature signature2) {\n+    BatchSemiAggregate aggregate1 = prepareBatchVerify(index, publicKeys1, message1, signature1);\n+    BatchSemiAggregate aggregate2 =\n+        prepareBatchVerify(index + 1, publicKeys2, message2, signature2);\n+\n+    return BlstFiniteSemiAggregate.merge(aggregate1, aggregate2);\n+  }\n+\n+  @Override\n+  public boolean completeBatchVerify(List<? extends BatchSemiAggregate> preparedList) {\n+    boolean anyInvalidDummy =\n+        preparedList.stream()\n+            .filter(a -> a instanceof BlstInfiniteSemiAggregate)\n+            .map(a -> (BlstInfiniteSemiAggregate) a)\n+            .anyMatch(a -> !a.isValid());\n+\n+    List<BlstFiniteSemiAggregate> blstList =\n+        preparedList.stream()\n+            .filter(a -> a instanceof BlstFiniteSemiAggregate)\n+            .map(b -> (BlstFiniteSemiAggregate) b)\n+            .collect(Collectors.toList());\n+\n+    if (blstList.isEmpty()) {\n+      return true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjcwOTI4MQ=="}, "originalCommit": {"oid": "fa8ec9862ed4dcda26ef467d981198c71be8c84d"}, "originalPosition": 236}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4ODg2ODY5OnYy", "diffSide": "RIGHT", "path": "bls/src/main/java/tech/pegasys/teku/bls/impl/blst/BlstPublicKey.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwMzoyMDoyOVrOG5Rn1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwNTowNzo1NFrOG5TTmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjcxMDc0MQ==", "bodyText": "Slightly surprised that if you aggregate a mix of finite and infinite keys you get a finite key back and the infinite keys are essentially just ignored.", "url": "https://github.com/ConsenSys/teku/pull/2453#discussion_r462710741", "createdAt": "2020-07-30T03:20:29Z", "author": {"login": "ajsutton"}, "path": "bls/src/main/java/tech/pegasys/teku/bls/impl/blst/BlstPublicKey.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.bls.impl.blst;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes48;\n+import tech.pegasys.teku.bls.impl.PublicKey;\n+import tech.pegasys.teku.bls.impl.blst.swig.BLST_ERROR;\n+import tech.pegasys.teku.bls.impl.blst.swig.blst;\n+import tech.pegasys.teku.bls.impl.blst.swig.p1;\n+import tech.pegasys.teku.bls.impl.blst.swig.p1_affine;\n+\n+public class BlstPublicKey implements PublicKey {\n+  private static final int COMPRESSED_PK_SIZE = 48;\n+  private static final int UNCOMPRESSED_PK_LENGTH = 96;\n+\n+  static final Bytes48 INFINITY_COMPRESSED_BYTES =\n+      Bytes48.fromHexString(\n+          \"0x\"\n+              + \"c0000000000000000000000000000000\"\n+              + \"00000000000000000000000000000000\"\n+              + \"00000000000000000000000000000000\");\n+\n+  static final BlstPublicKey INFINITY =\n+      new BlstPublicKey(null) {\n+        @Override\n+        public void forceValidation() {}\n+\n+        @Override\n+        public Bytes48 toBytesCompressed() {\n+          return INFINITY_COMPRESSED_BYTES;\n+        }\n+\n+        @Override\n+        public Bytes toBytesUncompressed() {\n+          throw new UnsupportedOperationException();\n+        }\n+      };\n+\n+  public static BlstPublicKey fromBytesUncompressed(Bytes uncompressed) {\n+    checkArgument(uncompressed.size() == UNCOMPRESSED_PK_LENGTH);\n+    p1_affine ecPoint = new p1_affine();\n+    if (blst.p1_deserialize(ecPoint, uncompressed.toArrayUnsafe()) == BLST_ERROR.BLST_SUCCESS) {\n+      return new BlstPublicKey(ecPoint);\n+    } else {\n+      ecPoint.delete();\n+      throw new IllegalArgumentException(\"Invalid PublicKey bytes: \" + uncompressed);\n+    }\n+  }\n+\n+  public static BlstPublicKey fromBytes(Bytes48 compressed) {\n+    if (compressed.equals(INFINITY_COMPRESSED_BYTES)) {\n+      return INFINITY;\n+    }\n+    p1_affine ecPoint = new p1_affine();\n+    if (blst.p1_uncompress(ecPoint, compressed.toArrayUnsafe()) == BLST_ERROR.BLST_SUCCESS) {\n+      return new BlstPublicKey(ecPoint);\n+    } else {\n+      ecPoint.delete();\n+      throw new IllegalArgumentException(\"Invalid PublicKey bytes: \" + compressed);\n+    }\n+  }\n+\n+  public static BlstPublicKey aggregate(List<BlstPublicKey> publicKeys) {\n+    checkArgument(publicKeys.size() > 0);\n+\n+    List<BlstPublicKey> finitePublicKeys =\n+        publicKeys.stream().filter(pk -> !pk.isInfinity()).collect(Collectors.toList());\n+    if (finitePublicKeys.isEmpty()) {\n+      return BlstPublicKey.INFINITY;\n+    }\n+\n+    p1 sum = new p1();\n+    blst.p1_from_affine(sum, finitePublicKeys.get(0).ecPoint);\n+    for (int i = 1; i < finitePublicKeys.size(); i++) {\n+      blst.p1_add_or_double_affine(sum, sum, finitePublicKeys.get(i).ecPoint);\n+    }\n+    p1_affine res = new p1_affine();\n+    blst.p1_to_affine(res, sum);\n+    sum.delete();\n+\n+    return new BlstPublicKey(res);\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa8ec9862ed4dcda26ef467d981198c71be8c84d"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjczODMyOQ==", "bodyText": "In elliptic curve arithmetic, the \"point at infinity\" is the identity. It's weird terminology, but adding the point at infinity is like adding zero to a number, or multiplying by one, so you can safely skip it.", "url": "https://github.com/ConsenSys/teku/pull/2453#discussion_r462738329", "createdAt": "2020-07-30T05:07:54Z", "author": {"login": "benjaminion"}, "path": "bls/src/main/java/tech/pegasys/teku/bls/impl/blst/BlstPublicKey.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.bls.impl.blst;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes48;\n+import tech.pegasys.teku.bls.impl.PublicKey;\n+import tech.pegasys.teku.bls.impl.blst.swig.BLST_ERROR;\n+import tech.pegasys.teku.bls.impl.blst.swig.blst;\n+import tech.pegasys.teku.bls.impl.blst.swig.p1;\n+import tech.pegasys.teku.bls.impl.blst.swig.p1_affine;\n+\n+public class BlstPublicKey implements PublicKey {\n+  private static final int COMPRESSED_PK_SIZE = 48;\n+  private static final int UNCOMPRESSED_PK_LENGTH = 96;\n+\n+  static final Bytes48 INFINITY_COMPRESSED_BYTES =\n+      Bytes48.fromHexString(\n+          \"0x\"\n+              + \"c0000000000000000000000000000000\"\n+              + \"00000000000000000000000000000000\"\n+              + \"00000000000000000000000000000000\");\n+\n+  static final BlstPublicKey INFINITY =\n+      new BlstPublicKey(null) {\n+        @Override\n+        public void forceValidation() {}\n+\n+        @Override\n+        public Bytes48 toBytesCompressed() {\n+          return INFINITY_COMPRESSED_BYTES;\n+        }\n+\n+        @Override\n+        public Bytes toBytesUncompressed() {\n+          throw new UnsupportedOperationException();\n+        }\n+      };\n+\n+  public static BlstPublicKey fromBytesUncompressed(Bytes uncompressed) {\n+    checkArgument(uncompressed.size() == UNCOMPRESSED_PK_LENGTH);\n+    p1_affine ecPoint = new p1_affine();\n+    if (blst.p1_deserialize(ecPoint, uncompressed.toArrayUnsafe()) == BLST_ERROR.BLST_SUCCESS) {\n+      return new BlstPublicKey(ecPoint);\n+    } else {\n+      ecPoint.delete();\n+      throw new IllegalArgumentException(\"Invalid PublicKey bytes: \" + uncompressed);\n+    }\n+  }\n+\n+  public static BlstPublicKey fromBytes(Bytes48 compressed) {\n+    if (compressed.equals(INFINITY_COMPRESSED_BYTES)) {\n+      return INFINITY;\n+    }\n+    p1_affine ecPoint = new p1_affine();\n+    if (blst.p1_uncompress(ecPoint, compressed.toArrayUnsafe()) == BLST_ERROR.BLST_SUCCESS) {\n+      return new BlstPublicKey(ecPoint);\n+    } else {\n+      ecPoint.delete();\n+      throw new IllegalArgumentException(\"Invalid PublicKey bytes: \" + compressed);\n+    }\n+  }\n+\n+  public static BlstPublicKey aggregate(List<BlstPublicKey> publicKeys) {\n+    checkArgument(publicKeys.size() > 0);\n+\n+    List<BlstPublicKey> finitePublicKeys =\n+        publicKeys.stream().filter(pk -> !pk.isInfinity()).collect(Collectors.toList());\n+    if (finitePublicKeys.isEmpty()) {\n+      return BlstPublicKey.INFINITY;\n+    }\n+\n+    p1 sum = new p1();\n+    blst.p1_from_affine(sum, finitePublicKeys.get(0).ecPoint);\n+    for (int i = 1; i < finitePublicKeys.size(); i++) {\n+      blst.p1_add_or_double_affine(sum, sum, finitePublicKeys.get(i).ecPoint);\n+    }\n+    p1_affine res = new p1_affine();\n+    blst.p1_to_affine(res, sum);\n+    sum.delete();\n+\n+    return new BlstPublicKey(res);\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjcxMDc0MQ=="}, "originalCommit": {"oid": "fa8ec9862ed4dcda26ef467d981198c71be8c84d"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4ODkwMzgzOnYy", "diffSide": "LEFT", "path": "bls/src/test/java/tech/pegasys/teku/bls/BLSPublicKeyTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwMzo0MToxNFrOG5R8Qg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxMzo1OTowMlrOG5kSgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjcxNTk3MA==", "bodyText": "We seem to have lost tests that confirm we can load a BLSPublicKey with an invalid point and safely compare them.  We need to ensure that deposits with invalid public keys can still be processed correctly when included in blocks (which depends on creating BLSPublicKey instances for invalid points and calling equals and hashCode.", "url": "https://github.com/ConsenSys/teku/pull/2453#discussion_r462715970", "createdAt": "2020-07-30T03:41:14Z", "author": {"login": "ajsutton"}, "path": "bls/src/test/java/tech/pegasys/teku/bls/BLSPublicKeyTest.java", "diffHunk": "@@ -50,44 +54,29 @@ void succeedsWhenEqualsReturnsTrueForTheSameEmptyPublicKey() {\n   @Test\n   void succeedsWhenTwoInfinityPublicKeysAreEqual() {\n     // Infinity keys are valid G1 points, so pass the equality test\n-    BLSPublicKey publicKey1 = BLSPublicKey.fromBytes(InfinityPublicKey);\n-    BLSPublicKey publicKey2 = BLSPublicKey.fromBytes(InfinityPublicKey);\n+    BLSPublicKey publicKey1 = BLSPublicKey.fromSSZBytes(InfinityPublicKey);\n+    BLSPublicKey publicKey2 = BLSPublicKey.fromSSZBytes(InfinityPublicKey);\n     assertEquals(publicKey1, publicKey2);\n   }\n \n   @Test\n-  void succeedsWhenInvalidPublicKeyIsInvalid() {\n-    BLSPublicKey invalidPublicKey =\n-        BLSPublicKey.fromBytesCompressed(\n-            Bytes.fromHexString(\n-                \"0x9378a6e3984e96d2cd50450c76ca14732f1300efa04aecdb805b22e6d6926a85ef409e8f3acf494a1481090bf32ce3bd\"));\n-    assertFalse(invalidPublicKey.isValid());\n-  }\n-\n-  @Test\n-  void succeedsWhenComparingInvalidAndValidPublicKeyFails() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa8ec9862ed4dcda26ef467d981198c71be8c84d"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzAxNjU3OA==", "bodyText": "Right, thanks for catching this \ud83d\udc4d\nReviewed a couple of times for lost tests but still missed this one", "url": "https://github.com/ConsenSys/teku/pull/2453#discussion_r463016578", "createdAt": "2020-07-30T13:59:02Z", "author": {"login": "Nashatyrev"}, "path": "bls/src/test/java/tech/pegasys/teku/bls/BLSPublicKeyTest.java", "diffHunk": "@@ -50,44 +54,29 @@ void succeedsWhenEqualsReturnsTrueForTheSameEmptyPublicKey() {\n   @Test\n   void succeedsWhenTwoInfinityPublicKeysAreEqual() {\n     // Infinity keys are valid G1 points, so pass the equality test\n-    BLSPublicKey publicKey1 = BLSPublicKey.fromBytes(InfinityPublicKey);\n-    BLSPublicKey publicKey2 = BLSPublicKey.fromBytes(InfinityPublicKey);\n+    BLSPublicKey publicKey1 = BLSPublicKey.fromSSZBytes(InfinityPublicKey);\n+    BLSPublicKey publicKey2 = BLSPublicKey.fromSSZBytes(InfinityPublicKey);\n     assertEquals(publicKey1, publicKey2);\n   }\n \n   @Test\n-  void succeedsWhenInvalidPublicKeyIsInvalid() {\n-    BLSPublicKey invalidPublicKey =\n-        BLSPublicKey.fromBytesCompressed(\n-            Bytes.fromHexString(\n-                \"0x9378a6e3984e96d2cd50450c76ca14732f1300efa04aecdb805b22e6d6926a85ef409e8f3acf494a1481090bf32ce3bd\"));\n-    assertFalse(invalidPublicKey.isValid());\n-  }\n-\n-  @Test\n-  void succeedsWhenComparingInvalidAndValidPublicKeyFails() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjcxNTk3MA=="}, "originalCommit": {"oid": "fa8ec9862ed4dcda26ef467d981198c71be8c84d"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4ODkzNjM4OnYy", "diffSide": "RIGHT", "path": "bls/src/test/java/tech/pegasys/teku/bls/impl/blst/BlstPublicKeyTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwNDowMToxMVrOG5SO6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxNDowMTo0M1rOG5kazw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjcyMDc0NQ==", "bodyText": "Why disabled?", "url": "https://github.com/ConsenSys/teku/pull/2453#discussion_r462720745", "createdAt": "2020-07-30T04:01:11Z", "author": {"login": "ajsutton"}, "path": "bls/src/test/java/tech/pegasys/teku/bls/impl/blst/BlstPublicKeyTest.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.bls.impl.blst;\n+\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes48;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n+\n+public class BlstPublicKeyTest {\n+\n+  @BeforeAll\n+  static void setup() {\n+    BlstBLS12381.INSTANCE.hashCode();\n+  }\n+\n+  @Disabled", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa8ec9862ed4dcda26ef467d981198c71be8c84d"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzAxODcwMw==", "bodyText": "Left comment there:\n  // Blst library doesn't handle infinity pubkeys at the moment.\n  // Could enable the test when the issue https://github.com/supranational/blst/issues/11 is\n  // addressed", "url": "https://github.com/ConsenSys/teku/pull/2453#discussion_r463018703", "createdAt": "2020-07-30T14:01:43Z", "author": {"login": "Nashatyrev"}, "path": "bls/src/test/java/tech/pegasys/teku/bls/impl/blst/BlstPublicKeyTest.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.bls.impl.blst;\n+\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes48;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n+\n+public class BlstPublicKeyTest {\n+\n+  @BeforeAll\n+  static void setup() {\n+    BlstBLS12381.INSTANCE.hashCode();\n+  }\n+\n+  @Disabled", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjcyMDc0NQ=="}, "originalCommit": {"oid": "fa8ec9862ed4dcda26ef467d981198c71be8c84d"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4ODkzODQ5OnYy", "diffSide": "RIGHT", "path": "bls/src/test/java/tech/pegasys/teku/bls/impl/mikuli/MikuliPublicKeyTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwNDowMjoyMVrOG5SQHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwNDowMjoyMVrOG5SQHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjcyMTA1NQ==", "bodyText": "Probably shouldn't have a System.out.println here and should assert something instead?", "url": "https://github.com/ConsenSys/teku/pull/2453#discussion_r462721055", "createdAt": "2020-07-30T04:02:21Z", "author": {"login": "ajsutton"}, "path": "bls/src/test/java/tech/pegasys/teku/bls/impl/mikuli/MikuliPublicKeyTest.java", "diffHunk": "@@ -47,22 +47,36 @@ void succeedsWhenTwoInfinityPublicKeysAreEqual() {\n \n   @Test\n   void succeedsIfDeserializationOfInfinityPublicKeyIsCorrect() {\n-    BLSPublicKey infinityPublicKey = new BLSPublicKey(new MikuliPublicKey(new G1Point()));\n+    MikuliPublicKey infinityPublicKey = new MikuliPublicKey(new G1Point());\n     byte[] pointBytes = new byte[48];\n     pointBytes[0] = (byte) 0xc0;\n     Bytes infinityBytesSsz =\n         SSZ.encode(\n             writer -> {\n               writer.writeFixedBytes(Bytes.wrap(pointBytes));\n             });\n-    BLSPublicKey deserializedPublicKey = BLSPublicKey.fromBytes(infinityBytesSsz);\n+    MikuliPublicKey deserializedPublicKey = MikuliPublicKey.fromBytesCompressed(infinityBytesSsz);\n     assertEquals(infinityPublicKey, deserializedPublicKey);\n   }\n \n   @Test\n   void succeedsWhenRoundtripSSZReturnsTheInfinityPublicKey() {\n-    BLSPublicKey publicKey1 = new BLSPublicKey(new MikuliPublicKey(new G1Point()));\n-    BLSPublicKey publicKey2 = BLSPublicKey.fromBytes(publicKey1.toBytes());\n+    MikuliPublicKey publicKey1 = new MikuliPublicKey(new G1Point());\n+    MikuliPublicKey publicKey2 =\n+        MikuliPublicKey.fromBytesCompressed(publicKey1.toBytesCompressed());\n     assertEquals(publicKey1, publicKey2);\n   }\n+\n+  @Test\n+  void infinityPublicKeyIsValid() {\n+    MikuliPublicKey infinityG1 =\n+        MikuliPublicKey.fromBytesCompressed(\n+            Bytes48.fromHexString(\n+                \"0x\"\n+                    + \"c0000000000000000000000000000000\"\n+                    + \"00000000000000000000000000000000\"\n+                    + \"00000000000000000000000000000000\"));\n+    infinityG1.forceValidation();\n+    System.out.println(infinityG1.g1Point());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa8ec9862ed4dcda26ef467d981198c71be8c84d"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4ODk0NDMzOnYy", "diffSide": "RIGHT", "path": "gradle/check-licenses.gradle", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwNDowNTo0MlrOG5STZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwNDowNTo0MlrOG5STZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjcyMTg5Mw==", "bodyText": "We should probably log a ticket to get the license information included in the blst native jar.  I can't remember the magic incantation and its not a priority but something we should do when we setup a full CI for it and then we shouldn't need this.", "url": "https://github.com/ConsenSys/teku/pull/2453#discussion_r462721893", "createdAt": "2020-07-30T04:05:42Z", "author": {"login": "ajsutton"}, "path": "gradle/check-licenses.gradle", "diffHunk": "@@ -169,6 +169,7 @@ downloadLicenses {\n       //JMH-Core is licensed under GPLv2 with the Classpath Exception, which allows us to link it and license the derived work under our license.\n       'org.openjdk.jmh:jmh-core:1.21': apache,\n       (group('io.libp2p')): apache,\n+      (group('tech.pegasys')): apache,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa8ec9862ed4dcda26ef467d981198c71be8c84d"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5MDQ4Nzg5OnYy", "diffSide": "RIGHT", "path": "bls/src/main/java/tech/pegasys/teku/bls/BLS.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxMjozMjo0MlrOG5g-cg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxNzo0OTo0NlrOG5tkhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk2MjI5MA==", "bodyText": "As per the code comment higher up the file, my intention was that this BLS class follows the standard as closely as possible. There is no function similar to aggregatePublicKeys in the standard, and it seems only to be used in testing, so suggest moving it to a test class.", "url": "https://github.com/ConsenSys/teku/pull/2453#discussion_r462962290", "createdAt": "2020-07-30T12:32:42Z", "author": {"login": "benjaminion"}, "path": "bls/src/main/java/tech/pegasys/teku/bls/BLS.java", "diffHunk": "@@ -80,6 +91,13 @@ public static boolean verify(BLSPublicKey publicKey, Bytes message, BLSSignature\n     return signature.getSignature().verify(publicKey.getPublicKey(), message);\n   }\n \n+  public static BLSPublicKey aggregatePublicKeys(List<BLSPublicKey> publicKeys) {\n+    return new BLSPublicKey(\n+        getBlsImpl()\n+            .aggregatePublicKeys(\n+                publicKeys.stream().map(BLSPublicKey::getPublicKey).collect(Collectors.toList())));\n+  }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa8ec9862ed4dcda26ef467d981198c71be8c84d"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzA1NzcwMA==", "bodyText": "Honestly speaking I would love to leave aggregatePublicKeys public assuming that our bls module can potentially be used by other projects. What do think of making this method static PublicKey.aggregate() and then I could rollback aggregateSignatures name", "url": "https://github.com/ConsenSys/teku/pull/2453#discussion_r463057700", "createdAt": "2020-07-30T14:55:23Z", "author": {"login": "Nashatyrev"}, "path": "bls/src/main/java/tech/pegasys/teku/bls/BLS.java", "diffHunk": "@@ -80,6 +91,13 @@ public static boolean verify(BLSPublicKey publicKey, Bytes message, BLSSignature\n     return signature.getSignature().verify(publicKey.getPublicKey(), message);\n   }\n \n+  public static BLSPublicKey aggregatePublicKeys(List<BLSPublicKey> publicKeys) {\n+    return new BLSPublicKey(\n+        getBlsImpl()\n+            .aggregatePublicKeys(\n+                publicKeys.stream().map(BLSPublicKey::getPublicKey).collect(Collectors.toList())));\n+  }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk2MjI5MA=="}, "originalCommit": {"oid": "fa8ec9862ed4dcda26ef467d981198c71be8c84d"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzEwODY2OQ==", "bodyText": "Well... imo other projects should be encouraged to follow the BLS standard, in which case they don't need aggregatePublicKeys (except maybe for testing).  Your proposal is fine, though.", "url": "https://github.com/ConsenSys/teku/pull/2453#discussion_r463108669", "createdAt": "2020-07-30T16:08:24Z", "author": {"login": "benjaminion"}, "path": "bls/src/main/java/tech/pegasys/teku/bls/BLS.java", "diffHunk": "@@ -80,6 +91,13 @@ public static boolean verify(BLSPublicKey publicKey, Bytes message, BLSSignature\n     return signature.getSignature().verify(publicKey.getPublicKey(), message);\n   }\n \n+  public static BLSPublicKey aggregatePublicKeys(List<BLSPublicKey> publicKeys) {\n+    return new BLSPublicKey(\n+        getBlsImpl()\n+            .aggregatePublicKeys(\n+                publicKeys.stream().map(BLSPublicKey::getPublicKey).collect(Collectors.toList())));\n+  }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk2MjI5MA=="}, "originalCommit": {"oid": "fa8ec9862ed4dcda26ef467d981198c71be8c84d"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE1ODkzOA==", "bodyText": "Just though of one possible use case: if a hypothetical 'BLSCoin' has public keys == addresses there could be multisig addresses created by signers addresses aggregation :)", "url": "https://github.com/ConsenSys/teku/pull/2453#discussion_r463158938", "createdAt": "2020-07-30T17:32:09Z", "author": {"login": "Nashatyrev"}, "path": "bls/src/main/java/tech/pegasys/teku/bls/BLS.java", "diffHunk": "@@ -80,6 +91,13 @@ public static boolean verify(BLSPublicKey publicKey, Bytes message, BLSSignature\n     return signature.getSignature().verify(publicKey.getPublicKey(), message);\n   }\n \n+  public static BLSPublicKey aggregatePublicKeys(List<BLSPublicKey> publicKeys) {\n+    return new BLSPublicKey(\n+        getBlsImpl()\n+            .aggregatePublicKeys(\n+                publicKeys.stream().map(BLSPublicKey::getPublicKey).collect(Collectors.toList())));\n+  }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk2MjI5MA=="}, "originalCommit": {"oid": "fa8ec9862ed4dcda26ef467d981198c71be8c84d"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE2ODY0NQ==", "bodyText": "Done: b60a046", "url": "https://github.com/ConsenSys/teku/pull/2453#discussion_r463168645", "createdAt": "2020-07-30T17:49:46Z", "author": {"login": "Nashatyrev"}, "path": "bls/src/main/java/tech/pegasys/teku/bls/BLS.java", "diffHunk": "@@ -80,6 +91,13 @@ public static boolean verify(BLSPublicKey publicKey, Bytes message, BLSSignature\n     return signature.getSignature().verify(publicKey.getPublicKey(), message);\n   }\n \n+  public static BLSPublicKey aggregatePublicKeys(List<BLSPublicKey> publicKeys) {\n+    return new BLSPublicKey(\n+        getBlsImpl()\n+            .aggregatePublicKeys(\n+                publicKeys.stream().map(BLSPublicKey::getPublicKey).collect(Collectors.toList())));\n+  }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk2MjI5MA=="}, "originalCommit": {"oid": "fa8ec9862ed4dcda26ef467d981198c71be8c84d"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5MDQ5NDAxOnYy", "diffSide": "RIGHT", "path": "bls/src/main/java/tech/pegasys/teku/bls/BLS.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxMjozNDoyN1rOG5hCCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxNDo1NTo0N1rOG5m0UA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk2MzIwOQ==", "bodyText": "As per my comment on aggregatePublicKeys - if that is moved elsewhere, then this can be reverted to the same name it has in the standard (i.e. aggregate() - modulo a captial letter).", "url": "https://github.com/ConsenSys/teku/pull/2453#discussion_r462963209", "createdAt": "2020-07-30T12:34:27Z", "author": {"login": "benjaminion"}, "path": "bls/src/main/java/tech/pegasys/teku/bls/BLS.java", "diffHunk": "@@ -91,8 +109,10 @@ public static boolean verify(BLSPublicKey publicKey, Bytes message, BLSSignature\n    *\n    * @param signatures the list of signatures to be aggregated\n    * @return the aggregated signature\n+   * @throws IllegalArgumentException if any of supplied signatures is invalid\n    */\n-  public static BLSSignature aggregate(List<BLSSignature> signatures) {\n+  public static BLSSignature aggregateSignatures(List<BLSSignature> signatures)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa8ec9862ed4dcda26ef467d981198c71be8c84d"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzA1ODAwMA==", "bodyText": "Commented on aggregatePublicKeys", "url": "https://github.com/ConsenSys/teku/pull/2453#discussion_r463058000", "createdAt": "2020-07-30T14:55:47Z", "author": {"login": "Nashatyrev"}, "path": "bls/src/main/java/tech/pegasys/teku/bls/BLS.java", "diffHunk": "@@ -91,8 +109,10 @@ public static boolean verify(BLSPublicKey publicKey, Bytes message, BLSSignature\n    *\n    * @param signatures the list of signatures to be aggregated\n    * @return the aggregated signature\n+   * @throws IllegalArgumentException if any of supplied signatures is invalid\n    */\n-  public static BLSSignature aggregate(List<BLSSignature> signatures) {\n+  public static BLSSignature aggregateSignatures(List<BLSSignature> signatures)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk2MzIwOQ=="}, "originalCommit": {"oid": "fa8ec9862ed4dcda26ef467d981198c71be8c84d"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5MDUzNTk5OnYy", "diffSide": "RIGHT", "path": "bls/src/main/java/tech/pegasys/teku/bls/BLSSecretKey.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxMjo0NjoxMFrOG5hbbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxNjoxMjo1NVrOG5qFnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk2OTcwOQ==", "bodyText": "We should probably have a constants class that contains things like this, and BLS_PUBKEY_SIZE, BLS_SIGNATURE_SIZE and other magic numbers. Mikuli extracts them from a Milagro constants class.\nThe point is that the mechanics of BLS signing are actually somewhat independent of the underlying curve, and it would be cleaner not to let details of the curve leak up to this level. But not a big deal.", "url": "https://github.com/ConsenSys/teku/pull/2453#discussion_r462969709", "createdAt": "2020-07-30T12:46:10Z", "author": {"login": "benjaminion"}, "path": "bls/src/main/java/tech/pegasys/teku/bls/BLSSecretKey.java", "diffHunk": "@@ -13,15 +13,46 @@\n \n package tech.pegasys.teku.bls;\n \n+import java.math.BigInteger;\n+import java.nio.ByteOrder;\n import java.util.Objects;\n import org.apache.tuweni.bytes.Bytes;\n import org.apache.tuweni.bytes.Bytes32;\n import tech.pegasys.teku.bls.impl.SecretKey;\n \n public final class BLSSecretKey {\n \n-  public static BLSSecretKey fromBytes(Bytes32 bytes) {\n-    return new BLSSecretKey(BLS.getBlsImpl().secretKeyFromBytes(bytes));\n+  private static final Bytes32 CURVE_ORDER =\n+      Bytes32.fromHexString(\"0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa8ec9862ed4dcda26ef467d981198c71be8c84d"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzA4ODIxOQ==", "bodyText": "I moved BLS constants to the BLSConstants class, though left SSZ related constants in their corresponding classes.\nI also made a clear distinction between SSZ and Compressed bytes for BLSPublicKey & BLSSignature through they are equivalent with the current SSZ implementation\nCommits: 25fb802 and 5dca043\nDoes this make sense?", "url": "https://github.com/ConsenSys/teku/pull/2453#discussion_r463088219", "createdAt": "2020-07-30T15:38:25Z", "author": {"login": "Nashatyrev"}, "path": "bls/src/main/java/tech/pegasys/teku/bls/BLSSecretKey.java", "diffHunk": "@@ -13,15 +13,46 @@\n \n package tech.pegasys.teku.bls;\n \n+import java.math.BigInteger;\n+import java.nio.ByteOrder;\n import java.util.Objects;\n import org.apache.tuweni.bytes.Bytes;\n import org.apache.tuweni.bytes.Bytes32;\n import tech.pegasys.teku.bls.impl.SecretKey;\n \n public final class BLSSecretKey {\n \n-  public static BLSSecretKey fromBytes(Bytes32 bytes) {\n-    return new BLSSecretKey(BLS.getBlsImpl().secretKeyFromBytes(bytes));\n+  private static final Bytes32 CURVE_ORDER =\n+      Bytes32.fromHexString(\"0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk2OTcwOQ=="}, "originalCommit": {"oid": "fa8ec9862ed4dcda26ef467d981198c71be8c84d"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzExMTU4MQ==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/ConsenSys/teku/pull/2453#discussion_r463111581", "createdAt": "2020-07-30T16:12:55Z", "author": {"login": "benjaminion"}, "path": "bls/src/main/java/tech/pegasys/teku/bls/BLSSecretKey.java", "diffHunk": "@@ -13,15 +13,46 @@\n \n package tech.pegasys.teku.bls;\n \n+import java.math.BigInteger;\n+import java.nio.ByteOrder;\n import java.util.Objects;\n import org.apache.tuweni.bytes.Bytes;\n import org.apache.tuweni.bytes.Bytes32;\n import tech.pegasys.teku.bls.impl.SecretKey;\n \n public final class BLSSecretKey {\n \n-  public static BLSSecretKey fromBytes(Bytes32 bytes) {\n-    return new BLSSecretKey(BLS.getBlsImpl().secretKeyFromBytes(bytes));\n+  private static final Bytes32 CURVE_ORDER =\n+      Bytes32.fromHexString(\"0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk2OTcwOQ=="}, "originalCommit": {"oid": "fa8ec9862ed4dcda26ef467d981198c71be8c84d"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5MDU0NTc5OnYy", "diffSide": "RIGHT", "path": "bls/src/main/java/tech/pegasys/teku/bls/BLSSecretKey.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxMjo0ODo1MlrOG5hhiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxNTozODo1OFrOG5orzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk3MTI3NQ==", "bodyText": "Oops, magic number. My fault. See comment about having a Constants class.", "url": "https://github.com/ConsenSys/teku/pull/2453#discussion_r462971275", "createdAt": "2020-07-30T12:48:52Z", "author": {"login": "benjaminion"}, "path": "bls/src/main/java/tech/pegasys/teku/bls/BLSSecretKey.java", "diffHunk": "@@ -35,10 +66,14 @@ public BLSSecretKey(SecretKey secretKey) {\n     this.secretKey = secretKey;\n   }\n \n-  public SecretKey getSecretKey() {\n+  SecretKey getSecretKey() {\n     return secretKey;\n   }\n \n+  public BLSPublicKey toPublicKey() {\n+    return new BLSPublicKey(getSecretKey().derivePublicKey());\n+  }\n+\n   public Bytes toBytes() {\n     final Bytes bytes = secretKey.toBytes();\n     if (bytes.size() == 48) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa8ec9862ed4dcda26ef467d981198c71be8c84d"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzA4ODU5MQ==", "bodyText": "Not relevant now", "url": "https://github.com/ConsenSys/teku/pull/2453#discussion_r463088591", "createdAt": "2020-07-30T15:38:58Z", "author": {"login": "Nashatyrev"}, "path": "bls/src/main/java/tech/pegasys/teku/bls/BLSSecretKey.java", "diffHunk": "@@ -35,10 +66,14 @@ public BLSSecretKey(SecretKey secretKey) {\n     this.secretKey = secretKey;\n   }\n \n-  public SecretKey getSecretKey() {\n+  SecretKey getSecretKey() {\n     return secretKey;\n   }\n \n+  public BLSPublicKey toPublicKey() {\n+    return new BLSPublicKey(getSecretKey().derivePublicKey());\n+  }\n+\n   public Bytes toBytes() {\n     final Bytes bytes = secretKey.toBytes();\n     if (bytes.size() == 48) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk3MTI3NQ=="}, "originalCommit": {"oid": "fa8ec9862ed4dcda26ef467d981198c71be8c84d"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5MTUwOTkzOnYy", "diffSide": "RIGHT", "path": "bls/src/test/java/tech/pegasys/teku/bls/BLSPublicKeyTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxNjozMToyN1rOG5qzqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxNjozMToyN1rOG5qzqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzEyMzM2OA==", "bodyText": "Should we have an assert here, if only to be explicit about what we are testing for?", "url": "https://github.com/ConsenSys/teku/pull/2453#discussion_r463123368", "createdAt": "2020-07-30T16:31:27Z", "author": {"login": "benjaminion"}, "path": "bls/src/test/java/tech/pegasys/teku/bls/BLSPublicKeyTest.java", "diffHunk": "@@ -29,16 +31,18 @@\n           \"0xc00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\");\n \n   @Test\n-  void isValidReturnsTrueForValidKey() {\n-    BLSPublicKey publicKey = BLSPublicKey.random(1);\n-    assertTrue(publicKey.isValid());\n+  void fromBytesCompressedValidate_okWhenValidBytes() {\n+    BLSPublicKey.fromBytesCompressedValidate(BLSPublicKey.random(1).toBytesCompressed());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "913e484ad9bf80718de5007a74e0fc789df903f4"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5MTU2MDkxOnYy", "diffSide": "RIGHT", "path": "bls/src/test/java/tech/pegasys/teku/bls/BLSSignatureTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxNjo0NTowNlrOG5rTtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxNzoxODoyNFrOG5sfqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzEzMTU3Mw==", "bodyText": "Should probably assert something here - ideally that the signature is a member of G2. Or that we can sign and verify something with it. Not sure really.", "url": "https://github.com/ConsenSys/teku/pull/2453#discussion_r463131573", "createdAt": "2020-07-30T16:45:06Z", "author": {"login": "benjaminion"}, "path": "bls/src/test/java/tech/pegasys/teku/bls/BLSSignatureTest.java", "diffHunk": "@@ -84,14 +85,34 @@ void succeedsWhenEqualsReturnsFalseForDifferentSignatures() {\n   @Test\n   void succeedsWhenRoundtripSSZReturnsTheSameSignature() {\n     BLSSignature signature1 = BLSSignature.random(65);\n-    BLSSignature signature2 = BLSSignature.fromBytes(signature1.toBytes());\n+    BLSSignature signature2 = BLSSignature.fromSSZBytes(signature1.toSSZBytes());\n     assertEquals(signature1, signature2);\n   }\n \n   @Test\n   void succeedsWhenRoundtripSSZReturnsTheEmptySignature() {\n     BLSSignature signature1 = BLSSignature.empty();\n-    BLSSignature signature2 = BLSSignature.fromBytes(signature1.toBytes());\n+    BLSSignature signature2 = BLSSignature.fromSSZBytes(signature1.toSSZBytes());\n     assertEquals(signature1, signature2);\n   }\n+\n+  @Test\n+  void succeedsWhenEqualsReturnsTrueForEmptySignatures() {\n+    assertEquals(BLSSignature.empty(), BLSSignature.empty());\n+    assertEquals(BLSSignature.empty().hashCode(), BLSSignature.empty().hashCode());\n+  }\n+\n+  @Test\n+  void roundtripEncodeDecodeCompressed() {\n+    BLSSignature signature = BLSSignature.random(513);\n+    final BLSSignature result = BLSSignature.fromBytesCompressed(signature.toBytesCompressed());\n+    assertEquals(signature, result);\n+    assertEquals(signature.hashCode(), result.hashCode());\n+  }\n+\n+  @Test\n+  void testRandomFromSeed() {\n+    BLSSignature randomSig = BLSSignature.random(92892840);\n+    System.out.println(randomSig);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "913e484ad9bf80718de5007a74e0fc789df903f4"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE1MTAxNg==", "bodyText": "Oh that were just experiments when I was sorting out that problem with incompatible random signatures.\nWould remove this case as there are a lot of other random() cases and this one has nothing special.", "url": "https://github.com/ConsenSys/teku/pull/2453#discussion_r463151016", "createdAt": "2020-07-30T17:18:24Z", "author": {"login": "Nashatyrev"}, "path": "bls/src/test/java/tech/pegasys/teku/bls/BLSSignatureTest.java", "diffHunk": "@@ -84,14 +85,34 @@ void succeedsWhenEqualsReturnsFalseForDifferentSignatures() {\n   @Test\n   void succeedsWhenRoundtripSSZReturnsTheSameSignature() {\n     BLSSignature signature1 = BLSSignature.random(65);\n-    BLSSignature signature2 = BLSSignature.fromBytes(signature1.toBytes());\n+    BLSSignature signature2 = BLSSignature.fromSSZBytes(signature1.toSSZBytes());\n     assertEquals(signature1, signature2);\n   }\n \n   @Test\n   void succeedsWhenRoundtripSSZReturnsTheEmptySignature() {\n     BLSSignature signature1 = BLSSignature.empty();\n-    BLSSignature signature2 = BLSSignature.fromBytes(signature1.toBytes());\n+    BLSSignature signature2 = BLSSignature.fromSSZBytes(signature1.toSSZBytes());\n     assertEquals(signature1, signature2);\n   }\n+\n+  @Test\n+  void succeedsWhenEqualsReturnsTrueForEmptySignatures() {\n+    assertEquals(BLSSignature.empty(), BLSSignature.empty());\n+    assertEquals(BLSSignature.empty().hashCode(), BLSSignature.empty().hashCode());\n+  }\n+\n+  @Test\n+  void roundtripEncodeDecodeCompressed() {\n+    BLSSignature signature = BLSSignature.random(513);\n+    final BLSSignature result = BLSSignature.fromBytesCompressed(signature.toBytesCompressed());\n+    assertEquals(signature, result);\n+    assertEquals(signature.hashCode(), result.hashCode());\n+  }\n+\n+  @Test\n+  void testRandomFromSeed() {\n+    BLSSignature randomSig = BLSSignature.random(92892840);\n+    System.out.println(randomSig);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzEzMTU3Mw=="}, "originalCommit": {"oid": "913e484ad9bf80718de5007a74e0fc789df903f4"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5MTU3NjA2OnYy", "diffSide": "RIGHT", "path": "bls/src/test/java/tech/pegasys/teku/bls/impl/blst/BlstTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxNjo0ODo1OVrOG5rdNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxNjo0ODo1OVrOG5rdNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzEzNDAwNg==", "bodyText": "Nit - comment looks like a left-over.", "url": "https://github.com/ConsenSys/teku/pull/2453#discussion_r463134006", "createdAt": "2020-07-30T16:48:59Z", "author": {"login": "benjaminion"}, "path": "bls/src/test/java/tech/pegasys/teku/bls/impl/blst/BlstTest.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.bls.impl.blst;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.util.List;\n+import java.util.Random;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import tech.pegasys.teku.bls.BatchSemiAggregate;\n+\n+public class BlstTest {\n+  private static final Random random = new Random(1);\n+\n+  private static BlstBLS12381 BLS;\n+\n+  @BeforeAll\n+  static void setup() {\n+    BLS = BlstBLS12381.INSTANCE.orElseThrow();\n+  }\n+\n+  @Test\n+  void testBatchVerifySingleSig() {\n+    Bytes msg = Bytes32.ZERO; // .fromHexString(\"123456\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "913e484ad9bf80718de5007a74e0fc789df903f4"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5MTYxNDU2OnYy", "diffSide": "RIGHT", "path": "validator/client/src/test/java/tech/pegasys/teku/validator/client/signer/SignerTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxNjo1OTowNFrOG5r1CQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxNzoxMjo0MFrOG5sTMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE0MDEwNQ==", "bodyText": "Ugh. Why did this change? Is dataStructureUtil.randomSignature(); using a different seed value? That whole thing looks a bit fragile to me. (Not your problem!)", "url": "https://github.com/ConsenSys/teku/pull/2453#discussion_r463140105", "createdAt": "2020-07-30T16:59:04Z", "author": {"login": "benjaminion"}, "path": "validator/client/src/test/java/tech/pegasys/teku/validator/client/signer/SignerTest.java", "diffHunk": "@@ -53,11 +53,11 @@ public void shouldCreateRandaoReveal() {\n   }\n \n   @Test\n-  public void shouldSignBlock() {\n+  public void shouldSignBlock1() {\n     final BeaconBlock block = dataStructureUtil.randomBeaconBlock(10);\n     final BLSSignature signature = dataStructureUtil.randomSignature();\n     final Bytes expectedSigningRoot =\n-        Bytes.fromHexString(\"0xc0e4ed8375c98504b262f610f217d31ebf109f0f73c164362090c6ad7d4770c1\");\n+        Bytes.fromHexString(\"0xfa8b3cfed0268ed15e354e84db5558eb76ad30737a86d6d057615e331ff30d44\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "913e484ad9bf80718de5007a74e0fc789df903f4"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE0NzgyNQ==", "bodyText": "All the BLS random items are generated using random secret key. The random key was generated with Mikuli RAND and blst uses key material to derive secret key from. It doesn't matter for normal use, but for tests the secret key generated from the same seed differed between Mikuli and Blst. So I did implementation independent secret key generation from seed for testing purposes and update this hash to actual value.\nYep it looks fragile but seems to work fine: the same seed should always yields the same random structure. With the exception may be of this change  :)", "url": "https://github.com/ConsenSys/teku/pull/2453#discussion_r463147825", "createdAt": "2020-07-30T17:12:40Z", "author": {"login": "Nashatyrev"}, "path": "validator/client/src/test/java/tech/pegasys/teku/validator/client/signer/SignerTest.java", "diffHunk": "@@ -53,11 +53,11 @@ public void shouldCreateRandaoReveal() {\n   }\n \n   @Test\n-  public void shouldSignBlock() {\n+  public void shouldSignBlock1() {\n     final BeaconBlock block = dataStructureUtil.randomBeaconBlock(10);\n     final BLSSignature signature = dataStructureUtil.randomSignature();\n     final Bytes expectedSigningRoot =\n-        Bytes.fromHexString(\"0xc0e4ed8375c98504b262f610f217d31ebf109f0f73c164362090c6ad7d4770c1\");\n+        Bytes.fromHexString(\"0xfa8b3cfed0268ed15e354e84db5558eb76ad30737a86d6d057615e331ff30d44\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzE0MDEwNQ=="}, "originalCommit": {"oid": "913e484ad9bf80718de5007a74e0fc789df903f4"}, "originalPosition": 10}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3437, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}