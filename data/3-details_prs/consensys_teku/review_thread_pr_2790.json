{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg2MjY1MzEy", "number": 2790, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMTo0NTowNlrOEjFgew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMTo1MToyOVrOEjFonQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MjI1ODUxOnYy", "diffSide": "RIGHT", "path": "sync/src/main/java/tech/pegasys/teku/sync/multipeer/Sync.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMTo0NTowNlrOHRP7lw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQyMToyNDo0NlrOHRnHrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg0ODg1NQ==", "bodyText": "If the the target is changed while the previous sync is in progress what the Future returned previously should result in?", "url": "https://github.com/ConsenSys/teku/pull/2790#discussion_r487848855", "createdAt": "2020-09-14T11:45:06Z", "author": {"login": "Nashatyrev"}, "path": "sync/src/main/java/tech/pegasys/teku/sync/multipeer/Sync.java", "diffHunk": "@@ -0,0 +1,29 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.sync.multipeer;\n+\n+import tech.pegasys.teku.infrastructure.async.SafeFuture;\n+import tech.pegasys.teku.sync.multipeer.chains.TargetChain;\n+\n+public interface Sync {\n+\n+  /**\n+   * Sync to a target chain. This may be called while a previous sync is in progress to switch the\n+   * sync target to a new chain.\n+   *\n+   * @param targetChain the chain to sync to\n+   * @return a future that completes when the sync is complete\n+   */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "41dcae0e8385bf3baeae48be252158c0e1866936"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODIyODc4Mg==", "bodyText": "I was thinking it would just not complete, but it's probably more accurate to have it failed with CancellationException which we'd then have to handle as you say.", "url": "https://github.com/ConsenSys/teku/pull/2790#discussion_r488228782", "createdAt": "2020-09-14T21:24:46Z", "author": {"login": "ajsutton"}, "path": "sync/src/main/java/tech/pegasys/teku/sync/multipeer/Sync.java", "diffHunk": "@@ -0,0 +1,29 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.sync.multipeer;\n+\n+import tech.pegasys.teku.infrastructure.async.SafeFuture;\n+import tech.pegasys.teku.sync.multipeer.chains.TargetChain;\n+\n+public interface Sync {\n+\n+  /**\n+   * Sync to a target chain. This may be called while a previous sync is in progress to switch the\n+   * sync target to a new chain.\n+   *\n+   * @param targetChain the chain to sync to\n+   * @return a future that completes when the sync is complete\n+   */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg0ODg1NQ=="}, "originalCommit": {"oid": "41dcae0e8385bf3baeae48be252158c0e1866936"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA1MjI3OTMzOnYy", "diffSide": "RIGHT", "path": "sync/src/main/java/tech/pegasys/teku/sync/multipeer/SyncController.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMTo1MToyOVrOHRQIYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNFQxMTo1MToyOVrOHRQIYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzg1MjEyOQ==", "bodyText": "If the target chain changes the previous sync Future should be exceptionally completed? If yes then we should handle this exception gracefully", "url": "https://github.com/ConsenSys/teku/pull/2790#discussion_r487852129", "createdAt": "2020-09-14T11:51:29Z", "author": {"login": "Nashatyrev"}, "path": "sync/src/main/java/tech/pegasys/teku/sync/multipeer/SyncController.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.sync.multipeer;\n+\n+import java.util.Optional;\n+import tech.pegasys.teku.infrastructure.async.SafeFuture;\n+import tech.pegasys.teku.infrastructure.async.eventthread.EventThread;\n+import tech.pegasys.teku.infrastructure.subscribers.Subscribers;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.storage.client.RecentChainData;\n+import tech.pegasys.teku.sync.SyncService.SyncSubscriber;\n+import tech.pegasys.teku.sync.SyncingStatus;\n+import tech.pegasys.teku.sync.multipeer.chains.TargetChain;\n+import tech.pegasys.teku.sync.multipeer.chains.TargetChains;\n+\n+public class SyncController {\n+\n+  private final Subscribers<SyncSubscriber> subscribers = Subscribers.create(true);\n+\n+  private final EventThread eventThread;\n+  private final RecentChainData recentChainData;\n+  private final ChainSelector finalizedTargetChainSelector;\n+  private final Sync finalizedSync;\n+\n+  /**\n+   * The current sync. When empty, no sync has started, otherwise contains the details of the last\n+   * started sync, which may have completed.\n+   *\n+   * <p>Note that this field may be accessed from off the event thread so that the sync status can\n+   * be queried from any thread. It should only be written from the event thread.\n+   */\n+  private Optional<InProgressSync> currentSync = Optional.empty();\n+\n+  public SyncController(\n+      final EventThread eventThread,\n+      final RecentChainData recentChainData,\n+      final ChainSelector finalizedTargetChainSelector,\n+      final Sync finalizedSync) {\n+    this.eventThread = eventThread;\n+    this.recentChainData = recentChainData;\n+    this.finalizedTargetChainSelector = finalizedTargetChainSelector;\n+    this.finalizedSync = finalizedSync;\n+  }\n+\n+  /**\n+   * Notify Must be called on the sync event thread.\n+   *\n+   * @param finalizedChains the currently known finalized chains to consider\n+   */\n+  public void onTargetChainsUpdated(final TargetChains finalizedChains) {\n+    eventThread.checkOnEventThread();\n+    final Optional<InProgressSync> newFinalizedSync =\n+        finalizedTargetChainSelector\n+            .selectTargetChain(finalizedChains)\n+            .map(this::startFinalizedSync);\n+    if (newFinalizedSync.isEmpty() && isSyncActive()) {\n+      return;\n+    }\n+    if (!isSyncActive() && newFinalizedSync.isPresent()) {\n+      subscribers.deliver(SyncSubscriber::onSyncingChange, true);\n+    }\n+    currentSync = newFinalizedSync;\n+  }\n+\n+  private void onSyncComplete() {\n+    eventThread.checkOnEventThread();\n+    if (isSyncActive()) {\n+      // A different sync is now running so ignore this change.\n+      return;\n+    }\n+    subscribers.deliver(SyncSubscriber::onSyncingChange, false);\n+  }\n+\n+  public boolean isSyncActive() {\n+    return currentSync.map(InProgressSync::isActive).orElse(false);\n+  }\n+\n+  public SyncingStatus getSyncStatus() {\n+    return currentSync.map(InProgressSync::asSyncingStatus).orElseGet(this::notSyncingStatus);\n+  }\n+\n+  private SyncingStatus notSyncingStatus() {\n+    return new SyncingStatus(false, recentChainData.getHeadSlot());\n+  }\n+\n+  public long subscribeToSyncChanges(final SyncSubscriber subscriber) {\n+    return subscribers.subscribe(subscriber);\n+  }\n+\n+  public void unsubscribeFromSyncChanges(final long subscriberId) {\n+    subscribers.unsubscribe(subscriberId);\n+  }\n+\n+  private InProgressSync startFinalizedSync(final TargetChain chain) {\n+    eventThread.checkOnEventThread();\n+    if (currentSync.map(current -> current.hasSameTarget(chain)).orElse(false)) {\n+      return currentSync.get();\n+    }\n+    final UInt64 startSlot = recentChainData.getHeadSlot();\n+    final SafeFuture<Void> syncResult = finalizedSync.syncToChain(chain);\n+    syncResult.thenRunAsync(this::onSyncComplete, eventThread).reportExceptions();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "41dcae0e8385bf3baeae48be252158c0e1866936"}, "originalPosition": 112}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3252, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}