{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg5NTYyNDU5", "number": 1386, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwNDoyNTozMlrODolD3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwNDoyNTozMlrODolD3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzODc2ODI4OnYy", "diffSide": "RIGHT", "path": "util/src/main/java/tech/pegasys/artemis/util/async/SafeFuture.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwNDoyNTozMlrOF3NkLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwNDo0ODowNVrOF3N2zA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQzODI1Mw==", "bodyText": "Would it be worth using a parallel stream rather than a sequential stream?\nStream.of(futures). parallel().forEach(future -> future.finish(() -> {}, complete::completeExceptionally));", "url": "https://github.com/ConsenSys/teku/pull/1386#discussion_r393438253", "createdAt": "2020-03-17T04:25:32Z", "author": {"login": "CjHare"}, "path": "util/src/main/java/tech/pegasys/artemis/util/async/SafeFuture.java", "diffHunk": "@@ -96,6 +97,27 @@ public static void reportExceptions(final CompletionStage<?> future) {\n     return of(CompletableFuture.allOf(futures));\n   }\n \n+  /**\n+   * Returns a new SafeFuture that is completed when all of the given SafeFutures complete\n+   * successfully or completes exceptionally immediately when any of the SafeFutures complete\n+   * exceptionally. The results, if any, of the given SafeFutures are not reflected in the returned\n+   * SafeFuture, but may be obtained by inspecting them individually. If no SafeFutures are\n+   * provided, returns a SafeFuture completed with the value {@code null}.\n+   *\n+   * <p>Among the applications of this method is to await completion of a set of independent\n+   * SafeFutures before continuing a program, as in: {@code SafeFuture.allOf(c1, c2, c3).join();}.\n+   *\n+   * @param futures the SafeFutures\n+   * @return a new SafeFuture that is completed when all of the given SafeFutures complete\n+   * @throws NullPointerException if the array or any of its elements are {@code null}\n+   */\n+  public static <U> SafeFuture<Void> allOfFailFast(final SafeFuture<?>... futures) {\n+    final SafeFuture<Void> complete = new SafeFuture<>();\n+    Stream.of(futures).forEach(future -> future.finish(() -> {}, complete::completeExceptionally));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8395431975ace88e19f0ec98dd1bed09af87b500"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQzOTI1NA==", "bodyText": "No definitely not.  It adds a lot of complexity to reason about and the overhead of cross-thread communication is not going to be close to worth it for what is always a very small number of futures (and calling finish on each is a very cheap operation).\nIt's very rare that Stream.parallel is a good idea. :)", "url": "https://github.com/ConsenSys/teku/pull/1386#discussion_r393439254", "createdAt": "2020-03-17T04:30:35Z", "author": {"login": "ajsutton"}, "path": "util/src/main/java/tech/pegasys/artemis/util/async/SafeFuture.java", "diffHunk": "@@ -96,6 +97,27 @@ public static void reportExceptions(final CompletionStage<?> future) {\n     return of(CompletableFuture.allOf(futures));\n   }\n \n+  /**\n+   * Returns a new SafeFuture that is completed when all of the given SafeFutures complete\n+   * successfully or completes exceptionally immediately when any of the SafeFutures complete\n+   * exceptionally. The results, if any, of the given SafeFutures are not reflected in the returned\n+   * SafeFuture, but may be obtained by inspecting them individually. If no SafeFutures are\n+   * provided, returns a SafeFuture completed with the value {@code null}.\n+   *\n+   * <p>Among the applications of this method is to await completion of a set of independent\n+   * SafeFutures before continuing a program, as in: {@code SafeFuture.allOf(c1, c2, c3).join();}.\n+   *\n+   * @param futures the SafeFutures\n+   * @return a new SafeFuture that is completed when all of the given SafeFutures complete\n+   * @throws NullPointerException if the array or any of its elements are {@code null}\n+   */\n+  public static <U> SafeFuture<Void> allOfFailFast(final SafeFuture<?>... futures) {\n+    final SafeFuture<Void> complete = new SafeFuture<>();\n+    Stream.of(futures).forEach(future -> future.finish(() -> {}, complete::completeExceptionally));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQzODI1Mw=="}, "originalCommit": {"oid": "8395431975ace88e19f0ec98dd1bed09af87b500"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQ0MzAyMA==", "bodyText": "Fair enough", "url": "https://github.com/ConsenSys/teku/pull/1386#discussion_r393443020", "createdAt": "2020-03-17T04:48:05Z", "author": {"login": "CjHare"}, "path": "util/src/main/java/tech/pegasys/artemis/util/async/SafeFuture.java", "diffHunk": "@@ -96,6 +97,27 @@ public static void reportExceptions(final CompletionStage<?> future) {\n     return of(CompletableFuture.allOf(futures));\n   }\n \n+  /**\n+   * Returns a new SafeFuture that is completed when all of the given SafeFutures complete\n+   * successfully or completes exceptionally immediately when any of the SafeFutures complete\n+   * exceptionally. The results, if any, of the given SafeFutures are not reflected in the returned\n+   * SafeFuture, but may be obtained by inspecting them individually. If no SafeFutures are\n+   * provided, returns a SafeFuture completed with the value {@code null}.\n+   *\n+   * <p>Among the applications of this method is to await completion of a set of independent\n+   * SafeFutures before continuing a program, as in: {@code SafeFuture.allOf(c1, c2, c3).join();}.\n+   *\n+   * @param futures the SafeFutures\n+   * @return a new SafeFuture that is completed when all of the given SafeFutures complete\n+   * @throws NullPointerException if the array or any of its elements are {@code null}\n+   */\n+  public static <U> SafeFuture<Void> allOfFailFast(final SafeFuture<?>... futures) {\n+    final SafeFuture<Void> complete = new SafeFuture<>();\n+    Stream.of(futures).forEach(future -> future.finish(() -> {}, complete::completeExceptionally));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzQzODI1Mw=="}, "originalCommit": {"oid": "8395431975ace88e19f0ec98dd1bed09af87b500"}, "originalPosition": 28}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2553, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}