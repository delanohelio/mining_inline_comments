{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg3NjQ2NDU2", "number": 2802, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwMjozMzo1MFrOEj3QJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwMjozMzo1MFrOEj3QJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA2MDQwODcwOnYy", "diffSide": "RIGHT", "path": "sync/src/testFixtures/java/tech/pegasys/teku/sync/multipeer/batches/StubBatch.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwMjozMzo1MFrOHSd2dw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwMjozNjoyOFrOHSd5KQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTEyNTQ5NQ==", "bodyText": "is this going to be resolved in the current issue or are we raising a new issue or just leaving with no issue context?", "url": "https://github.com/ConsenSys/teku/pull/2802#discussion_r489125495", "createdAt": "2020-09-16T02:33:50Z", "author": {"login": "rolfyone"}, "path": "sync/src/testFixtures/java/tech/pegasys/teku/sync/multipeer/batches/StubBatch.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.sync.multipeer.batches;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Arrays.asList;\n+\n+import com.google.common.base.MoreObjects;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.sync.multipeer.chains.TargetChain;\n+\n+public class StubBatch implements Batch {\n+  private final TargetChain targetChain;\n+  private final UInt64 firstSlot;\n+  private final UInt64 count;\n+  private final List<SignedBeaconBlock> blocks = new ArrayList<>();\n+  private boolean invalid = false;\n+  private Optional<Runnable> blockCallback = Optional.empty();\n+  private boolean complete = false;\n+  private boolean contested = false;\n+  private boolean firstBlockConfirmed = false;\n+  private boolean lastBlockConfirmed = false;\n+\n+  public StubBatch(final TargetChain targetChain, final UInt64 firstSlot, final UInt64 count) {\n+    checkArgument(\n+        count.isGreaterThanOrEqualTo(UInt64.ONE), \"Must include at least one slot in a batch\");\n+    this.targetChain = targetChain;\n+    this.firstSlot = firstSlot;\n+    this.count = count;\n+  }\n+\n+  public void receiveBlocksAndMarkComplete(final SignedBeaconBlock... blocks) {\n+    receiveBlocks(blocks, true);\n+  }\n+\n+  public void receiveBlocks(final SignedBeaconBlock... blocks) {\n+    // Batches automatically mark themselves complete when the block is received for the last slot\n+    // or a request comes back completely empty\n+    final boolean markComplete =\n+        blocks.length == 0 || blocks[blocks.length - 1].getSlot().equals(getLastSlot());\n+    receiveBlocks(blocks, markComplete);\n+  }\n+\n+  public void requestError() {\n+    blockCallback.orElseThrow().run();\n+    blockCallback = Optional.empty();\n+  }\n+\n+  private void receiveBlocks(final SignedBeaconBlock[] blocks, final boolean markComplete) {\n+    checkState(blockCallback.isPresent(), \"Received blocks when none were expected\");\n+    this.blocks.addAll(asList(blocks));\n+    if (markComplete) {\n+      complete = true;\n+    }\n+    final Runnable callback = blockCallback.get();\n+    blockCallback = Optional.empty();\n+    callback.run();\n+  }\n+\n+  @Override\n+  public UInt64 getFirstSlot() {\n+    return firstSlot;\n+  }\n+\n+  @Override\n+  public UInt64 getLastSlot() {\n+    return firstSlot.plus(count).minus(1);\n+  }\n+\n+  @Override\n+  public Optional<SignedBeaconBlock> getFirstBlock() {\n+    return blocks.isEmpty() ? Optional.empty() : Optional.of(blocks.get(0));\n+  }\n+\n+  @Override\n+  public Optional<SignedBeaconBlock> getLastBlock() {\n+    return blocks.isEmpty() ? Optional.empty() : Optional.of(blocks.get(blocks.size() - 1));\n+  }\n+\n+  @Override\n+  public List<SignedBeaconBlock> getBlocks() {\n+    return blocks;\n+  }\n+\n+  @Override\n+  public void markComplete() {\n+    complete = true;\n+  }\n+\n+  @Override\n+  public boolean isComplete() {\n+    return complete;\n+  }\n+\n+  @Override\n+  public boolean isConfirmed() {\n+    return firstBlockConfirmed && lastBlockConfirmed;\n+  }\n+\n+  @Override\n+  public boolean isFirstBlockConfirmed() {\n+    return firstBlockConfirmed;\n+  }\n+\n+  @Override\n+  public boolean isContested() {\n+    return contested;\n+  }\n+\n+  @Override\n+  public void markFirstBlockConfirmed() {\n+    firstBlockConfirmed = true;\n+  }\n+\n+  @Override\n+  public void markLastBlockConfirmed() {\n+    lastBlockConfirmed = true;\n+  }\n+\n+  @Override\n+  public void markAsContested() {\n+    // TODO: Be more careful about exact behaviour here", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6600d11bc86d4959ed82a4b182a21f056978e072"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTEyNjE4NQ==", "bodyText": "Removed it, the behaviour works well for testing.  I am thinking I may be able to remove StubBatch and just use some simple utils with the SyncSourceBatch but that will definitely be a later PR.", "url": "https://github.com/ConsenSys/teku/pull/2802#discussion_r489126185", "createdAt": "2020-09-16T02:36:28Z", "author": {"login": "ajsutton"}, "path": "sync/src/testFixtures/java/tech/pegasys/teku/sync/multipeer/batches/StubBatch.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.sync.multipeer.batches;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Arrays.asList;\n+\n+import com.google.common.base.MoreObjects;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.sync.multipeer.chains.TargetChain;\n+\n+public class StubBatch implements Batch {\n+  private final TargetChain targetChain;\n+  private final UInt64 firstSlot;\n+  private final UInt64 count;\n+  private final List<SignedBeaconBlock> blocks = new ArrayList<>();\n+  private boolean invalid = false;\n+  private Optional<Runnable> blockCallback = Optional.empty();\n+  private boolean complete = false;\n+  private boolean contested = false;\n+  private boolean firstBlockConfirmed = false;\n+  private boolean lastBlockConfirmed = false;\n+\n+  public StubBatch(final TargetChain targetChain, final UInt64 firstSlot, final UInt64 count) {\n+    checkArgument(\n+        count.isGreaterThanOrEqualTo(UInt64.ONE), \"Must include at least one slot in a batch\");\n+    this.targetChain = targetChain;\n+    this.firstSlot = firstSlot;\n+    this.count = count;\n+  }\n+\n+  public void receiveBlocksAndMarkComplete(final SignedBeaconBlock... blocks) {\n+    receiveBlocks(blocks, true);\n+  }\n+\n+  public void receiveBlocks(final SignedBeaconBlock... blocks) {\n+    // Batches automatically mark themselves complete when the block is received for the last slot\n+    // or a request comes back completely empty\n+    final boolean markComplete =\n+        blocks.length == 0 || blocks[blocks.length - 1].getSlot().equals(getLastSlot());\n+    receiveBlocks(blocks, markComplete);\n+  }\n+\n+  public void requestError() {\n+    blockCallback.orElseThrow().run();\n+    blockCallback = Optional.empty();\n+  }\n+\n+  private void receiveBlocks(final SignedBeaconBlock[] blocks, final boolean markComplete) {\n+    checkState(blockCallback.isPresent(), \"Received blocks when none were expected\");\n+    this.blocks.addAll(asList(blocks));\n+    if (markComplete) {\n+      complete = true;\n+    }\n+    final Runnable callback = blockCallback.get();\n+    blockCallback = Optional.empty();\n+    callback.run();\n+  }\n+\n+  @Override\n+  public UInt64 getFirstSlot() {\n+    return firstSlot;\n+  }\n+\n+  @Override\n+  public UInt64 getLastSlot() {\n+    return firstSlot.plus(count).minus(1);\n+  }\n+\n+  @Override\n+  public Optional<SignedBeaconBlock> getFirstBlock() {\n+    return blocks.isEmpty() ? Optional.empty() : Optional.of(blocks.get(0));\n+  }\n+\n+  @Override\n+  public Optional<SignedBeaconBlock> getLastBlock() {\n+    return blocks.isEmpty() ? Optional.empty() : Optional.of(blocks.get(blocks.size() - 1));\n+  }\n+\n+  @Override\n+  public List<SignedBeaconBlock> getBlocks() {\n+    return blocks;\n+  }\n+\n+  @Override\n+  public void markComplete() {\n+    complete = true;\n+  }\n+\n+  @Override\n+  public boolean isComplete() {\n+    return complete;\n+  }\n+\n+  @Override\n+  public boolean isConfirmed() {\n+    return firstBlockConfirmed && lastBlockConfirmed;\n+  }\n+\n+  @Override\n+  public boolean isFirstBlockConfirmed() {\n+    return firstBlockConfirmed;\n+  }\n+\n+  @Override\n+  public boolean isContested() {\n+    return contested;\n+  }\n+\n+  @Override\n+  public void markFirstBlockConfirmed() {\n+    firstBlockConfirmed = true;\n+  }\n+\n+  @Override\n+  public void markLastBlockConfirmed() {\n+    lastBlockConfirmed = true;\n+  }\n+\n+  @Override\n+  public void markAsContested() {\n+    // TODO: Be more careful about exact behaviour here", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTEyNTQ5NQ=="}, "originalCommit": {"oid": "6600d11bc86d4959ed82a4b182a21f056978e072"}, "originalPosition": 138}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3263, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}