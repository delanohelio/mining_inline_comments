{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzU5NjAzMTA0", "number": 1081, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wNlQyMTowNDowMFrODWFfyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wNlQyMzo0NjowM1rODWHh1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0NDg1MzIwOnYy", "diffSide": "RIGHT", "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/rpc/beaconchain/BeaconChainMethods.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wNlQyMTowNDowMFrOFapLfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wNlQyMTowNDowMFrOFapLfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzQ4MTk4MQ==", "bodyText": "Strictly these should probably be get prefixed, but it is one of those cases where it feels right to break the rule (and I'm usually a big fan of get prefixes...).", "url": "https://github.com/ConsenSys/teku/pull/1081#discussion_r363481981", "createdAt": "2020-01-06T21:04:00Z", "author": {"login": "ajsutton"}, "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/rpc/beaconchain/BeaconChainMethods.java", "diffHunk": "@@ -25,57 +28,126 @@\n import tech.pegasys.artemis.networking.eth2.rpc.beaconchain.methods.GoodbyeMessageHandler;\n import tech.pegasys.artemis.networking.eth2.rpc.beaconchain.methods.StatusMessageFactory;\n import tech.pegasys.artemis.networking.eth2.rpc.beaconchain.methods.StatusMessageHandler;\n-import tech.pegasys.artemis.networking.eth2.rpc.core.RpcMessageHandler;\n-import tech.pegasys.artemis.networking.eth2.rpc.core.RpcMethod;\n-import tech.pegasys.artemis.networking.eth2.rpc.core.RpcMethods;\n+import tech.pegasys.artemis.networking.eth2.rpc.core.Eth2RpcMethod;\n import tech.pegasys.artemis.networking.eth2.rpc.core.encodings.RpcEncoding;\n+import tech.pegasys.artemis.networking.p2p.rpc.RpcMethod;\n import tech.pegasys.artemis.storage.ChainStorageClient;\n import tech.pegasys.artemis.storage.CombinedChainDataClient;\n \n public class BeaconChainMethods {\n-  public static final RpcMethod<StatusMessage, StatusMessage> STATUS =\n-      new RpcMethod<>(\n-          \"/eth2/beacon_chain/req/status/1\",\n-          RpcEncoding.SSZ,\n-          StatusMessage.class,\n-          StatusMessage.class);\n-  public static final RpcMethod<GoodbyeMessage, GoodbyeMessage> GOODBYE =\n-      new RpcMethod<>(\n-          \"/eth2/beacon_chain/req/goodbye/1\",\n-          RpcEncoding.SSZ,\n-          GoodbyeMessage.class,\n-          GoodbyeMessage.class);\n-  public static final RpcMethod<BeaconBlocksByRootRequestMessage, BeaconBlock>\n-      BEACON_BLOCKS_BY_ROOT =\n-          new RpcMethod<>(\n-              \"/eth2/beacon_chain/req/beacon_blocks_by_root/1\",\n-              RpcEncoding.SSZ,\n-              BeaconBlocksByRootRequestMessage.class,\n-              BeaconBlock.class);\n-  public static final RpcMethod<BeaconBlocksByRangeRequestMessage, BeaconBlock>\n-      BEACON_BLOCKS_BY_RANGE =\n-          new RpcMethod<>(\n-              \"/eth2/beacon_chain/req/beacon_blocks_by_range/1\",\n-              RpcEncoding.SSZ,\n-              BeaconBlocksByRangeRequestMessage.class,\n-              BeaconBlock.class);\n-\n-  public static RpcMethods createRpcMethods(\n-      PeerLookup peerLookup,\n+  private static final String STATUS = \"/eth2/beacon_chain/req/status/1\";\n+  private static final String GOODBYE = \"/eth2/beacon_chain/req/goodbye/1\";\n+  private static final String BEACON_BLOCKS_BY_ROOT =\n+      \"/eth2/beacon_chain/req/beacon_blocks_by_root/1\";\n+  private static final String BEACON_BLOCKS_BY_RANGE =\n+      \"/eth2/beacon_chain/req/beacon_blocks_by_range/1\";\n+\n+  private final Eth2RpcMethod<StatusMessage, StatusMessage> status;\n+  private final Eth2RpcMethod<GoodbyeMessage, GoodbyeMessage> goodBye;\n+  private final Eth2RpcMethod<BeaconBlocksByRootRequestMessage, BeaconBlock> beaconBlocksByRoot;\n+  private final Eth2RpcMethod<BeaconBlocksByRangeRequestMessage, BeaconBlock> beaconBlocksByRange;\n+\n+  private final Collection<Eth2RpcMethod<?, ?>> allMethods;\n+\n+  private BeaconChainMethods(\n+      final Eth2RpcMethod<StatusMessage, StatusMessage> status,\n+      final Eth2RpcMethod<GoodbyeMessage, GoodbyeMessage> goodBye,\n+      final Eth2RpcMethod<BeaconBlocksByRootRequestMessage, BeaconBlock> beaconBlocksByRoot,\n+      final Eth2RpcMethod<BeaconBlocksByRangeRequestMessage, BeaconBlock> beaconBlocksByRange) {\n+    this.status = status;\n+    this.goodBye = goodBye;\n+    this.beaconBlocksByRoot = beaconBlocksByRoot;\n+    this.beaconBlocksByRange = beaconBlocksByRange;\n+    allMethods = List.of(status, goodBye, beaconBlocksByRoot, beaconBlocksByRange);\n+  }\n+\n+  public static BeaconChainMethods create(\n+      final PeerLookup peerLookup,\n       final CombinedChainDataClient combinedChainDataClient,\n       final ChainStorageClient chainStorageClient,\n       final MetricsSystem metricsSystem,\n       final StatusMessageFactory statusMessageFactory) {\n+    return new BeaconChainMethods(\n+        createStatus(statusMessageFactory, peerLookup),\n+        createGoodBye(metricsSystem, peerLookup),\n+        createBeaconBlocksByRoot(chainStorageClient, peerLookup),\n+        createBeaconBlocksByRange(combinedChainDataClient, peerLookup));\n+  }\n+\n+  private static Eth2RpcMethod<StatusMessage, StatusMessage> createStatus(\n+      final StatusMessageFactory statusMessageFactory, final PeerLookup peerLookup) {\n     final StatusMessageHandler statusHandler = new StatusMessageHandler(statusMessageFactory);\n+    return new Eth2RpcMethod<>(\n+        STATUS,\n+        RpcEncoding.SSZ,\n+        StatusMessage.class,\n+        StatusMessage.class,\n+        false,\n+        statusHandler,\n+        peerLookup);\n+  }\n+\n+  private static Eth2RpcMethod<GoodbyeMessage, GoodbyeMessage> createGoodBye(\n+      final MetricsSystem metricsSystem, final PeerLookup peerLookup) {\n     final GoodbyeMessageHandler goodbyeHandler = new GoodbyeMessageHandler(metricsSystem);\n+    return new Eth2RpcMethod<>(\n+        GOODBYE,\n+        RpcEncoding.SSZ,\n+        GoodbyeMessage.class,\n+        GoodbyeMessage.class,\n+        true,\n+        goodbyeHandler,\n+        peerLookup);\n+  }\n+\n+  private static Eth2RpcMethod<BeaconBlocksByRootRequestMessage, BeaconBlock>\n+      createBeaconBlocksByRoot(\n+          final ChainStorageClient chainStorageClient, final PeerLookup peerLookup) {\n     final BeaconBlocksByRootMessageHandler beaconBlocksByRootHandler =\n         new BeaconBlocksByRootMessageHandler(chainStorageClient);\n+    return new Eth2RpcMethod<>(\n+        BEACON_BLOCKS_BY_ROOT,\n+        RpcEncoding.SSZ,\n+        BeaconBlocksByRootRequestMessage.class,\n+        BeaconBlock.class,\n+        false,\n+        beaconBlocksByRootHandler,\n+        peerLookup);\n+  }\n+\n+  private static Eth2RpcMethod<BeaconBlocksByRangeRequestMessage, BeaconBlock>\n+      createBeaconBlocksByRange(\n+          final CombinedChainDataClient combinedChainDataClient, final PeerLookup peerLookup) {\n+\n     final BeaconBlocksByRangeMessageHandler beaconBlocksByRangeHandler =\n         new BeaconBlocksByRangeMessageHandler(combinedChainDataClient);\n-    return new RpcMethods(\n-        new RpcMessageHandler<>(STATUS, peerLookup, statusHandler),\n-        new RpcMessageHandler<>(GOODBYE, peerLookup, goodbyeHandler).setCloseNotification(),\n-        new RpcMessageHandler<>(BEACON_BLOCKS_BY_ROOT, peerLookup, beaconBlocksByRootHandler),\n-        new RpcMessageHandler<>(BEACON_BLOCKS_BY_RANGE, peerLookup, beaconBlocksByRangeHandler));\n+    return new Eth2RpcMethod<>(\n+        BEACON_BLOCKS_BY_RANGE,\n+        RpcEncoding.SSZ,\n+        BeaconBlocksByRangeRequestMessage.class,\n+        BeaconBlock.class,\n+        false,\n+        beaconBlocksByRangeHandler,\n+        peerLookup);\n+  }\n+\n+  public Collection<RpcMethod> all() {\n+    return Collections.unmodifiableCollection(allMethods);\n+  }\n+\n+  public Eth2RpcMethod<StatusMessage, StatusMessage> status() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0025d7b941e51b3032ba2167ba71fe6a4ed24e42"}, "originalPosition": 158}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0NDg1OTg2OnYy", "diffSide": "RIGHT", "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/rpc/core/RpcResponseCallback.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wNlQyMTowNjo0MlrOFapPrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wNlQyMTo0ODoxMVrOFaqN9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzQ4MzA1NA==", "bodyText": "Does this need reportExceptions()?", "url": "https://github.com/ConsenSys/teku/pull/1081#discussion_r363483054", "createdAt": "2020-01-06T21:06:42Z", "author": {"login": "ajsutton"}, "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/rpc/core/RpcResponseCallback.java", "diffHunk": "@@ -13,57 +13,36 @@\n \n package tech.pegasys.artemis.networking.eth2.rpc.core;\n \n-import io.libp2p.core.Connection;\n-import io.netty.buffer.ByteBuf;\n-import io.netty.channel.ChannelHandlerContext;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n-import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.artemis.networking.p2p.rpc.RpcStream;\n \n class RpcResponseCallback<TResponse> implements ResponseCallback<TResponse> {\n   private static final Logger LOG = LogManager.getLogger();\n-  private final ChannelHandlerContext ctx;\n   private final RpcEncoder rpcEncoder;\n-  private final boolean closeNotification;\n-  private final Connection connection;\n+  private final RpcStream rpcStream;\n \n-  public RpcResponseCallback(\n-      final ChannelHandlerContext ctx,\n-      final RpcEncoder rpcEncoder,\n-      final boolean closeNotification,\n-      final Connection connection) {\n-    this.ctx = ctx;\n+  public RpcResponseCallback(final RpcStream rpcStream, final RpcEncoder rpcEncoder) {\n+    this.rpcStream = rpcStream;\n     this.rpcEncoder = rpcEncoder;\n-    this.closeNotification = closeNotification;\n-    this.connection = connection;\n   }\n \n   @Override\n   public void respond(final TResponse data) {\n-    writeResponse(ctx, rpcEncoder.encodeSuccessfulResponse(data));\n+    rpcStream.writeBytes(rpcEncoder.encodeSuccessfulResponse(data)).reportExceptions();\n   }\n \n   @Override\n   @SuppressWarnings(\"FutureReturnValueIgnored\")\n   public void completeSuccessfully() {\n-    ctx.channel().disconnect();\n-    if (closeNotification) {\n-      connection.getNettyChannel().close();\n-    }\n+    rpcStream.disconnect().reportExceptions();\n   }\n \n   @Override\n   @SuppressWarnings(\"FutureReturnValueIgnored\")\n   public void completeWithError(final RpcException error) {\n     LOG.debug(\"Responding to RPC request with error: {}\", error.getErrorMessage());\n-    writeResponse(ctx, rpcEncoder.encodeErrorResponse(error));\n-    ctx.channel().disconnect();\n-  }\n-\n-  @SuppressWarnings(\"FutureReturnValueIgnored\")\n-  private void writeResponse(final ChannelHandlerContext ctx, final Bytes encoded) {\n-    ByteBuf respBuf = ctx.alloc().buffer();\n-    respBuf.writeBytes(encoded.toArrayUnsafe());\n-    ctx.writeAndFlush(respBuf);\n+    rpcStream.writeBytes(rpcEncoder.encodeErrorResponse(error));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0025d7b941e51b3032ba2167ba71fe6a4ed24e42"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzQ5ODk5OA==", "bodyText": "yes - good call!", "url": "https://github.com/ConsenSys/teku/pull/1081#discussion_r363498998", "createdAt": "2020-01-06T21:48:11Z", "author": {"login": "mbaxter"}, "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/rpc/core/RpcResponseCallback.java", "diffHunk": "@@ -13,57 +13,36 @@\n \n package tech.pegasys.artemis.networking.eth2.rpc.core;\n \n-import io.libp2p.core.Connection;\n-import io.netty.buffer.ByteBuf;\n-import io.netty.channel.ChannelHandlerContext;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n-import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.artemis.networking.p2p.rpc.RpcStream;\n \n class RpcResponseCallback<TResponse> implements ResponseCallback<TResponse> {\n   private static final Logger LOG = LogManager.getLogger();\n-  private final ChannelHandlerContext ctx;\n   private final RpcEncoder rpcEncoder;\n-  private final boolean closeNotification;\n-  private final Connection connection;\n+  private final RpcStream rpcStream;\n \n-  public RpcResponseCallback(\n-      final ChannelHandlerContext ctx,\n-      final RpcEncoder rpcEncoder,\n-      final boolean closeNotification,\n-      final Connection connection) {\n-    this.ctx = ctx;\n+  public RpcResponseCallback(final RpcStream rpcStream, final RpcEncoder rpcEncoder) {\n+    this.rpcStream = rpcStream;\n     this.rpcEncoder = rpcEncoder;\n-    this.closeNotification = closeNotification;\n-    this.connection = connection;\n   }\n \n   @Override\n   public void respond(final TResponse data) {\n-    writeResponse(ctx, rpcEncoder.encodeSuccessfulResponse(data));\n+    rpcStream.writeBytes(rpcEncoder.encodeSuccessfulResponse(data)).reportExceptions();\n   }\n \n   @Override\n   @SuppressWarnings(\"FutureReturnValueIgnored\")\n   public void completeSuccessfully() {\n-    ctx.channel().disconnect();\n-    if (closeNotification) {\n-      connection.getNettyChannel().close();\n-    }\n+    rpcStream.disconnect().reportExceptions();\n   }\n \n   @Override\n   @SuppressWarnings(\"FutureReturnValueIgnored\")\n   public void completeWithError(final RpcException error) {\n     LOG.debug(\"Responding to RPC request with error: {}\", error.getErrorMessage());\n-    writeResponse(ctx, rpcEncoder.encodeErrorResponse(error));\n-    ctx.channel().disconnect();\n-  }\n-\n-  @SuppressWarnings(\"FutureReturnValueIgnored\")\n-  private void writeResponse(final ChannelHandlerContext ctx, final Bytes encoded) {\n-    ByteBuf respBuf = ctx.alloc().buffer();\n-    respBuf.writeBytes(encoded.toArrayUnsafe());\n-    ctx.writeAndFlush(respBuf);\n+    rpcStream.writeBytes(rpcEncoder.encodeErrorResponse(error));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzQ4MzA1NA=="}, "originalCommit": {"oid": "0025d7b941e51b3032ba2167ba71fe6a4ed24e42"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0NDg2NDkyOnYy", "diffSide": "RIGHT", "path": "networking/p2p/src/main/java/tech/pegasys/artemis/networking/p2p/libp2p/LibP2PPeer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wNlQyMTowODo1MVrOFapS5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wNlQyMTowODo1MVrOFapS5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzQ4Mzg3OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  throw new IllegalArgumentException(\"Unknown rpc method method invoked: \" + rpcMethod.getId());\n          \n          \n            \n                  throw new IllegalArgumentException(\"Unknown rpc method invoked: \" + rpcMethod.getId());", "url": "https://github.com/ConsenSys/teku/pull/1081#discussion_r363483879", "createdAt": "2020-01-06T21:08:51Z", "author": {"login": "ajsutton"}, "path": "networking/p2p/src/main/java/tech/pegasys/artemis/networking/p2p/libp2p/LibP2PPeer.java", "diffHunk": "@@ -39,8 +50,19 @@ public boolean isConnected() {\n   }\n \n   @Override\n-  public Connection getConnection() {\n-    return connection;\n+  @SuppressWarnings(\"FutureReturnValueIgnored\")\n+  public void disconnect() {\n+    connection.getNettyChannel().close();\n+  }\n+\n+  @Override\n+  public SafeFuture<RpcStream> sendRequest(\n+      RpcMethod rpcMethod, final Bytes initialPayload, final RpcRequestHandler handler) {\n+    RpcHandler rpcHandler = rpcHandlers.get(rpcMethod);\n+    if (rpcHandler == null) {\n+      throw new IllegalArgumentException(\"Unknown rpc method method invoked: \" + rpcMethod.getId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0025d7b941e51b3032ba2167ba71fe6a4ed24e42"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0NDg2ODg2OnYy", "diffSide": "RIGHT", "path": "networking/p2p/src/main/java/tech/pegasys/artemis/networking/p2p/libp2p/rpc/LibP2PRpcStream.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wNlQyMToxMDo0M1rOFapVgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wNlQyMToxMDo0M1rOFapVgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzQ4NDU0NA==", "bodyText": "Really like this abstraction to hide the Netty APIs.", "url": "https://github.com/ConsenSys/teku/pull/1081#discussion_r363484544", "createdAt": "2020-01-06T21:10:43Z", "author": {"login": "ajsutton"}, "path": "networking/p2p/src/main/java/tech/pegasys/artemis/networking/p2p/libp2p/rpc/LibP2PRpcStream.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.networking.p2p.libp2p.rpc;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelHandlerContext;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.artemis.networking.p2p.rpc.RpcStream;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+\n+public class LibP2PRpcStream implements RpcStream {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0025d7b941e51b3032ba2167ba71fe6a4ed24e42"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI0NTE4NjE0OnYy", "diffSide": "RIGHT", "path": "networking/p2p/src/main/java/tech/pegasys/artemis/networking/p2p/libp2p/rpc/RpcHandler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wNlQyMzo0NjowM1rOFascjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wN1QxNDo0MDozNFrOFa7QqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzUzNTUwMg==", "bodyText": "is the 0 here on the method name on purpose?", "url": "https://github.com/ConsenSys/teku/pull/1081#discussion_r363535502", "createdAt": "2020-01-06T23:46:03Z", "author": {"login": "cemozerr"}, "path": "networking/p2p/src/main/java/tech/pegasys/artemis/networking/p2p/libp2p/rpc/RpcHandler.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Copyright 2019 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.networking.p2p.libp2p.rpc;\n+\n+import io.libp2p.core.Connection;\n+import io.libp2p.core.P2PAbstractChannel;\n+import io.libp2p.core.multistream.Mode;\n+import io.libp2p.core.multistream.Multistream;\n+import io.libp2p.core.multistream.ProtocolBinding;\n+import io.libp2p.core.multistream.ProtocolMatcher;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.jetbrains.annotations.NotNull;\n+import tech.pegasys.artemis.networking.p2p.libp2p.LibP2PNodeId;\n+import tech.pegasys.artemis.networking.p2p.libp2p.rpc.RpcHandler.Controller;\n+import tech.pegasys.artemis.networking.p2p.peer.NodeId;\n+import tech.pegasys.artemis.networking.p2p.rpc.RpcMethod;\n+import tech.pegasys.artemis.networking.p2p.rpc.RpcRequestHandler;\n+import tech.pegasys.artemis.networking.p2p.rpc.RpcStream;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+\n+public class RpcHandler implements ProtocolBinding<Controller> {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final RpcMethod rpcMethod;\n+\n+  public RpcHandler(RpcMethod rpcMethod) {\n+    this.rpcMethod = rpcMethod;\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public SafeFuture<RpcStream> sendRequest(\n+      Connection connection, Bytes initialPayload, RpcRequestHandler handler) {\n+    return SafeFuture.of(\n+            connection\n+                .getMuxerSession()\n+                .createStream(\n+                    Multistream.create(this.toInitiator(rpcMethod.getId())).toStreamHandler())\n+                .getControler())\n+        .thenCompose(\n+            ctr -> {\n+              ctr.setRequestHandler(handler);\n+              return ctr.getRpcStream()\n+                  .writeBytes(initialPayload)\n+                  .thenApply(f -> ctr.getRpcStream());\n+            });\n+  }\n+\n+  @NotNull\n+  @Override\n+  public String getAnnounce() {\n+    return rpcMethod.getId();\n+  }\n+\n+  @NotNull\n+  @Override\n+  public ProtocolMatcher getMatcher() {\n+    return new ProtocolMatcher(Mode.STRICT, getAnnounce(), null);\n+  }\n+\n+  @NotNull\n+  @Override\n+  public SafeFuture<Controller> initChannel(P2PAbstractChannel channel, String s) {\n+    // TODO timeout handlers\n+    final Connection connection = ((io.libp2p.core.Stream) channel).getConn();\n+    final NodeId nodeId = new LibP2PNodeId(connection.getSecureSession().getRemoteId());\n+    Controller controller = new Controller(nodeId);\n+    if (!channel.isInitiator()) {\n+      controller.setRequestHandler(rpcMethod.createIncomingRequestHandler());\n+    }\n+    channel.getNettyChannel().pipeline().addLast(controller);\n+    return controller.activeFuture;\n+  }\n+\n+  static class Controller extends SimpleChannelInboundHandler<ByteBuf> {\n+    private final NodeId nodeId;\n+    private RpcRequestHandler rpcRequestHandler;\n+    private RpcStream rpcStream;\n+    private List<ByteBuf> bufferedData = new ArrayList<>();\n+\n+    protected final SafeFuture<Controller> activeFuture = new SafeFuture<>();\n+\n+    private Controller(final NodeId nodeId) {\n+      this.nodeId = nodeId;\n+    }\n+\n+    @Override\n+    public void channelActive(ChannelHandlerContext ctx) {\n+      rpcStream = new LibP2PRpcStream(ctx);\n+      activeFuture.complete(this);\n+    }\n+\n+    public RpcStream getRpcStream() {\n+      return rpcStream;\n+    }\n+\n+    @Override\n+    protected void channelRead0(final ChannelHandlerContext ctx, final ByteBuf msg) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f595fe18d74b172d596dfa4cdbd24d1e75364ac"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Mzc3ODIxNw==", "bodyText": "yeah - its a quirk of the API (https://netty.io/4.0/api/io/netty/channel/SimpleChannelInboundHandler.html):\n\nPlease keep in mind that #channelRead0(ChannelHandlerContext, I) will be renamed to messageReceived(ChannelHandlerContext, I) in 5.0.", "url": "https://github.com/ConsenSys/teku/pull/1081#discussion_r363778217", "createdAt": "2020-01-07T14:40:34Z", "author": {"login": "mbaxter"}, "path": "networking/p2p/src/main/java/tech/pegasys/artemis/networking/p2p/libp2p/rpc/RpcHandler.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Copyright 2019 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.networking.p2p.libp2p.rpc;\n+\n+import io.libp2p.core.Connection;\n+import io.libp2p.core.P2PAbstractChannel;\n+import io.libp2p.core.multistream.Mode;\n+import io.libp2p.core.multistream.Multistream;\n+import io.libp2p.core.multistream.ProtocolBinding;\n+import io.libp2p.core.multistream.ProtocolMatcher;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.jetbrains.annotations.NotNull;\n+import tech.pegasys.artemis.networking.p2p.libp2p.LibP2PNodeId;\n+import tech.pegasys.artemis.networking.p2p.libp2p.rpc.RpcHandler.Controller;\n+import tech.pegasys.artemis.networking.p2p.peer.NodeId;\n+import tech.pegasys.artemis.networking.p2p.rpc.RpcMethod;\n+import tech.pegasys.artemis.networking.p2p.rpc.RpcRequestHandler;\n+import tech.pegasys.artemis.networking.p2p.rpc.RpcStream;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+\n+public class RpcHandler implements ProtocolBinding<Controller> {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final RpcMethod rpcMethod;\n+\n+  public RpcHandler(RpcMethod rpcMethod) {\n+    this.rpcMethod = rpcMethod;\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public SafeFuture<RpcStream> sendRequest(\n+      Connection connection, Bytes initialPayload, RpcRequestHandler handler) {\n+    return SafeFuture.of(\n+            connection\n+                .getMuxerSession()\n+                .createStream(\n+                    Multistream.create(this.toInitiator(rpcMethod.getId())).toStreamHandler())\n+                .getControler())\n+        .thenCompose(\n+            ctr -> {\n+              ctr.setRequestHandler(handler);\n+              return ctr.getRpcStream()\n+                  .writeBytes(initialPayload)\n+                  .thenApply(f -> ctr.getRpcStream());\n+            });\n+  }\n+\n+  @NotNull\n+  @Override\n+  public String getAnnounce() {\n+    return rpcMethod.getId();\n+  }\n+\n+  @NotNull\n+  @Override\n+  public ProtocolMatcher getMatcher() {\n+    return new ProtocolMatcher(Mode.STRICT, getAnnounce(), null);\n+  }\n+\n+  @NotNull\n+  @Override\n+  public SafeFuture<Controller> initChannel(P2PAbstractChannel channel, String s) {\n+    // TODO timeout handlers\n+    final Connection connection = ((io.libp2p.core.Stream) channel).getConn();\n+    final NodeId nodeId = new LibP2PNodeId(connection.getSecureSession().getRemoteId());\n+    Controller controller = new Controller(nodeId);\n+    if (!channel.isInitiator()) {\n+      controller.setRequestHandler(rpcMethod.createIncomingRequestHandler());\n+    }\n+    channel.getNettyChannel().pipeline().addLast(controller);\n+    return controller.activeFuture;\n+  }\n+\n+  static class Controller extends SimpleChannelInboundHandler<ByteBuf> {\n+    private final NodeId nodeId;\n+    private RpcRequestHandler rpcRequestHandler;\n+    private RpcStream rpcStream;\n+    private List<ByteBuf> bufferedData = new ArrayList<>();\n+\n+    protected final SafeFuture<Controller> activeFuture = new SafeFuture<>();\n+\n+    private Controller(final NodeId nodeId) {\n+      this.nodeId = nodeId;\n+    }\n+\n+    @Override\n+    public void channelActive(ChannelHandlerContext ctx) {\n+      rpcStream = new LibP2PRpcStream(ctx);\n+      activeFuture.complete(this);\n+    }\n+\n+    public RpcStream getRpcStream() {\n+      return rpcStream;\n+    }\n+\n+    @Override\n+    protected void channelRead0(final ChannelHandlerContext ctx, final ByteBuf msg) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzUzNTUwMg=="}, "originalCommit": {"oid": "2f595fe18d74b172d596dfa4cdbd24d1e75364ac"}, "originalPosition": 115}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2742, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}