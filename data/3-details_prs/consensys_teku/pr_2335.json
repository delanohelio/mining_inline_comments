{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ2OTY2NjIz", "number": 2335, "title": "Fix rpc handler close future leak", "bodyText": "PR Description\n\nAvoid leaking references to the Libp2p Connection.closeFuture. (details below)\nMake RpcHandler.sendRequest() code a bit cleaner with using new SafeFuture.orInterrupt() feature\n\nConnection.closeFuture may be very long living future in terms it may keep uncompleted for very long time (while we are connected to a peer). Meanwhile there are many streams (and their handlers) are created which derive from this future this or that way to be aware of the parent channel close while setting up a child Stream.\nThe problem is when you are deriving any other future from the Connection.closeFuture (in any ways like thenApply, whenComplete etc) that future would remain referenced together with all closures refs until the Connection.closeFuture is complete (which may never happen).\nThere are no means for CompletableFuture to remove this dependency later (unlike netty.Future.add/removeListener). The only mean the dependency can be removed is via CompletableFuture.anyOf (or .*either*) methods, so when the 'main' future is completed all other futures are released.\nThis way I implemented SafeFuture.orInterrupt() concept.\n\nit doesn't accumulate dependent future refs inside interruption futures (like closeFuture)\nit prevents further async tasks from being executed when interruption occurs (when inserted together with every async task)\nseems like it can make that async hell a bit cleaner\n\nFixed Issue(s)\nRelates #2286 (though most likely the Libp2p fix is the primary for resolving this issue libp2p/jvm-libp2p@7030249)\nDocumentation\n\n I thought about documentation and added the documentation label to this PR if updates are required.", "createdAt": "2020-07-09T16:26:07Z", "url": "https://github.com/ConsenSys/teku/pull/2335", "merged": true, "mergeCommit": {"oid": "1af63a8486700e52d744d6316c91d31977601425"}, "closed": true, "closedAt": "2020-07-15T21:11:16Z", "author": {"login": "Nashatyrev"}, "timelineItems": {"totalCount": 26, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABczPLjggH2gAyNDQ2OTY2NjIzOjFlNGViNzNlNDY4MjQ2MDRkMTA4OGQzN2Y5MTA1ZTNiZTk2MjcwYjc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc1RCIdgFqTQ0OTMyMjk3Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "1e4eb73e46824604d1088d37f9105e3be96270b7", "author": {"user": {"login": "Nashatyrev", "name": "Anton Nashatyrev"}}, "url": "https://github.com/ConsenSys/teku/commit/1e4eb73e46824604d1088d37f9105e3be96270b7", "committedDate": "2020-07-09T13:37:25Z", "message": "Add SafeFuture or() and orInterrupt() methods"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2e226fc5ce493bd6d95e4a1076d3cb82a9782f8e", "author": {"user": {"login": "Nashatyrev", "name": "Anton Nashatyrev"}}, "url": "https://github.com/ConsenSys/teku/commit/2e226fc5ce493bd6d95e4a1076d3cb82a9782f8e", "committedDate": "2020-07-09T13:39:53Z", "message": "Refactor RpcHandler.sendRequest() method to have a cleaner logic and not flood up the potentially long living connection.closeFuture() with dependencies"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4f5fcbd39b2a5e10180199cff07ff2645555d22d", "author": {"user": {"login": "Nashatyrev", "name": "Anton Nashatyrev"}}, "url": "https://github.com/ConsenSys/teku/commit/4f5fcbd39b2a5e10180199cff07ff2645555d22d", "committedDate": "2020-07-09T14:20:04Z", "message": "Add SafeFuture javadocs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "098fecabd232decdc86ee7930f20b9506dc4cbcb", "author": {"user": {"login": "Nashatyrev", "name": "Anton Nashatyrev"}}, "url": "https://github.com/ConsenSys/teku/commit/098fecabd232decdc86ee7930f20b9506dc4cbcb", "committedDate": "2020-07-09T16:26:30Z", "message": "Merge remote-tracking branch 'pegasys/master' into fix-rpc-handler-close-future-leak"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "27aae9a095462d94768a7f0e55b8d265fdad9386", "author": {"user": {"login": "Nashatyrev", "name": "Anton Nashatyrev"}}, "url": "https://github.com/ConsenSys/teku/commit/27aae9a095462d94768a7f0e55b8d265fdad9386", "committedDate": "2020-07-09T16:46:57Z", "message": "Fix errorprone warns"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7be46ad3a929e2bb2f7771a892464834ecd41226", "author": {"user": {"login": "Nashatyrev", "name": "Anton Nashatyrev"}}, "url": "https://github.com/ConsenSys/teku/commit/7be46ad3a929e2bb2f7771a892464834ecd41226", "committedDate": "2020-07-09T17:05:15Z", "message": "Spotless apply"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1OTA4MTMx", "url": "https://github.com/ConsenSys/teku/pull/2335#pullrequestreview-445908131", "createdAt": "2020-07-09T19:30:08Z", "commit": {"oid": "7be46ad3a929e2bb2f7771a892464834ecd41226"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQxOTozMDowOFrOGve55g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQyMDoxMjozOVrOGvgLFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ0MjU5OA==", "bodyText": "Can we just use fut.getNumberOfDependents()?", "url": "https://github.com/ConsenSys/teku/pull/2335#discussion_r452442598", "createdAt": "2020-07-09T19:30:08Z", "author": {"login": "mbaxter"}, "path": "util/src/test/java/tech/pegasys/teku/util/async/SafeFutureTest.java", "diffHunk": "@@ -502,6 +503,201 @@ public void allOfFailFast_completesWhenAllFuturesComplete() {\n     assertThat(result).isCompleted();\n   }\n \n+  private static boolean hasDependents(CompletableFuture<?> fut) {\n+    return fut.toString().toLowerCase().contains(\"dependents\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7be46ad3a929e2bb2f7771a892464834ecd41226"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ0NjA3MA==", "bodyText": "For readability, I'd probably move these classes out to the bottom of the file.", "url": "https://github.com/ConsenSys/teku/pull/2335#discussion_r452446070", "createdAt": "2020-07-09T19:37:32Z", "author": {"login": "mbaxter"}, "path": "util/src/test/java/tech/pegasys/teku/util/async/SafeFutureTest.java", "diffHunk": "@@ -502,6 +503,201 @@ public void allOfFailFast_completesWhenAllFuturesComplete() {\n     assertThat(result).isCompleted();\n   }\n \n+  private static boolean hasDependents(CompletableFuture<?> fut) {\n+    return fut.toString().toLowerCase().contains(\"dependents\");\n+  }\n+\n+  @Test\n+  public void orTest1() throws Exception {\n+    SafeFuture<Integer> fut0 = new SafeFuture<>();\n+    SafeFuture<Integer> fut1 = new SafeFuture<>();\n+\n+    assertThat(hasDependents(fut0)).isFalse();\n+\n+    SafeFuture<Integer> orFut = fut0.or(fut1);\n+\n+    assertThat(hasDependents(fut0)).isTrue();\n+    assertThat(hasDependents(fut1)).isTrue();\n+\n+    fut1.complete(12);\n+\n+    assertThat(hasDependents(fut0)).isFalse();\n+    assertThat(hasDependents(fut1)).isFalse();\n+    assertThat(orFut.get()).isEqualTo(12);\n+  }\n+\n+  @Test\n+  public void orTest2() throws Exception {\n+    SafeFuture<Integer> fut0 = new SafeFuture<>();\n+    SafeFuture<Integer> fut1 = new SafeFuture<>();\n+\n+    assertThat(hasDependents(fut0)).isFalse();\n+\n+    SafeFuture<Integer> orFut = fut0.or(fut1);\n+\n+    assertThat(hasDependents(fut0)).isTrue();\n+    assertThat(hasDependents(fut1)).isTrue();\n+\n+    fut0.complete(12);\n+\n+    assertThat(hasDependents(fut0)).isFalse();\n+    assertThat(hasDependents(fut1)).isFalse();\n+    assertThat(orFut.get()).isEqualTo(12);\n+  }\n+\n+  @Test\n+  public void orTest3() {\n+    SafeFuture<Integer> fut0 = new SafeFuture<>();\n+    SafeFuture<Integer> fut1 = new SafeFuture<>();\n+\n+    assertThat(hasDependents(fut0)).isFalse();\n+\n+    SafeFuture<Integer> orFut = fut0.or(fut1);\n+\n+    assertThat(hasDependents(fut0)).isTrue();\n+    assertThat(hasDependents(fut1)).isTrue();\n+\n+    fut1.completeExceptionally(new IllegalStateException());\n+\n+    assertThat(hasDependents(fut0)).isFalse();\n+    assertThat(hasDependents(fut1)).isFalse();\n+    assertThat(orFut).isCompletedExceptionally();\n+  }\n+\n+  @Test\n+  public void interruptTest1() throws Exception {\n+    SafeFuture<Integer> interruptorFut = new SafeFuture<>();\n+    Interruptor interruptor =\n+        SafeFuture.createInterruptor(interruptorFut, IllegalStateException::new);\n+    SafeFuture<Integer> fut0 = new SafeFuture<>();\n+\n+    assertThat(hasDependents(interruptorFut)).isFalse();\n+    assertThat(hasDependents(fut0)).isFalse();\n+\n+    SafeFuture<Integer> intFut = fut0.orInterrupt(interruptor);\n+\n+    assertThat(hasDependents(interruptorFut)).isTrue();\n+    assertThat(hasDependents(fut0)).isTrue();\n+\n+    fut0.complete(12);\n+\n+    assertThat(hasDependents(interruptorFut)).isFalse();\n+    assertThat(hasDependents(fut0)).isFalse();\n+    assertThat(intFut.get()).isEqualTo(12);\n+  }\n+\n+  @Test\n+  public void interruptTest2() throws Exception {\n+    SafeFuture<Integer> interruptorFut1 = new SafeFuture<>();\n+    SafeFuture<Integer> interruptorFut2 = new SafeFuture<>();\n+    Interruptor interruptor1 =\n+        SafeFuture.createInterruptor(interruptorFut1, IllegalStateException::new);\n+    Interruptor interruptor2 =\n+        SafeFuture.createInterruptor(interruptorFut2, IllegalStateException::new);\n+    SafeFuture<Integer> fut0 = new SafeFuture<>();\n+\n+    assertThat(hasDependents(interruptorFut1)).isFalse();\n+    assertThat(hasDependents(interruptorFut2)).isFalse();\n+    assertThat(hasDependents(fut0)).isFalse();\n+\n+    SafeFuture<Integer> intFut = fut0.orInterrupt(interruptor1, interruptor2);\n+\n+    assertThat(hasDependents(interruptorFut1)).isTrue();\n+    assertThat(hasDependents(interruptorFut2)).isTrue();\n+    assertThat(hasDependents(fut0)).isTrue();\n+\n+    interruptorFut2.complete(0);\n+\n+    assertThat(hasDependents(interruptorFut1)).isFalse();\n+    assertThat(hasDependents(interruptorFut2)).isFalse();\n+    assertThat(hasDependents(fut0)).isFalse();\n+    assertThat(intFut).isCompletedExceptionally();\n+  }\n+\n+  @Test\n+  public void interruptTest3() throws Exception {\n+    class AsyncExec {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7be46ad3a929e2bb2f7771a892464834ecd41226"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ0NzExNw==", "bodyText": "I'd probably split these separate test blocks out into separate test functions:  interrupt_chainOfFutures_successful(), interrupt_chainOfFutures_immediatelyInterrupted(), etc.", "url": "https://github.com/ConsenSys/teku/pull/2335#discussion_r452447117", "createdAt": "2020-07-09T19:39:39Z", "author": {"login": "mbaxter"}, "path": "util/src/test/java/tech/pegasys/teku/util/async/SafeFutureTest.java", "diffHunk": "@@ -502,6 +503,201 @@ public void allOfFailFast_completesWhenAllFuturesComplete() {\n     assertThat(result).isCompleted();\n   }\n \n+  private static boolean hasDependents(CompletableFuture<?> fut) {\n+    return fut.toString().toLowerCase().contains(\"dependents\");\n+  }\n+\n+  @Test\n+  public void orTest1() throws Exception {\n+    SafeFuture<Integer> fut0 = new SafeFuture<>();\n+    SafeFuture<Integer> fut1 = new SafeFuture<>();\n+\n+    assertThat(hasDependents(fut0)).isFalse();\n+\n+    SafeFuture<Integer> orFut = fut0.or(fut1);\n+\n+    assertThat(hasDependents(fut0)).isTrue();\n+    assertThat(hasDependents(fut1)).isTrue();\n+\n+    fut1.complete(12);\n+\n+    assertThat(hasDependents(fut0)).isFalse();\n+    assertThat(hasDependents(fut1)).isFalse();\n+    assertThat(orFut.get()).isEqualTo(12);\n+  }\n+\n+  @Test\n+  public void orTest2() throws Exception {\n+    SafeFuture<Integer> fut0 = new SafeFuture<>();\n+    SafeFuture<Integer> fut1 = new SafeFuture<>();\n+\n+    assertThat(hasDependents(fut0)).isFalse();\n+\n+    SafeFuture<Integer> orFut = fut0.or(fut1);\n+\n+    assertThat(hasDependents(fut0)).isTrue();\n+    assertThat(hasDependents(fut1)).isTrue();\n+\n+    fut0.complete(12);\n+\n+    assertThat(hasDependents(fut0)).isFalse();\n+    assertThat(hasDependents(fut1)).isFalse();\n+    assertThat(orFut.get()).isEqualTo(12);\n+  }\n+\n+  @Test\n+  public void orTest3() {\n+    SafeFuture<Integer> fut0 = new SafeFuture<>();\n+    SafeFuture<Integer> fut1 = new SafeFuture<>();\n+\n+    assertThat(hasDependents(fut0)).isFalse();\n+\n+    SafeFuture<Integer> orFut = fut0.or(fut1);\n+\n+    assertThat(hasDependents(fut0)).isTrue();\n+    assertThat(hasDependents(fut1)).isTrue();\n+\n+    fut1.completeExceptionally(new IllegalStateException());\n+\n+    assertThat(hasDependents(fut0)).isFalse();\n+    assertThat(hasDependents(fut1)).isFalse();\n+    assertThat(orFut).isCompletedExceptionally();\n+  }\n+\n+  @Test\n+  public void interruptTest1() throws Exception {\n+    SafeFuture<Integer> interruptorFut = new SafeFuture<>();\n+    Interruptor interruptor =\n+        SafeFuture.createInterruptor(interruptorFut, IllegalStateException::new);\n+    SafeFuture<Integer> fut0 = new SafeFuture<>();\n+\n+    assertThat(hasDependents(interruptorFut)).isFalse();\n+    assertThat(hasDependents(fut0)).isFalse();\n+\n+    SafeFuture<Integer> intFut = fut0.orInterrupt(interruptor);\n+\n+    assertThat(hasDependents(interruptorFut)).isTrue();\n+    assertThat(hasDependents(fut0)).isTrue();\n+\n+    fut0.complete(12);\n+\n+    assertThat(hasDependents(interruptorFut)).isFalse();\n+    assertThat(hasDependents(fut0)).isFalse();\n+    assertThat(intFut.get()).isEqualTo(12);\n+  }\n+\n+  @Test\n+  public void interruptTest2() throws Exception {\n+    SafeFuture<Integer> interruptorFut1 = new SafeFuture<>();\n+    SafeFuture<Integer> interruptorFut2 = new SafeFuture<>();\n+    Interruptor interruptor1 =\n+        SafeFuture.createInterruptor(interruptorFut1, IllegalStateException::new);\n+    Interruptor interruptor2 =\n+        SafeFuture.createInterruptor(interruptorFut2, IllegalStateException::new);\n+    SafeFuture<Integer> fut0 = new SafeFuture<>();\n+\n+    assertThat(hasDependents(interruptorFut1)).isFalse();\n+    assertThat(hasDependents(interruptorFut2)).isFalse();\n+    assertThat(hasDependents(fut0)).isFalse();\n+\n+    SafeFuture<Integer> intFut = fut0.orInterrupt(interruptor1, interruptor2);\n+\n+    assertThat(hasDependents(interruptorFut1)).isTrue();\n+    assertThat(hasDependents(interruptorFut2)).isTrue();\n+    assertThat(hasDependents(fut0)).isTrue();\n+\n+    interruptorFut2.complete(0);\n+\n+    assertThat(hasDependents(interruptorFut1)).isFalse();\n+    assertThat(hasDependents(interruptorFut2)).isFalse();\n+    assertThat(hasDependents(fut0)).isFalse();\n+    assertThat(intFut).isCompletedExceptionally();\n+  }\n+\n+  @Test\n+  public void interruptTest3() throws Exception {\n+    class AsyncExec {\n+      SafeFuture<Integer> fut = new SafeFuture<>();\n+      boolean executed = false;\n+\n+      SafeFuture<Integer> exec() {\n+        executed = true;\n+        return fut;\n+      }\n+    }\n+\n+    class Test {\n+      SafeFuture<Integer> interruptorFut1 = new SafeFuture<>();\n+      SafeFuture<Integer> interruptorFut2 = new SafeFuture<>();\n+      Interruptor interruptor1 =\n+          SafeFuture.createInterruptor(interruptorFut1, IllegalStateException::new);\n+      Interruptor interruptor2 =\n+          SafeFuture.createInterruptor(interruptorFut2, IllegalArgumentException::new);\n+      SafeFuture<Integer> fut0 = new SafeFuture<>();\n+      AsyncExec exec1 = new AsyncExec();\n+      AsyncExec exec2 = new AsyncExec();\n+\n+      SafeFuture<Integer> intFut =\n+          fut0.orInterrupt(interruptor1, interruptor2)\n+              .thenCompose(__ -> exec1.exec())\n+              .orInterrupt(interruptor1, interruptor2)\n+              .thenCompose(__ -> exec2.exec())\n+              .orInterrupt(interruptor1, interruptor2);\n+\n+      public Test() {\n+        assertThat(hasDependents(interruptorFut1)).isTrue();\n+        assertThat(hasDependents(interruptorFut2)).isTrue();\n+        assertThat(hasDependents(fut0)).isTrue();\n+      }\n+\n+      public void assertReleased() {\n+        assertThat(hasDependents(interruptorFut1)).isFalse();\n+        assertThat(hasDependents(interruptorFut2)).isFalse();\n+        assertThat(hasDependents(fut0)).isFalse();\n+      }\n+    }\n+\n+    {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7be46ad3a929e2bb2f7771a892464834ecd41226"}, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ0ODY0Mw==", "bodyText": "(nit) The generally format we tend to use for unit tests is <methodBeingTested_testCase>, would be nice to update these test names to be more descriptive.  For example:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public void interruptTest1() throws Exception {\n          \n          \n            \n              public void orInterrupt_completeWithoutFiringInterrupt() throws Exception {", "url": "https://github.com/ConsenSys/teku/pull/2335#discussion_r452448643", "createdAt": "2020-07-09T19:42:37Z", "author": {"login": "mbaxter"}, "path": "util/src/test/java/tech/pegasys/teku/util/async/SafeFutureTest.java", "diffHunk": "@@ -502,6 +503,201 @@ public void allOfFailFast_completesWhenAllFuturesComplete() {\n     assertThat(result).isCompleted();\n   }\n \n+  private static boolean hasDependents(CompletableFuture<?> fut) {\n+    return fut.toString().toLowerCase().contains(\"dependents\");\n+  }\n+\n+  @Test\n+  public void orTest1() throws Exception {\n+    SafeFuture<Integer> fut0 = new SafeFuture<>();\n+    SafeFuture<Integer> fut1 = new SafeFuture<>();\n+\n+    assertThat(hasDependents(fut0)).isFalse();\n+\n+    SafeFuture<Integer> orFut = fut0.or(fut1);\n+\n+    assertThat(hasDependents(fut0)).isTrue();\n+    assertThat(hasDependents(fut1)).isTrue();\n+\n+    fut1.complete(12);\n+\n+    assertThat(hasDependents(fut0)).isFalse();\n+    assertThat(hasDependents(fut1)).isFalse();\n+    assertThat(orFut.get()).isEqualTo(12);\n+  }\n+\n+  @Test\n+  public void orTest2() throws Exception {\n+    SafeFuture<Integer> fut0 = new SafeFuture<>();\n+    SafeFuture<Integer> fut1 = new SafeFuture<>();\n+\n+    assertThat(hasDependents(fut0)).isFalse();\n+\n+    SafeFuture<Integer> orFut = fut0.or(fut1);\n+\n+    assertThat(hasDependents(fut0)).isTrue();\n+    assertThat(hasDependents(fut1)).isTrue();\n+\n+    fut0.complete(12);\n+\n+    assertThat(hasDependents(fut0)).isFalse();\n+    assertThat(hasDependents(fut1)).isFalse();\n+    assertThat(orFut.get()).isEqualTo(12);\n+  }\n+\n+  @Test\n+  public void orTest3() {\n+    SafeFuture<Integer> fut0 = new SafeFuture<>();\n+    SafeFuture<Integer> fut1 = new SafeFuture<>();\n+\n+    assertThat(hasDependents(fut0)).isFalse();\n+\n+    SafeFuture<Integer> orFut = fut0.or(fut1);\n+\n+    assertThat(hasDependents(fut0)).isTrue();\n+    assertThat(hasDependents(fut1)).isTrue();\n+\n+    fut1.completeExceptionally(new IllegalStateException());\n+\n+    assertThat(hasDependents(fut0)).isFalse();\n+    assertThat(hasDependents(fut1)).isFalse();\n+    assertThat(orFut).isCompletedExceptionally();\n+  }\n+\n+  @Test\n+  public void interruptTest1() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7be46ad3a929e2bb2f7771a892464834ecd41226"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ2MzM4MA==", "bodyText": "Doesn't look like we use this - seems reasonable to require a custom exception on interruption ...", "url": "https://github.com/ConsenSys/teku/pull/2335#discussion_r452463380", "createdAt": "2020-07-09T20:12:39Z", "author": {"login": "mbaxter"}, "path": "util/src/main/java/tech/pegasys/teku/util/async/SafeFuture.java", "diffHunk": "@@ -87,6 +88,47 @@ public static void reportExceptions(final CompletionStage<?> future) {\n     }\n   }\n \n+  /**\n+   * Creates a completed {@link SafeFuture} instance if no of supplied interruptors is completed,\n+   * else creates an exceptionally completed {@link SafeFuture} instance\n+   *\n+   * @see #orInterrupt(Interruptor...)\n+   */\n+  public static SafeFuture<Void> notInterrupted(Interruptor... interruptors) {\n+    return SafeFuture.<Void>completedFuture(null).orInterrupt(interruptors);\n+  }\n+\n+  /**\n+   * Create {@link Interruptor} with default exception supplier which creates {@link\n+   * InterruptedException}\n+   *\n+   * @see #createInterruptor(CompletableFuture, Supplier)\n+   */\n+  public static Interruptor createInterruptor(CompletableFuture<?> interruptFuture) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7be46ad3a929e2bb2f7771a892464834ecd41226"}, "originalPosition": 28}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1OTgxODgx", "url": "https://github.com/ConsenSys/teku/pull/2335#pullrequestreview-445981881", "createdAt": "2020-07-09T21:28:42Z", "commit": {"oid": "7be46ad3a929e2bb2f7771a892464834ecd41226"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQyMToyODo0M1rOGvicwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wOVQyMTo0NzoyN1rOGvi9AQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjUwMDY3NA==", "bodyText": "Given this should never happen, could we log an error if it does instead of ignoring?", "url": "https://github.com/ConsenSys/teku/pull/2335#discussion_r452500674", "createdAt": "2020-07-09T21:28:43Z", "author": {"login": "ajsutton"}, "path": "util/src/main/java/tech/pegasys/teku/util/async/SafeFuture.java", "diffHunk": "@@ -332,4 +374,84 @@ public void finish(final Consumer<T> onSuccess, final Consumer<Throwable> onErro\n   public SafeFuture<T> orTimeout(final long timeout, final TimeUnit unit) {\n     return (SafeFuture<T>) super.orTimeout(timeout, unit);\n   }\n+\n+  @SafeVarargs\n+  @SuppressWarnings(\"unchecked\")\n+  public final SafeFuture<T> or(SafeFuture<T>... others) {\n+    SafeFuture<T>[] futures = Arrays.copyOf(others, others.length + 1);\n+    futures[others.length] = this;\n+    return anyOf(futures).thenApply(o -> (T) o);\n+  }\n+\n+  /**\n+   * Derives a {@link SafeFuture} which yields the same result as this {@link SafeFuture} if no\n+   * {@link Interruptor} was triggered before this future is done.\n+   *\n+   * <p>If any of supplied {@link Interruptor}s is triggered the returned {@link SafeFuture} is\n+   * completed exceptionally. The exception thrown depends on which specific Interruptor was\n+   * triggered\n+   *\n+   * <p>The key feature of this method is that {@code interruptFuture} contained in Interruptor\n+   * doesn't hold the reference to dependent futures after they complete. It's desired to consider\n+   * this for long living interrupting futures to avoid memory leaks\n+   *\n+   * @param interruptors a set of interruptors which futures trigger interruption if complete\n+   *     (normally or exceptionally)\n+   * @see #createInterruptor(CompletableFuture, Supplier)\n+   */\n+  public SafeFuture<T> orInterrupt(Interruptor... interruptors) {\n+    CompletableFuture<?>[] allFuts = new CompletableFuture<?>[interruptors.length + 1];\n+    allFuts[0] = this;\n+    for (int i = 0; i < interruptors.length; i++) {\n+      allFuts[i + 1] = interruptors[i].interruptFuture;\n+    }\n+    SafeFuture<T> ret = new SafeFuture<>();\n+    anyOf(allFuts)\n+        .whenComplete(\n+            (res, err) -> {\n+              if (this.isDone()) {\n+                this.propagateTo(ret);\n+              } else {\n+                for (Interruptor interruptor : interruptors) {\n+                  if (interruptor.interruptFuture.isDone()) {\n+                    try {\n+                      interruptor.getInterruptFuture().get();\n+                      ret.completeExceptionally(interruptor.getExceptionSupplier().get());\n+                    } catch (Exception e) {\n+                      ret.completeExceptionally(e);\n+                    }\n+                  }\n+                }\n+              }\n+            })\n+        .exceptionally(e -> null); // all exceptions are propagated to ret", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7be46ad3a929e2bb2f7771a892464834ecd41226"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjUwODkyOQ==", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * Creates a completed {@link SafeFuture} instance if no of supplied interruptors is completed,\n          \n          \n            \n               * Creates a completed {@link SafeFuture} instance if none of the supplied interruptors are completed,", "url": "https://github.com/ConsenSys/teku/pull/2335#discussion_r452508929", "createdAt": "2020-07-09T21:47:27Z", "author": {"login": "ajsutton"}, "path": "util/src/main/java/tech/pegasys/teku/util/async/SafeFuture.java", "diffHunk": "@@ -87,6 +88,47 @@ public static void reportExceptions(final CompletionStage<?> future) {\n     }\n   }\n \n+  /**\n+   * Creates a completed {@link SafeFuture} instance if no of supplied interruptors is completed,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7be46ad3a929e2bb2f7771a892464834ecd41226"}, "originalPosition": 13}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "616a6b649a284fc66eddc423c6c288b38a2f4b52", "author": {"user": {"login": "Nashatyrev", "name": "Anton Nashatyrev"}}, "url": "https://github.com/ConsenSys/teku/commit/616a6b649a284fc66eddc423c6c288b38a2f4b52", "committedDate": "2020-07-10T12:27:38Z", "message": "Move test classes out of method"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8857d3387399a1356e964c26bb7099274aaa00d7", "author": {"user": {"login": "Nashatyrev", "name": "Anton Nashatyrev"}}, "url": "https://github.com/ConsenSys/teku/commit/8857d3387399a1356e964c26bb7099274aaa00d7", "committedDate": "2020-07-10T12:34:24Z", "message": "Split and rename tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0fd75183daee34cf991f49898b580015df4fce86", "author": {"user": {"login": "Nashatyrev", "name": "Anton Nashatyrev"}}, "url": "https://github.com/ConsenSys/teku/commit/0fd75183daee34cf991f49898b580015df4fce86", "committedDate": "2020-07-10T12:35:36Z", "message": "Remove unused method"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "963187eea9bd27db8254adfcfc2a6756d2dd06fa", "author": {"user": {"login": "Nashatyrev", "name": "Anton Nashatyrev"}}, "url": "https://github.com/ConsenSys/teku/commit/963187eea9bd27db8254adfcfc2a6756d2dd06fa", "committedDate": "2020-07-10T12:36:32Z", "message": "Fix the doc wording\n\nCo-authored-by: Adrian Sutton <adrian@symphonious.net>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "97bae5a8394ac845e7b1ad05c4b1810147485a92", "author": {"user": {"login": "Nashatyrev", "name": "Anton Nashatyrev"}}, "url": "https://github.com/ConsenSys/teku/commit/97bae5a8394ac845e7b1ad05c4b1810147485a92", "committedDate": "2020-07-10T12:36:47Z", "message": "Merge branch 'fix-rpc-handler-close-future-leak' of https://github.com/Nashatyrev/artemis into fix-rpc-handler-close-future-leak"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2d459fb2702ff673e34e9ccdeb7227dca1e54b23", "author": {"user": {"login": "Nashatyrev", "name": "Anton Nashatyrev"}}, "url": "https://github.com/ConsenSys/teku/commit/2d459fb2702ff673e34e9ccdeb7227dca1e54b23", "committedDate": "2020-07-10T12:49:23Z", "message": "Add FutureReturnValueIgnored warning suppress with comment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a6f5d4afcfee286fcfd05702f17cedcc35da1b9d", "author": {"user": {"login": "Nashatyrev", "name": "Anton Nashatyrev"}}, "url": "https://github.com/ConsenSys/teku/commit/a6f5d4afcfee286fcfd05702f17cedcc35da1b9d", "committedDate": "2020-07-10T12:53:04Z", "message": "Spotless apply"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3MzI5ODEw", "url": "https://github.com/ConsenSys/teku/pull/2335#pullrequestreview-447329810", "createdAt": "2020-07-13T14:56:23Z", "commit": {"oid": "a6f5d4afcfee286fcfd05702f17cedcc35da1b9d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNDo1NjoyM1rOGwsVVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xM1QxNDo1NjoyM1rOGwsVVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzcxMTE4OQ==", "bodyText": "If an interrupt fires, don't we still need to close the controller?", "url": "https://github.com/ConsenSys/teku/pull/2335#discussion_r453711189", "createdAt": "2020-07-13T14:56:23Z", "author": {"login": "mbaxter"}, "path": "networking/p2p/src/main/java/tech/pegasys/teku/networking/p2p/libp2p/rpc/RpcHandler.java", "diffHunk": "@@ -58,53 +59,28 @@ public RpcHandler(final AsyncRunner asyncRunner, RpcMethod rpcMethod) {\n   @SuppressWarnings(\"unchecked\")\n   public SafeFuture<RpcStream> sendRequest(\n       Connection connection, Bytes initialPayload, RpcRequestHandler handler) {\n-    if (connection.closeFuture().isDone()) {\n-      return SafeFuture.failedFuture(new PeerDisconnectedException());\n-    }\n \n-    SafeFuture<RpcStream> streamFuture = new SafeFuture<>();\n+    Interruptor closeInterruptor =\n+        SafeFuture.createInterruptor(connection.closeFuture(), PeerDisconnectedException::new);\n+    Interruptor timeoutInterruptor =\n+        SafeFuture.createInterruptor(\n+            asyncRunner.getDelayedFuture(TIMEOUT.toMillis(), TimeUnit.MILLISECONDS),\n+            () ->\n+                new StreamTimeoutException(\n+                    \"Timed out waiting to initialize stream for method \" + rpcMethod.getId()));\n \n-    // Complete future if peer disconnects\n-    SafeFuture.of(connection.closeFuture())\n-        .always(() -> streamFuture.completeExceptionally(new PeerDisconnectedException()));\n-    // Complete future if we fail to initialize\n-    asyncRunner\n-        .getDelayedFuture(TIMEOUT.toMillis(), TimeUnit.MILLISECONDS)\n-        .thenAccept(\n-            __ ->\n-                streamFuture.completeExceptionally(\n-                    new StreamTimeoutException(\n-                        \"Timed out waiting to initialize stream for method \" + rpcMethod.getId())))\n-        .reportExceptions();\n-\n-    // Try to initiate stream\n-    SafeFuture.of(\n-            connection\n-                .muxerSession()\n-                .createStream(Multistream.create(this).toStreamHandler())\n-                .getController())\n+    return SafeFuture.notInterrupted(closeInterruptor)\n         .thenCompose(\n-            ctr -> {\n-              ctr.setRequestHandler(handler);\n-              return ctr.getRpcStream()\n-                  .writeBytes(initialPayload)\n-                  .thenApply(f -> ctr.getRpcStream())\n-                  .thenAccept(\n-                      rpcStream -> {\n-                        if (!streamFuture.complete(rpcStream)) {\n-                          // If future was already completed exceptionally, close the controller\n-                          ctr.close();\n-                        }\n-                      });\n-            })\n-        .exceptionally(\n-            err -> {\n-              streamFuture.completeExceptionally(err);\n-              return null;\n-            })\n-        .reportExceptions();\n-\n-    return streamFuture;\n+            __ ->\n+                connection\n+                    .muxerSession()\n+                    .createStream(Multistream.create(this).toStreamHandler())\n+                    .getController())\n+        .orInterrupt(closeInterruptor, timeoutInterruptor)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6f5d4afcfee286fcfd05702f17cedcc35da1b9d"}, "originalPosition": 73}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a013b3efd416279868ba62f3a6c09180ba7c6bfa", "author": {"user": {"login": "Nashatyrev", "name": "Anton Nashatyrev"}}, "url": "https://github.com/ConsenSys/teku/commit/a013b3efd416279868ba62f3a6c09180ba7c6bfa", "committedDate": "2020-07-13T15:36:29Z", "message": "Merge remote-tracking branch 'pegasys/master' into fix-rpc-handler-close-future-leak"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4beacd40b5f5310f932c202f05113021b1c10923", "author": {"user": {"login": "Nashatyrev", "name": "Anton Nashatyrev"}}, "url": "https://github.com/ConsenSys/teku/commit/4beacd40b5f5310f932c202f05113021b1c10923", "committedDate": "2020-07-15T10:38:10Z", "message": "Merge remote-tracking branch 'pegasys/master' into fix-rpc-handler-close-future-leak"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1a67626f3b63bb0e18351ee4090885827c1ff7c4", "author": {"user": {"login": "Nashatyrev", "name": "Anton Nashatyrev"}}, "url": "https://github.com/ConsenSys/teku/commit/1a67626f3b63bb0e18351ee4090885827c1ff7c4", "committedDate": "2020-07-15T10:38:45Z", "message": "When sending RPC request close the created stream if any exception or interruption occurs while sending initial payload"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ba108a5453dc0ea80e9e6b5513ebad45a4321c29", "author": {"user": {"login": "Nashatyrev", "name": "Anton Nashatyrev"}}, "url": "https://github.com/ConsenSys/teku/commit/ba108a5453dc0ea80e9e6b5513ebad45a4321c29", "committedDate": "2020-07-15T14:51:23Z", "message": "Fix SafeFuture.notInterrupted. Add a test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d392fc5704a647b2aa714c6bc961237e409811ed", "author": {"user": {"login": "Nashatyrev", "name": "Anton Nashatyrev"}}, "url": "https://github.com/ConsenSys/teku/commit/d392fc5704a647b2aa714c6bc961237e409811ed", "committedDate": "2020-07-15T15:15:33Z", "message": "Add RpcHandlerTest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a0f9f0f1e53b65ec9e5b57b2a8a2f2f9d0e4b3ce", "author": {"user": {"login": "Nashatyrev", "name": "Anton Nashatyrev"}}, "url": "https://github.com/ConsenSys/teku/commit/a0f9f0f1e53b65ec9e5b57b2a8a2f2f9d0e4b3ce", "committedDate": "2020-07-15T15:16:15Z", "message": "Apply spotless"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c0be43c495455dde851d8c7aefc84cb9e5078dcc", "author": {"user": {"login": "Nashatyrev", "name": "Anton Nashatyrev"}}, "url": "https://github.com/ConsenSys/teku/commit/c0be43c495455dde851d8c7aefc84cb9e5078dcc", "committedDate": "2020-07-15T17:15:44Z", "message": "Resolve unhandled future warning"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5MjExOTQ1", "url": "https://github.com/ConsenSys/teku/pull/2335#pullrequestreview-449211945", "createdAt": "2020-07-15T18:12:24Z", "commit": {"oid": "c0be43c495455dde851d8c7aefc84cb9e5078dcc"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxODoxMjoyNFrOGyKDGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxODoyOTozMVrOGyKssQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI0NjYxOQ==", "bodyText": "It seems pretty unlikely we'll actually hit this, but isn't it still possible for us to leave a dangling stream open here if the timeout interrupts before getStream resolves?", "url": "https://github.com/ConsenSys/teku/pull/2335#discussion_r455246619", "createdAt": "2020-07-15T18:12:24Z", "author": {"login": "mbaxter"}, "path": "networking/p2p/src/main/java/tech/pegasys/teku/networking/p2p/libp2p/rpc/RpcHandler.java", "diffHunk": "@@ -58,53 +59,28 @@ public RpcHandler(final AsyncRunner asyncRunner, RpcMethod rpcMethod) {\n   @SuppressWarnings(\"unchecked\")\n   public SafeFuture<RpcStream> sendRequest(\n       Connection connection, Bytes initialPayload, RpcRequestHandler handler) {\n-    if (connection.closeFuture().isDone()) {\n-      return SafeFuture.failedFuture(new PeerDisconnectedException());\n-    }\n \n-    SafeFuture<RpcStream> streamFuture = new SafeFuture<>();\n+    Interruptor closeInterruptor =\n+        SafeFuture.createInterruptor(connection.closeFuture(), PeerDisconnectedException::new);\n+    Interruptor timeoutInterruptor =\n+        SafeFuture.createInterruptor(\n+            asyncRunner.getDelayedFuture(TIMEOUT.toMillis(), TimeUnit.MILLISECONDS),\n+            () ->\n+                new StreamTimeoutException(\n+                    \"Timed out waiting to initialize stream for method \" + rpcMethod.getId()));\n \n-    // Complete future if peer disconnects\n-    SafeFuture.of(connection.closeFuture())\n-        .always(() -> streamFuture.completeExceptionally(new PeerDisconnectedException()));\n-    // Complete future if we fail to initialize\n-    asyncRunner\n-        .getDelayedFuture(TIMEOUT.toMillis(), TimeUnit.MILLISECONDS)\n-        .thenAccept(\n-            __ ->\n-                streamFuture.completeExceptionally(\n-                    new StreamTimeoutException(\n-                        \"Timed out waiting to initialize stream for method \" + rpcMethod.getId())))\n-        .reportExceptions();\n-\n-    // Try to initiate stream\n-    SafeFuture.of(\n-            connection\n-                .muxerSession()\n-                .createStream(Multistream.create(this).toStreamHandler())\n-                .getController())\n+    return SafeFuture.notInterrupted(closeInterruptor)\n         .thenCompose(\n-            ctr -> {\n-              ctr.setRequestHandler(handler);\n-              return ctr.getRpcStream()\n-                  .writeBytes(initialPayload)\n-                  .thenApply(f -> ctr.getRpcStream())\n-                  .thenAccept(\n-                      rpcStream -> {\n-                        if (!streamFuture.complete(rpcStream)) {\n-                          // If future was already completed exceptionally, close the controller\n-                          ctr.close();\n-                        }\n-                      });\n-            })\n-        .exceptionally(\n-            err -> {\n-              streamFuture.completeExceptionally(err);\n-              return null;\n-            })\n-        .reportExceptions();\n-\n-    return streamFuture;\n+            __ ->\n+                connection\n+                    .muxerSession()\n+                    .createStream(Multistream.create(this).toStreamHandler())\n+                    .getController())\n+        .orInterrupt(closeInterruptor, timeoutInterruptor)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzcxMTE4OQ=="}, "originalCommit": {"oid": "a6f5d4afcfee286fcfd05702f17cedcc35da1b9d"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI1NzAyNg==", "bodyText": "nice! \ud83c\udf89", "url": "https://github.com/ConsenSys/teku/pull/2335#discussion_r455257026", "createdAt": "2020-07-15T18:29:11Z", "author": {"login": "mbaxter"}, "path": "networking/p2p/src/test/java/tech/pegasys/teku/networking/p2p/libp2p/rpc/RpcHandlerTest.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.networking.p2p.libp2p.rpc;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import io.libp2p.core.Connection;\n+import io.libp2p.core.Stream;\n+import io.libp2p.core.StreamPromise;\n+import io.libp2p.core.mux.StreamMuxer.Session;\n+import java.util.concurrent.CompletableFuture;\n+import kotlin.Unit;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import tech.pegasys.teku.networking.p2p.libp2p.rpc.RpcHandler.Controller;\n+import tech.pegasys.teku.networking.p2p.peer.PeerDisconnectedException;\n+import tech.pegasys.teku.networking.p2p.rpc.RpcMethod;\n+import tech.pegasys.teku.networking.p2p.rpc.RpcRequestHandler;\n+import tech.pegasys.teku.networking.p2p.rpc.RpcStream;\n+import tech.pegasys.teku.networking.p2p.rpc.StreamTimeoutException;\n+import tech.pegasys.teku.util.async.SafeFuture;\n+import tech.pegasys.teku.util.async.StubAsyncRunner;\n+\n+public class RpcHandlerTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0be43c495455dde851d8c7aefc84cb9e5078dcc"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI1NzI2NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                assertThat(closeFuture.getNumberOfDependents()).isEqualTo(0);\n          \n          \n            \n                assertThat(closeFuture.getNumberOfDependents()).isEqualTo(0);\n          \n          \n            \n                verify(stream).close();", "url": "https://github.com/ConsenSys/teku/pull/2335#discussion_r455257265", "createdAt": "2020-07-15T18:29:31Z", "author": {"login": "mbaxter"}, "path": "networking/p2p/src/test/java/tech/pegasys/teku/networking/p2p/libp2p/rpc/RpcHandlerTest.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.networking.p2p.libp2p.rpc;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import io.libp2p.core.Connection;\n+import io.libp2p.core.Stream;\n+import io.libp2p.core.StreamPromise;\n+import io.libp2p.core.mux.StreamMuxer.Session;\n+import java.util.concurrent.CompletableFuture;\n+import kotlin.Unit;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import tech.pegasys.teku.networking.p2p.libp2p.rpc.RpcHandler.Controller;\n+import tech.pegasys.teku.networking.p2p.peer.PeerDisconnectedException;\n+import tech.pegasys.teku.networking.p2p.rpc.RpcMethod;\n+import tech.pegasys.teku.networking.p2p.rpc.RpcRequestHandler;\n+import tech.pegasys.teku.networking.p2p.rpc.RpcStream;\n+import tech.pegasys.teku.networking.p2p.rpc.StreamTimeoutException;\n+import tech.pegasys.teku.util.async.SafeFuture;\n+import tech.pegasys.teku.util.async.StubAsyncRunner;\n+\n+public class RpcHandlerTest {\n+\n+  StubAsyncRunner asyncRunner = new StubAsyncRunner();\n+  RpcMethod rpcMethod = mock(RpcMethod.class);\n+  RpcHandler rpcHandler = new RpcHandler(asyncRunner, rpcMethod);\n+\n+  Connection connection = mock(Connection.class);\n+  Session session = mock(Session.class);\n+  StreamPromise<Object> streamPromise =\n+      new StreamPromise<>(new CompletableFuture<>(), new CompletableFuture<>());\n+  CompletableFuture<Unit> closeFuture = new CompletableFuture<>();\n+  SafeFuture<Void> writeFuture = new SafeFuture<>();\n+\n+  Stream stream = mock(Stream.class);\n+  Controller controller = mock(Controller.class);\n+  RpcStream rpcStream = mock(RpcStream.class);\n+  RpcRequestHandler rpcRequestHandler = mock(RpcRequestHandler.class);\n+\n+  @BeforeEach\n+  void init() {\n+    when(connection.muxerSession()).thenReturn(session);\n+    when(session.createStream(any())).thenReturn(streamPromise);\n+    when(connection.closeFuture()).thenReturn(closeFuture);\n+\n+    when(controller.getRpcStream()).thenReturn(rpcStream);\n+    when(rpcStream.writeBytes(any())).thenReturn(writeFuture);\n+  }\n+\n+  @Test\n+  void sendRequest_positiveCase() {\n+    SafeFuture<RpcStream> future =\n+        rpcHandler.sendRequest(connection, Bytes.fromHexString(\"0x11223344\"), rpcRequestHandler);\n+\n+    assertThat(future).isNotDone();\n+    streamPromise.getStream().complete(stream);\n+\n+    assertThat(future).isNotDone();\n+    streamPromise.getController().complete(controller);\n+\n+    assertThat(future).isNotDone();\n+    writeFuture.complete(null);\n+\n+    verify(stream, never()).close();\n+    verify(controller, never()).close();\n+    assertThat(future).isCompletedWithValue(rpcStream);\n+    assertThat(closeFuture.getNumberOfDependents()).isEqualTo(0);\n+\n+    // interrupting after completion shouldn't affect anything\n+    closeFuture.complete(null);\n+\n+    verify(stream, never()).close();\n+    verify(controller, never()).close();\n+    assertThat(future).isCompletedWithValue(rpcStream);\n+    assertThat(closeFuture.getNumberOfDependents()).isEqualTo(0);\n+  }\n+\n+  @Test\n+  void sendRequest_streamClosedWhenConnectionClosedBeforeController() {\n+    SafeFuture<RpcStream> future =\n+        rpcHandler.sendRequest(connection, Bytes.fromHexString(\"0x11223344\"), rpcRequestHandler);\n+\n+    streamPromise.getStream().complete(stream);\n+    closeFuture.complete(null);\n+\n+    verify(connection).muxerSession();\n+    verify(controller, never()).getRpcStream();\n+\n+    assertThatThrownBy(future::get).hasRootCauseInstanceOf(PeerDisconnectedException.class);\n+    assertThat(closeFuture.getNumberOfDependents()).isEqualTo(0);\n+  }\n+\n+  @Test\n+  void sendRequest_streamClosedWhenConnectionClosedBeforeWrite() {\n+    SafeFuture<RpcStream> future =\n+        rpcHandler.sendRequest(connection, Bytes.fromHexString(\"0x11223344\"), rpcRequestHandler);\n+\n+    streamPromise.getStream().complete(stream);\n+    streamPromise.getController().complete(controller);\n+    closeFuture.complete(null);\n+\n+    verify(connection).muxerSession();\n+    verify(controller).getRpcStream();\n+    verify(rpcStream).writeBytes(any());\n+\n+    assertThatThrownBy(future::get).hasRootCauseInstanceOf(PeerDisconnectedException.class);\n+    assertThat(closeFuture.getNumberOfDependents()).isEqualTo(0);\n+  }\n+\n+  @Test\n+  void sendRequest_noStreamCreationWhenInitiallyClosed() {\n+    closeFuture.complete(null);\n+\n+    SafeFuture<RpcStream> future =\n+        rpcHandler.sendRequest(connection, Bytes.fromHexString(\"0x11223344\"), rpcRequestHandler);\n+\n+    verify(connection, never()).muxerSession();\n+    assertThatThrownBy(future::get).hasRootCauseInstanceOf(PeerDisconnectedException.class);\n+    assertThat(closeFuture.getNumberOfDependents()).isEqualTo(0);\n+  }\n+\n+  @Test\n+  void sendRequest_streamClosedOnTimeoutBeforeController() {\n+    SafeFuture<RpcStream> future =\n+        rpcHandler.sendRequest(connection, Bytes.fromHexString(\"0x11223344\"), rpcRequestHandler);\n+\n+    streamPromise.getStream().complete(stream);\n+    asyncRunner.executeQueuedActions();\n+\n+    verify(connection).muxerSession();\n+    verify(controller, never()).getRpcStream();\n+\n+    assertThatThrownBy(future::get).hasRootCauseInstanceOf(StreamTimeoutException.class);\n+    assertThat(closeFuture.getNumberOfDependents()).isEqualTo(0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0be43c495455dde851d8c7aefc84cb9e5078dcc"}, "originalPosition": 154}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1cbacb7c4ce2cc731386bacd323118fcfd76c3a4", "author": {"user": {"login": "Nashatyrev", "name": "Anton Nashatyrev"}}, "url": "https://github.com/ConsenSys/teku/commit/1cbacb7c4ce2cc731386bacd323118fcfd76c3a4", "committedDate": "2020-07-15T19:46:53Z", "message": "Check that stream was closed in tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ5MzIyOTc3", "url": "https://github.com/ConsenSys/teku/pull/2335#pullrequestreview-449322977", "createdAt": "2020-07-15T20:54:47Z", "commit": {"oid": "1cbacb7c4ce2cc731386bacd323118fcfd76c3a4"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3829, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}