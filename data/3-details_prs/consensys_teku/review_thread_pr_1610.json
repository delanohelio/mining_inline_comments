{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA0OTAzNjAw", "number": 1610, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwMDoyMDo0N1rODzfsGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwMDoyNDo1N1rODzfuoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1MzIzMTYxOnYy", "diffSide": "RIGHT", "path": "services/beaconchain/src/main/java/tech/pegasys/artemis/services/beaconchain/BeaconChainController.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwMDoyMDo0N1rOGH_BBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwMDoyMDo0N1rOGH_BBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTAyNTY3MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                beaconChainMetrics.initialise(metricsSystem);\n          \n          \n            \n                beaconChainMetrics.initialize(metricsSystem);", "url": "https://github.com/ConsenSys/teku/pull/1610#discussion_r411025670", "createdAt": "2020-04-20T00:20:47Z", "author": {"login": "macfarla"}, "path": "services/beaconchain/src/main/java/tech/pegasys/artemis/services/beaconchain/BeaconChainController.java", "diffHunk": "@@ -220,124 +220,10 @@ private void initForkChoice() {\n     eventChannels.subscribe(FinalizedCheckpointChannel.class, forkChoice);\n   }\n \n-  private long getCurrentSlotValue() {\n-    return nodeSlot.longValue();\n-  }\n-\n-  private long getHeadSlotValue() {\n-    return recentChainData.getBestSlot().longValue();\n-  }\n-\n-  private static long getLongFromRoot(Bytes32 root) {\n-    return root.getLong(24, ByteOrder.LITTLE_ENDIAN);\n-  }\n-\n-  private long getFinalizedRootValue() {\n-    Optional<BeaconBlockAndState> maybeBlockAndState = recentChainData.getBestBlockAndState();\n-    if (maybeBlockAndState.isPresent()) {\n-      Bytes32 root =\n-          maybeBlockAndState.get().getState().getCurrent_justified_checkpoint().getRoot();\n-      return getLongFromRoot(root);\n-    }\n-    return 0L;\n-  }\n-\n-  private long getPreviousJustifiedRootValue() {\n-    Optional<BeaconBlockAndState> maybeBlockAndState = recentChainData.getBestBlockAndState();\n-    if (maybeBlockAndState.isPresent()) {\n-      Bytes32 root =\n-          maybeBlockAndState.get().getState().getPrevious_justified_checkpoint().getRoot();\n-      return getLongFromRoot(root);\n-    }\n-    return 0L;\n-  }\n-\n-  private long getJustifiedRootValue() {\n-    Optional<BeaconBlockAndState> maybeBlockAndState = recentChainData.getBestBlockAndState();\n-    if (maybeBlockAndState.isPresent()) {\n-      Bytes32 root =\n-          maybeBlockAndState.get().getState().getCurrent_justified_checkpoint().getRoot();\n-      return getLongFromRoot(root);\n-    }\n-    return 0L;\n-  }\n-\n-  private long getHeadRootValue() {\n-    Optional<Bytes32> maybeBlockRoot = recentChainData.getBestBlockRoot();\n-    return maybeBlockRoot.isPresent() ? getLongFromRoot(maybeBlockRoot.get()) : 0L;\n-  }\n-\n-  private long getFinalizedEpochValue() {\n-    return recentChainData.getFinalizedEpoch().longValue();\n-  }\n-\n-  private long getJustifiedEpochValue() {\n-    return recentChainData.getStore().getBestJustifiedCheckpoint().getEpoch().longValue();\n-  }\n-\n-  private long getPreviousJustifiedEpochValue() {\n-    Optional<BeaconBlockAndState> maybeBlockAndState = recentChainData.getBestBlockAndState();\n-    if (maybeBlockAndState.isPresent()) {\n-      return maybeBlockAndState\n-          .get()\n-          .getState()\n-          .getPrevious_justified_checkpoint()\n-          .getEpoch()\n-          .longValue();\n-    }\n-    return 0L;\n-  }\n-\n   public void initMetrics() {\n     LOG.debug(\"BeaconChainController.initMetrics()\");\n-    metricsSystem.createGauge(\n-        ArtemisMetricCategory.BEACON,\n-        \"slot\",\n-        \"Latest slot recorded by the beacon chain\",\n-        this::getCurrentSlotValue);\n-    metricsSystem.createGauge(\n-        ArtemisMetricCategory.BEACON,\n-        \"head_slot\",\n-        \"Slot of the head block of the beacon chain\",\n-        this::getHeadSlotValue);\n-    metricsSystem.createGauge(\n-        ArtemisMetricCategory.BEACON,\n-        \"head_root\",\n-        \"Root of the head block of the beacon chain\",\n-        this::getHeadRootValue);\n-\n-    metricsSystem.createGauge(\n-        ArtemisMetricCategory.BEACON,\n-        \"finalized_epoch\",\n-        \"Current finalized epoch\",\n-        this::getFinalizedEpochValue);\n-    metricsSystem.createGauge(\n-        ArtemisMetricCategory.BEACON,\n-        \"finalized_root\",\n-        \"Current finalized root\",\n-        this::getFinalizedRootValue);\n-\n-    metricsSystem.createGauge(\n-        ArtemisMetricCategory.BEACON,\n-        \"current_justified_epoch\",\n-        \"Current justified epoch\",\n-        this::getJustifiedEpochValue);\n-    metricsSystem.createGauge(\n-        ArtemisMetricCategory.BEACON,\n-        \"current_justified_root\",\n-        \"Current justified root\",\n-        this::getJustifiedRootValue);\n-\n-    metricsSystem.createGauge(\n-        ArtemisMetricCategory.BEACON,\n-        \"previous_justified_epoch\",\n-        \"Current previously justified epoch\",\n-        this::getPreviousJustifiedEpochValue);\n-    metricsSystem.createGauge(\n-        ArtemisMetricCategory.BEACON,\n-        \"previous_justified_root\",\n-        \"Current previously justified root\",\n-        this::getPreviousJustifiedRootValue);\n+    beaconChainMetrics = new BeaconChainMetrics(recentChainData, nodeSlot);\n+    beaconChainMetrics.initialise(metricsSystem);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cc15a2e5802a9c6b4bad1ed044c7be2bb2d8c172"}, "originalPosition": 165}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1MzIzMzQxOnYy", "diffSide": "RIGHT", "path": "services/beaconchain/src/main/java/tech/pegasys/artemis/services/beaconchain/BeaconChainMetrics.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwMDoyMjowNVrOGH_B1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwMDoyMjowNVrOGH_B1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTAyNTg3Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public void initialise(final MetricsSystem metricsSystem) {\n          \n          \n            \n              public void initialize(final MetricsSystem metricsSystem) {", "url": "https://github.com/ConsenSys/teku/pull/1610#discussion_r411025877", "createdAt": "2020-04-20T00:22:05Z", "author": {"login": "macfarla"}, "path": "services/beaconchain/src/main/java/tech/pegasys/artemis/services/beaconchain/BeaconChainMetrics.java", "diffHunk": "@@ -0,0 +1,164 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.services.beaconchain;\n+\n+import java.nio.ByteOrder;\n+import java.util.Optional;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.hyperledger.besu.plugin.services.MetricsSystem;\n+import tech.pegasys.artemis.datastructures.blocks.BeaconBlockAndState;\n+import tech.pegasys.artemis.datastructures.blocks.NodeSlot;\n+import tech.pegasys.artemis.metrics.ArtemisMetricCategory;\n+import tech.pegasys.artemis.storage.client.RecentChainData;\n+\n+public class BeaconChainMetrics {\n+  private static final long NOT_SET = 0L;\n+  private final RecentChainData recentChainData;\n+  private volatile NodeSlot nodeSlot;\n+\n+  public BeaconChainMetrics(final RecentChainData recentChainData, NodeSlot nodeSlot) {\n+    this.recentChainData = recentChainData;\n+    this.nodeSlot = nodeSlot;\n+  }\n+\n+  public void initialise(final MetricsSystem metricsSystem) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cc15a2e5802a9c6b4bad1ed044c7be2bb2d8c172"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1MzIzODA5OnYy", "diffSide": "RIGHT", "path": "services/beaconchain/src/test/java/tech/pegasys/artemis/services/beaconchain/BeaconChainMetricsTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwMDoyNDo1N1rOGH_D_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwMDoyNDo1N1rOGH_D_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTAyNjQyOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              void getJustifiedEpochValue_shouldSupplyValueWhenStoreIsPresent() {\n          \n          \n            \n              void getJustifiedEpochValue_shouldReturnValueWhenStoreIsPresent() {", "url": "https://github.com/ConsenSys/teku/pull/1610#discussion_r411026428", "createdAt": "2020-04-20T00:24:57Z", "author": {"login": "macfarla"}, "path": "services/beaconchain/src/test/java/tech/pegasys/artemis/services/beaconchain/BeaconChainMetricsTest.java", "diffHunk": "@@ -0,0 +1,231 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.services.beaconchain;\n+\n+import static com.google.common.primitives.UnsignedLong.ONE;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.Optional;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.api.Test;\n+import tech.pegasys.artemis.datastructures.blocks.BeaconBlockAndState;\n+import tech.pegasys.artemis.datastructures.blocks.NodeSlot;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.state.Checkpoint;\n+import tech.pegasys.artemis.storage.client.RecentChainData;\n+\n+class BeaconChainMetricsTest {\n+  private static final UnsignedLong NODE_SLOT_VALUE = UnsignedLong.valueOf(100L);\n+  private final Bytes32 root =\n+      Bytes32.fromHexString(\"0x760aa80a2c5cc1452a5301ecb176b366372d5f2218e0c24eFFFFFFFFFFFFFFFF\");\n+  private final Bytes32 root2 =\n+      Bytes32.fromHexString(\"0x760aa80a2c5cc1452a5301ecb176b366372d5f2218e0c24eFFFFFFFFFFFFFF7F\");\n+  private final Bytes32 root3 =\n+      Bytes32.fromHexString(\"0x760aa80a2c5cc1452a5301ecb176b366372d5f2218e0c24e0000000000000080\");\n+  private final Checkpoint checkpoint = new Checkpoint(NODE_SLOT_VALUE, root);\n+\n+  private static BeaconBlockAndState blockAndState = mock(BeaconBlockAndState.class);\n+  private BeaconState state = mock(BeaconState.class);\n+\n+  private final NodeSlot nodeSlot = new NodeSlot(NODE_SLOT_VALUE);\n+\n+  private final RecentChainData recentChainData = mock(RecentChainData.class);\n+\n+  @Test\n+  void getLongFromRoot_shouldParseNegativeOne() {\n+    assertThat(-1L).isEqualTo(BeaconChainMetrics.getLongFromRoot(root));\n+  }\n+\n+  @Test\n+  void getLongFromRoot_shouldParseMaxLong() {\n+    assertThat(Long.MAX_VALUE).isEqualTo(BeaconChainMetrics.getLongFromRoot(root2));\n+  }\n+\n+  @Test\n+  void getLongFromRoot_shouldParseMinLong() {\n+    assertThat(Long.MIN_VALUE).isEqualTo(BeaconChainMetrics.getLongFromRoot(root3));\n+  }\n+\n+  @Test\n+  void getCurrentSlotValue_shouldReturnCurrentSlot() {\n+    BeaconChainMetrics metrics = new BeaconChainMetrics(recentChainData, nodeSlot);\n+    assertThat(NODE_SLOT_VALUE.longValue()).isEqualTo(metrics.getCurrentSlotValue());\n+  }\n+\n+  @Test\n+  void getHeadSlotValue_shouldSupplyValueWhenStoreIsPresent() {\n+    BeaconChainMetrics metrics = new BeaconChainMetrics(recentChainData, nodeSlot);\n+    when(recentChainData.isPreGenesis()).thenReturn(false);\n+    when(recentChainData.getBestSlot()).thenReturn(ONE);\n+\n+    assertThat(1L).isEqualTo(metrics.getHeadSlotValue());\n+    verify(recentChainData).isPreGenesis();\n+    verify(recentChainData).getBestSlot();\n+  }\n+\n+  @Test\n+  void getHeadSlotValue_shouldReturnNotSetWhenStoreNotPresent() {\n+    BeaconChainMetrics metrics = new BeaconChainMetrics(recentChainData, nodeSlot);\n+    when(recentChainData.isPreGenesis()).thenReturn(true);\n+\n+    assertThat(0L).isEqualTo(metrics.getHeadSlotValue());\n+    verify(recentChainData).isPreGenesis();\n+  }\n+\n+  @Test\n+  void getFinalizedEpochValue_shouldReturnNotSetWhenStoreNotPresent() {\n+    BeaconChainMetrics metrics = new BeaconChainMetrics(recentChainData, nodeSlot);\n+    when(recentChainData.isPreGenesis()).thenReturn(true);\n+\n+    assertThat(0L).isEqualTo(metrics.getFinalizedEpochValue());\n+    verify(recentChainData).isPreGenesis();\n+  }\n+\n+  @Test\n+  void getFinalizedEpochValue_shouldSupplyValueWhenStoreIsPresent() {\n+    BeaconChainMetrics metrics = new BeaconChainMetrics(recentChainData, nodeSlot);\n+    when(recentChainData.isPreGenesis()).thenReturn(false);\n+    when(recentChainData.getFinalizedEpoch()).thenReturn(ONE);\n+\n+    assertThat(1L).isEqualTo(metrics.getFinalizedEpochValue());\n+    verify(recentChainData).isPreGenesis();\n+  }\n+\n+  @Test\n+  void getHeadRootValue_shouldReturnNotSetWhenStoreNotPresent() {\n+    BeaconChainMetrics metrics = new BeaconChainMetrics(recentChainData, nodeSlot);\n+    when(recentChainData.isPreGenesis()).thenReturn(true);\n+\n+    assertThat(0L).isEqualTo(metrics.getHeadRootValue());\n+    verify(recentChainData).isPreGenesis();\n+  }\n+\n+  @Test\n+  void getHeadRootValue_shouldReturnValueWhenStoreIsPresent() {\n+    BeaconChainMetrics metrics = new BeaconChainMetrics(recentChainData, nodeSlot);\n+    when(recentChainData.isPreGenesis()).thenReturn(false);\n+    when(recentChainData.getBestBlockRoot()).thenReturn(Optional.of(root));\n+\n+    assertThat(-1L).isEqualTo(metrics.getHeadRootValue());\n+    verify(recentChainData).getBestBlockRoot();\n+  }\n+\n+  @Test\n+  void getFinalizedRootValue_shouldReturnNotSetWhenStoreNotPresent() {\n+    BeaconChainMetrics metrics = new BeaconChainMetrics(recentChainData, nodeSlot);\n+    when(recentChainData.isPreGenesis()).thenReturn(true);\n+    when(recentChainData.getBestBlockAndState()).thenCallRealMethod();\n+\n+    assertThat(0L).isEqualTo(metrics.getFinalizedRootValue());\n+    verify(recentChainData).isPreGenesis();\n+  }\n+\n+  @Test\n+  void getFinalizedRootValue_shouldReturnValueWhenStoreIsPresent() {\n+    BeaconChainMetrics metrics = new BeaconChainMetrics(recentChainData, nodeSlot);\n+    when(recentChainData.getBestBlockAndState()).thenReturn(Optional.of(blockAndState));\n+    when(blockAndState.getState()).thenReturn(state);\n+    when(state.getFinalized_checkpoint()).thenReturn(checkpoint);\n+\n+    assertThat(-1L).isEqualTo(metrics.getFinalizedRootValue());\n+    verify(state).getFinalized_checkpoint();\n+  }\n+\n+  @Test\n+  void getPreviousJustifiedEpochValue_shouldReturnNotSetWhenStoreNotPresent() {\n+    BeaconChainMetrics metrics = new BeaconChainMetrics(recentChainData, nodeSlot);\n+    when(recentChainData.isPreGenesis()).thenReturn(true);\n+    when(recentChainData.getBestBlockAndState()).thenCallRealMethod();\n+\n+    assertThat(0L).isEqualTo(metrics.getPreviousJustifiedEpochValue());\n+    verify(recentChainData).isPreGenesis();\n+  }\n+\n+  @Test\n+  void getPreviousJustifiedEpochValue_shouldSupplyValueWhenStoreIsPresent() {\n+    BeaconChainMetrics metrics = new BeaconChainMetrics(recentChainData, nodeSlot);\n+    when(recentChainData.isPreGenesis()).thenReturn(false);\n+    when(recentChainData.getBestBlockAndState()).thenReturn(Optional.of(blockAndState));\n+    when(blockAndState.getState()).thenReturn(state);\n+    when(state.getPrevious_justified_checkpoint()).thenReturn(checkpoint);\n+\n+    assertThat(NODE_SLOT_VALUE.longValue()).isEqualTo(metrics.getPreviousJustifiedEpochValue());\n+    verify(state).getPrevious_justified_checkpoint();\n+  }\n+\n+  @Test\n+  void getPreviousJustifiedRootValue_shouldReturnNotSetWhenStoreNotPresent() {\n+    BeaconChainMetrics metrics = new BeaconChainMetrics(recentChainData, nodeSlot);\n+    when(recentChainData.isPreGenesis()).thenReturn(true);\n+    when(recentChainData.getBestBlockAndState()).thenCallRealMethod();\n+\n+    assertThat(0L).isEqualTo(metrics.getPreviousJustifiedRootValue());\n+    verify(recentChainData).isPreGenesis();\n+  }\n+\n+  @Test\n+  void getPreviousJustifiedRootValue_shouldReturnValueWhenStoreIsPresent() {\n+    BeaconChainMetrics metrics = new BeaconChainMetrics(recentChainData, nodeSlot);\n+    when(recentChainData.getBestBlockAndState()).thenReturn(Optional.of(blockAndState));\n+    when(blockAndState.getState()).thenReturn(state);\n+    when(state.getPrevious_justified_checkpoint()).thenReturn(checkpoint);\n+\n+    assertThat(-1L).isEqualTo(metrics.getPreviousJustifiedRootValue());\n+    verify(state).getPrevious_justified_checkpoint();\n+  }\n+\n+  @Test\n+  void getJustifiedRootValue_shouldReturnNotSetWhenStoreNotPresent() {\n+    BeaconChainMetrics metrics = new BeaconChainMetrics(recentChainData, nodeSlot);\n+    when(recentChainData.isPreGenesis()).thenReturn(true);\n+    when(recentChainData.getBestBlockAndState()).thenCallRealMethod();\n+\n+    assertThat(0L).isEqualTo(metrics.getJustifiedRootValue());\n+    verify(recentChainData).isPreGenesis();\n+  }\n+\n+  @Test\n+  void getJustifiedRootValue_shouldReturnValueWhenStoreIsPresent() {\n+    BeaconChainMetrics metrics = new BeaconChainMetrics(recentChainData, nodeSlot);\n+    when(recentChainData.getBestBlockAndState()).thenReturn(Optional.of(blockAndState));\n+    when(blockAndState.getState()).thenReturn(state);\n+    when(state.getCurrent_justified_checkpoint()).thenReturn(new Checkpoint(NODE_SLOT_VALUE, root));\n+\n+    assertThat(-1L).isEqualTo(metrics.getJustifiedRootValue());\n+    verify(state).getCurrent_justified_checkpoint();\n+  }\n+\n+  @Test\n+  void getJustifiedEpochValue_shouldReturnNotSetWhenStoreNotPresent() {\n+    BeaconChainMetrics metrics = new BeaconChainMetrics(recentChainData, nodeSlot);\n+    when(recentChainData.isPreGenesis()).thenReturn(true);\n+\n+    assertThat(0L).isEqualTo(metrics.getJustifiedEpochValue());\n+    verify(recentChainData).isPreGenesis();\n+  }\n+\n+  @Test\n+  void getJustifiedEpochValue_shouldSupplyValueWhenStoreIsPresent() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cc15a2e5802a9c6b4bad1ed044c7be2bb2d8c172"}, "originalPosition": 223}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1652, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}