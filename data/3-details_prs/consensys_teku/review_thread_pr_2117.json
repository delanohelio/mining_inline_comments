{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMyNjcxMTkz", "number": 2117, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMjo1NDoyNVrOEEfEvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMjo1OTowNVrOEEfITQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMTM4ODc2OnYy", "diffSide": "RIGHT", "path": "ethereum/core/src/test/java/tech/pegasys/teku/core/StateGeneratorTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMjo1NDoyNVrOGiI6kQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNToxNjo0NVrOGiiBTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ1MDgzMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    assertThat(resultMap.get(root) == expectedResult.get(root)).isTrue();\n          \n          \n            \n                    assertThat(resultMap.get(root)).isSameAs(expectedResult.get(root));", "url": "https://github.com/ConsenSys/teku/pull/2117#discussion_r438450833", "createdAt": "2020-06-10T22:54:25Z", "author": {"login": "ajsutton"}, "path": "ethereum/core/src/test/java/tech/pegasys/teku/core/StateGeneratorTest.java", "diffHunk": "@@ -215,7 +230,19 @@ private void testRegenerateAllStates(\n     assertThat(resultMap.size()).isEqualTo(results.size());\n     // Check that our expectations are met\n     assertThat(resultMap.size()).isEqualTo(expectedResult.size());\n-    assertThat(resultMap).isEqualToComparingFieldByField(expectedResult);\n+    assertThat(resultMap).containsExactlyInAnyOrderEntriesOf(expectedResult);\n+    // Check states were / were not regenerated as expected\n+    if (supplyAllKnownStates) {\n+      // No states should be regenerated - they should all match the known state\n+      for (Bytes32 root : expectedResult.keySet()) {\n+        assertThat(resultMap.get(root) == expectedResult.get(root)).isTrue();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "744022beaa59995c0d4815ebbb07c8ccddd6faea"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg2MjE1Nw==", "bodyText": "thanks - I knew there was an API for this but couldn't find it!", "url": "https://github.com/ConsenSys/teku/pull/2117#discussion_r438862157", "createdAt": "2020-06-11T15:16:45Z", "author": {"login": "mbaxter"}, "path": "ethereum/core/src/test/java/tech/pegasys/teku/core/StateGeneratorTest.java", "diffHunk": "@@ -215,7 +230,19 @@ private void testRegenerateAllStates(\n     assertThat(resultMap.size()).isEqualTo(results.size());\n     // Check that our expectations are met\n     assertThat(resultMap.size()).isEqualTo(expectedResult.size());\n-    assertThat(resultMap).isEqualToComparingFieldByField(expectedResult);\n+    assertThat(resultMap).containsExactlyInAnyOrderEntriesOf(expectedResult);\n+    // Check states were / were not regenerated as expected\n+    if (supplyAllKnownStates) {\n+      // No states should be regenerated - they should all match the known state\n+      for (Bytes32 root : expectedResult.keySet()) {\n+        assertThat(resultMap.get(root) == expectedResult.get(root)).isTrue();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ1MDgzMw=="}, "originalCommit": {"oid": "744022beaa59995c0d4815ebbb07c8ccddd6faea"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMTM4OTI3OnYy", "diffSide": "RIGHT", "path": "ethereum/core/src/test/java/tech/pegasys/teku/core/StateGeneratorTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMjo1NDozOVrOGiI64A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMjo1NDozOVrOGiI64A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ1MDkxMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    assertThat(resultMap.get(root) == expectedResult.get(root)).isFalse();\n          \n          \n            \n                    assertThat(resultMap.get(root)).isNotSameAs(expectedResult.get(root));", "url": "https://github.com/ConsenSys/teku/pull/2117#discussion_r438450912", "createdAt": "2020-06-10T22:54:39Z", "author": {"login": "ajsutton"}, "path": "ethereum/core/src/test/java/tech/pegasys/teku/core/StateGeneratorTest.java", "diffHunk": "@@ -215,7 +230,19 @@ private void testRegenerateAllStates(\n     assertThat(resultMap.size()).isEqualTo(results.size());\n     // Check that our expectations are met\n     assertThat(resultMap.size()).isEqualTo(expectedResult.size());\n-    assertThat(resultMap).isEqualToComparingFieldByField(expectedResult);\n+    assertThat(resultMap).containsExactlyInAnyOrderEntriesOf(expectedResult);\n+    // Check states were / were not regenerated as expected\n+    if (supplyAllKnownStates) {\n+      // No states should be regenerated - they should all match the known state\n+      for (Bytes32 root : expectedResult.keySet()) {\n+        assertThat(resultMap.get(root) == expectedResult.get(root)).isTrue();\n+      }\n+    } else if (cacheSize == 0) {\n+      // All states should be regenerated and should not match the known states\n+      for (Bytes32 root : expectedResult.keySet()) {\n+        assertThat(resultMap.get(root) == expectedResult.get(root)).isFalse();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "744022beaa59995c0d4815ebbb07c8ccddd6faea"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMTM5Nzg5OnYy", "diffSide": "RIGHT", "path": "storage/src/main/java/tech/pegasys/teku/storage/store/StoreTransactionUpdates.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMjo1OTowNVrOGiJAZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMjo1OTowNVrOGiJAZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ1MjMyNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                final HashMap<Bytes32, BeaconState> states = new HashMap<>();\n          \n          \n            \n                final Map<Bytes32, BeaconState> states = new HashMap<>();", "url": "https://github.com/ConsenSys/teku/pull/2117#discussion_r438452326", "createdAt": "2020-06-10T22:59:05Z", "author": {"login": "ajsutton"}, "path": "storage/src/main/java/tech/pegasys/teku/storage/store/StoreTransactionUpdates.java", "diffHunk": "@@ -149,17 +154,18 @@ public static StoreTransactionUpdates calculate(final Store baseStore, final Tra\n       throw new IllegalStateException(\"Unable to retrieve all finalized blocks\");\n     }\n \n-    // Collect states in order and return finalized chain data map\n-    // State collection is done separately to avoid repeatedly regenerating state by processing\n-    // states in reverse-order.  See: Store.getOrGenerateBlockState\n-    Collections.reverse(blocks);\n-    return blocks.stream()\n-        .map(\n-            block -> {\n-              final BeaconState state = tx.getBlockState(block.getRoot());\n-              return new SignedBlockAndState(block, state);\n-            })\n-        .collect(Collectors.toMap(SignedBlockAndState::getRoot, Function.identity()));\n+    return blocks;\n+  }\n+\n+  private static Map<Bytes32, BeaconState> collectFinalizedStates(\n+      final Store.Transaction tx, final Set<SignedBeaconBlock> finalizedBlocks) {\n+    final HashMap<Bytes32, BeaconState> states = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "744022beaa59995c0d4815ebbb07c8ccddd6faea"}, "originalPosition": 153}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3573, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}