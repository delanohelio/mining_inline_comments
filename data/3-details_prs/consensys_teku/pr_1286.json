{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg0MDIyMzg4", "number": 1286, "title": "#1178 update validator generate subcommand to create encrypted BLS keystore", "bodyText": "PR Description\nUpdate teku validator generate subcommand to generate encrypted keystore .\nNew cli options (as it appears in teku validator generate --help):\n<snip>\n-e, --encrypted-keystore-enabled=<true|false>\n                            Create encrypted keystores for validator and\n                              withdrawal keys. (Default: true)\n<snip>\n Non-interactive password options for validator keystores:\n      --validator-keystore-password-env=<ENV_VAR>\n                            Read password from environment variable to encrypt\n                              the validator keys\n      --validator-keystore-password-file=<FILE>\n                            Read password from the file to encrypt the\n                              validator keys\nNon-interactive password options for withdrawal keystores:\n      --withdrawal-keystore-password-env=<ENV_VAR>\n                            Read password from environment variable to encrypt\n                              the withdrawal keys\n      --withdrawal-keystore-password-file=<FILE>\n                            Read password from the file to encrypt the\n                              withdrawal keys", "createdAt": "2020-03-05T01:49:17Z", "url": "https://github.com/ConsenSys/teku/pull/1286", "merged": true, "mergeCommit": {"oid": "6a9481c9aac9802c4b515ebd4e15233a925154c8"}, "closed": true, "closedAt": "2020-03-12T02:18:33Z", "author": {"login": "usmansaleem"}, "timelineItems": {"totalCount": 39, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcKg2zmgH2gAyMzg0MDIyMzg4OjkxNDMxN2Y4MmFjOTkzMWQyODRiNDJjZWExNzUzYTYxN2UwYjk1MGE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcMx73vgH2gAyMzg0MDIyMzg4OjE0ZmY4NTI1MGMwNWQwMmZjNGJlMzQ5ZGM1Y2E5NDk2MTgyODdmMTc=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "914317f82ac9931d284b42cea1753a617e0b950a", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/914317f82ac9931d284b42cea1753a617e0b950a", "committedDate": "2020-03-05T01:02:09Z", "message": "#1178 Generate encrypted keystore from validate generate subcommand\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "803201c2c4b68aa49efb85fb75cc842327e4e2a7", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/803201c2c4b68aa49efb85fb75cc842327e4e2a7", "committedDate": "2020-03-05T01:16:44Z", "message": "cli param labels\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dbdfe0b62b203c0f3743d2e2d892180d1e97a015", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/dbdfe0b62b203c0f3743d2e2d892180d1e97a015", "committedDate": "2020-03-05T01:45:54Z", "message": "Merge remote-tracking branch 'upstream/master' into 1178_validator_generate_keystore\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3c8c4c185f1126c2991df47457e204a7073abd85", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/3c8c4c185f1126c2991df47457e204a7073abd85", "committedDate": "2020-03-05T05:16:36Z", "message": "Merge remote-tracking branch 'upstream/master' into 1178_validator_generate_keystore\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b7638623ccc0ef0ef0a428b7e4069a475a5994a2", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/b7638623ccc0ef0ef0a428b7e4069a475a5994a2", "committedDate": "2020-03-05T07:59:14Z", "message": "Add unit test case\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "05541e5f9cc81589e76819dbe9b91a4392c3992f", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/05541e5f9cc81589e76819dbe9b91a4392c3992f", "committedDate": "2020-03-05T08:00:10Z", "message": "Merge remote-tracking branch 'upstream/master' into 1178_validator_generate_keystore\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "97487d6d035ddfef60029d3ebd7a92cc798fcb28", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/97487d6d035ddfef60029d3ebd7a92cc798fcb28", "committedDate": "2020-03-05T08:04:27Z", "message": "update cli text\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/a967bf290bf0c284504f81b75ec5bb3299f0c6a0", "committedDate": "2020-03-05T08:07:54Z", "message": "add line seperator in yaml line\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5OTU3ODM2", "url": "https://github.com/ConsenSys/teku/pull/1286#pullrequestreview-369957836", "createdAt": "2020-03-05T22:22:35Z", "commit": {"oid": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMjoyMjozNVrOFymYRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMjoyMjozNVrOFymYRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYwMTkyNw==", "bodyText": "has the web3j problem been solved?", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388601927", "createdAt": "2020-03-05T22:22:35Z", "author": {"login": "macfarla"}, "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "diffHunk": "@@ -81,44 +99,144 @@ public void generate(\n           int validatorCount,\n       @Option(\n               names = {\"--output-file\", \"-o\"},\n+              paramLabel = \"<FILE>\",\n               description =\n-                  \"File to write validator keys to. Keys are printed to std out if not specified\")\n-          String outputFile) {\n+                  \"File to write unencrypted validator keys to. Keys are printed to std out if not specified\")\n+          String outputFile,\n+      @Option(\n+              names = {\"--encrypt-keys\", \"-e\"},\n+              defaultValue = \"false\",\n+              paramLabel = \"<TRUE|FALSE>\",\n+              description = \"Encrypt validator keys. (Default: false)\",\n+              arity = \"1\")\n+          boolean encryptKeys,\n+      @Option(\n+              names = {\"--keystore-output-dir\", \"-k\"},\n+              paramLabel = \"<PATH>\",\n+              description =\n+                  \"Encrypted keystore output directory. Use current directory if not specified\")\n+          String keystorePath) {\n+\n     try (params) {\n+      // generate BLS validator key and withdrawal key\n+      final List<Pair<BLSKeyPair, BLSKeyPair>> validatorKeyPairs =\n+          IntStream.range(0, validatorCount)\n+              .mapToObj(value -> Pair.of(BLSKeyPair.random(), BLSKeyPair.random()))\n+              .collect(Collectors.toList());\n+\n       final DepositTransactionSender sender = params.createTransactionSender();\n-      final List<SafeFuture<TransactionReceipt>> futures = new ArrayList<>();\n \n-      final PrintStream keyWriter;\n-      if (outputFile == null || outputFile.isBlank()) {\n-        keyWriter = System.out;\n-      } else {\n-        keyWriter = new PrintStream(new FileOutputStream(outputFile), true, StandardCharsets.UTF_8);\n-      }\n+      final StringBuilder yamlStringBuilder = new StringBuilder();\n+      final boolean printOnStandardOut = outputFile == null || outputFile.isBlank();\n+      final Path keyStoreOutputDirectory =\n+          keystorePath == null || keystorePath.isBlank() ? Path.of(\".\") : Path.of(keystorePath);\n+      final AtomicInteger counterSuffix = new AtomicInteger(0);\n+      final List<SafeFuture<TransactionReceipt>> futures;\n+      try {\n+        futures =\n+            validatorKeyPairs.stream()\n+                .map(\n+                    keyPair -> {\n+                      final String yamlFormattedString = getYamlFormattedString(keyPair);\n+                      if (encryptKeys) {\n+                        generateKeystores(\n+                            keyPair, keyStoreOutputDirectory, counterSuffix.incrementAndGet());\n+                      } else if (printOnStandardOut) {\n+                        System.out.println(yamlFormattedString);\n+                      } else {\n+                        yamlStringBuilder\n+                            .append(yamlFormattedString)\n+                            .append(System.lineSeparator());\n+                      }\n+\n+                      return sendDeposit(\n+                          sender,\n+                          keyPair.getLeft(),\n+                          keyPair.getRight().getPublicKey(),\n+                          params.amount);\n+                    })\n+                .collect(Collectors.toList());\n \n-      try (keyWriter) {\n-        for (int i = 0; i < validatorCount; i++) {\n-          final BLSKeyPair validatorKey = BLSKeyPair.random();\n-          final BLSKeyPair withdrawalKey = BLSKeyPair.random();\n-\n-          keyWriter.println(\n-              String.format(\n-                  \"- {privkey: '%s', pubkey: '%s', withdrawalPrivkey: '%s', withdrawalPubkey: '%s'}\",\n-                  validatorKey.getSecretKey().getSecretKey().toBytes(),\n-                  validatorKey.getPublicKey().toBytesCompressed(),\n-                  withdrawalKey.getSecretKey().getSecretKey().toBytes(),\n-                  withdrawalKey.getPublicKey().toBytesCompressed()));\n-          futures.add(\n-              sendDeposit(sender, validatorKey, withdrawalKey.getPublicKey(), params.amount));\n+      } finally {\n+        if (!encryptKeys && !printOnStandardOut) {\n+          // write keys yaml to file\n+          Files.writeString(Path.of(outputFile), yamlStringBuilder.toString());\n         }\n       }\n-      SafeFuture.allOf(futures.toArray(SafeFuture[]::new)).get(2, TimeUnit.MINUTES);\n+\n+      waitForTransactionReceipts(futures);\n     } catch (final Throwable t) {\n       STDOUT.log(\n           Level.FATAL,\n           \"Failed to send deposit transaction: \" + t.getClass() + \": \" + t.getMessage());\n-      System.exit(1); // Web3J creates a non-daemon thread we can't shut down. :(\n+      exit(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0"}, "originalPosition": 155}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwMDAwNjI2", "url": "https://github.com/ConsenSys/teku/pull/1286#pullrequestreview-370000626", "createdAt": "2020-03-06T00:11:26Z", "commit": {"oid": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwMDoxMToyNlrOFyokCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwMDozMToxMFrOFyo9pg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYzNzcwNQ==", "bodyText": "False doesn't seem like the right default here.  Writing unencrypted keys to disk is a really bad idea.", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388637705", "createdAt": "2020-03-06T00:11:26Z", "author": {"login": "ajsutton"}, "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "diffHunk": "@@ -81,44 +99,144 @@ public void generate(\n           int validatorCount,\n       @Option(\n               names = {\"--output-file\", \"-o\"},\n+              paramLabel = \"<FILE>\",\n               description =\n-                  \"File to write validator keys to. Keys are printed to std out if not specified\")\n-          String outputFile) {\n+                  \"File to write unencrypted validator keys to. Keys are printed to std out if not specified\")\n+          String outputFile,\n+      @Option(\n+              names = {\"--encrypt-keys\", \"-e\"},\n+              defaultValue = \"false\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYzODE2MA==", "bodyText": "How does this relate to --output-file?  Seems kind of confusing to have two separate options to specify where to output things.  @jakehaugen any ideas on the right CLI options for this?", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388638160", "createdAt": "2020-03-06T00:12:55Z", "author": {"login": "ajsutton"}, "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "diffHunk": "@@ -81,44 +99,144 @@ public void generate(\n           int validatorCount,\n       @Option(\n               names = {\"--output-file\", \"-o\"},\n+              paramLabel = \"<FILE>\",\n               description =\n-                  \"File to write validator keys to. Keys are printed to std out if not specified\")\n-          String outputFile) {\n+                  \"File to write unencrypted validator keys to. Keys are printed to std out if not specified\")\n+          String outputFile,\n+      @Option(\n+              names = {\"--encrypt-keys\", \"-e\"},\n+              defaultValue = \"false\",\n+              paramLabel = \"<TRUE|FALSE>\",\n+              description = \"Encrypt validator keys. (Default: false)\",\n+              arity = \"1\")\n+          boolean encryptKeys,\n+      @Option(\n+              names = {\"--keystore-output-dir\", \"-k\"},\n+              paramLabel = \"<PATH>\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYzODg3NQ==", "bodyText": "Rather than overriding this method in tests, it would be better to pass in a Consumer<Integer> shutdownFunction to the constructor (ie prefer delegation over inheritance).  You can pass a mock in tests and System::exit in production.\nYou will likely need two constructors for DepositCommand - a noarg one that passes System::exit and one that accepts the consumer that tests can use.", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388638875", "createdAt": "2020-03-06T00:15:24Z", "author": {"login": "ajsutton"}, "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "diffHunk": "@@ -81,44 +99,144 @@ public void generate(\n           int validatorCount,\n       @Option(\n               names = {\"--output-file\", \"-o\"},\n+              paramLabel = \"<FILE>\",\n               description =\n-                  \"File to write validator keys to. Keys are printed to std out if not specified\")\n-          String outputFile) {\n+                  \"File to write unencrypted validator keys to. Keys are printed to std out if not specified\")\n+          String outputFile,\n+      @Option(\n+              names = {\"--encrypt-keys\", \"-e\"},\n+              defaultValue = \"false\",\n+              paramLabel = \"<TRUE|FALSE>\",\n+              description = \"Encrypt validator keys. (Default: false)\",\n+              arity = \"1\")\n+          boolean encryptKeys,\n+      @Option(\n+              names = {\"--keystore-output-dir\", \"-k\"},\n+              paramLabel = \"<PATH>\",\n+              description =\n+                  \"Encrypted keystore output directory. Use current directory if not specified\")\n+          String keystorePath) {\n+\n     try (params) {\n+      // generate BLS validator key and withdrawal key\n+      final List<Pair<BLSKeyPair, BLSKeyPair>> validatorKeyPairs =\n+          IntStream.range(0, validatorCount)\n+              .mapToObj(value -> Pair.of(BLSKeyPair.random(), BLSKeyPair.random()))\n+              .collect(Collectors.toList());\n+\n       final DepositTransactionSender sender = params.createTransactionSender();\n-      final List<SafeFuture<TransactionReceipt>> futures = new ArrayList<>();\n \n-      final PrintStream keyWriter;\n-      if (outputFile == null || outputFile.isBlank()) {\n-        keyWriter = System.out;\n-      } else {\n-        keyWriter = new PrintStream(new FileOutputStream(outputFile), true, StandardCharsets.UTF_8);\n-      }\n+      final StringBuilder yamlStringBuilder = new StringBuilder();\n+      final boolean printOnStandardOut = outputFile == null || outputFile.isBlank();\n+      final Path keyStoreOutputDirectory =\n+          keystorePath == null || keystorePath.isBlank() ? Path.of(\".\") : Path.of(keystorePath);\n+      final AtomicInteger counterSuffix = new AtomicInteger(0);\n+      final List<SafeFuture<TransactionReceipt>> futures;\n+      try {\n+        futures =\n+            validatorKeyPairs.stream()\n+                .map(\n+                    keyPair -> {\n+                      final String yamlFormattedString = getYamlFormattedString(keyPair);\n+                      if (encryptKeys) {\n+                        generateKeystores(\n+                            keyPair, keyStoreOutputDirectory, counterSuffix.incrementAndGet());\n+                      } else if (printOnStandardOut) {\n+                        System.out.println(yamlFormattedString);\n+                      } else {\n+                        yamlStringBuilder\n+                            .append(yamlFormattedString)\n+                            .append(System.lineSeparator());\n+                      }\n+\n+                      return sendDeposit(\n+                          sender,\n+                          keyPair.getLeft(),\n+                          keyPair.getRight().getPublicKey(),\n+                          params.amount);\n+                    })\n+                .collect(Collectors.toList());\n \n-      try (keyWriter) {\n-        for (int i = 0; i < validatorCount; i++) {\n-          final BLSKeyPair validatorKey = BLSKeyPair.random();\n-          final BLSKeyPair withdrawalKey = BLSKeyPair.random();\n-\n-          keyWriter.println(\n-              String.format(\n-                  \"- {privkey: '%s', pubkey: '%s', withdrawalPrivkey: '%s', withdrawalPubkey: '%s'}\",\n-                  validatorKey.getSecretKey().getSecretKey().toBytes(),\n-                  validatorKey.getPublicKey().toBytesCompressed(),\n-                  withdrawalKey.getSecretKey().getSecretKey().toBytes(),\n-                  withdrawalKey.getPublicKey().toBytesCompressed()));\n-          futures.add(\n-              sendDeposit(sender, validatorKey, withdrawalKey.getPublicKey(), params.amount));\n+      } finally {\n+        if (!encryptKeys && !printOnStandardOut) {\n+          // write keys yaml to file\n+          Files.writeString(Path.of(outputFile), yamlStringBuilder.toString());\n         }\n       }\n-      SafeFuture.allOf(futures.toArray(SafeFuture[]::new)).get(2, TimeUnit.MINUTES);\n+\n+      waitForTransactionReceipts(futures);\n     } catch (final Throwable t) {\n       STDOUT.log(\n           Level.FATAL,\n           \"Failed to send deposit transaction: \" + t.getClass() + \": \" + t.getMessage());\n-      System.exit(1); // Web3J creates a non-daemon thread we can't shut down. :(\n+      exit(1);\n     }\n-    System.exit(0); // Web3J creates a non-daemon thread we can't shut down. :(\n+    exit(0);\n+  }\n+\n+  @VisibleForTesting\n+  void waitForTransactionReceipts(final List<SafeFuture<TransactionReceipt>> futures)\n+      throws InterruptedException, ExecutionException, TimeoutException {\n+    SafeFuture.allOf(futures.toArray(SafeFuture[]::new)).get(2, TimeUnit.MINUTES);\n+  }\n+\n+  @VisibleForTesting\n+  void exit(final int status) {\n+    System.exit(status); // Web3J creates a non-daemon thread we can't shut down. :(\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0"}, "originalPosition": 170}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYzOTg3NQ==", "bodyText": "Two issues here:\n\nIt's vital that we write the keys to output before sending the deposit transaction.  Otherwise if we fail somewhere we've just burned a lot of ETH and lost the keys forever.\nSince the logic for writing keys has become more complex we should create a KeyWriter interface with 2 separate implementations - one that writes YAML to a PrintStream (used for all unencrypted output) and one that writes to a keystore for encrypted output.", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388639875", "createdAt": "2020-03-06T00:18:35Z", "author": {"login": "ajsutton"}, "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "diffHunk": "@@ -81,44 +99,144 @@ public void generate(\n           int validatorCount,\n       @Option(\n               names = {\"--output-file\", \"-o\"},\n+              paramLabel = \"<FILE>\",\n               description =\n-                  \"File to write validator keys to. Keys are printed to std out if not specified\")\n-          String outputFile) {\n+                  \"File to write unencrypted validator keys to. Keys are printed to std out if not specified\")\n+          String outputFile,\n+      @Option(\n+              names = {\"--encrypt-keys\", \"-e\"},\n+              defaultValue = \"false\",\n+              paramLabel = \"<TRUE|FALSE>\",\n+              description = \"Encrypt validator keys. (Default: false)\",\n+              arity = \"1\")\n+          boolean encryptKeys,\n+      @Option(\n+              names = {\"--keystore-output-dir\", \"-k\"},\n+              paramLabel = \"<PATH>\",\n+              description =\n+                  \"Encrypted keystore output directory. Use current directory if not specified\")\n+          String keystorePath) {\n+\n     try (params) {\n+      // generate BLS validator key and withdrawal key\n+      final List<Pair<BLSKeyPair, BLSKeyPair>> validatorKeyPairs =\n+          IntStream.range(0, validatorCount)\n+              .mapToObj(value -> Pair.of(BLSKeyPair.random(), BLSKeyPair.random()))\n+              .collect(Collectors.toList());\n+\n       final DepositTransactionSender sender = params.createTransactionSender();\n-      final List<SafeFuture<TransactionReceipt>> futures = new ArrayList<>();\n \n-      final PrintStream keyWriter;\n-      if (outputFile == null || outputFile.isBlank()) {\n-        keyWriter = System.out;\n-      } else {\n-        keyWriter = new PrintStream(new FileOutputStream(outputFile), true, StandardCharsets.UTF_8);\n-      }\n+      final StringBuilder yamlStringBuilder = new StringBuilder();\n+      final boolean printOnStandardOut = outputFile == null || outputFile.isBlank();\n+      final Path keyStoreOutputDirectory =\n+          keystorePath == null || keystorePath.isBlank() ? Path.of(\".\") : Path.of(keystorePath);\n+      final AtomicInteger counterSuffix = new AtomicInteger(0);\n+      final List<SafeFuture<TransactionReceipt>> futures;\n+      try {\n+        futures =\n+            validatorKeyPairs.stream()\n+                .map(\n+                    keyPair -> {\n+                      final String yamlFormattedString = getYamlFormattedString(keyPair);\n+                      if (encryptKeys) {\n+                        generateKeystores(\n+                            keyPair, keyStoreOutputDirectory, counterSuffix.incrementAndGet());\n+                      } else if (printOnStandardOut) {\n+                        System.out.println(yamlFormattedString);\n+                      } else {\n+                        yamlStringBuilder\n+                            .append(yamlFormattedString)\n+                            .append(System.lineSeparator());\n+                      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0MDk5OA==", "bodyText": "We should have a way to specify the password to use for keystrokes.  No point writing an encrypted keystore if you write an unencrypted password for it as well.  It's probably enough to be able to specify a password for all signing keys and a (potentially different) password for all withdrawal keys.", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388640998", "createdAt": "2020-03-06T00:22:11Z", "author": {"login": "ajsutton"}, "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "diffHunk": "@@ -81,44 +99,144 @@ public void generate(\n           int validatorCount,\n       @Option(\n               names = {\"--output-file\", \"-o\"},\n+              paramLabel = \"<FILE>\",\n               description =\n-                  \"File to write validator keys to. Keys are printed to std out if not specified\")\n-          String outputFile) {\n+                  \"File to write unencrypted validator keys to. Keys are printed to std out if not specified\")\n+          String outputFile,\n+      @Option(\n+              names = {\"--encrypt-keys\", \"-e\"},\n+              defaultValue = \"false\",\n+              paramLabel = \"<TRUE|FALSE>\",\n+              description = \"Encrypt validator keys. (Default: false)\",\n+              arity = \"1\")\n+          boolean encryptKeys,\n+      @Option(\n+              names = {\"--keystore-output-dir\", \"-k\"},\n+              paramLabel = \"<PATH>\",\n+              description =\n+                  \"Encrypted keystore output directory. Use current directory if not specified\")\n+          String keystorePath) {\n+\n     try (params) {\n+      // generate BLS validator key and withdrawal key\n+      final List<Pair<BLSKeyPair, BLSKeyPair>> validatorKeyPairs =\n+          IntStream.range(0, validatorCount)\n+              .mapToObj(value -> Pair.of(BLSKeyPair.random(), BLSKeyPair.random()))\n+              .collect(Collectors.toList());\n+\n       final DepositTransactionSender sender = params.createTransactionSender();\n-      final List<SafeFuture<TransactionReceipt>> futures = new ArrayList<>();\n \n-      final PrintStream keyWriter;\n-      if (outputFile == null || outputFile.isBlank()) {\n-        keyWriter = System.out;\n-      } else {\n-        keyWriter = new PrintStream(new FileOutputStream(outputFile), true, StandardCharsets.UTF_8);\n-      }\n+      final StringBuilder yamlStringBuilder = new StringBuilder();\n+      final boolean printOnStandardOut = outputFile == null || outputFile.isBlank();\n+      final Path keyStoreOutputDirectory =\n+          keystorePath == null || keystorePath.isBlank() ? Path.of(\".\") : Path.of(keystorePath);\n+      final AtomicInteger counterSuffix = new AtomicInteger(0);\n+      final List<SafeFuture<TransactionReceipt>> futures;\n+      try {\n+        futures =\n+            validatorKeyPairs.stream()\n+                .map(\n+                    keyPair -> {\n+                      final String yamlFormattedString = getYamlFormattedString(keyPair);\n+                      if (encryptKeys) {\n+                        generateKeystores(\n+                            keyPair, keyStoreOutputDirectory, counterSuffix.incrementAndGet());\n+                      } else if (printOnStandardOut) {\n+                        System.out.println(yamlFormattedString);\n+                      } else {\n+                        yamlStringBuilder\n+                            .append(yamlFormattedString)\n+                            .append(System.lineSeparator());\n+                      }\n+\n+                      return sendDeposit(\n+                          sender,\n+                          keyPair.getLeft(),\n+                          keyPair.getRight().getPublicKey(),\n+                          params.amount);\n+                    })\n+                .collect(Collectors.toList());\n \n-      try (keyWriter) {\n-        for (int i = 0; i < validatorCount; i++) {\n-          final BLSKeyPair validatorKey = BLSKeyPair.random();\n-          final BLSKeyPair withdrawalKey = BLSKeyPair.random();\n-\n-          keyWriter.println(\n-              String.format(\n-                  \"- {privkey: '%s', pubkey: '%s', withdrawalPrivkey: '%s', withdrawalPubkey: '%s'}\",\n-                  validatorKey.getSecretKey().getSecretKey().toBytes(),\n-                  validatorKey.getPublicKey().toBytesCompressed(),\n-                  withdrawalKey.getSecretKey().getSecretKey().toBytes(),\n-                  withdrawalKey.getPublicKey().toBytesCompressed()));\n-          futures.add(\n-              sendDeposit(sender, validatorKey, withdrawalKey.getPublicKey(), params.amount));\n+      } finally {\n+        if (!encryptKeys && !printOnStandardOut) {\n+          // write keys yaml to file\n+          Files.writeString(Path.of(outputFile), yamlStringBuilder.toString());\n         }\n       }\n-      SafeFuture.allOf(futures.toArray(SafeFuture[]::new)).get(2, TimeUnit.MINUTES);\n+\n+      waitForTransactionReceipts(futures);\n     } catch (final Throwable t) {\n       STDOUT.log(\n           Level.FATAL,\n           \"Failed to send deposit transaction: \" + t.getClass() + \": \" + t.getMessage());\n-      System.exit(1); // Web3J creates a non-daemon thread we can't shut down. :(\n+      exit(1);\n     }\n-    System.exit(0); // Web3J creates a non-daemon thread we can't shut down. :(\n+    exit(0);\n+  }\n+\n+  @VisibleForTesting\n+  void waitForTransactionReceipts(final List<SafeFuture<TransactionReceipt>> futures)\n+      throws InterruptedException, ExecutionException, TimeoutException {\n+    SafeFuture.allOf(futures.toArray(SafeFuture[]::new)).get(2, TimeUnit.MINUTES);\n+  }\n+\n+  @VisibleForTesting\n+  void exit(final int status) {\n+    System.exit(status); // Web3J creates a non-daemon thread we can't shut down. :(\n+  }\n+\n+  private String getYamlFormattedString(final Pair<BLSKeyPair, BLSKeyPair> keyPair) {\n+    return String.format(\n+        \"- {privkey: '%s', pubkey: '%s', withdrawalPrivkey: '%s', withdrawalPubkey: '%s'}\",\n+        keyPair.getLeft().getSecretKey().getSecretKey().toBytes(),\n+        keyPair.getLeft().getPublicKey().toBytesCompressed(),\n+        keyPair.getRight().getSecretKey().getSecretKey().toBytes(),\n+        keyPair.getRight().getPublicKey().toBytesCompressed());\n+  }\n+\n+  private void generateKeystores(\n+      final Pair<BLSKeyPair, BLSKeyPair> keyPair,\n+      final Path keyStoreOutputDirectory,\n+      final int counter) {\n+    generateKeystore(keyPair.getLeft(), keyStoreOutputDirectory, \"validator\", counter);\n+    generateKeystore(keyPair.getRight(), keyStoreOutputDirectory, \"withdrawal\", counter);\n+  }\n+\n+  private void generateKeystore(\n+      final BLSKeyPair key, final Path outputDir, final String prefix, final int counter) {\n+    try {\n+      final KdfParam kdfParam = new SCryptParam(32, Bytes32.random());\n+      final Cipher cipher = new Cipher(CipherFunction.AES_128_CTR, Bytes.random(16));\n+      final String randomPassword = generateRandomHexToken();\n+      final KeyStoreData keyStoreData =\n+          KeyStore.encrypt(\n+              key.getSecretKey().getSecretKey().toBytes(),\n+              generateRandomHexToken(),\n+              \"\",\n+              kdfParam,\n+              cipher);\n+\n+      // create sub directory\n+      final Path keystoreDirectory =\n+          Files.createDirectories(outputDir.resolve(\"validator_\" + counter));\n+\n+      // save keystore\n+      KeyStoreLoader.saveToFile(\n+          keystoreDirectory.resolve(prefix + \"_keystore_\" + counter + \".json\"), keyStoreData);\n+\n+      // save password\n+      Files.writeString(\n+          keystoreDirectory.resolve(prefix + \"_password_\" + counter + \".txt\"), randomPassword);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0"}, "originalPosition": 213}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0MTEzOQ==", "bodyText": "Web3j remains problematic unfortunately.", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388641139", "createdAt": "2020-03-06T00:22:41Z", "author": {"login": "ajsutton"}, "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "diffHunk": "@@ -81,44 +99,144 @@ public void generate(\n           int validatorCount,\n       @Option(\n               names = {\"--output-file\", \"-o\"},\n+              paramLabel = \"<FILE>\",\n               description =\n-                  \"File to write validator keys to. Keys are printed to std out if not specified\")\n-          String outputFile) {\n+                  \"File to write unencrypted validator keys to. Keys are printed to std out if not specified\")\n+          String outputFile,\n+      @Option(\n+              names = {\"--encrypt-keys\", \"-e\"},\n+              defaultValue = \"false\",\n+              paramLabel = \"<TRUE|FALSE>\",\n+              description = \"Encrypt validator keys. (Default: false)\",\n+              arity = \"1\")\n+          boolean encryptKeys,\n+      @Option(\n+              names = {\"--keystore-output-dir\", \"-k\"},\n+              paramLabel = \"<PATH>\",\n+              description =\n+                  \"Encrypted keystore output directory. Use current directory if not specified\")\n+          String keystorePath) {\n+\n     try (params) {\n+      // generate BLS validator key and withdrawal key\n+      final List<Pair<BLSKeyPair, BLSKeyPair>> validatorKeyPairs =\n+          IntStream.range(0, validatorCount)\n+              .mapToObj(value -> Pair.of(BLSKeyPair.random(), BLSKeyPair.random()))\n+              .collect(Collectors.toList());\n+\n       final DepositTransactionSender sender = params.createTransactionSender();\n-      final List<SafeFuture<TransactionReceipt>> futures = new ArrayList<>();\n \n-      final PrintStream keyWriter;\n-      if (outputFile == null || outputFile.isBlank()) {\n-        keyWriter = System.out;\n-      } else {\n-        keyWriter = new PrintStream(new FileOutputStream(outputFile), true, StandardCharsets.UTF_8);\n-      }\n+      final StringBuilder yamlStringBuilder = new StringBuilder();\n+      final boolean printOnStandardOut = outputFile == null || outputFile.isBlank();\n+      final Path keyStoreOutputDirectory =\n+          keystorePath == null || keystorePath.isBlank() ? Path.of(\".\") : Path.of(keystorePath);\n+      final AtomicInteger counterSuffix = new AtomicInteger(0);\n+      final List<SafeFuture<TransactionReceipt>> futures;\n+      try {\n+        futures =\n+            validatorKeyPairs.stream()\n+                .map(\n+                    keyPair -> {\n+                      final String yamlFormattedString = getYamlFormattedString(keyPair);\n+                      if (encryptKeys) {\n+                        generateKeystores(\n+                            keyPair, keyStoreOutputDirectory, counterSuffix.incrementAndGet());\n+                      } else if (printOnStandardOut) {\n+                        System.out.println(yamlFormattedString);\n+                      } else {\n+                        yamlStringBuilder\n+                            .append(yamlFormattedString)\n+                            .append(System.lineSeparator());\n+                      }\n+\n+                      return sendDeposit(\n+                          sender,\n+                          keyPair.getLeft(),\n+                          keyPair.getRight().getPublicKey(),\n+                          params.amount);\n+                    })\n+                .collect(Collectors.toList());\n \n-      try (keyWriter) {\n-        for (int i = 0; i < validatorCount; i++) {\n-          final BLSKeyPair validatorKey = BLSKeyPair.random();\n-          final BLSKeyPair withdrawalKey = BLSKeyPair.random();\n-\n-          keyWriter.println(\n-              String.format(\n-                  \"- {privkey: '%s', pubkey: '%s', withdrawalPrivkey: '%s', withdrawalPubkey: '%s'}\",\n-                  validatorKey.getSecretKey().getSecretKey().toBytes(),\n-                  validatorKey.getPublicKey().toBytesCompressed(),\n-                  withdrawalKey.getSecretKey().getSecretKey().toBytes(),\n-                  withdrawalKey.getPublicKey().toBytesCompressed()));\n-          futures.add(\n-              sendDeposit(sender, validatorKey, withdrawalKey.getPublicKey(), params.amount));\n+      } finally {\n+        if (!encryptKeys && !printOnStandardOut) {\n+          // write keys yaml to file\n+          Files.writeString(Path.of(outputFile), yamlStringBuilder.toString());\n         }\n       }\n-      SafeFuture.allOf(futures.toArray(SafeFuture[]::new)).get(2, TimeUnit.MINUTES);\n+\n+      waitForTransactionReceipts(futures);\n     } catch (final Throwable t) {\n       STDOUT.log(\n           Level.FATAL,\n           \"Failed to send deposit transaction: \" + t.getClass() + \": \" + t.getMessage());\n-      System.exit(1); // Web3J creates a non-daemon thread we can't shut down. :(\n+      exit(1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYwMTkyNw=="}, "originalCommit": {"oid": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0MTM2MA==", "bodyText": "It would be much better to use:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                return new BigInteger(1, token).toString(16); // hex encoding\n          \n          \n            \n                return Bytes.wrap(token).toHexString()", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388641360", "createdAt": "2020-03-06T00:23:25Z", "author": {"login": "ajsutton"}, "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "diffHunk": "@@ -81,44 +99,144 @@ public void generate(\n           int validatorCount,\n       @Option(\n               names = {\"--output-file\", \"-o\"},\n+              paramLabel = \"<FILE>\",\n               description =\n-                  \"File to write validator keys to. Keys are printed to std out if not specified\")\n-          String outputFile) {\n+                  \"File to write unencrypted validator keys to. Keys are printed to std out if not specified\")\n+          String outputFile,\n+      @Option(\n+              names = {\"--encrypt-keys\", \"-e\"},\n+              defaultValue = \"false\",\n+              paramLabel = \"<TRUE|FALSE>\",\n+              description = \"Encrypt validator keys. (Default: false)\",\n+              arity = \"1\")\n+          boolean encryptKeys,\n+      @Option(\n+              names = {\"--keystore-output-dir\", \"-k\"},\n+              paramLabel = \"<PATH>\",\n+              description =\n+                  \"Encrypted keystore output directory. Use current directory if not specified\")\n+          String keystorePath) {\n+\n     try (params) {\n+      // generate BLS validator key and withdrawal key\n+      final List<Pair<BLSKeyPair, BLSKeyPair>> validatorKeyPairs =\n+          IntStream.range(0, validatorCount)\n+              .mapToObj(value -> Pair.of(BLSKeyPair.random(), BLSKeyPair.random()))\n+              .collect(Collectors.toList());\n+\n       final DepositTransactionSender sender = params.createTransactionSender();\n-      final List<SafeFuture<TransactionReceipt>> futures = new ArrayList<>();\n \n-      final PrintStream keyWriter;\n-      if (outputFile == null || outputFile.isBlank()) {\n-        keyWriter = System.out;\n-      } else {\n-        keyWriter = new PrintStream(new FileOutputStream(outputFile), true, StandardCharsets.UTF_8);\n-      }\n+      final StringBuilder yamlStringBuilder = new StringBuilder();\n+      final boolean printOnStandardOut = outputFile == null || outputFile.isBlank();\n+      final Path keyStoreOutputDirectory =\n+          keystorePath == null || keystorePath.isBlank() ? Path.of(\".\") : Path.of(keystorePath);\n+      final AtomicInteger counterSuffix = new AtomicInteger(0);\n+      final List<SafeFuture<TransactionReceipt>> futures;\n+      try {\n+        futures =\n+            validatorKeyPairs.stream()\n+                .map(\n+                    keyPair -> {\n+                      final String yamlFormattedString = getYamlFormattedString(keyPair);\n+                      if (encryptKeys) {\n+                        generateKeystores(\n+                            keyPair, keyStoreOutputDirectory, counterSuffix.incrementAndGet());\n+                      } else if (printOnStandardOut) {\n+                        System.out.println(yamlFormattedString);\n+                      } else {\n+                        yamlStringBuilder\n+                            .append(yamlFormattedString)\n+                            .append(System.lineSeparator());\n+                      }\n+\n+                      return sendDeposit(\n+                          sender,\n+                          keyPair.getLeft(),\n+                          keyPair.getRight().getPublicKey(),\n+                          params.amount);\n+                    })\n+                .collect(Collectors.toList());\n \n-      try (keyWriter) {\n-        for (int i = 0; i < validatorCount; i++) {\n-          final BLSKeyPair validatorKey = BLSKeyPair.random();\n-          final BLSKeyPair withdrawalKey = BLSKeyPair.random();\n-\n-          keyWriter.println(\n-              String.format(\n-                  \"- {privkey: '%s', pubkey: '%s', withdrawalPrivkey: '%s', withdrawalPubkey: '%s'}\",\n-                  validatorKey.getSecretKey().getSecretKey().toBytes(),\n-                  validatorKey.getPublicKey().toBytesCompressed(),\n-                  withdrawalKey.getSecretKey().getSecretKey().toBytes(),\n-                  withdrawalKey.getPublicKey().toBytesCompressed()));\n-          futures.add(\n-              sendDeposit(sender, validatorKey, withdrawalKey.getPublicKey(), params.amount));\n+      } finally {\n+        if (!encryptKeys && !printOnStandardOut) {\n+          // write keys yaml to file\n+          Files.writeString(Path.of(outputFile), yamlStringBuilder.toString());\n         }\n       }\n-      SafeFuture.allOf(futures.toArray(SafeFuture[]::new)).get(2, TimeUnit.MINUTES);\n+\n+      waitForTransactionReceipts(futures);\n     } catch (final Throwable t) {\n       STDOUT.log(\n           Level.FATAL,\n           \"Failed to send deposit transaction: \" + t.getClass() + \": \" + t.getMessage());\n-      System.exit(1); // Web3J creates a non-daemon thread we can't shut down. :(\n+      exit(1);\n     }\n-    System.exit(0); // Web3J creates a non-daemon thread we can't shut down. :(\n+    exit(0);\n+  }\n+\n+  @VisibleForTesting\n+  void waitForTransactionReceipts(final List<SafeFuture<TransactionReceipt>> futures)\n+      throws InterruptedException, ExecutionException, TimeoutException {\n+    SafeFuture.allOf(futures.toArray(SafeFuture[]::new)).get(2, TimeUnit.MINUTES);\n+  }\n+\n+  @VisibleForTesting\n+  void exit(final int status) {\n+    System.exit(status); // Web3J creates a non-daemon thread we can't shut down. :(\n+  }\n+\n+  private String getYamlFormattedString(final Pair<BLSKeyPair, BLSKeyPair> keyPair) {\n+    return String.format(\n+        \"- {privkey: '%s', pubkey: '%s', withdrawalPrivkey: '%s', withdrawalPubkey: '%s'}\",\n+        keyPair.getLeft().getSecretKey().getSecretKey().toBytes(),\n+        keyPair.getLeft().getPublicKey().toBytesCompressed(),\n+        keyPair.getRight().getSecretKey().getSecretKey().toBytes(),\n+        keyPair.getRight().getPublicKey().toBytesCompressed());\n+  }\n+\n+  private void generateKeystores(\n+      final Pair<BLSKeyPair, BLSKeyPair> keyPair,\n+      final Path keyStoreOutputDirectory,\n+      final int counter) {\n+    generateKeystore(keyPair.getLeft(), keyStoreOutputDirectory, \"validator\", counter);\n+    generateKeystore(keyPair.getRight(), keyStoreOutputDirectory, \"withdrawal\", counter);\n+  }\n+\n+  private void generateKeystore(\n+      final BLSKeyPair key, final Path outputDir, final String prefix, final int counter) {\n+    try {\n+      final KdfParam kdfParam = new SCryptParam(32, Bytes32.random());\n+      final Cipher cipher = new Cipher(CipherFunction.AES_128_CTR, Bytes.random(16));\n+      final String randomPassword = generateRandomHexToken();\n+      final KeyStoreData keyStoreData =\n+          KeyStore.encrypt(\n+              key.getSecretKey().getSecretKey().toBytes(),\n+              generateRandomHexToken(),\n+              \"\",\n+              kdfParam,\n+              cipher);\n+\n+      // create sub directory\n+      final Path keystoreDirectory =\n+          Files.createDirectories(outputDir.resolve(\"validator_\" + counter));\n+\n+      // save keystore\n+      KeyStoreLoader.saveToFile(\n+          keystoreDirectory.resolve(prefix + \"_keystore_\" + counter + \".json\"), keyStoreData);\n+\n+      // save password\n+      Files.writeString(\n+          keystoreDirectory.resolve(prefix + \"_password_\" + counter + \".txt\"), randomPassword);\n+    } catch (final IOException e) {\n+      throw new UncheckedIOException(e);\n+    }\n+  }\n+\n+  private String generateRandomHexToken() {\n+    final SecureRandom secureRandom = SecureRandomProvider.createSecureRandom();\n+    byte[] token = new byte[32];\n+    secureRandom.nextBytes(token);\n+    return new BigInteger(1, token).toString(16); // hex encoding", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0"}, "originalPosition": 223}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0MTk4MA==", "bodyText": "Using a spy for the class under test is really unpleasant.\nWe also normally use the Mockito static methods instead of the @Mock annotations. Not for any particular reason, but it's pretty consistent so seems worth sticking with it.", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388641980", "createdAt": "2020-03-06T00:25:22Z", "author": {"login": "ajsutton"}, "path": "artemis/src/test/java/tech/pegasys/artemis/DepositCommandTest.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+\n+import java.io.File;\n+import java.nio.file.Path;\n+import java.util.stream.IntStream;\n+import org.assertj.core.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import tech.pegasys.artemis.services.powchain.DepositTransactionSender;\n+\n+@ExtendWith(MockitoExtension.class)\n+class DepositCommandTest {\n+  private static final int VALIDATORS_COUNT = 2;\n+  @Mock private DepositCommand.CommonParams commonParams;\n+  @Mock private DepositTransactionSender depositTransactionSender;\n+  @Spy private DepositCommand depositCommand = new DepositCommand();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0MzIxOQ==", "bodyText": "This should be able to use the when format:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                doReturn(depositTransactionSender).when(commonParams).createTransactionSender();\n          \n          \n            \n                when(commonParams.createTransactionSender()).thenReturn(depositTransactionSender);\n          \n      \n    \n    \n  \n\nThat way we get type checking done by the compiler.", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388643219", "createdAt": "2020-03-06T00:28:39Z", "author": {"login": "ajsutton"}, "path": "artemis/src/test/java/tech/pegasys/artemis/DepositCommandTest.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+\n+import java.io.File;\n+import java.nio.file.Path;\n+import java.util.stream.IntStream;\n+import org.assertj.core.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import tech.pegasys.artemis.services.powchain.DepositTransactionSender;\n+\n+@ExtendWith(MockitoExtension.class)\n+class DepositCommandTest {\n+  private static final int VALIDATORS_COUNT = 2;\n+  @Mock private DepositCommand.CommonParams commonParams;\n+  @Mock private DepositTransactionSender depositTransactionSender;\n+  @Spy private DepositCommand depositCommand = new DepositCommand();\n+\n+  @Test\n+  void encryptedKeystoresAreCreated(@TempDir final Path tempDir) throws Exception {\n+    doReturn(depositTransactionSender).when(commonParams).createTransactionSender();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0MzM3Ng==", "bodyText": "The mock transaction sender should just return completed futures and you won't need to override this.", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388643376", "createdAt": "2020-03-06T00:29:01Z", "author": {"login": "ajsutton"}, "path": "artemis/src/test/java/tech/pegasys/artemis/DepositCommandTest.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+\n+import java.io.File;\n+import java.nio.file.Path;\n+import java.util.stream.IntStream;\n+import org.assertj.core.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import tech.pegasys.artemis.services.powchain.DepositTransactionSender;\n+\n+@ExtendWith(MockitoExtension.class)\n+class DepositCommandTest {\n+  private static final int VALIDATORS_COUNT = 2;\n+  @Mock private DepositCommand.CommonParams commonParams;\n+  @Mock private DepositTransactionSender depositTransactionSender;\n+  @Spy private DepositCommand depositCommand = new DepositCommand();\n+\n+  @Test\n+  void encryptedKeystoresAreCreated(@TempDir final Path tempDir) throws Exception {\n+    doReturn(depositTransactionSender).when(commonParams).createTransactionSender();\n+    doNothing().when(depositCommand).waitForTransactionReceipts(any());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0MzU5OA==", "bodyText": "Is it worth checking we can actually decrypt the keystore?", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388643598", "createdAt": "2020-03-06T00:29:33Z", "author": {"login": "ajsutton"}, "path": "artemis/src/test/java/tech/pegasys/artemis/DepositCommandTest.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+\n+import java.io.File;\n+import java.nio.file.Path;\n+import java.util.stream.IntStream;\n+import org.assertj.core.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import tech.pegasys.artemis.services.powchain.DepositTransactionSender;\n+\n+@ExtendWith(MockitoExtension.class)\n+class DepositCommandTest {\n+  private static final int VALIDATORS_COUNT = 2;\n+  @Mock private DepositCommand.CommonParams commonParams;\n+  @Mock private DepositTransactionSender depositTransactionSender;\n+  @Spy private DepositCommand depositCommand = new DepositCommand();\n+\n+  @Test\n+  void encryptedKeystoresAreCreated(@TempDir final Path tempDir) throws Exception {\n+    doReturn(depositTransactionSender).when(commonParams).createTransactionSender();\n+    doNothing().when(depositCommand).waitForTransactionReceipts(any());\n+    doNothing().when(depositCommand).exit(0);\n+\n+    depositCommand.generate(commonParams, VALIDATORS_COUNT, \"\", true, tempDir.toString());\n+\n+    // assert that sub directories exist\n+    final File[] subDirectories =\n+        IntStream.range(1, VALIDATORS_COUNT + 1)\n+            .mapToObj(i -> tempDir.resolve(\"validator_\" + i).toFile())\n+            .toArray(File[]::new);\n+    Assertions.assertThat(tempDir.toFile().listFiles()).containsExactlyInAnyOrder(subDirectories);\n+\n+    for (int i = 0; i < subDirectories.length; i++) {\n+      assertKeyStoreAndPasswordExist(subDirectories[i].toPath(), i + 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0NDI2Mg==", "bodyText": "We can avoid adding this dependency if we stay consistent with the Mockito.mock approach to creating mocks right?", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388644262", "createdAt": "2020-03-06T00:31:10Z", "author": {"login": "ajsutton"}, "path": "gradle/versions.gradle", "diffHunk": "@@ -84,7 +84,8 @@ dependencyManagement {\n     }\n \n     dependency 'org.mockito:mockito-core:3.1.0'\n-    \n+    dependency 'org.mockito:mockito-junit-jupiter:3.1.0'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5OTg3NTcw", "url": "https://github.com/ConsenSys/teku/pull/1286#pullrequestreview-369987570", "createdAt": "2020-03-05T23:35:26Z", "commit": {"oid": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMzozNToyNlrOFyn7Fw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMzo1NDoyNlrOFyoQvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYyNzIyMw==", "bodyText": "nit: final", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388627223", "createdAt": "2020-03-05T23:35:26Z", "author": {"login": "jframe"}, "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "diffHunk": "@@ -81,44 +99,144 @@ public void generate(\n           int validatorCount,\n       @Option(\n               names = {\"--output-file\", \"-o\"},\n+              paramLabel = \"<FILE>\",\n               description =\n-                  \"File to write validator keys to. Keys are printed to std out if not specified\")\n-          String outputFile) {\n+                  \"File to write unencrypted validator keys to. Keys are printed to std out if not specified\")\n+          String outputFile,\n+      @Option(\n+              names = {\"--encrypt-keys\", \"-e\"},\n+              defaultValue = \"false\",\n+              paramLabel = \"<TRUE|FALSE>\",\n+              description = \"Encrypt validator keys. (Default: false)\",\n+              arity = \"1\")\n+          boolean encryptKeys,\n+      @Option(\n+              names = {\"--keystore-output-dir\", \"-k\"},\n+              paramLabel = \"<PATH>\",\n+              description =\n+                  \"Encrypted keystore output directory. Use current directory if not specified\")\n+          String keystorePath) {\n+\n     try (params) {\n+      // generate BLS validator key and withdrawal key\n+      final List<Pair<BLSKeyPair, BLSKeyPair>> validatorKeyPairs =\n+          IntStream.range(0, validatorCount)\n+              .mapToObj(value -> Pair.of(BLSKeyPair.random(), BLSKeyPair.random()))\n+              .collect(Collectors.toList());\n+\n       final DepositTransactionSender sender = params.createTransactionSender();\n-      final List<SafeFuture<TransactionReceipt>> futures = new ArrayList<>();\n \n-      final PrintStream keyWriter;\n-      if (outputFile == null || outputFile.isBlank()) {\n-        keyWriter = System.out;\n-      } else {\n-        keyWriter = new PrintStream(new FileOutputStream(outputFile), true, StandardCharsets.UTF_8);\n-      }\n+      final StringBuilder yamlStringBuilder = new StringBuilder();\n+      final boolean printOnStandardOut = outputFile == null || outputFile.isBlank();\n+      final Path keyStoreOutputDirectory =\n+          keystorePath == null || keystorePath.isBlank() ? Path.of(\".\") : Path.of(keystorePath);\n+      final AtomicInteger counterSuffix = new AtomicInteger(0);\n+      final List<SafeFuture<TransactionReceipt>> futures;\n+      try {\n+        futures =\n+            validatorKeyPairs.stream()\n+                .map(\n+                    keyPair -> {\n+                      final String yamlFormattedString = getYamlFormattedString(keyPair);\n+                      if (encryptKeys) {\n+                        generateKeystores(\n+                            keyPair, keyStoreOutputDirectory, counterSuffix.incrementAndGet());\n+                      } else if (printOnStandardOut) {\n+                        System.out.println(yamlFormattedString);\n+                      } else {\n+                        yamlStringBuilder\n+                            .append(yamlFormattedString)\n+                            .append(System.lineSeparator());\n+                      }\n+\n+                      return sendDeposit(\n+                          sender,\n+                          keyPair.getLeft(),\n+                          keyPair.getRight().getPublicKey(),\n+                          params.amount);\n+                    })\n+                .collect(Collectors.toList());\n \n-      try (keyWriter) {\n-        for (int i = 0; i < validatorCount; i++) {\n-          final BLSKeyPair validatorKey = BLSKeyPair.random();\n-          final BLSKeyPair withdrawalKey = BLSKeyPair.random();\n-\n-          keyWriter.println(\n-              String.format(\n-                  \"- {privkey: '%s', pubkey: '%s', withdrawalPrivkey: '%s', withdrawalPubkey: '%s'}\",\n-                  validatorKey.getSecretKey().getSecretKey().toBytes(),\n-                  validatorKey.getPublicKey().toBytesCompressed(),\n-                  withdrawalKey.getSecretKey().getSecretKey().toBytes(),\n-                  withdrawalKey.getPublicKey().toBytesCompressed()));\n-          futures.add(\n-              sendDeposit(sender, validatorKey, withdrawalKey.getPublicKey(), params.amount));\n+      } finally {\n+        if (!encryptKeys && !printOnStandardOut) {\n+          // write keys yaml to file\n+          Files.writeString(Path.of(outputFile), yamlStringBuilder.toString());\n         }\n       }\n-      SafeFuture.allOf(futures.toArray(SafeFuture[]::new)).get(2, TimeUnit.MINUTES);\n+\n+      waitForTransactionReceipts(futures);\n     } catch (final Throwable t) {\n       STDOUT.log(\n           Level.FATAL,\n           \"Failed to send deposit transaction: \" + t.getClass() + \": \" + t.getMessage());\n-      System.exit(1); // Web3J creates a non-daemon thread we can't shut down. :(\n+      exit(1);\n     }\n-    System.exit(0); // Web3J creates a non-daemon thread we can't shut down. :(\n+    exit(0);\n+  }\n+\n+  @VisibleForTesting\n+  void waitForTransactionReceipts(final List<SafeFuture<TransactionReceipt>> futures)\n+      throws InterruptedException, ExecutionException, TimeoutException {\n+    SafeFuture.allOf(futures.toArray(SafeFuture[]::new)).get(2, TimeUnit.MINUTES);\n+  }\n+\n+  @VisibleForTesting\n+  void exit(final int status) {\n+    System.exit(status); // Web3J creates a non-daemon thread we can't shut down. :(\n+  }\n+\n+  private String getYamlFormattedString(final Pair<BLSKeyPair, BLSKeyPair> keyPair) {\n+    return String.format(\n+        \"- {privkey: '%s', pubkey: '%s', withdrawalPrivkey: '%s', withdrawalPubkey: '%s'}\",\n+        keyPair.getLeft().getSecretKey().getSecretKey().toBytes(),\n+        keyPair.getLeft().getPublicKey().toBytesCompressed(),\n+        keyPair.getRight().getSecretKey().getSecretKey().toBytes(),\n+        keyPair.getRight().getPublicKey().toBytesCompressed());\n+  }\n+\n+  private void generateKeystores(\n+      final Pair<BLSKeyPair, BLSKeyPair> keyPair,\n+      final Path keyStoreOutputDirectory,\n+      final int counter) {\n+    generateKeystore(keyPair.getLeft(), keyStoreOutputDirectory, \"validator\", counter);\n+    generateKeystore(keyPair.getRight(), keyStoreOutputDirectory, \"withdrawal\", counter);\n+  }\n+\n+  private void generateKeystore(\n+      final BLSKeyPair key, final Path outputDir, final String prefix, final int counter) {\n+    try {\n+      final KdfParam kdfParam = new SCryptParam(32, Bytes32.random());\n+      final Cipher cipher = new Cipher(CipherFunction.AES_128_CTR, Bytes.random(16));\n+      final String randomPassword = generateRandomHexToken();\n+      final KeyStoreData keyStoreData =\n+          KeyStore.encrypt(\n+              key.getSecretKey().getSecretKey().toBytes(),\n+              generateRandomHexToken(),\n+              \"\",\n+              kdfParam,\n+              cipher);\n+\n+      // create sub directory\n+      final Path keystoreDirectory =\n+          Files.createDirectories(outputDir.resolve(\"validator_\" + counter));\n+\n+      // save keystore\n+      KeyStoreLoader.saveToFile(\n+          keystoreDirectory.resolve(prefix + \"_keystore_\" + counter + \".json\"), keyStoreData);\n+\n+      // save password\n+      Files.writeString(\n+          keystoreDirectory.resolve(prefix + \"_password_\" + counter + \".txt\"), randomPassword);\n+    } catch (final IOException e) {\n+      throw new UncheckedIOException(e);\n+    }\n+  }\n+\n+  private String generateRandomHexToken() {\n+    final SecureRandom secureRandom = SecureRandomProvider.createSecureRandom();\n+    byte[] token = new byte[32];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0"}, "originalPosition": 221}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYyNzk2OQ==", "bodyText": "Think we should use SecureRandom for the random seed", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388627969", "createdAt": "2020-03-05T23:37:52Z", "author": {"login": "jframe"}, "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "diffHunk": "@@ -81,44 +99,144 @@ public void generate(\n           int validatorCount,\n       @Option(\n               names = {\"--output-file\", \"-o\"},\n+              paramLabel = \"<FILE>\",\n               description =\n-                  \"File to write validator keys to. Keys are printed to std out if not specified\")\n-          String outputFile) {\n+                  \"File to write unencrypted validator keys to. Keys are printed to std out if not specified\")\n+          String outputFile,\n+      @Option(\n+              names = {\"--encrypt-keys\", \"-e\"},\n+              defaultValue = \"false\",\n+              paramLabel = \"<TRUE|FALSE>\",\n+              description = \"Encrypt validator keys. (Default: false)\",\n+              arity = \"1\")\n+          boolean encryptKeys,\n+      @Option(\n+              names = {\"--keystore-output-dir\", \"-k\"},\n+              paramLabel = \"<PATH>\",\n+              description =\n+                  \"Encrypted keystore output directory. Use current directory if not specified\")\n+          String keystorePath) {\n+\n     try (params) {\n+      // generate BLS validator key and withdrawal key\n+      final List<Pair<BLSKeyPair, BLSKeyPair>> validatorKeyPairs =\n+          IntStream.range(0, validatorCount)\n+              .mapToObj(value -> Pair.of(BLSKeyPair.random(), BLSKeyPair.random()))\n+              .collect(Collectors.toList());\n+\n       final DepositTransactionSender sender = params.createTransactionSender();\n-      final List<SafeFuture<TransactionReceipt>> futures = new ArrayList<>();\n \n-      final PrintStream keyWriter;\n-      if (outputFile == null || outputFile.isBlank()) {\n-        keyWriter = System.out;\n-      } else {\n-        keyWriter = new PrintStream(new FileOutputStream(outputFile), true, StandardCharsets.UTF_8);\n-      }\n+      final StringBuilder yamlStringBuilder = new StringBuilder();\n+      final boolean printOnStandardOut = outputFile == null || outputFile.isBlank();\n+      final Path keyStoreOutputDirectory =\n+          keystorePath == null || keystorePath.isBlank() ? Path.of(\".\") : Path.of(keystorePath);\n+      final AtomicInteger counterSuffix = new AtomicInteger(0);\n+      final List<SafeFuture<TransactionReceipt>> futures;\n+      try {\n+        futures =\n+            validatorKeyPairs.stream()\n+                .map(\n+                    keyPair -> {\n+                      final String yamlFormattedString = getYamlFormattedString(keyPair);\n+                      if (encryptKeys) {\n+                        generateKeystores(\n+                            keyPair, keyStoreOutputDirectory, counterSuffix.incrementAndGet());\n+                      } else if (printOnStandardOut) {\n+                        System.out.println(yamlFormattedString);\n+                      } else {\n+                        yamlStringBuilder\n+                            .append(yamlFormattedString)\n+                            .append(System.lineSeparator());\n+                      }\n+\n+                      return sendDeposit(\n+                          sender,\n+                          keyPair.getLeft(),\n+                          keyPair.getRight().getPublicKey(),\n+                          params.amount);\n+                    })\n+                .collect(Collectors.toList());\n \n-      try (keyWriter) {\n-        for (int i = 0; i < validatorCount; i++) {\n-          final BLSKeyPair validatorKey = BLSKeyPair.random();\n-          final BLSKeyPair withdrawalKey = BLSKeyPair.random();\n-\n-          keyWriter.println(\n-              String.format(\n-                  \"- {privkey: '%s', pubkey: '%s', withdrawalPrivkey: '%s', withdrawalPubkey: '%s'}\",\n-                  validatorKey.getSecretKey().getSecretKey().toBytes(),\n-                  validatorKey.getPublicKey().toBytesCompressed(),\n-                  withdrawalKey.getSecretKey().getSecretKey().toBytes(),\n-                  withdrawalKey.getPublicKey().toBytesCompressed()));\n-          futures.add(\n-              sendDeposit(sender, validatorKey, withdrawalKey.getPublicKey(), params.amount));\n+      } finally {\n+        if (!encryptKeys && !printOnStandardOut) {\n+          // write keys yaml to file\n+          Files.writeString(Path.of(outputFile), yamlStringBuilder.toString());\n         }\n       }\n-      SafeFuture.allOf(futures.toArray(SafeFuture[]::new)).get(2, TimeUnit.MINUTES);\n+\n+      waitForTransactionReceipts(futures);\n     } catch (final Throwable t) {\n       STDOUT.log(\n           Level.FATAL,\n           \"Failed to send deposit transaction: \" + t.getClass() + \": \" + t.getMessage());\n-      System.exit(1); // Web3J creates a non-daemon thread we can't shut down. :(\n+      exit(1);\n     }\n-    System.exit(0); // Web3J creates a non-daemon thread we can't shut down. :(\n+    exit(0);\n+  }\n+\n+  @VisibleForTesting\n+  void waitForTransactionReceipts(final List<SafeFuture<TransactionReceipt>> futures)\n+      throws InterruptedException, ExecutionException, TimeoutException {\n+    SafeFuture.allOf(futures.toArray(SafeFuture[]::new)).get(2, TimeUnit.MINUTES);\n+  }\n+\n+  @VisibleForTesting\n+  void exit(final int status) {\n+    System.exit(status); // Web3J creates a non-daemon thread we can't shut down. :(\n+  }\n+\n+  private String getYamlFormattedString(final Pair<BLSKeyPair, BLSKeyPair> keyPair) {\n+    return String.format(\n+        \"- {privkey: '%s', pubkey: '%s', withdrawalPrivkey: '%s', withdrawalPubkey: '%s'}\",\n+        keyPair.getLeft().getSecretKey().getSecretKey().toBytes(),\n+        keyPair.getLeft().getPublicKey().toBytesCompressed(),\n+        keyPair.getRight().getSecretKey().getSecretKey().toBytes(),\n+        keyPair.getRight().getPublicKey().toBytesCompressed());\n+  }\n+\n+  private void generateKeystores(\n+      final Pair<BLSKeyPair, BLSKeyPair> keyPair,\n+      final Path keyStoreOutputDirectory,\n+      final int counter) {\n+    generateKeystore(keyPair.getLeft(), keyStoreOutputDirectory, \"validator\", counter);\n+    generateKeystore(keyPair.getRight(), keyStoreOutputDirectory, \"withdrawal\", counter);\n+  }\n+\n+  private void generateKeystore(\n+      final BLSKeyPair key, final Path outputDir, final String prefix, final int counter) {\n+    try {\n+      final KdfParam kdfParam = new SCryptParam(32, Bytes32.random());\n+      final Cipher cipher = new Cipher(CipherFunction.AES_128_CTR, Bytes.random(16));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0"}, "originalPosition": 193}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYyOTMxNg==", "bodyText": "Thinking we should log an error at this point so we know which keystore failed to be created", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388629316", "createdAt": "2020-03-05T23:42:42Z", "author": {"login": "jframe"}, "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "diffHunk": "@@ -81,44 +99,144 @@ public void generate(\n           int validatorCount,\n       @Option(\n               names = {\"--output-file\", \"-o\"},\n+              paramLabel = \"<FILE>\",\n               description =\n-                  \"File to write validator keys to. Keys are printed to std out if not specified\")\n-          String outputFile) {\n+                  \"File to write unencrypted validator keys to. Keys are printed to std out if not specified\")\n+          String outputFile,\n+      @Option(\n+              names = {\"--encrypt-keys\", \"-e\"},\n+              defaultValue = \"false\",\n+              paramLabel = \"<TRUE|FALSE>\",\n+              description = \"Encrypt validator keys. (Default: false)\",\n+              arity = \"1\")\n+          boolean encryptKeys,\n+      @Option(\n+              names = {\"--keystore-output-dir\", \"-k\"},\n+              paramLabel = \"<PATH>\",\n+              description =\n+                  \"Encrypted keystore output directory. Use current directory if not specified\")\n+          String keystorePath) {\n+\n     try (params) {\n+      // generate BLS validator key and withdrawal key\n+      final List<Pair<BLSKeyPair, BLSKeyPair>> validatorKeyPairs =\n+          IntStream.range(0, validatorCount)\n+              .mapToObj(value -> Pair.of(BLSKeyPair.random(), BLSKeyPair.random()))\n+              .collect(Collectors.toList());\n+\n       final DepositTransactionSender sender = params.createTransactionSender();\n-      final List<SafeFuture<TransactionReceipt>> futures = new ArrayList<>();\n \n-      final PrintStream keyWriter;\n-      if (outputFile == null || outputFile.isBlank()) {\n-        keyWriter = System.out;\n-      } else {\n-        keyWriter = new PrintStream(new FileOutputStream(outputFile), true, StandardCharsets.UTF_8);\n-      }\n+      final StringBuilder yamlStringBuilder = new StringBuilder();\n+      final boolean printOnStandardOut = outputFile == null || outputFile.isBlank();\n+      final Path keyStoreOutputDirectory =\n+          keystorePath == null || keystorePath.isBlank() ? Path.of(\".\") : Path.of(keystorePath);\n+      final AtomicInteger counterSuffix = new AtomicInteger(0);\n+      final List<SafeFuture<TransactionReceipt>> futures;\n+      try {\n+        futures =\n+            validatorKeyPairs.stream()\n+                .map(\n+                    keyPair -> {\n+                      final String yamlFormattedString = getYamlFormattedString(keyPair);\n+                      if (encryptKeys) {\n+                        generateKeystores(\n+                            keyPair, keyStoreOutputDirectory, counterSuffix.incrementAndGet());\n+                      } else if (printOnStandardOut) {\n+                        System.out.println(yamlFormattedString);\n+                      } else {\n+                        yamlStringBuilder\n+                            .append(yamlFormattedString)\n+                            .append(System.lineSeparator());\n+                      }\n+\n+                      return sendDeposit(\n+                          sender,\n+                          keyPair.getLeft(),\n+                          keyPair.getRight().getPublicKey(),\n+                          params.amount);\n+                    })\n+                .collect(Collectors.toList());\n \n-      try (keyWriter) {\n-        for (int i = 0; i < validatorCount; i++) {\n-          final BLSKeyPair validatorKey = BLSKeyPair.random();\n-          final BLSKeyPair withdrawalKey = BLSKeyPair.random();\n-\n-          keyWriter.println(\n-              String.format(\n-                  \"- {privkey: '%s', pubkey: '%s', withdrawalPrivkey: '%s', withdrawalPubkey: '%s'}\",\n-                  validatorKey.getSecretKey().getSecretKey().toBytes(),\n-                  validatorKey.getPublicKey().toBytesCompressed(),\n-                  withdrawalKey.getSecretKey().getSecretKey().toBytes(),\n-                  withdrawalKey.getPublicKey().toBytesCompressed()));\n-          futures.add(\n-              sendDeposit(sender, validatorKey, withdrawalKey.getPublicKey(), params.amount));\n+      } finally {\n+        if (!encryptKeys && !printOnStandardOut) {\n+          // write keys yaml to file\n+          Files.writeString(Path.of(outputFile), yamlStringBuilder.toString());\n         }\n       }\n-      SafeFuture.allOf(futures.toArray(SafeFuture[]::new)).get(2, TimeUnit.MINUTES);\n+\n+      waitForTransactionReceipts(futures);\n     } catch (final Throwable t) {\n       STDOUT.log(\n           Level.FATAL,\n           \"Failed to send deposit transaction: \" + t.getClass() + \": \" + t.getMessage());\n-      System.exit(1); // Web3J creates a non-daemon thread we can't shut down. :(\n+      exit(1);\n     }\n-    System.exit(0); // Web3J creates a non-daemon thread we can't shut down. :(\n+    exit(0);\n+  }\n+\n+  @VisibleForTesting\n+  void waitForTransactionReceipts(final List<SafeFuture<TransactionReceipt>> futures)\n+      throws InterruptedException, ExecutionException, TimeoutException {\n+    SafeFuture.allOf(futures.toArray(SafeFuture[]::new)).get(2, TimeUnit.MINUTES);\n+  }\n+\n+  @VisibleForTesting\n+  void exit(final int status) {\n+    System.exit(status); // Web3J creates a non-daemon thread we can't shut down. :(\n+  }\n+\n+  private String getYamlFormattedString(final Pair<BLSKeyPair, BLSKeyPair> keyPair) {\n+    return String.format(\n+        \"- {privkey: '%s', pubkey: '%s', withdrawalPrivkey: '%s', withdrawalPubkey: '%s'}\",\n+        keyPair.getLeft().getSecretKey().getSecretKey().toBytes(),\n+        keyPair.getLeft().getPublicKey().toBytesCompressed(),\n+        keyPair.getRight().getSecretKey().getSecretKey().toBytes(),\n+        keyPair.getRight().getPublicKey().toBytesCompressed());\n+  }\n+\n+  private void generateKeystores(\n+      final Pair<BLSKeyPair, BLSKeyPair> keyPair,\n+      final Path keyStoreOutputDirectory,\n+      final int counter) {\n+    generateKeystore(keyPair.getLeft(), keyStoreOutputDirectory, \"validator\", counter);\n+    generateKeystore(keyPair.getRight(), keyStoreOutputDirectory, \"withdrawal\", counter);\n+  }\n+\n+  private void generateKeystore(\n+      final BLSKeyPair key, final Path outputDir, final String prefix, final int counter) {\n+    try {\n+      final KdfParam kdfParam = new SCryptParam(32, Bytes32.random());\n+      final Cipher cipher = new Cipher(CipherFunction.AES_128_CTR, Bytes.random(16));\n+      final String randomPassword = generateRandomHexToken();\n+      final KeyStoreData keyStoreData =\n+          KeyStore.encrypt(\n+              key.getSecretKey().getSecretKey().toBytes(),\n+              generateRandomHexToken(),\n+              \"\",\n+              kdfParam,\n+              cipher);\n+\n+      // create sub directory\n+      final Path keystoreDirectory =\n+          Files.createDirectories(outputDir.resolve(\"validator_\" + counter));\n+\n+      // save keystore\n+      KeyStoreLoader.saveToFile(\n+          keystoreDirectory.resolve(prefix + \"_keystore_\" + counter + \".json\"), keyStoreData);\n+\n+      // save password\n+      Files.writeString(\n+          keystoreDirectory.resolve(prefix + \"_password_\" + counter + \".txt\"), randomPassword);\n+    } catch (final IOException e) {\n+      throw new UncheckedIOException(e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0"}, "originalPosition": 215}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYzMDYyNg==", "bodyText": "nit: instead the generic Pair a small custom class would help with readability so that you do something like validatorKeyPair.getValidatorKey() instead of getLeft for example", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388630626", "createdAt": "2020-03-05T23:47:25Z", "author": {"login": "jframe"}, "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "diffHunk": "@@ -81,44 +99,144 @@ public void generate(\n           int validatorCount,\n       @Option(\n               names = {\"--output-file\", \"-o\"},\n+              paramLabel = \"<FILE>\",\n               description =\n-                  \"File to write validator keys to. Keys are printed to std out if not specified\")\n-          String outputFile) {\n+                  \"File to write unencrypted validator keys to. Keys are printed to std out if not specified\")\n+          String outputFile,\n+      @Option(\n+              names = {\"--encrypt-keys\", \"-e\"},\n+              defaultValue = \"false\",\n+              paramLabel = \"<TRUE|FALSE>\",\n+              description = \"Encrypt validator keys. (Default: false)\",\n+              arity = \"1\")\n+          boolean encryptKeys,\n+      @Option(\n+              names = {\"--keystore-output-dir\", \"-k\"},\n+              paramLabel = \"<PATH>\",\n+              description =\n+                  \"Encrypted keystore output directory. Use current directory if not specified\")\n+          String keystorePath) {\n+\n     try (params) {\n+      // generate BLS validator key and withdrawal key\n+      final List<Pair<BLSKeyPair, BLSKeyPair>> validatorKeyPairs =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYzMDk5MA==", "bodyText": "nit: transactionReceiptFutures?", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388630990", "createdAt": "2020-03-05T23:48:41Z", "author": {"login": "jframe"}, "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "diffHunk": "@@ -81,44 +99,144 @@ public void generate(\n           int validatorCount,\n       @Option(\n               names = {\"--output-file\", \"-o\"},\n+              paramLabel = \"<FILE>\",\n               description =\n-                  \"File to write validator keys to. Keys are printed to std out if not specified\")\n-          String outputFile) {\n+                  \"File to write unencrypted validator keys to. Keys are printed to std out if not specified\")\n+          String outputFile,\n+      @Option(\n+              names = {\"--encrypt-keys\", \"-e\"},\n+              defaultValue = \"false\",\n+              paramLabel = \"<TRUE|FALSE>\",\n+              description = \"Encrypt validator keys. (Default: false)\",\n+              arity = \"1\")\n+          boolean encryptKeys,\n+      @Option(\n+              names = {\"--keystore-output-dir\", \"-k\"},\n+              paramLabel = \"<PATH>\",\n+              description =\n+                  \"Encrypted keystore output directory. Use current directory if not specified\")\n+          String keystorePath) {\n+\n     try (params) {\n+      // generate BLS validator key and withdrawal key\n+      final List<Pair<BLSKeyPair, BLSKeyPair>> validatorKeyPairs =\n+          IntStream.range(0, validatorCount)\n+              .mapToObj(value -> Pair.of(BLSKeyPair.random(), BLSKeyPair.random()))\n+              .collect(Collectors.toList());\n+\n       final DepositTransactionSender sender = params.createTransactionSender();\n-      final List<SafeFuture<TransactionReceipt>> futures = new ArrayList<>();\n \n-      final PrintStream keyWriter;\n-      if (outputFile == null || outputFile.isBlank()) {\n-        keyWriter = System.out;\n-      } else {\n-        keyWriter = new PrintStream(new FileOutputStream(outputFile), true, StandardCharsets.UTF_8);\n-      }\n+      final StringBuilder yamlStringBuilder = new StringBuilder();\n+      final boolean printOnStandardOut = outputFile == null || outputFile.isBlank();\n+      final Path keyStoreOutputDirectory =\n+          keystorePath == null || keystorePath.isBlank() ? Path.of(\".\") : Path.of(keystorePath);\n+      final AtomicInteger counterSuffix = new AtomicInteger(0);\n+      final List<SafeFuture<TransactionReceipt>> futures;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYzMjM1OQ==", "bodyText": "rename to validatorKeyStoreFile and similarly rename password1File to validatoryPasswordFile", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388632359", "createdAt": "2020-03-05T23:53:08Z", "author": {"login": "jframe"}, "path": "artemis/src/test/java/tech/pegasys/artemis/DepositCommandTest.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+\n+import java.io.File;\n+import java.nio.file.Path;\n+import java.util.stream.IntStream;\n+import org.assertj.core.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import tech.pegasys.artemis.services.powchain.DepositTransactionSender;\n+\n+@ExtendWith(MockitoExtension.class)\n+class DepositCommandTest {\n+  private static final int VALIDATORS_COUNT = 2;\n+  @Mock private DepositCommand.CommonParams commonParams;\n+  @Mock private DepositTransactionSender depositTransactionSender;\n+  @Spy private DepositCommand depositCommand = new DepositCommand();\n+\n+  @Test\n+  void encryptedKeystoresAreCreated(@TempDir final Path tempDir) throws Exception {\n+    doReturn(depositTransactionSender).when(commonParams).createTransactionSender();\n+    doNothing().when(depositCommand).waitForTransactionReceipts(any());\n+    doNothing().when(depositCommand).exit(0);\n+\n+    depositCommand.generate(commonParams, VALIDATORS_COUNT, \"\", true, tempDir.toString());\n+\n+    // assert that sub directories exist\n+    final File[] subDirectories =\n+        IntStream.range(1, VALIDATORS_COUNT + 1)\n+            .mapToObj(i -> tempDir.resolve(\"validator_\" + i).toFile())\n+            .toArray(File[]::new);\n+    Assertions.assertThat(tempDir.toFile().listFiles()).containsExactlyInAnyOrder(subDirectories);\n+\n+    for (int i = 0; i < subDirectories.length; i++) {\n+      assertKeyStoreAndPasswordExist(subDirectories[i].toPath(), i + 1);\n+    }\n+  }\n+\n+  private void assertKeyStoreAndPasswordExist(final Path parentDir, final int suffix) {\n+    final Path keystore1File = parentDir.resolve(\"validator_keystore_\" + suffix + \".json\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYzMjc2Nw==", "bodyText": "rename withdrawalKeyStoreFile and similarly rename password2File to withdrawalPasswordFile", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388632767", "createdAt": "2020-03-05T23:54:26Z", "author": {"login": "jframe"}, "path": "artemis/src/test/java/tech/pegasys/artemis/DepositCommandTest.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+\n+import java.io.File;\n+import java.nio.file.Path;\n+import java.util.stream.IntStream;\n+import org.assertj.core.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import tech.pegasys.artemis.services.powchain.DepositTransactionSender;\n+\n+@ExtendWith(MockitoExtension.class)\n+class DepositCommandTest {\n+  private static final int VALIDATORS_COUNT = 2;\n+  @Mock private DepositCommand.CommonParams commonParams;\n+  @Mock private DepositTransactionSender depositTransactionSender;\n+  @Spy private DepositCommand depositCommand = new DepositCommand();\n+\n+  @Test\n+  void encryptedKeystoresAreCreated(@TempDir final Path tempDir) throws Exception {\n+    doReturn(depositTransactionSender).when(commonParams).createTransactionSender();\n+    doNothing().when(depositCommand).waitForTransactionReceipts(any());\n+    doNothing().when(depositCommand).exit(0);\n+\n+    depositCommand.generate(commonParams, VALIDATORS_COUNT, \"\", true, tempDir.toString());\n+\n+    // assert that sub directories exist\n+    final File[] subDirectories =\n+        IntStream.range(1, VALIDATORS_COUNT + 1)\n+            .mapToObj(i -> tempDir.resolve(\"validator_\" + i).toFile())\n+            .toArray(File[]::new);\n+    Assertions.assertThat(tempDir.toFile().listFiles()).containsExactlyInAnyOrder(subDirectories);\n+\n+    for (int i = 0; i < subDirectories.length; i++) {\n+      assertKeyStoreAndPasswordExist(subDirectories[i].toPath(), i + 1);\n+    }\n+  }\n+\n+  private void assertKeyStoreAndPasswordExist(final Path parentDir, final int suffix) {\n+    final Path keystore1File = parentDir.resolve(\"validator_keystore_\" + suffix + \".json\");\n+    final Path password1File = parentDir.resolve(\"validator_password_\" + suffix + \".txt\");\n+    final Path keystore2File = parentDir.resolve(\"withdrawal_keystore_\" + suffix + \".json\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0"}, "originalPosition": 62}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2e38f2b14a848e05b6266f04425804f53ee21f97", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/2e38f2b14a848e05b6266f04425804f53ee21f97", "committedDate": "2020-03-06T01:45:22Z", "message": "review suggestion - use functional interface to invoke System.exit\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "866e7910bd9924cc6451eab560743189db78d4dd", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/866e7910bd9924cc6451eab560743189db78d4dd", "committedDate": "2020-03-06T02:02:22Z", "message": "review suggestion - use static mock function\n\n -- removed mockito junit5 extensions\n -- updated mock senddeposittransaction to return completed future\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b13acdfaaef8203ea2b8b74efa7584307e06d59e", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/b13acdfaaef8203ea2b8b74efa7584307e06d59e", "committedDate": "2020-03-06T05:09:20Z", "message": "Merge remote-tracking branch 'upstream/master' into 1178_validator_generate_keystore\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1811f480ea049f9598bdc61a90e9cb2c94bd1524", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/1811f480ea049f9598bdc61a90e9cb2c94bd1524", "committedDate": "2020-03-06T07:14:46Z", "message": "wip\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d6a4c3cb48159960e64bafad9ea5796763e15eb7", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/d6a4c3cb48159960e64bafad9ea5796763e15eb7", "committedDate": "2020-03-06T08:11:11Z", "message": "Merge remote-tracking branch 'upstream/master' into 1178_validator_generate_keystore\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4e6a6fabc93d95278774a6b174c9b05ab8eb286c", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/4e6a6fabc93d95278774a6b174c9b05ab8eb286c", "committedDate": "2020-03-06T09:19:29Z", "message": "Use new KeysWriter in DepositCommand.\nTODO: Update unit test case\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5a3f29a46c4e0e81450d3b3bab08662dd3d63aae", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/5a3f29a46c4e0e81450d3b3bab08662dd3d63aae", "committedDate": "2020-03-08T23:28:41Z", "message": "Merge upstream branch\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "67343355fa41c7628f2f3660ba5f044ad9566fc7", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/67343355fa41c7628f2f3660ba5f044ad9566fc7", "committedDate": "2020-03-09T04:09:34Z", "message": "Interactive mode to read password. Also use arggroup\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6cd5ab26e48c1290d7bc2a61e16ff7ab34c3516f", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/6cd5ab26e48c1290d7bc2a61e16ff7ab34c3516f", "committedDate": "2020-03-09T04:13:02Z", "message": "Merge remote-tracking branch 'upstream/master' into 1178_validator_generate_keystore\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4010e602c4a52d5abeadbd5a4a3ada7600c0147e", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/4010e602c4a52d5abeadbd5a4a3ada7600c0147e", "committedDate": "2020-03-09T05:43:37Z", "message": "arg group not working, removed it temporarily\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "998eae48ba1f9a665795e4156db17d84e7d9fab8", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/998eae48ba1f9a665795e4156db17d84e7d9fab8", "committedDate": "2020-03-09T07:27:30Z", "message": "cleaning up interactive mode\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1be3527676a0a252dc727820860df98f060350db", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/1be3527676a0a252dc727820860df98f060350db", "committedDate": "2020-03-09T09:37:45Z", "message": "fixing unit test\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5efc5a5ca901eabd21f2213f295d3666709e08c5", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/5efc5a5ca901eabd21f2213f295d3666709e08c5", "committedDate": "2020-03-09T09:39:49Z", "message": "merge upstream\n\nSigned-off-by: Usman Saleem <usman@usmans.info>\n\n# Conflicts:\n#\tartemis/src/main/java/tech/pegasys/artemis/DepositCommand.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1d63fa6a192ae950d1789f00947deb8e2f895e9f", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/1d63fa6a192ae950d1789f00947deb8e2f895e9f", "committedDate": "2020-03-09T09:47:47Z", "message": "merge conflicts status_log\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2987c4dfa2f934d4957292d2fd4bbe70abb453d4", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/2987c4dfa2f934d4957292d2fd4bbe70abb453d4", "committedDate": "2020-03-09T10:11:35Z", "message": "fixing depositsender acceptance test\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eb4e4fced1d629777d6f8440fd26e8a158d4253d", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/eb4e4fced1d629777d6f8440fd26e8a158d4253d", "committedDate": "2020-03-09T13:09:58Z", "message": "fixing depositsender acceptance test\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxNTY5NDIy", "url": "https://github.com/ConsenSys/teku/pull/1286#pullrequestreview-371569422", "createdAt": "2020-03-09T22:24:58Z", "commit": {"oid": "eb4e4fced1d629777d6f8440fd26e8a158d4253d"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQyMjoyNDo1OFrOFz7Z6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQyMjo0Mjo0N1rOFz7y4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk5NDk4NQ==", "bodyText": "This isn't the right approach.  If we're outputting to STDOUT, we need to make sure logging is either disabled or sent to STDERR.  Otherwise people who run this tool in real life will get corrupt output.", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r389994985", "createdAt": "2020-03-09T22:24:58Z", "author": {"login": "ajsutton"}, "path": "acceptance-tests/src/test-support/java/tech/pegasys/artemis/test/acceptance/dsl/ArtemisDepositSender.java", "diffHunk": "@@ -44,6 +47,11 @@ public String sendValidatorDeposits(final BesuNode eth1Node, final int numberOfV\n     container.start();\n     Waiter.waitFor(() -> assertThat(container.isRunning()).isFalse());\n     container.stop();\n-    return validatorKeys.toString();\n+    // because we have introduced some logging, only pick lines which start with a - {\n+    return validatorKeys\n+        .toString()\n+        .lines()\n+        .filter(s -> s.startsWith(\"- {\"))\n+        .collect(Collectors.joining(System.lineSeparator()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb4e4fced1d629777d6f8440fd26e8a158d4253d"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk5NjY1Ng==", "bodyText": "colon in the arg name is weird. I'd have expected --validator-password-file. Might be possible to do it with a single --validator-password option - if no arg use interactive prompt, if it starts with env: treat as an environment variable and otherwise treat as a file path.  Not entirely sure that's a good idea though...\n@jakehaugen any thoughts?", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r389996656", "createdAt": "2020-03-09T22:29:38Z", "author": {"login": "ajsutton"}, "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "diffHunk": "@@ -80,45 +100,98 @@ public void generate(\n               defaultValue = \"1\")\n           int validatorCount,\n       @Option(\n-              names = {\"--output-file\", \"-o\"},\n+              names = {\"--output-path\", \"-o\"},\n+              paramLabel = \"<FILE|DIR>\",\n               description =\n-                  \"File to write validator keys to. Keys are printed to std out if not specified\")\n-          String outputFile) {\n+                  \"Path to output file for unencrypted keys or output directory for encrypted keystore files. If not set, unencrypted keys will be written on standard out and encrypted keystores will be created in current directory\")\n+          String outputPath,\n+      @Option(\n+              names = {\"--encrypt-keys\", \"-e\"},\n+              defaultValue = \"true\",\n+              paramLabel = \"<true|false>\",\n+              description = \"Encrypt validator and withdrawal keys. (Default: true)\",\n+              arity = \"1\")\n+          boolean encryptKeys,\n+      @Option(\n+              names = {\"--validator-password:file\"},", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb4e4fced1d629777d6f8440fd26e8a158d4253d"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk5OTY0Ng==", "bodyText": "It seems weird to have to specify --validator-password to get the prompt to provide the password. Makes me naturally want to specify the password on the command line which is insecure and doesn't actually work.", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r389999646", "createdAt": "2020-03-09T22:37:35Z", "author": {"login": "ajsutton"}, "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "diffHunk": "@@ -80,45 +100,98 @@ public void generate(\n               defaultValue = \"1\")\n           int validatorCount,\n       @Option(\n-              names = {\"--output-file\", \"-o\"},\n+              names = {\"--output-path\", \"-o\"},\n+              paramLabel = \"<FILE|DIR>\",\n               description =\n-                  \"File to write validator keys to. Keys are printed to std out if not specified\")\n-          String outputFile) {\n+                  \"Path to output file for unencrypted keys or output directory for encrypted keystore files. If not set, unencrypted keys will be written on standard out and encrypted keystores will be created in current directory\")\n+          String outputPath,\n+      @Option(\n+              names = {\"--encrypt-keys\", \"-e\"},\n+              defaultValue = \"true\",\n+              paramLabel = \"<true|false>\",\n+              description = \"Encrypt validator and withdrawal keys. (Default: true)\",\n+              arity = \"1\")\n+          boolean encryptKeys,\n+      @Option(\n+              names = {\"--validator-password:file\"},\n+              paramLabel = \"<FILE>\",\n+              description = \"Read password from the file to encrypt the validator keys\")\n+          File validatorPasswordFile,\n+      @Option(\n+              names = {\"--validator-password:env\"},\n+              paramLabel = \"<ENV_VAR>\",\n+              description = \"Read password from environment variable to encrypt the validator keys\")\n+          String validatorPasswordEnv,\n+      @Option(\n+              names = {\"--validator-password\"},", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb4e4fced1d629777d6f8440fd26e8a158d4253d"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk5OTc5NQ==", "bodyText": "Probably should check that only one of the three options for specifying the password have been provided.  Otherwise it will be very confusing which password actually gets used.", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r389999795", "createdAt": "2020-03-09T22:38:01Z", "author": {"login": "ajsutton"}, "path": "artemis/src/main/java/tech/pegasys/artemis/cli/deposit/EncryptedKeystorePasswordProvider.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.cli.deposit;\n+\n+import static org.apache.commons.lang3.StringUtils.isBlank;\n+\n+import com.google.common.io.Files;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import picocli.CommandLine.Model.CommandSpec;\n+import picocli.CommandLine.ParameterException;\n+\n+public class EncryptedKeystorePasswordProvider {\n+  private final String password;\n+  private final String environmentVariable;\n+  private final File passwordFile;\n+  private final String errorPrefix;\n+\n+  private final CommandSpec spec;\n+\n+  public EncryptedKeystorePasswordProvider(\n+      final CommandSpec spec,\n+      final String password,\n+      final String environmentVariable,\n+      final File passwordFile,\n+      final String errorPrefix) {\n+    this.spec = spec;\n+    this.password = password;\n+    this.environmentVariable = environmentVariable;\n+    this.passwordFile = passwordFile;\n+    this.errorPrefix = errorPrefix;\n+  }\n+\n+  public String retrievePassword() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb4e4fced1d629777d6f8440fd26e8a158d4253d"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwMDQwMw==", "bodyText": "It's really annoying to get the missing options error message in small chunks.  ie I tried:\n$ ./build/install/teku/bin/teku validator generate\nMissing required options [--node-url=<URL>, --contract-address=<ADDRESS>, --private-key=<KEY>]\n\n$ ./build/install/teku/bin/teku validator generate --node-url=http://localhost:8545 --contract-address=dddddddd --private-key=222222222\nMissing options: [--validator-password | --validator-password:env | --validator-password:file]\n\n$ ./build/install/teku/bin/teku validator generate --node-url=http://localhost:8545 --contract-address=dddddddd --private-key=222222222 --validator-password\nEnter value for --validator-password (Password to encrypt validator keys):\nMissing options: [--withdrawal-password | --withdrawal-password:env | --withdrawal-password:file]\n\nSo it took me four goes to actually be told all of what I had to provide.", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r390000403", "createdAt": "2020-03-09T22:39:51Z", "author": {"login": "ajsutton"}, "path": "artemis/src/main/java/tech/pegasys/artemis/cli/deposit/EncryptedKeystorePasswordProvider.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.cli.deposit;\n+\n+import static org.apache.commons.lang3.StringUtils.isBlank;\n+\n+import com.google.common.io.Files;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import picocli.CommandLine.Model.CommandSpec;\n+import picocli.CommandLine.ParameterException;\n+\n+public class EncryptedKeystorePasswordProvider {\n+  private final String password;\n+  private final String environmentVariable;\n+  private final File passwordFile;\n+  private final String errorPrefix;\n+\n+  private final CommandSpec spec;\n+\n+  public EncryptedKeystorePasswordProvider(\n+      final CommandSpec spec,\n+      final String password,\n+      final String environmentVariable,\n+      final File passwordFile,\n+      final String errorPrefix) {\n+    this.spec = spec;\n+    this.password = password;\n+    this.environmentVariable = environmentVariable;\n+    this.passwordFile = passwordFile;\n+    this.errorPrefix = errorPrefix;\n+  }\n+\n+  public String retrievePassword() {\n+    if (!isBlank(password)) {\n+      return password;\n+    }\n+\n+    if (environmentVariable != null) {\n+      final String password = System.getenv(environmentVariable);\n+      if (isBlank(password)) {\n+        throw new ParameterException(\n+            spec.commandLine(),\n+            \"Error in reading password from environment variable: \" + environmentVariable);\n+      }\n+      return password;\n+    }\n+\n+    if (passwordFile != null) {\n+      try {\n+        final String password =\n+            Files.asCharSource(passwordFile, StandardCharsets.UTF_8).readFirstLine();\n+        if (isBlank(password)) {\n+          throw new ParameterException(\n+              spec.commandLine(), \"Empty password read from password file: \" + passwordFile);\n+        }\n+        return password;\n+      } catch (final FileNotFoundException e) {\n+        throw new ParameterException(\n+            spec.commandLine(), \"Password file not found: \" + passwordFile);\n+      } catch (IOException e) {\n+        throw new ParameterException(\n+            spec.commandLine(),\n+            \"Unexpected IO error while reading password from file [\"\n+                + passwordFile\n+                + \"] : \"\n+                + e.getMessage());\n+      }\n+    }\n+\n+    final String errorMessage =\n+        String.format(\n+            \"Missing options: [--%1$s-password | --%1$s-password:env | --%1$s-password:file]\",\n+            errorPrefix);\n+    throw new ParameterException(spec.commandLine(), errorMessage);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb4e4fced1d629777d6f8440fd26e8a158d4253d"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwMTM3Nw==", "bodyText": "If I run the command twice, does this wind up overwriting the existing keys (losing my funds)?  Would it be better to use the public key as part of the directory name rather than the index - then it's guaranteed to be unique.", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r390001377", "createdAt": "2020-03-09T22:42:47Z", "author": {"login": "ajsutton"}, "path": "artemis/src/main/java/tech/pegasys/artemis/cli/deposit/EncryptedKeystoreWriter.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.cli.deposit;\n+\n+import static tech.pegasys.artemis.util.crypto.SecureRandomProvider.createSecureRandom;\n+import static tech.pegasys.teku.logging.StatusLogger.STATUS_LOG;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.apache.logging.log4j.Level;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.artemis.bls.keystore.KeyStore;\n+import tech.pegasys.artemis.bls.keystore.KeyStoreLoader;\n+import tech.pegasys.artemis.bls.keystore.KeyStoreValidationException;\n+import tech.pegasys.artemis.bls.keystore.model.Cipher;\n+import tech.pegasys.artemis.bls.keystore.model.CipherFunction;\n+import tech.pegasys.artemis.bls.keystore.model.KdfParam;\n+import tech.pegasys.artemis.bls.keystore.model.KeyStoreData;\n+import tech.pegasys.artemis.bls.keystore.model.SCryptParam;\n+import tech.pegasys.artemis.util.bls.BLSKeyPair;\n+\n+public class EncryptedKeystoreWriter implements KeysWriter {\n+  private final String validatorKeyPassword;\n+  private final String withdrawalKeyPassword;\n+  private final Path outputPath;\n+  private final AtomicInteger counter = new AtomicInteger(0);\n+\n+  public EncryptedKeystoreWriter(\n+      final String validatorKeyPassword,\n+      final String withdrawalKeyPassword,\n+      final Path outputPath) {\n+    this.validatorKeyPassword = validatorKeyPassword;\n+    this.withdrawalKeyPassword = withdrawalKeyPassword;\n+    this.outputPath = outputPath;\n+  }\n+\n+  @Override\n+  public void writeKeys(final BLSKeyPair validatorKey, final BLSKeyPair withdrawalKey)\n+      throws UncheckedIOException, KeyStoreValidationException {\n+    final Path keystoreDirectory = createKeystoreDirectory();\n+\n+    final KeyStoreData validatorKeyStoreData =\n+        generateKeystoreData(validatorKey, validatorKeyPassword);\n+    final KeyStoreData withdrawalKeyStoreData =\n+        generateKeystoreData(withdrawalKey, withdrawalKeyPassword);\n+\n+    saveKeyStore(keystoreDirectory.resolve(\"validator_keystore.json\"), validatorKeyStoreData);\n+    saveKeyStore(keystoreDirectory.resolve(\"withdrawal_keystore.json\"), withdrawalKeyStoreData);\n+  }\n+\n+  private Path createKeystoreDirectory() {\n+    final Path keystoreDirectory = outputPath.resolve(\"validator_\" + counter.incrementAndGet());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb4e4fced1d629777d6f8440fd26e8a158d4253d"}, "originalPosition": 67}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "27ac813be91da89eaed75fdb98ec147d88b31723", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/27ac813be91da89eaed75fdb98ec147d88b31723", "committedDate": "2020-03-10T00:29:18Z", "message": "Merge remote-tracking branch 'upstream/master' into 1178_validator_generate_keystore\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "740c37c3546245cba6d9484a0586a23371433b4e", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/740c37c3546245cba6d9484a0586a23371433b4e", "committedDate": "2020-03-10T00:53:09Z", "message": "fixing expected output in yamlkeyswritertest due to tuweni output in lower case\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f4c60c78df5d79eebe5a9f7f1658dc7ec755dfe3", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/f4c60c78df5d79eebe5a9f7f1658dc7ec755dfe3", "committedDate": "2020-03-10T01:01:04Z", "message": "DepositCommand - reverting stdout logs\n\n -- reverted stdout logs when yaml keys are required to be printed on standard out\n -- fixed acceptance test case\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4569ecb20aa21cc68529b35c55aade82ce107fb7", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/4569ecb20aa21cc68529b35c55aade82ce107fb7", "committedDate": "2020-03-10T02:02:37Z", "message": "Review suggestions - use validator bls public key as directory name\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "481eee36e02b5db6638441820ffb8d93f55b36bc", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/481eee36e02b5db6638441820ffb8d93f55b36bc", "committedDate": "2020-03-10T08:26:42Z", "message": "Converting subcommands methods to static classes to allow ArgGroups\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "914c0504b4575a7dca42ba7e986410f209474d1b", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/914c0504b4575a7dca42ba7e986410f209474d1b", "committedDate": "2020-03-10T12:02:31Z", "message": "Updating deposit subcommands and unit test cases\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d2645ad94f6fdfa01ad060756ca02e320301a664", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/d2645ad94f6fdfa01ad060756ca02e320301a664", "committedDate": "2020-03-10T12:03:04Z", "message": "Merge remote-tracking branch 'upstream/master' into 1178_validator_generate_keystore\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a3805453241a698d4ab3b505c96852bd7971fb68", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/a3805453241a698d4ab3b505c96852bd7971fb68", "committedDate": "2020-03-10T12:16:19Z", "message": "typo in exception msg\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzczMjA5NDIx", "url": "https://github.com/ConsenSys/teku/pull/1286#pullrequestreview-373209421", "createdAt": "2020-03-12T00:23:32Z", "commit": {"oid": "a3805453241a698d4ab3b505c96852bd7971fb68"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8d5d673cbcce5a6e1dc9522be1b3848546052b0a", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/8d5d673cbcce5a6e1dc9522be1b3848546052b0a", "committedDate": "2020-03-12T00:44:15Z", "message": "Merging upstream master\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "14ff85250c05d02fc4be349dc5ca949618287f17", "author": {"user": {"login": "usmansaleem", "name": "Usman Saleem"}}, "url": "https://github.com/ConsenSys/teku/commit/14ff85250c05d02fc4be349dc5ca949618287f17", "committedDate": "2020-03-12T02:03:55Z", "message": "Review suggestion - update non-interactive option name to include keystore\n\nSigned-off-by: Usman Saleem <usman@usmans.info>"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4171, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}