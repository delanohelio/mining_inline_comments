{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI2ODc4NjM0", "number": 2042, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwMDowNToyOVrOEB9WJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwMTo1NTowNFrOEB-ZRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNDg5MTI2OnYy", "diffSide": "RIGHT", "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/DepositMerkleTree.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwMDowNToyOVrOGeH3nQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNToxNjoxOFrOGegtRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDIzOTM4OQ==", "bodyText": "I don't feel like this class is the right approach - the responsibilities here feel like they should stay in DepositProvider (which is primarily responsible for providing the deposits to include in a block).\nThe TestDepositGenerator class also feels a little overly specific to the test it's used in.  I've suggested a simpler way to get an inactive validator on that test.", "url": "https://github.com/ConsenSys/teku/pull/2042#discussion_r434239389", "createdAt": "2020-06-03T00:05:29Z", "author": {"login": "ajsutton"}, "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/DepositMerkleTree.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.core;\n+\n+import static java.lang.StrictMath.toIntExact;\n+import static tech.pegasys.teku.util.config.Constants.DEPOSIT_CONTRACT_TREE_DEPTH;\n+import static tech.pegasys.teku.util.config.Constants.MAX_DEPOSITS;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.List;\n+import java.util.NavigableMap;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.datastructures.operations.Deposit;\n+import tech.pegasys.teku.datastructures.operations.DepositWithIndex;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.datastructures.util.MerkleTree;\n+import tech.pegasys.teku.datastructures.util.OptimizedMerkleTree;\n+import tech.pegasys.teku.ssz.SSZTypes.SSZList;\n+\n+public class DepositMerkleTree {\n+  private final MerkleTree depositMerkleTree = new OptimizedMerkleTree(DEPOSIT_CONTRACT_TREE_DEPTH);\n+  private final NavigableMap<UnsignedLong, DepositWithIndex> depositNavigableMap = new TreeMap<>();\n+\n+  public void addDeposit(DepositWithIndex deposit) {\n+    depositNavigableMap.put(deposit.getIndex(), deposit);\n+    depositMerkleTree.add(deposit.getData().hash_tree_root());\n+  }\n+\n+  public SSZList<Deposit> getDeposits(BeaconState state) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff20c22e3f29abd7b6506609686605f022e5f432"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY0NjM0MQ==", "bodyText": "I agree, the only reason I did that was because the DepositProvider has a rather specific API. It only accepts through DepositsFromBlockEvents. For testing, it would be better to have a class that accepts through only deposits as well.", "url": "https://github.com/ConsenSys/teku/pull/2042#discussion_r434646341", "createdAt": "2020-06-03T15:16:18Z", "author": {"login": "cemozerr"}, "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/DepositMerkleTree.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.core;\n+\n+import static java.lang.StrictMath.toIntExact;\n+import static tech.pegasys.teku.util.config.Constants.DEPOSIT_CONTRACT_TREE_DEPTH;\n+import static tech.pegasys.teku.util.config.Constants.MAX_DEPOSITS;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.List;\n+import java.util.NavigableMap;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.datastructures.operations.Deposit;\n+import tech.pegasys.teku.datastructures.operations.DepositWithIndex;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.datastructures.util.MerkleTree;\n+import tech.pegasys.teku.datastructures.util.OptimizedMerkleTree;\n+import tech.pegasys.teku.ssz.SSZTypes.SSZList;\n+\n+public class DepositMerkleTree {\n+  private final MerkleTree depositMerkleTree = new OptimizedMerkleTree(DEPOSIT_CONTRACT_TREE_DEPTH);\n+  private final NavigableMap<UnsignedLong, DepositWithIndex> depositNavigableMap = new TreeMap<>();\n+\n+  public void addDeposit(DepositWithIndex deposit) {\n+    depositNavigableMap.put(deposit.getIndex(), deposit);\n+    depositMerkleTree.add(deposit.getData().hash_tree_root());\n+  }\n+\n+  public SSZList<Deposit> getDeposits(BeaconState state) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDIzOTM4OQ=="}, "originalCommit": {"oid": "ff20c22e3f29abd7b6506609686605f022e5f432"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNDk3NDMyOnYy", "diffSide": "RIGHT", "path": "ethereum/statetransition/src/testFixtures/java/tech/pegasys/teku/statetransition/BeaconChainUtil.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwMDo1NTozOVrOGeIpnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwMDo1NTozOVrOGeIpnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI1MjE4OA==", "bodyText": "Stray println.", "url": "https://github.com/ConsenSys/teku/pull/2042#discussion_r434252188", "createdAt": "2020-06-03T00:55:39Z", "author": {"login": "ajsutton"}, "path": "ethereum/statetransition/src/testFixtures/java/tech/pegasys/teku/statetransition/BeaconChainUtil.java", "diffHunk": "@@ -227,7 +269,30 @@ public void finalizeChainAtEpoch(final UnsignedLong epoch) throws Exception {\n               Attestation.class);\n       createAndImportBlockAtSlot(\n           recentChainData.getBestSlot().plus(UnsignedLong.ONE),\n-          Optional.of(currentSlotAssignments));\n+          Optional.of(currentSlotAssignments),\n+          Optional.empty(),\n+          Optional.empty(),\n+          Optional.empty());\n+    }\n+  }\n+\n+  public void setEth1DataOfChain(final Eth1Data eth1Data) throws Exception {\n+    long vote_count = 0;\n+    while (true) {\n+      System.out.println(vote_count);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff20c22e3f29abd7b6506609686605f022e5f432"}, "originalPosition": 145}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNDk4MDg2OnYy", "diffSide": "RIGHT", "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/gossip/topics/validation/VoluntaryExitValidator.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwMDo1OTozOVrOGeIthg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNjoxNDo1M1rOGfNlww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI1MzE5MA==", "bodyText": "We should modify verify_voluntary_exits to return a reason code rather than throwing an exception while we're making changes here.  Helps move us away from using exceptions to indicate validation failure which is an anti-pattern.", "url": "https://github.com/ConsenSys/teku/pull/2042#discussion_r434253190", "createdAt": "2020-06-03T00:59:39Z", "author": {"login": "ajsutton"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/gossip/topics/validation/VoluntaryExitValidator.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.networking.eth2.gossip.topics.validation;\n+\n+import static tech.pegasys.teku.core.BlockProcessorUtil.check_voluntary_exit;\n+import static tech.pegasys.teku.core.BlockProcessorUtil.verify_voluntary_exits;\n+import static tech.pegasys.teku.networking.eth2.gossip.topics.validation.ValidationResult.INVALID;\n+import static tech.pegasys.teku.networking.eth2.gossip.topics.validation.ValidationResult.VALID;\n+import static tech.pegasys.teku.util.config.Constants.VALID_VALIDATOR_SET_SIZE;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.Set;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import tech.pegasys.teku.bls.BLSSignatureVerifier;\n+import tech.pegasys.teku.datastructures.operations.SignedVoluntaryExit;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.ssz.SSZTypes.SSZList;\n+import tech.pegasys.teku.storage.client.RecentChainData;\n+import tech.pegasys.teku.util.collections.ConcurrentLimitedSet;\n+import tech.pegasys.teku.util.collections.LimitStrategy;\n+\n+public class VoluntaryExitValidator {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final RecentChainData recentChainData;\n+  private final Set<UnsignedLong> receivedValidExitSet =\n+      ConcurrentLimitedSet.create(\n+          VALID_VALIDATOR_SET_SIZE, LimitStrategy.DROP_LEAST_RECENTLY_ACCESSED);\n+\n+  public VoluntaryExitValidator(RecentChainData recentChainData) {\n+    this.recentChainData = recentChainData;\n+  }\n+\n+  public ValidationResult validate(SignedVoluntaryExit exit) {\n+    if (!isFirstValidExitForValidator(exit)) {\n+      LOG.trace(\"VoluntaryExitValidator: Exit is not the first one for the given validator.\");\n+      return INVALID;\n+    }\n+\n+    if (!passesProcessVoluntaryExitConditions(exit)) {\n+      return INVALID;\n+    }\n+\n+    if (receivedValidExitSet.add(exit.getMessage().getValidator_index())) {\n+      return VALID;\n+    } else {\n+      LOG.trace(\"VoluntaryExitValidator: Exit is not the first one for the given validator.\");\n+      return INVALID;\n+    }\n+  }\n+\n+  private boolean passesProcessVoluntaryExitConditions(SignedVoluntaryExit exit) {\n+    try {\n+      BeaconState state =\n+          recentChainData\n+              .getBestState()\n+              .orElseThrow(\n+                  () ->\n+                      new IllegalStateException(\n+                          \"Unable to get best state for voluntary exit processing\"));\n+      check_voluntary_exit(state, exit.getMessage());\n+      verify_voluntary_exits(state, SSZList.singleton(exit), BLSSignatureVerifier.SIMPLE);\n+    } catch (IllegalArgumentException | BLSSignatureVerifier.InvalidSignatureException e) {\n+      LOG.trace(\"VoluntaryExitValidator: Exit fails process voluntary exit conditions.\", e);\n+      return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff20c22e3f29abd7b6506609686605f022e5f432"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDcwNzc2MQ==", "bodyText": "I just did that refactoring for processing voluntary exits but to do that for the signature check, i.e. the verify_voluntary_exits seems like it might require a lot of work (due to it being tied into batch block signature verification). I should probably do that in another PR since this one's already getting pretty big.", "url": "https://github.com/ConsenSys/teku/pull/2042#discussion_r434707761", "createdAt": "2020-06-03T16:41:56Z", "author": {"login": "cemozerr"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/gossip/topics/validation/VoluntaryExitValidator.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.networking.eth2.gossip.topics.validation;\n+\n+import static tech.pegasys.teku.core.BlockProcessorUtil.check_voluntary_exit;\n+import static tech.pegasys.teku.core.BlockProcessorUtil.verify_voluntary_exits;\n+import static tech.pegasys.teku.networking.eth2.gossip.topics.validation.ValidationResult.INVALID;\n+import static tech.pegasys.teku.networking.eth2.gossip.topics.validation.ValidationResult.VALID;\n+import static tech.pegasys.teku.util.config.Constants.VALID_VALIDATOR_SET_SIZE;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.Set;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import tech.pegasys.teku.bls.BLSSignatureVerifier;\n+import tech.pegasys.teku.datastructures.operations.SignedVoluntaryExit;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.ssz.SSZTypes.SSZList;\n+import tech.pegasys.teku.storage.client.RecentChainData;\n+import tech.pegasys.teku.util.collections.ConcurrentLimitedSet;\n+import tech.pegasys.teku.util.collections.LimitStrategy;\n+\n+public class VoluntaryExitValidator {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final RecentChainData recentChainData;\n+  private final Set<UnsignedLong> receivedValidExitSet =\n+      ConcurrentLimitedSet.create(\n+          VALID_VALIDATOR_SET_SIZE, LimitStrategy.DROP_LEAST_RECENTLY_ACCESSED);\n+\n+  public VoluntaryExitValidator(RecentChainData recentChainData) {\n+    this.recentChainData = recentChainData;\n+  }\n+\n+  public ValidationResult validate(SignedVoluntaryExit exit) {\n+    if (!isFirstValidExitForValidator(exit)) {\n+      LOG.trace(\"VoluntaryExitValidator: Exit is not the first one for the given validator.\");\n+      return INVALID;\n+    }\n+\n+    if (!passesProcessVoluntaryExitConditions(exit)) {\n+      return INVALID;\n+    }\n+\n+    if (receivedValidExitSet.add(exit.getMessage().getValidator_index())) {\n+      return VALID;\n+    } else {\n+      LOG.trace(\"VoluntaryExitValidator: Exit is not the first one for the given validator.\");\n+      return INVALID;\n+    }\n+  }\n+\n+  private boolean passesProcessVoluntaryExitConditions(SignedVoluntaryExit exit) {\n+    try {\n+      BeaconState state =\n+          recentChainData\n+              .getBestState()\n+              .orElseThrow(\n+                  () ->\n+                      new IllegalStateException(\n+                          \"Unable to get best state for voluntary exit processing\"));\n+      check_voluntary_exit(state, exit.getMessage());\n+      verify_voluntary_exits(state, SSZList.singleton(exit), BLSSignatureVerifier.SIMPLE);\n+    } catch (IllegalArgumentException | BLSSignatureVerifier.InvalidSignatureException e) {\n+      LOG.trace(\"VoluntaryExitValidator: Exit fails process voluntary exit conditions.\", e);\n+      return false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI1MzE5MA=="}, "originalCommit": {"oid": "ff20c22e3f29abd7b6506609686605f022e5f432"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDkwMDIzNQ==", "bodyText": "I don't think it has to be split out into a whole separate class for the validations - the signature check would wind up just using BLSSignatureVerifier.verify instead of verifyAndThrow - BlockProcessorUtil is already converting the InvalidSignatureException to a BlockProcessingException so it would be an easy change for verify_voluntary_exits to wind up returning a boolean instead of throwing.", "url": "https://github.com/ConsenSys/teku/pull/2042#discussion_r434900235", "createdAt": "2020-06-03T22:50:57Z", "author": {"login": "ajsutton"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/gossip/topics/validation/VoluntaryExitValidator.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.networking.eth2.gossip.topics.validation;\n+\n+import static tech.pegasys.teku.core.BlockProcessorUtil.check_voluntary_exit;\n+import static tech.pegasys.teku.core.BlockProcessorUtil.verify_voluntary_exits;\n+import static tech.pegasys.teku.networking.eth2.gossip.topics.validation.ValidationResult.INVALID;\n+import static tech.pegasys.teku.networking.eth2.gossip.topics.validation.ValidationResult.VALID;\n+import static tech.pegasys.teku.util.config.Constants.VALID_VALIDATOR_SET_SIZE;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.Set;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import tech.pegasys.teku.bls.BLSSignatureVerifier;\n+import tech.pegasys.teku.datastructures.operations.SignedVoluntaryExit;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.ssz.SSZTypes.SSZList;\n+import tech.pegasys.teku.storage.client.RecentChainData;\n+import tech.pegasys.teku.util.collections.ConcurrentLimitedSet;\n+import tech.pegasys.teku.util.collections.LimitStrategy;\n+\n+public class VoluntaryExitValidator {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final RecentChainData recentChainData;\n+  private final Set<UnsignedLong> receivedValidExitSet =\n+      ConcurrentLimitedSet.create(\n+          VALID_VALIDATOR_SET_SIZE, LimitStrategy.DROP_LEAST_RECENTLY_ACCESSED);\n+\n+  public VoluntaryExitValidator(RecentChainData recentChainData) {\n+    this.recentChainData = recentChainData;\n+  }\n+\n+  public ValidationResult validate(SignedVoluntaryExit exit) {\n+    if (!isFirstValidExitForValidator(exit)) {\n+      LOG.trace(\"VoluntaryExitValidator: Exit is not the first one for the given validator.\");\n+      return INVALID;\n+    }\n+\n+    if (!passesProcessVoluntaryExitConditions(exit)) {\n+      return INVALID;\n+    }\n+\n+    if (receivedValidExitSet.add(exit.getMessage().getValidator_index())) {\n+      return VALID;\n+    } else {\n+      LOG.trace(\"VoluntaryExitValidator: Exit is not the first one for the given validator.\");\n+      return INVALID;\n+    }\n+  }\n+\n+  private boolean passesProcessVoluntaryExitConditions(SignedVoluntaryExit exit) {\n+    try {\n+      BeaconState state =\n+          recentChainData\n+              .getBestState()\n+              .orElseThrow(\n+                  () ->\n+                      new IllegalStateException(\n+                          \"Unable to get best state for voluntary exit processing\"));\n+      check_voluntary_exit(state, exit.getMessage());\n+      verify_voluntary_exits(state, SSZList.singleton(exit), BLSSignatureVerifier.SIMPLE);\n+    } catch (IllegalArgumentException | BLSSignatureVerifier.InvalidSignatureException e) {\n+      LOG.trace(\"VoluntaryExitValidator: Exit fails process voluntary exit conditions.\", e);\n+      return false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI1MzE5MA=="}, "originalCommit": {"oid": "ff20c22e3f29abd7b6506609686605f022e5f432"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM4MTY5OQ==", "bodyText": "Makes sense. Made the change.", "url": "https://github.com/ConsenSys/teku/pull/2042#discussion_r435381699", "createdAt": "2020-06-04T16:14:53Z", "author": {"login": "cemozerr"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/gossip/topics/validation/VoluntaryExitValidator.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.networking.eth2.gossip.topics.validation;\n+\n+import static tech.pegasys.teku.core.BlockProcessorUtil.check_voluntary_exit;\n+import static tech.pegasys.teku.core.BlockProcessorUtil.verify_voluntary_exits;\n+import static tech.pegasys.teku.networking.eth2.gossip.topics.validation.ValidationResult.INVALID;\n+import static tech.pegasys.teku.networking.eth2.gossip.topics.validation.ValidationResult.VALID;\n+import static tech.pegasys.teku.util.config.Constants.VALID_VALIDATOR_SET_SIZE;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.Set;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import tech.pegasys.teku.bls.BLSSignatureVerifier;\n+import tech.pegasys.teku.datastructures.operations.SignedVoluntaryExit;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.ssz.SSZTypes.SSZList;\n+import tech.pegasys.teku.storage.client.RecentChainData;\n+import tech.pegasys.teku.util.collections.ConcurrentLimitedSet;\n+import tech.pegasys.teku.util.collections.LimitStrategy;\n+\n+public class VoluntaryExitValidator {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final RecentChainData recentChainData;\n+  private final Set<UnsignedLong> receivedValidExitSet =\n+      ConcurrentLimitedSet.create(\n+          VALID_VALIDATOR_SET_SIZE, LimitStrategy.DROP_LEAST_RECENTLY_ACCESSED);\n+\n+  public VoluntaryExitValidator(RecentChainData recentChainData) {\n+    this.recentChainData = recentChainData;\n+  }\n+\n+  public ValidationResult validate(SignedVoluntaryExit exit) {\n+    if (!isFirstValidExitForValidator(exit)) {\n+      LOG.trace(\"VoluntaryExitValidator: Exit is not the first one for the given validator.\");\n+      return INVALID;\n+    }\n+\n+    if (!passesProcessVoluntaryExitConditions(exit)) {\n+      return INVALID;\n+    }\n+\n+    if (receivedValidExitSet.add(exit.getMessage().getValidator_index())) {\n+      return VALID;\n+    } else {\n+      LOG.trace(\"VoluntaryExitValidator: Exit is not the first one for the given validator.\");\n+      return INVALID;\n+    }\n+  }\n+\n+  private boolean passesProcessVoluntaryExitConditions(SignedVoluntaryExit exit) {\n+    try {\n+      BeaconState state =\n+          recentChainData\n+              .getBestState()\n+              .orElseThrow(\n+                  () ->\n+                      new IllegalStateException(\n+                          \"Unable to get best state for voluntary exit processing\"));\n+      check_voluntary_exit(state, exit.getMessage());\n+      verify_voluntary_exits(state, SSZList.singleton(exit), BLSSignatureVerifier.SIMPLE);\n+    } catch (IllegalArgumentException | BLSSignatureVerifier.InvalidSignatureException e) {\n+      LOG.trace(\"VoluntaryExitValidator: Exit fails process voluntary exit conditions.\", e);\n+      return false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI1MzE5MA=="}, "originalCommit": {"oid": "ff20c22e3f29abd7b6506609686605f022e5f432"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNDk4MTc3OnYy", "diffSide": "RIGHT", "path": "networking/eth2/src/test/java/tech/pegasys/teku/networking/eth2/gossip/topics/VoluntaryExitTopicHandlerTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwMTowMDowOVrOGeIuEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNToyMzoyNFrOGehBoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI1MzMyOA==", "bodyText": "invalidBlock?", "url": "https://github.com/ConsenSys/teku/pull/2042#discussion_r434253328", "createdAt": "2020-06-03T01:00:09Z", "author": {"login": "ajsutton"}, "path": "networking/eth2/src/test/java/tech/pegasys/teku/networking/eth2/gossip/topics/VoluntaryExitTopicHandlerTest.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Copyright 2019 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.networking.eth2.gossip.topics;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+import static tech.pegasys.teku.networking.eth2.gossip.topics.validation.ValidationResult.INVALID;\n+import static tech.pegasys.teku.networking.eth2.gossip.topics.validation.ValidationResult.VALID;\n+\n+import com.google.common.eventbus.EventBus;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import tech.pegasys.teku.core.VoluntaryExitGenerator;\n+import tech.pegasys.teku.datastructures.operations.SignedVoluntaryExit;\n+import tech.pegasys.teku.datastructures.state.ForkInfo;\n+import tech.pegasys.teku.datastructures.util.DataStructureUtil;\n+import tech.pegasys.teku.networking.eth2.gossip.encoding.GossipEncoding;\n+import tech.pegasys.teku.networking.eth2.gossip.topics.validation.VoluntaryExitValidator;\n+import tech.pegasys.teku.ssz.SSZTypes.Bytes4;\n+import tech.pegasys.teku.statetransition.BeaconChainUtil;\n+import tech.pegasys.teku.storage.client.MemoryOnlyRecentChainData;\n+import tech.pegasys.teku.storage.client.RecentChainData;\n+\n+public class VoluntaryExitTopicHandlerTest {\n+  private final DataStructureUtil dataStructureUtil = new DataStructureUtil();\n+  private final EventBus eventBus = mock(EventBus.class);\n+  private final GossipEncoding gossipEncoding = GossipEncoding.SSZ_SNAPPY;\n+  private final RecentChainData recentChainData = MemoryOnlyRecentChainData.create(eventBus);\n+  private final BeaconChainUtil beaconChainUtil = BeaconChainUtil.create(5, recentChainData);\n+\n+  private final VoluntaryExitGenerator exitGenerator =\n+      new VoluntaryExitGenerator(beaconChainUtil.getValidatorKeys());\n+  private final VoluntaryExitValidator validator = mock(VoluntaryExitValidator.class);\n+\n+  private VoluntaryExitTopicHandler topicHandler =\n+      new VoluntaryExitTopicHandler(gossipEncoding, dataStructureUtil.randomForkInfo(), validator);\n+\n+  @BeforeEach\n+  public void setup() {\n+    beaconChainUtil.initializeStorage();\n+  }\n+\n+  @Test\n+  public void handleMessage_validExit() {\n+    final SignedVoluntaryExit exit =\n+        exitGenerator.withEpoch(recentChainData.getBestState().orElseThrow(), 3, 3);\n+    when(validator.validate(exit)).thenReturn(VALID);\n+    Bytes serialized = gossipEncoding.encode(exit);\n+    final boolean result = topicHandler.handleMessage(serialized);\n+    assertThat(result).isEqualTo(true);\n+  }\n+\n+  @Test\n+  public void handleMessage_invalidExit() {\n+    final SignedVoluntaryExit exit =\n+        exitGenerator.withEpoch(recentChainData.getBestState().orElseThrow(), 3, 3);\n+    when(validator.validate(exit)).thenReturn(INVALID);\n+    Bytes serialized = gossipEncoding.encode(exit);\n+    final boolean result = topicHandler.handleMessage(serialized);\n+    assertThat(result).isEqualTo(false);\n+  }\n+\n+  @Test\n+  public void handleMessage_invalidBlock_invalidSSZ() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff20c22e3f29abd7b6506609686605f022e5f432"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY1MTU1Mg==", "bodyText": "removed.", "url": "https://github.com/ConsenSys/teku/pull/2042#discussion_r434651552", "createdAt": "2020-06-03T15:23:24Z", "author": {"login": "cemozerr"}, "path": "networking/eth2/src/test/java/tech/pegasys/teku/networking/eth2/gossip/topics/VoluntaryExitTopicHandlerTest.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Copyright 2019 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.networking.eth2.gossip.topics;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+import static tech.pegasys.teku.networking.eth2.gossip.topics.validation.ValidationResult.INVALID;\n+import static tech.pegasys.teku.networking.eth2.gossip.topics.validation.ValidationResult.VALID;\n+\n+import com.google.common.eventbus.EventBus;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import tech.pegasys.teku.core.VoluntaryExitGenerator;\n+import tech.pegasys.teku.datastructures.operations.SignedVoluntaryExit;\n+import tech.pegasys.teku.datastructures.state.ForkInfo;\n+import tech.pegasys.teku.datastructures.util.DataStructureUtil;\n+import tech.pegasys.teku.networking.eth2.gossip.encoding.GossipEncoding;\n+import tech.pegasys.teku.networking.eth2.gossip.topics.validation.VoluntaryExitValidator;\n+import tech.pegasys.teku.ssz.SSZTypes.Bytes4;\n+import tech.pegasys.teku.statetransition.BeaconChainUtil;\n+import tech.pegasys.teku.storage.client.MemoryOnlyRecentChainData;\n+import tech.pegasys.teku.storage.client.RecentChainData;\n+\n+public class VoluntaryExitTopicHandlerTest {\n+  private final DataStructureUtil dataStructureUtil = new DataStructureUtil();\n+  private final EventBus eventBus = mock(EventBus.class);\n+  private final GossipEncoding gossipEncoding = GossipEncoding.SSZ_SNAPPY;\n+  private final RecentChainData recentChainData = MemoryOnlyRecentChainData.create(eventBus);\n+  private final BeaconChainUtil beaconChainUtil = BeaconChainUtil.create(5, recentChainData);\n+\n+  private final VoluntaryExitGenerator exitGenerator =\n+      new VoluntaryExitGenerator(beaconChainUtil.getValidatorKeys());\n+  private final VoluntaryExitValidator validator = mock(VoluntaryExitValidator.class);\n+\n+  private VoluntaryExitTopicHandler topicHandler =\n+      new VoluntaryExitTopicHandler(gossipEncoding, dataStructureUtil.randomForkInfo(), validator);\n+\n+  @BeforeEach\n+  public void setup() {\n+    beaconChainUtil.initializeStorage();\n+  }\n+\n+  @Test\n+  public void handleMessage_validExit() {\n+    final SignedVoluntaryExit exit =\n+        exitGenerator.withEpoch(recentChainData.getBestState().orElseThrow(), 3, 3);\n+    when(validator.validate(exit)).thenReturn(VALID);\n+    Bytes serialized = gossipEncoding.encode(exit);\n+    final boolean result = topicHandler.handleMessage(serialized);\n+    assertThat(result).isEqualTo(true);\n+  }\n+\n+  @Test\n+  public void handleMessage_invalidExit() {\n+    final SignedVoluntaryExit exit =\n+        exitGenerator.withEpoch(recentChainData.getBestState().orElseThrow(), 3, 3);\n+    when(validator.validate(exit)).thenReturn(INVALID);\n+    Bytes serialized = gossipEncoding.encode(exit);\n+    final boolean result = topicHandler.handleMessage(serialized);\n+    assertThat(result).isEqualTo(false);\n+  }\n+\n+  @Test\n+  public void handleMessage_invalidBlock_invalidSSZ() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI1MzMyOA=="}, "originalCommit": {"oid": "ff20c22e3f29abd7b6506609686605f022e5f432"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNTA2MDczOnYy", "diffSide": "RIGHT", "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/signatures/Signer.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwMTo1MzowN1rOGeJfTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNToyMzowMFrOGehAcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI2NTkzMg==", "bodyText": "You already have the epoch, so this is always generating invalid signatures. :)", "url": "https://github.com/ConsenSys/teku/pull/2042#discussion_r434265932", "createdAt": "2020-06-03T01:53:07Z", "author": {"login": "ajsutton"}, "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/signatures/Signer.java", "diffHunk": "@@ -95,6 +96,18 @@ public Signer(final MessageSignerService signerService) {\n     return signerService.signAggregateAndProof(signingRoot);\n   }\n \n+  public SafeFuture<BLSSignature> signVoluntaryExit(\n+      final VoluntaryExit voluntaryExit, final ForkInfo forkInfo) {\n+    final Bytes domain =\n+        get_domain(\n+            Constants.DOMAIN_VOLUNTARY_EXIT,\n+            compute_epoch_at_slot(voluntaryExit.getEpoch()),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff20c22e3f29abd7b6506609686605f022e5f432"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY1MTE5NQ==", "bodyText": "Oops. Good catch.", "url": "https://github.com/ConsenSys/teku/pull/2042#discussion_r434651195", "createdAt": "2020-06-03T15:22:56Z", "author": {"login": "cemozerr"}, "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/signatures/Signer.java", "diffHunk": "@@ -95,6 +96,18 @@ public Signer(final MessageSignerService signerService) {\n     return signerService.signAggregateAndProof(signingRoot);\n   }\n \n+  public SafeFuture<BLSSignature> signVoluntaryExit(\n+      final VoluntaryExit voluntaryExit, final ForkInfo forkInfo) {\n+    final Bytes domain =\n+        get_domain(\n+            Constants.DOMAIN_VOLUNTARY_EXIT,\n+            compute_epoch_at_slot(voluntaryExit.getEpoch()),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI2NTkzMg=="}, "originalCommit": {"oid": "ff20c22e3f29abd7b6506609686605f022e5f432"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY1MTI0OQ==", "bodyText": "Fixed.", "url": "https://github.com/ConsenSys/teku/pull/2042#discussion_r434651249", "createdAt": "2020-06-03T15:23:00Z", "author": {"login": "cemozerr"}, "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/signatures/Signer.java", "diffHunk": "@@ -95,6 +96,18 @@ public Signer(final MessageSignerService signerService) {\n     return signerService.signAggregateAndProof(signingRoot);\n   }\n \n+  public SafeFuture<BLSSignature> signVoluntaryExit(\n+      final VoluntaryExit voluntaryExit, final ForkInfo forkInfo) {\n+    final Bytes domain =\n+        get_domain(\n+            Constants.DOMAIN_VOLUNTARY_EXIT,\n+            compute_epoch_at_slot(voluntaryExit.getEpoch()),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI2NTkzMg=="}, "originalCommit": {"oid": "ff20c22e3f29abd7b6506609686605f022e5f432"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNTA2MzA4OnYy", "diffSide": "RIGHT", "path": "networking/eth2/src/test/java/tech/pegasys/teku/networking/eth2/gossip/topics/validation/VoluntaryExitValidatorTest.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwMTo1NTowNFrOGeJg3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNToyMTo0NVrOGeg88w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI2NjMzMg==", "bodyText": "You can do this without messing around with additional deposits and Eth1Data by just adding a validator to the genesis state that hasn't deposited enough to be activated:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              @Test\n          \n          \n            \n              public void shouldReturnInvalidForExitOfInactiveValidator() throws Exception {\n          \n          \n            \n                TestDepositGenerator testDepositGenerator =\n          \n          \n            \n                    new TestDepositGenerator(VALIDATOR_KEYS.subList(0, 20));\n          \n          \n            \n                List<Deposit> deposits = testDepositGenerator.getDeposits(10, 20, 20);\n          \n          \n            \n                initializeStorage(recentChainData, VALIDATOR_KEYS.subList(0, 10));\n          \n          \n            \n            \n          \n          \n            \n                beaconChainUtil.setEth1DataOfChain(\n          \n          \n            \n                    new Eth1Data(testDepositGenerator.getRoot(), UnsignedLong.valueOf(20), Bytes32.ZERO));\n          \n          \n            \n                beaconChainUtil.createAndImportBlockAtSlotWithDeposits(UnsignedLong.valueOf(6), deposits);\n          \n          \n            \n            \n          \n          \n            \n                SignedVoluntaryExit exit =\n          \n          \n            \n                    voluntaryExitGenerator.valid(recentChainData.getBestState().orElseThrow(), 15);\n          \n          \n            \n                assertThat(voluntaryExitValidator.validate(exit)).isEqualTo(INVALID);\n          \n          \n            \n              }\n          \n          \n            \n              @Test\n          \n          \n            \n              public void shouldReturnInvalidForExitOfInactiveValidator() throws Exception {\n          \n          \n            \n                final DepositGenerator depositGenerator = new DepositGenerator(true);\n          \n          \n            \n                final List<DepositData> initialDepositData =\n          \n          \n            \n                    new MockStartDepositGenerator(depositGenerator)\n          \n          \n            \n                        .createDeposits(VALIDATOR_KEYS.subList(0, 10));\n          \n          \n            \n                // Add an inactive validator (they haven't deposited enough to become a validator)\n          \n          \n            \n                final BLSKeyPair inactiveValidatorKeyPair = VALIDATOR_KEYS.get(10);\n          \n          \n            \n                initialDepositData.add(depositGenerator.createDepositData(inactiveValidatorKeyPair, UnsignedLong.ONE, inactiveValidatorKeyPair.getPublicKey()));\n          \n          \n            \n                final BeaconState genesisState = new MockStartBeaconStateGenerator()\n          \n          \n            \n                    .createInitialBeaconState(UnsignedLong.ZERO, initialDepositData);\n          \n          \n            \n                recentChainData.initializeFromGenesis(genesisState);\n          \n          \n            \n            \n          \n          \n            \n                SignedVoluntaryExit exit =\n          \n          \n            \n                    voluntaryExitGenerator.valid(recentChainData.getBestState().orElseThrow(), 10, false);\n          \n          \n            \n                assertThat(voluntaryExitValidator.validate(exit)).isEqualTo(INVALID);\n          \n          \n            \n              }", "url": "https://github.com/ConsenSys/teku/pull/2042#discussion_r434266332", "createdAt": "2020-06-03T01:55:04Z", "author": {"login": "ajsutton"}, "path": "networking/eth2/src/test/java/tech/pegasys/teku/networking/eth2/gossip/topics/validation/VoluntaryExitValidatorTest.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.networking.eth2.gossip.topics.validation;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_epoch_at_slot;\n+import static tech.pegasys.teku.networking.eth2.gossip.topics.validation.ValidationResult.INVALID;\n+import static tech.pegasys.teku.networking.eth2.gossip.topics.validation.ValidationResult.VALID;\n+import static tech.pegasys.teku.statetransition.BeaconChainUtil.initializeStorage;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.List;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import tech.pegasys.teku.bls.BLSKeyPair;\n+import tech.pegasys.teku.core.TestDepositGenerator;\n+import tech.pegasys.teku.core.VoluntaryExitGenerator;\n+import tech.pegasys.teku.datastructures.blocks.Eth1Data;\n+import tech.pegasys.teku.datastructures.operations.Deposit;\n+import tech.pegasys.teku.datastructures.operations.SignedVoluntaryExit;\n+import tech.pegasys.teku.datastructures.util.MockStartValidatorKeyPairFactory;\n+import tech.pegasys.teku.statetransition.BeaconChainUtil;\n+import tech.pegasys.teku.storage.client.MemoryOnlyRecentChainData;\n+import tech.pegasys.teku.storage.client.RecentChainData;\n+import tech.pegasys.teku.util.config.Constants;\n+\n+public class VoluntaryExitValidatorTest {\n+  private static final List<BLSKeyPair> VALIDATOR_KEYS =\n+      new MockStartValidatorKeyPairFactory().generateKeyPairs(0, 25);\n+  private final VoluntaryExitGenerator voluntaryExitGenerator =\n+      new VoluntaryExitGenerator(VALIDATOR_KEYS);\n+\n+  private RecentChainData recentChainData;\n+  private BeaconChainUtil beaconChainUtil;\n+  private VoluntaryExitValidator voluntaryExitValidator;\n+\n+  @BeforeAll\n+  static void beforeAll() {\n+    Constants.SLOTS_PER_EPOCH = 2;\n+    Constants.EPOCHS_PER_ETH1_VOTING_PERIOD = 1;\n+    Constants.PERSISTENT_COMMITTEE_PERIOD = 2;\n+  }\n+\n+  @AfterAll\n+  static void afterAll() {\n+    Constants.setConstants(\"minimal\");\n+  }\n+\n+  @BeforeEach\n+  void beforeEach() {\n+    recentChainData = MemoryOnlyRecentChainData.create(new EventBus());\n+    beaconChainUtil = BeaconChainUtil.create(recentChainData, VALIDATOR_KEYS, true);\n+    voluntaryExitValidator = new VoluntaryExitValidator(recentChainData);\n+  }\n+\n+  @Test\n+  public void shouldReturnValidForValidVoluntaryExit() throws Exception {\n+    beaconChainUtil.initializeStorage();\n+    beaconChainUtil.createAndImportBlockAtSlot(6);\n+    SignedVoluntaryExit exit =\n+        voluntaryExitGenerator.valid(recentChainData.getBestState().orElseThrow(), 3);\n+    assertThat(voluntaryExitValidator.validate(exit)).isEqualTo(VALID);\n+  }\n+\n+  @Test\n+  public void shouldReturnInvalidForExitsAfterTheFirstForValidator() throws Exception {\n+    beaconChainUtil.initializeStorage();\n+    beaconChainUtil.createAndImportBlockAtSlot(6);\n+    SignedVoluntaryExit exit1 =\n+        voluntaryExitGenerator.valid(recentChainData.getBestState().orElseThrow(), 3);\n+\n+    SignedVoluntaryExit exit2 =\n+        voluntaryExitGenerator.valid(recentChainData.getBestState().orElseThrow(), 3);\n+\n+    SignedVoluntaryExit exit3 =\n+        voluntaryExitGenerator.valid(recentChainData.getBestState().orElseThrow(), 3);\n+\n+    assertThat(voluntaryExitValidator.validate(exit1)).isEqualTo(VALID);\n+    assertThat(voluntaryExitValidator.validate(exit2)).isEqualTo(INVALID);\n+    assertThat(voluntaryExitValidator.validate(exit3)).isEqualTo(INVALID);\n+  }\n+\n+  @Test\n+  public void shouldReturnInvalidForExitWithInvalidSignature() throws Exception {\n+    beaconChainUtil.initializeStorage();\n+    beaconChainUtil.createAndImportBlockAtSlot(6);\n+    SignedVoluntaryExit exit1 =\n+        voluntaryExitGenerator.withInvalidSignature(\n+            recentChainData.getBestState().orElseThrow(), 3);\n+    assertThat(voluntaryExitValidator.validate(exit1)).isEqualTo(INVALID);\n+  }\n+\n+  @Test\n+  public void shouldReturnInvalidForExitOfInactiveValidator() throws Exception {\n+    TestDepositGenerator testDepositGenerator =\n+        new TestDepositGenerator(VALIDATOR_KEYS.subList(0, 20));\n+    List<Deposit> deposits = testDepositGenerator.getDeposits(10, 20, 20);\n+    initializeStorage(recentChainData, VALIDATOR_KEYS.subList(0, 10));\n+\n+    beaconChainUtil.setEth1DataOfChain(\n+        new Eth1Data(testDepositGenerator.getRoot(), UnsignedLong.valueOf(20), Bytes32.ZERO));\n+    beaconChainUtil.createAndImportBlockAtSlotWithDeposits(UnsignedLong.valueOf(6), deposits);\n+\n+    SignedVoluntaryExit exit =\n+        voluntaryExitGenerator.valid(recentChainData.getBestState().orElseThrow(), 15);\n+    assertThat(voluntaryExitValidator.validate(exit)).isEqualTo(INVALID);\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff20c22e3f29abd7b6506609686605f022e5f432"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMwOTI4MA==", "bodyText": "Do you think I should keep setEth1DataOfChain as a utility method, or remove it since this PR won't require it anymore?", "url": "https://github.com/ConsenSys/teku/pull/2042#discussion_r434309280", "createdAt": "2020-06-03T05:03:19Z", "author": {"login": "cemozerr"}, "path": "networking/eth2/src/test/java/tech/pegasys/teku/networking/eth2/gossip/topics/validation/VoluntaryExitValidatorTest.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.networking.eth2.gossip.topics.validation;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_epoch_at_slot;\n+import static tech.pegasys.teku.networking.eth2.gossip.topics.validation.ValidationResult.INVALID;\n+import static tech.pegasys.teku.networking.eth2.gossip.topics.validation.ValidationResult.VALID;\n+import static tech.pegasys.teku.statetransition.BeaconChainUtil.initializeStorage;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.List;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import tech.pegasys.teku.bls.BLSKeyPair;\n+import tech.pegasys.teku.core.TestDepositGenerator;\n+import tech.pegasys.teku.core.VoluntaryExitGenerator;\n+import tech.pegasys.teku.datastructures.blocks.Eth1Data;\n+import tech.pegasys.teku.datastructures.operations.Deposit;\n+import tech.pegasys.teku.datastructures.operations.SignedVoluntaryExit;\n+import tech.pegasys.teku.datastructures.util.MockStartValidatorKeyPairFactory;\n+import tech.pegasys.teku.statetransition.BeaconChainUtil;\n+import tech.pegasys.teku.storage.client.MemoryOnlyRecentChainData;\n+import tech.pegasys.teku.storage.client.RecentChainData;\n+import tech.pegasys.teku.util.config.Constants;\n+\n+public class VoluntaryExitValidatorTest {\n+  private static final List<BLSKeyPair> VALIDATOR_KEYS =\n+      new MockStartValidatorKeyPairFactory().generateKeyPairs(0, 25);\n+  private final VoluntaryExitGenerator voluntaryExitGenerator =\n+      new VoluntaryExitGenerator(VALIDATOR_KEYS);\n+\n+  private RecentChainData recentChainData;\n+  private BeaconChainUtil beaconChainUtil;\n+  private VoluntaryExitValidator voluntaryExitValidator;\n+\n+  @BeforeAll\n+  static void beforeAll() {\n+    Constants.SLOTS_PER_EPOCH = 2;\n+    Constants.EPOCHS_PER_ETH1_VOTING_PERIOD = 1;\n+    Constants.PERSISTENT_COMMITTEE_PERIOD = 2;\n+  }\n+\n+  @AfterAll\n+  static void afterAll() {\n+    Constants.setConstants(\"minimal\");\n+  }\n+\n+  @BeforeEach\n+  void beforeEach() {\n+    recentChainData = MemoryOnlyRecentChainData.create(new EventBus());\n+    beaconChainUtil = BeaconChainUtil.create(recentChainData, VALIDATOR_KEYS, true);\n+    voluntaryExitValidator = new VoluntaryExitValidator(recentChainData);\n+  }\n+\n+  @Test\n+  public void shouldReturnValidForValidVoluntaryExit() throws Exception {\n+    beaconChainUtil.initializeStorage();\n+    beaconChainUtil.createAndImportBlockAtSlot(6);\n+    SignedVoluntaryExit exit =\n+        voluntaryExitGenerator.valid(recentChainData.getBestState().orElseThrow(), 3);\n+    assertThat(voluntaryExitValidator.validate(exit)).isEqualTo(VALID);\n+  }\n+\n+  @Test\n+  public void shouldReturnInvalidForExitsAfterTheFirstForValidator() throws Exception {\n+    beaconChainUtil.initializeStorage();\n+    beaconChainUtil.createAndImportBlockAtSlot(6);\n+    SignedVoluntaryExit exit1 =\n+        voluntaryExitGenerator.valid(recentChainData.getBestState().orElseThrow(), 3);\n+\n+    SignedVoluntaryExit exit2 =\n+        voluntaryExitGenerator.valid(recentChainData.getBestState().orElseThrow(), 3);\n+\n+    SignedVoluntaryExit exit3 =\n+        voluntaryExitGenerator.valid(recentChainData.getBestState().orElseThrow(), 3);\n+\n+    assertThat(voluntaryExitValidator.validate(exit1)).isEqualTo(VALID);\n+    assertThat(voluntaryExitValidator.validate(exit2)).isEqualTo(INVALID);\n+    assertThat(voluntaryExitValidator.validate(exit3)).isEqualTo(INVALID);\n+  }\n+\n+  @Test\n+  public void shouldReturnInvalidForExitWithInvalidSignature() throws Exception {\n+    beaconChainUtil.initializeStorage();\n+    beaconChainUtil.createAndImportBlockAtSlot(6);\n+    SignedVoluntaryExit exit1 =\n+        voluntaryExitGenerator.withInvalidSignature(\n+            recentChainData.getBestState().orElseThrow(), 3);\n+    assertThat(voluntaryExitValidator.validate(exit1)).isEqualTo(INVALID);\n+  }\n+\n+  @Test\n+  public void shouldReturnInvalidForExitOfInactiveValidator() throws Exception {\n+    TestDepositGenerator testDepositGenerator =\n+        new TestDepositGenerator(VALIDATOR_KEYS.subList(0, 20));\n+    List<Deposit> deposits = testDepositGenerator.getDeposits(10, 20, 20);\n+    initializeStorage(recentChainData, VALIDATOR_KEYS.subList(0, 10));\n+\n+    beaconChainUtil.setEth1DataOfChain(\n+        new Eth1Data(testDepositGenerator.getRoot(), UnsignedLong.valueOf(20), Bytes32.ZERO));\n+    beaconChainUtil.createAndImportBlockAtSlotWithDeposits(UnsignedLong.valueOf(6), deposits);\n+\n+    SignedVoluntaryExit exit =\n+        voluntaryExitGenerator.valid(recentChainData.getBestState().orElseThrow(), 15);\n+    assertThat(voluntaryExitValidator.validate(exit)).isEqualTo(INVALID);\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI2NjMzMg=="}, "originalCommit": {"oid": "ff20c22e3f29abd7b6506609686605f022e5f432"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMxMDQ5NA==", "bodyText": "Probably take it out of this PR but keep it around locally - you're going to want it when fixing the bug about using the wrong Eth1Data when selecting deposits to go in the block. :)", "url": "https://github.com/ConsenSys/teku/pull/2042#discussion_r434310494", "createdAt": "2020-06-03T05:08:22Z", "author": {"login": "ajsutton"}, "path": "networking/eth2/src/test/java/tech/pegasys/teku/networking/eth2/gossip/topics/validation/VoluntaryExitValidatorTest.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.networking.eth2.gossip.topics.validation;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_epoch_at_slot;\n+import static tech.pegasys.teku.networking.eth2.gossip.topics.validation.ValidationResult.INVALID;\n+import static tech.pegasys.teku.networking.eth2.gossip.topics.validation.ValidationResult.VALID;\n+import static tech.pegasys.teku.statetransition.BeaconChainUtil.initializeStorage;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.List;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import tech.pegasys.teku.bls.BLSKeyPair;\n+import tech.pegasys.teku.core.TestDepositGenerator;\n+import tech.pegasys.teku.core.VoluntaryExitGenerator;\n+import tech.pegasys.teku.datastructures.blocks.Eth1Data;\n+import tech.pegasys.teku.datastructures.operations.Deposit;\n+import tech.pegasys.teku.datastructures.operations.SignedVoluntaryExit;\n+import tech.pegasys.teku.datastructures.util.MockStartValidatorKeyPairFactory;\n+import tech.pegasys.teku.statetransition.BeaconChainUtil;\n+import tech.pegasys.teku.storage.client.MemoryOnlyRecentChainData;\n+import tech.pegasys.teku.storage.client.RecentChainData;\n+import tech.pegasys.teku.util.config.Constants;\n+\n+public class VoluntaryExitValidatorTest {\n+  private static final List<BLSKeyPair> VALIDATOR_KEYS =\n+      new MockStartValidatorKeyPairFactory().generateKeyPairs(0, 25);\n+  private final VoluntaryExitGenerator voluntaryExitGenerator =\n+      new VoluntaryExitGenerator(VALIDATOR_KEYS);\n+\n+  private RecentChainData recentChainData;\n+  private BeaconChainUtil beaconChainUtil;\n+  private VoluntaryExitValidator voluntaryExitValidator;\n+\n+  @BeforeAll\n+  static void beforeAll() {\n+    Constants.SLOTS_PER_EPOCH = 2;\n+    Constants.EPOCHS_PER_ETH1_VOTING_PERIOD = 1;\n+    Constants.PERSISTENT_COMMITTEE_PERIOD = 2;\n+  }\n+\n+  @AfterAll\n+  static void afterAll() {\n+    Constants.setConstants(\"minimal\");\n+  }\n+\n+  @BeforeEach\n+  void beforeEach() {\n+    recentChainData = MemoryOnlyRecentChainData.create(new EventBus());\n+    beaconChainUtil = BeaconChainUtil.create(recentChainData, VALIDATOR_KEYS, true);\n+    voluntaryExitValidator = new VoluntaryExitValidator(recentChainData);\n+  }\n+\n+  @Test\n+  public void shouldReturnValidForValidVoluntaryExit() throws Exception {\n+    beaconChainUtil.initializeStorage();\n+    beaconChainUtil.createAndImportBlockAtSlot(6);\n+    SignedVoluntaryExit exit =\n+        voluntaryExitGenerator.valid(recentChainData.getBestState().orElseThrow(), 3);\n+    assertThat(voluntaryExitValidator.validate(exit)).isEqualTo(VALID);\n+  }\n+\n+  @Test\n+  public void shouldReturnInvalidForExitsAfterTheFirstForValidator() throws Exception {\n+    beaconChainUtil.initializeStorage();\n+    beaconChainUtil.createAndImportBlockAtSlot(6);\n+    SignedVoluntaryExit exit1 =\n+        voluntaryExitGenerator.valid(recentChainData.getBestState().orElseThrow(), 3);\n+\n+    SignedVoluntaryExit exit2 =\n+        voluntaryExitGenerator.valid(recentChainData.getBestState().orElseThrow(), 3);\n+\n+    SignedVoluntaryExit exit3 =\n+        voluntaryExitGenerator.valid(recentChainData.getBestState().orElseThrow(), 3);\n+\n+    assertThat(voluntaryExitValidator.validate(exit1)).isEqualTo(VALID);\n+    assertThat(voluntaryExitValidator.validate(exit2)).isEqualTo(INVALID);\n+    assertThat(voluntaryExitValidator.validate(exit3)).isEqualTo(INVALID);\n+  }\n+\n+  @Test\n+  public void shouldReturnInvalidForExitWithInvalidSignature() throws Exception {\n+    beaconChainUtil.initializeStorage();\n+    beaconChainUtil.createAndImportBlockAtSlot(6);\n+    SignedVoluntaryExit exit1 =\n+        voluntaryExitGenerator.withInvalidSignature(\n+            recentChainData.getBestState().orElseThrow(), 3);\n+    assertThat(voluntaryExitValidator.validate(exit1)).isEqualTo(INVALID);\n+  }\n+\n+  @Test\n+  public void shouldReturnInvalidForExitOfInactiveValidator() throws Exception {\n+    TestDepositGenerator testDepositGenerator =\n+        new TestDepositGenerator(VALIDATOR_KEYS.subList(0, 20));\n+    List<Deposit> deposits = testDepositGenerator.getDeposits(10, 20, 20);\n+    initializeStorage(recentChainData, VALIDATOR_KEYS.subList(0, 10));\n+\n+    beaconChainUtil.setEth1DataOfChain(\n+        new Eth1Data(testDepositGenerator.getRoot(), UnsignedLong.valueOf(20), Bytes32.ZERO));\n+    beaconChainUtil.createAndImportBlockAtSlotWithDeposits(UnsignedLong.valueOf(6), deposits);\n+\n+    SignedVoluntaryExit exit =\n+        voluntaryExitGenerator.valid(recentChainData.getBestState().orElseThrow(), 15);\n+    assertThat(voluntaryExitValidator.validate(exit)).isEqualTo(INVALID);\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI2NjMzMg=="}, "originalCommit": {"oid": "ff20c22e3f29abd7b6506609686605f022e5f432"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY0OTc2OA==", "bodyText": "Yep, this approach is way smarter and simpler btw.", "url": "https://github.com/ConsenSys/teku/pull/2042#discussion_r434649768", "createdAt": "2020-06-03T15:20:55Z", "author": {"login": "cemozerr"}, "path": "networking/eth2/src/test/java/tech/pegasys/teku/networking/eth2/gossip/topics/validation/VoluntaryExitValidatorTest.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.networking.eth2.gossip.topics.validation;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_epoch_at_slot;\n+import static tech.pegasys.teku.networking.eth2.gossip.topics.validation.ValidationResult.INVALID;\n+import static tech.pegasys.teku.networking.eth2.gossip.topics.validation.ValidationResult.VALID;\n+import static tech.pegasys.teku.statetransition.BeaconChainUtil.initializeStorage;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.List;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import tech.pegasys.teku.bls.BLSKeyPair;\n+import tech.pegasys.teku.core.TestDepositGenerator;\n+import tech.pegasys.teku.core.VoluntaryExitGenerator;\n+import tech.pegasys.teku.datastructures.blocks.Eth1Data;\n+import tech.pegasys.teku.datastructures.operations.Deposit;\n+import tech.pegasys.teku.datastructures.operations.SignedVoluntaryExit;\n+import tech.pegasys.teku.datastructures.util.MockStartValidatorKeyPairFactory;\n+import tech.pegasys.teku.statetransition.BeaconChainUtil;\n+import tech.pegasys.teku.storage.client.MemoryOnlyRecentChainData;\n+import tech.pegasys.teku.storage.client.RecentChainData;\n+import tech.pegasys.teku.util.config.Constants;\n+\n+public class VoluntaryExitValidatorTest {\n+  private static final List<BLSKeyPair> VALIDATOR_KEYS =\n+      new MockStartValidatorKeyPairFactory().generateKeyPairs(0, 25);\n+  private final VoluntaryExitGenerator voluntaryExitGenerator =\n+      new VoluntaryExitGenerator(VALIDATOR_KEYS);\n+\n+  private RecentChainData recentChainData;\n+  private BeaconChainUtil beaconChainUtil;\n+  private VoluntaryExitValidator voluntaryExitValidator;\n+\n+  @BeforeAll\n+  static void beforeAll() {\n+    Constants.SLOTS_PER_EPOCH = 2;\n+    Constants.EPOCHS_PER_ETH1_VOTING_PERIOD = 1;\n+    Constants.PERSISTENT_COMMITTEE_PERIOD = 2;\n+  }\n+\n+  @AfterAll\n+  static void afterAll() {\n+    Constants.setConstants(\"minimal\");\n+  }\n+\n+  @BeforeEach\n+  void beforeEach() {\n+    recentChainData = MemoryOnlyRecentChainData.create(new EventBus());\n+    beaconChainUtil = BeaconChainUtil.create(recentChainData, VALIDATOR_KEYS, true);\n+    voluntaryExitValidator = new VoluntaryExitValidator(recentChainData);\n+  }\n+\n+  @Test\n+  public void shouldReturnValidForValidVoluntaryExit() throws Exception {\n+    beaconChainUtil.initializeStorage();\n+    beaconChainUtil.createAndImportBlockAtSlot(6);\n+    SignedVoluntaryExit exit =\n+        voluntaryExitGenerator.valid(recentChainData.getBestState().orElseThrow(), 3);\n+    assertThat(voluntaryExitValidator.validate(exit)).isEqualTo(VALID);\n+  }\n+\n+  @Test\n+  public void shouldReturnInvalidForExitsAfterTheFirstForValidator() throws Exception {\n+    beaconChainUtil.initializeStorage();\n+    beaconChainUtil.createAndImportBlockAtSlot(6);\n+    SignedVoluntaryExit exit1 =\n+        voluntaryExitGenerator.valid(recentChainData.getBestState().orElseThrow(), 3);\n+\n+    SignedVoluntaryExit exit2 =\n+        voluntaryExitGenerator.valid(recentChainData.getBestState().orElseThrow(), 3);\n+\n+    SignedVoluntaryExit exit3 =\n+        voluntaryExitGenerator.valid(recentChainData.getBestState().orElseThrow(), 3);\n+\n+    assertThat(voluntaryExitValidator.validate(exit1)).isEqualTo(VALID);\n+    assertThat(voluntaryExitValidator.validate(exit2)).isEqualTo(INVALID);\n+    assertThat(voluntaryExitValidator.validate(exit3)).isEqualTo(INVALID);\n+  }\n+\n+  @Test\n+  public void shouldReturnInvalidForExitWithInvalidSignature() throws Exception {\n+    beaconChainUtil.initializeStorage();\n+    beaconChainUtil.createAndImportBlockAtSlot(6);\n+    SignedVoluntaryExit exit1 =\n+        voluntaryExitGenerator.withInvalidSignature(\n+            recentChainData.getBestState().orElseThrow(), 3);\n+    assertThat(voluntaryExitValidator.validate(exit1)).isEqualTo(INVALID);\n+  }\n+\n+  @Test\n+  public void shouldReturnInvalidForExitOfInactiveValidator() throws Exception {\n+    TestDepositGenerator testDepositGenerator =\n+        new TestDepositGenerator(VALIDATOR_KEYS.subList(0, 20));\n+    List<Deposit> deposits = testDepositGenerator.getDeposits(10, 20, 20);\n+    initializeStorage(recentChainData, VALIDATOR_KEYS.subList(0, 10));\n+\n+    beaconChainUtil.setEth1DataOfChain(\n+        new Eth1Data(testDepositGenerator.getRoot(), UnsignedLong.valueOf(20), Bytes32.ZERO));\n+    beaconChainUtil.createAndImportBlockAtSlotWithDeposits(UnsignedLong.valueOf(6), deposits);\n+\n+    SignedVoluntaryExit exit =\n+        voluntaryExitGenerator.valid(recentChainData.getBestState().orElseThrow(), 15);\n+    assertThat(voluntaryExitValidator.validate(exit)).isEqualTo(INVALID);\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI2NjMzMg=="}, "originalCommit": {"oid": "ff20c22e3f29abd7b6506609686605f022e5f432"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY1MDM1NQ==", "bodyText": "Done.", "url": "https://github.com/ConsenSys/teku/pull/2042#discussion_r434650355", "createdAt": "2020-06-03T15:21:45Z", "author": {"login": "cemozerr"}, "path": "networking/eth2/src/test/java/tech/pegasys/teku/networking/eth2/gossip/topics/validation/VoluntaryExitValidatorTest.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.networking.eth2.gossip.topics.validation;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_epoch_at_slot;\n+import static tech.pegasys.teku.networking.eth2.gossip.topics.validation.ValidationResult.INVALID;\n+import static tech.pegasys.teku.networking.eth2.gossip.topics.validation.ValidationResult.VALID;\n+import static tech.pegasys.teku.statetransition.BeaconChainUtil.initializeStorage;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.List;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import tech.pegasys.teku.bls.BLSKeyPair;\n+import tech.pegasys.teku.core.TestDepositGenerator;\n+import tech.pegasys.teku.core.VoluntaryExitGenerator;\n+import tech.pegasys.teku.datastructures.blocks.Eth1Data;\n+import tech.pegasys.teku.datastructures.operations.Deposit;\n+import tech.pegasys.teku.datastructures.operations.SignedVoluntaryExit;\n+import tech.pegasys.teku.datastructures.util.MockStartValidatorKeyPairFactory;\n+import tech.pegasys.teku.statetransition.BeaconChainUtil;\n+import tech.pegasys.teku.storage.client.MemoryOnlyRecentChainData;\n+import tech.pegasys.teku.storage.client.RecentChainData;\n+import tech.pegasys.teku.util.config.Constants;\n+\n+public class VoluntaryExitValidatorTest {\n+  private static final List<BLSKeyPair> VALIDATOR_KEYS =\n+      new MockStartValidatorKeyPairFactory().generateKeyPairs(0, 25);\n+  private final VoluntaryExitGenerator voluntaryExitGenerator =\n+      new VoluntaryExitGenerator(VALIDATOR_KEYS);\n+\n+  private RecentChainData recentChainData;\n+  private BeaconChainUtil beaconChainUtil;\n+  private VoluntaryExitValidator voluntaryExitValidator;\n+\n+  @BeforeAll\n+  static void beforeAll() {\n+    Constants.SLOTS_PER_EPOCH = 2;\n+    Constants.EPOCHS_PER_ETH1_VOTING_PERIOD = 1;\n+    Constants.PERSISTENT_COMMITTEE_PERIOD = 2;\n+  }\n+\n+  @AfterAll\n+  static void afterAll() {\n+    Constants.setConstants(\"minimal\");\n+  }\n+\n+  @BeforeEach\n+  void beforeEach() {\n+    recentChainData = MemoryOnlyRecentChainData.create(new EventBus());\n+    beaconChainUtil = BeaconChainUtil.create(recentChainData, VALIDATOR_KEYS, true);\n+    voluntaryExitValidator = new VoluntaryExitValidator(recentChainData);\n+  }\n+\n+  @Test\n+  public void shouldReturnValidForValidVoluntaryExit() throws Exception {\n+    beaconChainUtil.initializeStorage();\n+    beaconChainUtil.createAndImportBlockAtSlot(6);\n+    SignedVoluntaryExit exit =\n+        voluntaryExitGenerator.valid(recentChainData.getBestState().orElseThrow(), 3);\n+    assertThat(voluntaryExitValidator.validate(exit)).isEqualTo(VALID);\n+  }\n+\n+  @Test\n+  public void shouldReturnInvalidForExitsAfterTheFirstForValidator() throws Exception {\n+    beaconChainUtil.initializeStorage();\n+    beaconChainUtil.createAndImportBlockAtSlot(6);\n+    SignedVoluntaryExit exit1 =\n+        voluntaryExitGenerator.valid(recentChainData.getBestState().orElseThrow(), 3);\n+\n+    SignedVoluntaryExit exit2 =\n+        voluntaryExitGenerator.valid(recentChainData.getBestState().orElseThrow(), 3);\n+\n+    SignedVoluntaryExit exit3 =\n+        voluntaryExitGenerator.valid(recentChainData.getBestState().orElseThrow(), 3);\n+\n+    assertThat(voluntaryExitValidator.validate(exit1)).isEqualTo(VALID);\n+    assertThat(voluntaryExitValidator.validate(exit2)).isEqualTo(INVALID);\n+    assertThat(voluntaryExitValidator.validate(exit3)).isEqualTo(INVALID);\n+  }\n+\n+  @Test\n+  public void shouldReturnInvalidForExitWithInvalidSignature() throws Exception {\n+    beaconChainUtil.initializeStorage();\n+    beaconChainUtil.createAndImportBlockAtSlot(6);\n+    SignedVoluntaryExit exit1 =\n+        voluntaryExitGenerator.withInvalidSignature(\n+            recentChainData.getBestState().orElseThrow(), 3);\n+    assertThat(voluntaryExitValidator.validate(exit1)).isEqualTo(INVALID);\n+  }\n+\n+  @Test\n+  public void shouldReturnInvalidForExitOfInactiveValidator() throws Exception {\n+    TestDepositGenerator testDepositGenerator =\n+        new TestDepositGenerator(VALIDATOR_KEYS.subList(0, 20));\n+    List<Deposit> deposits = testDepositGenerator.getDeposits(10, 20, 20);\n+    initializeStorage(recentChainData, VALIDATOR_KEYS.subList(0, 10));\n+\n+    beaconChainUtil.setEth1DataOfChain(\n+        new Eth1Data(testDepositGenerator.getRoot(), UnsignedLong.valueOf(20), Bytes32.ZERO));\n+    beaconChainUtil.createAndImportBlockAtSlotWithDeposits(UnsignedLong.valueOf(6), deposits);\n+\n+    SignedVoluntaryExit exit =\n+        voluntaryExitGenerator.valid(recentChainData.getBestState().orElseThrow(), 15);\n+    assertThat(voluntaryExitValidator.validate(exit)).isEqualTo(INVALID);\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI2NjMzMg=="}, "originalCommit": {"oid": "ff20c22e3f29abd7b6506609686605f022e5f432"}, "originalPosition": 122}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3695, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}