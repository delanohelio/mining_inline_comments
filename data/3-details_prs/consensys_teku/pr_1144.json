{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcyODg3OTU2", "number": 1144, "title": "Add disk querying to beacon/block rest API", "bodyText": "PR Description\nPreviously our beacon/block API was unable to return information on blocks that were pruned from memory but kept on the disk, so this PR fixes that.", "createdAt": "2020-02-09T23:31:07Z", "url": "https://github.com/ConsenSys/teku/pull/1144", "merged": true, "mergeCommit": {"oid": "85adc589eda5bd3442b8c0d6dd1d5d58601fdbd3"}, "closed": true, "closedAt": "2020-02-10T02:30:11Z", "author": {"login": "cemozerr"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcCxJIPgH2gAyMzcyODg3OTU2OjY0MjAzMGRhMjgzMWNiZjIxNzM1NWI3ZjlhNWEyNWNjMzM1N2I4MmE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcCzmtNAH2gAyMzcyODg3OTU2OmIwMmYwNDM0ZWE5ZWUwODU5MWMzYjYwNTcwZWYxZGQ0ZTUyYzcyZDc=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "642030da2831cbf217355b7f9a5a25cc3357b82a", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/642030da2831cbf217355b7f9a5a25cc3357b82a", "committedDate": "2020-02-09T23:29:15Z", "message": "Add disk querying to beacon/block rest API"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "28214045ae9d3c7240c10c0def7793adaf3b8b7d", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/28214045ae9d3c7240c10c0def7793adaf3b8b7d", "committedDate": "2020-02-09T23:31:47Z", "message": "Merge branch 'master' into diskQueryingForRestAPI"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU1NjQ2MjAw", "url": "https://github.com/ConsenSys/teku/pull/1144#pullrequestreview-355646200", "createdAt": "2020-02-10T00:00:32Z", "commit": {"oid": "28214045ae9d3c7240c10c0def7793adaf3b8b7d"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQwMDowMDozMlrOFnX0uA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQwMDoxMTowMFrOFnX4YA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjgyOTExMg==", "bodyText": "We should be passing in the HistoricalChainData client, not creating it in the constructor here.  Possibly should even be passing HistoricalChainData into BeaconRestApi rather than event bus.", "url": "https://github.com/ConsenSys/teku/pull/1144#discussion_r376829112", "createdAt": "2020-02-10T00:00:32Z", "author": {"login": "ajsutton"}, "path": "data/beaconrestapi/src/main/java/tech/pegasys/artemis/beaconrestapi/beaconhandlers/BeaconBlockHandler.java", "diffHunk": "@@ -15,60 +15,79 @@\n \n import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.compute_start_slot_at_epoch;\n \n+import com.google.common.eventbus.EventBus;\n import com.google.common.primitives.UnsignedLong;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n import java.util.Optional;\n+import org.apache.commons.lang3.tuple.Pair;\n import org.apache.tuweni.bytes.Bytes32;\n import tech.pegasys.artemis.beaconrestapi.handlerinterfaces.BeaconRestApiHandler;\n import tech.pegasys.artemis.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n import tech.pegasys.artemis.storage.ChainStorageClient;\n+import tech.pegasys.artemis.storage.HistoricalChainData;\n \n public class BeaconBlockHandler implements BeaconRestApiHandler {\n \n   private final ChainStorageClient client;\n+  private final HistoricalChainData historicalChainData;\n \n-  public BeaconBlockHandler(ChainStorageClient client) {\n+  public BeaconBlockHandler(ChainStorageClient client, EventBus eventBus) {\n     this.client = client;\n+    this.historicalChainData = new HistoricalChainData(eventBus);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28214045ae9d3c7240c10c0def7793adaf3b8b7d"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjgyOTk2MA==", "bodyText": "return getBlockBySlot(slot)\n  .map(block -> ImmutableMap.of(\"block\", block, \"blockRoot\", block.hash_tree_root()))\n  .orElse(null);", "url": "https://github.com/ConsenSys/teku/pull/1144#discussion_r376829960", "createdAt": "2020-02-10T00:10:20Z", "author": {"login": "ajsutton"}, "path": "data/beaconrestapi/src/main/java/tech/pegasys/artemis/beaconrestapi/beaconhandlers/BeaconBlockHandler.java", "diffHunk": "@@ -15,60 +15,79 @@\n \n import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.compute_start_slot_at_epoch;\n \n+import com.google.common.eventbus.EventBus;\n import com.google.common.primitives.UnsignedLong;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n import java.util.Optional;\n+import org.apache.commons.lang3.tuple.Pair;\n import org.apache.tuweni.bytes.Bytes32;\n import tech.pegasys.artemis.beaconrestapi.handlerinterfaces.BeaconRestApiHandler;\n import tech.pegasys.artemis.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n import tech.pegasys.artemis.storage.ChainStorageClient;\n+import tech.pegasys.artemis.storage.HistoricalChainData;\n \n public class BeaconBlockHandler implements BeaconRestApiHandler {\n \n   private final ChainStorageClient client;\n+  private final HistoricalChainData historicalChainData;\n \n-  public BeaconBlockHandler(ChainStorageClient client) {\n+  public BeaconBlockHandler(ChainStorageClient client, EventBus eventBus) {\n     this.client = client;\n+    this.historicalChainData = new HistoricalChainData(eventBus);\n   }\n \n   @Override\n   public String getPath() {\n-    return \"/beacon/block/\";\n+    return \"/beacon/block\";\n   }\n \n   @Override\n   public Object handleRequest(RequestParams param) {\n     Map<String, List<String>> queryParamMap = param.getQueryParamMap();\n-    Map<String, Object> jsonObject = new HashMap<>();\n-    BeaconBlock block;\n-    Bytes32 blockRoot;\n     if (queryParamMap.containsKey(\"root\")) {\n       Bytes32 root = Bytes32.fromHexString(param.getQueryParam(\"root\"));\n       return client.getStore() != null ? client.getStore().getBlock(root) : null;\n-    } else if (queryParamMap.containsKey(\"epoch\")) {\n-      UnsignedLong epoch = UnsignedLong.valueOf(param.getQueryParam(\"epoch\"));\n-      Optional<Bytes32> blockRootAtSlot =\n-          client.getBlockRootBySlot(compute_start_slot_at_epoch(epoch));\n-      blockRoot = blockRootAtSlot.orElse(null);\n-      block =\n-          client.getStore() != null && blockRootAtSlot.isPresent()\n-              ? client.getStore().getBlock(blockRootAtSlot.get())\n-              : null;\n+    }\n+\n+    UnsignedLong slot;\n+    if (queryParamMap.containsKey(\"epoch\")) {\n+      slot = compute_start_slot_at_epoch(UnsignedLong.valueOf(param.getQueryParam(\"epoch\")));\n     } else if (queryParamMap.containsKey(\"slot\")) {\n-      UnsignedLong slot = UnsignedLong.valueOf(param.getQueryParam(\"slot\"));\n-      Optional<Bytes32> blockRootAtSlot = client.getBlockRootBySlot(slot);\n-      blockRoot = blockRootAtSlot.orElse(null);\n-      block =\n-          client.getStore() != null && blockRootAtSlot.isPresent()\n-              ? client.getStore().getBlock(blockRootAtSlot.get())\n-              : null;\n+      slot = UnsignedLong.valueOf(param.getQueryParam(\"slot\"));\n     } else {\n       return null;\n     }\n-    jsonObject.put(\"block\", block);\n-    jsonObject.put(\"blockRoot\", blockRoot.toHexString());\n+\n+    Optional<Pair<BeaconBlock, Bytes32>> blockAndRoot = getBlockBySlot(slot);\n+    if (blockAndRoot.isEmpty()) {\n+      return null;\n+    }\n+\n+    Map<String, Object> jsonObject = new HashMap<>();\n+    jsonObject.put(\"blockRoot\", blockAndRoot.get().getRight().toHexString());\n+    jsonObject.put(\"block\", blockAndRoot.get().getLeft());\n+\n     return jsonObject;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28214045ae9d3c7240c10c0def7793adaf3b8b7d"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjgzMDA0OA==", "bodyText": "This can just return Optional<BeaconBlock> since the root is just calculated by calling block.hash_tree_root() anyway.", "url": "https://github.com/ConsenSys/teku/pull/1144#discussion_r376830048", "createdAt": "2020-02-10T00:11:00Z", "author": {"login": "ajsutton"}, "path": "data/beaconrestapi/src/main/java/tech/pegasys/artemis/beaconrestapi/beaconhandlers/BeaconBlockHandler.java", "diffHunk": "@@ -15,60 +15,79 @@\n \n import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.compute_start_slot_at_epoch;\n \n+import com.google.common.eventbus.EventBus;\n import com.google.common.primitives.UnsignedLong;\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n import java.util.Optional;\n+import org.apache.commons.lang3.tuple.Pair;\n import org.apache.tuweni.bytes.Bytes32;\n import tech.pegasys.artemis.beaconrestapi.handlerinterfaces.BeaconRestApiHandler;\n import tech.pegasys.artemis.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n import tech.pegasys.artemis.storage.ChainStorageClient;\n+import tech.pegasys.artemis.storage.HistoricalChainData;\n \n public class BeaconBlockHandler implements BeaconRestApiHandler {\n \n   private final ChainStorageClient client;\n+  private final HistoricalChainData historicalChainData;\n \n-  public BeaconBlockHandler(ChainStorageClient client) {\n+  public BeaconBlockHandler(ChainStorageClient client, EventBus eventBus) {\n     this.client = client;\n+    this.historicalChainData = new HistoricalChainData(eventBus);\n   }\n \n   @Override\n   public String getPath() {\n-    return \"/beacon/block/\";\n+    return \"/beacon/block\";\n   }\n \n   @Override\n   public Object handleRequest(RequestParams param) {\n     Map<String, List<String>> queryParamMap = param.getQueryParamMap();\n-    Map<String, Object> jsonObject = new HashMap<>();\n-    BeaconBlock block;\n-    Bytes32 blockRoot;\n     if (queryParamMap.containsKey(\"root\")) {\n       Bytes32 root = Bytes32.fromHexString(param.getQueryParam(\"root\"));\n       return client.getStore() != null ? client.getStore().getBlock(root) : null;\n-    } else if (queryParamMap.containsKey(\"epoch\")) {\n-      UnsignedLong epoch = UnsignedLong.valueOf(param.getQueryParam(\"epoch\"));\n-      Optional<Bytes32> blockRootAtSlot =\n-          client.getBlockRootBySlot(compute_start_slot_at_epoch(epoch));\n-      blockRoot = blockRootAtSlot.orElse(null);\n-      block =\n-          client.getStore() != null && blockRootAtSlot.isPresent()\n-              ? client.getStore().getBlock(blockRootAtSlot.get())\n-              : null;\n+    }\n+\n+    UnsignedLong slot;\n+    if (queryParamMap.containsKey(\"epoch\")) {\n+      slot = compute_start_slot_at_epoch(UnsignedLong.valueOf(param.getQueryParam(\"epoch\")));\n     } else if (queryParamMap.containsKey(\"slot\")) {\n-      UnsignedLong slot = UnsignedLong.valueOf(param.getQueryParam(\"slot\"));\n-      Optional<Bytes32> blockRootAtSlot = client.getBlockRootBySlot(slot);\n-      blockRoot = blockRootAtSlot.orElse(null);\n-      block =\n-          client.getStore() != null && blockRootAtSlot.isPresent()\n-              ? client.getStore().getBlock(blockRootAtSlot.get())\n-              : null;\n+      slot = UnsignedLong.valueOf(param.getQueryParam(\"slot\"));\n     } else {\n       return null;\n     }\n-    jsonObject.put(\"block\", block);\n-    jsonObject.put(\"blockRoot\", blockRoot.toHexString());\n+\n+    Optional<Pair<BeaconBlock, Bytes32>> blockAndRoot = getBlockBySlot(slot);\n+    if (blockAndRoot.isEmpty()) {\n+      return null;\n+    }\n+\n+    Map<String, Object> jsonObject = new HashMap<>();\n+    jsonObject.put(\"blockRoot\", blockAndRoot.get().getRight().toHexString());\n+    jsonObject.put(\"block\", blockAndRoot.get().getLeft());\n+\n     return jsonObject;\n   }\n+\n+  private Optional<Pair<BeaconBlock, Bytes32>> getBlockBySlot(UnsignedLong slot) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28214045ae9d3c7240c10c0def7793adaf3b8b7d"}, "originalPosition": 85}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "38c4105d72521a4ee9cda7486103bb848758bfc0", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/38c4105d72521a4ee9cda7486103bb848758bfc0", "committedDate": "2020-02-10T02:03:29Z", "message": "Resolve comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU1NjYxMTA0", "url": "https://github.com/ConsenSys/teku/pull/1144#pullrequestreview-355661104", "createdAt": "2020-02-10T02:05:47Z", "commit": {"oid": "38c4105d72521a4ee9cda7486103bb848758bfc0"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "620997d9723d4884c788e6e8b53e4e5c2e0e2c8f", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/620997d9723d4884c788e6e8b53e4e5c2e0e2c8f", "committedDate": "2020-02-10T02:06:36Z", "message": "Run spotless"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5264171f442821a3c33c6856c32dd2496494c85b", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/5264171f442821a3c33c6856c32dd2496494c85b", "committedDate": "2020-02-10T02:18:50Z", "message": "Quick fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b02f0434ea9ee08591c3b60570ef1dd4e52c72d7", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/b02f0434ea9ee08591c3b60570ef1dd4e52c72d7", "committedDate": "2020-02-10T02:21:22Z", "message": "Run spotless"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4287, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}