{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ4NzAzNjIx", "number": 2349, "title": "Maintain a minimum number of randomly selected peers", "bodyText": "PR Description\nRather than selecting all peers based on their score, maintain a minimum number of randomly selected peers. This has two key benefits:\n\nprovides sybil resistance as randomly selected peers must be ones we've selected, and which are not affected by the scoring system\nimproves connectivity for nodes which are not running validators and so aren't subscribed to any subnets. Previously these would also be the first peers to be dropped but now at least have a chance of being randomly selected and preserved.\n\nFixed Issue(s)\nfixes #2332\nDocumentation\n\n I thought about documentation and added the documentation label to this PR if updates are required.", "createdAt": "2020-07-14T07:35:27Z", "url": "https://github.com/ConsenSys/teku/pull/2349", "merged": true, "mergeCommit": {"oid": "c4230e96f10772fcf69460af9cfa32ea9746698c"}, "closed": true, "closedAt": "2020-07-14T23:28:28Z", "author": {"login": "ajsutton"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc0w9E9AH2gAyNDQ4NzAzNjIxOmU2ZTQ4NWMxOTA5MDE0MTgwNTE0MzlhMWNjN2VkZmE2NmEwZGI1NzU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc0-bcXAH2gAyNDQ4NzAzNjIxOmNhNGY2MGM2OWMwZDZjNTE0MGJiZDdmMzhjNWVkMDhhZjAyYjgzZWU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "e6e485c190901418051439a1cc7edfa66a0db575", "author": {"user": {"login": "ajsutton", "name": "Adrian Sutton"}}, "url": "https://github.com/ConsenSys/teku/commit/e6e485c190901418051439a1cc7edfa66a0db575", "committedDate": "2020-07-14T07:32:18Z", "message": "Maintain a minimum number of randomly selected peers instead of selecting all peers based on score."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d81ece30cca7a22ae420295c2e481fd1a5ca744c", "author": {"user": {"login": "ajsutton", "name": "Adrian Sutton"}}, "url": "https://github.com/ConsenSys/teku/commit/d81ece30cca7a22ae420295c2e481fd1a5ca744c", "committedDate": "2020-07-14T07:53:17Z", "message": "Fix errorprone."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c479fac235ce01cbbfbcf25742aee2e3ecc3e239", "author": {"user": {"login": "ajsutton", "name": "Adrian Sutton"}}, "url": "https://github.com/ConsenSys/teku/commit/c479fac235ce01cbbfbcf25742aee2e3ecc3e239", "committedDate": "2020-07-14T09:01:38Z", "message": "Fix test."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "08949cbbeeb137986b721b336ec2a7040a6e62ec", "author": {"user": {"login": "ajsutton", "name": "Adrian Sutton"}}, "url": "https://github.com/ConsenSys/teku/commit/08949cbbeeb137986b721b336ec2a7040a6e62ec", "committedDate": "2020-07-14T09:03:11Z", "message": "Merge branch 'master' of github.com:PegaSysEng/teku into connect-random-peers"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3OTU3Mzk5", "url": "https://github.com/ConsenSys/teku/pull/2349#pullrequestreview-447957399", "createdAt": "2020-07-14T09:49:49Z", "commit": {"oid": "08949cbbeeb137986b721b336ec2a7040a6e62ec"}, "state": "APPROVED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQwOTo0OTo1MFrOGxMgIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNFQxMDoxNjo1NFrOGxNZLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDIzODI0MA==", "bodyText": "if candidates.get() is not heavy, may be makes sense to remove this if", "url": "https://github.com/ConsenSys/teku/pull/2349#discussion_r454238240", "createdAt": "2020-07-14T09:49:50Z", "author": {"login": "Nashatyrev"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/peers/Eth2PeerSelectionStrategy.java", "diffHunk": "@@ -38,54 +47,149 @@\n   private final TargetPeerRange targetPeerCountRange;\n   private final PeerSubnetSubscriptions.Factory peerSubnetSubscriptionsFactory;\n   private final ReputationManager reputationManager;\n+  private final Shuffler shuffler;\n \n   public Eth2PeerSelectionStrategy(\n       final TargetPeerRange targetPeerCountRange,\n       final PeerSubnetSubscriptions.Factory peerSubnetSubscriptionsFactory,\n-      final ReputationManager reputationManager) {\n+      final ReputationManager reputationManager,\n+      final Shuffler shuffler) {\n     this.targetPeerCountRange = targetPeerCountRange;\n     this.peerSubnetSubscriptionsFactory = peerSubnetSubscriptionsFactory;\n     this.reputationManager = reputationManager;\n+    this.shuffler = shuffler;\n   }\n \n   @Override\n   public List<PeerAddress> selectPeersToConnect(\n-      final P2PNetwork<?> network, final Supplier<List<DiscoveryPeer>> candidates) {\n+      final P2PNetwork<?> network,\n+      final PeerSources peerSources,\n+      final Supplier<List<DiscoveryPeer>> candidates) {\n     final PeerSubnetSubscriptions peerSubnetSubscriptions =\n         peerSubnetSubscriptionsFactory.create(network);\n     final int peersRequiredForPeerCount =\n         targetPeerCountRange.getPeersToAdd(network.getPeerCount());\n+    final int randomlySelectedPeerCount = getCurrentRandomlySelectedPeerCount(network, peerSources);\n+    final int randomlySelectedPeersToAdd =\n+        targetPeerCountRange.getRandomlySelectedPeersToAdd(randomlySelectedPeerCount);\n+\n     final int peersRequiredForSubnets = peerSubnetSubscriptions.getSubscribersRequired();\n-    final int maxAttempts = Math.max(peersRequiredForPeerCount, peersRequiredForSubnets);\n-    LOG.trace(\"Connecting to up to {} known peers\", maxAttempts);\n-    if (maxAttempts == 0) {\n+    final int scoreBasedPeersToAdd =\n+        Math.max(peersRequiredForPeerCount - randomlySelectedPeerCount, peersRequiredForSubnets);\n+    LOG.trace(\n+        \"Connecting to up to {} known peers\", scoreBasedPeersToAdd + randomlySelectedPeersToAdd);\n+    if (scoreBasedPeersToAdd == 0 && randomlySelectedPeersToAdd == 0) {\n       return emptyList();\n     }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "08949cbbeeb137986b721b336ec2a7040a6e62ec"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI0MjM0OA==", "bodyText": "I'd better do something like\nList<RandomPeers> randomPeers = \n     selectRandomPeers(network, peerSources, randomlySelectedPeersToAdd, allCandidatePeers));\nallCandidatePeers.removeAll(randomPeers);\n... to keep the functions cleaner and avoid implicit allCandidatePeers modification inside selectAndRemoveRandomPeers()", "url": "https://github.com/ConsenSys/teku/pull/2349#discussion_r454242348", "createdAt": "2020-07-14T09:57:12Z", "author": {"login": "Nashatyrev"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/peers/Eth2PeerSelectionStrategy.java", "diffHunk": "@@ -38,54 +47,149 @@\n   private final TargetPeerRange targetPeerCountRange;\n   private final PeerSubnetSubscriptions.Factory peerSubnetSubscriptionsFactory;\n   private final ReputationManager reputationManager;\n+  private final Shuffler shuffler;\n \n   public Eth2PeerSelectionStrategy(\n       final TargetPeerRange targetPeerCountRange,\n       final PeerSubnetSubscriptions.Factory peerSubnetSubscriptionsFactory,\n-      final ReputationManager reputationManager) {\n+      final ReputationManager reputationManager,\n+      final Shuffler shuffler) {\n     this.targetPeerCountRange = targetPeerCountRange;\n     this.peerSubnetSubscriptionsFactory = peerSubnetSubscriptionsFactory;\n     this.reputationManager = reputationManager;\n+    this.shuffler = shuffler;\n   }\n \n   @Override\n   public List<PeerAddress> selectPeersToConnect(\n-      final P2PNetwork<?> network, final Supplier<List<DiscoveryPeer>> candidates) {\n+      final P2PNetwork<?> network,\n+      final PeerSources peerSources,\n+      final Supplier<List<DiscoveryPeer>> candidates) {\n     final PeerSubnetSubscriptions peerSubnetSubscriptions =\n         peerSubnetSubscriptionsFactory.create(network);\n     final int peersRequiredForPeerCount =\n         targetPeerCountRange.getPeersToAdd(network.getPeerCount());\n+    final int randomlySelectedPeerCount = getCurrentRandomlySelectedPeerCount(network, peerSources);\n+    final int randomlySelectedPeersToAdd =\n+        targetPeerCountRange.getRandomlySelectedPeersToAdd(randomlySelectedPeerCount);\n+\n     final int peersRequiredForSubnets = peerSubnetSubscriptions.getSubscribersRequired();\n-    final int maxAttempts = Math.max(peersRequiredForPeerCount, peersRequiredForSubnets);\n-    LOG.trace(\"Connecting to up to {} known peers\", maxAttempts);\n-    if (maxAttempts == 0) {\n+    final int scoreBasedPeersToAdd =\n+        Math.max(peersRequiredForPeerCount - randomlySelectedPeerCount, peersRequiredForSubnets);\n+    LOG.trace(\n+        \"Connecting to up to {} known peers\", scoreBasedPeersToAdd + randomlySelectedPeersToAdd);\n+    if (scoreBasedPeersToAdd == 0 && randomlySelectedPeersToAdd == 0) {\n       return emptyList();\n     }\n+\n+    final List<DiscoveryPeer> allCandidatePeers = new ArrayList<>(candidates.get());\n+    final List<PeerAddress> selectedPeers = new ArrayList<>();\n+\n+    if (randomlySelectedPeersToAdd > 0) {\n+      selectedPeers.addAll(\n+          selectAndRemoveRandomPeers(\n+              network, peerSources, randomlySelectedPeersToAdd, allCandidatePeers));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "08949cbbeeb137986b721b336ec2a7040a6e62ec"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI0NDk0OA==", "bodyText": "Why not collect() here?", "url": "https://github.com/ConsenSys/teku/pull/2349#discussion_r454244948", "createdAt": "2020-07-14T10:01:50Z", "author": {"login": "Nashatyrev"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/peers/Eth2PeerSelectionStrategy.java", "diffHunk": "@@ -38,54 +47,149 @@\n   private final TargetPeerRange targetPeerCountRange;\n   private final PeerSubnetSubscriptions.Factory peerSubnetSubscriptionsFactory;\n   private final ReputationManager reputationManager;\n+  private final Shuffler shuffler;\n \n   public Eth2PeerSelectionStrategy(\n       final TargetPeerRange targetPeerCountRange,\n       final PeerSubnetSubscriptions.Factory peerSubnetSubscriptionsFactory,\n-      final ReputationManager reputationManager) {\n+      final ReputationManager reputationManager,\n+      final Shuffler shuffler) {\n     this.targetPeerCountRange = targetPeerCountRange;\n     this.peerSubnetSubscriptionsFactory = peerSubnetSubscriptionsFactory;\n     this.reputationManager = reputationManager;\n+    this.shuffler = shuffler;\n   }\n \n   @Override\n   public List<PeerAddress> selectPeersToConnect(\n-      final P2PNetwork<?> network, final Supplier<List<DiscoveryPeer>> candidates) {\n+      final P2PNetwork<?> network,\n+      final PeerSources peerSources,\n+      final Supplier<List<DiscoveryPeer>> candidates) {\n     final PeerSubnetSubscriptions peerSubnetSubscriptions =\n         peerSubnetSubscriptionsFactory.create(network);\n     final int peersRequiredForPeerCount =\n         targetPeerCountRange.getPeersToAdd(network.getPeerCount());\n+    final int randomlySelectedPeerCount = getCurrentRandomlySelectedPeerCount(network, peerSources);\n+    final int randomlySelectedPeersToAdd =\n+        targetPeerCountRange.getRandomlySelectedPeersToAdd(randomlySelectedPeerCount);\n+\n     final int peersRequiredForSubnets = peerSubnetSubscriptions.getSubscribersRequired();\n-    final int maxAttempts = Math.max(peersRequiredForPeerCount, peersRequiredForSubnets);\n-    LOG.trace(\"Connecting to up to {} known peers\", maxAttempts);\n-    if (maxAttempts == 0) {\n+    final int scoreBasedPeersToAdd =\n+        Math.max(peersRequiredForPeerCount - randomlySelectedPeerCount, peersRequiredForSubnets);\n+    LOG.trace(\n+        \"Connecting to up to {} known peers\", scoreBasedPeersToAdd + randomlySelectedPeersToAdd);\n+    if (scoreBasedPeersToAdd == 0 && randomlySelectedPeersToAdd == 0) {\n       return emptyList();\n     }\n+\n+    final List<DiscoveryPeer> allCandidatePeers = new ArrayList<>(candidates.get());\n+    final List<PeerAddress> selectedPeers = new ArrayList<>();\n+\n+    if (randomlySelectedPeersToAdd > 0) {\n+      selectedPeers.addAll(\n+          selectAndRemoveRandomPeers(\n+              network, peerSources, randomlySelectedPeersToAdd, allCandidatePeers));\n+    }\n+\n+    if (scoreBasedPeersToAdd > 0) {\n+      selectedPeers.addAll(\n+          selectPeersByScore(\n+              network, peerSubnetSubscriptions, scoreBasedPeersToAdd, allCandidatePeers));\n+    }\n+    return unmodifiableList(selectedPeers); // Unmodifiable to make errorprone happy\n+  }\n+\n+  private List<PeerAddress> selectAndRemoveRandomPeers(\n+      final P2PNetwork<?> network,\n+      final PeerSources peerSources,\n+      final int randomlySelectedPeersToAdd,\n+      final List<DiscoveryPeer> allCandidatePeers) {\n+    final List<PeerAddress> selectedPeers = new ArrayList<>();\n+    shuffler.shuffle(allCandidatePeers);\n+    while (!allCandidatePeers.isEmpty() && selectedPeers.size() < randomlySelectedPeersToAdd) {\n+      final DiscoveryPeer candidate = allCandidatePeers.remove(0);\n+      checkCandidate(candidate, network)\n+          .ifPresent(\n+              peerAddress -> {\n+                peerSources.recordPeerSource(peerAddress.getId(), RANDOMLY_SELECTED);\n+                selectedPeers.add(peerAddress);\n+              });\n+    }\n+    return selectedPeers;\n+  }\n+\n+  private List<PeerAddress> selectPeersByScore(\n+      final P2PNetwork<?> network,\n+      final PeerSubnetSubscriptions peerSubnetSubscriptions,\n+      final int scoreBasedPeersToAdd,\n+      final List<DiscoveryPeer> allCandidatePeers) {\n+    final List<PeerAddress> selectedPeers = new ArrayList<>();\n     final PeerScorer peerScorer = peerSubnetSubscriptions.createScorer();\n-    return candidates.get().stream()\n+    allCandidatePeers.stream()\n         .sorted(\n             Comparator.comparing((Function<DiscoveryPeer, Integer>) peerScorer::scoreCandidatePeer)\n                 .reversed())\n-        .map(network::createPeerAddress)\n+        .flatMap(candidate -> checkCandidate(candidate, network).stream())\n+        .limit(scoreBasedPeersToAdd)\n+        .forEach(selectedPeers::add);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "08949cbbeeb137986b721b336ec2a7040a6e62ec"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI0NzA4Nw==", "bodyText": "Am I missing the place where we record peer as SELECTED_BY_SCORE?\npeerSources.recordPeerSource(peer, SELECTED_BY_SCORE);", "url": "https://github.com/ConsenSys/teku/pull/2349#discussion_r454247087", "createdAt": "2020-07-14T10:05:53Z", "author": {"login": "Nashatyrev"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/peers/Eth2PeerSelectionStrategy.java", "diffHunk": "@@ -38,54 +47,149 @@\n   private final TargetPeerRange targetPeerCountRange;\n   private final PeerSubnetSubscriptions.Factory peerSubnetSubscriptionsFactory;\n   private final ReputationManager reputationManager;\n+  private final Shuffler shuffler;\n \n   public Eth2PeerSelectionStrategy(\n       final TargetPeerRange targetPeerCountRange,\n       final PeerSubnetSubscriptions.Factory peerSubnetSubscriptionsFactory,\n-      final ReputationManager reputationManager) {\n+      final ReputationManager reputationManager,\n+      final Shuffler shuffler) {\n     this.targetPeerCountRange = targetPeerCountRange;\n     this.peerSubnetSubscriptionsFactory = peerSubnetSubscriptionsFactory;\n     this.reputationManager = reputationManager;\n+    this.shuffler = shuffler;\n   }\n \n   @Override\n   public List<PeerAddress> selectPeersToConnect(\n-      final P2PNetwork<?> network, final Supplier<List<DiscoveryPeer>> candidates) {\n+      final P2PNetwork<?> network,\n+      final PeerSources peerSources,\n+      final Supplier<List<DiscoveryPeer>> candidates) {\n     final PeerSubnetSubscriptions peerSubnetSubscriptions =\n         peerSubnetSubscriptionsFactory.create(network);\n     final int peersRequiredForPeerCount =\n         targetPeerCountRange.getPeersToAdd(network.getPeerCount());\n+    final int randomlySelectedPeerCount = getCurrentRandomlySelectedPeerCount(network, peerSources);\n+    final int randomlySelectedPeersToAdd =\n+        targetPeerCountRange.getRandomlySelectedPeersToAdd(randomlySelectedPeerCount);\n+\n     final int peersRequiredForSubnets = peerSubnetSubscriptions.getSubscribersRequired();\n-    final int maxAttempts = Math.max(peersRequiredForPeerCount, peersRequiredForSubnets);\n-    LOG.trace(\"Connecting to up to {} known peers\", maxAttempts);\n-    if (maxAttempts == 0) {\n+    final int scoreBasedPeersToAdd =\n+        Math.max(peersRequiredForPeerCount - randomlySelectedPeerCount, peersRequiredForSubnets);\n+    LOG.trace(\n+        \"Connecting to up to {} known peers\", scoreBasedPeersToAdd + randomlySelectedPeersToAdd);\n+    if (scoreBasedPeersToAdd == 0 && randomlySelectedPeersToAdd == 0) {\n       return emptyList();\n     }\n+\n+    final List<DiscoveryPeer> allCandidatePeers = new ArrayList<>(candidates.get());\n+    final List<PeerAddress> selectedPeers = new ArrayList<>();\n+\n+    if (randomlySelectedPeersToAdd > 0) {\n+      selectedPeers.addAll(\n+          selectAndRemoveRandomPeers(\n+              network, peerSources, randomlySelectedPeersToAdd, allCandidatePeers));\n+    }\n+\n+    if (scoreBasedPeersToAdd > 0) {\n+      selectedPeers.addAll(\n+          selectPeersByScore(\n+              network, peerSubnetSubscriptions, scoreBasedPeersToAdd, allCandidatePeers));\n+    }\n+    return unmodifiableList(selectedPeers); // Unmodifiable to make errorprone happy\n+  }\n+\n+  private List<PeerAddress> selectAndRemoveRandomPeers(\n+      final P2PNetwork<?> network,\n+      final PeerSources peerSources,\n+      final int randomlySelectedPeersToAdd,\n+      final List<DiscoveryPeer> allCandidatePeers) {\n+    final List<PeerAddress> selectedPeers = new ArrayList<>();\n+    shuffler.shuffle(allCandidatePeers);\n+    while (!allCandidatePeers.isEmpty() && selectedPeers.size() < randomlySelectedPeersToAdd) {\n+      final DiscoveryPeer candidate = allCandidatePeers.remove(0);\n+      checkCandidate(candidate, network)\n+          .ifPresent(\n+              peerAddress -> {\n+                peerSources.recordPeerSource(peerAddress.getId(), RANDOMLY_SELECTED);\n+                selectedPeers.add(peerAddress);\n+              });\n+    }\n+    return selectedPeers;\n+  }\n+\n+  private List<PeerAddress> selectPeersByScore(\n+      final P2PNetwork<?> network,\n+      final PeerSubnetSubscriptions peerSubnetSubscriptions,\n+      final int scoreBasedPeersToAdd,\n+      final List<DiscoveryPeer> allCandidatePeers) {\n+    final List<PeerAddress> selectedPeers = new ArrayList<>();\n     final PeerScorer peerScorer = peerSubnetSubscriptions.createScorer();\n-    return candidates.get().stream()\n+    allCandidatePeers.stream()\n         .sorted(\n             Comparator.comparing((Function<DiscoveryPeer, Integer>) peerScorer::scoreCandidatePeer)\n                 .reversed())\n-        .map(network::createPeerAddress)\n+        .flatMap(candidate -> checkCandidate(candidate, network).stream())\n+        .limit(scoreBasedPeersToAdd)\n+        .forEach(selectedPeers::add);\n+    return selectedPeers;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "08949cbbeeb137986b721b336ec2a7040a6e62ec"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDI1Mjg0NA==", "bodyText": "Shouldn't we call peerSources.forgetPeer(peer.getId())) after .limit(peersToDrop) instead of line 182?\nMay be some of randomlySelectedPeersBeingDropped will not fall into the final list", "url": "https://github.com/ConsenSys/teku/pull/2349#discussion_r454252844", "createdAt": "2020-07-14T10:16:54Z", "author": {"login": "Nashatyrev"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/peers/Eth2PeerSelectionStrategy.java", "diffHunk": "@@ -38,54 +47,149 @@\n   private final TargetPeerRange targetPeerCountRange;\n   private final PeerSubnetSubscriptions.Factory peerSubnetSubscriptionsFactory;\n   private final ReputationManager reputationManager;\n+  private final Shuffler shuffler;\n \n   public Eth2PeerSelectionStrategy(\n       final TargetPeerRange targetPeerCountRange,\n       final PeerSubnetSubscriptions.Factory peerSubnetSubscriptionsFactory,\n-      final ReputationManager reputationManager) {\n+      final ReputationManager reputationManager,\n+      final Shuffler shuffler) {\n     this.targetPeerCountRange = targetPeerCountRange;\n     this.peerSubnetSubscriptionsFactory = peerSubnetSubscriptionsFactory;\n     this.reputationManager = reputationManager;\n+    this.shuffler = shuffler;\n   }\n \n   @Override\n   public List<PeerAddress> selectPeersToConnect(\n-      final P2PNetwork<?> network, final Supplier<List<DiscoveryPeer>> candidates) {\n+      final P2PNetwork<?> network,\n+      final PeerSources peerSources,\n+      final Supplier<List<DiscoveryPeer>> candidates) {\n     final PeerSubnetSubscriptions peerSubnetSubscriptions =\n         peerSubnetSubscriptionsFactory.create(network);\n     final int peersRequiredForPeerCount =\n         targetPeerCountRange.getPeersToAdd(network.getPeerCount());\n+    final int randomlySelectedPeerCount = getCurrentRandomlySelectedPeerCount(network, peerSources);\n+    final int randomlySelectedPeersToAdd =\n+        targetPeerCountRange.getRandomlySelectedPeersToAdd(randomlySelectedPeerCount);\n+\n     final int peersRequiredForSubnets = peerSubnetSubscriptions.getSubscribersRequired();\n-    final int maxAttempts = Math.max(peersRequiredForPeerCount, peersRequiredForSubnets);\n-    LOG.trace(\"Connecting to up to {} known peers\", maxAttempts);\n-    if (maxAttempts == 0) {\n+    final int scoreBasedPeersToAdd =\n+        Math.max(peersRequiredForPeerCount - randomlySelectedPeerCount, peersRequiredForSubnets);\n+    LOG.trace(\n+        \"Connecting to up to {} known peers\", scoreBasedPeersToAdd + randomlySelectedPeersToAdd);\n+    if (scoreBasedPeersToAdd == 0 && randomlySelectedPeersToAdd == 0) {\n       return emptyList();\n     }\n+\n+    final List<DiscoveryPeer> allCandidatePeers = new ArrayList<>(candidates.get());\n+    final List<PeerAddress> selectedPeers = new ArrayList<>();\n+\n+    if (randomlySelectedPeersToAdd > 0) {\n+      selectedPeers.addAll(\n+          selectAndRemoveRandomPeers(\n+              network, peerSources, randomlySelectedPeersToAdd, allCandidatePeers));\n+    }\n+\n+    if (scoreBasedPeersToAdd > 0) {\n+      selectedPeers.addAll(\n+          selectPeersByScore(\n+              network, peerSubnetSubscriptions, scoreBasedPeersToAdd, allCandidatePeers));\n+    }\n+    return unmodifiableList(selectedPeers); // Unmodifiable to make errorprone happy\n+  }\n+\n+  private List<PeerAddress> selectAndRemoveRandomPeers(\n+      final P2PNetwork<?> network,\n+      final PeerSources peerSources,\n+      final int randomlySelectedPeersToAdd,\n+      final List<DiscoveryPeer> allCandidatePeers) {\n+    final List<PeerAddress> selectedPeers = new ArrayList<>();\n+    shuffler.shuffle(allCandidatePeers);\n+    while (!allCandidatePeers.isEmpty() && selectedPeers.size() < randomlySelectedPeersToAdd) {\n+      final DiscoveryPeer candidate = allCandidatePeers.remove(0);\n+      checkCandidate(candidate, network)\n+          .ifPresent(\n+              peerAddress -> {\n+                peerSources.recordPeerSource(peerAddress.getId(), RANDOMLY_SELECTED);\n+                selectedPeers.add(peerAddress);\n+              });\n+    }\n+    return selectedPeers;\n+  }\n+\n+  private List<PeerAddress> selectPeersByScore(\n+      final P2PNetwork<?> network,\n+      final PeerSubnetSubscriptions peerSubnetSubscriptions,\n+      final int scoreBasedPeersToAdd,\n+      final List<DiscoveryPeer> allCandidatePeers) {\n+    final List<PeerAddress> selectedPeers = new ArrayList<>();\n     final PeerScorer peerScorer = peerSubnetSubscriptions.createScorer();\n-    return candidates.get().stream()\n+    allCandidatePeers.stream()\n         .sorted(\n             Comparator.comparing((Function<DiscoveryPeer, Integer>) peerScorer::scoreCandidatePeer)\n                 .reversed())\n-        .map(network::createPeerAddress)\n+        .flatMap(candidate -> checkCandidate(candidate, network).stream())\n+        .limit(scoreBasedPeersToAdd)\n+        .forEach(selectedPeers::add);\n+    return selectedPeers;\n+  }\n+\n+  private int getCurrentRandomlySelectedPeerCount(\n+      final P2PNetwork<?> network, final PeerSources peerSources) {\n+    return (int)\n+        network\n+            .streamPeers()\n+            .filter(peer -> peerSources.getSource(peer.getId()) == RANDOMLY_SELECTED)\n+            .count();\n+  }\n+\n+  private Optional<PeerAddress> checkCandidate(\n+      final DiscoveryPeer candidate, final P2PNetwork<?> network) {\n+    return Optional.of(network.createPeerAddress(candidate))\n         .filter(reputationManager::isConnectionInitiationAllowed)\n-        .filter(peerAddress -> !network.isConnected(peerAddress))\n-        .limit(maxAttempts)\n-        .collect(toList());\n+        .filter(peerAddress -> !network.isConnected(peerAddress));\n   }\n \n   @Override\n   public List<Peer> selectPeersToDisconnect(\n-      final P2PNetwork<?> network, final Predicate<Peer> canBeDisconnected) {\n-    final int peersToDrop = targetPeerCountRange.getPeersToDrop(network.getPeerCount());\n+      final P2PNetwork<?> network, final PeerSources peerSources) {\n+\n+    final Map<PeerSource, List<Peer>> peersBySource =\n+        network\n+            .streamPeers()\n+            .collect(Collectors.groupingBy(peer -> peerSources.getSource(peer.getId())));\n+\n+    final List<Peer> randomlySelectedPeers =\n+        peersBySource.getOrDefault(RANDOMLY_SELECTED, new ArrayList<>());\n+    final int randomlySelectedPeerCount = randomlySelectedPeers.size();\n+\n+    final int currentPeerCount = network.getPeerCount();\n+    final int peersToDrop = targetPeerCountRange.getPeersToDrop(currentPeerCount);\n     if (peersToDrop == 0) {\n       return emptyList();\n     }\n     final PeerScorer peerScorer = peerSubnetSubscriptionsFactory.create(network).createScorer();\n-    return network\n-        .streamPeers()\n-        .filter(canBeDisconnected)\n+    final int randomlySelectedPeersToDrop =\n+        targetPeerCountRange.getRandomlySelectedPeersToDrop(\n+            randomlySelectedPeerCount, currentPeerCount);\n+    shuffler.shuffle(randomlySelectedPeers);\n+    final List<Peer> randomlySelectedPeersBeingDropped =\n+        randomlySelectedPeers.subList(\n+            0, Math.min(randomlySelectedPeersToDrop, randomlySelectedPeers.size()));\n+    // Peers from the randomly selected pool that have been chosen are now left to justify\n+    // themselves based on their score alone.\n+    randomlySelectedPeersBeingDropped.forEach(peer -> peerSources.forgetPeer(peer.getId()));\n+    return Stream.concat(\n+            randomlySelectedPeersBeingDropped.stream(),\n+            peersBySource.getOrDefault(SELECTED_BY_SCORE, emptyList()).stream())\n         .sorted(Comparator.comparing(peerScorer::scoreExistingPeer))\n         .limit(peersToDrop)\n         .collect(toList());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "08949cbbeeb137986b721b336ec2a7040a6e62ec"}, "originalPosition": 185}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eba59236695c631b073260c1a147699e2668a4f0", "author": {"user": {"login": "ajsutton", "name": "Adrian Sutton"}}, "url": "https://github.com/ConsenSys/teku/commit/eba59236695c631b073260c1a147699e2668a4f0", "committedDate": "2020-07-14T22:53:35Z", "message": "Review feedback."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "12160b6966f609bbf05859b7b59aa0a1c860db26", "author": {"user": {"login": "ajsutton", "name": "Adrian Sutton"}}, "url": "https://github.com/ConsenSys/teku/commit/12160b6966f609bbf05859b7b59aa0a1c860db26", "committedDate": "2020-07-14T22:53:45Z", "message": "Merge branch 'master' of github.com:PegaSysEng/teku into connect-random-peers"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ca4f60c69c0d6c5140bbd7f38c5ed08af02b83ee", "author": {"user": {"login": "ajsutton", "name": "Adrian Sutton"}}, "url": "https://github.com/ConsenSys/teku/commit/ca4f60c69c0d6c5140bbd7f38c5ed08af02b83ee", "committedDate": "2020-07-14T23:14:14Z", "message": "Fix test."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3835, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}