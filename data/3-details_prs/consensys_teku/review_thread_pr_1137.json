{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcxNTQ1NDg2", "number": 1137, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQxNzoxNzo0OVrODdw8mA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQxNzoxNzo0OVrODdw8mA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyNTM3MjQwOnYy", "diffSide": "RIGHT", "path": "events/src/main/java/tech/pegasys/artemis/events/DirectEventDeliverer.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQxNzoxNzo0OVrOFmjb0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNlQyMzoyNDoyMVrOFmtrgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTk3MDc3MA==", "bodyText": "Should we include method.getName()?", "url": "https://github.com/ConsenSys/teku/pull/1137#discussion_r375970770", "createdAt": "2020-02-06T17:17:49Z", "author": {"login": "mbaxter"}, "path": "events/src/main/java/tech/pegasys/artemis/events/DirectEventDeliverer.java", "diffHunk": "@@ -13,24 +13,58 @@\n \n package tech.pegasys.artemis.events;\n \n+import static tech.pegasys.artemis.metrics.ArtemisMetricCategory.EVENTBUS;\n+\n import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Method;\n+import org.hyperledger.besu.plugin.services.MetricsSystem;\n+import org.hyperledger.besu.plugin.services.metrics.Counter;\n+import org.hyperledger.besu.plugin.services.metrics.LabelledMetric;\n \n class DirectEventDeliverer<T> extends EventDeliverer<T> {\n   private final ChannelExceptionHandler exceptionHandler;\n+  private final LabelledMetric<Counter> consumedEventCounter;\n+  private final LabelledMetric<Counter> failedEventCounter;\n \n-  DirectEventDeliverer(final ChannelExceptionHandler exceptionHandler) {\n+  DirectEventDeliverer(\n+      final ChannelExceptionHandler exceptionHandler, final MetricsSystem metricsSystem) {\n+    super(metricsSystem);\n     this.exceptionHandler = exceptionHandler;\n+    consumedEventCounter =\n+        metricsSystem.createLabelledCounter(\n+            EVENTBUS,\n+            \"event_consumed_count\",\n+            \"Total number of events consumed\",\n+            \"channel\",\n+            \"subscriber\");\n+    failedEventCounter =\n+        metricsSystem.createLabelledCounter(\n+            EVENTBUS,\n+            \"event_failed_count\",\n+            \"Number of events which failed to be processed\",\n+            \"channel\",\n+            \"subscriber\");\n   }\n \n   @Override\n   protected void deliverTo(final T subscriber, final Method method, final Object[] args) {\n     try {\n       method.invoke(subscriber, args);\n     } catch (IllegalAccessException e) {\n+      incrementCounter(failedEventCounter, subscriber, method);\n       exceptionHandler.handleException(e, subscriber, method, args);\n     } catch (InvocationTargetException e) {\n+      incrementCounter(failedEventCounter, subscriber, method);\n       exceptionHandler.handleException(e.getTargetException(), subscriber, method, args);\n+    } finally {\n+      incrementCounter(consumedEventCounter, subscriber, method);\n     }\n   }\n+\n+  private void incrementCounter(\n+      final LabelledMetric<Counter> counter, final T subscriber, final Method method) {\n+    counter\n+        .labels(method.getDeclaringClass().getSimpleName(), subscriber.getClass().getSimpleName())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ad9230e1b97b6b1e7e6b354d73f4fb4144cd635"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjEzODYyNg==", "bodyText": "Good question... I'm tempted to leave it out for now - every combination of label values introduces a whole new timeline to store so it would increase the storage required.  I suspect that most channels will only have a small number of highly related methods on them so we won't need that level of detail.  Previous experience with these kinds of events and monitoring lines up with that, but we won't know for sure until we use this to monitor actual nodes in production.", "url": "https://github.com/ConsenSys/teku/pull/1137#discussion_r376138626", "createdAt": "2020-02-06T23:24:21Z", "author": {"login": "ajsutton"}, "path": "events/src/main/java/tech/pegasys/artemis/events/DirectEventDeliverer.java", "diffHunk": "@@ -13,24 +13,58 @@\n \n package tech.pegasys.artemis.events;\n \n+import static tech.pegasys.artemis.metrics.ArtemisMetricCategory.EVENTBUS;\n+\n import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Method;\n+import org.hyperledger.besu.plugin.services.MetricsSystem;\n+import org.hyperledger.besu.plugin.services.metrics.Counter;\n+import org.hyperledger.besu.plugin.services.metrics.LabelledMetric;\n \n class DirectEventDeliverer<T> extends EventDeliverer<T> {\n   private final ChannelExceptionHandler exceptionHandler;\n+  private final LabelledMetric<Counter> consumedEventCounter;\n+  private final LabelledMetric<Counter> failedEventCounter;\n \n-  DirectEventDeliverer(final ChannelExceptionHandler exceptionHandler) {\n+  DirectEventDeliverer(\n+      final ChannelExceptionHandler exceptionHandler, final MetricsSystem metricsSystem) {\n+    super(metricsSystem);\n     this.exceptionHandler = exceptionHandler;\n+    consumedEventCounter =\n+        metricsSystem.createLabelledCounter(\n+            EVENTBUS,\n+            \"event_consumed_count\",\n+            \"Total number of events consumed\",\n+            \"channel\",\n+            \"subscriber\");\n+    failedEventCounter =\n+        metricsSystem.createLabelledCounter(\n+            EVENTBUS,\n+            \"event_failed_count\",\n+            \"Number of events which failed to be processed\",\n+            \"channel\",\n+            \"subscriber\");\n   }\n \n   @Override\n   protected void deliverTo(final T subscriber, final Method method, final Object[] args) {\n     try {\n       method.invoke(subscriber, args);\n     } catch (IllegalAccessException e) {\n+      incrementCounter(failedEventCounter, subscriber, method);\n       exceptionHandler.handleException(e, subscriber, method, args);\n     } catch (InvocationTargetException e) {\n+      incrementCounter(failedEventCounter, subscriber, method);\n       exceptionHandler.handleException(e.getTargetException(), subscriber, method, args);\n+    } finally {\n+      incrementCounter(consumedEventCounter, subscriber, method);\n     }\n   }\n+\n+  private void incrementCounter(\n+      final LabelledMetric<Counter> counter, final T subscriber, final Method method) {\n+    counter\n+        .labels(method.getDeclaringClass().getSimpleName(), subscriber.getClass().getSimpleName())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTk3MDc3MA=="}, "originalCommit": {"oid": "0ad9230e1b97b6b1e7e6b354d73f4fb4144cd635"}, "originalPosition": 56}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2841, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}