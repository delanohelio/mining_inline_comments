{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ5Mjg4NTEx", "number": 2358, "title": "Calculate min and max ssz lengths", "bodyText": "PR Description\nIn preparation for validating rpc message lengths more strictly, calculate the minimum and maximum lengths for SSZ serialised objects.  Not currently used anywhere but changes to SimpleOffsetSerializer are so complex it's worth reviewing them separately.\nFixed Issue(s)\nPart of #2077\nDocumentation\n\n I thought about documentation and added the documentation label to this PR if updates are required.", "createdAt": "2020-07-15T07:02:53Z", "url": "https://github.com/ConsenSys/teku/pull/2358", "merged": true, "mergeCommit": {"oid": "759736afca9cdafb96ee0b4706082c6ff8077457"}, "closed": true, "closedAt": "2020-07-15T21:36:57Z", "author": {"login": "ajsutton"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc1E-pdgH2gAyNDQ5Mjg4NTExOjVmMTZjNWY3MDMwZDk5ZjdmYTU1NDdjZmMyYzFiYjIxNjFlODdhOTI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc1RddfAH2gAyNDQ5Mjg4NTExOjBmZGJhMWZiM2M0NzdjMGM2Njc1NjFhMzA4OWZhNmVkNGVkZGQ3MDI=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "5f16c5f7030d99f7fa5547cfc2c1bb2161e87a92", "author": {"user": {"login": "ajsutton", "name": "Adrian Sutton"}}, "url": "https://github.com/ConsenSys/teku/commit/5f16c5f7030d99f7fa5547cfc2c1bb2161e87a92", "committedDate": "2020-07-15T06:52:07Z", "message": "Calculate min and max lengths for SSZ serialized objects."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3521d65b812486e422f79b4b6815d3a29bfd6d2b", "author": {"user": {"login": "ajsutton", "name": "Adrian Sutton"}}, "url": "https://github.com/ConsenSys/teku/commit/3521d65b812486e422f79b4b6815d3a29bfd6d2b", "committedDate": "2020-07-15T06:56:40Z", "message": "Move length calculation to a separate class"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9fc25d731f45a31d207386cd8137c91cfe783e47", "author": {"user": {"login": "ajsutton", "name": "Adrian Sutton"}}, "url": "https://github.com/ConsenSys/teku/commit/9fc25d731f45a31d207386cd8137c91cfe783e47", "committedDate": "2020-07-15T07:00:59Z", "message": "Simplify a little."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1202ed34f6650c1106ae6975a1bd2f363dfad27d", "author": {"user": {"login": "ajsutton", "name": "Adrian Sutton"}}, "url": "https://github.com/ConsenSys/teku/commit/1202ed34f6650c1106ae6975a1bd2f363dfad27d", "committedDate": "2020-07-15T07:02:18Z", "message": "Rename method."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fcec328a5892477ac801262d508feaf91eb9f2dd", "author": {"user": {"login": "ajsutton", "name": "Adrian Sutton"}}, "url": "https://github.com/ConsenSys/teku/commit/fcec328a5892477ac801262d508feaf91eb9f2dd", "committedDate": "2020-07-15T07:02:42Z", "message": "Remove stray class."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "594899ff515d30ae3f6e1b8d0dc6085d2632a583", "author": {"user": {"login": "ajsutton", "name": "Adrian Sutton"}}, "url": "https://github.com/ConsenSys/teku/commit/594899ff515d30ae3f6e1b8d0dc6085d2632a583", "committedDate": "2020-07-15T07:10:41Z", "message": "Fix generics."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ4Nzc2NzQ3", "url": "https://github.com/ConsenSys/teku/pull/2358#pullrequestreview-448776747", "createdAt": "2020-07-15T09:19:31Z", "commit": {"oid": "594899ff515d30ae3f6e1b8d0dc6085d2632a583"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwOToxOTozMVrOGx1p5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQwOTo0MTo0MlrOGx2c2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkxMjQ4Nw==", "bodyText": "May be change exception wording?", "url": "https://github.com/ConsenSys/teku/pull/2358#discussion_r454912487", "createdAt": "2020-07-15T09:19:31Z", "author": {"login": "Nashatyrev"}, "path": "ethereum/datastructures/src/main/java/tech/pegasys/teku/datastructures/util/LengthBoundCalculator.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.datastructures.util;\n+\n+import static tech.pegasys.teku.datastructures.util.SimpleOffsetSerializer.BOOLEAN_SIZE;\n+import static tech.pegasys.teku.datastructures.util.SimpleOffsetSerializer.UNSIGNED_LONG_SIZE;\n+import static tech.pegasys.teku.datastructures.util.SimpleOffsetSerializer.getOptionalReflectionInfo;\n+import static tech.pegasys.teku.datastructures.util.SimpleOffsetSerializer.getRequiredReflectionInfo;\n+import static tech.pegasys.teku.datastructures.util.SimpleOffsetSerializer.isBitvector;\n+import static tech.pegasys.teku.datastructures.util.SimpleOffsetSerializer.isPrimitive;\n+import static tech.pegasys.teku.datastructures.util.SimpleOffsetSerializer.isVariable;\n+import static tech.pegasys.teku.datastructures.util.SimpleOffsetSerializer.isVector;\n+import static tech.pegasys.teku.util.config.Constants.BYTES_PER_LENGTH_OFFSET;\n+\n+import java.lang.reflect.Field;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.bls.BLSPublicKey;\n+import tech.pegasys.teku.bls.BLSSignature;\n+import tech.pegasys.teku.ssz.SSZTypes.Bitlist;\n+import tech.pegasys.teku.ssz.SSZTypes.Bitvector;\n+import tech.pegasys.teku.ssz.SSZTypes.Bytes4;\n+import tech.pegasys.teku.ssz.SSZTypes.SSZList;\n+import tech.pegasys.teku.ssz.sos.ReflectionInformation;\n+\n+public class LengthBoundCalculator {\n+\n+  static <T> LengthBounds calculateLengthBounds(final Class<T> type) {\n+    final ReflectionInformation reflectionInfo = getRequiredReflectionInfo(type);\n+    LengthBounds lengthBounds = LengthBounds.ZERO;\n+    int variableFieldCount = 0;\n+    int vectorCount = 0;\n+    int bitvectorCount = 0;\n+    for (Field field : reflectionInfo.getFields()) {\n+      final Class<?> fieldType = field.getType();\n+      final LengthBounds fieldLengthBounds;\n+      if (getOptionalReflectionInfo(fieldType).isPresent()) {\n+        fieldLengthBounds = calculateLengthBounds(fieldType);\n+\n+      } else if (fieldType == Bitlist.class) {\n+        fieldLengthBounds = calculateBitlistLength(reflectionInfo, variableFieldCount);\n+\n+      } else if (fieldType == SSZList.class) {\n+        fieldLengthBounds = calculateSszListLength(reflectionInfo, variableFieldCount);\n+\n+      } else if (isVector(fieldType)) {\n+        fieldLengthBounds = calculateSszVectorLength(reflectionInfo, vectorCount);\n+        vectorCount++;\n+\n+      } else if (isBitvector(fieldType)) {\n+        fieldLengthBounds = calculateBitvectorLength(reflectionInfo, bitvectorCount);\n+        bitvectorCount++;\n+\n+      } else if (isPrimitive(fieldType)) {\n+        fieldLengthBounds = new LengthBounds(getPrimitiveLength(fieldType));\n+\n+      } else {\n+        throw new IllegalArgumentException(\n+            \"Don't know how to calculate length for \" + fieldType.getSimpleName());\n+      }\n+\n+      if (isVariable(fieldType)) {\n+        variableFieldCount++;\n+        // The fixed parts includes an offset in place of the variable length value\n+        lengthBounds = lengthBounds.add(new LengthBounds(BYTES_PER_LENGTH_OFFSET.longValue()));\n+      }\n+      lengthBounds = lengthBounds.add(fieldLengthBounds);\n+    }\n+    return lengthBounds;\n+  }\n+\n+  private static LengthBounds calculateBitvectorLength(\n+      final ReflectionInformation reflectionInfo, final int bitvectorCount) {\n+    final LengthBounds fieldLengthBounds;\n+    final Integer size = reflectionInfo.getBitvectorSizes().get(bitvectorCount);\n+    final int serializationLength = Bitvector.sszSerializationLength(size);\n+    fieldLengthBounds = new LengthBounds(serializationLength, serializationLength);\n+    return fieldLengthBounds;\n+  }\n+\n+  private static LengthBounds calculateSszVectorLength(\n+      final ReflectionInformation reflectionInfo, final int vectorCount) {\n+    final LengthBounds fieldLengthBounds;\n+    final Class<?> elementType = reflectionInfo.getVectorElementTypes().get(vectorCount);\n+    final int vectorLength = reflectionInfo.getVectorLengths().get(vectorCount);\n+    final LengthBounds elementLengthBounds = getElementLengthBounds(elementType);\n+    fieldLengthBounds =\n+        new LengthBounds(\n+            vectorLength * elementLengthBounds.getMin(),\n+            vectorLength * elementLengthBounds.getMax());\n+    return fieldLengthBounds;\n+  }\n+\n+  private static LengthBounds calculateSszListLength(\n+      final ReflectionInformation reflectionInfo, final int variableFieldCount) {\n+    final LengthBounds fieldLengthBounds;\n+    final Class<?> listElementType = reflectionInfo.getListElementTypes().get(variableFieldCount);\n+    final long listElementMaxSize = reflectionInfo.getListElementMaxSizes().get(variableFieldCount);\n+    final LengthBounds elementLengthBounds = getElementLengthBounds(listElementType);\n+    final long variableFieldOffsetsLength =\n+        isVariable(listElementType) ? BYTES_PER_LENGTH_OFFSET.intValue() * listElementMaxSize : 0;\n+    fieldLengthBounds =\n+        new LengthBounds(\n+            0, elementLengthBounds.getMax() * listElementMaxSize + variableFieldOffsetsLength);\n+    return fieldLengthBounds;\n+  }\n+\n+  private static LengthBounds calculateBitlistLength(\n+      final ReflectionInformation reflectionInfo, final int variableFieldCount) {\n+    final LengthBounds fieldLengthBounds;\n+    final long maxSize = reflectionInfo.getBitlistElementMaxSizes().get(variableFieldCount);\n+    fieldLengthBounds =\n+        new LengthBounds(\n+            Bitlist.sszSerializationLength(Math.toIntExact(0)),\n+            Bitlist.sszSerializationLength(Math.toIntExact(maxSize)));\n+    return fieldLengthBounds;\n+  }\n+\n+  private static LengthBounds getElementLengthBounds(final Class<?> listElementType) {\n+    if (isPrimitive(listElementType)) {\n+      final int primitiveLength = getPrimitiveLength(listElementType);\n+      return new LengthBounds(primitiveLength, primitiveLength);\n+    }\n+    return calculateLengthBounds(listElementType);\n+  }\n+\n+  private static int getPrimitiveLength(final Class<?> classInfo) {\n+    switch (classInfo.getSimpleName()) {\n+      case \"UnsignedLong\":\n+        return UNSIGNED_LONG_SIZE;\n+      case \"ArrayWrappingBytes32\":\n+      case \"Bytes32\":\n+        return Bytes32.SIZE;\n+      case \"Bytes4\":\n+        return Bytes4.SIZE;\n+      case \"BLSSignature\":\n+        return BLSSignature.BLS_SIGNATURE_SIZE;\n+      case \"BLSPublicKey\":\n+        return BLSPublicKey.BLS_PUBKEY_SIZE;\n+      case \"Boolean\":\n+      case \"boolean\":\n+        return BOOLEAN_SIZE;\n+      default:\n+        throw new IllegalArgumentException(\"Unable to deserialize \" + classInfo.getSimpleName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "594899ff515d30ae3f6e1b8d0dc6085d2632a583"}, "originalPosition": 154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkyNDQ5Mg==", "bodyText": "Not sure here: getBitlistElementMaxSizes() seems to return only Bitlist instance sizes in the referred class. Why is it indexed by variableFieldCount which is a total counter of lists and bitfields?", "url": "https://github.com/ConsenSys/teku/pull/2358#discussion_r454924492", "createdAt": "2020-07-15T09:39:59Z", "author": {"login": "Nashatyrev"}, "path": "ethereum/datastructures/src/main/java/tech/pegasys/teku/datastructures/util/LengthBoundCalculator.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.datastructures.util;\n+\n+import static tech.pegasys.teku.datastructures.util.SimpleOffsetSerializer.BOOLEAN_SIZE;\n+import static tech.pegasys.teku.datastructures.util.SimpleOffsetSerializer.UNSIGNED_LONG_SIZE;\n+import static tech.pegasys.teku.datastructures.util.SimpleOffsetSerializer.getOptionalReflectionInfo;\n+import static tech.pegasys.teku.datastructures.util.SimpleOffsetSerializer.getRequiredReflectionInfo;\n+import static tech.pegasys.teku.datastructures.util.SimpleOffsetSerializer.isBitvector;\n+import static tech.pegasys.teku.datastructures.util.SimpleOffsetSerializer.isPrimitive;\n+import static tech.pegasys.teku.datastructures.util.SimpleOffsetSerializer.isVariable;\n+import static tech.pegasys.teku.datastructures.util.SimpleOffsetSerializer.isVector;\n+import static tech.pegasys.teku.util.config.Constants.BYTES_PER_LENGTH_OFFSET;\n+\n+import java.lang.reflect.Field;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.bls.BLSPublicKey;\n+import tech.pegasys.teku.bls.BLSSignature;\n+import tech.pegasys.teku.ssz.SSZTypes.Bitlist;\n+import tech.pegasys.teku.ssz.SSZTypes.Bitvector;\n+import tech.pegasys.teku.ssz.SSZTypes.Bytes4;\n+import tech.pegasys.teku.ssz.SSZTypes.SSZList;\n+import tech.pegasys.teku.ssz.sos.ReflectionInformation;\n+\n+public class LengthBoundCalculator {\n+\n+  static <T> LengthBounds calculateLengthBounds(final Class<T> type) {\n+    final ReflectionInformation reflectionInfo = getRequiredReflectionInfo(type);\n+    LengthBounds lengthBounds = LengthBounds.ZERO;\n+    int variableFieldCount = 0;\n+    int vectorCount = 0;\n+    int bitvectorCount = 0;\n+    for (Field field : reflectionInfo.getFields()) {\n+      final Class<?> fieldType = field.getType();\n+      final LengthBounds fieldLengthBounds;\n+      if (getOptionalReflectionInfo(fieldType).isPresent()) {\n+        fieldLengthBounds = calculateLengthBounds(fieldType);\n+\n+      } else if (fieldType == Bitlist.class) {\n+        fieldLengthBounds = calculateBitlistLength(reflectionInfo, variableFieldCount);\n+\n+      } else if (fieldType == SSZList.class) {\n+        fieldLengthBounds = calculateSszListLength(reflectionInfo, variableFieldCount);\n+\n+      } else if (isVector(fieldType)) {\n+        fieldLengthBounds = calculateSszVectorLength(reflectionInfo, vectorCount);\n+        vectorCount++;\n+\n+      } else if (isBitvector(fieldType)) {\n+        fieldLengthBounds = calculateBitvectorLength(reflectionInfo, bitvectorCount);\n+        bitvectorCount++;\n+\n+      } else if (isPrimitive(fieldType)) {\n+        fieldLengthBounds = new LengthBounds(getPrimitiveLength(fieldType));\n+\n+      } else {\n+        throw new IllegalArgumentException(\n+            \"Don't know how to calculate length for \" + fieldType.getSimpleName());\n+      }\n+\n+      if (isVariable(fieldType)) {\n+        variableFieldCount++;\n+        // The fixed parts includes an offset in place of the variable length value\n+        lengthBounds = lengthBounds.add(new LengthBounds(BYTES_PER_LENGTH_OFFSET.longValue()));\n+      }\n+      lengthBounds = lengthBounds.add(fieldLengthBounds);\n+    }\n+    return lengthBounds;\n+  }\n+\n+  private static LengthBounds calculateBitvectorLength(\n+      final ReflectionInformation reflectionInfo, final int bitvectorCount) {\n+    final LengthBounds fieldLengthBounds;\n+    final Integer size = reflectionInfo.getBitvectorSizes().get(bitvectorCount);\n+    final int serializationLength = Bitvector.sszSerializationLength(size);\n+    fieldLengthBounds = new LengthBounds(serializationLength, serializationLength);\n+    return fieldLengthBounds;\n+  }\n+\n+  private static LengthBounds calculateSszVectorLength(\n+      final ReflectionInformation reflectionInfo, final int vectorCount) {\n+    final LengthBounds fieldLengthBounds;\n+    final Class<?> elementType = reflectionInfo.getVectorElementTypes().get(vectorCount);\n+    final int vectorLength = reflectionInfo.getVectorLengths().get(vectorCount);\n+    final LengthBounds elementLengthBounds = getElementLengthBounds(elementType);\n+    fieldLengthBounds =\n+        new LengthBounds(\n+            vectorLength * elementLengthBounds.getMin(),\n+            vectorLength * elementLengthBounds.getMax());\n+    return fieldLengthBounds;\n+  }\n+\n+  private static LengthBounds calculateSszListLength(\n+      final ReflectionInformation reflectionInfo, final int variableFieldCount) {\n+    final LengthBounds fieldLengthBounds;\n+    final Class<?> listElementType = reflectionInfo.getListElementTypes().get(variableFieldCount);\n+    final long listElementMaxSize = reflectionInfo.getListElementMaxSizes().get(variableFieldCount);\n+    final LengthBounds elementLengthBounds = getElementLengthBounds(listElementType);\n+    final long variableFieldOffsetsLength =\n+        isVariable(listElementType) ? BYTES_PER_LENGTH_OFFSET.intValue() * listElementMaxSize : 0;\n+    fieldLengthBounds =\n+        new LengthBounds(\n+            0, elementLengthBounds.getMax() * listElementMaxSize + variableFieldOffsetsLength);\n+    return fieldLengthBounds;\n+  }\n+\n+  private static LengthBounds calculateBitlistLength(\n+      final ReflectionInformation reflectionInfo, final int variableFieldCount) {\n+    final LengthBounds fieldLengthBounds;\n+    final long maxSize = reflectionInfo.getBitlistElementMaxSizes().get(variableFieldCount);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "594899ff515d30ae3f6e1b8d0dc6085d2632a583"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDkyNTUzMQ==", "bodyText": "The same question as for calculateBitlistLength", "url": "https://github.com/ConsenSys/teku/pull/2358#discussion_r454925531", "createdAt": "2020-07-15T09:41:42Z", "author": {"login": "Nashatyrev"}, "path": "ethereum/datastructures/src/main/java/tech/pegasys/teku/datastructures/util/LengthBoundCalculator.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.datastructures.util;\n+\n+import static tech.pegasys.teku.datastructures.util.SimpleOffsetSerializer.BOOLEAN_SIZE;\n+import static tech.pegasys.teku.datastructures.util.SimpleOffsetSerializer.UNSIGNED_LONG_SIZE;\n+import static tech.pegasys.teku.datastructures.util.SimpleOffsetSerializer.getOptionalReflectionInfo;\n+import static tech.pegasys.teku.datastructures.util.SimpleOffsetSerializer.getRequiredReflectionInfo;\n+import static tech.pegasys.teku.datastructures.util.SimpleOffsetSerializer.isBitvector;\n+import static tech.pegasys.teku.datastructures.util.SimpleOffsetSerializer.isPrimitive;\n+import static tech.pegasys.teku.datastructures.util.SimpleOffsetSerializer.isVariable;\n+import static tech.pegasys.teku.datastructures.util.SimpleOffsetSerializer.isVector;\n+import static tech.pegasys.teku.util.config.Constants.BYTES_PER_LENGTH_OFFSET;\n+\n+import java.lang.reflect.Field;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.bls.BLSPublicKey;\n+import tech.pegasys.teku.bls.BLSSignature;\n+import tech.pegasys.teku.ssz.SSZTypes.Bitlist;\n+import tech.pegasys.teku.ssz.SSZTypes.Bitvector;\n+import tech.pegasys.teku.ssz.SSZTypes.Bytes4;\n+import tech.pegasys.teku.ssz.SSZTypes.SSZList;\n+import tech.pegasys.teku.ssz.sos.ReflectionInformation;\n+\n+public class LengthBoundCalculator {\n+\n+  static <T> LengthBounds calculateLengthBounds(final Class<T> type) {\n+    final ReflectionInformation reflectionInfo = getRequiredReflectionInfo(type);\n+    LengthBounds lengthBounds = LengthBounds.ZERO;\n+    int variableFieldCount = 0;\n+    int vectorCount = 0;\n+    int bitvectorCount = 0;\n+    for (Field field : reflectionInfo.getFields()) {\n+      final Class<?> fieldType = field.getType();\n+      final LengthBounds fieldLengthBounds;\n+      if (getOptionalReflectionInfo(fieldType).isPresent()) {\n+        fieldLengthBounds = calculateLengthBounds(fieldType);\n+\n+      } else if (fieldType == Bitlist.class) {\n+        fieldLengthBounds = calculateBitlistLength(reflectionInfo, variableFieldCount);\n+\n+      } else if (fieldType == SSZList.class) {\n+        fieldLengthBounds = calculateSszListLength(reflectionInfo, variableFieldCount);\n+\n+      } else if (isVector(fieldType)) {\n+        fieldLengthBounds = calculateSszVectorLength(reflectionInfo, vectorCount);\n+        vectorCount++;\n+\n+      } else if (isBitvector(fieldType)) {\n+        fieldLengthBounds = calculateBitvectorLength(reflectionInfo, bitvectorCount);\n+        bitvectorCount++;\n+\n+      } else if (isPrimitive(fieldType)) {\n+        fieldLengthBounds = new LengthBounds(getPrimitiveLength(fieldType));\n+\n+      } else {\n+        throw new IllegalArgumentException(\n+            \"Don't know how to calculate length for \" + fieldType.getSimpleName());\n+      }\n+\n+      if (isVariable(fieldType)) {\n+        variableFieldCount++;\n+        // The fixed parts includes an offset in place of the variable length value\n+        lengthBounds = lengthBounds.add(new LengthBounds(BYTES_PER_LENGTH_OFFSET.longValue()));\n+      }\n+      lengthBounds = lengthBounds.add(fieldLengthBounds);\n+    }\n+    return lengthBounds;\n+  }\n+\n+  private static LengthBounds calculateBitvectorLength(\n+      final ReflectionInformation reflectionInfo, final int bitvectorCount) {\n+    final LengthBounds fieldLengthBounds;\n+    final Integer size = reflectionInfo.getBitvectorSizes().get(bitvectorCount);\n+    final int serializationLength = Bitvector.sszSerializationLength(size);\n+    fieldLengthBounds = new LengthBounds(serializationLength, serializationLength);\n+    return fieldLengthBounds;\n+  }\n+\n+  private static LengthBounds calculateSszVectorLength(\n+      final ReflectionInformation reflectionInfo, final int vectorCount) {\n+    final LengthBounds fieldLengthBounds;\n+    final Class<?> elementType = reflectionInfo.getVectorElementTypes().get(vectorCount);\n+    final int vectorLength = reflectionInfo.getVectorLengths().get(vectorCount);\n+    final LengthBounds elementLengthBounds = getElementLengthBounds(elementType);\n+    fieldLengthBounds =\n+        new LengthBounds(\n+            vectorLength * elementLengthBounds.getMin(),\n+            vectorLength * elementLengthBounds.getMax());\n+    return fieldLengthBounds;\n+  }\n+\n+  private static LengthBounds calculateSszListLength(\n+      final ReflectionInformation reflectionInfo, final int variableFieldCount) {\n+    final LengthBounds fieldLengthBounds;\n+    final Class<?> listElementType = reflectionInfo.getListElementTypes().get(variableFieldCount);\n+    final long listElementMaxSize = reflectionInfo.getListElementMaxSizes().get(variableFieldCount);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "594899ff515d30ae3f6e1b8d0dc6085d2632a583"}, "originalPosition": 108}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e5067df9cd7c4021c88d55544fd535a03482cdcd", "author": {"user": {"login": "ajsutton", "name": "Adrian Sutton"}}, "url": "https://github.com/ConsenSys/teku/commit/e5067df9cd7c4021c88d55544fd535a03482cdcd", "committedDate": "2020-07-15T21:21:46Z", "message": "Count SSZList and bitlist fields separately."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0fdba1fb3c477c0c667561a3089fa6ed4eddd702", "author": {"user": {"login": "ajsutton", "name": "Adrian Sutton"}}, "url": "https://github.com/ConsenSys/teku/commit/0fdba1fb3c477c0c667561a3089fa6ed4eddd702", "committedDate": "2020-07-15T21:24:38Z", "message": "Merge branch 'master' of github.com:PegaSysEng/teku into calculate-ssz-lengths"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3840, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}