{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIxNTMzOTM0", "number": 1836, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQwMDowMDoyN1rOD-yZwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNFQyMTo0ODoxNFrOD_Oisw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MTY0MDk3OnYy", "diffSide": "RIGHT", "path": "ethereum/datastructures/src/main/java/tech/pegasys/teku/datastructures/forkchoice/DelayableAttestation.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQwMDowMDoyN1rOGZGn5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNzo0Mzo1OVrOGZfEhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk3NjEwMQ==", "bodyText": "This should be volatile as it could potentially be accessed from multiple threads.", "url": "https://github.com/ConsenSys/teku/pull/1836#discussion_r428976101", "createdAt": "2020-05-22T00:00:27Z", "author": {"login": "ajsutton"}, "path": "ethereum/datastructures/src/main/java/tech/pegasys/teku/datastructures/forkchoice/DelayableAttestation.java", "diffHunk": "@@ -11,29 +11,43 @@\n  * specific language governing permissions and limitations under the License.\n  */\n \n-package tech.pegasys.teku.sync;\n+package tech.pegasys.teku.datastructures.forkchoice;\n \n import com.google.common.primitives.UnsignedLong;\n import java.util.Collection;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+\n import org.apache.tuweni.bytes.Bytes32;\n import tech.pegasys.teku.datastructures.operations.Attestation;\n+import tech.pegasys.teku.datastructures.operations.IndexedAttestation;\n \n public class DelayableAttestation {\n   private final Attestation attestation;\n-  private final Runnable onSuccessfulProcessing;\n+  private final Consumer<Attestation> onSuccessfulProcessing;\n+\n+  private Optional<IndexedAttestation> maybeIndexedAttestation = Optional.empty();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "628c22b4a8d745eecdeb75ca6895935c5f82f5f5"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM3NjY0NQ==", "bodyText": "Makes sense.", "url": "https://github.com/ConsenSys/teku/pull/1836#discussion_r429376645", "createdAt": "2020-05-22T17:43:59Z", "author": {"login": "cemozerr"}, "path": "ethereum/datastructures/src/main/java/tech/pegasys/teku/datastructures/forkchoice/DelayableAttestation.java", "diffHunk": "@@ -11,29 +11,43 @@\n  * specific language governing permissions and limitations under the License.\n  */\n \n-package tech.pegasys.teku.sync;\n+package tech.pegasys.teku.datastructures.forkchoice;\n \n import com.google.common.primitives.UnsignedLong;\n import java.util.Collection;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+\n import org.apache.tuweni.bytes.Bytes32;\n import tech.pegasys.teku.datastructures.operations.Attestation;\n+import tech.pegasys.teku.datastructures.operations.IndexedAttestation;\n \n public class DelayableAttestation {\n   private final Attestation attestation;\n-  private final Runnable onSuccessfulProcessing;\n+  private final Consumer<Attestation> onSuccessfulProcessing;\n+\n+  private Optional<IndexedAttestation> maybeIndexedAttestation = Optional.empty();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk3NjEwMQ=="}, "originalCommit": {"oid": "628c22b4a8d745eecdeb75ca6895935c5f82f5f5"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MTY1MTYzOnYy", "diffSide": "RIGHT", "path": "ethereum/statetransition/src/main/java/tech/pegasys/teku/statetransition/forkchoice/ForkChoice.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQwMDowNjo1NlrOGZGubg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNzo1Nzo1NFrOGZfdbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk3Nzc3NA==", "bodyText": "I'd say this should just take an IndexedAttestation and push responsibility for ensuring IndexedAttestation all the way up to AttestationManager.  It shouldn't ever add an attestation to FutureAttestation that hasn't passed validation.", "url": "https://github.com/ConsenSys/teku/pull/1836#discussion_r428977774", "createdAt": "2020-05-22T00:06:56Z", "author": {"login": "ajsutton"}, "path": "ethereum/statetransition/src/main/java/tech/pegasys/teku/statetransition/forkchoice/ForkChoice.java", "diffHunk": "@@ -71,11 +72,19 @@ public synchronized BlockImportResult onBlock(final SignedBeaconBlock block) {\n   }\n \n   public AttestationProcessingResult onAttestation(\n-      final MutableStore store, final Attestation attestation) {\n+      final MutableStore store, final DelayableAttestation attestation) {\n     return on_attestation(store, attestation, stateTransition, protoArrayForkChoiceStrategy);\n   }\n \n-  @Override\n+  public void applyIndexedAttestation(\n+          final MutableStore store, final DelayableAttestation attestation) {\n+    protoArrayForkChoiceStrategy.onAttestation(store, attestation.getIndexedAttestation()\n+            .orElseThrow(() -> new IllegalStateException(\"Future attestation should have had a proper indexed attestation.\"))\n+    );", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "628c22b4a8d745eecdeb75ca6895935c5f82f5f5"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM3ODgwNA==", "bodyText": "In that case, would FutureAttestation only holding IndexedAttestations make sense?", "url": "https://github.com/ConsenSys/teku/pull/1836#discussion_r429378804", "createdAt": "2020-05-22T17:49:06Z", "author": {"login": "cemozerr"}, "path": "ethereum/statetransition/src/main/java/tech/pegasys/teku/statetransition/forkchoice/ForkChoice.java", "diffHunk": "@@ -71,11 +72,19 @@ public synchronized BlockImportResult onBlock(final SignedBeaconBlock block) {\n   }\n \n   public AttestationProcessingResult onAttestation(\n-      final MutableStore store, final Attestation attestation) {\n+      final MutableStore store, final DelayableAttestation attestation) {\n     return on_attestation(store, attestation, stateTransition, protoArrayForkChoiceStrategy);\n   }\n \n-  @Override\n+  public void applyIndexedAttestation(\n+          final MutableStore store, final DelayableAttestation attestation) {\n+    protoArrayForkChoiceStrategy.onAttestation(store, attestation.getIndexedAttestation()\n+            .orElseThrow(() -> new IllegalStateException(\"Future attestation should have had a proper indexed attestation.\"))\n+    );", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk3Nzc3NA=="}, "originalCommit": {"oid": "628c22b4a8d745eecdeb75ca6895935c5f82f5f5"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM4MTE0Mw==", "bodyText": "One downside is that maybe we want to pass the attestation back to the networking layer once we take it out from FutureAttestation. Also, keeping a reference to the DelayableAttestation (the higher-level object) is more in line with the ValidateableAttestation concept, so I might just keep items in FutureAttestation as DelayableAttestations.", "url": "https://github.com/ConsenSys/teku/pull/1836#discussion_r429381143", "createdAt": "2020-05-22T17:53:19Z", "author": {"login": "cemozerr"}, "path": "ethereum/statetransition/src/main/java/tech/pegasys/teku/statetransition/forkchoice/ForkChoice.java", "diffHunk": "@@ -71,11 +72,19 @@ public synchronized BlockImportResult onBlock(final SignedBeaconBlock block) {\n   }\n \n   public AttestationProcessingResult onAttestation(\n-      final MutableStore store, final Attestation attestation) {\n+      final MutableStore store, final DelayableAttestation attestation) {\n     return on_attestation(store, attestation, stateTransition, protoArrayForkChoiceStrategy);\n   }\n \n-  @Override\n+  public void applyIndexedAttestation(\n+          final MutableStore store, final DelayableAttestation attestation) {\n+    protoArrayForkChoiceStrategy.onAttestation(store, attestation.getIndexedAttestation()\n+            .orElseThrow(() -> new IllegalStateException(\"Future attestation should have had a proper indexed attestation.\"))\n+    );", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk3Nzc3NA=="}, "originalCommit": {"oid": "628c22b4a8d745eecdeb75ca6895935c5f82f5f5"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM4MzAyMA==", "bodyText": "Done.", "url": "https://github.com/ConsenSys/teku/pull/1836#discussion_r429383020", "createdAt": "2020-05-22T17:57:54Z", "author": {"login": "cemozerr"}, "path": "ethereum/statetransition/src/main/java/tech/pegasys/teku/statetransition/forkchoice/ForkChoice.java", "diffHunk": "@@ -71,11 +72,19 @@ public synchronized BlockImportResult onBlock(final SignedBeaconBlock block) {\n   }\n \n   public AttestationProcessingResult onAttestation(\n-      final MutableStore store, final Attestation attestation) {\n+      final MutableStore store, final DelayableAttestation attestation) {\n     return on_attestation(store, attestation, stateTransition, protoArrayForkChoiceStrategy);\n   }\n \n-  @Override\n+  public void applyIndexedAttestation(\n+          final MutableStore store, final DelayableAttestation attestation) {\n+    protoArrayForkChoiceStrategy.onAttestation(store, attestation.getIndexedAttestation()\n+            .orElseThrow(() -> new IllegalStateException(\"Future attestation should have had a proper indexed attestation.\"))\n+    );", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk3Nzc3NA=="}, "originalCommit": {"oid": "628c22b4a8d745eecdeb75ca6895935c5f82f5f5"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MTY1NjkzOnYy", "diffSide": "RIGHT", "path": "ethereum/statetransition/src/main/java/tech/pegasys/teku/statetransition/attestation/ForkChoiceAttestationProcessor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQwMDoxMDoxMVrOGZGxxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNzo1ODoxOVrOGZfeHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk3ODYyOQ==", "bodyText": "Just take an IndexedAttestation here.", "url": "https://github.com/ConsenSys/teku/pull/1836#discussion_r428978629", "createdAt": "2020-05-22T00:10:11Z", "author": {"login": "ajsutton"}, "path": "ethereum/statetransition/src/main/java/tech/pegasys/teku/statetransition/attestation/ForkChoiceAttestationProcessor.java", "diffHunk": "@@ -30,12 +31,18 @@ public ForkChoiceAttestationProcessor(\n     this.forkChoice = forkChoice;\n   }\n \n-  public AttestationProcessingResult processAttestation(final Attestation attestation) {\n+  public AttestationProcessingResult processAttestation(final DelayableAttestation attestation) {\n     final Store.Transaction transaction = recentChainData.startStoreTransaction();\n     final AttestationProcessingResult result = forkChoice.onAttestation(transaction, attestation);\n     if (result.isSuccessful()) {\n       transaction.commit(() -> {}, \"Failed to persist attestation result\");\n     }\n     return result;\n   }\n+\n+  public void applyAttestationToForkChoice(final DelayableAttestation attestation) {\n+    final Store.Transaction transaction = recentChainData.startStoreTransaction();\n+    forkChoice.applyIndexedAttestation(transaction, attestation);\n+    transaction.commit(() -> {}, \"Failed to persist attestation result\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "628c22b4a8d745eecdeb75ca6895935c5f82f5f5"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM4MzE5OQ==", "bodyText": "Done.", "url": "https://github.com/ConsenSys/teku/pull/1836#discussion_r429383199", "createdAt": "2020-05-22T17:58:19Z", "author": {"login": "cemozerr"}, "path": "ethereum/statetransition/src/main/java/tech/pegasys/teku/statetransition/attestation/ForkChoiceAttestationProcessor.java", "diffHunk": "@@ -30,12 +31,18 @@ public ForkChoiceAttestationProcessor(\n     this.forkChoice = forkChoice;\n   }\n \n-  public AttestationProcessingResult processAttestation(final Attestation attestation) {\n+  public AttestationProcessingResult processAttestation(final DelayableAttestation attestation) {\n     final Store.Transaction transaction = recentChainData.startStoreTransaction();\n     final AttestationProcessingResult result = forkChoice.onAttestation(transaction, attestation);\n     if (result.isSuccessful()) {\n       transaction.commit(() -> {}, \"Failed to persist attestation result\");\n     }\n     return result;\n   }\n+\n+  public void applyAttestationToForkChoice(final DelayableAttestation attestation) {\n+    final Store.Transaction transaction = recentChainData.startStoreTransaction();\n+    forkChoice.applyIndexedAttestation(transaction, attestation);\n+    transaction.commit(() -> {}, \"Failed to persist attestation result\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk3ODYyOQ=="}, "originalCommit": {"oid": "628c22b4a8d745eecdeb75ca6895935c5f82f5f5"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MTY2MTY2OnYy", "diffSide": "RIGHT", "path": "sync/src/main/java/tech/pegasys/teku/sync/AttestationManager.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQwMDoxMjoyOFrOGZG0bA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNFQyMTo1MDoyMlrOGZxf3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk3OTMwOA==", "bodyText": "This is where I'd check the IndexedAttestation exists and log an error if it doesn't indicating that somehow an unvalidated attestation got into the future pool (then don't process it obviously).\nAt the moment you could actually make futureAttestations just hold IndexedAttestation but that's only because we aren't currently calling delayableAttestation.onAttestationProcessedSuccessfully for attestations we process from futureAttestations.", "url": "https://github.com/ConsenSys/teku/pull/1836#discussion_r428979308", "createdAt": "2020-05-22T00:12:28Z", "author": {"login": "ajsutton"}, "path": "sync/src/main/java/tech/pegasys/teku/sync/AttestationManager.java", "diffHunk": "@@ -41,47 +41,48 @@\n \n   private final PendingPool<DelayableAttestation> pendingAttestations;\n   private final FutureItems<DelayableAttestation> futureAttestations;\n+  private final AggregatingAttestationPool aggregatingAttestationPool;\n \n   AttestationManager(\n-      final EventBus eventBus,\n-      final ForkChoiceAttestationProcessor attestationProcessor,\n-      final PendingPool<DelayableAttestation> pendingAttestations,\n-      final FutureItems<DelayableAttestation> futureAttestations) {\n+          final EventBus eventBus,\n+          final ForkChoiceAttestationProcessor attestationProcessor,\n+          final PendingPool<DelayableAttestation> pendingAttestations,\n+          final FutureItems<DelayableAttestation> futureAttestations,\n+          final AggregatingAttestationPool aggregatingAttestationPool) {\n     this.eventBus = eventBus;\n     this.attestationProcessor = attestationProcessor;\n     this.pendingAttestations = pendingAttestations;\n     this.futureAttestations = futureAttestations;\n+    this.aggregatingAttestationPool = aggregatingAttestationPool;\n   }\n \n   public static AttestationManager create(\n       final EventBus eventBus,\n       final PendingPool<DelayableAttestation> pendingAttestations,\n       final FutureItems<DelayableAttestation> futureAttestations,\n-      final ForkChoiceAttestationProcessor forkChoiceAttestationProcessor) {\n+      final ForkChoiceAttestationProcessor forkChoiceAttestationProcessor,\n+      final AggregatingAttestationPool aggregatingAttestationPool) {\n     return new AttestationManager(\n-        eventBus, forkChoiceAttestationProcessor, pendingAttestations, futureAttestations);\n+        eventBus, forkChoiceAttestationProcessor, pendingAttestations, futureAttestations, aggregatingAttestationPool);\n   }\n \n   @Subscribe\n   @SuppressWarnings(\"unused\")\n   private void onGossipedAttestation(final Attestation attestation) {\n-    processAttestation(\n-        new DelayableAttestation(\n-            attestation, () -> eventBus.post(new ProcessedAttestationEvent(attestation))));\n+    processAttestation(new DelayableAttestation(attestation, aggregatingAttestationPool::add));\n   }\n \n   @Subscribe\n   @SuppressWarnings(\"unused\")\n   private void onAggregateAndProof(final SignedAggregateAndProof aggregateAndProof) {\n-    final Attestation aggregate = aggregateAndProof.getMessage().getAggregate();\n-    processAttestation(\n-        new DelayableAttestation(\n-            aggregate, () -> eventBus.post(new ProcessedAggregateEvent(aggregate))));\n+    final Attestation aggregateAttestation = aggregateAndProof.getMessage().getAggregate();\n+    processAttestation(new DelayableAttestation(aggregateAttestation, aggregatingAttestationPool::add));\n+\n   }\n \n   @Override\n   public void onSlot(final UnsignedLong slot) {\n-    futureAttestations.prune(slot).forEach(this::processAttestation);\n+    futureAttestations.prune(slot).forEach(attestationProcessor::applyAttestationToForkChoice);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "628c22b4a8d745eecdeb75ca6895935c5f82f5f5"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM4MzkzMw==", "bodyText": "This is exactly what I did after reading your previous comment and having not seen this :D", "url": "https://github.com/ConsenSys/teku/pull/1836#discussion_r429383933", "createdAt": "2020-05-22T18:00:06Z", "author": {"login": "cemozerr"}, "path": "sync/src/main/java/tech/pegasys/teku/sync/AttestationManager.java", "diffHunk": "@@ -41,47 +41,48 @@\n \n   private final PendingPool<DelayableAttestation> pendingAttestations;\n   private final FutureItems<DelayableAttestation> futureAttestations;\n+  private final AggregatingAttestationPool aggregatingAttestationPool;\n \n   AttestationManager(\n-      final EventBus eventBus,\n-      final ForkChoiceAttestationProcessor attestationProcessor,\n-      final PendingPool<DelayableAttestation> pendingAttestations,\n-      final FutureItems<DelayableAttestation> futureAttestations) {\n+          final EventBus eventBus,\n+          final ForkChoiceAttestationProcessor attestationProcessor,\n+          final PendingPool<DelayableAttestation> pendingAttestations,\n+          final FutureItems<DelayableAttestation> futureAttestations,\n+          final AggregatingAttestationPool aggregatingAttestationPool) {\n     this.eventBus = eventBus;\n     this.attestationProcessor = attestationProcessor;\n     this.pendingAttestations = pendingAttestations;\n     this.futureAttestations = futureAttestations;\n+    this.aggregatingAttestationPool = aggregatingAttestationPool;\n   }\n \n   public static AttestationManager create(\n       final EventBus eventBus,\n       final PendingPool<DelayableAttestation> pendingAttestations,\n       final FutureItems<DelayableAttestation> futureAttestations,\n-      final ForkChoiceAttestationProcessor forkChoiceAttestationProcessor) {\n+      final ForkChoiceAttestationProcessor forkChoiceAttestationProcessor,\n+      final AggregatingAttestationPool aggregatingAttestationPool) {\n     return new AttestationManager(\n-        eventBus, forkChoiceAttestationProcessor, pendingAttestations, futureAttestations);\n+        eventBus, forkChoiceAttestationProcessor, pendingAttestations, futureAttestations, aggregatingAttestationPool);\n   }\n \n   @Subscribe\n   @SuppressWarnings(\"unused\")\n   private void onGossipedAttestation(final Attestation attestation) {\n-    processAttestation(\n-        new DelayableAttestation(\n-            attestation, () -> eventBus.post(new ProcessedAttestationEvent(attestation))));\n+    processAttestation(new DelayableAttestation(attestation, aggregatingAttestationPool::add));\n   }\n \n   @Subscribe\n   @SuppressWarnings(\"unused\")\n   private void onAggregateAndProof(final SignedAggregateAndProof aggregateAndProof) {\n-    final Attestation aggregate = aggregateAndProof.getMessage().getAggregate();\n-    processAttestation(\n-        new DelayableAttestation(\n-            aggregate, () -> eventBus.post(new ProcessedAggregateEvent(aggregate))));\n+    final Attestation aggregateAttestation = aggregateAndProof.getMessage().getAggregate();\n+    processAttestation(new DelayableAttestation(aggregateAttestation, aggregatingAttestationPool::add));\n+\n   }\n \n   @Override\n   public void onSlot(final UnsignedLong slot) {\n-    futureAttestations.prune(slot).forEach(this::processAttestation);\n+    futureAttestations.prune(slot).forEach(attestationProcessor::applyAttestationToForkChoice);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk3OTMwOA=="}, "originalCommit": {"oid": "628c22b4a8d745eecdeb75ca6895935c5f82f5f5"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY3NzE1Nw==", "bodyText": "But now we're never even able to call onAttestationProcessedSuccessfully when the delayed attestation is actually processed.   I guess the event it fires doesn't actually do anything for now, but we'll probably have to change this back when we want to start gossiping attestations after we process them (if we haven't already).\nAlthough, whether we gossiped something or not seems like a nice thing to track in ValidatableAttestation so maybe it will work out...", "url": "https://github.com/ConsenSys/teku/pull/1836#discussion_r429677157", "createdAt": "2020-05-24T21:29:33Z", "author": {"login": "ajsutton"}, "path": "sync/src/main/java/tech/pegasys/teku/sync/AttestationManager.java", "diffHunk": "@@ -41,47 +41,48 @@\n \n   private final PendingPool<DelayableAttestation> pendingAttestations;\n   private final FutureItems<DelayableAttestation> futureAttestations;\n+  private final AggregatingAttestationPool aggregatingAttestationPool;\n \n   AttestationManager(\n-      final EventBus eventBus,\n-      final ForkChoiceAttestationProcessor attestationProcessor,\n-      final PendingPool<DelayableAttestation> pendingAttestations,\n-      final FutureItems<DelayableAttestation> futureAttestations) {\n+          final EventBus eventBus,\n+          final ForkChoiceAttestationProcessor attestationProcessor,\n+          final PendingPool<DelayableAttestation> pendingAttestations,\n+          final FutureItems<DelayableAttestation> futureAttestations,\n+          final AggregatingAttestationPool aggregatingAttestationPool) {\n     this.eventBus = eventBus;\n     this.attestationProcessor = attestationProcessor;\n     this.pendingAttestations = pendingAttestations;\n     this.futureAttestations = futureAttestations;\n+    this.aggregatingAttestationPool = aggregatingAttestationPool;\n   }\n \n   public static AttestationManager create(\n       final EventBus eventBus,\n       final PendingPool<DelayableAttestation> pendingAttestations,\n       final FutureItems<DelayableAttestation> futureAttestations,\n-      final ForkChoiceAttestationProcessor forkChoiceAttestationProcessor) {\n+      final ForkChoiceAttestationProcessor forkChoiceAttestationProcessor,\n+      final AggregatingAttestationPool aggregatingAttestationPool) {\n     return new AttestationManager(\n-        eventBus, forkChoiceAttestationProcessor, pendingAttestations, futureAttestations);\n+        eventBus, forkChoiceAttestationProcessor, pendingAttestations, futureAttestations, aggregatingAttestationPool);\n   }\n \n   @Subscribe\n   @SuppressWarnings(\"unused\")\n   private void onGossipedAttestation(final Attestation attestation) {\n-    processAttestation(\n-        new DelayableAttestation(\n-            attestation, () -> eventBus.post(new ProcessedAttestationEvent(attestation))));\n+    processAttestation(new DelayableAttestation(attestation, aggregatingAttestationPool::add));\n   }\n \n   @Subscribe\n   @SuppressWarnings(\"unused\")\n   private void onAggregateAndProof(final SignedAggregateAndProof aggregateAndProof) {\n-    final Attestation aggregate = aggregateAndProof.getMessage().getAggregate();\n-    processAttestation(\n-        new DelayableAttestation(\n-            aggregate, () -> eventBus.post(new ProcessedAggregateEvent(aggregate))));\n+    final Attestation aggregateAttestation = aggregateAndProof.getMessage().getAggregate();\n+    processAttestation(new DelayableAttestation(aggregateAttestation, aggregatingAttestationPool::add));\n+\n   }\n \n   @Override\n   public void onSlot(final UnsignedLong slot) {\n-    futureAttestations.prune(slot).forEach(this::processAttestation);\n+    futureAttestations.prune(slot).forEach(attestationProcessor::applyAttestationToForkChoice);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk3OTMwOA=="}, "originalCommit": {"oid": "628c22b4a8d745eecdeb75ca6895935c5f82f5f5"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY3ODU1OQ==", "bodyText": "Looking at how all the code has worked out this bit now makes more sense - we're not firing the unused events any more - the on processed event just adds it to the aggregate pool which we've already done for saved attestations.", "url": "https://github.com/ConsenSys/teku/pull/1836#discussion_r429678559", "createdAt": "2020-05-24T21:50:22Z", "author": {"login": "ajsutton"}, "path": "sync/src/main/java/tech/pegasys/teku/sync/AttestationManager.java", "diffHunk": "@@ -41,47 +41,48 @@\n \n   private final PendingPool<DelayableAttestation> pendingAttestations;\n   private final FutureItems<DelayableAttestation> futureAttestations;\n+  private final AggregatingAttestationPool aggregatingAttestationPool;\n \n   AttestationManager(\n-      final EventBus eventBus,\n-      final ForkChoiceAttestationProcessor attestationProcessor,\n-      final PendingPool<DelayableAttestation> pendingAttestations,\n-      final FutureItems<DelayableAttestation> futureAttestations) {\n+          final EventBus eventBus,\n+          final ForkChoiceAttestationProcessor attestationProcessor,\n+          final PendingPool<DelayableAttestation> pendingAttestations,\n+          final FutureItems<DelayableAttestation> futureAttestations,\n+          final AggregatingAttestationPool aggregatingAttestationPool) {\n     this.eventBus = eventBus;\n     this.attestationProcessor = attestationProcessor;\n     this.pendingAttestations = pendingAttestations;\n     this.futureAttestations = futureAttestations;\n+    this.aggregatingAttestationPool = aggregatingAttestationPool;\n   }\n \n   public static AttestationManager create(\n       final EventBus eventBus,\n       final PendingPool<DelayableAttestation> pendingAttestations,\n       final FutureItems<DelayableAttestation> futureAttestations,\n-      final ForkChoiceAttestationProcessor forkChoiceAttestationProcessor) {\n+      final ForkChoiceAttestationProcessor forkChoiceAttestationProcessor,\n+      final AggregatingAttestationPool aggregatingAttestationPool) {\n     return new AttestationManager(\n-        eventBus, forkChoiceAttestationProcessor, pendingAttestations, futureAttestations);\n+        eventBus, forkChoiceAttestationProcessor, pendingAttestations, futureAttestations, aggregatingAttestationPool);\n   }\n \n   @Subscribe\n   @SuppressWarnings(\"unused\")\n   private void onGossipedAttestation(final Attestation attestation) {\n-    processAttestation(\n-        new DelayableAttestation(\n-            attestation, () -> eventBus.post(new ProcessedAttestationEvent(attestation))));\n+    processAttestation(new DelayableAttestation(attestation, aggregatingAttestationPool::add));\n   }\n \n   @Subscribe\n   @SuppressWarnings(\"unused\")\n   private void onAggregateAndProof(final SignedAggregateAndProof aggregateAndProof) {\n-    final Attestation aggregate = aggregateAndProof.getMessage().getAggregate();\n-    processAttestation(\n-        new DelayableAttestation(\n-            aggregate, () -> eventBus.post(new ProcessedAggregateEvent(aggregate))));\n+    final Attestation aggregateAttestation = aggregateAndProof.getMessage().getAggregate();\n+    processAttestation(new DelayableAttestation(aggregateAttestation, aggregatingAttestationPool::add));\n+\n   }\n \n   @Override\n   public void onSlot(final UnsignedLong slot) {\n-    futureAttestations.prune(slot).forEach(this::processAttestation);\n+    futureAttestations.prune(slot).forEach(attestationProcessor::applyAttestationToForkChoice);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk3OTMwOA=="}, "originalCommit": {"oid": "628c22b4a8d745eecdeb75ca6895935c5f82f5f5"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MTY3ODcxOnYy", "diffSide": "RIGHT", "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/gossip/topics/validation/AttestationValidator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQwMDoyMjo1M1rOGZG-yA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxODowMTowOFrOGZfirA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk4MTk2MA==", "bodyText": "10 is probably too generous actually.  Really the only reason for this to happen is clock drift or if Teku is lagging behind slightly so 99% of the time it will only be one slot ahead so I'd probably limit it to something like 3 - that gives a 36 second buffer which should be plenty.", "url": "https://github.com/ConsenSys/teku/pull/1836#discussion_r428981960", "createdAt": "2020-05-22T00:22:53Z", "author": {"login": "ajsutton"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/gossip/topics/validation/AttestationValidator.java", "diffHunk": "@@ -41,6 +41,7 @@\n \n public class AttestationValidator {\n \n+  private static final UnsignedLong MAX_FUTURE_SLOT_ALLOWANCE = UnsignedLong.valueOf(10);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e199ed07dff7bca30ed21fe290f6d3d1eabe3670"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM4NDM2NA==", "bodyText": "Yeah that makes sense. Can't believe I gave a 120 second buffer \ud83d\ude02", "url": "https://github.com/ConsenSys/teku/pull/1836#discussion_r429384364", "createdAt": "2020-05-22T18:01:08Z", "author": {"login": "cemozerr"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/gossip/topics/validation/AttestationValidator.java", "diffHunk": "@@ -41,6 +41,7 @@\n \n public class AttestationValidator {\n \n+  private static final UnsignedLong MAX_FUTURE_SLOT_ALLOWANCE = UnsignedLong.valueOf(10);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk4MTk2MA=="}, "originalCommit": {"oid": "e199ed07dff7bca30ed21fe290f6d3d1eabe3670"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MTY4MTcwOnYy", "diffSide": "RIGHT", "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/gossip/topics/validation/AttestationValidator.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQwMDoyNDozOFrOGZHAnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxODoxMjoyN1rOGZf0-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk4MjQyOA==", "bodyText": "Is it just me or should isAfterPropagationSlotRange really be isBeforePropagationSlotRange?  ie it's valid if it's after the propagation slot range and invalid if it's from too far back.", "url": "https://github.com/ConsenSys/teku/pull/1836#discussion_r428982428", "createdAt": "2020-05-22T00:24:38Z", "author": {"login": "ajsutton"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/gossip/topics/validation/AttestationValidator.java", "diffHunk": "@@ -105,7 +106,8 @@ ValidationResult singleOrAggregateAttestationChecks(final Attestation attestatio\n     // queue\n     // future attestations for processing at the appropriate slot).\n     final UnsignedLong currentTimeMillis = secondsToMillis(recentChainData.getStore().getTime());\n-    if (isAfterPropagationSlotRange(currentTimeMillis, attestation)) {\n+    if (isAfterPropagationSlotRange(currentTimeMillis, attestation)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e199ed07dff7bca30ed21fe290f6d3d1eabe3670"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM4NDY5OQ==", "bodyText": "Yes it should be isBefore, I'll do the switch.", "url": "https://github.com/ConsenSys/teku/pull/1836#discussion_r429384699", "createdAt": "2020-05-22T18:01:59Z", "author": {"login": "cemozerr"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/gossip/topics/validation/AttestationValidator.java", "diffHunk": "@@ -105,7 +106,8 @@ ValidationResult singleOrAggregateAttestationChecks(final Attestation attestatio\n     // queue\n     // future attestations for processing at the appropriate slot).\n     final UnsignedLong currentTimeMillis = secondsToMillis(recentChainData.getStore().getTime());\n-    if (isAfterPropagationSlotRange(currentTimeMillis, attestation)) {\n+    if (isAfterPropagationSlotRange(currentTimeMillis, attestation)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk4MjQyOA=="}, "originalCommit": {"oid": "e199ed07dff7bca30ed21fe290f6d3d1eabe3670"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM4ODgyNw==", "bodyText": "No, on second thought, isAfterPropagationSlotRange is correct. Because it does not refer to the attestation, it refers to the current time. Current time is after the attestations propagation slot range, thus the naming. I'll change these methods to:\n\nisCurrentTimeAfterAttestationPropagationSlotRange\nisCurrentTimeBeforeMinimumAttestationBroadcastTime", "url": "https://github.com/ConsenSys/teku/pull/1836#discussion_r429388827", "createdAt": "2020-05-22T18:11:55Z", "author": {"login": "cemozerr"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/gossip/topics/validation/AttestationValidator.java", "diffHunk": "@@ -105,7 +106,8 @@ ValidationResult singleOrAggregateAttestationChecks(final Attestation attestatio\n     // queue\n     // future attestations for processing at the appropriate slot).\n     final UnsignedLong currentTimeMillis = secondsToMillis(recentChainData.getStore().getTime());\n-    if (isAfterPropagationSlotRange(currentTimeMillis, attestation)) {\n+    if (isAfterPropagationSlotRange(currentTimeMillis, attestation)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk4MjQyOA=="}, "originalCommit": {"oid": "e199ed07dff7bca30ed21fe290f6d3d1eabe3670"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM4OTA0OA==", "bodyText": "all for 50 character method names.", "url": "https://github.com/ConsenSys/teku/pull/1836#discussion_r429389048", "createdAt": "2020-05-22T18:12:27Z", "author": {"login": "cemozerr"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/gossip/topics/validation/AttestationValidator.java", "diffHunk": "@@ -105,7 +106,8 @@ ValidationResult singleOrAggregateAttestationChecks(final Attestation attestatio\n     // queue\n     // future attestations for processing at the appropriate slot).\n     final UnsignedLong currentTimeMillis = secondsToMillis(recentChainData.getStore().getTime());\n-    if (isAfterPropagationSlotRange(currentTimeMillis, attestation)) {\n+    if (isAfterPropagationSlotRange(currentTimeMillis, attestation)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk4MjQyOA=="}, "originalCommit": {"oid": "e199ed07dff7bca30ed21fe290f6d3d1eabe3670"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MTcwMDIzOnYy", "diffSide": "RIGHT", "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/gossip/topics/validation/AttestationValidator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQwMDozNjowMlrOGZHLuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxODoxNDowNlrOGZf3SQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk4NTI3NQ==", "bodyText": "nit: Suggest extracting the currentTimeMillis.plus bit to a variable - something like discardAttestationsAfterMillis.  Just makes the comparison clearer.", "url": "https://github.com/ConsenSys/teku/pull/1836#discussion_r428985275", "createdAt": "2020-05-22T00:36:02Z", "author": {"login": "ajsutton"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/gossip/topics/validation/AttestationValidator.java", "diffHunk": "@@ -152,6 +154,18 @@ private boolean isBeforeMinimumBroadcastTime(\n     return currentTimeMillis.compareTo(minimumBroadcastTimeMillis) < 0;\n   }\n \n+  private boolean isFromFarFuture(\n+          final Attestation attestation, final UnsignedLong currentTimeMillis) {\n+    final UnsignedLong attestationSlotTimeMillis =\n+            secondsToMillis(recentChainData\n+                    .getGenesisTime()\n+                    .plus(attestation.getEarliestSlotForForkChoiceProcessing()\n+                            .times(UnsignedLong.valueOf(SECONDS_PER_SLOT))\n+                    ));\n+    return attestationSlotTimeMillis.compareTo(currentTimeMillis\n+            .plus(secondsToMillis(MAX_FUTURE_SLOT_ALLOWANCE.times(UnsignedLong.valueOf(SECONDS_PER_SLOT))))) > 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e199ed07dff7bca30ed21fe290f6d3d1eabe3670"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTM4OTY0MQ==", "bodyText": "Makes sense. Done.", "url": "https://github.com/ConsenSys/teku/pull/1836#discussion_r429389641", "createdAt": "2020-05-22T18:14:06Z", "author": {"login": "cemozerr"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/gossip/topics/validation/AttestationValidator.java", "diffHunk": "@@ -152,6 +154,18 @@ private boolean isBeforeMinimumBroadcastTime(\n     return currentTimeMillis.compareTo(minimumBroadcastTimeMillis) < 0;\n   }\n \n+  private boolean isFromFarFuture(\n+          final Attestation attestation, final UnsignedLong currentTimeMillis) {\n+    final UnsignedLong attestationSlotTimeMillis =\n+            secondsToMillis(recentChainData\n+                    .getGenesisTime()\n+                    .plus(attestation.getEarliestSlotForForkChoiceProcessing()\n+                            .times(UnsignedLong.valueOf(SECONDS_PER_SLOT))\n+                    ));\n+    return attestationSlotTimeMillis.compareTo(currentTimeMillis\n+            .plus(secondsToMillis(MAX_FUTURE_SLOT_ALLOWANCE.times(UnsignedLong.valueOf(SECONDS_PER_SLOT))))) > 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk4NTI3NQ=="}, "originalCommit": {"oid": "e199ed07dff7bca30ed21fe290f6d3d1eabe3670"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NjI1MTM5OnYy", "diffSide": "RIGHT", "path": "sync/src/test/java/tech/pegasys/teku/sync/AttestationManagerTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNFQyMTo0ODoxNFrOGZxfWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxNzowNjo1MlrOGaoBWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY3ODQyNA==", "bodyText": "ewww, spies...  All the checks on on these can be done quite effectively just using it's size method to see if anything has been added or not.\nI'd also suggest adding a method:\nprivate void verifyAttestationProcessed(final Attestation attestation) {\n    ArgumentCaptor<DelayableAttestation> captor =\n        ArgumentCaptor.forClass(DelayableAttestation.class);\n    verify(attestationProcessor).processAttestation(captor.capture());\n    assertThat(captor.getValue().getAttestation()).isSameAs(attestation);\n  }\n\nwhich will let you be more specific instead of using verify(attestationProcessor).processAttestation(attestation).", "url": "https://github.com/ConsenSys/teku/pull/1836#discussion_r429678424", "createdAt": "2020-05-24T21:48:14Z", "author": {"login": "ajsutton"}, "path": "sync/src/test/java/tech/pegasys/teku/sync/AttestationManagerTest.java", "diffHunk": "@@ -25,45 +30,41 @@\n \n import com.google.common.eventbus.EventBus;\n import com.google.common.primitives.UnsignedLong;\n-import java.util.List;\n import org.apache.tuweni.bytes.Bytes32;\n import org.junit.jupiter.api.AfterEach;\n import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n+import org.mockito.ArgumentCaptor;\n import tech.pegasys.teku.bls.BLSSignature;\n import tech.pegasys.teku.core.results.AttestationProcessingResult;\n import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n-import tech.pegasys.teku.datastructures.operations.AggregateAndProof;\n+import tech.pegasys.teku.datastructures.forkchoice.DelayableAttestation;\n import tech.pegasys.teku.datastructures.operations.Attestation;\n import tech.pegasys.teku.datastructures.operations.AttestationData;\n+import tech.pegasys.teku.datastructures.operations.IndexedAttestation;\n import tech.pegasys.teku.datastructures.operations.SignedAggregateAndProof;\n import tech.pegasys.teku.datastructures.state.Checkpoint;\n import tech.pegasys.teku.datastructures.util.DataStructureUtil;\n import tech.pegasys.teku.ssz.SSZTypes.Bitlist;\n+import tech.pegasys.teku.statetransition.attestation.AggregatingAttestationPool;\n import tech.pegasys.teku.statetransition.attestation.ForkChoiceAttestationProcessor;\n-import tech.pegasys.teku.statetransition.events.attestation.ProcessedAggregateEvent;\n-import tech.pegasys.teku.statetransition.events.attestation.ProcessedAttestationEvent;\n import tech.pegasys.teku.statetransition.events.block.ImportedBlockEvent;\n-import tech.pegasys.teku.util.EventSink;\n \n class AttestationManagerTest {\n   private final DataStructureUtil dataStructureUtil = new DataStructureUtil();\n   private final EventBus eventBus = new EventBus();\n-  private final PendingPool<DelayableAttestation> pendingAttestations =\n-      PendingPool.createForAttestations();\n-  private final FutureItems<DelayableAttestation> futureAttestations =\n-      new FutureItems<>(DelayableAttestation::getEarliestSlotForForkChoiceProcessing);\n \n-  private final ForkChoiceAttestationProcessor attestationProcessor =\n+  private AggregatingAttestationPool attestationPool = mock(AggregatingAttestationPool.class);\n+  private ForkChoiceAttestationProcessor attestationProcessor =\n       mock(ForkChoiceAttestationProcessor.class);\n-  private final List<ProcessedAttestationEvent> processedAttestationEvents =\n-      EventSink.capture(eventBus, ProcessedAttestationEvent.class);\n-  private final List<ProcessedAggregateEvent> processedAggregateEvents =\n-      EventSink.capture(eventBus, ProcessedAggregateEvent.class);\n+  private final PendingPool<DelayableAttestation> pendingAttestations =\n+      spy(PendingPool.createForAttestations());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f745abfeb309b414a3ffa9b291c610ece57aade9"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU3MTg2Ng==", "bodyText": "Done :D. Thanks for the suggestion.", "url": "https://github.com/ConsenSys/teku/pull/1836#discussion_r430571866", "createdAt": "2020-05-26T17:06:52Z", "author": {"login": "cemozerr"}, "path": "sync/src/test/java/tech/pegasys/teku/sync/AttestationManagerTest.java", "diffHunk": "@@ -25,45 +30,41 @@\n \n import com.google.common.eventbus.EventBus;\n import com.google.common.primitives.UnsignedLong;\n-import java.util.List;\n import org.apache.tuweni.bytes.Bytes32;\n import org.junit.jupiter.api.AfterEach;\n import org.junit.jupiter.api.BeforeEach;\n import org.junit.jupiter.api.Test;\n+import org.mockito.ArgumentCaptor;\n import tech.pegasys.teku.bls.BLSSignature;\n import tech.pegasys.teku.core.results.AttestationProcessingResult;\n import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n-import tech.pegasys.teku.datastructures.operations.AggregateAndProof;\n+import tech.pegasys.teku.datastructures.forkchoice.DelayableAttestation;\n import tech.pegasys.teku.datastructures.operations.Attestation;\n import tech.pegasys.teku.datastructures.operations.AttestationData;\n+import tech.pegasys.teku.datastructures.operations.IndexedAttestation;\n import tech.pegasys.teku.datastructures.operations.SignedAggregateAndProof;\n import tech.pegasys.teku.datastructures.state.Checkpoint;\n import tech.pegasys.teku.datastructures.util.DataStructureUtil;\n import tech.pegasys.teku.ssz.SSZTypes.Bitlist;\n+import tech.pegasys.teku.statetransition.attestation.AggregatingAttestationPool;\n import tech.pegasys.teku.statetransition.attestation.ForkChoiceAttestationProcessor;\n-import tech.pegasys.teku.statetransition.events.attestation.ProcessedAggregateEvent;\n-import tech.pegasys.teku.statetransition.events.attestation.ProcessedAttestationEvent;\n import tech.pegasys.teku.statetransition.events.block.ImportedBlockEvent;\n-import tech.pegasys.teku.util.EventSink;\n \n class AttestationManagerTest {\n   private final DataStructureUtil dataStructureUtil = new DataStructureUtil();\n   private final EventBus eventBus = new EventBus();\n-  private final PendingPool<DelayableAttestation> pendingAttestations =\n-      PendingPool.createForAttestations();\n-  private final FutureItems<DelayableAttestation> futureAttestations =\n-      new FutureItems<>(DelayableAttestation::getEarliestSlotForForkChoiceProcessing);\n \n-  private final ForkChoiceAttestationProcessor attestationProcessor =\n+  private AggregatingAttestationPool attestationPool = mock(AggregatingAttestationPool.class);\n+  private ForkChoiceAttestationProcessor attestationProcessor =\n       mock(ForkChoiceAttestationProcessor.class);\n-  private final List<ProcessedAttestationEvent> processedAttestationEvents =\n-      EventSink.capture(eventBus, ProcessedAttestationEvent.class);\n-  private final List<ProcessedAggregateEvent> processedAggregateEvents =\n-      EventSink.capture(eventBus, ProcessedAggregateEvent.class);\n+  private final PendingPool<DelayableAttestation> pendingAttestations =\n+      spy(PendingPool.createForAttestations());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY3ODQyNA=="}, "originalCommit": {"oid": "f745abfeb309b414a3ffa9b291c610ece57aade9"}, "originalPosition": 61}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3651, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}