{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM0OTY5ODE3", "number": 2156, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxMzo1MDozMlrOEF8oeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxMzo1Mjo0MFrOEF8skg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0NjcxNzM2OnYy", "diffSide": "RIGHT", "path": "networking/eth2/src/test/java/tech/pegasys/teku/networking/eth2/rpc/beaconchain/methods/BeaconBlocksByRangeMessageHandlerTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxMzo1MDozMlrOGkcTXA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMjo0ODoxMFrOGkvwSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDg2NTYyOA==", "bodyText": "nit: We could make the test more explicit by saying count = Constants.MAX_BLOCK_BY_RANGE_REQUEST_SIZE + 1", "url": "https://github.com/ConsenSys/teku/pull/2156#discussion_r440865628", "createdAt": "2020-06-16T13:50:32Z", "author": {"login": "cemozerr"}, "path": "networking/eth2/src/test/java/tech/pegasys/teku/networking/eth2/rpc/beaconchain/methods/BeaconBlocksByRangeMessageHandlerTest.java", "diffHunk": "@@ -269,6 +272,23 @@ public void shouldRejectRequestWhenStepIsZero() {\n     verifyNoMoreInteractions(combinedChainDataClient);\n   }\n \n+  @Test\n+  void shouldLimitNumberOfBlocksReturned() {\n+    final RequestState requestState =\n+        new RequestState(\n+            new BeaconBlocksByRangeRequestMessage(\n+                UnsignedLong.ZERO, UnsignedLong.valueOf(500), UnsignedLong.ONE),\n+            UnsignedLong.valueOf(10000),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc801f3567dbe615da05df81708193548e26c44b"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE4NDMzMA==", "bodyText": "Done.", "url": "https://github.com/ConsenSys/teku/pull/2156#discussion_r441184330", "createdAt": "2020-06-16T22:48:10Z", "author": {"login": "ajsutton"}, "path": "networking/eth2/src/test/java/tech/pegasys/teku/networking/eth2/rpc/beaconchain/methods/BeaconBlocksByRangeMessageHandlerTest.java", "diffHunk": "@@ -269,6 +272,23 @@ public void shouldRejectRequestWhenStepIsZero() {\n     verifyNoMoreInteractions(combinedChainDataClient);\n   }\n \n+  @Test\n+  void shouldLimitNumberOfBlocksReturned() {\n+    final RequestState requestState =\n+        new RequestState(\n+            new BeaconBlocksByRangeRequestMessage(\n+                UnsignedLong.ZERO, UnsignedLong.valueOf(500), UnsignedLong.ONE),\n+            UnsignedLong.valueOf(10000),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDg2NTYyOA=="}, "originalCommit": {"oid": "bc801f3567dbe615da05df81708193548e26c44b"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0NjcyNzg2OnYy", "diffSide": "RIGHT", "path": "storage/src/main/java/tech/pegasys/teku/storage/client/RecentChainData.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxMzo1Mjo0MFrOGkcZ7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMjo0NToyNlrOGkvstw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDg2NzMwOA==", "bodyText": "Are we okay with not being able to get any block root before finalization?", "url": "https://github.com/ConsenSys/teku/pull/2156#discussion_r440867308", "createdAt": "2020-06-16T13:52:40Z", "author": {"login": "cemozerr"}, "path": "storage/src/main/java/tech/pegasys/teku/storage/client/RecentChainData.java", "diffHunk": "@@ -304,87 +308,17 @@ public boolean containsBlock(final Bytes32 root) {\n     return Optional.ofNullable(store.getBlockState(blockRoot));\n   }\n \n-  public Optional<BeaconBlock> getBlockBySlot(final UnsignedLong slot) {\n-    return getBlockRootBySlot(slot)\n-        .map(blockRoot -> store.getBlock(blockRoot))\n-        .filter(block -> block.getSlot().equals(slot));\n-  }\n-\n   public Optional<BeaconState> getStateInEffectAtSlot(final UnsignedLong slot) {\n     return getBlockRootBySlot(slot).map(blockRoot -> store.getBlockState(blockRoot));\n   }\n \n-  public boolean isIncludedInBestState(final Bytes32 blockRoot) {\n-    if (store == null) {\n-      return false;\n-    }\n-    final BeaconBlock block = store.getBlock(blockRoot);\n-    if (block == null) {\n-      return false;\n-    }\n-    return getBlockRootBySlot(block.getSlot())\n-        .map(actualRoot -> actualRoot.equals(block.hash_tree_root()))\n-        .orElse(false);\n-  }\n-\n   public Optional<Bytes32> getBlockRootBySlot(final UnsignedLong slot) {\n-    if (store == null || chainHead.isEmpty() || isHistoricalBlockRootAtSlotUnavailable(slot)) {\n-      return Optional.empty();\n-    }\n-    return getBlockRootBySlot(slot, chainHead.get());\n+    return chainHead.flatMap(head -> getBlockRootBySlot(slot, head.getRoot()));\n   }\n \n-  public Optional<Bytes32> getBlockRootBySlot(final UnsignedLong slot, final Bytes32 headRoot) {\n-    if (store == null || isHistoricalBlockRootAtSlotUnavailable(slot)) {\n-      return Optional.empty();\n-    }\n-    return store.getBlockAndState(headRoot).flatMap(head -> getBlockRootBySlot(slot, head));\n-  }\n-\n-  private boolean isHistoricalBlockRootAtSlotUnavailable(final UnsignedLong slot) {\n-    // If slot is prior to genesis, it is not available\n-    final UnsignedLong genesisSlot = UnsignedLong.valueOf(Constants.GENESIS_SLOT);\n-    if (slot.compareTo(genesisSlot) < 0) {\n-      return true;\n-    }\n-\n-    // If slot is out of range of the latest finalized block, it is unavailable\n-    final UnsignedLong slotsPerHistoricalRoot = UnsignedLong.valueOf(SLOTS_PER_HISTORICAL_ROOT);\n-    final UnsignedLong oldestAvailableState = store.getLatestFinalizedBlockSlot();\n-    final UnsignedLong oldestAvailableRoot =\n-        oldestAvailableState.compareTo(slotsPerHistoricalRoot) >= 0\n-            ? oldestAvailableState.minus(slotsPerHistoricalRoot)\n-            : UnsignedLong.ZERO;\n-    return slot.compareTo(oldestAvailableRoot) < 0;\n-  }\n-\n-  private Optional<Bytes32> getBlockRootBySlot(\n-      final UnsignedLong slot, final SignedBlockAndState headBlock) {\n-    checkNotNull(slot);\n-    final UnsignedLong slotsPerHistoricalRoot = UnsignedLong.valueOf(SLOTS_PER_HISTORICAL_ROOT);\n-    // Since older blocks are pruned - query the newest queryable slot where possible\n-    final UnsignedLong youngestQueryableSlot = slot.plus(slotsPerHistoricalRoot);\n-\n-    SignedBlockAndState currentBlock = headBlock;\n-    while (currentBlock != null) {\n-      if (currentBlock.getSlot().compareTo(slot) <= 0) {\n-        // The current block is less than or equal to the target slot, so it must be the block in\n-        // effect\n-        return Optional.of(currentBlock.getRoot());\n-      }\n-      if (BeaconStateUtil.isBlockRootAvailableFromState(currentBlock.getState(), slot)) {\n-        // The root is available from the current state\n-        return Optional.of(BeaconStateUtil.get_block_root_at_slot(currentBlock.getState(), slot));\n-      }\n-\n-      // Pull an older block to search\n-      final UnsignedLong oldestQueryableSlot = currentBlock.getSlot().minus(slotsPerHistoricalRoot);\n-      final UnsignedLong olderSlot = max(youngestQueryableSlot, oldestQueryableSlot);\n-      final Bytes32 olderRoot = get_block_root_at_slot(currentBlock.getState(), olderSlot);\n-      currentBlock = store.getBlockAndState(olderRoot).orElse(null);\n-    }\n-\n-    return Optional.empty();\n+  public Optional<Bytes32> getBlockRootBySlot(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bc801f3567dbe615da05df81708193548e26c44b"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDg3MDEzOA==", "bodyText": "If we do want to use ProtoArray for collecting block roots pre-finalization, we could modify it in such a way that findHead (and thus computeDeltas) would not traverse through ProtoNodes pre-finalization, and stop at the finalization slot, but we'd still have access to information on nodes pre-finalization. This way ForkChoice could stay efficient.", "url": "https://github.com/ConsenSys/teku/pull/2156#discussion_r440870138", "createdAt": "2020-06-16T13:56:14Z", "author": {"login": "cemozerr"}, "path": "storage/src/main/java/tech/pegasys/teku/storage/client/RecentChainData.java", "diffHunk": "@@ -304,87 +308,17 @@ public boolean containsBlock(final Bytes32 root) {\n     return Optional.ofNullable(store.getBlockState(blockRoot));\n   }\n \n-  public Optional<BeaconBlock> getBlockBySlot(final UnsignedLong slot) {\n-    return getBlockRootBySlot(slot)\n-        .map(blockRoot -> store.getBlock(blockRoot))\n-        .filter(block -> block.getSlot().equals(slot));\n-  }\n-\n   public Optional<BeaconState> getStateInEffectAtSlot(final UnsignedLong slot) {\n     return getBlockRootBySlot(slot).map(blockRoot -> store.getBlockState(blockRoot));\n   }\n \n-  public boolean isIncludedInBestState(final Bytes32 blockRoot) {\n-    if (store == null) {\n-      return false;\n-    }\n-    final BeaconBlock block = store.getBlock(blockRoot);\n-    if (block == null) {\n-      return false;\n-    }\n-    return getBlockRootBySlot(block.getSlot())\n-        .map(actualRoot -> actualRoot.equals(block.hash_tree_root()))\n-        .orElse(false);\n-  }\n-\n   public Optional<Bytes32> getBlockRootBySlot(final UnsignedLong slot) {\n-    if (store == null || chainHead.isEmpty() || isHistoricalBlockRootAtSlotUnavailable(slot)) {\n-      return Optional.empty();\n-    }\n-    return getBlockRootBySlot(slot, chainHead.get());\n+    return chainHead.flatMap(head -> getBlockRootBySlot(slot, head.getRoot()));\n   }\n \n-  public Optional<Bytes32> getBlockRootBySlot(final UnsignedLong slot, final Bytes32 headRoot) {\n-    if (store == null || isHistoricalBlockRootAtSlotUnavailable(slot)) {\n-      return Optional.empty();\n-    }\n-    return store.getBlockAndState(headRoot).flatMap(head -> getBlockRootBySlot(slot, head));\n-  }\n-\n-  private boolean isHistoricalBlockRootAtSlotUnavailable(final UnsignedLong slot) {\n-    // If slot is prior to genesis, it is not available\n-    final UnsignedLong genesisSlot = UnsignedLong.valueOf(Constants.GENESIS_SLOT);\n-    if (slot.compareTo(genesisSlot) < 0) {\n-      return true;\n-    }\n-\n-    // If slot is out of range of the latest finalized block, it is unavailable\n-    final UnsignedLong slotsPerHistoricalRoot = UnsignedLong.valueOf(SLOTS_PER_HISTORICAL_ROOT);\n-    final UnsignedLong oldestAvailableState = store.getLatestFinalizedBlockSlot();\n-    final UnsignedLong oldestAvailableRoot =\n-        oldestAvailableState.compareTo(slotsPerHistoricalRoot) >= 0\n-            ? oldestAvailableState.minus(slotsPerHistoricalRoot)\n-            : UnsignedLong.ZERO;\n-    return slot.compareTo(oldestAvailableRoot) < 0;\n-  }\n-\n-  private Optional<Bytes32> getBlockRootBySlot(\n-      final UnsignedLong slot, final SignedBlockAndState headBlock) {\n-    checkNotNull(slot);\n-    final UnsignedLong slotsPerHistoricalRoot = UnsignedLong.valueOf(SLOTS_PER_HISTORICAL_ROOT);\n-    // Since older blocks are pruned - query the newest queryable slot where possible\n-    final UnsignedLong youngestQueryableSlot = slot.plus(slotsPerHistoricalRoot);\n-\n-    SignedBlockAndState currentBlock = headBlock;\n-    while (currentBlock != null) {\n-      if (currentBlock.getSlot().compareTo(slot) <= 0) {\n-        // The current block is less than or equal to the target slot, so it must be the block in\n-        // effect\n-        return Optional.of(currentBlock.getRoot());\n-      }\n-      if (BeaconStateUtil.isBlockRootAvailableFromState(currentBlock.getState(), slot)) {\n-        // The root is available from the current state\n-        return Optional.of(BeaconStateUtil.get_block_root_at_slot(currentBlock.getState(), slot));\n-      }\n-\n-      // Pull an older block to search\n-      final UnsignedLong oldestQueryableSlot = currentBlock.getSlot().minus(slotsPerHistoricalRoot);\n-      final UnsignedLong olderSlot = max(youngestQueryableSlot, oldestQueryableSlot);\n-      final Bytes32 olderRoot = get_block_root_at_slot(currentBlock.getState(), olderSlot);\n-      currentBlock = store.getBlockAndState(olderRoot).orElse(null);\n-    }\n-\n-    return Optional.empty();\n+  public Optional<Bytes32> getBlockRootBySlot(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDg2NzMwOA=="}, "originalCommit": {"oid": "bc801f3567dbe615da05df81708193548e26c44b"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE4MzQxNQ==", "bodyText": "There was always a limit to how far back we could go with RecentChainData anyway so I think it's fine if it cuts off at the finalised block.  We don't have the blocks or states before that anyway.", "url": "https://github.com/ConsenSys/teku/pull/2156#discussion_r441183415", "createdAt": "2020-06-16T22:45:26Z", "author": {"login": "ajsutton"}, "path": "storage/src/main/java/tech/pegasys/teku/storage/client/RecentChainData.java", "diffHunk": "@@ -304,87 +308,17 @@ public boolean containsBlock(final Bytes32 root) {\n     return Optional.ofNullable(store.getBlockState(blockRoot));\n   }\n \n-  public Optional<BeaconBlock> getBlockBySlot(final UnsignedLong slot) {\n-    return getBlockRootBySlot(slot)\n-        .map(blockRoot -> store.getBlock(blockRoot))\n-        .filter(block -> block.getSlot().equals(slot));\n-  }\n-\n   public Optional<BeaconState> getStateInEffectAtSlot(final UnsignedLong slot) {\n     return getBlockRootBySlot(slot).map(blockRoot -> store.getBlockState(blockRoot));\n   }\n \n-  public boolean isIncludedInBestState(final Bytes32 blockRoot) {\n-    if (store == null) {\n-      return false;\n-    }\n-    final BeaconBlock block = store.getBlock(blockRoot);\n-    if (block == null) {\n-      return false;\n-    }\n-    return getBlockRootBySlot(block.getSlot())\n-        .map(actualRoot -> actualRoot.equals(block.hash_tree_root()))\n-        .orElse(false);\n-  }\n-\n   public Optional<Bytes32> getBlockRootBySlot(final UnsignedLong slot) {\n-    if (store == null || chainHead.isEmpty() || isHistoricalBlockRootAtSlotUnavailable(slot)) {\n-      return Optional.empty();\n-    }\n-    return getBlockRootBySlot(slot, chainHead.get());\n+    return chainHead.flatMap(head -> getBlockRootBySlot(slot, head.getRoot()));\n   }\n \n-  public Optional<Bytes32> getBlockRootBySlot(final UnsignedLong slot, final Bytes32 headRoot) {\n-    if (store == null || isHistoricalBlockRootAtSlotUnavailable(slot)) {\n-      return Optional.empty();\n-    }\n-    return store.getBlockAndState(headRoot).flatMap(head -> getBlockRootBySlot(slot, head));\n-  }\n-\n-  private boolean isHistoricalBlockRootAtSlotUnavailable(final UnsignedLong slot) {\n-    // If slot is prior to genesis, it is not available\n-    final UnsignedLong genesisSlot = UnsignedLong.valueOf(Constants.GENESIS_SLOT);\n-    if (slot.compareTo(genesisSlot) < 0) {\n-      return true;\n-    }\n-\n-    // If slot is out of range of the latest finalized block, it is unavailable\n-    final UnsignedLong slotsPerHistoricalRoot = UnsignedLong.valueOf(SLOTS_PER_HISTORICAL_ROOT);\n-    final UnsignedLong oldestAvailableState = store.getLatestFinalizedBlockSlot();\n-    final UnsignedLong oldestAvailableRoot =\n-        oldestAvailableState.compareTo(slotsPerHistoricalRoot) >= 0\n-            ? oldestAvailableState.minus(slotsPerHistoricalRoot)\n-            : UnsignedLong.ZERO;\n-    return slot.compareTo(oldestAvailableRoot) < 0;\n-  }\n-\n-  private Optional<Bytes32> getBlockRootBySlot(\n-      final UnsignedLong slot, final SignedBlockAndState headBlock) {\n-    checkNotNull(slot);\n-    final UnsignedLong slotsPerHistoricalRoot = UnsignedLong.valueOf(SLOTS_PER_HISTORICAL_ROOT);\n-    // Since older blocks are pruned - query the newest queryable slot where possible\n-    final UnsignedLong youngestQueryableSlot = slot.plus(slotsPerHistoricalRoot);\n-\n-    SignedBlockAndState currentBlock = headBlock;\n-    while (currentBlock != null) {\n-      if (currentBlock.getSlot().compareTo(slot) <= 0) {\n-        // The current block is less than or equal to the target slot, so it must be the block in\n-        // effect\n-        return Optional.of(currentBlock.getRoot());\n-      }\n-      if (BeaconStateUtil.isBlockRootAvailableFromState(currentBlock.getState(), slot)) {\n-        // The root is available from the current state\n-        return Optional.of(BeaconStateUtil.get_block_root_at_slot(currentBlock.getState(), slot));\n-      }\n-\n-      // Pull an older block to search\n-      final UnsignedLong oldestQueryableSlot = currentBlock.getSlot().minus(slotsPerHistoricalRoot);\n-      final UnsignedLong olderSlot = max(youngestQueryableSlot, oldestQueryableSlot);\n-      final Bytes32 olderRoot = get_block_root_at_slot(currentBlock.getState(), olderSlot);\n-      currentBlock = store.getBlockAndState(olderRoot).orElse(null);\n-    }\n-\n-    return Optional.empty();\n+  public Optional<Bytes32> getBlockRootBySlot(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDg2NzMwOA=="}, "originalCommit": {"oid": "bc801f3567dbe615da05df81708193548e26c44b"}, "originalPosition": 150}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3608, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}