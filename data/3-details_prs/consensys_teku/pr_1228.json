{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc5OTE5MDI1", "number": 1228, "title": "Implement Eth1MinGenesisTimeBlockFinder", "bodyText": "PR Description\nThis PR implements Eth1MinGenesisTimeBlockFinder which will be later used to trigger genesis even if there are no deposits at the Eth1 block with the correct minimum timestamp.", "createdAt": "2020-02-26T00:46:21Z", "url": "https://github.com/ConsenSys/teku/pull/1228", "merged": true, "mergeCommit": {"oid": "8360ef14676508e5380609a64209a537c939e63f"}, "closed": true, "closedAt": "2020-02-26T20:46:56Z", "author": {"login": "cemozerr"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcH7zf2AH2gAyMzc5OTE5MDI1OjA2MTM5MmMwMjc5OTMyNzY4YmM1MWNjODcyMzQ3YjJjMmYzOTQwYzM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcIMygNAH2gAyMzc5OTE5MDI1OmViYTc0NmI2N2RkNTI5MDVjOTJjMzNjYmMyMzNiMTZhN2JmNGUzNzc=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "061392c0279932768bc51cc872347b2c2f3940c3", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/061392c0279932768bc51cc872347b2c2f3940c3", "committedDate": "2020-02-26T00:44:12Z", "message": "Implement & test Eth1MinGenesisTimeBlock"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0NTU1MDgx", "url": "https://github.com/ConsenSys/teku/pull/1228#pullrequestreview-364555081", "createdAt": "2020-02-26T00:50:24Z", "commit": {"oid": "061392c0279932768bc51cc872347b2c2f3940c3"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwMDo1MDoyNFrOFuatnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwMjoyNzozN1rOFucXlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIxNjQ3Nw==", "bodyText": "compare doesn't have to return 1, 0 or -1 just anything positive or negative so we need to either use a signum kind of function or an if to check for < 0 & > 0 rather than 1 and -1 specifically.", "url": "https://github.com/ConsenSys/teku/pull/1228#discussion_r384216477", "createdAt": "2020-02-26T00:50:24Z", "author": {"login": "ajsutton"}, "path": "pow/src/main/java/tech/pegasys/artemis/pow/Eth1MinGenesisTimeBlockFinder.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import io.reactivex.disposables.Disposable;\n+import java.math.BigInteger;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.api.MinGenesisTimeBlockEventChannel;\n+import tech.pegasys.artemis.pow.event.MinGenesisTimeBlockEvent;\n+import tech.pegasys.artemis.util.async.AsyncRunner;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class Eth1MinGenesisTimeBlockFinder {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final Eth1Provider eth1Provider;\n+  private final MinGenesisTimeBlockEventChannel minGenesisTimeBlockEventChannel;\n+  private final AsyncRunner asyncRunner;\n+\n+  private volatile Disposable latestBlockDisposable;\n+\n+  public Eth1MinGenesisTimeBlockFinder(\n+      Eth1Provider eth1Provider,\n+      MinGenesisTimeBlockEventChannel minGenesisTimeBlockEventChannel,\n+      AsyncRunner asyncRunner) {\n+    this.eth1Provider = eth1Provider;\n+    this.minGenesisTimeBlockEventChannel = minGenesisTimeBlockEventChannel;\n+    this.asyncRunner = asyncRunner;\n+  }\n+\n+  public void start() {\n+    findAndPublishFirstValidBlock()\n+        .finish(\n+            () ->\n+                LOG.info(\n+                    \"Eth1MinGenesisBlockFinder successfully found first \"\n+                        + \"(time) valid genesis block\"));\n+  }\n+\n+  public SafeFuture<Void> findAndPublishFirstValidBlock() {\n+    return eth1Provider\n+        .getLatestEth1BlockFuture()\n+        .thenApply(EthBlock.Block::getNumber)\n+        .thenApply(number -> number.subtract(Constants.ETH1_FOLLOW_DISTANCE.bigIntegerValue()))\n+        .thenApply(UnsignedLong::valueOf)\n+        .thenCompose(eth1Provider::getEth1BlockFuture)\n+        .thenCompose(\n+            block -> {\n+              SafeFuture<EthBlock.Block> firstValidBlockFuture;\n+              switch (compareBlockTimestampToMinGenesisTime(block)) {\n+                case 1:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "061392c0279932768bc51cc872347b2c2f3940c3"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIxNzQ0NA==", "bodyText": "nit: just return exploreBlocksDownwards(block)", "url": "https://github.com/ConsenSys/teku/pull/1228#discussion_r384217444", "createdAt": "2020-02-26T00:53:19Z", "author": {"login": "ajsutton"}, "path": "pow/src/main/java/tech/pegasys/artemis/pow/Eth1MinGenesisTimeBlockFinder.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import io.reactivex.disposables.Disposable;\n+import java.math.BigInteger;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.api.MinGenesisTimeBlockEventChannel;\n+import tech.pegasys.artemis.pow.event.MinGenesisTimeBlockEvent;\n+import tech.pegasys.artemis.util.async.AsyncRunner;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class Eth1MinGenesisTimeBlockFinder {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final Eth1Provider eth1Provider;\n+  private final MinGenesisTimeBlockEventChannel minGenesisTimeBlockEventChannel;\n+  private final AsyncRunner asyncRunner;\n+\n+  private volatile Disposable latestBlockDisposable;\n+\n+  public Eth1MinGenesisTimeBlockFinder(\n+      Eth1Provider eth1Provider,\n+      MinGenesisTimeBlockEventChannel minGenesisTimeBlockEventChannel,\n+      AsyncRunner asyncRunner) {\n+    this.eth1Provider = eth1Provider;\n+    this.minGenesisTimeBlockEventChannel = minGenesisTimeBlockEventChannel;\n+    this.asyncRunner = asyncRunner;\n+  }\n+\n+  public void start() {\n+    findAndPublishFirstValidBlock()\n+        .finish(\n+            () ->\n+                LOG.info(\n+                    \"Eth1MinGenesisBlockFinder successfully found first \"\n+                        + \"(time) valid genesis block\"));\n+  }\n+\n+  public SafeFuture<Void> findAndPublishFirstValidBlock() {\n+    return eth1Provider\n+        .getLatestEth1BlockFuture()\n+        .thenApply(EthBlock.Block::getNumber)\n+        .thenApply(number -> number.subtract(Constants.ETH1_FOLLOW_DISTANCE.bigIntegerValue()))\n+        .thenApply(UnsignedLong::valueOf)\n+        .thenCompose(eth1Provider::getEth1BlockFuture)\n+        .thenCompose(\n+            block -> {\n+              SafeFuture<EthBlock.Block> firstValidBlockFuture;\n+              switch (compareBlockTimestampToMinGenesisTime(block)) {\n+                case 1:\n+                  // If block timestamp is greater than min genesis time\n+                  // find first valid block in history\n+                  firstValidBlockFuture = findFirstValidBlockInHistory(block);\n+                  break;\n+                case 0:\n+                  firstValidBlockFuture = SafeFuture.completedFuture(block);\n+                  break;\n+                case -1:\n+                  // If block timestamp is less than min genesis time\n+                  // subscribe to new block events and wait for the first\n+                  // valid block\n+                  firstValidBlockFuture = waitForFirstValidBlock();\n+                  break;\n+                default:\n+                  throw new IllegalStateException(\n+                      \"Unexpected value: \"\n+                          + calculateCandidateGenesisTimestamp(block.getTimestamp())\n+                              .compareTo(Constants.MIN_GENESIS_TIME));\n+              }\n+              return firstValidBlockFuture;\n+            })\n+        .thenAccept(this::publishFirstValidBlock)\n+        .exceptionallyCompose(\n+            err -> {\n+              LOG.debug(\n+                  \"Eth1MinGenesisTimeBlockFinder failed to find first valid block. Retry in \"\n+                      + Constants.ETH1_MIN_GENESIS_TIME_BLOCK_RETRY_TIMEOUT\n+                      + \" seconds\",\n+                  err);\n+\n+              return asyncRunner.runAfterDelay(\n+                  this::findAndPublishFirstValidBlock,\n+                  Constants.ETH1_MIN_GENESIS_TIME_BLOCK_RETRY_TIMEOUT,\n+                  TimeUnit.SECONDS);\n+            });\n+  }\n+\n+  private void publishFirstValidBlock(EthBlock.Block block) {\n+    minGenesisTimeBlockEventChannel.onMinGenesisTimeBlock(\n+        new MinGenesisTimeBlockEvent(\n+            UnsignedLong.valueOf(block.getTimestamp()),\n+            UnsignedLong.valueOf(block.getNumber()),\n+            Bytes32.fromHexString(block.getHash())));\n+  }\n+\n+  /**\n+   * Find first estimationBlock that has timestamp that is greater than MIN_GENESIS_TIME\n+   *\n+   * @param estimationBlock estimationBlock that will be used for estimation\n+   * @return first valid block in history\n+   */\n+  private SafeFuture<EthBlock.Block> findFirstValidBlockInHistory(EthBlock.Block estimationBlock) {\n+    UnsignedLong estimatedFirstValidBlockNumber =\n+        getEstimatedFirstValidBlockNumber(estimationBlock, Constants.SECONDS_PER_ETH1_BLOCK);\n+    return eth1Provider\n+        .getEth1BlockFuture(estimatedFirstValidBlockNumber)\n+        .thenCompose(\n+            block -> {\n+              SafeFuture<EthBlock.Block> firstValidBlock;\n+              switch (compareBlockTimestampToMinGenesisTime(block)) {\n+                case 1:\n+                  // If block timestamp is greater than min genesis time\n+                  // explore blocks downwards\n+                  firstValidBlock = exploreBlocksDownwards(block);\n+                  break;\n+                case 0:\n+                  firstValidBlock = SafeFuture.completedFuture(block);\n+                  break;\n+                case -1:\n+                  // If block timestamp is less than min genesis time\n+                  // explore blocks upwards\n+                  firstValidBlock = exploreBlocksUpwards(block);\n+                  break;\n+                default:\n+                  throw new IllegalStateException(\n+                      \"Unexpected value: \"\n+                          + calculateCandidateGenesisTimestamp(block.getTimestamp())\n+                              .compareTo(Constants.MIN_GENESIS_TIME));\n+              }\n+              return firstValidBlock;\n+            });\n+  }\n+\n+  private SafeFuture<EthBlock.Block> exploreBlocksDownwards(EthBlock.Block previousBlock) {\n+    UnsignedLong previousBlockNumber = UnsignedLong.valueOf(previousBlock.getNumber());\n+    UnsignedLong newBlockNumber = previousBlockNumber.minus(UnsignedLong.ONE);\n+    SafeFuture<EthBlock.Block> blockFuture = eth1Provider.getEth1BlockFuture(newBlockNumber);\n+    return blockFuture.thenCompose(\n+        block -> {\n+          SafeFuture<EthBlock.Block> firstValidBlock;\n+          switch (compareBlockTimestampToMinGenesisTime(block)) {\n+            case 1:\n+              // If exploring downwards and block timestamp > min genesis time,\n+              // then block must still be downwards.\n+              firstValidBlock = exploreBlocksDownwards(block);\n+              break;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "061392c0279932768bc51cc872347b2c2f3940c3"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI0MTk5Ng==", "bodyText": "What happens if this fails?", "url": "https://github.com/ConsenSys/teku/pull/1228#discussion_r384241996", "createdAt": "2020-02-26T02:21:36Z", "author": {"login": "ajsutton"}, "path": "pow/src/main/java/tech/pegasys/artemis/pow/Eth1MinGenesisTimeBlockFinder.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import io.reactivex.disposables.Disposable;\n+import java.math.BigInteger;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.api.MinGenesisTimeBlockEventChannel;\n+import tech.pegasys.artemis.pow.event.MinGenesisTimeBlockEvent;\n+import tech.pegasys.artemis.util.async.AsyncRunner;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class Eth1MinGenesisTimeBlockFinder {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final Eth1Provider eth1Provider;\n+  private final MinGenesisTimeBlockEventChannel minGenesisTimeBlockEventChannel;\n+  private final AsyncRunner asyncRunner;\n+\n+  private volatile Disposable latestBlockDisposable;\n+\n+  public Eth1MinGenesisTimeBlockFinder(\n+      Eth1Provider eth1Provider,\n+      MinGenesisTimeBlockEventChannel minGenesisTimeBlockEventChannel,\n+      AsyncRunner asyncRunner) {\n+    this.eth1Provider = eth1Provider;\n+    this.minGenesisTimeBlockEventChannel = minGenesisTimeBlockEventChannel;\n+    this.asyncRunner = asyncRunner;\n+  }\n+\n+  public void start() {\n+    findAndPublishFirstValidBlock()\n+        .finish(\n+            () ->\n+                LOG.info(\n+                    \"Eth1MinGenesisBlockFinder successfully found first \"\n+                        + \"(time) valid genesis block\"));\n+  }\n+\n+  public SafeFuture<Void> findAndPublishFirstValidBlock() {\n+    return eth1Provider\n+        .getLatestEth1BlockFuture()\n+        .thenApply(EthBlock.Block::getNumber)\n+        .thenApply(number -> number.subtract(Constants.ETH1_FOLLOW_DISTANCE.bigIntegerValue()))\n+        .thenApply(UnsignedLong::valueOf)\n+        .thenCompose(eth1Provider::getEth1BlockFuture)\n+        .thenCompose(\n+            block -> {\n+              SafeFuture<EthBlock.Block> firstValidBlockFuture;\n+              switch (compareBlockTimestampToMinGenesisTime(block)) {\n+                case 1:\n+                  // If block timestamp is greater than min genesis time\n+                  // find first valid block in history\n+                  firstValidBlockFuture = findFirstValidBlockInHistory(block);\n+                  break;\n+                case 0:\n+                  firstValidBlockFuture = SafeFuture.completedFuture(block);\n+                  break;\n+                case -1:\n+                  // If block timestamp is less than min genesis time\n+                  // subscribe to new block events and wait for the first\n+                  // valid block\n+                  firstValidBlockFuture = waitForFirstValidBlock();\n+                  break;\n+                default:\n+                  throw new IllegalStateException(\n+                      \"Unexpected value: \"\n+                          + calculateCandidateGenesisTimestamp(block.getTimestamp())\n+                              .compareTo(Constants.MIN_GENESIS_TIME));\n+              }\n+              return firstValidBlockFuture;\n+            })\n+        .thenAccept(this::publishFirstValidBlock)\n+        .exceptionallyCompose(\n+            err -> {\n+              LOG.debug(\n+                  \"Eth1MinGenesisTimeBlockFinder failed to find first valid block. Retry in \"\n+                      + Constants.ETH1_MIN_GENESIS_TIME_BLOCK_RETRY_TIMEOUT\n+                      + \" seconds\",\n+                  err);\n+\n+              return asyncRunner.runAfterDelay(\n+                  this::findAndPublishFirstValidBlock,\n+                  Constants.ETH1_MIN_GENESIS_TIME_BLOCK_RETRY_TIMEOUT,\n+                  TimeUnit.SECONDS);\n+            });\n+  }\n+\n+  private void publishFirstValidBlock(EthBlock.Block block) {\n+    minGenesisTimeBlockEventChannel.onMinGenesisTimeBlock(\n+        new MinGenesisTimeBlockEvent(\n+            UnsignedLong.valueOf(block.getTimestamp()),\n+            UnsignedLong.valueOf(block.getNumber()),\n+            Bytes32.fromHexString(block.getHash())));\n+  }\n+\n+  /**\n+   * Find first estimationBlock that has timestamp that is greater than MIN_GENESIS_TIME\n+   *\n+   * @param estimationBlock estimationBlock that will be used for estimation\n+   * @return first valid block in history\n+   */\n+  private SafeFuture<EthBlock.Block> findFirstValidBlockInHistory(EthBlock.Block estimationBlock) {\n+    UnsignedLong estimatedFirstValidBlockNumber =\n+        getEstimatedFirstValidBlockNumber(estimationBlock, Constants.SECONDS_PER_ETH1_BLOCK);\n+    return eth1Provider\n+        .getEth1BlockFuture(estimatedFirstValidBlockNumber)\n+        .thenCompose(\n+            block -> {\n+              SafeFuture<EthBlock.Block> firstValidBlock;\n+              switch (compareBlockTimestampToMinGenesisTime(block)) {\n+                case 1:\n+                  // If block timestamp is greater than min genesis time\n+                  // explore blocks downwards\n+                  firstValidBlock = exploreBlocksDownwards(block);\n+                  break;\n+                case 0:\n+                  firstValidBlock = SafeFuture.completedFuture(block);\n+                  break;\n+                case -1:\n+                  // If block timestamp is less than min genesis time\n+                  // explore blocks upwards\n+                  firstValidBlock = exploreBlocksUpwards(block);\n+                  break;\n+                default:\n+                  throw new IllegalStateException(\n+                      \"Unexpected value: \"\n+                          + calculateCandidateGenesisTimestamp(block.getTimestamp())\n+                              .compareTo(Constants.MIN_GENESIS_TIME));\n+              }\n+              return firstValidBlock;\n+            });\n+  }\n+\n+  private SafeFuture<EthBlock.Block> exploreBlocksDownwards(EthBlock.Block previousBlock) {\n+    UnsignedLong previousBlockNumber = UnsignedLong.valueOf(previousBlock.getNumber());\n+    UnsignedLong newBlockNumber = previousBlockNumber.minus(UnsignedLong.ONE);\n+    SafeFuture<EthBlock.Block> blockFuture = eth1Provider.getEth1BlockFuture(newBlockNumber);\n+    return blockFuture.thenCompose(\n+        block -> {\n+          SafeFuture<EthBlock.Block> firstValidBlock;\n+          switch (compareBlockTimestampToMinGenesisTime(block)) {\n+            case 1:\n+              // If exploring downwards and block timestamp > min genesis time,\n+              // then block must still be downwards.\n+              firstValidBlock = exploreBlocksDownwards(block);\n+              break;\n+            case 0:\n+              firstValidBlock = SafeFuture.completedFuture(block);\n+              break;\n+            case -1:\n+              // If exploring downwards and block timestamp < min genesis time,\n+              // then previous block must have been the first valid block.\n+              firstValidBlock = SafeFuture.completedFuture(previousBlock);\n+              break;\n+            default:\n+              throw new IllegalStateException(\n+                  \"Unexpected value: \"\n+                      + calculateCandidateGenesisTimestamp(block.getTimestamp())\n+                          .compareTo(Constants.MIN_GENESIS_TIME));\n+          }\n+          return firstValidBlock;\n+        });\n+  }\n+\n+  private SafeFuture<EthBlock.Block> exploreBlocksUpwards(EthBlock.Block previousBlock) {\n+    UnsignedLong previousBlockNumber = UnsignedLong.valueOf(previousBlock.getNumber());\n+    UnsignedLong newBlockNumber = previousBlockNumber.plus(UnsignedLong.ONE);\n+    SafeFuture<EthBlock.Block> blockFuture = eth1Provider.getEth1BlockFuture(newBlockNumber);\n+    return blockFuture.thenCompose(\n+        block -> {\n+          SafeFuture<EthBlock.Block> firstValidBlock;\n+          switch (compareBlockTimestampToMinGenesisTime(block)) {\n+            case 1:\n+            case 0:\n+              // If exploring upwards and block timestamp >= min genesis time,\n+              // then current block must be the first valid block.\n+              firstValidBlock = SafeFuture.completedFuture(block);\n+              break;\n+            case -1:\n+              // If exploring upwards and block timestamp < min genesis time,\n+              // then previous block must have been the first valid block.\n+              firstValidBlock = exploreBlocksUpwards(block);\n+              break;\n+            default:\n+              throw new IllegalStateException(\n+                  \"Unexpected value: \"\n+                      + calculateCandidateGenesisTimestamp(block.getTimestamp())\n+                          .compareTo(Constants.MIN_GENESIS_TIME));\n+          }\n+          return firstValidBlock;\n+        });\n+  }\n+\n+  /**\n+   * Subscribes to latest block events and sees if the latest canonical block, i.e. the block at\n+   * follow distance, is the first valid block.\n+   *\n+   * @return first valid block\n+   */\n+  private SafeFuture<EthBlock.Block> waitForFirstValidBlock() {\n+    SafeFuture<EthBlock.Block> firstValidBlockFuture = new SafeFuture<>();\n+\n+    latestBlockDisposable =\n+        eth1Provider\n+            .getLatestBlockFlowable()\n+            .map(EthBlock.Block::getNumber)\n+            .map(number -> number.subtract(ETH1_FOLLOW_DISTANCE.bigIntegerValue()))\n+            .map(UnsignedLong::valueOf)\n+            .subscribe(\n+                blockNumber -> onNewBlock(blockNumber, firstValidBlockFuture),\n+                firstValidBlockFuture::completeExceptionally);\n+\n+    return firstValidBlockFuture;\n+  }\n+\n+  private void onNewBlock(\n+      UnsignedLong blockNumber, SafeFuture<EthBlock.Block> firstValidBlockFuture) {\n+    eth1Provider\n+        .getEth1BlockFuture(blockNumber)\n+        .thenAccept(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "061392c0279932768bc51cc872347b2c2f3940c3"}, "originalPosition": 241}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI0MzQzOA==", "bodyText": "Probably need to handle the case where we reach the ETH1 genesis block and are still after min genesis time.", "url": "https://github.com/ConsenSys/teku/pull/1228#discussion_r384243438", "createdAt": "2020-02-26T02:26:56Z", "author": {"login": "ajsutton"}, "path": "pow/src/main/java/tech/pegasys/artemis/pow/Eth1MinGenesisTimeBlockFinder.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import io.reactivex.disposables.Disposable;\n+import java.math.BigInteger;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.api.MinGenesisTimeBlockEventChannel;\n+import tech.pegasys.artemis.pow.event.MinGenesisTimeBlockEvent;\n+import tech.pegasys.artemis.util.async.AsyncRunner;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class Eth1MinGenesisTimeBlockFinder {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final Eth1Provider eth1Provider;\n+  private final MinGenesisTimeBlockEventChannel minGenesisTimeBlockEventChannel;\n+  private final AsyncRunner asyncRunner;\n+\n+  private volatile Disposable latestBlockDisposable;\n+\n+  public Eth1MinGenesisTimeBlockFinder(\n+      Eth1Provider eth1Provider,\n+      MinGenesisTimeBlockEventChannel minGenesisTimeBlockEventChannel,\n+      AsyncRunner asyncRunner) {\n+    this.eth1Provider = eth1Provider;\n+    this.minGenesisTimeBlockEventChannel = minGenesisTimeBlockEventChannel;\n+    this.asyncRunner = asyncRunner;\n+  }\n+\n+  public void start() {\n+    findAndPublishFirstValidBlock()\n+        .finish(\n+            () ->\n+                LOG.info(\n+                    \"Eth1MinGenesisBlockFinder successfully found first \"\n+                        + \"(time) valid genesis block\"));\n+  }\n+\n+  public SafeFuture<Void> findAndPublishFirstValidBlock() {\n+    return eth1Provider\n+        .getLatestEth1BlockFuture()\n+        .thenApply(EthBlock.Block::getNumber)\n+        .thenApply(number -> number.subtract(Constants.ETH1_FOLLOW_DISTANCE.bigIntegerValue()))\n+        .thenApply(UnsignedLong::valueOf)\n+        .thenCompose(eth1Provider::getEth1BlockFuture)\n+        .thenCompose(\n+            block -> {\n+              SafeFuture<EthBlock.Block> firstValidBlockFuture;\n+              switch (compareBlockTimestampToMinGenesisTime(block)) {\n+                case 1:\n+                  // If block timestamp is greater than min genesis time\n+                  // find first valid block in history\n+                  firstValidBlockFuture = findFirstValidBlockInHistory(block);\n+                  break;\n+                case 0:\n+                  firstValidBlockFuture = SafeFuture.completedFuture(block);\n+                  break;\n+                case -1:\n+                  // If block timestamp is less than min genesis time\n+                  // subscribe to new block events and wait for the first\n+                  // valid block\n+                  firstValidBlockFuture = waitForFirstValidBlock();\n+                  break;\n+                default:\n+                  throw new IllegalStateException(\n+                      \"Unexpected value: \"\n+                          + calculateCandidateGenesisTimestamp(block.getTimestamp())\n+                              .compareTo(Constants.MIN_GENESIS_TIME));\n+              }\n+              return firstValidBlockFuture;\n+            })\n+        .thenAccept(this::publishFirstValidBlock)\n+        .exceptionallyCompose(\n+            err -> {\n+              LOG.debug(\n+                  \"Eth1MinGenesisTimeBlockFinder failed to find first valid block. Retry in \"\n+                      + Constants.ETH1_MIN_GENESIS_TIME_BLOCK_RETRY_TIMEOUT\n+                      + \" seconds\",\n+                  err);\n+\n+              return asyncRunner.runAfterDelay(\n+                  this::findAndPublishFirstValidBlock,\n+                  Constants.ETH1_MIN_GENESIS_TIME_BLOCK_RETRY_TIMEOUT,\n+                  TimeUnit.SECONDS);\n+            });\n+  }\n+\n+  private void publishFirstValidBlock(EthBlock.Block block) {\n+    minGenesisTimeBlockEventChannel.onMinGenesisTimeBlock(\n+        new MinGenesisTimeBlockEvent(\n+            UnsignedLong.valueOf(block.getTimestamp()),\n+            UnsignedLong.valueOf(block.getNumber()),\n+            Bytes32.fromHexString(block.getHash())));\n+  }\n+\n+  /**\n+   * Find first estimationBlock that has timestamp that is greater than MIN_GENESIS_TIME\n+   *\n+   * @param estimationBlock estimationBlock that will be used for estimation\n+   * @return first valid block in history\n+   */\n+  private SafeFuture<EthBlock.Block> findFirstValidBlockInHistory(EthBlock.Block estimationBlock) {\n+    UnsignedLong estimatedFirstValidBlockNumber =\n+        getEstimatedFirstValidBlockNumber(estimationBlock, Constants.SECONDS_PER_ETH1_BLOCK);\n+    return eth1Provider\n+        .getEth1BlockFuture(estimatedFirstValidBlockNumber)\n+        .thenCompose(\n+            block -> {\n+              SafeFuture<EthBlock.Block> firstValidBlock;\n+              switch (compareBlockTimestampToMinGenesisTime(block)) {\n+                case 1:\n+                  // If block timestamp is greater than min genesis time\n+                  // explore blocks downwards\n+                  firstValidBlock = exploreBlocksDownwards(block);\n+                  break;\n+                case 0:\n+                  firstValidBlock = SafeFuture.completedFuture(block);\n+                  break;\n+                case -1:\n+                  // If block timestamp is less than min genesis time\n+                  // explore blocks upwards\n+                  firstValidBlock = exploreBlocksUpwards(block);\n+                  break;\n+                default:\n+                  throw new IllegalStateException(\n+                      \"Unexpected value: \"\n+                          + calculateCandidateGenesisTimestamp(block.getTimestamp())\n+                              .compareTo(Constants.MIN_GENESIS_TIME));\n+              }\n+              return firstValidBlock;\n+            });\n+  }\n+\n+  private SafeFuture<EthBlock.Block> exploreBlocksDownwards(EthBlock.Block previousBlock) {\n+    UnsignedLong previousBlockNumber = UnsignedLong.valueOf(previousBlock.getNumber());\n+    UnsignedLong newBlockNumber = previousBlockNumber.minus(UnsignedLong.ONE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "061392c0279932768bc51cc872347b2c2f3940c3"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI0MzYwNA==", "bodyText": "Stray character got inserted here.", "url": "https://github.com/ConsenSys/teku/pull/1228#discussion_r384243604", "createdAt": "2020-02-26T02:27:37Z", "author": {"login": "ajsutton"}, "path": "pow/README.md", "diffHunk": "@@ -1,4 +1,4 @@\n-## Proof of Work Chain Environmental Setup\n+\uffff## Proof of Work Chain Environmental Setup", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "061392c0279932768bc51cc872347b2c2f3940c3"}, "originalPosition": 2}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "945cf8015a25717764d0631e2d23db14023c94bc", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/945cf8015a25717764d0631e2d23db14023c94bc", "committedDate": "2020-02-26T17:08:44Z", "message": "Resolve comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7bfe18f34a7d08a069c96896020f03f08b8df06b", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/7bfe18f34a7d08a069c96896020f03f08b8df06b", "committedDate": "2020-02-26T19:17:37Z", "message": "Handle when requesting a future block errors out"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1MTg0NjAz", "url": "https://github.com/ConsenSys/teku/pull/1228#pullrequestreview-365184603", "createdAt": "2020-02-26T19:36:53Z", "commit": {"oid": "7bfe18f34a7d08a069c96896020f03f08b8df06b"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxOTozNjo1M1rOFu5Vjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxOTozNjo1M1rOFu5Vjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcxODIyMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        (err) -> firstValidBlockFuture.completeExceptionally(new RuntimeException(err)));\n          \n          \n            \n                        (err) -> firstValidBlockFuture.completeExceptionally(err));", "url": "https://github.com/ConsenSys/teku/pull/1228#discussion_r384718223", "createdAt": "2020-02-26T19:36:53Z", "author": {"login": "ajsutton"}, "path": "pow/src/main/java/tech/pegasys/artemis/pow/Eth1MinGenesisTimeBlockFinder.java", "diffHunk": "@@ -0,0 +1,249 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import io.reactivex.disposables.Disposable;\n+import java.math.BigInteger;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.api.MinGenesisTimeBlockEventChannel;\n+import tech.pegasys.artemis.pow.event.MinGenesisTimeBlockEvent;\n+import tech.pegasys.artemis.util.async.AsyncRunner;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class Eth1MinGenesisTimeBlockFinder {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final Eth1Provider eth1Provider;\n+  private final MinGenesisTimeBlockEventChannel minGenesisTimeBlockEventChannel;\n+  private final AsyncRunner asyncRunner;\n+\n+  private volatile Disposable latestBlockDisposable;\n+\n+  public Eth1MinGenesisTimeBlockFinder(\n+      Eth1Provider eth1Provider,\n+      MinGenesisTimeBlockEventChannel minGenesisTimeBlockEventChannel,\n+      AsyncRunner asyncRunner) {\n+    this.eth1Provider = eth1Provider;\n+    this.minGenesisTimeBlockEventChannel = minGenesisTimeBlockEventChannel;\n+    this.asyncRunner = asyncRunner;\n+  }\n+\n+  public void start() {\n+    findAndPublishFirstValidBlock()\n+        .finish(\n+            () ->\n+                LOG.info(\n+                    \"Eth1MinGenesisBlockFinder successfully found first \"\n+                        + \"(time) valid genesis block\"));\n+  }\n+\n+  public SafeFuture<Void> findAndPublishFirstValidBlock() {\n+    return eth1Provider\n+        .getLatestEth1BlockFuture()\n+        .thenApply(EthBlock.Block::getNumber)\n+        .thenApply(number -> number.subtract(Constants.ETH1_FOLLOW_DISTANCE.bigIntegerValue()))\n+        .thenApply(UnsignedLong::valueOf)\n+        .thenCompose(eth1Provider::getEth1BlockFuture)\n+        .thenCompose(\n+            block -> {\n+              int comparison = compareBlockTimestampToMinGenesisTime(block);\n+              if (comparison > 0) {\n+                // If block timestamp is greater than min genesis time\n+                // find first valid block in history\n+                return findFirstValidBlockInHistory(block);\n+              } else if (comparison < 0) {\n+                // If block timestamp is less than min genesis time\n+                // subscribe to new block events and wait for the first\n+                // valid block\n+                return waitForFirstValidBlock();\n+              } else {\n+                return SafeFuture.completedFuture(block);\n+              }\n+            })\n+        .thenAccept(this::publishFirstValidBlock)\n+        .exceptionallyCompose(\n+            err -> {\n+              LOG.debug(\n+                  \"Eth1MinGenesisTimeBlockFinder failed to find first valid block. Retry in \"\n+                      + Constants.ETH1_MIN_GENESIS_TIME_BLOCK_RETRY_TIMEOUT\n+                      + \" seconds\",\n+                  err);\n+\n+              return asyncRunner.runAfterDelay(\n+                  this::findAndPublishFirstValidBlock,\n+                  Constants.ETH1_MIN_GENESIS_TIME_BLOCK_RETRY_TIMEOUT,\n+                  TimeUnit.SECONDS);\n+            });\n+  }\n+\n+  private void publishFirstValidBlock(EthBlock.Block block) {\n+    minGenesisTimeBlockEventChannel.onMinGenesisTimeBlock(\n+        new MinGenesisTimeBlockEvent(\n+            UnsignedLong.valueOf(block.getTimestamp()),\n+            UnsignedLong.valueOf(block.getNumber()),\n+            Bytes32.fromHexString(block.getHash())));\n+  }\n+\n+  /**\n+   * Find first estimationBlock that has timestamp that is greater than MIN_GENESIS_TIME\n+   *\n+   * @param estimationBlock estimationBlock that will be used for estimation\n+   * @return first valid block in history\n+   */\n+  private SafeFuture<EthBlock.Block> findFirstValidBlockInHistory(EthBlock.Block estimationBlock) {\n+    UnsignedLong estimatedFirstValidBlockNumber =\n+        getEstimatedFirstValidBlockNumber(estimationBlock, Constants.SECONDS_PER_ETH1_BLOCK);\n+    return eth1Provider\n+        .getEth1BlockFuture(estimatedFirstValidBlockNumber)\n+        .thenCompose(\n+            block -> {\n+              int comparison = compareBlockTimestampToMinGenesisTime(block);\n+              if (comparison > 0) {\n+                // If block timestamp is greater than min genesis time\n+                // explore blocks downwards\n+                return exploreBlocksDownwards(block);\n+              } else if (comparison < 0) {\n+                // If block timestamp is less than min genesis time\n+                // explore blocks upwards\n+                return exploreBlocksUpwards(block);\n+              } else {\n+                return SafeFuture.completedFuture(block);\n+              }\n+            });\n+  }\n+\n+  private SafeFuture<EthBlock.Block> exploreBlocksDownwards(EthBlock.Block previousBlock) {\n+    if (previousBlock.getNumber().equals(BigInteger.ZERO)) {\n+      throw new RuntimeException(\n+          \"Reached Eth1Genesis before reaching a valid min Eth2 genesis time, \"\n+              + \"MIN_GENESIS_TIME constant must be wrong\");\n+    }\n+    UnsignedLong previousBlockNumber = UnsignedLong.valueOf(previousBlock.getNumber());\n+    UnsignedLong newBlockNumber = previousBlockNumber.minus(UnsignedLong.ONE);\n+    SafeFuture<EthBlock.Block> blockFuture = eth1Provider.getEth1BlockFuture(newBlockNumber);\n+    return blockFuture.thenCompose(\n+        block -> {\n+          int comparison = compareBlockTimestampToMinGenesisTime(block);\n+          if (comparison > 0) {\n+            // If exploring downwards and block timestamp > min genesis time,\n+            // then block must still be downwards.\n+            return exploreBlocksDownwards(block);\n+          } else if (comparison < 0) {\n+            // If exploring downwards and block timestamp < min genesis time,\n+            // then previous block must have been the first valid block.\n+            return SafeFuture.completedFuture(previousBlock);\n+          } else {\n+            return SafeFuture.completedFuture(block);\n+          }\n+        });\n+  }\n+\n+  private SafeFuture<EthBlock.Block> exploreBlocksUpwards(EthBlock.Block previousBlock) {\n+    UnsignedLong previousBlockNumber = UnsignedLong.valueOf(previousBlock.getNumber());\n+    UnsignedLong newBlockNumber = previousBlockNumber.plus(UnsignedLong.ONE);\n+    SafeFuture<EthBlock.Block> blockFuture = eth1Provider.getEth1BlockFuture(newBlockNumber);\n+    return blockFuture.thenCompose(\n+        block -> {\n+          int comparison = compareBlockTimestampToMinGenesisTime(block);\n+          if (comparison >= 0) {\n+            // If exploring upwards and block timestamp >= min genesis time,\n+            // then current block must be the first valid block.\n+            return SafeFuture.completedFuture(block);\n+          } else {\n+            // If exploring upwards and block timestamp < min genesis time,\n+            // then previous block must have been the first valid block.\n+            return exploreBlocksUpwards(block);\n+          }\n+        });\n+  }\n+\n+  /**\n+   * Subscribes to latest block events and sees if the latest canonical block, i.e. the block at\n+   * follow distance, is the first valid block.\n+   *\n+   * @return first valid block\n+   */\n+  private SafeFuture<EthBlock.Block> waitForFirstValidBlock() {\n+    SafeFuture<EthBlock.Block> firstValidBlockFuture = new SafeFuture<>();\n+\n+    latestBlockDisposable =\n+        eth1Provider\n+            .getLatestBlockFlowable()\n+            .map(EthBlock.Block::getNumber)\n+            .map(number -> number.subtract(ETH1_FOLLOW_DISTANCE.bigIntegerValue()))\n+            .map(UnsignedLong::valueOf)\n+            .subscribe(\n+                blockNumber -> onNewBlock(blockNumber, firstValidBlockFuture),\n+                firstValidBlockFuture::completeExceptionally);\n+\n+    return firstValidBlockFuture;\n+  }\n+\n+  private void onNewBlock(\n+      UnsignedLong blockNumber, SafeFuture<EthBlock.Block> firstValidBlockFuture) {\n+\n+    eth1Provider\n+        .getEth1BlockFuture(blockNumber)\n+        .thenAccept(\n+            block -> {\n+              if (compareBlockTimestampToMinGenesisTime(block) >= 0) {\n+                firstValidBlockFuture.complete(block);\n+                latestBlockDisposable.dispose();\n+              }\n+            })\n+        .finish(\n+            () -> {},\n+            (err) -> firstValidBlockFuture.completeExceptionally(new RuntimeException(err)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bfe18f34a7d08a069c96896020f03f08b8df06b"}, "originalPosition": 216}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eaa867db5cf41e33c40c29fbba060658a7cb3864", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/eaa867db5cf41e33c40c29fbba060658a7cb3864", "committedDate": "2020-02-26T20:24:41Z", "message": "Add test for error and recovery of blocks in the future"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eba746b67dd52905c92c33cbc233b16a7bf4e377", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/eba746b67dd52905c92c33cbc233b16a7bf4e377", "committedDate": "2020-02-26T20:31:30Z", "message": "Merge branch 'master' into triggerGenesisAccordingToTime"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4111, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}