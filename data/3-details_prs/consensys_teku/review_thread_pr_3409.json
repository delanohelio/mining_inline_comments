{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM5Njg3MTkx", "number": 3409, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQyMDo1NTo0N1rOFFOTqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQyMjo1Njo0OFrOFFTGcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxMDIxNjEwOnYy", "diffSide": "RIGHT", "path": "validator/client/src/main/java/tech/pegasys/teku/validator/client/DefaultValidatorStatusLogger.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQyMDo1NTo0N1rOIFoWuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQyMDo1NTo0N1rOIFoWuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjc3NDk3MQ==", "bodyText": "I recently added a retry utility (AsyncRunner.runWithRetry) that might be useful here.", "url": "https://github.com/ConsenSys/teku/pull/3409#discussion_r542774971", "createdAt": "2020-12-14T20:55:47Z", "author": {"login": "mbaxter"}, "path": "validator/client/src/main/java/tech/pegasys/teku/validator/client/DefaultValidatorStatusLogger.java", "diffHunk": "@@ -19,48 +19,66 @@\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.Objects;\n import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n import java.util.concurrent.atomic.AtomicInteger;\n import java.util.concurrent.atomic.AtomicReference;\n import tech.pegasys.teku.api.response.v1.beacon.ValidatorStatus;\n import tech.pegasys.teku.bls.BLSPublicKey;\n+import tech.pegasys.teku.infrastructure.async.AsyncRunner;\n+import tech.pegasys.teku.infrastructure.async.SafeFuture;\n import tech.pegasys.teku.validator.api.ValidatorApiChannel;\n \n public class DefaultValidatorStatusLogger implements ValidatorStatusLogger {\n \n   private static final int VALIDATOR_KEYS_PRINT_LIMIT = 20;\n+  private static final long INITIAL_STATUS_CHECK_RETRY_PERIOD = 5; // seconds\n \n   final List<BLSPublicKey> validatorPublicKeys;\n   final ValidatorApiChannel validatorApiChannel;\n   final AtomicReference<Map<BLSPublicKey, ValidatorStatus>> latestValidatorStatuses =\n       new AtomicReference<>();\n+  final AsyncRunner asyncRunner;\n \n   public DefaultValidatorStatusLogger(\n-      List<BLSPublicKey> validatorPublicKeys, ValidatorApiChannel validatorApiChannel) {\n+      List<BLSPublicKey> validatorPublicKeys,\n+      ValidatorApiChannel validatorApiChannel,\n+      AsyncRunner asyncRunner) {\n     checkArgument(!validatorPublicKeys.isEmpty());\n     this.validatorPublicKeys = validatorPublicKeys;\n     this.validatorApiChannel = validatorApiChannel;\n+    this.asyncRunner = asyncRunner;\n   }\n \n   @Override\n-  public void printInitialValidatorStatuses() {\n-    validatorApiChannel\n+  public SafeFuture<Void> printInitialValidatorStatuses() {\n+    return validatorApiChannel\n         .getValidatorStatuses(validatorPublicKeys)\n-        .thenAccept(\n+        .thenCompose(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95d9b42de5c83eacb8012ea96c36e3c08fe71ac3"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxMDk4NjE0OnYy", "diffSide": "RIGHT", "path": "validator/coordinator/src/main/java/tech/pegasys/teku/validator/coordinator/ValidatorApiHandler.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQyMjo1NDoyMFrOIFv-jg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQyMzo0NTozOFrOIFxwJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg5OTg1NA==", "bodyText": "I'm very unclear how we got a ChainDataProvider in here - that should be part of the REST API implementation and the dependency should go the other way around where the providers call into ValidatorApiChannel.  We shouldn't be using the REST API in the internals of Teku like this (ideally that ValidatorResponse class shouldn't be accessible at all from here).  Actually same with ValidatorStatus, it shouldn't be used from here either.\nProbably need to rework this in a follow up PR and get the dependency chain right.", "url": "https://github.com/ConsenSys/teku/pull/3409#discussion_r542899854", "createdAt": "2020-12-14T22:54:20Z", "author": {"login": "ajsutton"}, "path": "validator/coordinator/src/main/java/tech/pegasys/teku/validator/coordinator/ValidatorApiHandler.java", "diffHunk": "@@ -216,20 +216,22 @@ public ValidatorApiHandler(\n   @Override\n   public SafeFuture<Optional<Map<BLSPublicKey, ValidatorStatus>>> getValidatorStatuses(\n       List<BLSPublicKey> validatorIdentifiers) {\n-    return chainDataProvider\n-        .getStateValidators(\n-            \"head\",\n-            validatorIdentifiers.stream().map(BLSPublicKey::toString).collect(toList()),\n-            new HashSet<>())\n-        .thenApply(\n-            (maybeList) ->\n-                maybeList.map(\n-                    list ->\n-                        list.stream()\n-                            .collect(\n-                                toMap(\n-                                    ValidatorResponse::getPublicKey,\n-                                    ValidatorResponse::getStatus))));\n+    return isSyncActive()\n+        ? SafeFuture.completedFuture(Optional.empty())\n+        : chainDataProvider\n+            .getStateValidators(\n+                \"head\",\n+                validatorIdentifiers.stream().map(BLSPublicKey::toString).collect(toList()),\n+                new HashSet<>())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dcc1f9d9064ca1d4a56b4870a6a74230b14c9976"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjkyODczNA==", "bodyText": "I believe I had inserted the ChainDataProvider to ValidatorApiHandler (we create a new one using combined chain data client and recent chain data client in BeaconChainController). The reason was that using ChainDataProvider methods made it easy to draw parallels when implementing the ValidatorApiChannel interface methods for the RemoteValidatorApiHandler and ValidatorApiHandler.", "url": "https://github.com/ConsenSys/teku/pull/3409#discussion_r542928734", "createdAt": "2020-12-14T23:45:12Z", "author": {"login": "cemozerr"}, "path": "validator/coordinator/src/main/java/tech/pegasys/teku/validator/coordinator/ValidatorApiHandler.java", "diffHunk": "@@ -216,20 +216,22 @@ public ValidatorApiHandler(\n   @Override\n   public SafeFuture<Optional<Map<BLSPublicKey, ValidatorStatus>>> getValidatorStatuses(\n       List<BLSPublicKey> validatorIdentifiers) {\n-    return chainDataProvider\n-        .getStateValidators(\n-            \"head\",\n-            validatorIdentifiers.stream().map(BLSPublicKey::toString).collect(toList()),\n-            new HashSet<>())\n-        .thenApply(\n-            (maybeList) ->\n-                maybeList.map(\n-                    list ->\n-                        list.stream()\n-                            .collect(\n-                                toMap(\n-                                    ValidatorResponse::getPublicKey,\n-                                    ValidatorResponse::getStatus))));\n+    return isSyncActive()\n+        ? SafeFuture.completedFuture(Optional.empty())\n+        : chainDataProvider\n+            .getStateValidators(\n+                \"head\",\n+                validatorIdentifiers.stream().map(BLSPublicKey::toString).collect(toList()),\n+                new HashSet<>())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg5OTg1NA=="}, "originalCommit": {"oid": "dcc1f9d9064ca1d4a56b4870a6a74230b14c9976"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjkyODkzNA==", "bodyText": "I understand your point though and can revert that in another PR.", "url": "https://github.com/ConsenSys/teku/pull/3409#discussion_r542928934", "createdAt": "2020-12-14T23:45:38Z", "author": {"login": "cemozerr"}, "path": "validator/coordinator/src/main/java/tech/pegasys/teku/validator/coordinator/ValidatorApiHandler.java", "diffHunk": "@@ -216,20 +216,22 @@ public ValidatorApiHandler(\n   @Override\n   public SafeFuture<Optional<Map<BLSPublicKey, ValidatorStatus>>> getValidatorStatuses(\n       List<BLSPublicKey> validatorIdentifiers) {\n-    return chainDataProvider\n-        .getStateValidators(\n-            \"head\",\n-            validatorIdentifiers.stream().map(BLSPublicKey::toString).collect(toList()),\n-            new HashSet<>())\n-        .thenApply(\n-            (maybeList) ->\n-                maybeList.map(\n-                    list ->\n-                        list.stream()\n-                            .collect(\n-                                toMap(\n-                                    ValidatorResponse::getPublicKey,\n-                                    ValidatorResponse::getStatus))));\n+    return isSyncActive()\n+        ? SafeFuture.completedFuture(Optional.empty())\n+        : chainDataProvider\n+            .getStateValidators(\n+                \"head\",\n+                validatorIdentifiers.stream().map(BLSPublicKey::toString).collect(toList()),\n+                new HashSet<>())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjg5OTg1NA=="}, "originalCommit": {"oid": "dcc1f9d9064ca1d4a56b4870a6a74230b14c9976"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxMTAwMTQ0OnYy", "diffSide": "RIGHT", "path": "validator/remote/src/main/java/tech/pegasys/teku/validator/remote/RemoteValidatorApiHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQyMjo1Njo0OFrOIFwHzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNFQyMzo0MTo0M1rOIFxpGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjkwMjIyMQ==", "bodyText": "nit:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  boolean requestSuccesful = validatorObjects.isPresent();\n          \n          \n            \n                  if (requestSuccesful) {\n          \n          \n            \n                    returnedObjects.putAll(validatorObjects.get());\n          \n          \n            \n                  } else {\n          \n          \n            \n                    return Optional.empty();\n          \n          \n            \n                  }\n          \n          \n            \n                  if (validatorObjects.isEmpty()) {\n          \n          \n            \n                    return Optional.empty();\n          \n          \n            \n                  }\n          \n          \n            \n                  returnedObjects.putAll(validatorObjects.get());", "url": "https://github.com/ConsenSys/teku/pull/3409#discussion_r542902221", "createdAt": "2020-12-14T22:56:48Z", "author": {"login": "ajsutton"}, "path": "validator/remote/src/main/java/tech/pegasys/teku/validator/remote/RemoteValidatorApiHandler.java", "diffHunk": "@@ -100,25 +100,34 @@ public RemoteValidatorApiHandler(\n     if (publicKeys.isEmpty()) {\n       return SafeFuture.completedFuture(emptyMap());\n     }\n-    return sendRequest(() -> makeBatchedValidatorRequest(publicKeys, ValidatorResponse::getIndex));\n+    return sendRequest(\n+        () ->\n+            makeBatchedValidatorRequest(publicKeys, ValidatorResponse::getIndex)\n+                .orElse(emptyMap()));\n   }\n \n   @Override\n   public SafeFuture<Optional<Map<BLSPublicKey, ValidatorStatus>>> getValidatorStatuses(\n       List<BLSPublicKey> publicKeys) {\n-    return sendRequest(\n-        () -> Optional.of(makeBatchedValidatorRequest(publicKeys, ValidatorResponse::getStatus)));\n+    return sendRequest(() -> makeBatchedValidatorRequest(publicKeys, ValidatorResponse::getStatus));\n   }\n \n-  private <T> Map<BLSPublicKey, T> makeBatchedValidatorRequest(\n+  private <T> Optional<Map<BLSPublicKey, T>> makeBatchedValidatorRequest(\n       List<BLSPublicKey> publicKeys, Function<ValidatorResponse, T> valueExtractor) {\n     final Map<BLSPublicKey, T> returnedObjects = new HashMap<>();\n     for (int i = 0; i < publicKeys.size(); i += MAX_PUBLIC_KEY_BATCH_SIZE) {\n       final List<BLSPublicKey> batch =\n           publicKeys.subList(i, Math.min(publicKeys.size(), i + MAX_PUBLIC_KEY_BATCH_SIZE));\n-      requestValidatorObject(batch, valueExtractor).ifPresent(returnedObjects::putAll);\n+      Optional<Map<BLSPublicKey, T>> validatorObjects =\n+          requestValidatorObject(batch, valueExtractor);\n+      boolean requestSuccesful = validatorObjects.isPresent();\n+      if (requestSuccesful) {\n+        returnedObjects.putAll(validatorObjects.get());\n+      } else {\n+        return Optional.empty();\n+      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dcc1f9d9064ca1d4a56b4870a6a74230b14c9976"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjkyNzEzMQ==", "bodyText": "Done.", "url": "https://github.com/ConsenSys/teku/pull/3409#discussion_r542927131", "createdAt": "2020-12-14T23:41:43Z", "author": {"login": "cemozerr"}, "path": "validator/remote/src/main/java/tech/pegasys/teku/validator/remote/RemoteValidatorApiHandler.java", "diffHunk": "@@ -100,25 +100,34 @@ public RemoteValidatorApiHandler(\n     if (publicKeys.isEmpty()) {\n       return SafeFuture.completedFuture(emptyMap());\n     }\n-    return sendRequest(() -> makeBatchedValidatorRequest(publicKeys, ValidatorResponse::getIndex));\n+    return sendRequest(\n+        () ->\n+            makeBatchedValidatorRequest(publicKeys, ValidatorResponse::getIndex)\n+                .orElse(emptyMap()));\n   }\n \n   @Override\n   public SafeFuture<Optional<Map<BLSPublicKey, ValidatorStatus>>> getValidatorStatuses(\n       List<BLSPublicKey> publicKeys) {\n-    return sendRequest(\n-        () -> Optional.of(makeBatchedValidatorRequest(publicKeys, ValidatorResponse::getStatus)));\n+    return sendRequest(() -> makeBatchedValidatorRequest(publicKeys, ValidatorResponse::getStatus));\n   }\n \n-  private <T> Map<BLSPublicKey, T> makeBatchedValidatorRequest(\n+  private <T> Optional<Map<BLSPublicKey, T>> makeBatchedValidatorRequest(\n       List<BLSPublicKey> publicKeys, Function<ValidatorResponse, T> valueExtractor) {\n     final Map<BLSPublicKey, T> returnedObjects = new HashMap<>();\n     for (int i = 0; i < publicKeys.size(); i += MAX_PUBLIC_KEY_BATCH_SIZE) {\n       final List<BLSPublicKey> batch =\n           publicKeys.subList(i, Math.min(publicKeys.size(), i + MAX_PUBLIC_KEY_BATCH_SIZE));\n-      requestValidatorObject(batch, valueExtractor).ifPresent(returnedObjects::putAll);\n+      Optional<Map<BLSPublicKey, T>> validatorObjects =\n+          requestValidatorObject(batch, valueExtractor);\n+      boolean requestSuccesful = validatorObjects.isPresent();\n+      if (requestSuccesful) {\n+        returnedObjects.putAll(validatorObjects.get());\n+      } else {\n+        return Optional.empty();\n+      }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjkwMjIyMQ=="}, "originalCommit": {"oid": "dcc1f9d9064ca1d4a56b4870a6a74230b14c9976"}, "originalPosition": 34}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2959, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}