{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg1ODE2Mjkx", "number": 1332, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQyMzo1NTowOFrODmgFSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQyMzo1NTowOFrODmgFSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNjk4MTIxOnYy", "diffSide": "RIGHT", "path": "networking/p2p/src/main/java/tech/pegasys/artemis/networking/p2p/libp2p/rpc/RpcHandler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQyMzo1NTowOFrOFz9KPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxNToxODowNFrOF0Ttnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAyMzc0MQ==", "bodyText": "Where are you completing succesfully?", "url": "https://github.com/ConsenSys/teku/pull/1332#discussion_r390023741", "createdAt": "2020-03-09T23:55:08Z", "author": {"login": "cemozerr"}, "path": "networking/p2p/src/main/java/tech/pegasys/artemis/networking/p2p/libp2p/rpc/RpcHandler.java", "diffHunk": "@@ -22,45 +22,92 @@\n import io.netty.buffer.ByteBuf;\n import io.netty.channel.ChannelHandlerContext;\n import io.netty.channel.SimpleChannelInboundHandler;\n+import java.time.Duration;\n import java.util.ArrayList;\n import java.util.List;\n+import java.util.concurrent.TimeUnit;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n import org.apache.tuweni.bytes.Bytes;\n import org.jetbrains.annotations.NotNull;\n import tech.pegasys.artemis.networking.p2p.libp2p.LibP2PNodeId;\n import tech.pegasys.artemis.networking.p2p.libp2p.rpc.RpcHandler.Controller;\n import tech.pegasys.artemis.networking.p2p.peer.NodeId;\n+import tech.pegasys.artemis.networking.p2p.peer.PeerDisconnectedException;\n import tech.pegasys.artemis.networking.p2p.rpc.RpcMethod;\n import tech.pegasys.artemis.networking.p2p.rpc.RpcRequestHandler;\n import tech.pegasys.artemis.networking.p2p.rpc.RpcStream;\n+import tech.pegasys.artemis.networking.p2p.rpc.StreamClosedException;\n+import tech.pegasys.artemis.networking.p2p.rpc.StreamTimeoutException;\n+import tech.pegasys.artemis.util.async.AsyncRunner;\n import tech.pegasys.artemis.util.async.SafeFuture;\n \n public class RpcHandler implements ProtocolBinding<Controller> {\n+  private static final Duration TIMEOUT = Duration.ofSeconds(5);\n   private static final Logger LOG = LogManager.getLogger();\n \n   private final RpcMethod rpcMethod;\n+  private final AsyncRunner asyncRunner;\n \n-  public RpcHandler(RpcMethod rpcMethod) {\n+  public RpcHandler(final AsyncRunner asyncRunner, RpcMethod rpcMethod) {\n+    this.asyncRunner = asyncRunner;\n     this.rpcMethod = rpcMethod;\n   }\n \n   @SuppressWarnings(\"unchecked\")\n   public SafeFuture<RpcStream> sendRequest(\n       Connection connection, Bytes initialPayload, RpcRequestHandler handler) {\n-    return SafeFuture.of(\n-            connection\n-                .muxerSession()\n-                .createStream(\n-                    Multistream.create(this.toInitiator(rpcMethod.getId())).toStreamHandler())\n-                .getController())\n-        .thenCompose(\n+    if (connection.closeFuture().isDone()) {\n+      return SafeFuture.failedFuture(new PeerDisconnectedException());\n+    }\n+\n+    SafeFuture<RpcStream> streamFuture = new SafeFuture<>();\n+\n+    // Complete future if peer disconnects\n+    SafeFuture.of(connection.closeFuture())\n+        .always(() -> streamFuture.completeExceptionally(new PeerDisconnectedException()));\n+    // Complete future if we fail to initialize\n+    asyncRunner\n+        .getDelayedFuture(TIMEOUT.toMillis(), TimeUnit.MILLISECONDS)\n+        .thenAccept(\n+            __ ->\n+                streamFuture.completeExceptionally(\n+                    new StreamTimeoutException(\"Timed out waiting to initialize stream\")))\n+        .reportExceptions();\n+\n+    // Try to initiate stream\n+    connection\n+        .muxerSession()\n+        .createStream(Multistream.create(this.toInitiator(rpcMethod.getId())).toStreamHandler())\n+        .getController()\n+        .thenAccept(\n             ctr -> {\n               ctr.setRequestHandler(handler);\n-              return ctr.getRpcStream()\n+              ctr.getRpcStream()\n                   .writeBytes(initialPayload)\n-                  .thenApply(f -> ctr.getRpcStream());\n+                  .thenApply(f -> ctr.getRpcStream())\n+                  .thenAccept(\n+                      rpcStream -> {\n+                        if (!streamFuture.complete(rpcStream)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2c0e1981bb68674dac510afe48ff775da79d942a"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDM5MzI0Nw==", "bodyText": "Right on that line, I see :D. My bad.", "url": "https://github.com/ConsenSys/teku/pull/1332#discussion_r390393247", "createdAt": "2020-03-10T15:18:04Z", "author": {"login": "cemozerr"}, "path": "networking/p2p/src/main/java/tech/pegasys/artemis/networking/p2p/libp2p/rpc/RpcHandler.java", "diffHunk": "@@ -22,45 +22,92 @@\n import io.netty.buffer.ByteBuf;\n import io.netty.channel.ChannelHandlerContext;\n import io.netty.channel.SimpleChannelInboundHandler;\n+import java.time.Duration;\n import java.util.ArrayList;\n import java.util.List;\n+import java.util.concurrent.TimeUnit;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n import org.apache.tuweni.bytes.Bytes;\n import org.jetbrains.annotations.NotNull;\n import tech.pegasys.artemis.networking.p2p.libp2p.LibP2PNodeId;\n import tech.pegasys.artemis.networking.p2p.libp2p.rpc.RpcHandler.Controller;\n import tech.pegasys.artemis.networking.p2p.peer.NodeId;\n+import tech.pegasys.artemis.networking.p2p.peer.PeerDisconnectedException;\n import tech.pegasys.artemis.networking.p2p.rpc.RpcMethod;\n import tech.pegasys.artemis.networking.p2p.rpc.RpcRequestHandler;\n import tech.pegasys.artemis.networking.p2p.rpc.RpcStream;\n+import tech.pegasys.artemis.networking.p2p.rpc.StreamClosedException;\n+import tech.pegasys.artemis.networking.p2p.rpc.StreamTimeoutException;\n+import tech.pegasys.artemis.util.async.AsyncRunner;\n import tech.pegasys.artemis.util.async.SafeFuture;\n \n public class RpcHandler implements ProtocolBinding<Controller> {\n+  private static final Duration TIMEOUT = Duration.ofSeconds(5);\n   private static final Logger LOG = LogManager.getLogger();\n \n   private final RpcMethod rpcMethod;\n+  private final AsyncRunner asyncRunner;\n \n-  public RpcHandler(RpcMethod rpcMethod) {\n+  public RpcHandler(final AsyncRunner asyncRunner, RpcMethod rpcMethod) {\n+    this.asyncRunner = asyncRunner;\n     this.rpcMethod = rpcMethod;\n   }\n \n   @SuppressWarnings(\"unchecked\")\n   public SafeFuture<RpcStream> sendRequest(\n       Connection connection, Bytes initialPayload, RpcRequestHandler handler) {\n-    return SafeFuture.of(\n-            connection\n-                .muxerSession()\n-                .createStream(\n-                    Multistream.create(this.toInitiator(rpcMethod.getId())).toStreamHandler())\n-                .getController())\n-        .thenCompose(\n+    if (connection.closeFuture().isDone()) {\n+      return SafeFuture.failedFuture(new PeerDisconnectedException());\n+    }\n+\n+    SafeFuture<RpcStream> streamFuture = new SafeFuture<>();\n+\n+    // Complete future if peer disconnects\n+    SafeFuture.of(connection.closeFuture())\n+        .always(() -> streamFuture.completeExceptionally(new PeerDisconnectedException()));\n+    // Complete future if we fail to initialize\n+    asyncRunner\n+        .getDelayedFuture(TIMEOUT.toMillis(), TimeUnit.MILLISECONDS)\n+        .thenAccept(\n+            __ ->\n+                streamFuture.completeExceptionally(\n+                    new StreamTimeoutException(\"Timed out waiting to initialize stream\")))\n+        .reportExceptions();\n+\n+    // Try to initiate stream\n+    connection\n+        .muxerSession()\n+        .createStream(Multistream.create(this.toInitiator(rpcMethod.getId())).toStreamHandler())\n+        .getController()\n+        .thenAccept(\n             ctr -> {\n               ctr.setRequestHandler(handler);\n-              return ctr.getRpcStream()\n+              ctr.getRpcStream()\n                   .writeBytes(initialPayload)\n-                  .thenApply(f -> ctr.getRpcStream());\n+                  .thenApply(f -> ctr.getRpcStream())\n+                  .thenAccept(\n+                      rpcStream -> {\n+                        if (!streamFuture.complete(rpcStream)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAyMzc0MQ=="}, "originalCommit": {"oid": "2c0e1981bb68674dac510afe48ff775da79d942a"}, "originalPosition": 80}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2518, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}