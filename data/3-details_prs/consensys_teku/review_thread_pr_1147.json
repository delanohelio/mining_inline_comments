{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzczOTc3MzU4", "number": 1147, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxNzoyNjo0NlrODfRGOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxODowOTowNlrODfR7yw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MTEyNTY4OnYy", "diffSide": "RIGHT", "path": "ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/util/MerkleTree.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxNzoyNjo0NlrOFo3v5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxODo1NDo1N1rOFo6lKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQwMDc0MQ==", "bodyText": "We should probably throw an exception of the value isn't found.", "url": "https://github.com/ConsenSys/teku/pull/1147#discussion_r378400741", "createdAt": "2020-02-12T17:26:46Z", "author": {"login": "mbaxter"}, "path": "ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/util/MerkleTree.java", "diffHunk": "@@ -38,45 +38,110 @@ protected MerkleTree(int treeDepth) {\n     zeroHashes = generateZeroHashes(treeDepth);\n   }\n \n-  abstract void add(Bytes32 leaf);\n+  public abstract void add(Bytes32 leaf);\n \n-  protected abstract int getNumberOfLeaves();\n+  public abstract int getNumberOfLeaves();\n \n   protected static List<Bytes32> generateZeroHashes(int height) {\n     List<Bytes32> zeroHashes = new ArrayList<>();\n-    for (int i = 0; i < height; i++) {\n-      zeroHashes.add(Bytes32.ZERO);\n-    }\n-    for (int i = 0; i < height - 1; i++) {\n-      zeroHashes.set(i + 1, Hash.sha2_256(Bytes.concatenate(zeroHashes.get(i), zeroHashes.get(i))));\n+    zeroHashes.add(Bytes32.ZERO);\n+    for (int i = 1; i < height; i++) {\n+      zeroHashes.add(\n+          i, Hash.sha2_256(Bytes.concatenate(zeroHashes.get(i - 1), zeroHashes.get(i - 1))));\n     }\n     return zeroHashes;\n   }\n \n-  public SSZVector<Bytes32> getProofTreeByValue(Bytes32 value) {\n+  public SSZVector<Bytes32> getProof(Bytes32 value) {\n     int index = tree.get(0).indexOf(value);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5477e5ddfd5412db946b1d632c963a03d9f87f4"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ0NzE0NQ==", "bodyText": "Done.", "url": "https://github.com/ConsenSys/teku/pull/1147#discussion_r378447145", "createdAt": "2020-02-12T18:54:57Z", "author": {"login": "cemozerr"}, "path": "ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/util/MerkleTree.java", "diffHunk": "@@ -38,45 +38,110 @@ protected MerkleTree(int treeDepth) {\n     zeroHashes = generateZeroHashes(treeDepth);\n   }\n \n-  abstract void add(Bytes32 leaf);\n+  public abstract void add(Bytes32 leaf);\n \n-  protected abstract int getNumberOfLeaves();\n+  public abstract int getNumberOfLeaves();\n \n   protected static List<Bytes32> generateZeroHashes(int height) {\n     List<Bytes32> zeroHashes = new ArrayList<>();\n-    for (int i = 0; i < height; i++) {\n-      zeroHashes.add(Bytes32.ZERO);\n-    }\n-    for (int i = 0; i < height - 1; i++) {\n-      zeroHashes.set(i + 1, Hash.sha2_256(Bytes.concatenate(zeroHashes.get(i), zeroHashes.get(i))));\n+    zeroHashes.add(Bytes32.ZERO);\n+    for (int i = 1; i < height; i++) {\n+      zeroHashes.add(\n+          i, Hash.sha2_256(Bytes.concatenate(zeroHashes.get(i - 1), zeroHashes.get(i - 1))));\n     }\n     return zeroHashes;\n   }\n \n-  public SSZVector<Bytes32> getProofTreeByValue(Bytes32 value) {\n+  public SSZVector<Bytes32> getProof(Bytes32 value) {\n     int index = tree.get(0).indexOf(value);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQwMDc0MQ=="}, "originalCommit": {"oid": "e5477e5ddfd5412db946b1d632c963a03d9f87f4"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MTE1NjQ0OnYy", "diffSide": "RIGHT", "path": "ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/util/MerkleTree.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxNzozNTo1OVrOFo4Drg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxODo1ODoxNVrOFo6saQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQwNTgwNg==", "bodyText": "I stared at this way too long - can we add a comment here? :D", "url": "https://github.com/ConsenSys/teku/pull/1147#discussion_r378405806", "createdAt": "2020-02-12T17:35:59Z", "author": {"login": "mbaxter"}, "path": "ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/util/MerkleTree.java", "diffHunk": "@@ -38,45 +38,110 @@ protected MerkleTree(int treeDepth) {\n     zeroHashes = generateZeroHashes(treeDepth);\n   }\n \n-  abstract void add(Bytes32 leaf);\n+  public abstract void add(Bytes32 leaf);\n \n-  protected abstract int getNumberOfLeaves();\n+  public abstract int getNumberOfLeaves();\n \n   protected static List<Bytes32> generateZeroHashes(int height) {\n     List<Bytes32> zeroHashes = new ArrayList<>();\n-    for (int i = 0; i < height; i++) {\n-      zeroHashes.add(Bytes32.ZERO);\n-    }\n-    for (int i = 0; i < height - 1; i++) {\n-      zeroHashes.set(i + 1, Hash.sha2_256(Bytes.concatenate(zeroHashes.get(i), zeroHashes.get(i))));\n+    zeroHashes.add(Bytes32.ZERO);\n+    for (int i = 1; i < height; i++) {\n+      zeroHashes.add(\n+          i, Hash.sha2_256(Bytes.concatenate(zeroHashes.get(i - 1), zeroHashes.get(i - 1))));\n     }\n     return zeroHashes;\n   }\n \n-  public SSZVector<Bytes32> getProofTreeByValue(Bytes32 value) {\n+  public SSZVector<Bytes32> getProof(Bytes32 value) {\n     int index = tree.get(0).indexOf(value);\n-    return getProofTreeByIndex(index);\n+    return getProof(index);\n   }\n \n-  public SSZVector<Bytes32> getProofTreeByIndex(int index) {\n+  public SSZVector<Bytes32> getProof(int index) {\n     List<Bytes32> proof = new ArrayList<>();\n     for (int i = 0; i < treeDepth; i++) {\n       index = index % 2 == 1 ? index - 1 : index + 1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5477e5ddfd5412db946b1d632c963a03d9f87f4"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ0OTAwMQ==", "bodyText": "Done.", "url": "https://github.com/ConsenSys/teku/pull/1147#discussion_r378449001", "createdAt": "2020-02-12T18:58:15Z", "author": {"login": "cemozerr"}, "path": "ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/util/MerkleTree.java", "diffHunk": "@@ -38,45 +38,110 @@ protected MerkleTree(int treeDepth) {\n     zeroHashes = generateZeroHashes(treeDepth);\n   }\n \n-  abstract void add(Bytes32 leaf);\n+  public abstract void add(Bytes32 leaf);\n \n-  protected abstract int getNumberOfLeaves();\n+  public abstract int getNumberOfLeaves();\n \n   protected static List<Bytes32> generateZeroHashes(int height) {\n     List<Bytes32> zeroHashes = new ArrayList<>();\n-    for (int i = 0; i < height; i++) {\n-      zeroHashes.add(Bytes32.ZERO);\n-    }\n-    for (int i = 0; i < height - 1; i++) {\n-      zeroHashes.set(i + 1, Hash.sha2_256(Bytes.concatenate(zeroHashes.get(i), zeroHashes.get(i))));\n+    zeroHashes.add(Bytes32.ZERO);\n+    for (int i = 1; i < height; i++) {\n+      zeroHashes.add(\n+          i, Hash.sha2_256(Bytes.concatenate(zeroHashes.get(i - 1), zeroHashes.get(i - 1))));\n     }\n     return zeroHashes;\n   }\n \n-  public SSZVector<Bytes32> getProofTreeByValue(Bytes32 value) {\n+  public SSZVector<Bytes32> getProof(Bytes32 value) {\n     int index = tree.get(0).indexOf(value);\n-    return getProofTreeByIndex(index);\n+    return getProof(index);\n   }\n \n-  public SSZVector<Bytes32> getProofTreeByIndex(int index) {\n+  public SSZVector<Bytes32> getProof(int index) {\n     List<Bytes32> proof = new ArrayList<>();\n     for (int i = 0; i < treeDepth; i++) {\n       index = index % 2 == 1 ? index - 1 : index + 1;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQwNTgwNg=="}, "originalCommit": {"oid": "e5477e5ddfd5412db946b1d632c963a03d9f87f4"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MTI1MDc2OnYy", "diffSide": "RIGHT", "path": "ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/util/MerkleTree.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxODowNToxNVrOFo4_1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxOTowMDo0OVrOFo6xog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQyMTIwNA==", "bodyText": "Is this equivalent to checking that viewLimit is <= # of leaf nodes?  Could we just have a single check at the top for this?", "url": "https://github.com/ConsenSys/teku/pull/1147#discussion_r378421204", "createdAt": "2020-02-12T18:05:15Z", "author": {"login": "mbaxter"}, "path": "ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/util/MerkleTree.java", "diffHunk": "@@ -38,45 +38,110 @@ protected MerkleTree(int treeDepth) {\n     zeroHashes = generateZeroHashes(treeDepth);\n   }\n \n-  abstract void add(Bytes32 leaf);\n+  public abstract void add(Bytes32 leaf);\n \n-  protected abstract int getNumberOfLeaves();\n+  public abstract int getNumberOfLeaves();\n \n   protected static List<Bytes32> generateZeroHashes(int height) {\n     List<Bytes32> zeroHashes = new ArrayList<>();\n-    for (int i = 0; i < height; i++) {\n-      zeroHashes.add(Bytes32.ZERO);\n-    }\n-    for (int i = 0; i < height - 1; i++) {\n-      zeroHashes.set(i + 1, Hash.sha2_256(Bytes.concatenate(zeroHashes.get(i), zeroHashes.get(i))));\n+    zeroHashes.add(Bytes32.ZERO);\n+    for (int i = 1; i < height; i++) {\n+      zeroHashes.add(\n+          i, Hash.sha2_256(Bytes.concatenate(zeroHashes.get(i - 1), zeroHashes.get(i - 1))));\n     }\n     return zeroHashes;\n   }\n \n-  public SSZVector<Bytes32> getProofTreeByValue(Bytes32 value) {\n+  public SSZVector<Bytes32> getProof(Bytes32 value) {\n     int index = tree.get(0).indexOf(value);\n-    return getProofTreeByIndex(index);\n+    return getProof(index);\n   }\n \n-  public SSZVector<Bytes32> getProofTreeByIndex(int index) {\n+  public SSZVector<Bytes32> getProof(int index) {\n     List<Bytes32> proof = new ArrayList<>();\n     for (int i = 0; i < treeDepth; i++) {\n       index = index % 2 == 1 ? index - 1 : index + 1;\n-      if (index < tree.get(i).size()) proof.add(tree.get(i).get(index));\n-      else proof.add(zeroHashes.get(i));\n+      if (index < tree.get(i).size()) {\n+        proof.add(tree.get(i).get(index));\n+      } else {\n+        proof.add(zeroHashes.get(i));\n+      }\n       index /= 2;\n     }\n     proof.add(calcMixInValue());\n     return new SSZVector<>(proof, Bytes32.class);\n   }\n \n-  private Bytes32 calcMixInValue() {\n+  private Bytes32 calcViewBoundaryRoot(int depth, int viewLimit) {\n+    if (depth == 0) {\n+      return zeroHashes.get(0);\n+    }\n+    depth -= 1;\n+    Bytes32 deeperRoot = calcViewBoundaryRoot(depth, viewLimit);\n+    if ((viewLimit & (1 << depth)) != 0) {\n+      return Hash.sha2_256(Bytes.concatenate(tree.get(depth).get(viewLimit >> depth), deeperRoot));\n+    } else {\n+      return Hash.sha2_256(Bytes.concatenate(deeperRoot, zeroHashes.get(depth)));\n+    }\n+  }\n+\n+  public SSZVector<Bytes32> getProofWithViewBoundary(Bytes32 value, int viewLimit) {\n+    return getProofWithViewBoundary(tree.get(0).indexOf(value), viewLimit);\n+  }\n+\n+  public SSZVector<Bytes32> getProofWithViewBoundary(int index, int viewLimit) {\n+    checkArgument(index < viewLimit, \"MerkleTree: Index must be within view limit\");\n+\n+    List<Bytes32> proof = new ArrayList<>();\n+    for (int i = 0; i < treeDepth; i++) {\n+      // Get index of sibling node\n+      index = index % 2 == 1 ? index - 1 : index + 1;\n+\n+      // Check how much of the tree at this level is strictly within the view limit.\n+      int limit = viewLimit >> i;\n+\n+      checkArgument(\n+          limit <= tree.get(i).size(), \"MerkleTree: Tree is too small for given limit at height\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5477e5ddfd5412db946b1d632c963a03d9f87f4"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ1MDMzOA==", "bodyText": "I am not sure if the two are equivalent", "url": "https://github.com/ConsenSys/teku/pull/1147#discussion_r378450338", "createdAt": "2020-02-12T19:00:49Z", "author": {"login": "cemozerr"}, "path": "ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/util/MerkleTree.java", "diffHunk": "@@ -38,45 +38,110 @@ protected MerkleTree(int treeDepth) {\n     zeroHashes = generateZeroHashes(treeDepth);\n   }\n \n-  abstract void add(Bytes32 leaf);\n+  public abstract void add(Bytes32 leaf);\n \n-  protected abstract int getNumberOfLeaves();\n+  public abstract int getNumberOfLeaves();\n \n   protected static List<Bytes32> generateZeroHashes(int height) {\n     List<Bytes32> zeroHashes = new ArrayList<>();\n-    for (int i = 0; i < height; i++) {\n-      zeroHashes.add(Bytes32.ZERO);\n-    }\n-    for (int i = 0; i < height - 1; i++) {\n-      zeroHashes.set(i + 1, Hash.sha2_256(Bytes.concatenate(zeroHashes.get(i), zeroHashes.get(i))));\n+    zeroHashes.add(Bytes32.ZERO);\n+    for (int i = 1; i < height; i++) {\n+      zeroHashes.add(\n+          i, Hash.sha2_256(Bytes.concatenate(zeroHashes.get(i - 1), zeroHashes.get(i - 1))));\n     }\n     return zeroHashes;\n   }\n \n-  public SSZVector<Bytes32> getProofTreeByValue(Bytes32 value) {\n+  public SSZVector<Bytes32> getProof(Bytes32 value) {\n     int index = tree.get(0).indexOf(value);\n-    return getProofTreeByIndex(index);\n+    return getProof(index);\n   }\n \n-  public SSZVector<Bytes32> getProofTreeByIndex(int index) {\n+  public SSZVector<Bytes32> getProof(int index) {\n     List<Bytes32> proof = new ArrayList<>();\n     for (int i = 0; i < treeDepth; i++) {\n       index = index % 2 == 1 ? index - 1 : index + 1;\n-      if (index < tree.get(i).size()) proof.add(tree.get(i).get(index));\n-      else proof.add(zeroHashes.get(i));\n+      if (index < tree.get(i).size()) {\n+        proof.add(tree.get(i).get(index));\n+      } else {\n+        proof.add(zeroHashes.get(i));\n+      }\n       index /= 2;\n     }\n     proof.add(calcMixInValue());\n     return new SSZVector<>(proof, Bytes32.class);\n   }\n \n-  private Bytes32 calcMixInValue() {\n+  private Bytes32 calcViewBoundaryRoot(int depth, int viewLimit) {\n+    if (depth == 0) {\n+      return zeroHashes.get(0);\n+    }\n+    depth -= 1;\n+    Bytes32 deeperRoot = calcViewBoundaryRoot(depth, viewLimit);\n+    if ((viewLimit & (1 << depth)) != 0) {\n+      return Hash.sha2_256(Bytes.concatenate(tree.get(depth).get(viewLimit >> depth), deeperRoot));\n+    } else {\n+      return Hash.sha2_256(Bytes.concatenate(deeperRoot, zeroHashes.get(depth)));\n+    }\n+  }\n+\n+  public SSZVector<Bytes32> getProofWithViewBoundary(Bytes32 value, int viewLimit) {\n+    return getProofWithViewBoundary(tree.get(0).indexOf(value), viewLimit);\n+  }\n+\n+  public SSZVector<Bytes32> getProofWithViewBoundary(int index, int viewLimit) {\n+    checkArgument(index < viewLimit, \"MerkleTree: Index must be within view limit\");\n+\n+    List<Bytes32> proof = new ArrayList<>();\n+    for (int i = 0; i < treeDepth; i++) {\n+      // Get index of sibling node\n+      index = index % 2 == 1 ? index - 1 : index + 1;\n+\n+      // Check how much of the tree at this level is strictly within the view limit.\n+      int limit = viewLimit >> i;\n+\n+      checkArgument(\n+          limit <= tree.get(i).size(), \"MerkleTree: Tree is too small for given limit at height\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQyMTIwNA=="}, "originalCommit": {"oid": "e5477e5ddfd5412db946b1d632c963a03d9f87f4"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MTI2MjgzOnYy", "diffSide": "RIGHT", "path": "ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/util/MerkleTree.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxODowOTowNlrOFo5HcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxOTowNjowOFrOFo68ag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQyMzE1Mw==", "bodyText": "Looks like viewLimit is exclusive - can we add some javadoc explaining the parameters?", "url": "https://github.com/ConsenSys/teku/pull/1147#discussion_r378423153", "createdAt": "2020-02-12T18:09:06Z", "author": {"login": "mbaxter"}, "path": "ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/util/MerkleTree.java", "diffHunk": "@@ -38,45 +38,110 @@ protected MerkleTree(int treeDepth) {\n     zeroHashes = generateZeroHashes(treeDepth);\n   }\n \n-  abstract void add(Bytes32 leaf);\n+  public abstract void add(Bytes32 leaf);\n \n-  protected abstract int getNumberOfLeaves();\n+  public abstract int getNumberOfLeaves();\n \n   protected static List<Bytes32> generateZeroHashes(int height) {\n     List<Bytes32> zeroHashes = new ArrayList<>();\n-    for (int i = 0; i < height; i++) {\n-      zeroHashes.add(Bytes32.ZERO);\n-    }\n-    for (int i = 0; i < height - 1; i++) {\n-      zeroHashes.set(i + 1, Hash.sha2_256(Bytes.concatenate(zeroHashes.get(i), zeroHashes.get(i))));\n+    zeroHashes.add(Bytes32.ZERO);\n+    for (int i = 1; i < height; i++) {\n+      zeroHashes.add(\n+          i, Hash.sha2_256(Bytes.concatenate(zeroHashes.get(i - 1), zeroHashes.get(i - 1))));\n     }\n     return zeroHashes;\n   }\n \n-  public SSZVector<Bytes32> getProofTreeByValue(Bytes32 value) {\n+  public SSZVector<Bytes32> getProof(Bytes32 value) {\n     int index = tree.get(0).indexOf(value);\n-    return getProofTreeByIndex(index);\n+    return getProof(index);\n   }\n \n-  public SSZVector<Bytes32> getProofTreeByIndex(int index) {\n+  public SSZVector<Bytes32> getProof(int index) {\n     List<Bytes32> proof = new ArrayList<>();\n     for (int i = 0; i < treeDepth; i++) {\n       index = index % 2 == 1 ? index - 1 : index + 1;\n-      if (index < tree.get(i).size()) proof.add(tree.get(i).get(index));\n-      else proof.add(zeroHashes.get(i));\n+      if (index < tree.get(i).size()) {\n+        proof.add(tree.get(i).get(index));\n+      } else {\n+        proof.add(zeroHashes.get(i));\n+      }\n       index /= 2;\n     }\n     proof.add(calcMixInValue());\n     return new SSZVector<>(proof, Bytes32.class);\n   }\n \n-  private Bytes32 calcMixInValue() {\n+  private Bytes32 calcViewBoundaryRoot(int depth, int viewLimit) {\n+    if (depth == 0) {\n+      return zeroHashes.get(0);\n+    }\n+    depth -= 1;\n+    Bytes32 deeperRoot = calcViewBoundaryRoot(depth, viewLimit);\n+    if ((viewLimit & (1 << depth)) != 0) {\n+      return Hash.sha2_256(Bytes.concatenate(tree.get(depth).get(viewLimit >> depth), deeperRoot));\n+    } else {\n+      return Hash.sha2_256(Bytes.concatenate(deeperRoot, zeroHashes.get(depth)));\n+    }\n+  }\n+\n+  public SSZVector<Bytes32> getProofWithViewBoundary(Bytes32 value, int viewLimit) {\n+    return getProofWithViewBoundary(tree.get(0).indexOf(value), viewLimit);\n+  }\n+\n+  public SSZVector<Bytes32> getProofWithViewBoundary(int index, int viewLimit) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5477e5ddfd5412db946b1d632c963a03d9f87f4"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ1MzA5OA==", "bodyText": "Switched to inclusive (it made more sense) and added javadocs.", "url": "https://github.com/ConsenSys/teku/pull/1147#discussion_r378453098", "createdAt": "2020-02-12T19:06:08Z", "author": {"login": "cemozerr"}, "path": "ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/util/MerkleTree.java", "diffHunk": "@@ -38,45 +38,110 @@ protected MerkleTree(int treeDepth) {\n     zeroHashes = generateZeroHashes(treeDepth);\n   }\n \n-  abstract void add(Bytes32 leaf);\n+  public abstract void add(Bytes32 leaf);\n \n-  protected abstract int getNumberOfLeaves();\n+  public abstract int getNumberOfLeaves();\n \n   protected static List<Bytes32> generateZeroHashes(int height) {\n     List<Bytes32> zeroHashes = new ArrayList<>();\n-    for (int i = 0; i < height; i++) {\n-      zeroHashes.add(Bytes32.ZERO);\n-    }\n-    for (int i = 0; i < height - 1; i++) {\n-      zeroHashes.set(i + 1, Hash.sha2_256(Bytes.concatenate(zeroHashes.get(i), zeroHashes.get(i))));\n+    zeroHashes.add(Bytes32.ZERO);\n+    for (int i = 1; i < height; i++) {\n+      zeroHashes.add(\n+          i, Hash.sha2_256(Bytes.concatenate(zeroHashes.get(i - 1), zeroHashes.get(i - 1))));\n     }\n     return zeroHashes;\n   }\n \n-  public SSZVector<Bytes32> getProofTreeByValue(Bytes32 value) {\n+  public SSZVector<Bytes32> getProof(Bytes32 value) {\n     int index = tree.get(0).indexOf(value);\n-    return getProofTreeByIndex(index);\n+    return getProof(index);\n   }\n \n-  public SSZVector<Bytes32> getProofTreeByIndex(int index) {\n+  public SSZVector<Bytes32> getProof(int index) {\n     List<Bytes32> proof = new ArrayList<>();\n     for (int i = 0; i < treeDepth; i++) {\n       index = index % 2 == 1 ? index - 1 : index + 1;\n-      if (index < tree.get(i).size()) proof.add(tree.get(i).get(index));\n-      else proof.add(zeroHashes.get(i));\n+      if (index < tree.get(i).size()) {\n+        proof.add(tree.get(i).get(index));\n+      } else {\n+        proof.add(zeroHashes.get(i));\n+      }\n       index /= 2;\n     }\n     proof.add(calcMixInValue());\n     return new SSZVector<>(proof, Bytes32.class);\n   }\n \n-  private Bytes32 calcMixInValue() {\n+  private Bytes32 calcViewBoundaryRoot(int depth, int viewLimit) {\n+    if (depth == 0) {\n+      return zeroHashes.get(0);\n+    }\n+    depth -= 1;\n+    Bytes32 deeperRoot = calcViewBoundaryRoot(depth, viewLimit);\n+    if ((viewLimit & (1 << depth)) != 0) {\n+      return Hash.sha2_256(Bytes.concatenate(tree.get(depth).get(viewLimit >> depth), deeperRoot));\n+    } else {\n+      return Hash.sha2_256(Bytes.concatenate(deeperRoot, zeroHashes.get(depth)));\n+    }\n+  }\n+\n+  public SSZVector<Bytes32> getProofWithViewBoundary(Bytes32 value, int viewLimit) {\n+    return getProofWithViewBoundary(tree.get(0).indexOf(value), viewLimit);\n+  }\n+\n+  public SSZVector<Bytes32> getProofWithViewBoundary(int index, int viewLimit) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQyMzE1Mw=="}, "originalCommit": {"oid": "e5477e5ddfd5412db946b1d632c963a03d9f87f4"}, "originalPosition": 77}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2858, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}