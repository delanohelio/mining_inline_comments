{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEzNzY1NjYz", "number": 1722, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMjowMjoyOVrOD5mHeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMjowMjoyOVrOD5mHeA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxNzE5OTI4OnYy", "diffSide": "RIGHT", "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/compression/SnappyCompressor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQyMjowMjozMFrOGQ9Nvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxNjowNTo1NlrOGRaXFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQzMzM0Mg==", "bodyText": "Shouldn't we be doing this check in all cases? ie even if we don't know what the expected uncompressed size is, we should check that we actually read all bytes from the gossip message.", "url": "https://github.com/ConsenSys/teku/pull/1722#discussion_r420433342", "createdAt": "2020-05-05T22:02:30Z", "author": {"login": "ajsutton"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/compression/SnappyCompressor.java", "diffHunk": "@@ -45,31 +47,60 @@ public Bytes compress(final Bytes data) {\n     }\n   }\n \n+  @Override\n+  public Bytes uncompress(final Bytes data) throws CompressionException {\n+    try (final InputStream byteStream = new ByteArrayInputStream(data.toArrayUnsafe())) {\n+      // Read everything\n+      return uncompress(byteStream, OptionalInt.empty());\n+    } catch (IOException e) {\n+      throw new RuntimeException(\n+          \"Unexpected error encountered while preparing to uncompress bytes\", e);\n+    }\n+  }\n+\n   @Override\n   public Bytes uncompress(final InputStream input, final int uncompressedPayloadSize)\n       throws CompressionException {\n+    return uncompress(input, OptionalInt.of(uncompressedPayloadSize));\n+  }\n+\n+  @Override\n+  public int getMaxCompressedLength(final int uncompressedLength) {\n+    // Return worst-case compression size\n+    // See:\n+    // https://github.com/google/snappy/blob/537f4ad6240e586970fe554614542e9717df7902/snappy.cc#L98\n+    return 32 + uncompressedLength + uncompressedLength / 6;\n+  }\n+\n+  private Bytes uncompress(final InputStream input, OptionalInt uncompressedPayloadSize)\n+      throws CompressionException {\n     // This is a bit of a hack - but we don't want to close the underlying stream when\n     // we close the SnappyFramedInputStream\n-    final UncloseableInputStream unclosableStream = new UncloseableInputStream(input);\n-    // Limit the max number of bytes we're allowed to read\n-    final InputStream limitedStream =\n-        ByteStreams.limit(unclosableStream, getMaxCompressedLength(uncompressedPayloadSize));\n+    InputStream srcStream = new UncloseableInputStream(input);\n \n-    try (final InputStream snappyIn = new SnappyFramedInputStream(limitedStream)) {\n-      final Bytes uncompressed = Bytes.wrap(snappyIn.readNBytes(uncompressedPayloadSize));\n+    if (uncompressedPayloadSize.isPresent()) {\n+      // Limit the max number of bytes we're allowed to read if we know the payload size\n+      final int maxCompressedBytes = getMaxCompressedLength(uncompressedPayloadSize.getAsInt());\n+      srcStream = ByteStreams.limit(srcStream, maxCompressedBytes);\n+    }\n+\n+    final int maxBytesToRead = uncompressedPayloadSize.orElse(Integer.MAX_VALUE);\n+    try (final InputStream snappyIn = new SnappyFramedInputStream(srcStream)) {\n+      final Bytes uncompressed = Bytes.wrap(snappyIn.readNBytes(maxBytesToRead));\n \n       // Validate payload is of expected size\n-      if (uncompressed.size() < uncompressedPayloadSize) {\n+      final boolean validateSize = uncompressedPayloadSize.isPresent();\n+      if (validateSize && uncompressed.size() < uncompressedPayloadSize.getAsInt()) {\n         throw new PayloadSmallerThanExpectedException(\n             String.format(\n                 \"Expected %d bytes but only uncompressed %d bytes\",\n-                uncompressedPayloadSize, uncompressed.size()));\n+                uncompressedPayloadSize.getAsInt(), uncompressed.size()));\n       }\n-      if (snappyIn.available() > 0) {\n+      if (validateSize && snappyIn.available() > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "490b01e0a575626353559c51ce5c6ef8ea7d5766"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDkxMDg2OA==", "bodyText": "It turns out we're supposed to use different compression strategies for gossip vs rpc requests (snappy block-format vs framed-format compression).  So, reverted these changes.", "url": "https://github.com/ConsenSys/teku/pull/1722#discussion_r420910868", "createdAt": "2020-05-06T16:05:56Z", "author": {"login": "mbaxter"}, "path": "networking/eth2/src/main/java/tech/pegasys/teku/networking/eth2/compression/SnappyCompressor.java", "diffHunk": "@@ -45,31 +47,60 @@ public Bytes compress(final Bytes data) {\n     }\n   }\n \n+  @Override\n+  public Bytes uncompress(final Bytes data) throws CompressionException {\n+    try (final InputStream byteStream = new ByteArrayInputStream(data.toArrayUnsafe())) {\n+      // Read everything\n+      return uncompress(byteStream, OptionalInt.empty());\n+    } catch (IOException e) {\n+      throw new RuntimeException(\n+          \"Unexpected error encountered while preparing to uncompress bytes\", e);\n+    }\n+  }\n+\n   @Override\n   public Bytes uncompress(final InputStream input, final int uncompressedPayloadSize)\n       throws CompressionException {\n+    return uncompress(input, OptionalInt.of(uncompressedPayloadSize));\n+  }\n+\n+  @Override\n+  public int getMaxCompressedLength(final int uncompressedLength) {\n+    // Return worst-case compression size\n+    // See:\n+    // https://github.com/google/snappy/blob/537f4ad6240e586970fe554614542e9717df7902/snappy.cc#L98\n+    return 32 + uncompressedLength + uncompressedLength / 6;\n+  }\n+\n+  private Bytes uncompress(final InputStream input, OptionalInt uncompressedPayloadSize)\n+      throws CompressionException {\n     // This is a bit of a hack - but we don't want to close the underlying stream when\n     // we close the SnappyFramedInputStream\n-    final UncloseableInputStream unclosableStream = new UncloseableInputStream(input);\n-    // Limit the max number of bytes we're allowed to read\n-    final InputStream limitedStream =\n-        ByteStreams.limit(unclosableStream, getMaxCompressedLength(uncompressedPayloadSize));\n+    InputStream srcStream = new UncloseableInputStream(input);\n \n-    try (final InputStream snappyIn = new SnappyFramedInputStream(limitedStream)) {\n-      final Bytes uncompressed = Bytes.wrap(snappyIn.readNBytes(uncompressedPayloadSize));\n+    if (uncompressedPayloadSize.isPresent()) {\n+      // Limit the max number of bytes we're allowed to read if we know the payload size\n+      final int maxCompressedBytes = getMaxCompressedLength(uncompressedPayloadSize.getAsInt());\n+      srcStream = ByteStreams.limit(srcStream, maxCompressedBytes);\n+    }\n+\n+    final int maxBytesToRead = uncompressedPayloadSize.orElse(Integer.MAX_VALUE);\n+    try (final InputStream snappyIn = new SnappyFramedInputStream(srcStream)) {\n+      final Bytes uncompressed = Bytes.wrap(snappyIn.readNBytes(maxBytesToRead));\n \n       // Validate payload is of expected size\n-      if (uncompressed.size() < uncompressedPayloadSize) {\n+      final boolean validateSize = uncompressedPayloadSize.isPresent();\n+      if (validateSize && uncompressed.size() < uncompressedPayloadSize.getAsInt()) {\n         throw new PayloadSmallerThanExpectedException(\n             String.format(\n                 \"Expected %d bytes but only uncompressed %d bytes\",\n-                uncompressedPayloadSize, uncompressed.size()));\n+                uncompressedPayloadSize.getAsInt(), uncompressed.size()));\n       }\n-      if (snappyIn.available() > 0) {\n+      if (validateSize && snappyIn.available() > 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQzMzM0Mg=="}, "originalCommit": {"oid": "490b01e0a575626353559c51ce5c6ef8ea7d5766"}, "originalPosition": 75}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3763, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}