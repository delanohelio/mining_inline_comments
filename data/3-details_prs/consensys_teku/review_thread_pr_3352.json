{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMxNjQ2NTY0", "number": 3352, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQwNDoxMTo1NVrOFAnb_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQwNDoxOTo1N1rOFAnizg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2MTkwNDYzOnYy", "diffSide": "RIGHT", "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/epoch/status/ValidatorStatuses.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQwNDoxMTo1NVrOH_AA_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNlQyMDowODoyMlrOIAOz0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTgyMjU4OA==", "bodyText": "is the double call here intentional?", "url": "https://github.com/ConsenSys/teku/pull/3352#discussion_r535822588", "createdAt": "2020-12-04T04:11:55Z", "author": {"login": "rolfyone"}, "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/epoch/status/ValidatorStatuses.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.core.epoch.status;\n+\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root_at_slot;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.datastructures.operations.AttestationData;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.datastructures.state.Checkpoint;\n+import tech.pegasys.teku.datastructures.state.Validator;\n+import tech.pegasys.teku.datastructures.util.AttestationUtil;\n+import tech.pegasys.teku.datastructures.util.BeaconStateUtil;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.ssz.SSZTypes.SSZList;\n+\n+public class ValidatorStatuses {\n+  private final List<ValidatorStatus> statuses;\n+  private final TotalBalances totalBalances;\n+\n+  private ValidatorStatuses(\n+      final List<ValidatorStatus> statuses, final TotalBalances totalBalances) {\n+    this.statuses = statuses;\n+    this.totalBalances = totalBalances;\n+  }\n+\n+  public static ValidatorStatuses create(final BeaconState state) {\n+    final SSZList<Validator> validators = state.getValidators();\n+\n+    final UInt64 currentEpoch = BeaconStateUtil.get_current_epoch(state);\n+    final UInt64 previousEpoch = BeaconStateUtil.get_previous_epoch(state);\n+\n+    final List<ValidatorStatus> statuses =\n+        validators.stream()\n+            .map(validator -> ValidatorStatus.create(validator, previousEpoch, currentEpoch))\n+            .collect(Collectors.toCollection(() -> new ArrayList<>(validators.size())));\n+\n+    processAttestations(statuses, state, previousEpoch, currentEpoch);\n+\n+    final TotalBalances totalBalances = TotalBalances.create(statuses);\n+\n+    return new ValidatorStatuses(statuses, totalBalances);\n+  }\n+\n+  private static void processAttestations(\n+      final List<ValidatorStatus> statuses,\n+      final BeaconState state,\n+      final UInt64 previousEpoch,\n+      final UInt64 currentEpoch) {\n+    Stream.concat(\n+            state.getPrevious_epoch_attestations().stream(),\n+            state.getCurrent_epoch_attestations().stream())\n+        .forEach(\n+            attestation -> {\n+              final AttestationData data = attestation.getData();\n+\n+              final AttestationUpdates updates = new AttestationUpdates();\n+              final Checkpoint target = data.getTarget();\n+              if (target.getEpoch().equals(currentEpoch)) {\n+                updates.currentEpochAttester = true;\n+                updates.currentEpochTargetAttester =\n+                    matchesEpochStartBlock(state, currentEpoch, target.getRoot());\n+              } else if (target.getEpoch().equals(previousEpoch)) {\n+                updates.previousEpochAttester = true;\n+\n+                updates.inclusionInfo =\n+                    Optional.of(\n+                        new InclusionInfo(\n+                            attestation.getInclusion_delay(), attestation.getProposer_index()));\n+\n+                if (matchesEpochStartBlock(state, previousEpoch, target.getRoot())) {\n+                  updates.previousEpochTargetAttester = true;\n+\n+                  updates.previousEpochHeadAttester =\n+                      get_block_root_at_slot(state, data.getSlot())\n+                          .equals(data.getBeacon_block_root());\n+                }\n+              }\n+\n+              // Apply flags to attestingIndices\n+              AttestationUtil.stream_attesting_indices(\n+                      state, data, attestation.getAggregation_bits())\n+                  .mapToObj(statuses::get)\n+                  .forEach(updates::apply);\n+            });\n+  }\n+\n+  private static boolean matchesEpochStartBlock(\n+      final BeaconState state, final UInt64 currentEpoch, final Bytes32 root) {\n+    return BeaconStateUtil.get_block_root(state, currentEpoch).equals(root);\n+  }\n+\n+  public TotalBalances getTotalBalances() {\n+    return totalBalances;\n+  }\n+\n+  public List<ValidatorStatus> getStatuses() {\n+    return statuses;\n+  }\n+\n+  public int getValidatorCount() {\n+    return statuses.size();\n+  }\n+\n+  private static class AttestationUpdates {\n+    private boolean currentEpochAttester = false;\n+    private boolean currentEpochTargetAttester = false;\n+    private boolean previousEpochAttester = false;\n+    private boolean previousEpochTargetAttester = false;\n+    private boolean previousEpochHeadAttester = false;\n+    private Optional<InclusionInfo> inclusionInfo = Optional.empty();\n+\n+    public void apply(final ValidatorStatus status) {\n+      status.updateCurrentEpochAttester(currentEpochAttester);\n+      status.updateCurrentEpochAttester(currentEpochAttester);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66afa36703fc03f86c047692986e4297120314de"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzExMzU1NQ==", "bodyText": "No, that would explain how I originally managed to miss calling updatePreviousEpochAttester though...", "url": "https://github.com/ConsenSys/teku/pull/3352#discussion_r537113555", "createdAt": "2020-12-06T20:08:22Z", "author": {"login": "ajsutton"}, "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/epoch/status/ValidatorStatuses.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.core.epoch.status;\n+\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root_at_slot;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.datastructures.operations.AttestationData;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.datastructures.state.Checkpoint;\n+import tech.pegasys.teku.datastructures.state.Validator;\n+import tech.pegasys.teku.datastructures.util.AttestationUtil;\n+import tech.pegasys.teku.datastructures.util.BeaconStateUtil;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.ssz.SSZTypes.SSZList;\n+\n+public class ValidatorStatuses {\n+  private final List<ValidatorStatus> statuses;\n+  private final TotalBalances totalBalances;\n+\n+  private ValidatorStatuses(\n+      final List<ValidatorStatus> statuses, final TotalBalances totalBalances) {\n+    this.statuses = statuses;\n+    this.totalBalances = totalBalances;\n+  }\n+\n+  public static ValidatorStatuses create(final BeaconState state) {\n+    final SSZList<Validator> validators = state.getValidators();\n+\n+    final UInt64 currentEpoch = BeaconStateUtil.get_current_epoch(state);\n+    final UInt64 previousEpoch = BeaconStateUtil.get_previous_epoch(state);\n+\n+    final List<ValidatorStatus> statuses =\n+        validators.stream()\n+            .map(validator -> ValidatorStatus.create(validator, previousEpoch, currentEpoch))\n+            .collect(Collectors.toCollection(() -> new ArrayList<>(validators.size())));\n+\n+    processAttestations(statuses, state, previousEpoch, currentEpoch);\n+\n+    final TotalBalances totalBalances = TotalBalances.create(statuses);\n+\n+    return new ValidatorStatuses(statuses, totalBalances);\n+  }\n+\n+  private static void processAttestations(\n+      final List<ValidatorStatus> statuses,\n+      final BeaconState state,\n+      final UInt64 previousEpoch,\n+      final UInt64 currentEpoch) {\n+    Stream.concat(\n+            state.getPrevious_epoch_attestations().stream(),\n+            state.getCurrent_epoch_attestations().stream())\n+        .forEach(\n+            attestation -> {\n+              final AttestationData data = attestation.getData();\n+\n+              final AttestationUpdates updates = new AttestationUpdates();\n+              final Checkpoint target = data.getTarget();\n+              if (target.getEpoch().equals(currentEpoch)) {\n+                updates.currentEpochAttester = true;\n+                updates.currentEpochTargetAttester =\n+                    matchesEpochStartBlock(state, currentEpoch, target.getRoot());\n+              } else if (target.getEpoch().equals(previousEpoch)) {\n+                updates.previousEpochAttester = true;\n+\n+                updates.inclusionInfo =\n+                    Optional.of(\n+                        new InclusionInfo(\n+                            attestation.getInclusion_delay(), attestation.getProposer_index()));\n+\n+                if (matchesEpochStartBlock(state, previousEpoch, target.getRoot())) {\n+                  updates.previousEpochTargetAttester = true;\n+\n+                  updates.previousEpochHeadAttester =\n+                      get_block_root_at_slot(state, data.getSlot())\n+                          .equals(data.getBeacon_block_root());\n+                }\n+              }\n+\n+              // Apply flags to attestingIndices\n+              AttestationUtil.stream_attesting_indices(\n+                      state, data, attestation.getAggregation_bits())\n+                  .mapToObj(statuses::get)\n+                  .forEach(updates::apply);\n+            });\n+  }\n+\n+  private static boolean matchesEpochStartBlock(\n+      final BeaconState state, final UInt64 currentEpoch, final Bytes32 root) {\n+    return BeaconStateUtil.get_block_root(state, currentEpoch).equals(root);\n+  }\n+\n+  public TotalBalances getTotalBalances() {\n+    return totalBalances;\n+  }\n+\n+  public List<ValidatorStatus> getStatuses() {\n+    return statuses;\n+  }\n+\n+  public int getValidatorCount() {\n+    return statuses.size();\n+  }\n+\n+  private static class AttestationUpdates {\n+    private boolean currentEpochAttester = false;\n+    private boolean currentEpochTargetAttester = false;\n+    private boolean previousEpochAttester = false;\n+    private boolean previousEpochTargetAttester = false;\n+    private boolean previousEpochHeadAttester = false;\n+    private Optional<InclusionInfo> inclusionInfo = Optional.empty();\n+\n+    public void apply(final ValidatorStatus status) {\n+      status.updateCurrentEpochAttester(currentEpochAttester);\n+      status.updateCurrentEpochAttester(currentEpochAttester);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTgyMjU4OA=="}, "originalCommit": {"oid": "66afa36703fc03f86c047692986e4297120314de"}, "originalPosition": 131}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2MTkxNjgyOnYy", "diffSide": "RIGHT", "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/epoch/status/ValidatorStatuses.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQwNDoxNzoyOVrOH_AHdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QwMzozODoyNFrOIAUpiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTgyNDI0NQ==", "bodyText": "this might be just a java oddity, but why not just Collectors.toList()?", "url": "https://github.com/ConsenSys/teku/pull/3352#discussion_r535824245", "createdAt": "2020-12-04T04:17:29Z", "author": {"login": "rolfyone"}, "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/epoch/status/ValidatorStatuses.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.core.epoch.status;\n+\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root_at_slot;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.datastructures.operations.AttestationData;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.datastructures.state.Checkpoint;\n+import tech.pegasys.teku.datastructures.state.Validator;\n+import tech.pegasys.teku.datastructures.util.AttestationUtil;\n+import tech.pegasys.teku.datastructures.util.BeaconStateUtil;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.ssz.SSZTypes.SSZList;\n+\n+public class ValidatorStatuses {\n+  private final List<ValidatorStatus> statuses;\n+  private final TotalBalances totalBalances;\n+\n+  private ValidatorStatuses(\n+      final List<ValidatorStatus> statuses, final TotalBalances totalBalances) {\n+    this.statuses = statuses;\n+    this.totalBalances = totalBalances;\n+  }\n+\n+  public static ValidatorStatuses create(final BeaconState state) {\n+    final SSZList<Validator> validators = state.getValidators();\n+\n+    final UInt64 currentEpoch = BeaconStateUtil.get_current_epoch(state);\n+    final UInt64 previousEpoch = BeaconStateUtil.get_previous_epoch(state);\n+\n+    final List<ValidatorStatus> statuses =\n+        validators.stream()\n+            .map(validator -> ValidatorStatus.create(validator, previousEpoch, currentEpoch))\n+            .collect(Collectors.toCollection(() -> new ArrayList<>(validators.size())));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66afa36703fc03f86c047692986e4297120314de"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzIwOTIyNA==", "bodyText": "If we just used toList() it would create a default sized backing array and then when the number of validators outgrows it have to copy them all to a new, bigger list.  It will wind up repeating that process at least a few times before it is actually big enough to hold the validators, and that final array may actually wind up being much bigger than we needed, wasting memory.\nSince we know the final list size we'll need and it's a really big number that we want to avoid having to copy, creating the array this way winds up more efficient in CPU and memory usage.", "url": "https://github.com/ConsenSys/teku/pull/3352#discussion_r537209224", "createdAt": "2020-12-07T03:38:24Z", "author": {"login": "ajsutton"}, "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/epoch/status/ValidatorStatuses.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.core.epoch.status;\n+\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root_at_slot;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.datastructures.operations.AttestationData;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.datastructures.state.Checkpoint;\n+import tech.pegasys.teku.datastructures.state.Validator;\n+import tech.pegasys.teku.datastructures.util.AttestationUtil;\n+import tech.pegasys.teku.datastructures.util.BeaconStateUtil;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.ssz.SSZTypes.SSZList;\n+\n+public class ValidatorStatuses {\n+  private final List<ValidatorStatus> statuses;\n+  private final TotalBalances totalBalances;\n+\n+  private ValidatorStatuses(\n+      final List<ValidatorStatus> statuses, final TotalBalances totalBalances) {\n+    this.statuses = statuses;\n+    this.totalBalances = totalBalances;\n+  }\n+\n+  public static ValidatorStatuses create(final BeaconState state) {\n+    final SSZList<Validator> validators = state.getValidators();\n+\n+    final UInt64 currentEpoch = BeaconStateUtil.get_current_epoch(state);\n+    final UInt64 previousEpoch = BeaconStateUtil.get_previous_epoch(state);\n+\n+    final List<ValidatorStatus> statuses =\n+        validators.stream()\n+            .map(validator -> ValidatorStatus.create(validator, previousEpoch, currentEpoch))\n+            .collect(Collectors.toCollection(() -> new ArrayList<>(validators.size())));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTgyNDI0NQ=="}, "originalCommit": {"oid": "66afa36703fc03f86c047692986e4297120314de"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM2MTkyMjA2OnYy", "diffSide": "RIGHT", "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/epoch/status/ValidatorStatuses.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNFQwNDoxOTo1N1rOH_AKNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wN1QwNToxMzoxNlrOIAWSBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTgyNDk1MQ==", "bodyText": "if it's not current or previous, should it be an IllegalState? theres if, else if, no else...", "url": "https://github.com/ConsenSys/teku/pull/3352#discussion_r535824951", "createdAt": "2020-12-04T04:19:57Z", "author": {"login": "rolfyone"}, "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/epoch/status/ValidatorStatuses.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.core.epoch.status;\n+\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root_at_slot;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.datastructures.operations.AttestationData;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.datastructures.state.Checkpoint;\n+import tech.pegasys.teku.datastructures.state.Validator;\n+import tech.pegasys.teku.datastructures.util.AttestationUtil;\n+import tech.pegasys.teku.datastructures.util.BeaconStateUtil;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.ssz.SSZTypes.SSZList;\n+\n+public class ValidatorStatuses {\n+  private final List<ValidatorStatus> statuses;\n+  private final TotalBalances totalBalances;\n+\n+  private ValidatorStatuses(\n+      final List<ValidatorStatus> statuses, final TotalBalances totalBalances) {\n+    this.statuses = statuses;\n+    this.totalBalances = totalBalances;\n+  }\n+\n+  public static ValidatorStatuses create(final BeaconState state) {\n+    final SSZList<Validator> validators = state.getValidators();\n+\n+    final UInt64 currentEpoch = BeaconStateUtil.get_current_epoch(state);\n+    final UInt64 previousEpoch = BeaconStateUtil.get_previous_epoch(state);\n+\n+    final List<ValidatorStatus> statuses =\n+        validators.stream()\n+            .map(validator -> ValidatorStatus.create(validator, previousEpoch, currentEpoch))\n+            .collect(Collectors.toCollection(() -> new ArrayList<>(validators.size())));\n+\n+    processAttestations(statuses, state, previousEpoch, currentEpoch);\n+\n+    final TotalBalances totalBalances = TotalBalances.create(statuses);\n+\n+    return new ValidatorStatuses(statuses, totalBalances);\n+  }\n+\n+  private static void processAttestations(\n+      final List<ValidatorStatus> statuses,\n+      final BeaconState state,\n+      final UInt64 previousEpoch,\n+      final UInt64 currentEpoch) {\n+    Stream.concat(\n+            state.getPrevious_epoch_attestations().stream(),\n+            state.getCurrent_epoch_attestations().stream())\n+        .forEach(\n+            attestation -> {\n+              final AttestationData data = attestation.getData();\n+\n+              final AttestationUpdates updates = new AttestationUpdates();\n+              final Checkpoint target = data.getTarget();\n+              if (target.getEpoch().equals(currentEpoch)) {\n+                updates.currentEpochAttester = true;\n+                updates.currentEpochTargetAttester =\n+                    matchesEpochStartBlock(state, currentEpoch, target.getRoot());\n+              } else if (target.getEpoch().equals(previousEpoch)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "66afa36703fc03f86c047692986e4297120314de"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzIyODE3OA==", "bodyText": "I'm in two minds about this.  If it's not either, there's no rewards and we can just ignore the attestation so the current code isn't wrong.  It shouldn't ever happen because the attestations in a state only come from blocks and the block validation prevents attestations that aren't from current or previous epoch from appearing.  If that ever changed we wouldn't necessarily want this to throw an exception.\nGiven that we're iterating over the combination of getPrevious_epoch_attestations and getCurrent_epoch_attestations I'm going to lean towards not having the else unless there are particularly strong objections.", "url": "https://github.com/ConsenSys/teku/pull/3352#discussion_r537228178", "createdAt": "2020-12-07T04:46:22Z", "author": {"login": "ajsutton"}, "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/epoch/status/ValidatorStatuses.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.core.epoch.status;\n+\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root_at_slot;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.datastructures.operations.AttestationData;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.datastructures.state.Checkpoint;\n+import tech.pegasys.teku.datastructures.state.Validator;\n+import tech.pegasys.teku.datastructures.util.AttestationUtil;\n+import tech.pegasys.teku.datastructures.util.BeaconStateUtil;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.ssz.SSZTypes.SSZList;\n+\n+public class ValidatorStatuses {\n+  private final List<ValidatorStatus> statuses;\n+  private final TotalBalances totalBalances;\n+\n+  private ValidatorStatuses(\n+      final List<ValidatorStatus> statuses, final TotalBalances totalBalances) {\n+    this.statuses = statuses;\n+    this.totalBalances = totalBalances;\n+  }\n+\n+  public static ValidatorStatuses create(final BeaconState state) {\n+    final SSZList<Validator> validators = state.getValidators();\n+\n+    final UInt64 currentEpoch = BeaconStateUtil.get_current_epoch(state);\n+    final UInt64 previousEpoch = BeaconStateUtil.get_previous_epoch(state);\n+\n+    final List<ValidatorStatus> statuses =\n+        validators.stream()\n+            .map(validator -> ValidatorStatus.create(validator, previousEpoch, currentEpoch))\n+            .collect(Collectors.toCollection(() -> new ArrayList<>(validators.size())));\n+\n+    processAttestations(statuses, state, previousEpoch, currentEpoch);\n+\n+    final TotalBalances totalBalances = TotalBalances.create(statuses);\n+\n+    return new ValidatorStatuses(statuses, totalBalances);\n+  }\n+\n+  private static void processAttestations(\n+      final List<ValidatorStatus> statuses,\n+      final BeaconState state,\n+      final UInt64 previousEpoch,\n+      final UInt64 currentEpoch) {\n+    Stream.concat(\n+            state.getPrevious_epoch_attestations().stream(),\n+            state.getCurrent_epoch_attestations().stream())\n+        .forEach(\n+            attestation -> {\n+              final AttestationData data = attestation.getData();\n+\n+              final AttestationUpdates updates = new AttestationUpdates();\n+              final Checkpoint target = data.getTarget();\n+              if (target.getEpoch().equals(currentEpoch)) {\n+                updates.currentEpochAttester = true;\n+                updates.currentEpochTargetAttester =\n+                    matchesEpochStartBlock(state, currentEpoch, target.getRoot());\n+              } else if (target.getEpoch().equals(previousEpoch)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTgyNDk1MQ=="}, "originalCommit": {"oid": "66afa36703fc03f86c047692986e4297120314de"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzIzNDUyMw==", "bodyText": "I was just curious of the reasoning because its a little uncommon so I figured I'd ask the question - happy with the answer.", "url": "https://github.com/ConsenSys/teku/pull/3352#discussion_r537234523", "createdAt": "2020-12-07T05:08:21Z", "author": {"login": "rolfyone"}, "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/epoch/status/ValidatorStatuses.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.core.epoch.status;\n+\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root_at_slot;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.datastructures.operations.AttestationData;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.datastructures.state.Checkpoint;\n+import tech.pegasys.teku.datastructures.state.Validator;\n+import tech.pegasys.teku.datastructures.util.AttestationUtil;\n+import tech.pegasys.teku.datastructures.util.BeaconStateUtil;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.ssz.SSZTypes.SSZList;\n+\n+public class ValidatorStatuses {\n+  private final List<ValidatorStatus> statuses;\n+  private final TotalBalances totalBalances;\n+\n+  private ValidatorStatuses(\n+      final List<ValidatorStatus> statuses, final TotalBalances totalBalances) {\n+    this.statuses = statuses;\n+    this.totalBalances = totalBalances;\n+  }\n+\n+  public static ValidatorStatuses create(final BeaconState state) {\n+    final SSZList<Validator> validators = state.getValidators();\n+\n+    final UInt64 currentEpoch = BeaconStateUtil.get_current_epoch(state);\n+    final UInt64 previousEpoch = BeaconStateUtil.get_previous_epoch(state);\n+\n+    final List<ValidatorStatus> statuses =\n+        validators.stream()\n+            .map(validator -> ValidatorStatus.create(validator, previousEpoch, currentEpoch))\n+            .collect(Collectors.toCollection(() -> new ArrayList<>(validators.size())));\n+\n+    processAttestations(statuses, state, previousEpoch, currentEpoch);\n+\n+    final TotalBalances totalBalances = TotalBalances.create(statuses);\n+\n+    return new ValidatorStatuses(statuses, totalBalances);\n+  }\n+\n+  private static void processAttestations(\n+      final List<ValidatorStatus> statuses,\n+      final BeaconState state,\n+      final UInt64 previousEpoch,\n+      final UInt64 currentEpoch) {\n+    Stream.concat(\n+            state.getPrevious_epoch_attestations().stream(),\n+            state.getCurrent_epoch_attestations().stream())\n+        .forEach(\n+            attestation -> {\n+              final AttestationData data = attestation.getData();\n+\n+              final AttestationUpdates updates = new AttestationUpdates();\n+              final Checkpoint target = data.getTarget();\n+              if (target.getEpoch().equals(currentEpoch)) {\n+                updates.currentEpochAttester = true;\n+                updates.currentEpochTargetAttester =\n+                    matchesEpochStartBlock(state, currentEpoch, target.getRoot());\n+              } else if (target.getEpoch().equals(previousEpoch)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTgyNDk1MQ=="}, "originalCommit": {"oid": "66afa36703fc03f86c047692986e4297120314de"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzIzNTk3Mw==", "bodyText": "It was an excellent question. :)", "url": "https://github.com/ConsenSys/teku/pull/3352#discussion_r537235973", "createdAt": "2020-12-07T05:13:16Z", "author": {"login": "ajsutton"}, "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/epoch/status/ValidatorStatuses.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.core.epoch.status;\n+\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_block_root_at_slot;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.datastructures.operations.AttestationData;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.datastructures.state.Checkpoint;\n+import tech.pegasys.teku.datastructures.state.Validator;\n+import tech.pegasys.teku.datastructures.util.AttestationUtil;\n+import tech.pegasys.teku.datastructures.util.BeaconStateUtil;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+import tech.pegasys.teku.ssz.SSZTypes.SSZList;\n+\n+public class ValidatorStatuses {\n+  private final List<ValidatorStatus> statuses;\n+  private final TotalBalances totalBalances;\n+\n+  private ValidatorStatuses(\n+      final List<ValidatorStatus> statuses, final TotalBalances totalBalances) {\n+    this.statuses = statuses;\n+    this.totalBalances = totalBalances;\n+  }\n+\n+  public static ValidatorStatuses create(final BeaconState state) {\n+    final SSZList<Validator> validators = state.getValidators();\n+\n+    final UInt64 currentEpoch = BeaconStateUtil.get_current_epoch(state);\n+    final UInt64 previousEpoch = BeaconStateUtil.get_previous_epoch(state);\n+\n+    final List<ValidatorStatus> statuses =\n+        validators.stream()\n+            .map(validator -> ValidatorStatus.create(validator, previousEpoch, currentEpoch))\n+            .collect(Collectors.toCollection(() -> new ArrayList<>(validators.size())));\n+\n+    processAttestations(statuses, state, previousEpoch, currentEpoch);\n+\n+    final TotalBalances totalBalances = TotalBalances.create(statuses);\n+\n+    return new ValidatorStatuses(statuses, totalBalances);\n+  }\n+\n+  private static void processAttestations(\n+      final List<ValidatorStatus> statuses,\n+      final BeaconState state,\n+      final UInt64 previousEpoch,\n+      final UInt64 currentEpoch) {\n+    Stream.concat(\n+            state.getPrevious_epoch_attestations().stream(),\n+            state.getCurrent_epoch_attestations().stream())\n+        .forEach(\n+            attestation -> {\n+              final AttestationData data = attestation.getData();\n+\n+              final AttestationUpdates updates = new AttestationUpdates();\n+              final Checkpoint target = data.getTarget();\n+              if (target.getEpoch().equals(currentEpoch)) {\n+                updates.currentEpochAttester = true;\n+                updates.currentEpochTargetAttester =\n+                    matchesEpochStartBlock(state, currentEpoch, target.getRoot());\n+              } else if (target.getEpoch().equals(previousEpoch)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTgyNDk1MQ=="}, "originalCommit": {"oid": "66afa36703fc03f86c047692986e4297120314de"}, "originalPosition": 79}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2910, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}