{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg0MDIyMzg4", "number": 1286, "reviewThreads": {"totalCount": 25, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMjoyMjozNVrODlm-TQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQyMjo0Mjo0N1rODmfLzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNzYyNDQ1OnYy", "diffSide": "RIGHT", "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMjoyMjozNVrOFymYRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwMDoyMjo0MVrOFyoxcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYwMTkyNw==", "bodyText": "has the web3j problem been solved?", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388601927", "createdAt": "2020-03-05T22:22:35Z", "author": {"login": "macfarla"}, "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "diffHunk": "@@ -81,44 +99,144 @@ public void generate(\n           int validatorCount,\n       @Option(\n               names = {\"--output-file\", \"-o\"},\n+              paramLabel = \"<FILE>\",\n               description =\n-                  \"File to write validator keys to. Keys are printed to std out if not specified\")\n-          String outputFile) {\n+                  \"File to write unencrypted validator keys to. Keys are printed to std out if not specified\")\n+          String outputFile,\n+      @Option(\n+              names = {\"--encrypt-keys\", \"-e\"},\n+              defaultValue = \"false\",\n+              paramLabel = \"<TRUE|FALSE>\",\n+              description = \"Encrypt validator keys. (Default: false)\",\n+              arity = \"1\")\n+          boolean encryptKeys,\n+      @Option(\n+              names = {\"--keystore-output-dir\", \"-k\"},\n+              paramLabel = \"<PATH>\",\n+              description =\n+                  \"Encrypted keystore output directory. Use current directory if not specified\")\n+          String keystorePath) {\n+\n     try (params) {\n+      // generate BLS validator key and withdrawal key\n+      final List<Pair<BLSKeyPair, BLSKeyPair>> validatorKeyPairs =\n+          IntStream.range(0, validatorCount)\n+              .mapToObj(value -> Pair.of(BLSKeyPair.random(), BLSKeyPair.random()))\n+              .collect(Collectors.toList());\n+\n       final DepositTransactionSender sender = params.createTransactionSender();\n-      final List<SafeFuture<TransactionReceipt>> futures = new ArrayList<>();\n \n-      final PrintStream keyWriter;\n-      if (outputFile == null || outputFile.isBlank()) {\n-        keyWriter = System.out;\n-      } else {\n-        keyWriter = new PrintStream(new FileOutputStream(outputFile), true, StandardCharsets.UTF_8);\n-      }\n+      final StringBuilder yamlStringBuilder = new StringBuilder();\n+      final boolean printOnStandardOut = outputFile == null || outputFile.isBlank();\n+      final Path keyStoreOutputDirectory =\n+          keystorePath == null || keystorePath.isBlank() ? Path.of(\".\") : Path.of(keystorePath);\n+      final AtomicInteger counterSuffix = new AtomicInteger(0);\n+      final List<SafeFuture<TransactionReceipt>> futures;\n+      try {\n+        futures =\n+            validatorKeyPairs.stream()\n+                .map(\n+                    keyPair -> {\n+                      final String yamlFormattedString = getYamlFormattedString(keyPair);\n+                      if (encryptKeys) {\n+                        generateKeystores(\n+                            keyPair, keyStoreOutputDirectory, counterSuffix.incrementAndGet());\n+                      } else if (printOnStandardOut) {\n+                        System.out.println(yamlFormattedString);\n+                      } else {\n+                        yamlStringBuilder\n+                            .append(yamlFormattedString)\n+                            .append(System.lineSeparator());\n+                      }\n+\n+                      return sendDeposit(\n+                          sender,\n+                          keyPair.getLeft(),\n+                          keyPair.getRight().getPublicKey(),\n+                          params.amount);\n+                    })\n+                .collect(Collectors.toList());\n \n-      try (keyWriter) {\n-        for (int i = 0; i < validatorCount; i++) {\n-          final BLSKeyPair validatorKey = BLSKeyPair.random();\n-          final BLSKeyPair withdrawalKey = BLSKeyPair.random();\n-\n-          keyWriter.println(\n-              String.format(\n-                  \"- {privkey: '%s', pubkey: '%s', withdrawalPrivkey: '%s', withdrawalPubkey: '%s'}\",\n-                  validatorKey.getSecretKey().getSecretKey().toBytes(),\n-                  validatorKey.getPublicKey().toBytesCompressed(),\n-                  withdrawalKey.getSecretKey().getSecretKey().toBytes(),\n-                  withdrawalKey.getPublicKey().toBytesCompressed()));\n-          futures.add(\n-              sendDeposit(sender, validatorKey, withdrawalKey.getPublicKey(), params.amount));\n+      } finally {\n+        if (!encryptKeys && !printOnStandardOut) {\n+          // write keys yaml to file\n+          Files.writeString(Path.of(outputFile), yamlStringBuilder.toString());\n         }\n       }\n-      SafeFuture.allOf(futures.toArray(SafeFuture[]::new)).get(2, TimeUnit.MINUTES);\n+\n+      waitForTransactionReceipts(futures);\n     } catch (final Throwable t) {\n       STDOUT.log(\n           Level.FATAL,\n           \"Failed to send deposit transaction: \" + t.getClass() + \": \" + t.getMessage());\n-      System.exit(1); // Web3J creates a non-daemon thread we can't shut down. :(\n+      exit(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYzODM3OQ==", "bodyText": "I don't know about web3j. I moved the call in a method so that I can mock it in tests.", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388638379", "createdAt": "2020-03-06T00:13:43Z", "author": {"login": "usmansaleem"}, "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "diffHunk": "@@ -81,44 +99,144 @@ public void generate(\n           int validatorCount,\n       @Option(\n               names = {\"--output-file\", \"-o\"},\n+              paramLabel = \"<FILE>\",\n               description =\n-                  \"File to write validator keys to. Keys are printed to std out if not specified\")\n-          String outputFile) {\n+                  \"File to write unencrypted validator keys to. Keys are printed to std out if not specified\")\n+          String outputFile,\n+      @Option(\n+              names = {\"--encrypt-keys\", \"-e\"},\n+              defaultValue = \"false\",\n+              paramLabel = \"<TRUE|FALSE>\",\n+              description = \"Encrypt validator keys. (Default: false)\",\n+              arity = \"1\")\n+          boolean encryptKeys,\n+      @Option(\n+              names = {\"--keystore-output-dir\", \"-k\"},\n+              paramLabel = \"<PATH>\",\n+              description =\n+                  \"Encrypted keystore output directory. Use current directory if not specified\")\n+          String keystorePath) {\n+\n     try (params) {\n+      // generate BLS validator key and withdrawal key\n+      final List<Pair<BLSKeyPair, BLSKeyPair>> validatorKeyPairs =\n+          IntStream.range(0, validatorCount)\n+              .mapToObj(value -> Pair.of(BLSKeyPair.random(), BLSKeyPair.random()))\n+              .collect(Collectors.toList());\n+\n       final DepositTransactionSender sender = params.createTransactionSender();\n-      final List<SafeFuture<TransactionReceipt>> futures = new ArrayList<>();\n \n-      final PrintStream keyWriter;\n-      if (outputFile == null || outputFile.isBlank()) {\n-        keyWriter = System.out;\n-      } else {\n-        keyWriter = new PrintStream(new FileOutputStream(outputFile), true, StandardCharsets.UTF_8);\n-      }\n+      final StringBuilder yamlStringBuilder = new StringBuilder();\n+      final boolean printOnStandardOut = outputFile == null || outputFile.isBlank();\n+      final Path keyStoreOutputDirectory =\n+          keystorePath == null || keystorePath.isBlank() ? Path.of(\".\") : Path.of(keystorePath);\n+      final AtomicInteger counterSuffix = new AtomicInteger(0);\n+      final List<SafeFuture<TransactionReceipt>> futures;\n+      try {\n+        futures =\n+            validatorKeyPairs.stream()\n+                .map(\n+                    keyPair -> {\n+                      final String yamlFormattedString = getYamlFormattedString(keyPair);\n+                      if (encryptKeys) {\n+                        generateKeystores(\n+                            keyPair, keyStoreOutputDirectory, counterSuffix.incrementAndGet());\n+                      } else if (printOnStandardOut) {\n+                        System.out.println(yamlFormattedString);\n+                      } else {\n+                        yamlStringBuilder\n+                            .append(yamlFormattedString)\n+                            .append(System.lineSeparator());\n+                      }\n+\n+                      return sendDeposit(\n+                          sender,\n+                          keyPair.getLeft(),\n+                          keyPair.getRight().getPublicKey(),\n+                          params.amount);\n+                    })\n+                .collect(Collectors.toList());\n \n-      try (keyWriter) {\n-        for (int i = 0; i < validatorCount; i++) {\n-          final BLSKeyPair validatorKey = BLSKeyPair.random();\n-          final BLSKeyPair withdrawalKey = BLSKeyPair.random();\n-\n-          keyWriter.println(\n-              String.format(\n-                  \"- {privkey: '%s', pubkey: '%s', withdrawalPrivkey: '%s', withdrawalPubkey: '%s'}\",\n-                  validatorKey.getSecretKey().getSecretKey().toBytes(),\n-                  validatorKey.getPublicKey().toBytesCompressed(),\n-                  withdrawalKey.getSecretKey().getSecretKey().toBytes(),\n-                  withdrawalKey.getPublicKey().toBytesCompressed()));\n-          futures.add(\n-              sendDeposit(sender, validatorKey, withdrawalKey.getPublicKey(), params.amount));\n+      } finally {\n+        if (!encryptKeys && !printOnStandardOut) {\n+          // write keys yaml to file\n+          Files.writeString(Path.of(outputFile), yamlStringBuilder.toString());\n         }\n       }\n-      SafeFuture.allOf(futures.toArray(SafeFuture[]::new)).get(2, TimeUnit.MINUTES);\n+\n+      waitForTransactionReceipts(futures);\n     } catch (final Throwable t) {\n       STDOUT.log(\n           Level.FATAL,\n           \"Failed to send deposit transaction: \" + t.getClass() + \": \" + t.getMessage());\n-      System.exit(1); // Web3J creates a non-daemon thread we can't shut down. :(\n+      exit(1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYwMTkyNw=="}, "originalCommit": {"oid": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0MTEzOQ==", "bodyText": "Web3j remains problematic unfortunately.", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388641139", "createdAt": "2020-03-06T00:22:41Z", "author": {"login": "ajsutton"}, "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "diffHunk": "@@ -81,44 +99,144 @@ public void generate(\n           int validatorCount,\n       @Option(\n               names = {\"--output-file\", \"-o\"},\n+              paramLabel = \"<FILE>\",\n               description =\n-                  \"File to write validator keys to. Keys are printed to std out if not specified\")\n-          String outputFile) {\n+                  \"File to write unencrypted validator keys to. Keys are printed to std out if not specified\")\n+          String outputFile,\n+      @Option(\n+              names = {\"--encrypt-keys\", \"-e\"},\n+              defaultValue = \"false\",\n+              paramLabel = \"<TRUE|FALSE>\",\n+              description = \"Encrypt validator keys. (Default: false)\",\n+              arity = \"1\")\n+          boolean encryptKeys,\n+      @Option(\n+              names = {\"--keystore-output-dir\", \"-k\"},\n+              paramLabel = \"<PATH>\",\n+              description =\n+                  \"Encrypted keystore output directory. Use current directory if not specified\")\n+          String keystorePath) {\n+\n     try (params) {\n+      // generate BLS validator key and withdrawal key\n+      final List<Pair<BLSKeyPair, BLSKeyPair>> validatorKeyPairs =\n+          IntStream.range(0, validatorCount)\n+              .mapToObj(value -> Pair.of(BLSKeyPair.random(), BLSKeyPair.random()))\n+              .collect(Collectors.toList());\n+\n       final DepositTransactionSender sender = params.createTransactionSender();\n-      final List<SafeFuture<TransactionReceipt>> futures = new ArrayList<>();\n \n-      final PrintStream keyWriter;\n-      if (outputFile == null || outputFile.isBlank()) {\n-        keyWriter = System.out;\n-      } else {\n-        keyWriter = new PrintStream(new FileOutputStream(outputFile), true, StandardCharsets.UTF_8);\n-      }\n+      final StringBuilder yamlStringBuilder = new StringBuilder();\n+      final boolean printOnStandardOut = outputFile == null || outputFile.isBlank();\n+      final Path keyStoreOutputDirectory =\n+          keystorePath == null || keystorePath.isBlank() ? Path.of(\".\") : Path.of(keystorePath);\n+      final AtomicInteger counterSuffix = new AtomicInteger(0);\n+      final List<SafeFuture<TransactionReceipt>> futures;\n+      try {\n+        futures =\n+            validatorKeyPairs.stream()\n+                .map(\n+                    keyPair -> {\n+                      final String yamlFormattedString = getYamlFormattedString(keyPair);\n+                      if (encryptKeys) {\n+                        generateKeystores(\n+                            keyPair, keyStoreOutputDirectory, counterSuffix.incrementAndGet());\n+                      } else if (printOnStandardOut) {\n+                        System.out.println(yamlFormattedString);\n+                      } else {\n+                        yamlStringBuilder\n+                            .append(yamlFormattedString)\n+                            .append(System.lineSeparator());\n+                      }\n+\n+                      return sendDeposit(\n+                          sender,\n+                          keyPair.getLeft(),\n+                          keyPair.getRight().getPublicKey(),\n+                          params.amount);\n+                    })\n+                .collect(Collectors.toList());\n \n-      try (keyWriter) {\n-        for (int i = 0; i < validatorCount; i++) {\n-          final BLSKeyPair validatorKey = BLSKeyPair.random();\n-          final BLSKeyPair withdrawalKey = BLSKeyPair.random();\n-\n-          keyWriter.println(\n-              String.format(\n-                  \"- {privkey: '%s', pubkey: '%s', withdrawalPrivkey: '%s', withdrawalPubkey: '%s'}\",\n-                  validatorKey.getSecretKey().getSecretKey().toBytes(),\n-                  validatorKey.getPublicKey().toBytesCompressed(),\n-                  withdrawalKey.getSecretKey().getSecretKey().toBytes(),\n-                  withdrawalKey.getPublicKey().toBytesCompressed()));\n-          futures.add(\n-              sendDeposit(sender, validatorKey, withdrawalKey.getPublicKey(), params.amount));\n+      } finally {\n+        if (!encryptKeys && !printOnStandardOut) {\n+          // write keys yaml to file\n+          Files.writeString(Path.of(outputFile), yamlStringBuilder.toString());\n         }\n       }\n-      SafeFuture.allOf(futures.toArray(SafeFuture[]::new)).get(2, TimeUnit.MINUTES);\n+\n+      waitForTransactionReceipts(futures);\n     } catch (final Throwable t) {\n       STDOUT.log(\n           Level.FATAL,\n           \"Failed to send deposit transaction: \" + t.getClass() + \": \" + t.getMessage());\n-      System.exit(1); // Web3J creates a non-daemon thread we can't shut down. :(\n+      exit(1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYwMTkyNw=="}, "originalCommit": {"oid": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0"}, "originalPosition": 155}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNzc5NTMyOnYy", "diffSide": "RIGHT", "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMzozNToyNlrOFyn7Fw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQwOTo1ODozMFrOFzg0Kg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYyNzIyMw==", "bodyText": "nit: final", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388627223", "createdAt": "2020-03-05T23:35:26Z", "author": {"login": "jframe"}, "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "diffHunk": "@@ -81,44 +99,144 @@ public void generate(\n           int validatorCount,\n       @Option(\n               names = {\"--output-file\", \"-o\"},\n+              paramLabel = \"<FILE>\",\n               description =\n-                  \"File to write validator keys to. Keys are printed to std out if not specified\")\n-          String outputFile) {\n+                  \"File to write unencrypted validator keys to. Keys are printed to std out if not specified\")\n+          String outputFile,\n+      @Option(\n+              names = {\"--encrypt-keys\", \"-e\"},\n+              defaultValue = \"false\",\n+              paramLabel = \"<TRUE|FALSE>\",\n+              description = \"Encrypt validator keys. (Default: false)\",\n+              arity = \"1\")\n+          boolean encryptKeys,\n+      @Option(\n+              names = {\"--keystore-output-dir\", \"-k\"},\n+              paramLabel = \"<PATH>\",\n+              description =\n+                  \"Encrypted keystore output directory. Use current directory if not specified\")\n+          String keystorePath) {\n+\n     try (params) {\n+      // generate BLS validator key and withdrawal key\n+      final List<Pair<BLSKeyPair, BLSKeyPair>> validatorKeyPairs =\n+          IntStream.range(0, validatorCount)\n+              .mapToObj(value -> Pair.of(BLSKeyPair.random(), BLSKeyPair.random()))\n+              .collect(Collectors.toList());\n+\n       final DepositTransactionSender sender = params.createTransactionSender();\n-      final List<SafeFuture<TransactionReceipt>> futures = new ArrayList<>();\n \n-      final PrintStream keyWriter;\n-      if (outputFile == null || outputFile.isBlank()) {\n-        keyWriter = System.out;\n-      } else {\n-        keyWriter = new PrintStream(new FileOutputStream(outputFile), true, StandardCharsets.UTF_8);\n-      }\n+      final StringBuilder yamlStringBuilder = new StringBuilder();\n+      final boolean printOnStandardOut = outputFile == null || outputFile.isBlank();\n+      final Path keyStoreOutputDirectory =\n+          keystorePath == null || keystorePath.isBlank() ? Path.of(\".\") : Path.of(keystorePath);\n+      final AtomicInteger counterSuffix = new AtomicInteger(0);\n+      final List<SafeFuture<TransactionReceipt>> futures;\n+      try {\n+        futures =\n+            validatorKeyPairs.stream()\n+                .map(\n+                    keyPair -> {\n+                      final String yamlFormattedString = getYamlFormattedString(keyPair);\n+                      if (encryptKeys) {\n+                        generateKeystores(\n+                            keyPair, keyStoreOutputDirectory, counterSuffix.incrementAndGet());\n+                      } else if (printOnStandardOut) {\n+                        System.out.println(yamlFormattedString);\n+                      } else {\n+                        yamlStringBuilder\n+                            .append(yamlFormattedString)\n+                            .append(System.lineSeparator());\n+                      }\n+\n+                      return sendDeposit(\n+                          sender,\n+                          keyPair.getLeft(),\n+                          keyPair.getRight().getPublicKey(),\n+                          params.amount);\n+                    })\n+                .collect(Collectors.toList());\n \n-      try (keyWriter) {\n-        for (int i = 0; i < validatorCount; i++) {\n-          final BLSKeyPair validatorKey = BLSKeyPair.random();\n-          final BLSKeyPair withdrawalKey = BLSKeyPair.random();\n-\n-          keyWriter.println(\n-              String.format(\n-                  \"- {privkey: '%s', pubkey: '%s', withdrawalPrivkey: '%s', withdrawalPubkey: '%s'}\",\n-                  validatorKey.getSecretKey().getSecretKey().toBytes(),\n-                  validatorKey.getPublicKey().toBytesCompressed(),\n-                  withdrawalKey.getSecretKey().getSecretKey().toBytes(),\n-                  withdrawalKey.getPublicKey().toBytesCompressed()));\n-          futures.add(\n-              sendDeposit(sender, validatorKey, withdrawalKey.getPublicKey(), params.amount));\n+      } finally {\n+        if (!encryptKeys && !printOnStandardOut) {\n+          // write keys yaml to file\n+          Files.writeString(Path.of(outputFile), yamlStringBuilder.toString());\n         }\n       }\n-      SafeFuture.allOf(futures.toArray(SafeFuture[]::new)).get(2, TimeUnit.MINUTES);\n+\n+      waitForTransactionReceipts(futures);\n     } catch (final Throwable t) {\n       STDOUT.log(\n           Level.FATAL,\n           \"Failed to send deposit transaction: \" + t.getClass() + \": \" + t.getMessage());\n-      System.exit(1); // Web3J creates a non-daemon thread we can't shut down. :(\n+      exit(1);\n     }\n-    System.exit(0); // Web3J creates a non-daemon thread we can't shut down. :(\n+    exit(0);\n+  }\n+\n+  @VisibleForTesting\n+  void waitForTransactionReceipts(final List<SafeFuture<TransactionReceipt>> futures)\n+      throws InterruptedException, ExecutionException, TimeoutException {\n+    SafeFuture.allOf(futures.toArray(SafeFuture[]::new)).get(2, TimeUnit.MINUTES);\n+  }\n+\n+  @VisibleForTesting\n+  void exit(final int status) {\n+    System.exit(status); // Web3J creates a non-daemon thread we can't shut down. :(\n+  }\n+\n+  private String getYamlFormattedString(final Pair<BLSKeyPair, BLSKeyPair> keyPair) {\n+    return String.format(\n+        \"- {privkey: '%s', pubkey: '%s', withdrawalPrivkey: '%s', withdrawalPubkey: '%s'}\",\n+        keyPair.getLeft().getSecretKey().getSecretKey().toBytes(),\n+        keyPair.getLeft().getPublicKey().toBytesCompressed(),\n+        keyPair.getRight().getSecretKey().getSecretKey().toBytes(),\n+        keyPair.getRight().getPublicKey().toBytesCompressed());\n+  }\n+\n+  private void generateKeystores(\n+      final Pair<BLSKeyPair, BLSKeyPair> keyPair,\n+      final Path keyStoreOutputDirectory,\n+      final int counter) {\n+    generateKeystore(keyPair.getLeft(), keyStoreOutputDirectory, \"validator\", counter);\n+    generateKeystore(keyPair.getRight(), keyStoreOutputDirectory, \"withdrawal\", counter);\n+  }\n+\n+  private void generateKeystore(\n+      final BLSKeyPair key, final Path outputDir, final String prefix, final int counter) {\n+    try {\n+      final KdfParam kdfParam = new SCryptParam(32, Bytes32.random());\n+      final Cipher cipher = new Cipher(CipherFunction.AES_128_CTR, Bytes.random(16));\n+      final String randomPassword = generateRandomHexToken();\n+      final KeyStoreData keyStoreData =\n+          KeyStore.encrypt(\n+              key.getSecretKey().getSecretKey().toBytes(),\n+              generateRandomHexToken(),\n+              \"\",\n+              kdfParam,\n+              cipher);\n+\n+      // create sub directory\n+      final Path keystoreDirectory =\n+          Files.createDirectories(outputDir.resolve(\"validator_\" + counter));\n+\n+      // save keystore\n+      KeyStoreLoader.saveToFile(\n+          keystoreDirectory.resolve(prefix + \"_keystore_\" + counter + \".json\"), keyStoreData);\n+\n+      // save password\n+      Files.writeString(\n+          keystoreDirectory.resolve(prefix + \"_password_\" + counter + \".txt\"), randomPassword);\n+    } catch (final IOException e) {\n+      throw new UncheckedIOException(e);\n+    }\n+  }\n+\n+  private String generateRandomHexToken() {\n+    final SecureRandom secureRandom = SecureRandomProvider.createSecureRandom();\n+    byte[] token = new byte[32];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0"}, "originalPosition": 221}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTU1OTMzOA==", "bodyText": "This method has been removed.", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r389559338", "createdAt": "2020-03-09T09:58:30Z", "author": {"login": "usmansaleem"}, "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "diffHunk": "@@ -81,44 +99,144 @@ public void generate(\n           int validatorCount,\n       @Option(\n               names = {\"--output-file\", \"-o\"},\n+              paramLabel = \"<FILE>\",\n               description =\n-                  \"File to write validator keys to. Keys are printed to std out if not specified\")\n-          String outputFile) {\n+                  \"File to write unencrypted validator keys to. Keys are printed to std out if not specified\")\n+          String outputFile,\n+      @Option(\n+              names = {\"--encrypt-keys\", \"-e\"},\n+              defaultValue = \"false\",\n+              paramLabel = \"<TRUE|FALSE>\",\n+              description = \"Encrypt validator keys. (Default: false)\",\n+              arity = \"1\")\n+          boolean encryptKeys,\n+      @Option(\n+              names = {\"--keystore-output-dir\", \"-k\"},\n+              paramLabel = \"<PATH>\",\n+              description =\n+                  \"Encrypted keystore output directory. Use current directory if not specified\")\n+          String keystorePath) {\n+\n     try (params) {\n+      // generate BLS validator key and withdrawal key\n+      final List<Pair<BLSKeyPair, BLSKeyPair>> validatorKeyPairs =\n+          IntStream.range(0, validatorCount)\n+              .mapToObj(value -> Pair.of(BLSKeyPair.random(), BLSKeyPair.random()))\n+              .collect(Collectors.toList());\n+\n       final DepositTransactionSender sender = params.createTransactionSender();\n-      final List<SafeFuture<TransactionReceipt>> futures = new ArrayList<>();\n \n-      final PrintStream keyWriter;\n-      if (outputFile == null || outputFile.isBlank()) {\n-        keyWriter = System.out;\n-      } else {\n-        keyWriter = new PrintStream(new FileOutputStream(outputFile), true, StandardCharsets.UTF_8);\n-      }\n+      final StringBuilder yamlStringBuilder = new StringBuilder();\n+      final boolean printOnStandardOut = outputFile == null || outputFile.isBlank();\n+      final Path keyStoreOutputDirectory =\n+          keystorePath == null || keystorePath.isBlank() ? Path.of(\".\") : Path.of(keystorePath);\n+      final AtomicInteger counterSuffix = new AtomicInteger(0);\n+      final List<SafeFuture<TransactionReceipt>> futures;\n+      try {\n+        futures =\n+            validatorKeyPairs.stream()\n+                .map(\n+                    keyPair -> {\n+                      final String yamlFormattedString = getYamlFormattedString(keyPair);\n+                      if (encryptKeys) {\n+                        generateKeystores(\n+                            keyPair, keyStoreOutputDirectory, counterSuffix.incrementAndGet());\n+                      } else if (printOnStandardOut) {\n+                        System.out.println(yamlFormattedString);\n+                      } else {\n+                        yamlStringBuilder\n+                            .append(yamlFormattedString)\n+                            .append(System.lineSeparator());\n+                      }\n+\n+                      return sendDeposit(\n+                          sender,\n+                          keyPair.getLeft(),\n+                          keyPair.getRight().getPublicKey(),\n+                          params.amount);\n+                    })\n+                .collect(Collectors.toList());\n \n-      try (keyWriter) {\n-        for (int i = 0; i < validatorCount; i++) {\n-          final BLSKeyPair validatorKey = BLSKeyPair.random();\n-          final BLSKeyPair withdrawalKey = BLSKeyPair.random();\n-\n-          keyWriter.println(\n-              String.format(\n-                  \"- {privkey: '%s', pubkey: '%s', withdrawalPrivkey: '%s', withdrawalPubkey: '%s'}\",\n-                  validatorKey.getSecretKey().getSecretKey().toBytes(),\n-                  validatorKey.getPublicKey().toBytesCompressed(),\n-                  withdrawalKey.getSecretKey().getSecretKey().toBytes(),\n-                  withdrawalKey.getPublicKey().toBytesCompressed()));\n-          futures.add(\n-              sendDeposit(sender, validatorKey, withdrawalKey.getPublicKey(), params.amount));\n+      } finally {\n+        if (!encryptKeys && !printOnStandardOut) {\n+          // write keys yaml to file\n+          Files.writeString(Path.of(outputFile), yamlStringBuilder.toString());\n         }\n       }\n-      SafeFuture.allOf(futures.toArray(SafeFuture[]::new)).get(2, TimeUnit.MINUTES);\n+\n+      waitForTransactionReceipts(futures);\n     } catch (final Throwable t) {\n       STDOUT.log(\n           Level.FATAL,\n           \"Failed to send deposit transaction: \" + t.getClass() + \": \" + t.getMessage());\n-      System.exit(1); // Web3J creates a non-daemon thread we can't shut down. :(\n+      exit(1);\n     }\n-    System.exit(0); // Web3J creates a non-daemon thread we can't shut down. :(\n+    exit(0);\n+  }\n+\n+  @VisibleForTesting\n+  void waitForTransactionReceipts(final List<SafeFuture<TransactionReceipt>> futures)\n+      throws InterruptedException, ExecutionException, TimeoutException {\n+    SafeFuture.allOf(futures.toArray(SafeFuture[]::new)).get(2, TimeUnit.MINUTES);\n+  }\n+\n+  @VisibleForTesting\n+  void exit(final int status) {\n+    System.exit(status); // Web3J creates a non-daemon thread we can't shut down. :(\n+  }\n+\n+  private String getYamlFormattedString(final Pair<BLSKeyPair, BLSKeyPair> keyPair) {\n+    return String.format(\n+        \"- {privkey: '%s', pubkey: '%s', withdrawalPrivkey: '%s', withdrawalPubkey: '%s'}\",\n+        keyPair.getLeft().getSecretKey().getSecretKey().toBytes(),\n+        keyPair.getLeft().getPublicKey().toBytesCompressed(),\n+        keyPair.getRight().getSecretKey().getSecretKey().toBytes(),\n+        keyPair.getRight().getPublicKey().toBytesCompressed());\n+  }\n+\n+  private void generateKeystores(\n+      final Pair<BLSKeyPair, BLSKeyPair> keyPair,\n+      final Path keyStoreOutputDirectory,\n+      final int counter) {\n+    generateKeystore(keyPair.getLeft(), keyStoreOutputDirectory, \"validator\", counter);\n+    generateKeystore(keyPair.getRight(), keyStoreOutputDirectory, \"withdrawal\", counter);\n+  }\n+\n+  private void generateKeystore(\n+      final BLSKeyPair key, final Path outputDir, final String prefix, final int counter) {\n+    try {\n+      final KdfParam kdfParam = new SCryptParam(32, Bytes32.random());\n+      final Cipher cipher = new Cipher(CipherFunction.AES_128_CTR, Bytes.random(16));\n+      final String randomPassword = generateRandomHexToken();\n+      final KeyStoreData keyStoreData =\n+          KeyStore.encrypt(\n+              key.getSecretKey().getSecretKey().toBytes(),\n+              generateRandomHexToken(),\n+              \"\",\n+              kdfParam,\n+              cipher);\n+\n+      // create sub directory\n+      final Path keystoreDirectory =\n+          Files.createDirectories(outputDir.resolve(\"validator_\" + counter));\n+\n+      // save keystore\n+      KeyStoreLoader.saveToFile(\n+          keystoreDirectory.resolve(prefix + \"_keystore_\" + counter + \".json\"), keyStoreData);\n+\n+      // save password\n+      Files.writeString(\n+          keystoreDirectory.resolve(prefix + \"_password_\" + counter + \".txt\"), randomPassword);\n+    } catch (final IOException e) {\n+      throw new UncheckedIOException(e);\n+    }\n+  }\n+\n+  private String generateRandomHexToken() {\n+    final SecureRandom secureRandom = SecureRandomProvider.createSecureRandom();\n+    byte[] token = new byte[32];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYyNzIyMw=="}, "originalCommit": {"oid": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0"}, "originalPosition": 221}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNzgwMDI0OnYy", "diffSide": "RIGHT", "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMzozNzo1MlrOFyn-AQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQwOTo1ODo0NVrOFzg0qg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYyNzk2OQ==", "bodyText": "Think we should use SecureRandom for the random seed", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388627969", "createdAt": "2020-03-05T23:37:52Z", "author": {"login": "jframe"}, "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "diffHunk": "@@ -81,44 +99,144 @@ public void generate(\n           int validatorCount,\n       @Option(\n               names = {\"--output-file\", \"-o\"},\n+              paramLabel = \"<FILE>\",\n               description =\n-                  \"File to write validator keys to. Keys are printed to std out if not specified\")\n-          String outputFile) {\n+                  \"File to write unencrypted validator keys to. Keys are printed to std out if not specified\")\n+          String outputFile,\n+      @Option(\n+              names = {\"--encrypt-keys\", \"-e\"},\n+              defaultValue = \"false\",\n+              paramLabel = \"<TRUE|FALSE>\",\n+              description = \"Encrypt validator keys. (Default: false)\",\n+              arity = \"1\")\n+          boolean encryptKeys,\n+      @Option(\n+              names = {\"--keystore-output-dir\", \"-k\"},\n+              paramLabel = \"<PATH>\",\n+              description =\n+                  \"Encrypted keystore output directory. Use current directory if not specified\")\n+          String keystorePath) {\n+\n     try (params) {\n+      // generate BLS validator key and withdrawal key\n+      final List<Pair<BLSKeyPair, BLSKeyPair>> validatorKeyPairs =\n+          IntStream.range(0, validatorCount)\n+              .mapToObj(value -> Pair.of(BLSKeyPair.random(), BLSKeyPair.random()))\n+              .collect(Collectors.toList());\n+\n       final DepositTransactionSender sender = params.createTransactionSender();\n-      final List<SafeFuture<TransactionReceipt>> futures = new ArrayList<>();\n \n-      final PrintStream keyWriter;\n-      if (outputFile == null || outputFile.isBlank()) {\n-        keyWriter = System.out;\n-      } else {\n-        keyWriter = new PrintStream(new FileOutputStream(outputFile), true, StandardCharsets.UTF_8);\n-      }\n+      final StringBuilder yamlStringBuilder = new StringBuilder();\n+      final boolean printOnStandardOut = outputFile == null || outputFile.isBlank();\n+      final Path keyStoreOutputDirectory =\n+          keystorePath == null || keystorePath.isBlank() ? Path.of(\".\") : Path.of(keystorePath);\n+      final AtomicInteger counterSuffix = new AtomicInteger(0);\n+      final List<SafeFuture<TransactionReceipt>> futures;\n+      try {\n+        futures =\n+            validatorKeyPairs.stream()\n+                .map(\n+                    keyPair -> {\n+                      final String yamlFormattedString = getYamlFormattedString(keyPair);\n+                      if (encryptKeys) {\n+                        generateKeystores(\n+                            keyPair, keyStoreOutputDirectory, counterSuffix.incrementAndGet());\n+                      } else if (printOnStandardOut) {\n+                        System.out.println(yamlFormattedString);\n+                      } else {\n+                        yamlStringBuilder\n+                            .append(yamlFormattedString)\n+                            .append(System.lineSeparator());\n+                      }\n+\n+                      return sendDeposit(\n+                          sender,\n+                          keyPair.getLeft(),\n+                          keyPair.getRight().getPublicKey(),\n+                          params.amount);\n+                    })\n+                .collect(Collectors.toList());\n \n-      try (keyWriter) {\n-        for (int i = 0; i < validatorCount; i++) {\n-          final BLSKeyPair validatorKey = BLSKeyPair.random();\n-          final BLSKeyPair withdrawalKey = BLSKeyPair.random();\n-\n-          keyWriter.println(\n-              String.format(\n-                  \"- {privkey: '%s', pubkey: '%s', withdrawalPrivkey: '%s', withdrawalPubkey: '%s'}\",\n-                  validatorKey.getSecretKey().getSecretKey().toBytes(),\n-                  validatorKey.getPublicKey().toBytesCompressed(),\n-                  withdrawalKey.getSecretKey().getSecretKey().toBytes(),\n-                  withdrawalKey.getPublicKey().toBytesCompressed()));\n-          futures.add(\n-              sendDeposit(sender, validatorKey, withdrawalKey.getPublicKey(), params.amount));\n+      } finally {\n+        if (!encryptKeys && !printOnStandardOut) {\n+          // write keys yaml to file\n+          Files.writeString(Path.of(outputFile), yamlStringBuilder.toString());\n         }\n       }\n-      SafeFuture.allOf(futures.toArray(SafeFuture[]::new)).get(2, TimeUnit.MINUTES);\n+\n+      waitForTransactionReceipts(futures);\n     } catch (final Throwable t) {\n       STDOUT.log(\n           Level.FATAL,\n           \"Failed to send deposit transaction: \" + t.getClass() + \": \" + t.getMessage());\n-      System.exit(1); // Web3J creates a non-daemon thread we can't shut down. :(\n+      exit(1);\n     }\n-    System.exit(0); // Web3J creates a non-daemon thread we can't shut down. :(\n+    exit(0);\n+  }\n+\n+  @VisibleForTesting\n+  void waitForTransactionReceipts(final List<SafeFuture<TransactionReceipt>> futures)\n+      throws InterruptedException, ExecutionException, TimeoutException {\n+    SafeFuture.allOf(futures.toArray(SafeFuture[]::new)).get(2, TimeUnit.MINUTES);\n+  }\n+\n+  @VisibleForTesting\n+  void exit(final int status) {\n+    System.exit(status); // Web3J creates a non-daemon thread we can't shut down. :(\n+  }\n+\n+  private String getYamlFormattedString(final Pair<BLSKeyPair, BLSKeyPair> keyPair) {\n+    return String.format(\n+        \"- {privkey: '%s', pubkey: '%s', withdrawalPrivkey: '%s', withdrawalPubkey: '%s'}\",\n+        keyPair.getLeft().getSecretKey().getSecretKey().toBytes(),\n+        keyPair.getLeft().getPublicKey().toBytesCompressed(),\n+        keyPair.getRight().getSecretKey().getSecretKey().toBytes(),\n+        keyPair.getRight().getPublicKey().toBytesCompressed());\n+  }\n+\n+  private void generateKeystores(\n+      final Pair<BLSKeyPair, BLSKeyPair> keyPair,\n+      final Path keyStoreOutputDirectory,\n+      final int counter) {\n+    generateKeystore(keyPair.getLeft(), keyStoreOutputDirectory, \"validator\", counter);\n+    generateKeystore(keyPair.getRight(), keyStoreOutputDirectory, \"withdrawal\", counter);\n+  }\n+\n+  private void generateKeystore(\n+      final BLSKeyPair key, final Path outputDir, final String prefix, final int counter) {\n+    try {\n+      final KdfParam kdfParam = new SCryptParam(32, Bytes32.random());\n+      final Cipher cipher = new Cipher(CipherFunction.AES_128_CTR, Bytes.random(16));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0"}, "originalPosition": 193}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY3NzY0OQ==", "bodyText": "tuweni Bytes random by default use new SecureRandom, but we should/can pass our own SecureRandom instance as well.", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388677649", "createdAt": "2020-03-06T02:06:59Z", "author": {"login": "usmansaleem"}, "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "diffHunk": "@@ -81,44 +99,144 @@ public void generate(\n           int validatorCount,\n       @Option(\n               names = {\"--output-file\", \"-o\"},\n+              paramLabel = \"<FILE>\",\n               description =\n-                  \"File to write validator keys to. Keys are printed to std out if not specified\")\n-          String outputFile) {\n+                  \"File to write unencrypted validator keys to. Keys are printed to std out if not specified\")\n+          String outputFile,\n+      @Option(\n+              names = {\"--encrypt-keys\", \"-e\"},\n+              defaultValue = \"false\",\n+              paramLabel = \"<TRUE|FALSE>\",\n+              description = \"Encrypt validator keys. (Default: false)\",\n+              arity = \"1\")\n+          boolean encryptKeys,\n+      @Option(\n+              names = {\"--keystore-output-dir\", \"-k\"},\n+              paramLabel = \"<PATH>\",\n+              description =\n+                  \"Encrypted keystore output directory. Use current directory if not specified\")\n+          String keystorePath) {\n+\n     try (params) {\n+      // generate BLS validator key and withdrawal key\n+      final List<Pair<BLSKeyPair, BLSKeyPair>> validatorKeyPairs =\n+          IntStream.range(0, validatorCount)\n+              .mapToObj(value -> Pair.of(BLSKeyPair.random(), BLSKeyPair.random()))\n+              .collect(Collectors.toList());\n+\n       final DepositTransactionSender sender = params.createTransactionSender();\n-      final List<SafeFuture<TransactionReceipt>> futures = new ArrayList<>();\n \n-      final PrintStream keyWriter;\n-      if (outputFile == null || outputFile.isBlank()) {\n-        keyWriter = System.out;\n-      } else {\n-        keyWriter = new PrintStream(new FileOutputStream(outputFile), true, StandardCharsets.UTF_8);\n-      }\n+      final StringBuilder yamlStringBuilder = new StringBuilder();\n+      final boolean printOnStandardOut = outputFile == null || outputFile.isBlank();\n+      final Path keyStoreOutputDirectory =\n+          keystorePath == null || keystorePath.isBlank() ? Path.of(\".\") : Path.of(keystorePath);\n+      final AtomicInteger counterSuffix = new AtomicInteger(0);\n+      final List<SafeFuture<TransactionReceipt>> futures;\n+      try {\n+        futures =\n+            validatorKeyPairs.stream()\n+                .map(\n+                    keyPair -> {\n+                      final String yamlFormattedString = getYamlFormattedString(keyPair);\n+                      if (encryptKeys) {\n+                        generateKeystores(\n+                            keyPair, keyStoreOutputDirectory, counterSuffix.incrementAndGet());\n+                      } else if (printOnStandardOut) {\n+                        System.out.println(yamlFormattedString);\n+                      } else {\n+                        yamlStringBuilder\n+                            .append(yamlFormattedString)\n+                            .append(System.lineSeparator());\n+                      }\n+\n+                      return sendDeposit(\n+                          sender,\n+                          keyPair.getLeft(),\n+                          keyPair.getRight().getPublicKey(),\n+                          params.amount);\n+                    })\n+                .collect(Collectors.toList());\n \n-      try (keyWriter) {\n-        for (int i = 0; i < validatorCount; i++) {\n-          final BLSKeyPair validatorKey = BLSKeyPair.random();\n-          final BLSKeyPair withdrawalKey = BLSKeyPair.random();\n-\n-          keyWriter.println(\n-              String.format(\n-                  \"- {privkey: '%s', pubkey: '%s', withdrawalPrivkey: '%s', withdrawalPubkey: '%s'}\",\n-                  validatorKey.getSecretKey().getSecretKey().toBytes(),\n-                  validatorKey.getPublicKey().toBytesCompressed(),\n-                  withdrawalKey.getSecretKey().getSecretKey().toBytes(),\n-                  withdrawalKey.getPublicKey().toBytesCompressed()));\n-          futures.add(\n-              sendDeposit(sender, validatorKey, withdrawalKey.getPublicKey(), params.amount));\n+      } finally {\n+        if (!encryptKeys && !printOnStandardOut) {\n+          // write keys yaml to file\n+          Files.writeString(Path.of(outputFile), yamlStringBuilder.toString());\n         }\n       }\n-      SafeFuture.allOf(futures.toArray(SafeFuture[]::new)).get(2, TimeUnit.MINUTES);\n+\n+      waitForTransactionReceipts(futures);\n     } catch (final Throwable t) {\n       STDOUT.log(\n           Level.FATAL,\n           \"Failed to send deposit transaction: \" + t.getClass() + \": \" + t.getMessage());\n-      System.exit(1); // Web3J creates a non-daemon thread we can't shut down. :(\n+      exit(1);\n     }\n-    System.exit(0); // Web3J creates a non-daemon thread we can't shut down. :(\n+    exit(0);\n+  }\n+\n+  @VisibleForTesting\n+  void waitForTransactionReceipts(final List<SafeFuture<TransactionReceipt>> futures)\n+      throws InterruptedException, ExecutionException, TimeoutException {\n+    SafeFuture.allOf(futures.toArray(SafeFuture[]::new)).get(2, TimeUnit.MINUTES);\n+  }\n+\n+  @VisibleForTesting\n+  void exit(final int status) {\n+    System.exit(status); // Web3J creates a non-daemon thread we can't shut down. :(\n+  }\n+\n+  private String getYamlFormattedString(final Pair<BLSKeyPair, BLSKeyPair> keyPair) {\n+    return String.format(\n+        \"- {privkey: '%s', pubkey: '%s', withdrawalPrivkey: '%s', withdrawalPubkey: '%s'}\",\n+        keyPair.getLeft().getSecretKey().getSecretKey().toBytes(),\n+        keyPair.getLeft().getPublicKey().toBytesCompressed(),\n+        keyPair.getRight().getSecretKey().getSecretKey().toBytes(),\n+        keyPair.getRight().getPublicKey().toBytesCompressed());\n+  }\n+\n+  private void generateKeystores(\n+      final Pair<BLSKeyPair, BLSKeyPair> keyPair,\n+      final Path keyStoreOutputDirectory,\n+      final int counter) {\n+    generateKeystore(keyPair.getLeft(), keyStoreOutputDirectory, \"validator\", counter);\n+    generateKeystore(keyPair.getRight(), keyStoreOutputDirectory, \"withdrawal\", counter);\n+  }\n+\n+  private void generateKeystore(\n+      final BLSKeyPair key, final Path outputDir, final String prefix, final int counter) {\n+    try {\n+      final KdfParam kdfParam = new SCryptParam(32, Bytes32.random());\n+      final Cipher cipher = new Cipher(CipherFunction.AES_128_CTR, Bytes.random(16));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYyNzk2OQ=="}, "originalCommit": {"oid": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0"}, "originalPosition": 193}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTU1OTQ2Ng==", "bodyText": "done.", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r389559466", "createdAt": "2020-03-09T09:58:45Z", "author": {"login": "usmansaleem"}, "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "diffHunk": "@@ -81,44 +99,144 @@ public void generate(\n           int validatorCount,\n       @Option(\n               names = {\"--output-file\", \"-o\"},\n+              paramLabel = \"<FILE>\",\n               description =\n-                  \"File to write validator keys to. Keys are printed to std out if not specified\")\n-          String outputFile) {\n+                  \"File to write unencrypted validator keys to. Keys are printed to std out if not specified\")\n+          String outputFile,\n+      @Option(\n+              names = {\"--encrypt-keys\", \"-e\"},\n+              defaultValue = \"false\",\n+              paramLabel = \"<TRUE|FALSE>\",\n+              description = \"Encrypt validator keys. (Default: false)\",\n+              arity = \"1\")\n+          boolean encryptKeys,\n+      @Option(\n+              names = {\"--keystore-output-dir\", \"-k\"},\n+              paramLabel = \"<PATH>\",\n+              description =\n+                  \"Encrypted keystore output directory. Use current directory if not specified\")\n+          String keystorePath) {\n+\n     try (params) {\n+      // generate BLS validator key and withdrawal key\n+      final List<Pair<BLSKeyPair, BLSKeyPair>> validatorKeyPairs =\n+          IntStream.range(0, validatorCount)\n+              .mapToObj(value -> Pair.of(BLSKeyPair.random(), BLSKeyPair.random()))\n+              .collect(Collectors.toList());\n+\n       final DepositTransactionSender sender = params.createTransactionSender();\n-      final List<SafeFuture<TransactionReceipt>> futures = new ArrayList<>();\n \n-      final PrintStream keyWriter;\n-      if (outputFile == null || outputFile.isBlank()) {\n-        keyWriter = System.out;\n-      } else {\n-        keyWriter = new PrintStream(new FileOutputStream(outputFile), true, StandardCharsets.UTF_8);\n-      }\n+      final StringBuilder yamlStringBuilder = new StringBuilder();\n+      final boolean printOnStandardOut = outputFile == null || outputFile.isBlank();\n+      final Path keyStoreOutputDirectory =\n+          keystorePath == null || keystorePath.isBlank() ? Path.of(\".\") : Path.of(keystorePath);\n+      final AtomicInteger counterSuffix = new AtomicInteger(0);\n+      final List<SafeFuture<TransactionReceipt>> futures;\n+      try {\n+        futures =\n+            validatorKeyPairs.stream()\n+                .map(\n+                    keyPair -> {\n+                      final String yamlFormattedString = getYamlFormattedString(keyPair);\n+                      if (encryptKeys) {\n+                        generateKeystores(\n+                            keyPair, keyStoreOutputDirectory, counterSuffix.incrementAndGet());\n+                      } else if (printOnStandardOut) {\n+                        System.out.println(yamlFormattedString);\n+                      } else {\n+                        yamlStringBuilder\n+                            .append(yamlFormattedString)\n+                            .append(System.lineSeparator());\n+                      }\n+\n+                      return sendDeposit(\n+                          sender,\n+                          keyPair.getLeft(),\n+                          keyPair.getRight().getPublicKey(),\n+                          params.amount);\n+                    })\n+                .collect(Collectors.toList());\n \n-      try (keyWriter) {\n-        for (int i = 0; i < validatorCount; i++) {\n-          final BLSKeyPair validatorKey = BLSKeyPair.random();\n-          final BLSKeyPair withdrawalKey = BLSKeyPair.random();\n-\n-          keyWriter.println(\n-              String.format(\n-                  \"- {privkey: '%s', pubkey: '%s', withdrawalPrivkey: '%s', withdrawalPubkey: '%s'}\",\n-                  validatorKey.getSecretKey().getSecretKey().toBytes(),\n-                  validatorKey.getPublicKey().toBytesCompressed(),\n-                  withdrawalKey.getSecretKey().getSecretKey().toBytes(),\n-                  withdrawalKey.getPublicKey().toBytesCompressed()));\n-          futures.add(\n-              sendDeposit(sender, validatorKey, withdrawalKey.getPublicKey(), params.amount));\n+      } finally {\n+        if (!encryptKeys && !printOnStandardOut) {\n+          // write keys yaml to file\n+          Files.writeString(Path.of(outputFile), yamlStringBuilder.toString());\n         }\n       }\n-      SafeFuture.allOf(futures.toArray(SafeFuture[]::new)).get(2, TimeUnit.MINUTES);\n+\n+      waitForTransactionReceipts(futures);\n     } catch (final Throwable t) {\n       STDOUT.log(\n           Level.FATAL,\n           \"Failed to send deposit transaction: \" + t.getClass() + \": \" + t.getMessage());\n-      System.exit(1); // Web3J creates a non-daemon thread we can't shut down. :(\n+      exit(1);\n     }\n-    System.exit(0); // Web3J creates a non-daemon thread we can't shut down. :(\n+    exit(0);\n+  }\n+\n+  @VisibleForTesting\n+  void waitForTransactionReceipts(final List<SafeFuture<TransactionReceipt>> futures)\n+      throws InterruptedException, ExecutionException, TimeoutException {\n+    SafeFuture.allOf(futures.toArray(SafeFuture[]::new)).get(2, TimeUnit.MINUTES);\n+  }\n+\n+  @VisibleForTesting\n+  void exit(final int status) {\n+    System.exit(status); // Web3J creates a non-daemon thread we can't shut down. :(\n+  }\n+\n+  private String getYamlFormattedString(final Pair<BLSKeyPair, BLSKeyPair> keyPair) {\n+    return String.format(\n+        \"- {privkey: '%s', pubkey: '%s', withdrawalPrivkey: '%s', withdrawalPubkey: '%s'}\",\n+        keyPair.getLeft().getSecretKey().getSecretKey().toBytes(),\n+        keyPair.getLeft().getPublicKey().toBytesCompressed(),\n+        keyPair.getRight().getSecretKey().getSecretKey().toBytes(),\n+        keyPair.getRight().getPublicKey().toBytesCompressed());\n+  }\n+\n+  private void generateKeystores(\n+      final Pair<BLSKeyPair, BLSKeyPair> keyPair,\n+      final Path keyStoreOutputDirectory,\n+      final int counter) {\n+    generateKeystore(keyPair.getLeft(), keyStoreOutputDirectory, \"validator\", counter);\n+    generateKeystore(keyPair.getRight(), keyStoreOutputDirectory, \"withdrawal\", counter);\n+  }\n+\n+  private void generateKeystore(\n+      final BLSKeyPair key, final Path outputDir, final String prefix, final int counter) {\n+    try {\n+      final KdfParam kdfParam = new SCryptParam(32, Bytes32.random());\n+      final Cipher cipher = new Cipher(CipherFunction.AES_128_CTR, Bytes.random(16));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYyNzk2OQ=="}, "originalCommit": {"oid": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0"}, "originalPosition": 193}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNzgwOTE4OnYy", "diffSide": "RIGHT", "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMzo0Mjo0MlrOFyoDRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQwOTo1OTozOFrOFzg2mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYyOTMxNg==", "bodyText": "Thinking we should log an error at this point so we know which keystore failed to be created", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388629316", "createdAt": "2020-03-05T23:42:42Z", "author": {"login": "jframe"}, "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "diffHunk": "@@ -81,44 +99,144 @@ public void generate(\n           int validatorCount,\n       @Option(\n               names = {\"--output-file\", \"-o\"},\n+              paramLabel = \"<FILE>\",\n               description =\n-                  \"File to write validator keys to. Keys are printed to std out if not specified\")\n-          String outputFile) {\n+                  \"File to write unencrypted validator keys to. Keys are printed to std out if not specified\")\n+          String outputFile,\n+      @Option(\n+              names = {\"--encrypt-keys\", \"-e\"},\n+              defaultValue = \"false\",\n+              paramLabel = \"<TRUE|FALSE>\",\n+              description = \"Encrypt validator keys. (Default: false)\",\n+              arity = \"1\")\n+          boolean encryptKeys,\n+      @Option(\n+              names = {\"--keystore-output-dir\", \"-k\"},\n+              paramLabel = \"<PATH>\",\n+              description =\n+                  \"Encrypted keystore output directory. Use current directory if not specified\")\n+          String keystorePath) {\n+\n     try (params) {\n+      // generate BLS validator key and withdrawal key\n+      final List<Pair<BLSKeyPair, BLSKeyPair>> validatorKeyPairs =\n+          IntStream.range(0, validatorCount)\n+              .mapToObj(value -> Pair.of(BLSKeyPair.random(), BLSKeyPair.random()))\n+              .collect(Collectors.toList());\n+\n       final DepositTransactionSender sender = params.createTransactionSender();\n-      final List<SafeFuture<TransactionReceipt>> futures = new ArrayList<>();\n \n-      final PrintStream keyWriter;\n-      if (outputFile == null || outputFile.isBlank()) {\n-        keyWriter = System.out;\n-      } else {\n-        keyWriter = new PrintStream(new FileOutputStream(outputFile), true, StandardCharsets.UTF_8);\n-      }\n+      final StringBuilder yamlStringBuilder = new StringBuilder();\n+      final boolean printOnStandardOut = outputFile == null || outputFile.isBlank();\n+      final Path keyStoreOutputDirectory =\n+          keystorePath == null || keystorePath.isBlank() ? Path.of(\".\") : Path.of(keystorePath);\n+      final AtomicInteger counterSuffix = new AtomicInteger(0);\n+      final List<SafeFuture<TransactionReceipt>> futures;\n+      try {\n+        futures =\n+            validatorKeyPairs.stream()\n+                .map(\n+                    keyPair -> {\n+                      final String yamlFormattedString = getYamlFormattedString(keyPair);\n+                      if (encryptKeys) {\n+                        generateKeystores(\n+                            keyPair, keyStoreOutputDirectory, counterSuffix.incrementAndGet());\n+                      } else if (printOnStandardOut) {\n+                        System.out.println(yamlFormattedString);\n+                      } else {\n+                        yamlStringBuilder\n+                            .append(yamlFormattedString)\n+                            .append(System.lineSeparator());\n+                      }\n+\n+                      return sendDeposit(\n+                          sender,\n+                          keyPair.getLeft(),\n+                          keyPair.getRight().getPublicKey(),\n+                          params.amount);\n+                    })\n+                .collect(Collectors.toList());\n \n-      try (keyWriter) {\n-        for (int i = 0; i < validatorCount; i++) {\n-          final BLSKeyPair validatorKey = BLSKeyPair.random();\n-          final BLSKeyPair withdrawalKey = BLSKeyPair.random();\n-\n-          keyWriter.println(\n-              String.format(\n-                  \"- {privkey: '%s', pubkey: '%s', withdrawalPrivkey: '%s', withdrawalPubkey: '%s'}\",\n-                  validatorKey.getSecretKey().getSecretKey().toBytes(),\n-                  validatorKey.getPublicKey().toBytesCompressed(),\n-                  withdrawalKey.getSecretKey().getSecretKey().toBytes(),\n-                  withdrawalKey.getPublicKey().toBytesCompressed()));\n-          futures.add(\n-              sendDeposit(sender, validatorKey, withdrawalKey.getPublicKey(), params.amount));\n+      } finally {\n+        if (!encryptKeys && !printOnStandardOut) {\n+          // write keys yaml to file\n+          Files.writeString(Path.of(outputFile), yamlStringBuilder.toString());\n         }\n       }\n-      SafeFuture.allOf(futures.toArray(SafeFuture[]::new)).get(2, TimeUnit.MINUTES);\n+\n+      waitForTransactionReceipts(futures);\n     } catch (final Throwable t) {\n       STDOUT.log(\n           Level.FATAL,\n           \"Failed to send deposit transaction: \" + t.getClass() + \": \" + t.getMessage());\n-      System.exit(1); // Web3J creates a non-daemon thread we can't shut down. :(\n+      exit(1);\n     }\n-    System.exit(0); // Web3J creates a non-daemon thread we can't shut down. :(\n+    exit(0);\n+  }\n+\n+  @VisibleForTesting\n+  void waitForTransactionReceipts(final List<SafeFuture<TransactionReceipt>> futures)\n+      throws InterruptedException, ExecutionException, TimeoutException {\n+    SafeFuture.allOf(futures.toArray(SafeFuture[]::new)).get(2, TimeUnit.MINUTES);\n+  }\n+\n+  @VisibleForTesting\n+  void exit(final int status) {\n+    System.exit(status); // Web3J creates a non-daemon thread we can't shut down. :(\n+  }\n+\n+  private String getYamlFormattedString(final Pair<BLSKeyPair, BLSKeyPair> keyPair) {\n+    return String.format(\n+        \"- {privkey: '%s', pubkey: '%s', withdrawalPrivkey: '%s', withdrawalPubkey: '%s'}\",\n+        keyPair.getLeft().getSecretKey().getSecretKey().toBytes(),\n+        keyPair.getLeft().getPublicKey().toBytesCompressed(),\n+        keyPair.getRight().getSecretKey().getSecretKey().toBytes(),\n+        keyPair.getRight().getPublicKey().toBytesCompressed());\n+  }\n+\n+  private void generateKeystores(\n+      final Pair<BLSKeyPair, BLSKeyPair> keyPair,\n+      final Path keyStoreOutputDirectory,\n+      final int counter) {\n+    generateKeystore(keyPair.getLeft(), keyStoreOutputDirectory, \"validator\", counter);\n+    generateKeystore(keyPair.getRight(), keyStoreOutputDirectory, \"withdrawal\", counter);\n+  }\n+\n+  private void generateKeystore(\n+      final BLSKeyPair key, final Path outputDir, final String prefix, final int counter) {\n+    try {\n+      final KdfParam kdfParam = new SCryptParam(32, Bytes32.random());\n+      final Cipher cipher = new Cipher(CipherFunction.AES_128_CTR, Bytes.random(16));\n+      final String randomPassword = generateRandomHexToken();\n+      final KeyStoreData keyStoreData =\n+          KeyStore.encrypt(\n+              key.getSecretKey().getSecretKey().toBytes(),\n+              generateRandomHexToken(),\n+              \"\",\n+              kdfParam,\n+              cipher);\n+\n+      // create sub directory\n+      final Path keystoreDirectory =\n+          Files.createDirectories(outputDir.resolve(\"validator_\" + counter));\n+\n+      // save keystore\n+      KeyStoreLoader.saveToFile(\n+          keystoreDirectory.resolve(prefix + \"_keystore_\" + counter + \".json\"), keyStoreData);\n+\n+      // save password\n+      Files.writeString(\n+          keystoreDirectory.resolve(prefix + \"_password_\" + counter + \".txt\"), randomPassword);\n+    } catch (final IOException e) {\n+      throw new UncheckedIOException(e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0"}, "originalPosition": 215}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTU1OTk2Mw==", "bodyText": "The methods has been extracted to a new class and they will be logging appropriate logging statements before erroring out.", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r389559963", "createdAt": "2020-03-09T09:59:38Z", "author": {"login": "usmansaleem"}, "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "diffHunk": "@@ -81,44 +99,144 @@ public void generate(\n           int validatorCount,\n       @Option(\n               names = {\"--output-file\", \"-o\"},\n+              paramLabel = \"<FILE>\",\n               description =\n-                  \"File to write validator keys to. Keys are printed to std out if not specified\")\n-          String outputFile) {\n+                  \"File to write unencrypted validator keys to. Keys are printed to std out if not specified\")\n+          String outputFile,\n+      @Option(\n+              names = {\"--encrypt-keys\", \"-e\"},\n+              defaultValue = \"false\",\n+              paramLabel = \"<TRUE|FALSE>\",\n+              description = \"Encrypt validator keys. (Default: false)\",\n+              arity = \"1\")\n+          boolean encryptKeys,\n+      @Option(\n+              names = {\"--keystore-output-dir\", \"-k\"},\n+              paramLabel = \"<PATH>\",\n+              description =\n+                  \"Encrypted keystore output directory. Use current directory if not specified\")\n+          String keystorePath) {\n+\n     try (params) {\n+      // generate BLS validator key and withdrawal key\n+      final List<Pair<BLSKeyPair, BLSKeyPair>> validatorKeyPairs =\n+          IntStream.range(0, validatorCount)\n+              .mapToObj(value -> Pair.of(BLSKeyPair.random(), BLSKeyPair.random()))\n+              .collect(Collectors.toList());\n+\n       final DepositTransactionSender sender = params.createTransactionSender();\n-      final List<SafeFuture<TransactionReceipt>> futures = new ArrayList<>();\n \n-      final PrintStream keyWriter;\n-      if (outputFile == null || outputFile.isBlank()) {\n-        keyWriter = System.out;\n-      } else {\n-        keyWriter = new PrintStream(new FileOutputStream(outputFile), true, StandardCharsets.UTF_8);\n-      }\n+      final StringBuilder yamlStringBuilder = new StringBuilder();\n+      final boolean printOnStandardOut = outputFile == null || outputFile.isBlank();\n+      final Path keyStoreOutputDirectory =\n+          keystorePath == null || keystorePath.isBlank() ? Path.of(\".\") : Path.of(keystorePath);\n+      final AtomicInteger counterSuffix = new AtomicInteger(0);\n+      final List<SafeFuture<TransactionReceipt>> futures;\n+      try {\n+        futures =\n+            validatorKeyPairs.stream()\n+                .map(\n+                    keyPair -> {\n+                      final String yamlFormattedString = getYamlFormattedString(keyPair);\n+                      if (encryptKeys) {\n+                        generateKeystores(\n+                            keyPair, keyStoreOutputDirectory, counterSuffix.incrementAndGet());\n+                      } else if (printOnStandardOut) {\n+                        System.out.println(yamlFormattedString);\n+                      } else {\n+                        yamlStringBuilder\n+                            .append(yamlFormattedString)\n+                            .append(System.lineSeparator());\n+                      }\n+\n+                      return sendDeposit(\n+                          sender,\n+                          keyPair.getLeft(),\n+                          keyPair.getRight().getPublicKey(),\n+                          params.amount);\n+                    })\n+                .collect(Collectors.toList());\n \n-      try (keyWriter) {\n-        for (int i = 0; i < validatorCount; i++) {\n-          final BLSKeyPair validatorKey = BLSKeyPair.random();\n-          final BLSKeyPair withdrawalKey = BLSKeyPair.random();\n-\n-          keyWriter.println(\n-              String.format(\n-                  \"- {privkey: '%s', pubkey: '%s', withdrawalPrivkey: '%s', withdrawalPubkey: '%s'}\",\n-                  validatorKey.getSecretKey().getSecretKey().toBytes(),\n-                  validatorKey.getPublicKey().toBytesCompressed(),\n-                  withdrawalKey.getSecretKey().getSecretKey().toBytes(),\n-                  withdrawalKey.getPublicKey().toBytesCompressed()));\n-          futures.add(\n-              sendDeposit(sender, validatorKey, withdrawalKey.getPublicKey(), params.amount));\n+      } finally {\n+        if (!encryptKeys && !printOnStandardOut) {\n+          // write keys yaml to file\n+          Files.writeString(Path.of(outputFile), yamlStringBuilder.toString());\n         }\n       }\n-      SafeFuture.allOf(futures.toArray(SafeFuture[]::new)).get(2, TimeUnit.MINUTES);\n+\n+      waitForTransactionReceipts(futures);\n     } catch (final Throwable t) {\n       STDOUT.log(\n           Level.FATAL,\n           \"Failed to send deposit transaction: \" + t.getClass() + \": \" + t.getMessage());\n-      System.exit(1); // Web3J creates a non-daemon thread we can't shut down. :(\n+      exit(1);\n     }\n-    System.exit(0); // Web3J creates a non-daemon thread we can't shut down. :(\n+    exit(0);\n+  }\n+\n+  @VisibleForTesting\n+  void waitForTransactionReceipts(final List<SafeFuture<TransactionReceipt>> futures)\n+      throws InterruptedException, ExecutionException, TimeoutException {\n+    SafeFuture.allOf(futures.toArray(SafeFuture[]::new)).get(2, TimeUnit.MINUTES);\n+  }\n+\n+  @VisibleForTesting\n+  void exit(final int status) {\n+    System.exit(status); // Web3J creates a non-daemon thread we can't shut down. :(\n+  }\n+\n+  private String getYamlFormattedString(final Pair<BLSKeyPair, BLSKeyPair> keyPair) {\n+    return String.format(\n+        \"- {privkey: '%s', pubkey: '%s', withdrawalPrivkey: '%s', withdrawalPubkey: '%s'}\",\n+        keyPair.getLeft().getSecretKey().getSecretKey().toBytes(),\n+        keyPair.getLeft().getPublicKey().toBytesCompressed(),\n+        keyPair.getRight().getSecretKey().getSecretKey().toBytes(),\n+        keyPair.getRight().getPublicKey().toBytesCompressed());\n+  }\n+\n+  private void generateKeystores(\n+      final Pair<BLSKeyPair, BLSKeyPair> keyPair,\n+      final Path keyStoreOutputDirectory,\n+      final int counter) {\n+    generateKeystore(keyPair.getLeft(), keyStoreOutputDirectory, \"validator\", counter);\n+    generateKeystore(keyPair.getRight(), keyStoreOutputDirectory, \"withdrawal\", counter);\n+  }\n+\n+  private void generateKeystore(\n+      final BLSKeyPair key, final Path outputDir, final String prefix, final int counter) {\n+    try {\n+      final KdfParam kdfParam = new SCryptParam(32, Bytes32.random());\n+      final Cipher cipher = new Cipher(CipherFunction.AES_128_CTR, Bytes.random(16));\n+      final String randomPassword = generateRandomHexToken();\n+      final KeyStoreData keyStoreData =\n+          KeyStore.encrypt(\n+              key.getSecretKey().getSecretKey().toBytes(),\n+              generateRandomHexToken(),\n+              \"\",\n+              kdfParam,\n+              cipher);\n+\n+      // create sub directory\n+      final Path keystoreDirectory =\n+          Files.createDirectories(outputDir.resolve(\"validator_\" + counter));\n+\n+      // save keystore\n+      KeyStoreLoader.saveToFile(\n+          keystoreDirectory.resolve(prefix + \"_keystore_\" + counter + \".json\"), keyStoreData);\n+\n+      // save password\n+      Files.writeString(\n+          keystoreDirectory.resolve(prefix + \"_password_\" + counter + \".txt\"), randomPassword);\n+    } catch (final IOException e) {\n+      throw new UncheckedIOException(e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYyOTMxNg=="}, "originalCommit": {"oid": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0"}, "originalPosition": 215}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNzgxNzg2OnYy", "diffSide": "RIGHT", "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMzo0NzoyNVrOFyoIYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxMDowMDoxN1rOFzg32w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYzMDYyNg==", "bodyText": "nit: instead the generic Pair a small custom class would help with readability so that you do something like validatorKeyPair.getValidatorKey() instead of getLeft for example", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388630626", "createdAt": "2020-03-05T23:47:25Z", "author": {"login": "jframe"}, "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "diffHunk": "@@ -81,44 +99,144 @@ public void generate(\n           int validatorCount,\n       @Option(\n               names = {\"--output-file\", \"-o\"},\n+              paramLabel = \"<FILE>\",\n               description =\n-                  \"File to write validator keys to. Keys are printed to std out if not specified\")\n-          String outputFile) {\n+                  \"File to write unencrypted validator keys to. Keys are printed to std out if not specified\")\n+          String outputFile,\n+      @Option(\n+              names = {\"--encrypt-keys\", \"-e\"},\n+              defaultValue = \"false\",\n+              paramLabel = \"<TRUE|FALSE>\",\n+              description = \"Encrypt validator keys. (Default: false)\",\n+              arity = \"1\")\n+          boolean encryptKeys,\n+      @Option(\n+              names = {\"--keystore-output-dir\", \"-k\"},\n+              paramLabel = \"<PATH>\",\n+              description =\n+                  \"Encrypted keystore output directory. Use current directory if not specified\")\n+          String keystorePath) {\n+\n     try (params) {\n+      // generate BLS validator key and withdrawal key\n+      final List<Pair<BLSKeyPair, BLSKeyPair>> validatorKeyPairs =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTU2MDI4Mw==", "bodyText": "Its not used anymore.", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r389560283", "createdAt": "2020-03-09T10:00:17Z", "author": {"login": "usmansaleem"}, "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "diffHunk": "@@ -81,44 +99,144 @@ public void generate(\n           int validatorCount,\n       @Option(\n               names = {\"--output-file\", \"-o\"},\n+              paramLabel = \"<FILE>\",\n               description =\n-                  \"File to write validator keys to. Keys are printed to std out if not specified\")\n-          String outputFile) {\n+                  \"File to write unencrypted validator keys to. Keys are printed to std out if not specified\")\n+          String outputFile,\n+      @Option(\n+              names = {\"--encrypt-keys\", \"-e\"},\n+              defaultValue = \"false\",\n+              paramLabel = \"<TRUE|FALSE>\",\n+              description = \"Encrypt validator keys. (Default: false)\",\n+              arity = \"1\")\n+          boolean encryptKeys,\n+      @Option(\n+              names = {\"--keystore-output-dir\", \"-k\"},\n+              paramLabel = \"<PATH>\",\n+              description =\n+                  \"Encrypted keystore output directory. Use current directory if not specified\")\n+          String keystorePath) {\n+\n     try (params) {\n+      // generate BLS validator key and withdrawal key\n+      final List<Pair<BLSKeyPair, BLSKeyPair>> validatorKeyPairs =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYzMDYyNg=="}, "originalCommit": {"oid": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNzgyMDM1OnYy", "diffSide": "RIGHT", "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMzo0ODo0MVrOFyoJzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMzo0ODo0MVrOFyoJzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYzMDk5MA==", "bodyText": "nit: transactionReceiptFutures?", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388630990", "createdAt": "2020-03-05T23:48:41Z", "author": {"login": "jframe"}, "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "diffHunk": "@@ -81,44 +99,144 @@ public void generate(\n           int validatorCount,\n       @Option(\n               names = {\"--output-file\", \"-o\"},\n+              paramLabel = \"<FILE>\",\n               description =\n-                  \"File to write validator keys to. Keys are printed to std out if not specified\")\n-          String outputFile) {\n+                  \"File to write unencrypted validator keys to. Keys are printed to std out if not specified\")\n+          String outputFile,\n+      @Option(\n+              names = {\"--encrypt-keys\", \"-e\"},\n+              defaultValue = \"false\",\n+              paramLabel = \"<TRUE|FALSE>\",\n+              description = \"Encrypt validator keys. (Default: false)\",\n+              arity = \"1\")\n+          boolean encryptKeys,\n+      @Option(\n+              names = {\"--keystore-output-dir\", \"-k\"},\n+              paramLabel = \"<PATH>\",\n+              description =\n+                  \"Encrypted keystore output directory. Use current directory if not specified\")\n+          String keystorePath) {\n+\n     try (params) {\n+      // generate BLS validator key and withdrawal key\n+      final List<Pair<BLSKeyPair, BLSKeyPair>> validatorKeyPairs =\n+          IntStream.range(0, validatorCount)\n+              .mapToObj(value -> Pair.of(BLSKeyPair.random(), BLSKeyPair.random()))\n+              .collect(Collectors.toList());\n+\n       final DepositTransactionSender sender = params.createTransactionSender();\n-      final List<SafeFuture<TransactionReceipt>> futures = new ArrayList<>();\n \n-      final PrintStream keyWriter;\n-      if (outputFile == null || outputFile.isBlank()) {\n-        keyWriter = System.out;\n-      } else {\n-        keyWriter = new PrintStream(new FileOutputStream(outputFile), true, StandardCharsets.UTF_8);\n-      }\n+      final StringBuilder yamlStringBuilder = new StringBuilder();\n+      final boolean printOnStandardOut = outputFile == null || outputFile.isBlank();\n+      final Path keyStoreOutputDirectory =\n+          keystorePath == null || keystorePath.isBlank() ? Path.of(\".\") : Path.of(keystorePath);\n+      final AtomicInteger counterSuffix = new AtomicInteger(0);\n+      final List<SafeFuture<TransactionReceipt>> futures;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNzgyOTA5OnYy", "diffSide": "RIGHT", "path": "artemis/src/test/java/tech/pegasys/artemis/DepositCommandTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMzo1MzowOFrOFyoPJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxMDowMDo1NlrOFzg5MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYzMjM1OQ==", "bodyText": "rename to validatorKeyStoreFile and similarly rename password1File to validatoryPasswordFile", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388632359", "createdAt": "2020-03-05T23:53:08Z", "author": {"login": "jframe"}, "path": "artemis/src/test/java/tech/pegasys/artemis/DepositCommandTest.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+\n+import java.io.File;\n+import java.nio.file.Path;\n+import java.util.stream.IntStream;\n+import org.assertj.core.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import tech.pegasys.artemis.services.powchain.DepositTransactionSender;\n+\n+@ExtendWith(MockitoExtension.class)\n+class DepositCommandTest {\n+  private static final int VALIDATORS_COUNT = 2;\n+  @Mock private DepositCommand.CommonParams commonParams;\n+  @Mock private DepositTransactionSender depositTransactionSender;\n+  @Spy private DepositCommand depositCommand = new DepositCommand();\n+\n+  @Test\n+  void encryptedKeystoresAreCreated(@TempDir final Path tempDir) throws Exception {\n+    doReturn(depositTransactionSender).when(commonParams).createTransactionSender();\n+    doNothing().when(depositCommand).waitForTransactionReceipts(any());\n+    doNothing().when(depositCommand).exit(0);\n+\n+    depositCommand.generate(commonParams, VALIDATORS_COUNT, \"\", true, tempDir.toString());\n+\n+    // assert that sub directories exist\n+    final File[] subDirectories =\n+        IntStream.range(1, VALIDATORS_COUNT + 1)\n+            .mapToObj(i -> tempDir.resolve(\"validator_\" + i).toFile())\n+            .toArray(File[]::new);\n+    Assertions.assertThat(tempDir.toFile().listFiles()).containsExactlyInAnyOrder(subDirectories);\n+\n+    for (int i = 0; i < subDirectories.length; i++) {\n+      assertKeyStoreAndPasswordExist(subDirectories[i].toPath(), i + 1);\n+    }\n+  }\n+\n+  private void assertKeyStoreAndPasswordExist(final Path parentDir, final int suffix) {\n+    final Path keystore1File = parentDir.resolve(\"validator_keystore_\" + suffix + \".json\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTU2MDYyNQ==", "bodyText": "This unit test has been refactored.", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r389560625", "createdAt": "2020-03-09T10:00:56Z", "author": {"login": "usmansaleem"}, "path": "artemis/src/test/java/tech/pegasys/artemis/DepositCommandTest.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+\n+import java.io.File;\n+import java.nio.file.Path;\n+import java.util.stream.IntStream;\n+import org.assertj.core.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import tech.pegasys.artemis.services.powchain.DepositTransactionSender;\n+\n+@ExtendWith(MockitoExtension.class)\n+class DepositCommandTest {\n+  private static final int VALIDATORS_COUNT = 2;\n+  @Mock private DepositCommand.CommonParams commonParams;\n+  @Mock private DepositTransactionSender depositTransactionSender;\n+  @Spy private DepositCommand depositCommand = new DepositCommand();\n+\n+  @Test\n+  void encryptedKeystoresAreCreated(@TempDir final Path tempDir) throws Exception {\n+    doReturn(depositTransactionSender).when(commonParams).createTransactionSender();\n+    doNothing().when(depositCommand).waitForTransactionReceipts(any());\n+    doNothing().when(depositCommand).exit(0);\n+\n+    depositCommand.generate(commonParams, VALIDATORS_COUNT, \"\", true, tempDir.toString());\n+\n+    // assert that sub directories exist\n+    final File[] subDirectories =\n+        IntStream.range(1, VALIDATORS_COUNT + 1)\n+            .mapToObj(i -> tempDir.resolve(\"validator_\" + i).toFile())\n+            .toArray(File[]::new);\n+    Assertions.assertThat(tempDir.toFile().listFiles()).containsExactlyInAnyOrder(subDirectories);\n+\n+    for (int i = 0; i < subDirectories.length; i++) {\n+      assertKeyStoreAndPasswordExist(subDirectories[i].toPath(), i + 1);\n+    }\n+  }\n+\n+  private void assertKeyStoreAndPasswordExist(final Path parentDir, final int suffix) {\n+    final Path keystore1File = parentDir.resolve(\"validator_keystore_\" + suffix + \".json\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYzMjM1OQ=="}, "originalCommit": {"oid": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNzgzMTgxOnYy", "diffSide": "RIGHT", "path": "artemis/src/test/java/tech/pegasys/artemis/DepositCommandTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQyMzo1NDoyNlrOFyoQvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxMDowMToxNVrOFzg51w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYzMjc2Nw==", "bodyText": "rename withdrawalKeyStoreFile and similarly rename password2File to withdrawalPasswordFile", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388632767", "createdAt": "2020-03-05T23:54:26Z", "author": {"login": "jframe"}, "path": "artemis/src/test/java/tech/pegasys/artemis/DepositCommandTest.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+\n+import java.io.File;\n+import java.nio.file.Path;\n+import java.util.stream.IntStream;\n+import org.assertj.core.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import tech.pegasys.artemis.services.powchain.DepositTransactionSender;\n+\n+@ExtendWith(MockitoExtension.class)\n+class DepositCommandTest {\n+  private static final int VALIDATORS_COUNT = 2;\n+  @Mock private DepositCommand.CommonParams commonParams;\n+  @Mock private DepositTransactionSender depositTransactionSender;\n+  @Spy private DepositCommand depositCommand = new DepositCommand();\n+\n+  @Test\n+  void encryptedKeystoresAreCreated(@TempDir final Path tempDir) throws Exception {\n+    doReturn(depositTransactionSender).when(commonParams).createTransactionSender();\n+    doNothing().when(depositCommand).waitForTransactionReceipts(any());\n+    doNothing().when(depositCommand).exit(0);\n+\n+    depositCommand.generate(commonParams, VALIDATORS_COUNT, \"\", true, tempDir.toString());\n+\n+    // assert that sub directories exist\n+    final File[] subDirectories =\n+        IntStream.range(1, VALIDATORS_COUNT + 1)\n+            .mapToObj(i -> tempDir.resolve(\"validator_\" + i).toFile())\n+            .toArray(File[]::new);\n+    Assertions.assertThat(tempDir.toFile().listFiles()).containsExactlyInAnyOrder(subDirectories);\n+\n+    for (int i = 0; i < subDirectories.length; i++) {\n+      assertKeyStoreAndPasswordExist(subDirectories[i].toPath(), i + 1);\n+    }\n+  }\n+\n+  private void assertKeyStoreAndPasswordExist(final Path parentDir, final int suffix) {\n+    final Path keystore1File = parentDir.resolve(\"validator_keystore_\" + suffix + \".json\");\n+    final Path password1File = parentDir.resolve(\"validator_password_\" + suffix + \".txt\");\n+    final Path keystore2File = parentDir.resolve(\"withdrawal_keystore_\" + suffix + \".json\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTU2MDc5MQ==", "bodyText": "This unit test has been refactored.", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r389560791", "createdAt": "2020-03-09T10:01:15Z", "author": {"login": "usmansaleem"}, "path": "artemis/src/test/java/tech/pegasys/artemis/DepositCommandTest.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+\n+import java.io.File;\n+import java.nio.file.Path;\n+import java.util.stream.IntStream;\n+import org.assertj.core.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import tech.pegasys.artemis.services.powchain.DepositTransactionSender;\n+\n+@ExtendWith(MockitoExtension.class)\n+class DepositCommandTest {\n+  private static final int VALIDATORS_COUNT = 2;\n+  @Mock private DepositCommand.CommonParams commonParams;\n+  @Mock private DepositTransactionSender depositTransactionSender;\n+  @Spy private DepositCommand depositCommand = new DepositCommand();\n+\n+  @Test\n+  void encryptedKeystoresAreCreated(@TempDir final Path tempDir) throws Exception {\n+    doReturn(depositTransactionSender).when(commonParams).createTransactionSender();\n+    doNothing().when(depositCommand).waitForTransactionReceipts(any());\n+    doNothing().when(depositCommand).exit(0);\n+\n+    depositCommand.generate(commonParams, VALIDATORS_COUNT, \"\", true, tempDir.toString());\n+\n+    // assert that sub directories exist\n+    final File[] subDirectories =\n+        IntStream.range(1, VALIDATORS_COUNT + 1)\n+            .mapToObj(i -> tempDir.resolve(\"validator_\" + i).toFile())\n+            .toArray(File[]::new);\n+    Assertions.assertThat(tempDir.toFile().listFiles()).containsExactlyInAnyOrder(subDirectories);\n+\n+    for (int i = 0; i < subDirectories.length; i++) {\n+      assertKeyStoreAndPasswordExist(subDirectories[i].toPath(), i + 1);\n+    }\n+  }\n+\n+  private void assertKeyStoreAndPasswordExist(final Path parentDir, final int suffix) {\n+    final Path keystore1File = parentDir.resolve(\"validator_keystore_\" + suffix + \".json\");\n+    final Path password1File = parentDir.resolve(\"validator_password_\" + suffix + \".txt\");\n+    final Path keystore2File = parentDir.resolve(\"withdrawal_keystore_\" + suffix + \".json\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYzMjc2Nw=="}, "originalCommit": {"oid": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNzg2NDM1OnYy", "diffSide": "RIGHT", "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwMDoxMToyNlrOFyokCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQwOTo1MDo0OVrOFzgkIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYzNzcwNQ==", "bodyText": "False doesn't seem like the right default here.  Writing unencrypted keys to disk is a really bad idea.", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388637705", "createdAt": "2020-03-06T00:11:26Z", "author": {"login": "ajsutton"}, "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "diffHunk": "@@ -81,44 +99,144 @@ public void generate(\n           int validatorCount,\n       @Option(\n               names = {\"--output-file\", \"-o\"},\n+              paramLabel = \"<FILE>\",\n               description =\n-                  \"File to write validator keys to. Keys are printed to std out if not specified\")\n-          String outputFile) {\n+                  \"File to write unencrypted validator keys to. Keys are printed to std out if not specified\")\n+          String outputFile,\n+      @Option(\n+              names = {\"--encrypt-keys\", \"-e\"},\n+              defaultValue = \"false\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTU1NTIzMg==", "bodyText": "--encrypt-keys defaults to true now.", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r389555232", "createdAt": "2020-03-09T09:50:49Z", "author": {"login": "usmansaleem"}, "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "diffHunk": "@@ -81,44 +99,144 @@ public void generate(\n           int validatorCount,\n       @Option(\n               names = {\"--output-file\", \"-o\"},\n+              paramLabel = \"<FILE>\",\n               description =\n-                  \"File to write validator keys to. Keys are printed to std out if not specified\")\n-          String outputFile) {\n+                  \"File to write unencrypted validator keys to. Keys are printed to std out if not specified\")\n+          String outputFile,\n+      @Option(\n+              names = {\"--encrypt-keys\", \"-e\"},\n+              defaultValue = \"false\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYzNzcwNQ=="}, "originalCommit": {"oid": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNzg2NjkyOnYy", "diffSide": "RIGHT", "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwMDoxMjo1NVrOFyol0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQwOTo1MzoxMFrOFzgpEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYzODE2MA==", "bodyText": "How does this relate to --output-file?  Seems kind of confusing to have two separate options to specify where to output things.  @jakehaugen any ideas on the right CLI options for this?", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388638160", "createdAt": "2020-03-06T00:12:55Z", "author": {"login": "ajsutton"}, "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "diffHunk": "@@ -81,44 +99,144 @@ public void generate(\n           int validatorCount,\n       @Option(\n               names = {\"--output-file\", \"-o\"},\n+              paramLabel = \"<FILE>\",\n               description =\n-                  \"File to write validator keys to. Keys are printed to std out if not specified\")\n-          String outputFile) {\n+                  \"File to write unencrypted validator keys to. Keys are printed to std out if not specified\")\n+          String outputFile,\n+      @Option(\n+              names = {\"--encrypt-keys\", \"-e\"},\n+              defaultValue = \"false\",\n+              paramLabel = \"<TRUE|FALSE>\",\n+              description = \"Encrypt validator keys. (Default: false)\",\n+              arity = \"1\")\n+          boolean encryptKeys,\n+      @Option(\n+              names = {\"--keystore-output-dir\", \"-k\"},\n+              paramLabel = \"<PATH>\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTU1NjQ5Nw==", "bodyText": "--keystore-output-dir is not used anymore. Instead I am now using --output-path to be treated either as directory or file depending upon we are using encrypted mode or unencrypted mode.", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r389556497", "createdAt": "2020-03-09T09:53:10Z", "author": {"login": "usmansaleem"}, "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "diffHunk": "@@ -81,44 +99,144 @@ public void generate(\n           int validatorCount,\n       @Option(\n               names = {\"--output-file\", \"-o\"},\n+              paramLabel = \"<FILE>\",\n               description =\n-                  \"File to write validator keys to. Keys are printed to std out if not specified\")\n-          String outputFile) {\n+                  \"File to write unencrypted validator keys to. Keys are printed to std out if not specified\")\n+          String outputFile,\n+      @Option(\n+              names = {\"--encrypt-keys\", \"-e\"},\n+              defaultValue = \"false\",\n+              paramLabel = \"<TRUE|FALSE>\",\n+              description = \"Encrypt validator keys. (Default: false)\",\n+              arity = \"1\")\n+          boolean encryptKeys,\n+      @Option(\n+              names = {\"--keystore-output-dir\", \"-k\"},\n+              paramLabel = \"<PATH>\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYzODE2MA=="}, "originalCommit": {"oid": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNzg3MTM1OnYy", "diffSide": "RIGHT", "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwMDoxNToyNFrOFyoomw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwMjowMzo1M1rOFyq9eA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYzODg3NQ==", "bodyText": "Rather than overriding this method in tests, it would be better to pass in a Consumer<Integer> shutdownFunction to the constructor (ie prefer delegation over inheritance).  You can pass a mock in tests and System::exit in production.\nYou will likely need two constructors for DepositCommand - a noarg one that passes System::exit and one that accepts the consumer that tests can use.", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388638875", "createdAt": "2020-03-06T00:15:24Z", "author": {"login": "ajsutton"}, "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "diffHunk": "@@ -81,44 +99,144 @@ public void generate(\n           int validatorCount,\n       @Option(\n               names = {\"--output-file\", \"-o\"},\n+              paramLabel = \"<FILE>\",\n               description =\n-                  \"File to write validator keys to. Keys are printed to std out if not specified\")\n-          String outputFile) {\n+                  \"File to write unencrypted validator keys to. Keys are printed to std out if not specified\")\n+          String outputFile,\n+      @Option(\n+              names = {\"--encrypt-keys\", \"-e\"},\n+              defaultValue = \"false\",\n+              paramLabel = \"<TRUE|FALSE>\",\n+              description = \"Encrypt validator keys. (Default: false)\",\n+              arity = \"1\")\n+          boolean encryptKeys,\n+      @Option(\n+              names = {\"--keystore-output-dir\", \"-k\"},\n+              paramLabel = \"<PATH>\",\n+              description =\n+                  \"Encrypted keystore output directory. Use current directory if not specified\")\n+          String keystorePath) {\n+\n     try (params) {\n+      // generate BLS validator key and withdrawal key\n+      final List<Pair<BLSKeyPair, BLSKeyPair>> validatorKeyPairs =\n+          IntStream.range(0, validatorCount)\n+              .mapToObj(value -> Pair.of(BLSKeyPair.random(), BLSKeyPair.random()))\n+              .collect(Collectors.toList());\n+\n       final DepositTransactionSender sender = params.createTransactionSender();\n-      final List<SafeFuture<TransactionReceipt>> futures = new ArrayList<>();\n \n-      final PrintStream keyWriter;\n-      if (outputFile == null || outputFile.isBlank()) {\n-        keyWriter = System.out;\n-      } else {\n-        keyWriter = new PrintStream(new FileOutputStream(outputFile), true, StandardCharsets.UTF_8);\n-      }\n+      final StringBuilder yamlStringBuilder = new StringBuilder();\n+      final boolean printOnStandardOut = outputFile == null || outputFile.isBlank();\n+      final Path keyStoreOutputDirectory =\n+          keystorePath == null || keystorePath.isBlank() ? Path.of(\".\") : Path.of(keystorePath);\n+      final AtomicInteger counterSuffix = new AtomicInteger(0);\n+      final List<SafeFuture<TransactionReceipt>> futures;\n+      try {\n+        futures =\n+            validatorKeyPairs.stream()\n+                .map(\n+                    keyPair -> {\n+                      final String yamlFormattedString = getYamlFormattedString(keyPair);\n+                      if (encryptKeys) {\n+                        generateKeystores(\n+                            keyPair, keyStoreOutputDirectory, counterSuffix.incrementAndGet());\n+                      } else if (printOnStandardOut) {\n+                        System.out.println(yamlFormattedString);\n+                      } else {\n+                        yamlStringBuilder\n+                            .append(yamlFormattedString)\n+                            .append(System.lineSeparator());\n+                      }\n+\n+                      return sendDeposit(\n+                          sender,\n+                          keyPair.getLeft(),\n+                          keyPair.getRight().getPublicKey(),\n+                          params.amount);\n+                    })\n+                .collect(Collectors.toList());\n \n-      try (keyWriter) {\n-        for (int i = 0; i < validatorCount; i++) {\n-          final BLSKeyPair validatorKey = BLSKeyPair.random();\n-          final BLSKeyPair withdrawalKey = BLSKeyPair.random();\n-\n-          keyWriter.println(\n-              String.format(\n-                  \"- {privkey: '%s', pubkey: '%s', withdrawalPrivkey: '%s', withdrawalPubkey: '%s'}\",\n-                  validatorKey.getSecretKey().getSecretKey().toBytes(),\n-                  validatorKey.getPublicKey().toBytesCompressed(),\n-                  withdrawalKey.getSecretKey().getSecretKey().toBytes(),\n-                  withdrawalKey.getPublicKey().toBytesCompressed()));\n-          futures.add(\n-              sendDeposit(sender, validatorKey, withdrawalKey.getPublicKey(), params.amount));\n+      } finally {\n+        if (!encryptKeys && !printOnStandardOut) {\n+          // write keys yaml to file\n+          Files.writeString(Path.of(outputFile), yamlStringBuilder.toString());\n         }\n       }\n-      SafeFuture.allOf(futures.toArray(SafeFuture[]::new)).get(2, TimeUnit.MINUTES);\n+\n+      waitForTransactionReceipts(futures);\n     } catch (final Throwable t) {\n       STDOUT.log(\n           Level.FATAL,\n           \"Failed to send deposit transaction: \" + t.getClass() + \": \" + t.getMessage());\n-      System.exit(1); // Web3J creates a non-daemon thread we can't shut down. :(\n+      exit(1);\n     }\n-    System.exit(0); // Web3J creates a non-daemon thread we can't shut down. :(\n+    exit(0);\n+  }\n+\n+  @VisibleForTesting\n+  void waitForTransactionReceipts(final List<SafeFuture<TransactionReceipt>> futures)\n+      throws InterruptedException, ExecutionException, TimeoutException {\n+    SafeFuture.allOf(futures.toArray(SafeFuture[]::new)).get(2, TimeUnit.MINUTES);\n+  }\n+\n+  @VisibleForTesting\n+  void exit(final int status) {\n+    System.exit(status); // Web3J creates a non-daemon thread we can't shut down. :(\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0"}, "originalPosition": 170}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY3Njk4NA==", "bodyText": "Implemented functional consumer interface.", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388676984", "createdAt": "2020-03-06T02:03:53Z", "author": {"login": "usmansaleem"}, "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "diffHunk": "@@ -81,44 +99,144 @@ public void generate(\n           int validatorCount,\n       @Option(\n               names = {\"--output-file\", \"-o\"},\n+              paramLabel = \"<FILE>\",\n               description =\n-                  \"File to write validator keys to. Keys are printed to std out if not specified\")\n-          String outputFile) {\n+                  \"File to write unencrypted validator keys to. Keys are printed to std out if not specified\")\n+          String outputFile,\n+      @Option(\n+              names = {\"--encrypt-keys\", \"-e\"},\n+              defaultValue = \"false\",\n+              paramLabel = \"<TRUE|FALSE>\",\n+              description = \"Encrypt validator keys. (Default: false)\",\n+              arity = \"1\")\n+          boolean encryptKeys,\n+      @Option(\n+              names = {\"--keystore-output-dir\", \"-k\"},\n+              paramLabel = \"<PATH>\",\n+              description =\n+                  \"Encrypted keystore output directory. Use current directory if not specified\")\n+          String keystorePath) {\n+\n     try (params) {\n+      // generate BLS validator key and withdrawal key\n+      final List<Pair<BLSKeyPair, BLSKeyPair>> validatorKeyPairs =\n+          IntStream.range(0, validatorCount)\n+              .mapToObj(value -> Pair.of(BLSKeyPair.random(), BLSKeyPair.random()))\n+              .collect(Collectors.toList());\n+\n       final DepositTransactionSender sender = params.createTransactionSender();\n-      final List<SafeFuture<TransactionReceipt>> futures = new ArrayList<>();\n \n-      final PrintStream keyWriter;\n-      if (outputFile == null || outputFile.isBlank()) {\n-        keyWriter = System.out;\n-      } else {\n-        keyWriter = new PrintStream(new FileOutputStream(outputFile), true, StandardCharsets.UTF_8);\n-      }\n+      final StringBuilder yamlStringBuilder = new StringBuilder();\n+      final boolean printOnStandardOut = outputFile == null || outputFile.isBlank();\n+      final Path keyStoreOutputDirectory =\n+          keystorePath == null || keystorePath.isBlank() ? Path.of(\".\") : Path.of(keystorePath);\n+      final AtomicInteger counterSuffix = new AtomicInteger(0);\n+      final List<SafeFuture<TransactionReceipt>> futures;\n+      try {\n+        futures =\n+            validatorKeyPairs.stream()\n+                .map(\n+                    keyPair -> {\n+                      final String yamlFormattedString = getYamlFormattedString(keyPair);\n+                      if (encryptKeys) {\n+                        generateKeystores(\n+                            keyPair, keyStoreOutputDirectory, counterSuffix.incrementAndGet());\n+                      } else if (printOnStandardOut) {\n+                        System.out.println(yamlFormattedString);\n+                      } else {\n+                        yamlStringBuilder\n+                            .append(yamlFormattedString)\n+                            .append(System.lineSeparator());\n+                      }\n+\n+                      return sendDeposit(\n+                          sender,\n+                          keyPair.getLeft(),\n+                          keyPair.getRight().getPublicKey(),\n+                          params.amount);\n+                    })\n+                .collect(Collectors.toList());\n \n-      try (keyWriter) {\n-        for (int i = 0; i < validatorCount; i++) {\n-          final BLSKeyPair validatorKey = BLSKeyPair.random();\n-          final BLSKeyPair withdrawalKey = BLSKeyPair.random();\n-\n-          keyWriter.println(\n-              String.format(\n-                  \"- {privkey: '%s', pubkey: '%s', withdrawalPrivkey: '%s', withdrawalPubkey: '%s'}\",\n-                  validatorKey.getSecretKey().getSecretKey().toBytes(),\n-                  validatorKey.getPublicKey().toBytesCompressed(),\n-                  withdrawalKey.getSecretKey().getSecretKey().toBytes(),\n-                  withdrawalKey.getPublicKey().toBytesCompressed()));\n-          futures.add(\n-              sendDeposit(sender, validatorKey, withdrawalKey.getPublicKey(), params.amount));\n+      } finally {\n+        if (!encryptKeys && !printOnStandardOut) {\n+          // write keys yaml to file\n+          Files.writeString(Path.of(outputFile), yamlStringBuilder.toString());\n         }\n       }\n-      SafeFuture.allOf(futures.toArray(SafeFuture[]::new)).get(2, TimeUnit.MINUTES);\n+\n+      waitForTransactionReceipts(futures);\n     } catch (final Throwable t) {\n       STDOUT.log(\n           Level.FATAL,\n           \"Failed to send deposit transaction: \" + t.getClass() + \": \" + t.getMessage());\n-      System.exit(1); // Web3J creates a non-daemon thread we can't shut down. :(\n+      exit(1);\n     }\n-    System.exit(0); // Web3J creates a non-daemon thread we can't shut down. :(\n+    exit(0);\n+  }\n+\n+  @VisibleForTesting\n+  void waitForTransactionReceipts(final List<SafeFuture<TransactionReceipt>> futures)\n+      throws InterruptedException, ExecutionException, TimeoutException {\n+    SafeFuture.allOf(futures.toArray(SafeFuture[]::new)).get(2, TimeUnit.MINUTES);\n+  }\n+\n+  @VisibleForTesting\n+  void exit(final int status) {\n+    System.exit(status); // Web3J creates a non-daemon thread we can't shut down. :(\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYzODg3NQ=="}, "originalCommit": {"oid": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0"}, "originalPosition": 170}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNzg3NzQ5OnYy", "diffSide": "RIGHT", "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwMDoxODozNVrOFyosgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQwOTo1NDo1N1rOFzgspw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYzOTg3NQ==", "bodyText": "Two issues here:\n\nIt's vital that we write the keys to output before sending the deposit transaction.  Otherwise if we fail somewhere we've just burned a lot of ETH and lost the keys forever.\nSince the logic for writing keys has become more complex we should create a KeyWriter interface with 2 separate implementations - one that writes YAML to a PrintStream (used for all unencrypted output) and one that writes to a keystore for encrypted output.", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388639875", "createdAt": "2020-03-06T00:18:35Z", "author": {"login": "ajsutton"}, "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "diffHunk": "@@ -81,44 +99,144 @@ public void generate(\n           int validatorCount,\n       @Option(\n               names = {\"--output-file\", \"-o\"},\n+              paramLabel = \"<FILE>\",\n               description =\n-                  \"File to write validator keys to. Keys are printed to std out if not specified\")\n-          String outputFile) {\n+                  \"File to write unencrypted validator keys to. Keys are printed to std out if not specified\")\n+          String outputFile,\n+      @Option(\n+              names = {\"--encrypt-keys\", \"-e\"},\n+              defaultValue = \"false\",\n+              paramLabel = \"<TRUE|FALSE>\",\n+              description = \"Encrypt validator keys. (Default: false)\",\n+              arity = \"1\")\n+          boolean encryptKeys,\n+      @Option(\n+              names = {\"--keystore-output-dir\", \"-k\"},\n+              paramLabel = \"<PATH>\",\n+              description =\n+                  \"Encrypted keystore output directory. Use current directory if not specified\")\n+          String keystorePath) {\n+\n     try (params) {\n+      // generate BLS validator key and withdrawal key\n+      final List<Pair<BLSKeyPair, BLSKeyPair>> validatorKeyPairs =\n+          IntStream.range(0, validatorCount)\n+              .mapToObj(value -> Pair.of(BLSKeyPair.random(), BLSKeyPair.random()))\n+              .collect(Collectors.toList());\n+\n       final DepositTransactionSender sender = params.createTransactionSender();\n-      final List<SafeFuture<TransactionReceipt>> futures = new ArrayList<>();\n \n-      final PrintStream keyWriter;\n-      if (outputFile == null || outputFile.isBlank()) {\n-        keyWriter = System.out;\n-      } else {\n-        keyWriter = new PrintStream(new FileOutputStream(outputFile), true, StandardCharsets.UTF_8);\n-      }\n+      final StringBuilder yamlStringBuilder = new StringBuilder();\n+      final boolean printOnStandardOut = outputFile == null || outputFile.isBlank();\n+      final Path keyStoreOutputDirectory =\n+          keystorePath == null || keystorePath.isBlank() ? Path.of(\".\") : Path.of(keystorePath);\n+      final AtomicInteger counterSuffix = new AtomicInteger(0);\n+      final List<SafeFuture<TransactionReceipt>> futures;\n+      try {\n+        futures =\n+            validatorKeyPairs.stream()\n+                .map(\n+                    keyPair -> {\n+                      final String yamlFormattedString = getYamlFormattedString(keyPair);\n+                      if (encryptKeys) {\n+                        generateKeystores(\n+                            keyPair, keyStoreOutputDirectory, counterSuffix.incrementAndGet());\n+                      } else if (printOnStandardOut) {\n+                        System.out.println(yamlFormattedString);\n+                      } else {\n+                        yamlStringBuilder\n+                            .append(yamlFormattedString)\n+                            .append(System.lineSeparator());\n+                      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY2ODY4NA==", "bodyText": "Yes I hear you, thats why I wrote file in finally block that should have written keys up to sendTransaction fails. Using KeyWrite interface is better idea though.", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388668684", "createdAt": "2020-03-06T01:31:25Z", "author": {"login": "usmansaleem"}, "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "diffHunk": "@@ -81,44 +99,144 @@ public void generate(\n           int validatorCount,\n       @Option(\n               names = {\"--output-file\", \"-o\"},\n+              paramLabel = \"<FILE>\",\n               description =\n-                  \"File to write validator keys to. Keys are printed to std out if not specified\")\n-          String outputFile) {\n+                  \"File to write unencrypted validator keys to. Keys are printed to std out if not specified\")\n+          String outputFile,\n+      @Option(\n+              names = {\"--encrypt-keys\", \"-e\"},\n+              defaultValue = \"false\",\n+              paramLabel = \"<TRUE|FALSE>\",\n+              description = \"Encrypt validator keys. (Default: false)\",\n+              arity = \"1\")\n+          boolean encryptKeys,\n+      @Option(\n+              names = {\"--keystore-output-dir\", \"-k\"},\n+              paramLabel = \"<PATH>\",\n+              description =\n+                  \"Encrypted keystore output directory. Use current directory if not specified\")\n+          String keystorePath) {\n+\n     try (params) {\n+      // generate BLS validator key and withdrawal key\n+      final List<Pair<BLSKeyPair, BLSKeyPair>> validatorKeyPairs =\n+          IntStream.range(0, validatorCount)\n+              .mapToObj(value -> Pair.of(BLSKeyPair.random(), BLSKeyPair.random()))\n+              .collect(Collectors.toList());\n+\n       final DepositTransactionSender sender = params.createTransactionSender();\n-      final List<SafeFuture<TransactionReceipt>> futures = new ArrayList<>();\n \n-      final PrintStream keyWriter;\n-      if (outputFile == null || outputFile.isBlank()) {\n-        keyWriter = System.out;\n-      } else {\n-        keyWriter = new PrintStream(new FileOutputStream(outputFile), true, StandardCharsets.UTF_8);\n-      }\n+      final StringBuilder yamlStringBuilder = new StringBuilder();\n+      final boolean printOnStandardOut = outputFile == null || outputFile.isBlank();\n+      final Path keyStoreOutputDirectory =\n+          keystorePath == null || keystorePath.isBlank() ? Path.of(\".\") : Path.of(keystorePath);\n+      final AtomicInteger counterSuffix = new AtomicInteger(0);\n+      final List<SafeFuture<TransactionReceipt>> futures;\n+      try {\n+        futures =\n+            validatorKeyPairs.stream()\n+                .map(\n+                    keyPair -> {\n+                      final String yamlFormattedString = getYamlFormattedString(keyPair);\n+                      if (encryptKeys) {\n+                        generateKeystores(\n+                            keyPair, keyStoreOutputDirectory, counterSuffix.incrementAndGet());\n+                      } else if (printOnStandardOut) {\n+                        System.out.println(yamlFormattedString);\n+                      } else {\n+                        yamlStringBuilder\n+                            .append(yamlFormattedString)\n+                            .append(System.lineSeparator());\n+                      }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYzOTg3NQ=="}, "originalCommit": {"oid": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY2OTYyMA==", "bodyText": "A finally block does not guarantee it happens first.  If the process or computer crashed the key would never be written and the funds would be lost.", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388669620", "createdAt": "2020-03-06T01:34:39Z", "author": {"login": "ajsutton"}, "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "diffHunk": "@@ -81,44 +99,144 @@ public void generate(\n           int validatorCount,\n       @Option(\n               names = {\"--output-file\", \"-o\"},\n+              paramLabel = \"<FILE>\",\n               description =\n-                  \"File to write validator keys to. Keys are printed to std out if not specified\")\n-          String outputFile) {\n+                  \"File to write unencrypted validator keys to. Keys are printed to std out if not specified\")\n+          String outputFile,\n+      @Option(\n+              names = {\"--encrypt-keys\", \"-e\"},\n+              defaultValue = \"false\",\n+              paramLabel = \"<TRUE|FALSE>\",\n+              description = \"Encrypt validator keys. (Default: false)\",\n+              arity = \"1\")\n+          boolean encryptKeys,\n+      @Option(\n+              names = {\"--keystore-output-dir\", \"-k\"},\n+              paramLabel = \"<PATH>\",\n+              description =\n+                  \"Encrypted keystore output directory. Use current directory if not specified\")\n+          String keystorePath) {\n+\n     try (params) {\n+      // generate BLS validator key and withdrawal key\n+      final List<Pair<BLSKeyPair, BLSKeyPair>> validatorKeyPairs =\n+          IntStream.range(0, validatorCount)\n+              .mapToObj(value -> Pair.of(BLSKeyPair.random(), BLSKeyPair.random()))\n+              .collect(Collectors.toList());\n+\n       final DepositTransactionSender sender = params.createTransactionSender();\n-      final List<SafeFuture<TransactionReceipt>> futures = new ArrayList<>();\n \n-      final PrintStream keyWriter;\n-      if (outputFile == null || outputFile.isBlank()) {\n-        keyWriter = System.out;\n-      } else {\n-        keyWriter = new PrintStream(new FileOutputStream(outputFile), true, StandardCharsets.UTF_8);\n-      }\n+      final StringBuilder yamlStringBuilder = new StringBuilder();\n+      final boolean printOnStandardOut = outputFile == null || outputFile.isBlank();\n+      final Path keyStoreOutputDirectory =\n+          keystorePath == null || keystorePath.isBlank() ? Path.of(\".\") : Path.of(keystorePath);\n+      final AtomicInteger counterSuffix = new AtomicInteger(0);\n+      final List<SafeFuture<TransactionReceipt>> futures;\n+      try {\n+        futures =\n+            validatorKeyPairs.stream()\n+                .map(\n+                    keyPair -> {\n+                      final String yamlFormattedString = getYamlFormattedString(keyPair);\n+                      if (encryptKeys) {\n+                        generateKeystores(\n+                            keyPair, keyStoreOutputDirectory, counterSuffix.incrementAndGet());\n+                      } else if (printOnStandardOut) {\n+                        System.out.println(yamlFormattedString);\n+                      } else {\n+                        yamlStringBuilder\n+                            .append(yamlFormattedString)\n+                            .append(System.lineSeparator());\n+                      }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYzOTg3NQ=="}, "originalCommit": {"oid": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTU1NzA4Mg==", "bodyText": "We now have KeyWriter which is implemented by YamlKeysWriter and EncryptedKeyStoreWriter.", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r389557082", "createdAt": "2020-03-09T09:54:20Z", "author": {"login": "usmansaleem"}, "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "diffHunk": "@@ -81,44 +99,144 @@ public void generate(\n           int validatorCount,\n       @Option(\n               names = {\"--output-file\", \"-o\"},\n+              paramLabel = \"<FILE>\",\n               description =\n-                  \"File to write validator keys to. Keys are printed to std out if not specified\")\n-          String outputFile) {\n+                  \"File to write unencrypted validator keys to. Keys are printed to std out if not specified\")\n+          String outputFile,\n+      @Option(\n+              names = {\"--encrypt-keys\", \"-e\"},\n+              defaultValue = \"false\",\n+              paramLabel = \"<TRUE|FALSE>\",\n+              description = \"Encrypt validator keys. (Default: false)\",\n+              arity = \"1\")\n+          boolean encryptKeys,\n+      @Option(\n+              names = {\"--keystore-output-dir\", \"-k\"},\n+              paramLabel = \"<PATH>\",\n+              description =\n+                  \"Encrypted keystore output directory. Use current directory if not specified\")\n+          String keystorePath) {\n+\n     try (params) {\n+      // generate BLS validator key and withdrawal key\n+      final List<Pair<BLSKeyPair, BLSKeyPair>> validatorKeyPairs =\n+          IntStream.range(0, validatorCount)\n+              .mapToObj(value -> Pair.of(BLSKeyPair.random(), BLSKeyPair.random()))\n+              .collect(Collectors.toList());\n+\n       final DepositTransactionSender sender = params.createTransactionSender();\n-      final List<SafeFuture<TransactionReceipt>> futures = new ArrayList<>();\n \n-      final PrintStream keyWriter;\n-      if (outputFile == null || outputFile.isBlank()) {\n-        keyWriter = System.out;\n-      } else {\n-        keyWriter = new PrintStream(new FileOutputStream(outputFile), true, StandardCharsets.UTF_8);\n-      }\n+      final StringBuilder yamlStringBuilder = new StringBuilder();\n+      final boolean printOnStandardOut = outputFile == null || outputFile.isBlank();\n+      final Path keyStoreOutputDirectory =\n+          keystorePath == null || keystorePath.isBlank() ? Path.of(\".\") : Path.of(keystorePath);\n+      final AtomicInteger counterSuffix = new AtomicInteger(0);\n+      final List<SafeFuture<TransactionReceipt>> futures;\n+      try {\n+        futures =\n+            validatorKeyPairs.stream()\n+                .map(\n+                    keyPair -> {\n+                      final String yamlFormattedString = getYamlFormattedString(keyPair);\n+                      if (encryptKeys) {\n+                        generateKeystores(\n+                            keyPair, keyStoreOutputDirectory, counterSuffix.incrementAndGet());\n+                      } else if (printOnStandardOut) {\n+                        System.out.println(yamlFormattedString);\n+                      } else {\n+                        yamlStringBuilder\n+                            .append(yamlFormattedString)\n+                            .append(System.lineSeparator());\n+                      }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYzOTg3NQ=="}, "originalCommit": {"oid": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTU1NzQxNQ==", "bodyText": "The approach to write keys has been changed so that they get persisted first before sendTransaction is called.", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r389557415", "createdAt": "2020-03-09T09:54:57Z", "author": {"login": "usmansaleem"}, "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "diffHunk": "@@ -81,44 +99,144 @@ public void generate(\n           int validatorCount,\n       @Option(\n               names = {\"--output-file\", \"-o\"},\n+              paramLabel = \"<FILE>\",\n               description =\n-                  \"File to write validator keys to. Keys are printed to std out if not specified\")\n-          String outputFile) {\n+                  \"File to write unencrypted validator keys to. Keys are printed to std out if not specified\")\n+          String outputFile,\n+      @Option(\n+              names = {\"--encrypt-keys\", \"-e\"},\n+              defaultValue = \"false\",\n+              paramLabel = \"<TRUE|FALSE>\",\n+              description = \"Encrypt validator keys. (Default: false)\",\n+              arity = \"1\")\n+          boolean encryptKeys,\n+      @Option(\n+              names = {\"--keystore-output-dir\", \"-k\"},\n+              paramLabel = \"<PATH>\",\n+              description =\n+                  \"Encrypted keystore output directory. Use current directory if not specified\")\n+          String keystorePath) {\n+\n     try (params) {\n+      // generate BLS validator key and withdrawal key\n+      final List<Pair<BLSKeyPair, BLSKeyPair>> validatorKeyPairs =\n+          IntStream.range(0, validatorCount)\n+              .mapToObj(value -> Pair.of(BLSKeyPair.random(), BLSKeyPair.random()))\n+              .collect(Collectors.toList());\n+\n       final DepositTransactionSender sender = params.createTransactionSender();\n-      final List<SafeFuture<TransactionReceipt>> futures = new ArrayList<>();\n \n-      final PrintStream keyWriter;\n-      if (outputFile == null || outputFile.isBlank()) {\n-        keyWriter = System.out;\n-      } else {\n-        keyWriter = new PrintStream(new FileOutputStream(outputFile), true, StandardCharsets.UTF_8);\n-      }\n+      final StringBuilder yamlStringBuilder = new StringBuilder();\n+      final boolean printOnStandardOut = outputFile == null || outputFile.isBlank();\n+      final Path keyStoreOutputDirectory =\n+          keystorePath == null || keystorePath.isBlank() ? Path.of(\".\") : Path.of(keystorePath);\n+      final AtomicInteger counterSuffix = new AtomicInteger(0);\n+      final List<SafeFuture<TransactionReceipt>> futures;\n+      try {\n+        futures =\n+            validatorKeyPairs.stream()\n+                .map(\n+                    keyPair -> {\n+                      final String yamlFormattedString = getYamlFormattedString(keyPair);\n+                      if (encryptKeys) {\n+                        generateKeystores(\n+                            keyPair, keyStoreOutputDirectory, counterSuffix.incrementAndGet());\n+                      } else if (printOnStandardOut) {\n+                        System.out.println(yamlFormattedString);\n+                      } else {\n+                        yamlStringBuilder\n+                            .append(yamlFormattedString)\n+                            .append(System.lineSeparator());\n+                      }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYzOTg3NQ=="}, "originalCommit": {"oid": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0"}, "originalPosition": 117}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNzg4NDU1OnYy", "diffSide": "RIGHT", "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "isResolved": false, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwMDoyMjoxMVrOFyow5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQwOTo1NzowMlrOFzgxBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0MDk5OA==", "bodyText": "We should have a way to specify the password to use for keystrokes.  No point writing an encrypted keystore if you write an unencrypted password for it as well.  It's probably enough to be able to specify a password for all signing keys and a (potentially different) password for all withdrawal keys.", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388640998", "createdAt": "2020-03-06T00:22:11Z", "author": {"login": "ajsutton"}, "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "diffHunk": "@@ -81,44 +99,144 @@ public void generate(\n           int validatorCount,\n       @Option(\n               names = {\"--output-file\", \"-o\"},\n+              paramLabel = \"<FILE>\",\n               description =\n-                  \"File to write validator keys to. Keys are printed to std out if not specified\")\n-          String outputFile) {\n+                  \"File to write unencrypted validator keys to. Keys are printed to std out if not specified\")\n+          String outputFile,\n+      @Option(\n+              names = {\"--encrypt-keys\", \"-e\"},\n+              defaultValue = \"false\",\n+              paramLabel = \"<TRUE|FALSE>\",\n+              description = \"Encrypt validator keys. (Default: false)\",\n+              arity = \"1\")\n+          boolean encryptKeys,\n+      @Option(\n+              names = {\"--keystore-output-dir\", \"-k\"},\n+              paramLabel = \"<PATH>\",\n+              description =\n+                  \"Encrypted keystore output directory. Use current directory if not specified\")\n+          String keystorePath) {\n+\n     try (params) {\n+      // generate BLS validator key and withdrawal key\n+      final List<Pair<BLSKeyPair, BLSKeyPair>> validatorKeyPairs =\n+          IntStream.range(0, validatorCount)\n+              .mapToObj(value -> Pair.of(BLSKeyPair.random(), BLSKeyPair.random()))\n+              .collect(Collectors.toList());\n+\n       final DepositTransactionSender sender = params.createTransactionSender();\n-      final List<SafeFuture<TransactionReceipt>> futures = new ArrayList<>();\n \n-      final PrintStream keyWriter;\n-      if (outputFile == null || outputFile.isBlank()) {\n-        keyWriter = System.out;\n-      } else {\n-        keyWriter = new PrintStream(new FileOutputStream(outputFile), true, StandardCharsets.UTF_8);\n-      }\n+      final StringBuilder yamlStringBuilder = new StringBuilder();\n+      final boolean printOnStandardOut = outputFile == null || outputFile.isBlank();\n+      final Path keyStoreOutputDirectory =\n+          keystorePath == null || keystorePath.isBlank() ? Path.of(\".\") : Path.of(keystorePath);\n+      final AtomicInteger counterSuffix = new AtomicInteger(0);\n+      final List<SafeFuture<TransactionReceipt>> futures;\n+      try {\n+        futures =\n+            validatorKeyPairs.stream()\n+                .map(\n+                    keyPair -> {\n+                      final String yamlFormattedString = getYamlFormattedString(keyPair);\n+                      if (encryptKeys) {\n+                        generateKeystores(\n+                            keyPair, keyStoreOutputDirectory, counterSuffix.incrementAndGet());\n+                      } else if (printOnStandardOut) {\n+                        System.out.println(yamlFormattedString);\n+                      } else {\n+                        yamlStringBuilder\n+                            .append(yamlFormattedString)\n+                            .append(System.lineSeparator());\n+                      }\n+\n+                      return sendDeposit(\n+                          sender,\n+                          keyPair.getLeft(),\n+                          keyPair.getRight().getPublicKey(),\n+                          params.amount);\n+                    })\n+                .collect(Collectors.toList());\n \n-      try (keyWriter) {\n-        for (int i = 0; i < validatorCount; i++) {\n-          final BLSKeyPair validatorKey = BLSKeyPair.random();\n-          final BLSKeyPair withdrawalKey = BLSKeyPair.random();\n-\n-          keyWriter.println(\n-              String.format(\n-                  \"- {privkey: '%s', pubkey: '%s', withdrawalPrivkey: '%s', withdrawalPubkey: '%s'}\",\n-                  validatorKey.getSecretKey().getSecretKey().toBytes(),\n-                  validatorKey.getPublicKey().toBytesCompressed(),\n-                  withdrawalKey.getSecretKey().getSecretKey().toBytes(),\n-                  withdrawalKey.getPublicKey().toBytesCompressed()));\n-          futures.add(\n-              sendDeposit(sender, validatorKey, withdrawalKey.getPublicKey(), params.amount));\n+      } finally {\n+        if (!encryptKeys && !printOnStandardOut) {\n+          // write keys yaml to file\n+          Files.writeString(Path.of(outputFile), yamlStringBuilder.toString());\n         }\n       }\n-      SafeFuture.allOf(futures.toArray(SafeFuture[]::new)).get(2, TimeUnit.MINUTES);\n+\n+      waitForTransactionReceipts(futures);\n     } catch (final Throwable t) {\n       STDOUT.log(\n           Level.FATAL,\n           \"Failed to send deposit transaction: \" + t.getClass() + \": \" + t.getMessage());\n-      System.exit(1); // Web3J creates a non-daemon thread we can't shut down. :(\n+      exit(1);\n     }\n-    System.exit(0); // Web3J creates a non-daemon thread we can't shut down. :(\n+    exit(0);\n+  }\n+\n+  @VisibleForTesting\n+  void waitForTransactionReceipts(final List<SafeFuture<TransactionReceipt>> futures)\n+      throws InterruptedException, ExecutionException, TimeoutException {\n+    SafeFuture.allOf(futures.toArray(SafeFuture[]::new)).get(2, TimeUnit.MINUTES);\n+  }\n+\n+  @VisibleForTesting\n+  void exit(final int status) {\n+    System.exit(status); // Web3J creates a non-daemon thread we can't shut down. :(\n+  }\n+\n+  private String getYamlFormattedString(final Pair<BLSKeyPair, BLSKeyPair> keyPair) {\n+    return String.format(\n+        \"- {privkey: '%s', pubkey: '%s', withdrawalPrivkey: '%s', withdrawalPubkey: '%s'}\",\n+        keyPair.getLeft().getSecretKey().getSecretKey().toBytes(),\n+        keyPair.getLeft().getPublicKey().toBytesCompressed(),\n+        keyPair.getRight().getSecretKey().getSecretKey().toBytes(),\n+        keyPair.getRight().getPublicKey().toBytesCompressed());\n+  }\n+\n+  private void generateKeystores(\n+      final Pair<BLSKeyPair, BLSKeyPair> keyPair,\n+      final Path keyStoreOutputDirectory,\n+      final int counter) {\n+    generateKeystore(keyPair.getLeft(), keyStoreOutputDirectory, \"validator\", counter);\n+    generateKeystore(keyPair.getRight(), keyStoreOutputDirectory, \"withdrawal\", counter);\n+  }\n+\n+  private void generateKeystore(\n+      final BLSKeyPair key, final Path outputDir, final String prefix, final int counter) {\n+    try {\n+      final KdfParam kdfParam = new SCryptParam(32, Bytes32.random());\n+      final Cipher cipher = new Cipher(CipherFunction.AES_128_CTR, Bytes.random(16));\n+      final String randomPassword = generateRandomHexToken();\n+      final KeyStoreData keyStoreData =\n+          KeyStore.encrypt(\n+              key.getSecretKey().getSecretKey().toBytes(),\n+              generateRandomHexToken(),\n+              \"\",\n+              kdfParam,\n+              cipher);\n+\n+      // create sub directory\n+      final Path keystoreDirectory =\n+          Files.createDirectories(outputDir.resolve(\"validator_\" + counter));\n+\n+      // save keystore\n+      KeyStoreLoader.saveToFile(\n+          keystoreDirectory.resolve(prefix + \"_keystore_\" + counter + \".json\"), keyStoreData);\n+\n+      // save password\n+      Files.writeString(\n+          keystoreDirectory.resolve(prefix + \"_password_\" + counter + \".txt\"), randomPassword);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0"}, "originalPosition": 213}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY2OTI4Mg==", "bodyText": "that make sense. Let me figure out whether to read the password from stdin or from files or from cli option.", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388669282", "createdAt": "2020-03-06T01:33:34Z", "author": {"login": "usmansaleem"}, "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "diffHunk": "@@ -81,44 +99,144 @@ public void generate(\n           int validatorCount,\n       @Option(\n               names = {\"--output-file\", \"-o\"},\n+              paramLabel = \"<FILE>\",\n               description =\n-                  \"File to write validator keys to. Keys are printed to std out if not specified\")\n-          String outputFile) {\n+                  \"File to write unencrypted validator keys to. Keys are printed to std out if not specified\")\n+          String outputFile,\n+      @Option(\n+              names = {\"--encrypt-keys\", \"-e\"},\n+              defaultValue = \"false\",\n+              paramLabel = \"<TRUE|FALSE>\",\n+              description = \"Encrypt validator keys. (Default: false)\",\n+              arity = \"1\")\n+          boolean encryptKeys,\n+      @Option(\n+              names = {\"--keystore-output-dir\", \"-k\"},\n+              paramLabel = \"<PATH>\",\n+              description =\n+                  \"Encrypted keystore output directory. Use current directory if not specified\")\n+          String keystorePath) {\n+\n     try (params) {\n+      // generate BLS validator key and withdrawal key\n+      final List<Pair<BLSKeyPair, BLSKeyPair>> validatorKeyPairs =\n+          IntStream.range(0, validatorCount)\n+              .mapToObj(value -> Pair.of(BLSKeyPair.random(), BLSKeyPair.random()))\n+              .collect(Collectors.toList());\n+\n       final DepositTransactionSender sender = params.createTransactionSender();\n-      final List<SafeFuture<TransactionReceipt>> futures = new ArrayList<>();\n \n-      final PrintStream keyWriter;\n-      if (outputFile == null || outputFile.isBlank()) {\n-        keyWriter = System.out;\n-      } else {\n-        keyWriter = new PrintStream(new FileOutputStream(outputFile), true, StandardCharsets.UTF_8);\n-      }\n+      final StringBuilder yamlStringBuilder = new StringBuilder();\n+      final boolean printOnStandardOut = outputFile == null || outputFile.isBlank();\n+      final Path keyStoreOutputDirectory =\n+          keystorePath == null || keystorePath.isBlank() ? Path.of(\".\") : Path.of(keystorePath);\n+      final AtomicInteger counterSuffix = new AtomicInteger(0);\n+      final List<SafeFuture<TransactionReceipt>> futures;\n+      try {\n+        futures =\n+            validatorKeyPairs.stream()\n+                .map(\n+                    keyPair -> {\n+                      final String yamlFormattedString = getYamlFormattedString(keyPair);\n+                      if (encryptKeys) {\n+                        generateKeystores(\n+                            keyPair, keyStoreOutputDirectory, counterSuffix.incrementAndGet());\n+                      } else if (printOnStandardOut) {\n+                        System.out.println(yamlFormattedString);\n+                      } else {\n+                        yamlStringBuilder\n+                            .append(yamlFormattedString)\n+                            .append(System.lineSeparator());\n+                      }\n+\n+                      return sendDeposit(\n+                          sender,\n+                          keyPair.getLeft(),\n+                          keyPair.getRight().getPublicKey(),\n+                          params.amount);\n+                    })\n+                .collect(Collectors.toList());\n \n-      try (keyWriter) {\n-        for (int i = 0; i < validatorCount; i++) {\n-          final BLSKeyPair validatorKey = BLSKeyPair.random();\n-          final BLSKeyPair withdrawalKey = BLSKeyPair.random();\n-\n-          keyWriter.println(\n-              String.format(\n-                  \"- {privkey: '%s', pubkey: '%s', withdrawalPrivkey: '%s', withdrawalPubkey: '%s'}\",\n-                  validatorKey.getSecretKey().getSecretKey().toBytes(),\n-                  validatorKey.getPublicKey().toBytesCompressed(),\n-                  withdrawalKey.getSecretKey().getSecretKey().toBytes(),\n-                  withdrawalKey.getPublicKey().toBytesCompressed()));\n-          futures.add(\n-              sendDeposit(sender, validatorKey, withdrawalKey.getPublicKey(), params.amount));\n+      } finally {\n+        if (!encryptKeys && !printOnStandardOut) {\n+          // write keys yaml to file\n+          Files.writeString(Path.of(outputFile), yamlStringBuilder.toString());\n         }\n       }\n-      SafeFuture.allOf(futures.toArray(SafeFuture[]::new)).get(2, TimeUnit.MINUTES);\n+\n+      waitForTransactionReceipts(futures);\n     } catch (final Throwable t) {\n       STDOUT.log(\n           Level.FATAL,\n           \"Failed to send deposit transaction: \" + t.getClass() + \": \" + t.getMessage());\n-      System.exit(1); // Web3J creates a non-daemon thread we can't shut down. :(\n+      exit(1);\n     }\n-    System.exit(0); // Web3J creates a non-daemon thread we can't shut down. :(\n+    exit(0);\n+  }\n+\n+  @VisibleForTesting\n+  void waitForTransactionReceipts(final List<SafeFuture<TransactionReceipt>> futures)\n+      throws InterruptedException, ExecutionException, TimeoutException {\n+    SafeFuture.allOf(futures.toArray(SafeFuture[]::new)).get(2, TimeUnit.MINUTES);\n+  }\n+\n+  @VisibleForTesting\n+  void exit(final int status) {\n+    System.exit(status); // Web3J creates a non-daemon thread we can't shut down. :(\n+  }\n+\n+  private String getYamlFormattedString(final Pair<BLSKeyPair, BLSKeyPair> keyPair) {\n+    return String.format(\n+        \"- {privkey: '%s', pubkey: '%s', withdrawalPrivkey: '%s', withdrawalPubkey: '%s'}\",\n+        keyPair.getLeft().getSecretKey().getSecretKey().toBytes(),\n+        keyPair.getLeft().getPublicKey().toBytesCompressed(),\n+        keyPair.getRight().getSecretKey().getSecretKey().toBytes(),\n+        keyPair.getRight().getPublicKey().toBytesCompressed());\n+  }\n+\n+  private void generateKeystores(\n+      final Pair<BLSKeyPair, BLSKeyPair> keyPair,\n+      final Path keyStoreOutputDirectory,\n+      final int counter) {\n+    generateKeystore(keyPair.getLeft(), keyStoreOutputDirectory, \"validator\", counter);\n+    generateKeystore(keyPair.getRight(), keyStoreOutputDirectory, \"withdrawal\", counter);\n+  }\n+\n+  private void generateKeystore(\n+      final BLSKeyPair key, final Path outputDir, final String prefix, final int counter) {\n+    try {\n+      final KdfParam kdfParam = new SCryptParam(32, Bytes32.random());\n+      final Cipher cipher = new Cipher(CipherFunction.AES_128_CTR, Bytes.random(16));\n+      final String randomPassword = generateRandomHexToken();\n+      final KeyStoreData keyStoreData =\n+          KeyStore.encrypt(\n+              key.getSecretKey().getSecretKey().toBytes(),\n+              generateRandomHexToken(),\n+              \"\",\n+              kdfParam,\n+              cipher);\n+\n+      // create sub directory\n+      final Path keystoreDirectory =\n+          Files.createDirectories(outputDir.resolve(\"validator_\" + counter));\n+\n+      // save keystore\n+      KeyStoreLoader.saveToFile(\n+          keystoreDirectory.resolve(prefix + \"_keystore_\" + counter + \".json\"), keyStoreData);\n+\n+      // save password\n+      Files.writeString(\n+          keystoreDirectory.resolve(prefix + \"_password_\" + counter + \".txt\"), randomPassword);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0MDk5OA=="}, "originalCommit": {"oid": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0"}, "originalPosition": 213}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY3MDc2Mw==", "bodyText": "The password should not be included on the command line.  Using ps auxwww any user on the same box can see command line arguments for any running program.  It also tends to get written to places like .bash_history", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388670763", "createdAt": "2020-03-06T01:38:53Z", "author": {"login": "ajsutton"}, "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "diffHunk": "@@ -81,44 +99,144 @@ public void generate(\n           int validatorCount,\n       @Option(\n               names = {\"--output-file\", \"-o\"},\n+              paramLabel = \"<FILE>\",\n               description =\n-                  \"File to write validator keys to. Keys are printed to std out if not specified\")\n-          String outputFile) {\n+                  \"File to write unencrypted validator keys to. Keys are printed to std out if not specified\")\n+          String outputFile,\n+      @Option(\n+              names = {\"--encrypt-keys\", \"-e\"},\n+              defaultValue = \"false\",\n+              paramLabel = \"<TRUE|FALSE>\",\n+              description = \"Encrypt validator keys. (Default: false)\",\n+              arity = \"1\")\n+          boolean encryptKeys,\n+      @Option(\n+              names = {\"--keystore-output-dir\", \"-k\"},\n+              paramLabel = \"<PATH>\",\n+              description =\n+                  \"Encrypted keystore output directory. Use current directory if not specified\")\n+          String keystorePath) {\n+\n     try (params) {\n+      // generate BLS validator key and withdrawal key\n+      final List<Pair<BLSKeyPair, BLSKeyPair>> validatorKeyPairs =\n+          IntStream.range(0, validatorCount)\n+              .mapToObj(value -> Pair.of(BLSKeyPair.random(), BLSKeyPair.random()))\n+              .collect(Collectors.toList());\n+\n       final DepositTransactionSender sender = params.createTransactionSender();\n-      final List<SafeFuture<TransactionReceipt>> futures = new ArrayList<>();\n \n-      final PrintStream keyWriter;\n-      if (outputFile == null || outputFile.isBlank()) {\n-        keyWriter = System.out;\n-      } else {\n-        keyWriter = new PrintStream(new FileOutputStream(outputFile), true, StandardCharsets.UTF_8);\n-      }\n+      final StringBuilder yamlStringBuilder = new StringBuilder();\n+      final boolean printOnStandardOut = outputFile == null || outputFile.isBlank();\n+      final Path keyStoreOutputDirectory =\n+          keystorePath == null || keystorePath.isBlank() ? Path.of(\".\") : Path.of(keystorePath);\n+      final AtomicInteger counterSuffix = new AtomicInteger(0);\n+      final List<SafeFuture<TransactionReceipt>> futures;\n+      try {\n+        futures =\n+            validatorKeyPairs.stream()\n+                .map(\n+                    keyPair -> {\n+                      final String yamlFormattedString = getYamlFormattedString(keyPair);\n+                      if (encryptKeys) {\n+                        generateKeystores(\n+                            keyPair, keyStoreOutputDirectory, counterSuffix.incrementAndGet());\n+                      } else if (printOnStandardOut) {\n+                        System.out.println(yamlFormattedString);\n+                      } else {\n+                        yamlStringBuilder\n+                            .append(yamlFormattedString)\n+                            .append(System.lineSeparator());\n+                      }\n+\n+                      return sendDeposit(\n+                          sender,\n+                          keyPair.getLeft(),\n+                          keyPair.getRight().getPublicKey(),\n+                          params.amount);\n+                    })\n+                .collect(Collectors.toList());\n \n-      try (keyWriter) {\n-        for (int i = 0; i < validatorCount; i++) {\n-          final BLSKeyPair validatorKey = BLSKeyPair.random();\n-          final BLSKeyPair withdrawalKey = BLSKeyPair.random();\n-\n-          keyWriter.println(\n-              String.format(\n-                  \"- {privkey: '%s', pubkey: '%s', withdrawalPrivkey: '%s', withdrawalPubkey: '%s'}\",\n-                  validatorKey.getSecretKey().getSecretKey().toBytes(),\n-                  validatorKey.getPublicKey().toBytesCompressed(),\n-                  withdrawalKey.getSecretKey().getSecretKey().toBytes(),\n-                  withdrawalKey.getPublicKey().toBytesCompressed()));\n-          futures.add(\n-              sendDeposit(sender, validatorKey, withdrawalKey.getPublicKey(), params.amount));\n+      } finally {\n+        if (!encryptKeys && !printOnStandardOut) {\n+          // write keys yaml to file\n+          Files.writeString(Path.of(outputFile), yamlStringBuilder.toString());\n         }\n       }\n-      SafeFuture.allOf(futures.toArray(SafeFuture[]::new)).get(2, TimeUnit.MINUTES);\n+\n+      waitForTransactionReceipts(futures);\n     } catch (final Throwable t) {\n       STDOUT.log(\n           Level.FATAL,\n           \"Failed to send deposit transaction: \" + t.getClass() + \": \" + t.getMessage());\n-      System.exit(1); // Web3J creates a non-daemon thread we can't shut down. :(\n+      exit(1);\n     }\n-    System.exit(0); // Web3J creates a non-daemon thread we can't shut down. :(\n+    exit(0);\n+  }\n+\n+  @VisibleForTesting\n+  void waitForTransactionReceipts(final List<SafeFuture<TransactionReceipt>> futures)\n+      throws InterruptedException, ExecutionException, TimeoutException {\n+    SafeFuture.allOf(futures.toArray(SafeFuture[]::new)).get(2, TimeUnit.MINUTES);\n+  }\n+\n+  @VisibleForTesting\n+  void exit(final int status) {\n+    System.exit(status); // Web3J creates a non-daemon thread we can't shut down. :(\n+  }\n+\n+  private String getYamlFormattedString(final Pair<BLSKeyPair, BLSKeyPair> keyPair) {\n+    return String.format(\n+        \"- {privkey: '%s', pubkey: '%s', withdrawalPrivkey: '%s', withdrawalPubkey: '%s'}\",\n+        keyPair.getLeft().getSecretKey().getSecretKey().toBytes(),\n+        keyPair.getLeft().getPublicKey().toBytesCompressed(),\n+        keyPair.getRight().getSecretKey().getSecretKey().toBytes(),\n+        keyPair.getRight().getPublicKey().toBytesCompressed());\n+  }\n+\n+  private void generateKeystores(\n+      final Pair<BLSKeyPair, BLSKeyPair> keyPair,\n+      final Path keyStoreOutputDirectory,\n+      final int counter) {\n+    generateKeystore(keyPair.getLeft(), keyStoreOutputDirectory, \"validator\", counter);\n+    generateKeystore(keyPair.getRight(), keyStoreOutputDirectory, \"withdrawal\", counter);\n+  }\n+\n+  private void generateKeystore(\n+      final BLSKeyPair key, final Path outputDir, final String prefix, final int counter) {\n+    try {\n+      final KdfParam kdfParam = new SCryptParam(32, Bytes32.random());\n+      final Cipher cipher = new Cipher(CipherFunction.AES_128_CTR, Bytes.random(16));\n+      final String randomPassword = generateRandomHexToken();\n+      final KeyStoreData keyStoreData =\n+          KeyStore.encrypt(\n+              key.getSecretKey().getSecretKey().toBytes(),\n+              generateRandomHexToken(),\n+              \"\",\n+              kdfParam,\n+              cipher);\n+\n+      // create sub directory\n+      final Path keystoreDirectory =\n+          Files.createDirectories(outputDir.resolve(\"validator_\" + counter));\n+\n+      // save keystore\n+      KeyStoreLoader.saveToFile(\n+          keystoreDirectory.resolve(prefix + \"_keystore_\" + counter + \".json\"), keyStoreData);\n+\n+      // save password\n+      Files.writeString(\n+          keystoreDirectory.resolve(prefix + \"_password_\" + counter + \".txt\"), randomPassword);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0MDk5OA=="}, "originalCommit": {"oid": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0"}, "originalPosition": 213}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY3MTIxMA==", "bodyText": "password input file it is ... unless we are open for \"interactive shell\" approach to read the input from user.", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388671210", "createdAt": "2020-03-06T01:40:49Z", "author": {"login": "usmansaleem"}, "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "diffHunk": "@@ -81,44 +99,144 @@ public void generate(\n           int validatorCount,\n       @Option(\n               names = {\"--output-file\", \"-o\"},\n+              paramLabel = \"<FILE>\",\n               description =\n-                  \"File to write validator keys to. Keys are printed to std out if not specified\")\n-          String outputFile) {\n+                  \"File to write unencrypted validator keys to. Keys are printed to std out if not specified\")\n+          String outputFile,\n+      @Option(\n+              names = {\"--encrypt-keys\", \"-e\"},\n+              defaultValue = \"false\",\n+              paramLabel = \"<TRUE|FALSE>\",\n+              description = \"Encrypt validator keys. (Default: false)\",\n+              arity = \"1\")\n+          boolean encryptKeys,\n+      @Option(\n+              names = {\"--keystore-output-dir\", \"-k\"},\n+              paramLabel = \"<PATH>\",\n+              description =\n+                  \"Encrypted keystore output directory. Use current directory if not specified\")\n+          String keystorePath) {\n+\n     try (params) {\n+      // generate BLS validator key and withdrawal key\n+      final List<Pair<BLSKeyPair, BLSKeyPair>> validatorKeyPairs =\n+          IntStream.range(0, validatorCount)\n+              .mapToObj(value -> Pair.of(BLSKeyPair.random(), BLSKeyPair.random()))\n+              .collect(Collectors.toList());\n+\n       final DepositTransactionSender sender = params.createTransactionSender();\n-      final List<SafeFuture<TransactionReceipt>> futures = new ArrayList<>();\n \n-      final PrintStream keyWriter;\n-      if (outputFile == null || outputFile.isBlank()) {\n-        keyWriter = System.out;\n-      } else {\n-        keyWriter = new PrintStream(new FileOutputStream(outputFile), true, StandardCharsets.UTF_8);\n-      }\n+      final StringBuilder yamlStringBuilder = new StringBuilder();\n+      final boolean printOnStandardOut = outputFile == null || outputFile.isBlank();\n+      final Path keyStoreOutputDirectory =\n+          keystorePath == null || keystorePath.isBlank() ? Path.of(\".\") : Path.of(keystorePath);\n+      final AtomicInteger counterSuffix = new AtomicInteger(0);\n+      final List<SafeFuture<TransactionReceipt>> futures;\n+      try {\n+        futures =\n+            validatorKeyPairs.stream()\n+                .map(\n+                    keyPair -> {\n+                      final String yamlFormattedString = getYamlFormattedString(keyPair);\n+                      if (encryptKeys) {\n+                        generateKeystores(\n+                            keyPair, keyStoreOutputDirectory, counterSuffix.incrementAndGet());\n+                      } else if (printOnStandardOut) {\n+                        System.out.println(yamlFormattedString);\n+                      } else {\n+                        yamlStringBuilder\n+                            .append(yamlFormattedString)\n+                            .append(System.lineSeparator());\n+                      }\n+\n+                      return sendDeposit(\n+                          sender,\n+                          keyPair.getLeft(),\n+                          keyPair.getRight().getPublicKey(),\n+                          params.amount);\n+                    })\n+                .collect(Collectors.toList());\n \n-      try (keyWriter) {\n-        for (int i = 0; i < validatorCount; i++) {\n-          final BLSKeyPair validatorKey = BLSKeyPair.random();\n-          final BLSKeyPair withdrawalKey = BLSKeyPair.random();\n-\n-          keyWriter.println(\n-              String.format(\n-                  \"- {privkey: '%s', pubkey: '%s', withdrawalPrivkey: '%s', withdrawalPubkey: '%s'}\",\n-                  validatorKey.getSecretKey().getSecretKey().toBytes(),\n-                  validatorKey.getPublicKey().toBytesCompressed(),\n-                  withdrawalKey.getSecretKey().getSecretKey().toBytes(),\n-                  withdrawalKey.getPublicKey().toBytesCompressed()));\n-          futures.add(\n-              sendDeposit(sender, validatorKey, withdrawalKey.getPublicKey(), params.amount));\n+      } finally {\n+        if (!encryptKeys && !printOnStandardOut) {\n+          // write keys yaml to file\n+          Files.writeString(Path.of(outputFile), yamlStringBuilder.toString());\n         }\n       }\n-      SafeFuture.allOf(futures.toArray(SafeFuture[]::new)).get(2, TimeUnit.MINUTES);\n+\n+      waitForTransactionReceipts(futures);\n     } catch (final Throwable t) {\n       STDOUT.log(\n           Level.FATAL,\n           \"Failed to send deposit transaction: \" + t.getClass() + \": \" + t.getMessage());\n-      System.exit(1); // Web3J creates a non-daemon thread we can't shut down. :(\n+      exit(1);\n     }\n-    System.exit(0); // Web3J creates a non-daemon thread we can't shut down. :(\n+    exit(0);\n+  }\n+\n+  @VisibleForTesting\n+  void waitForTransactionReceipts(final List<SafeFuture<TransactionReceipt>> futures)\n+      throws InterruptedException, ExecutionException, TimeoutException {\n+    SafeFuture.allOf(futures.toArray(SafeFuture[]::new)).get(2, TimeUnit.MINUTES);\n+  }\n+\n+  @VisibleForTesting\n+  void exit(final int status) {\n+    System.exit(status); // Web3J creates a non-daemon thread we can't shut down. :(\n+  }\n+\n+  private String getYamlFormattedString(final Pair<BLSKeyPair, BLSKeyPair> keyPair) {\n+    return String.format(\n+        \"- {privkey: '%s', pubkey: '%s', withdrawalPrivkey: '%s', withdrawalPubkey: '%s'}\",\n+        keyPair.getLeft().getSecretKey().getSecretKey().toBytes(),\n+        keyPair.getLeft().getPublicKey().toBytesCompressed(),\n+        keyPair.getRight().getSecretKey().getSecretKey().toBytes(),\n+        keyPair.getRight().getPublicKey().toBytesCompressed());\n+  }\n+\n+  private void generateKeystores(\n+      final Pair<BLSKeyPair, BLSKeyPair> keyPair,\n+      final Path keyStoreOutputDirectory,\n+      final int counter) {\n+    generateKeystore(keyPair.getLeft(), keyStoreOutputDirectory, \"validator\", counter);\n+    generateKeystore(keyPair.getRight(), keyStoreOutputDirectory, \"withdrawal\", counter);\n+  }\n+\n+  private void generateKeystore(\n+      final BLSKeyPair key, final Path outputDir, final String prefix, final int counter) {\n+    try {\n+      final KdfParam kdfParam = new SCryptParam(32, Bytes32.random());\n+      final Cipher cipher = new Cipher(CipherFunction.AES_128_CTR, Bytes.random(16));\n+      final String randomPassword = generateRandomHexToken();\n+      final KeyStoreData keyStoreData =\n+          KeyStore.encrypt(\n+              key.getSecretKey().getSecretKey().toBytes(),\n+              generateRandomHexToken(),\n+              \"\",\n+              kdfParam,\n+              cipher);\n+\n+      // create sub directory\n+      final Path keystoreDirectory =\n+          Files.createDirectories(outputDir.resolve(\"validator_\" + counter));\n+\n+      // save keystore\n+      KeyStoreLoader.saveToFile(\n+          keystoreDirectory.resolve(prefix + \"_keystore_\" + counter + \".json\"), keyStoreData);\n+\n+      // save password\n+      Files.writeString(\n+          keystoreDirectory.resolve(prefix + \"_password_\" + counter + \".txt\"), randomPassword);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0MDk5OA=="}, "originalCommit": {"oid": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0"}, "originalPosition": 213}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY3MTQ4Mw==", "bodyText": "I think an interactive mode would be an excellent option to support.  Need to check with POs as to priority and probably get Jake to think about the details.", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388671483", "createdAt": "2020-03-06T01:41:52Z", "author": {"login": "ajsutton"}, "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "diffHunk": "@@ -81,44 +99,144 @@ public void generate(\n           int validatorCount,\n       @Option(\n               names = {\"--output-file\", \"-o\"},\n+              paramLabel = \"<FILE>\",\n               description =\n-                  \"File to write validator keys to. Keys are printed to std out if not specified\")\n-          String outputFile) {\n+                  \"File to write unencrypted validator keys to. Keys are printed to std out if not specified\")\n+          String outputFile,\n+      @Option(\n+              names = {\"--encrypt-keys\", \"-e\"},\n+              defaultValue = \"false\",\n+              paramLabel = \"<TRUE|FALSE>\",\n+              description = \"Encrypt validator keys. (Default: false)\",\n+              arity = \"1\")\n+          boolean encryptKeys,\n+      @Option(\n+              names = {\"--keystore-output-dir\", \"-k\"},\n+              paramLabel = \"<PATH>\",\n+              description =\n+                  \"Encrypted keystore output directory. Use current directory if not specified\")\n+          String keystorePath) {\n+\n     try (params) {\n+      // generate BLS validator key and withdrawal key\n+      final List<Pair<BLSKeyPair, BLSKeyPair>> validatorKeyPairs =\n+          IntStream.range(0, validatorCount)\n+              .mapToObj(value -> Pair.of(BLSKeyPair.random(), BLSKeyPair.random()))\n+              .collect(Collectors.toList());\n+\n       final DepositTransactionSender sender = params.createTransactionSender();\n-      final List<SafeFuture<TransactionReceipt>> futures = new ArrayList<>();\n \n-      final PrintStream keyWriter;\n-      if (outputFile == null || outputFile.isBlank()) {\n-        keyWriter = System.out;\n-      } else {\n-        keyWriter = new PrintStream(new FileOutputStream(outputFile), true, StandardCharsets.UTF_8);\n-      }\n+      final StringBuilder yamlStringBuilder = new StringBuilder();\n+      final boolean printOnStandardOut = outputFile == null || outputFile.isBlank();\n+      final Path keyStoreOutputDirectory =\n+          keystorePath == null || keystorePath.isBlank() ? Path.of(\".\") : Path.of(keystorePath);\n+      final AtomicInteger counterSuffix = new AtomicInteger(0);\n+      final List<SafeFuture<TransactionReceipt>> futures;\n+      try {\n+        futures =\n+            validatorKeyPairs.stream()\n+                .map(\n+                    keyPair -> {\n+                      final String yamlFormattedString = getYamlFormattedString(keyPair);\n+                      if (encryptKeys) {\n+                        generateKeystores(\n+                            keyPair, keyStoreOutputDirectory, counterSuffix.incrementAndGet());\n+                      } else if (printOnStandardOut) {\n+                        System.out.println(yamlFormattedString);\n+                      } else {\n+                        yamlStringBuilder\n+                            .append(yamlFormattedString)\n+                            .append(System.lineSeparator());\n+                      }\n+\n+                      return sendDeposit(\n+                          sender,\n+                          keyPair.getLeft(),\n+                          keyPair.getRight().getPublicKey(),\n+                          params.amount);\n+                    })\n+                .collect(Collectors.toList());\n \n-      try (keyWriter) {\n-        for (int i = 0; i < validatorCount; i++) {\n-          final BLSKeyPair validatorKey = BLSKeyPair.random();\n-          final BLSKeyPair withdrawalKey = BLSKeyPair.random();\n-\n-          keyWriter.println(\n-              String.format(\n-                  \"- {privkey: '%s', pubkey: '%s', withdrawalPrivkey: '%s', withdrawalPubkey: '%s'}\",\n-                  validatorKey.getSecretKey().getSecretKey().toBytes(),\n-                  validatorKey.getPublicKey().toBytesCompressed(),\n-                  withdrawalKey.getSecretKey().getSecretKey().toBytes(),\n-                  withdrawalKey.getPublicKey().toBytesCompressed()));\n-          futures.add(\n-              sendDeposit(sender, validatorKey, withdrawalKey.getPublicKey(), params.amount));\n+      } finally {\n+        if (!encryptKeys && !printOnStandardOut) {\n+          // write keys yaml to file\n+          Files.writeString(Path.of(outputFile), yamlStringBuilder.toString());\n         }\n       }\n-      SafeFuture.allOf(futures.toArray(SafeFuture[]::new)).get(2, TimeUnit.MINUTES);\n+\n+      waitForTransactionReceipts(futures);\n     } catch (final Throwable t) {\n       STDOUT.log(\n           Level.FATAL,\n           \"Failed to send deposit transaction: \" + t.getClass() + \": \" + t.getMessage());\n-      System.exit(1); // Web3J creates a non-daemon thread we can't shut down. :(\n+      exit(1);\n     }\n-    System.exit(0); // Web3J creates a non-daemon thread we can't shut down. :(\n+    exit(0);\n+  }\n+\n+  @VisibleForTesting\n+  void waitForTransactionReceipts(final List<SafeFuture<TransactionReceipt>> futures)\n+      throws InterruptedException, ExecutionException, TimeoutException {\n+    SafeFuture.allOf(futures.toArray(SafeFuture[]::new)).get(2, TimeUnit.MINUTES);\n+  }\n+\n+  @VisibleForTesting\n+  void exit(final int status) {\n+    System.exit(status); // Web3J creates a non-daemon thread we can't shut down. :(\n+  }\n+\n+  private String getYamlFormattedString(final Pair<BLSKeyPair, BLSKeyPair> keyPair) {\n+    return String.format(\n+        \"- {privkey: '%s', pubkey: '%s', withdrawalPrivkey: '%s', withdrawalPubkey: '%s'}\",\n+        keyPair.getLeft().getSecretKey().getSecretKey().toBytes(),\n+        keyPair.getLeft().getPublicKey().toBytesCompressed(),\n+        keyPair.getRight().getSecretKey().getSecretKey().toBytes(),\n+        keyPair.getRight().getPublicKey().toBytesCompressed());\n+  }\n+\n+  private void generateKeystores(\n+      final Pair<BLSKeyPair, BLSKeyPair> keyPair,\n+      final Path keyStoreOutputDirectory,\n+      final int counter) {\n+    generateKeystore(keyPair.getLeft(), keyStoreOutputDirectory, \"validator\", counter);\n+    generateKeystore(keyPair.getRight(), keyStoreOutputDirectory, \"withdrawal\", counter);\n+  }\n+\n+  private void generateKeystore(\n+      final BLSKeyPair key, final Path outputDir, final String prefix, final int counter) {\n+    try {\n+      final KdfParam kdfParam = new SCryptParam(32, Bytes32.random());\n+      final Cipher cipher = new Cipher(CipherFunction.AES_128_CTR, Bytes.random(16));\n+      final String randomPassword = generateRandomHexToken();\n+      final KeyStoreData keyStoreData =\n+          KeyStore.encrypt(\n+              key.getSecretKey().getSecretKey().toBytes(),\n+              generateRandomHexToken(),\n+              \"\",\n+              kdfParam,\n+              cipher);\n+\n+      // create sub directory\n+      final Path keystoreDirectory =\n+          Files.createDirectories(outputDir.resolve(\"validator_\" + counter));\n+\n+      // save keystore\n+      KeyStoreLoader.saveToFile(\n+          keystoreDirectory.resolve(prefix + \"_keystore_\" + counter + \".json\"), keyStoreData);\n+\n+      // save password\n+      Files.writeString(\n+          keystoreDirectory.resolve(prefix + \"_password_\" + counter + \".txt\"), randomPassword);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0MDk5OA=="}, "originalCommit": {"oid": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0"}, "originalPosition": 213}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY3MTU5MQ==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388671591", "createdAt": "2020-03-06T01:42:16Z", "author": {"login": "usmansaleem"}, "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "diffHunk": "@@ -81,44 +99,144 @@ public void generate(\n           int validatorCount,\n       @Option(\n               names = {\"--output-file\", \"-o\"},\n+              paramLabel = \"<FILE>\",\n               description =\n-                  \"File to write validator keys to. Keys are printed to std out if not specified\")\n-          String outputFile) {\n+                  \"File to write unencrypted validator keys to. Keys are printed to std out if not specified\")\n+          String outputFile,\n+      @Option(\n+              names = {\"--encrypt-keys\", \"-e\"},\n+              defaultValue = \"false\",\n+              paramLabel = \"<TRUE|FALSE>\",\n+              description = \"Encrypt validator keys. (Default: false)\",\n+              arity = \"1\")\n+          boolean encryptKeys,\n+      @Option(\n+              names = {\"--keystore-output-dir\", \"-k\"},\n+              paramLabel = \"<PATH>\",\n+              description =\n+                  \"Encrypted keystore output directory. Use current directory if not specified\")\n+          String keystorePath) {\n+\n     try (params) {\n+      // generate BLS validator key and withdrawal key\n+      final List<Pair<BLSKeyPair, BLSKeyPair>> validatorKeyPairs =\n+          IntStream.range(0, validatorCount)\n+              .mapToObj(value -> Pair.of(BLSKeyPair.random(), BLSKeyPair.random()))\n+              .collect(Collectors.toList());\n+\n       final DepositTransactionSender sender = params.createTransactionSender();\n-      final List<SafeFuture<TransactionReceipt>> futures = new ArrayList<>();\n \n-      final PrintStream keyWriter;\n-      if (outputFile == null || outputFile.isBlank()) {\n-        keyWriter = System.out;\n-      } else {\n-        keyWriter = new PrintStream(new FileOutputStream(outputFile), true, StandardCharsets.UTF_8);\n-      }\n+      final StringBuilder yamlStringBuilder = new StringBuilder();\n+      final boolean printOnStandardOut = outputFile == null || outputFile.isBlank();\n+      final Path keyStoreOutputDirectory =\n+          keystorePath == null || keystorePath.isBlank() ? Path.of(\".\") : Path.of(keystorePath);\n+      final AtomicInteger counterSuffix = new AtomicInteger(0);\n+      final List<SafeFuture<TransactionReceipt>> futures;\n+      try {\n+        futures =\n+            validatorKeyPairs.stream()\n+                .map(\n+                    keyPair -> {\n+                      final String yamlFormattedString = getYamlFormattedString(keyPair);\n+                      if (encryptKeys) {\n+                        generateKeystores(\n+                            keyPair, keyStoreOutputDirectory, counterSuffix.incrementAndGet());\n+                      } else if (printOnStandardOut) {\n+                        System.out.println(yamlFormattedString);\n+                      } else {\n+                        yamlStringBuilder\n+                            .append(yamlFormattedString)\n+                            .append(System.lineSeparator());\n+                      }\n+\n+                      return sendDeposit(\n+                          sender,\n+                          keyPair.getLeft(),\n+                          keyPair.getRight().getPublicKey(),\n+                          params.amount);\n+                    })\n+                .collect(Collectors.toList());\n \n-      try (keyWriter) {\n-        for (int i = 0; i < validatorCount; i++) {\n-          final BLSKeyPair validatorKey = BLSKeyPair.random();\n-          final BLSKeyPair withdrawalKey = BLSKeyPair.random();\n-\n-          keyWriter.println(\n-              String.format(\n-                  \"- {privkey: '%s', pubkey: '%s', withdrawalPrivkey: '%s', withdrawalPubkey: '%s'}\",\n-                  validatorKey.getSecretKey().getSecretKey().toBytes(),\n-                  validatorKey.getPublicKey().toBytesCompressed(),\n-                  withdrawalKey.getSecretKey().getSecretKey().toBytes(),\n-                  withdrawalKey.getPublicKey().toBytesCompressed()));\n-          futures.add(\n-              sendDeposit(sender, validatorKey, withdrawalKey.getPublicKey(), params.amount));\n+      } finally {\n+        if (!encryptKeys && !printOnStandardOut) {\n+          // write keys yaml to file\n+          Files.writeString(Path.of(outputFile), yamlStringBuilder.toString());\n         }\n       }\n-      SafeFuture.allOf(futures.toArray(SafeFuture[]::new)).get(2, TimeUnit.MINUTES);\n+\n+      waitForTransactionReceipts(futures);\n     } catch (final Throwable t) {\n       STDOUT.log(\n           Level.FATAL,\n           \"Failed to send deposit transaction: \" + t.getClass() + \": \" + t.getMessage());\n-      System.exit(1); // Web3J creates a non-daemon thread we can't shut down. :(\n+      exit(1);\n     }\n-    System.exit(0); // Web3J creates a non-daemon thread we can't shut down. :(\n+    exit(0);\n+  }\n+\n+  @VisibleForTesting\n+  void waitForTransactionReceipts(final List<SafeFuture<TransactionReceipt>> futures)\n+      throws InterruptedException, ExecutionException, TimeoutException {\n+    SafeFuture.allOf(futures.toArray(SafeFuture[]::new)).get(2, TimeUnit.MINUTES);\n+  }\n+\n+  @VisibleForTesting\n+  void exit(final int status) {\n+    System.exit(status); // Web3J creates a non-daemon thread we can't shut down. :(\n+  }\n+\n+  private String getYamlFormattedString(final Pair<BLSKeyPair, BLSKeyPair> keyPair) {\n+    return String.format(\n+        \"- {privkey: '%s', pubkey: '%s', withdrawalPrivkey: '%s', withdrawalPubkey: '%s'}\",\n+        keyPair.getLeft().getSecretKey().getSecretKey().toBytes(),\n+        keyPair.getLeft().getPublicKey().toBytesCompressed(),\n+        keyPair.getRight().getSecretKey().getSecretKey().toBytes(),\n+        keyPair.getRight().getPublicKey().toBytesCompressed());\n+  }\n+\n+  private void generateKeystores(\n+      final Pair<BLSKeyPair, BLSKeyPair> keyPair,\n+      final Path keyStoreOutputDirectory,\n+      final int counter) {\n+    generateKeystore(keyPair.getLeft(), keyStoreOutputDirectory, \"validator\", counter);\n+    generateKeystore(keyPair.getRight(), keyStoreOutputDirectory, \"withdrawal\", counter);\n+  }\n+\n+  private void generateKeystore(\n+      final BLSKeyPair key, final Path outputDir, final String prefix, final int counter) {\n+    try {\n+      final KdfParam kdfParam = new SCryptParam(32, Bytes32.random());\n+      final Cipher cipher = new Cipher(CipherFunction.AES_128_CTR, Bytes.random(16));\n+      final String randomPassword = generateRandomHexToken();\n+      final KeyStoreData keyStoreData =\n+          KeyStore.encrypt(\n+              key.getSecretKey().getSecretKey().toBytes(),\n+              generateRandomHexToken(),\n+              \"\",\n+              kdfParam,\n+              cipher);\n+\n+      // create sub directory\n+      final Path keystoreDirectory =\n+          Files.createDirectories(outputDir.resolve(\"validator_\" + counter));\n+\n+      // save keystore\n+      KeyStoreLoader.saveToFile(\n+          keystoreDirectory.resolve(prefix + \"_keystore_\" + counter + \".json\"), keyStoreData);\n+\n+      // save password\n+      Files.writeString(\n+          keystoreDirectory.resolve(prefix + \"_password_\" + counter + \".txt\"), randomPassword);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0MDk5OA=="}, "originalCommit": {"oid": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0"}, "originalPosition": 213}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTU1ODUzNA==", "bodyText": "The interactive mode is now supported, along with reading values from environment variable as well as from a file.\n--validator-password\n--validator-password:env\n--validator-password:file", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r389558534", "createdAt": "2020-03-09T09:57:02Z", "author": {"login": "usmansaleem"}, "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "diffHunk": "@@ -81,44 +99,144 @@ public void generate(\n           int validatorCount,\n       @Option(\n               names = {\"--output-file\", \"-o\"},\n+              paramLabel = \"<FILE>\",\n               description =\n-                  \"File to write validator keys to. Keys are printed to std out if not specified\")\n-          String outputFile) {\n+                  \"File to write unencrypted validator keys to. Keys are printed to std out if not specified\")\n+          String outputFile,\n+      @Option(\n+              names = {\"--encrypt-keys\", \"-e\"},\n+              defaultValue = \"false\",\n+              paramLabel = \"<TRUE|FALSE>\",\n+              description = \"Encrypt validator keys. (Default: false)\",\n+              arity = \"1\")\n+          boolean encryptKeys,\n+      @Option(\n+              names = {\"--keystore-output-dir\", \"-k\"},\n+              paramLabel = \"<PATH>\",\n+              description =\n+                  \"Encrypted keystore output directory. Use current directory if not specified\")\n+          String keystorePath) {\n+\n     try (params) {\n+      // generate BLS validator key and withdrawal key\n+      final List<Pair<BLSKeyPair, BLSKeyPair>> validatorKeyPairs =\n+          IntStream.range(0, validatorCount)\n+              .mapToObj(value -> Pair.of(BLSKeyPair.random(), BLSKeyPair.random()))\n+              .collect(Collectors.toList());\n+\n       final DepositTransactionSender sender = params.createTransactionSender();\n-      final List<SafeFuture<TransactionReceipt>> futures = new ArrayList<>();\n \n-      final PrintStream keyWriter;\n-      if (outputFile == null || outputFile.isBlank()) {\n-        keyWriter = System.out;\n-      } else {\n-        keyWriter = new PrintStream(new FileOutputStream(outputFile), true, StandardCharsets.UTF_8);\n-      }\n+      final StringBuilder yamlStringBuilder = new StringBuilder();\n+      final boolean printOnStandardOut = outputFile == null || outputFile.isBlank();\n+      final Path keyStoreOutputDirectory =\n+          keystorePath == null || keystorePath.isBlank() ? Path.of(\".\") : Path.of(keystorePath);\n+      final AtomicInteger counterSuffix = new AtomicInteger(0);\n+      final List<SafeFuture<TransactionReceipt>> futures;\n+      try {\n+        futures =\n+            validatorKeyPairs.stream()\n+                .map(\n+                    keyPair -> {\n+                      final String yamlFormattedString = getYamlFormattedString(keyPair);\n+                      if (encryptKeys) {\n+                        generateKeystores(\n+                            keyPair, keyStoreOutputDirectory, counterSuffix.incrementAndGet());\n+                      } else if (printOnStandardOut) {\n+                        System.out.println(yamlFormattedString);\n+                      } else {\n+                        yamlStringBuilder\n+                            .append(yamlFormattedString)\n+                            .append(System.lineSeparator());\n+                      }\n+\n+                      return sendDeposit(\n+                          sender,\n+                          keyPair.getLeft(),\n+                          keyPair.getRight().getPublicKey(),\n+                          params.amount);\n+                    })\n+                .collect(Collectors.toList());\n \n-      try (keyWriter) {\n-        for (int i = 0; i < validatorCount; i++) {\n-          final BLSKeyPair validatorKey = BLSKeyPair.random();\n-          final BLSKeyPair withdrawalKey = BLSKeyPair.random();\n-\n-          keyWriter.println(\n-              String.format(\n-                  \"- {privkey: '%s', pubkey: '%s', withdrawalPrivkey: '%s', withdrawalPubkey: '%s'}\",\n-                  validatorKey.getSecretKey().getSecretKey().toBytes(),\n-                  validatorKey.getPublicKey().toBytesCompressed(),\n-                  withdrawalKey.getSecretKey().getSecretKey().toBytes(),\n-                  withdrawalKey.getPublicKey().toBytesCompressed()));\n-          futures.add(\n-              sendDeposit(sender, validatorKey, withdrawalKey.getPublicKey(), params.amount));\n+      } finally {\n+        if (!encryptKeys && !printOnStandardOut) {\n+          // write keys yaml to file\n+          Files.writeString(Path.of(outputFile), yamlStringBuilder.toString());\n         }\n       }\n-      SafeFuture.allOf(futures.toArray(SafeFuture[]::new)).get(2, TimeUnit.MINUTES);\n+\n+      waitForTransactionReceipts(futures);\n     } catch (final Throwable t) {\n       STDOUT.log(\n           Level.FATAL,\n           \"Failed to send deposit transaction: \" + t.getClass() + \": \" + t.getMessage());\n-      System.exit(1); // Web3J creates a non-daemon thread we can't shut down. :(\n+      exit(1);\n     }\n-    System.exit(0); // Web3J creates a non-daemon thread we can't shut down. :(\n+    exit(0);\n+  }\n+\n+  @VisibleForTesting\n+  void waitForTransactionReceipts(final List<SafeFuture<TransactionReceipt>> futures)\n+      throws InterruptedException, ExecutionException, TimeoutException {\n+    SafeFuture.allOf(futures.toArray(SafeFuture[]::new)).get(2, TimeUnit.MINUTES);\n+  }\n+\n+  @VisibleForTesting\n+  void exit(final int status) {\n+    System.exit(status); // Web3J creates a non-daemon thread we can't shut down. :(\n+  }\n+\n+  private String getYamlFormattedString(final Pair<BLSKeyPair, BLSKeyPair> keyPair) {\n+    return String.format(\n+        \"- {privkey: '%s', pubkey: '%s', withdrawalPrivkey: '%s', withdrawalPubkey: '%s'}\",\n+        keyPair.getLeft().getSecretKey().getSecretKey().toBytes(),\n+        keyPair.getLeft().getPublicKey().toBytesCompressed(),\n+        keyPair.getRight().getSecretKey().getSecretKey().toBytes(),\n+        keyPair.getRight().getPublicKey().toBytesCompressed());\n+  }\n+\n+  private void generateKeystores(\n+      final Pair<BLSKeyPair, BLSKeyPair> keyPair,\n+      final Path keyStoreOutputDirectory,\n+      final int counter) {\n+    generateKeystore(keyPair.getLeft(), keyStoreOutputDirectory, \"validator\", counter);\n+    generateKeystore(keyPair.getRight(), keyStoreOutputDirectory, \"withdrawal\", counter);\n+  }\n+\n+  private void generateKeystore(\n+      final BLSKeyPair key, final Path outputDir, final String prefix, final int counter) {\n+    try {\n+      final KdfParam kdfParam = new SCryptParam(32, Bytes32.random());\n+      final Cipher cipher = new Cipher(CipherFunction.AES_128_CTR, Bytes.random(16));\n+      final String randomPassword = generateRandomHexToken();\n+      final KeyStoreData keyStoreData =\n+          KeyStore.encrypt(\n+              key.getSecretKey().getSecretKey().toBytes(),\n+              generateRandomHexToken(),\n+              \"\",\n+              kdfParam,\n+              cipher);\n+\n+      // create sub directory\n+      final Path keystoreDirectory =\n+          Files.createDirectories(outputDir.resolve(\"validator_\" + counter));\n+\n+      // save keystore\n+      KeyStoreLoader.saveToFile(\n+          keystoreDirectory.resolve(prefix + \"_keystore_\" + counter + \".json\"), keyStoreData);\n+\n+      // save password\n+      Files.writeString(\n+          keystoreDirectory.resolve(prefix + \"_password_\" + counter + \".txt\"), randomPassword);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0MDk5OA=="}, "originalCommit": {"oid": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0"}, "originalPosition": 213}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNzg4Njg1OnYy", "diffSide": "RIGHT", "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwMDoyMzoyNVrOFyoyUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQwOTo1Nzo0N1rOFzgygw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0MTM2MA==", "bodyText": "It would be much better to use:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                return new BigInteger(1, token).toString(16); // hex encoding\n          \n          \n            \n                return Bytes.wrap(token).toHexString()", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388641360", "createdAt": "2020-03-06T00:23:25Z", "author": {"login": "ajsutton"}, "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "diffHunk": "@@ -81,44 +99,144 @@ public void generate(\n           int validatorCount,\n       @Option(\n               names = {\"--output-file\", \"-o\"},\n+              paramLabel = \"<FILE>\",\n               description =\n-                  \"File to write validator keys to. Keys are printed to std out if not specified\")\n-          String outputFile) {\n+                  \"File to write unencrypted validator keys to. Keys are printed to std out if not specified\")\n+          String outputFile,\n+      @Option(\n+              names = {\"--encrypt-keys\", \"-e\"},\n+              defaultValue = \"false\",\n+              paramLabel = \"<TRUE|FALSE>\",\n+              description = \"Encrypt validator keys. (Default: false)\",\n+              arity = \"1\")\n+          boolean encryptKeys,\n+      @Option(\n+              names = {\"--keystore-output-dir\", \"-k\"},\n+              paramLabel = \"<PATH>\",\n+              description =\n+                  \"Encrypted keystore output directory. Use current directory if not specified\")\n+          String keystorePath) {\n+\n     try (params) {\n+      // generate BLS validator key and withdrawal key\n+      final List<Pair<BLSKeyPair, BLSKeyPair>> validatorKeyPairs =\n+          IntStream.range(0, validatorCount)\n+              .mapToObj(value -> Pair.of(BLSKeyPair.random(), BLSKeyPair.random()))\n+              .collect(Collectors.toList());\n+\n       final DepositTransactionSender sender = params.createTransactionSender();\n-      final List<SafeFuture<TransactionReceipt>> futures = new ArrayList<>();\n \n-      final PrintStream keyWriter;\n-      if (outputFile == null || outputFile.isBlank()) {\n-        keyWriter = System.out;\n-      } else {\n-        keyWriter = new PrintStream(new FileOutputStream(outputFile), true, StandardCharsets.UTF_8);\n-      }\n+      final StringBuilder yamlStringBuilder = new StringBuilder();\n+      final boolean printOnStandardOut = outputFile == null || outputFile.isBlank();\n+      final Path keyStoreOutputDirectory =\n+          keystorePath == null || keystorePath.isBlank() ? Path.of(\".\") : Path.of(keystorePath);\n+      final AtomicInteger counterSuffix = new AtomicInteger(0);\n+      final List<SafeFuture<TransactionReceipt>> futures;\n+      try {\n+        futures =\n+            validatorKeyPairs.stream()\n+                .map(\n+                    keyPair -> {\n+                      final String yamlFormattedString = getYamlFormattedString(keyPair);\n+                      if (encryptKeys) {\n+                        generateKeystores(\n+                            keyPair, keyStoreOutputDirectory, counterSuffix.incrementAndGet());\n+                      } else if (printOnStandardOut) {\n+                        System.out.println(yamlFormattedString);\n+                      } else {\n+                        yamlStringBuilder\n+                            .append(yamlFormattedString)\n+                            .append(System.lineSeparator());\n+                      }\n+\n+                      return sendDeposit(\n+                          sender,\n+                          keyPair.getLeft(),\n+                          keyPair.getRight().getPublicKey(),\n+                          params.amount);\n+                    })\n+                .collect(Collectors.toList());\n \n-      try (keyWriter) {\n-        for (int i = 0; i < validatorCount; i++) {\n-          final BLSKeyPair validatorKey = BLSKeyPair.random();\n-          final BLSKeyPair withdrawalKey = BLSKeyPair.random();\n-\n-          keyWriter.println(\n-              String.format(\n-                  \"- {privkey: '%s', pubkey: '%s', withdrawalPrivkey: '%s', withdrawalPubkey: '%s'}\",\n-                  validatorKey.getSecretKey().getSecretKey().toBytes(),\n-                  validatorKey.getPublicKey().toBytesCompressed(),\n-                  withdrawalKey.getSecretKey().getSecretKey().toBytes(),\n-                  withdrawalKey.getPublicKey().toBytesCompressed()));\n-          futures.add(\n-              sendDeposit(sender, validatorKey, withdrawalKey.getPublicKey(), params.amount));\n+      } finally {\n+        if (!encryptKeys && !printOnStandardOut) {\n+          // write keys yaml to file\n+          Files.writeString(Path.of(outputFile), yamlStringBuilder.toString());\n         }\n       }\n-      SafeFuture.allOf(futures.toArray(SafeFuture[]::new)).get(2, TimeUnit.MINUTES);\n+\n+      waitForTransactionReceipts(futures);\n     } catch (final Throwable t) {\n       STDOUT.log(\n           Level.FATAL,\n           \"Failed to send deposit transaction: \" + t.getClass() + \": \" + t.getMessage());\n-      System.exit(1); // Web3J creates a non-daemon thread we can't shut down. :(\n+      exit(1);\n     }\n-    System.exit(0); // Web3J creates a non-daemon thread we can't shut down. :(\n+    exit(0);\n+  }\n+\n+  @VisibleForTesting\n+  void waitForTransactionReceipts(final List<SafeFuture<TransactionReceipt>> futures)\n+      throws InterruptedException, ExecutionException, TimeoutException {\n+    SafeFuture.allOf(futures.toArray(SafeFuture[]::new)).get(2, TimeUnit.MINUTES);\n+  }\n+\n+  @VisibleForTesting\n+  void exit(final int status) {\n+    System.exit(status); // Web3J creates a non-daemon thread we can't shut down. :(\n+  }\n+\n+  private String getYamlFormattedString(final Pair<BLSKeyPair, BLSKeyPair> keyPair) {\n+    return String.format(\n+        \"- {privkey: '%s', pubkey: '%s', withdrawalPrivkey: '%s', withdrawalPubkey: '%s'}\",\n+        keyPair.getLeft().getSecretKey().getSecretKey().toBytes(),\n+        keyPair.getLeft().getPublicKey().toBytesCompressed(),\n+        keyPair.getRight().getSecretKey().getSecretKey().toBytes(),\n+        keyPair.getRight().getPublicKey().toBytesCompressed());\n+  }\n+\n+  private void generateKeystores(\n+      final Pair<BLSKeyPair, BLSKeyPair> keyPair,\n+      final Path keyStoreOutputDirectory,\n+      final int counter) {\n+    generateKeystore(keyPair.getLeft(), keyStoreOutputDirectory, \"validator\", counter);\n+    generateKeystore(keyPair.getRight(), keyStoreOutputDirectory, \"withdrawal\", counter);\n+  }\n+\n+  private void generateKeystore(\n+      final BLSKeyPair key, final Path outputDir, final String prefix, final int counter) {\n+    try {\n+      final KdfParam kdfParam = new SCryptParam(32, Bytes32.random());\n+      final Cipher cipher = new Cipher(CipherFunction.AES_128_CTR, Bytes.random(16));\n+      final String randomPassword = generateRandomHexToken();\n+      final KeyStoreData keyStoreData =\n+          KeyStore.encrypt(\n+              key.getSecretKey().getSecretKey().toBytes(),\n+              generateRandomHexToken(),\n+              \"\",\n+              kdfParam,\n+              cipher);\n+\n+      // create sub directory\n+      final Path keystoreDirectory =\n+          Files.createDirectories(outputDir.resolve(\"validator_\" + counter));\n+\n+      // save keystore\n+      KeyStoreLoader.saveToFile(\n+          keystoreDirectory.resolve(prefix + \"_keystore_\" + counter + \".json\"), keyStoreData);\n+\n+      // save password\n+      Files.writeString(\n+          keystoreDirectory.resolve(prefix + \"_password_\" + counter + \".txt\"), randomPassword);\n+    } catch (final IOException e) {\n+      throw new UncheckedIOException(e);\n+    }\n+  }\n+\n+  private String generateRandomHexToken() {\n+    final SecureRandom secureRandom = SecureRandomProvider.createSecureRandom();\n+    byte[] token = new byte[32];\n+    secureRandom.nextBytes(token);\n+    return new BigInteger(1, token).toString(16); // hex encoding", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0"}, "originalPosition": 223}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTU1ODkxNQ==", "bodyText": "This method has been removed.", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r389558915", "createdAt": "2020-03-09T09:57:47Z", "author": {"login": "usmansaleem"}, "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "diffHunk": "@@ -81,44 +99,144 @@ public void generate(\n           int validatorCount,\n       @Option(\n               names = {\"--output-file\", \"-o\"},\n+              paramLabel = \"<FILE>\",\n               description =\n-                  \"File to write validator keys to. Keys are printed to std out if not specified\")\n-          String outputFile) {\n+                  \"File to write unencrypted validator keys to. Keys are printed to std out if not specified\")\n+          String outputFile,\n+      @Option(\n+              names = {\"--encrypt-keys\", \"-e\"},\n+              defaultValue = \"false\",\n+              paramLabel = \"<TRUE|FALSE>\",\n+              description = \"Encrypt validator keys. (Default: false)\",\n+              arity = \"1\")\n+          boolean encryptKeys,\n+      @Option(\n+              names = {\"--keystore-output-dir\", \"-k\"},\n+              paramLabel = \"<PATH>\",\n+              description =\n+                  \"Encrypted keystore output directory. Use current directory if not specified\")\n+          String keystorePath) {\n+\n     try (params) {\n+      // generate BLS validator key and withdrawal key\n+      final List<Pair<BLSKeyPair, BLSKeyPair>> validatorKeyPairs =\n+          IntStream.range(0, validatorCount)\n+              .mapToObj(value -> Pair.of(BLSKeyPair.random(), BLSKeyPair.random()))\n+              .collect(Collectors.toList());\n+\n       final DepositTransactionSender sender = params.createTransactionSender();\n-      final List<SafeFuture<TransactionReceipt>> futures = new ArrayList<>();\n \n-      final PrintStream keyWriter;\n-      if (outputFile == null || outputFile.isBlank()) {\n-        keyWriter = System.out;\n-      } else {\n-        keyWriter = new PrintStream(new FileOutputStream(outputFile), true, StandardCharsets.UTF_8);\n-      }\n+      final StringBuilder yamlStringBuilder = new StringBuilder();\n+      final boolean printOnStandardOut = outputFile == null || outputFile.isBlank();\n+      final Path keyStoreOutputDirectory =\n+          keystorePath == null || keystorePath.isBlank() ? Path.of(\".\") : Path.of(keystorePath);\n+      final AtomicInteger counterSuffix = new AtomicInteger(0);\n+      final List<SafeFuture<TransactionReceipt>> futures;\n+      try {\n+        futures =\n+            validatorKeyPairs.stream()\n+                .map(\n+                    keyPair -> {\n+                      final String yamlFormattedString = getYamlFormattedString(keyPair);\n+                      if (encryptKeys) {\n+                        generateKeystores(\n+                            keyPair, keyStoreOutputDirectory, counterSuffix.incrementAndGet());\n+                      } else if (printOnStandardOut) {\n+                        System.out.println(yamlFormattedString);\n+                      } else {\n+                        yamlStringBuilder\n+                            .append(yamlFormattedString)\n+                            .append(System.lineSeparator());\n+                      }\n+\n+                      return sendDeposit(\n+                          sender,\n+                          keyPair.getLeft(),\n+                          keyPair.getRight().getPublicKey(),\n+                          params.amount);\n+                    })\n+                .collect(Collectors.toList());\n \n-      try (keyWriter) {\n-        for (int i = 0; i < validatorCount; i++) {\n-          final BLSKeyPair validatorKey = BLSKeyPair.random();\n-          final BLSKeyPair withdrawalKey = BLSKeyPair.random();\n-\n-          keyWriter.println(\n-              String.format(\n-                  \"- {privkey: '%s', pubkey: '%s', withdrawalPrivkey: '%s', withdrawalPubkey: '%s'}\",\n-                  validatorKey.getSecretKey().getSecretKey().toBytes(),\n-                  validatorKey.getPublicKey().toBytesCompressed(),\n-                  withdrawalKey.getSecretKey().getSecretKey().toBytes(),\n-                  withdrawalKey.getPublicKey().toBytesCompressed()));\n-          futures.add(\n-              sendDeposit(sender, validatorKey, withdrawalKey.getPublicKey(), params.amount));\n+      } finally {\n+        if (!encryptKeys && !printOnStandardOut) {\n+          // write keys yaml to file\n+          Files.writeString(Path.of(outputFile), yamlStringBuilder.toString());\n         }\n       }\n-      SafeFuture.allOf(futures.toArray(SafeFuture[]::new)).get(2, TimeUnit.MINUTES);\n+\n+      waitForTransactionReceipts(futures);\n     } catch (final Throwable t) {\n       STDOUT.log(\n           Level.FATAL,\n           \"Failed to send deposit transaction: \" + t.getClass() + \": \" + t.getMessage());\n-      System.exit(1); // Web3J creates a non-daemon thread we can't shut down. :(\n+      exit(1);\n     }\n-    System.exit(0); // Web3J creates a non-daemon thread we can't shut down. :(\n+    exit(0);\n+  }\n+\n+  @VisibleForTesting\n+  void waitForTransactionReceipts(final List<SafeFuture<TransactionReceipt>> futures)\n+      throws InterruptedException, ExecutionException, TimeoutException {\n+    SafeFuture.allOf(futures.toArray(SafeFuture[]::new)).get(2, TimeUnit.MINUTES);\n+  }\n+\n+  @VisibleForTesting\n+  void exit(final int status) {\n+    System.exit(status); // Web3J creates a non-daemon thread we can't shut down. :(\n+  }\n+\n+  private String getYamlFormattedString(final Pair<BLSKeyPair, BLSKeyPair> keyPair) {\n+    return String.format(\n+        \"- {privkey: '%s', pubkey: '%s', withdrawalPrivkey: '%s', withdrawalPubkey: '%s'}\",\n+        keyPair.getLeft().getSecretKey().getSecretKey().toBytes(),\n+        keyPair.getLeft().getPublicKey().toBytesCompressed(),\n+        keyPair.getRight().getSecretKey().getSecretKey().toBytes(),\n+        keyPair.getRight().getPublicKey().toBytesCompressed());\n+  }\n+\n+  private void generateKeystores(\n+      final Pair<BLSKeyPair, BLSKeyPair> keyPair,\n+      final Path keyStoreOutputDirectory,\n+      final int counter) {\n+    generateKeystore(keyPair.getLeft(), keyStoreOutputDirectory, \"validator\", counter);\n+    generateKeystore(keyPair.getRight(), keyStoreOutputDirectory, \"withdrawal\", counter);\n+  }\n+\n+  private void generateKeystore(\n+      final BLSKeyPair key, final Path outputDir, final String prefix, final int counter) {\n+    try {\n+      final KdfParam kdfParam = new SCryptParam(32, Bytes32.random());\n+      final Cipher cipher = new Cipher(CipherFunction.AES_128_CTR, Bytes.random(16));\n+      final String randomPassword = generateRandomHexToken();\n+      final KeyStoreData keyStoreData =\n+          KeyStore.encrypt(\n+              key.getSecretKey().getSecretKey().toBytes(),\n+              generateRandomHexToken(),\n+              \"\",\n+              kdfParam,\n+              cipher);\n+\n+      // create sub directory\n+      final Path keystoreDirectory =\n+          Files.createDirectories(outputDir.resolve(\"validator_\" + counter));\n+\n+      // save keystore\n+      KeyStoreLoader.saveToFile(\n+          keystoreDirectory.resolve(prefix + \"_keystore_\" + counter + \".json\"), keyStoreData);\n+\n+      // save password\n+      Files.writeString(\n+          keystoreDirectory.resolve(prefix + \"_password_\" + counter + \".txt\"), randomPassword);\n+    } catch (final IOException e) {\n+      throw new UncheckedIOException(e);\n+    }\n+  }\n+\n+  private String generateRandomHexToken() {\n+    final SecureRandom secureRandom = SecureRandomProvider.createSecureRandom();\n+    byte[] token = new byte[32];\n+    secureRandom.nextBytes(token);\n+    return new BigInteger(1, token).toString(16); // hex encoding", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0MTM2MA=="}, "originalCommit": {"oid": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0"}, "originalPosition": 223}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNzg5MDU2OnYy", "diffSide": "RIGHT", "path": "artemis/src/test/java/tech/pegasys/artemis/DepositCommandTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwMDoyNToyMlrOFyo0vA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwMjowNDozNlrOFyq-Bg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0MTk4MA==", "bodyText": "Using a spy for the class under test is really unpleasant.\nWe also normally use the Mockito static methods instead of the @Mock annotations. Not for any particular reason, but it's pretty consistent so seems worth sticking with it.", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388641980", "createdAt": "2020-03-06T00:25:22Z", "author": {"login": "ajsutton"}, "path": "artemis/src/test/java/tech/pegasys/artemis/DepositCommandTest.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+\n+import java.io.File;\n+import java.nio.file.Path;\n+import java.util.stream.IntStream;\n+import org.assertj.core.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import tech.pegasys.artemis.services.powchain.DepositTransactionSender;\n+\n+@ExtendWith(MockitoExtension.class)\n+class DepositCommandTest {\n+  private static final int VALIDATORS_COUNT = 2;\n+  @Mock private DepositCommand.CommonParams commonParams;\n+  @Mock private DepositTransactionSender depositTransactionSender;\n+  @Spy private DepositCommand depositCommand = new DepositCommand();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY3NzEyNg==", "bodyText": "The unit test code has been updated as per the suggestions.", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388677126", "createdAt": "2020-03-06T02:04:36Z", "author": {"login": "usmansaleem"}, "path": "artemis/src/test/java/tech/pegasys/artemis/DepositCommandTest.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+\n+import java.io.File;\n+import java.nio.file.Path;\n+import java.util.stream.IntStream;\n+import org.assertj.core.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import tech.pegasys.artemis.services.powchain.DepositTransactionSender;\n+\n+@ExtendWith(MockitoExtension.class)\n+class DepositCommandTest {\n+  private static final int VALIDATORS_COUNT = 2;\n+  @Mock private DepositCommand.CommonParams commonParams;\n+  @Mock private DepositTransactionSender depositTransactionSender;\n+  @Spy private DepositCommand depositCommand = new DepositCommand();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0MTk4MA=="}, "originalCommit": {"oid": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNzg5OTYwOnYy", "diffSide": "RIGHT", "path": "artemis/src/test/java/tech/pegasys/artemis/DepositCommandTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwMDoyODozOVrOFyo5kw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwMjowNDo1MlrOFyq-PA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0MzIxOQ==", "bodyText": "This should be able to use the when format:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                doReturn(depositTransactionSender).when(commonParams).createTransactionSender();\n          \n          \n            \n                when(commonParams.createTransactionSender()).thenReturn(depositTransactionSender);\n          \n      \n    \n    \n  \n\nThat way we get type checking done by the compiler.", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388643219", "createdAt": "2020-03-06T00:28:39Z", "author": {"login": "ajsutton"}, "path": "artemis/src/test/java/tech/pegasys/artemis/DepositCommandTest.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+\n+import java.io.File;\n+import java.nio.file.Path;\n+import java.util.stream.IntStream;\n+import org.assertj.core.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import tech.pegasys.artemis.services.powchain.DepositTransactionSender;\n+\n+@ExtendWith(MockitoExtension.class)\n+class DepositCommandTest {\n+  private static final int VALIDATORS_COUNT = 2;\n+  @Mock private DepositCommand.CommonParams commonParams;\n+  @Mock private DepositTransactionSender depositTransactionSender;\n+  @Spy private DepositCommand depositCommand = new DepositCommand();\n+\n+  @Test\n+  void encryptedKeystoresAreCreated(@TempDir final Path tempDir) throws Exception {\n+    doReturn(depositTransactionSender).when(commonParams).createTransactionSender();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY3NzE4MA==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388677180", "createdAt": "2020-03-06T02:04:52Z", "author": {"login": "usmansaleem"}, "path": "artemis/src/test/java/tech/pegasys/artemis/DepositCommandTest.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+\n+import java.io.File;\n+import java.nio.file.Path;\n+import java.util.stream.IntStream;\n+import org.assertj.core.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import tech.pegasys.artemis.services.powchain.DepositTransactionSender;\n+\n+@ExtendWith(MockitoExtension.class)\n+class DepositCommandTest {\n+  private static final int VALIDATORS_COUNT = 2;\n+  @Mock private DepositCommand.CommonParams commonParams;\n+  @Mock private DepositTransactionSender depositTransactionSender;\n+  @Spy private DepositCommand depositCommand = new DepositCommand();\n+\n+  @Test\n+  void encryptedKeystoresAreCreated(@TempDir final Path tempDir) throws Exception {\n+    doReturn(depositTransactionSender).when(commonParams).createTransactionSender();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0MzIxOQ=="}, "originalCommit": {"oid": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNzkwMDc5OnYy", "diffSide": "RIGHT", "path": "artemis/src/test/java/tech/pegasys/artemis/DepositCommandTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwMDoyOTowMVrOFyo6MA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwMjowNToyMFrOFyq-mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0MzM3Ng==", "bodyText": "The mock transaction sender should just return completed futures and you won't need to override this.", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388643376", "createdAt": "2020-03-06T00:29:01Z", "author": {"login": "ajsutton"}, "path": "artemis/src/test/java/tech/pegasys/artemis/DepositCommandTest.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+\n+import java.io.File;\n+import java.nio.file.Path;\n+import java.util.stream.IntStream;\n+import org.assertj.core.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import tech.pegasys.artemis.services.powchain.DepositTransactionSender;\n+\n+@ExtendWith(MockitoExtension.class)\n+class DepositCommandTest {\n+  private static final int VALIDATORS_COUNT = 2;\n+  @Mock private DepositCommand.CommonParams commonParams;\n+  @Mock private DepositTransactionSender depositTransactionSender;\n+  @Spy private DepositCommand depositCommand = new DepositCommand();\n+\n+  @Test\n+  void encryptedKeystoresAreCreated(@TempDir final Path tempDir) throws Exception {\n+    doReturn(depositTransactionSender).when(commonParams).createTransactionSender();\n+    doNothing().when(depositCommand).waitForTransactionReceipts(any());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY3NzI3NQ==", "bodyText": "Thanks for the hint, I was having some trouble with it :). It's sorted out now.", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388677275", "createdAt": "2020-03-06T02:05:20Z", "author": {"login": "usmansaleem"}, "path": "artemis/src/test/java/tech/pegasys/artemis/DepositCommandTest.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+\n+import java.io.File;\n+import java.nio.file.Path;\n+import java.util.stream.IntStream;\n+import org.assertj.core.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import tech.pegasys.artemis.services.powchain.DepositTransactionSender;\n+\n+@ExtendWith(MockitoExtension.class)\n+class DepositCommandTest {\n+  private static final int VALIDATORS_COUNT = 2;\n+  @Mock private DepositCommand.CommonParams commonParams;\n+  @Mock private DepositTransactionSender depositTransactionSender;\n+  @Spy private DepositCommand depositCommand = new DepositCommand();\n+\n+  @Test\n+  void encryptedKeystoresAreCreated(@TempDir final Path tempDir) throws Exception {\n+    doReturn(depositTransactionSender).when(commonParams).createTransactionSender();\n+    doNothing().when(depositCommand).waitForTransactionReceipts(any());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0MzM3Ng=="}, "originalCommit": {"oid": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNzkwMjQ2OnYy", "diffSide": "RIGHT", "path": "artemis/src/test/java/tech/pegasys/artemis/DepositCommandTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwMDoyOTozM1rOFyo7Dg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQwOTo1ODowOVrOFzgzXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0MzU5OA==", "bodyText": "Is it worth checking we can actually decrypt the keystore?", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388643598", "createdAt": "2020-03-06T00:29:33Z", "author": {"login": "ajsutton"}, "path": "artemis/src/test/java/tech/pegasys/artemis/DepositCommandTest.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+\n+import java.io.File;\n+import java.nio.file.Path;\n+import java.util.stream.IntStream;\n+import org.assertj.core.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import tech.pegasys.artemis.services.powchain.DepositTransactionSender;\n+\n+@ExtendWith(MockitoExtension.class)\n+class DepositCommandTest {\n+  private static final int VALIDATORS_COUNT = 2;\n+  @Mock private DepositCommand.CommonParams commonParams;\n+  @Mock private DepositTransactionSender depositTransactionSender;\n+  @Spy private DepositCommand depositCommand = new DepositCommand();\n+\n+  @Test\n+  void encryptedKeystoresAreCreated(@TempDir final Path tempDir) throws Exception {\n+    doReturn(depositTransactionSender).when(commonParams).createTransactionSender();\n+    doNothing().when(depositCommand).waitForTransactionReceipts(any());\n+    doNothing().when(depositCommand).exit(0);\n+\n+    depositCommand.generate(commonParams, VALIDATORS_COUNT, \"\", true, tempDir.toString());\n+\n+    // assert that sub directories exist\n+    final File[] subDirectories =\n+        IntStream.range(1, VALIDATORS_COUNT + 1)\n+            .mapToObj(i -> tempDir.resolve(\"validator_\" + i).toFile())\n+            .toArray(File[]::new);\n+    Assertions.assertThat(tempDir.toFile().listFiles()).containsExactlyInAnyOrder(subDirectories);\n+\n+    for (int i = 0; i < subDirectories.length; i++) {\n+      assertKeyStoreAndPasswordExist(subDirectories[i].toPath(), i + 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTU1OTEzMg==", "bodyText": "The tests are now decrypting the keystore.", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r389559132", "createdAt": "2020-03-09T09:58:09Z", "author": {"login": "usmansaleem"}, "path": "artemis/src/test/java/tech/pegasys/artemis/DepositCommandTest.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis;\n+\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.doReturn;\n+\n+import java.io.File;\n+import java.nio.file.Path;\n+import java.util.stream.IntStream;\n+import org.assertj.core.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.api.io.TempDir;\n+import org.mockito.Mock;\n+import org.mockito.Spy;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import tech.pegasys.artemis.services.powchain.DepositTransactionSender;\n+\n+@ExtendWith(MockitoExtension.class)\n+class DepositCommandTest {\n+  private static final int VALIDATORS_COUNT = 2;\n+  @Mock private DepositCommand.CommonParams commonParams;\n+  @Mock private DepositTransactionSender depositTransactionSender;\n+  @Spy private DepositCommand depositCommand = new DepositCommand();\n+\n+  @Test\n+  void encryptedKeystoresAreCreated(@TempDir final Path tempDir) throws Exception {\n+    doReturn(depositTransactionSender).when(commonParams).createTransactionSender();\n+    doNothing().when(depositCommand).waitForTransactionReceipts(any());\n+    doNothing().when(depositCommand).exit(0);\n+\n+    depositCommand.generate(commonParams, VALIDATORS_COUNT, \"\", true, tempDir.toString());\n+\n+    // assert that sub directories exist\n+    final File[] subDirectories =\n+        IntStream.range(1, VALIDATORS_COUNT + 1)\n+            .mapToObj(i -> tempDir.resolve(\"validator_\" + i).toFile())\n+            .toArray(File[]::new);\n+    Assertions.assertThat(tempDir.toFile().listFiles()).containsExactlyInAnyOrder(subDirectories);\n+\n+    for (int i = 0; i < subDirectories.length; i++) {\n+      assertKeyStoreAndPasswordExist(subDirectories[i].toPath(), i + 1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0MzU5OA=="}, "originalCommit": {"oid": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwNzkwNzEwOnYy", "diffSide": "RIGHT", "path": "gradle/versions.gradle", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwMDozMToxMFrOFyo9pg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwMjowNjowMFrOFyq_NQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0NDI2Mg==", "bodyText": "We can avoid adding this dependency if we stay consistent with the Mockito.mock approach to creating mocks right?", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388644262", "createdAt": "2020-03-06T00:31:10Z", "author": {"login": "ajsutton"}, "path": "gradle/versions.gradle", "diffHunk": "@@ -84,7 +84,8 @@ dependencyManagement {\n     }\n \n     dependency 'org.mockito:mockito-core:3.1.0'\n-    \n+    dependency 'org.mockito:mockito-junit-jupiter:3.1.0'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY3NzQyOQ==", "bodyText": "reverted the dependency.", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r388677429", "createdAt": "2020-03-06T02:06:00Z", "author": {"login": "usmansaleem"}, "path": "gradle/versions.gradle", "diffHunk": "@@ -84,7 +84,8 @@ dependencyManagement {\n     }\n \n     dependency 'org.mockito:mockito-core:3.1.0'\n-    \n+    dependency 'org.mockito:mockito-junit-jupiter:3.1.0'", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODY0NDI2Mg=="}, "originalCommit": {"oid": "a967bf290bf0c284504f81b75ec5bb3299f0c6a0"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNjc5MjAxOnYy", "diffSide": "RIGHT", "path": "acceptance-tests/src/test-support/java/tech/pegasys/artemis/test/acceptance/dsl/ArtemisDepositSender.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQyMjoyNDo1OFrOFz7Z6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQwMTowMjoyOVrOFz-O9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk5NDk4NQ==", "bodyText": "This isn't the right approach.  If we're outputting to STDOUT, we need to make sure logging is either disabled or sent to STDERR.  Otherwise people who run this tool in real life will get corrupt output.", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r389994985", "createdAt": "2020-03-09T22:24:58Z", "author": {"login": "ajsutton"}, "path": "acceptance-tests/src/test-support/java/tech/pegasys/artemis/test/acceptance/dsl/ArtemisDepositSender.java", "diffHunk": "@@ -44,6 +47,11 @@ public String sendValidatorDeposits(final BesuNode eth1Node, final int numberOfV\n     container.start();\n     Waiter.waitFor(() -> assertThat(container.isRunning()).isFalse());\n     container.stop();\n-    return validatorKeys.toString();\n+    // because we have introduced some logging, only pick lines which start with a - {\n+    return validatorKeys\n+        .toString()\n+        .lines()\n+        .filter(s -> s.startsWith(\"- {\"))\n+        .collect(Collectors.joining(System.lineSeparator()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb4e4fced1d629777d6f8440fd26e8a158d4253d"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAyMjcxNw==", "bodyText": "It's because of the limitation of \"testcontainer\" docker API we are using that captures whole of standard/error output. A more better approach, which I tested, is to mount the \"keys\" file with --output-path and read that file after running the command. However, in Windows environment this usually cause an issue because we would have \"share\" the host location via docker preference. In another project of ours, we used user's home folder and create a temp directory there which can be mounted to docker container, I wonder if we can use same approach.\nLast, but not least, is that I can remove the \"info\" logging that I introduced so that it only outputs the yaml keys on std out.", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r390022717", "createdAt": "2020-03-09T23:51:10Z", "author": {"login": "usmansaleem"}, "path": "acceptance-tests/src/test-support/java/tech/pegasys/artemis/test/acceptance/dsl/ArtemisDepositSender.java", "diffHunk": "@@ -44,6 +47,11 @@ public String sendValidatorDeposits(final BesuNode eth1Node, final int numberOfV\n     container.start();\n     Waiter.waitFor(() -> assertThat(container.isRunning()).isFalse());\n     container.stop();\n-    return validatorKeys.toString();\n+    // because we have introduced some logging, only pick lines which start with a - {\n+    return validatorKeys\n+        .toString()\n+        .lines()\n+        .filter(s -> s.startsWith(\"- {\"))\n+        .collect(Collectors.joining(System.lineSeparator()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk5NDk4NQ=="}, "originalCommit": {"oid": "eb4e4fced1d629777d6f8440fd26e8a158d4253d"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAyMzQ0OA==", "bodyText": "It's not really docker related - if we're saying we'll output the content to STDOUT, we should only output the content to STDOUT but the logs are going there as well (they don't go to STDERR by default).  We can configure test containers to capture STDOUT and STDERR separately if need be.\nI suspect just removing the log messages is probably the simplest approach though.", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r390023448", "createdAt": "2020-03-09T23:53:58Z", "author": {"login": "ajsutton"}, "path": "acceptance-tests/src/test-support/java/tech/pegasys/artemis/test/acceptance/dsl/ArtemisDepositSender.java", "diffHunk": "@@ -44,6 +47,11 @@ public String sendValidatorDeposits(final BesuNode eth1Node, final int numberOfV\n     container.start();\n     Waiter.waitFor(() -> assertThat(container.isRunning()).isFalse());\n     container.stop();\n-    return validatorKeys.toString();\n+    // because we have introduced some logging, only pick lines which start with a - {\n+    return validatorKeys\n+        .toString()\n+        .lines()\n+        .filter(s -> s.startsWith(\"- {\"))\n+        .collect(Collectors.joining(System.lineSeparator()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk5NDk4NQ=="}, "originalCommit": {"oid": "eb4e4fced1d629777d6f8440fd26e8a158d4253d"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA0MTMzMg==", "bodyText": "Removed additional logging for \"yaml keys on standard out\" mode.", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r390041332", "createdAt": "2020-03-10T01:02:29Z", "author": {"login": "usmansaleem"}, "path": "acceptance-tests/src/test-support/java/tech/pegasys/artemis/test/acceptance/dsl/ArtemisDepositSender.java", "diffHunk": "@@ -44,6 +47,11 @@ public String sendValidatorDeposits(final BesuNode eth1Node, final int numberOfV\n     container.start();\n     Waiter.waitFor(() -> assertThat(container.isRunning()).isFalse());\n     container.stop();\n-    return validatorKeys.toString();\n+    // because we have introduced some logging, only pick lines which start with a - {\n+    return validatorKeys\n+        .toString()\n+        .lines()\n+        .filter(s -> s.startsWith(\"- {\"))\n+        .collect(Collectors.joining(System.lineSeparator()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk5NDk4NQ=="}, "originalCommit": {"oid": "eb4e4fced1d629777d6f8440fd26e8a158d4253d"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNjgwMjU1OnYy", "diffSide": "RIGHT", "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "isResolved": false, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQyMjoyOTozOFrOFz7gcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQwMDowMTo0NlrOFz9RrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk5NjY1Ng==", "bodyText": "colon in the arg name is weird. I'd have expected --validator-password-file. Might be possible to do it with a single --validator-password option - if no arg use interactive prompt, if it starts with env: treat as an environment variable and otherwise treat as a file path.  Not entirely sure that's a good idea though...\n@jakehaugen any thoughts?", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r389996656", "createdAt": "2020-03-09T22:29:38Z", "author": {"login": "ajsutton"}, "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "diffHunk": "@@ -80,45 +100,98 @@ public void generate(\n               defaultValue = \"1\")\n           int validatorCount,\n       @Option(\n-              names = {\"--output-file\", \"-o\"},\n+              names = {\"--output-path\", \"-o\"},\n+              paramLabel = \"<FILE|DIR>\",\n               description =\n-                  \"File to write validator keys to. Keys are printed to std out if not specified\")\n-          String outputFile) {\n+                  \"Path to output file for unencrypted keys or output directory for encrypted keystore files. If not set, unencrypted keys will be written on standard out and encrypted keystores will be created in current directory\")\n+          String outputPath,\n+      @Option(\n+              names = {\"--encrypt-keys\", \"-e\"},\n+              defaultValue = \"true\",\n+              paramLabel = \"<true|false>\",\n+              description = \"Encrypt validator and withdrawal keys. (Default: true)\",\n+              arity = \"1\")\n+          boolean encryptKeys,\n+      @Option(\n+              names = {\"--validator-password:file\"},", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb4e4fced1d629777d6f8440fd26e8a158d4253d"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAyMzE3NA==", "bodyText": "I picked the :file :env approach from PicoCLI's sample code. We can modify them as per our needs. https://github.com/remkop/picocli/blob/master/picocli-examples/src/main/java/picocli/examples/interactive/PasswordDemo.java", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r390023174", "createdAt": "2020-03-09T23:52:55Z", "author": {"login": "usmansaleem"}, "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "diffHunk": "@@ -80,45 +100,98 @@ public void generate(\n               defaultValue = \"1\")\n           int validatorCount,\n       @Option(\n-              names = {\"--output-file\", \"-o\"},\n+              names = {\"--output-path\", \"-o\"},\n+              paramLabel = \"<FILE|DIR>\",\n               description =\n-                  \"File to write validator keys to. Keys are printed to std out if not specified\")\n-          String outputFile) {\n+                  \"Path to output file for unencrypted keys or output directory for encrypted keystore files. If not set, unencrypted keys will be written on standard out and encrypted keystores will be created in current directory\")\n+          String outputPath,\n+      @Option(\n+              names = {\"--encrypt-keys\", \"-e\"},\n+              defaultValue = \"true\",\n+              paramLabel = \"<true|false>\",\n+              description = \"Encrypt validator and withdrawal keys. (Default: true)\",\n+              arity = \"1\")\n+          boolean encryptKeys,\n+      @Option(\n+              names = {\"--validator-password:file\"},", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk5NjY1Ng=="}, "originalCommit": {"oid": "eb4e4fced1d629777d6f8440fd26e8a158d4253d"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAyMzcwOA==", "bodyText": "Yeah I have no idea why they thought that was normal...", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r390023708", "createdAt": "2020-03-09T23:55:00Z", "author": {"login": "ajsutton"}, "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "diffHunk": "@@ -80,45 +100,98 @@ public void generate(\n               defaultValue = \"1\")\n           int validatorCount,\n       @Option(\n-              names = {\"--output-file\", \"-o\"},\n+              names = {\"--output-path\", \"-o\"},\n+              paramLabel = \"<FILE|DIR>\",\n               description =\n-                  \"File to write validator keys to. Keys are printed to std out if not specified\")\n-          String outputFile) {\n+                  \"Path to output file for unencrypted keys or output directory for encrypted keystore files. If not set, unencrypted keys will be written on standard out and encrypted keystores will be created in current directory\")\n+          String outputPath,\n+      @Option(\n+              names = {\"--encrypt-keys\", \"-e\"},\n+              defaultValue = \"true\",\n+              paramLabel = \"<true|false>\",\n+              description = \"Encrypt validator and withdrawal keys. (Default: true)\",\n+              arity = \"1\")\n+          boolean encryptKeys,\n+      @Option(\n+              names = {\"--validator-password:file\"},", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk5NjY1Ng=="}, "originalCommit": {"oid": "eb4e4fced1d629777d6f8440fd26e8a158d4253d"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAyNDM2NA==", "bodyText": "You are suggesting to use --stdin:validator-password, --env:validator-password, --file:validator-password as an alternative? Or simply use three mutually exclusive parameters? i.e. --validator-password-stdin, --validator-password-file, --validator-pasword-env?", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r390024364", "createdAt": "2020-03-09T23:57:22Z", "author": {"login": "usmansaleem"}, "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "diffHunk": "@@ -80,45 +100,98 @@ public void generate(\n               defaultValue = \"1\")\n           int validatorCount,\n       @Option(\n-              names = {\"--output-file\", \"-o\"},\n+              names = {\"--output-path\", \"-o\"},\n+              paramLabel = \"<FILE|DIR>\",\n               description =\n-                  \"File to write validator keys to. Keys are printed to std out if not specified\")\n-          String outputFile) {\n+                  \"Path to output file for unencrypted keys or output directory for encrypted keystore files. If not set, unencrypted keys will be written on standard out and encrypted keystores will be created in current directory\")\n+          String outputPath,\n+      @Option(\n+              names = {\"--encrypt-keys\", \"-e\"},\n+              defaultValue = \"true\",\n+              paramLabel = \"<true|false>\",\n+              description = \"Encrypt validator and withdrawal keys. (Default: true)\",\n+              arity = \"1\")\n+          boolean encryptKeys,\n+      @Option(\n+              names = {\"--validator-password:file\"},", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk5NjY1Ng=="}, "originalCommit": {"oid": "eb4e4fced1d629777d6f8440fd26e8a158d4253d"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAyNDY4MQ==", "bodyText": "OR.... --validator-password=env:VAL_PASS approach?", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r390024681", "createdAt": "2020-03-09T23:58:31Z", "author": {"login": "usmansaleem"}, "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "diffHunk": "@@ -80,45 +100,98 @@ public void generate(\n               defaultValue = \"1\")\n           int validatorCount,\n       @Option(\n-              names = {\"--output-file\", \"-o\"},\n+              names = {\"--output-path\", \"-o\"},\n+              paramLabel = \"<FILE|DIR>\",\n               description =\n-                  \"File to write validator keys to. Keys are printed to std out if not specified\")\n-          String outputFile) {\n+                  \"Path to output file for unencrypted keys or output directory for encrypted keystore files. If not set, unencrypted keys will be written on standard out and encrypted keystores will be created in current directory\")\n+          String outputPath,\n+      @Option(\n+              names = {\"--encrypt-keys\", \"-e\"},\n+              defaultValue = \"true\",\n+              paramLabel = \"<true|false>\",\n+              description = \"Encrypt validator and withdrawal keys. (Default: true)\",\n+              arity = \"1\")\n+          boolean encryptKeys,\n+      @Option(\n+              names = {\"--validator-password:file\"},", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk5NjY1Ng=="}, "originalCommit": {"oid": "eb4e4fced1d629777d6f8440fd26e8a158d4253d"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAyNTQ5Mg==", "bodyText": "Two possible approaches:\n\n\nSeparate options.  So you'd have --validator-password-file and --validator-password-env if neither of those is specified, use the interactive prompt.\n\n\nA single option that works out how to interpret the arg (feeling like this is going to be confusing, so leaning towards option 1).  So not specifying the option or --validator-password with no arg uses an interactive prompt.  --validator-password env:SOME_VAR would read from an environment var (the env: prefix is what tells us it's an env var) and --validator-password <any-arg> reads from a file (assuming  doesn't start with env:).", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r390025492", "createdAt": "2020-03-10T00:01:10Z", "author": {"login": "ajsutton"}, "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "diffHunk": "@@ -80,45 +100,98 @@ public void generate(\n               defaultValue = \"1\")\n           int validatorCount,\n       @Option(\n-              names = {\"--output-file\", \"-o\"},\n+              names = {\"--output-path\", \"-o\"},\n+              paramLabel = \"<FILE|DIR>\",\n               description =\n-                  \"File to write validator keys to. Keys are printed to std out if not specified\")\n-          String outputFile) {\n+                  \"Path to output file for unencrypted keys or output directory for encrypted keystore files. If not set, unencrypted keys will be written on standard out and encrypted keystores will be created in current directory\")\n+          String outputPath,\n+      @Option(\n+              names = {\"--encrypt-keys\", \"-e\"},\n+              defaultValue = \"true\",\n+              paramLabel = \"<true|false>\",\n+              description = \"Encrypt validator and withdrawal keys. (Default: true)\",\n+              arity = \"1\")\n+          boolean encryptKeys,\n+      @Option(\n+              names = {\"--validator-password:file\"},", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk5NjY1Ng=="}, "originalCommit": {"oid": "eb4e4fced1d629777d6f8440fd26e8a158d4253d"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAyNTY0NA==", "bodyText": "But you should really talk to Jake. That's why we have a UX person. :)", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r390025644", "createdAt": "2020-03-10T00:01:46Z", "author": {"login": "ajsutton"}, "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "diffHunk": "@@ -80,45 +100,98 @@ public void generate(\n               defaultValue = \"1\")\n           int validatorCount,\n       @Option(\n-              names = {\"--output-file\", \"-o\"},\n+              names = {\"--output-path\", \"-o\"},\n+              paramLabel = \"<FILE|DIR>\",\n               description =\n-                  \"File to write validator keys to. Keys are printed to std out if not specified\")\n-          String outputFile) {\n+                  \"Path to output file for unencrypted keys or output directory for encrypted keystore files. If not set, unencrypted keys will be written on standard out and encrypted keystores will be created in current directory\")\n+          String outputPath,\n+      @Option(\n+              names = {\"--encrypt-keys\", \"-e\"},\n+              defaultValue = \"true\",\n+              paramLabel = \"<true|false>\",\n+              description = \"Encrypt validator and withdrawal keys. (Default: true)\",\n+              arity = \"1\")\n+          boolean encryptKeys,\n+      @Option(\n+              names = {\"--validator-password:file\"},", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk5NjY1Ng=="}, "originalCommit": {"oid": "eb4e4fced1d629777d6f8440fd26e8a158d4253d"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNjgyMjQzOnYy", "diffSide": "RIGHT", "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQyMjozNzozNVrOFz7sHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQyMjozNzozNVrOFz7sHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk5OTY0Ng==", "bodyText": "It seems weird to have to specify --validator-password to get the prompt to provide the password. Makes me naturally want to specify the password on the command line which is insecure and doesn't actually work.", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r389999646", "createdAt": "2020-03-09T22:37:35Z", "author": {"login": "ajsutton"}, "path": "artemis/src/main/java/tech/pegasys/artemis/DepositCommand.java", "diffHunk": "@@ -80,45 +100,98 @@ public void generate(\n               defaultValue = \"1\")\n           int validatorCount,\n       @Option(\n-              names = {\"--output-file\", \"-o\"},\n+              names = {\"--output-path\", \"-o\"},\n+              paramLabel = \"<FILE|DIR>\",\n               description =\n-                  \"File to write validator keys to. Keys are printed to std out if not specified\")\n-          String outputFile) {\n+                  \"Path to output file for unencrypted keys or output directory for encrypted keystore files. If not set, unencrypted keys will be written on standard out and encrypted keystores will be created in current directory\")\n+          String outputPath,\n+      @Option(\n+              names = {\"--encrypt-keys\", \"-e\"},\n+              defaultValue = \"true\",\n+              paramLabel = \"<true|false>\",\n+              description = \"Encrypt validator and withdrawal keys. (Default: true)\",\n+              arity = \"1\")\n+          boolean encryptKeys,\n+      @Option(\n+              names = {\"--validator-password:file\"},\n+              paramLabel = \"<FILE>\",\n+              description = \"Read password from the file to encrypt the validator keys\")\n+          File validatorPasswordFile,\n+      @Option(\n+              names = {\"--validator-password:env\"},\n+              paramLabel = \"<ENV_VAR>\",\n+              description = \"Read password from environment variable to encrypt the validator keys\")\n+          String validatorPasswordEnv,\n+      @Option(\n+              names = {\"--validator-password\"},", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb4e4fced1d629777d6f8440fd26e8a158d4253d"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNjgyMzM1OnYy", "diffSide": "RIGHT", "path": "artemis/src/main/java/tech/pegasys/artemis/cli/deposit/EncryptedKeystorePasswordProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQyMjozODowMVrOFz7ssw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQyMjozODowMVrOFz7ssw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk5OTc5NQ==", "bodyText": "Probably should check that only one of the three options for specifying the password have been provided.  Otherwise it will be very confusing which password actually gets used.", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r389999795", "createdAt": "2020-03-09T22:38:01Z", "author": {"login": "ajsutton"}, "path": "artemis/src/main/java/tech/pegasys/artemis/cli/deposit/EncryptedKeystorePasswordProvider.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.cli.deposit;\n+\n+import static org.apache.commons.lang3.StringUtils.isBlank;\n+\n+import com.google.common.io.Files;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import picocli.CommandLine.Model.CommandSpec;\n+import picocli.CommandLine.ParameterException;\n+\n+public class EncryptedKeystorePasswordProvider {\n+  private final String password;\n+  private final String environmentVariable;\n+  private final File passwordFile;\n+  private final String errorPrefix;\n+\n+  private final CommandSpec spec;\n+\n+  public EncryptedKeystorePasswordProvider(\n+      final CommandSpec spec,\n+      final String password,\n+      final String environmentVariable,\n+      final File passwordFile,\n+      final String errorPrefix) {\n+    this.spec = spec;\n+    this.password = password;\n+    this.environmentVariable = environmentVariable;\n+    this.passwordFile = passwordFile;\n+    this.errorPrefix = errorPrefix;\n+  }\n+\n+  public String retrievePassword() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb4e4fced1d629777d6f8440fd26e8a158d4253d"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNjgyNzQ2OnYy", "diffSide": "RIGHT", "path": "artemis/src/main/java/tech/pegasys/artemis/cli/deposit/EncryptedKeystorePasswordProvider.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQyMjozOTo1MVrOFz7vEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQwMDo1MjoxNVrOF1ODKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwMDQwMw==", "bodyText": "It's really annoying to get the missing options error message in small chunks.  ie I tried:\n$ ./build/install/teku/bin/teku validator generate\nMissing required options [--node-url=<URL>, --contract-address=<ADDRESS>, --private-key=<KEY>]\n\n$ ./build/install/teku/bin/teku validator generate --node-url=http://localhost:8545 --contract-address=dddddddd --private-key=222222222\nMissing options: [--validator-password | --validator-password:env | --validator-password:file]\n\n$ ./build/install/teku/bin/teku validator generate --node-url=http://localhost:8545 --contract-address=dddddddd --private-key=222222222 --validator-password\nEnter value for --validator-password (Password to encrypt validator keys):\nMissing options: [--withdrawal-password | --withdrawal-password:env | --withdrawal-password:file]\n\nSo it took me four goes to actually be told all of what I had to provide.", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r390000403", "createdAt": "2020-03-09T22:39:51Z", "author": {"login": "ajsutton"}, "path": "artemis/src/main/java/tech/pegasys/artemis/cli/deposit/EncryptedKeystorePasswordProvider.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.cli.deposit;\n+\n+import static org.apache.commons.lang3.StringUtils.isBlank;\n+\n+import com.google.common.io.Files;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import picocli.CommandLine.Model.CommandSpec;\n+import picocli.CommandLine.ParameterException;\n+\n+public class EncryptedKeystorePasswordProvider {\n+  private final String password;\n+  private final String environmentVariable;\n+  private final File passwordFile;\n+  private final String errorPrefix;\n+\n+  private final CommandSpec spec;\n+\n+  public EncryptedKeystorePasswordProvider(\n+      final CommandSpec spec,\n+      final String password,\n+      final String environmentVariable,\n+      final File passwordFile,\n+      final String errorPrefix) {\n+    this.spec = spec;\n+    this.password = password;\n+    this.environmentVariable = environmentVariable;\n+    this.passwordFile = passwordFile;\n+    this.errorPrefix = errorPrefix;\n+  }\n+\n+  public String retrievePassword() {\n+    if (!isBlank(password)) {\n+      return password;\n+    }\n+\n+    if (environmentVariable != null) {\n+      final String password = System.getenv(environmentVariable);\n+      if (isBlank(password)) {\n+        throw new ParameterException(\n+            spec.commandLine(),\n+            \"Error in reading password from environment variable: \" + environmentVariable);\n+      }\n+      return password;\n+    }\n+\n+    if (passwordFile != null) {\n+      try {\n+        final String password =\n+            Files.asCharSource(passwordFile, StandardCharsets.UTF_8).readFirstLine();\n+        if (isBlank(password)) {\n+          throw new ParameterException(\n+              spec.commandLine(), \"Empty password read from password file: \" + passwordFile);\n+        }\n+        return password;\n+      } catch (final FileNotFoundException e) {\n+        throw new ParameterException(\n+            spec.commandLine(), \"Password file not found: \" + passwordFile);\n+      } catch (IOException e) {\n+        throw new ParameterException(\n+            spec.commandLine(),\n+            \"Unexpected IO error while reading password from file [\"\n+                + passwordFile\n+                + \"] : \"\n+                + e.getMessage());\n+      }\n+    }\n+\n+    final String errorMessage =\n+        String.format(\n+            \"Missing options: [--%1$s-password | --%1$s-password:env | --%1$s-password:file]\",\n+            errorPrefix);\n+    throw new ParameterException(spec.commandLine(), errorMessage);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb4e4fced1d629777d6f8440fd26e8a158d4253d"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI3Mjg4Ng==", "bodyText": "I have introduced mutually exclusive ArgGroup so that picocli handles these errors automagically. I do have to extract out subcommands by converting methods to standalone classes to make ArgGroup work (I believe PicoCli has a bug where ArgGroup doesn't work if methods are used as subcommands). I have also changed the --encrypt-keys to --encrypted-keystore-enabled and we now run in interactive mode to obtain passwords if none of the non-interactive password options are specified. The ArgGroup also allows to provide sub-section heading. e.g.\n./teku validator generate --help\n\nteku validator generate [OPTIONS]\n\nDescription:\n\nRegister validators by generating new keys and sending deposit transactions to\nan Ethereum 1 node\n\nOptions:\n  -a, --amount=<GWEI>       Deposit amount in Gwei (default: 32000000000)\n  -c, --contract-address=<ADDRESS>\n                            Address of the deposit contract\n  -e, --encrypted-keystore-enabled=<true|false>\n                            Create encrypted keystores for validator and\n                              withdrawal keys. (Default: true)\n  -h, --help                Show this help message and exit.\n  -n, --number-of-validators=<NUMBER>\n                            The number of validators to create keys for and\n                              register\n  -o, --output-path=<FILE|DIR>\n                            Path to output file for unencrypted keys or output\n                              directory for encrypted keystore files. If not\n                              set, unencrypted keys will be written on standard\n                              out and encrypted keystores will be created in\n                              current directory\n  -p, --private-key=<KEY>   Ethereum 1 private key to use to send transactions\n  -u, --node-url=<URL>      JSON-RPC endpoint URL for the Ethereum 1 node to\n                              send transactions via\n  -V, --version             Print version information and exit.\nNon-interactive password options for validator keystores:\n      --validator-password-env=<ENV_VAR>\n                            Read password from environment variable to encrypt\n                              the validator keys\n      --validator-password-file=<FILE>\n                            Read password from the file to encrypt the\n                              validator keys\nNon-interactive password options for withdrawal keystores:\n      --withdrawal-password-env=<ENV_VAR>\n                            Read password from environment variable to encrypt\n                              the withdrawal keys\n      --withdrawal-password-file=<FILE>\n                            Read password from the file to encrypt the\n                              withdrawal keys\n\nTeku is licensed under the Apache License 2.0\n\n(@jakehaugen and @arash009  FYI)", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r390272886", "createdAt": "2020-03-10T12:17:17Z", "author": {"login": "usmansaleem"}, "path": "artemis/src/main/java/tech/pegasys/artemis/cli/deposit/EncryptedKeystorePasswordProvider.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.cli.deposit;\n+\n+import static org.apache.commons.lang3.StringUtils.isBlank;\n+\n+import com.google.common.io.Files;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import picocli.CommandLine.Model.CommandSpec;\n+import picocli.CommandLine.ParameterException;\n+\n+public class EncryptedKeystorePasswordProvider {\n+  private final String password;\n+  private final String environmentVariable;\n+  private final File passwordFile;\n+  private final String errorPrefix;\n+\n+  private final CommandSpec spec;\n+\n+  public EncryptedKeystorePasswordProvider(\n+      final CommandSpec spec,\n+      final String password,\n+      final String environmentVariable,\n+      final File passwordFile,\n+      final String errorPrefix) {\n+    this.spec = spec;\n+    this.password = password;\n+    this.environmentVariable = environmentVariable;\n+    this.passwordFile = passwordFile;\n+    this.errorPrefix = errorPrefix;\n+  }\n+\n+  public String retrievePassword() {\n+    if (!isBlank(password)) {\n+      return password;\n+    }\n+\n+    if (environmentVariable != null) {\n+      final String password = System.getenv(environmentVariable);\n+      if (isBlank(password)) {\n+        throw new ParameterException(\n+            spec.commandLine(),\n+            \"Error in reading password from environment variable: \" + environmentVariable);\n+      }\n+      return password;\n+    }\n+\n+    if (passwordFile != null) {\n+      try {\n+        final String password =\n+            Files.asCharSource(passwordFile, StandardCharsets.UTF_8).readFirstLine();\n+        if (isBlank(password)) {\n+          throw new ParameterException(\n+              spec.commandLine(), \"Empty password read from password file: \" + passwordFile);\n+        }\n+        return password;\n+      } catch (final FileNotFoundException e) {\n+        throw new ParameterException(\n+            spec.commandLine(), \"Password file not found: \" + passwordFile);\n+      } catch (IOException e) {\n+        throw new ParameterException(\n+            spec.commandLine(),\n+            \"Unexpected IO error while reading password from file [\"\n+                + passwordFile\n+                + \"] : \"\n+                + e.getMessage());\n+      }\n+    }\n+\n+    final String errorMessage =\n+        String.format(\n+            \"Missing options: [--%1$s-password | --%1$s-password:env | --%1$s-password:file]\",\n+            errorPrefix);\n+    throw new ParameterException(spec.commandLine(), errorMessage);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwMDQwMw=="}, "originalCommit": {"oid": "eb4e4fced1d629777d6f8440fd26e8a158d4253d"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDI3Mzk3OA==", "bodyText": "Running generate command with required parameters only:\n./teku validator generate --contract-address=dddddddddddddddddddddddddddddddddddddddd \\\n--number-of-validators=1 \\\n--private-key=8f2a55949038a9610f50fb23b5883af3b4ecb3c3bb792cbcefbd1542c692be63 \\\n--node-url=http://localhost:8545\nEnter password for Validator Keystore:\nRe-Enter password for Validator Keystore:\nEnter password for Withdrawal Keystore:\nRe-Enter password for Withdrawal Keystore:\n22:18:24.268 [INFO ] - Generating Encrypted Keystores in .", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r390273978", "createdAt": "2020-03-10T12:19:41Z", "author": {"login": "usmansaleem"}, "path": "artemis/src/main/java/tech/pegasys/artemis/cli/deposit/EncryptedKeystorePasswordProvider.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.cli.deposit;\n+\n+import static org.apache.commons.lang3.StringUtils.isBlank;\n+\n+import com.google.common.io.Files;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import picocli.CommandLine.Model.CommandSpec;\n+import picocli.CommandLine.ParameterException;\n+\n+public class EncryptedKeystorePasswordProvider {\n+  private final String password;\n+  private final String environmentVariable;\n+  private final File passwordFile;\n+  private final String errorPrefix;\n+\n+  private final CommandSpec spec;\n+\n+  public EncryptedKeystorePasswordProvider(\n+      final CommandSpec spec,\n+      final String password,\n+      final String environmentVariable,\n+      final File passwordFile,\n+      final String errorPrefix) {\n+    this.spec = spec;\n+    this.password = password;\n+    this.environmentVariable = environmentVariable;\n+    this.passwordFile = passwordFile;\n+    this.errorPrefix = errorPrefix;\n+  }\n+\n+  public String retrievePassword() {\n+    if (!isBlank(password)) {\n+      return password;\n+    }\n+\n+    if (environmentVariable != null) {\n+      final String password = System.getenv(environmentVariable);\n+      if (isBlank(password)) {\n+        throw new ParameterException(\n+            spec.commandLine(),\n+            \"Error in reading password from environment variable: \" + environmentVariable);\n+      }\n+      return password;\n+    }\n+\n+    if (passwordFile != null) {\n+      try {\n+        final String password =\n+            Files.asCharSource(passwordFile, StandardCharsets.UTF_8).readFirstLine();\n+        if (isBlank(password)) {\n+          throw new ParameterException(\n+              spec.commandLine(), \"Empty password read from password file: \" + passwordFile);\n+        }\n+        return password;\n+      } catch (final FileNotFoundException e) {\n+        throw new ParameterException(\n+            spec.commandLine(), \"Password file not found: \" + passwordFile);\n+      } catch (IOException e) {\n+        throw new ParameterException(\n+            spec.commandLine(),\n+            \"Unexpected IO error while reading password from file [\"\n+                + passwordFile\n+                + \"] : \"\n+                + e.getMessage());\n+      }\n+    }\n+\n+    final String errorMessage =\n+        String.format(\n+            \"Missing options: [--%1$s-password | --%1$s-password:env | --%1$s-password:file]\",\n+            errorPrefix);\n+    throw new ParameterException(spec.commandLine(), errorMessage);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwMDQwMw=="}, "originalCommit": {"oid": "eb4e4fced1d629777d6f8440fd26e8a158d4253d"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU5ODU3Mg==", "bodyText": "To confirm, do you have to use the same method to supply the validator password and withdrawal password? e..g. can I supply validator password via env variable, and use interactive method for withdrawal password? (I dont think there really is a use case for that, but just checking what works)", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r390598572", "createdAt": "2020-03-10T20:43:08Z", "author": {"login": "arash009"}, "path": "artemis/src/main/java/tech/pegasys/artemis/cli/deposit/EncryptedKeystorePasswordProvider.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.cli.deposit;\n+\n+import static org.apache.commons.lang3.StringUtils.isBlank;\n+\n+import com.google.common.io.Files;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import picocli.CommandLine.Model.CommandSpec;\n+import picocli.CommandLine.ParameterException;\n+\n+public class EncryptedKeystorePasswordProvider {\n+  private final String password;\n+  private final String environmentVariable;\n+  private final File passwordFile;\n+  private final String errorPrefix;\n+\n+  private final CommandSpec spec;\n+\n+  public EncryptedKeystorePasswordProvider(\n+      final CommandSpec spec,\n+      final String password,\n+      final String environmentVariable,\n+      final File passwordFile,\n+      final String errorPrefix) {\n+    this.spec = spec;\n+    this.password = password;\n+    this.environmentVariable = environmentVariable;\n+    this.passwordFile = passwordFile;\n+    this.errorPrefix = errorPrefix;\n+  }\n+\n+  public String retrievePassword() {\n+    if (!isBlank(password)) {\n+      return password;\n+    }\n+\n+    if (environmentVariable != null) {\n+      final String password = System.getenv(environmentVariable);\n+      if (isBlank(password)) {\n+        throw new ParameterException(\n+            spec.commandLine(),\n+            \"Error in reading password from environment variable: \" + environmentVariable);\n+      }\n+      return password;\n+    }\n+\n+    if (passwordFile != null) {\n+      try {\n+        final String password =\n+            Files.asCharSource(passwordFile, StandardCharsets.UTF_8).readFirstLine();\n+        if (isBlank(password)) {\n+          throw new ParameterException(\n+              spec.commandLine(), \"Empty password read from password file: \" + passwordFile);\n+        }\n+        return password;\n+      } catch (final FileNotFoundException e) {\n+        throw new ParameterException(\n+            spec.commandLine(), \"Password file not found: \" + passwordFile);\n+      } catch (IOException e) {\n+        throw new ParameterException(\n+            spec.commandLine(),\n+            \"Unexpected IO error while reading password from file [\"\n+                + passwordFile\n+                + \"] : \"\n+                + e.getMessage());\n+      }\n+    }\n+\n+    final String errorMessage =\n+        String.format(\n+            \"Missing options: [--%1$s-password | --%1$s-password:env | --%1$s-password:file]\",\n+            errorPrefix);\n+    throw new ParameterException(spec.commandLine(), errorMessage);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwMDQwMw=="}, "originalCommit": {"oid": "eb4e4fced1d629777d6f8440fd26e8a158d4253d"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTM0OTAzNQ==", "bodyText": "@arash009  yes, both validator keystore and withdrawal keystore options are independent of each other, so validator keystore's password can come from environment variable for instance, while withdrawal's password can be read from file. However, due to mutually exclusive mode, you can either specify --validator-password-env or --validator-password-file but not both.", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r391349035", "createdAt": "2020-03-12T00:52:15Z", "author": {"login": "usmansaleem"}, "path": "artemis/src/main/java/tech/pegasys/artemis/cli/deposit/EncryptedKeystorePasswordProvider.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.cli.deposit;\n+\n+import static org.apache.commons.lang3.StringUtils.isBlank;\n+\n+import com.google.common.io.Files;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import picocli.CommandLine.Model.CommandSpec;\n+import picocli.CommandLine.ParameterException;\n+\n+public class EncryptedKeystorePasswordProvider {\n+  private final String password;\n+  private final String environmentVariable;\n+  private final File passwordFile;\n+  private final String errorPrefix;\n+\n+  private final CommandSpec spec;\n+\n+  public EncryptedKeystorePasswordProvider(\n+      final CommandSpec spec,\n+      final String password,\n+      final String environmentVariable,\n+      final File passwordFile,\n+      final String errorPrefix) {\n+    this.spec = spec;\n+    this.password = password;\n+    this.environmentVariable = environmentVariable;\n+    this.passwordFile = passwordFile;\n+    this.errorPrefix = errorPrefix;\n+  }\n+\n+  public String retrievePassword() {\n+    if (!isBlank(password)) {\n+      return password;\n+    }\n+\n+    if (environmentVariable != null) {\n+      final String password = System.getenv(environmentVariable);\n+      if (isBlank(password)) {\n+        throw new ParameterException(\n+            spec.commandLine(),\n+            \"Error in reading password from environment variable: \" + environmentVariable);\n+      }\n+      return password;\n+    }\n+\n+    if (passwordFile != null) {\n+      try {\n+        final String password =\n+            Files.asCharSource(passwordFile, StandardCharsets.UTF_8).readFirstLine();\n+        if (isBlank(password)) {\n+          throw new ParameterException(\n+              spec.commandLine(), \"Empty password read from password file: \" + passwordFile);\n+        }\n+        return password;\n+      } catch (final FileNotFoundException e) {\n+        throw new ParameterException(\n+            spec.commandLine(), \"Password file not found: \" + passwordFile);\n+      } catch (IOException e) {\n+        throw new ParameterException(\n+            spec.commandLine(),\n+            \"Unexpected IO error while reading password from file [\"\n+                + passwordFile\n+                + \"] : \"\n+                + e.getMessage());\n+      }\n+    }\n+\n+    final String errorMessage =\n+        String.format(\n+            \"Missing options: [--%1$s-password | --%1$s-password:env | --%1$s-password:file]\",\n+            errorPrefix);\n+    throw new ParameterException(spec.commandLine(), errorMessage);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwMDQwMw=="}, "originalCommit": {"oid": "eb4e4fced1d629777d6f8440fd26e8a158d4253d"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxNjgzNDA1OnYy", "diffSide": "RIGHT", "path": "artemis/src/main/java/tech/pegasys/artemis/cli/deposit/EncryptedKeystoreWriter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQyMjo0Mjo0N1rOFz7y4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQwMDoyODo0N1rOFz9tNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwMTM3Nw==", "bodyText": "If I run the command twice, does this wind up overwriting the existing keys (losing my funds)?  Would it be better to use the public key as part of the directory name rather than the index - then it's guaranteed to be unique.", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r390001377", "createdAt": "2020-03-09T22:42:47Z", "author": {"login": "ajsutton"}, "path": "artemis/src/main/java/tech/pegasys/artemis/cli/deposit/EncryptedKeystoreWriter.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.cli.deposit;\n+\n+import static tech.pegasys.artemis.util.crypto.SecureRandomProvider.createSecureRandom;\n+import static tech.pegasys.teku.logging.StatusLogger.STATUS_LOG;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.apache.logging.log4j.Level;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.artemis.bls.keystore.KeyStore;\n+import tech.pegasys.artemis.bls.keystore.KeyStoreLoader;\n+import tech.pegasys.artemis.bls.keystore.KeyStoreValidationException;\n+import tech.pegasys.artemis.bls.keystore.model.Cipher;\n+import tech.pegasys.artemis.bls.keystore.model.CipherFunction;\n+import tech.pegasys.artemis.bls.keystore.model.KdfParam;\n+import tech.pegasys.artemis.bls.keystore.model.KeyStoreData;\n+import tech.pegasys.artemis.bls.keystore.model.SCryptParam;\n+import tech.pegasys.artemis.util.bls.BLSKeyPair;\n+\n+public class EncryptedKeystoreWriter implements KeysWriter {\n+  private final String validatorKeyPassword;\n+  private final String withdrawalKeyPassword;\n+  private final Path outputPath;\n+  private final AtomicInteger counter = new AtomicInteger(0);\n+\n+  public EncryptedKeystoreWriter(\n+      final String validatorKeyPassword,\n+      final String withdrawalKeyPassword,\n+      final Path outputPath) {\n+    this.validatorKeyPassword = validatorKeyPassword;\n+    this.withdrawalKeyPassword = withdrawalKeyPassword;\n+    this.outputPath = outputPath;\n+  }\n+\n+  @Override\n+  public void writeKeys(final BLSKeyPair validatorKey, final BLSKeyPair withdrawalKey)\n+      throws UncheckedIOException, KeyStoreValidationException {\n+    final Path keystoreDirectory = createKeystoreDirectory();\n+\n+    final KeyStoreData validatorKeyStoreData =\n+        generateKeystoreData(validatorKey, validatorKeyPassword);\n+    final KeyStoreData withdrawalKeyStoreData =\n+        generateKeystoreData(withdrawalKey, withdrawalKeyPassword);\n+\n+    saveKeyStore(keystoreDirectory.resolve(\"validator_keystore.json\"), validatorKeyStoreData);\n+    saveKeyStore(keystoreDirectory.resolve(\"withdrawal_keystore.json\"), withdrawalKeyStoreData);\n+  }\n+\n+  private Path createKeystoreDirectory() {\n+    final Path keystoreDirectory = outputPath.resolve(\"validator_\" + counter.incrementAndGet());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb4e4fced1d629777d6f8440fd26e8a158d4253d"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAzMjY5Mw==", "bodyText": "Yes, thats a good catch. I'll modify logic to use public key as folder name.", "url": "https://github.com/ConsenSys/teku/pull/1286#discussion_r390032693", "createdAt": "2020-03-10T00:28:47Z", "author": {"login": "usmansaleem"}, "path": "artemis/src/main/java/tech/pegasys/artemis/cli/deposit/EncryptedKeystoreWriter.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.cli.deposit;\n+\n+import static tech.pegasys.artemis.util.crypto.SecureRandomProvider.createSecureRandom;\n+import static tech.pegasys.teku.logging.StatusLogger.STATUS_LOG;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.apache.logging.log4j.Level;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.artemis.bls.keystore.KeyStore;\n+import tech.pegasys.artemis.bls.keystore.KeyStoreLoader;\n+import tech.pegasys.artemis.bls.keystore.KeyStoreValidationException;\n+import tech.pegasys.artemis.bls.keystore.model.Cipher;\n+import tech.pegasys.artemis.bls.keystore.model.CipherFunction;\n+import tech.pegasys.artemis.bls.keystore.model.KdfParam;\n+import tech.pegasys.artemis.bls.keystore.model.KeyStoreData;\n+import tech.pegasys.artemis.bls.keystore.model.SCryptParam;\n+import tech.pegasys.artemis.util.bls.BLSKeyPair;\n+\n+public class EncryptedKeystoreWriter implements KeysWriter {\n+  private final String validatorKeyPassword;\n+  private final String withdrawalKeyPassword;\n+  private final Path outputPath;\n+  private final AtomicInteger counter = new AtomicInteger(0);\n+\n+  public EncryptedKeystoreWriter(\n+      final String validatorKeyPassword,\n+      final String withdrawalKeyPassword,\n+      final Path outputPath) {\n+    this.validatorKeyPassword = validatorKeyPassword;\n+    this.withdrawalKeyPassword = withdrawalKeyPassword;\n+    this.outputPath = outputPath;\n+  }\n+\n+  @Override\n+  public void writeKeys(final BLSKeyPair validatorKey, final BLSKeyPair withdrawalKey)\n+      throws UncheckedIOException, KeyStoreValidationException {\n+    final Path keystoreDirectory = createKeystoreDirectory();\n+\n+    final KeyStoreData validatorKeyStoreData =\n+        generateKeystoreData(validatorKey, validatorKeyPassword);\n+    final KeyStoreData withdrawalKeyStoreData =\n+        generateKeystoreData(withdrawalKey, withdrawalKeyPassword);\n+\n+    saveKeyStore(keystoreDirectory.resolve(\"validator_keystore.json\"), validatorKeyStoreData);\n+    saveKeyStore(keystoreDirectory.resolve(\"withdrawal_keystore.json\"), withdrawalKeyStoreData);\n+  }\n+\n+  private Path createKeystoreDirectory() {\n+    final Path keystoreDirectory = outputPath.resolve(\"validator_\" + counter.incrementAndGet());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwMTM3Nw=="}, "originalCommit": {"oid": "eb4e4fced1d629777d6f8440fd26e8a158d4253d"}, "originalPosition": 67}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2731, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}