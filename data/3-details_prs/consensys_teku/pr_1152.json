{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc0NjczMjA5", "number": 1152, "title": "Implement DepositProvider", "bodyText": "PR Description\nImplements DepositProvider which allows ValidatorCoordinator to include correct post-genesis deposits (with proofs) to blocks. Is able to handle providing deposits for separate forks. Prunes deposits from memory after every finalization.\nFixes\nFixes the getProofWithViewBoundary method. Previously, this method was unable to provide proof for leaves that have more than approximately 3 or more leaf distance to the view boundary.", "createdAt": "2020-02-13T05:10:26Z", "url": "https://github.com/ConsenSys/teku/pull/1152", "merged": true, "mergeCommit": {"oid": "e045eac7d6a6b073c255cad7ab05237aec46adf1"}, "closed": true, "closedAt": "2020-02-18T20:55:18Z", "author": {"login": "cemozerr"}, "timelineItems": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcDz0CRgH2gAyMzc0NjczMjA5OjZiYWU3MmQ3YmM4YTYyYzJmNmZjMzc2NDQ5YTE5OGNlY2VhZTI1ZGM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcFoSA9gFqTM2MDY2MjcwOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "6bae72d7bc8a62c2f6fc376449a198ceceae25dc", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/6bae72d7bc8a62c2f6fc376449a198ceceae25dc", "committedDate": "2020-02-13T05:09:51Z", "message": "WIP: Implement DepositProvider"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d0da02e8d81906fa54b06a229666d552056c6466", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/d0da02e8d81906fa54b06a229666d552056c6466", "committedDate": "2020-02-14T21:58:12Z", "message": "Fix merkle tree getViewWithBoundary method"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "85c13de11c431030ee0ba7687c964d61c3ad6443", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/85c13de11c431030ee0ba7687c964d61c3ad6443", "committedDate": "2020-02-14T23:01:51Z", "message": "Run spotless"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c121e93e116698aa611dc4f2eaba36b3a04e4fa0", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/c121e93e116698aa611dc4f2eaba36b3a04e4fa0", "committedDate": "2020-02-14T23:38:57Z", "message": "Fix test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f8dcac1374cab638d4d7eca18e12e8bf661bbf66", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/f8dcac1374cab638d4d7eca18e12e8bf661bbf66", "committedDate": "2020-02-15T02:44:20Z", "message": "Remove unnecessary variable and print out"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "01f338be5abde63c640f685bff93e57709305467", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/01f338be5abde63c640f685bff93e57709305467", "committedDate": "2020-02-15T02:50:32Z", "message": "Remove redundant deposits code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3044d741c22a38f35dcb79616eddb164ec86b057", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/3044d741c22a38f35dcb79616eddb164ec86b057", "committedDate": "2020-02-15T02:58:51Z", "message": "Run spotless"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dbda195f19b8176ceb063aebf0a1ad09030b38f5", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/dbda195f19b8176ceb063aebf0a1ad09030b38f5", "committedDate": "2020-02-15T03:04:25Z", "message": "Merge branch 'master' into implementDepositProvider"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU5NDMwNjIz", "url": "https://github.com/ConsenSys/teku/pull/1152#pullrequestreview-359430623", "createdAt": "2020-02-16T21:32:16Z", "commit": {"oid": "dbda195f19b8176ceb063aebf0a1ad09030b38f5"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNlQyMTozMjoxNlrOFqVZSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNlQyMTo0OTowMlrOFqVdpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTkzNTA1MQ==", "bodyText": "nit: found not find", "url": "https://github.com/ConsenSys/teku/pull/1152#discussion_r379935051", "createdAt": "2020-02-16T21:32:16Z", "author": {"login": "ajsutton"}, "path": "validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/DepositProvider.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.validator.coordinator;\n+\n+import static java.lang.StrictMath.toIntExact;\n+import static tech.pegasys.artemis.util.config.Constants.DEPOSIT_CONTRACT_TREE_DEPTH;\n+import static tech.pegasys.artemis.util.config.Constants.MAX_DEPOSITS;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.List;\n+import java.util.NavigableMap;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+import tech.pegasys.artemis.datastructures.operations.Deposit;\n+import tech.pegasys.artemis.datastructures.operations.DepositData;\n+import tech.pegasys.artemis.datastructures.operations.DepositWithIndex;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.util.DepositUtil;\n+import tech.pegasys.artemis.datastructures.util.MerkleTree;\n+import tech.pegasys.artemis.datastructures.util.OptimizedMerkleTree;\n+import tech.pegasys.artemis.pow.api.DepositEventChannel;\n+import tech.pegasys.artemis.pow.event.DepositsFromBlockEvent;\n+import tech.pegasys.artemis.storage.ChainStorageClient;\n+import tech.pegasys.artemis.storage.api.FinalizedCheckpointEventChannel;\n+import tech.pegasys.artemis.storage.events.FinalizedCheckpointEvent;\n+import tech.pegasys.artemis.util.SSZTypes.SSZList;\n+\n+public class DepositProvider implements DepositEventChannel, FinalizedCheckpointEventChannel {\n+\n+  private final ChainStorageClient chainStorageClient;\n+  private final MerkleTree depositMerkleTree = new OptimizedMerkleTree(DEPOSIT_CONTRACT_TREE_DEPTH);\n+\n+  @VisibleForTesting\n+  NavigableMap<UnsignedLong, DepositWithIndex> depositNavigableMap = new TreeMap<>();\n+\n+  public DepositProvider(ChainStorageClient chainStorageClient) {\n+    this.chainStorageClient = chainStorageClient;\n+  }\n+\n+  @Override\n+  public void onDepositsFromBlock(DepositsFromBlockEvent event) {\n+    event.getDeposits().stream()\n+        .map(DepositUtil::convertDepositEventToOperationDeposit)\n+        .peek(deposit -> depositNavigableMap.put(deposit.getIndex(), deposit))\n+        .map(Deposit::getData)\n+        .map(DepositData::hash_tree_root)\n+        .forEachOrdered(depositMerkleTree::add);\n+  }\n+\n+  @Override\n+  public void onFinalizedCheckpoint(FinalizedCheckpointEvent event) {\n+    BeaconState finalizedState =\n+        chainStorageClient\n+            .getBlockState(event.getCheckpoint().getRoot())\n+            .orElseThrow(\n+                () -> new IllegalArgumentException(\"Finalized Checkpoint state can not be find.\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dbda195f19b8176ceb063aebf0a1ad09030b38f5"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTkzNTM2NA==", "bodyText": "This is probably a misuse of the peek API and it makes it more complex to see what's going on here (it looks like a single operation but actually it's two).\nI'd just use:\nevent.getDeposits().stream()\n  .map(DepositUtil::convertDepositEventToOperationDeposit)\n  .forEach(deposit -> {\n    depositNavigableMap.put(deposit.getIndex(), deposit);\n    depositMerkleTree.add(deposit.getData().hash_tree_root());\n  });\n\nFor the record, the only time you need to use forEachOrdered rather than forEach is when you've moved to a parallel stream somewhere.  It doesn't hurt because a sequential stream just implements forEachOrdered as forEach but it makes me stop and go looking for the parallel call every time I see forEachOrdered.", "url": "https://github.com/ConsenSys/teku/pull/1152#discussion_r379935364", "createdAt": "2020-02-16T21:36:41Z", "author": {"login": "ajsutton"}, "path": "validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/DepositProvider.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.validator.coordinator;\n+\n+import static java.lang.StrictMath.toIntExact;\n+import static tech.pegasys.artemis.util.config.Constants.DEPOSIT_CONTRACT_TREE_DEPTH;\n+import static tech.pegasys.artemis.util.config.Constants.MAX_DEPOSITS;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.List;\n+import java.util.NavigableMap;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+import tech.pegasys.artemis.datastructures.operations.Deposit;\n+import tech.pegasys.artemis.datastructures.operations.DepositData;\n+import tech.pegasys.artemis.datastructures.operations.DepositWithIndex;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.util.DepositUtil;\n+import tech.pegasys.artemis.datastructures.util.MerkleTree;\n+import tech.pegasys.artemis.datastructures.util.OptimizedMerkleTree;\n+import tech.pegasys.artemis.pow.api.DepositEventChannel;\n+import tech.pegasys.artemis.pow.event.DepositsFromBlockEvent;\n+import tech.pegasys.artemis.storage.ChainStorageClient;\n+import tech.pegasys.artemis.storage.api.FinalizedCheckpointEventChannel;\n+import tech.pegasys.artemis.storage.events.FinalizedCheckpointEvent;\n+import tech.pegasys.artemis.util.SSZTypes.SSZList;\n+\n+public class DepositProvider implements DepositEventChannel, FinalizedCheckpointEventChannel {\n+\n+  private final ChainStorageClient chainStorageClient;\n+  private final MerkleTree depositMerkleTree = new OptimizedMerkleTree(DEPOSIT_CONTRACT_TREE_DEPTH);\n+\n+  @VisibleForTesting\n+  NavigableMap<UnsignedLong, DepositWithIndex> depositNavigableMap = new TreeMap<>();\n+\n+  public DepositProvider(ChainStorageClient chainStorageClient) {\n+    this.chainStorageClient = chainStorageClient;\n+  }\n+\n+  @Override\n+  public void onDepositsFromBlock(DepositsFromBlockEvent event) {\n+    event.getDeposits().stream()\n+        .map(DepositUtil::convertDepositEventToOperationDeposit)\n+        .peek(deposit -> depositNavigableMap.put(deposit.getIndex(), deposit))\n+        .map(Deposit::getData)\n+        .map(DepositData::hash_tree_root)\n+        .forEachOrdered(depositMerkleTree::add);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dbda195f19b8176ceb063aebf0a1ad09030b38f5"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTkzNTgwNA==", "bodyText": "This will actually leak memory because tailMap returns a view into the original map - it doesn't create a new, smaller copy.  We'll need to get the set of keys to remove (probably something using the navigableKeySet() method) and then use removeAll.\nThis method is called from a different event channel to onDeposits so two different threads will be used and we'll have to synchronise access to depositMerkleTree and depositNavigableMap.  getDeposits would be called from different threads as well.", "url": "https://github.com/ConsenSys/teku/pull/1152#discussion_r379935804", "createdAt": "2020-02-16T21:43:15Z", "author": {"login": "ajsutton"}, "path": "validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/DepositProvider.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.validator.coordinator;\n+\n+import static java.lang.StrictMath.toIntExact;\n+import static tech.pegasys.artemis.util.config.Constants.DEPOSIT_CONTRACT_TREE_DEPTH;\n+import static tech.pegasys.artemis.util.config.Constants.MAX_DEPOSITS;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.List;\n+import java.util.NavigableMap;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+import tech.pegasys.artemis.datastructures.operations.Deposit;\n+import tech.pegasys.artemis.datastructures.operations.DepositData;\n+import tech.pegasys.artemis.datastructures.operations.DepositWithIndex;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.util.DepositUtil;\n+import tech.pegasys.artemis.datastructures.util.MerkleTree;\n+import tech.pegasys.artemis.datastructures.util.OptimizedMerkleTree;\n+import tech.pegasys.artemis.pow.api.DepositEventChannel;\n+import tech.pegasys.artemis.pow.event.DepositsFromBlockEvent;\n+import tech.pegasys.artemis.storage.ChainStorageClient;\n+import tech.pegasys.artemis.storage.api.FinalizedCheckpointEventChannel;\n+import tech.pegasys.artemis.storage.events.FinalizedCheckpointEvent;\n+import tech.pegasys.artemis.util.SSZTypes.SSZList;\n+\n+public class DepositProvider implements DepositEventChannel, FinalizedCheckpointEventChannel {\n+\n+  private final ChainStorageClient chainStorageClient;\n+  private final MerkleTree depositMerkleTree = new OptimizedMerkleTree(DEPOSIT_CONTRACT_TREE_DEPTH);\n+\n+  @VisibleForTesting\n+  NavigableMap<UnsignedLong, DepositWithIndex> depositNavigableMap = new TreeMap<>();\n+\n+  public DepositProvider(ChainStorageClient chainStorageClient) {\n+    this.chainStorageClient = chainStorageClient;\n+  }\n+\n+  @Override\n+  public void onDepositsFromBlock(DepositsFromBlockEvent event) {\n+    event.getDeposits().stream()\n+        .map(DepositUtil::convertDepositEventToOperationDeposit)\n+        .peek(deposit -> depositNavigableMap.put(deposit.getIndex(), deposit))\n+        .map(Deposit::getData)\n+        .map(DepositData::hash_tree_root)\n+        .forEachOrdered(depositMerkleTree::add);\n+  }\n+\n+  @Override\n+  public void onFinalizedCheckpoint(FinalizedCheckpointEvent event) {\n+    BeaconState finalizedState =\n+        chainStorageClient\n+            .getBlockState(event.getCheckpoint().getRoot())\n+            .orElseThrow(\n+                () -> new IllegalArgumentException(\"Finalized Checkpoint state can not be find.\"));\n+\n+    depositNavigableMap = depositNavigableMap.tailMap(finalizedState.getEth1_deposit_index(), true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dbda195f19b8176ceb063aebf0a1ad09030b38f5"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTkzNjE2Ng==", "bodyText": "This probably isn't a good place to use peek - we're performing two separate operations so we should make that clear.\nWe also have an issue here because the Deposit instances are all being shared, but being mutated to set different deposit proofs based on the state.  That's not going to end well as different threads might change the proof before it actually gets used and the block winds up invalid. So we really need to make a copy of the deposits here before setting the proof.  With a bit of luck we can remove the setProof method from Deposit to move it towards being immutable (the DepositData method still has a setSignature unfortunately so it won't get us all the way there).", "url": "https://github.com/ConsenSys/teku/pull/1152#discussion_r379936166", "createdAt": "2020-02-16T21:49:02Z", "author": {"login": "ajsutton"}, "path": "validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/DepositProvider.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.validator.coordinator;\n+\n+import static java.lang.StrictMath.toIntExact;\n+import static tech.pegasys.artemis.util.config.Constants.DEPOSIT_CONTRACT_TREE_DEPTH;\n+import static tech.pegasys.artemis.util.config.Constants.MAX_DEPOSITS;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.List;\n+import java.util.NavigableMap;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+import tech.pegasys.artemis.datastructures.operations.Deposit;\n+import tech.pegasys.artemis.datastructures.operations.DepositData;\n+import tech.pegasys.artemis.datastructures.operations.DepositWithIndex;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.util.DepositUtil;\n+import tech.pegasys.artemis.datastructures.util.MerkleTree;\n+import tech.pegasys.artemis.datastructures.util.OptimizedMerkleTree;\n+import tech.pegasys.artemis.pow.api.DepositEventChannel;\n+import tech.pegasys.artemis.pow.event.DepositsFromBlockEvent;\n+import tech.pegasys.artemis.storage.ChainStorageClient;\n+import tech.pegasys.artemis.storage.api.FinalizedCheckpointEventChannel;\n+import tech.pegasys.artemis.storage.events.FinalizedCheckpointEvent;\n+import tech.pegasys.artemis.util.SSZTypes.SSZList;\n+\n+public class DepositProvider implements DepositEventChannel, FinalizedCheckpointEventChannel {\n+\n+  private final ChainStorageClient chainStorageClient;\n+  private final MerkleTree depositMerkleTree = new OptimizedMerkleTree(DEPOSIT_CONTRACT_TREE_DEPTH);\n+\n+  @VisibleForTesting\n+  NavigableMap<UnsignedLong, DepositWithIndex> depositNavigableMap = new TreeMap<>();\n+\n+  public DepositProvider(ChainStorageClient chainStorageClient) {\n+    this.chainStorageClient = chainStorageClient;\n+  }\n+\n+  @Override\n+  public void onDepositsFromBlock(DepositsFromBlockEvent event) {\n+    event.getDeposits().stream()\n+        .map(DepositUtil::convertDepositEventToOperationDeposit)\n+        .peek(deposit -> depositNavigableMap.put(deposit.getIndex(), deposit))\n+        .map(Deposit::getData)\n+        .map(DepositData::hash_tree_root)\n+        .forEachOrdered(depositMerkleTree::add);\n+  }\n+\n+  @Override\n+  public void onFinalizedCheckpoint(FinalizedCheckpointEvent event) {\n+    BeaconState finalizedState =\n+        chainStorageClient\n+            .getBlockState(event.getCheckpoint().getRoot())\n+            .orElseThrow(\n+                () -> new IllegalArgumentException(\"Finalized Checkpoint state can not be find.\"));\n+\n+    depositNavigableMap = depositNavigableMap.tailMap(finalizedState.getEth1_deposit_index(), true);\n+  }\n+\n+  public SSZList<Deposit> getDeposits(BeaconState state) {\n+    UnsignedLong eth1DepositCount = state.getEth1_data().getDeposit_count();\n+\n+    UnsignedLong fromDepositIndex = state.getEth1_deposit_index();\n+    UnsignedLong latestDepositIndexWithMaxBlock =\n+        fromDepositIndex.plus(UnsignedLong.valueOf(MAX_DEPOSITS));\n+\n+    UnsignedLong toDepositIndex =\n+        latestDepositIndexWithMaxBlock.compareTo(eth1DepositCount) > 0\n+            ? eth1DepositCount\n+            : latestDepositIndexWithMaxBlock;\n+\n+    return new SSZList<>(\n+        getDepositsWithProof(fromDepositIndex, toDepositIndex, eth1DepositCount),\n+        MAX_DEPOSITS,\n+        Deposit.class);\n+  }\n+\n+  // TODO: switch the MerkleTree to use UnsignedLongs instead of using toIntExact() here,\n+  //  it will result in an overflow at some point\n+  /**\n+   * @param fromDepositIndex inclusive\n+   * @param toDepositIndex exclusive\n+   * @param eth1DepositCount number of deposits in the merkle tree according to Eth1Data in state\n+   * @return\n+   */\n+  private List<Deposit> getDepositsWithProof(\n+      UnsignedLong fromDepositIndex, UnsignedLong toDepositIndex, UnsignedLong eth1DepositCount) {\n+    return depositNavigableMap.subMap(fromDepositIndex, toDepositIndex).values().stream()\n+        .peek(\n+            deposit ->\n+                deposit.setProof(\n+                    depositMerkleTree.getProofWithViewBoundary(\n+                        toIntExact(deposit.getIndex().longValue()),\n+                        toIntExact(eth1DepositCount.longValue()))))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dbda195f19b8176ceb063aebf0a1ad09030b38f5"}, "originalPosition": 107}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU5NDM4ODcy", "url": "https://github.com/ConsenSys/teku/pull/1152#pullrequestreview-359438872", "createdAt": "2020-02-16T23:33:10Z", "commit": {"oid": "dbda195f19b8176ceb063aebf0a1ad09030b38f5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNlQyMzozMzoxMVrOFqV7DQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNlQyMzozMzoxMVrOFqV7DQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk0MzY5Mw==", "bodyText": "Rather than expose this map, I'd add a size or depositCount method to return how many deposits are still stored, then check that is reduced after a finalised block and that the expected remaining deposits are still returned on subsequent calls to getDeposits.  That way we're testing the expected behaviours of the API rather than internal details of the implementation.  While we don't strictly need a size method, it's a sensible addition to the API which could be used by monitoring and is better than exposing the internal map directly.", "url": "https://github.com/ConsenSys/teku/pull/1152#discussion_r379943693", "createdAt": "2020-02-16T23:33:11Z", "author": {"login": "ajsutton"}, "path": "validator/coordinator/src/test/java/tech/pegasys/artemis/validator/coordinator/DepositProviderTest.java", "diffHunk": "@@ -0,0 +1,175 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.validator.coordinator;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.is_valid_merkle_branch;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import tech.pegasys.artemis.datastructures.blocks.Eth1Data;\n+import tech.pegasys.artemis.datastructures.operations.Deposit;\n+import tech.pegasys.artemis.datastructures.operations.DepositData;\n+import tech.pegasys.artemis.datastructures.operations.DepositWithIndex;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.state.Checkpoint;\n+import tech.pegasys.artemis.datastructures.util.DataStructureUtil;\n+import tech.pegasys.artemis.datastructures.util.DepositUtil;\n+import tech.pegasys.artemis.datastructures.util.MerkleTree;\n+import tech.pegasys.artemis.datastructures.util.OptimizedMerkleTree;\n+import tech.pegasys.artemis.pow.event.DepositsFromBlockEvent;\n+import tech.pegasys.artemis.storage.ChainStorageClient;\n+import tech.pegasys.artemis.storage.events.FinalizedCheckpointEvent;\n+import tech.pegasys.artemis.util.SSZTypes.SSZList;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class DepositProviderTest {\n+\n+  private int seed = 0;\n+\n+  private List<tech.pegasys.artemis.pow.event.Deposit> allSeenDepositsList;\n+  private DepositProvider depositProvider;\n+  private ChainStorageClient chainStorageClient;\n+  private BeaconState beaconState;\n+  private MerkleTree depositMerkleTree;\n+\n+  @BeforeEach\n+  void setUp() {\n+    chainStorageClient = mock(ChainStorageClient.class);\n+    beaconState = mock(BeaconState.class);\n+\n+    depositMerkleTree = new OptimizedMerkleTree(Constants.DEPOSIT_CONTRACT_TREE_DEPTH);\n+    depositProvider = new DepositProvider(chainStorageClient);\n+\n+    createDepositEvents(40);\n+  }\n+\n+  @Test\n+  void stateEth1DepositIndexIsEqualToEth1DataDepositCount_NoDepositReturned() {\n+    Constants.MAX_DEPOSITS = 5;\n+    mockStateEth1DepositIndex(2);\n+    mockEth1DataDepositCount(2);\n+    mockDepositsFromEth1Block(0, 10);\n+    SSZList<Deposit> deposits = depositProvider.getDeposits(beaconState);\n+    assertThat(deposits).isEmpty();\n+  }\n+\n+  @Test\n+  void numberOfDepositsThatCanBeIncludedLessThanMaxDeposits() {\n+    mockStateEth1DepositIndex(5);\n+    mockEth1DataDepositCount(20);\n+\n+    Constants.MAX_DEPOSITS = 16;\n+\n+    mockDepositsFromEth1Block(0, 10);\n+    mockDepositsFromEth1Block(10, 20);\n+\n+    SSZList<Deposit> deposits = depositProvider.getDeposits(beaconState);\n+    assertThat(deposits).hasSize(15);\n+    checkThatDepositProofIsValid(deposits);\n+  }\n+\n+  @Test\n+  void numberOfDepositsThatCanBeIncludedMoreThanMaxDeposits() {\n+    mockStateEth1DepositIndex(5);\n+    mockEth1DataDepositCount(20);\n+\n+    Constants.MAX_DEPOSITS = 10;\n+\n+    mockDepositsFromEth1Block(0, 10);\n+    mockDepositsFromEth1Block(10, 20);\n+\n+    SSZList<Deposit> deposits = depositProvider.getDeposits(beaconState);\n+    assertThat(deposits).hasSize(10);\n+    checkThatDepositProofIsValid(deposits);\n+  }\n+\n+  @Test\n+  void depositsWithFinalizedIndicesGetPrunedFromMap() {\n+    Bytes32 finalizedBlockRoot = Bytes32.fromHexString(\"0x01\");\n+    mockStateEth1DepositIndex(10);\n+    mockDepositsFromEth1Block(0, 20);\n+    when(chainStorageClient.getBlockState(eq(finalizedBlockRoot)))\n+        .thenReturn(Optional.ofNullable(beaconState));\n+\n+    depositProvider.onFinalizedCheckpoint(\n+        new FinalizedCheckpointEvent(new Checkpoint(UnsignedLong.ONE, finalizedBlockRoot)));\n+\n+    assertThat(depositProvider.depositNavigableMap)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dbda195f19b8176ceb063aebf0a1ad09030b38f5"}, "originalPosition": 118}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f40129e2415718b75d65ed23c8b8e7978ce3a85c", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/f40129e2415718b75d65ed23c8b8e7978ce3a85c", "committedDate": "2020-02-18T18:31:09Z", "message": "Resolve comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3204216f945671aaa007e69de7b4bad95ba2e55b", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/3204216f945671aaa007e69de7b4bad95ba2e55b", "committedDate": "2020-02-18T18:47:17Z", "message": "Fix test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "78ac95d44b2ca5874bd91422b48580816975624c", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/78ac95d44b2ca5874bd91422b48580816975624c", "committedDate": "2020-02-18T18:48:17Z", "message": "Merge branch 'master' into implementDepositProvider"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYwNjYyNzA5", "url": "https://github.com/ConsenSys/teku/pull/1152#pullrequestreview-360662709", "createdAt": "2020-02-18T20:50:58Z", "commit": {"oid": "78ac95d44b2ca5874bd91422b48580816975624c"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQyMDo1MDo1OVrOFrR8YQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQyMDo1MDo1OVrOFrR8YQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDkyNzA3Mw==", "bodyText": "Can we make sure we have a ticket for this please? Will take a while to get that many deposits but definitely don't want to be caught by surprise.", "url": "https://github.com/ConsenSys/teku/pull/1152#discussion_r380927073", "createdAt": "2020-02-18T20:50:59Z", "author": {"login": "ajsutton"}, "path": "validator/coordinator/src/main/java/tech/pegasys/artemis/validator/coordinator/DepositProvider.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.validator.coordinator;\n+\n+import static java.lang.StrictMath.toIntExact;\n+import static tech.pegasys.artemis.util.config.Constants.DEPOSIT_CONTRACT_TREE_DEPTH;\n+import static tech.pegasys.artemis.util.config.Constants.MAX_DEPOSITS;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.List;\n+import java.util.NavigableMap;\n+import java.util.TreeMap;\n+import java.util.stream.Collectors;\n+import tech.pegasys.artemis.datastructures.operations.Deposit;\n+import tech.pegasys.artemis.datastructures.operations.DepositWithIndex;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.util.DepositUtil;\n+import tech.pegasys.artemis.datastructures.util.MerkleTree;\n+import tech.pegasys.artemis.datastructures.util.OptimizedMerkleTree;\n+import tech.pegasys.artemis.pow.api.DepositEventChannel;\n+import tech.pegasys.artemis.pow.event.DepositsFromBlockEvent;\n+import tech.pegasys.artemis.storage.ChainStorageClient;\n+import tech.pegasys.artemis.storage.api.FinalizedCheckpointEventChannel;\n+import tech.pegasys.artemis.storage.events.FinalizedCheckpointEvent;\n+import tech.pegasys.artemis.util.SSZTypes.SSZList;\n+\n+public class DepositProvider implements DepositEventChannel, FinalizedCheckpointEventChannel {\n+\n+  private final ChainStorageClient chainStorageClient;\n+  private final MerkleTree depositMerkleTree = new OptimizedMerkleTree(DEPOSIT_CONTRACT_TREE_DEPTH);\n+\n+  private NavigableMap<UnsignedLong, DepositWithIndex> depositNavigableMap = new TreeMap<>();\n+\n+  public DepositProvider(ChainStorageClient chainStorageClient) {\n+    this.chainStorageClient = chainStorageClient;\n+  }\n+\n+  @Override\n+  public void onDepositsFromBlock(DepositsFromBlockEvent event) {\n+    event.getDeposits().stream()\n+        .map(DepositUtil::convertDepositEventToOperationDeposit)\n+        .forEach(\n+            deposit -> {\n+              synchronized (DepositProvider.this) {\n+                depositNavigableMap.put(deposit.getIndex(), deposit);\n+                depositMerkleTree.add(deposit.getData().hash_tree_root());\n+              }\n+            });\n+  }\n+\n+  @Override\n+  public synchronized void onFinalizedCheckpoint(FinalizedCheckpointEvent event) {\n+    BeaconState finalizedState =\n+        chainStorageClient\n+            .getBlockState(event.getCheckpoint().getRoot())\n+            .orElseThrow(\n+                () -> new IllegalArgumentException(\"Finalized Checkpoint state can not be found.\"));\n+\n+    depositNavigableMap.headMap(finalizedState.getEth1_deposit_index()).clear();\n+  }\n+\n+  public SSZList<Deposit> getDeposits(BeaconState state) {\n+    UnsignedLong eth1DepositCount = state.getEth1_data().getDeposit_count();\n+\n+    UnsignedLong fromDepositIndex = state.getEth1_deposit_index();\n+    UnsignedLong latestDepositIndexWithMaxBlock =\n+        fromDepositIndex.plus(UnsignedLong.valueOf(MAX_DEPOSITS));\n+\n+    UnsignedLong toDepositIndex =\n+        latestDepositIndexWithMaxBlock.compareTo(eth1DepositCount) > 0\n+            ? eth1DepositCount\n+            : latestDepositIndexWithMaxBlock;\n+\n+    return new SSZList<>(\n+        getDepositsWithProof(fromDepositIndex, toDepositIndex, eth1DepositCount),\n+        MAX_DEPOSITS,\n+        Deposit.class);\n+  }\n+\n+  public int getDepositMapSize() {\n+    return depositNavigableMap.size();\n+  }\n+\n+  // TODO: switch the MerkleTree to use UnsignedLongs instead of using toIntExact() here,\n+  //  it will result in an overflow at some point", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78ac95d44b2ca5874bd91422b48580816975624c"}, "originalPosition": 96}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4038, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}