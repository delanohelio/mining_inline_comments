{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMxMDYyMDY2", "number": 3347, "title": "Heap optimize: reduce BeaconState.Validators backing tree memory consumption", "bodyText": "PR Description\nThis change optimizes BeaconState backing binary tree memory consumption. For 100K validators the memory footprint for backing tree drops from ~66Mb to ~14Mb.\nThe general idea is to merge 'low-level' subtree nodes into a single TreeNode structure (SszSuperNode) with a backing storage of ssz serialized bytes for this subtree. Updates to this structure (as well as hashTreeRoot recalculation) is more expensive in favor of memory effectiveness. This is well suited for BeaconState.validators list as it changes pretty rarely but takes over 95% of the whole state.\nThis PR applies SszSuperNode to sequences of 256 validators backing subtrees.\nFixed Issue(s)\n\n\nPartially fix #3031\nDocumentation\n\n I thought about documentation and added the documentation label to this PR if updates are required.", "createdAt": "2020-12-02T14:39:39Z", "url": "https://github.com/ConsenSys/teku/pull/3347", "merged": true, "mergeCommit": {"oid": "eac65c8e9d80dac09f307604abc484cb22374341"}, "closed": true, "closedAt": "2020-12-09T08:17:51Z", "author": {"login": "Nashatyrev"}, "timelineItems": {"totalCount": 28, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdiPfHCgH2gAyNTMxMDYyMDY2OmE2Y2M5OTQ1YzkyYWIzZGEzODI1YzdlYmRhODI5NGE0NGNiOGI4MmM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdkZ5-0AH2gAyNTMxMDYyMDY2OjRiZjFmY2M0YWIzZmNmMmVjNWI5Y2YxZWUwOWExYzYwYWY3NGQ1OWY=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "a6cc9945c92ab3da3825c7ebda8294a44cb8b82c", "author": {"user": {"login": "Nashatyrev", "name": "Anton Nashatyrev"}}, "url": "https://github.com/ConsenSys/teku/commit/a6cc9945c92ab3da3825c7ebda8294a44cb8b82c", "committedDate": "2020-12-02T14:33:13Z", "message": "Add SszSuperNode, TypeHints and add a hint to BeaconState.validators to use SszSuperNode in the list backing tree"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f2706b50bc8f61bbc661a5d2b90e91d0ee7c96da", "author": {"user": {"login": "Nashatyrev", "name": "Anton Nashatyrev"}}, "url": "https://github.com/ConsenSys/teku/commit/f2706b50bc8f61bbc661a5d2b90e91d0ee7c96da", "committedDate": "2020-12-02T14:34:59Z", "message": "Spotless"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6e3067f811359e5d37649bb50ccb52e42ef1b0cd", "author": {"user": {"login": "Nashatyrev", "name": "Anton Nashatyrev"}}, "url": "https://github.com/ConsenSys/teku/commit/6e3067f811359e5d37649bb50ccb52e42ef1b0cd", "committedDate": "2020-12-02T14:36:31Z", "message": "Remove obsolete test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "64c96d16d1893afa6b7551cfd902bee25a0a49a8", "author": {"user": {"login": "Nashatyrev", "name": "Anton Nashatyrev"}}, "url": "https://github.com/ConsenSys/teku/commit/64c96d16d1893afa6b7551cfd902bee25a0a49a8", "committedDate": "2020-12-02T14:55:28Z", "message": "Fix compiler warns"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5fd6687c3e09993c5dece307e0537f0e10ab994c", "author": {"user": {"login": "Nashatyrev", "name": "Anton Nashatyrev"}}, "url": "https://github.com/ConsenSys/teku/commit/5fd6687c3e09993c5dece307e0537f0e10ab994c", "committedDate": "2020-12-03T12:03:52Z", "message": "Fix TreeNode.toString() for large trees"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4e723a951d7d935638c7d6dee0ca1d150ef3bc38", "author": {"user": {"login": "Nashatyrev", "name": "Anton Nashatyrev"}}, "url": "https://github.com/ConsenSys/teku/commit/4e723a951d7d935638c7d6dee0ca1d150ef3bc38", "committedDate": "2020-12-03T12:05:16Z", "message": "Refactor SszNodeTemplate to be able to return subTemplate and fix SszSuperNode to be able to return subtrees"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9472146f850a9bd93e8729c69476b12d09c1933d", "author": {"user": {"login": "Nashatyrev", "name": "Anton Nashatyrev"}}, "url": "https://github.com/ConsenSys/teku/commit/9472146f850a9bd93e8729c69476b12d09c1933d", "committedDate": "2020-12-03T13:41:48Z", "message": "Fix SszSuperNode.hashTreeRoot bug"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5fa04833754c92bd8fd12953fa819d5620200952", "author": {"user": {"login": "Nashatyrev", "name": "Anton Nashatyrev"}}, "url": "https://github.com/ConsenSys/teku/commit/5fa04833754c92bd8fd12953fa819d5620200952", "committedDate": "2020-12-03T13:47:20Z", "message": "Spotless"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "27e3e5ddab46290d25c9ad570dc8612804aa6dee", "author": {"user": {"login": "Nashatyrev", "name": "Anton Nashatyrev"}}, "url": "https://github.com/ConsenSys/teku/commit/27e3e5ddab46290d25c9ad570dc8612804aa6dee", "committedDate": "2020-12-03T13:59:35Z", "message": "Remove obsolete test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8dd83b358df4a49c8a43cdb256e8c30a36bcdbce", "author": {"user": {"login": "Nashatyrev", "name": "Anton Nashatyrev"}}, "url": "https://github.com/ConsenSys/teku/commit/8dd83b358df4a49c8a43cdb256e8c30a36bcdbce", "committedDate": "2020-12-04T14:50:53Z", "message": "Add test for ListView with TypeHints"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "57d712306942c530860a4775213fc785d8f9b6c9", "author": {"user": {"login": "Nashatyrev", "name": "Anton Nashatyrev"}}, "url": "https://github.com/ConsenSys/teku/commit/57d712306942c530860a4775213fc785d8f9b6c9", "committedDate": "2020-12-07T09:26:06Z", "message": "Add equals/hashCode to List/VectorViewRead"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "66bc0008cfebd67b63386498422cb87b03bfe306", "author": {"user": {"login": "Nashatyrev", "name": "Anton Nashatyrev"}}, "url": "https://github.com/ConsenSys/teku/commit/66bc0008cfebd67b63386498422cb87b03bfe306", "committedDate": "2020-12-07T16:05:04Z", "message": "Add tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b330a1aa59d4672a057b8c757828108b3bcdab52", "author": {"user": {"login": "Nashatyrev", "name": "Anton Nashatyrev"}}, "url": "https://github.com/ConsenSys/teku/commit/b330a1aa59d4672a057b8c757828108b3bcdab52", "committedDate": "2020-12-07T16:05:49Z", "message": "Refactor SszNodeTemplate to use GeneralizedIndex based map"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ab9192d84594e4d967704eebcd534dfb1e054c4b", "author": {"user": {"login": "Nashatyrev", "name": "Anton Nashatyrev"}}, "url": "https://github.com/ConsenSys/teku/commit/ab9192d84594e4d967704eebcd534dfb1e054c4b", "committedDate": "2020-12-07T16:10:35Z", "message": "Spotless"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "01ad85d72c866a5b45115d1ae6917e5907be0ffb", "author": {"user": {"login": "Nashatyrev", "name": "Anton Nashatyrev"}}, "url": "https://github.com/ConsenSys/teku/commit/01ad85d72c866a5b45115d1ae6917e5907be0ffb", "committedDate": "2020-12-07T16:50:35Z", "message": "Implement optimized SszSuperNode.updated variant"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "76b5ab5e9cb854f59fd1752d7fc316b53be86805", "author": {"user": {"login": "Nashatyrev", "name": "Anton Nashatyrev"}}, "url": "https://github.com/ConsenSys/teku/commit/76b5ab5e9cb854f59fd1752d7fc316b53be86805", "committedDate": "2020-12-07T17:22:45Z", "message": "Add javadocs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bf8e497a9c6bc7712e57ed115f116bfddf19e504", "author": {"user": {"login": "Nashatyrev", "name": "Anton Nashatyrev"}}, "url": "https://github.com/ConsenSys/teku/commit/bf8e497a9c6bc7712e57ed115f116bfddf19e504", "committedDate": "2020-12-07T17:25:52Z", "message": "Remove accidentally committed debug code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eb9659586403f90447511464e312877134dcd68e", "author": {"user": {"login": "Nashatyrev", "name": "Anton Nashatyrev"}}, "url": "https://github.com/ConsenSys/teku/commit/eb9659586403f90447511464e312877134dcd68e", "committedDate": "2020-12-07T17:33:03Z", "message": "Fix the LeafDataNode class name and add javadocs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "60ea403a35293925bea3ce790607086c52b7abcc", "author": {"user": {"login": "Nashatyrev", "name": "Anton Nashatyrev"}}, "url": "https://github.com/ConsenSys/teku/commit/60ea403a35293925bea3ce790607086c52b7abcc", "committedDate": "2020-12-07T17:37:09Z", "message": "Minor refactoring of SszNodeTemplate"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2881b5fa48b0f51577a2f5de73014910fc598ff9", "author": {"user": {"login": "Nashatyrev", "name": "Anton Nashatyrev"}}, "url": "https://github.com/ConsenSys/teku/commit/2881b5fa48b0f51577a2f5de73014910fc598ff9", "committedDate": "2020-12-07T18:00:46Z", "message": "Fix javadoc html"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b3d07885c2ff6ee726d799eb39df027de952319e", "author": {"user": {"login": "Nashatyrev", "name": "Anton Nashatyrev"}}, "url": "https://github.com/ConsenSys/teku/commit/b3d07885c2ff6ee726d799eb39df027de952319e", "committedDate": "2020-12-07T18:17:59Z", "message": "Merge branch 'master' into optimize/state-tree-validators"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ2NzA1MTA3", "url": "https://github.com/ConsenSys/teku/pull/3347#pullrequestreview-546705107", "createdAt": "2020-12-08T02:49:37Z", "commit": {"oid": "b3d07885c2ff6ee726d799eb39df027de952319e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwMjo0OTozN1rOIBEdsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwMjo0OTozN1rOIBEdsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk5MjYyNw==", "bodyText": "Understanding this took me way too long. But beautiful...", "url": "https://github.com/ConsenSys/teku/pull/3347#discussion_r537992627", "createdAt": "2020-12-08T02:49:37Z", "author": {"login": "cemozerr"}, "path": "ssz/src/main/java/tech/pegasys/teku/ssz/backing/tree/SszNodeTemplate.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.ssz.backing.tree;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static tech.pegasys.teku.ssz.backing.tree.GIndexUtil.LEFTMOST_G_INDEX;\n+import static tech.pegasys.teku.ssz.backing.tree.GIndexUtil.RIGHTMOST_G_INDEX;\n+import static tech.pegasys.teku.ssz.backing.tree.GIndexUtil.SELF_G_INDEX;\n+import static tech.pegasys.teku.ssz.backing.tree.GIndexUtil.gIdxIsSelf;\n+import static tech.pegasys.teku.ssz.backing.tree.GIndexUtil.gIdxLeftGIndex;\n+import static tech.pegasys.teku.ssz.backing.tree.GIndexUtil.gIdxRightGIndex;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.apache.tuweni.bytes.MutableBytes;\n+import org.apache.tuweni.crypto.Hash;\n+import tech.pegasys.teku.ssz.backing.type.ViewType;\n+\n+/**\n+ * Represents the tree structure for a fixed size SSZ type See {@link SszSuperNode} docs for more\n+ * details\n+ */\n+public class SszNodeTemplate {\n+\n+  static final class Location {\n+    private final int offset;\n+    private final int length;\n+    private final boolean leaf;\n+\n+    public Location(int offset, int length, boolean leaf) {\n+      this.offset = offset;\n+      this.length = length;\n+      this.leaf = leaf;\n+    }\n+\n+    public Location withAddedOffset(int addOffset) {\n+      return new Location(getOffset() + addOffset, getLength(), isLeaf());\n+    }\n+\n+    public int getOffset() {\n+      return offset;\n+    }\n+\n+    public int getLength() {\n+      return length;\n+    }\n+\n+    public boolean isLeaf() {\n+      return leaf;\n+    }\n+  }\n+\n+  public static SszNodeTemplate createFromType(ViewType viewType) {\n+    checkArgument(viewType.isFixedSize(), \"Only fixed size types supported\");\n+\n+    return createFromTree(viewType.getDefaultTree());\n+  }\n+\n+  // This should be CANONICAL binary tree\n+  private static SszNodeTemplate createFromTree(TreeNode defaultTree) {\n+    Map<Long, Location> gIdxToLoc =\n+        binaryTraverse(\n+            GIndexUtil.SELF_G_INDEX,\n+            defaultTree,\n+            new BinaryVisitor<>() {\n+              @Override\n+              public Map<Long, Location> visitLeaf(long gIndex, LeafNode node) {\n+                Map<Long, Location> ret = new HashMap<>();\n+                ret.put(gIndex, new Location(0, node.getData().size(), true));\n+                return ret;\n+              }\n+\n+              @Override\n+              public Map<Long, Location> visitBranch(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3d07885c2ff6ee726d799eb39df027de952319e"}, "originalPosition": 90}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ3Mzc1NTk1", "url": "https://github.com/ConsenSys/teku/pull/3347#pullrequestreview-547375595", "createdAt": "2020-12-08T15:58:04Z", "commit": {"oid": "b3d07885c2ff6ee726d799eb39df027de952319e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNTo1ODowNFrOIBla9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNTo1ODowNFrOIBla9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODUzMjU5OQ==", "bodyText": "This might make the code easier to read and make the code more defensive.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  } else {\n          \n          \n            \n                  } else if (offset == ssz.size()) {\n          \n          \n            \n                    return DEFAULT_NODE.hashTreeRoot();\n          \n          \n            \n                  } else {\n          \n          \n            \n                    throw new IllegalStateException(\"Offset can not be greater than ssz length\");\n          \n          \n            \n                  }", "url": "https://github.com/ConsenSys/teku/pull/3347#discussion_r538532599", "createdAt": "2020-12-08T15:58:04Z", "author": {"login": "cemozerr"}, "path": "ssz/src/main/java/tech/pegasys/teku/ssz/backing/tree/SszSuperNode.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.ssz.backing.tree;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static tech.pegasys.teku.ssz.backing.tree.GIndexUtil.gIdxCompare;\n+import static tech.pegasys.teku.ssz.backing.tree.GIndexUtil.gIdxGetChildIndex;\n+import static tech.pegasys.teku.ssz.backing.tree.GIndexUtil.gIdxGetRelativeGIndex;\n+import static tech.pegasys.teku.ssz.backing.tree.GIndexUtil.gIdxIsSelf;\n+\n+import com.google.common.base.Supplier;\n+import com.google.common.base.Suppliers;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.apache.tuweni.bytes.MutableBytes;\n+import org.apache.tuweni.crypto.Hash;\n+import org.jetbrains.annotations.NotNull;\n+import tech.pegasys.teku.ssz.backing.tree.GIndexUtil.NodeRelation;\n+import tech.pegasys.teku.ssz.backing.tree.SszNodeTemplate.Location;\n+\n+/**\n+ * Stores consecutive elements of the same fixed size type as a single packed bytes of their leaves\n+ * (this representation exactly matches SSZ representation of elements sequence).\n+ *\n+ * <p>This node represents a subtree of binary merkle tree for sequence (list or vector) of elements\n+ * with maximum length of <code>2 ^ depth</code>. If the sequence has less than maximum elements\n+ * then <code>ssz</code> bytes store only existing elements (what again matches SSZ representation\n+ * of a list)\n+ *\n+ * <p>To address individual nodes inside elements and resolve their internal generalized indexes the\n+ * node uses {@link SszNodeTemplate} which represents element type tree structure\n+ *\n+ * <p>This node favors memory efficiency over update performance and thus is the best choice for\n+ * rarely updated and space consuming structures (e.g. Eth2 <code>BeaconState.validators</code>\n+ * list)\n+ */\n+public class SszSuperNode implements TreeNode, LeafDataNode {\n+  private static final TreeNode DEFAULT_NODE = LeafNode.EMPTY_LEAF;\n+\n+  private final int depth;\n+  private final SszNodeTemplate elementTemplate;\n+  private final Bytes ssz;\n+  private final Supplier<Bytes32> hashTreeRoot = Suppliers.memoize(this::calcHashTreeRoot);\n+\n+  public SszSuperNode(int depth, SszNodeTemplate elementTemplate, Bytes ssz) {\n+    this.depth = depth;\n+    this.elementTemplate = elementTemplate;\n+    this.ssz = ssz;\n+    checkArgument(ssz.size() % elementTemplate.getSszLength() == 0);\n+    checkArgument(getElementsCount() <= getMaxElements());\n+  }\n+\n+  private int getMaxElements() {\n+    return 1 << depth;\n+  }\n+\n+  private int getElementsCount() {\n+    return ssz.size() / elementTemplate.getSszLength();\n+  }\n+\n+  @Override\n+  public Bytes32 hashTreeRoot() {\n+    return hashTreeRoot.get();\n+  }\n+\n+  private Bytes32 calcHashTreeRoot() {\n+    return hashTreeRoot(0, 0);\n+  }\n+\n+  private Bytes32 hashTreeRoot(int curDepth, int offset) {\n+    if (curDepth == depth) {\n+      if (offset < ssz.size()) {\n+        return elementTemplate.calculateHashTreeRoot(ssz, offset);\n+      } else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3d07885c2ff6ee726d799eb39df027de952319e"}, "originalPosition": 87}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ3NDIxMzk3", "url": "https://github.com/ConsenSys/teku/pull/3347#pullrequestreview-547421397", "createdAt": "2020-12-08T16:44:44Z", "commit": {"oid": "b3d07885c2ff6ee726d799eb39df027de952319e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNjo0NDo0NVrOIBoqUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNjo0NDo0NVrOIBoqUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODU4NTY4Mg==", "bodyText": "Would it make more sense to do the ssz update on the SszSuperNode object rather than the template? To me the template seems to almost exclusively deal with the structure/location of the trees", "url": "https://github.com/ConsenSys/teku/pull/3347#discussion_r538585682", "createdAt": "2020-12-08T16:44:45Z", "author": {"login": "cemozerr"}, "path": "ssz/src/main/java/tech/pegasys/teku/ssz/backing/tree/SszSuperNode.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.ssz.backing.tree;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static tech.pegasys.teku.ssz.backing.tree.GIndexUtil.gIdxCompare;\n+import static tech.pegasys.teku.ssz.backing.tree.GIndexUtil.gIdxGetChildIndex;\n+import static tech.pegasys.teku.ssz.backing.tree.GIndexUtil.gIdxGetRelativeGIndex;\n+import static tech.pegasys.teku.ssz.backing.tree.GIndexUtil.gIdxIsSelf;\n+\n+import com.google.common.base.Supplier;\n+import com.google.common.base.Suppliers;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.apache.tuweni.bytes.MutableBytes;\n+import org.apache.tuweni.crypto.Hash;\n+import org.jetbrains.annotations.NotNull;\n+import tech.pegasys.teku.ssz.backing.tree.GIndexUtil.NodeRelation;\n+import tech.pegasys.teku.ssz.backing.tree.SszNodeTemplate.Location;\n+\n+/**\n+ * Stores consecutive elements of the same fixed size type as a single packed bytes of their leaves\n+ * (this representation exactly matches SSZ representation of elements sequence).\n+ *\n+ * <p>This node represents a subtree of binary merkle tree for sequence (list or vector) of elements\n+ * with maximum length of <code>2 ^ depth</code>. If the sequence has less than maximum elements\n+ * then <code>ssz</code> bytes store only existing elements (what again matches SSZ representation\n+ * of a list)\n+ *\n+ * <p>To address individual nodes inside elements and resolve their internal generalized indexes the\n+ * node uses {@link SszNodeTemplate} which represents element type tree structure\n+ *\n+ * <p>This node favors memory efficiency over update performance and thus is the best choice for\n+ * rarely updated and space consuming structures (e.g. Eth2 <code>BeaconState.validators</code>\n+ * list)\n+ */\n+public class SszSuperNode implements TreeNode, LeafDataNode {\n+  private static final TreeNode DEFAULT_NODE = LeafNode.EMPTY_LEAF;\n+\n+  private final int depth;\n+  private final SszNodeTemplate elementTemplate;\n+  private final Bytes ssz;\n+  private final Supplier<Bytes32> hashTreeRoot = Suppliers.memoize(this::calcHashTreeRoot);\n+\n+  public SszSuperNode(int depth, SszNodeTemplate elementTemplate, Bytes ssz) {\n+    this.depth = depth;\n+    this.elementTemplate = elementTemplate;\n+    this.ssz = ssz;\n+    checkArgument(ssz.size() % elementTemplate.getSszLength() == 0);\n+    checkArgument(getElementsCount() <= getMaxElements());\n+  }\n+\n+  private int getMaxElements() {\n+    return 1 << depth;\n+  }\n+\n+  private int getElementsCount() {\n+    return ssz.size() / elementTemplate.getSszLength();\n+  }\n+\n+  @Override\n+  public Bytes32 hashTreeRoot() {\n+    return hashTreeRoot.get();\n+  }\n+\n+  private Bytes32 calcHashTreeRoot() {\n+    return hashTreeRoot(0, 0);\n+  }\n+\n+  private Bytes32 hashTreeRoot(int curDepth, int offset) {\n+    if (curDepth == depth) {\n+      if (offset < ssz.size()) {\n+        return elementTemplate.calculateHashTreeRoot(ssz, offset);\n+      } else {\n+        return DEFAULT_NODE.hashTreeRoot();\n+      }\n+    } else {\n+      return Hash.sha2_256(\n+          Bytes.wrap(\n+              hashTreeRoot(curDepth + 1, offset),\n+              hashTreeRoot(\n+                  curDepth + 1,\n+                  offset + elementTemplate.getSszLength() * (1 << ((depth - curDepth) - 1)))));\n+    }\n+  }\n+\n+  @NotNull\n+  @Override\n+  public TreeNode get(long generalizedIndex) {\n+    if (gIdxIsSelf(generalizedIndex)) {\n+      return this;\n+    }\n+    int childIndex = gIdxGetChildIndex(generalizedIndex, depth);\n+    int childOffset = childIndex * elementTemplate.getSszLength();\n+    checkArgument(childOffset < ssz.size(), \"Invalid index\");\n+    long relativeGIndex = gIdxGetRelativeGIndex(generalizedIndex, depth);\n+    Location nodeLoc = elementTemplate.getNodeSszLocation(relativeGIndex);\n+    if (nodeLoc.isLeaf()) {\n+      return LeafNode.create(ssz.slice(childOffset + nodeLoc.getOffset(), nodeLoc.getLength()));\n+    } else if (gIdxIsSelf(relativeGIndex)) {\n+      return new SszSuperNode(\n+          0, elementTemplate, ssz.slice(childOffset, elementTemplate.getSszLength()));\n+    } else {\n+      SszNodeTemplate subTemplate = elementTemplate.getSubTemplate(relativeGIndex);\n+      return new SszSuperNode(\n+          0, subTemplate, ssz.slice(childOffset + nodeLoc.getOffset(), nodeLoc.getLength()));\n+    }\n+  }\n+\n+  @Override\n+  public boolean iterate(\n+      long thisGeneralizedIndex, long startGeneralizedIndex, TreeVisitor visitor) {\n+    if (gIdxCompare(thisGeneralizedIndex, startGeneralizedIndex) == NodeRelation.Left) {\n+      return true;\n+    } else {\n+      return visitor.visit(this, thisGeneralizedIndex);\n+    }\n+  }\n+\n+  @Override\n+  public TreeNode updated(TreeUpdates newNodes) {\n+    if (newNodes.isEmpty()) {\n+      return this;\n+    }\n+    long leftmostUpdateIndex = newNodes.getRelativeGIndex(newNodes.size() - 1);\n+    int leftmostChildIndex = gIdxGetChildIndex(leftmostUpdateIndex, depth);\n+    int newSszSize = (leftmostChildIndex + 1) * elementTemplate.getSszLength();\n+    Bytes updatedSizeSsz =\n+        newSszSize <= ssz.size()\n+            ? ssz\n+            : Bytes.wrap(ssz, Bytes.wrap(new byte[newSszSize - ssz.size()]));\n+    MutableBytes mutableCopy = updatedSizeSsz.mutableCopy();\n+    for (int i = 0; i < newNodes.size(); i++) {\n+      long updateGIndex = newNodes.getRelativeGIndex(i);\n+      int childIndex = gIdxGetChildIndex(updateGIndex, depth);\n+      long childGIndex = gIdxGetRelativeGIndex(updateGIndex, depth);\n+      int childOffset = childIndex * elementTemplate.getSszLength();\n+      MutableBytes childMutableSlice =\n+          mutableCopy.mutableSlice(childOffset, elementTemplate.getSszLength());\n+      elementTemplate.update(childGIndex, newNodes.getNode(i), childMutableSlice);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3d07885c2ff6ee726d799eb39df027de952319e"}, "originalPosition": 153}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d6eec77b174ac25eaf5fad12d24d10cfaa3b51a9", "author": {"user": {"login": "Nashatyrev", "name": "Anton Nashatyrev"}}, "url": "https://github.com/ConsenSys/teku/commit/d6eec77b174ac25eaf5fad12d24d10cfaa3b51a9", "committedDate": "2020-12-08T17:37:30Z", "message": "Add assertion to double check offset"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9f44ee31e3b8fba63b0a9f61c2a8d92498052c33", "author": {"user": {"login": "Nashatyrev", "name": "Anton Nashatyrev"}}, "url": "https://github.com/ConsenSys/teku/commit/9f44ee31e3b8fba63b0a9f61c2a8d92498052c33", "committedDate": "2020-12-08T17:38:01Z", "message": "Merge remote-tracking branch 'origin/optimize/state-tree-validators' into optimize/state-tree-validators"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ3NTQxNDc2", "url": "https://github.com/ConsenSys/teku/pull/3347#pullrequestreview-547541476", "createdAt": "2020-12-08T19:02:43Z", "commit": {"oid": "9f44ee31e3b8fba63b0a9f61c2a8d92498052c33"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4bf1fcc4ab3fcf2ec5b9cf1ee09a1c60af74d59f", "author": {"user": {"login": "Nashatyrev", "name": "Anton Nashatyrev"}}, "url": "https://github.com/ConsenSys/teku/commit/4bf1fcc4ab3fcf2ec5b9cf1ee09a1c60af74d59f", "committedDate": "2020-12-09T07:49:28Z", "message": "Merge branch 'master' into optimize/state-tree-validators"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4336, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}