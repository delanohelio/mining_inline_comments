{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY1NzI5MDUx", "number": 2547, "title": "[Issue-2438] Rework checks to trigger peer sync", "bodyText": "PR Description\nRework logic to trigger peer sync:\n\nAdd some sanity checks to make sure peers aren't broadcasting a chain state from the future\nBe more consistent wrt how head slot / finalized epoch triggers sync:\n\nA peer's finalized epoch must now be > 1 epoch ahead, in line with the head slot check which only triggers a sync if the peer's head slot is > 1 epoch ahead.\n\n\n\nThe change to the finalized epoch trigger helps us avoid triggering a sync too aggressively in the following scenario:\n\nOur local node is missing a very recent block at an epoch boundary that will cause our finalized block to advance\nA peer has this additional block, causing us to see that the peer's finalized epoch is ahead of our node\n\nFixed Issue(s)\nFixes #2438\nDocumentation\n\n I thought about documentation and added the documentation label to this PR if updates are required.", "createdAt": "2020-08-10T21:00:35Z", "url": "https://github.com/ConsenSys/teku/pull/2547", "merged": true, "mergeCommit": {"oid": "60985dba8db6896d750b0e0a4993a5f972b97406"}, "closed": true, "closedAt": "2020-08-10T22:10:57Z", "author": {"login": "mbaxter"}, "timelineItems": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc9oemGgH2gAyNDY1NzI5MDUxOmJmZDEzOTQ1ZDk5MzljNDNiZWMzMDg3YzM3YWQ2NDIzYjk3NzczMDU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc9pgJagH2gAyNDY1NzI5MDUxOjI5MjU2NDE5YmFlYzU3NDlhNjA5MDRjMTU4ZmM5YmMyNzdmYTE4NjQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "bfd13945d9939c43bec3087c37ad6423b9777305", "author": {"user": {"login": "mbaxter", "name": null}}, "url": "https://github.com/ConsenSys/teku/commit/bfd13945d9939c43bec3087c37ad6423b9777305", "committedDate": "2020-08-10T20:45:05Z", "message": "Rework checks to trigger peer sync"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "123d6c24c5446988026cf3011d6033888cb5fefd", "author": {"user": {"login": "mbaxter", "name": null}}, "url": "https://github.com/ConsenSys/teku/commit/123d6c24c5446988026cf3011d6033888cb5fefd", "committedDate": "2020-08-10T21:03:34Z", "message": "Save slot-based threshold to constant"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7a17ea5a25a532712c8baccbe742be84407ec366", "author": {"user": {"login": "mbaxter", "name": null}}, "url": "https://github.com/ConsenSys/teku/commit/7a17ea5a25a532712c8baccbe742be84407ec366", "committedDate": "2020-08-10T21:16:21Z", "message": "Merge branch 'master' into issue-2438/rework-sync-trigger"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0NjAwMDYy", "url": "https://github.com/ConsenSys/teku/pull/2547#pullrequestreview-464600062", "createdAt": "2020-08-10T21:27:03Z", "commit": {"oid": "7a17ea5a25a532712c8baccbe742be84407ec366"}, "state": "APPROVED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQyMToyNzowM1rOG-gY8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQyMToyOToxN1rOG-gdGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE5NTU2OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                return peerStatus.getFinalizedEpoch().compareTo(currentEpoch) <= 0\n          \n          \n            \n                    && peerStatus.getHeadSlot().compareTo(currentSlot.plus(slotErrorThreshold)) <= 0;\n          \n          \n            \n                return peerStatus.getFinalizedEpoch().isLessThanOrEqualTo(currentEpoch)\n          \n          \n            \n                    && peerStatus.getHeadSlot().isLessThanOrEqualTo(currentSlot.plus(slotErrorThreshold));", "url": "https://github.com/ConsenSys/teku/pull/2547#discussion_r468195568", "createdAt": "2020-08-10T21:27:03Z", "author": {"login": "ajsutton"}, "path": "sync/src/main/java/tech/pegasys/teku/sync/SyncManager.java", "diffHunk": "@@ -255,14 +260,35 @@ private boolean isPeerSyncSuitable(Eth2Peer peer) {\n         \"Looking for suitable peer (out of {}) with finalized epoch > {}.\",\n         network.getPeerCount(),\n         ourFinalizedEpoch);\n+\n+    final PeerStatus peerStatus = peer.getStatus();\n     return !peersWithSyncErrors.contains(peer.getId())\n-        && (peer.getStatus().getFinalizedEpoch().compareTo(ourFinalizedEpoch) > 0\n-            || isHeadMoreThanAnEpochAhead(peer));\n+        && peerStatusIsConsistentWithOurNode(peerStatus)\n+        && peerIsAheadOfOurNode(peerStatus, ourFinalizedEpoch);\n+  }\n+\n+  /** Make sure remote peer is not broadcasting a chain state from the future. */\n+  private boolean peerStatusIsConsistentWithOurNode(final PeerStatus peerStatus) {\n+    final UInt64 currentSlot = storageClient.getCurrentSlot().orElse(UInt64.ZERO);\n+    final UInt64 currentEpoch = compute_epoch_at_slot(currentSlot);\n+    final UInt64 slotErrorThreshold = UInt64.ONE;\n+\n+    return peerStatus.getFinalizedEpoch().compareTo(currentEpoch) <= 0\n+        && peerStatus.getHeadSlot().compareTo(currentSlot.plus(slotErrorThreshold)) <= 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a17ea5a25a532712c8baccbe742be84407ec366"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE5NTgzNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                return peerStatus.getFinalizedEpoch().compareTo(finalizedEpochThreshold) > 0\n          \n          \n            \n                return peerStatus.getFinalizedEpoch().isGreaterThan(finalizedEpochThreshold)", "url": "https://github.com/ConsenSys/teku/pull/2547#discussion_r468195834", "createdAt": "2020-08-10T21:27:38Z", "author": {"login": "ajsutton"}, "path": "sync/src/main/java/tech/pegasys/teku/sync/SyncManager.java", "diffHunk": "@@ -255,14 +260,35 @@ private boolean isPeerSyncSuitable(Eth2Peer peer) {\n         \"Looking for suitable peer (out of {}) with finalized epoch > {}.\",\n         network.getPeerCount(),\n         ourFinalizedEpoch);\n+\n+    final PeerStatus peerStatus = peer.getStatus();\n     return !peersWithSyncErrors.contains(peer.getId())\n-        && (peer.getStatus().getFinalizedEpoch().compareTo(ourFinalizedEpoch) > 0\n-            || isHeadMoreThanAnEpochAhead(peer));\n+        && peerStatusIsConsistentWithOurNode(peerStatus)\n+        && peerIsAheadOfOurNode(peerStatus, ourFinalizedEpoch);\n+  }\n+\n+  /** Make sure remote peer is not broadcasting a chain state from the future. */\n+  private boolean peerStatusIsConsistentWithOurNode(final PeerStatus peerStatus) {\n+    final UInt64 currentSlot = storageClient.getCurrentSlot().orElse(UInt64.ZERO);\n+    final UInt64 currentEpoch = compute_epoch_at_slot(currentSlot);\n+    final UInt64 slotErrorThreshold = UInt64.ONE;\n+\n+    return peerStatus.getFinalizedEpoch().compareTo(currentEpoch) <= 0\n+        && peerStatus.getHeadSlot().compareTo(currentSlot.plus(slotErrorThreshold)) <= 0;\n   }\n \n-  private boolean isHeadMoreThanAnEpochAhead(final Eth2Peer peer) {\n+  private boolean peerIsAheadOfOurNode(\n+      final PeerStatus peerStatus, final UInt64 ourFinalizedEpoch) {\n+    final UInt64 finalizedEpochThreshold = ourFinalizedEpoch.plus(SYNC_THRESHOLD_IN_EPOCHS);\n+\n+    return peerStatus.getFinalizedEpoch().compareTo(finalizedEpochThreshold) > 0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a17ea5a25a532712c8baccbe742be84407ec366"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE5NTk5NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                return peerStatus.getHeadSlot().compareTo(headSlotThreshold) > 0;\n          \n          \n            \n                return peerStatus.getHeadSlot().isGreaterThan(headSlotThreshold);", "url": "https://github.com/ConsenSys/teku/pull/2547#discussion_r468195995", "createdAt": "2020-08-10T21:27:59Z", "author": {"login": "ajsutton"}, "path": "sync/src/main/java/tech/pegasys/teku/sync/SyncManager.java", "diffHunk": "@@ -255,14 +260,35 @@ private boolean isPeerSyncSuitable(Eth2Peer peer) {\n         \"Looking for suitable peer (out of {}) with finalized epoch > {}.\",\n         network.getPeerCount(),\n         ourFinalizedEpoch);\n+\n+    final PeerStatus peerStatus = peer.getStatus();\n     return !peersWithSyncErrors.contains(peer.getId())\n-        && (peer.getStatus().getFinalizedEpoch().compareTo(ourFinalizedEpoch) > 0\n-            || isHeadMoreThanAnEpochAhead(peer));\n+        && peerStatusIsConsistentWithOurNode(peerStatus)\n+        && peerIsAheadOfOurNode(peerStatus, ourFinalizedEpoch);\n+  }\n+\n+  /** Make sure remote peer is not broadcasting a chain state from the future. */\n+  private boolean peerStatusIsConsistentWithOurNode(final PeerStatus peerStatus) {\n+    final UInt64 currentSlot = storageClient.getCurrentSlot().orElse(UInt64.ZERO);\n+    final UInt64 currentEpoch = compute_epoch_at_slot(currentSlot);\n+    final UInt64 slotErrorThreshold = UInt64.ONE;\n+\n+    return peerStatus.getFinalizedEpoch().compareTo(currentEpoch) <= 0\n+        && peerStatus.getHeadSlot().compareTo(currentSlot.plus(slotErrorThreshold)) <= 0;\n   }\n \n-  private boolean isHeadMoreThanAnEpochAhead(final Eth2Peer peer) {\n+  private boolean peerIsAheadOfOurNode(\n+      final PeerStatus peerStatus, final UInt64 ourFinalizedEpoch) {\n+    final UInt64 finalizedEpochThreshold = ourFinalizedEpoch.plus(SYNC_THRESHOLD_IN_EPOCHS);\n+\n+    return peerStatus.getFinalizedEpoch().compareTo(finalizedEpochThreshold) > 0\n+        || isPeerHeadSlotAhead(peerStatus);\n+  }\n+\n+  private boolean isPeerHeadSlotAhead(final PeerStatus peerStatus) {\n     final UInt64 ourHeadSlot = storageClient.getBestSlot();\n-    final UInt64 theirHeadSlot = peer.getStatus().getHeadSlot();\n-    return theirHeadSlot.compareTo(ourHeadSlot.plus(UInt64.valueOf(SLOTS_PER_EPOCH))) > 0;\n+    final UInt64 headSlotThreshold = ourHeadSlot.plus(SYNC_THRESHOLD_IN_SLOTS);\n+\n+    return peerStatus.getHeadSlot().compareTo(headSlotThreshold) > 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a17ea5a25a532712c8baccbe742be84407ec366"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE5NjYzNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    PEER_STATUS.getHeadSlot().minus(UInt64.valueOf(Constants.SLOTS_PER_EPOCH + 1));\n          \n          \n            \n                    PEER_STATUS.getHeadSlot().minus(Constants.SLOTS_PER_EPOCH + 1);", "url": "https://github.com/ConsenSys/teku/pull/2547#discussion_r468196634", "createdAt": "2020-08-10T21:29:17Z", "author": {"login": "ajsutton"}, "path": "sync/src/test/java/tech/pegasys/teku/sync/SyncManagerTest.java", "diffHunk": "@@ -116,12 +168,59 @@ void sync_existingPeers() {\n     assertThat(syncManager.isSyncQueued()).isFalse();\n   }\n \n+  @Test\n+  void sync_existingPeers_remoteHeadSlotIsAheadButWithinErrorThreshold() {\n+    final UInt64 headSlot = PEER_HEAD_SLOT.minus(UInt64.ONE);\n+    localSlot.set(headSlot);\n+\n+    when(network.streamPeers()).thenReturn(Stream.of(peer));\n+\n+    final SafeFuture<PeerSyncResult> syncFuture = new SafeFuture<>();\n+    when(peerSync.sync(peer)).thenReturn(syncFuture);\n+\n+    assertThat(syncManager.start()).isCompleted();\n+    assertThat(syncManager.isSyncActive()).isTrue();\n+    assertThat(syncManager.isSyncQueued()).isFalse();\n+\n+    verify(peerSync).sync(peer);\n+\n+    // Signal the peer sync is complete\n+    syncFuture.complete(PeerSyncResult.SUCCESSFUL_SYNC);\n+\n+    // Check that the sync is done and the peer was not disconnected.\n+    assertThat(syncManager.isSyncActive()).isFalse();\n+    assertThat(syncManager.isSyncQueued()).isFalse();\n+  }\n+\n+  @Test\n+  void sync_existingPeers_peerFinalizedEpochMoreThan1EpochAhead() {\n+    setLocalChainState(\n+        PEER_STATUS.getHeadSlot(), PEER_STATUS.getFinalizedEpoch().minus(UInt64.valueOf(2)));\n+    when(network.streamPeers()).thenReturn(Stream.of(peer));\n+\n+    final SafeFuture<PeerSyncResult> syncFuture = new SafeFuture<>();\n+    when(peerSync.sync(peer)).thenReturn(syncFuture);\n+\n+    assertThat(syncManager.start()).isCompleted();\n+    assertThat(syncManager.isSyncActive()).isTrue();\n+    assertThat(syncManager.isSyncQueued()).isFalse();\n+\n+    verify(peerSync).sync(peer);\n+\n+    // Signal the peer sync is complete\n+    syncFuture.complete(PeerSyncResult.SUCCESSFUL_SYNC);\n+\n+    // Check that the sync is done and the peer was not disconnected.\n+    assertThat(syncManager.isSyncActive()).isFalse();\n+    assertThat(syncManager.isSyncQueued()).isFalse();\n+  }\n+\n   @Test\n   void sync_existingPeerWithSameFinalizedEpochButMuchBetterHeadSlot() {\n     when(network.streamPeers()).thenReturn(Stream.of(peer));\n-    when(storageClient.getFinalizedEpoch()).thenReturn(PEER_STATUS.getFinalizedEpoch());\n-    when(storageClient.getBestSlot())\n-        .thenReturn(PEER_STATUS.getHeadSlot().minus(UInt64.valueOf(Constants.SLOTS_PER_EPOCH + 1)));\n+    final UInt64 oldHeadSlot =\n+        PEER_STATUS.getHeadSlot().minus(UInt64.valueOf(Constants.SLOTS_PER_EPOCH + 1));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7a17ea5a25a532712c8baccbe742be84407ec366"}, "originalPosition": 145}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "29256419baec5749a60904c158fc9bc277fa1864", "author": {"user": {"login": "mbaxter", "name": null}}, "url": "https://github.com/ConsenSys/teku/commit/29256419baec5749a60904c158fc9bc277fa1864", "committedDate": "2020-08-10T21:56:41Z", "message": "Use new UInt64 helpers"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3609, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}