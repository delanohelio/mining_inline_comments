{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU0NzgwODQ5", "number": 2419, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQwMTozOTowNVrOEQ20UA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQwMTozOTowNVrOEQ20UA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MTEwODAwOnYy", "diffSide": "RIGHT", "path": "protoarray/src/main/java/tech/pegasys/teku/protoarray/ProtoArrayForkChoiceStrategy.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQwMTozOTowNVrOG1PmtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxODo1NDozN1rOG1v67A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ4MzM4MA==", "bodyText": "If the blocks are immediately available, do we have a risk of a stack overflow exception here because of the number of chained futures?  I think at worst we'd have 10 epochs worth of blocks held in memory so 320 blocks.\nProbably worth having a test for it, or just deliberately use a thenAcceptAsync variant. Not sure if using the default fork choice pool is sensible here or if we should ensure it goes onto one of the threads own by an AsyncRunner or not (which would require a new method in SafeFuture to support).", "url": "https://github.com/ConsenSys/teku/pull/2419#discussion_r458483380", "createdAt": "2020-07-22T01:39:05Z", "author": {"login": "ajsutton"}, "path": "protoarray/src/main/java/tech/pegasys/teku/protoarray/ProtoArrayForkChoiceStrategy.java", "diffHunk": "@@ -144,27 +145,38 @@ public void maybePrune(Bytes32 finalizedRoot) {\n   }\n \n   // Internal\n-  private static void processBlocksInStoreAtStartup(ReadOnlyStore store, ProtoArray protoArray) {\n+  private static SafeFuture<Void> processBlocksInStoreAtStartup(\n+      PrunableStore store, ProtoArray protoArray) {\n     List<Bytes32> alreadyIncludedBlockRoots =\n         protoArray.getNodes().stream().map(ProtoNode::getBlockRoot).collect(Collectors.toList());\n \n-    store.getBlockRoots().stream()\n-        .filter(root -> !alreadyIncludedBlockRoots.contains(root))\n-        .map(store::getBlock)\n-        .sorted(Comparator.comparing(BeaconBlock::getSlot))\n-        .forEach(block -> processBlockAtStartup(store, protoArray, block));\n+    SafeFuture<Void> future = SafeFuture.completedFuture(null);\n+    for (Bytes32 blockRoot : store.getOrderedBlockRoots()) {\n+      if (alreadyIncludedBlockRoots.contains(blockRoot)) {\n+        continue;\n+      }\n+      future =\n+          future.thenCompose(\n+              __ ->\n+                  store\n+                      .retrieveBlockAndState(blockRoot)\n+                      .thenAccept(\n+                          blockAndState ->\n+                              blockAndState.ifPresent(b -> processBlockAtStartup(protoArray, b))));\n+    }\n+    return future;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5490d93cf8fcc4a40b1a3136c8d4a7fa8b188ebf"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAwOTc0OQ==", "bodyText": "Also, if the blockAndState is not in Store, should we throw an error?", "url": "https://github.com/ConsenSys/teku/pull/2419#discussion_r459009749", "createdAt": "2020-07-22T18:49:24Z", "author": {"login": "cemozerr"}, "path": "protoarray/src/main/java/tech/pegasys/teku/protoarray/ProtoArrayForkChoiceStrategy.java", "diffHunk": "@@ -144,27 +145,38 @@ public void maybePrune(Bytes32 finalizedRoot) {\n   }\n \n   // Internal\n-  private static void processBlocksInStoreAtStartup(ReadOnlyStore store, ProtoArray protoArray) {\n+  private static SafeFuture<Void> processBlocksInStoreAtStartup(\n+      PrunableStore store, ProtoArray protoArray) {\n     List<Bytes32> alreadyIncludedBlockRoots =\n         protoArray.getNodes().stream().map(ProtoNode::getBlockRoot).collect(Collectors.toList());\n \n-    store.getBlockRoots().stream()\n-        .filter(root -> !alreadyIncludedBlockRoots.contains(root))\n-        .map(store::getBlock)\n-        .sorted(Comparator.comparing(BeaconBlock::getSlot))\n-        .forEach(block -> processBlockAtStartup(store, protoArray, block));\n+    SafeFuture<Void> future = SafeFuture.completedFuture(null);\n+    for (Bytes32 blockRoot : store.getOrderedBlockRoots()) {\n+      if (alreadyIncludedBlockRoots.contains(blockRoot)) {\n+        continue;\n+      }\n+      future =\n+          future.thenCompose(\n+              __ ->\n+                  store\n+                      .retrieveBlockAndState(blockRoot)\n+                      .thenAccept(\n+                          blockAndState ->\n+                              blockAndState.ifPresent(b -> processBlockAtStartup(protoArray, b))));\n+    }\n+    return future;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ4MzM4MA=="}, "originalCommit": {"oid": "5490d93cf8fcc4a40b1a3136c8d4a7fa8b188ebf"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAxMjg0NA==", "bodyText": "I don't think there's any risk of stack overflow because we're just constructing this chain of futures in a for loop without invoking any methods recursively.  Added a test that processes a few thousand blocks to confirm - ran it locally with 10k blocks and it worked fine.", "url": "https://github.com/ConsenSys/teku/pull/2419#discussion_r459012844", "createdAt": "2020-07-22T18:54:37Z", "author": {"login": "mbaxter"}, "path": "protoarray/src/main/java/tech/pegasys/teku/protoarray/ProtoArrayForkChoiceStrategy.java", "diffHunk": "@@ -144,27 +145,38 @@ public void maybePrune(Bytes32 finalizedRoot) {\n   }\n \n   // Internal\n-  private static void processBlocksInStoreAtStartup(ReadOnlyStore store, ProtoArray protoArray) {\n+  private static SafeFuture<Void> processBlocksInStoreAtStartup(\n+      PrunableStore store, ProtoArray protoArray) {\n     List<Bytes32> alreadyIncludedBlockRoots =\n         protoArray.getNodes().stream().map(ProtoNode::getBlockRoot).collect(Collectors.toList());\n \n-    store.getBlockRoots().stream()\n-        .filter(root -> !alreadyIncludedBlockRoots.contains(root))\n-        .map(store::getBlock)\n-        .sorted(Comparator.comparing(BeaconBlock::getSlot))\n-        .forEach(block -> processBlockAtStartup(store, protoArray, block));\n+    SafeFuture<Void> future = SafeFuture.completedFuture(null);\n+    for (Bytes32 blockRoot : store.getOrderedBlockRoots()) {\n+      if (alreadyIncludedBlockRoots.contains(blockRoot)) {\n+        continue;\n+      }\n+      future =\n+          future.thenCompose(\n+              __ ->\n+                  store\n+                      .retrieveBlockAndState(blockRoot)\n+                      .thenAccept(\n+                          blockAndState ->\n+                              blockAndState.ifPresent(b -> processBlockAtStartup(protoArray, b))));\n+    }\n+    return future;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ4MzM4MA=="}, "originalCommit": {"oid": "5490d93cf8fcc4a40b1a3136c8d4a7fa8b188ebf"}, "originalPosition": 77}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3423, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}