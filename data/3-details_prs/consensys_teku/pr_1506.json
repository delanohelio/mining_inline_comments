{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk2MDY3Njkx", "number": 1506, "title": "Add ValidatorClientService", "bodyText": "PR Description\nAdd new ValidatorClientService that tracks the current fork and validator duties without direct access to the beacon state or state transition logic.\nThe ValidatorClientService timings are currently driven off of the beacon chain service events but an anticorruption layer is used to ensure a clean separation between the two APIs. The timings in ValidatorClientService can later be driven from other sources (potentially varying depending on how it's deployed).\nThe new validator client is toggled off as the duties are currently still performed by ValidatorCoordinator and unimplemented in ValidatorClientService.\nServiceController has been modified to work with a list of services, making it easier to handle optional services.", "createdAt": "2020-03-31T04:47:05Z", "url": "https://github.com/ConsenSys/teku/pull/1506", "merged": true, "mergeCommit": {"oid": "b588fda68bd1a70ad0a3612e519e31456d3dc353"}, "closed": true, "closedAt": "2020-03-31T23:13:56Z", "author": {"login": "ajsutton"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcS7KCggH2gAyMzk2MDY3NjkxOmJkOTU1NmE2MTc1YjYyZDcxZGY4YTk3ZTZhM2ViYTE3NjU0MzRkODY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcTLWR2AFqTM4NTE2Mzg1NQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "bd9556a6175b62d71df8a97e6a3eba1765434d86", "author": {"user": {"login": "ajsutton", "name": "Adrian Sutton"}}, "url": "https://github.com/ConsenSys/teku/commit/bd9556a6175b62d71df8a97e6a3eba1765434d86", "committedDate": "2020-03-31T04:12:05Z", "message": "Maintain services in a list in ServiceController so optional services are easier."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fc3af7109660743abc55ca5ba4608aa044d91fd8", "author": {"user": {"login": "ajsutton", "name": "Adrian Sutton"}}, "url": "https://github.com/ConsenSys/teku/commit/fc3af7109660743abc55ca5ba4608aa044d91fd8", "committedDate": "2020-03-31T04:42:22Z", "message": "Add new ValidatorClientService that tracks the current fork and validator duties.\nToggled off as the duties are currently still performed by ValidatorCoordinator and unimplemented in ValidatorClientService."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ec94232275f899ae9daba422cc642bb6be50b0c8", "author": {"user": {"login": "ajsutton", "name": "Adrian Sutton"}}, "url": "https://github.com/ConsenSys/teku/commit/ec94232275f899ae9daba422cc642bb6be50b0c8", "committedDate": "2020-03-31T04:44:00Z", "message": "Add final."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "93bbb990e5464f53623a7a71eb2bc0ecd2ca0caf", "author": {"user": {"login": "ajsutton", "name": "Adrian Sutton"}}, "url": "https://github.com/ConsenSys/teku/commit/93bbb990e5464f53623a7a71eb2bc0ecd2ca0caf", "committedDate": "2020-03-31T04:48:47Z", "message": "Uncomment."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7df0b1aab972ff493231169be15aac31af80c9f6", "author": {"user": {"login": "ajsutton", "name": "Adrian Sutton"}}, "url": "https://github.com/ConsenSys/teku/commit/7df0b1aab972ff493231169be15aac31af80c9f6", "committedDate": "2020-03-31T04:50:32Z", "message": "Spotless."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0OTU3ODYy", "url": "https://github.com/ConsenSys/teku/pull/1506#pullrequestreview-384957862", "createdAt": "2020-03-31T17:36:28Z", "commit": {"oid": "7df0b1aab972ff493231169be15aac31af80c9f6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxNzozNjoyOFrOF-gzCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxNzozNjoyOFrOF-gzCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTA5MzM4Nw==", "bodyText": "nit: would be nice to have a generic function that takes attestationProposalDuties and blockProposalDuties as arguments since the rest of the logic is same.", "url": "https://github.com/ConsenSys/teku/pull/1506#discussion_r401093387", "createdAt": "2020-03-31T17:36:28Z", "author": {"login": "cemozerr"}, "path": "validator/client/src/main/java/tech/pegasys/artemis/validator/client/DutyScheduler.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.validator.client;\n+\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.compute_epoch_at_slot;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import tech.pegasys.artemis.util.async.AsyncRunner;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.bls.BLSPublicKey;\n+import tech.pegasys.artemis.util.config.Constants;\n+import tech.pegasys.artemis.validator.api.ValidatorApiChannel;\n+import tech.pegasys.artemis.validator.api.ValidatorDuties;\n+import tech.pegasys.artemis.validator.api.ValidatorTimingChannel;\n+import tech.pegasys.artemis.validator.client.duties.AttestationProductionDuty;\n+import tech.pegasys.artemis.validator.client.duties.BlockProductionDuty;\n+import tech.pegasys.artemis.validator.client.duties.ValidatorDutyFactory;\n+\n+public class DutyScheduler implements ValidatorTimingChannel {\n+  private static final Logger LOG = LogManager.getLogger();\n+  final AtomicReference<UnsignedLong> latestScheduledEpoch = new AtomicReference<>();\n+  private final ConcurrentMap<UnsignedLong, BlockProductionDuty> blockProposalDuties =\n+      new ConcurrentHashMap<>();\n+  private final ConcurrentMap<UnsignedLong, AttestationProductionDuty> attestationProposalDuties =\n+      new ConcurrentHashMap<>();\n+  private final AsyncRunner asyncRunner;\n+  private final ValidatorApiChannel validatorApiChannel;\n+  private final ValidatorDutyFactory dutyFactory;\n+  private final Map<BLSPublicKey, Validator> validators;\n+\n+  public DutyScheduler(\n+      final AsyncRunner asyncRunner,\n+      final ValidatorApiChannel validatorApiChannel,\n+      final ValidatorDutyFactory dutyFactory,\n+      final Map<BLSPublicKey, Validator> validators) {\n+    this.asyncRunner = asyncRunner;\n+    this.validatorApiChannel = validatorApiChannel;\n+    this.dutyFactory = dutyFactory;\n+    this.validators = validators;\n+  }\n+\n+  @Override\n+  public void onSlot(final UnsignedLong slotNumber) {\n+    final UnsignedLong epochNumber = compute_epoch_at_slot(slotNumber);\n+    latestScheduledEpoch.getAndUpdate(\n+        lastRequestedEpoch -> {\n+          final UnsignedLong startEpoch =\n+              lastRequestedEpoch == null ? epochNumber : lastRequestedEpoch.plus(UnsignedLong.ONE);\n+          final UnsignedLong endEpoch = epochNumber.plus(UnsignedLong.ONE);\n+          for (UnsignedLong currentEpoch = startEpoch;\n+              currentEpoch.compareTo(endEpoch) <= 0;\n+              currentEpoch = currentEpoch.plus(UnsignedLong.ONE)) {\n+            scheduleDutiesForEpoch(currentEpoch).reportExceptions();\n+          }\n+          return startEpoch.compareTo(endEpoch) > 0 ? startEpoch : endEpoch;\n+        });\n+  }\n+\n+  private SafeFuture<Void> scheduleDutiesForEpoch(final UnsignedLong epoch) {\n+    LOG.trace(\"Requesting duties for epoch {}\", epoch);\n+    return validatorApiChannel\n+        .getDuties(epoch, validators.keySet())\n+        .orTimeout(Constants.VALIDATOR_DUTIES_TIMEOUT, TimeUnit.SECONDS)\n+        .thenApply(\n+            maybeDuties ->\n+                maybeDuties.orElseThrow(\n+                    () ->\n+                        new IllegalStateException(\n+                            \"Duties could not be calculated because chain data was not yet available\")))\n+        .thenAccept(duties -> duties.forEach(this::scheduleDuties))\n+        .exceptionallyCompose(\n+            error -> {\n+              LOG.error(\n+                  \"Failed to request validator duties for epoch \"\n+                      + epoch\n+                      + \". Retrying after delay.\",\n+                  error);\n+              return asyncRunner.runAfterDelay(\n+                  () -> scheduleDutiesForEpoch(epoch), 5, TimeUnit.SECONDS);\n+            });\n+  }\n+\n+  private void scheduleDuties(final ValidatorDuties validatorDuties) {\n+    LOG.trace(\"Got validator duties: {}\", validatorDuties);\n+    final Validator validator = validators.get(validatorDuties.getPublicKey());\n+    validatorDuties\n+        .getDuties()\n+        .ifPresent(\n+            duties -> {\n+              duties\n+                  .getBlockProposalSlots()\n+                  .forEach(slot -> scheduleBlockProduction(validator, slot));\n+              scheduleAttestationProduction(\n+                  duties.getAttestationCommitteeIndex(),\n+                  validator,\n+                  duties.getValidatorIndex(),\n+                  duties.getAttestationSlot());\n+            });\n+  }\n+\n+  private void scheduleBlockProduction(final Validator validator, final UnsignedLong slot) {\n+    blockProposalDuties.put(slot, dutyFactory.createBlockProductionDuty(validator, slot));\n+  }\n+\n+  private void scheduleAttestationProduction(\n+      final int attestationCommitteeIndex,\n+      final Validator validator,\n+      final int validatorIndex,\n+      final UnsignedLong slot) {\n+    attestationProposalDuties\n+        .computeIfAbsent(slot, dutyFactory::createAttestationProductionDuty)\n+        .addValidator(attestationCommitteeIndex, validator, validatorIndex);\n+  }\n+\n+  @Override\n+  public void onBlockProductionDue(final UnsignedLong slot) {\n+    final BlockProductionDuty duty = blockProposalDuties.remove(slot);\n+    if (duty == null) {\n+      return;\n+    }\n+    duty.performDuty();\n+  }\n+\n+  @Override\n+  public void onAttestationCreationDue(final UnsignedLong slot) {\n+    final AttestationProductionDuty duty = attestationProposalDuties.remove(slot);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7df0b1aab972ff493231169be15aac31af80c9f6"}, "originalPosition": 144}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0OTY0ODUx", "url": "https://github.com/ConsenSys/teku/pull/1506#pullrequestreview-384964851", "createdAt": "2020-03-31T17:45:44Z", "commit": {"oid": "7df0b1aab972ff493231169be15aac31af80c9f6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxNzo0NTo0NFrOF-hJVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxNzo0NTo0NFrOF-hJVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTA5OTA5NA==", "bodyText": "The block production duty is probably more time-dependent than the duty scheduling that gets performed in onSlot so I would reverse their order (unless there is a scenario in which we schedule the block production of the current slot in the exact slot itself, although since we're scheduling an epoch ahead, that probably should not happen)\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                validatorTimingChannel.onSlot(slot);\n          \n          \n            \n                validatorTimingChannel.onBlockProductionDue(slot);", "url": "https://github.com/ConsenSys/teku/pull/1506#discussion_r401099094", "createdAt": "2020-03-31T17:45:44Z", "author": {"login": "cemozerr"}, "path": "validator/anticorruption/src/main/java/tech/pegasys/artemis/validator/anticorruption/BeaconChainEventAdapter.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.validator.anticorruption;\n+\n+import com.google.common.eventbus.Subscribe;\n+import com.google.common.primitives.UnsignedLong;\n+import tech.pegasys.artemis.statetransition.events.attestation.BroadcastAttestationEvent;\n+import tech.pegasys.artemis.util.time.channels.SlotEventsChannel;\n+import tech.pegasys.artemis.validator.api.ValidatorTimingChannel;\n+\n+/**\n+ * Converts events from the {@link com.google.common.eventbus.EventBus} to the new validator client\n+ * {@link tech.pegasys.artemis.events.EventChannels}.\n+ */\n+class BeaconChainEventAdapter implements SlotEventsChannel {\n+\n+  private final ValidatorTimingChannel validatorTimingChannel;\n+\n+  public BeaconChainEventAdapter(final ValidatorTimingChannel validatorTimingChannel) {\n+    this.validatorTimingChannel = validatorTimingChannel;\n+  }\n+\n+  @Subscribe\n+  public void onBroadcastAttestationEvent(final BroadcastAttestationEvent event) {\n+    validatorTimingChannel.onAttestationCreationDue(event.getNodeSlot());\n+  }\n+\n+  @Override\n+  public void onSlot(final UnsignedLong slot) {\n+    validatorTimingChannel.onSlot(slot);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7df0b1aab972ff493231169be15aac31af80c9f6"}, "originalPosition": 41}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0OTY1MDAz", "url": "https://github.com/ConsenSys/teku/pull/1506#pullrequestreview-384965003", "createdAt": "2020-03-31T17:45:58Z", "commit": {"oid": "7df0b1aab972ff493231169be15aac31af80c9f6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxNzo0NTo1OFrOF-hJ1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxNzo0NTo1OFrOF-hJ1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTA5OTIyMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                validatorTimingChannel.onBlockProductionDue(slot);\n          \n          \n            \n                validatorTimingChannel.onSlot(slot);", "url": "https://github.com/ConsenSys/teku/pull/1506#discussion_r401099223", "createdAt": "2020-03-31T17:45:58Z", "author": {"login": "cemozerr"}, "path": "validator/anticorruption/src/main/java/tech/pegasys/artemis/validator/anticorruption/BeaconChainEventAdapter.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.validator.anticorruption;\n+\n+import com.google.common.eventbus.Subscribe;\n+import com.google.common.primitives.UnsignedLong;\n+import tech.pegasys.artemis.statetransition.events.attestation.BroadcastAttestationEvent;\n+import tech.pegasys.artemis.util.time.channels.SlotEventsChannel;\n+import tech.pegasys.artemis.validator.api.ValidatorTimingChannel;\n+\n+/**\n+ * Converts events from the {@link com.google.common.eventbus.EventBus} to the new validator client\n+ * {@link tech.pegasys.artemis.events.EventChannels}.\n+ */\n+class BeaconChainEventAdapter implements SlotEventsChannel {\n+\n+  private final ValidatorTimingChannel validatorTimingChannel;\n+\n+  public BeaconChainEventAdapter(final ValidatorTimingChannel validatorTimingChannel) {\n+    this.validatorTimingChannel = validatorTimingChannel;\n+  }\n+\n+  @Subscribe\n+  public void onBroadcastAttestationEvent(final BroadcastAttestationEvent event) {\n+    validatorTimingChannel.onAttestationCreationDue(event.getNodeSlot());\n+  }\n+\n+  @Override\n+  public void onSlot(final UnsignedLong slot) {\n+    validatorTimingChannel.onSlot(slot);\n+    validatorTimingChannel.onBlockProductionDue(slot);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7df0b1aab972ff493231169be15aac31af80c9f6"}, "originalPosition": 42}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0OTY3MDUw", "url": "https://github.com/ConsenSys/teku/pull/1506#pullrequestreview-384967050", "createdAt": "2020-03-31T17:48:43Z", "commit": {"oid": "7df0b1aab972ff493231169be15aac31af80c9f6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxNzo0ODo0M1rOF-hQaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxNzo0ODo0M1rOF-hQaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTEwMDkwNA==", "bodyText": "Is this fork number for hard forks? Otherwise, 5 minutes of refresh time seems a bit risky.", "url": "https://github.com/ConsenSys/teku/pull/1506#discussion_r401100904", "createdAt": "2020-03-31T17:48:43Z", "author": {"login": "cemozerr"}, "path": "validator/client/src/main/java/tech/pegasys/artemis/validator/client/ForkProvider.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.validator.client;\n+\n+import static tech.pegasys.artemis.util.config.Constants.FORK_REFRESH_TIME_SECONDS;\n+import static tech.pegasys.artemis.util.config.Constants.FORK_RETRY_DELAY_SECONDS;\n+\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import tech.pegasys.artemis.datastructures.state.Fork;\n+import tech.pegasys.artemis.util.async.AsyncRunner;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.validator.api.ValidatorApiChannel;\n+\n+public class ForkProvider {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private AsyncRunner asyncRunner;\n+  private final ValidatorApiChannel validatorApiChannel;\n+\n+  private volatile Optional<Fork> currentFork = Optional.empty();\n+\n+  public ForkProvider(\n+      final AsyncRunner asyncRunner, final ValidatorApiChannel validatorApiChannel) {\n+    this.asyncRunner = asyncRunner;\n+    this.validatorApiChannel = validatorApiChannel;\n+  }\n+\n+  public SafeFuture<Fork> getFork() {\n+    return currentFork.map(SafeFuture::completedFuture).orElseGet(this::loadFork);\n+  }\n+\n+  public SafeFuture<Fork> loadFork() {\n+    return requestFork()\n+        .exceptionallyCompose(\n+            error -> {\n+              LOG.error(\"Failed to retrieve current fork. Retrying after delay\", error);\n+              return asyncRunner.runAfterDelay(\n+                  this::getFork, FORK_RETRY_DELAY_SECONDS, TimeUnit.SECONDS);\n+            });\n+  }\n+\n+  public SafeFuture<Fork> requestFork() {\n+    return validatorApiChannel\n+        .getFork()\n+        .thenCompose(\n+            maybeFork -> {\n+              if (maybeFork.isEmpty()) {\n+                LOG.trace(\"Fork not available, retrying\");\n+                return asyncRunner.runAfterDelay(\n+                    this::requestFork, FORK_RETRY_DELAY_SECONDS, TimeUnit.SECONDS);\n+              }\n+              final Fork fork = maybeFork.orElseThrow();\n+              currentFork = Optional.of(fork);\n+              // Periodically refresh the current fork.\n+              asyncRunner\n+                  .runAfterDelay(this::loadFork, FORK_REFRESH_TIME_SECONDS, TimeUnit.SECONDS)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7df0b1aab972ff493231169be15aac31af80c9f6"}, "originalPosition": 70}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0OTczODYx", "url": "https://github.com/ConsenSys/teku/pull/1506#pullrequestreview-384973861", "createdAt": "2020-03-31T17:57:43Z", "commit": {"oid": "7df0b1aab972ff493231169be15aac31af80c9f6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxNzo1Nzo0M1rOF-hmYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxNzo1Nzo0M1rOF-hmYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTEwNjUyOA==", "bodyText": "I might have missed this previously, but why does ValidatorDuties keep a list of blockProposerSlots? A validator proposes a block about every 3 weeks.", "url": "https://github.com/ConsenSys/teku/pull/1506#discussion_r401106528", "createdAt": "2020-03-31T17:57:43Z", "author": {"login": "cemozerr"}, "path": "validator/client/src/test/java/tech/pegasys/artemis/validator/client/DutySchedulerTest.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.validator.client;\n+\n+import static java.util.Collections.emptyList;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.when;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.compute_start_slot_at_epoch;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.async.StubAsyncRunner;\n+import tech.pegasys.artemis.util.bls.BLSPublicKey;\n+import tech.pegasys.artemis.validator.api.ValidatorApiChannel;\n+import tech.pegasys.artemis.validator.api.ValidatorDuties;\n+import tech.pegasys.artemis.validator.client.duties.AttestationProductionDuty;\n+import tech.pegasys.artemis.validator.client.duties.BlockProductionDuty;\n+import tech.pegasys.artemis.validator.client.duties.ValidatorDutyFactory;\n+import tech.pegasys.artemis.validator.client.signer.Signer;\n+\n+class DutySchedulerTest {\n+  private static final BLSPublicKey VALIDATOR1_KEY = BLSPublicKey.random(100);\n+  private static final BLSPublicKey VALIDATOR2_KEY = BLSPublicKey.random(200);\n+  private static final Collection<BLSPublicKey> VALIDATOR_KEYS =\n+      Set.of(VALIDATOR1_KEY, VALIDATOR2_KEY);\n+  private final Signer validator1Signer = mock(Signer.class);\n+  private final Signer validator2Signer = mock(Signer.class);\n+  private final Validator validator1 = new Validator(VALIDATOR1_KEY, validator1Signer);\n+  private final Validator validator2 = new Validator(VALIDATOR2_KEY, validator2Signer);\n+\n+  private final ValidatorApiChannel validatorApiChannel = mock(ValidatorApiChannel.class);\n+  private final ValidatorDutyFactory dutyFactory = mock(ValidatorDutyFactory.class);\n+  private final StubAsyncRunner asyncRunner = new StubAsyncRunner();\n+\n+  private final DutyScheduler validatorClient =\n+      new DutyScheduler(\n+          asyncRunner,\n+          validatorApiChannel,\n+          dutyFactory,\n+          Map.of(VALIDATOR1_KEY, validator1, VALIDATOR2_KEY, validator2));\n+\n+  @BeforeEach\n+  public void setUp() {\n+    when(validatorApiChannel.getDuties(any(), any()))\n+        .thenReturn(SafeFuture.completedFuture(Optional.of(emptyList())));\n+    when(dutyFactory.createAttestationProductionDuty(any()))\n+        .thenReturn(mock(AttestationProductionDuty.class));\n+  }\n+\n+  @Test\n+  public void shouldFetchDutiesForCurrentAndNextEpoch() {\n+    validatorClient.onSlot(compute_start_slot_at_epoch(UnsignedLong.ONE));\n+\n+    verify(validatorApiChannel).getDuties(UnsignedLong.ONE, VALIDATOR_KEYS);\n+    verify(validatorApiChannel).getDuties(UnsignedLong.valueOf(2), VALIDATOR_KEYS);\n+  }\n+\n+  @Test\n+  public void shouldNotRefetchDutiesWhichHaveAlreadyBeenRetrieved() {\n+    when(validatorApiChannel.getDuties(any(), any())).thenReturn(new SafeFuture<>());\n+    validatorClient.onSlot(compute_start_slot_at_epoch(UnsignedLong.ONE));\n+\n+    verify(validatorApiChannel).getDuties(UnsignedLong.ONE, VALIDATOR_KEYS);\n+    verify(validatorApiChannel).getDuties(UnsignedLong.valueOf(2), VALIDATOR_KEYS);\n+\n+    validatorClient.onSlot(compute_start_slot_at_epoch(UnsignedLong.valueOf(2)));\n+\n+    // Requests the next epoch, but not the current one because we already have that\n+    verify(validatorApiChannel).getDuties(UnsignedLong.valueOf(3), VALIDATOR_KEYS);\n+    verifyNoMoreInteractions(validatorApiChannel);\n+  }\n+\n+  @Test\n+  public void shouldRetryWhenRequestingDutiesFails() {\n+    final SafeFuture<Optional<List<ValidatorDuties>>> request1 = new SafeFuture<>();\n+    final SafeFuture<Optional<List<ValidatorDuties>>> request2 = new SafeFuture<>();\n+    when(validatorApiChannel.getDuties(UnsignedLong.ONE, VALIDATOR_KEYS))\n+        .thenReturn(request1)\n+        .thenReturn(request2);\n+\n+    validatorClient.onSlot(compute_start_slot_at_epoch(UnsignedLong.ONE));\n+    verify(validatorApiChannel, times(1)).getDuties(UnsignedLong.ONE, VALIDATOR_KEYS);\n+\n+    request1.completeExceptionally(new RuntimeException(\"Nope\"));\n+    assertThat(asyncRunner.hasDelayedActions()).isTrue();\n+    asyncRunner.executeQueuedActions();\n+\n+    // Should retry request\n+    verify(validatorApiChannel, times(2)).getDuties(UnsignedLong.ONE, VALIDATOR_KEYS);\n+\n+    // And not have any more retries scheduled\n+    assertThat(asyncRunner.hasDelayedActions()).isFalse();\n+  }\n+\n+  @Test\n+  public void shouldScheduleBlockProposalDuty() {\n+    final UnsignedLong blockProposerSlot = UnsignedLong.valueOf(5);\n+    final ValidatorDuties validator1Duties =\n+        ValidatorDuties.withDuties(\n+            VALIDATOR1_KEY, 5, 3, List.of(blockProposerSlot), UnsignedLong.valueOf(7));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7df0b1aab972ff493231169be15aac31af80c9f6"}, "originalPosition": 124}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0OTgxMDk2", "url": "https://github.com/ConsenSys/teku/pull/1506#pullrequestreview-384981096", "createdAt": "2020-03-31T18:07:46Z", "commit": {"oid": "7df0b1aab972ff493231169be15aac31af80c9f6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxODowNzo0NlrOF-h91A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxODowNzo0NlrOF-h91A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTExMjUzMg==", "bodyText": "This functionality is not yet implemented although you're still testing, right?", "url": "https://github.com/ConsenSys/teku/pull/1506#discussion_r401112532", "createdAt": "2020-03-31T18:07:46Z", "author": {"login": "cemozerr"}, "path": "validator/client/src/test/java/tech/pegasys/artemis/validator/client/DutySchedulerTest.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.validator.client;\n+\n+import static java.util.Collections.emptyList;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.when;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.compute_start_slot_at_epoch;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.async.StubAsyncRunner;\n+import tech.pegasys.artemis.util.bls.BLSPublicKey;\n+import tech.pegasys.artemis.validator.api.ValidatorApiChannel;\n+import tech.pegasys.artemis.validator.api.ValidatorDuties;\n+import tech.pegasys.artemis.validator.client.duties.AttestationProductionDuty;\n+import tech.pegasys.artemis.validator.client.duties.BlockProductionDuty;\n+import tech.pegasys.artemis.validator.client.duties.ValidatorDutyFactory;\n+import tech.pegasys.artemis.validator.client.signer.Signer;\n+\n+class DutySchedulerTest {\n+  private static final BLSPublicKey VALIDATOR1_KEY = BLSPublicKey.random(100);\n+  private static final BLSPublicKey VALIDATOR2_KEY = BLSPublicKey.random(200);\n+  private static final Collection<BLSPublicKey> VALIDATOR_KEYS =\n+      Set.of(VALIDATOR1_KEY, VALIDATOR2_KEY);\n+  private final Signer validator1Signer = mock(Signer.class);\n+  private final Signer validator2Signer = mock(Signer.class);\n+  private final Validator validator1 = new Validator(VALIDATOR1_KEY, validator1Signer);\n+  private final Validator validator2 = new Validator(VALIDATOR2_KEY, validator2Signer);\n+\n+  private final ValidatorApiChannel validatorApiChannel = mock(ValidatorApiChannel.class);\n+  private final ValidatorDutyFactory dutyFactory = mock(ValidatorDutyFactory.class);\n+  private final StubAsyncRunner asyncRunner = new StubAsyncRunner();\n+\n+  private final DutyScheduler validatorClient =\n+      new DutyScheduler(\n+          asyncRunner,\n+          validatorApiChannel,\n+          dutyFactory,\n+          Map.of(VALIDATOR1_KEY, validator1, VALIDATOR2_KEY, validator2));\n+\n+  @BeforeEach\n+  public void setUp() {\n+    when(validatorApiChannel.getDuties(any(), any()))\n+        .thenReturn(SafeFuture.completedFuture(Optional.of(emptyList())));\n+    when(dutyFactory.createAttestationProductionDuty(any()))\n+        .thenReturn(mock(AttestationProductionDuty.class));\n+  }\n+\n+  @Test\n+  public void shouldFetchDutiesForCurrentAndNextEpoch() {\n+    validatorClient.onSlot(compute_start_slot_at_epoch(UnsignedLong.ONE));\n+\n+    verify(validatorApiChannel).getDuties(UnsignedLong.ONE, VALIDATOR_KEYS);\n+    verify(validatorApiChannel).getDuties(UnsignedLong.valueOf(2), VALIDATOR_KEYS);\n+  }\n+\n+  @Test\n+  public void shouldNotRefetchDutiesWhichHaveAlreadyBeenRetrieved() {\n+    when(validatorApiChannel.getDuties(any(), any())).thenReturn(new SafeFuture<>());\n+    validatorClient.onSlot(compute_start_slot_at_epoch(UnsignedLong.ONE));\n+\n+    verify(validatorApiChannel).getDuties(UnsignedLong.ONE, VALIDATOR_KEYS);\n+    verify(validatorApiChannel).getDuties(UnsignedLong.valueOf(2), VALIDATOR_KEYS);\n+\n+    validatorClient.onSlot(compute_start_slot_at_epoch(UnsignedLong.valueOf(2)));\n+\n+    // Requests the next epoch, but not the current one because we already have that\n+    verify(validatorApiChannel).getDuties(UnsignedLong.valueOf(3), VALIDATOR_KEYS);\n+    verifyNoMoreInteractions(validatorApiChannel);\n+  }\n+\n+  @Test\n+  public void shouldRetryWhenRequestingDutiesFails() {\n+    final SafeFuture<Optional<List<ValidatorDuties>>> request1 = new SafeFuture<>();\n+    final SafeFuture<Optional<List<ValidatorDuties>>> request2 = new SafeFuture<>();\n+    when(validatorApiChannel.getDuties(UnsignedLong.ONE, VALIDATOR_KEYS))\n+        .thenReturn(request1)\n+        .thenReturn(request2);\n+\n+    validatorClient.onSlot(compute_start_slot_at_epoch(UnsignedLong.ONE));\n+    verify(validatorApiChannel, times(1)).getDuties(UnsignedLong.ONE, VALIDATOR_KEYS);\n+\n+    request1.completeExceptionally(new RuntimeException(\"Nope\"));\n+    assertThat(asyncRunner.hasDelayedActions()).isTrue();\n+    asyncRunner.executeQueuedActions();\n+\n+    // Should retry request\n+    verify(validatorApiChannel, times(2)).getDuties(UnsignedLong.ONE, VALIDATOR_KEYS);\n+\n+    // And not have any more retries scheduled\n+    assertThat(asyncRunner.hasDelayedActions()).isFalse();\n+  }\n+\n+  @Test\n+  public void shouldScheduleBlockProposalDuty() {\n+    final UnsignedLong blockProposerSlot = UnsignedLong.valueOf(5);\n+    final ValidatorDuties validator1Duties =\n+        ValidatorDuties.withDuties(\n+            VALIDATOR1_KEY, 5, 3, List.of(blockProposerSlot), UnsignedLong.valueOf(7));\n+    when(validatorApiChannel.getDuties(eq(UnsignedLong.ONE), any()))\n+        .thenReturn(SafeFuture.completedFuture(Optional.of(List.of(validator1Duties))));\n+\n+    final BlockProductionDuty blockCreationDuty = mock(BlockProductionDuty.class);\n+    when(dutyFactory.createBlockProductionDuty(validator1, blockProposerSlot))\n+        .thenReturn(blockCreationDuty);\n+\n+    // Load duties\n+    validatorClient.onSlot(compute_start_slot_at_epoch(UnsignedLong.ONE));\n+\n+    // Execute\n+    validatorClient.onBlockProductionDue(blockProposerSlot);\n+    verify(blockCreationDuty).performDuty();\n+  }\n+\n+  @Test\n+  public void shouldNotPerformDutiesForSameSlotTwice() {\n+    final UnsignedLong blockProposerSlot = UnsignedLong.valueOf(5);\n+    final ValidatorDuties validator1Duties =\n+        ValidatorDuties.withDuties(\n+            VALIDATOR1_KEY, 5, 3, List.of(blockProposerSlot), UnsignedLong.valueOf(7));\n+    when(validatorApiChannel.getDuties(eq(UnsignedLong.ONE), any()))\n+        .thenReturn(SafeFuture.completedFuture(Optional.of(List.of(validator1Duties))));\n+\n+    final BlockProductionDuty blockCreationDuty = mock(BlockProductionDuty.class);\n+    when(dutyFactory.createBlockProductionDuty(validator1, blockProposerSlot))\n+        .thenReturn(blockCreationDuty);\n+\n+    // Load duties\n+    validatorClient.onSlot(compute_start_slot_at_epoch(UnsignedLong.ONE));\n+\n+    // Execute\n+    validatorClient.onBlockProductionDue(blockProposerSlot);\n+    verify(blockCreationDuty).performDuty();\n+\n+    // Somehow we triggered the same slot again.\n+    validatorClient.onBlockProductionDue(blockProposerSlot);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7df0b1aab972ff493231169be15aac31af80c9f6"}, "originalPosition": 161}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0OTgxNTQ0", "url": "https://github.com/ConsenSys/teku/pull/1506#pullrequestreview-384981544", "createdAt": "2020-03-31T18:08:19Z", "commit": {"oid": "7df0b1aab972ff493231169be15aac31af80c9f6"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cd4899fc05c315f57cdb366cb119aa41fc537e08", "author": {"user": {"login": "ajsutton", "name": "Adrian Sutton"}}, "url": "https://github.com/ConsenSys/teku/commit/cd4899fc05c315f57cdb366cb119aa41fc537e08", "committedDate": "2020-03-31T22:49:44Z", "message": "Merge branch 'master' of github.com:PegaSysEng/teku into validator-client-service"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c656dab491839c800cd5b9ca6c17bcbebb5a47ac", "author": {"user": {"login": "ajsutton", "name": "Adrian Sutton"}}, "url": "https://github.com/ConsenSys/teku/commit/c656dab491839c800cd5b9ca6c17bcbebb5a47ac", "committedDate": "2020-03-31T22:54:18Z", "message": "Update test."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8b775504e7fe3e4c94fe5920c280358bd95c8c20", "author": {"user": {"login": "ajsutton", "name": "Adrian Sutton"}}, "url": "https://github.com/ConsenSys/teku/commit/8b775504e7fe3e4c94fe5920c280358bd95c8c20", "committedDate": "2020-03-31T23:01:01Z", "message": "Extract Duty interface to remove duplication when performing duties."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg1MTYzODU1", "url": "https://github.com/ConsenSys/teku/pull/1506#pullrequestreview-385163855", "createdAt": "2020-03-31T23:03:56Z", "commit": {"oid": "8b775504e7fe3e4c94fe5920c280358bd95c8c20"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQyMzowMzo1NlrOF-rR7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQyMzowMzo1NlrOF-rR7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTI2NTEzNQ==", "bodyText": "Nice!", "url": "https://github.com/ConsenSys/teku/pull/1506#discussion_r401265135", "createdAt": "2020-03-31T23:03:56Z", "author": {"login": "cemozerr"}, "path": "validator/client/src/main/java/tech/pegasys/artemis/validator/client/DutyScheduler.java", "diffHunk": "@@ -132,16 +133,17 @@ private void scheduleAttestationProduction(\n \n   @Override\n   public void onBlockProductionDue(final UnsignedLong slot) {\n-    final BlockProductionDuty duty = blockProposalDuties.remove(slot);\n-    if (duty == null) {\n-      return;\n-    }\n-    duty.performDuty();\n+    performDutyForSlot(blockProposalDuties, slot);\n   }\n \n   @Override\n   public void onAttestationCreationDue(final UnsignedLong slot) {\n-    final AttestationProductionDuty duty = attestationProposalDuties.remove(slot);\n+    performDutyForSlot(attestationProposalDuties, slot);\n+  }\n+\n+  public void performDutyForSlot(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b775504e7fe3e4c94fe5920c280358bd95c8c20"}, "originalPosition": 26}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4423, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}