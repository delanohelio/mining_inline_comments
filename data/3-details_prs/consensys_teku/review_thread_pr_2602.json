{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY5MTk4NzQ4", "number": 2602, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwODoyNzowOFrOEZXohA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwODoyNzowOFrOEZXohA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MDM3MDYwOnYy", "diffSide": "RIGHT", "path": "ethereum/statetransition/src/main/java/tech/pegasys/teku/statetransition/forkchoice/ForkChoice.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwODoyNzowOFrOHCI9uQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwODo0ODo1NVrOHCJ0ZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjAwNjA3Mw==", "bodyText": "Seems like we don't check if the attestation processing was successful before committing anymore. Is this on purpose?", "url": "https://github.com/ConsenSys/teku/pull/2602#discussion_r472006073", "createdAt": "2020-08-18T08:27:08Z", "author": {"login": "cemozerr"}, "path": "ethereum/statetransition/src/main/java/tech/pegasys/teku/statetransition/forkchoice/ForkChoice.java", "diffHunk": "@@ -48,97 +52,119 @@ private void initializeProtoArrayForkChoice() {\n     processHead();\n   }\n \n-  public synchronized void processHead() {\n+  private void processHead() {\n     processHead(Optional.empty());\n   }\n \n-  public synchronized void processHead(UInt64 nodeSlot) {\n+  public void processHead(UInt64 nodeSlot) {\n     processHead(Optional.of(nodeSlot));\n   }\n \n-  private synchronized void processHead(Optional<UInt64> nodeSlot) {\n-    final Checkpoint finalizedCheckpoint = recentChainData.getStore().getFinalizedCheckpoint();\n-    final Checkpoint justifiedCheckpoint = recentChainData.getStore().getJustifiedCheckpoint();\n-    recentChainData\n-        .retrieveCheckpointState(justifiedCheckpoint)\n-        .thenAccept(\n-            justifiedCheckpointState -> {\n-              StoreTransaction transaction = recentChainData.startStoreTransaction();\n-              final ForkChoiceStrategy forkChoiceStrategy = getForkChoiceStrategy();\n-              Bytes32 headBlockRoot =\n-                  forkChoiceStrategy.findHead(\n-                      transaction,\n-                      finalizedCheckpoint,\n-                      justifiedCheckpoint,\n-                      justifiedCheckpointState.orElseThrow());\n-              transaction.commit(() -> {}, \"Failed to persist validator vote changes.\");\n-\n-              recentChainData.updateHead(\n-                  headBlockRoot,\n-                  nodeSlot.orElse(\n-                      forkChoiceStrategy\n-                          .blockSlot(headBlockRoot)\n-                          .orElseThrow(\n-                              () ->\n-                                  new IllegalStateException(\n-                                      \"Unable to retrieve the slot of fork choice head\"))));\n+  private void processHead(Optional<UInt64> nodeSlot) {\n+    withLock(\n+            () -> {\n+              final Checkpoint finalizedCheckpoint =\n+                  recentChainData.getStore().getFinalizedCheckpoint();\n+              final Checkpoint justifiedCheckpoint =\n+                  recentChainData.getStore().getJustifiedCheckpoint();\n+              return recentChainData\n+                  .retrieveCheckpointState(justifiedCheckpoint)\n+                  .thenCompose(\n+                      justifiedCheckpointState -> {\n+                        final StoreTransaction transaction =\n+                            recentChainData.startStoreTransaction();\n+                        final ForkChoiceStrategy forkChoiceStrategy = getForkChoiceStrategy();\n+                        Bytes32 headBlockRoot =\n+                            forkChoiceStrategy.findHead(\n+                                transaction,\n+                                finalizedCheckpoint,\n+                                justifiedCheckpoint,\n+                                justifiedCheckpointState.orElseThrow());\n+\n+                        recentChainData.updateHead(\n+                            headBlockRoot,\n+                            nodeSlot.orElse(\n+                                forkChoiceStrategy\n+                                    .blockSlot(headBlockRoot)\n+                                    .orElseThrow(\n+                                        () ->\n+                                            new IllegalStateException(\n+                                                \"Unable to retrieve the slot of fork choice head\"))));\n+                        return transaction.commit();\n+                      });\n             })\n         .join();\n   }\n \n-  public synchronized BlockImportResult onBlock(\n+  public SafeFuture<BlockImportResult> onBlock(\n       final SignedBeaconBlock block, Optional<BeaconState> preState) {\n-    final ForkChoiceStrategy forkChoiceStrategy = getForkChoiceStrategy();\n-    StoreTransaction transaction = recentChainData.startStoreTransaction();\n-    final BlockImportResult result =\n-        on_block(\n-            transaction,\n-            block,\n-            preState,\n-            stateTransition,\n-            forkChoiceStrategy,\n-            beaconState ->\n-                transaction.putStateRoot(\n-                    beaconState.hash_tree_root(),\n-                    new SlotAndBlockRoot(\n-                        beaconState.getSlot(),\n-                        beaconState.getLatest_block_header().hash_tree_root())));\n-\n-    if (!result.isSuccessful()) {\n-      return result;\n-    }\n-\n-    transaction.commit().join();\n-    result\n-        .getBlockProcessingRecord()\n-        .ifPresent(record -> forkChoiceStrategy.onBlock(block.getMessage(), record.getPostState()));\n-\n-    return result;\n+    return withLock(\n+        () -> {\n+          final ForkChoiceStrategy forkChoiceStrategy = getForkChoiceStrategy();\n+          final StoreTransaction transaction = recentChainData.startStoreTransaction();\n+          final BlockImportResult result =\n+              on_block(\n+                  transaction,\n+                  block,\n+                  preState,\n+                  stateTransition,\n+                  forkChoiceStrategy,\n+                  beaconState ->\n+                      transaction.putStateRoot(\n+                          beaconState.hash_tree_root(),\n+                          new SlotAndBlockRoot(\n+                              beaconState.getSlot(),\n+                              beaconState.getLatest_block_header().hash_tree_root())));\n+\n+          if (!result.isSuccessful()) {\n+            return SafeFuture.completedFuture(result);\n+          }\n+          return transaction\n+              .commit()\n+              .thenRun(\n+                  () ->\n+                      result\n+                          .getBlockProcessingRecord()\n+                          .ifPresent(\n+                              record ->\n+                                  forkChoiceStrategy.onBlock(\n+                                      block.getMessage(), record.getPostState())))\n+              .thenApply(__ -> result);\n+        });\n   }\n \n   public SafeFuture<AttestationProcessingResult> onAttestation(\n       final ValidateableAttestation attestation) {\n     return recentChainData\n         .retrieveCheckpointState(attestation.getData().getTarget())\n-        .thenApply(\n-            targetState -> {\n-              StoreTransaction transaction = recentChainData.startStoreTransaction();\n-              final AttestationProcessingResult result =\n-                  on_attestation(transaction, attestation, targetState, getForkChoiceStrategy());\n-              if (result.isSuccessful()) {\n-                transaction.commit(() -> {}, \"Failed to persist attestation result\");\n-              }\n-              return result;\n-            });\n+        .thenCompose(\n+            targetState ->\n+                withLock(\n+                    () -> {\n+                      final StoreTransaction transaction = recentChainData.startStoreTransaction();\n+                      final AttestationProcessingResult result =\n+                          on_attestation(\n+                              transaction, attestation, targetState, getForkChoiceStrategy());\n+                      return transaction.commit().thenApply(__ -> result);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80a8f18ef5e2efab537d814709d4058a0fec0946"}, "originalPosition": 194}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjAyMDA2OA==", "bodyText": "No. Good spot we need to fix that.", "url": "https://github.com/ConsenSys/teku/pull/2602#discussion_r472020068", "createdAt": "2020-08-18T08:48:55Z", "author": {"login": "ajsutton"}, "path": "ethereum/statetransition/src/main/java/tech/pegasys/teku/statetransition/forkchoice/ForkChoice.java", "diffHunk": "@@ -48,97 +52,119 @@ private void initializeProtoArrayForkChoice() {\n     processHead();\n   }\n \n-  public synchronized void processHead() {\n+  private void processHead() {\n     processHead(Optional.empty());\n   }\n \n-  public synchronized void processHead(UInt64 nodeSlot) {\n+  public void processHead(UInt64 nodeSlot) {\n     processHead(Optional.of(nodeSlot));\n   }\n \n-  private synchronized void processHead(Optional<UInt64> nodeSlot) {\n-    final Checkpoint finalizedCheckpoint = recentChainData.getStore().getFinalizedCheckpoint();\n-    final Checkpoint justifiedCheckpoint = recentChainData.getStore().getJustifiedCheckpoint();\n-    recentChainData\n-        .retrieveCheckpointState(justifiedCheckpoint)\n-        .thenAccept(\n-            justifiedCheckpointState -> {\n-              StoreTransaction transaction = recentChainData.startStoreTransaction();\n-              final ForkChoiceStrategy forkChoiceStrategy = getForkChoiceStrategy();\n-              Bytes32 headBlockRoot =\n-                  forkChoiceStrategy.findHead(\n-                      transaction,\n-                      finalizedCheckpoint,\n-                      justifiedCheckpoint,\n-                      justifiedCheckpointState.orElseThrow());\n-              transaction.commit(() -> {}, \"Failed to persist validator vote changes.\");\n-\n-              recentChainData.updateHead(\n-                  headBlockRoot,\n-                  nodeSlot.orElse(\n-                      forkChoiceStrategy\n-                          .blockSlot(headBlockRoot)\n-                          .orElseThrow(\n-                              () ->\n-                                  new IllegalStateException(\n-                                      \"Unable to retrieve the slot of fork choice head\"))));\n+  private void processHead(Optional<UInt64> nodeSlot) {\n+    withLock(\n+            () -> {\n+              final Checkpoint finalizedCheckpoint =\n+                  recentChainData.getStore().getFinalizedCheckpoint();\n+              final Checkpoint justifiedCheckpoint =\n+                  recentChainData.getStore().getJustifiedCheckpoint();\n+              return recentChainData\n+                  .retrieveCheckpointState(justifiedCheckpoint)\n+                  .thenCompose(\n+                      justifiedCheckpointState -> {\n+                        final StoreTransaction transaction =\n+                            recentChainData.startStoreTransaction();\n+                        final ForkChoiceStrategy forkChoiceStrategy = getForkChoiceStrategy();\n+                        Bytes32 headBlockRoot =\n+                            forkChoiceStrategy.findHead(\n+                                transaction,\n+                                finalizedCheckpoint,\n+                                justifiedCheckpoint,\n+                                justifiedCheckpointState.orElseThrow());\n+\n+                        recentChainData.updateHead(\n+                            headBlockRoot,\n+                            nodeSlot.orElse(\n+                                forkChoiceStrategy\n+                                    .blockSlot(headBlockRoot)\n+                                    .orElseThrow(\n+                                        () ->\n+                                            new IllegalStateException(\n+                                                \"Unable to retrieve the slot of fork choice head\"))));\n+                        return transaction.commit();\n+                      });\n             })\n         .join();\n   }\n \n-  public synchronized BlockImportResult onBlock(\n+  public SafeFuture<BlockImportResult> onBlock(\n       final SignedBeaconBlock block, Optional<BeaconState> preState) {\n-    final ForkChoiceStrategy forkChoiceStrategy = getForkChoiceStrategy();\n-    StoreTransaction transaction = recentChainData.startStoreTransaction();\n-    final BlockImportResult result =\n-        on_block(\n-            transaction,\n-            block,\n-            preState,\n-            stateTransition,\n-            forkChoiceStrategy,\n-            beaconState ->\n-                transaction.putStateRoot(\n-                    beaconState.hash_tree_root(),\n-                    new SlotAndBlockRoot(\n-                        beaconState.getSlot(),\n-                        beaconState.getLatest_block_header().hash_tree_root())));\n-\n-    if (!result.isSuccessful()) {\n-      return result;\n-    }\n-\n-    transaction.commit().join();\n-    result\n-        .getBlockProcessingRecord()\n-        .ifPresent(record -> forkChoiceStrategy.onBlock(block.getMessage(), record.getPostState()));\n-\n-    return result;\n+    return withLock(\n+        () -> {\n+          final ForkChoiceStrategy forkChoiceStrategy = getForkChoiceStrategy();\n+          final StoreTransaction transaction = recentChainData.startStoreTransaction();\n+          final BlockImportResult result =\n+              on_block(\n+                  transaction,\n+                  block,\n+                  preState,\n+                  stateTransition,\n+                  forkChoiceStrategy,\n+                  beaconState ->\n+                      transaction.putStateRoot(\n+                          beaconState.hash_tree_root(),\n+                          new SlotAndBlockRoot(\n+                              beaconState.getSlot(),\n+                              beaconState.getLatest_block_header().hash_tree_root())));\n+\n+          if (!result.isSuccessful()) {\n+            return SafeFuture.completedFuture(result);\n+          }\n+          return transaction\n+              .commit()\n+              .thenRun(\n+                  () ->\n+                      result\n+                          .getBlockProcessingRecord()\n+                          .ifPresent(\n+                              record ->\n+                                  forkChoiceStrategy.onBlock(\n+                                      block.getMessage(), record.getPostState())))\n+              .thenApply(__ -> result);\n+        });\n   }\n \n   public SafeFuture<AttestationProcessingResult> onAttestation(\n       final ValidateableAttestation attestation) {\n     return recentChainData\n         .retrieveCheckpointState(attestation.getData().getTarget())\n-        .thenApply(\n-            targetState -> {\n-              StoreTransaction transaction = recentChainData.startStoreTransaction();\n-              final AttestationProcessingResult result =\n-                  on_attestation(transaction, attestation, targetState, getForkChoiceStrategy());\n-              if (result.isSuccessful()) {\n-                transaction.commit(() -> {}, \"Failed to persist attestation result\");\n-              }\n-              return result;\n-            });\n+        .thenCompose(\n+            targetState ->\n+                withLock(\n+                    () -> {\n+                      final StoreTransaction transaction = recentChainData.startStoreTransaction();\n+                      final AttestationProcessingResult result =\n+                          on_attestation(\n+                              transaction, attestation, targetState, getForkChoiceStrategy());\n+                      return transaction.commit().thenApply(__ -> result);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjAwNjA3Mw=="}, "originalCommit": {"oid": "80a8f18ef5e2efab537d814709d4058a0fec0946"}, "originalPosition": 194}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3400, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}