{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY5MTk4NzQ4", "number": 2602, "title": "Fix race condition when committing changes to fork choice votes", "bodyText": "PR Description\nFixes race conditions in fork choice because while changes to votes were made within a read/write lock, the store transaction they were changed in was committed outside of that lock and so may wind up overwriting conflicting changes.\nAlso fixes access to Store.votes to ensure it only occurs inside the store's read lock.\nie:\nWhen we process attestations, we start a StoreTransaction then take the votes write lock, update the votes with next nextRoot and nextEpoch, release the write lock and then commit the transaction.\nWhen we update head, we start a StoreTransaction , take the votes write lock, apply deltas and set the vote current root to next root, release the write lock and then commit the transaction.\nTrouble is we might interleave those like:\nAttestation - start transaction\nAttestation - take write lock, update nextRoot, release write lock\nUpdate Head - start transaction\nUpdate Head - take write lock, apply deltas, update current root, release write lock\nUpdate Head - commit transaction\nAttestation - commit transaction, overwriting the vote changes that Update Head made.\nWith this change we likely have more locks than we actually need.  ForkChoice has been moved to use a ReentrantLock instead of synchronized so that it can use futures safely and still ensure the lock is held for the duration of the action and guaranteed to be released at the end.  But since all it's access to ProtoArrayForkChoiceStrategy is now controlled by that lock, we likely don't need as many locks in ProtoArrayForkChoiceStrategy. It may be better to make ProtoArrayForkChoiceStrategy not thread safe and control access entirely through ForkChoice but will leave that for further investigation later once we confirm this fixes the immediate issue.\nFixed Issue(s)\nfixes #2562\nDocumentation\n\n I thought about documentation and added the documentation label to this PR if updates are required.", "createdAt": "2020-08-18T04:50:29Z", "url": "https://github.com/ConsenSys/teku/pull/2602", "merged": true, "mergeCommit": {"oid": "39bfecad0bff96e5ab31aaca970929f45b61b94d"}, "closed": true, "closedAt": "2020-08-18T11:45:13Z", "author": {"login": "ajsutton"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc__iaVgH2gAyNDY5MTk4NzQ4Ojg5ZWJlN2YzNTZmNGY0OTcxNTliOWI4MjliMjVlNDAwOGMxOWIzNzE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdAD-McgH2gAyNDY5MTk4NzQ4OmIzY2M5NDQwYmRkMWVlYjZlMGE5YmQ5NmM0OWQwZGMzNDNiYmJkOTg=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "89ebe7f356f4f497159b9b829b25e4008c19b371", "author": {"user": {"login": "ajsutton", "name": "Adrian Sutton"}}, "url": "https://github.com/ConsenSys/teku/commit/89ebe7f356f4f497159b9b829b25e4008c19b371", "committedDate": "2020-08-18T04:44:55Z", "message": "Wrap fork choice updates in a lock to ensure that the store transaction that changes votes are committed before the lock is released."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9728e934ce093cbfefd2a5fc9d4d24e6c184d25b", "author": {"user": {"login": "ajsutton", "name": "Adrian Sutton"}}, "url": "https://github.com/ConsenSys/teku/commit/9728e934ce093cbfefd2a5fc9d4d24e6c184d25b", "committedDate": "2020-08-18T05:38:22Z", "message": "Ensure block updates are applied within the lock. Stop trying to be clever with store transactions."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "80a8f18ef5e2efab537d814709d4058a0fec0946", "author": {"user": {"login": "ajsutton", "name": "Adrian Sutton"}}, "url": "https://github.com/ConsenSys/teku/commit/80a8f18ef5e2efab537d814709d4058a0fec0946", "committedDate": "2020-08-18T05:57:45Z", "message": "Can't use a ReentrantLock because a different thread may release the lock than the one that acquires it."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5MDQzMzI4", "url": "https://github.com/ConsenSys/teku/pull/2602#pullrequestreview-469043328", "createdAt": "2020-08-18T07:03:24Z", "commit": {"oid": "80a8f18ef5e2efab537d814709d4058a0fec0946"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5MTAzMzI2", "url": "https://github.com/ConsenSys/teku/pull/2602#pullrequestreview-469103326", "createdAt": "2020-08-18T08:27:07Z", "commit": {"oid": "80a8f18ef5e2efab537d814709d4058a0fec0946"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwODoyNzowOFrOHCI9uQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwODoyNzowOFrOHCI9uQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjAwNjA3Mw==", "bodyText": "Seems like we don't check if the attestation processing was successful before committing anymore. Is this on purpose?", "url": "https://github.com/ConsenSys/teku/pull/2602#discussion_r472006073", "createdAt": "2020-08-18T08:27:08Z", "author": {"login": "cemozerr"}, "path": "ethereum/statetransition/src/main/java/tech/pegasys/teku/statetransition/forkchoice/ForkChoice.java", "diffHunk": "@@ -48,97 +52,119 @@ private void initializeProtoArrayForkChoice() {\n     processHead();\n   }\n \n-  public synchronized void processHead() {\n+  private void processHead() {\n     processHead(Optional.empty());\n   }\n \n-  public synchronized void processHead(UInt64 nodeSlot) {\n+  public void processHead(UInt64 nodeSlot) {\n     processHead(Optional.of(nodeSlot));\n   }\n \n-  private synchronized void processHead(Optional<UInt64> nodeSlot) {\n-    final Checkpoint finalizedCheckpoint = recentChainData.getStore().getFinalizedCheckpoint();\n-    final Checkpoint justifiedCheckpoint = recentChainData.getStore().getJustifiedCheckpoint();\n-    recentChainData\n-        .retrieveCheckpointState(justifiedCheckpoint)\n-        .thenAccept(\n-            justifiedCheckpointState -> {\n-              StoreTransaction transaction = recentChainData.startStoreTransaction();\n-              final ForkChoiceStrategy forkChoiceStrategy = getForkChoiceStrategy();\n-              Bytes32 headBlockRoot =\n-                  forkChoiceStrategy.findHead(\n-                      transaction,\n-                      finalizedCheckpoint,\n-                      justifiedCheckpoint,\n-                      justifiedCheckpointState.orElseThrow());\n-              transaction.commit(() -> {}, \"Failed to persist validator vote changes.\");\n-\n-              recentChainData.updateHead(\n-                  headBlockRoot,\n-                  nodeSlot.orElse(\n-                      forkChoiceStrategy\n-                          .blockSlot(headBlockRoot)\n-                          .orElseThrow(\n-                              () ->\n-                                  new IllegalStateException(\n-                                      \"Unable to retrieve the slot of fork choice head\"))));\n+  private void processHead(Optional<UInt64> nodeSlot) {\n+    withLock(\n+            () -> {\n+              final Checkpoint finalizedCheckpoint =\n+                  recentChainData.getStore().getFinalizedCheckpoint();\n+              final Checkpoint justifiedCheckpoint =\n+                  recentChainData.getStore().getJustifiedCheckpoint();\n+              return recentChainData\n+                  .retrieveCheckpointState(justifiedCheckpoint)\n+                  .thenCompose(\n+                      justifiedCheckpointState -> {\n+                        final StoreTransaction transaction =\n+                            recentChainData.startStoreTransaction();\n+                        final ForkChoiceStrategy forkChoiceStrategy = getForkChoiceStrategy();\n+                        Bytes32 headBlockRoot =\n+                            forkChoiceStrategy.findHead(\n+                                transaction,\n+                                finalizedCheckpoint,\n+                                justifiedCheckpoint,\n+                                justifiedCheckpointState.orElseThrow());\n+\n+                        recentChainData.updateHead(\n+                            headBlockRoot,\n+                            nodeSlot.orElse(\n+                                forkChoiceStrategy\n+                                    .blockSlot(headBlockRoot)\n+                                    .orElseThrow(\n+                                        () ->\n+                                            new IllegalStateException(\n+                                                \"Unable to retrieve the slot of fork choice head\"))));\n+                        return transaction.commit();\n+                      });\n             })\n         .join();\n   }\n \n-  public synchronized BlockImportResult onBlock(\n+  public SafeFuture<BlockImportResult> onBlock(\n       final SignedBeaconBlock block, Optional<BeaconState> preState) {\n-    final ForkChoiceStrategy forkChoiceStrategy = getForkChoiceStrategy();\n-    StoreTransaction transaction = recentChainData.startStoreTransaction();\n-    final BlockImportResult result =\n-        on_block(\n-            transaction,\n-            block,\n-            preState,\n-            stateTransition,\n-            forkChoiceStrategy,\n-            beaconState ->\n-                transaction.putStateRoot(\n-                    beaconState.hash_tree_root(),\n-                    new SlotAndBlockRoot(\n-                        beaconState.getSlot(),\n-                        beaconState.getLatest_block_header().hash_tree_root())));\n-\n-    if (!result.isSuccessful()) {\n-      return result;\n-    }\n-\n-    transaction.commit().join();\n-    result\n-        .getBlockProcessingRecord()\n-        .ifPresent(record -> forkChoiceStrategy.onBlock(block.getMessage(), record.getPostState()));\n-\n-    return result;\n+    return withLock(\n+        () -> {\n+          final ForkChoiceStrategy forkChoiceStrategy = getForkChoiceStrategy();\n+          final StoreTransaction transaction = recentChainData.startStoreTransaction();\n+          final BlockImportResult result =\n+              on_block(\n+                  transaction,\n+                  block,\n+                  preState,\n+                  stateTransition,\n+                  forkChoiceStrategy,\n+                  beaconState ->\n+                      transaction.putStateRoot(\n+                          beaconState.hash_tree_root(),\n+                          new SlotAndBlockRoot(\n+                              beaconState.getSlot(),\n+                              beaconState.getLatest_block_header().hash_tree_root())));\n+\n+          if (!result.isSuccessful()) {\n+            return SafeFuture.completedFuture(result);\n+          }\n+          return transaction\n+              .commit()\n+              .thenRun(\n+                  () ->\n+                      result\n+                          .getBlockProcessingRecord()\n+                          .ifPresent(\n+                              record ->\n+                                  forkChoiceStrategy.onBlock(\n+                                      block.getMessage(), record.getPostState())))\n+              .thenApply(__ -> result);\n+        });\n   }\n \n   public SafeFuture<AttestationProcessingResult> onAttestation(\n       final ValidateableAttestation attestation) {\n     return recentChainData\n         .retrieveCheckpointState(attestation.getData().getTarget())\n-        .thenApply(\n-            targetState -> {\n-              StoreTransaction transaction = recentChainData.startStoreTransaction();\n-              final AttestationProcessingResult result =\n-                  on_attestation(transaction, attestation, targetState, getForkChoiceStrategy());\n-              if (result.isSuccessful()) {\n-                transaction.commit(() -> {}, \"Failed to persist attestation result\");\n-              }\n-              return result;\n-            });\n+        .thenCompose(\n+            targetState ->\n+                withLock(\n+                    () -> {\n+                      final StoreTransaction transaction = recentChainData.startStoreTransaction();\n+                      final AttestationProcessingResult result =\n+                          on_attestation(\n+                              transaction, attestation, targetState, getForkChoiceStrategy());\n+                      return transaction.commit().thenApply(__ -> result);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "80a8f18ef5e2efab537d814709d4058a0fec0946"}, "originalPosition": 194}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5MTA4MzQy", "url": "https://github.com/ConsenSys/teku/pull/2602#pullrequestreview-469108342", "createdAt": "2020-08-18T08:33:20Z", "commit": {"oid": "80a8f18ef5e2efab537d814709d4058a0fec0946"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3c34ddee4ae680d1733b71e44474943b35805781", "author": {"user": {"login": "ajsutton", "name": "Adrian Sutton"}}, "url": "https://github.com/ConsenSys/teku/commit/3c34ddee4ae680d1733b71e44474943b35805781", "committedDate": "2020-08-18T08:52:36Z", "message": "Only commit if the attestation is valid."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b0dd1d3444186f94aac05385c6c5362993600c08", "author": {"user": {"login": "ajsutton", "name": "Adrian Sutton"}}, "url": "https://github.com/ConsenSys/teku/commit/b0dd1d3444186f94aac05385c6c5362993600c08", "committedDate": "2020-08-18T09:35:50Z", "message": "Merge branch 'master' of github.com:PegaSysEng/teku into fork-choice-locks"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b3cc9440bdd1eeb6e0a9bd96c49d0dc343bbbd98", "author": {"user": {"login": "ajsutton", "name": "Adrian Sutton"}}, "url": "https://github.com/ConsenSys/teku/commit/b3cc9440bdd1eeb6e0a9bd96c49d0dc343bbbd98", "committedDate": "2020-08-18T09:54:53Z", "message": "Merge branch 'master' of github.com:PegaSysEng/teku into fork-choice-locks"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3632, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}