{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg2NzY5NDY4", "number": 1359, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQyMjoyMDo1NlrODnRf9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQyMjozODoyMlrODnRvqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyNTA3NzY1OnYy", "diffSide": "RIGHT", "path": "acceptance-tests/src/test-support/java/tech/pegasys/artemis/test/acceptance/dsl/ArtemisNode.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQyMjoyMDo1NlrOF1LSkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQyMjoyMDo1NlrOF1LSkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMwMzgyNA==", "bodyText": "We should probably be using fetchBeaconHead here rather than waitForBeaconHead. Otherwise we're effectively nesting a waiter inside a waiter.  It will work but failure times become a lot longer unnecessarily.", "url": "https://github.com/ConsenSys/teku/pull/1359#discussion_r391303824", "createdAt": "2020-03-11T22:20:56Z", "author": {"login": "ajsutton"}, "path": "acceptance-tests/src/test-support/java/tech/pegasys/artemis/test/acceptance/dsl/ArtemisNode.java", "diffHunk": "@@ -137,39 +138,70 @@ public UnsignedLong getGenesisTime() throws IOException {\n     return fetchGenesisTime();\n   }\n \n-  public void waitForNewBlock() throws IOException {\n-    final Bytes32 startingBlockRoot = getCurrentBeaconHead().getBlockRoot();\n-    waitFor(\n-        () -> assertThat(getCurrentBeaconHead().getBlockRoot()).isNotEqualTo(startingBlockRoot));\n+  public void waitForNewBlock() {\n+    final Bytes32 startingBlockRoot = waitForBeaconHead().getBlockRoot();\n+    waitFor(() -> assertThat(waitForBeaconHead().getBlockRoot()).isNotEqualTo(startingBlockRoot));\n   }\n \n-  public void waitForNewFinalization() throws IOException {\n-    UnsignedLong startingFinalizedEpoch = getChainHead().finalized_epoch;\n+  public void waitForNewFinalization() {\n+    UnsignedLong startingFinalizedEpoch = waitForChainHead().finalized_epoch;\n     LOG.debug(\"Wait for finalized block\");\n     waitFor(\n-        () -> assertThat(getChainHead().finalized_epoch).isNotEqualTo(startingFinalizedEpoch), 540);\n+        () -> assertThat(waitForChainHead().finalized_epoch).isNotEqualTo(startingFinalizedEpoch),\n+        540);\n   }\n \n   public void waitUntilInSyncWith(final ArtemisNode targetNode) {\n     LOG.debug(\"Wait for {} to sync to {}\", nodeAlias, targetNode.nodeAlias);\n+    waitFor(() -> assertThat(waitForBeaconHead()).isEqualTo(targetNode.waitForBeaconHead()), 300);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d32cc919331aefe660c559f29a076279a86887b"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyNTA3ODIyOnYy", "diffSide": "RIGHT", "path": "acceptance-tests/src/test-support/java/tech/pegasys/artemis/test/acceptance/dsl/ArtemisNode.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQyMjoyMToxNFrOF1LS6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQyMjoyMToxNFrOF1LS6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMwMzkxNA==", "bodyText": "Probably should use fetchChainHead here inside the waiter.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    () -> assertThat(waitForChainHead().finalized_epoch).isNotEqualTo(startingFinalizedEpoch),\n          \n          \n            \n                    () -> assertThat(fetchChainHead().finalized_epoch).isNotEqualTo(startingFinalizedEpoch),", "url": "https://github.com/ConsenSys/teku/pull/1359#discussion_r391303914", "createdAt": "2020-03-11T22:21:14Z", "author": {"login": "ajsutton"}, "path": "acceptance-tests/src/test-support/java/tech/pegasys/artemis/test/acceptance/dsl/ArtemisNode.java", "diffHunk": "@@ -137,39 +138,70 @@ public UnsignedLong getGenesisTime() throws IOException {\n     return fetchGenesisTime();\n   }\n \n-  public void waitForNewBlock() throws IOException {\n-    final Bytes32 startingBlockRoot = getCurrentBeaconHead().getBlockRoot();\n-    waitFor(\n-        () -> assertThat(getCurrentBeaconHead().getBlockRoot()).isNotEqualTo(startingBlockRoot));\n+  public void waitForNewBlock() {\n+    final Bytes32 startingBlockRoot = waitForBeaconHead().getBlockRoot();\n+    waitFor(() -> assertThat(waitForBeaconHead().getBlockRoot()).isNotEqualTo(startingBlockRoot));\n   }\n \n-  public void waitForNewFinalization() throws IOException {\n-    UnsignedLong startingFinalizedEpoch = getChainHead().finalized_epoch;\n+  public void waitForNewFinalization() {\n+    UnsignedLong startingFinalizedEpoch = waitForChainHead().finalized_epoch;\n     LOG.debug(\"Wait for finalized block\");\n     waitFor(\n-        () -> assertThat(getChainHead().finalized_epoch).isNotEqualTo(startingFinalizedEpoch), 540);\n+        () -> assertThat(waitForChainHead().finalized_epoch).isNotEqualTo(startingFinalizedEpoch),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d32cc919331aefe660c559f29a076279a86887b"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyNTA3OTI4OnYy", "diffSide": "RIGHT", "path": "acceptance-tests/src/test-support/java/tech/pegasys/artemis/test/acceptance/dsl/ArtemisNode.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQyMjoyMTozN1rOF1LTfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQyMjoyMTozN1rOF1LTfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMwNDA2MQ==", "bodyText": "Probably should use fetchBeaconHead here.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                waitFor(() -> assertThat(waitForBeaconHead().getBlockRoot()).isNotEqualTo(startingBlockRoot));\n          \n          \n            \n                waitFor(() -> assertThat(fetchBeaconHead().getBlockRoot()).isNotEqualTo(startingBlockRoot));", "url": "https://github.com/ConsenSys/teku/pull/1359#discussion_r391304061", "createdAt": "2020-03-11T22:21:37Z", "author": {"login": "ajsutton"}, "path": "acceptance-tests/src/test-support/java/tech/pegasys/artemis/test/acceptance/dsl/ArtemisNode.java", "diffHunk": "@@ -137,39 +138,70 @@ public UnsignedLong getGenesisTime() throws IOException {\n     return fetchGenesisTime();\n   }\n \n-  public void waitForNewBlock() throws IOException {\n-    final Bytes32 startingBlockRoot = getCurrentBeaconHead().getBlockRoot();\n-    waitFor(\n-        () -> assertThat(getCurrentBeaconHead().getBlockRoot()).isNotEqualTo(startingBlockRoot));\n+  public void waitForNewBlock() {\n+    final Bytes32 startingBlockRoot = waitForBeaconHead().getBlockRoot();\n+    waitFor(() -> assertThat(waitForBeaconHead().getBlockRoot()).isNotEqualTo(startingBlockRoot));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d32cc919331aefe660c559f29a076279a86887b"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyNTA5MTkzOnYy", "diffSide": "RIGHT", "path": "networking/eth2/src/test/java/tech/pegasys/artemis/networking/eth2/gossip/topics/AttestationTopicHandlerTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQyMjoyNzoxN1rOF1LbRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQyMjoyNzoxN1rOF1LbRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMwNjA1Mg==", "bodyText": "Nice to be using real data structures instead of mocking them.", "url": "https://github.com/ConsenSys/teku/pull/1359#discussion_r391306052", "createdAt": "2020-03-11T22:27:17Z", "author": {"login": "ajsutton"}, "path": "networking/eth2/src/test/java/tech/pegasys/artemis/networking/eth2/gossip/topics/AttestationTopicHandlerTest.java", "diffHunk": "@@ -84,10 +82,10 @@ public void handleMessage_invalidAttestation_missingState() throws Exception {\n     final Bytes serialized = SimpleOffsetSerializer.serialize(attestation);\n \n     // Set up state to be missing\n-    final Bytes32 blockRoot = attestation.getData().getBeacon_block_root();\n-    Store mockStore = mock(Store.class);\n-    storageClient.setStore(mockStore);\n-    doReturn(null).when(mockStore).getBlockState(blockRoot);\n+    final ChainStorageClient storageClient = ChainStorageClient.memoryOnlyClient(eventBus);\n+    storageClient.setGenesisState(DataStructureUtil.randomBeaconState(1));\n+    final AttestationTopicHandler topicHandler =\n+        new AttestationTopicHandler(eventBus, storageClient, 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d32cc919331aefe660c559f29a076279a86887b"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyNTEwMjE5OnYy", "diffSide": "RIGHT", "path": "storage/src/main/java/tech/pegasys/artemis/storage/ChainStorageClient.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQyMjozMTo1NVrOF1Lh4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMlQxNToyNjo1M1rOF1jeqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMwNzc0NQ==", "bodyText": "Not a big deal but I think I preferred the initializeFromGenesis naming because it doesn't feel like it quite matches the pattern of a setter (particularly that it can't be called multiple times).", "url": "https://github.com/ConsenSys/teku/pull/1359#discussion_r391307745", "createdAt": "2020-03-11T22:31:55Z", "author": {"login": "ajsutton"}, "path": "storage/src/main/java/tech/pegasys/artemis/storage/ChainStorageClient.java", "diffHunk": "@@ -45,54 +47,68 @@\n   protected final EventBus eventBus;\n   private final TransactionPrecommit transactionPrecommit;\n \n+  private final AtomicBoolean storeInitialized = new AtomicBoolean(false);\n+  private final SafeFuture<Void> storeInitializedFuture = new SafeFuture<>();\n+  private final SafeFuture<Void> bestBlockInitialized = new SafeFuture<>();\n+\n   private volatile Store store;\n-  private volatile Bytes32 bestBlockRoot =\n-      Bytes32.ZERO; // block chosen by lmd ghost to build and attest on\n+  private volatile Optional<Bytes32> bestBlockRoot =\n+      Optional.empty(); // block chosen by lmd ghost to build and attest on\n   private volatile UnsignedLong bestSlot =\n       UnsignedLong.ZERO; // slot of the block chosen by lmd ghost to build and attest on\n   // Time\n   private volatile UnsignedLong genesisTime;\n \n   public static ChainStorageClient memoryOnlyClient(final EventBus eventBus) {\n-    return new ChainStorageClient(eventBus, TransactionPrecommit.memoryOnly());\n+    final ChainStorageClient client =\n+        new ChainStorageClient(eventBus, TransactionPrecommit.memoryOnly());\n+    eventBus.register(client);\n+    return client;\n+  }\n+\n+  public static SafeFuture<ChainStorageClient> storageBackedClient(final EventBus eventBus) {\n+    final StorageBackedChainStorageClientFactory factory =\n+        new StorageBackedChainStorageClientFactory(eventBus);\n+    eventBus.register(factory);\n+    return factory.get();\n   }\n \n-  public static ChainStorageClient storageBackedClient(final EventBus eventBus) {\n-    return new ChainStorageClient(eventBus, TransactionPrecommit.storageEnabled(eventBus));\n+  @VisibleForTesting\n+  static ChainStorageClient memoryOnlyClientWithStore(final EventBus eventBus, final Store store) {\n+    final ChainStorageClient client =\n+        new ChainStorageClient(eventBus, TransactionPrecommit.memoryOnly());\n+    eventBus.register(client);\n+    client.setStore(store);\n+    return client;\n   }\n \n-  private ChainStorageClient(EventBus eventBus, final TransactionPrecommit transactionPrecommit) {\n+  ChainStorageClient(EventBus eventBus, final TransactionPrecommit transactionPrecommit) {\n     this.eventBus = eventBus;\n     this.transactionPrecommit = transactionPrecommit;\n-    this.eventBus.register(this);\n   }\n \n-  public void initializeFromGenesis(final BeaconState initialState) {\n-    setGenesisTime(initialState.getGenesis_time());\n-    final Store store = Store.get_genesis_store(initialState);\n-    setStore(store);\n-    eventBus.post(new StoreGenesisDiskUpdateEvent(store));\n+  public void subscribeStoreInitialized(Runnable runnable) {\n+    storeInitializedFuture.always(runnable);\n+  }\n \n-    // The genesis state is by definition finalised so just get the root from there.\n-    Bytes32 headBlockRoot = store.getFinalizedCheckpoint().getRoot();\n-    BeaconBlock headBlock = store.getBlock(headBlockRoot);\n-    updateBestBlock(headBlockRoot, headBlock.getSlot());\n-    eventBus.post(new StoreInitializedEvent());\n+  public void subscribeBestBlockInitialized(Runnable runnable) {\n+    bestBlockInitialized.always(runnable);\n   }\n \n-  public void initializeFromStore(final Store store, final Bytes32 headBlockRoot) {\n-    BeaconState state = store.getBlockState(headBlockRoot);\n-    setGenesisTime(state.getGenesis_time());\n-    setStore(store);\n+  public void setGenesisState(final BeaconState genesisState) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d32cc919331aefe660c559f29a076279a86887b"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTcwMDEzOA==", "bodyText": "Fair enough - will switch it back", "url": "https://github.com/ConsenSys/teku/pull/1359#discussion_r391700138", "createdAt": "2020-03-12T15:26:53Z", "author": {"login": "mbaxter"}, "path": "storage/src/main/java/tech/pegasys/artemis/storage/ChainStorageClient.java", "diffHunk": "@@ -45,54 +47,68 @@\n   protected final EventBus eventBus;\n   private final TransactionPrecommit transactionPrecommit;\n \n+  private final AtomicBoolean storeInitialized = new AtomicBoolean(false);\n+  private final SafeFuture<Void> storeInitializedFuture = new SafeFuture<>();\n+  private final SafeFuture<Void> bestBlockInitialized = new SafeFuture<>();\n+\n   private volatile Store store;\n-  private volatile Bytes32 bestBlockRoot =\n-      Bytes32.ZERO; // block chosen by lmd ghost to build and attest on\n+  private volatile Optional<Bytes32> bestBlockRoot =\n+      Optional.empty(); // block chosen by lmd ghost to build and attest on\n   private volatile UnsignedLong bestSlot =\n       UnsignedLong.ZERO; // slot of the block chosen by lmd ghost to build and attest on\n   // Time\n   private volatile UnsignedLong genesisTime;\n \n   public static ChainStorageClient memoryOnlyClient(final EventBus eventBus) {\n-    return new ChainStorageClient(eventBus, TransactionPrecommit.memoryOnly());\n+    final ChainStorageClient client =\n+        new ChainStorageClient(eventBus, TransactionPrecommit.memoryOnly());\n+    eventBus.register(client);\n+    return client;\n+  }\n+\n+  public static SafeFuture<ChainStorageClient> storageBackedClient(final EventBus eventBus) {\n+    final StorageBackedChainStorageClientFactory factory =\n+        new StorageBackedChainStorageClientFactory(eventBus);\n+    eventBus.register(factory);\n+    return factory.get();\n   }\n \n-  public static ChainStorageClient storageBackedClient(final EventBus eventBus) {\n-    return new ChainStorageClient(eventBus, TransactionPrecommit.storageEnabled(eventBus));\n+  @VisibleForTesting\n+  static ChainStorageClient memoryOnlyClientWithStore(final EventBus eventBus, final Store store) {\n+    final ChainStorageClient client =\n+        new ChainStorageClient(eventBus, TransactionPrecommit.memoryOnly());\n+    eventBus.register(client);\n+    client.setStore(store);\n+    return client;\n   }\n \n-  private ChainStorageClient(EventBus eventBus, final TransactionPrecommit transactionPrecommit) {\n+  ChainStorageClient(EventBus eventBus, final TransactionPrecommit transactionPrecommit) {\n     this.eventBus = eventBus;\n     this.transactionPrecommit = transactionPrecommit;\n-    this.eventBus.register(this);\n   }\n \n-  public void initializeFromGenesis(final BeaconState initialState) {\n-    setGenesisTime(initialState.getGenesis_time());\n-    final Store store = Store.get_genesis_store(initialState);\n-    setStore(store);\n-    eventBus.post(new StoreGenesisDiskUpdateEvent(store));\n+  public void subscribeStoreInitialized(Runnable runnable) {\n+    storeInitializedFuture.always(runnable);\n+  }\n \n-    // The genesis state is by definition finalised so just get the root from there.\n-    Bytes32 headBlockRoot = store.getFinalizedCheckpoint().getRoot();\n-    BeaconBlock headBlock = store.getBlock(headBlockRoot);\n-    updateBestBlock(headBlockRoot, headBlock.getSlot());\n-    eventBus.post(new StoreInitializedEvent());\n+  public void subscribeBestBlockInitialized(Runnable runnable) {\n+    bestBlockInitialized.always(runnable);\n   }\n \n-  public void initializeFromStore(final Store store, final Bytes32 headBlockRoot) {\n-    BeaconState state = store.getBlockState(headBlockRoot);\n-    setGenesisTime(state.getGenesis_time());\n-    setStore(store);\n+  public void setGenesisState(final BeaconState genesisState) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMwNzc0NQ=="}, "originalCommit": {"oid": "0d32cc919331aefe660c559f29a076279a86887b"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyNTEwNzkyOnYy", "diffSide": "RIGHT", "path": "storage/src/main/java/tech/pegasys/artemis/storage/ChainStorageClient.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQyMjozNDoxMVrOF1LlIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQyMjozNDoxMVrOF1LlIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMwODU3Nw==", "bodyText": "Nice to see these becoming Optional instead of returning null.", "url": "https://github.com/ConsenSys/teku/pull/1359#discussion_r391308577", "createdAt": "2020-03-11T22:34:11Z", "author": {"login": "ajsutton"}, "path": "storage/src/main/java/tech/pegasys/artemis/storage/ChainStorageClient.java", "diffHunk": "@@ -154,7 +178,7 @@ public Bytes4 getForkAtEpoch(UnsignedLong epoch) {\n    *\n    * @return\n    */\n-  public Bytes32 getBestBlockRoot() {\n+  public Optional<Bytes32> getBestBlockRoot() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d32cc919331aefe660c559f29a076279a86887b"}, "originalPosition": 166}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQyNTExNzg2OnYy", "diffSide": "RIGHT", "path": "storage/src/main/java/tech/pegasys/artemis/storage/StorageBackedChainStorageClientFactory.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQyMjozODoyMlrOF1Lq7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMVQyMjozODoyMlrOF1Lq7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTMxMDA2Mw==", "bodyText": "I like specifically requesting the store instead of it just magically being fired at startup.  Should be even nicer when we get to convert this over to EventChannels.", "url": "https://github.com/ConsenSys/teku/pull/1359#discussion_r391310063", "createdAt": "2020-03-11T22:38:22Z", "author": {"login": "ajsutton"}, "path": "storage/src/main/java/tech/pegasys/artemis/storage/StorageBackedChainStorageClientFactory.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.storage;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.eventbus.Subscribe;\n+import java.util.OptionalLong;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import tech.pegasys.artemis.storage.events.GetStoreRequest;\n+import tech.pegasys.artemis.storage.events.GetStoreResponse;\n+import tech.pegasys.artemis.storage.events.StoreInitializedFromStorageEvent;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+\n+class StorageBackedChainStorageClientFactory {\n+  private static final Logger LOG = LogManager.getLogger();\n+  private final ChainStorageClient client;\n+  private final EventBus eventBus;\n+\n+  private final AtomicBoolean initializationStarted = new AtomicBoolean(false);\n+  private final SafeFuture<ChainStorageClient> initializationCompleted = new SafeFuture<>();\n+  private volatile OptionalLong getStoreRequestId = OptionalLong.empty();\n+\n+  public StorageBackedChainStorageClientFactory(final EventBus eventBus) {\n+    this.client = new ChainStorageClient(eventBus, TransactionPrecommit.storageEnabled(eventBus));\n+    this.eventBus = eventBus;\n+    eventBus.register(client);\n+  }\n+\n+  public SafeFuture<ChainStorageClient> get() {\n+    initializeFromStorage();\n+    return initializationCompleted;\n+  }\n+\n+  private void initializeFromStorage() {\n+    if (initializationStarted.compareAndSet(false, true)) {\n+      LOG.trace(\"Begin initializing {} from storage\", client.getClass().getSimpleName());\n+      final GetStoreRequest storeRequest = new GetStoreRequest();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d32cc919331aefe660c559f29a076279a86887b"}, "originalPosition": 50}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2535, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}