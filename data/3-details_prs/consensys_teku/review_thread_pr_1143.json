{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcyNjUzOTUz", "number": 1143, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMzo0MDoyMlrODepWQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMzo0MDoyMlrODepWQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMzNDYxMzEzOnYy", "diffSide": "RIGHT", "path": "networking/p2p/src/main/java/tech/pegasys/artemis/networking/p2p/libp2p/PeerManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMFQyMzo0MDoyMlrOFn5lhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMVQxNTowNDoxMVrOFoMcEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM4MjI3Ng==", "bodyText": "Given that this shouldn't ever complete exceptionally, could we use reportExceptions() on the end instead of ignoreFuture?  That way if for some reason an exception does bubble up because of a bug somewhere it will get logged instead of silently ignored.", "url": "https://github.com/ConsenSys/teku/pull/1143#discussion_r377382276", "createdAt": "2020-02-10T23:40:22Z", "author": {"login": "ajsutton"}, "path": "networking/p2p/src/main/java/tech/pegasys/artemis/networking/p2p/libp2p/PeerManager.java", "diffHunk": "@@ -83,36 +84,34 @@ public void unsubscribeConnect(final long subscriptionId) {\n \n   public SafeFuture<?> connect(final Multiaddr peer, final Network network) {\n     STDOUT.log(Level.DEBUG, \"Connecting to \" + peer);\n-    return SafeFuture.of(network.connect(peer))\n-        .whenComplete(\n-            (conn, throwable) -> {\n-              if (throwable != null) {\n-                STDOUT.log(\n-                    Level.DEBUG,\n-                    \"Connection to \" + peer + \" failed. Will retry shortly: \" + throwable);\n-                ignoreFuture(\n-                    scheduler.schedule(\n-                        () -> connect(peer, network).reportExceptions(),\n-                        RECONNECT_TIMEOUT,\n-                        TimeUnit.MILLISECONDS));\n-              } else {\n-                STDOUT.log(\n-                    Level.DEBUG,\n-                    \"Connection to peer: \"\n-                        + conn.secureSession().getRemoteId()\n-                        + \" was successful\");\n-                SafeFuture.of(conn.closeFuture())\n-                    .finish(\n-                        () -> {\n-                          LOG.debug(\"Connection to {} closed. Will retry shortly\", peer);\n-                          ignoreFuture(\n-                              scheduler.schedule(\n-                                  () -> connect(peer, network).reportExceptions(),\n-                                  RECONNECT_TIMEOUT,\n-                                  TimeUnit.MILLISECONDS));\n-                        });\n-              }\n-            });\n+    final SafeFuture<Connection> initialConnectionFuture = SafeFuture.of(network.connect(peer));\n+    final SafeFuture<?> retryLoop =\n+        initialConnectionFuture\n+            .thenCompose(\n+                conn -> {\n+                  LOG.debug(\n+                      \"Connection to peer {} was successful\", conn.secureSession().getRemoteId());\n+                  return SafeFuture.of(conn.closeFuture());\n+                })\n+            .exceptionally(\n+                (err) -> {\n+                  LOG.debug(\"Connection to {} failed: {}\", peer, err);\n+                  return null;\n+                })\n+            .thenCompose(\n+                (res) -> {\n+                  LOG.debug(\n+                      \"Connection to {} was closed. Will retry in {} sec\",\n+                      peer,\n+                      RECONNECT_TIMEOUT.toSeconds());\n+\n+                  return asynRunner.runAfterDelay(\n+                      () -> connect(peer, network),\n+                      RECONNECT_TIMEOUT.toMillis(),\n+                      TimeUnit.MILLISECONDS);\n+                });\n+    ignoreFuture(retryLoop);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca56949601e2341e64a45d4c0c13ff222ee6375f"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY5MTE1NA==", "bodyText": "\ud83d\udc4dupdated", "url": "https://github.com/ConsenSys/teku/pull/1143#discussion_r377691154", "createdAt": "2020-02-11T15:04:11Z", "author": {"login": "mbaxter"}, "path": "networking/p2p/src/main/java/tech/pegasys/artemis/networking/p2p/libp2p/PeerManager.java", "diffHunk": "@@ -83,36 +84,34 @@ public void unsubscribeConnect(final long subscriptionId) {\n \n   public SafeFuture<?> connect(final Multiaddr peer, final Network network) {\n     STDOUT.log(Level.DEBUG, \"Connecting to \" + peer);\n-    return SafeFuture.of(network.connect(peer))\n-        .whenComplete(\n-            (conn, throwable) -> {\n-              if (throwable != null) {\n-                STDOUT.log(\n-                    Level.DEBUG,\n-                    \"Connection to \" + peer + \" failed. Will retry shortly: \" + throwable);\n-                ignoreFuture(\n-                    scheduler.schedule(\n-                        () -> connect(peer, network).reportExceptions(),\n-                        RECONNECT_TIMEOUT,\n-                        TimeUnit.MILLISECONDS));\n-              } else {\n-                STDOUT.log(\n-                    Level.DEBUG,\n-                    \"Connection to peer: \"\n-                        + conn.secureSession().getRemoteId()\n-                        + \" was successful\");\n-                SafeFuture.of(conn.closeFuture())\n-                    .finish(\n-                        () -> {\n-                          LOG.debug(\"Connection to {} closed. Will retry shortly\", peer);\n-                          ignoreFuture(\n-                              scheduler.schedule(\n-                                  () -> connect(peer, network).reportExceptions(),\n-                                  RECONNECT_TIMEOUT,\n-                                  TimeUnit.MILLISECONDS));\n-                        });\n-              }\n-            });\n+    final SafeFuture<Connection> initialConnectionFuture = SafeFuture.of(network.connect(peer));\n+    final SafeFuture<?> retryLoop =\n+        initialConnectionFuture\n+            .thenCompose(\n+                conn -> {\n+                  LOG.debug(\n+                      \"Connection to peer {} was successful\", conn.secureSession().getRemoteId());\n+                  return SafeFuture.of(conn.closeFuture());\n+                })\n+            .exceptionally(\n+                (err) -> {\n+                  LOG.debug(\"Connection to {} failed: {}\", peer, err);\n+                  return null;\n+                })\n+            .thenCompose(\n+                (res) -> {\n+                  LOG.debug(\n+                      \"Connection to {} was closed. Will retry in {} sec\",\n+                      peer,\n+                      RECONNECT_TIMEOUT.toSeconds());\n+\n+                  return asynRunner.runAfterDelay(\n+                      () -> connect(peer, network),\n+                      RECONNECT_TIMEOUT.toMillis(),\n+                      TimeUnit.MILLISECONDS);\n+                });\n+    ignoreFuture(retryLoop);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM4MjI3Ng=="}, "originalCommit": {"oid": "ca56949601e2341e64a45d4c0c13ff222ee6375f"}, "originalPosition": 105}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2850, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}