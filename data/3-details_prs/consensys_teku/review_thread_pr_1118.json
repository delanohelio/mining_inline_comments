{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY4MTIwMzAw", "number": 1118, "reviewThreads": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxODowNzo0M1rODbUeSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQyMDoxNTozNFrODbtM9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5OTczNTc5OnYy", "diffSide": "RIGHT", "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/rpc/core/ResponseStreamImpl.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxODowNzo0M1rOFivK-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxODowNzo0M1rOFivK-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk2ODc2Mg==", "bodyText": "nice.", "url": "https://github.com/ConsenSys/teku/pull/1118#discussion_r371968762", "createdAt": "2020-01-28T18:07:43Z", "author": {"login": "cemozerr"}, "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/rpc/core/ResponseStreamImpl.java", "diffHunk": "@@ -76,4 +76,13 @@ public void completeSuccessfully() {\n   public void completeWithError(final Throwable error) {\n     completionFuture.completeExceptionally(error);\n   }\n+\n+  public void subscribeCompleted(RequestCompleteSubscriber subscriber) {\n+    completionFuture.finish(\n+        res -> subscriber.onRequestComplete(true), err -> subscriber.onRequestComplete(false));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ee1c1b7cd1b5530efcee0f1908fbb63691615f3"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5OTk2Mjg3OnYy", "diffSide": "RIGHT", "path": "util/src/test-support/java/tech/pegasys/artemis/util/executors/MockExecutorService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxOToyMDozN1rOFixamg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxOTo0NjowNVrOFiyNUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAwNTUzMA==", "bodyText": "do you not just do tasks.forEach() to make sure to not run futures added after you called this method?", "url": "https://github.com/ConsenSys/teku/pull/1118#discussion_r372005530", "createdAt": "2020-01-28T19:20:37Z", "author": {"login": "cemozerr"}, "path": "util/src/test-support/java/tech/pegasys/artemis/util/executors/MockExecutorService.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.util.executors;\n+\n+import static tech.pegasys.artemis.util.async.FutureUtil.ignoreFuture;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+\n+public class MockExecutorService implements ExecutorService {\n+\n+  private boolean autoRun = false;\n+\n+  private final List<ExecutorTask<?>> tasks = new ArrayList<>();\n+\n+  // Test utility for inspecting executor's futures\n+  public List<Future<?>> getFutures() {\n+    return tasks.stream().map(ExecutorTask::getFuture).collect(Collectors.toList());\n+  }\n+\n+  public void setAutoRun(final boolean shouldAutoRunTasks) {\n+    this.autoRun = shouldAutoRunTasks;\n+  }\n+\n+  public void runPendingFutures() {\n+    final List<ExecutorTask<?>> currentTasks = new ArrayList<>(tasks);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ee1c1b7cd1b5530efcee0f1908fbb63691615f3"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAxODUxNQ==", "bodyText": "Right - we only want to run tasks that are currently tracked.  Some of these tasks might trigger additional scheduled tasks.", "url": "https://github.com/ConsenSys/teku/pull/1118#discussion_r372018515", "createdAt": "2020-01-28T19:46:05Z", "author": {"login": "mbaxter"}, "path": "util/src/test-support/java/tech/pegasys/artemis/util/executors/MockExecutorService.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.util.executors;\n+\n+import static tech.pegasys.artemis.util.async.FutureUtil.ignoreFuture;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+\n+public class MockExecutorService implements ExecutorService {\n+\n+  private boolean autoRun = false;\n+\n+  private final List<ExecutorTask<?>> tasks = new ArrayList<>();\n+\n+  // Test utility for inspecting executor's futures\n+  public List<Future<?>> getFutures() {\n+    return tasks.stream().map(ExecutorTask::getFuture).collect(Collectors.toList());\n+  }\n+\n+  public void setAutoRun(final boolean shouldAutoRunTasks) {\n+    this.autoRun = shouldAutoRunTasks;\n+  }\n+\n+  public void runPendingFutures() {\n+    final List<ExecutorTask<?>> currentTasks = new ArrayList<>(tasks);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAwNTUzMA=="}, "originalCommit": {"oid": "4ee1c1b7cd1b5530efcee0f1908fbb63691615f3"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5OTk4MjQ4OnYy", "diffSide": "RIGHT", "path": "util/src/test-support/java/tech/pegasys/artemis/util/executors/MockExecutorService.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxOToyNjo1MlrOFixnAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQxOTo1MjozOVrOFiyaaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAwODcwNQ==", "bodyText": "Did you implement these because extending the interface required you to do so? I don't understand why you return the same exact thing that was passed into the argument.", "url": "https://github.com/ConsenSys/teku/pull/1118#discussion_r372008705", "createdAt": "2020-01-28T19:26:52Z", "author": {"login": "cemozerr"}, "path": "util/src/test-support/java/tech/pegasys/artemis/util/executors/MockExecutorService.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.util.executors;\n+\n+import static tech.pegasys.artemis.util.async.FutureUtil.ignoreFuture;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+\n+public class MockExecutorService implements ExecutorService {\n+\n+  private boolean autoRun = false;\n+\n+  private final List<ExecutorTask<?>> tasks = new ArrayList<>();\n+\n+  // Test utility for inspecting executor's futures\n+  public List<Future<?>> getFutures() {\n+    return tasks.stream().map(ExecutorTask::getFuture).collect(Collectors.toList());\n+  }\n+\n+  public void setAutoRun(final boolean shouldAutoRunTasks) {\n+    this.autoRun = shouldAutoRunTasks;\n+  }\n+\n+  public void runPendingFutures() {\n+    final List<ExecutorTask<?>> currentTasks = new ArrayList<>(tasks);\n+    currentTasks.forEach(ExecutorTask::run);\n+  }\n+\n+  public long getPendingFuturesCount() {\n+    return tasks.stream().filter(ExecutorTask::isPending).count();\n+  }\n+\n+  public void runPendingFuturesInSeparateThreads(final ExecutorService executorService) {\n+    final List<ExecutorTask<?>> currentTasks = new ArrayList<>(tasks);\n+    currentTasks.forEach(task -> executorService.execute(task::run));\n+  }\n+\n+  @Override\n+  public void shutdown() {}\n+\n+  @Override\n+  public List<Runnable> shutdownNow() {\n+    return Collections.emptyList();\n+  }\n+\n+  @Override\n+  public boolean isShutdown() {\n+    return false;\n+  }\n+\n+  @Override\n+  public boolean isTerminated() {\n+    return false;\n+  }\n+\n+  @Override\n+  public boolean awaitTermination(final long timeout, final TimeUnit unit)\n+      throws InterruptedException {\n+    return false;\n+  }\n+\n+  @Override\n+  public <T> Future<T> submit(final Callable<T> task) {\n+    ExecutorTask<T> execTask = new ExecutorTask<>(task::call);\n+    tasks.add(execTask);\n+    if (autoRun) {\n+      execTask.run();\n+    }\n+\n+    return execTask.getFuture();\n+  }\n+\n+  @Override\n+  public <T> Future<T> submit(final Runnable task, final T result) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ee1c1b7cd1b5530efcee0f1908fbb63691615f3"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAyMTA2OA==", "bodyText": "This task gets channeled to the submit method on line 85 which adds tracking arounds the tasks.", "url": "https://github.com/ConsenSys/teku/pull/1118#discussion_r372021068", "createdAt": "2020-01-28T19:51:09Z", "author": {"login": "mbaxter"}, "path": "util/src/test-support/java/tech/pegasys/artemis/util/executors/MockExecutorService.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.util.executors;\n+\n+import static tech.pegasys.artemis.util.async.FutureUtil.ignoreFuture;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+\n+public class MockExecutorService implements ExecutorService {\n+\n+  private boolean autoRun = false;\n+\n+  private final List<ExecutorTask<?>> tasks = new ArrayList<>();\n+\n+  // Test utility for inspecting executor's futures\n+  public List<Future<?>> getFutures() {\n+    return tasks.stream().map(ExecutorTask::getFuture).collect(Collectors.toList());\n+  }\n+\n+  public void setAutoRun(final boolean shouldAutoRunTasks) {\n+    this.autoRun = shouldAutoRunTasks;\n+  }\n+\n+  public void runPendingFutures() {\n+    final List<ExecutorTask<?>> currentTasks = new ArrayList<>(tasks);\n+    currentTasks.forEach(ExecutorTask::run);\n+  }\n+\n+  public long getPendingFuturesCount() {\n+    return tasks.stream().filter(ExecutorTask::isPending).count();\n+  }\n+\n+  public void runPendingFuturesInSeparateThreads(final ExecutorService executorService) {\n+    final List<ExecutorTask<?>> currentTasks = new ArrayList<>(tasks);\n+    currentTasks.forEach(task -> executorService.execute(task::run));\n+  }\n+\n+  @Override\n+  public void shutdown() {}\n+\n+  @Override\n+  public List<Runnable> shutdownNow() {\n+    return Collections.emptyList();\n+  }\n+\n+  @Override\n+  public boolean isShutdown() {\n+    return false;\n+  }\n+\n+  @Override\n+  public boolean isTerminated() {\n+    return false;\n+  }\n+\n+  @Override\n+  public boolean awaitTermination(final long timeout, final TimeUnit unit)\n+      throws InterruptedException {\n+    return false;\n+  }\n+\n+  @Override\n+  public <T> Future<T> submit(final Callable<T> task) {\n+    ExecutorTask<T> execTask = new ExecutorTask<>(task::call);\n+    tasks.add(execTask);\n+    if (autoRun) {\n+      execTask.run();\n+    }\n+\n+    return execTask.getFuture();\n+  }\n+\n+  @Override\n+  public <T> Future<T> submit(final Runnable task, final T result) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAwODcwNQ=="}, "originalCommit": {"oid": "4ee1c1b7cd1b5530efcee0f1908fbb63691615f3"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAyMTg2Nw==", "bodyText": "I grabbed these utils from besu btw: https://github.com/hyperledger/besu/blob/6060a79d6618fbeebf6e5e1da7e9f788a213598a/testutil/src/main/java/org/hyperledger/besu/testutil/MockExecutorService.java", "url": "https://github.com/ConsenSys/teku/pull/1118#discussion_r372021867", "createdAt": "2020-01-28T19:52:39Z", "author": {"login": "mbaxter"}, "path": "util/src/test-support/java/tech/pegasys/artemis/util/executors/MockExecutorService.java", "diffHunk": "@@ -0,0 +1,176 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.util.executors;\n+\n+import static tech.pegasys.artemis.util.async.FutureUtil.ignoreFuture;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.stream.Collectors;\n+\n+public class MockExecutorService implements ExecutorService {\n+\n+  private boolean autoRun = false;\n+\n+  private final List<ExecutorTask<?>> tasks = new ArrayList<>();\n+\n+  // Test utility for inspecting executor's futures\n+  public List<Future<?>> getFutures() {\n+    return tasks.stream().map(ExecutorTask::getFuture).collect(Collectors.toList());\n+  }\n+\n+  public void setAutoRun(final boolean shouldAutoRunTasks) {\n+    this.autoRun = shouldAutoRunTasks;\n+  }\n+\n+  public void runPendingFutures() {\n+    final List<ExecutorTask<?>> currentTasks = new ArrayList<>(tasks);\n+    currentTasks.forEach(ExecutorTask::run);\n+  }\n+\n+  public long getPendingFuturesCount() {\n+    return tasks.stream().filter(ExecutorTask::isPending).count();\n+  }\n+\n+  public void runPendingFuturesInSeparateThreads(final ExecutorService executorService) {\n+    final List<ExecutorTask<?>> currentTasks = new ArrayList<>(tasks);\n+    currentTasks.forEach(task -> executorService.execute(task::run));\n+  }\n+\n+  @Override\n+  public void shutdown() {}\n+\n+  @Override\n+  public List<Runnable> shutdownNow() {\n+    return Collections.emptyList();\n+  }\n+\n+  @Override\n+  public boolean isShutdown() {\n+    return false;\n+  }\n+\n+  @Override\n+  public boolean isTerminated() {\n+    return false;\n+  }\n+\n+  @Override\n+  public boolean awaitTermination(final long timeout, final TimeUnit unit)\n+      throws InterruptedException {\n+    return false;\n+  }\n+\n+  @Override\n+  public <T> Future<T> submit(final Callable<T> task) {\n+    ExecutorTask<T> execTask = new ExecutorTask<>(task::call);\n+    tasks.add(execTask);\n+    if (autoRun) {\n+      execTask.run();\n+    }\n+\n+    return execTask.getFuture();\n+  }\n+\n+  @Override\n+  public <T> Future<T> submit(final Runnable task, final T result) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjAwODcwNQ=="}, "originalCommit": {"oid": "4ee1c1b7cd1b5530efcee0f1908fbb63691615f3"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMDU0Nzc2OnYy", "diffSide": "RIGHT", "path": "util/src/test-support/java/tech/pegasys/artemis/util/executors/MockScheduledExecutor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQyMjo0MDozOVrOFi3JeA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxNTowNzo1NVrOFjL0rg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjA5OTQ0OA==", "bodyText": "We have an AsyncRunner interface now, (along with DelayedExecutorAsyncRunner and StubAsyncRunner) now so MockScheduledExecutor might be overkill for now, or else, we can remove the AsyncRunner, and refactor to use MockScheduledExecutor. In any case, we should pick one to prevent duplication.\nWith AsyncRunner interface, this is how the connect() method in PeerManager.java would look like:\n  public SafeFuture<?> connect(final Multiaddr peer, final Network network) {\n    STDOUT.log(Level.DEBUG, \"Connecting to \" + peer);\n    return SafeFuture.of(network.connect(peer))\n        .whenComplete(\n            (conn, throwable) -> {\n              if (throwable != null) {\n                STDOUT.log(\n                    Level.DEBUG,\n                    \"Connection to \" + peer + \" failed. Will retry shortly: \" + throwable);\n                    asyncRunner.runAfterDelay(\n                        () -> connect(peer, network),\n                        RECONNECT_TIMEOUT,\n                        TimeUnit.MILLISECONDS);\n              } else {\n                STDOUT.log(\n                    Level.DEBUG,\n                    \"Connection to peer: \"\n                        + conn.secureSession().getRemoteId()\n                        + \" was successful\");\n                SafeFuture.of(conn.closeFuture())\n                    .finish(\n                        () -> {\n                          LOG.debug(\"Connection to {} closed. Will retry shortly\", peer);\n                              asyncRunner.runAfterDelay(\n                                  () -> connect(peer, network),\n                                  RECONNECT_TIMEOUT,\n                                  TimeUnit.MILLISECONDS));\n                        });\n              }\n            });\n  }", "url": "https://github.com/ConsenSys/teku/pull/1118#discussion_r372099448", "createdAt": "2020-01-28T22:40:39Z", "author": {"login": "cemozerr"}, "path": "util/src/test-support/java/tech/pegasys/artemis/util/executors/MockScheduledExecutor.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.util.executors;\n+\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.Delayed;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+public class MockScheduledExecutor extends MockExecutorService implements ScheduledExecutorService {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e40cfe955405983c7a14303c33a4b5a2858a730"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQzODE5MA==", "bodyText": "Makes sense - will look into this", "url": "https://github.com/ConsenSys/teku/pull/1118#discussion_r372438190", "createdAt": "2020-01-29T15:07:55Z", "author": {"login": "mbaxter"}, "path": "util/src/test-support/java/tech/pegasys/artemis/util/executors/MockScheduledExecutor.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.util.executors;\n+\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.Delayed;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+public class MockScheduledExecutor extends MockExecutorService implements ScheduledExecutorService {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjA5OTQ0OA=="}, "originalCommit": {"oid": "9e40cfe955405983c7a14303c33a4b5a2858a730"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMDU2NTEzOnYy", "diffSide": "RIGHT", "path": "sync/src/main/java/tech/pegasys/artemis/sync/RetryDelayFunction.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQyMjo0NzozM1rOFi3T6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQyMjo0NzozM1rOFi3T6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEwMjEyMA==", "bodyText": "nice.", "url": "https://github.com/ConsenSys/teku/pull/1118#discussion_r372102120", "createdAt": "2020-01-28T22:47:33Z", "author": {"login": "cemozerr"}, "path": "sync/src/main/java/tech/pegasys/artemis/sync/RetryDelayFunction.java", "diffHunk": "@@ -0,0 +1,31 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.sync;\n+\n+import java.time.Duration;\n+\n+public interface RetryDelayFunction {\n+  public Duration getRetryDelay(final int retryCount);\n+\n+  static RetryDelayFunction createExponentialRetry(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e40cfe955405983c7a14303c33a4b5a2858a730"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMDU3MTExOnYy", "diffSide": "RIGHT", "path": "sync/src/integration-test/java/tech/pegasys/artemis/sync/BlockPropagationIntegrationTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQyMjo1MDowOVrOFi3XqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQyMjo1MDowOVrOFi3XqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEwMzA4MA==", "bodyText": "(nit) one Waiter.waitFor() uses the whole definition, the other one is just waitFor()", "url": "https://github.com/ConsenSys/teku/pull/1118#discussion_r372103080", "createdAt": "2020-01-28T22:50:09Z", "author": {"login": "cemozerr"}, "path": "sync/src/integration-test/java/tech/pegasys/artemis/sync/BlockPropagationIntegrationTest.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.sync;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static tech.pegasys.artemis.util.Waiter.waitFor;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.Test;\n+import tech.pegasys.artemis.data.BlockProcessingRecord;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.networking.eth2.Eth2NetworkFactory;\n+import tech.pegasys.artemis.statetransition.events.BlockProposedEvent;\n+import tech.pegasys.artemis.util.Waiter;\n+import tech.pegasys.artemis.util.bls.BLSKeyGenerator;\n+import tech.pegasys.artemis.util.bls.BLSKeyPair;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class BlockPropagationIntegrationTest {\n+  private final List<BLSKeyPair> validatorKeys = BLSKeyGenerator.generateKeyPairs(3);\n+  private final Eth2NetworkFactory networkFactory = new Eth2NetworkFactory();\n+\n+  @AfterEach\n+  public void tearDown() {\n+    networkFactory.stopAll();\n+  }\n+\n+  @Test\n+  public void shouldFetchUnknownAncestorsOfPropagatedBlock() throws Exception {\n+    UnsignedLong currentSlot = UnsignedLong.valueOf(Constants.GENESIS_SLOT);\n+\n+    // Setup node 1\n+    SyncingNodeManager node1 = SyncingNodeManager.create(networkFactory, validatorKeys);\n+    node1.chainUtil().setSlot(currentSlot);\n+\n+    // Add some blocks to node1, which node 2 will need to fetch\n+    final List<SignedBeaconBlock> blocksToFetch = new ArrayList<>();\n+    for (int i = 0; i < 3; i++) {\n+      currentSlot = currentSlot.plus(UnsignedLong.ONE);\n+      final BlockProcessingRecord record =\n+          node1.chainUtil().createAndImportBlockAtSlot(currentSlot);\n+      blocksToFetch.add(record.getBlock());\n+    }\n+\n+    // Setup node 2\n+    SyncingNodeManager node2 = SyncingNodeManager.create(networkFactory, validatorKeys);\n+\n+    // Connect networks\n+    waitFor(node1.network().connect(node2.network().getNodeAddress()));\n+    // Wait for connections to get set up\n+    Waiter.waitFor(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e40cfe955405983c7a14303c33a4b5a2858a730"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMDU4NDQxOnYy", "diffSide": "RIGHT", "path": "sync/src/main/java/tech/pegasys/artemis/sync/PendingPool.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOFQyMjo1NjowMVrOFi3gJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxNToxNDozNFrOFjMGTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEwNTI1NQ==", "bodyText": "Any reason we want to suppress the callback exceptions?", "url": "https://github.com/ConsenSys/teku/pull/1118#discussion_r372105255", "createdAt": "2020-01-28T22:56:01Z", "author": {"login": "cemozerr"}, "path": "sync/src/main/java/tech/pegasys/artemis/sync/PendingPool.java", "diffHunk": "@@ -46,15 +48,20 @@\n   private static final UnsignedLong GENESIS_SLOT = UnsignedLong.valueOf(Constants.GENESIS_SLOT);\n \n   private final EventBus eventBus;\n+  private final Subscribers<RequiredBlockRootSubscriber> requiredBlockRootSubscribers =\n+      Subscribers.create(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e40cfe955405983c7a14303c33a4b5a2858a730"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQ0MjcwMQ==", "bodyText": "It means that if any subscriber ends up throwing an exception, it doesn't bubble up to this class and interrupt its processing.  Otherwise - we have to assume that any time we dispatch events the subscribers might throw errors and we'd have to handle that here.  Since we have no context, at best we'd just end up logging the exception.  Instead, the Subscribers class just handles that for us by logging the errors.", "url": "https://github.com/ConsenSys/teku/pull/1118#discussion_r372442701", "createdAt": "2020-01-29T15:14:34Z", "author": {"login": "mbaxter"}, "path": "sync/src/main/java/tech/pegasys/artemis/sync/PendingPool.java", "diffHunk": "@@ -46,15 +48,20 @@\n   private static final UnsignedLong GENESIS_SLOT = UnsignedLong.valueOf(Constants.GENESIS_SLOT);\n \n   private final EventBus eventBus;\n+  private final Subscribers<RequiredBlockRootSubscriber> requiredBlockRootSubscribers =\n+      Subscribers.create(true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEwNTI1NQ=="}, "originalCommit": {"oid": "9e40cfe955405983c7a14303c33a4b5a2858a730"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMDkzODMyOnYy", "diffSide": "RIGHT", "path": "sync/src/main/java/tech/pegasys/artemis/sync/FetchBlockTask.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQwMjoyNTozNVrOFi65ew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQwMjoyNTozNVrOFi65ew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjE2MDg5MQ==", "bodyText": "This class and the static nested class is beautifully written. \ud83c\udf89", "url": "https://github.com/ConsenSys/teku/pull/1118#discussion_r372160891", "createdAt": "2020-01-29T02:25:35Z", "author": {"login": "cemozerr"}, "path": "sync/src/main/java/tech/pegasys/artemis/sync/FetchBlockTask.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.sync;\n+\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.NoSuchElementException;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.networking.eth2.Eth2Network;\n+import tech.pegasys.artemis.networking.eth2.peers.Eth2Peer;\n+import tech.pegasys.artemis.networking.p2p.peer.NodeId;\n+import tech.pegasys.artemis.sync.FetchBlockTask.FetchBlockResult.Status;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+\n+class FetchBlockTask {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e40cfe955405983c7a14303c33a4b5a2858a730"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMDk0MzAxOnYy", "diffSide": "RIGHT", "path": "sync/src/main/java/tech/pegasys/artemis/sync/FetchRecentBlocksService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQwMjoyOToyOVrOFi68iA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxNToyMzozN1rOFjMdXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjE2MTY3Mg==", "bodyText": "If we're only going to use the statically declared RetryDelayFunction above, why also have a member variable instance of it?", "url": "https://github.com/ConsenSys/teku/pull/1118#discussion_r372161672", "createdAt": "2020-01-29T02:29:29Z", "author": {"login": "cemozerr"}, "path": "sync/src/main/java/tech/pegasys/artemis/sync/FetchRecentBlocksService.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.sync;\n+\n+import static tech.pegasys.artemis.util.async.FutureUtil.ignoreFuture;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import java.time.Duration;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.networking.eth2.Eth2Network;\n+import tech.pegasys.artemis.service.serviceutils.Service;\n+import tech.pegasys.artemis.sync.FetchBlockTask.FetchBlockResult;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.events.Subscribers;\n+\n+class FetchRecentBlocksService extends Service {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private static final int MAX_CONCURRENT_REQUESTS = 3;\n+  private static final Duration WAIT_FOR_PEERS_DURATION = Duration.ofSeconds(30);\n+  private static final RetryDelayFunction DEFAULT_RETRY_DELAY_FUNCTION =\n+      RetryDelayFunction.createExponentialRetry(2, Duration.ofSeconds(5), Duration.ofMinutes(5));\n+\n+  private final int maxConcurrentRequests;\n+  private final Eth2Network eth2Network;\n+  private final PendingPool<SignedBeaconBlock> pendingBlocksPool;\n+\n+  private final Map<Bytes32, FetchBlockTask> allTasks = new ConcurrentHashMap<>();\n+  private final Queue<FetchBlockTask> pendingTasks = new ConcurrentLinkedQueue<>();\n+  private final Collection<FetchBlockTask> activeTasks = new ConcurrentLinkedQueue<>();\n+\n+  private final FetchBlockTaskFactory fetchBlockTaskFactory;\n+  private final RetryDelayFunction retryDelayFunction;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e40cfe955405983c7a14303c33a4b5a2858a730"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQ0ODYwNA==", "bodyText": "This pattern lets us inject mock values for testing.  But it doesn't look like I'm really doing anything special with this in the tests.  I'll look into simplifying.", "url": "https://github.com/ConsenSys/teku/pull/1118#discussion_r372448604", "createdAt": "2020-01-29T15:23:37Z", "author": {"login": "mbaxter"}, "path": "sync/src/main/java/tech/pegasys/artemis/sync/FetchRecentBlocksService.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.sync;\n+\n+import static tech.pegasys.artemis.util.async.FutureUtil.ignoreFuture;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import java.time.Duration;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.networking.eth2.Eth2Network;\n+import tech.pegasys.artemis.service.serviceutils.Service;\n+import tech.pegasys.artemis.sync.FetchBlockTask.FetchBlockResult;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.events.Subscribers;\n+\n+class FetchRecentBlocksService extends Service {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private static final int MAX_CONCURRENT_REQUESTS = 3;\n+  private static final Duration WAIT_FOR_PEERS_DURATION = Duration.ofSeconds(30);\n+  private static final RetryDelayFunction DEFAULT_RETRY_DELAY_FUNCTION =\n+      RetryDelayFunction.createExponentialRetry(2, Duration.ofSeconds(5), Duration.ofMinutes(5));\n+\n+  private final int maxConcurrentRequests;\n+  private final Eth2Network eth2Network;\n+  private final PendingPool<SignedBeaconBlock> pendingBlocksPool;\n+\n+  private final Map<Bytes32, FetchBlockTask> allTasks = new ConcurrentHashMap<>();\n+  private final Queue<FetchBlockTask> pendingTasks = new ConcurrentLinkedQueue<>();\n+  private final Collection<FetchBlockTask> activeTasks = new ConcurrentLinkedQueue<>();\n+\n+  private final FetchBlockTaskFactory fetchBlockTaskFactory;\n+  private final RetryDelayFunction retryDelayFunction;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjE2MTY3Mg=="}, "originalCommit": {"oid": "9e40cfe955405983c7a14303c33a4b5a2858a730"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMTAwNTQwOnYy", "diffSide": "RIGHT", "path": "sync/src/main/java/tech/pegasys/artemis/sync/PendingPool.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQwMzoxNTo1MFrOFi7hVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQwMzoxNTo1MFrOFi7hVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjE3MTA5Mg==", "bodyText": "(nit) I wound consider renaming pendingItemsByRequiredBlockRoot to requiredBlockRootToPendingItems. It took me a loooong while to figure out", "url": "https://github.com/ConsenSys/teku/pull/1118#discussion_r372171092", "createdAt": "2020-01-29T03:15:50Z", "author": {"login": "cemozerr"}, "path": "sync/src/main/java/tech/pegasys/artemis/sync/PendingPool.java", "diffHunk": "@@ -116,16 +123,23 @@ public void add(T item) {\n     }\n \n     final Bytes32 itemRoot = hashTreeRootFunction.apply(item);\n-    final Collection<Bytes32> dependentBlockRoots = dependentBlockHashFunction.apply(item);\n+    final Collection<Bytes32> requiredRoots = requiredBlockRootsFunction.apply(item);\n \n-    dependentBlockRoots.forEach(\n-        dependentBlockRoot ->\n-            // Index block by parent\n-            pendingItemsByDependentBlockRoot\n+    requiredRoots.forEach(\n+        requiredRoot ->\n+            // Index item by required roots\n+            pendingItemsByRequiredBlockRoot", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e40cfe955405983c7a14303c33a4b5a2858a730"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMzExMDk2OnYy", "diffSide": "RIGHT", "path": "sync/src/test/java/tech/pegasys/artemis/sync/FetchBlockTaskTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxNjo0MToxM1rOFjPfKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxNjo0MToxM1rOFjPfKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQ5ODIxOQ==", "bodyText": "very neat.", "url": "https://github.com/ConsenSys/teku/pull/1118#discussion_r372498219", "createdAt": "2020-01-29T16:41:13Z", "author": {"login": "cemozerr"}, "path": "sync/src/test/java/tech/pegasys/artemis/sync/FetchBlockTaskTest.java", "diffHunk": "@@ -0,0 +1,178 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.sync;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.datastructures.util.DataStructureUtil;\n+import tech.pegasys.artemis.networking.eth2.Eth2Network;\n+import tech.pegasys.artemis.networking.eth2.peers.Eth2Peer;\n+import tech.pegasys.artemis.networking.p2p.mock.MockNodeId;\n+import tech.pegasys.artemis.sync.FetchBlockTask.FetchBlockResult;\n+import tech.pegasys.artemis.sync.FetchBlockTask.FetchBlockResult.Status;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+\n+public class FetchBlockTaskTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1ecb2303a80ac3b70d198ae7afb5e21f883f157b"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMzE2MDI1OnYy", "diffSide": "RIGHT", "path": "sync/src/main/java/tech/pegasys/artemis/sync/PendingPool.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxNjo1NTowM1rOFjP-mQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxNjo1NTo0NlrOFjQAUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjUwNjI2NQ==", "bodyText": "(nit)\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                final Bytes32 itemRoot = hashTreeRootFunction.apply(item);\n          \n          \n            \n                final Bytes32 pendingItemRoot = hashTreeRootFunction.apply(item);", "url": "https://github.com/ConsenSys/teku/pull/1118#discussion_r372506265", "createdAt": "2020-01-29T16:55:03Z", "author": {"login": "cemozerr"}, "path": "sync/src/main/java/tech/pegasys/artemis/sync/PendingPool.java", "diffHunk": "@@ -116,16 +123,23 @@ public void add(T item) {\n     }\n \n     final Bytes32 itemRoot = hashTreeRootFunction.apply(item);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1ecb2303a80ac3b70d198ae7afb5e21f883f157b"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjUwNjcwNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                final Bytes32 itemRoot = hashTreeRootFunction.apply(item);\n          \n          \n            \n                final Bytes32 pendingItemRoot = hashTreeRootFunction.apply(pendingItem);", "url": "https://github.com/ConsenSys/teku/pull/1118#discussion_r372506707", "createdAt": "2020-01-29T16:55:46Z", "author": {"login": "cemozerr"}, "path": "sync/src/main/java/tech/pegasys/artemis/sync/PendingPool.java", "diffHunk": "@@ -116,16 +123,23 @@ public void add(T item) {\n     }\n \n     final Bytes32 itemRoot = hashTreeRootFunction.apply(item);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjUwNjI2NQ=="}, "originalCommit": {"oid": "1ecb2303a80ac3b70d198ae7afb5e21f883f157b"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMzQwMTE2OnYy", "diffSide": "RIGHT", "path": "sync/src/main/java/tech/pegasys/artemis/sync/FetchRecentBlocksService.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxODowOToyOVrOFjSXbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQyMDowODoyNlrOFjV-nA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU0NTM5MA==", "bodyText": "In what scenario here can the if statement return false?", "url": "https://github.com/ConsenSys/teku/pull/1118#discussion_r372545390", "createdAt": "2020-01-29T18:09:29Z", "author": {"login": "cemozerr"}, "path": "sync/src/main/java/tech/pegasys/artemis/sync/FetchRecentBlocksService.java", "diffHunk": "@@ -0,0 +1,249 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.sync;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import java.time.Duration;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.networking.eth2.Eth2Network;\n+import tech.pegasys.artemis.service.serviceutils.Service;\n+import tech.pegasys.artemis.sync.FetchBlockTask.FetchBlockResult;\n+import tech.pegasys.artemis.util.async.AsyncRunner;\n+import tech.pegasys.artemis.util.async.DelayedExecutorAsyncRunner;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.events.Subscribers;\n+\n+class FetchRecentBlocksService extends Service {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private static final int MAX_CONCURRENT_REQUESTS = 3;\n+  private static final Duration WAIT_FOR_PEERS_DURATION = Duration.ofSeconds(30);\n+  private static final RetryDelayFunction DEFAULT_RETRY_DELAY_FUNCTION =\n+      RetryDelayFunction.createExponentialRetry(2, Duration.ofSeconds(5), Duration.ofMinutes(5));\n+\n+  private final int maxConcurrentRequests;\n+  private final Eth2Network eth2Network;\n+  private final PendingPool<SignedBeaconBlock> pendingBlocksPool;\n+\n+  private final Map<Bytes32, FetchBlockTask> allTasks = new ConcurrentHashMap<>();\n+  private final Queue<FetchBlockTask> pendingTasks = new ConcurrentLinkedQueue<>();\n+  private final Collection<FetchBlockTask> activeTasks = new ConcurrentLinkedQueue<>();\n+\n+  private final FetchBlockTaskFactory fetchBlockTaskFactory;\n+  private final RetryDelayFunction retryDelayFunction;\n+  private final Subscribers<BlockSubscriber> blockSubscribers = Subscribers.create(true);\n+  private final AsyncRunner asyncRunner;\n+\n+  FetchRecentBlocksService(\n+      final AsyncRunner asyncRunner,\n+      final Eth2Network eth2Network,\n+      final PendingPool<SignedBeaconBlock> pendingBlocksPool,\n+      final FetchBlockTaskFactory fetchBlockTaskFactory,\n+      final RetryDelayFunction retryDelayFunction,\n+      final int maxConcurrentRequests) {\n+    this.asyncRunner = asyncRunner;\n+    this.maxConcurrentRequests = maxConcurrentRequests;\n+    this.eth2Network = eth2Network;\n+    this.pendingBlocksPool = pendingBlocksPool;\n+    this.fetchBlockTaskFactory = fetchBlockTaskFactory;\n+    this.retryDelayFunction = retryDelayFunction;\n+  }\n+\n+  public static FetchRecentBlocksService create(\n+      final Eth2Network eth2Network, final PendingPool<SignedBeaconBlock> pendingBlocksPool) {\n+    return new FetchRecentBlocksService(\n+        new DelayedExecutorAsyncRunner(),\n+        eth2Network,\n+        pendingBlocksPool,\n+        FetchBlockTask::create,\n+        DEFAULT_RETRY_DELAY_FUNCTION,\n+        MAX_CONCURRENT_REQUESTS);\n+  }\n+\n+  @Override\n+  protected SafeFuture<?> doStart() {\n+    setupSubscribers();\n+    return SafeFuture.completedFuture(null);\n+  }\n+\n+  @Override\n+  protected SafeFuture<?> doStop() {\n+    return SafeFuture.completedFuture(null);\n+  }\n+\n+  public long subscribeBlockFetched(final BlockSubscriber subscriber) {\n+    return blockSubscribers.subscribe(subscriber);\n+  }\n+\n+  public void unsubscribeBlockFetched(final int subscriberId) {\n+    blockSubscribers.unsubscribe(subscriberId);\n+  }\n+\n+  private void setupSubscribers() {\n+    this.pendingBlocksPool.subscribeRequiredBlockRoot(this::requestRecentBlock);\n+    this.pendingBlocksPool.subscribeRequiredBlockRootDropped(this::cancelRecentBlockRequest);\n+  }\n+\n+  public void requestRecentBlock(final Bytes32 blockRoot) {\n+    if (pendingBlocksPool.contains(blockRoot)) {\n+      // We've already got this block\n+      return;\n+    }\n+    final FetchBlockTask task = fetchBlockTaskFactory.create(eth2Network, blockRoot);\n+    if (allTasks.putIfAbsent(blockRoot, task) != null) {\n+      // We're already tracking this task\n+      task.cancel();\n+      return;\n+    }\n+    LOG.trace(\"Queue block to be fetched: {}\", blockRoot);\n+    queueTask(task);\n+  }\n+\n+  public void cancelRecentBlockRequest(final Bytes32 blockRoot) {\n+    final FetchBlockTask task = allTasks.get(blockRoot);\n+    if (task != null) {\n+      task.cancel();\n+    }\n+  }\n+\n+  private synchronized void checkTasks() {\n+    // If we have capacity, execute the next task\n+    if (activeTasks.size() < maxConcurrentRequests) {\n+      final FetchBlockTask nextTask = pendingTasks.poll();\n+      if (nextTask == null) {\n+        return;\n+      }\n+      runNextTask(nextTask);\n+    }\n+  }\n+\n+  private void runNextTask(final FetchBlockTask task) {\n+    registerActiveTask(task);\n+    task.run()\n+        .thenAccept(res -> processFetchResult(task, res))\n+        .exceptionally(\n+            (err) -> {\n+              LOG.warn(\"Failed to run \" + task.getClass().getSimpleName(), err);\n+              return null;\n+            })\n+        .always(() -> deregisterActiveTask(task));\n+  }\n+\n+  private void processFetchResult(final FetchBlockTask task, final FetchBlockResult result) {\n+    switch (result.getStatus()) {\n+      case SUCCESSFUL:\n+        handleFetchedBlock(task, result.getBlock());\n+        break;\n+      case NO_AVAILABLE_PEERS:\n+        // Wait a bit and then requeue\n+        queueTaskWithDelay(task, WAIT_FOR_PEERS_DURATION);\n+        break;\n+      case FETCH_FAILED:\n+        // Push task back onto queue to retry\n+        queueTaskWithRetryDelay(task);\n+        break;\n+      case CANCELLED:\n+        LOG.trace(\"Request for block cancelled: {}.\", task.getBlockRoot());\n+        removeTask(task);\n+        break;\n+    }\n+  }\n+\n+  private void registerActiveTask(FetchBlockTask task) {\n+    LOG.trace(\"Fetch block {}\", task.getBlockRoot());\n+    activeTasks.add(task);\n+  }\n+\n+  private void deregisterActiveTask(FetchBlockTask task) {\n+    activeTasks.remove(task);\n+    checkTasks();\n+  }\n+\n+  private void removeTask(FetchBlockTask task) {\n+    // Stop tracking task\n+    task.cancel();\n+    allTasks.compute(\n+        task.getBlockRoot(),\n+        (root, existingTask) -> {\n+          if (Objects.equals(task, existingTask)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1ecb2303a80ac3b70d198ae7afb5e21f883f157b"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU0NTc1Ng==", "bodyText": "And if there can be multiple tasks for each block root, why not have a set instead of a 1 to 1 mapping", "url": "https://github.com/ConsenSys/teku/pull/1118#discussion_r372545756", "createdAt": "2020-01-29T18:10:18Z", "author": {"login": "cemozerr"}, "path": "sync/src/main/java/tech/pegasys/artemis/sync/FetchRecentBlocksService.java", "diffHunk": "@@ -0,0 +1,249 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.sync;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import java.time.Duration;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.networking.eth2.Eth2Network;\n+import tech.pegasys.artemis.service.serviceutils.Service;\n+import tech.pegasys.artemis.sync.FetchBlockTask.FetchBlockResult;\n+import tech.pegasys.artemis.util.async.AsyncRunner;\n+import tech.pegasys.artemis.util.async.DelayedExecutorAsyncRunner;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.events.Subscribers;\n+\n+class FetchRecentBlocksService extends Service {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private static final int MAX_CONCURRENT_REQUESTS = 3;\n+  private static final Duration WAIT_FOR_PEERS_DURATION = Duration.ofSeconds(30);\n+  private static final RetryDelayFunction DEFAULT_RETRY_DELAY_FUNCTION =\n+      RetryDelayFunction.createExponentialRetry(2, Duration.ofSeconds(5), Duration.ofMinutes(5));\n+\n+  private final int maxConcurrentRequests;\n+  private final Eth2Network eth2Network;\n+  private final PendingPool<SignedBeaconBlock> pendingBlocksPool;\n+\n+  private final Map<Bytes32, FetchBlockTask> allTasks = new ConcurrentHashMap<>();\n+  private final Queue<FetchBlockTask> pendingTasks = new ConcurrentLinkedQueue<>();\n+  private final Collection<FetchBlockTask> activeTasks = new ConcurrentLinkedQueue<>();\n+\n+  private final FetchBlockTaskFactory fetchBlockTaskFactory;\n+  private final RetryDelayFunction retryDelayFunction;\n+  private final Subscribers<BlockSubscriber> blockSubscribers = Subscribers.create(true);\n+  private final AsyncRunner asyncRunner;\n+\n+  FetchRecentBlocksService(\n+      final AsyncRunner asyncRunner,\n+      final Eth2Network eth2Network,\n+      final PendingPool<SignedBeaconBlock> pendingBlocksPool,\n+      final FetchBlockTaskFactory fetchBlockTaskFactory,\n+      final RetryDelayFunction retryDelayFunction,\n+      final int maxConcurrentRequests) {\n+    this.asyncRunner = asyncRunner;\n+    this.maxConcurrentRequests = maxConcurrentRequests;\n+    this.eth2Network = eth2Network;\n+    this.pendingBlocksPool = pendingBlocksPool;\n+    this.fetchBlockTaskFactory = fetchBlockTaskFactory;\n+    this.retryDelayFunction = retryDelayFunction;\n+  }\n+\n+  public static FetchRecentBlocksService create(\n+      final Eth2Network eth2Network, final PendingPool<SignedBeaconBlock> pendingBlocksPool) {\n+    return new FetchRecentBlocksService(\n+        new DelayedExecutorAsyncRunner(),\n+        eth2Network,\n+        pendingBlocksPool,\n+        FetchBlockTask::create,\n+        DEFAULT_RETRY_DELAY_FUNCTION,\n+        MAX_CONCURRENT_REQUESTS);\n+  }\n+\n+  @Override\n+  protected SafeFuture<?> doStart() {\n+    setupSubscribers();\n+    return SafeFuture.completedFuture(null);\n+  }\n+\n+  @Override\n+  protected SafeFuture<?> doStop() {\n+    return SafeFuture.completedFuture(null);\n+  }\n+\n+  public long subscribeBlockFetched(final BlockSubscriber subscriber) {\n+    return blockSubscribers.subscribe(subscriber);\n+  }\n+\n+  public void unsubscribeBlockFetched(final int subscriberId) {\n+    blockSubscribers.unsubscribe(subscriberId);\n+  }\n+\n+  private void setupSubscribers() {\n+    this.pendingBlocksPool.subscribeRequiredBlockRoot(this::requestRecentBlock);\n+    this.pendingBlocksPool.subscribeRequiredBlockRootDropped(this::cancelRecentBlockRequest);\n+  }\n+\n+  public void requestRecentBlock(final Bytes32 blockRoot) {\n+    if (pendingBlocksPool.contains(blockRoot)) {\n+      // We've already got this block\n+      return;\n+    }\n+    final FetchBlockTask task = fetchBlockTaskFactory.create(eth2Network, blockRoot);\n+    if (allTasks.putIfAbsent(blockRoot, task) != null) {\n+      // We're already tracking this task\n+      task.cancel();\n+      return;\n+    }\n+    LOG.trace(\"Queue block to be fetched: {}\", blockRoot);\n+    queueTask(task);\n+  }\n+\n+  public void cancelRecentBlockRequest(final Bytes32 blockRoot) {\n+    final FetchBlockTask task = allTasks.get(blockRoot);\n+    if (task != null) {\n+      task.cancel();\n+    }\n+  }\n+\n+  private synchronized void checkTasks() {\n+    // If we have capacity, execute the next task\n+    if (activeTasks.size() < maxConcurrentRequests) {\n+      final FetchBlockTask nextTask = pendingTasks.poll();\n+      if (nextTask == null) {\n+        return;\n+      }\n+      runNextTask(nextTask);\n+    }\n+  }\n+\n+  private void runNextTask(final FetchBlockTask task) {\n+    registerActiveTask(task);\n+    task.run()\n+        .thenAccept(res -> processFetchResult(task, res))\n+        .exceptionally(\n+            (err) -> {\n+              LOG.warn(\"Failed to run \" + task.getClass().getSimpleName(), err);\n+              return null;\n+            })\n+        .always(() -> deregisterActiveTask(task));\n+  }\n+\n+  private void processFetchResult(final FetchBlockTask task, final FetchBlockResult result) {\n+    switch (result.getStatus()) {\n+      case SUCCESSFUL:\n+        handleFetchedBlock(task, result.getBlock());\n+        break;\n+      case NO_AVAILABLE_PEERS:\n+        // Wait a bit and then requeue\n+        queueTaskWithDelay(task, WAIT_FOR_PEERS_DURATION);\n+        break;\n+      case FETCH_FAILED:\n+        // Push task back onto queue to retry\n+        queueTaskWithRetryDelay(task);\n+        break;\n+      case CANCELLED:\n+        LOG.trace(\"Request for block cancelled: {}.\", task.getBlockRoot());\n+        removeTask(task);\n+        break;\n+    }\n+  }\n+\n+  private void registerActiveTask(FetchBlockTask task) {\n+    LOG.trace(\"Fetch block {}\", task.getBlockRoot());\n+    activeTasks.add(task);\n+  }\n+\n+  private void deregisterActiveTask(FetchBlockTask task) {\n+    activeTasks.remove(task);\n+    checkTasks();\n+  }\n+\n+  private void removeTask(FetchBlockTask task) {\n+    // Stop tracking task\n+    task.cancel();\n+    allTasks.compute(\n+        task.getBlockRoot(),\n+        (root, existingTask) -> {\n+          if (Objects.equals(task, existingTask)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU0NTM5MA=="}, "originalCommit": {"oid": "1ecb2303a80ac3b70d198ae7afb5e21f883f157b"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjYwNDU3Mg==", "bodyText": "I don't think this should ever actually return false - its just a safety thing to make sure that if somehow the task had been overwritten with a separate task, we won't interfere with the newer task.  There's a simpler way to do this though:  allTasks.remove(task.getBlockRoot(), task).  Will update.", "url": "https://github.com/ConsenSys/teku/pull/1118#discussion_r372604572", "createdAt": "2020-01-29T20:08:26Z", "author": {"login": "mbaxter"}, "path": "sync/src/main/java/tech/pegasys/artemis/sync/FetchRecentBlocksService.java", "diffHunk": "@@ -0,0 +1,249 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.sync;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import java.time.Duration;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.networking.eth2.Eth2Network;\n+import tech.pegasys.artemis.service.serviceutils.Service;\n+import tech.pegasys.artemis.sync.FetchBlockTask.FetchBlockResult;\n+import tech.pegasys.artemis.util.async.AsyncRunner;\n+import tech.pegasys.artemis.util.async.DelayedExecutorAsyncRunner;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.events.Subscribers;\n+\n+class FetchRecentBlocksService extends Service {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private static final int MAX_CONCURRENT_REQUESTS = 3;\n+  private static final Duration WAIT_FOR_PEERS_DURATION = Duration.ofSeconds(30);\n+  private static final RetryDelayFunction DEFAULT_RETRY_DELAY_FUNCTION =\n+      RetryDelayFunction.createExponentialRetry(2, Duration.ofSeconds(5), Duration.ofMinutes(5));\n+\n+  private final int maxConcurrentRequests;\n+  private final Eth2Network eth2Network;\n+  private final PendingPool<SignedBeaconBlock> pendingBlocksPool;\n+\n+  private final Map<Bytes32, FetchBlockTask> allTasks = new ConcurrentHashMap<>();\n+  private final Queue<FetchBlockTask> pendingTasks = new ConcurrentLinkedQueue<>();\n+  private final Collection<FetchBlockTask> activeTasks = new ConcurrentLinkedQueue<>();\n+\n+  private final FetchBlockTaskFactory fetchBlockTaskFactory;\n+  private final RetryDelayFunction retryDelayFunction;\n+  private final Subscribers<BlockSubscriber> blockSubscribers = Subscribers.create(true);\n+  private final AsyncRunner asyncRunner;\n+\n+  FetchRecentBlocksService(\n+      final AsyncRunner asyncRunner,\n+      final Eth2Network eth2Network,\n+      final PendingPool<SignedBeaconBlock> pendingBlocksPool,\n+      final FetchBlockTaskFactory fetchBlockTaskFactory,\n+      final RetryDelayFunction retryDelayFunction,\n+      final int maxConcurrentRequests) {\n+    this.asyncRunner = asyncRunner;\n+    this.maxConcurrentRequests = maxConcurrentRequests;\n+    this.eth2Network = eth2Network;\n+    this.pendingBlocksPool = pendingBlocksPool;\n+    this.fetchBlockTaskFactory = fetchBlockTaskFactory;\n+    this.retryDelayFunction = retryDelayFunction;\n+  }\n+\n+  public static FetchRecentBlocksService create(\n+      final Eth2Network eth2Network, final PendingPool<SignedBeaconBlock> pendingBlocksPool) {\n+    return new FetchRecentBlocksService(\n+        new DelayedExecutorAsyncRunner(),\n+        eth2Network,\n+        pendingBlocksPool,\n+        FetchBlockTask::create,\n+        DEFAULT_RETRY_DELAY_FUNCTION,\n+        MAX_CONCURRENT_REQUESTS);\n+  }\n+\n+  @Override\n+  protected SafeFuture<?> doStart() {\n+    setupSubscribers();\n+    return SafeFuture.completedFuture(null);\n+  }\n+\n+  @Override\n+  protected SafeFuture<?> doStop() {\n+    return SafeFuture.completedFuture(null);\n+  }\n+\n+  public long subscribeBlockFetched(final BlockSubscriber subscriber) {\n+    return blockSubscribers.subscribe(subscriber);\n+  }\n+\n+  public void unsubscribeBlockFetched(final int subscriberId) {\n+    blockSubscribers.unsubscribe(subscriberId);\n+  }\n+\n+  private void setupSubscribers() {\n+    this.pendingBlocksPool.subscribeRequiredBlockRoot(this::requestRecentBlock);\n+    this.pendingBlocksPool.subscribeRequiredBlockRootDropped(this::cancelRecentBlockRequest);\n+  }\n+\n+  public void requestRecentBlock(final Bytes32 blockRoot) {\n+    if (pendingBlocksPool.contains(blockRoot)) {\n+      // We've already got this block\n+      return;\n+    }\n+    final FetchBlockTask task = fetchBlockTaskFactory.create(eth2Network, blockRoot);\n+    if (allTasks.putIfAbsent(blockRoot, task) != null) {\n+      // We're already tracking this task\n+      task.cancel();\n+      return;\n+    }\n+    LOG.trace(\"Queue block to be fetched: {}\", blockRoot);\n+    queueTask(task);\n+  }\n+\n+  public void cancelRecentBlockRequest(final Bytes32 blockRoot) {\n+    final FetchBlockTask task = allTasks.get(blockRoot);\n+    if (task != null) {\n+      task.cancel();\n+    }\n+  }\n+\n+  private synchronized void checkTasks() {\n+    // If we have capacity, execute the next task\n+    if (activeTasks.size() < maxConcurrentRequests) {\n+      final FetchBlockTask nextTask = pendingTasks.poll();\n+      if (nextTask == null) {\n+        return;\n+      }\n+      runNextTask(nextTask);\n+    }\n+  }\n+\n+  private void runNextTask(final FetchBlockTask task) {\n+    registerActiveTask(task);\n+    task.run()\n+        .thenAccept(res -> processFetchResult(task, res))\n+        .exceptionally(\n+            (err) -> {\n+              LOG.warn(\"Failed to run \" + task.getClass().getSimpleName(), err);\n+              return null;\n+            })\n+        .always(() -> deregisterActiveTask(task));\n+  }\n+\n+  private void processFetchResult(final FetchBlockTask task, final FetchBlockResult result) {\n+    switch (result.getStatus()) {\n+      case SUCCESSFUL:\n+        handleFetchedBlock(task, result.getBlock());\n+        break;\n+      case NO_AVAILABLE_PEERS:\n+        // Wait a bit and then requeue\n+        queueTaskWithDelay(task, WAIT_FOR_PEERS_DURATION);\n+        break;\n+      case FETCH_FAILED:\n+        // Push task back onto queue to retry\n+        queueTaskWithRetryDelay(task);\n+        break;\n+      case CANCELLED:\n+        LOG.trace(\"Request for block cancelled: {}.\", task.getBlockRoot());\n+        removeTask(task);\n+        break;\n+    }\n+  }\n+\n+  private void registerActiveTask(FetchBlockTask task) {\n+    LOG.trace(\"Fetch block {}\", task.getBlockRoot());\n+    activeTasks.add(task);\n+  }\n+\n+  private void deregisterActiveTask(FetchBlockTask task) {\n+    activeTasks.remove(task);\n+    checkTasks();\n+  }\n+\n+  private void removeTask(FetchBlockTask task) {\n+    // Stop tracking task\n+    task.cancel();\n+    allTasks.compute(\n+        task.getBlockRoot(),\n+        (root, existingTask) -> {\n+          if (Objects.equals(task, existingTask)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU0NTM5MA=="}, "originalCommit": {"oid": "1ecb2303a80ac3b70d198ae7afb5e21f883f157b"}, "originalPosition": 189}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMzQxNDQ5OnYy", "diffSide": "RIGHT", "path": "sync/src/test/java/tech/pegasys/artemis/sync/FetchRecentBlocksServiceTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxODoxNDoxN1rOFjSgNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQyMDoxMToyM1rOFjWDzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU0NzYzNg==", "bodyText": "Why use the @mock annotation instead of the mock() method?", "url": "https://github.com/ConsenSys/teku/pull/1118#discussion_r372547636", "createdAt": "2020-01-29T18:14:17Z", "author": {"login": "cemozerr"}, "path": "sync/src/test/java/tech/pegasys/artemis/sync/FetchRecentBlocksServiceTest.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.sync;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.Mockito.lenient;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.datastructures.util.DataStructureUtil;\n+import tech.pegasys.artemis.networking.eth2.Eth2Network;\n+import tech.pegasys.artemis.sync.FetchBlockTask.FetchBlockResult;\n+import tech.pegasys.artemis.sync.FetchBlockTask.FetchBlockResult.Status;\n+import tech.pegasys.artemis.sync.FetchRecentBlocksService.FetchBlockTaskFactory;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.async.StubAsyncRunner;\n+\n+@ExtendWith(MockitoExtension.class)\n+public class FetchRecentBlocksServiceTest {\n+\n+  @Mock private Eth2Network eth2Network;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1ecb2303a80ac3b70d198ae7afb5e21f883f157b"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjYwNTkwMQ==", "bodyText": "I'm mainly using it because I don't know create a generic mock (PendingPool<SignedBeaconBlock>) with the mock() method without using casting and suppressing warnings.", "url": "https://github.com/ConsenSys/teku/pull/1118#discussion_r372605901", "createdAt": "2020-01-29T20:11:23Z", "author": {"login": "mbaxter"}, "path": "sync/src/test/java/tech/pegasys/artemis/sync/FetchRecentBlocksServiceTest.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.sync;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.anyInt;\n+import static org.mockito.Mockito.lenient;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.Mock;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.datastructures.util.DataStructureUtil;\n+import tech.pegasys.artemis.networking.eth2.Eth2Network;\n+import tech.pegasys.artemis.sync.FetchBlockTask.FetchBlockResult;\n+import tech.pegasys.artemis.sync.FetchBlockTask.FetchBlockResult.Status;\n+import tech.pegasys.artemis.sync.FetchRecentBlocksService.FetchBlockTaskFactory;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.async.StubAsyncRunner;\n+\n+@ExtendWith(MockitoExtension.class)\n+public class FetchRecentBlocksServiceTest {\n+\n+  @Mock private Eth2Network eth2Network;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU0NzYzNg=="}, "originalCommit": {"oid": "1ecb2303a80ac3b70d198ae7afb5e21f883f157b"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMzc2MDcyOnYy", "diffSide": "RIGHT", "path": "sync/src/main/java/tech/pegasys/artemis/sync/BlockPropagationManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQyMDowNToyOFrOFjV5pQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQyMDowNToyOFrOFjV5pQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjYwMzMwMQ==", "bodyText": "(nit)\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (blockIsInvalid(block)) {\n          \n          \n            \n                if (blockIsKnown(block) || blockIsInvalid(block)) {\n          \n      \n    \n    \n  \n\nThis way we can get rid of the blockIsKnown() check in the on gossipedBlock. It's confusing to have those checks in different functions imo.", "url": "https://github.com/ConsenSys/teku/pull/1118#discussion_r372603301", "createdAt": "2020-01-29T20:05:28Z", "author": {"login": "cemozerr"}, "path": "sync/src/main/java/tech/pegasys/artemis/sync/BlockPropagationManager.java", "diffHunk": "@@ -87,43 +108,55 @@ void onBlockImported(BlockImportedEvent blockImportedEvent) {\n     final SignedBeaconBlock block = blockImportedEvent.getBlock();\n     final Bytes32 blockRoot = block.getMessage().hash_tree_root();\n     pendingBlocks.remove(block);\n-    pendingBlocks\n-        .childrenOf(blockRoot)\n-        .forEach(\n-            child -> {\n-              pendingBlocks.remove(child);\n-              importBlock(child);\n-            });\n+    final List<SignedBeaconBlock> children = pendingBlocks.getItemsDependingOn(blockRoot, false);\n+    children.forEach(pendingBlocks::remove);\n+    children.forEach(this::importBlock);\n   }\n \n   @Subscribe\n   void onSlot(final SlotEvent slotEvent) {\n     futureBlocks.prune(slotEvent.getSlot()).forEach(this::importBlock);\n   }\n \n+  private boolean blockIsInvalid(final SignedBeaconBlock block) {\n+    return invalidBlockRoots.contains(block.getMessage().hash_tree_root())\n+        || invalidBlockRoots.contains(block.getParent_root());\n+  }\n+\n   private boolean blockIsKnown(final SignedBeaconBlock block) {\n     return pendingBlocks.contains(block)\n         || storageClient.getBlockByRoot(block.getMessage().hash_tree_root()).isPresent();\n   }\n \n   private void importBlock(final SignedBeaconBlock block) {\n+    if (blockIsInvalid(block)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1ecb2303a80ac3b70d198ae7afb5e21f883f157b"}, "originalPosition": 122}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMwMzc4NzQxOnYy", "diffSide": "RIGHT", "path": "sync/src/test/java/tech/pegasys/artemis/sync/BlockPropagationManagerTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQyMDoxNTozNFrOFjWKvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQyMDoxNTozNFrOFjWKvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjYwNzY3OA==", "bodyText": "I think this should be:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                // Gossip all blocks except the first\n          \n          \n            \n                // Gossip all blocks except the first two", "url": "https://github.com/ConsenSys/teku/pull/1118#discussion_r372607678", "createdAt": "2020-01-29T20:15:34Z", "author": {"login": "cemozerr"}, "path": "sync/src/test/java/tech/pegasys/artemis/sync/BlockPropagationManagerTest.java", "diffHunk": "@@ -155,6 +168,78 @@ public void onBlockImported_withPendingBlocks() throws Exception {\n     assertThat(pendingBlocks.size()).isEqualTo(0);\n   }\n \n+  @Test\n+  public void onBlockImportFailure_withPendingDependantBlocks() throws Exception {\n+    final int invalidChainDepth = 3;\n+    final List<SignedBeaconBlock> invalidBlockDescendants = new ArrayList<>(invalidChainDepth);\n+\n+    final SignedBeaconBlock invalidBlock =\n+        remoteChain.createBlockAtSlotFromInvalidProposer(incrementSlot());\n+    Bytes32 parentBlockRoot = invalidBlock.getMessage().hash_tree_root();\n+    for (int i = 0; i < invalidChainDepth; i++) {\n+      final UnsignedLong nextSlot = incrementSlot();\n+      final SignedBeaconBlock block =\n+          DataStructureUtil.randomSignedBeaconBlock(nextSlot.longValue(), parentBlockRoot, i);\n+      invalidBlockDescendants.add(block);\n+      parentBlockRoot = block.getMessage().hash_tree_root();\n+    }\n+\n+    // Gossip all blocks except the first\n+    invalidBlockDescendants.stream().map(GossipedBlockEvent::new).forEach(localEventBus::post);\n+    assertThat(importedBlocks.get()).isEmpty();\n+    assertThat(pendingBlocks.size()).isEqualTo(invalidChainDepth);\n+\n+    // Gossip next block, causing dependent blocks to be dropped when the import fails\n+    localEventBus.post(new GossipedBlockEvent(invalidBlock));\n+    assertThat(importedBlocks.get()).isEmpty();\n+    assertThat(pendingBlocks.size()).isEqualTo(0);\n+\n+    // If any invalid block is again gossiped, it should be ignored\n+    invalidBlockDescendants.stream().map(GossipedBlockEvent::new).forEach(localEventBus::post);\n+    assertThat(importedBlocks.get()).isEmpty();\n+    assertThat(pendingBlocks.size()).isEqualTo(0);\n+  }\n+\n+  @Test\n+  public void onBlockImportFailure_withUnconnectedPendingDependantBlocks() throws Exception {\n+    final int invalidChainDepth = 3;\n+    final List<SignedBeaconBlock> invalidBlockDescendants = new ArrayList<>(invalidChainDepth);\n+\n+    final SignedBeaconBlock invalidBlock =\n+        remoteChain.createBlockAtSlotFromInvalidProposer(incrementSlot());\n+    Bytes32 parentBlockRoot = invalidBlock.getMessage().hash_tree_root();\n+    for (int i = 0; i < invalidChainDepth; i++) {\n+      final UnsignedLong nextSlot = incrementSlot();\n+      final SignedBeaconBlock block =\n+          DataStructureUtil.randomSignedBeaconBlock(nextSlot.longValue(), parentBlockRoot, i);\n+      invalidBlockDescendants.add(block);\n+      parentBlockRoot = block.getMessage().hash_tree_root();\n+    }\n+\n+    // Gossip all blocks except the first", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1ecb2303a80ac3b70d198ae7afb5e21f883f157b"}, "originalPosition": 110}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2811, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}