{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM5MzU5Mjcy", "number": 2211, "title": "[Issue 2037] Limit hot blocks kept in memory", "bodyText": "PR Description\nLimit hot blocks kept in memory.\nChanges include:\n\nPass a BlockProvider into Store, allowing Store to drop blocks from memory, and re-pull them from storage as-needed.\nUpdate StateGenerator to run with a BlockProvider so that it can regenerate states even if the required blocks are not immediately available.\nUpdate Database.getStore() to return a StoreBuilder so that the BlockProvider (which will call back to the database to retrieve missing blocks) can be set externally.\nKeep a HashTree instance in Store, so that even if blocks are dropped, we can calculate which blocks are known, what hashes have been finalized, and what blocks are required to regenerate states\n\nRemaining TODO's:\n\nThe Store retrieves blocks asynchronously by calling to storage, but all API's are still synchronous.  We need to rework the API's to use futures where necessary.\n\nFixed Issue(s)\nFixes #2037\nDocumentation\n\n I thought about documentation and added the documentation label to this PR if updates are required.", "createdAt": "2020-06-24T17:50:50Z", "url": "https://github.com/ConsenSys/teku/pull/2211", "merged": true, "mergeCommit": {"oid": "d0baaea500b2b8547afdb1e0a6ebce11b0ffda6e"}, "closed": true, "closedAt": "2020-06-26T16:17:59Z", "author": {"login": "mbaxter"}, "timelineItems": {"totalCount": 30, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcudtQwgH2gAyNDM5MzU5MjcyOmNkYjA3NTFiNmZiNzJmNWJmNDJjZDk2ZjJjMTYwNWMzN2EzMWM5OWE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcvFh_5gH2gAyNDM5MzU5MjcyOmVjMGY0MWU3MDEyZWYzZDU1MzAxZjc3NGEzMzA0MTcwN2M3NWYxODM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "cdb0751b6fb72f5bf42cd96f2c1605c37a31c99a", "author": {"user": {"login": "mbaxter", "name": null}}, "url": "https://github.com/ConsenSys/teku/commit/cdb0751b6fb72f5bf42cd96f2c1605c37a31c99a", "committedDate": "2020-06-24T17:43:17Z", "message": "Cut unnecessary calls to Store.getBlock"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6999a8dc57a508f3cd29e821e617eb3a4a60baca", "author": {"user": {"login": "mbaxter", "name": null}}, "url": "https://github.com/ConsenSys/teku/commit/6999a8dc57a508f3cd29e821e617eb3a4a60baca", "committedDate": "2020-06-24T17:43:17Z", "message": "Create an object for holding pruning options"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aee9c4f8b6f26d944122d143f0271eb6bbc00c4c", "author": {"user": {"login": "mbaxter", "name": null}}, "url": "https://github.com/ConsenSys/teku/commit/aee9c4f8b6f26d944122d143f0271eb6bbc00c4c", "committedDate": "2020-06-24T17:43:17Z", "message": "Rework state generation to work with async BlockProvider"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9ebf9d31a789587d7441ffb2d7993fefeea8186a", "author": {"user": {"login": "mbaxter", "name": null}}, "url": "https://github.com/ConsenSys/teku/commit/9ebf9d31a789587d7441ffb2d7993fefeea8186a", "committedDate": "2020-06-24T17:45:34Z", "message": "Add StorageSystem.restart() helper"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0c7cf073929ce38bf6fd1a527e0a987251021121", "author": {"user": {"login": "mbaxter", "name": null}}, "url": "https://github.com/ConsenSys/teku/commit/0c7cf073929ce38bf6fd1a527e0a987251021121", "committedDate": "2020-06-24T17:45:37Z", "message": "Fix tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "94ea0e21cf867e5fac327211617928b251e9522f", "author": {"user": {"login": "mbaxter", "name": null}}, "url": "https://github.com/ConsenSys/teku/commit/94ea0e21cf867e5fac327211617928b251e9522f", "committedDate": "2020-06-24T17:45:37Z", "message": "Update state generator to provide (block, state) pairs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8dbb394c98493122335e9ca1443cb1e9f5e46cda", "author": {"user": {"login": "mbaxter", "name": null}}, "url": "https://github.com/ConsenSys/teku/commit/8dbb394c98493122335e9ca1443cb1e9f5e46cda", "committedDate": "2020-06-24T17:45:38Z", "message": "Don't supply full block list to Store constructor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "20beb15e8ec6124124c3dc61859505f75dba9317", "author": {"user": {"login": "mbaxter", "name": null}}, "url": "https://github.com/ConsenSys/teku/commit/20beb15e8ec6124124c3dc61859505f75dba9317", "committedDate": "2020-06-24T17:45:38Z", "message": "Limit hot blocks in memory"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "75a684130b29f61532d8cdf0dc7e34f753a159ad", "author": {"user": {"login": "mbaxter", "name": null}}, "url": "https://github.com/ConsenSys/teku/commit/75a684130b29f61532d8cdf0dc7e34f753a159ad", "committedDate": "2020-06-24T19:14:14Z", "message": "Move ChainBuilder default values"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "50a0d68840a8868649c9273a48c8cc04074b1013", "author": {"user": {"login": "mbaxter", "name": null}}, "url": "https://github.com/ConsenSys/teku/commit/50a0d68840a8868649c9273a48c8cc04074b1013", "committedDate": "2020-06-24T19:14:28Z", "message": "Fix defaults"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a38c90e7298afc4b78a187465b36ce110492710d", "author": {"user": {"login": "mbaxter", "name": null}}, "url": "https://github.com/ConsenSys/teku/commit/a38c90e7298afc4b78a187465b36ce110492710d", "committedDate": "2020-06-24T19:17:12Z", "message": "Fix integration tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5e7d73f506c8ebd65b68aa89637e3a643f0c04b7", "author": {"user": {"login": "mbaxter", "name": null}}, "url": "https://github.com/ConsenSys/teku/commit/5e7d73f506c8ebd65b68aa89637e3a643f0c04b7", "committedDate": "2020-06-24T21:21:27Z", "message": "Clean up"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6998ec6fc633f66cc6233e60cf68d21f92b16547", "author": {"user": {"login": "mbaxter", "name": null}}, "url": "https://github.com/ConsenSys/teku/commit/6998ec6fc633f66cc6233e60cf68d21f92b16547", "committedDate": "2020-06-24T21:32:50Z", "message": "Fix checkpointState initialization"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fa09cba24ce82ee092bf6fe0e06f81c093d2eb40", "author": {"user": {"login": "mbaxter", "name": null}}, "url": "https://github.com/ConsenSys/teku/commit/fa09cba24ce82ee092bf6fe0e06f81c093d2eb40", "committedDate": "2020-06-24T21:33:05Z", "message": "Cut problematic check"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "95d6039f1eeb870a8c81f6d8d76818d81abd7e88", "author": {"user": {"login": "mbaxter", "name": null}}, "url": "https://github.com/ConsenSys/teku/commit/95d6039f1eeb870a8c81f6d8d76818d81abd7e88", "committedDate": "2020-06-24T22:16:06Z", "message": "Expand StateGenerator tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0271a79de9e56422e273034a8403b06af7d782b1", "author": {"user": {"login": "mbaxter", "name": null}}, "url": "https://github.com/ConsenSys/teku/commit/0271a79de9e56422e273034a8403b06af7d782b1", "committedDate": "2020-06-25T17:07:18Z", "message": "Add more unit tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2bd942192ec9edc424077be1eb8a6c2bf17edb4b", "author": {"user": {"login": "mbaxter", "name": null}}, "url": "https://github.com/ConsenSys/teku/commit/2bd942192ec9edc424077be1eb8a6c2bf17edb4b", "committedDate": "2020-06-25T19:30:09Z", "message": "Simplify hashTree add more tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7ccf832a22644afdc399b6266f089dbca69d8fb3", "author": {"user": {"login": "mbaxter", "name": null}}, "url": "https://github.com/ConsenSys/teku/commit/7ccf832a22644afdc399b6266f089dbca69d8fb3", "committedDate": "2020-06-25T19:46:27Z", "message": "Build trees more efficiently"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d86b22cec72879bc1cd8fd76d89f1d2e3a6d6b62", "author": {"user": {"login": "mbaxter", "name": null}}, "url": "https://github.com/ConsenSys/teku/commit/d86b22cec72879bc1cd8fd76d89f1d2e3a6d6b62", "committedDate": "2020-06-25T19:54:18Z", "message": "Merge branch 'master' into issue-2037/limit-hot-blocks-kept-in-memory"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dee7982a8f639a8f37064bc41714f166844f7fa9", "author": {"user": {"login": "mbaxter", "name": null}}, "url": "https://github.com/ConsenSys/teku/commit/dee7982a8f639a8f37064bc41714f166844f7fa9", "committedDate": "2020-06-25T20:04:55Z", "message": "Cut unnecessary constraint"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1b0e63e9ca82558488f8b61d5dffab275b2c3daf", "author": {"user": {"login": "mbaxter", "name": null}}, "url": "https://github.com/ConsenSys/teku/commit/1b0e63e9ca82558488f8b61d5dffab275b2c3daf", "committedDate": "2020-06-25T20:33:08Z", "message": "Move factory helper to test util"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f6e6e89990cef63beda4da54c744bd9a29fc1c53", "author": {"user": {"login": "mbaxter", "name": null}}, "url": "https://github.com/ConsenSys/teku/commit/f6e6e89990cef63beda4da54c744bd9a29fc1c53", "committedDate": "2020-06-25T21:26:25Z", "message": "Fix internal calls to getSignedBlock"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "993f69fdb0762b7bc21e994355f79bf637703e2d", "author": {"user": {"login": "mbaxter", "name": null}}, "url": "https://github.com/ConsenSys/teku/commit/993f69fdb0762b7bc21e994355f79bf637703e2d", "committedDate": "2020-06-25T21:58:47Z", "message": "Fix overloaded method name"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8db57ee27ded5223778a708022c13ceedaa1964f", "author": {"user": {"login": "mbaxter", "name": null}}, "url": "https://github.com/ConsenSys/teku/commit/8db57ee27ded5223778a708022c13ceedaa1964f", "committedDate": "2020-06-25T22:36:37Z", "message": "Include cached blocks in Store's BlockProvider"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "843b5148550f1e8da1b35b9f80d6996750e73f26", "author": {"user": {"login": "mbaxter", "name": null}}, "url": "https://github.com/ConsenSys/teku/commit/843b5148550f1e8da1b35b9f80d6996750e73f26", "committedDate": "2020-06-25T23:32:51Z", "message": "Don't regenerate states when storageMode == PRUNE"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3OTQwMzc0", "url": "https://github.com/ConsenSys/teku/pull/2211#pullrequestreview-437940374", "createdAt": "2020-06-26T00:17:25Z", "commit": {"oid": "843b5148550f1e8da1b35b9f80d6996750e73f26"}, "state": "APPROVED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwMDozMzo0NFrOGpQJDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwMjowMjo0OFrOGpRaKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTkwOTI2MA==", "bodyText": "checkNotNull?", "url": "https://github.com/ConsenSys/teku/pull/2211#discussion_r445909260", "createdAt": "2020-06-26T00:33:44Z", "author": {"login": "ajsutton"}, "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/stategenerator/AsyncChainStateGenerator.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.core.stategenerator;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+\n+import com.google.common.collect.Lists;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.core.lookup.BlockProvider;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.hashtree.HashTree;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.util.async.SafeFuture;\n+\n+class AsyncChainStateGenerator {\n+  public static final int DEFAULT_BLOCK_BATCH_SIZE = 250;\n+\n+  private final HashTree blockTree;\n+  private final BlockProvider blockProvider;\n+  private final StateProvider stateProvider;\n+  private final int blockBatchSize;\n+\n+  private AsyncChainStateGenerator(\n+      final HashTree blockTree,\n+      final BlockProvider blockProvider,\n+      final StateProvider stateProvider,\n+      final int blockBatchSize) {\n+    this.blockTree = blockTree;\n+    this.blockProvider = blockProvider;\n+    this.stateProvider = stateProvider;\n+    this.blockBatchSize = blockBatchSize;\n+  }\n+\n+  public static AsyncChainStateGenerator create(\n+      final HashTree blockTree,\n+      final BlockProvider blockProvider,\n+      final StateProvider stateProvider) {\n+    return new AsyncChainStateGenerator(\n+        blockTree, blockProvider, stateProvider, DEFAULT_BLOCK_BATCH_SIZE);\n+  }\n+\n+  public SafeFuture<BeaconState> generateTargetState(final Bytes32 targetRoot) {\n+    if (!blockTree.contains(targetRoot)) {\n+      return SafeFuture.failedFuture(\n+          new IllegalArgumentException(\"Target root is unknown: \" + targetRoot));\n+    }\n+\n+    final SafeFuture<BeaconState> lastState = new SafeFuture<>();\n+    generateStates(\n+            targetRoot,\n+            (block, state) -> {\n+              if (block.getRoot().equals(targetRoot)) {\n+                lastState.complete(state);\n+              }\n+            })\n+        .finish(\n+            // Make sure future is completed\n+            () ->\n+                lastState.completeExceptionally(\n+                    new IllegalStateException(\"Failed to generate state for \" + targetRoot)),\n+            lastState::completeExceptionally);\n+\n+    return lastState;\n+  }\n+\n+  public SafeFuture<?> generateStates(final Bytes32 targetRoot, final StateHandler handler) {\n+    return SafeFuture.of(\n+        () -> {\n+          // Build chain from target root to the first ancestor with a known state\n+          final AtomicReference<BeaconState> baseState = new AtomicReference<>(null);\n+          final List<Bytes32> chain =\n+              blockTree.collectChainRoots(\n+                  targetRoot,\n+                  (currentRoot) -> {\n+                    stateProvider.getState(currentRoot).ifPresent(baseState::set);\n+                    return baseState.get() == null;\n+                  });\n+\n+          if (baseState.get() == null) {\n+            throw new IllegalArgumentException(\"Unable to find base state to build on\");\n+          }\n+\n+          if (chain.size() == 0) {\n+            throw new IllegalStateException(\"Failed to retrieve chain\");\n+          }\n+\n+          // Process chain in batches\n+          final List<List<Bytes32>> blockBatches = Lists.partition(chain, blockBatchSize);\n+          // Request and process each batch of blocks in order\n+          SafeFuture<BeaconState> future =\n+              processBlockBatch(blockBatches.get(0), baseState.get(), handler);\n+          for (int i = 1; i < blockBatches.size(); i++) {\n+            final List<Bytes32> blockBatch = blockBatches.get(i);\n+            future = future.thenCompose(state -> processBlockBatch(blockBatch, state, handler));\n+          }\n+          return future;\n+        });\n+  }\n+\n+  private SafeFuture<BeaconState> processBlockBatch(\n+      final List<Bytes32> blockRoots, final BeaconState startState, final StateHandler handler) {\n+    checkArgument(startState != null, \"Must provide start state\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "843b5148550f1e8da1b35b9f80d6996750e73f26"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTkxMDYwMg==", "bodyText": "We should probably just make this a field instead of creating a new instance for every block.", "url": "https://github.com/ConsenSys/teku/pull/2211#discussion_r445910602", "createdAt": "2020-06-26T00:39:15Z", "author": {"login": "ajsutton"}, "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/stategenerator/BlockProcessor.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.core.stategenerator;\n+\n+import tech.pegasys.teku.core.StateTransition;\n+import tech.pegasys.teku.core.StateTransitionException;\n+import tech.pegasys.teku.core.blockvalidator.NopBlockValidator;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+\n+class BlockProcessor {\n+\n+  public BeaconState process(final BeaconState preState, final SignedBeaconBlock block) {\n+    StateTransition stateTransition = new StateTransition(new NopBlockValidator());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "843b5148550f1e8da1b35b9f80d6996750e73f26"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTkxMTA3Ng==", "bodyText": "Isn't this the same check that assertBlockAndStateMatch is doing?", "url": "https://github.com/ConsenSys/teku/pull/2211#discussion_r445911076", "createdAt": "2020-06-26T00:41:06Z", "author": {"login": "ajsutton"}, "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/stategenerator/BlockProcessor.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.core.stategenerator;\n+\n+import tech.pegasys.teku.core.StateTransition;\n+import tech.pegasys.teku.core.StateTransitionException;\n+import tech.pegasys.teku.core.blockvalidator.NopBlockValidator;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+\n+class BlockProcessor {\n+\n+  public BeaconState process(final BeaconState preState, final SignedBeaconBlock block) {\n+    StateTransition stateTransition = new StateTransition(new NopBlockValidator());\n+    try {\n+      final BeaconState postState = stateTransition.initiate(preState, block);\n+      assertBlockAndStateMatch(block, postState);\n+      // Validate that state matches expectation\n+      if (!block.getMessage().getState_root().equals(postState.hash_tree_root())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "843b5148550f1e8da1b35b9f80d6996750e73f26"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTkxNDEyNw==", "bodyText": "There isn't a good one that I know of.", "url": "https://github.com/ConsenSys/teku/pull/2211#discussion_r445914127", "createdAt": "2020-06-26T00:53:51Z", "author": {"login": "ajsutton"}, "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/stategenerator/StateGenerator.java", "diffHunk": "@@ -0,0 +1,202 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.core.stategenerator;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static tech.pegasys.teku.core.stategenerator.AsyncChainStateGenerator.DEFAULT_BLOCK_BATCH_SIZE;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.Lists;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.core.lookup.BlockProvider;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.blocks.SignedBlockAndState;\n+import tech.pegasys.teku.datastructures.hashtree.HashTree;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.datastructures.state.BlockRootAndState;\n+import tech.pegasys.teku.util.async.SafeFuture;\n+\n+public class StateGenerator {\n+  public static final int DEFAULT_STATE_CACHE_SIZE = 50;\n+\n+  private final BlockProcessor blockProcessor = new BlockProcessor();\n+  private final HashTree blockTree;\n+  private final BlockProvider blockProvider;\n+  private final AsyncChainStateGenerator chainStateGenerator;\n+\n+  private final StateCache stateCache;\n+  private final int blockBatchSize;\n+\n+  private StateGenerator(\n+      final HashTree blockTree,\n+      final BlockProvider blockProvider,\n+      final AsyncChainStateGenerator chainStateGenerator,\n+      final StateCache stateCache,\n+      final int blockBatchSize) {\n+    checkArgument(blockBatchSize > 0, \"Must provide a block batch size > 0\");\n+    checkArgument(\n+        stateCache.containsKnownState(blockTree.getRootHash()), \"Root state must be available\");\n+\n+    this.blockTree = blockTree;\n+    this.blockProvider = blockProvider;\n+    this.stateCache = stateCache;\n+    this.blockBatchSize = blockBatchSize;\n+    this.chainStateGenerator = chainStateGenerator;\n+  }\n+\n+  public static StateGenerator create(\n+      final HashTree blockTree,\n+      final SignedBlockAndState rootBlockAndState,\n+      final BlockProvider blockProvider) {\n+    return create(blockTree, rootBlockAndState, blockProvider, Collections.emptyMap());\n+  }\n+\n+  public static StateGenerator create(\n+      final HashTree blockTree,\n+      final SignedBlockAndState rootBlockAndState,\n+      final BlockProvider blockProvider,\n+      final Map<Bytes32, BeaconState> knownStates) {\n+    return create(\n+        blockTree,\n+        rootBlockAndState,\n+        blockProvider,\n+        knownStates,\n+        DEFAULT_BLOCK_BATCH_SIZE,\n+        DEFAULT_STATE_CACHE_SIZE);\n+  }\n+\n+  public static StateGenerator create(\n+      final HashTree blockTree,\n+      final SignedBlockAndState rootBlockAndState,\n+      final BlockProvider blockProvider,\n+      final Map<Bytes32, BeaconState> knownStates,\n+      final int blockBatchSize,\n+      final int stateCacheSize) {\n+    checkArgument(\n+        rootBlockAndState.getRoot().equals(blockTree.getRootHash()),\n+        \"Provided root block must match the root of the provided block tree\");\n+\n+    final Map<Bytes32, BeaconState> availableStates = new HashMap<>(knownStates);\n+    availableStates.put(rootBlockAndState.getRoot(), rootBlockAndState.getState());\n+    final StateCache stateCache = new StateCache(stateCacheSize, availableStates);\n+\n+    final AsyncChainStateGenerator chainStateGenerator =\n+        AsyncChainStateGenerator.create(blockTree, blockProvider, stateCache::get);\n+    return new StateGenerator(\n+        blockTree, blockProvider, chainStateGenerator, stateCache, blockBatchSize);\n+  }\n+\n+  public SafeFuture<BeaconState> regenerateStateForBlock(final Bytes32 blockRoot) {\n+    return chainStateGenerator.generateTargetState(blockRoot);\n+  }\n+\n+  public SafeFuture<Void> regenerateAllStates(final StateHandler stateHandler) {\n+    return regenerateAllStatesInternal(stateHandler).thenAccept(__ -> stateCache.clear());\n+  }\n+\n+  @VisibleForTesting\n+  SafeFuture<?> regenerateAllStatesInternal(final StateHandler stateHandler) {\n+    final List<Bytes32> blockRoots = blockTree.preOrderStream().collect(Collectors.toList());\n+    if (blockRoots.size() == 0) {\n+      return SafeFuture.completedFuture(null);\n+    }\n+\n+    // Break up blocks into batches\n+    // TODO - is there a way to partition the stream directly?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "843b5148550f1e8da1b35b9f80d6996750e73f26"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTkyMTk4MA==", "bodyText": "Nice. I really don't know why we hadn't thought of that earlier...", "url": "https://github.com/ConsenSys/teku/pull/2211#discussion_r445921980", "createdAt": "2020-06-26T01:27:46Z", "author": {"login": "ajsutton"}, "path": "ethereum/core/src/testFixtures/java/tech/pegasys/teku/core/ChainBuilder.java", "diffHunk": "@@ -53,6 +54,8 @@\n \n /** A utility for building small, valid chains of blocks with states for testing */\n public class ChainBuilder {\n+  private static final List<BLSKeyPair> DEFAULT_VALIDATOR_KEYS =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "843b5148550f1e8da1b35b9f80d6996750e73f26"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTkyNzg4Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    .map(root -> hotDao.getHotBlock(root).orElse(null))\n          \n          \n            \n                    .filter(Objects::nonNull)\n          \n          \n            \n                    .flatMap(root -> hotDao.getHotBlock(root).stream())", "url": "https://github.com/ConsenSys/teku/pull/2211#discussion_r445927883", "createdAt": "2020-06-26T01:53:55Z", "author": {"login": "ajsutton"}, "path": "storage/src/main/java/tech/pegasys/teku/storage/server/rocksdb/RocksDbDatabase.java", "diffHunk": "@@ -220,6 +230,14 @@ public void update(final StorageUpdate event) {\n     return hotDao.getHotBlock(root).or(() -> finalizedDao.getFinalizedBlock(root));\n   }\n \n+  @Override\n+  public Map<Bytes32, SignedBeaconBlock> getHotBlocks(final Set<Bytes32> blockRoots) {\n+    return blockRoots.stream()\n+        .map(root -> hotDao.getHotBlock(root).orElse(null))\n+        .filter(Objects::nonNull)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "843b5148550f1e8da1b35b9f80d6996750e73f26"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTkyODQ2NQ==", "bodyText": "I suspect the next step is actually to avoid regenerating states at this point.  We only store snapshots anyway so could just leave a bigger gap than usual between snapshots if finalisation is delayed (and potentially fill that gap if we do wind up having to generate the states for an API request in the future).\nMakes sense to leave that for the future though.", "url": "https://github.com/ConsenSys/teku/pull/2211#discussion_r445928465", "createdAt": "2020-06-26T01:56:12Z", "author": {"login": "ajsutton"}, "path": "storage/src/main/java/tech/pegasys/teku/storage/server/rocksdb/RocksDbDatabase.java", "diffHunk": "@@ -289,36 +306,67 @@ private void doUpdate(final StorageUpdate update) {\n     }\n   }\n \n-  private void putFinalizedStates(\n-      FinalizedUpdater updater,\n+  private void updateFinalizedData(\n+      Map<Bytes32, Bytes32> finalizedChildToParentMap,\n       final Map<Bytes32, SignedBeaconBlock> finalizedBlocks,\n       final Map<Bytes32, BeaconState> finalizedStates) {\n-    if (finalizedBlocks.isEmpty()) {\n+    if (finalizedChildToParentMap.isEmpty()) {\n+      // Nothing to do\n       return;\n     }\n \n-    switch (stateStorageMode) {\n-      case ARCHIVE:\n-        // Get previously finalized block to build on top of\n-        final Bytes32 baseBlockRoot = hotDao.getFinalizedCheckpoint().orElseThrow().getRoot();\n-        final SignedBeaconBlock baseBlock =\n-            finalizedDao.getFinalizedBlock(baseBlockRoot).orElseThrow();\n-        final BeaconState baseState = hotDao.getLatestFinalizedState().orElseThrow();\n-\n-        final BlockTree blockTree =\n-            BlockTree.builder().rootBlock(baseBlock).blocks(finalizedBlocks.values()).build();\n-        final StateGenerator stateGenerator =\n-            StateGenerator.create(blockTree, baseState, finalizedStates);\n-        stateGenerator.regenerateAllStates(updater::addFinalizedState);\n-        break;\n-      case PRUNE:\n-        // Don't persist finalized state\n-        break;\n-      default:\n-        throw new UnsupportedOperationException(\"Unhandled storage mode: \" + stateStorageMode);\n+    try (final FinalizedUpdater updater = finalizedDao.finalizedUpdater()) {\n+      final BlockProvider blockProvider =\n+          BlockProvider.withKnownBlocks(\n+              roots -> SafeFuture.completedFuture(getHotBlocks(roots)), finalizedBlocks);\n+\n+      switch (stateStorageMode) {\n+        case ARCHIVE:\n+          // Get previously finalized block to build on top of\n+          final SignedBlockAndState baseBlock = getFinalizedBlockAndState();\n+\n+          final HashTree blockTree =\n+              HashTree.builder()\n+                  .rootHash(baseBlock.getRoot())\n+                  .childAndParentRoots(finalizedChildToParentMap)\n+                  .build();\n+\n+          final StateGenerator stateGenerator =\n+              StateGenerator.create(blockTree, baseBlock, blockProvider, finalizedStates);\n+          // TODO - don't join, create synchronous API for synchronous blockProvider\n+          stateGenerator\n+              .regenerateAllStates(\n+                  (block, state) -> {\n+                    updater.addFinalizedBlock(block);\n+                    updater.addFinalizedState(block.getRoot(), state);\n+                  })\n+              .join();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "843b5148550f1e8da1b35b9f80d6996750e73f26"}, "originalPosition": 235}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTkyOTAzNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              Stream<SignedBeaconBlock> streamHotBlocks();\n          \n          \n            \n              @MustBeClosed\n          \n          \n            \n              Stream<SignedBeaconBlock> streamHotBlocks();", "url": "https://github.com/ConsenSys/teku/pull/2211#discussion_r445929036", "createdAt": "2020-06-26T01:58:35Z", "author": {"login": "ajsutton"}, "path": "storage/src/main/java/tech/pegasys/teku/storage/server/rocksdb/dataaccess/RocksDbHotDao.java", "diffHunk": "@@ -43,6 +44,8 @@\n \n   Map<Bytes32, SignedBeaconBlock> getHotBlocks();\n \n+  Stream<SignedBeaconBlock> streamHotBlocks();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "843b5148550f1e8da1b35b9f80d6996750e73f26"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTkzMDAyNw==", "bodyText": "Doesn't this mean we wind up holding the finalised block and state from startup in memory permanently?", "url": "https://github.com/ConsenSys/teku/pull/2211#discussion_r445930027", "createdAt": "2020-06-26T02:02:48Z", "author": {"login": "ajsutton"}, "path": "storage/src/main/java/tech/pegasys/teku/storage/store/Store.java", "diffHunk": "@@ -104,45 +110,68 @@\n     stateRequestCachedCounter = stateRequestCounter.labels(\"cached\");\n     stateRequestRegenerateCounter = stateRequestCounter.labels(\"regenerate\");\n     stateRequestMissCounter = stateRequestCounter.labels(\"miss\");\n+\n     this.time = time;\n     this.genesis_time = genesis_time;\n     this.justified_checkpoint = justified_checkpoint;\n     this.finalized_checkpoint = finalized_checkpoint;\n     this.best_justified_checkpoint = best_justified_checkpoint;\n-    this.blocks = new ConcurrentHashMap<>(blocks);\n+    this.blocks =\n+        ConcurrentLimitedMap.create(\n+            pruningOptions.getBlockCacheSize(), LimitStrategy.DROP_LEAST_RECENTLY_ACCESSED);\n     this.block_states =\n-        ConcurrentLimitedMap.create(stateCacheSize, LimitStrategy.DROP_LEAST_RECENTLY_ACCESSED);\n-    this.checkpoint_states = new ConcurrentHashMap<>(checkpoint_states);\n+        LimitedMap.create(\n+            pruningOptions.getStateCacheSize(), LimitStrategy.DROP_LEAST_RECENTLY_ACCESSED);\n+    this.checkpoint_states = new HashMap<>(checkpoint_states);\n+\n+    this.blockProvider =\n+        BlockProvider.combined(\n+            fromMap(Map.of(finalizedBlockAndState.getRoot(), finalizedBlockAndState.getBlock())),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "843b5148550f1e8da1b35b9f80d6996750e73f26"}, "originalPosition": 118}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7f956c40601b69994b48e9bfd2e89001aa2e9cfa", "author": {"user": {"login": "mbaxter", "name": null}}, "url": "https://github.com/ConsenSys/teku/commit/7f956c40601b69994b48e9bfd2e89001aa2e9cfa", "committedDate": "2020-06-26T15:34:07Z", "message": "Merge branch 'master' into issue-2037/limit-hot-blocks-kept-in-memory"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9ff9dae65a9f796f75d23f153a593a330fc814bf", "author": {"user": {"login": "mbaxter", "name": null}}, "url": "https://github.com/ConsenSys/teku/commit/9ff9dae65a9f796f75d23f153a593a330fc814bf", "committedDate": "2020-06-26T15:55:28Z", "message": "Address review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "25c2426dc5bd6608b76eca5cbe267f4297f6f9ef", "author": {"user": {"login": "mbaxter", "name": null}}, "url": "https://github.com/ConsenSys/teku/commit/25c2426dc5bd6608b76eca5cbe267f4297f6f9ef", "committedDate": "2020-06-26T16:02:39Z", "message": "Fix stream management"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ec0f41e7012ef3d55301f774a33041707c75f183", "author": {"user": {"login": "mbaxter", "name": null}}, "url": "https://github.com/ConsenSys/teku/commit/ec0f41e7012ef3d55301f774a33041707c75f183", "committedDate": "2020-06-26T16:07:11Z", "message": "Add `MustBeClosed` annotations to implementing methods"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3976, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}