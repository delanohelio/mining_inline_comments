{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYyNzAxOTQ1", "number": 1089, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQyMjoxNjo0NFrODYAYzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQyMToxOTo1NFrODYpTEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NDk4NzY1OnYy", "diffSide": "RIGHT", "path": "ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/util/BeaconStateUtil.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQyMjoxNjo0NFrOFdnnaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQyMDo1Mzo1MFrOFenOfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYwMjA4OQ==", "bodyText": "Could we have a test that checks this is set to true please? It's the kind of thing that could easily be changed during development and accidentally committed which would be bad.", "url": "https://github.com/ConsenSys/teku/pull/1089#discussion_r366602089", "createdAt": "2020-01-14T22:16:44Z", "author": {"login": "ajsutton"}, "path": "ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/util/BeaconStateUtil.java", "diffHunk": "@@ -76,6 +76,8 @@\n \n public class BeaconStateUtil {\n \n+  public static boolean BLS_VERIFY_DEPOSIT = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e217cb55d07dcc7cfa89a7b2ccc509ea236f2da"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc3Mjc1Nw==", "bodyText": "Added this test b7288de\nDid you mean something like this?", "url": "https://github.com/ConsenSys/teku/pull/1089#discussion_r366772757", "createdAt": "2020-01-15T09:33:00Z", "author": {"login": "Nashatyrev"}, "path": "ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/util/BeaconStateUtil.java", "diffHunk": "@@ -76,6 +76,8 @@\n \n public class BeaconStateUtil {\n \n+  public static boolean BLS_VERIFY_DEPOSIT = true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYwMjA4OQ=="}, "originalCommit": {"oid": "8e217cb55d07dcc7cfa89a7b2ccc509ea236f2da"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA4NDAwMg==", "bodyText": "That test is probably good to have too, but I was thinking of the really straight forward:\n@Test\nvoid ensureVerifyDepositDefaultsToFalse() {\n  assertThat(BeaconStateUtil.BLS_VERIFY_DEPOSIT).isTrue();\n}\n\nPurely to ensure something fails if someone changes that to false for testing or something and accidentally commits it.", "url": "https://github.com/ConsenSys/teku/pull/1089#discussion_r367084002", "createdAt": "2020-01-15T20:12:48Z", "author": {"login": "ajsutton"}, "path": "ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/util/BeaconStateUtil.java", "diffHunk": "@@ -76,6 +76,8 @@\n \n public class BeaconStateUtil {\n \n+  public static boolean BLS_VERIFY_DEPOSIT = true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYwMjA4OQ=="}, "originalCommit": {"oid": "8e217cb55d07dcc7cfa89a7b2ccc509ea236f2da"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzI4OTc0NA==", "bodyText": "Yep, I see what you mean. My test covers this case.\nAdded your variant as well", "url": "https://github.com/ConsenSys/teku/pull/1089#discussion_r367289744", "createdAt": "2020-01-16T08:38:13Z", "author": {"login": "Nashatyrev"}, "path": "ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/util/BeaconStateUtil.java", "diffHunk": "@@ -76,6 +76,8 @@\n \n public class BeaconStateUtil {\n \n+  public static boolean BLS_VERIFY_DEPOSIT = true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYwMjA4OQ=="}, "originalCommit": {"oid": "8e217cb55d07dcc7cfa89a7b2ccc509ea236f2da"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY0NDI4NA==", "bodyText": "Ah yes it would too, sorry.  I know I'm very paranoid about \"disable validation\" flags like these so glad to have the very explicit boolean is true test as well.", "url": "https://github.com/ConsenSys/teku/pull/1089#discussion_r367644284", "createdAt": "2020-01-16T20:53:50Z", "author": {"login": "ajsutton"}, "path": "ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/util/BeaconStateUtil.java", "diffHunk": "@@ -76,6 +76,8 @@\n \n public class BeaconStateUtil {\n \n+  public static boolean BLS_VERIFY_DEPOSIT = true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYwMjA4OQ=="}, "originalCommit": {"oid": "8e217cb55d07dcc7cfa89a7b2ccc509ea236f2da"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NTA1NTIzOnYy", "diffSide": "RIGHT", "path": "ethereum/statetransition/src/main/java/tech/pegasys/artemis/statetransition/AttestationAggregator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQyMjo0NTozNlrOFdoRhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwOTozNDowOVrOFdyEOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYxMjg2OQ==", "bodyText": "What's the context for needing this method? If it's only needed for benchmarks should it just live in the benchmark code rather than the production code?  Or is there something else coming that will use it?", "url": "https://github.com/ConsenSys/teku/pull/1089#discussion_r366612869", "createdAt": "2020-01-14T22:45:36Z", "author": {"login": "ajsutton"}, "path": "ethereum/statetransition/src/main/java/tech/pegasys/artemis/statetransition/AttestationAggregator.java", "diffHunk": "@@ -117,6 +121,49 @@ private synchronized void aggregateAttestations(\n         BLSAggregate.bls_aggregate_signatures(signaturesToAggregate));\n   }\n \n+  /**\n+   * Groups passed attestations by their {@link\n+   * tech.pegasys.artemis.datastructures.operations.AttestationData} and aggregates attestations in\n+   * every group to a single {@link Attestation}\n+   *\n+   * @return a list of aggregated {@link Attestation}s with distinct {@link\n+   *     tech.pegasys.artemis.datastructures.operations.AttestationData}\n+   */\n+  public static List<Attestation> groupAndAggregateAttestations(List<Attestation> srcAttestations) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e217cb55d07dcc7cfa89a7b2ccc509ea236f2da"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc3MzMwNw==", "bodyText": "Yep these 2 methods are just for benchmarking. Just thought they can be potentially useful.\nMoved them to bench code", "url": "https://github.com/ConsenSys/teku/pull/1089#discussion_r366773307", "createdAt": "2020-01-15T09:34:09Z", "author": {"login": "Nashatyrev"}, "path": "ethereum/statetransition/src/main/java/tech/pegasys/artemis/statetransition/AttestationAggregator.java", "diffHunk": "@@ -117,6 +121,49 @@ private synchronized void aggregateAttestations(\n         BLSAggregate.bls_aggregate_signatures(signaturesToAggregate));\n   }\n \n+  /**\n+   * Groups passed attestations by their {@link\n+   * tech.pegasys.artemis.datastructures.operations.AttestationData} and aggregates attestations in\n+   * every group to a single {@link Attestation}\n+   *\n+   * @return a list of aggregated {@link Attestation}s with distinct {@link\n+   *     tech.pegasys.artemis.datastructures.operations.AttestationData}\n+   */\n+  public static List<Attestation> groupAndAggregateAttestations(List<Attestation> srcAttestations) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYxMjg2OQ=="}, "originalCommit": {"oid": "8e217cb55d07dcc7cfa89a7b2ccc509ea236f2da"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NTA2NDA3OnYy", "diffSide": "RIGHT", "path": "ethereum/statetransition/src/main/java/tech/pegasys/artemis/statetransition/AttestationAggregator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNFQyMjo0OTozNFrOFdoW9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwOTozNDo0MVrOFdyFSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYxNDI2MQ==", "bodyText": "We've typically used Guava's Preconditions class to do these assertions rather than the assert keyword. As a result we aren't explicitly controlling whether assert is actually enforced or not in our startup scripts and test config.  Might be worth a discussion if the preconditions show up as a performance bottleneck - the second check here is potentially quite expensive for example.\nI'd be tempted to make the first one a Preconditions.checkArgument and probably just remove the second.  If this method could be made private we'd be confident that groupAndAggregateAttestations is calling it with the right arguments.", "url": "https://github.com/ConsenSys/teku/pull/1089#discussion_r366614261", "createdAt": "2020-01-14T22:49:34Z", "author": {"login": "ajsutton"}, "path": "ethereum/statetransition/src/main/java/tech/pegasys/artemis/statetransition/AttestationAggregator.java", "diffHunk": "@@ -117,6 +121,49 @@ private synchronized void aggregateAttestations(\n         BLSAggregate.bls_aggregate_signatures(signaturesToAggregate));\n   }\n \n+  /**\n+   * Groups passed attestations by their {@link\n+   * tech.pegasys.artemis.datastructures.operations.AttestationData} and aggregates attestations in\n+   * every group to a single {@link Attestation}\n+   *\n+   * @return a list of aggregated {@link Attestation}s with distinct {@link\n+   *     tech.pegasys.artemis.datastructures.operations.AttestationData}\n+   */\n+  public static List<Attestation> groupAndAggregateAttestations(List<Attestation> srcAttestations) {\n+    Collection<List<Attestation>> groupedAtt =\n+        srcAttestations.stream().collect(Collectors.groupingBy(Attestation::getData)).values();\n+    return groupedAtt.stream()\n+        .map(AttestationAggregator::aggregateAttestations)\n+        .collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Aggregates passed attestations\n+   *\n+   * @param srcAttestations attestations which should have the same {@link Attestation#getData()}\n+   */\n+  public static Attestation aggregateAttestations(List<Attestation> srcAttestations) {\n+    assert !srcAttestations.isEmpty();\n+    assert srcAttestations.stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d9e2ab2a53ae9f60a988027d999cc22f6e9f9d3"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc3MzU3OA==", "bodyText": "Done", "url": "https://github.com/ConsenSys/teku/pull/1089#discussion_r366773578", "createdAt": "2020-01-15T09:34:41Z", "author": {"login": "Nashatyrev"}, "path": "ethereum/statetransition/src/main/java/tech/pegasys/artemis/statetransition/AttestationAggregator.java", "diffHunk": "@@ -117,6 +121,49 @@ private synchronized void aggregateAttestations(\n         BLSAggregate.bls_aggregate_signatures(signaturesToAggregate));\n   }\n \n+  /**\n+   * Groups passed attestations by their {@link\n+   * tech.pegasys.artemis.datastructures.operations.AttestationData} and aggregates attestations in\n+   * every group to a single {@link Attestation}\n+   *\n+   * @return a list of aggregated {@link Attestation}s with distinct {@link\n+   *     tech.pegasys.artemis.datastructures.operations.AttestationData}\n+   */\n+  public static List<Attestation> groupAndAggregateAttestations(List<Attestation> srcAttestations) {\n+    Collection<List<Attestation>> groupedAtt =\n+        srcAttestations.stream().collect(Collectors.groupingBy(Attestation::getData)).values();\n+    return groupedAtt.stream()\n+        .map(AttestationAggregator::aggregateAttestations)\n+        .collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Aggregates passed attestations\n+   *\n+   * @param srcAttestations attestations which should have the same {@link Attestation#getData()}\n+   */\n+  public static Attestation aggregateAttestations(List<Attestation> srcAttestations) {\n+    assert !srcAttestations.isEmpty();\n+    assert srcAttestations.stream()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYxNDI2MQ=="}, "originalCommit": {"oid": "6d9e2ab2a53ae9f60a988027d999cc22f6e9f9d3"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NTI2OTQ5OnYy", "diffSide": "RIGHT", "path": "ethereum/statetransition/src/test-support/java/tech/pegasys/artemis/statetransition/BeaconChainUtil.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwMDo0Mjo0OVrOFdqVYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwOTozNDo1N1rOFdyFvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjY0NjYyNw==", "bodyText": "Maybe just:\nOptional<SSZList<Attestation> sszList = attestations.isEmpty() ? Optional.empty() : Optional.of(new SSZList<>(...))\n\nto save mixing null and Optional.", "url": "https://github.com/ConsenSys/teku/pull/1089#discussion_r366646627", "createdAt": "2020-01-15T00:42:49Z", "author": {"login": "ajsutton"}, "path": "ethereum/statetransition/src/test-support/java/tech/pegasys/artemis/statetransition/BeaconChainUtil.java", "diffHunk": "@@ -94,6 +112,16 @@ public BlockProcessingRecord createAndImportBlockAtSlot(final long slot) throws\n     return createAndImportBlockAtSlot(UnsignedLong.valueOf(slot));\n   }\n \n+  public BlockProcessingRecord createAndImportBlockAtSlot(\n+      final UnsignedLong slot, List<Attestation> attestations) throws Exception {\n+    SSZList<Attestation> sszList =\n+        attestations.isEmpty()\n+            ? null\n+            : new SSZList<>(attestations, Constants.MAX_ATTESTATIONS, Attestation.class);\n+\n+    return createAndImportBlockAtSlot(slot, Optional.ofNullable(sszList));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d9e2ab2a53ae9f60a988027d999cc22f6e9f9d3"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc3MzY5Mw==", "bodyText": "Done", "url": "https://github.com/ConsenSys/teku/pull/1089#discussion_r366773693", "createdAt": "2020-01-15T09:34:57Z", "author": {"login": "Nashatyrev"}, "path": "ethereum/statetransition/src/test-support/java/tech/pegasys/artemis/statetransition/BeaconChainUtil.java", "diffHunk": "@@ -94,6 +112,16 @@ public BlockProcessingRecord createAndImportBlockAtSlot(final long slot) throws\n     return createAndImportBlockAtSlot(UnsignedLong.valueOf(slot));\n   }\n \n+  public BlockProcessingRecord createAndImportBlockAtSlot(\n+      final UnsignedLong slot, List<Attestation> attestations) throws Exception {\n+    SSZList<Attestation> sszList =\n+        attestations.isEmpty()\n+            ? null\n+            : new SSZList<>(attestations, Constants.MAX_ATTESTATIONS, Attestation.class);\n+\n+    return createAndImportBlockAtSlot(slot, Optional.ofNullable(sszList));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjY0NjYyNw=="}, "originalCommit": {"oid": "6d9e2ab2a53ae9f60a988027d999cc22f6e9f9d3"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI2NTQ0ODc0OnYy", "diffSide": "RIGHT", "path": "ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/util/ValidatorsUtil.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwMjo0ODoxNlrOFdsAxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQwOTowMjozNVrOFeSObA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjY3NDExNw==", "bodyText": "Does flatMap sustain the order of elements here? I believe we had an issue with a similar change in the past due to not preserving the order of validator indices.", "url": "https://github.com/ConsenSys/teku/pull/1089#discussion_r366674117", "createdAt": "2020-01-15T02:48:16Z", "author": {"login": "cemozerr"}, "path": "ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/util/ValidatorsUtil.java", "diffHunk": "@@ -72,18 +71,16 @@ public static boolean is_active_validator(Validator validator, UnsignedLong epoc\n    *     <a>https://github.com/ethereum/eth2.0-specs/blob/v0.8.0/specs/core/0_beacon-chain.md#get_active_validator_indices</a>\n    */\n   public static List<Integer> get_active_validator_indices(BeaconState state, UnsignedLong epoch) {\n-    List<Integer> active_validator_indices = Collections.synchronizedList(new ArrayList<>());\n     List<Validator> validators = state.getValidators();\n-    IntStream.range(0, validators.size())\n+    return IntStream.range(0, validators.size())\n         .parallel()\n-        .forEachOrdered(\n-            index -> {\n-              if (is_active_validator(validators.get(index), epoch)) {\n-                active_validator_indices.add(index);\n-              }\n-            });\n-\n-    return active_validator_indices;\n+        .flatMap(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6d9e2ab2a53ae9f60a988027d999cc22f6e9f9d3"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc1MDQ2NA==", "bodyText": "@cemozerr Good question. I didn't find any mentions that flatMap makes a stream unordered. My minitest also confirms this. However this is not relevant any more, since I change this method in the next commit", "url": "https://github.com/ConsenSys/teku/pull/1089#discussion_r366750464", "createdAt": "2020-01-15T08:42:43Z", "author": {"login": "Nashatyrev"}, "path": "ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/util/ValidatorsUtil.java", "diffHunk": "@@ -72,18 +71,16 @@ public static boolean is_active_validator(Validator validator, UnsignedLong epoc\n    *     <a>https://github.com/ethereum/eth2.0-specs/blob/v0.8.0/specs/core/0_beacon-chain.md#get_active_validator_indices</a>\n    */\n   public static List<Integer> get_active_validator_indices(BeaconState state, UnsignedLong epoch) {\n-    List<Integer> active_validator_indices = Collections.synchronizedList(new ArrayList<>());\n     List<Validator> validators = state.getValidators();\n-    IntStream.range(0, validators.size())\n+    return IntStream.range(0, validators.size())\n         .parallel()\n-        .forEachOrdered(\n-            index -> {\n-              if (is_active_validator(validators.get(index), epoch)) {\n-                active_validator_indices.add(index);\n-              }\n-            });\n-\n-    return active_validator_indices;\n+        .flatMap(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjY3NDExNw=="}, "originalCommit": {"oid": "6d9e2ab2a53ae9f60a988027d999cc22f6e9f9d3"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzA4NTAxNg==", "bodyText": "flatMap preserves ordering but making a stream parallel may not (you can have parallel, ordered streams but that restricts how much parallelisation can happen). I can't recall how or if you can choose between ordered or unordered parallel streams so tend to just assume parallel streams won't preserve order unless I go check more carefully.", "url": "https://github.com/ConsenSys/teku/pull/1089#discussion_r367085016", "createdAt": "2020-01-15T20:15:03Z", "author": {"login": "ajsutton"}, "path": "ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/util/ValidatorsUtil.java", "diffHunk": "@@ -72,18 +71,16 @@ public static boolean is_active_validator(Validator validator, UnsignedLong epoc\n    *     <a>https://github.com/ethereum/eth2.0-specs/blob/v0.8.0/specs/core/0_beacon-chain.md#get_active_validator_indices</a>\n    */\n   public static List<Integer> get_active_validator_indices(BeaconState state, UnsignedLong epoch) {\n-    List<Integer> active_validator_indices = Collections.synchronizedList(new ArrayList<>());\n     List<Validator> validators = state.getValidators();\n-    IntStream.range(0, validators.size())\n+    return IntStream.range(0, validators.size())\n         .parallel()\n-        .forEachOrdered(\n-            index -> {\n-              if (is_active_validator(validators.get(index), epoch)) {\n-                active_validator_indices.add(index);\n-              }\n-            });\n-\n-    return active_validator_indices;\n+        .flatMap(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjY3NDExNw=="}, "originalCommit": {"oid": "6d9e2ab2a53ae9f60a988027d999cc22f6e9f9d3"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzMwMDIwNA==", "bodyText": "From my understanding of the spec if the original stream is ordered and all pipeline operators preserve ordering (unlike e.g. .unordered() operator) then collector would make ordered list. parallel() preserves ordering\nIf e.g. is_active_validator is heavy operation (which is actually not the case), then parallelization would yield good gain here.\nE.g. the following test:\n    IntStream.range(0, 10)\n        .parallel()\n        .flatMap(i -> {\n          LOG.info(\"Calculating \" + i);\n          Thread.sleep(1000);\n          return i % 2 == 0 ? IntStream.of(i) : IntStream.empty();\n        })\n        .forEachOrdered(i -> LOG.info(i));\nWould print:\n11:59:25.985 | ForkJoinPool.commonPool-worker-7  | Calculating 1\n11:59:25.985 | ForkJoinPool.commonPool-worker-15 | Calculating 7\n11:59:25.985 | ForkJoinPool.commonPool-worker-9  | Calculating 5\n11:59:25.985 | ForkJoinPool.commonPool-worker-5  | Calculating 2\n11:59:25.985 | ForkJoinPool.commonPool-worker-3  | Calculating 8\n11:59:25.985 | main                              | Calculating 6\n11:59:25.985 | ForkJoinPool.commonPool-worker-11 | Calculating 0\n11:59:25.985 | ForkJoinPool.commonPool-worker-13 | Calculating 9\n11:59:26.994 | ForkJoinPool.commonPool-worker-7  | Calculating 3\n11:59:26.994 | ForkJoinPool.commonPool-worker-13 | Calculating 4\n11:59:26.995 | ForkJoinPool.commonPool-worker-11 | 0\n11:59:26.996 | ForkJoinPool.commonPool-worker-11 | 2\n11:59:27.995 | ForkJoinPool.commonPool-worker-13 | 4\n11:59:27.995 | ForkJoinPool.commonPool-worker-13 | 6\n11:59:27.995 | ForkJoinPool.commonPool-worker-13 | 8", "url": "https://github.com/ConsenSys/teku/pull/1089#discussion_r367300204", "createdAt": "2020-01-16T09:02:35Z", "author": {"login": "Nashatyrev"}, "path": "ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/util/ValidatorsUtil.java", "diffHunk": "@@ -72,18 +71,16 @@ public static boolean is_active_validator(Validator validator, UnsignedLong epoc\n    *     <a>https://github.com/ethereum/eth2.0-specs/blob/v0.8.0/specs/core/0_beacon-chain.md#get_active_validator_indices</a>\n    */\n   public static List<Integer> get_active_validator_indices(BeaconState state, UnsignedLong epoch) {\n-    List<Integer> active_validator_indices = Collections.synchronizedList(new ArrayList<>());\n     List<Validator> validators = state.getValidators();\n-    IntStream.range(0, validators.size())\n+    return IntStream.range(0, validators.size())\n         .parallel()\n-        .forEachOrdered(\n-            index -> {\n-              if (is_active_validator(validators.get(index), epoch)) {\n-                active_validator_indices.add(index);\n-              }\n-            });\n-\n-    return active_validator_indices;\n+        .flatMap(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjY3NDExNw=="}, "originalCommit": {"oid": "6d9e2ab2a53ae9f60a988027d999cc22f6e9f9d3"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI3MTY5MDQzOnYy", "diffSide": "RIGHT", "path": "ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/util/BeaconStateUtil.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQyMToxOTo1NVrOFen6dA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNlQyMTo0ODozN1rOFeoqrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY1NTU0MA==", "bodyText": "This took me a bit to get my head around so maybe worth adding a comment.  I believe the logic is:\n\nif the validator is already present, just use the cached index\nif it's not present then we're going to add it to the end of the validator list so it's index will be the current size of that list and we have no existingIndex.\n\nThat works on the basis that the pubKeyToIndexMap contains a key to index mapping for every validator, which holds because this method is private and only called when we're generating the genesis state from a list of ETH1 deposits.", "url": "https://github.com/ConsenSys/teku/pull/1089#discussion_r367655540", "createdAt": "2020-01-16T21:19:55Z", "author": {"login": "ajsutton"}, "path": "ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/util/BeaconStateUtil.java", "diffHunk": "@@ -179,9 +189,20 @@ public static void process_deposit(BeaconState state, Deposit deposit) {\n \n     BLSPublicKey pubkey = deposit.getData().getPubkey();\n     UnsignedLong amount = deposit.getData().getAmount();\n-    List<BLSPublicKey> validator_pubkeys =\n-        state.getValidators().stream().map(Validator::getPubkey).collect(Collectors.toList());\n-    if (!validator_pubkeys.contains(pubkey)) {\n+\n+    SSZList<Validator> validators = state.getValidators();\n+    OptionalInt existingIndex;\n+    if (pubKeyToIndexMap != null) {\n+      Integer cachedIndex = pubKeyToIndexMap.putIfAbsent(pubkey, state.getValidators().size());\n+      existingIndex = cachedIndex == null ? OptionalInt.empty() : OptionalInt.of(cachedIndex);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca3e8b8cfeaad9d685b969d5153ee8e9eb29f2e9"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY2Nzg4NA==", "bodyText": "Yep, exactly.\nThis could be subject to migrate to a global PubKey -> ValidatorIdex cache at later optimization stages", "url": "https://github.com/ConsenSys/teku/pull/1089#discussion_r367667884", "createdAt": "2020-01-16T21:48:37Z", "author": {"login": "Nashatyrev"}, "path": "ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/util/BeaconStateUtil.java", "diffHunk": "@@ -179,9 +189,20 @@ public static void process_deposit(BeaconState state, Deposit deposit) {\n \n     BLSPublicKey pubkey = deposit.getData().getPubkey();\n     UnsignedLong amount = deposit.getData().getAmount();\n-    List<BLSPublicKey> validator_pubkeys =\n-        state.getValidators().stream().map(Validator::getPubkey).collect(Collectors.toList());\n-    if (!validator_pubkeys.contains(pubkey)) {\n+\n+    SSZList<Validator> validators = state.getValidators();\n+    OptionalInt existingIndex;\n+    if (pubKeyToIndexMap != null) {\n+      Integer cachedIndex = pubKeyToIndexMap.putIfAbsent(pubkey, state.getValidators().size());\n+      existingIndex = cachedIndex == null ? OptionalInt.empty() : OptionalInt.of(cachedIndex);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzY1NTU0MA=="}, "originalCommit": {"oid": "ca3e8b8cfeaad9d685b969d5153ee8e9eb29f2e9"}, "originalPosition": 59}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2759, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}