{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA1MjkyNjUx", "number": 1615, "title": "Implement BlockValidator", "bodyText": "PR Description\nImplements Block Validator which gets used to check all the conditions necessary to gossip, drop, or save blocks for the future.", "createdAt": "2020-04-17T19:03:03Z", "url": "https://github.com/ConsenSys/teku/pull/1615", "merged": true, "mergeCommit": {"oid": "e25cbd07f367fefcb0cbe51b54def9d75c40fda1"}, "closed": true, "closedAt": "2020-04-20T17:46:26Z", "author": {"login": "cemozerr"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcYmFn8AH2gAyNDA1MjkyNjUxOjRlMGZlYTc5ZTk4MjEzZTg5ZWJhMzQ0ZDgwMzY3NGFkNTMzNzcwNTE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcZinnfAH2gAyNDA1MjkyNjUxOjgxMDY0MWUwOGUxNWZmYjg3ZWJmY2UxMDRlNzdiY2JmMGM0N2RiMmI=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "4e0fea79e98213e89eba344d803674ad53377051", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/4e0fea79e98213e89eba344d803674ad53377051", "committedDate": "2020-04-17T19:02:48Z", "message": "Implement BlockValidator"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1NzQyNzQw", "url": "https://github.com/ConsenSys/teku/pull/1615#pullrequestreview-395742740", "createdAt": "2020-04-17T20:11:04Z", "commit": {"oid": "4e0fea79e98213e89eba344d803674ad53377051"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMDoxMTowNVrOGHbpYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMToxMzo1OFrOGHdSYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0NjE3OA==", "bodyText": "We should use a ConcurrentLimitedSet here, so this collection doesn't grow forever:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private final Set<UnsignedLong> receivedValidSignatureBlockSlots = new HashSet<>();\n          \n          \n            \n              private final Set<UnsignedLong> receivedValidSignatureBlockSlots = ConcurrentLimitedSet.create(maxSize, DROP_LEAST_RECENTLY_ACCESSED);", "url": "https://github.com/ConsenSys/teku/pull/1615#discussion_r410446178", "createdAt": "2020-04-17T20:11:05Z", "author": {"login": "mbaxter"}, "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/gossip/topics/validation/BlockValidator.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package tech.pegasys.artemis.networking.eth2.gossip.topics.validation;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.artemis.bls.BLS;\n+import tech.pegasys.artemis.bls.BLSSignature;\n+import tech.pegasys.artemis.core.StateTransition;\n+import tech.pegasys.artemis.core.exceptions.EpochProcessingException;\n+import tech.pegasys.artemis.core.exceptions.SlotProcessingException;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.datastructures.forkchoice.ReadOnlyStore;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.state.Validator;\n+import tech.pegasys.artemis.storage.client.RecentChainData;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static com.google.common.primitives.UnsignedLong.valueOf;\n+import static java.lang.Math.toIntExact;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.compute_signing_root;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_beacon_proposer_index;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_domain;\n+import static tech.pegasys.artemis.statetransition.forkchoice.ForkChoiceUtil.getCurrentSlot;\n+import static tech.pegasys.artemis.util.config.Constants.DOMAIN_BEACON_PROPOSER;\n+import static tech.pegasys.artemis.util.config.Constants.MAXIMUM_GOSSIP_CLOCK_DISPARITY;\n+\n+public class BlockValidator {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final RecentChainData recentChainData;\n+  private final StateTransition stateTransition;\n+  private final Set<UnsignedLong> receivedValidSignatureBlockSlots = new HashSet<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e0fea79e98213e89eba344d803674ad53377051"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0OTkyMg==", "bodyText": "(nit) You could just use an Optional here:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                final BeaconState preState = recentChainData.getStore().getBlockState(block.getMessage().getParent_root());\n          \n          \n            \n                final Optional<BeaconState> preState = recentChainData.getBlockState(block.getMessage().getParent_root());\n          \n          \n            \n                if (preState.isEmpty() || !blockIsNotFromFutureSlot(block)) {", "url": "https://github.com/ConsenSys/teku/pull/1615#discussion_r410449922", "createdAt": "2020-04-17T20:19:25Z", "author": {"login": "mbaxter"}, "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/gossip/topics/validation/BlockValidator.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package tech.pegasys.artemis.networking.eth2.gossip.topics.validation;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.artemis.bls.BLS;\n+import tech.pegasys.artemis.bls.BLSSignature;\n+import tech.pegasys.artemis.core.StateTransition;\n+import tech.pegasys.artemis.core.exceptions.EpochProcessingException;\n+import tech.pegasys.artemis.core.exceptions.SlotProcessingException;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.datastructures.forkchoice.ReadOnlyStore;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.state.Validator;\n+import tech.pegasys.artemis.storage.client.RecentChainData;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static com.google.common.primitives.UnsignedLong.valueOf;\n+import static java.lang.Math.toIntExact;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.compute_signing_root;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_beacon_proposer_index;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_domain;\n+import static tech.pegasys.artemis.statetransition.forkchoice.ForkChoiceUtil.getCurrentSlot;\n+import static tech.pegasys.artemis.util.config.Constants.DOMAIN_BEACON_PROPOSER;\n+import static tech.pegasys.artemis.util.config.Constants.MAXIMUM_GOSSIP_CLOCK_DISPARITY;\n+\n+public class BlockValidator {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final RecentChainData recentChainData;\n+  private final StateTransition stateTransition;\n+  private final Set<UnsignedLong> receivedValidSignatureBlockSlots = new HashSet<>();\n+\n+  public BlockValidator(RecentChainData recentChainData,\n+                        StateTransition stateTransition) {\n+    this.recentChainData = recentChainData;\n+    this.stateTransition = stateTransition;\n+  }\n+\n+  public BlockValidationResult validate(SignedBeaconBlock block) {\n+\n+    if (!blockSlotIsGreaterThanLatestFinalizedSlot(block) || !blockIsFirstBlockWithValidSignatureForSlot(block)) {\n+      LOG.trace(\"BlockValidator: Block is either too old or is not the first block with valid signature for \" +\n+              \"its slot. It will be dropped\");\n+      return BlockValidationResult.INVALID;\n+    }\n+\n+    final BeaconState preState = recentChainData.getStore().getBlockState(block.getMessage().getParent_root());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e0fea79e98213e89eba344d803674ad53377051"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ1MDU1NA==", "bodyText": "The double-negative is a bit confusing:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (!blockPreStateDoesExist(preState) || !blockIsNotFromFutureSlot(block)) {\n          \n          \n            \n                if (!blockPreStateDoesExist(preState) || blockIsFromFutureSlot(block)) {", "url": "https://github.com/ConsenSys/teku/pull/1615#discussion_r410450554", "createdAt": "2020-04-17T20:20:38Z", "author": {"login": "mbaxter"}, "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/gossip/topics/validation/BlockValidator.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package tech.pegasys.artemis.networking.eth2.gossip.topics.validation;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.artemis.bls.BLS;\n+import tech.pegasys.artemis.bls.BLSSignature;\n+import tech.pegasys.artemis.core.StateTransition;\n+import tech.pegasys.artemis.core.exceptions.EpochProcessingException;\n+import tech.pegasys.artemis.core.exceptions.SlotProcessingException;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.datastructures.forkchoice.ReadOnlyStore;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.state.Validator;\n+import tech.pegasys.artemis.storage.client.RecentChainData;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static com.google.common.primitives.UnsignedLong.valueOf;\n+import static java.lang.Math.toIntExact;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.compute_signing_root;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_beacon_proposer_index;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_domain;\n+import static tech.pegasys.artemis.statetransition.forkchoice.ForkChoiceUtil.getCurrentSlot;\n+import static tech.pegasys.artemis.util.config.Constants.DOMAIN_BEACON_PROPOSER;\n+import static tech.pegasys.artemis.util.config.Constants.MAXIMUM_GOSSIP_CLOCK_DISPARITY;\n+\n+public class BlockValidator {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final RecentChainData recentChainData;\n+  private final StateTransition stateTransition;\n+  private final Set<UnsignedLong> receivedValidSignatureBlockSlots = new HashSet<>();\n+\n+  public BlockValidator(RecentChainData recentChainData,\n+                        StateTransition stateTransition) {\n+    this.recentChainData = recentChainData;\n+    this.stateTransition = stateTransition;\n+  }\n+\n+  public BlockValidationResult validate(SignedBeaconBlock block) {\n+\n+    if (!blockSlotIsGreaterThanLatestFinalizedSlot(block) || !blockIsFirstBlockWithValidSignatureForSlot(block)) {\n+      LOG.trace(\"BlockValidator: Block is either too old or is not the first block with valid signature for \" +\n+              \"its slot. It will be dropped\");\n+      return BlockValidationResult.INVALID;\n+    }\n+\n+    final BeaconState preState = recentChainData.getStore().getBlockState(block.getMessage().getParent_root());\n+    if (!blockPreStateDoesExist(preState) || !blockIsNotFromFutureSlot(block)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e0fea79e98213e89eba344d803674ad53377051"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ1ODEwMw==", "bodyText": "In general, I'd probably cut back on the logging in this validator.  I think we probably just want to log a trace message if we encounter something that clearly violates the spec (invalid signature, unprocessable block, etc).", "url": "https://github.com/ConsenSys/teku/pull/1615#discussion_r410458103", "createdAt": "2020-04-17T20:38:35Z", "author": {"login": "mbaxter"}, "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/gossip/topics/validation/BlockValidator.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package tech.pegasys.artemis.networking.eth2.gossip.topics.validation;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.artemis.bls.BLS;\n+import tech.pegasys.artemis.bls.BLSSignature;\n+import tech.pegasys.artemis.core.StateTransition;\n+import tech.pegasys.artemis.core.exceptions.EpochProcessingException;\n+import tech.pegasys.artemis.core.exceptions.SlotProcessingException;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.datastructures.forkchoice.ReadOnlyStore;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.state.Validator;\n+import tech.pegasys.artemis.storage.client.RecentChainData;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static com.google.common.primitives.UnsignedLong.valueOf;\n+import static java.lang.Math.toIntExact;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.compute_signing_root;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_beacon_proposer_index;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_domain;\n+import static tech.pegasys.artemis.statetransition.forkchoice.ForkChoiceUtil.getCurrentSlot;\n+import static tech.pegasys.artemis.util.config.Constants.DOMAIN_BEACON_PROPOSER;\n+import static tech.pegasys.artemis.util.config.Constants.MAXIMUM_GOSSIP_CLOCK_DISPARITY;\n+\n+public class BlockValidator {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final RecentChainData recentChainData;\n+  private final StateTransition stateTransition;\n+  private final Set<UnsignedLong> receivedValidSignatureBlockSlots = new HashSet<>();\n+\n+  public BlockValidator(RecentChainData recentChainData,\n+                        StateTransition stateTransition) {\n+    this.recentChainData = recentChainData;\n+    this.stateTransition = stateTransition;\n+  }\n+\n+  public BlockValidationResult validate(SignedBeaconBlock block) {\n+\n+    if (!blockSlotIsGreaterThanLatestFinalizedSlot(block) || !blockIsFirstBlockWithValidSignatureForSlot(block)) {\n+      LOG.trace(\"BlockValidator: Block is either too old or is not the first block with valid signature for \" +\n+              \"its slot. It will be dropped\");\n+      return BlockValidationResult.INVALID;\n+    }\n+\n+    final BeaconState preState = recentChainData.getStore().getBlockState(block.getMessage().getParent_root());\n+    if (!blockPreStateDoesExist(preState) || !blockIsNotFromFutureSlot(block)) {\n+      LOG.trace(\"BlockValidator: Either block pre state does not exist or block is from the future. \" +\n+              \"It will be saved for future processing\");\n+      return BlockValidationResult.SAVED_FOR_FUTURE;\n+    }\n+\n+    try {\n+      BeaconState postState = stateTransition.process_slots(preState, block.getMessage().getSlot());\n+      if (blockIsProposedByTheExpectedProposer(block, postState) &&\n+              blockSignatureIsValidWithRespectToProposerIndex(block, preState, postState)) {\n+        LOG.trace(\"BlockValidator: Block has passed all gossip layer validation\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e0fea79e98213e89eba344d803674ad53377051"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ2NDIyMg==", "bodyText": "I don't think this calculation actually does anything (when MAXIMUM_GOSSIP_CLOCK_DISPARITY < 1000) ...  Should we do something like?:\nfinal long disparityInSeconds = Math.round((float) MAXIMUM_GOSSIP_CLOCK_DISPARITY / 1000.0);\nfinal UnsignedLong maxOffset = UnsignedLong.valueOf(disparityInSeconds);\nfinal UnsignedLong maxTime = store.getTime.plus(maxOffset);", "url": "https://github.com/ConsenSys/teku/pull/1615#discussion_r410464222", "createdAt": "2020-04-17T20:53:13Z", "author": {"login": "mbaxter"}, "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/gossip/topics/validation/BlockValidator.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package tech.pegasys.artemis.networking.eth2.gossip.topics.validation;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.artemis.bls.BLS;\n+import tech.pegasys.artemis.bls.BLSSignature;\n+import tech.pegasys.artemis.core.StateTransition;\n+import tech.pegasys.artemis.core.exceptions.EpochProcessingException;\n+import tech.pegasys.artemis.core.exceptions.SlotProcessingException;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.datastructures.forkchoice.ReadOnlyStore;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.state.Validator;\n+import tech.pegasys.artemis.storage.client.RecentChainData;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static com.google.common.primitives.UnsignedLong.valueOf;\n+import static java.lang.Math.toIntExact;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.compute_signing_root;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_beacon_proposer_index;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_domain;\n+import static tech.pegasys.artemis.statetransition.forkchoice.ForkChoiceUtil.getCurrentSlot;\n+import static tech.pegasys.artemis.util.config.Constants.DOMAIN_BEACON_PROPOSER;\n+import static tech.pegasys.artemis.util.config.Constants.MAXIMUM_GOSSIP_CLOCK_DISPARITY;\n+\n+public class BlockValidator {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final RecentChainData recentChainData;\n+  private final StateTransition stateTransition;\n+  private final Set<UnsignedLong> receivedValidSignatureBlockSlots = new HashSet<>();\n+\n+  public BlockValidator(RecentChainData recentChainData,\n+                        StateTransition stateTransition) {\n+    this.recentChainData = recentChainData;\n+    this.stateTransition = stateTransition;\n+  }\n+\n+  public BlockValidationResult validate(SignedBeaconBlock block) {\n+\n+    if (!blockSlotIsGreaterThanLatestFinalizedSlot(block) || !blockIsFirstBlockWithValidSignatureForSlot(block)) {\n+      LOG.trace(\"BlockValidator: Block is either too old or is not the first block with valid signature for \" +\n+              \"its slot. It will be dropped\");\n+      return BlockValidationResult.INVALID;\n+    }\n+\n+    final BeaconState preState = recentChainData.getStore().getBlockState(block.getMessage().getParent_root());\n+    if (!blockPreStateDoesExist(preState) || !blockIsNotFromFutureSlot(block)) {\n+      LOG.trace(\"BlockValidator: Either block pre state does not exist or block is from the future. \" +\n+              \"It will be saved for future processing\");\n+      return BlockValidationResult.SAVED_FOR_FUTURE;\n+    }\n+\n+    try {\n+      BeaconState postState = stateTransition.process_slots(preState, block.getMessage().getSlot());\n+      if (blockIsProposedByTheExpectedProposer(block, postState) &&\n+              blockSignatureIsValidWithRespectToProposerIndex(block, preState, postState)) {\n+        LOG.trace(\"BlockValidator: Block has passed all gossip layer validation\");\n+        return BlockValidationResult.VALID;\n+      }\n+    } catch (EpochProcessingException | SlotProcessingException e) {\n+      LOG.error(\"BlockValidator: Unable to process block state.\", e);\n+      return BlockValidationResult.INVALID;\n+    }\n+\n+    return BlockValidationResult.INVALID;\n+  }\n+\n+  private boolean blockIsNotFromFutureSlot(SignedBeaconBlock block) {\n+    ReadOnlyStore store = recentChainData.getStore();\n+    // .times() and .dividedBy() is to account for the fact that store.time is in seconds\n+    // and MAXIMUM_GOSSIP_CLOCK_DISPARITY is in ms.\n+    UnsignedLong maxTime = store.getTime()\n+            .times(valueOf(1000))\n+            .plus(MAXIMUM_GOSSIP_CLOCK_DISPARITY)\n+            .dividedBy(valueOf(1000));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e0fea79e98213e89eba344d803674ad53377051"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ2NjY5Ng==", "bodyText": "The add method will return true if we successfully add a new element.  Suggest only continuing with processing if we successfully add to the collection.", "url": "https://github.com/ConsenSys/teku/pull/1615#discussion_r410466696", "createdAt": "2020-04-17T20:58:53Z", "author": {"login": "mbaxter"}, "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/gossip/topics/validation/BlockValidator.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package tech.pegasys.artemis.networking.eth2.gossip.topics.validation;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.artemis.bls.BLS;\n+import tech.pegasys.artemis.bls.BLSSignature;\n+import tech.pegasys.artemis.core.StateTransition;\n+import tech.pegasys.artemis.core.exceptions.EpochProcessingException;\n+import tech.pegasys.artemis.core.exceptions.SlotProcessingException;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.datastructures.forkchoice.ReadOnlyStore;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.state.Validator;\n+import tech.pegasys.artemis.storage.client.RecentChainData;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static com.google.common.primitives.UnsignedLong.valueOf;\n+import static java.lang.Math.toIntExact;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.compute_signing_root;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_beacon_proposer_index;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_domain;\n+import static tech.pegasys.artemis.statetransition.forkchoice.ForkChoiceUtil.getCurrentSlot;\n+import static tech.pegasys.artemis.util.config.Constants.DOMAIN_BEACON_PROPOSER;\n+import static tech.pegasys.artemis.util.config.Constants.MAXIMUM_GOSSIP_CLOCK_DISPARITY;\n+\n+public class BlockValidator {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final RecentChainData recentChainData;\n+  private final StateTransition stateTransition;\n+  private final Set<UnsignedLong> receivedValidSignatureBlockSlots = new HashSet<>();\n+\n+  public BlockValidator(RecentChainData recentChainData,\n+                        StateTransition stateTransition) {\n+    this.recentChainData = recentChainData;\n+    this.stateTransition = stateTransition;\n+  }\n+\n+  public BlockValidationResult validate(SignedBeaconBlock block) {\n+\n+    if (!blockSlotIsGreaterThanLatestFinalizedSlot(block) || !blockIsFirstBlockWithValidSignatureForSlot(block)) {\n+      LOG.trace(\"BlockValidator: Block is either too old or is not the first block with valid signature for \" +\n+              \"its slot. It will be dropped\");\n+      return BlockValidationResult.INVALID;\n+    }\n+\n+    final BeaconState preState = recentChainData.getStore().getBlockState(block.getMessage().getParent_root());\n+    if (!blockPreStateDoesExist(preState) || !blockIsNotFromFutureSlot(block)) {\n+      LOG.trace(\"BlockValidator: Either block pre state does not exist or block is from the future. \" +\n+              \"It will be saved for future processing\");\n+      return BlockValidationResult.SAVED_FOR_FUTURE;\n+    }\n+\n+    try {\n+      BeaconState postState = stateTransition.process_slots(preState, block.getMessage().getSlot());\n+      if (blockIsProposedByTheExpectedProposer(block, postState) &&\n+              blockSignatureIsValidWithRespectToProposerIndex(block, preState, postState)) {\n+        LOG.trace(\"BlockValidator: Block has passed all gossip layer validation\");\n+        return BlockValidationResult.VALID;\n+      }\n+    } catch (EpochProcessingException | SlotProcessingException e) {\n+      LOG.error(\"BlockValidator: Unable to process block state.\", e);\n+      return BlockValidationResult.INVALID;\n+    }\n+\n+    return BlockValidationResult.INVALID;\n+  }\n+\n+  private boolean blockIsNotFromFutureSlot(SignedBeaconBlock block) {\n+    ReadOnlyStore store = recentChainData.getStore();\n+    // .times() and .dividedBy() is to account for the fact that store.time is in seconds\n+    // and MAXIMUM_GOSSIP_CLOCK_DISPARITY is in ms.\n+    UnsignedLong maxTime = store.getTime()\n+            .times(valueOf(1000))\n+            .plus(MAXIMUM_GOSSIP_CLOCK_DISPARITY)\n+            .dividedBy(valueOf(1000));\n+    UnsignedLong maxCurrSlot = getCurrentSlot(maxTime, store.getGenesisTime());\n+    return block.getSlot().compareTo(maxCurrSlot) <= 0;\n+  }\n+\n+  private boolean blockSlotIsGreaterThanLatestFinalizedSlot(SignedBeaconBlock block) {\n+    UnsignedLong finalizedSlot = recentChainData.getStore().getFinalizedCheckpoint().getEpochStartSlot();\n+    return block.getSlot().compareTo(finalizedSlot) > 0;\n+  }\n+\n+  private boolean blockPreStateDoesExist(BeaconState preState) {\n+    return preState != null;\n+  }\n+\n+  private boolean blockIsFirstBlockWithValidSignatureForSlot(SignedBeaconBlock block) {\n+    return !receivedValidSignatureBlockSlots.contains(block.getSlot());\n+  }\n+\n+  private boolean blockSignatureIsValidWithRespectToProposerIndex(SignedBeaconBlock block,\n+                                                                  BeaconState preState,\n+                                                                  BeaconState postState) {\n+      Validator proposer = postState.getValidators().get(\n+              toIntExact(block.getMessage().getProposer_index().longValue())\n+      );\n+\n+      final Bytes domain = get_domain(preState, DOMAIN_BEACON_PROPOSER);\n+      final Bytes signing_root = compute_signing_root(block.getMessage(), domain);\n+      final BLSSignature signature = block.getSignature();\n+      boolean signatureValid = BLS.verify(proposer.getPubkey(), signing_root, signature);\n+\n+      if (signatureValid) {\n+        receivedValidSignatureBlockSlots.add(block.getSlot());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e0fea79e98213e89eba344d803674ad53377051"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ2NzkyMw==", "bodyText": "I think we need to put slot/proposerIndex pairs in this collection ... What if there are multiple forks where we have different valid proposers for the same slot on different forks?", "url": "https://github.com/ConsenSys/teku/pull/1615#discussion_r410467923", "createdAt": "2020-04-17T21:01:37Z", "author": {"login": "mbaxter"}, "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/gossip/topics/validation/BlockValidator.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package tech.pegasys.artemis.networking.eth2.gossip.topics.validation;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.artemis.bls.BLS;\n+import tech.pegasys.artemis.bls.BLSSignature;\n+import tech.pegasys.artemis.core.StateTransition;\n+import tech.pegasys.artemis.core.exceptions.EpochProcessingException;\n+import tech.pegasys.artemis.core.exceptions.SlotProcessingException;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.datastructures.forkchoice.ReadOnlyStore;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.state.Validator;\n+import tech.pegasys.artemis.storage.client.RecentChainData;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static com.google.common.primitives.UnsignedLong.valueOf;\n+import static java.lang.Math.toIntExact;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.compute_signing_root;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_beacon_proposer_index;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_domain;\n+import static tech.pegasys.artemis.statetransition.forkchoice.ForkChoiceUtil.getCurrentSlot;\n+import static tech.pegasys.artemis.util.config.Constants.DOMAIN_BEACON_PROPOSER;\n+import static tech.pegasys.artemis.util.config.Constants.MAXIMUM_GOSSIP_CLOCK_DISPARITY;\n+\n+public class BlockValidator {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final RecentChainData recentChainData;\n+  private final StateTransition stateTransition;\n+  private final Set<UnsignedLong> receivedValidSignatureBlockSlots = new HashSet<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e0fea79e98213e89eba344d803674ad53377051"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ3MTY4MA==", "bodyText": "nice :D", "url": "https://github.com/ConsenSys/teku/pull/1615#discussion_r410471680", "createdAt": "2020-04-17T21:10:27Z", "author": {"login": "mbaxter"}, "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/gossip/topics/BlockTopicHandler.java", "diffHunk": "@@ -66,49 +56,18 @@ protected SignedBeaconBlock deserialize(final Bytes bytes) throws SSZException {\n \n   @Override\n   protected boolean validateData(final SignedBeaconBlock block) {\n-    if (recentChainData.isPreGenesis()) {\n-      // We can't process blocks pre-genesis\n-      return false;\n-    }\n-\n-    final BeaconState preState =\n-        recentChainData.getStore().getBlockState(block.getMessage().getParent_root());\n-    if (preState == null) {\n-      // Post event even if we don't have the prestate\n-      eventBus.post(createEvent(block));\n-      return false;\n-    }\n-\n-    if (!isBlockSignatureValid(block, preState)) {\n-      LOG.trace(\"Dropping gossiped block with invalid signature: {}\", block);\n-      return false;\n-    }\n-\n-    final UnsignedLong currentSlot = get_current_slot(recentChainData.getStore());\n-    if (block.getSlot().compareTo(currentSlot) > 0) {\n-      // Don't gossip future blocks\n-      eventBus.post(createEvent(block));\n-      return false;\n-    }\n-\n-    return true;\n-  }\n-\n-  private boolean isBlockSignatureValid(final SignedBeaconBlock block, final BeaconState preState) {\n-    final StateTransition stateTransition = new StateTransition();\n-\n-    try {\n-      BeaconState postState = stateTransition.process_slots(preState, block.getMessage().getSlot());\n-      final int proposerIndex = get_beacon_proposer_index(postState);\n-      final Validator proposer = postState.getValidators().get(proposerIndex);\n-      final Bytes domain = get_domain(preState, DOMAIN_BEACON_PROPOSER);\n-      final Bytes signing_root = compute_signing_root(block.getMessage(), domain);\n-      final BLSSignature signature = block.getSignature();\n-      return BLS.verify(proposer.getPubkey(), signing_root, signature);\n-\n-    } catch (EpochProcessingException | SlotProcessingException e) {\n-      LOG.error(\"Unable to process block state.\", e);\n-      return false;\n+    BlockValidationResult blockValidationResult = blockValidator.validate(block);\n+    switch (blockValidationResult) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e0fea79e98213e89eba344d803674ad53377051"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ3MzA1OA==", "bodyText": "Looks like a few test cases are missing for invalid signatures, missing prestate, duplicate block", "url": "https://github.com/ConsenSys/teku/pull/1615#discussion_r410473058", "createdAt": "2020-04-17T21:13:58Z", "author": {"login": "mbaxter"}, "path": "networking/eth2/src/test/java/tech/pegasys/artemis/networking/eth2/gossip/BlockValidatorTest.java", "diffHunk": "@@ -0,0 +1,69 @@\n+package tech.pegasys.artemis.networking.eth2.gossip;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.primitives.UnsignedLong;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import tech.pegasys.artemis.bls.BLSKeyGenerator;\n+import tech.pegasys.artemis.bls.BLSKeyPair;\n+import tech.pegasys.artemis.core.ChainBuilder;\n+import tech.pegasys.artemis.core.StateTransition;\n+import tech.pegasys.artemis.core.StateTransitionException;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.networking.eth2.gossip.topics.validation.BlockValidationResult;\n+import tech.pegasys.artemis.networking.eth2.gossip.topics.validation.BlockValidator;\n+import tech.pegasys.artemis.statetransition.BeaconChainUtil;\n+import tech.pegasys.artemis.storage.client.MemoryOnlyRecentChainData;\n+import tech.pegasys.artemis.storage.client.RecentChainData;\n+\n+import java.util.List;\n+\n+import static com.google.common.primitives.UnsignedLong.ONE;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.mock;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.compute_start_slot_at_epoch;\n+\n+public class BlockValidatorTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e0fea79e98213e89eba344d803674ad53377051"}, "originalPosition": 26}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "94a50bb49933bdf3208a6158f84492602c83dfbc", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/94a50bb49933bdf3208a6158f84492602c83dfbc", "committedDate": "2020-04-17T22:46:07Z", "message": "Resolve comments & finish tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a6a6e0e607bf224018860f84d87e2d97bda71aaf", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/a6a6e0e607bf224018860f84d87e2d97bda71aaf", "committedDate": "2020-04-17T23:44:55Z", "message": "Fix tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "97c0cc75708674ab7d01fbdb746abe03703d0203", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/97c0cc75708674ab7d01fbdb746abe03703d0203", "committedDate": "2020-04-17T23:49:35Z", "message": "Run spotless"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "03175188f7c5e6a6c9c826b9e32daa5f1f760e5b", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/03175188f7c5e6a6c9c826b9e32daa5f1f760e5b", "committedDate": "2020-04-17T23:51:22Z", "message": "Merge remote-tracking branch 'remotes/origin/master' into validateBlocks\n\n# Conflicts:\n#\tnetworking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/gossip/topics/BlockTopicHandler.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "984a2c8fdc88801ff0fcdf0695d4158f491f483a", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/984a2c8fdc88801ff0fcdf0695d4158f491f483a", "committedDate": "2020-04-18T00:00:08Z", "message": "Fix merge issue"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a38713fa1922a8b1f6b348fd578ff01dd0ad066c", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/a38713fa1922a8b1f6b348fd578ff01dd0ad066c", "committedDate": "2020-04-18T00:13:00Z", "message": "Only post on to eventBus once if valid"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2MTM2MjE4", "url": "https://github.com/ConsenSys/teku/pull/1615#pullrequestreview-396136218", "createdAt": "2020-04-20T04:45:38Z", "commit": {"oid": "a38713fa1922a8b1f6b348fd578ff01dd0ad066c"}, "state": "APPROVED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwNDo0NTozOFrOGIC63A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwNTowMDoxNVrOGIDLfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTA4OTYyOA==", "bodyText": "nit: We should provide a message here to indicate what the unexpected value was.", "url": "https://github.com/ConsenSys/teku/pull/1615#discussion_r411089628", "createdAt": "2020-04-20T04:45:38Z", "author": {"login": "ajsutton"}, "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/gossip/topics/BlockTopicHandler.java", "diffHunk": "@@ -66,49 +50,17 @@ protected SignedBeaconBlock deserialize(final Bytes bytes) throws SSZException {\n \n   @Override\n   protected boolean validateData(final SignedBeaconBlock block) {\n-    if (recentChainData.isPreGenesis()) {\n-      // We can't process blocks pre-genesis\n-      return false;\n-    }\n-\n-    final BeaconState preState =\n-        recentChainData.getStore().getBlockState(block.getMessage().getParent_root());\n-    if (preState == null) {\n-      // Post event even if we don't have the prestate\n-      eventBus.post(createEvent(block));\n-      return false;\n-    }\n-\n-    if (!isBlockSignatureValid(block, preState)) {\n-      LOG.trace(\"Dropping gossiped block with invalid signature: {}\", block);\n-      return false;\n-    }\n-\n-    final UnsignedLong currentSlot = get_current_slot(recentChainData.getStore());\n-    if (block.getSlot().compareTo(currentSlot) > 0) {\n-      // Don't gossip future blocks\n-      eventBus.post(createEvent(block));\n-      return false;\n-    }\n-\n-    return true;\n-  }\n-\n-  private boolean isBlockSignatureValid(final SignedBeaconBlock block, final BeaconState preState) {\n-    final StateTransition stateTransition = new StateTransition();\n-\n-    try {\n-      BeaconState postState = stateTransition.process_slots(preState, block.getMessage().getSlot());\n-      final int proposerIndex = get_beacon_proposer_index(postState);\n-      final Validator proposer = postState.getValidators().get(proposerIndex);\n-      final Bytes domain = get_domain(preState, DOMAIN_BEACON_PROPOSER);\n-      final Bytes signing_root = compute_signing_root(block.getMessage(), domain);\n-      final BLSSignature signature = block.getSignature();\n-      return BLS.verify(proposer.getPubkey(), signing_root, signature);\n-\n-    } catch (EpochProcessingException | SlotProcessingException e) {\n-      LOG.error(\"Unable to process block state.\", e);\n-      return false;\n+    BlockValidationResult blockValidationResult = blockValidator.validate(block);\n+    switch (blockValidationResult) {\n+      case INVALID:\n+        return false;\n+      case SAVED_FOR_FUTURE:\n+        eventBus.post(createEvent(block));\n+        return false;\n+      case VALID:\n+        return true;\n+      default:\n+        throw new UnsupportedOperationException();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a38713fa1922a8b1f6b348fd578ff01dd0ad066c"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTA5MjIxMA==", "bodyText": "We should be using the caches for this via AttestationUtil.getValidatorPubKey (which probably should be moved to a public method in ValidatorsUtil.", "url": "https://github.com/ConsenSys/teku/pull/1615#discussion_r411092210", "createdAt": "2020-04-20T04:54:18Z", "author": {"login": "ajsutton"}, "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/gossip/topics/validation/BlockValidator.java", "diffHunk": "@@ -0,0 +1,155 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.networking.eth2.gossip.topics.validation;\n+\n+import static java.lang.Math.toIntExact;\n+import static tech.pegasys.artemis.core.ForkChoiceUtil.getCurrentSlot;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.compute_signing_root;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_beacon_proposer_index;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_domain;\n+import static tech.pegasys.artemis.util.config.Constants.DOMAIN_BEACON_PROPOSER;\n+import static tech.pegasys.artemis.util.config.Constants.MAXIMUM_GOSSIP_CLOCK_DISPARITY;\n+import static tech.pegasys.artemis.util.config.Constants.VALID_BLOCK_SET_SIZE;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.Optional;\n+import java.util.Set;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.artemis.bls.BLS;\n+import tech.pegasys.artemis.bls.BLSSignature;\n+import tech.pegasys.artemis.core.StateTransition;\n+import tech.pegasys.artemis.core.exceptions.EpochProcessingException;\n+import tech.pegasys.artemis.core.exceptions.SlotProcessingException;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.datastructures.forkchoice.ReadOnlyStore;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.state.Validator;\n+import tech.pegasys.artemis.storage.client.RecentChainData;\n+import tech.pegasys.artemis.util.collections.ConcurrentLimitedSet;\n+import tech.pegasys.artemis.util.collections.LimitStrategy;\n+\n+public class BlockValidator {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final RecentChainData recentChainData;\n+  private final StateTransition stateTransition;\n+  private final Set<SlotAndProposer> receivedValidBlockInfoSet =\n+      ConcurrentLimitedSet.create(VALID_BLOCK_SET_SIZE, LimitStrategy.DROP_OLDEST_ELEMENT);\n+\n+  public BlockValidator(RecentChainData recentChainData, StateTransition stateTransition) {\n+    this.recentChainData = recentChainData;\n+    this.stateTransition = stateTransition;\n+  }\n+\n+  public BlockValidationResult validate(SignedBeaconBlock block) {\n+\n+    if (!blockSlotIsGreaterThanLatestFinalizedSlot(block)\n+        || !blockIsFirstBlockWithValidSignatureForSlot(block)) {\n+      LOG.trace(\n+          \"BlockValidator: Block is either too old or is not the first block with valid signature for \"\n+              + \"its slot. It will be dropped\");\n+      return BlockValidationResult.INVALID;\n+    }\n+\n+    final Optional<BeaconState> preState =\n+        Optional.ofNullable(\n+            recentChainData.getStore().getBlockState(block.getMessage().getParent_root()));\n+    if (preState.isEmpty() || blockIsFromFutureSlot(block)) {\n+      LOG.trace(\n+          \"BlockValidator: Either block pre state does not exist or block is from the future. \"\n+              + \"It will be saved for future processing\");\n+      return BlockValidationResult.SAVED_FOR_FUTURE;\n+    }\n+\n+    try {\n+      BeaconState postState =\n+          stateTransition.process_slots(preState.get(), block.getMessage().getSlot());\n+      if (blockIsProposedByTheExpectedProposer(block, postState)\n+          && blockSignatureIsValidWithRespectToProposerIndex(block, preState.get(), postState)) {\n+        return BlockValidationResult.VALID;\n+      }\n+    } catch (EpochProcessingException | SlotProcessingException e) {\n+      LOG.error(\"BlockValidator: Unable to process block state.\", e);\n+      return BlockValidationResult.INVALID;\n+    }\n+\n+    return BlockValidationResult.INVALID;\n+  }\n+\n+  private boolean blockIsFromFutureSlot(SignedBeaconBlock block) {\n+    ReadOnlyStore store = recentChainData.getStore();\n+    final long disparityInSeconds = Math.round((float) MAXIMUM_GOSSIP_CLOCK_DISPARITY / 1000.0);\n+    final UnsignedLong maxOffset = UnsignedLong.valueOf(disparityInSeconds);\n+    final UnsignedLong maxTime = store.getTime().plus(maxOffset);\n+    UnsignedLong maxCurrSlot = getCurrentSlot(maxTime, store.getGenesisTime());\n+    return block.getSlot().compareTo(maxCurrSlot) > 0;\n+  }\n+\n+  private boolean blockSlotIsGreaterThanLatestFinalizedSlot(SignedBeaconBlock block) {\n+    UnsignedLong finalizedSlot =\n+        recentChainData.getStore().getFinalizedCheckpoint().getEpochStartSlot();\n+    return block.getSlot().compareTo(finalizedSlot) > 0;\n+  }\n+\n+  private boolean blockIsFirstBlockWithValidSignatureForSlot(SignedBeaconBlock block) {\n+    return !receivedValidBlockInfoSet.contains(new SlotAndProposer(block));\n+  }\n+\n+  private boolean blockSignatureIsValidWithRespectToProposerIndex(\n+      SignedBeaconBlock block, BeaconState preState, BeaconState postState) {\n+    Validator proposer =\n+        postState\n+            .getValidators()\n+            .get(toIntExact(block.getMessage().getProposer_index().longValue()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a38713fa1922a8b1f6b348fd578ff01dd0ad066c"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTA5MjYxNw==", "bodyText": "Remove the toIntExact here and use long comparison (the int proposerIndex will be automatically up-cast to a long).  That way it will evaluate to false if proposer index is greater than Integer.MAX_VALUE rather than throwing an exception.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                return proposerIndex == toIntExact(block.getMessage().getProposer_index().longValue());\n          \n          \n            \n                return proposerIndex == block.getMessage().getProposer_index().longValue();", "url": "https://github.com/ConsenSys/teku/pull/1615#discussion_r411092617", "createdAt": "2020-04-20T04:55:42Z", "author": {"login": "ajsutton"}, "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/gossip/topics/validation/BlockValidator.java", "diffHunk": "@@ -0,0 +1,155 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.networking.eth2.gossip.topics.validation;\n+\n+import static java.lang.Math.toIntExact;\n+import static tech.pegasys.artemis.core.ForkChoiceUtil.getCurrentSlot;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.compute_signing_root;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_beacon_proposer_index;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_domain;\n+import static tech.pegasys.artemis.util.config.Constants.DOMAIN_BEACON_PROPOSER;\n+import static tech.pegasys.artemis.util.config.Constants.MAXIMUM_GOSSIP_CLOCK_DISPARITY;\n+import static tech.pegasys.artemis.util.config.Constants.VALID_BLOCK_SET_SIZE;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.Optional;\n+import java.util.Set;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.artemis.bls.BLS;\n+import tech.pegasys.artemis.bls.BLSSignature;\n+import tech.pegasys.artemis.core.StateTransition;\n+import tech.pegasys.artemis.core.exceptions.EpochProcessingException;\n+import tech.pegasys.artemis.core.exceptions.SlotProcessingException;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.datastructures.forkchoice.ReadOnlyStore;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.state.Validator;\n+import tech.pegasys.artemis.storage.client.RecentChainData;\n+import tech.pegasys.artemis.util.collections.ConcurrentLimitedSet;\n+import tech.pegasys.artemis.util.collections.LimitStrategy;\n+\n+public class BlockValidator {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final RecentChainData recentChainData;\n+  private final StateTransition stateTransition;\n+  private final Set<SlotAndProposer> receivedValidBlockInfoSet =\n+      ConcurrentLimitedSet.create(VALID_BLOCK_SET_SIZE, LimitStrategy.DROP_OLDEST_ELEMENT);\n+\n+  public BlockValidator(RecentChainData recentChainData, StateTransition stateTransition) {\n+    this.recentChainData = recentChainData;\n+    this.stateTransition = stateTransition;\n+  }\n+\n+  public BlockValidationResult validate(SignedBeaconBlock block) {\n+\n+    if (!blockSlotIsGreaterThanLatestFinalizedSlot(block)\n+        || !blockIsFirstBlockWithValidSignatureForSlot(block)) {\n+      LOG.trace(\n+          \"BlockValidator: Block is either too old or is not the first block with valid signature for \"\n+              + \"its slot. It will be dropped\");\n+      return BlockValidationResult.INVALID;\n+    }\n+\n+    final Optional<BeaconState> preState =\n+        Optional.ofNullable(\n+            recentChainData.getStore().getBlockState(block.getMessage().getParent_root()));\n+    if (preState.isEmpty() || blockIsFromFutureSlot(block)) {\n+      LOG.trace(\n+          \"BlockValidator: Either block pre state does not exist or block is from the future. \"\n+              + \"It will be saved for future processing\");\n+      return BlockValidationResult.SAVED_FOR_FUTURE;\n+    }\n+\n+    try {\n+      BeaconState postState =\n+          stateTransition.process_slots(preState.get(), block.getMessage().getSlot());\n+      if (blockIsProposedByTheExpectedProposer(block, postState)\n+          && blockSignatureIsValidWithRespectToProposerIndex(block, preState.get(), postState)) {\n+        return BlockValidationResult.VALID;\n+      }\n+    } catch (EpochProcessingException | SlotProcessingException e) {\n+      LOG.error(\"BlockValidator: Unable to process block state.\", e);\n+      return BlockValidationResult.INVALID;\n+    }\n+\n+    return BlockValidationResult.INVALID;\n+  }\n+\n+  private boolean blockIsFromFutureSlot(SignedBeaconBlock block) {\n+    ReadOnlyStore store = recentChainData.getStore();\n+    final long disparityInSeconds = Math.round((float) MAXIMUM_GOSSIP_CLOCK_DISPARITY / 1000.0);\n+    final UnsignedLong maxOffset = UnsignedLong.valueOf(disparityInSeconds);\n+    final UnsignedLong maxTime = store.getTime().plus(maxOffset);\n+    UnsignedLong maxCurrSlot = getCurrentSlot(maxTime, store.getGenesisTime());\n+    return block.getSlot().compareTo(maxCurrSlot) > 0;\n+  }\n+\n+  private boolean blockSlotIsGreaterThanLatestFinalizedSlot(SignedBeaconBlock block) {\n+    UnsignedLong finalizedSlot =\n+        recentChainData.getStore().getFinalizedCheckpoint().getEpochStartSlot();\n+    return block.getSlot().compareTo(finalizedSlot) > 0;\n+  }\n+\n+  private boolean blockIsFirstBlockWithValidSignatureForSlot(SignedBeaconBlock block) {\n+    return !receivedValidBlockInfoSet.contains(new SlotAndProposer(block));\n+  }\n+\n+  private boolean blockSignatureIsValidWithRespectToProposerIndex(\n+      SignedBeaconBlock block, BeaconState preState, BeaconState postState) {\n+    Validator proposer =\n+        postState\n+            .getValidators()\n+            .get(toIntExact(block.getMessage().getProposer_index().longValue()));\n+\n+    final Bytes domain = get_domain(preState, DOMAIN_BEACON_PROPOSER);\n+    final Bytes signing_root = compute_signing_root(block.getMessage(), domain);\n+    final BLSSignature signature = block.getSignature();\n+    boolean signatureValid = BLS.verify(proposer.getPubkey(), signing_root, signature);\n+\n+    return signatureValid && receivedValidBlockInfoSet.add(new SlotAndProposer(block));\n+  }\n+\n+  private boolean blockIsProposedByTheExpectedProposer(\n+      SignedBeaconBlock block, BeaconState postState) {\n+    final int proposerIndex = get_beacon_proposer_index(postState);\n+    return proposerIndex == toIntExact(block.getMessage().getProposer_index().longValue());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a38713fa1922a8b1f6b348fd578ff01dd0ad066c"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTA5Mzg4Nw==", "bodyText": "Still need a test for a block that's not from the future, but that we don't have the parent for.", "url": "https://github.com/ConsenSys/teku/pull/1615#discussion_r411093887", "createdAt": "2020-04-20T05:00:15Z", "author": {"login": "ajsutton"}, "path": "networking/eth2/src/test/java/tech/pegasys/artemis/networking/eth2/gossip/BlockValidatorTest.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.networking.eth2.gossip;\n+\n+import static com.google.common.primitives.UnsignedLong.ONE;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.compute_start_slot_at_epoch;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.primitives.UnsignedLong;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import tech.pegasys.artemis.bls.BLSSignature;\n+import tech.pegasys.artemis.core.StateTransition;\n+import tech.pegasys.artemis.core.signatures.Signer;\n+import tech.pegasys.artemis.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.networking.eth2.gossip.topics.validation.BlockValidationResult;\n+import tech.pegasys.artemis.networking.eth2.gossip.topics.validation.BlockValidator;\n+import tech.pegasys.artemis.statetransition.BeaconChainUtil;\n+import tech.pegasys.artemis.storage.client.MemoryOnlyRecentChainData;\n+import tech.pegasys.artemis.storage.client.RecentChainData;\n+\n+public class BlockValidatorTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a38713fa1922a8b1f6b348fd578ff01dd0ad066c"}, "originalPosition": 35}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f707197c5e1fa43257c08e3c2fcd10ac36b5754f", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/f707197c5e1fa43257c08e3c2fcd10ac36b5754f", "committedDate": "2020-04-20T17:27:10Z", "message": "Resolve comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "96cdd4164520357d3a13fe0049d25dc63fdf58e5", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/96cdd4164520357d3a13fe0049d25dc63fdf58e5", "committedDate": "2020-04-20T17:30:19Z", "message": "Merge remote-tracking branch 'remotes/origin/master' into validateBlocks\n\n# Conflicts:\n#\tnetworking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/ActiveEth2Network.java\n#\tutil/src/main/java/tech/pegasys/artemis/util/config/Constants.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "810641e08e15ffb87ebfce104e77bcbf0c47db2b", "author": {"user": {"login": "cemozerr", "name": "Cem Ozer"}}, "url": "https://github.com/ConsenSys/teku/commit/810641e08e15ffb87ebfce104e77bcbf0c47db2b", "committedDate": "2020-04-20T17:34:14Z", "message": "Merge branch 'master' into validateBlocks"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4310, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}