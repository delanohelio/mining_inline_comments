{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDUzODQ1MzYw", "number": 2391, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwMDoyODozNVrOEQaxCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwMToyMDoxNVrOEQbVlg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1NjUxMjA4OnYy", "diffSide": "RIGHT", "path": "networking/eth2/src/test/java/tech/pegasys/teku/networking/eth2/gossip/subnets/AttestationSubnetSubscriptionsTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwMDoyODozNVrOG0jywA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxNTozNTo1OVrOG0933Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc2NTU2OA==", "bodyText": "These join calls are spreading through tests a lot.  It's not the end of the world but if for some reason the future wasn't completed they'd hang forever which would make it very hard to know which test was failing.\nWe already have SafeFutureAssert to add some utilities for asserting stuff about futures so I think we could add:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                assertThat(subnetSubscriptions.getChannel(attestation).join()).isNotEqualTo(Optional.empty());\n          \n          \n            \n                assertThat(subnetSubscriptions.getChannel(attestation2).join()).isEqualTo(Optional.empty());\n          \n          \n            \n                  public void isCompletedWithEmptyOptional() {\n          \n          \n            \n                isCompleted();\n          \n          \n            \n                Assertions.assertThat(actual.join()).isEqualTo(Optional.empty());\n          \n          \n            \n              }\n          \n          \n            \n              \n          \n          \n            \n              public void isCompletedWithNonEmptyOptional() {\n          \n          \n            \n                isCompleted();\n          \n          \n            \n                Assertions.assertThat(actual.join()).isNotEqualTo(Optional.empty());  \n          \n          \n            \n              }", "url": "https://github.com/ConsenSys/teku/pull/2391#discussion_r457765568", "createdAt": "2020-07-21T00:28:35Z", "author": {"login": "ajsutton"}, "path": "networking/eth2/src/test/java/tech/pegasys/teku/networking/eth2/gossip/subnets/AttestationSubnetSubscriptionsTest.java", "diffHunk": "@@ -73,16 +73,16 @@ void getChannelReturnsEmptyIfNotSubscribedToSubnet() {\n     int subnetId = computeSubnetId(attestation);\n     assertThat(computeSubnetId(attestation2)).isNotEqualTo(subnetId); // Sanity check\n     subnetSubscriptions.subscribeToSubnetId(subnetId);\n-    assertThat(subnetSubscriptions.getChannel(attestation)).isNotEqualTo(Optional.empty());\n-    assertThat(subnetSubscriptions.getChannel(attestation2)).isEqualTo(Optional.empty());\n+    assertThat(subnetSubscriptions.getChannel(attestation).join()).isNotEqualTo(Optional.empty());\n+    assertThat(subnetSubscriptions.getChannel(attestation2).join()).isEqualTo(Optional.empty());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd54c67470aeadf9dd73683c55aa2e47fc35cce7"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODE5Mjg2MQ==", "bodyText": "neat \ud83c\udf89", "url": "https://github.com/ConsenSys/teku/pull/2391#discussion_r458192861", "createdAt": "2020-07-21T15:35:59Z", "author": {"login": "mbaxter"}, "path": "networking/eth2/src/test/java/tech/pegasys/teku/networking/eth2/gossip/subnets/AttestationSubnetSubscriptionsTest.java", "diffHunk": "@@ -73,16 +73,16 @@ void getChannelReturnsEmptyIfNotSubscribedToSubnet() {\n     int subnetId = computeSubnetId(attestation);\n     assertThat(computeSubnetId(attestation2)).isNotEqualTo(subnetId); // Sanity check\n     subnetSubscriptions.subscribeToSubnetId(subnetId);\n-    assertThat(subnetSubscriptions.getChannel(attestation)).isNotEqualTo(Optional.empty());\n-    assertThat(subnetSubscriptions.getChannel(attestation2)).isEqualTo(Optional.empty());\n+    assertThat(subnetSubscriptions.getChannel(attestation).join()).isNotEqualTo(Optional.empty());\n+    assertThat(subnetSubscriptions.getChannel(attestation2).join()).isEqualTo(Optional.empty());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc2NTU2OA=="}, "originalCommit": {"oid": "bd54c67470aeadf9dd73683c55aa2e47fc35cce7"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1NjUxMzAxOnYy", "diffSide": "RIGHT", "path": "networking/eth2/src/test/java/tech/pegasys/teku/networking/eth2/gossip/subnets/AttestationSubnetSubscriptionsTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwMDoyOTowN1rOG0jzSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwMDoyOTowN1rOG0jzSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc2NTcwNQ==", "bodyText": "These can just be:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                assertThat(subnetSubscriptions.getChannel(attestation1).join())\n          \n          \n            \n                    .isEqualTo(Optional.of(topicChannel1));\n          \n          \n            \n                assertThat(subnetSubscriptions.getChannel(attestation2).join())\n          \n          \n            \n                    .isEqualTo(Optional.of(topicChannel2));\n          \n          \n            \n                assertThat(subnetSubscriptions.getChannel(attestation1))\n          \n          \n            \n                    .isCompletedWith(Optional.of(topicChannel1));\n          \n          \n            \n                assertThat(subnetSubscriptions.getChannel(attestation2))\n          \n          \n            \n                    .isCompletedWith(Optional.of(topicChannel2));", "url": "https://github.com/ConsenSys/teku/pull/2391#discussion_r457765705", "createdAt": "2020-07-21T00:29:07Z", "author": {"login": "ajsutton"}, "path": "networking/eth2/src/test/java/tech/pegasys/teku/networking/eth2/gossip/subnets/AttestationSubnetSubscriptionsTest.java", "diffHunk": "@@ -110,8 +110,10 @@ void shouldSubscribeToCommitteesOnDifferentSubnets() {\n     verify(gossipNetwork)\n         .subscribe(argThat(i -> i.contains(\"beacon_attestation_\" + subnetId2)), any());\n \n-    assertThat(subnetSubscriptions.getChannel(attestation1)).isEqualTo(Optional.of(topicChannel1));\n-    assertThat(subnetSubscriptions.getChannel(attestation2)).isEqualTo(Optional.of(topicChannel2));\n+    assertThat(subnetSubscriptions.getChannel(attestation1).join())\n+        .isEqualTo(Optional.of(topicChannel1));\n+    assertThat(subnetSubscriptions.getChannel(attestation2).join())\n+        .isEqualTo(Optional.of(topicChannel2));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd54c67470aeadf9dd73683c55aa2e47fc35cce7"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1NjUxMzU5OnYy", "diffSide": "RIGHT", "path": "networking/eth2/src/test/java/tech/pegasys/teku/networking/eth2/gossip/subnets/AttestationSubnetSubscriptionsTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwMDoyOToyM1rOG0jznQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwMDoyOToyM1rOG0jznQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc2NTc4OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                assertThat(subnetSubscriptions.getChannel(attestation).join())\n          \n          \n            \n                    .isEqualTo(Optional.of(topicChannel));\n          \n          \n            \n                assertThat(subnetSubscriptions.getChannel(attestation))\n          \n          \n            \n                    .isCompletedWith(Optional.of(topicChannel));", "url": "https://github.com/ConsenSys/teku/pull/2391#discussion_r457765789", "createdAt": "2020-07-21T00:29:23Z", "author": {"login": "ajsutton"}, "path": "networking/eth2/src/test/java/tech/pegasys/teku/networking/eth2/gossip/subnets/AttestationSubnetSubscriptionsTest.java", "diffHunk": "@@ -126,7 +128,8 @@ void shouldUnsubscribeFromOnlyCommitteeOnSubnet() {\n \n     verify(gossipNetwork).subscribe(any(), any());\n \n-    assertThat(subnetSubscriptions.getChannel(attestation)).isEqualTo(Optional.of(topicChannel));\n+    assertThat(subnetSubscriptions.getChannel(attestation).join())\n+        .isEqualTo(Optional.of(topicChannel));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd54c67470aeadf9dd73683c55aa2e47fc35cce7"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1NjUxNTIzOnYy", "diffSide": "RIGHT", "path": "storage/src/main/java/tech/pegasys/teku/storage/client/CombinedChainDataClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwMDozMDoxMVrOG0j0dQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwMDozMDoxMVrOG0j0dQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc2NjAwNQ==", "bodyText": "nit:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            // during\n          \n          \n            \n                            // processing\n          \n          \n            \n                            // during processing", "url": "https://github.com/ConsenSys/teku/pull/2391#discussion_r457766005", "createdAt": "2020-07-21T00:30:11Z", "author": {"login": "ajsutton"}, "path": "storage/src/main/java/tech/pegasys/teku/storage/client/CombinedChainDataClient.java", "diffHunk": "@@ -160,16 +160,20 @@ public boolean isFinalizedEpoch(final UnsignedLong epoch) {\n     }\n \n     if (isRecentData(slot)) {\n-      final Optional<BeaconState> recentState = recentChainData.getStateInEffectAtSlot(slot);\n-      if (recentState.isPresent()) {\n-        LOG.trace(\"State at slot {} was from recent chain data\", slot);\n-        return completedFuture(recentState);\n-      }\n+      return recentChainData\n+          .retrieveStateInEffectAtSlot(slot)\n+          .thenCompose(\n+              recentState -> {\n+                if (recentState.isPresent()) {\n+                  return completedFuture(recentState);\n+                }\n+                // Fall-through to historical query in case state has moved into historical range\n+                // during\n+                // processing", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd54c67470aeadf9dd73683c55aa2e47fc35cce7"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg1NjYwNTY2OnYy", "diffSide": "RIGHT", "path": "storage/src/main/java/tech/pegasys/teku/storage/client/RecentChainData.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQwMToyMDoxNVrOG0kqLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQwMDowMjo0NVrOG1N_6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc3OTc1OQ==", "bodyText": "I don't think this works.  Say we have:\n\nUpdate 1 starts, grabs original head as slot 1, trying to set slot to 2.\nUpdate 2 starts, grabs original head as slot 1, trying to set slot to 3.\nUpdate 1 completes and sets head to 2\nUpdate 2 will now be skipped because it expects head to be 1 but it's changed. We then wind up with an outdated head (but at least we don't go backwards).\n\nI wonder if in RecentChainData we should just return the SafeFuture.  ForkChoiceHead is the key place it gets called from and it probably needs to call join so it all happens in the synchronized block.  Kind of just pushing the problem down the road unfortunately but I'm struggling to see how else to do it.  Ultimately we need to ensure there is only one thing updating head at a time.", "url": "https://github.com/ConsenSys/teku/pull/2391#discussion_r457779759", "createdAt": "2020-07-21T01:20:15Z", "author": {"login": "ajsutton"}, "path": "storage/src/main/java/tech/pegasys/teku/storage/client/RecentChainData.java", "diffHunk": "@@ -186,30 +186,43 @@ public StoreTransaction startStoreTransaction() {\n    * @param slot the new best slot\n    */\n   public void updateBestBlock(Bytes32 root, UnsignedLong slot) {\n+    final Optional<SignedBlockAndStateAndSlot> originalChainHead = chainHead;\n+    store\n+        .retrieveBlockAndState(root)\n+        .thenApply(\n+            headBlockAndState ->\n+                headBlockAndState\n+                    .map(head -> SignedBlockAndStateAndSlot.create(head, slot))\n+                    .orElseThrow(\n+                        () ->\n+                            new IllegalStateException(\n+                                String.format(\n+                                    \"Unable to update best block as of slot %s.  Block is unavailable: %s.\",\n+                                    slot, root))))\n+        .thenAccept(headBlock -> updateChainHead(originalChainHead, headBlock))\n+        .reportExceptions();\n+  }\n+\n+  private void updateChainHead(\n+      final Optional<SignedBlockAndStateAndSlot> originalHead,\n+      final SignedBlockAndStateAndSlot newChainHead) {\n     synchronized (this) {\n-      final SignedBeaconBlock newBestBlock = store.getSignedBlock(root);\n-      final BeaconState newBestState = store.getBlockState(root);\n-      if (newBestBlock == null || newBestState == null) {\n-        LOG.warn(\n-            \"Unable to update best block (slot={}, root={}). Corresponding {} unavailable\",\n-            slot,\n-            root,\n-            newBestBlock == null ? \"block\" : \"state\");\n+      if (!chainHead.equals(originalHead)) {\n+        // The chain head has been updated while we were waiting for the newChainHead\n+        // Skip this update to avoid accidentally regressing the chain head\n+        LOG.debug(\"Skipping best block update to avoid potential rollback of the best block.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd54c67470aeadf9dd73683c55aa2e47fc35cce7"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI3OTQyMw==", "bodyText": "Right - the current logic will prevent us from rolling back the chain head, but it doesn't guarantee we get the most up-to-date chain head.\nI think as long as we're taking the chain head from RecentChainData  it shouldn't matter if we miss an update on rare occasions should it?  We update the head periodically so it should advance on the next call that completes.", "url": "https://github.com/ConsenSys/teku/pull/2391#discussion_r458279423", "createdAt": "2020-07-21T17:47:33Z", "author": {"login": "mbaxter"}, "path": "storage/src/main/java/tech/pegasys/teku/storage/client/RecentChainData.java", "diffHunk": "@@ -186,30 +186,43 @@ public StoreTransaction startStoreTransaction() {\n    * @param slot the new best slot\n    */\n   public void updateBestBlock(Bytes32 root, UnsignedLong slot) {\n+    final Optional<SignedBlockAndStateAndSlot> originalChainHead = chainHead;\n+    store\n+        .retrieveBlockAndState(root)\n+        .thenApply(\n+            headBlockAndState ->\n+                headBlockAndState\n+                    .map(head -> SignedBlockAndStateAndSlot.create(head, slot))\n+                    .orElseThrow(\n+                        () ->\n+                            new IllegalStateException(\n+                                String.format(\n+                                    \"Unable to update best block as of slot %s.  Block is unavailable: %s.\",\n+                                    slot, root))))\n+        .thenAccept(headBlock -> updateChainHead(originalChainHead, headBlock))\n+        .reportExceptions();\n+  }\n+\n+  private void updateChainHead(\n+      final Optional<SignedBlockAndStateAndSlot> originalHead,\n+      final SignedBlockAndStateAndSlot newChainHead) {\n     synchronized (this) {\n-      final SignedBeaconBlock newBestBlock = store.getSignedBlock(root);\n-      final BeaconState newBestState = store.getBlockState(root);\n-      if (newBestBlock == null || newBestState == null) {\n-        LOG.warn(\n-            \"Unable to update best block (slot={}, root={}). Corresponding {} unavailable\",\n-            slot,\n-            root,\n-            newBestBlock == null ? \"block\" : \"state\");\n+      if (!chainHead.equals(originalHead)) {\n+        // The chain head has been updated while we were waiting for the newChainHead\n+        // Skip this update to avoid accidentally regressing the chain head\n+        LOG.debug(\"Skipping best block update to avoid potential rollback of the best block.\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc3OTc1OQ=="}, "originalCommit": {"oid": "bd54c67470aeadf9dd73683c55aa2e47fc35cce7"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ1NzA2Ng==", "bodyText": "It makes me nervous and may mean we generate attestations pointing to an outdated head but yeah it probably works -especially since we very likely still have the state in cache since we would have either created it by processing a block or processed an attestation that needed it.\nI think it would be well worth printing an INFO level message each time we skip an update though. If it happens a lot we should be worried and I think it's useful to know how often it is happening.", "url": "https://github.com/ConsenSys/teku/pull/2391#discussion_r458457066", "createdAt": "2020-07-22T00:02:45Z", "author": {"login": "ajsutton"}, "path": "storage/src/main/java/tech/pegasys/teku/storage/client/RecentChainData.java", "diffHunk": "@@ -186,30 +186,43 @@ public StoreTransaction startStoreTransaction() {\n    * @param slot the new best slot\n    */\n   public void updateBestBlock(Bytes32 root, UnsignedLong slot) {\n+    final Optional<SignedBlockAndStateAndSlot> originalChainHead = chainHead;\n+    store\n+        .retrieveBlockAndState(root)\n+        .thenApply(\n+            headBlockAndState ->\n+                headBlockAndState\n+                    .map(head -> SignedBlockAndStateAndSlot.create(head, slot))\n+                    .orElseThrow(\n+                        () ->\n+                            new IllegalStateException(\n+                                String.format(\n+                                    \"Unable to update best block as of slot %s.  Block is unavailable: %s.\",\n+                                    slot, root))))\n+        .thenAccept(headBlock -> updateChainHead(originalChainHead, headBlock))\n+        .reportExceptions();\n+  }\n+\n+  private void updateChainHead(\n+      final Optional<SignedBlockAndStateAndSlot> originalHead,\n+      final SignedBlockAndStateAndSlot newChainHead) {\n     synchronized (this) {\n-      final SignedBeaconBlock newBestBlock = store.getSignedBlock(root);\n-      final BeaconState newBestState = store.getBlockState(root);\n-      if (newBestBlock == null || newBestState == null) {\n-        LOG.warn(\n-            \"Unable to update best block (slot={}, root={}). Corresponding {} unavailable\",\n-            slot,\n-            root,\n-            newBestBlock == null ? \"block\" : \"state\");\n+      if (!chainHead.equals(originalHead)) {\n+        // The chain head has been updated while we were waiting for the newChainHead\n+        // Skip this update to avoid accidentally regressing the chain head\n+        LOG.debug(\"Skipping best block update to avoid potential rollback of the best block.\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzc3OTc1OQ=="}, "originalCommit": {"oid": "bd54c67470aeadf9dd73683c55aa2e47fc35cce7"}, "originalPosition": 36}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3417, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}