{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQzMjU1NDQ2", "number": 2294, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNToxMTowNVrOEK8D5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNToxMTowNVrOEK8D5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5OTA1MjUyOnYy", "diffSide": "RIGHT", "path": "storage/src/main/java/tech/pegasys/teku/storage/store/Store.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNToxMTowNVrOGsRMcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQyMToyMzozNlrOGsdZ9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA3MjI0Mg==", "bodyText": "Is this supposed to be:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  if (baseState == null || baseState.getSlot().equals(checkpoint.getEpochStartSlot())) {\n          \n          \n            \n                  if (baseState != null || baseState.getSlot().equals(checkpoint.getEpochStartSlot())) {\n          \n      \n    \n    \n  \n\nI'm not sure why you would return a null pointer and then try to store that in checkpoint_states.", "url": "https://github.com/ConsenSys/teku/pull/2294#discussion_r449072242", "createdAt": "2020-07-02T15:11:05Z", "author": {"login": "cemozerr"}, "path": "storage/src/main/java/tech/pegasys/teku/storage/store/Store.java", "diffHunk": "@@ -390,21 +379,49 @@ public BeaconState getBlockState(Bytes32 blockRoot) {\n \n   @Override\n   public BeaconState getCheckpointState(Checkpoint checkpoint) {\n+    return getCheckpointStateIfAvailable(checkpoint)\n+        .orElseGet(\n+            () -> {\n+              final BeaconState checkpointState =\n+                  regenerateCheckpointState(checkpoint, this::getBlockState);\n+              lock.writeLock().lock();\n+              try {\n+                checkpoint_states.put(checkpoint, checkpointState);\n+              } finally {\n+                lock.writeLock().unlock();\n+              }\n+              return checkpointState;\n+            });\n+  }\n+\n+  private Optional<BeaconState> getCheckpointStateIfAvailable(final Checkpoint checkpoint) {\n     readLock.lock();\n     try {\n-      return checkpoint_states.get(checkpoint);\n+      final BeaconState state = checkpoint_states.get(checkpoint);\n+      if (state != null) {\n+        checkpointStateRequestCachedCounter.inc();\n+        return Optional.of(state);\n+      } else {\n+        checkpointStateRequestMissCounter.inc();\n+        return Optional.empty();\n+      }\n     } finally {\n       readLock.unlock();\n     }\n   }\n \n-  @Override\n-  public boolean containsCheckpointState(Checkpoint checkpoint) {\n-    readLock.lock();\n+  private BeaconState regenerateCheckpointState(\n+      final Checkpoint checkpoint, Function<Bytes32, BeaconState> getBlockState) {\n     try {\n-      return checkpoint_states.containsKey(checkpoint);\n-    } finally {\n-      readLock.unlock();\n+      final BeaconState baseState = getBlockState.apply(checkpoint.getRoot());\n+      if (baseState == null || baseState.getSlot().equals(checkpoint.getEpochStartSlot())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5198ef9134f4a5407d2426fdbff0a9c085ad0aed"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA3NDQ1MQ==", "bodyText": "Actually I do see why you would check for null and return here, but in that scenario, we still have to deal with the null object in the caller method.", "url": "https://github.com/ConsenSys/teku/pull/2294#discussion_r449074451", "createdAt": "2020-07-02T15:14:36Z", "author": {"login": "cemozerr"}, "path": "storage/src/main/java/tech/pegasys/teku/storage/store/Store.java", "diffHunk": "@@ -390,21 +379,49 @@ public BeaconState getBlockState(Bytes32 blockRoot) {\n \n   @Override\n   public BeaconState getCheckpointState(Checkpoint checkpoint) {\n+    return getCheckpointStateIfAvailable(checkpoint)\n+        .orElseGet(\n+            () -> {\n+              final BeaconState checkpointState =\n+                  regenerateCheckpointState(checkpoint, this::getBlockState);\n+              lock.writeLock().lock();\n+              try {\n+                checkpoint_states.put(checkpoint, checkpointState);\n+              } finally {\n+                lock.writeLock().unlock();\n+              }\n+              return checkpointState;\n+            });\n+  }\n+\n+  private Optional<BeaconState> getCheckpointStateIfAvailable(final Checkpoint checkpoint) {\n     readLock.lock();\n     try {\n-      return checkpoint_states.get(checkpoint);\n+      final BeaconState state = checkpoint_states.get(checkpoint);\n+      if (state != null) {\n+        checkpointStateRequestCachedCounter.inc();\n+        return Optional.of(state);\n+      } else {\n+        checkpointStateRequestMissCounter.inc();\n+        return Optional.empty();\n+      }\n     } finally {\n       readLock.unlock();\n     }\n   }\n \n-  @Override\n-  public boolean containsCheckpointState(Checkpoint checkpoint) {\n-    readLock.lock();\n+  private BeaconState regenerateCheckpointState(\n+      final Checkpoint checkpoint, Function<Bytes32, BeaconState> getBlockState) {\n     try {\n-      return checkpoint_states.containsKey(checkpoint);\n-    } finally {\n-      readLock.unlock();\n+      final BeaconState baseState = getBlockState.apply(checkpoint.getRoot());\n+      if (baseState == null || baseState.getSlot().equals(checkpoint.getEpochStartSlot())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA3MjI0Mg=="}, "originalCommit": {"oid": "5198ef9134f4a5407d2426fdbff0a9c085ad0aed"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI3MjMwOA==", "bodyText": "Good point, I've switched regenerateCheckpointState to return an Optional and flowed that around.", "url": "https://github.com/ConsenSys/teku/pull/2294#discussion_r449272308", "createdAt": "2020-07-02T21:23:36Z", "author": {"login": "ajsutton"}, "path": "storage/src/main/java/tech/pegasys/teku/storage/store/Store.java", "diffHunk": "@@ -390,21 +379,49 @@ public BeaconState getBlockState(Bytes32 blockRoot) {\n \n   @Override\n   public BeaconState getCheckpointState(Checkpoint checkpoint) {\n+    return getCheckpointStateIfAvailable(checkpoint)\n+        .orElseGet(\n+            () -> {\n+              final BeaconState checkpointState =\n+                  regenerateCheckpointState(checkpoint, this::getBlockState);\n+              lock.writeLock().lock();\n+              try {\n+                checkpoint_states.put(checkpoint, checkpointState);\n+              } finally {\n+                lock.writeLock().unlock();\n+              }\n+              return checkpointState;\n+            });\n+  }\n+\n+  private Optional<BeaconState> getCheckpointStateIfAvailable(final Checkpoint checkpoint) {\n     readLock.lock();\n     try {\n-      return checkpoint_states.get(checkpoint);\n+      final BeaconState state = checkpoint_states.get(checkpoint);\n+      if (state != null) {\n+        checkpointStateRequestCachedCounter.inc();\n+        return Optional.of(state);\n+      } else {\n+        checkpointStateRequestMissCounter.inc();\n+        return Optional.empty();\n+      }\n     } finally {\n       readLock.unlock();\n     }\n   }\n \n-  @Override\n-  public boolean containsCheckpointState(Checkpoint checkpoint) {\n-    readLock.lock();\n+  private BeaconState regenerateCheckpointState(\n+      final Checkpoint checkpoint, Function<Bytes32, BeaconState> getBlockState) {\n     try {\n-      return checkpoint_states.containsKey(checkpoint);\n-    } finally {\n-      readLock.unlock();\n+      final BeaconState baseState = getBlockState.apply(checkpoint.getRoot());\n+      if (baseState == null || baseState.getSlot().equals(checkpoint.getEpochStartSlot())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA3MjI0Mg=="}, "originalCommit": {"oid": "5198ef9134f4a5407d2426fdbff0a9c085ad0aed"}, "originalPosition": 152}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3505, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}