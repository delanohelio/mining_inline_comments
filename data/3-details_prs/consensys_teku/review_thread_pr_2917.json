{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk5NjU1ODAy", "number": 2917, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxODowNDo0MlrOErut5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQyMDowNToxNlrOErxYcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0Mjg5NjM2OnYy", "diffSide": "RIGHT", "path": "data/beaconrestapi/src/main/java/tech/pegasys/teku/beaconrestapi/handlers/v1/events/EventSubscriber.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxODowNDo0MlrOHeqYBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxODowNDo0MlrOHeqYBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTkxMzYwNg==", "bodyText": "(nit) We could do this to avoid nesting:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (eventTypes.contains(eventType)) {\n          \n          \n            \n                if (!eventTypes.contains(eventType)) {\n          \n          \n            \n                  return;\n          \n          \n            \n                }", "url": "https://github.com/ConsenSys/teku/pull/2917#discussion_r501913606", "createdAt": "2020-10-08T18:04:42Z", "author": {"login": "cemozerr"}, "path": "data/beaconrestapi/src/main/java/tech/pegasys/teku/beaconrestapi/handlers/v1/events/EventSubscriber.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.beaconrestapi.handlers.v1.events;\n+\n+import io.javalin.http.sse.SseClient;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import tech.pegasys.teku.infrastructure.async.AsyncRunner;\n+\n+public class EventSubscriber {\n+  private static final Logger LOG = LogManager.getLogger();\n+  private static final int MAX_PENDING_EVENTS = 10;\n+  private final List<EventType> eventTypes;\n+  private final SseClient sseClient;\n+  private final Queue<QueuedEvent> queuedEvents;\n+  private final Runnable closeCallback;\n+  private final AtomicBoolean processingQueue;\n+  final AsyncRunner asyncRunner;\n+\n+  public EventSubscriber(\n+      final List<String> eventTypes,\n+      final SseClient sseClient,\n+      final Runnable closeCallback,\n+      final AsyncRunner asyncRunner) {\n+    this.eventTypes = getTopics(eventTypes);\n+    this.sseClient = sseClient;\n+    this.closeCallback = closeCallback;\n+    this.queuedEvents = new ConcurrentLinkedQueue<>();\n+    this.processingQueue = new AtomicBoolean(false);\n+    this.asyncRunner = asyncRunner;\n+    this.sseClient.onClose(closeCallback);\n+  }\n+\n+  public void onEvent(final EventType eventType, final String message) {\n+    if (eventTypes.contains(eventType)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "18cb32be8a374cba65e564fb3f9602026b7d2d4b"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0MjkwNTY0OnYy", "diffSide": "RIGHT", "path": "data/beaconrestapi/src/test/java/tech/pegasys/teku/beaconrestapi/handlers/v1/events/EventSubscriberTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxODowNjo1N1rOHeqdhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxODowNjo1N1rOHeqdhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTkxNTAxMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                for (int i = 0; i < 11; i++) {\n          \n          \n            \n                for (int i = 0; i < MAX_PENDING_EVENTS + 1; i++) {", "url": "https://github.com/ConsenSys/teku/pull/2917#discussion_r501915012", "createdAt": "2020-10-08T18:06:57Z", "author": {"login": "cemozerr"}, "path": "data/beaconrestapi/src/test/java/tech/pegasys/teku/beaconrestapi/handlers/v1/events/EventSubscriberTest.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.beaconrestapi.handlers.v1.events;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import io.javalin.http.Context;\n+import io.javalin.http.sse.SseClient;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.ServletOutputStream;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import tech.pegasys.teku.infrastructure.async.StubAsyncRunner;\n+\n+public class EventSubscriberTest {\n+  private final AsyncContext asyncContext = mock(AsyncContext.class);\n+  private final HttpServletRequest req = mock(HttpServletRequest.class);\n+  private final HttpServletResponse res = mock(HttpServletResponse.class);\n+  private final Runnable onCloseCallback = mock(Runnable.class);\n+  private final ServletResponse servletResponse = mock(ServletResponse.class);\n+  private final ServletOutputStream outputStream = mock(ServletOutputStream.class);\n+\n+  private final Context context = new Context(req, res, Collections.emptyMap());\n+  private final StubAsyncRunner asyncRunner = new StubAsyncRunner();\n+  private final List<EventType> allEventTypes =\n+      Arrays.stream(EventType.values()).collect(Collectors.toList());\n+\n+  private SseClient sseClient;\n+\n+  @BeforeEach\n+  public void setup() throws IOException {\n+    when(req.getAsyncContext()).thenReturn(asyncContext);\n+    when(asyncContext.getResponse()).thenReturn(servletResponse);\n+    when(servletResponse.getOutputStream()).thenReturn(outputStream);\n+    sseClient = new SseClient(context);\n+  }\n+\n+  @Test\n+  void shouldParseEventTypes() {\n+    List<EventType> topics =\n+        EventSubscriber.getTopics(List.of(\"head\", \"chain_reorg\", \"finalized_checkpoint\"));\n+    assertThat(topics)\n+        .containsExactlyInAnyOrder(\n+            EventType.head, EventType.chain_reorg, EventType.finalized_checkpoint);\n+  }\n+\n+  @Test\n+  void shouldFailToParseInvalidEvents() {\n+    assertThrows(IllegalArgumentException.class, () -> EventSubscriber.getTopics(List.of(\"head1\")));\n+  }\n+\n+  @Test\n+  void shouldGetSseClient() {\n+    EventSubscriber eventSubscriber =\n+        new EventSubscriber(List.of(\"head\"), sseClient, onCloseCallback, asyncRunner);\n+    assertThat(eventSubscriber.getSseClient()).isEqualTo(sseClient);\n+  }\n+\n+  @Test\n+  void shouldDisconnectAfterTooManyRequestsAreLogged() {\n+    EventSubscriber eventSubscriber =\n+        new EventSubscriber(List.of(\"head\"), sseClient, onCloseCallback, asyncRunner);\n+\n+    for (int i = 0; i < 11; i++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "18cb32be8a374cba65e564fb3f9602026b7d2d4b"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0MjkwNjYzOnYy", "diffSide": "RIGHT", "path": "data/beaconrestapi/src/main/java/tech/pegasys/teku/beaconrestapi/handlers/v1/events/EventSubscriber.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxODowNzoxNVrOHeqeGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxODowNzoxNVrOHeqeGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTkxNTE2Mw==", "bodyText": "Why not use poll()?\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                          while (queuedEvents.size() > 0) {\n          \n          \n            \n                            QueuedEvent event = queuedEvents.peek();\n          \n          \n            \n                            queuedEvents.remove(event);\n          \n          \n            \n                            sseClient.sendEvent(event.getEventType().name(), event.getMessageData());\n          \n          \n            \n                          }\n          \n          \n            \n                          while (queuedEvents.size() > 0) {\n          \n          \n            \n                            QueuedEvent event = queuedEvents.poll();\n          \n          \n            \n                            if (poll == null) {\n          \n          \n            \n                               break;\n          \n          \n            \n                            }\n          \n          \n            \n                            sseClient.sendEvent(event.getEventType().name(), event.getMessageData());\n          \n          \n            \n                          }", "url": "https://github.com/ConsenSys/teku/pull/2917#discussion_r501915163", "createdAt": "2020-10-08T18:07:15Z", "author": {"login": "mbaxter"}, "path": "data/beaconrestapi/src/main/java/tech/pegasys/teku/beaconrestapi/handlers/v1/events/EventSubscriber.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.beaconrestapi.handlers.v1.events;\n+\n+import io.javalin.http.sse.SseClient;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import tech.pegasys.teku.infrastructure.async.AsyncRunner;\n+\n+public class EventSubscriber {\n+  private static final Logger LOG = LogManager.getLogger();\n+  private static final int MAX_PENDING_EVENTS = 10;\n+  private final List<EventType> eventTypes;\n+  private final SseClient sseClient;\n+  private final Queue<QueuedEvent> queuedEvents;\n+  private final Runnable closeCallback;\n+  private final AtomicBoolean processingQueue;\n+  final AsyncRunner asyncRunner;\n+\n+  public EventSubscriber(\n+      final List<String> eventTypes,\n+      final SseClient sseClient,\n+      final Runnable closeCallback,\n+      final AsyncRunner asyncRunner) {\n+    this.eventTypes = getTopics(eventTypes);\n+    this.sseClient = sseClient;\n+    this.closeCallback = closeCallback;\n+    this.queuedEvents = new ConcurrentLinkedQueue<>();\n+    this.processingQueue = new AtomicBoolean(false);\n+    this.asyncRunner = asyncRunner;\n+    this.sseClient.onClose(closeCallback);\n+  }\n+\n+  public void onEvent(final EventType eventType, final String message) {\n+    if (eventTypes.contains(eventType)) {\n+      if (queuedEvents.size() < MAX_PENDING_EVENTS) {\n+        queuedEvents.add(QueuedEvent.of(eventType, message));\n+        processEventQueue();\n+      } else {\n+        LOG.trace(\"Closing client connection due to exceeding the pending message limit\");\n+        sseClient.ctx.req.getAsyncContext().complete();\n+        closeCallback.run();\n+      }\n+    }\n+  }\n+\n+  static List<EventType> getTopics(List<String> topics) {\n+    return topics.stream().map(EventType::valueOf).collect(Collectors.toList());\n+  }\n+\n+  public SseClient getSseClient() {\n+    return sseClient;\n+  }\n+\n+  private void processEventQueue() {\n+    if (!processingQueue.compareAndSet(false, true)) {\n+      // any queue processing in progress will clear the queue, no need to run another instance\n+      return;\n+    }\n+    asyncRunner\n+        .runAsync(\n+            () -> {\n+              LOG.trace(\n+                  \"Processing queue with {} elements for event client {}\",\n+                  queuedEvents.size(),\n+                  sseClient.hashCode());\n+              while (queuedEvents.size() > 0) {\n+                QueuedEvent event = queuedEvents.peek();\n+                queuedEvents.remove(event);\n+                sseClient.sendEvent(event.getEventType().name(), event.getMessageData());\n+              }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "18cb32be8a374cba65e564fb3f9602026b7d2d4b"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0MjkxODg2OnYy", "diffSide": "RIGHT", "path": "data/beaconrestapi/src/main/java/tech/pegasys/teku/beaconrestapi/handlers/v1/events/EventSubscriber.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxODoxMDowOFrOHeqlQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxOToxMTo1MFrOHesyog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTkxNjk5NA==", "bodyText": "Probably safer to reset this with:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                          processingQueue.set(false);\n          \n          \n            \n                        })\n          \n          \n            \n                    .reportExceptions();\n          \n          \n            \n                        })\n          \n          \n            \n                    .alwaysRun(() -> processingQueue.set(false))\n          \n          \n            \n                    .reportExceptions();", "url": "https://github.com/ConsenSys/teku/pull/2917#discussion_r501916994", "createdAt": "2020-10-08T18:10:08Z", "author": {"login": "mbaxter"}, "path": "data/beaconrestapi/src/main/java/tech/pegasys/teku/beaconrestapi/handlers/v1/events/EventSubscriber.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.beaconrestapi.handlers.v1.events;\n+\n+import io.javalin.http.sse.SseClient;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import tech.pegasys.teku.infrastructure.async.AsyncRunner;\n+\n+public class EventSubscriber {\n+  private static final Logger LOG = LogManager.getLogger();\n+  private static final int MAX_PENDING_EVENTS = 10;\n+  private final List<EventType> eventTypes;\n+  private final SseClient sseClient;\n+  private final Queue<QueuedEvent> queuedEvents;\n+  private final Runnable closeCallback;\n+  private final AtomicBoolean processingQueue;\n+  final AsyncRunner asyncRunner;\n+\n+  public EventSubscriber(\n+      final List<String> eventTypes,\n+      final SseClient sseClient,\n+      final Runnable closeCallback,\n+      final AsyncRunner asyncRunner) {\n+    this.eventTypes = getTopics(eventTypes);\n+    this.sseClient = sseClient;\n+    this.closeCallback = closeCallback;\n+    this.queuedEvents = new ConcurrentLinkedQueue<>();\n+    this.processingQueue = new AtomicBoolean(false);\n+    this.asyncRunner = asyncRunner;\n+    this.sseClient.onClose(closeCallback);\n+  }\n+\n+  public void onEvent(final EventType eventType, final String message) {\n+    if (eventTypes.contains(eventType)) {\n+      if (queuedEvents.size() < MAX_PENDING_EVENTS) {\n+        queuedEvents.add(QueuedEvent.of(eventType, message));\n+        processEventQueue();\n+      } else {\n+        LOG.trace(\"Closing client connection due to exceeding the pending message limit\");\n+        sseClient.ctx.req.getAsyncContext().complete();\n+        closeCallback.run();\n+      }\n+    }\n+  }\n+\n+  static List<EventType> getTopics(List<String> topics) {\n+    return topics.stream().map(EventType::valueOf).collect(Collectors.toList());\n+  }\n+\n+  public SseClient getSseClient() {\n+    return sseClient;\n+  }\n+\n+  private void processEventQueue() {\n+    if (!processingQueue.compareAndSet(false, true)) {\n+      // any queue processing in progress will clear the queue, no need to run another instance\n+      return;\n+    }\n+    asyncRunner\n+        .runAsync(\n+            () -> {\n+              LOG.trace(\n+                  \"Processing queue with {} elements for event client {}\",\n+                  queuedEvents.size(),\n+                  sseClient.hashCode());\n+              while (queuedEvents.size() > 0) {\n+                QueuedEvent event = queuedEvents.peek();\n+                queuedEvents.remove(event);\n+                sseClient.sendEvent(event.getEventType().name(), event.getMessageData());\n+              }\n+              processingQueue.set(false);\n+            })\n+        .reportExceptions();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "18cb32be8a374cba65e564fb3f9602026b7d2d4b"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTkxNzc1NA==", "bodyText": "Probably worth adding a test where sseClient.sendEvent throws to make sure we don't get stuck.", "url": "https://github.com/ConsenSys/teku/pull/2917#discussion_r501917754", "createdAt": "2020-10-08T18:11:20Z", "author": {"login": "mbaxter"}, "path": "data/beaconrestapi/src/main/java/tech/pegasys/teku/beaconrestapi/handlers/v1/events/EventSubscriber.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.beaconrestapi.handlers.v1.events;\n+\n+import io.javalin.http.sse.SseClient;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import tech.pegasys.teku.infrastructure.async.AsyncRunner;\n+\n+public class EventSubscriber {\n+  private static final Logger LOG = LogManager.getLogger();\n+  private static final int MAX_PENDING_EVENTS = 10;\n+  private final List<EventType> eventTypes;\n+  private final SseClient sseClient;\n+  private final Queue<QueuedEvent> queuedEvents;\n+  private final Runnable closeCallback;\n+  private final AtomicBoolean processingQueue;\n+  final AsyncRunner asyncRunner;\n+\n+  public EventSubscriber(\n+      final List<String> eventTypes,\n+      final SseClient sseClient,\n+      final Runnable closeCallback,\n+      final AsyncRunner asyncRunner) {\n+    this.eventTypes = getTopics(eventTypes);\n+    this.sseClient = sseClient;\n+    this.closeCallback = closeCallback;\n+    this.queuedEvents = new ConcurrentLinkedQueue<>();\n+    this.processingQueue = new AtomicBoolean(false);\n+    this.asyncRunner = asyncRunner;\n+    this.sseClient.onClose(closeCallback);\n+  }\n+\n+  public void onEvent(final EventType eventType, final String message) {\n+    if (eventTypes.contains(eventType)) {\n+      if (queuedEvents.size() < MAX_PENDING_EVENTS) {\n+        queuedEvents.add(QueuedEvent.of(eventType, message));\n+        processEventQueue();\n+      } else {\n+        LOG.trace(\"Closing client connection due to exceeding the pending message limit\");\n+        sseClient.ctx.req.getAsyncContext().complete();\n+        closeCallback.run();\n+      }\n+    }\n+  }\n+\n+  static List<EventType> getTopics(List<String> topics) {\n+    return topics.stream().map(EventType::valueOf).collect(Collectors.toList());\n+  }\n+\n+  public SseClient getSseClient() {\n+    return sseClient;\n+  }\n+\n+  private void processEventQueue() {\n+    if (!processingQueue.compareAndSet(false, true)) {\n+      // any queue processing in progress will clear the queue, no need to run another instance\n+      return;\n+    }\n+    asyncRunner\n+        .runAsync(\n+            () -> {\n+              LOG.trace(\n+                  \"Processing queue with {} elements for event client {}\",\n+                  queuedEvents.size(),\n+                  sseClient.hashCode());\n+              while (queuedEvents.size() > 0) {\n+                QueuedEvent event = queuedEvents.peek();\n+                queuedEvents.remove(event);\n+                sseClient.sendEvent(event.getEventType().name(), event.getMessageData());\n+              }\n+              processingQueue.set(false);\n+            })\n+        .reportExceptions();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTkxNjk5NA=="}, "originalCommit": {"oid": "18cb32be8a374cba65e564fb3f9602026b7d2d4b"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTk1MzE4Ng==", "bodyText": "It doesn't actually throw, I found out while writing this - i'll remove the .reportExceptions, and put in the alwaysRun just in case anything weird happens.\nIf the queue fills and we disconnect the client it'll reconnect and become a new client, so it's not the end of the world I guess.", "url": "https://github.com/ConsenSys/teku/pull/2917#discussion_r501953186", "createdAt": "2020-10-08T19:11:50Z", "author": {"login": "rolfyone"}, "path": "data/beaconrestapi/src/main/java/tech/pegasys/teku/beaconrestapi/handlers/v1/events/EventSubscriber.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.beaconrestapi.handlers.v1.events;\n+\n+import io.javalin.http.sse.SseClient;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import tech.pegasys.teku.infrastructure.async.AsyncRunner;\n+\n+public class EventSubscriber {\n+  private static final Logger LOG = LogManager.getLogger();\n+  private static final int MAX_PENDING_EVENTS = 10;\n+  private final List<EventType> eventTypes;\n+  private final SseClient sseClient;\n+  private final Queue<QueuedEvent> queuedEvents;\n+  private final Runnable closeCallback;\n+  private final AtomicBoolean processingQueue;\n+  final AsyncRunner asyncRunner;\n+\n+  public EventSubscriber(\n+      final List<String> eventTypes,\n+      final SseClient sseClient,\n+      final Runnable closeCallback,\n+      final AsyncRunner asyncRunner) {\n+    this.eventTypes = getTopics(eventTypes);\n+    this.sseClient = sseClient;\n+    this.closeCallback = closeCallback;\n+    this.queuedEvents = new ConcurrentLinkedQueue<>();\n+    this.processingQueue = new AtomicBoolean(false);\n+    this.asyncRunner = asyncRunner;\n+    this.sseClient.onClose(closeCallback);\n+  }\n+\n+  public void onEvent(final EventType eventType, final String message) {\n+    if (eventTypes.contains(eventType)) {\n+      if (queuedEvents.size() < MAX_PENDING_EVENTS) {\n+        queuedEvents.add(QueuedEvent.of(eventType, message));\n+        processEventQueue();\n+      } else {\n+        LOG.trace(\"Closing client connection due to exceeding the pending message limit\");\n+        sseClient.ctx.req.getAsyncContext().complete();\n+        closeCallback.run();\n+      }\n+    }\n+  }\n+\n+  static List<EventType> getTopics(List<String> topics) {\n+    return topics.stream().map(EventType::valueOf).collect(Collectors.toList());\n+  }\n+\n+  public SseClient getSseClient() {\n+    return sseClient;\n+  }\n+\n+  private void processEventQueue() {\n+    if (!processingQueue.compareAndSet(false, true)) {\n+      // any queue processing in progress will clear the queue, no need to run another instance\n+      return;\n+    }\n+    asyncRunner\n+        .runAsync(\n+            () -> {\n+              LOG.trace(\n+                  \"Processing queue with {} elements for event client {}\",\n+                  queuedEvents.size(),\n+                  sseClient.hashCode());\n+              while (queuedEvents.size() > 0) {\n+                QueuedEvent event = queuedEvents.peek();\n+                queuedEvents.remove(event);\n+                sseClient.sendEvent(event.getEventType().name(), event.getMessageData());\n+              }\n+              processingQueue.set(false);\n+            })\n+        .reportExceptions();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTkxNjk5NA=="}, "originalCommit": {"oid": "18cb32be8a374cba65e564fb3f9602026b7d2d4b"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0MjkzODg5OnYy", "diffSide": "RIGHT", "path": "data/beaconrestapi/src/test/java/tech/pegasys/teku/beaconrestapi/handlers/v1/events/EventSubscriberTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxODoxNDo1MVrOHeqwpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxODoxNDo1MVrOHeqwpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTkxOTkxMQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                for (int i = 0; i < 11; i++) {\n          \n          \n            \n                for (int i = 0; i < MAX_PENDING_EVENTS + 1; i++) {", "url": "https://github.com/ConsenSys/teku/pull/2917#discussion_r501919911", "createdAt": "2020-10-08T18:14:51Z", "author": {"login": "mbaxter"}, "path": "data/beaconrestapi/src/test/java/tech/pegasys/teku/beaconrestapi/handlers/v1/events/EventSubscriberTest.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.beaconrestapi.handlers.v1.events;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import io.javalin.http.Context;\n+import io.javalin.http.sse.SseClient;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.ServletOutputStream;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import tech.pegasys.teku.infrastructure.async.StubAsyncRunner;\n+\n+public class EventSubscriberTest {\n+  private final AsyncContext asyncContext = mock(AsyncContext.class);\n+  private final HttpServletRequest req = mock(HttpServletRequest.class);\n+  private final HttpServletResponse res = mock(HttpServletResponse.class);\n+  private final Runnable onCloseCallback = mock(Runnable.class);\n+  private final ServletResponse servletResponse = mock(ServletResponse.class);\n+  private final ServletOutputStream outputStream = mock(ServletOutputStream.class);\n+\n+  private final Context context = new Context(req, res, Collections.emptyMap());\n+  private final StubAsyncRunner asyncRunner = new StubAsyncRunner();\n+  private final List<EventType> allEventTypes =\n+      Arrays.stream(EventType.values()).collect(Collectors.toList());\n+\n+  private SseClient sseClient;\n+\n+  @BeforeEach\n+  public void setup() throws IOException {\n+    when(req.getAsyncContext()).thenReturn(asyncContext);\n+    when(asyncContext.getResponse()).thenReturn(servletResponse);\n+    when(servletResponse.getOutputStream()).thenReturn(outputStream);\n+    sseClient = new SseClient(context);\n+  }\n+\n+  @Test\n+  void shouldParseEventTypes() {\n+    List<EventType> topics =\n+        EventSubscriber.getTopics(List.of(\"head\", \"chain_reorg\", \"finalized_checkpoint\"));\n+    assertThat(topics)\n+        .containsExactlyInAnyOrder(\n+            EventType.head, EventType.chain_reorg, EventType.finalized_checkpoint);\n+  }\n+\n+  @Test\n+  void shouldFailToParseInvalidEvents() {\n+    assertThrows(IllegalArgumentException.class, () -> EventSubscriber.getTopics(List.of(\"head1\")));\n+  }\n+\n+  @Test\n+  void shouldGetSseClient() {\n+    EventSubscriber eventSubscriber =\n+        new EventSubscriber(List.of(\"head\"), sseClient, onCloseCallback, asyncRunner);\n+    assertThat(eventSubscriber.getSseClient()).isEqualTo(sseClient);\n+  }\n+\n+  @Test\n+  void shouldDisconnectAfterTooManyRequestsAreLogged() {\n+    EventSubscriber eventSubscriber =\n+        new EventSubscriber(List.of(\"head\"), sseClient, onCloseCallback, asyncRunner);\n+\n+    for (int i = 0; i < 11; i++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "18cb32be8a374cba65e564fb3f9602026b7d2d4b"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0MjkzOTc2OnYy", "diffSide": "RIGHT", "path": "data/beaconrestapi/src/test/java/tech/pegasys/teku/beaconrestapi/handlers/v1/events/EventSubscriberTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxODoxNTowNFrOHeqxKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxODoxNTowNFrOHeqxKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTkyMDA0Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                for (int i = 0; i < 10; i++) {\n          \n          \n            \n                for (int i = 0; i < MAX_PENDING_EVENTS; i++) {", "url": "https://github.com/ConsenSys/teku/pull/2917#discussion_r501920043", "createdAt": "2020-10-08T18:15:04Z", "author": {"login": "mbaxter"}, "path": "data/beaconrestapi/src/test/java/tech/pegasys/teku/beaconrestapi/handlers/v1/events/EventSubscriberTest.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.beaconrestapi.handlers.v1.events;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import io.javalin.http.Context;\n+import io.javalin.http.sse.SseClient;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.ServletOutputStream;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import tech.pegasys.teku.infrastructure.async.StubAsyncRunner;\n+\n+public class EventSubscriberTest {\n+  private final AsyncContext asyncContext = mock(AsyncContext.class);\n+  private final HttpServletRequest req = mock(HttpServletRequest.class);\n+  private final HttpServletResponse res = mock(HttpServletResponse.class);\n+  private final Runnable onCloseCallback = mock(Runnable.class);\n+  private final ServletResponse servletResponse = mock(ServletResponse.class);\n+  private final ServletOutputStream outputStream = mock(ServletOutputStream.class);\n+\n+  private final Context context = new Context(req, res, Collections.emptyMap());\n+  private final StubAsyncRunner asyncRunner = new StubAsyncRunner();\n+  private final List<EventType> allEventTypes =\n+      Arrays.stream(EventType.values()).collect(Collectors.toList());\n+\n+  private SseClient sseClient;\n+\n+  @BeforeEach\n+  public void setup() throws IOException {\n+    when(req.getAsyncContext()).thenReturn(asyncContext);\n+    when(asyncContext.getResponse()).thenReturn(servletResponse);\n+    when(servletResponse.getOutputStream()).thenReturn(outputStream);\n+    sseClient = new SseClient(context);\n+  }\n+\n+  @Test\n+  void shouldParseEventTypes() {\n+    List<EventType> topics =\n+        EventSubscriber.getTopics(List.of(\"head\", \"chain_reorg\", \"finalized_checkpoint\"));\n+    assertThat(topics)\n+        .containsExactlyInAnyOrder(\n+            EventType.head, EventType.chain_reorg, EventType.finalized_checkpoint);\n+  }\n+\n+  @Test\n+  void shouldFailToParseInvalidEvents() {\n+    assertThrows(IllegalArgumentException.class, () -> EventSubscriber.getTopics(List.of(\"head1\")));\n+  }\n+\n+  @Test\n+  void shouldGetSseClient() {\n+    EventSubscriber eventSubscriber =\n+        new EventSubscriber(List.of(\"head\"), sseClient, onCloseCallback, asyncRunner);\n+    assertThat(eventSubscriber.getSseClient()).isEqualTo(sseClient);\n+  }\n+\n+  @Test\n+  void shouldDisconnectAfterTooManyRequestsAreLogged() {\n+    EventSubscriber eventSubscriber =\n+        new EventSubscriber(List.of(\"head\"), sseClient, onCloseCallback, asyncRunner);\n+\n+    for (int i = 0; i < 11; i++) {\n+      verify(onCloseCallback, never()).run();\n+      eventSubscriber.onEvent(EventType.head, \"test\");\n+    }\n+    verify(onCloseCallback).run();\n+  }\n+\n+  @Test\n+  void shouldSubscribeToMultipleEventsSuccessfully() throws IOException {\n+    EventSubscriber eventSubscriber =\n+        new EventSubscriber(\n+            allEventTypes.stream().map(EventType::name).collect(Collectors.toList()),\n+            sseClient,\n+            onCloseCallback,\n+            asyncRunner);\n+    allEventTypes.forEach(eventType -> eventSubscriber.onEvent(eventType, \"test\"));\n+    assertThat(asyncRunner.countDelayedActions()).isEqualTo(1);\n+    asyncRunner.executeQueuedActions();\n+    verify(outputStream, times(allEventTypes.size())).print(anyString());\n+  }\n+\n+  @Test\n+  void shouldNotDisconnectIfQueueProcessingCatchesUp() throws IOException {\n+    EventSubscriber eventSubscriber =\n+        new EventSubscriber(List.of(\"head\"), sseClient, onCloseCallback, asyncRunner);\n+\n+    for (int i = 0; i < 10; i++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "18cb32be8a374cba65e564fb3f9602026b7d2d4b"}, "originalPosition": 118}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0Mjk0MDYyOnYy", "diffSide": "RIGHT", "path": "data/beaconrestapi/src/test/java/tech/pegasys/teku/beaconrestapi/handlers/v1/events/EventSubscriberTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxODoxNToxNFrOHeqxmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxODoxNToxNFrOHeqxmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTkyMDE1NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                for (int i = 0; i < 10; i++) {\n          \n          \n            \n                for (int i = 0; i < MAX_PENDING_EVENTS; i++) {", "url": "https://github.com/ConsenSys/teku/pull/2917#discussion_r501920155", "createdAt": "2020-10-08T18:15:14Z", "author": {"login": "mbaxter"}, "path": "data/beaconrestapi/src/test/java/tech/pegasys/teku/beaconrestapi/handlers/v1/events/EventSubscriberTest.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.beaconrestapi.handlers.v1.events;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.mockito.ArgumentMatchers.anyString;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.never;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import io.javalin.http.Context;\n+import io.javalin.http.sse.SseClient;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import javax.servlet.AsyncContext;\n+import javax.servlet.ServletOutputStream;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.EnumSource;\n+import tech.pegasys.teku.infrastructure.async.StubAsyncRunner;\n+\n+public class EventSubscriberTest {\n+  private final AsyncContext asyncContext = mock(AsyncContext.class);\n+  private final HttpServletRequest req = mock(HttpServletRequest.class);\n+  private final HttpServletResponse res = mock(HttpServletResponse.class);\n+  private final Runnable onCloseCallback = mock(Runnable.class);\n+  private final ServletResponse servletResponse = mock(ServletResponse.class);\n+  private final ServletOutputStream outputStream = mock(ServletOutputStream.class);\n+\n+  private final Context context = new Context(req, res, Collections.emptyMap());\n+  private final StubAsyncRunner asyncRunner = new StubAsyncRunner();\n+  private final List<EventType> allEventTypes =\n+      Arrays.stream(EventType.values()).collect(Collectors.toList());\n+\n+  private SseClient sseClient;\n+\n+  @BeforeEach\n+  public void setup() throws IOException {\n+    when(req.getAsyncContext()).thenReturn(asyncContext);\n+    when(asyncContext.getResponse()).thenReturn(servletResponse);\n+    when(servletResponse.getOutputStream()).thenReturn(outputStream);\n+    sseClient = new SseClient(context);\n+  }\n+\n+  @Test\n+  void shouldParseEventTypes() {\n+    List<EventType> topics =\n+        EventSubscriber.getTopics(List.of(\"head\", \"chain_reorg\", \"finalized_checkpoint\"));\n+    assertThat(topics)\n+        .containsExactlyInAnyOrder(\n+            EventType.head, EventType.chain_reorg, EventType.finalized_checkpoint);\n+  }\n+\n+  @Test\n+  void shouldFailToParseInvalidEvents() {\n+    assertThrows(IllegalArgumentException.class, () -> EventSubscriber.getTopics(List.of(\"head1\")));\n+  }\n+\n+  @Test\n+  void shouldGetSseClient() {\n+    EventSubscriber eventSubscriber =\n+        new EventSubscriber(List.of(\"head\"), sseClient, onCloseCallback, asyncRunner);\n+    assertThat(eventSubscriber.getSseClient()).isEqualTo(sseClient);\n+  }\n+\n+  @Test\n+  void shouldDisconnectAfterTooManyRequestsAreLogged() {\n+    EventSubscriber eventSubscriber =\n+        new EventSubscriber(List.of(\"head\"), sseClient, onCloseCallback, asyncRunner);\n+\n+    for (int i = 0; i < 11; i++) {\n+      verify(onCloseCallback, never()).run();\n+      eventSubscriber.onEvent(EventType.head, \"test\");\n+    }\n+    verify(onCloseCallback).run();\n+  }\n+\n+  @Test\n+  void shouldSubscribeToMultipleEventsSuccessfully() throws IOException {\n+    EventSubscriber eventSubscriber =\n+        new EventSubscriber(\n+            allEventTypes.stream().map(EventType::name).collect(Collectors.toList()),\n+            sseClient,\n+            onCloseCallback,\n+            asyncRunner);\n+    allEventTypes.forEach(eventType -> eventSubscriber.onEvent(eventType, \"test\"));\n+    assertThat(asyncRunner.countDelayedActions()).isEqualTo(1);\n+    asyncRunner.executeQueuedActions();\n+    verify(outputStream, times(allEventTypes.size())).print(anyString());\n+  }\n+\n+  @Test\n+  void shouldNotDisconnectIfQueueProcessingCatchesUp() throws IOException {\n+    EventSubscriber eventSubscriber =\n+        new EventSubscriber(List.of(\"head\"), sseClient, onCloseCallback, asyncRunner);\n+\n+    for (int i = 0; i < 10; i++) {\n+      eventSubscriber.onEvent(EventType.head, \"test\");\n+    }\n+    asyncRunner.executeQueuedActions();\n+    verify(outputStream, times(10)).print(anyString());\n+\n+    for (int i = 0; i < 10; i++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "18cb32be8a374cba65e564fb3f9602026b7d2d4b"}, "originalPosition": 124}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0Mjk1NjUzOnYy", "diffSide": "RIGHT", "path": "data/beaconrestapi/src/main/java/tech/pegasys/teku/beaconrestapi/handlers/v1/events/EventSubscriber.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxODoxOToxMVrOHeq7Ow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxODoxOToxMVrOHeq7Ow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTkyMjYxOQ==", "bodyText": "(nit) This helper might make more sense on EventType.", "url": "https://github.com/ConsenSys/teku/pull/2917#discussion_r501922619", "createdAt": "2020-10-08T18:19:11Z", "author": {"login": "mbaxter"}, "path": "data/beaconrestapi/src/main/java/tech/pegasys/teku/beaconrestapi/handlers/v1/events/EventSubscriber.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.beaconrestapi.handlers.v1.events;\n+\n+import io.javalin.http.sse.SseClient;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import tech.pegasys.teku.infrastructure.async.AsyncRunner;\n+\n+public class EventSubscriber {\n+  private static final Logger LOG = LogManager.getLogger();\n+  private static final int MAX_PENDING_EVENTS = 10;\n+  private final List<EventType> eventTypes;\n+  private final SseClient sseClient;\n+  private final Queue<QueuedEvent> queuedEvents;\n+  private final Runnable closeCallback;\n+  private final AtomicBoolean processingQueue;\n+  final AsyncRunner asyncRunner;\n+\n+  public EventSubscriber(\n+      final List<String> eventTypes,\n+      final SseClient sseClient,\n+      final Runnable closeCallback,\n+      final AsyncRunner asyncRunner) {\n+    this.eventTypes = getTopics(eventTypes);\n+    this.sseClient = sseClient;\n+    this.closeCallback = closeCallback;\n+    this.queuedEvents = new ConcurrentLinkedQueue<>();\n+    this.processingQueue = new AtomicBoolean(false);\n+    this.asyncRunner = asyncRunner;\n+    this.sseClient.onClose(closeCallback);\n+  }\n+\n+  public void onEvent(final EventType eventType, final String message) {\n+    if (eventTypes.contains(eventType)) {\n+      if (queuedEvents.size() < MAX_PENDING_EVENTS) {\n+        queuedEvents.add(QueuedEvent.of(eventType, message));\n+        processEventQueue();\n+      } else {\n+        LOG.trace(\"Closing client connection due to exceeding the pending message limit\");\n+        sseClient.ctx.req.getAsyncContext().complete();\n+        closeCallback.run();\n+      }\n+    }\n+  }\n+\n+  static List<EventType> getTopics(List<String> topics) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "18cb32be8a374cba65e564fb3f9602026b7d2d4b"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0Mjk2NDE4OnYy", "diffSide": "RIGHT", "path": "data/beaconrestapi/src/main/java/tech/pegasys/teku/beaconrestapi/handlers/v1/events/QueuedEvent.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxODoyMTowM1rOHeq_sQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQxODoyMTowM1rOHeq_sQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTkyMzc2MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public QueuedEvent(final EventType eventType, final String messageData) {\n          \n          \n            \n              private QueuedEvent(final EventType eventType, final String messageData) {", "url": "https://github.com/ConsenSys/teku/pull/2917#discussion_r501923761", "createdAt": "2020-10-08T18:21:03Z", "author": {"login": "mbaxter"}, "path": "data/beaconrestapi/src/main/java/tech/pegasys/teku/beaconrestapi/handlers/v1/events/QueuedEvent.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.beaconrestapi.handlers.v1.events;\n+\n+import java.util.Objects;\n+\n+public class QueuedEvent {\n+  private final EventType eventType;\n+  private final String messageData;\n+\n+  public QueuedEvent(final EventType eventType, final String messageData) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "18cb32be8a374cba65e564fb3f9602026b7d2d4b"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0MzMzMjk5OnYy", "diffSide": "RIGHT", "path": "data/beaconrestapi/src/main/java/tech/pegasys/teku/beaconrestapi/handlers/v1/events/EventSubscriber.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQyMDowNToxNlrOHeuhbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQyMDowNToxNlrOHeuhbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTk4MTU1MA==", "bodyText": "This actually leaves a race condition open.  The broken sequence would be:\n\nThread A adds an event to the queue\nThread A calls processEventQueue and schedules the next event\nThread B starts processing the next event and sends all events in the queue, but hasn't yet st processingQueue to false\nThread C adds an event to the queue\nThread C calls processEventQueue which doesn't schedule another event because one is in progress\nThread B sets processingQueue to false\n\nThe event from thread C is now left in the queue with no send task scheduled for it.\nI'd suggest just using EventThread to queue the send tasks and always schedule another task.  If there is nothing in the queue to publish they will just exit immediately.", "url": "https://github.com/ConsenSys/teku/pull/2917#discussion_r501981550", "createdAt": "2020-10-08T20:05:16Z", "author": {"login": "ajsutton"}, "path": "data/beaconrestapi/src/main/java/tech/pegasys/teku/beaconrestapi/handlers/v1/events/EventSubscriber.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.beaconrestapi.handlers.v1.events;\n+\n+import io.javalin.http.sse.SseClient;\n+import java.util.List;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import tech.pegasys.teku.infrastructure.async.AsyncRunner;\n+\n+public class EventSubscriber {\n+  private static final Logger LOG = LogManager.getLogger();\n+  static final int MAX_PENDING_EVENTS = 10;\n+  private final List<EventType> eventTypes;\n+  private final SseClient sseClient;\n+  private final Queue<QueuedEvent> queuedEvents;\n+  private final Runnable closeCallback;\n+  private final AtomicBoolean processingQueue;\n+  final AsyncRunner asyncRunner;\n+\n+  public EventSubscriber(\n+      final List<String> eventTypes,\n+      final SseClient sseClient,\n+      final Runnable closeCallback,\n+      final AsyncRunner asyncRunner) {\n+    this.eventTypes = EventType.getTopics(eventTypes);\n+    this.sseClient = sseClient;\n+    this.closeCallback = closeCallback;\n+    this.queuedEvents = new ConcurrentLinkedQueue<>();\n+    this.processingQueue = new AtomicBoolean(false);\n+    this.asyncRunner = asyncRunner;\n+    this.sseClient.onClose(closeCallback);\n+  }\n+\n+  public void onEvent(final EventType eventType, final String message) {\n+    if (!eventTypes.contains(eventType)) {\n+      return;\n+    }\n+    if (queuedEvents.size() < MAX_PENDING_EVENTS) {\n+      queuedEvents.add(QueuedEvent.of(eventType, message));\n+      processEventQueue();\n+    } else {\n+      LOG.trace(\"Closing client connection due to exceeding the pending message limit\");\n+      sseClient.ctx.req.getAsyncContext().complete();\n+      closeCallback.run();\n+    }\n+  }\n+\n+  public SseClient getSseClient() {\n+    return sseClient;\n+  }\n+\n+  private void processEventQueue() {\n+    if (!processingQueue.compareAndSet(false, true)) {\n+      // any queue processing in progress will clear the queue, no need to run another instance\n+      return;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ec1ad9176737cc7b228dfac0ce554cfcd5328cb"}, "originalPosition": 71}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3156, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}