{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI4NTQxNjEy", "number": 2062, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwMDozMjowNFrOEDq6nQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMjoyMTowOFrOEEepjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMjg0MzE3OnYy", "diffSide": "RIGHT", "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/ForkChoiceUtil.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwMDozMjowNFrOGg0zFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNToyOTozM1rOGhQPYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA3MjY2MQ==", "bodyText": "Rather than throwing UnknownBlockRootException which is then caught as a routine result in each place that calls this - would be better to return Optional from here.\nreturn forkChoiceStrategy\n        .blockSlot(root)\n        .flatMap(\n            blockSlot -> {\n              if (blockSlot.compareTo(slot) > 0) {\n                return get_ancestor(\n                    forkChoiceStrategy,\n                    forkChoiceStrategy.blockParentRoot(root).orElseThrow(),\n                    slot);\n              } else if (blockSlot.equals(slot)) {\n                return Optional.of(root);\n              } else {\n                // root is older than the queried slot, thus a skip slot. Return earliest root prior\n                // to slot.\n                return Optional.of(root);\n              }\n            });", "url": "https://github.com/ConsenSys/teku/pull/2062#discussion_r437072661", "createdAt": "2020-06-09T00:32:04Z", "author": {"login": "ajsutton"}, "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/ForkChoiceUtil.java", "diffHunk": "@@ -76,18 +76,27 @@ public static UnsignedLong compute_slots_since_epoch_start(UnsignedLong slot) {\n   /**\n    * Get the ancestor of ``block`` with slot number ``slot``.\n    *\n-   * @param store\n+   * @param forkChoiceStrategy\n    * @param root\n    * @param slot\n    * @return\n    * @see\n    *     <a>https://github.com/ethereum/eth2.0-specs/blob/v0.10.1/specs/phase0/fork-choice.md#get_ancestor</a>\n    */\n-  private static Bytes32 get_ancestor(ReadOnlyStore store, Bytes32 root, UnsignedLong slot) {\n-    BeaconBlock block = store.getBlock(root);\n-    if (block.getSlot().compareTo(slot) > 0) {\n-      return get_ancestor(store, block.getParent_root(), slot);\n-    } else if (block.getSlot().equals(slot)) {\n+  private static Bytes32 get_ancestor(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd7aec30801173c9f8bca144f82f449c304fb9a2"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzUyMjI3NQ==", "bodyText": "Makes sense. Done.", "url": "https://github.com/ConsenSys/teku/pull/2062#discussion_r437522275", "createdAt": "2020-06-09T15:29:33Z", "author": {"login": "cemozerr"}, "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/ForkChoiceUtil.java", "diffHunk": "@@ -76,18 +76,27 @@ public static UnsignedLong compute_slots_since_epoch_start(UnsignedLong slot) {\n   /**\n    * Get the ancestor of ``block`` with slot number ``slot``.\n    *\n-   * @param store\n+   * @param forkChoiceStrategy\n    * @param root\n    * @param slot\n    * @return\n    * @see\n    *     <a>https://github.com/ethereum/eth2.0-specs/blob/v0.10.1/specs/phase0/fork-choice.md#get_ancestor</a>\n    */\n-  private static Bytes32 get_ancestor(ReadOnlyStore store, Bytes32 root, UnsignedLong slot) {\n-    BeaconBlock block = store.getBlock(root);\n-    if (block.getSlot().compareTo(slot) > 0) {\n-      return get_ancestor(store, block.getParent_root(), slot);\n-    } else if (block.getSlot().equals(slot)) {\n+  private static Bytes32 get_ancestor(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA3MjY2MQ=="}, "originalCommit": {"oid": "cd7aec30801173c9f8bca144f82f449c304fb9a2"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMjg0NDkwOnYy", "diffSide": "RIGHT", "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/ForkChoiceUtil.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwMDozMjo1N1rOGg00Gg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNToyOTo0MFrOGhQPqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA3MjkyMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                try {\n          \n          \n            \n                  return get_ancestor(forkChoiceStrategy, new_justified_checkpoint.getRoot(), justified_slot)\n          \n          \n            \n                      .equals(store.getJustifiedCheckpoint().getRoot());\n          \n          \n            \n                } catch (UnknownBlockRootException e) {\n          \n          \n            \n                  return false;\n          \n          \n            \n                }\n          \n          \n            \n            return get_ancestor(forkChoiceStrategy, new_justified_checkpoint.getRoot(), justified_slot)\n          \n          \n            \n                    .map(ancestorRoot -> ancestorRoot.equals(store.getJustifiedCheckpoint().getRoot()))\n          \n          \n            \n                    .orElse(false);", "url": "https://github.com/ConsenSys/teku/pull/2062#discussion_r437072922", "createdAt": "2020-06-09T00:32:57Z", "author": {"login": "ajsutton"}, "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/ForkChoiceUtil.java", "diffHunk": "@@ -112,8 +123,12 @@ private static boolean should_update_justified_checkpoint(\n \n     UnsignedLong justified_slot =\n         compute_start_slot_at_epoch(store.getJustifiedCheckpoint().getEpoch());\n-    return get_ancestor(store, new_justified_checkpoint.getRoot(), justified_slot)\n-        .equals(store.getJustifiedCheckpoint().getRoot());\n+    try {\n+      return get_ancestor(forkChoiceStrategy, new_justified_checkpoint.getRoot(), justified_slot)\n+          .equals(store.getJustifiedCheckpoint().getRoot());\n+    } catch (UnknownBlockRootException e) {\n+      return false;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd7aec30801173c9f8bca144f82f449c304fb9a2"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzUyMjM0NQ==", "bodyText": "Done.", "url": "https://github.com/ConsenSys/teku/pull/2062#discussion_r437522345", "createdAt": "2020-06-09T15:29:40Z", "author": {"login": "cemozerr"}, "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/ForkChoiceUtil.java", "diffHunk": "@@ -112,8 +123,12 @@ private static boolean should_update_justified_checkpoint(\n \n     UnsignedLong justified_slot =\n         compute_start_slot_at_epoch(store.getJustifiedCheckpoint().getEpoch());\n-    return get_ancestor(store, new_justified_checkpoint.getRoot(), justified_slot)\n-        .equals(store.getJustifiedCheckpoint().getRoot());\n+    try {\n+      return get_ancestor(forkChoiceStrategy, new_justified_checkpoint.getRoot(), justified_slot)\n+          .equals(store.getJustifiedCheckpoint().getRoot());\n+    } catch (UnknownBlockRootException e) {\n+      return false;\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA3MjkyMg=="}, "originalCommit": {"oid": "cd7aec30801173c9f8bca144f82f449c304fb9a2"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMjg0NzgwOnYy", "diffSide": "RIGHT", "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/ForkChoiceUtil.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwMDozNTowM1rOGg02Bg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNToyOTo0NVrOGhQP4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA3MzQxNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  boolean isFinalizedAncestorOfJustified;\n          \n          \n            \n                  try {\n          \n          \n            \n                    Bytes32 ancestorOfJustifiedAtFinalizedSlot =\n          \n          \n            \n                        get_ancestor(\n          \n          \n            \n                            forkChoiceStrategy, store.getJustifiedCheckpoint().getRoot(), finalized_slot);\n          \n          \n            \n                    isFinalizedAncestorOfJustified =\n          \n          \n            \n                        ancestorOfJustifiedAtFinalizedSlot.equals(store.getFinalizedCheckpoint().getRoot());\n          \n          \n            \n                  } catch (UnknownBlockRootException e) {\n          \n          \n            \n                    isFinalizedAncestorOfJustified = false;\n          \n          \n            \n                  }\n          \n          \n            \n                  boolean isFinalizedAncestorOfJustified =\n          \n          \n            \n                      get_ancestor(forkChoiceStrategy, store.getJustifiedCheckpoint().getRoot(), finalized_slot)\n          \n          \n            \n                          .map(\n          \n          \n            \n                              ancestorOfJustifiedAtFinalizedSlot ->\n          \n          \n            \n                                  ancestorOfJustifiedAtFinalizedSlot.equals(\n          \n          \n            \n                                      store.getFinalizedCheckpoint().getRoot()))\n          \n          \n            \n                          .orElse(false);", "url": "https://github.com/ConsenSys/teku/pull/2062#discussion_r437073414", "createdAt": "2020-06-09T00:35:03Z", "author": {"login": "ajsutton"}, "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/ForkChoiceUtil.java", "diffHunk": "@@ -213,13 +232,24 @@ public static BlockImportResult on_block(\n       UnsignedLong finalized_slot = store.getFinalizedCheckpoint().getEpochStartSlot();\n       // Update justified if new justified is later than store justified\n       // or if store justified is not in chain with finalized checkpoint\n+\n+      boolean isFinalizedAncestorOfJustified;\n+      try {\n+        Bytes32 ancestorOfJustifiedAtFinalizedSlot =\n+            get_ancestor(\n+                forkChoiceStrategy, store.getJustifiedCheckpoint().getRoot(), finalized_slot);\n+        isFinalizedAncestorOfJustified =\n+            ancestorOfJustifiedAtFinalizedSlot.equals(store.getFinalizedCheckpoint().getRoot());\n+      } catch (UnknownBlockRootException e) {\n+        isFinalizedAncestorOfJustified = false;\n+      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd7aec30801173c9f8bca144f82f449c304fb9a2"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzUyMjQwMw==", "bodyText": "Done.", "url": "https://github.com/ConsenSys/teku/pull/2062#discussion_r437522403", "createdAt": "2020-06-09T15:29:45Z", "author": {"login": "cemozerr"}, "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/ForkChoiceUtil.java", "diffHunk": "@@ -213,13 +232,24 @@ public static BlockImportResult on_block(\n       UnsignedLong finalized_slot = store.getFinalizedCheckpoint().getEpochStartSlot();\n       // Update justified if new justified is later than store justified\n       // or if store justified is not in chain with finalized checkpoint\n+\n+      boolean isFinalizedAncestorOfJustified;\n+      try {\n+        Bytes32 ancestorOfJustifiedAtFinalizedSlot =\n+            get_ancestor(\n+                forkChoiceStrategy, store.getJustifiedCheckpoint().getRoot(), finalized_slot);\n+        isFinalizedAncestorOfJustified =\n+            ancestorOfJustifiedAtFinalizedSlot.equals(store.getFinalizedCheckpoint().getRoot());\n+      } catch (UnknownBlockRootException e) {\n+        isFinalizedAncestorOfJustified = false;\n+      }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA3MzQxNA=="}, "originalCommit": {"oid": "cd7aec30801173c9f8bca144f82f449c304fb9a2"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMjg0OTgyOnYy", "diffSide": "RIGHT", "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/ForkChoiceUtil.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwMDozNjoxMlrOGg03LA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNDo1MDowMlrOGhN53w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA3MzcwOA==", "bodyText": "We should restore the order of these checks as finding the ancestor is a lot more expensive than checking the epochs.  So probably make isFinalizedAncestorOfJustified a method that's called here rather than a variable. Then we benefit from short circuiting.", "url": "https://github.com/ConsenSys/teku/pull/2062#discussion_r437073708", "createdAt": "2020-06-09T00:36:12Z", "author": {"login": "ajsutton"}, "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/ForkChoiceUtil.java", "diffHunk": "@@ -213,13 +232,24 @@ public static BlockImportResult on_block(\n       UnsignedLong finalized_slot = store.getFinalizedCheckpoint().getEpochStartSlot();\n       // Update justified if new justified is later than store justified\n       // or if store justified is not in chain with finalized checkpoint\n+\n+      boolean isFinalizedAncestorOfJustified;\n+      try {\n+        Bytes32 ancestorOfJustifiedAtFinalizedSlot =\n+            get_ancestor(\n+                forkChoiceStrategy, store.getJustifiedCheckpoint().getRoot(), finalized_slot);\n+        isFinalizedAncestorOfJustified =\n+            ancestorOfJustifiedAtFinalizedSlot.equals(store.getFinalizedCheckpoint().getRoot());\n+      } catch (UnknownBlockRootException e) {\n+        isFinalizedAncestorOfJustified = false;\n+      }\n+\n       if (state\n                   .getCurrent_justified_checkpoint()\n                   .getEpoch()\n                   .compareTo(store.getJustifiedCheckpoint().getEpoch())\n               > 0\n-          || !get_ancestor(store, store.getJustifiedCheckpoint().getRoot(), finalized_slot)\n-              .equals(store.getFinalizedCheckpoint().getRoot())) {\n+          || !isFinalizedAncestorOfJustified) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd7aec30801173c9f8bca144f82f449c304fb9a2"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ4Mzk5OQ==", "bodyText": "Makes sense. Done.", "url": "https://github.com/ConsenSys/teku/pull/2062#discussion_r437483999", "createdAt": "2020-06-09T14:50:02Z", "author": {"login": "cemozerr"}, "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/ForkChoiceUtil.java", "diffHunk": "@@ -213,13 +232,24 @@ public static BlockImportResult on_block(\n       UnsignedLong finalized_slot = store.getFinalizedCheckpoint().getEpochStartSlot();\n       // Update justified if new justified is later than store justified\n       // or if store justified is not in chain with finalized checkpoint\n+\n+      boolean isFinalizedAncestorOfJustified;\n+      try {\n+        Bytes32 ancestorOfJustifiedAtFinalizedSlot =\n+            get_ancestor(\n+                forkChoiceStrategy, store.getJustifiedCheckpoint().getRoot(), finalized_slot);\n+        isFinalizedAncestorOfJustified =\n+            ancestorOfJustifiedAtFinalizedSlot.equals(store.getFinalizedCheckpoint().getRoot());\n+      } catch (UnknownBlockRootException e) {\n+        isFinalizedAncestorOfJustified = false;\n+      }\n+\n       if (state\n                   .getCurrent_justified_checkpoint()\n                   .getEpoch()\n                   .compareTo(store.getJustifiedCheckpoint().getEpoch())\n               > 0\n-          || !get_ancestor(store, store.getJustifiedCheckpoint().getRoot(), finalized_slot)\n-              .equals(store.getFinalizedCheckpoint().getRoot())) {\n+          || !isFinalizedAncestorOfJustified) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA3MzcwOA=="}, "originalCommit": {"oid": "cd7aec30801173c9f8bca144f82f449c304fb9a2"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMjg1Mzg5OnYy", "diffSide": "RIGHT", "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/ForkChoiceUtil.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwMDozOTowNFrOGg05rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNToyOTo1NlrOGhQQaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA3NDM1MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                try {\n          \n          \n            \n                  final Bytes32 ancestorAtFinalizedSlot =\n          \n          \n            \n                      get_ancestor(forkChoiceStrategy, block.getParent_root(), finalizedSlot);\n          \n          \n            \n                  return ancestorAtFinalizedSlot.equals(finalizedCheckpoint.getRoot());\n          \n          \n            \n                } catch (UnknownBlockRootException e) {\n          \n          \n            \n                  return false;\n          \n          \n            \n                }\n          \n          \n            \n               return get_ancestor(forkChoiceStrategy, block.getParent_root(), finalizedSlot)\n          \n          \n            \n                    .map(\n          \n          \n            \n                        ancestorAtFinalizedSlot ->\n          \n          \n            \n                            ancestorAtFinalizedSlot.equals(finalizedCheckpoint.getRoot()))\n          \n          \n            \n                    .orElse(false);\n          \n      \n    \n    \n  \n\nI'm feeling like there's a pattern here so we could just extract a hasAncestorAtSlot(BeaconBlock block, UnsignedLong slot, Bytes32 expectedBlockRoot) method.", "url": "https://github.com/ConsenSys/teku/pull/2062#discussion_r437074350", "createdAt": "2020-06-09T00:39:04Z", "author": {"login": "ajsutton"}, "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/ForkChoiceUtil.java", "diffHunk": "@@ -235,41 +265,54 @@ public static BlockImportResult on_block(\n   }\n \n   private static Optional<BlockImportResult> checkOnBlockConditions(\n-      final BeaconBlock block, final BeaconState preState, final ReadOnlyStore store) {\n+      final BeaconBlock block,\n+      final BeaconState preState,\n+      final ReadOnlyStore store,\n+      final ForkChoiceStrategy forkChoiceStrategy) {\n+    final UnsignedLong blockSlot = block.getSlot();\n     if (preState == null) {\n       return Optional.of(BlockImportResult.FAILED_UNKNOWN_PARENT);\n     }\n-    if (preState.getSlot().compareTo(block.getSlot()) >= 0) {\n+    if (preState.getSlot().compareTo(blockSlot) >= 0) {\n       return Optional.of(BlockImportResult.FAILED_INVALID_ANCESTRY);\n     }\n-    if (blockIsFromFuture(block, store)) {\n+    if (blockIsFromFuture(store, blockSlot)) {\n       return Optional.of(BlockImportResult.FAILED_BLOCK_IS_FROM_FUTURE);\n     }\n-    if (!blockDescendsFromLatestFinalizedBlock(block, store)) {\n+    if (!blockDescendsFromLatestFinalizedBlock(block, store, forkChoiceStrategy)) {\n       return Optional.of(BlockImportResult.FAILED_INVALID_ANCESTRY);\n     }\n     return Optional.empty();\n   }\n \n-  private static boolean blockIsFromFuture(BeaconBlock block, ReadOnlyStore store) {\n-    return get_current_slot(store).compareTo(block.getSlot()) < 0;\n+  private static boolean blockIsFromFuture(ReadOnlyStore store, final UnsignedLong blockSlot) {\n+    return get_current_slot(store).compareTo(blockSlot) < 0;\n   }\n \n   private static boolean blockDescendsFromLatestFinalizedBlock(\n-      final BeaconBlock block, final ReadOnlyStore store) {\n+      final BeaconBlock block,\n+      final ReadOnlyStore store,\n+      final ForkChoiceStrategy forkChoiceStrategy) {\n     final Checkpoint finalizedCheckpoint = store.getFinalizedCheckpoint();\n+    // TODO: throw specific error here\n+    final UnsignedLong blockSlot = block.getSlot();\n \n     // Make sure this block's slot is after the latest finalized slot\n     final UnsignedLong finalizedEpochStartSlot = finalizedCheckpoint.getEpochStartSlot();\n-    if (block.getSlot().compareTo(finalizedEpochStartSlot) <= 0) {\n+    if (blockSlot.compareTo(finalizedEpochStartSlot) <= 0) {\n       return false;\n     }\n \n     // Make sure this block descends from the finalized block\n-    final UnsignedLong finalizedSlot = store.getBlock(finalizedCheckpoint.getRoot()).getSlot();\n-    final Bytes32 ancestorAtFinalizedSlot =\n-        get_ancestor(store, block.getParent_root(), finalizedSlot);\n-    return ancestorAtFinalizedSlot.equals(finalizedCheckpoint.getRoot());\n+    final UnsignedLong finalizedSlot =\n+        forkChoiceStrategy.blockSlot(finalizedCheckpoint.getRoot()).orElseThrow();\n+    try {\n+      final Bytes32 ancestorAtFinalizedSlot =\n+          get_ancestor(forkChoiceStrategy, block.getParent_root(), finalizedSlot);\n+      return ancestorAtFinalizedSlot.equals(finalizedCheckpoint.getRoot());\n+    } catch (UnknownBlockRootException e) {\n+      return false;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd7aec30801173c9f8bca144f82f449c304fb9a2"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzUyMjUzNw==", "bodyText": "Extracted the method.", "url": "https://github.com/ConsenSys/teku/pull/2062#discussion_r437522537", "createdAt": "2020-06-09T15:29:56Z", "author": {"login": "cemozerr"}, "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/ForkChoiceUtil.java", "diffHunk": "@@ -235,41 +265,54 @@ public static BlockImportResult on_block(\n   }\n \n   private static Optional<BlockImportResult> checkOnBlockConditions(\n-      final BeaconBlock block, final BeaconState preState, final ReadOnlyStore store) {\n+      final BeaconBlock block,\n+      final BeaconState preState,\n+      final ReadOnlyStore store,\n+      final ForkChoiceStrategy forkChoiceStrategy) {\n+    final UnsignedLong blockSlot = block.getSlot();\n     if (preState == null) {\n       return Optional.of(BlockImportResult.FAILED_UNKNOWN_PARENT);\n     }\n-    if (preState.getSlot().compareTo(block.getSlot()) >= 0) {\n+    if (preState.getSlot().compareTo(blockSlot) >= 0) {\n       return Optional.of(BlockImportResult.FAILED_INVALID_ANCESTRY);\n     }\n-    if (blockIsFromFuture(block, store)) {\n+    if (blockIsFromFuture(store, blockSlot)) {\n       return Optional.of(BlockImportResult.FAILED_BLOCK_IS_FROM_FUTURE);\n     }\n-    if (!blockDescendsFromLatestFinalizedBlock(block, store)) {\n+    if (!blockDescendsFromLatestFinalizedBlock(block, store, forkChoiceStrategy)) {\n       return Optional.of(BlockImportResult.FAILED_INVALID_ANCESTRY);\n     }\n     return Optional.empty();\n   }\n \n-  private static boolean blockIsFromFuture(BeaconBlock block, ReadOnlyStore store) {\n-    return get_current_slot(store).compareTo(block.getSlot()) < 0;\n+  private static boolean blockIsFromFuture(ReadOnlyStore store, final UnsignedLong blockSlot) {\n+    return get_current_slot(store).compareTo(blockSlot) < 0;\n   }\n \n   private static boolean blockDescendsFromLatestFinalizedBlock(\n-      final BeaconBlock block, final ReadOnlyStore store) {\n+      final BeaconBlock block,\n+      final ReadOnlyStore store,\n+      final ForkChoiceStrategy forkChoiceStrategy) {\n     final Checkpoint finalizedCheckpoint = store.getFinalizedCheckpoint();\n+    // TODO: throw specific error here\n+    final UnsignedLong blockSlot = block.getSlot();\n \n     // Make sure this block's slot is after the latest finalized slot\n     final UnsignedLong finalizedEpochStartSlot = finalizedCheckpoint.getEpochStartSlot();\n-    if (block.getSlot().compareTo(finalizedEpochStartSlot) <= 0) {\n+    if (blockSlot.compareTo(finalizedEpochStartSlot) <= 0) {\n       return false;\n     }\n \n     // Make sure this block descends from the finalized block\n-    final UnsignedLong finalizedSlot = store.getBlock(finalizedCheckpoint.getRoot()).getSlot();\n-    final Bytes32 ancestorAtFinalizedSlot =\n-        get_ancestor(store, block.getParent_root(), finalizedSlot);\n-    return ancestorAtFinalizedSlot.equals(finalizedCheckpoint.getRoot());\n+    final UnsignedLong finalizedSlot =\n+        forkChoiceStrategy.blockSlot(finalizedCheckpoint.getRoot()).orElseThrow();\n+    try {\n+      final Bytes32 ancestorAtFinalizedSlot =\n+          get_ancestor(forkChoiceStrategy, block.getParent_root(), finalizedSlot);\n+      return ancestorAtFinalizedSlot.equals(finalizedCheckpoint.getRoot());\n+    } catch (UnknownBlockRootException e) {\n+      return false;\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA3NDM1MA=="}, "originalCommit": {"oid": "cd7aec30801173c9f8bca144f82f449c304fb9a2"}, "originalPosition": 178}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMjg1OTQ0OnYy", "diffSide": "RIGHT", "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/ForkChoiceUtil.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwMDo0Mjo0NFrOGg09Hw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNToxMToyOFrOGhO-2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA3NTIzMQ==", "bodyText": "If the previous checks that the roots are known mean we can safely call get here, can we replace one or more of them with a check that the returned blockSlot is empty?  Otherwise, do we need to handle blockSlot returning empty?", "url": "https://github.com/ConsenSys/teku/pull/2062#discussion_r437075231", "createdAt": "2020-06-09T00:42:44Z", "author": {"login": "ajsutton"}, "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/ForkChoiceUtil.java", "diffHunk": "@@ -381,21 +426,21 @@ private static AttestationProcessingResult validateOnAttestation(\n       return AttestationProcessingResult.INVALID;\n     }\n \n-    if (!store.getBlockRoots().contains(target.getRoot())) {\n+    if (!forkChoiceStrategy.contains(target.getRoot())) {\n       // Attestations target must be for a known block. If a target block is unknown, delay\n       // consideration until the block is found\n       return AttestationProcessingResult.UNKNOWN_BLOCK;\n     }\n \n-    if (!store.getBlockRoots().contains(attestation.getData().getBeacon_block_root())) {\n+    if (!forkChoiceStrategy.contains(attestation.getData().getBeacon_block_root())) {\n       // Attestations must be for a known block. If block is unknown, delay consideration until the\n       // block is found\n       return AttestationProcessingResult.UNKNOWN_BLOCK;\n     }\n \n-    if (store\n-            .getBlock(attestation.getData().getBeacon_block_root())\n-            .getSlot()\n+    if (forkChoiceStrategy\n+            .blockSlot(attestation.getData().getBeacon_block_root())\n+            .get()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd7aec30801173c9f8bca144f82f449c304fb9a2"}, "originalPosition": 234}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzUwMDA2NA==", "bodyText": "No, you're right we don't need to handle blockSlot returning empty, we can remove the .contains check with just saving the return value from forkChoiceStrategy.blockSlot", "url": "https://github.com/ConsenSys/teku/pull/2062#discussion_r437500064", "createdAt": "2020-06-09T15:10:08Z", "author": {"login": "cemozerr"}, "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/ForkChoiceUtil.java", "diffHunk": "@@ -381,21 +426,21 @@ private static AttestationProcessingResult validateOnAttestation(\n       return AttestationProcessingResult.INVALID;\n     }\n \n-    if (!store.getBlockRoots().contains(target.getRoot())) {\n+    if (!forkChoiceStrategy.contains(target.getRoot())) {\n       // Attestations target must be for a known block. If a target block is unknown, delay\n       // consideration until the block is found\n       return AttestationProcessingResult.UNKNOWN_BLOCK;\n     }\n \n-    if (!store.getBlockRoots().contains(attestation.getData().getBeacon_block_root())) {\n+    if (!forkChoiceStrategy.contains(attestation.getData().getBeacon_block_root())) {\n       // Attestations must be for a known block. If block is unknown, delay consideration until the\n       // block is found\n       return AttestationProcessingResult.UNKNOWN_BLOCK;\n     }\n \n-    if (store\n-            .getBlock(attestation.getData().getBeacon_block_root())\n-            .getSlot()\n+    if (forkChoiceStrategy\n+            .blockSlot(attestation.getData().getBeacon_block_root())\n+            .get()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA3NTIzMQ=="}, "originalCommit": {"oid": "cd7aec30801173c9f8bca144f82f449c304fb9a2"}, "originalPosition": 234}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzUwMTY1Ng==", "bodyText": "Done.", "url": "https://github.com/ConsenSys/teku/pull/2062#discussion_r437501656", "createdAt": "2020-06-09T15:11:28Z", "author": {"login": "cemozerr"}, "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/ForkChoiceUtil.java", "diffHunk": "@@ -381,21 +426,21 @@ private static AttestationProcessingResult validateOnAttestation(\n       return AttestationProcessingResult.INVALID;\n     }\n \n-    if (!store.getBlockRoots().contains(target.getRoot())) {\n+    if (!forkChoiceStrategy.contains(target.getRoot())) {\n       // Attestations target must be for a known block. If a target block is unknown, delay\n       // consideration until the block is found\n       return AttestationProcessingResult.UNKNOWN_BLOCK;\n     }\n \n-    if (!store.getBlockRoots().contains(attestation.getData().getBeacon_block_root())) {\n+    if (!forkChoiceStrategy.contains(attestation.getData().getBeacon_block_root())) {\n       // Attestations must be for a known block. If block is unknown, delay consideration until the\n       // block is found\n       return AttestationProcessingResult.UNKNOWN_BLOCK;\n     }\n \n-    if (store\n-            .getBlock(attestation.getData().getBeacon_block_root())\n-            .getSlot()\n+    if (forkChoiceStrategy\n+            .blockSlot(attestation.getData().getBeacon_block_root())\n+            .get()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA3NTIzMQ=="}, "originalCommit": {"oid": "cd7aec30801173c9f8bca144f82f449c304fb9a2"}, "originalPosition": 234}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMjg2MDAzOnYy", "diffSide": "RIGHT", "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/UnknownBlockRootException.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwMDo0MzowNVrOGg09fw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNTowNjozM1rOGhOrGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA3NTMyNw==", "bodyText": "If we return Optional we can get rid of this.", "url": "https://github.com/ConsenSys/teku/pull/2062#discussion_r437075327", "createdAt": "2020-06-09T00:43:05Z", "author": {"login": "ajsutton"}, "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/UnknownBlockRootException.java", "diffHunk": "@@ -0,0 +1,20 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.core;\n+\n+public class UnknownBlockRootException extends Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd7aec30801173c9f8bca144f82f449c304fb9a2"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ5NjYwMQ==", "bodyText": "Done.", "url": "https://github.com/ConsenSys/teku/pull/2062#discussion_r437496601", "createdAt": "2020-06-09T15:06:33Z", "author": {"login": "cemozerr"}, "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/UnknownBlockRootException.java", "diffHunk": "@@ -0,0 +1,20 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.core;\n+\n+public class UnknownBlockRootException extends Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA3NTMyNw=="}, "originalCommit": {"oid": "cd7aec30801173c9f8bca144f82f449c304fb9a2"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyMjg2MjQ4OnYy", "diffSide": "RIGHT", "path": "ethereum/statetransition/src/main/java/tech/pegasys/teku/statetransition/forkchoice/ForkChoice.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwMDo0NDozNlrOGg0-9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxNToyMToxOFrOGhPyeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA3NTcwMw==", "bodyText": "When we were finding head we already knew the root and slot.  Can we find a way to just return it instead of having to do a second lookup?", "url": "https://github.com/ConsenSys/teku/pull/2062#discussion_r437075703", "createdAt": "2020-06-09T00:44:36Z", "author": {"login": "ajsutton"}, "path": "ethereum/statetransition/src/main/java/tech/pegasys/teku/statetransition/forkchoice/ForkChoice.java", "diffHunk": "@@ -53,14 +52,20 @@ public synchronized Bytes32 processHead() {\n     StoreTransaction transaction = recentChainData.startStoreTransaction();\n     Bytes32 headBlockRoot = protoArrayForkChoiceStrategy.findHead(transaction);\n     transaction.commit(() -> {}, \"Failed to persist validator vote changes.\");\n-    BeaconBlock headBlock = recentChainData.getStore().getBlock(headBlockRoot);\n-    recentChainData.updateBestBlock(headBlockRoot, headBlock.getSlot());\n+    recentChainData.updateBestBlock(\n+        headBlockRoot,\n+        protoArrayForkChoiceStrategy\n+            .blockSlot(headBlockRoot)\n+            .orElseThrow(\n+                () ->\n+                    new IllegalStateException(\"Unable to retrieve the slot of fork choice head\")));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cd7aec30801173c9f8bca144f82f449c304fb9a2"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzUxNDg3Mw==", "bodyText": "It could be done but the findHead method of ProtoArray is used more than 50 times in tests so I'd be wary to change its API in this PR. Also, I'm not worried since the retrieval is constant time, and findHead gets called once (or twice a slot).", "url": "https://github.com/ConsenSys/teku/pull/2062#discussion_r437514873", "createdAt": "2020-06-09T15:21:18Z", "author": {"login": "cemozerr"}, "path": "ethereum/statetransition/src/main/java/tech/pegasys/teku/statetransition/forkchoice/ForkChoice.java", "diffHunk": "@@ -53,14 +52,20 @@ public synchronized Bytes32 processHead() {\n     StoreTransaction transaction = recentChainData.startStoreTransaction();\n     Bytes32 headBlockRoot = protoArrayForkChoiceStrategy.findHead(transaction);\n     transaction.commit(() -> {}, \"Failed to persist validator vote changes.\");\n-    BeaconBlock headBlock = recentChainData.getStore().getBlock(headBlockRoot);\n-    recentChainData.updateBestBlock(headBlockRoot, headBlock.getSlot());\n+    recentChainData.updateBestBlock(\n+        headBlockRoot,\n+        protoArrayForkChoiceStrategy\n+            .blockSlot(headBlockRoot)\n+            .orElseThrow(\n+                () ->\n+                    new IllegalStateException(\"Unable to retrieve the slot of fork choice head\")));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA3NTcwMw=="}, "originalCommit": {"oid": "cd7aec30801173c9f8bca144f82f449c304fb9a2"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMTMxOTE4OnYy", "diffSide": "RIGHT", "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/ForkChoiceUtil.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMjoyMTowOFrOGiIO7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxNTowMDozOFrOGihWKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQzOTY2MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    .map(ancestorAtFinalizedSlot -> ancestorAtFinalizedSlot.equals(ancestorRoot))\n          \n          \n            \n                    .map(ancestorAtSlot -> ancestorAtSlot.equals(ancestorRoot))", "url": "https://github.com/ConsenSys/teku/pull/2062#discussion_r438439661", "createdAt": "2020-06-10T22:21:08Z", "author": {"login": "ajsutton"}, "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/ForkChoiceUtil.java", "diffHunk": "@@ -233,42 +249,69 @@ public static BlockImportResult on_block(\n     return BlockImportResult.successful(record);\n   }\n \n+  private static boolean isFinalizedAncestorOfJustified(\n+      ForkChoiceStrategy forkChoiceStrategy, ReadOnlyStore store) {\n+    UnsignedLong finalizedSlot = store.getFinalizedCheckpoint().getEpochStartSlot();\n+    return hasAncestorAtSlot(\n+        forkChoiceStrategy,\n+        store.getJustifiedCheckpoint().getRoot(),\n+        finalizedSlot,\n+        store.getFinalizedCheckpoint().getRoot());\n+  }\n+\n   private static Optional<BlockImportResult> checkOnBlockConditions(\n-      final BeaconBlock block, final BeaconState preState, final ReadOnlyStore store) {\n+      final BeaconBlock block,\n+      final BeaconState preState,\n+      final ReadOnlyStore store,\n+      final ForkChoiceStrategy forkChoiceStrategy) {\n+    final UnsignedLong blockSlot = block.getSlot();\n     if (preState == null) {\n       return Optional.of(BlockImportResult.FAILED_UNKNOWN_PARENT);\n     }\n-    if (preState.getSlot().compareTo(block.getSlot()) >= 0) {\n+    if (preState.getSlot().compareTo(blockSlot) >= 0) {\n       return Optional.of(BlockImportResult.FAILED_INVALID_ANCESTRY);\n     }\n-    if (blockIsFromFuture(block, store)) {\n+    if (blockIsFromFuture(store, blockSlot)) {\n       return Optional.of(BlockImportResult.FAILED_BLOCK_IS_FROM_FUTURE);\n     }\n-    if (!blockDescendsFromLatestFinalizedBlock(block, store)) {\n+    if (!blockDescendsFromLatestFinalizedBlock(block, store, forkChoiceStrategy)) {\n       return Optional.of(BlockImportResult.FAILED_INVALID_ANCESTRY);\n     }\n     return Optional.empty();\n   }\n \n-  private static boolean blockIsFromFuture(BeaconBlock block, ReadOnlyStore store) {\n-    return get_current_slot(store).compareTo(block.getSlot()) < 0;\n+  private static boolean blockIsFromFuture(ReadOnlyStore store, final UnsignedLong blockSlot) {\n+    return get_current_slot(store).compareTo(blockSlot) < 0;\n+  }\n+\n+  private static boolean hasAncestorAtSlot(\n+      ForkChoiceStrategy forkChoiceStrategy,\n+      Bytes32 root,\n+      UnsignedLong slot,\n+      Bytes32 ancestorRoot) {\n+    return get_ancestor(forkChoiceStrategy, root, slot)\n+        .map(ancestorAtFinalizedSlot -> ancestorAtFinalizedSlot.equals(ancestorRoot))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "543c42aa6bb7fb23690487c64b7d0706d3baed8e"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg1MTExNQ==", "bodyText": "Good catch. Done.", "url": "https://github.com/ConsenSys/teku/pull/2062#discussion_r438851115", "createdAt": "2020-06-11T15:00:38Z", "author": {"login": "cemozerr"}, "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/ForkChoiceUtil.java", "diffHunk": "@@ -233,42 +249,69 @@ public static BlockImportResult on_block(\n     return BlockImportResult.successful(record);\n   }\n \n+  private static boolean isFinalizedAncestorOfJustified(\n+      ForkChoiceStrategy forkChoiceStrategy, ReadOnlyStore store) {\n+    UnsignedLong finalizedSlot = store.getFinalizedCheckpoint().getEpochStartSlot();\n+    return hasAncestorAtSlot(\n+        forkChoiceStrategy,\n+        store.getJustifiedCheckpoint().getRoot(),\n+        finalizedSlot,\n+        store.getFinalizedCheckpoint().getRoot());\n+  }\n+\n   private static Optional<BlockImportResult> checkOnBlockConditions(\n-      final BeaconBlock block, final BeaconState preState, final ReadOnlyStore store) {\n+      final BeaconBlock block,\n+      final BeaconState preState,\n+      final ReadOnlyStore store,\n+      final ForkChoiceStrategy forkChoiceStrategy) {\n+    final UnsignedLong blockSlot = block.getSlot();\n     if (preState == null) {\n       return Optional.of(BlockImportResult.FAILED_UNKNOWN_PARENT);\n     }\n-    if (preState.getSlot().compareTo(block.getSlot()) >= 0) {\n+    if (preState.getSlot().compareTo(blockSlot) >= 0) {\n       return Optional.of(BlockImportResult.FAILED_INVALID_ANCESTRY);\n     }\n-    if (blockIsFromFuture(block, store)) {\n+    if (blockIsFromFuture(store, blockSlot)) {\n       return Optional.of(BlockImportResult.FAILED_BLOCK_IS_FROM_FUTURE);\n     }\n-    if (!blockDescendsFromLatestFinalizedBlock(block, store)) {\n+    if (!blockDescendsFromLatestFinalizedBlock(block, store, forkChoiceStrategy)) {\n       return Optional.of(BlockImportResult.FAILED_INVALID_ANCESTRY);\n     }\n     return Optional.empty();\n   }\n \n-  private static boolean blockIsFromFuture(BeaconBlock block, ReadOnlyStore store) {\n-    return get_current_slot(store).compareTo(block.getSlot()) < 0;\n+  private static boolean blockIsFromFuture(ReadOnlyStore store, final UnsignedLong blockSlot) {\n+    return get_current_slot(store).compareTo(blockSlot) < 0;\n+  }\n+\n+  private static boolean hasAncestorAtSlot(\n+      ForkChoiceStrategy forkChoiceStrategy,\n+      Bytes32 root,\n+      UnsignedLong slot,\n+      Bytes32 ancestorRoot) {\n+    return get_ancestor(forkChoiceStrategy, root, slot)\n+        .map(ancestorAtFinalizedSlot -> ancestorAtFinalizedSlot.equals(ancestorRoot))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQzOTY2MQ=="}, "originalCommit": {"oid": "543c42aa6bb7fb23690487c64b7d0706d3baed8e"}, "originalPosition": 168}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3549, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}