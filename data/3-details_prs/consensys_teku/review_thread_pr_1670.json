{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA4ODA4NTE5", "number": 1670, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQyMTo1NDozNlrOD30NOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQwMDo0NToyNlrOD32gqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5ODUzNjI3OnYy", "diffSide": "RIGHT", "path": "networking/eth2/src/test/java/tech/pegasys/artemis/networking/eth2/compression/SnappyCompressorTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQyMTo1NDozNlrOGOSdGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQyMjoyNzo1MVrOGO8gmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzYzNTYwOQ==", "bodyText": "Internally, the SnappyFramedInputStream blocks waiting for the next full frame to arrive. So if we get a partial frame over the wire, the SnappyCompressor will block waiting for the rest of the frame to arrive.", "url": "https://github.com/ConsenSys/teku/pull/1670#discussion_r417635609", "createdAt": "2020-04-29T21:54:36Z", "author": {"login": "mbaxter"}, "path": "networking/eth2/src/test/java/tech/pegasys/artemis/networking/eth2/compression/SnappyCompressorTest.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.networking.eth2.compression;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static tech.pegasys.artemis.networking.eth2.compression.SnappyCompressor.MAX_FRAME_CONTENT_SIZE;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.InputStream;\n+import java.io.PipedInputStream;\n+import java.io.PipedOutputStream;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.util.DataStructureUtil;\n+import tech.pegasys.artemis.datastructures.util.SimpleOffsetSerializer;\n+\n+public class SnappyCompressorTest {\n+  private final DataStructureUtil dataStructureUtil = new DataStructureUtil();\n+  private final Compressor compressor = new SnappyCompressor();\n+\n+  @Test\n+  public void roundTrip() throws Exception {\n+    final BeaconState state = dataStructureUtil.randomBeaconState(0);\n+    final Bytes serializedState =\n+        Bytes.wrap(SimpleOffsetSerializer.serialize(state).toArrayUnsafe());\n+\n+    final Bytes compressed = compressor.compress(serializedState);\n+    assertThat(compressed).isNotEqualTo(serializedState);\n+\n+    final Bytes uncompressed = compressor.uncompress(compressed);\n+    assertThat(uncompressed).isEqualTo(serializedState);\n+  }\n+\n+  @Test\n+  public void uncompress_invalidData() {\n+    final BeaconState state = dataStructureUtil.randomBeaconState(0);\n+    final Bytes serializedState =\n+        Bytes.wrap(SimpleOffsetSerializer.serialize(state).toArrayUnsafe());\n+\n+    assertThatThrownBy(() -> compressor.uncompress(serializedState))\n+        .isInstanceOf(CompressionException.class);\n+  }\n+\n+  @Test\n+  public void uncompress_seriesOfValues() throws Exception {\n+    final BeaconState stateA = dataStructureUtil.randomBeaconState(0);\n+    final BeaconState stateB = dataStructureUtil.randomBeaconState(1);\n+    final Bytes serializedStateA =\n+        Bytes.wrap(SimpleOffsetSerializer.serialize(stateA).toArrayUnsafe());\n+    final Bytes serializedStateB =\n+        Bytes.wrap(SimpleOffsetSerializer.serialize(stateB).toArrayUnsafe());\n+\n+    final Bytes compressedA = compressor.compress(serializedStateA);\n+    final Bytes compressedB = compressor.compress(serializedStateB);\n+    final Bytes compressedSeries = Bytes.concatenate(compressedA, compressedB);\n+    final InputStream input = new ByteArrayInputStream(compressedSeries.toArrayUnsafe());\n+\n+    // Get first value\n+    final Bytes uncompressed = compressor.uncompress(input, serializedStateA.size());\n+    assertThat(uncompressed).isEqualTo(serializedStateA);\n+    // Then next value\n+    final Bytes uncompressed2 = compressor.uncompress(input, serializedStateB.size());\n+    assertThat(uncompressed2).isEqualTo(serializedStateB);\n+    // Input stream should now be closed\n+    assertThat(input.available()).isEqualTo(0);\n+    assertThat(input.read()).isEqualTo(-1);\n+  }\n+\n+  @Test\n+  public void uncompress_partialValue() throws Exception {\n+    final BeaconState state = dataStructureUtil.randomBeaconState(0);\n+    final Bytes serializedState =\n+        Bytes.wrap(SimpleOffsetSerializer.serialize(state).toArrayUnsafe());\n+\n+    final Bytes compressed = compressor.compress(serializedState);\n+    final int maxBytes = MAX_FRAME_CONTENT_SIZE / 2;\n+    // Check assumptions\n+    assertThat(serializedState.size()).isGreaterThan(MAX_FRAME_CONTENT_SIZE);\n+\n+    final InputStream input = new ByteArrayInputStream(compressed.toArrayUnsafe());\n+    final Bytes uncompressed = compressor.uncompress(input, maxBytes);\n+    assertThat(uncompressed.size()).isLessThanOrEqualTo(maxBytes);\n+  }\n+\n+  @Test\n+  @Disabled(\"SnappyCompressor will currently block in this case\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2727a0b183d80178ad6c5487f2307628ebd5a13e"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMyNDYzMg==", "bodyText": "This issue has been fixed and the test has been enabled.", "url": "https://github.com/ConsenSys/teku/pull/1670#discussion_r418324632", "createdAt": "2020-04-30T22:27:51Z", "author": {"login": "mbaxter"}, "path": "networking/eth2/src/test/java/tech/pegasys/artemis/networking/eth2/compression/SnappyCompressorTest.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.networking.eth2.compression;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static tech.pegasys.artemis.networking.eth2.compression.SnappyCompressor.MAX_FRAME_CONTENT_SIZE;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.InputStream;\n+import java.io.PipedInputStream;\n+import java.io.PipedOutputStream;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.util.DataStructureUtil;\n+import tech.pegasys.artemis.datastructures.util.SimpleOffsetSerializer;\n+\n+public class SnappyCompressorTest {\n+  private final DataStructureUtil dataStructureUtil = new DataStructureUtil();\n+  private final Compressor compressor = new SnappyCompressor();\n+\n+  @Test\n+  public void roundTrip() throws Exception {\n+    final BeaconState state = dataStructureUtil.randomBeaconState(0);\n+    final Bytes serializedState =\n+        Bytes.wrap(SimpleOffsetSerializer.serialize(state).toArrayUnsafe());\n+\n+    final Bytes compressed = compressor.compress(serializedState);\n+    assertThat(compressed).isNotEqualTo(serializedState);\n+\n+    final Bytes uncompressed = compressor.uncompress(compressed);\n+    assertThat(uncompressed).isEqualTo(serializedState);\n+  }\n+\n+  @Test\n+  public void uncompress_invalidData() {\n+    final BeaconState state = dataStructureUtil.randomBeaconState(0);\n+    final Bytes serializedState =\n+        Bytes.wrap(SimpleOffsetSerializer.serialize(state).toArrayUnsafe());\n+\n+    assertThatThrownBy(() -> compressor.uncompress(serializedState))\n+        .isInstanceOf(CompressionException.class);\n+  }\n+\n+  @Test\n+  public void uncompress_seriesOfValues() throws Exception {\n+    final BeaconState stateA = dataStructureUtil.randomBeaconState(0);\n+    final BeaconState stateB = dataStructureUtil.randomBeaconState(1);\n+    final Bytes serializedStateA =\n+        Bytes.wrap(SimpleOffsetSerializer.serialize(stateA).toArrayUnsafe());\n+    final Bytes serializedStateB =\n+        Bytes.wrap(SimpleOffsetSerializer.serialize(stateB).toArrayUnsafe());\n+\n+    final Bytes compressedA = compressor.compress(serializedStateA);\n+    final Bytes compressedB = compressor.compress(serializedStateB);\n+    final Bytes compressedSeries = Bytes.concatenate(compressedA, compressedB);\n+    final InputStream input = new ByteArrayInputStream(compressedSeries.toArrayUnsafe());\n+\n+    // Get first value\n+    final Bytes uncompressed = compressor.uncompress(input, serializedStateA.size());\n+    assertThat(uncompressed).isEqualTo(serializedStateA);\n+    // Then next value\n+    final Bytes uncompressed2 = compressor.uncompress(input, serializedStateB.size());\n+    assertThat(uncompressed2).isEqualTo(serializedStateB);\n+    // Input stream should now be closed\n+    assertThat(input.available()).isEqualTo(0);\n+    assertThat(input.read()).isEqualTo(-1);\n+  }\n+\n+  @Test\n+  public void uncompress_partialValue() throws Exception {\n+    final BeaconState state = dataStructureUtil.randomBeaconState(0);\n+    final Bytes serializedState =\n+        Bytes.wrap(SimpleOffsetSerializer.serialize(state).toArrayUnsafe());\n+\n+    final Bytes compressed = compressor.compress(serializedState);\n+    final int maxBytes = MAX_FRAME_CONTENT_SIZE / 2;\n+    // Check assumptions\n+    assertThat(serializedState.size()).isGreaterThan(MAX_FRAME_CONTENT_SIZE);\n+\n+    final InputStream input = new ByteArrayInputStream(compressed.toArrayUnsafe());\n+    final Bytes uncompressed = compressor.uncompress(input, maxBytes);\n+    assertThat(uncompressed.size()).isLessThanOrEqualTo(maxBytes);\n+  }\n+\n+  @Test\n+  @Disabled(\"SnappyCompressor will currently block in this case\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzYzNTYwOQ=="}, "originalCommit": {"oid": "2727a0b183d80178ad6c5487f2307628ebd5a13e"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5ODU0NTExOnYy", "diffSide": "RIGHT", "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/compression/Compressor.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQyMTo1Nzo1N1rOGOSiyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQyMjo0Njo1NVrOGO87JA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzYzNzA2Nw==", "bodyText": "The networking spec says:\n\nA reader SHOULD NOT read more than max_encoded_len(n) bytes after reading the SSZ length prefix n from the header.\n\nBut I don't think we can actually enforce that atm because of how the Snappy library works.  See: https://github.com/PegaSysEng/teku/pull/1670/files#r417635609", "url": "https://github.com/ConsenSys/teku/pull/1670#discussion_r417637067", "createdAt": "2020-04-29T21:57:57Z", "author": {"login": "mbaxter"}, "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/compression/Compressor.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.networking.eth2.compression;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import org.apache.tuweni.bytes.Bytes;\n+\n+public interface Compressor {\n+\n+  /**\n+   * Returns the compressed data\n+   *\n+   * @param data The data to compress\n+   * @return The compressed data\n+   */\n+  Bytes compress(final Bytes data);\n+\n+  /**\n+   * Returns the uncompressed data.\n+   *\n+   * @param data The data to uncompress.\n+   * @return The uncompressed data.\n+   */\n+  default Bytes uncompress(final Bytes data) throws CompressionException {\n+    try (final InputStream byteStream = new ByteArrayInputStream(data.toArrayUnsafe())) {\n+      // Read everything\n+      return uncompress(byteStream, Integer.MAX_VALUE);\n+    } catch (IOException e) {\n+      throw new RuntimeException(\n+          \"Unexpected error encountered while preparing to uncompress bytes\", e);\n+    }\n+  }\n+\n+  /**\n+   * Uncompress up to {@code maxBytes} bytes. May return fewer bytes if the end of stream is\n+   * detected or an error occurs.\n+   *\n+   * @param input The underlying {@link InputStream} to read from.\n+   * @param maxBytes The maximum number of uncompressed bytes to produce\n+   * @return The uncompressed bytes read from the underlying inputStream {@code input} stream.\n+   */\n+  Bytes uncompress(final InputStream input, final int maxBytes) throws CompressionException;\n+\n+  /**\n+   * Returns a maximum estimate of the size of a compressed payload given the uncompressed payload\n+   * size.\n+   *\n+   * @param uncompressedLength The size of an uncompressed payload.\n+   * @return The maximum size of a payload of size {@code uncompressedLength} after compression.\n+   */\n+  int getMaxCompressedLength(final int uncompressedLength);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2727a0b183d80178ad6c5487f2307628ebd5a13e"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzczNzY4Mg==", "bodyText": "I'm not 100% sure I've understood exactly where the issue enforcing this check is so these comments may be off the mark but...\nI think the main security concern is that we can't be made to read massive amounts of data from the stream.  The total number of uncompressed bytes we could read is limited but there's a risk that we could be fed a series of effectively empty snappy frames so that we never reach that limit. Not sure if that's actually possible with snappy or if it would be rejected as invalid compressed data.\nOne option we could have is to limit the underlying input stream.  ie we have an InputStream that is the source of compressed data - we could wrap it in a custom InputStream that mostly just delegates but keeps track of the number of bytes read and throws an exception if we wind up reading more than the expected limit.", "url": "https://github.com/ConsenSys/teku/pull/1670#discussion_r417737682", "createdAt": "2020-04-30T03:48:26Z", "author": {"login": "ajsutton"}, "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/compression/Compressor.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.networking.eth2.compression;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import org.apache.tuweni.bytes.Bytes;\n+\n+public interface Compressor {\n+\n+  /**\n+   * Returns the compressed data\n+   *\n+   * @param data The data to compress\n+   * @return The compressed data\n+   */\n+  Bytes compress(final Bytes data);\n+\n+  /**\n+   * Returns the uncompressed data.\n+   *\n+   * @param data The data to uncompress.\n+   * @return The uncompressed data.\n+   */\n+  default Bytes uncompress(final Bytes data) throws CompressionException {\n+    try (final InputStream byteStream = new ByteArrayInputStream(data.toArrayUnsafe())) {\n+      // Read everything\n+      return uncompress(byteStream, Integer.MAX_VALUE);\n+    } catch (IOException e) {\n+      throw new RuntimeException(\n+          \"Unexpected error encountered while preparing to uncompress bytes\", e);\n+    }\n+  }\n+\n+  /**\n+   * Uncompress up to {@code maxBytes} bytes. May return fewer bytes if the end of stream is\n+   * detected or an error occurs.\n+   *\n+   * @param input The underlying {@link InputStream} to read from.\n+   * @param maxBytes The maximum number of uncompressed bytes to produce\n+   * @return The uncompressed bytes read from the underlying inputStream {@code input} stream.\n+   */\n+  Bytes uncompress(final InputStream input, final int maxBytes) throws CompressionException;\n+\n+  /**\n+   * Returns a maximum estimate of the size of a compressed payload given the uncompressed payload\n+   * size.\n+   *\n+   * @param uncompressedLength The size of an uncompressed payload.\n+   * @return The maximum size of a payload of size {@code uncompressedLength} after compression.\n+   */\n+  int getMaxCompressedLength(final int uncompressedLength);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzYzNzA2Nw=="}, "originalCommit": {"oid": "2727a0b183d80178ad6c5487f2307628ebd5a13e"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE1NjY4Mw==", "bodyText": "Yeah, you're right.  I was hoping snappy was smarter about what constitutes a valid sequence of frames, but it will happily decode a sequence of identical frames each with a 1-byte payload: 8eb8780\nSo yeah, we'll have to have some kind of wrapped InputStream that tracks the number of bytes actually read.", "url": "https://github.com/ConsenSys/teku/pull/1670#discussion_r418156683", "createdAt": "2020-04-30T17:01:45Z", "author": {"login": "mbaxter"}, "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/compression/Compressor.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.networking.eth2.compression;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import org.apache.tuweni.bytes.Bytes;\n+\n+public interface Compressor {\n+\n+  /**\n+   * Returns the compressed data\n+   *\n+   * @param data The data to compress\n+   * @return The compressed data\n+   */\n+  Bytes compress(final Bytes data);\n+\n+  /**\n+   * Returns the uncompressed data.\n+   *\n+   * @param data The data to uncompress.\n+   * @return The uncompressed data.\n+   */\n+  default Bytes uncompress(final Bytes data) throws CompressionException {\n+    try (final InputStream byteStream = new ByteArrayInputStream(data.toArrayUnsafe())) {\n+      // Read everything\n+      return uncompress(byteStream, Integer.MAX_VALUE);\n+    } catch (IOException e) {\n+      throw new RuntimeException(\n+          \"Unexpected error encountered while preparing to uncompress bytes\", e);\n+    }\n+  }\n+\n+  /**\n+   * Uncompress up to {@code maxBytes} bytes. May return fewer bytes if the end of stream is\n+   * detected or an error occurs.\n+   *\n+   * @param input The underlying {@link InputStream} to read from.\n+   * @param maxBytes The maximum number of uncompressed bytes to produce\n+   * @return The uncompressed bytes read from the underlying inputStream {@code input} stream.\n+   */\n+  Bytes uncompress(final InputStream input, final int maxBytes) throws CompressionException;\n+\n+  /**\n+   * Returns a maximum estimate of the size of a compressed payload given the uncompressed payload\n+   * size.\n+   *\n+   * @param uncompressedLength The size of an uncompressed payload.\n+   * @return The maximum size of a payload of size {@code uncompressedLength} after compression.\n+   */\n+  int getMaxCompressedLength(final int uncompressedLength);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzYzNzA2Nw=="}, "originalCommit": {"oid": "2727a0b183d80178ad6c5487f2307628ebd5a13e"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMyNjAzNQ==", "bodyText": "Turns out guava has a util for created a limited input stream.  It's marked @Beta: https://guava.dev/releases/19.0/api/docs/com/google/common/annotations/Beta.html.  But I think that's fine for us?  If not, I started on an implementation that we could swap in.", "url": "https://github.com/ConsenSys/teku/pull/1670#discussion_r418326035", "createdAt": "2020-04-30T22:31:29Z", "author": {"login": "mbaxter"}, "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/compression/Compressor.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.networking.eth2.compression;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import org.apache.tuweni.bytes.Bytes;\n+\n+public interface Compressor {\n+\n+  /**\n+   * Returns the compressed data\n+   *\n+   * @param data The data to compress\n+   * @return The compressed data\n+   */\n+  Bytes compress(final Bytes data);\n+\n+  /**\n+   * Returns the uncompressed data.\n+   *\n+   * @param data The data to uncompress.\n+   * @return The uncompressed data.\n+   */\n+  default Bytes uncompress(final Bytes data) throws CompressionException {\n+    try (final InputStream byteStream = new ByteArrayInputStream(data.toArrayUnsafe())) {\n+      // Read everything\n+      return uncompress(byteStream, Integer.MAX_VALUE);\n+    } catch (IOException e) {\n+      throw new RuntimeException(\n+          \"Unexpected error encountered while preparing to uncompress bytes\", e);\n+    }\n+  }\n+\n+  /**\n+   * Uncompress up to {@code maxBytes} bytes. May return fewer bytes if the end of stream is\n+   * detected or an error occurs.\n+   *\n+   * @param input The underlying {@link InputStream} to read from.\n+   * @param maxBytes The maximum number of uncompressed bytes to produce\n+   * @return The uncompressed bytes read from the underlying inputStream {@code input} stream.\n+   */\n+  Bytes uncompress(final InputStream input, final int maxBytes) throws CompressionException;\n+\n+  /**\n+   * Returns a maximum estimate of the size of a compressed payload given the uncompressed payload\n+   * size.\n+   *\n+   * @param uncompressedLength The size of an uncompressed payload.\n+   * @return The maximum size of a payload of size {@code uncompressedLength} after compression.\n+   */\n+  int getMaxCompressedLength(final int uncompressedLength);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzYzNzA2Nw=="}, "originalCommit": {"oid": "2727a0b183d80178ad6c5487f2307628ebd5a13e"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMzMTQyOA==", "bodyText": "I'm fine with using the Guava version.", "url": "https://github.com/ConsenSys/teku/pull/1670#discussion_r418331428", "createdAt": "2020-04-30T22:46:55Z", "author": {"login": "ajsutton"}, "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/compression/Compressor.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.networking.eth2.compression;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import org.apache.tuweni.bytes.Bytes;\n+\n+public interface Compressor {\n+\n+  /**\n+   * Returns the compressed data\n+   *\n+   * @param data The data to compress\n+   * @return The compressed data\n+   */\n+  Bytes compress(final Bytes data);\n+\n+  /**\n+   * Returns the uncompressed data.\n+   *\n+   * @param data The data to uncompress.\n+   * @return The uncompressed data.\n+   */\n+  default Bytes uncompress(final Bytes data) throws CompressionException {\n+    try (final InputStream byteStream = new ByteArrayInputStream(data.toArrayUnsafe())) {\n+      // Read everything\n+      return uncompress(byteStream, Integer.MAX_VALUE);\n+    } catch (IOException e) {\n+      throw new RuntimeException(\n+          \"Unexpected error encountered while preparing to uncompress bytes\", e);\n+    }\n+  }\n+\n+  /**\n+   * Uncompress up to {@code maxBytes} bytes. May return fewer bytes if the end of stream is\n+   * detected or an error occurs.\n+   *\n+   * @param input The underlying {@link InputStream} to read from.\n+   * @param maxBytes The maximum number of uncompressed bytes to produce\n+   * @return The uncompressed bytes read from the underlying inputStream {@code input} stream.\n+   */\n+  Bytes uncompress(final InputStream input, final int maxBytes) throws CompressionException;\n+\n+  /**\n+   * Returns a maximum estimate of the size of a compressed payload given the uncompressed payload\n+   * size.\n+   *\n+   * @param uncompressedLength The size of an uncompressed payload.\n+   * @return The maximum size of a payload of size {@code uncompressedLength} after compression.\n+   */\n+  int getMaxCompressedLength(final int uncompressedLength);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzYzNzA2Nw=="}, "originalCommit": {"oid": "2727a0b183d80178ad6c5487f2307628ebd5a13e"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5ODU1NjI0OnYy", "diffSide": "RIGHT", "path": "networking/p2p/src/main/java/tech/pegasys/artemis/networking/p2p/libp2p/rpc/RpcHandler.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQyMjowMTo0MlrOGOSpvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQyMjo0Njo0NlrOGO868A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzYzODg0Ng==", "bodyText": "(discussion) Here, we're processing the input asynchronously using the standard DelayedExecutorAsyncRunner.  Wondering if we should run these tasks in a dedicated thread pool?", "url": "https://github.com/ConsenSys/teku/pull/1670#discussion_r417638846", "createdAt": "2020-04-29T22:01:42Z", "author": {"login": "mbaxter"}, "path": "networking/p2p/src/main/java/tech/pegasys/artemis/networking/p2p/libp2p/rpc/RpcHandler.java", "diffHunk": "@@ -169,11 +194,25 @@ public void setRequestHandler(RpcRequestHandler rpcRequestHandler) {\n         throw new IllegalStateException(\"Attempt to set an already set data handler\");\n       }\n       this.rpcRequestHandler = rpcRequestHandler;\n-      activeFuture.thenAccept(__ -> rpcRequestHandler.onActivation(rpcStream)).reportExceptions();\n-      while (!bufferedData.isEmpty()) {\n-        ByteBuf currentBuffer = bufferedData.remove(0);\n-        this.rpcRequestHandler.onData(nodeId, rpcStream, currentBuffer);\n-      }\n+\n+      activeFuture\n+          .thenCompose(\n+              __ ->\n+                  asyncRunner.runAsync(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2727a0b183d80178ad6c5487f2307628ebd5a13e"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY5NzIyOQ==", "bodyText": "Yeah I've been generally trying to ensure we use a single async runner that's injected rather than creating them all over the place so we can start to make decisions about how many threads it can use etc.\nIt probably makes sense to have networking use it's own thread pool.  If we're blocking we may need to make the limit on number of threads quite high, but it would definitely be good to know how many threads are being used by networking and be able to limit them independently.", "url": "https://github.com/ConsenSys/teku/pull/1670#discussion_r417697229", "createdAt": "2020-04-30T00:58:35Z", "author": {"login": "ajsutton"}, "path": "networking/p2p/src/main/java/tech/pegasys/artemis/networking/p2p/libp2p/rpc/RpcHandler.java", "diffHunk": "@@ -169,11 +194,25 @@ public void setRequestHandler(RpcRequestHandler rpcRequestHandler) {\n         throw new IllegalStateException(\"Attempt to set an already set data handler\");\n       }\n       this.rpcRequestHandler = rpcRequestHandler;\n-      activeFuture.thenAccept(__ -> rpcRequestHandler.onActivation(rpcStream)).reportExceptions();\n-      while (!bufferedData.isEmpty()) {\n-        ByteBuf currentBuffer = bufferedData.remove(0);\n-        this.rpcRequestHandler.onData(nodeId, rpcStream, currentBuffer);\n-      }\n+\n+      activeFuture\n+          .thenCompose(\n+              __ ->\n+                  asyncRunner.runAsync(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzYzODg0Ng=="}, "originalCommit": {"oid": "2727a0b183d80178ad6c5487f2307628ebd5a13e"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMyNjQxNQ==", "bodyText": "I think this might require a bit of reorganization and this PR is already pretty big, so I think I'll log a ticket to follow-up on this if that sounds fine to you.", "url": "https://github.com/ConsenSys/teku/pull/1670#discussion_r418326415", "createdAt": "2020-04-30T22:32:32Z", "author": {"login": "mbaxter"}, "path": "networking/p2p/src/main/java/tech/pegasys/artemis/networking/p2p/libp2p/rpc/RpcHandler.java", "diffHunk": "@@ -169,11 +194,25 @@ public void setRequestHandler(RpcRequestHandler rpcRequestHandler) {\n         throw new IllegalStateException(\"Attempt to set an already set data handler\");\n       }\n       this.rpcRequestHandler = rpcRequestHandler;\n-      activeFuture.thenAccept(__ -> rpcRequestHandler.onActivation(rpcStream)).reportExceptions();\n-      while (!bufferedData.isEmpty()) {\n-        ByteBuf currentBuffer = bufferedData.remove(0);\n-        this.rpcRequestHandler.onData(nodeId, rpcStream, currentBuffer);\n-      }\n+\n+      activeFuture\n+          .thenCompose(\n+              __ ->\n+                  asyncRunner.runAsync(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzYzODg0Ng=="}, "originalCommit": {"oid": "2727a0b183d80178ad6c5487f2307628ebd5a13e"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMzMTM3Ng==", "bodyText": "Yep agreed.", "url": "https://github.com/ConsenSys/teku/pull/1670#discussion_r418331376", "createdAt": "2020-04-30T22:46:46Z", "author": {"login": "ajsutton"}, "path": "networking/p2p/src/main/java/tech/pegasys/artemis/networking/p2p/libp2p/rpc/RpcHandler.java", "diffHunk": "@@ -169,11 +194,25 @@ public void setRequestHandler(RpcRequestHandler rpcRequestHandler) {\n         throw new IllegalStateException(\"Attempt to set an already set data handler\");\n       }\n       this.rpcRequestHandler = rpcRequestHandler;\n-      activeFuture.thenAccept(__ -> rpcRequestHandler.onActivation(rpcStream)).reportExceptions();\n-      while (!bufferedData.isEmpty()) {\n-        ByteBuf currentBuffer = bufferedData.remove(0);\n-        this.rpcRequestHandler.onData(nodeId, rpcStream, currentBuffer);\n-      }\n+\n+      activeFuture\n+          .thenCompose(\n+              __ ->\n+                  asyncRunner.runAsync(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzYzODg0Ng=="}, "originalCommit": {"oid": "2727a0b183d80178ad6c5487f2307628ebd5a13e"}, "originalPosition": 98}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5ODU2MjM1OnYy", "diffSide": "RIGHT", "path": "networking/p2p/src/main/java/tech/pegasys/artemis/networking/p2p/libp2p/rpc/RpcHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQyMjowMzo1NVrOGOStnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQyMjowMzo1NVrOGOStnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzYzOTgzOQ==", "bodyText": "We might want to have some kind of custom InputStream that runs over appended ByteBuf instances, similar to how we were previously managing these ByteBuf's in MessageBuffer.  If we think that's worth doing, I can add a follow-up ticket.", "url": "https://github.com/ConsenSys/teku/pull/1670#discussion_r417639839", "createdAt": "2020-04-29T22:03:55Z", "author": {"login": "mbaxter"}, "path": "networking/p2p/src/main/java/tech/pegasys/artemis/networking/p2p/libp2p/rpc/RpcHandler.java", "diffHunk": "@@ -157,10 +174,18 @@ public RpcStream getRpcStream() {\n \n     @Override\n     protected void channelRead0(final ChannelHandlerContext ctx, final ByteBuf msg) {\n-      if (rpcRequestHandler != null) {\n-        rpcRequestHandler.onData(nodeId, rpcStream, msg);\n-      } else {\n-        bufferedData.add(msg);\n+      if (outputStreamClosed) {\n+        // Discard any data if output stream has been closed\n+        return;\n+      }\n+      try {\n+        // TODO - we may want to optimize this to pass on ByteBuf's directly and manage their\n+        //  garbage collection rather than immediately copying these bytes\n+        final Bytes bytes = Bytes.wrapByteBuf(msg);\n+        outputStream.write(bytes.toArray());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2727a0b183d80178ad6c5487f2307628ebd5a13e"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5ODc5ODc2OnYy", "diffSide": "RIGHT", "path": "networking/eth2/src/integration-test/java/tech/pegasys/artemis/networking/eth2/PeerStatusIntegrationTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQyMzo0NjoyMlrOGOU7yw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNjowNzo0OFrOGOwO6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY3NjIzNQ==", "bodyText": "Slightly crazy idea and probably something for a follow up PR anyway, but what if we had a test fixture class implementing ArgumentsProvider that could gave a stream of Eth2Network.builder().rpcEncoding(..) with each of the encodings.  Then you could just use @ArgumentsSource(RpcEncodingsProvider.class) on methods.", "url": "https://github.com/ConsenSys/teku/pull/1670#discussion_r417676235", "createdAt": "2020-04-29T23:46:22Z", "author": {"login": "ajsutton"}, "path": "networking/eth2/src/integration-test/java/tech/pegasys/artemis/networking/eth2/PeerStatusIntegrationTest.java", "diffHunk": "@@ -51,17 +55,29 @@ public void tearDown() {\n     networkFactory.stopAll();\n   }\n \n-  @Test\n-  public void shouldExchangeStatusMessagesOnConnection() throws Exception {\n+  public static Stream<Arguments> getEncodings() {\n+    final List<RpcEncoding> encodings = List.of(RpcEncoding.SSZ, RpcEncoding.SSZ_SNAPPY);\n+    return encodings.stream().map(e -> Arguments.of(e.getName(), e));\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2727a0b183d80178ad6c5487f2307628ebd5a13e"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODEyMzQ5OQ==", "bodyText": "Yeah - I'm a bit unhappy with all of the duplication of the arguments boilerplate.  Sounds like a good idea \ud83d\udc4d", "url": "https://github.com/ConsenSys/teku/pull/1670#discussion_r418123499", "createdAt": "2020-04-30T16:07:48Z", "author": {"login": "mbaxter"}, "path": "networking/eth2/src/integration-test/java/tech/pegasys/artemis/networking/eth2/PeerStatusIntegrationTest.java", "diffHunk": "@@ -51,17 +55,29 @@ public void tearDown() {\n     networkFactory.stopAll();\n   }\n \n-  @Test\n-  public void shouldExchangeStatusMessagesOnConnection() throws Exception {\n+  public static Stream<Arguments> getEncodings() {\n+    final List<RpcEncoding> encodings = List.of(RpcEncoding.SSZ, RpcEncoding.SSZ_SNAPPY);\n+    return encodings.stream().map(e -> Arguments.of(e.getName(), e));\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY3NjIzNQ=="}, "originalCommit": {"oid": "2727a0b183d80178ad6c5487f2307628ebd5a13e"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5ODg1MjM0OnYy", "diffSide": "RIGHT", "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/compression/SnappyCompressor.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQwMDoxMzoxMlrOGOVcRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQyMDo1MDowNlrOGPVX-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY4NDU1MA==", "bodyText": "The potential risk here is that SnappyFramedInputStream maintains any kind of internal state or buffer of read data.  Sounds like it works now but it feels slightly dangerous to be creating and discarding wrapper input streams.\nIdeally when the input stream was first created, the compressor would get a chance to wrap it and then you could just use it as an input stream to read data from.  It might be possible to do that in the RpcRequestHandler but not entirely sure.", "url": "https://github.com/ConsenSys/teku/pull/1670#discussion_r417684550", "createdAt": "2020-04-30T00:13:12Z", "author": {"login": "ajsutton"}, "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/compression/SnappyCompressor.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.networking.eth2.compression;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.xerial.snappy.SnappyFramedInputStream;\n+import org.xerial.snappy.SnappyFramedOutputStream;\n+import tech.pegasys.artemis.util.iostreams.DelegatingInputStream;\n+\n+public class SnappyCompressor implements Compressor {\n+  // The max uncompressed bytes that will be packed into a single frame\n+  // See:\n+  // https://github.com/google/snappy/blob/251d935d5096da77c4fef26ea41b019430da5572/framing_format.txt#L104-L106\n+  static final int MAX_FRAME_CONTENT_SIZE = 65536;\n+\n+  @Override\n+  public Bytes compress(final Bytes data) {\n+\n+    try (final ByteArrayOutputStream out = new ByteArrayOutputStream(data.size() / 2);\n+        final OutputStream compressor = new SnappyFramedOutputStream(out)) {\n+      compressor.write(data.toArrayUnsafe());\n+      compressor.flush();\n+      return Bytes.wrap(out.toByteArray());\n+    } catch (IOException e) {\n+      throw new RuntimeException(\"Failed to compress data\", e);\n+    }\n+  }\n+\n+  @Override\n+  public Bytes uncompress(final InputStream input, final int maxBytes) throws CompressionException {\n+    // This is a bit of a hack - but we don't want to close the underlying stream when\n+    // we close the SnappyFramedInputStream\n+    final UnclosableInputStream wrappedStream = new UnclosableInputStream(input);\n+\n+    try (final InputStream snappyIn = new SnappyFramedInputStream(wrappedStream)) {\n+      return Bytes.wrap(snappyIn.readNBytes(maxBytes));\n+    } catch (IOException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2727a0b183d80178ad6c5487f2307628ebd5a13e"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE2MzM4Nw==", "bodyText": "I can rework the javadoc to make it clear that the maxBytes param is really the expected size of the final payload to uncompress.  If the SnappyFramedInputStream ends up pulling more data than expected from the underlying stream, it means that there's extra data appended that we don't expect, so it's an error anyway.\nThe problem with wrapping the initial input stream is that we're not actually processing a series of snappy data.  For responses, we're processing a sequence of statusCode|lengthPrefix|snappyData.  So it's not really straightforward.  I guess we could wrap the entire inputStream, and then read from the underlying inputStream when we process the status and lengthPrefix, but that seems kind of messy too.", "url": "https://github.com/ConsenSys/teku/pull/1670#discussion_r418163387", "createdAt": "2020-04-30T17:13:20Z", "author": {"login": "mbaxter"}, "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/compression/SnappyCompressor.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.networking.eth2.compression;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.xerial.snappy.SnappyFramedInputStream;\n+import org.xerial.snappy.SnappyFramedOutputStream;\n+import tech.pegasys.artemis.util.iostreams.DelegatingInputStream;\n+\n+public class SnappyCompressor implements Compressor {\n+  // The max uncompressed bytes that will be packed into a single frame\n+  // See:\n+  // https://github.com/google/snappy/blob/251d935d5096da77c4fef26ea41b019430da5572/framing_format.txt#L104-L106\n+  static final int MAX_FRAME_CONTENT_SIZE = 65536;\n+\n+  @Override\n+  public Bytes compress(final Bytes data) {\n+\n+    try (final ByteArrayOutputStream out = new ByteArrayOutputStream(data.size() / 2);\n+        final OutputStream compressor = new SnappyFramedOutputStream(out)) {\n+      compressor.write(data.toArrayUnsafe());\n+      compressor.flush();\n+      return Bytes.wrap(out.toByteArray());\n+    } catch (IOException e) {\n+      throw new RuntimeException(\"Failed to compress data\", e);\n+    }\n+  }\n+\n+  @Override\n+  public Bytes uncompress(final InputStream input, final int maxBytes) throws CompressionException {\n+    // This is a bit of a hack - but we don't want to close the underlying stream when\n+    // we close the SnappyFramedInputStream\n+    final UnclosableInputStream wrappedStream = new UnclosableInputStream(input);\n+\n+    try (final InputStream snappyIn = new SnappyFramedInputStream(wrappedStream)) {\n+      return Bytes.wrap(snappyIn.readNBytes(maxBytes));\n+    } catch (IOException e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY4NDU1MA=="}, "originalCommit": {"oid": "2727a0b183d80178ad6c5487f2307628ebd5a13e"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODIzNTUxOA==", "bodyText": "I reworked the API, but it may be cleaner to try the other approach - I'll experiment.", "url": "https://github.com/ConsenSys/teku/pull/1670#discussion_r418235518", "createdAt": "2020-04-30T19:21:06Z", "author": {"login": "mbaxter"}, "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/compression/SnappyCompressor.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.networking.eth2.compression;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.xerial.snappy.SnappyFramedInputStream;\n+import org.xerial.snappy.SnappyFramedOutputStream;\n+import tech.pegasys.artemis.util.iostreams.DelegatingInputStream;\n+\n+public class SnappyCompressor implements Compressor {\n+  // The max uncompressed bytes that will be packed into a single frame\n+  // See:\n+  // https://github.com/google/snappy/blob/251d935d5096da77c4fef26ea41b019430da5572/framing_format.txt#L104-L106\n+  static final int MAX_FRAME_CONTENT_SIZE = 65536;\n+\n+  @Override\n+  public Bytes compress(final Bytes data) {\n+\n+    try (final ByteArrayOutputStream out = new ByteArrayOutputStream(data.size() / 2);\n+        final OutputStream compressor = new SnappyFramedOutputStream(out)) {\n+      compressor.write(data.toArrayUnsafe());\n+      compressor.flush();\n+      return Bytes.wrap(out.toByteArray());\n+    } catch (IOException e) {\n+      throw new RuntimeException(\"Failed to compress data\", e);\n+    }\n+  }\n+\n+  @Override\n+  public Bytes uncompress(final InputStream input, final int maxBytes) throws CompressionException {\n+    // This is a bit of a hack - but we don't want to close the underlying stream when\n+    // we close the SnappyFramedInputStream\n+    final UnclosableInputStream wrappedStream = new UnclosableInputStream(input);\n+\n+    try (final InputStream snappyIn = new SnappyFramedInputStream(wrappedStream)) {\n+      return Bytes.wrap(snappyIn.readNBytes(maxBytes));\n+    } catch (IOException e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY4NDU1MA=="}, "originalCommit": {"oid": "2727a0b183d80178ad6c5487f2307628ebd5a13e"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMzMTA3Nw==", "bodyText": "Hmm, yeah the fact that it's not all snappy data makes life much more interesting. I don't think it would be right to just always wrap it so maybe better to stick with what we have then.\nThe completely correct answer is probably to read statusCode|lengthPrefix from the input stream, then wrap it with SnappyFramedInputStream and use that to read until the end of that message (even if it's received across multiple Netty reads).  But there's still a risk the snappy stream read past the end of the message which would consume the status code and length prefix of the next message.  So I think we're always dependent on SnappyFramedInputStream not doing any read ahead regardless. If that becomes an issue we may need to contribute to the upstream project or fork it.", "url": "https://github.com/ConsenSys/teku/pull/1670#discussion_r418331077", "createdAt": "2020-04-30T22:46:05Z", "author": {"login": "ajsutton"}, "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/compression/SnappyCompressor.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.networking.eth2.compression;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.xerial.snappy.SnappyFramedInputStream;\n+import org.xerial.snappy.SnappyFramedOutputStream;\n+import tech.pegasys.artemis.util.iostreams.DelegatingInputStream;\n+\n+public class SnappyCompressor implements Compressor {\n+  // The max uncompressed bytes that will be packed into a single frame\n+  // See:\n+  // https://github.com/google/snappy/blob/251d935d5096da77c4fef26ea41b019430da5572/framing_format.txt#L104-L106\n+  static final int MAX_FRAME_CONTENT_SIZE = 65536;\n+\n+  @Override\n+  public Bytes compress(final Bytes data) {\n+\n+    try (final ByteArrayOutputStream out = new ByteArrayOutputStream(data.size() / 2);\n+        final OutputStream compressor = new SnappyFramedOutputStream(out)) {\n+      compressor.write(data.toArrayUnsafe());\n+      compressor.flush();\n+      return Bytes.wrap(out.toByteArray());\n+    } catch (IOException e) {\n+      throw new RuntimeException(\"Failed to compress data\", e);\n+    }\n+  }\n+\n+  @Override\n+  public Bytes uncompress(final InputStream input, final int maxBytes) throws CompressionException {\n+    // This is a bit of a hack - but we don't want to close the underlying stream when\n+    // we close the SnappyFramedInputStream\n+    final UnclosableInputStream wrappedStream = new UnclosableInputStream(input);\n+\n+    try (final InputStream snappyIn = new SnappyFramedInputStream(wrappedStream)) {\n+      return Bytes.wrap(snappyIn.readNBytes(maxBytes));\n+    } catch (IOException e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY4NDU1MA=="}, "originalCommit": {"oid": "2727a0b183d80178ad6c5487f2307628ebd5a13e"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODczMjAyNw==", "bodyText": "The completely correct answer is probably to read statusCode|lengthPrefix from the input stream, then wrap it with SnappyFramedInputStream and use that to read until the end of that message (even if it's received across multiple Netty reads).\n\nThat's pretty much what we're doing now.  But yeah, if snappy reads too much that's still a problem.  Though since we're asking it for a specific number of bytes which should correspond to the full uncompressed payload, it doesn't really have a reason to read beyond the current chunk unless the message is malformed.", "url": "https://github.com/ConsenSys/teku/pull/1670#discussion_r418732027", "createdAt": "2020-05-01T20:50:06Z", "author": {"login": "mbaxter"}, "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/compression/SnappyCompressor.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.networking.eth2.compression;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.xerial.snappy.SnappyFramedInputStream;\n+import org.xerial.snappy.SnappyFramedOutputStream;\n+import tech.pegasys.artemis.util.iostreams.DelegatingInputStream;\n+\n+public class SnappyCompressor implements Compressor {\n+  // The max uncompressed bytes that will be packed into a single frame\n+  // See:\n+  // https://github.com/google/snappy/blob/251d935d5096da77c4fef26ea41b019430da5572/framing_format.txt#L104-L106\n+  static final int MAX_FRAME_CONTENT_SIZE = 65536;\n+\n+  @Override\n+  public Bytes compress(final Bytes data) {\n+\n+    try (final ByteArrayOutputStream out = new ByteArrayOutputStream(data.size() / 2);\n+        final OutputStream compressor = new SnappyFramedOutputStream(out)) {\n+      compressor.write(data.toArrayUnsafe());\n+      compressor.flush();\n+      return Bytes.wrap(out.toByteArray());\n+    } catch (IOException e) {\n+      throw new RuntimeException(\"Failed to compress data\", e);\n+    }\n+  }\n+\n+  @Override\n+  public Bytes uncompress(final InputStream input, final int maxBytes) throws CompressionException {\n+    // This is a bit of a hack - but we don't want to close the underlying stream when\n+    // we close the SnappyFramedInputStream\n+    final UnclosableInputStream wrappedStream = new UnclosableInputStream(input);\n+\n+    try (final InputStream snappyIn = new SnappyFramedInputStream(wrappedStream)) {\n+      return Bytes.wrap(snappyIn.readNBytes(maxBytes));\n+    } catch (IOException e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY4NDU1MA=="}, "originalCommit": {"oid": "2727a0b183d80178ad6c5487f2307628ebd5a13e"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5ODg1MjY0OnYy", "diffSide": "RIGHT", "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/compression/SnappyCompressor.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQwMDoxMzoyM1rOGOVcdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQyMjozMzoyNVrOGO8ozw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY4NDU5Ng==", "bodyText": "We don't ever seem to call this method.", "url": "https://github.com/ConsenSys/teku/pull/1670#discussion_r417684596", "createdAt": "2020-04-30T00:13:23Z", "author": {"login": "ajsutton"}, "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/compression/SnappyCompressor.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.networking.eth2.compression;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.xerial.snappy.SnappyFramedInputStream;\n+import org.xerial.snappy.SnappyFramedOutputStream;\n+import tech.pegasys.artemis.util.iostreams.DelegatingInputStream;\n+\n+public class SnappyCompressor implements Compressor {\n+  // The max uncompressed bytes that will be packed into a single frame\n+  // See:\n+  // https://github.com/google/snappy/blob/251d935d5096da77c4fef26ea41b019430da5572/framing_format.txt#L104-L106\n+  static final int MAX_FRAME_CONTENT_SIZE = 65536;\n+\n+  @Override\n+  public Bytes compress(final Bytes data) {\n+\n+    try (final ByteArrayOutputStream out = new ByteArrayOutputStream(data.size() / 2);\n+        final OutputStream compressor = new SnappyFramedOutputStream(out)) {\n+      compressor.write(data.toArrayUnsafe());\n+      compressor.flush();\n+      return Bytes.wrap(out.toByteArray());\n+    } catch (IOException e) {\n+      throw new RuntimeException(\"Failed to compress data\", e);\n+    }\n+  }\n+\n+  @Override\n+  public Bytes uncompress(final InputStream input, final int maxBytes) throws CompressionException {\n+    // This is a bit of a hack - but we don't want to close the underlying stream when\n+    // we close the SnappyFramedInputStream\n+    final UnclosableInputStream wrappedStream = new UnclosableInputStream(input);\n+\n+    try (final InputStream snappyIn = new SnappyFramedInputStream(wrappedStream)) {\n+      return Bytes.wrap(snappyIn.readNBytes(maxBytes));\n+    } catch (IOException e) {\n+      throw new CompressionException(\"Unable to uncompress data\", e);\n+    }\n+  }\n+\n+  @Override\n+  public int getMaxCompressedLength(final int uncompressedLength) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2727a0b183d80178ad6c5487f2307628ebd5a13e"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE2NDc0Mg==", "bodyText": "This is because we're not strictly enforcing read limits atm.  Added a test that uses this and we'll need it to handle the limits properly.", "url": "https://github.com/ConsenSys/teku/pull/1670#discussion_r418164742", "createdAt": "2020-04-30T17:15:34Z", "author": {"login": "mbaxter"}, "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/compression/SnappyCompressor.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.networking.eth2.compression;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.xerial.snappy.SnappyFramedInputStream;\n+import org.xerial.snappy.SnappyFramedOutputStream;\n+import tech.pegasys.artemis.util.iostreams.DelegatingInputStream;\n+\n+public class SnappyCompressor implements Compressor {\n+  // The max uncompressed bytes that will be packed into a single frame\n+  // See:\n+  // https://github.com/google/snappy/blob/251d935d5096da77c4fef26ea41b019430da5572/framing_format.txt#L104-L106\n+  static final int MAX_FRAME_CONTENT_SIZE = 65536;\n+\n+  @Override\n+  public Bytes compress(final Bytes data) {\n+\n+    try (final ByteArrayOutputStream out = new ByteArrayOutputStream(data.size() / 2);\n+        final OutputStream compressor = new SnappyFramedOutputStream(out)) {\n+      compressor.write(data.toArrayUnsafe());\n+      compressor.flush();\n+      return Bytes.wrap(out.toByteArray());\n+    } catch (IOException e) {\n+      throw new RuntimeException(\"Failed to compress data\", e);\n+    }\n+  }\n+\n+  @Override\n+  public Bytes uncompress(final InputStream input, final int maxBytes) throws CompressionException {\n+    // This is a bit of a hack - but we don't want to close the underlying stream when\n+    // we close the SnappyFramedInputStream\n+    final UnclosableInputStream wrappedStream = new UnclosableInputStream(input);\n+\n+    try (final InputStream snappyIn = new SnappyFramedInputStream(wrappedStream)) {\n+      return Bytes.wrap(snappyIn.readNBytes(maxBytes));\n+    } catch (IOException e) {\n+      throw new CompressionException(\"Unable to uncompress data\", e);\n+    }\n+  }\n+\n+  @Override\n+  public int getMaxCompressedLength(final int uncompressedLength) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY4NDU5Ng=="}, "originalCommit": {"oid": "2727a0b183d80178ad6c5487f2307628ebd5a13e"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMyNjczNQ==", "bodyText": "Update - we're now using this to enforce read limits.", "url": "https://github.com/ConsenSys/teku/pull/1670#discussion_r418326735", "createdAt": "2020-04-30T22:33:25Z", "author": {"login": "mbaxter"}, "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/compression/SnappyCompressor.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.networking.eth2.compression;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.xerial.snappy.SnappyFramedInputStream;\n+import org.xerial.snappy.SnappyFramedOutputStream;\n+import tech.pegasys.artemis.util.iostreams.DelegatingInputStream;\n+\n+public class SnappyCompressor implements Compressor {\n+  // The max uncompressed bytes that will be packed into a single frame\n+  // See:\n+  // https://github.com/google/snappy/blob/251d935d5096da77c4fef26ea41b019430da5572/framing_format.txt#L104-L106\n+  static final int MAX_FRAME_CONTENT_SIZE = 65536;\n+\n+  @Override\n+  public Bytes compress(final Bytes data) {\n+\n+    try (final ByteArrayOutputStream out = new ByteArrayOutputStream(data.size() / 2);\n+        final OutputStream compressor = new SnappyFramedOutputStream(out)) {\n+      compressor.write(data.toArrayUnsafe());\n+      compressor.flush();\n+      return Bytes.wrap(out.toByteArray());\n+    } catch (IOException e) {\n+      throw new RuntimeException(\"Failed to compress data\", e);\n+    }\n+  }\n+\n+  @Override\n+  public Bytes uncompress(final InputStream input, final int maxBytes) throws CompressionException {\n+    // This is a bit of a hack - but we don't want to close the underlying stream when\n+    // we close the SnappyFramedInputStream\n+    final UnclosableInputStream wrappedStream = new UnclosableInputStream(input);\n+\n+    try (final InputStream snappyIn = new SnappyFramedInputStream(wrappedStream)) {\n+      return Bytes.wrap(snappyIn.readNBytes(maxBytes));\n+    } catch (IOException e) {\n+      throw new CompressionException(\"Unable to uncompress data\", e);\n+    }\n+  }\n+\n+  @Override\n+  public int getMaxCompressedLength(final int uncompressedLength) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY4NDU5Ng=="}, "originalCommit": {"oid": "2727a0b183d80178ad6c5487f2307628ebd5a13e"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5ODg2NzgyOnYy", "diffSide": "RIGHT", "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/rpc/core/Eth2OutgoingRequestHandler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQwMDoyMjowOVrOGOVl3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQwMDoyMjowOVrOGOVl3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY4NzAwNQ==", "bodyText": "In terms of being able to re-use the one input stream instead of discarding the wrapper each time - I wonder if responseDecoder rather than being used directly could be changed to something like responseDecoder.forInputStream(input) and that returns an object that provides the decodeNextResponse methods - then it'd be able to hold onto the one snappy wrapper stream.  I think you'd have to do the same trick with RpcEncoding having a decoderFor(InputStream) kind of method too and maybe again at the actual Compressor level.\nUnfortunate amount of boiler plate code there but SnappyFramedInputStream has a frameHeader buffer which worries me that would could potentially lose bytes.", "url": "https://github.com/ConsenSys/teku/pull/1670#discussion_r417687005", "createdAt": "2020-04-30T00:22:09Z", "author": {"login": "ajsutton"}, "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/rpc/core/Eth2OutgoingRequestHandler.java", "diffHunk": "@@ -57,56 +58,70 @@ public Eth2OutgoingRequestHandler(\n \n     responseProcessor =\n         new AsyncResponseProcessor<>(asyncRunner, responseStream, this::onAsyncProcessorError);\n-    responseHandler = new ResponseRpcDecoder<>(responseProcessor::processResponse, this.method);\n+    responseDecoder = method.createResponseDecoder();\n   }\n \n-  @Override\n-  public void onActivation(final RpcStream rpcStream) {\n-    this.rpcStream = rpcStream;\n+  public void handleInitialPayloadSent(final RpcStream stream) {\n+    this.rpcStream = stream;\n+\n+    if (method.shouldReceiveResponse()) {\n+      // Close the write side of the stream\n+      stream.closeWriteStream().reportExceptions();\n+      // Start timer for first bytes\n+      ensureFirstBytesArriveWithinTimeLimit(stream);\n+    } else {\n+      // If we're not expecting any response, complete the request\n+      completeRequest(stream);\n+    }\n   }\n \n   @Override\n-  public void onData(final NodeId nodeId, final RpcStream rpcStream, final ByteBuf bytes) {\n+  public void processInput(\n+      final NodeId nodeId, final RpcStream rpcStream, final InputStream input) {\n     try {\n-      if (hasReceivedInitialBytes.compareAndSet(false, true)) {\n-        // Setup initial chunk timeout\n-        ensureNextResponseArrivesInTime(rpcStream, currentChunkCount.get(), currentChunkCount);\n-      }\n-      LOG.trace(\"Requester received {} bytes.\", bytes.capacity());\n-      responseHandler.onDataReceived(bytes);\n-\n-      final int previousResponseCount = currentChunkCount.get();\n-      currentChunkCount.set(responseProcessor.getResponseCount());\n-      if (currentChunkCount.get() >= maximumResponseChunks) {\n-        completeRequest(rpcStream);\n-      } else if (currentChunkCount.get() > previousResponseCount) {\n-        ensureNextResponseArrivesInTime(rpcStream, currentChunkCount.get(), currentChunkCount);\n+      this.rpcStream = rpcStream;\n+\n+      Optional<TResponse> maybeResponse =\n+          responseDecoder.decodeNextResponse(input, this::onFirstByteReceived);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2727a0b183d80178ad6c5487f2307628ebd5a13e"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5ODg5Nzg5OnYy", "diffSide": "RIGHT", "path": "networking/eth2/src/test/java/tech/pegasys/artemis/networking/eth2/compression/SnappyCompressorTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQwMDozNjozNVrOGOV3PQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQyMjozNDowMFrOGO8plA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY5MTQ1Mw==", "bodyText": "We probably want to get this test working before we merge.  Will unfortunately have to be multithreaded I guess and likely not all that easy to write but seems quite important.", "url": "https://github.com/ConsenSys/teku/pull/1670#discussion_r417691453", "createdAt": "2020-04-30T00:36:35Z", "author": {"login": "ajsutton"}, "path": "networking/eth2/src/test/java/tech/pegasys/artemis/networking/eth2/compression/SnappyCompressorTest.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.networking.eth2.compression;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static tech.pegasys.artemis.networking.eth2.compression.SnappyCompressor.MAX_FRAME_CONTENT_SIZE;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.InputStream;\n+import java.io.PipedInputStream;\n+import java.io.PipedOutputStream;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.util.DataStructureUtil;\n+import tech.pegasys.artemis.datastructures.util.SimpleOffsetSerializer;\n+\n+public class SnappyCompressorTest {\n+  private final DataStructureUtil dataStructureUtil = new DataStructureUtil();\n+  private final Compressor compressor = new SnappyCompressor();\n+\n+  @Test\n+  public void roundTrip() throws Exception {\n+    final BeaconState state = dataStructureUtil.randomBeaconState(0);\n+    final Bytes serializedState =\n+        Bytes.wrap(SimpleOffsetSerializer.serialize(state).toArrayUnsafe());\n+\n+    final Bytes compressed = compressor.compress(serializedState);\n+    assertThat(compressed).isNotEqualTo(serializedState);\n+\n+    final Bytes uncompressed = compressor.uncompress(compressed);\n+    assertThat(uncompressed).isEqualTo(serializedState);\n+  }\n+\n+  @Test\n+  public void uncompress_invalidData() {\n+    final BeaconState state = dataStructureUtil.randomBeaconState(0);\n+    final Bytes serializedState =\n+        Bytes.wrap(SimpleOffsetSerializer.serialize(state).toArrayUnsafe());\n+\n+    assertThatThrownBy(() -> compressor.uncompress(serializedState))\n+        .isInstanceOf(CompressionException.class);\n+  }\n+\n+  @Test\n+  public void uncompress_seriesOfValues() throws Exception {\n+    final BeaconState stateA = dataStructureUtil.randomBeaconState(0);\n+    final BeaconState stateB = dataStructureUtil.randomBeaconState(1);\n+    final Bytes serializedStateA =\n+        Bytes.wrap(SimpleOffsetSerializer.serialize(stateA).toArrayUnsafe());\n+    final Bytes serializedStateB =\n+        Bytes.wrap(SimpleOffsetSerializer.serialize(stateB).toArrayUnsafe());\n+\n+    final Bytes compressedA = compressor.compress(serializedStateA);\n+    final Bytes compressedB = compressor.compress(serializedStateB);\n+    final Bytes compressedSeries = Bytes.concatenate(compressedA, compressedB);\n+    final InputStream input = new ByteArrayInputStream(compressedSeries.toArrayUnsafe());\n+\n+    // Get first value\n+    final Bytes uncompressed = compressor.uncompress(input, serializedStateA.size());\n+    assertThat(uncompressed).isEqualTo(serializedStateA);\n+    // Then next value\n+    final Bytes uncompressed2 = compressor.uncompress(input, serializedStateB.size());\n+    assertThat(uncompressed2).isEqualTo(serializedStateB);\n+    // Input stream should now be closed\n+    assertThat(input.available()).isEqualTo(0);\n+    assertThat(input.read()).isEqualTo(-1);\n+  }\n+\n+  @Test\n+  public void uncompress_partialValue() throws Exception {\n+    final BeaconState state = dataStructureUtil.randomBeaconState(0);\n+    final Bytes serializedState =\n+        Bytes.wrap(SimpleOffsetSerializer.serialize(state).toArrayUnsafe());\n+\n+    final Bytes compressed = compressor.compress(serializedState);\n+    final int maxBytes = MAX_FRAME_CONTENT_SIZE / 2;\n+    // Check assumptions\n+    assertThat(serializedState.size()).isGreaterThan(MAX_FRAME_CONTENT_SIZE);\n+\n+    final InputStream input = new ByteArrayInputStream(compressed.toArrayUnsafe());\n+    final Bytes uncompressed = compressor.uncompress(input, maxBytes);\n+    assertThat(uncompressed.size()).isLessThanOrEqualTo(maxBytes);\n+  }\n+\n+  @Test\n+  @Disabled(\"SnappyCompressor will currently block in this case\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2727a0b183d80178ad6c5487f2307628ebd5a13e"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMyNjkzMg==", "bodyText": "This test is enabled and works now.", "url": "https://github.com/ConsenSys/teku/pull/1670#discussion_r418326932", "createdAt": "2020-04-30T22:34:00Z", "author": {"login": "mbaxter"}, "path": "networking/eth2/src/test/java/tech/pegasys/artemis/networking/eth2/compression/SnappyCompressorTest.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.networking.eth2.compression;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static tech.pegasys.artemis.networking.eth2.compression.SnappyCompressor.MAX_FRAME_CONTENT_SIZE;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.InputStream;\n+import java.io.PipedInputStream;\n+import java.io.PipedOutputStream;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.util.DataStructureUtil;\n+import tech.pegasys.artemis.datastructures.util.SimpleOffsetSerializer;\n+\n+public class SnappyCompressorTest {\n+  private final DataStructureUtil dataStructureUtil = new DataStructureUtil();\n+  private final Compressor compressor = new SnappyCompressor();\n+\n+  @Test\n+  public void roundTrip() throws Exception {\n+    final BeaconState state = dataStructureUtil.randomBeaconState(0);\n+    final Bytes serializedState =\n+        Bytes.wrap(SimpleOffsetSerializer.serialize(state).toArrayUnsafe());\n+\n+    final Bytes compressed = compressor.compress(serializedState);\n+    assertThat(compressed).isNotEqualTo(serializedState);\n+\n+    final Bytes uncompressed = compressor.uncompress(compressed);\n+    assertThat(uncompressed).isEqualTo(serializedState);\n+  }\n+\n+  @Test\n+  public void uncompress_invalidData() {\n+    final BeaconState state = dataStructureUtil.randomBeaconState(0);\n+    final Bytes serializedState =\n+        Bytes.wrap(SimpleOffsetSerializer.serialize(state).toArrayUnsafe());\n+\n+    assertThatThrownBy(() -> compressor.uncompress(serializedState))\n+        .isInstanceOf(CompressionException.class);\n+  }\n+\n+  @Test\n+  public void uncompress_seriesOfValues() throws Exception {\n+    final BeaconState stateA = dataStructureUtil.randomBeaconState(0);\n+    final BeaconState stateB = dataStructureUtil.randomBeaconState(1);\n+    final Bytes serializedStateA =\n+        Bytes.wrap(SimpleOffsetSerializer.serialize(stateA).toArrayUnsafe());\n+    final Bytes serializedStateB =\n+        Bytes.wrap(SimpleOffsetSerializer.serialize(stateB).toArrayUnsafe());\n+\n+    final Bytes compressedA = compressor.compress(serializedStateA);\n+    final Bytes compressedB = compressor.compress(serializedStateB);\n+    final Bytes compressedSeries = Bytes.concatenate(compressedA, compressedB);\n+    final InputStream input = new ByteArrayInputStream(compressedSeries.toArrayUnsafe());\n+\n+    // Get first value\n+    final Bytes uncompressed = compressor.uncompress(input, serializedStateA.size());\n+    assertThat(uncompressed).isEqualTo(serializedStateA);\n+    // Then next value\n+    final Bytes uncompressed2 = compressor.uncompress(input, serializedStateB.size());\n+    assertThat(uncompressed2).isEqualTo(serializedStateB);\n+    // Input stream should now be closed\n+    assertThat(input.available()).isEqualTo(0);\n+    assertThat(input.read()).isEqualTo(-1);\n+  }\n+\n+  @Test\n+  public void uncompress_partialValue() throws Exception {\n+    final BeaconState state = dataStructureUtil.randomBeaconState(0);\n+    final Bytes serializedState =\n+        Bytes.wrap(SimpleOffsetSerializer.serialize(state).toArrayUnsafe());\n+\n+    final Bytes compressed = compressor.compress(serializedState);\n+    final int maxBytes = MAX_FRAME_CONTENT_SIZE / 2;\n+    // Check assumptions\n+    assertThat(serializedState.size()).isGreaterThan(MAX_FRAME_CONTENT_SIZE);\n+\n+    final InputStream input = new ByteArrayInputStream(compressed.toArrayUnsafe());\n+    final Bytes uncompressed = compressor.uncompress(input, maxBytes);\n+    assertThat(uncompressed.size()).isLessThanOrEqualTo(maxBytes);\n+  }\n+\n+  @Test\n+  @Disabled(\"SnappyCompressor will currently block in this case\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY5MTQ1Mw=="}, "originalCommit": {"oid": "2727a0b183d80178ad6c5487f2307628ebd5a13e"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5ODkxMzY4OnYy", "diffSide": "RIGHT", "path": "networking/p2p/src/main/java/tech/pegasys/artemis/networking/p2p/libp2p/rpc/RpcHandler.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQwMDo0NToyNlrOGOWAgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQwMDo0NToyNlrOGOWAgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY5MzgyNg==", "bodyText": "On the plus side, copying the data means we don't have to manage retaining and releasing the ByteBuf if we jump threads later.  So unless this shows up as a significant performance issue it would be great to leave as-is.", "url": "https://github.com/ConsenSys/teku/pull/1670#discussion_r417693826", "createdAt": "2020-04-30T00:45:26Z", "author": {"login": "ajsutton"}, "path": "networking/p2p/src/main/java/tech/pegasys/artemis/networking/p2p/libp2p/rpc/RpcHandler.java", "diffHunk": "@@ -157,10 +174,18 @@ public RpcStream getRpcStream() {\n \n     @Override\n     protected void channelRead0(final ChannelHandlerContext ctx, final ByteBuf msg) {\n-      if (rpcRequestHandler != null) {\n-        rpcRequestHandler.onData(nodeId, rpcStream, msg);\n-      } else {\n-        bufferedData.add(msg);\n+      if (outputStreamClosed) {\n+        // Discard any data if output stream has been closed\n+        return;\n+      }\n+      try {\n+        // TODO - we may want to optimize this to pass on ByteBuf's directly and manage their\n+        //  garbage collection rather than immediately copying these bytes\n+        final Bytes bytes = Bytes.wrapByteBuf(msg);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2727a0b183d80178ad6c5487f2307628ebd5a13e"}, "originalPosition": 77}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3730, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}