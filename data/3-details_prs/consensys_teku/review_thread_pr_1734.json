{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE0ODg5NDg2", "number": 1734, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QyMDowMDoxMlrOD6ZlEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwNzoyODoxMVrOD7hkHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyNTYzMDg5OnYy", "diffSide": "LEFT", "path": "storage/src/main/java/tech/pegasys/teku/storage/client/CombinedChainDataClient.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QyMDowMDoxMlrOGSOJvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QyMTowNjoyMFrOGSQR5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc1OTQyMA==", "bodyText": "I don't see why we need a special case for the first epoch / genesis block, so I cut this.  But if there's a valid reason, I can add this back in.", "url": "https://github.com/ConsenSys/teku/pull/1734#discussion_r421759420", "createdAt": "2020-05-07T20:00:12Z", "author": {"login": "mbaxter"}, "path": "storage/src/main/java/tech/pegasys/teku/storage/client/CombinedChainDataClient.java", "diffHunk": "@@ -149,11 +147,6 @@ public CombinedChainDataClient(\n     return getBlockByBlockRoot(get_block_root_at_slot(state, slot));\n   }\n \n-  private boolean isHistoricalData(final UnsignedLong slot) {\n-    final boolean finalizedPastFirstEpoch = !recentChainData.getFinalizedEpoch().equals(ZERO);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "518e985375492373d2a2073b1d0dc12cca1d151f"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc4NDY1Ng==", "bodyText": "I believe it was added because we were always going to disk to retrieve the genesis state due to it being inherently finalised.  But I think we've fixed isFinalized now so the last finalized slot is expected to be in memory.\nBasically as long as the genesis state is retrieved from the memory store instead of disk it's fine to cut it.", "url": "https://github.com/ConsenSys/teku/pull/1734#discussion_r421784656", "createdAt": "2020-05-07T20:48:54Z", "author": {"login": "ajsutton"}, "path": "storage/src/main/java/tech/pegasys/teku/storage/client/CombinedChainDataClient.java", "diffHunk": "@@ -149,11 +147,6 @@ public CombinedChainDataClient(\n     return getBlockByBlockRoot(get_block_root_at_slot(state, slot));\n   }\n \n-  private boolean isHistoricalData(final UnsignedLong slot) {\n-    final boolean finalizedPastFirstEpoch = !recentChainData.getFinalizedEpoch().equals(ZERO);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc1OTQyMA=="}, "originalCommit": {"oid": "518e985375492373d2a2073b1d0dc12cca1d151f"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc5NDI3OQ==", "bodyText": "Ok, so basically we want to retrieve latest finalized data from memory, whether or not its on the epoch boundary?  And this applies for all finalized data, not just genesis?", "url": "https://github.com/ConsenSys/teku/pull/1734#discussion_r421794279", "createdAt": "2020-05-07T21:06:20Z", "author": {"login": "mbaxter"}, "path": "storage/src/main/java/tech/pegasys/teku/storage/client/CombinedChainDataClient.java", "diffHunk": "@@ -149,11 +147,6 @@ public CombinedChainDataClient(\n     return getBlockByBlockRoot(get_block_root_at_slot(state, slot));\n   }\n \n-  private boolean isHistoricalData(final UnsignedLong slot) {\n-    final boolean finalizedPastFirstEpoch = !recentChainData.getFinalizedEpoch().equals(ZERO);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTc1OTQyMA=="}, "originalCommit": {"oid": "518e985375492373d2a2073b1d0dc12cca1d151f"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzNjM0NDQ2OnYy", "diffSide": "RIGHT", "path": "storage/src/main/java/tech/pegasys/teku/storage/server/rocksdb/RocksDbDatabase.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQyMjowOToxN1rOGTvJNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQyMjowOToxN1rOGTvJNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzM0ODUzMg==", "bodyText": "Created this RocksDbAccessor interface so that we could have a mock in-memory replacement for the core RocksDB access logic.  Not super happy with the current implementation, but leaving a larger refactor for the future since we have active development in this area.", "url": "https://github.com/ConsenSys/teku/pull/1734#discussion_r423348532", "createdAt": "2020-05-11T22:09:17Z", "author": {"login": "mbaxter"}, "path": "storage/src/main/java/tech/pegasys/teku/storage/server/rocksdb/RocksDbDatabase.java", "diffHunk": "@@ -53,7 +53,11 @@\n \n   public static Database createV3(\n       final RocksDbConfiguration configuration, final StateStorageMode stateStorageMode) {\n-    final RocksDbInstance db = RocksDbInstanceFactory.create(configuration, V3Schema.class);\n+    final RocksDbAccessor db = RocksDbInstanceFactory.create(configuration, V3Schema.class);\n+    return createV3(db, stateStorageMode);\n+  }\n+\n+  static Database createV3(final RocksDbAccessor db, final StateStorageMode stateStorageMode) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3ab1f4f47ad4d4c8814fb98f41e0d66a07ebf05"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzNzQxMDczOnYy", "diffSide": "RIGHT", "path": "storage/src/main/java/tech/pegasys/teku/storage/client/CombinedChainDataClient.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwNzoyNDowMlrOGT5aJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQxNToyMzoxOVrOGUMFiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUxNjcwOQ==", "bodyText": "Aren't we at risk of race conditions here?  ie we check if the slot is recent and it is, but then before we actually get the block the store is changed and the slot we're interested in is dropped.  Seems like we should try to get it from the Store and if it's not there, then fall back to getting it from disk.  That would be a reasonable way to handle the case where we need to request a block that's more than SLOTS_PER_HISTORICAL_ROOT behind the current state as well - we'd fail to get it from the store and fallback to getting it from disk.", "url": "https://github.com/ConsenSys/teku/pull/1734#discussion_r423516709", "createdAt": "2020-05-12T07:24:02Z", "author": {"login": "ajsutton"}, "path": "storage/src/main/java/tech/pegasys/teku/storage/client/CombinedChainDataClient.java", "diffHunk": "@@ -107,7 +106,7 @@ public CombinedChainDataClient(\n       LOG.trace(\"Block root at slot {} is the specified head block root\", slot);\n       return getBlockByBlockRoot(headBlockRoot);\n     }\n-    if (isHistoricalData(slot)) {\n+    if (!isRecentData(slot)) {\n       LOG.trace(\"Block at slot {} is in a finalized epoch. Retrieving from historical data\", slot);\n       return historicalChainData.getLatestFinalizedBlockAtSlot(slot);\n     }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca5968a7e94eb866c2528baa5e5c98d3fdd404c1"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzgyMjczMQ==", "bodyText": "I think this method currently has a few problems - coming back to it in a follow-up PR.", "url": "https://github.com/ConsenSys/teku/pull/1734#discussion_r423822731", "createdAt": "2020-05-12T15:23:19Z", "author": {"login": "mbaxter"}, "path": "storage/src/main/java/tech/pegasys/teku/storage/client/CombinedChainDataClient.java", "diffHunk": "@@ -107,7 +106,7 @@ public CombinedChainDataClient(\n       LOG.trace(\"Block root at slot {} is the specified head block root\", slot);\n       return getBlockByBlockRoot(headBlockRoot);\n     }\n-    if (isHistoricalData(slot)) {\n+    if (!isRecentData(slot)) {\n       LOG.trace(\"Block at slot {} is in a finalized epoch. Retrieving from historical data\", slot);\n       return historicalChainData.getLatestFinalizedBlockAtSlot(slot);\n     }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUxNjcwOQ=="}, "originalCommit": {"oid": "ca5968a7e94eb866c2528baa5e5c98d3fdd404c1"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzNzQyNDk1OnYy", "diffSide": "RIGHT", "path": "storage/src/main/java/tech/pegasys/teku/storage/server/rocksdb/schema/Schema.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwNzoyODoxMVrOGT5jAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwNzoyODoxMVrOGT5jAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUxODk3Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    .filter(f -> (f.getModifiers() & Modifier.STATIC) > 0)\n          \n          \n            \n                    .filter(f -> Modifiers.isState(f.getModifiers()))\n          \n      \n    \n    \n  \n\nand could apply the same change above in streamColumns because apparently you should use the java.lang.reflect.Modifiers class to decode modifiers...", "url": "https://github.com/ConsenSys/teku/pull/1734#discussion_r423518976", "createdAt": "2020-05-12T07:28:11Z", "author": {"login": "ajsutton"}, "path": "storage/src/main/java/tech/pegasys/teku/storage/server/rocksdb/schema/Schema.java", "diffHunk": "@@ -35,4 +35,18 @@\n               }\n             });\n   }\n+\n+  static Stream<RocksDbVariable<?>> streamVariables(Class<? extends Schema> schema) {\n+    return Arrays.stream(schema.getDeclaredFields())\n+        .filter(f -> (f.getModifiers() & Modifier.STATIC) > 0)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca5968a7e94eb866c2528baa5e5c98d3fdd404c1"}, "originalPosition": 7}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3773, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}