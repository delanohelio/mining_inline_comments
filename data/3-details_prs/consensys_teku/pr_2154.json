{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM0ODcyNjUx", "number": 2154, "title": "Integrate fork choice tests", "bodyText": "Preliminary version of fork choice integration tests (based on v0.11.3 currently).", "createdAt": "2020-06-15T23:17:43Z", "url": "https://github.com/ConsenSys/teku/pull/2154", "merged": true, "mergeCommit": {"oid": "7b97ccb247d698055dbb91fa8d0117002b589b38"}, "closed": true, "closedAt": "2020-06-16T17:10:35Z", "author": {"login": "ericsson49"}, "timelineItems": {"totalCount": 22, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcrpAoCgH2gAyNDM0ODcyNjUxOmNmMzNhMWJhZTM5YjdhYjhjZjFlZTM5ODhhNWZlOWU2ZTNmNDI4ZGY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcr3DkRAFqTQzMTYzNDY0NQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "cf33a1bae39b7ab8cf1ee3988a5fe9e6e3f428df", "author": {"user": {"login": "ericsson49", "name": "Alex Vlasov"}}, "url": "https://github.com/ConsenSys/teku/commit/cf33a1bae39b7ab8cf1ee3988a5fe9e6e3f428df", "committedDate": "2020-06-15T23:11:37Z", "message": "initial commit of fork choice description files"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a4213ec2cf921339858668e29bb381dcc57af863", "author": {"user": {"login": "ericsson49", "name": "Alex Vlasov"}}, "url": "https://github.com/ConsenSys/teku/commit/a4213ec2cf921339858668e29bb381dcc57af863", "committedDate": "2020-06-15T23:12:34Z", "message": "Initial commit of fork choice test executor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "50e427436b40a54201f4fa68b08e46bbfce5e663", "author": {"user": {"login": "ericsson49", "name": "Alex Vlasov"}}, "url": "https://github.com/ConsenSys/teku/commit/50e427436b40a54201f4fa68b08e46bbfce5e663", "committedDate": "2020-06-15T23:13:34Z", "message": "Add ForkChoiceTestFinder"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "954b55d09b3c74e96ef78f7902a931b9c2e3cb35", "author": {"user": {"login": "ericsson49", "name": "Alex Vlasov"}}, "url": "https://github.com/ConsenSys/teku/commit/954b55d09b3c74e96ef78f7902a931b9c2e3cb35", "committedDate": "2020-06-15T23:30:44Z", "message": "Merge branch 'master' into integrateForkChoiceTests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d042217413a8ed4b3a2bfe4c9637c51d2df58832", "author": {"user": {"login": "ericsson49", "name": "Alex Vlasov"}}, "url": "https://github.com/ConsenSys/teku/commit/d042217413a8ed4b3a2bfe4c9637c51d2df58832", "committedDate": "2020-06-15T23:48:02Z", "message": "initial commit of fork choice description files"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6842b775aeb3ee1ad32f3fc56ef8c68166929263", "author": {"user": {"login": "ericsson49", "name": "Alex Vlasov"}}, "url": "https://github.com/ConsenSys/teku/commit/6842b775aeb3ee1ad32f3fc56ef8c68166929263", "committedDate": "2020-06-15T23:48:02Z", "message": "Initial commit of fork choice test executor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1e651b5902bc7de3b1114343b88b53ab704ff89b", "author": {"user": {"login": "ericsson49", "name": "Alex Vlasov"}}, "url": "https://github.com/ConsenSys/teku/commit/1e651b5902bc7de3b1114343b88b53ab704ff89b", "committedDate": "2020-06-15T23:48:02Z", "message": "Add ForkChoiceTestFinder"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fdd8ee9386e4f24c56d8cfa50c13ea2b37b2274e", "author": {"user": {"login": "ericsson49", "name": "Alex Vlasov"}}, "url": "https://github.com/ConsenSys/teku/commit/fdd8ee9386e4f24c56d8cfa50c13ea2b37b2274e", "committedDate": "2020-06-15T23:52:31Z", "message": "Merge remote-tracking branch 'origin/integrateForkChoiceTests' into integrateForkChoiceTests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxNTQ5MTIy", "url": "https://github.com/ConsenSys/teku/pull/2154#pullrequestreview-431549122", "createdAt": "2020-06-16T14:13:26Z", "commit": {"oid": "fdd8ee9386e4f24c56d8cfa50c13ea2b37b2274e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxNDoxMzoyNlrOGkdZMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxNDoxMzoyNlrOGkdZMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDg4MzUwNw==", "bodyText": "nit: Seems like lines 67 to 72 are stale.", "url": "https://github.com/ConsenSys/teku/pull/2154#discussion_r440883507", "createdAt": "2020-06-16T14:13:26Z", "author": {"login": "cemozerr"}, "path": "eth-reference-tests/src/referenceTest/java/tech/pegasys/teku/reference/phase0/fork_choice/ForkChoiceTestExecutor.java", "diffHunk": "@@ -0,0 +1,309 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.reference.phase0.fork_choice;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.primitives.UnsignedLong;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import tech.pegasys.teku.core.ForkChoiceUtil;\n+import tech.pegasys.teku.core.StateTransition;\n+import tech.pegasys.teku.core.results.BlockImportResult;\n+import tech.pegasys.teku.datastructures.attestation.ValidateableAttestation;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.operations.Attestation;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.datastructures.state.BeaconStateImpl;\n+import tech.pegasys.teku.datastructures.util.AttestationProcessingResult;\n+import tech.pegasys.teku.datastructures.util.SimpleOffsetSerializer;\n+import tech.pegasys.teku.ethtests.finder.ReferenceTestFinder;\n+import tech.pegasys.teku.ethtests.finder.TestDefinition;\n+import tech.pegasys.teku.protoarray.ForkChoiceStrategy;\n+import tech.pegasys.teku.protoarray.ProtoArrayForkChoiceStrategy;\n+import tech.pegasys.teku.reference.phase0.TestExecutor;\n+import tech.pegasys.teku.storage.client.MemoryOnlyRecentChainData;\n+import tech.pegasys.teku.storage.client.RecentChainData;\n+import tech.pegasys.teku.storage.store.UpdatableStore;\n+\n+public class ForkChoiceTestExecutor implements TestExecutor {\n+  private static final ObjectMapper mapper = new ObjectMapper(new YAMLFactory());\n+\n+  public static ImmutableMap<String, TestExecutor> FORK_CHOICE_TEST_TYPES =\n+      ImmutableMap.of(\"fork_choice/integration_tests\", new ForkChoiceTestExecutor());\n+\n+  public static Stream<Arguments> loadForkChoiceTests() throws Exception {\n+    Path rootDirectory = ReferenceTestFinder.findReferenceTestRootDirectory();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fdd8ee9386e4f24c56d8cfa50c13ea2b37b2274e"}, "originalPosition": 67}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e1bfb85dc784c37d1959dec26523a80ead7ac647", "author": {"user": {"login": "ericsson49", "name": "Alex Vlasov"}}, "url": "https://github.com/ConsenSys/teku/commit/e1bfb85dc784c37d1959dec26523a80ead7ac647", "committedDate": "2020-06-16T14:25:03Z", "message": "Merge remote-tracking branch 'upstream/master' into integrateForkChoiceTests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "003014cefc8cbc31fd0b0bad8a5fd4ce825ba3cc", "author": {"user": {"login": "ericsson49", "name": "Alex Vlasov"}}, "url": "https://github.com/ConsenSys/teku/commit/003014cefc8cbc31fd0b0bad8a5fd4ce825ba3cc", "committedDate": "2020-06-16T14:26:02Z", "message": "Clean up stale code"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxNTg2NDkw", "url": "https://github.com/ConsenSys/teku/pull/2154#pullrequestreview-431586490", "createdAt": "2020-06-16T14:49:58Z", "commit": {"oid": "003014cefc8cbc31fd0b0bad8a5fd4ce825ba3cc"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxNDo0OTo1OFrOGkfG0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxNDo0OTo1OFrOGkfG0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDkxMTU2OQ==", "bodyText": "What I understand is that: we try to process the block, and if it's unsuccessful, we add it to the blockBuffer, and then at the next step we try to process it again. Should we not be failing (throwing an error) if block or attestation processing fails? I'm assuming we're not failing on purpose.", "url": "https://github.com/ConsenSys/teku/pull/2154#discussion_r440911569", "createdAt": "2020-06-16T14:49:58Z", "author": {"login": "cemozerr"}, "path": "eth-reference-tests/src/referenceTest/java/tech/pegasys/teku/reference/phase0/fork_choice/ForkChoiceTestExecutor.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.reference.phase0.fork_choice;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.primitives.UnsignedLong;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import tech.pegasys.teku.core.ForkChoiceUtil;\n+import tech.pegasys.teku.core.StateTransition;\n+import tech.pegasys.teku.core.results.BlockImportResult;\n+import tech.pegasys.teku.datastructures.attestation.ValidateableAttestation;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.operations.Attestation;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.datastructures.state.BeaconStateImpl;\n+import tech.pegasys.teku.datastructures.util.AttestationProcessingResult;\n+import tech.pegasys.teku.datastructures.util.SimpleOffsetSerializer;\n+import tech.pegasys.teku.ethtests.finder.TestDefinition;\n+import tech.pegasys.teku.protoarray.ForkChoiceStrategy;\n+import tech.pegasys.teku.protoarray.ProtoArrayForkChoiceStrategy;\n+import tech.pegasys.teku.reference.phase0.TestExecutor;\n+import tech.pegasys.teku.storage.client.MemoryOnlyRecentChainData;\n+import tech.pegasys.teku.storage.client.RecentChainData;\n+import tech.pegasys.teku.storage.store.UpdatableStore;\n+\n+public class ForkChoiceTestExecutor implements TestExecutor {\n+  private static final ObjectMapper mapper = new ObjectMapper(new YAMLFactory());\n+\n+  public static ImmutableMap<String, TestExecutor> FORK_CHOICE_TEST_TYPES =\n+      ImmutableMap.of(\"fork_choice/integration_tests\", new ForkChoiceTestExecutor());\n+\n+  public static Stream<Arguments> loadForkChoiceTests() {\n+    Path path =\n+        Paths.get(\n+            \"src/referenceTest/java/tech/pegasys/teku/reference/phase0/fork_choice/integration_tests/\");\n+    List<File> testFiles = findForkChoiceTestsByPath(path);\n+    return testFiles.stream().flatMap(file -> parseForkChoiceFile(file.toPath()).stream());\n+  }\n+\n+  private static Optional<? extends Arguments> parseForkChoiceFile(Path path) {\n+    File file = path.toFile();\n+    try {\n+      @SuppressWarnings(\"rawtypes\")\n+      Map content = mapper.readValue(file, Map.class);\n+\n+      if (content.containsKey(\"steps\")) {\n+        BeaconStateImpl genesisState =\n+            resolvePart(BeaconStateImpl.class, file, content.get(\"genesis\"));\n+\n+        @SuppressWarnings(\"unchecked\")\n+        List<Object> steps =\n+            ((List<Map<String, Object>>) content.get(\"steps\"))\n+                .stream().map(step -> extractTestStep(file, step)).collect(Collectors.toList());\n+        return Optional.of(Arguments.of(genesisState, steps, file.getName(), true));\n+      } else {\n+        return Optional.empty();\n+      }\n+    } catch (IOException e) {\n+      return Optional.empty();\n+    }\n+  }\n+\n+  private static List<File> findForkChoiceTestsByPath(Path path) {\n+    try (Stream<Path> paths = Files.walk(path)) {\n+      return paths\n+          .filter(p -> Files.isRegularFile(p) && !p.getParent().endsWith(\"cache\"))\n+          .map(Path::toFile)\n+          .filter(f -> f.getName().endsWith(\".yaml\"))\n+          .collect(Collectors.toList());\n+    } catch (IOException e) {\n+      return Collections.emptyList();\n+    }\n+  }\n+\n+  private static Object extractTestStep(File file, Map<String, Object> stepDescription) {\n+    ForkChoiceTestStep stepKind = getStepKind(stepDescription);\n+    Object value = stepDescription.get(stepKind.name());\n+\n+    switch (stepKind) {\n+      case slot:\n+        {\n+          return UnsignedLong.valueOf((Integer) value);\n+        }\n+      case block:\n+        {\n+          return resolvePart(SignedBeaconBlock.class, file, value);\n+        }\n+      case attestation:\n+        {\n+          return resolvePart(Attestation.class, file, value);\n+        }\n+      case checks:\n+        {\n+          return value;\n+        }\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported step kind \" + stepKind);\n+    }\n+  }\n+\n+  private static ForkChoiceTestStep getStepKind(Map<String, Object> ss) {\n+    return ss.keySet().stream()\n+        .map(ForkChoiceTestStep::valueOf)\n+        .collect(Collectors.toList())\n+        .get(0);\n+  }\n+\n+  private static <T> T resolvePart(Class<T> clazz, File testFile, Object value) {\n+    if (value instanceof String) {\n+      String path = (String) value;\n+      if (path.endsWith(\".yaml\") || path.endsWith(\".ssz\")) {\n+        Path partPath = Paths.get(testFile.getParentFile().getParent(), \"cache\", path);\n+        try {\n+          if (path.endsWith(\".ssz\")) {\n+            return SimpleOffsetSerializer.deserialize(\n+                Bytes.wrap(Files.readAllBytes(partPath)), clazz);\n+          } else {\n+            return mapper.readValue(partPath.toFile(), clazz);\n+          }\n+        } catch (IOException e) {\n+          throw new IllegalArgumentException(\"Couldn't resolve \" + path + \": \" + e.getMessage());\n+        }\n+      }\n+    }\n+    return clazz.cast(value);\n+  }\n+\n+  @Override\n+  public void runTest(TestDefinition testDefinition) throws Throwable {\n+    Path testDirectory = testDefinition.getTestDirectory();\n+    Arguments arguments = parseForkChoiceFile(testDirectory).get();\n+    Object[] objects = arguments.get();\n+    BeaconState genesis = (BeaconState) objects[0];\n+    @SuppressWarnings(\"unchecked\")\n+    List<Object> steps = (List<Object>) objects[1];\n+    String testName = (String) objects[2];\n+    Boolean protoArrayFC = (Boolean) objects[3];\n+    runForkChoiceTests(genesis, steps, testName, protoArrayFC);\n+  }\n+\n+  @ParameterizedTest(name = \"{index}.{2} fork choice test\")\n+  @MethodSource(\"loadForkChoiceTests\")\n+  void runForkChoiceTests(\n+      BeaconState genesis, List<Object> steps, String testName, boolean protoArrayFC) {\n+    StateTransition st = new StateTransition();\n+\n+    EventBus eventBus = new EventBus();\n+    RecentChainData storageClient = MemoryOnlyRecentChainData.create(eventBus);\n+    storageClient.initializeFromGenesis(genesis);\n+\n+    ForkChoiceStrategy forkChoiceStrategy =\n+        protoArrayFC\n+            ? ProtoArrayForkChoiceStrategy.create(storageClient.getStore())\n+            : new OrigForkChoiceStrategy(storageClient.getStore());\n+\n+    @SuppressWarnings(\"ModifiedButNotUsed\")\n+    List<SignedBeaconBlock> blockBuffer = new ArrayList<>();\n+    @SuppressWarnings(\"ModifiedButNotUsed\")\n+    List<Attestation> attestationBuffer = new ArrayList<>();\n+\n+    for (Object step : steps) {\n+      blockBuffer.removeIf(block -> processBlock(st, storageClient, block, forkChoiceStrategy));\n+      attestationBuffer.removeIf(\n+          attestation -> processAttestation(st, storageClient, attestation, forkChoiceStrategy));\n+      if (step instanceof UnsignedLong) {\n+        UpdatableStore.StoreTransaction transaction = storageClient.startStoreTransaction();\n+        while (ForkChoiceUtil.get_current_slot(transaction).compareTo((UnsignedLong) step) < 0) {\n+          ForkChoiceUtil.on_tick(transaction, transaction.getTime().plus(UnsignedLong.ONE));\n+        }\n+        assertEquals(step, ForkChoiceUtil.get_current_slot(transaction));\n+        transaction.commit().join();\n+      } else if (step instanceof SignedBeaconBlock) {\n+        for (Attestation attestation :\n+            ((SignedBeaconBlock) step).getMessage().getBody().getAttestations()) {\n+          attestationBuffer.add(attestation);\n+        }\n+        if (!processBlock(st, storageClient, (SignedBeaconBlock) step, forkChoiceStrategy)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "003014cefc8cbc31fd0b0bad8a5fd4ce825ba3cc"}, "originalPosition": 210}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxNTk3OTM0", "url": "https://github.com/ConsenSys/teku/pull/2154#pullrequestreview-431597934", "createdAt": "2020-06-16T15:00:53Z", "commit": {"oid": "003014cefc8cbc31fd0b0bad8a5fd4ce825ba3cc"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxNTowMDo1M1rOGkfpZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxNTowMDo1M1rOGkfpZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDkyMDQyMw==", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            assertTrue(storageClient.getBlockByRoot(root).isPresent(), \"block_in_store\");\n          \n          \n            \n                            assertTrue(storageClient.getBlockByRoot(root).isPresent(), \"Block is missing from store :\" + root);", "url": "https://github.com/ConsenSys/teku/pull/2154#discussion_r440920423", "createdAt": "2020-06-16T15:00:53Z", "author": {"login": "cemozerr"}, "path": "eth-reference-tests/src/referenceTest/java/tech/pegasys/teku/reference/phase0/fork_choice/ForkChoiceTestExecutor.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.reference.phase0.fork_choice;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.primitives.UnsignedLong;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import tech.pegasys.teku.core.ForkChoiceUtil;\n+import tech.pegasys.teku.core.StateTransition;\n+import tech.pegasys.teku.core.results.BlockImportResult;\n+import tech.pegasys.teku.datastructures.attestation.ValidateableAttestation;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.operations.Attestation;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.datastructures.state.BeaconStateImpl;\n+import tech.pegasys.teku.datastructures.util.AttestationProcessingResult;\n+import tech.pegasys.teku.datastructures.util.SimpleOffsetSerializer;\n+import tech.pegasys.teku.ethtests.finder.TestDefinition;\n+import tech.pegasys.teku.protoarray.ForkChoiceStrategy;\n+import tech.pegasys.teku.protoarray.ProtoArrayForkChoiceStrategy;\n+import tech.pegasys.teku.reference.phase0.TestExecutor;\n+import tech.pegasys.teku.storage.client.MemoryOnlyRecentChainData;\n+import tech.pegasys.teku.storage.client.RecentChainData;\n+import tech.pegasys.teku.storage.store.UpdatableStore;\n+\n+public class ForkChoiceTestExecutor implements TestExecutor {\n+  private static final ObjectMapper mapper = new ObjectMapper(new YAMLFactory());\n+\n+  public static ImmutableMap<String, TestExecutor> FORK_CHOICE_TEST_TYPES =\n+      ImmutableMap.of(\"fork_choice/integration_tests\", new ForkChoiceTestExecutor());\n+\n+  public static Stream<Arguments> loadForkChoiceTests() {\n+    Path path =\n+        Paths.get(\n+            \"src/referenceTest/java/tech/pegasys/teku/reference/phase0/fork_choice/integration_tests/\");\n+    List<File> testFiles = findForkChoiceTestsByPath(path);\n+    return testFiles.stream().flatMap(file -> parseForkChoiceFile(file.toPath()).stream());\n+  }\n+\n+  private static Optional<? extends Arguments> parseForkChoiceFile(Path path) {\n+    File file = path.toFile();\n+    try {\n+      @SuppressWarnings(\"rawtypes\")\n+      Map content = mapper.readValue(file, Map.class);\n+\n+      if (content.containsKey(\"steps\")) {\n+        BeaconStateImpl genesisState =\n+            resolvePart(BeaconStateImpl.class, file, content.get(\"genesis\"));\n+\n+        @SuppressWarnings(\"unchecked\")\n+        List<Object> steps =\n+            ((List<Map<String, Object>>) content.get(\"steps\"))\n+                .stream().map(step -> extractTestStep(file, step)).collect(Collectors.toList());\n+        return Optional.of(Arguments.of(genesisState, steps, file.getName(), true));\n+      } else {\n+        return Optional.empty();\n+      }\n+    } catch (IOException e) {\n+      return Optional.empty();\n+    }\n+  }\n+\n+  private static List<File> findForkChoiceTestsByPath(Path path) {\n+    try (Stream<Path> paths = Files.walk(path)) {\n+      return paths\n+          .filter(p -> Files.isRegularFile(p) && !p.getParent().endsWith(\"cache\"))\n+          .map(Path::toFile)\n+          .filter(f -> f.getName().endsWith(\".yaml\"))\n+          .collect(Collectors.toList());\n+    } catch (IOException e) {\n+      return Collections.emptyList();\n+    }\n+  }\n+\n+  private static Object extractTestStep(File file, Map<String, Object> stepDescription) {\n+    ForkChoiceTestStep stepKind = getStepKind(stepDescription);\n+    Object value = stepDescription.get(stepKind.name());\n+\n+    switch (stepKind) {\n+      case slot:\n+        {\n+          return UnsignedLong.valueOf((Integer) value);\n+        }\n+      case block:\n+        {\n+          return resolvePart(SignedBeaconBlock.class, file, value);\n+        }\n+      case attestation:\n+        {\n+          return resolvePart(Attestation.class, file, value);\n+        }\n+      case checks:\n+        {\n+          return value;\n+        }\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported step kind \" + stepKind);\n+    }\n+  }\n+\n+  private static ForkChoiceTestStep getStepKind(Map<String, Object> ss) {\n+    return ss.keySet().stream()\n+        .map(ForkChoiceTestStep::valueOf)\n+        .collect(Collectors.toList())\n+        .get(0);\n+  }\n+\n+  private static <T> T resolvePart(Class<T> clazz, File testFile, Object value) {\n+    if (value instanceof String) {\n+      String path = (String) value;\n+      if (path.endsWith(\".yaml\") || path.endsWith(\".ssz\")) {\n+        Path partPath = Paths.get(testFile.getParentFile().getParent(), \"cache\", path);\n+        try {\n+          if (path.endsWith(\".ssz\")) {\n+            return SimpleOffsetSerializer.deserialize(\n+                Bytes.wrap(Files.readAllBytes(partPath)), clazz);\n+          } else {\n+            return mapper.readValue(partPath.toFile(), clazz);\n+          }\n+        } catch (IOException e) {\n+          throw new IllegalArgumentException(\"Couldn't resolve \" + path + \": \" + e.getMessage());\n+        }\n+      }\n+    }\n+    return clazz.cast(value);\n+  }\n+\n+  @Override\n+  public void runTest(TestDefinition testDefinition) throws Throwable {\n+    Path testDirectory = testDefinition.getTestDirectory();\n+    Arguments arguments = parseForkChoiceFile(testDirectory).get();\n+    Object[] objects = arguments.get();\n+    BeaconState genesis = (BeaconState) objects[0];\n+    @SuppressWarnings(\"unchecked\")\n+    List<Object> steps = (List<Object>) objects[1];\n+    String testName = (String) objects[2];\n+    Boolean protoArrayFC = (Boolean) objects[3];\n+    runForkChoiceTests(genesis, steps, testName, protoArrayFC);\n+  }\n+\n+  @ParameterizedTest(name = \"{index}.{2} fork choice test\")\n+  @MethodSource(\"loadForkChoiceTests\")\n+  void runForkChoiceTests(\n+      BeaconState genesis, List<Object> steps, String testName, boolean protoArrayFC) {\n+    StateTransition st = new StateTransition();\n+\n+    EventBus eventBus = new EventBus();\n+    RecentChainData storageClient = MemoryOnlyRecentChainData.create(eventBus);\n+    storageClient.initializeFromGenesis(genesis);\n+\n+    ForkChoiceStrategy forkChoiceStrategy =\n+        protoArrayFC\n+            ? ProtoArrayForkChoiceStrategy.create(storageClient.getStore())\n+            : new OrigForkChoiceStrategy(storageClient.getStore());\n+\n+    @SuppressWarnings(\"ModifiedButNotUsed\")\n+    List<SignedBeaconBlock> blockBuffer = new ArrayList<>();\n+    @SuppressWarnings(\"ModifiedButNotUsed\")\n+    List<Attestation> attestationBuffer = new ArrayList<>();\n+\n+    for (Object step : steps) {\n+      blockBuffer.removeIf(block -> processBlock(st, storageClient, block, forkChoiceStrategy));\n+      attestationBuffer.removeIf(\n+          attestation -> processAttestation(st, storageClient, attestation, forkChoiceStrategy));\n+      if (step instanceof UnsignedLong) {\n+        UpdatableStore.StoreTransaction transaction = storageClient.startStoreTransaction();\n+        while (ForkChoiceUtil.get_current_slot(transaction).compareTo((UnsignedLong) step) < 0) {\n+          ForkChoiceUtil.on_tick(transaction, transaction.getTime().plus(UnsignedLong.ONE));\n+        }\n+        assertEquals(step, ForkChoiceUtil.get_current_slot(transaction));\n+        transaction.commit().join();\n+      } else if (step instanceof SignedBeaconBlock) {\n+        for (Attestation attestation :\n+            ((SignedBeaconBlock) step).getMessage().getBody().getAttestations()) {\n+          attestationBuffer.add(attestation);\n+        }\n+        if (!processBlock(st, storageClient, (SignedBeaconBlock) step, forkChoiceStrategy)) {\n+          blockBuffer.add((SignedBeaconBlock) step);\n+        }\n+      } else if (step instanceof Attestation) {\n+        if (!processAttestation(st, storageClient, (Attestation) step, forkChoiceStrategy)) {\n+          attestationBuffer.add((Attestation) step);\n+        }\n+      } else if (step instanceof Map) {\n+        @SuppressWarnings(\"unchecked\")\n+        Map<String, Object> checks = (Map<String, Object>) step;\n+        for (Map.Entry<String, Object> e : checks.entrySet()) {\n+          String check = e.getKey();\n+          switch (check) {\n+            case \"block_in_store\":\n+              {\n+                Bytes32 root = Bytes32.fromHexString((String) e.getValue());\n+                assertTrue(storageClient.getBlockByRoot(root).isPresent(), \"block_in_store\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "003014cefc8cbc31fd0b0bad8a5fd4ce825ba3cc"}, "originalPosition": 226}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxNTk5NjQw", "url": "https://github.com/ConsenSys/teku/pull/2154#pullrequestreview-431599640", "createdAt": "2020-06-16T15:02:32Z", "commit": {"oid": "003014cefc8cbc31fd0b0bad8a5fd4ce825ba3cc"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxNTowMjozM1rOGkfuYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxNTowMjozM1rOGkfuYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDkyMTY5Ng==", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            assertTrue(storageClient.getBlockByRoot(root).isEmpty(), \"!block_in_store\");\n          \n          \n            \n                            assertTrue(storageClient.getBlockByRoot(root).isEmpty(), \"Block should not have been in store :\" + root);", "url": "https://github.com/ConsenSys/teku/pull/2154#discussion_r440921696", "createdAt": "2020-06-16T15:02:33Z", "author": {"login": "cemozerr"}, "path": "eth-reference-tests/src/referenceTest/java/tech/pegasys/teku/reference/phase0/fork_choice/ForkChoiceTestExecutor.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.reference.phase0.fork_choice;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.primitives.UnsignedLong;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import tech.pegasys.teku.core.ForkChoiceUtil;\n+import tech.pegasys.teku.core.StateTransition;\n+import tech.pegasys.teku.core.results.BlockImportResult;\n+import tech.pegasys.teku.datastructures.attestation.ValidateableAttestation;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.operations.Attestation;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.datastructures.state.BeaconStateImpl;\n+import tech.pegasys.teku.datastructures.util.AttestationProcessingResult;\n+import tech.pegasys.teku.datastructures.util.SimpleOffsetSerializer;\n+import tech.pegasys.teku.ethtests.finder.TestDefinition;\n+import tech.pegasys.teku.protoarray.ForkChoiceStrategy;\n+import tech.pegasys.teku.protoarray.ProtoArrayForkChoiceStrategy;\n+import tech.pegasys.teku.reference.phase0.TestExecutor;\n+import tech.pegasys.teku.storage.client.MemoryOnlyRecentChainData;\n+import tech.pegasys.teku.storage.client.RecentChainData;\n+import tech.pegasys.teku.storage.store.UpdatableStore;\n+\n+public class ForkChoiceTestExecutor implements TestExecutor {\n+  private static final ObjectMapper mapper = new ObjectMapper(new YAMLFactory());\n+\n+  public static ImmutableMap<String, TestExecutor> FORK_CHOICE_TEST_TYPES =\n+      ImmutableMap.of(\"fork_choice/integration_tests\", new ForkChoiceTestExecutor());\n+\n+  public static Stream<Arguments> loadForkChoiceTests() {\n+    Path path =\n+        Paths.get(\n+            \"src/referenceTest/java/tech/pegasys/teku/reference/phase0/fork_choice/integration_tests/\");\n+    List<File> testFiles = findForkChoiceTestsByPath(path);\n+    return testFiles.stream().flatMap(file -> parseForkChoiceFile(file.toPath()).stream());\n+  }\n+\n+  private static Optional<? extends Arguments> parseForkChoiceFile(Path path) {\n+    File file = path.toFile();\n+    try {\n+      @SuppressWarnings(\"rawtypes\")\n+      Map content = mapper.readValue(file, Map.class);\n+\n+      if (content.containsKey(\"steps\")) {\n+        BeaconStateImpl genesisState =\n+            resolvePart(BeaconStateImpl.class, file, content.get(\"genesis\"));\n+\n+        @SuppressWarnings(\"unchecked\")\n+        List<Object> steps =\n+            ((List<Map<String, Object>>) content.get(\"steps\"))\n+                .stream().map(step -> extractTestStep(file, step)).collect(Collectors.toList());\n+        return Optional.of(Arguments.of(genesisState, steps, file.getName(), true));\n+      } else {\n+        return Optional.empty();\n+      }\n+    } catch (IOException e) {\n+      return Optional.empty();\n+    }\n+  }\n+\n+  private static List<File> findForkChoiceTestsByPath(Path path) {\n+    try (Stream<Path> paths = Files.walk(path)) {\n+      return paths\n+          .filter(p -> Files.isRegularFile(p) && !p.getParent().endsWith(\"cache\"))\n+          .map(Path::toFile)\n+          .filter(f -> f.getName().endsWith(\".yaml\"))\n+          .collect(Collectors.toList());\n+    } catch (IOException e) {\n+      return Collections.emptyList();\n+    }\n+  }\n+\n+  private static Object extractTestStep(File file, Map<String, Object> stepDescription) {\n+    ForkChoiceTestStep stepKind = getStepKind(stepDescription);\n+    Object value = stepDescription.get(stepKind.name());\n+\n+    switch (stepKind) {\n+      case slot:\n+        {\n+          return UnsignedLong.valueOf((Integer) value);\n+        }\n+      case block:\n+        {\n+          return resolvePart(SignedBeaconBlock.class, file, value);\n+        }\n+      case attestation:\n+        {\n+          return resolvePart(Attestation.class, file, value);\n+        }\n+      case checks:\n+        {\n+          return value;\n+        }\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported step kind \" + stepKind);\n+    }\n+  }\n+\n+  private static ForkChoiceTestStep getStepKind(Map<String, Object> ss) {\n+    return ss.keySet().stream()\n+        .map(ForkChoiceTestStep::valueOf)\n+        .collect(Collectors.toList())\n+        .get(0);\n+  }\n+\n+  private static <T> T resolvePart(Class<T> clazz, File testFile, Object value) {\n+    if (value instanceof String) {\n+      String path = (String) value;\n+      if (path.endsWith(\".yaml\") || path.endsWith(\".ssz\")) {\n+        Path partPath = Paths.get(testFile.getParentFile().getParent(), \"cache\", path);\n+        try {\n+          if (path.endsWith(\".ssz\")) {\n+            return SimpleOffsetSerializer.deserialize(\n+                Bytes.wrap(Files.readAllBytes(partPath)), clazz);\n+          } else {\n+            return mapper.readValue(partPath.toFile(), clazz);\n+          }\n+        } catch (IOException e) {\n+          throw new IllegalArgumentException(\"Couldn't resolve \" + path + \": \" + e.getMessage());\n+        }\n+      }\n+    }\n+    return clazz.cast(value);\n+  }\n+\n+  @Override\n+  public void runTest(TestDefinition testDefinition) throws Throwable {\n+    Path testDirectory = testDefinition.getTestDirectory();\n+    Arguments arguments = parseForkChoiceFile(testDirectory).get();\n+    Object[] objects = arguments.get();\n+    BeaconState genesis = (BeaconState) objects[0];\n+    @SuppressWarnings(\"unchecked\")\n+    List<Object> steps = (List<Object>) objects[1];\n+    String testName = (String) objects[2];\n+    Boolean protoArrayFC = (Boolean) objects[3];\n+    runForkChoiceTests(genesis, steps, testName, protoArrayFC);\n+  }\n+\n+  @ParameterizedTest(name = \"{index}.{2} fork choice test\")\n+  @MethodSource(\"loadForkChoiceTests\")\n+  void runForkChoiceTests(\n+      BeaconState genesis, List<Object> steps, String testName, boolean protoArrayFC) {\n+    StateTransition st = new StateTransition();\n+\n+    EventBus eventBus = new EventBus();\n+    RecentChainData storageClient = MemoryOnlyRecentChainData.create(eventBus);\n+    storageClient.initializeFromGenesis(genesis);\n+\n+    ForkChoiceStrategy forkChoiceStrategy =\n+        protoArrayFC\n+            ? ProtoArrayForkChoiceStrategy.create(storageClient.getStore())\n+            : new OrigForkChoiceStrategy(storageClient.getStore());\n+\n+    @SuppressWarnings(\"ModifiedButNotUsed\")\n+    List<SignedBeaconBlock> blockBuffer = new ArrayList<>();\n+    @SuppressWarnings(\"ModifiedButNotUsed\")\n+    List<Attestation> attestationBuffer = new ArrayList<>();\n+\n+    for (Object step : steps) {\n+      blockBuffer.removeIf(block -> processBlock(st, storageClient, block, forkChoiceStrategy));\n+      attestationBuffer.removeIf(\n+          attestation -> processAttestation(st, storageClient, attestation, forkChoiceStrategy));\n+      if (step instanceof UnsignedLong) {\n+        UpdatableStore.StoreTransaction transaction = storageClient.startStoreTransaction();\n+        while (ForkChoiceUtil.get_current_slot(transaction).compareTo((UnsignedLong) step) < 0) {\n+          ForkChoiceUtil.on_tick(transaction, transaction.getTime().plus(UnsignedLong.ONE));\n+        }\n+        assertEquals(step, ForkChoiceUtil.get_current_slot(transaction));\n+        transaction.commit().join();\n+      } else if (step instanceof SignedBeaconBlock) {\n+        for (Attestation attestation :\n+            ((SignedBeaconBlock) step).getMessage().getBody().getAttestations()) {\n+          attestationBuffer.add(attestation);\n+        }\n+        if (!processBlock(st, storageClient, (SignedBeaconBlock) step, forkChoiceStrategy)) {\n+          blockBuffer.add((SignedBeaconBlock) step);\n+        }\n+      } else if (step instanceof Attestation) {\n+        if (!processAttestation(st, storageClient, (Attestation) step, forkChoiceStrategy)) {\n+          attestationBuffer.add((Attestation) step);\n+        }\n+      } else if (step instanceof Map) {\n+        @SuppressWarnings(\"unchecked\")\n+        Map<String, Object> checks = (Map<String, Object>) step;\n+        for (Map.Entry<String, Object> e : checks.entrySet()) {\n+          String check = e.getKey();\n+          switch (check) {\n+            case \"block_in_store\":\n+              {\n+                Bytes32 root = Bytes32.fromHexString((String) e.getValue());\n+                assertTrue(storageClient.getBlockByRoot(root).isPresent(), \"block_in_store\");\n+                break;\n+              }\n+            case \"block_not_in_store\":\n+              {\n+                Bytes32 root = Bytes32.fromHexString((String) e.getValue());\n+                assertTrue(storageClient.getBlockByRoot(root).isEmpty(), \"!block_in_store\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "003014cefc8cbc31fd0b0bad8a5fd4ce825ba3cc"}, "originalPosition": 232}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fa60b3815df3438522f320bbc1e6e657db1bb9db", "author": {"user": {"login": "ericsson49", "name": "Alex Vlasov"}}, "url": "https://github.com/ConsenSys/teku/commit/fa60b3815df3438522f320bbc1e6e657db1bb9db", "committedDate": "2020-06-16T15:04:13Z", "message": "Update eth-reference-tests/src/referenceTest/java/tech/pegasys/teku/reference/phase0/fork_choice/ForkChoiceTestExecutor.java\n\nCo-authored-by: Cem Ozer <cemozer2018@u.northwestern.edu>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxNjAxMzUw", "url": "https://github.com/ConsenSys/teku/pull/2154#pullrequestreview-431601350", "createdAt": "2020-06-16T15:04:16Z", "commit": {"oid": "003014cefc8cbc31fd0b0bad8a5fd4ce825ba3cc"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxNTowNDoxNlrOGkfzMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxNTowNDoxNlrOGkfzMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDkyMjkzMA==", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            assertEquals(root, head, \"head\");\n          \n          \n            \n                            assertEquals(root, head, \"Head does not match expected head: \\n head: \" + head + \"\\n expectedHead: \" + root);", "url": "https://github.com/ConsenSys/teku/pull/2154#discussion_r440922930", "createdAt": "2020-06-16T15:04:16Z", "author": {"login": "cemozerr"}, "path": "eth-reference-tests/src/referenceTest/java/tech/pegasys/teku/reference/phase0/fork_choice/ForkChoiceTestExecutor.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.reference.phase0.fork_choice;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.primitives.UnsignedLong;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import tech.pegasys.teku.core.ForkChoiceUtil;\n+import tech.pegasys.teku.core.StateTransition;\n+import tech.pegasys.teku.core.results.BlockImportResult;\n+import tech.pegasys.teku.datastructures.attestation.ValidateableAttestation;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.operations.Attestation;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.datastructures.state.BeaconStateImpl;\n+import tech.pegasys.teku.datastructures.util.AttestationProcessingResult;\n+import tech.pegasys.teku.datastructures.util.SimpleOffsetSerializer;\n+import tech.pegasys.teku.ethtests.finder.TestDefinition;\n+import tech.pegasys.teku.protoarray.ForkChoiceStrategy;\n+import tech.pegasys.teku.protoarray.ProtoArrayForkChoiceStrategy;\n+import tech.pegasys.teku.reference.phase0.TestExecutor;\n+import tech.pegasys.teku.storage.client.MemoryOnlyRecentChainData;\n+import tech.pegasys.teku.storage.client.RecentChainData;\n+import tech.pegasys.teku.storage.store.UpdatableStore;\n+\n+public class ForkChoiceTestExecutor implements TestExecutor {\n+  private static final ObjectMapper mapper = new ObjectMapper(new YAMLFactory());\n+\n+  public static ImmutableMap<String, TestExecutor> FORK_CHOICE_TEST_TYPES =\n+      ImmutableMap.of(\"fork_choice/integration_tests\", new ForkChoiceTestExecutor());\n+\n+  public static Stream<Arguments> loadForkChoiceTests() {\n+    Path path =\n+        Paths.get(\n+            \"src/referenceTest/java/tech/pegasys/teku/reference/phase0/fork_choice/integration_tests/\");\n+    List<File> testFiles = findForkChoiceTestsByPath(path);\n+    return testFiles.stream().flatMap(file -> parseForkChoiceFile(file.toPath()).stream());\n+  }\n+\n+  private static Optional<? extends Arguments> parseForkChoiceFile(Path path) {\n+    File file = path.toFile();\n+    try {\n+      @SuppressWarnings(\"rawtypes\")\n+      Map content = mapper.readValue(file, Map.class);\n+\n+      if (content.containsKey(\"steps\")) {\n+        BeaconStateImpl genesisState =\n+            resolvePart(BeaconStateImpl.class, file, content.get(\"genesis\"));\n+\n+        @SuppressWarnings(\"unchecked\")\n+        List<Object> steps =\n+            ((List<Map<String, Object>>) content.get(\"steps\"))\n+                .stream().map(step -> extractTestStep(file, step)).collect(Collectors.toList());\n+        return Optional.of(Arguments.of(genesisState, steps, file.getName(), true));\n+      } else {\n+        return Optional.empty();\n+      }\n+    } catch (IOException e) {\n+      return Optional.empty();\n+    }\n+  }\n+\n+  private static List<File> findForkChoiceTestsByPath(Path path) {\n+    try (Stream<Path> paths = Files.walk(path)) {\n+      return paths\n+          .filter(p -> Files.isRegularFile(p) && !p.getParent().endsWith(\"cache\"))\n+          .map(Path::toFile)\n+          .filter(f -> f.getName().endsWith(\".yaml\"))\n+          .collect(Collectors.toList());\n+    } catch (IOException e) {\n+      return Collections.emptyList();\n+    }\n+  }\n+\n+  private static Object extractTestStep(File file, Map<String, Object> stepDescription) {\n+    ForkChoiceTestStep stepKind = getStepKind(stepDescription);\n+    Object value = stepDescription.get(stepKind.name());\n+\n+    switch (stepKind) {\n+      case slot:\n+        {\n+          return UnsignedLong.valueOf((Integer) value);\n+        }\n+      case block:\n+        {\n+          return resolvePart(SignedBeaconBlock.class, file, value);\n+        }\n+      case attestation:\n+        {\n+          return resolvePart(Attestation.class, file, value);\n+        }\n+      case checks:\n+        {\n+          return value;\n+        }\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported step kind \" + stepKind);\n+    }\n+  }\n+\n+  private static ForkChoiceTestStep getStepKind(Map<String, Object> ss) {\n+    return ss.keySet().stream()\n+        .map(ForkChoiceTestStep::valueOf)\n+        .collect(Collectors.toList())\n+        .get(0);\n+  }\n+\n+  private static <T> T resolvePart(Class<T> clazz, File testFile, Object value) {\n+    if (value instanceof String) {\n+      String path = (String) value;\n+      if (path.endsWith(\".yaml\") || path.endsWith(\".ssz\")) {\n+        Path partPath = Paths.get(testFile.getParentFile().getParent(), \"cache\", path);\n+        try {\n+          if (path.endsWith(\".ssz\")) {\n+            return SimpleOffsetSerializer.deserialize(\n+                Bytes.wrap(Files.readAllBytes(partPath)), clazz);\n+          } else {\n+            return mapper.readValue(partPath.toFile(), clazz);\n+          }\n+        } catch (IOException e) {\n+          throw new IllegalArgumentException(\"Couldn't resolve \" + path + \": \" + e.getMessage());\n+        }\n+      }\n+    }\n+    return clazz.cast(value);\n+  }\n+\n+  @Override\n+  public void runTest(TestDefinition testDefinition) throws Throwable {\n+    Path testDirectory = testDefinition.getTestDirectory();\n+    Arguments arguments = parseForkChoiceFile(testDirectory).get();\n+    Object[] objects = arguments.get();\n+    BeaconState genesis = (BeaconState) objects[0];\n+    @SuppressWarnings(\"unchecked\")\n+    List<Object> steps = (List<Object>) objects[1];\n+    String testName = (String) objects[2];\n+    Boolean protoArrayFC = (Boolean) objects[3];\n+    runForkChoiceTests(genesis, steps, testName, protoArrayFC);\n+  }\n+\n+  @ParameterizedTest(name = \"{index}.{2} fork choice test\")\n+  @MethodSource(\"loadForkChoiceTests\")\n+  void runForkChoiceTests(\n+      BeaconState genesis, List<Object> steps, String testName, boolean protoArrayFC) {\n+    StateTransition st = new StateTransition();\n+\n+    EventBus eventBus = new EventBus();\n+    RecentChainData storageClient = MemoryOnlyRecentChainData.create(eventBus);\n+    storageClient.initializeFromGenesis(genesis);\n+\n+    ForkChoiceStrategy forkChoiceStrategy =\n+        protoArrayFC\n+            ? ProtoArrayForkChoiceStrategy.create(storageClient.getStore())\n+            : new OrigForkChoiceStrategy(storageClient.getStore());\n+\n+    @SuppressWarnings(\"ModifiedButNotUsed\")\n+    List<SignedBeaconBlock> blockBuffer = new ArrayList<>();\n+    @SuppressWarnings(\"ModifiedButNotUsed\")\n+    List<Attestation> attestationBuffer = new ArrayList<>();\n+\n+    for (Object step : steps) {\n+      blockBuffer.removeIf(block -> processBlock(st, storageClient, block, forkChoiceStrategy));\n+      attestationBuffer.removeIf(\n+          attestation -> processAttestation(st, storageClient, attestation, forkChoiceStrategy));\n+      if (step instanceof UnsignedLong) {\n+        UpdatableStore.StoreTransaction transaction = storageClient.startStoreTransaction();\n+        while (ForkChoiceUtil.get_current_slot(transaction).compareTo((UnsignedLong) step) < 0) {\n+          ForkChoiceUtil.on_tick(transaction, transaction.getTime().plus(UnsignedLong.ONE));\n+        }\n+        assertEquals(step, ForkChoiceUtil.get_current_slot(transaction));\n+        transaction.commit().join();\n+      } else if (step instanceof SignedBeaconBlock) {\n+        for (Attestation attestation :\n+            ((SignedBeaconBlock) step).getMessage().getBody().getAttestations()) {\n+          attestationBuffer.add(attestation);\n+        }\n+        if (!processBlock(st, storageClient, (SignedBeaconBlock) step, forkChoiceStrategy)) {\n+          blockBuffer.add((SignedBeaconBlock) step);\n+        }\n+      } else if (step instanceof Attestation) {\n+        if (!processAttestation(st, storageClient, (Attestation) step, forkChoiceStrategy)) {\n+          attestationBuffer.add((Attestation) step);\n+        }\n+      } else if (step instanceof Map) {\n+        @SuppressWarnings(\"unchecked\")\n+        Map<String, Object> checks = (Map<String, Object>) step;\n+        for (Map.Entry<String, Object> e : checks.entrySet()) {\n+          String check = e.getKey();\n+          switch (check) {\n+            case \"block_in_store\":\n+              {\n+                Bytes32 root = Bytes32.fromHexString((String) e.getValue());\n+                assertTrue(storageClient.getBlockByRoot(root).isPresent(), \"block_in_store\");\n+                break;\n+              }\n+            case \"block_not_in_store\":\n+              {\n+                Bytes32 root = Bytes32.fromHexString((String) e.getValue());\n+                assertTrue(storageClient.getBlockByRoot(root).isEmpty(), \"!block_in_store\");\n+                break;\n+              }\n+            case \"head\":\n+              {\n+                Bytes32 root = Bytes32.fromHexString((String) e.getValue());\n+                UpdatableStore.StoreTransaction transaction = storageClient.startStoreTransaction();\n+                Bytes32 head = forkChoiceStrategy.findHead(transaction);\n+                transaction.commit(() -> {}, \"Failed to persist validator vote changes.\");\n+                assertEquals(root, head, \"head\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "003014cefc8cbc31fd0b0bad8a5fd4ce825ba3cc"}, "originalPosition": 241}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f4e3f54ce8a7ddfcad083ffe39facf80e0688298", "author": {"user": {"login": "ericsson49", "name": "Alex Vlasov"}}, "url": "https://github.com/ConsenSys/teku/commit/f4e3f54ce8a7ddfcad083ffe39facf80e0688298", "committedDate": "2020-06-16T15:04:23Z", "message": "Update eth-reference-tests/src/referenceTest/java/tech/pegasys/teku/reference/phase0/fork_choice/ForkChoiceTestExecutor.java\n\nCo-authored-by: Cem Ozer <cemozer2018@u.northwestern.edu>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9183ebad83248c0b063cf7b870b0552cc17ac9a6", "author": {"user": {"login": "ericsson49", "name": "Alex Vlasov"}}, "url": "https://github.com/ConsenSys/teku/commit/9183ebad83248c0b063cf7b870b0552cc17ac9a6", "committedDate": "2020-06-16T15:04:40Z", "message": "Update eth-reference-tests/src/referenceTest/java/tech/pegasys/teku/reference/phase0/fork_choice/ForkChoiceTestExecutor.java\n\nCo-authored-by: Cem Ozer <cemozer2018@u.northwestern.edu>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxNjAzMzA0", "url": "https://github.com/ConsenSys/teku/pull/2154#pullrequestreview-431603304", "createdAt": "2020-06-16T15:06:10Z", "commit": {"oid": "003014cefc8cbc31fd0b0bad8a5fd4ce825ba3cc"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxNTowNjoxMVrOGkf4vA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxNTowNjoxMVrOGkf4vA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDkyNDM0OA==", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            assertEquals(expected, actual, \"justified_checkpoint_epoch\");\n          \n          \n            \n                            assertEquals(expected, actual, \"Justified checkpoint epoch does not match expected: \\n actual: \" + actual + \"\\n expected: \" + expected);", "url": "https://github.com/ConsenSys/teku/pull/2154#discussion_r440924348", "createdAt": "2020-06-16T15:06:11Z", "author": {"login": "cemozerr"}, "path": "eth-reference-tests/src/referenceTest/java/tech/pegasys/teku/reference/phase0/fork_choice/ForkChoiceTestExecutor.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.reference.phase0.fork_choice;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.dataformat.yaml.YAMLFactory;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.primitives.UnsignedLong;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import tech.pegasys.teku.core.ForkChoiceUtil;\n+import tech.pegasys.teku.core.StateTransition;\n+import tech.pegasys.teku.core.results.BlockImportResult;\n+import tech.pegasys.teku.datastructures.attestation.ValidateableAttestation;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.operations.Attestation;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.datastructures.state.BeaconStateImpl;\n+import tech.pegasys.teku.datastructures.util.AttestationProcessingResult;\n+import tech.pegasys.teku.datastructures.util.SimpleOffsetSerializer;\n+import tech.pegasys.teku.ethtests.finder.TestDefinition;\n+import tech.pegasys.teku.protoarray.ForkChoiceStrategy;\n+import tech.pegasys.teku.protoarray.ProtoArrayForkChoiceStrategy;\n+import tech.pegasys.teku.reference.phase0.TestExecutor;\n+import tech.pegasys.teku.storage.client.MemoryOnlyRecentChainData;\n+import tech.pegasys.teku.storage.client.RecentChainData;\n+import tech.pegasys.teku.storage.store.UpdatableStore;\n+\n+public class ForkChoiceTestExecutor implements TestExecutor {\n+  private static final ObjectMapper mapper = new ObjectMapper(new YAMLFactory());\n+\n+  public static ImmutableMap<String, TestExecutor> FORK_CHOICE_TEST_TYPES =\n+      ImmutableMap.of(\"fork_choice/integration_tests\", new ForkChoiceTestExecutor());\n+\n+  public static Stream<Arguments> loadForkChoiceTests() {\n+    Path path =\n+        Paths.get(\n+            \"src/referenceTest/java/tech/pegasys/teku/reference/phase0/fork_choice/integration_tests/\");\n+    List<File> testFiles = findForkChoiceTestsByPath(path);\n+    return testFiles.stream().flatMap(file -> parseForkChoiceFile(file.toPath()).stream());\n+  }\n+\n+  private static Optional<? extends Arguments> parseForkChoiceFile(Path path) {\n+    File file = path.toFile();\n+    try {\n+      @SuppressWarnings(\"rawtypes\")\n+      Map content = mapper.readValue(file, Map.class);\n+\n+      if (content.containsKey(\"steps\")) {\n+        BeaconStateImpl genesisState =\n+            resolvePart(BeaconStateImpl.class, file, content.get(\"genesis\"));\n+\n+        @SuppressWarnings(\"unchecked\")\n+        List<Object> steps =\n+            ((List<Map<String, Object>>) content.get(\"steps\"))\n+                .stream().map(step -> extractTestStep(file, step)).collect(Collectors.toList());\n+        return Optional.of(Arguments.of(genesisState, steps, file.getName(), true));\n+      } else {\n+        return Optional.empty();\n+      }\n+    } catch (IOException e) {\n+      return Optional.empty();\n+    }\n+  }\n+\n+  private static List<File> findForkChoiceTestsByPath(Path path) {\n+    try (Stream<Path> paths = Files.walk(path)) {\n+      return paths\n+          .filter(p -> Files.isRegularFile(p) && !p.getParent().endsWith(\"cache\"))\n+          .map(Path::toFile)\n+          .filter(f -> f.getName().endsWith(\".yaml\"))\n+          .collect(Collectors.toList());\n+    } catch (IOException e) {\n+      return Collections.emptyList();\n+    }\n+  }\n+\n+  private static Object extractTestStep(File file, Map<String, Object> stepDescription) {\n+    ForkChoiceTestStep stepKind = getStepKind(stepDescription);\n+    Object value = stepDescription.get(stepKind.name());\n+\n+    switch (stepKind) {\n+      case slot:\n+        {\n+          return UnsignedLong.valueOf((Integer) value);\n+        }\n+      case block:\n+        {\n+          return resolvePart(SignedBeaconBlock.class, file, value);\n+        }\n+      case attestation:\n+        {\n+          return resolvePart(Attestation.class, file, value);\n+        }\n+      case checks:\n+        {\n+          return value;\n+        }\n+      default:\n+        throw new IllegalArgumentException(\"Unsupported step kind \" + stepKind);\n+    }\n+  }\n+\n+  private static ForkChoiceTestStep getStepKind(Map<String, Object> ss) {\n+    return ss.keySet().stream()\n+        .map(ForkChoiceTestStep::valueOf)\n+        .collect(Collectors.toList())\n+        .get(0);\n+  }\n+\n+  private static <T> T resolvePart(Class<T> clazz, File testFile, Object value) {\n+    if (value instanceof String) {\n+      String path = (String) value;\n+      if (path.endsWith(\".yaml\") || path.endsWith(\".ssz\")) {\n+        Path partPath = Paths.get(testFile.getParentFile().getParent(), \"cache\", path);\n+        try {\n+          if (path.endsWith(\".ssz\")) {\n+            return SimpleOffsetSerializer.deserialize(\n+                Bytes.wrap(Files.readAllBytes(partPath)), clazz);\n+          } else {\n+            return mapper.readValue(partPath.toFile(), clazz);\n+          }\n+        } catch (IOException e) {\n+          throw new IllegalArgumentException(\"Couldn't resolve \" + path + \": \" + e.getMessage());\n+        }\n+      }\n+    }\n+    return clazz.cast(value);\n+  }\n+\n+  @Override\n+  public void runTest(TestDefinition testDefinition) throws Throwable {\n+    Path testDirectory = testDefinition.getTestDirectory();\n+    Arguments arguments = parseForkChoiceFile(testDirectory).get();\n+    Object[] objects = arguments.get();\n+    BeaconState genesis = (BeaconState) objects[0];\n+    @SuppressWarnings(\"unchecked\")\n+    List<Object> steps = (List<Object>) objects[1];\n+    String testName = (String) objects[2];\n+    Boolean protoArrayFC = (Boolean) objects[3];\n+    runForkChoiceTests(genesis, steps, testName, protoArrayFC);\n+  }\n+\n+  @ParameterizedTest(name = \"{index}.{2} fork choice test\")\n+  @MethodSource(\"loadForkChoiceTests\")\n+  void runForkChoiceTests(\n+      BeaconState genesis, List<Object> steps, String testName, boolean protoArrayFC) {\n+    StateTransition st = new StateTransition();\n+\n+    EventBus eventBus = new EventBus();\n+    RecentChainData storageClient = MemoryOnlyRecentChainData.create(eventBus);\n+    storageClient.initializeFromGenesis(genesis);\n+\n+    ForkChoiceStrategy forkChoiceStrategy =\n+        protoArrayFC\n+            ? ProtoArrayForkChoiceStrategy.create(storageClient.getStore())\n+            : new OrigForkChoiceStrategy(storageClient.getStore());\n+\n+    @SuppressWarnings(\"ModifiedButNotUsed\")\n+    List<SignedBeaconBlock> blockBuffer = new ArrayList<>();\n+    @SuppressWarnings(\"ModifiedButNotUsed\")\n+    List<Attestation> attestationBuffer = new ArrayList<>();\n+\n+    for (Object step : steps) {\n+      blockBuffer.removeIf(block -> processBlock(st, storageClient, block, forkChoiceStrategy));\n+      attestationBuffer.removeIf(\n+          attestation -> processAttestation(st, storageClient, attestation, forkChoiceStrategy));\n+      if (step instanceof UnsignedLong) {\n+        UpdatableStore.StoreTransaction transaction = storageClient.startStoreTransaction();\n+        while (ForkChoiceUtil.get_current_slot(transaction).compareTo((UnsignedLong) step) < 0) {\n+          ForkChoiceUtil.on_tick(transaction, transaction.getTime().plus(UnsignedLong.ONE));\n+        }\n+        assertEquals(step, ForkChoiceUtil.get_current_slot(transaction));\n+        transaction.commit().join();\n+      } else if (step instanceof SignedBeaconBlock) {\n+        for (Attestation attestation :\n+            ((SignedBeaconBlock) step).getMessage().getBody().getAttestations()) {\n+          attestationBuffer.add(attestation);\n+        }\n+        if (!processBlock(st, storageClient, (SignedBeaconBlock) step, forkChoiceStrategy)) {\n+          blockBuffer.add((SignedBeaconBlock) step);\n+        }\n+      } else if (step instanceof Attestation) {\n+        if (!processAttestation(st, storageClient, (Attestation) step, forkChoiceStrategy)) {\n+          attestationBuffer.add((Attestation) step);\n+        }\n+      } else if (step instanceof Map) {\n+        @SuppressWarnings(\"unchecked\")\n+        Map<String, Object> checks = (Map<String, Object>) step;\n+        for (Map.Entry<String, Object> e : checks.entrySet()) {\n+          String check = e.getKey();\n+          switch (check) {\n+            case \"block_in_store\":\n+              {\n+                Bytes32 root = Bytes32.fromHexString((String) e.getValue());\n+                assertTrue(storageClient.getBlockByRoot(root).isPresent(), \"block_in_store\");\n+                break;\n+              }\n+            case \"block_not_in_store\":\n+              {\n+                Bytes32 root = Bytes32.fromHexString((String) e.getValue());\n+                assertTrue(storageClient.getBlockByRoot(root).isEmpty(), \"!block_in_store\");\n+                break;\n+              }\n+            case \"head\":\n+              {\n+                Bytes32 root = Bytes32.fromHexString((String) e.getValue());\n+                UpdatableStore.StoreTransaction transaction = storageClient.startStoreTransaction();\n+                Bytes32 head = forkChoiceStrategy.findHead(transaction);\n+                transaction.commit(() -> {}, \"Failed to persist validator vote changes.\");\n+                assertEquals(root, head, \"head\");\n+                break;\n+              }\n+            case \"justified_checkpoint_epoch\":\n+              {\n+                UnsignedLong expected = UnsignedLong.valueOf((Integer) e.getValue());\n+                UnsignedLong actual = storageClient.getStore().getJustifiedCheckpoint().getEpoch();\n+                assertEquals(expected, actual, \"justified_checkpoint_epoch\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "003014cefc8cbc31fd0b0bad8a5fd4ce825ba3cc"}, "originalPosition": 248}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "24b554d8b560de3fb7100abcc193da841592fb1b", "author": {"user": {"login": "ericsson49", "name": "Alex Vlasov"}}, "url": "https://github.com/ConsenSys/teku/commit/24b554d8b560de3fb7100abcc193da841592fb1b", "committedDate": "2020-06-16T15:06:48Z", "message": "Update eth-reference-tests/src/referenceTest/java/tech/pegasys/teku/reference/phase0/fork_choice/ForkChoiceTestExecutor.java\n\nCo-authored-by: Cem Ozer <cemozer2018@u.northwestern.edu>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7951eae465f7a66324ed8887a6bbf11e5eaa3838", "author": {"user": {"login": "ericsson49", "name": "Alex Vlasov"}}, "url": "https://github.com/ConsenSys/teku/commit/7951eae465f7a66324ed8887a6bbf11e5eaa3838", "committedDate": "2020-06-16T15:13:02Z", "message": "fix spotless problems"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxNjM0NjQ1", "url": "https://github.com/ConsenSys/teku/pull/2154#pullrequestreview-431634645", "createdAt": "2020-06-16T15:33:30Z", "commit": {"oid": "7951eae465f7a66324ed8887a6bbf11e5eaa3838"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3934, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}