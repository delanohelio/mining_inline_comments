{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIyNTQwNDQz", "number": 1902, "title": "Calculate ETH1 deposit count and root based on event logs", "bodyText": "PR Description\nReworks how Eth1Data is collected so that there is no longer a dependency on having ETH1 world state available. All information is built up from the deposit event logs.\nOn both the PoWService and BeaconChainService sides, Eth1Data is now controlled by the deposit handling, rather than separate. This allows us to guarantee that all deposit data is processed before the Eth1Data for any empty blocks is filled in.\nOn the PoWService side:\n\nempty blocks are completely ignored until all deposits are processed up to the ETH1 follow distance from head.  This avoids querying old block data unnecessarily.\nOnce follow distance has been reached, block data is fetched walking backwards from that latest block until a block is reached with a timestamp prior to the caching period. This handles filling the cache at initial startup\nAs the chain moves forward, deposits are requested and processed for the unprocessed range, then any blocks without deposits in that range are requested.\n\nOn the BeaconChain side:\n\nDepositProvider continues to receive and process all deposits. After all deposits in a block are processed it notifies Eth1DataCache of the block and the new Eth1Data associated with that block (generated from the deposit Merkle tree).\nDepositProvider also passes block information for blocks without deposits to Eth1DataCache.  Eth1DataCache uses the same deposit root and count as the prior block from its cache for this blocks (as with no deposits in the block they must be unchanged).\n\nFixed Issue(s)\nfixes #1813\nfixes #1863", "createdAt": "2020-05-25T04:39:52Z", "url": "https://github.com/ConsenSys/teku/pull/1902", "merged": true, "mergeCommit": {"oid": "8f8b6829693adcf906a18060d1545dafb767763a"}, "closed": true, "closedAt": "2020-05-26T22:32:55Z", "author": {"login": "ajsutton"}, "timelineItems": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABckoThggH2gAyNDIyNTQwNDQzOjMwNTJiMWNiMzliYjRkZTVkZWMyMTAyOGE5ZGQzNjg4ZDIyOTMxN2E=", "endCursor": "Y3Vyc29yOnYyOpPPAAABclMLEjAH2gAyNDIyNTQwNDQzOjliYmM5ODIxYjcxYjNjYzRhNDk1NDcxMDdjMmFkZTBkYjgzNDNlODg=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "3052b1cb39bb4de5dec21028a9dd3688d229317a", "author": {"user": {"login": "ajsutton", "name": "Adrian Sutton"}}, "url": "https://github.com/ConsenSys/teku/commit/3052b1cb39bb4de5dec21028a9dd3688d229317a", "committedDate": "2020-05-25T04:24:53Z", "message": "Rework Eth1Data handling to avoid needing ETH1 world state."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "19908bbcffef807efd7d018488f7ad81c9b68cde", "author": {"user": {"login": "ajsutton", "name": "Adrian Sutton"}}, "url": "https://github.com/ConsenSys/teku/commit/19908bbcffef807efd7d018488f7ad81c9b68cde", "committedDate": "2020-05-25T04:39:36Z", "message": "Rename method."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8a6da1a5709ad234c85448da025268c96a05af12", "author": {"user": {"login": "ajsutton", "name": "Adrian Sutton"}}, "url": "https://github.com/ConsenSys/teku/commit/8a6da1a5709ad234c85448da025268c96a05af12", "committedDate": "2020-05-25T04:42:57Z", "message": "Remove unused variable."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "65b333f34dc2610200a569b874aa3d2e66bd369f", "author": {"user": {"login": "ajsutton", "name": "Adrian Sutton"}}, "url": "https://github.com/ConsenSys/teku/commit/65b333f34dc2610200a569b874aa3d2e66bd369f", "committedDate": "2020-05-25T04:48:12Z", "message": "Request empty blocks in parallel with processing deposits."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE4NDI0NDUx", "url": "https://github.com/ConsenSys/teku/pull/1902#pullrequestreview-418424451", "createdAt": "2020-05-26T15:35:45Z", "commit": {"oid": "65b333f34dc2610200a569b874aa3d2e66bd369f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxNTozNTo0NVrOGakE1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxNTozNTo0NVrOGakE1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDUwNzIyMQ==", "bodyText": "This line seems redundant. Every time requestNextBlockIfRequired  calls requestBlock, it sets requestInProgress to true. However, requestNextBlockIfRequired does not set requestInProgress to false. So requestNextBlockIfRequiredreturns early every time its called inside requestBlock.", "url": "https://github.com/ConsenSys/teku/pull/1902#discussion_r430507221", "createdAt": "2020-05-26T15:35:45Z", "author": {"login": "cemozerr"}, "path": "pow/src/main/java/tech/pegasys/teku/pow/Eth1BlockFetcher.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.pow;\n+\n+import static com.google.common.primitives.UnsignedLong.ONE;\n+import static com.google.common.primitives.UnsignedLong.ZERO;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.math.BigInteger;\n+import java.util.NavigableSet;\n+import java.util.TreeSet;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.core.methods.response.EthBlock.Block;\n+import tech.pegasys.teku.pow.api.Eth1EventsChannel;\n+import tech.pegasys.teku.util.async.SafeFuture;\n+import tech.pegasys.teku.util.time.TimeProvider;\n+\n+public class Eth1BlockFetcher {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final Eth1Provider eth1Provider;\n+  private final TimeProvider timeProvider;\n+  private final UnsignedLong cacheDuration;\n+  private final Eth1EventsChannel eth1EventsChannel;\n+  private final NavigableSet<UnsignedLong> blocksToRequest = new TreeSet<>();\n+  private boolean requestInProgress = false;\n+  private boolean active = false;\n+\n+  public Eth1BlockFetcher(\n+      final Eth1EventsChannel eth1EventsChannel,\n+      final Eth1Provider eth1Provider,\n+      final TimeProvider timeProvider,\n+      final UnsignedLong cacheDuration) {\n+    this.eth1EventsChannel = eth1EventsChannel;\n+    this.eth1Provider = eth1Provider;\n+    this.timeProvider = timeProvider;\n+    this.cacheDuration = cacheDuration;\n+  }\n+\n+  public synchronized void onInSync(final UnsignedLong latestCanonicalBlockNumber) {\n+    if (active) {\n+      return;\n+    }\n+    active = true;\n+    LOG.debug(\"Beginning back-fill of Eth1 blocks\");\n+    backfillEth1Blocks(latestCanonicalBlockNumber);\n+  }\n+\n+  public void fetch(final BigInteger fromBlock, final BigInteger toBlock) {\n+    synchronized (this) {\n+      if (!active) {\n+        // No point starting to request data if we haven't yet reached the start of the chain\n+        // We'll just wind up downloading a heap of blocks we then throw away\n+        return;\n+      }\n+      for (BigInteger block = fromBlock;\n+          block.compareTo(toBlock) <= 0;\n+          block = block.add(BigInteger.ONE)) {\n+        blocksToRequest.add(UnsignedLong.valueOf(block));\n+      }\n+    }\n+    requestNextBlockIfRequired();\n+  }\n+\n+  private void requestNextBlockIfRequired() {\n+    UnsignedLong blockToRequest;\n+    synchronized (this) {\n+      if (requestInProgress || blocksToRequest.isEmpty()) {\n+        return;\n+      }\n+      blockToRequest = blocksToRequest.last();\n+      blocksToRequest.remove(blockToRequest);\n+      requestInProgress = true;\n+    }\n+    requestBlock(blockToRequest)\n+        .always(\n+            () -> {\n+              synchronized (Eth1BlockFetcher.this) {\n+                requestInProgress = false;\n+              }\n+              requestNextBlockIfRequired();\n+            });\n+  }\n+\n+  private SafeFuture<Void> requestBlock(final UnsignedLong blockNumberToRequest) {\n+    // Note: Not using guaranteed requests here - if the Eth1 chain is temporarily unavailable\n+    // we may miss some blocks but that's better than potentially getting stuck retrying a block\n+    LOG.debug(\"Requesting block {}\", blockNumberToRequest);\n+    return eth1Provider\n+        .getEth1BlockFuture(blockNumberToRequest)\n+        .thenAccept(\n+            block -> {\n+              if (isAboveLowerBound(UnsignedLong.valueOf(block.getTimestamp()))) {\n+                postBlock(block);\n+              } else {\n+                // Every block before the one we just fetched must be outside of the range\n+                synchronized (Eth1BlockFetcher.this) {\n+                  // All blocks at or before this number must be before the cache period\n+                  blocksToRequest.headSet(blockNumberToRequest, true).clear();\n+                }\n+              }\n+              requestNextBlockIfRequired();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65b333f34dc2610200a569b874aa3d2e66bd369f"}, "originalPosition": 115}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE4NDM5NTMy", "url": "https://github.com/ConsenSys/teku/pull/1902#pullrequestreview-418439532", "createdAt": "2020-05-26T15:51:50Z", "commit": {"oid": "65b333f34dc2610200a569b874aa3d2e66bd369f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxNTo1MTo1MFrOGak5Zw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxNTo1MTo1MFrOGak5Zw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDUyMDY3OQ==", "bodyText": "Is there a reason why you used guaranteed requests here? Missing some blocks does seem better than potentially getting stuck retrying a block, similar to the case above.", "url": "https://github.com/ConsenSys/teku/pull/1902#discussion_r430520679", "createdAt": "2020-05-26T15:51:50Z", "author": {"login": "cemozerr"}, "path": "pow/src/main/java/tech/pegasys/teku/pow/Eth1BlockFetcher.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.pow;\n+\n+import static com.google.common.primitives.UnsignedLong.ONE;\n+import static com.google.common.primitives.UnsignedLong.ZERO;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.math.BigInteger;\n+import java.util.NavigableSet;\n+import java.util.TreeSet;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.core.methods.response.EthBlock.Block;\n+import tech.pegasys.teku.pow.api.Eth1EventsChannel;\n+import tech.pegasys.teku.util.async.SafeFuture;\n+import tech.pegasys.teku.util.time.TimeProvider;\n+\n+public class Eth1BlockFetcher {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final Eth1Provider eth1Provider;\n+  private final TimeProvider timeProvider;\n+  private final UnsignedLong cacheDuration;\n+  private final Eth1EventsChannel eth1EventsChannel;\n+  private final NavigableSet<UnsignedLong> blocksToRequest = new TreeSet<>();\n+  private boolean requestInProgress = false;\n+  private boolean active = false;\n+\n+  public Eth1BlockFetcher(\n+      final Eth1EventsChannel eth1EventsChannel,\n+      final Eth1Provider eth1Provider,\n+      final TimeProvider timeProvider,\n+      final UnsignedLong cacheDuration) {\n+    this.eth1EventsChannel = eth1EventsChannel;\n+    this.eth1Provider = eth1Provider;\n+    this.timeProvider = timeProvider;\n+    this.cacheDuration = cacheDuration;\n+  }\n+\n+  public synchronized void onInSync(final UnsignedLong latestCanonicalBlockNumber) {\n+    if (active) {\n+      return;\n+    }\n+    active = true;\n+    LOG.debug(\"Beginning back-fill of Eth1 blocks\");\n+    backfillEth1Blocks(latestCanonicalBlockNumber);\n+  }\n+\n+  public void fetch(final BigInteger fromBlock, final BigInteger toBlock) {\n+    synchronized (this) {\n+      if (!active) {\n+        // No point starting to request data if we haven't yet reached the start of the chain\n+        // We'll just wind up downloading a heap of blocks we then throw away\n+        return;\n+      }\n+      for (BigInteger block = fromBlock;\n+          block.compareTo(toBlock) <= 0;\n+          block = block.add(BigInteger.ONE)) {\n+        blocksToRequest.add(UnsignedLong.valueOf(block));\n+      }\n+    }\n+    requestNextBlockIfRequired();\n+  }\n+\n+  private void requestNextBlockIfRequired() {\n+    UnsignedLong blockToRequest;\n+    synchronized (this) {\n+      if (requestInProgress || blocksToRequest.isEmpty()) {\n+        return;\n+      }\n+      blockToRequest = blocksToRequest.last();\n+      blocksToRequest.remove(blockToRequest);\n+      requestInProgress = true;\n+    }\n+    requestBlock(blockToRequest)\n+        .always(\n+            () -> {\n+              synchronized (Eth1BlockFetcher.this) {\n+                requestInProgress = false;\n+              }\n+              requestNextBlockIfRequired();\n+            });\n+  }\n+\n+  private SafeFuture<Void> requestBlock(final UnsignedLong blockNumberToRequest) {\n+    // Note: Not using guaranteed requests here - if the Eth1 chain is temporarily unavailable\n+    // we may miss some blocks but that's better than potentially getting stuck retrying a block\n+    LOG.debug(\"Requesting block {}\", blockNumberToRequest);\n+    return eth1Provider\n+        .getEth1BlockFuture(blockNumberToRequest)\n+        .thenAccept(\n+            block -> {\n+              if (isAboveLowerBound(UnsignedLong.valueOf(block.getTimestamp()))) {\n+                postBlock(block);\n+              } else {\n+                // Every block before the one we just fetched must be outside of the range\n+                synchronized (Eth1BlockFetcher.this) {\n+                  // All blocks at or before this number must be before the cache period\n+                  blocksToRequest.headSet(blockNumberToRequest, true).clear();\n+                }\n+              }\n+              requestNextBlockIfRequired();\n+            })\n+        .exceptionallyCompose(\n+            error -> {\n+              LOG.warn(\"Failed to retrieve block {}\", blockNumberToRequest);\n+              return SafeFuture.COMPLETE;\n+            });\n+  }\n+\n+  private void postBlock(final Block block) {\n+    eth1EventsChannel.onEth1Block(\n+        Bytes32.fromHexString(block.getHash()), UnsignedLong.valueOf(block.getTimestamp()));\n+  }\n+\n+  private void backfillEth1Blocks(final UnsignedLong nextBlockToRequest) {\n+    // Walk backwards from blockNumber until we reach the start of the voting period\n+    eth1Provider\n+        .getGuaranteedEth1BlockFuture(nextBlockToRequest)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65b333f34dc2610200a569b874aa3d2e66bd369f"}, "originalPosition": 132}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE4NDc1MTYx", "url": "https://github.com/ConsenSys/teku/pull/1902#pullrequestreview-418475161", "createdAt": "2020-05-26T16:32:21Z", "commit": {"oid": "65b333f34dc2610200a569b874aa3d2e66bd369f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxNjozMjoyMVrOGamn0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxNjozMjoyMVrOGamn0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU0ODk0NQ==", "bodyText": "Adding a LOG.debug here might be useful, in case we're getting too many redundant blocks from Eth1BlockFetcher", "url": "https://github.com/ConsenSys/teku/pull/1902#discussion_r430548945", "createdAt": "2020-05-26T16:32:21Z", "author": {"login": "cemozerr"}, "path": "validator/coordinator/src/main/java/tech/pegasys/teku/validator/coordinator/Eth1DataCache.java", "diffHunk": "@@ -13,50 +13,48 @@\n \n package tech.pegasys.teku.validator.coordinator;\n \n-import static tech.pegasys.teku.util.config.Constants.EPOCHS_PER_ETH1_VOTING_PERIOD;\n-import static tech.pegasys.teku.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n-import static tech.pegasys.teku.util.config.Constants.SECONDS_PER_ETH1_BLOCK;\n-import static tech.pegasys.teku.util.config.Constants.SECONDS_PER_SLOT;\n-import static tech.pegasys.teku.util.config.Constants.SLOTS_PER_EPOCH;\n-\n-import com.google.common.eventbus.EventBus;\n-import com.google.common.eventbus.Subscribe;\n import com.google.common.primitives.UnsignedLong;\n import java.util.HashMap;\n import java.util.Map;\n+import java.util.Map.Entry;\n import java.util.NavigableMap;\n import java.util.Optional;\n import java.util.concurrent.ConcurrentSkipListMap;\n+import org.apache.tuweni.bytes.Bytes32;\n import tech.pegasys.teku.datastructures.blocks.Eth1Data;\n import tech.pegasys.teku.datastructures.state.BeaconState;\n-import tech.pegasys.teku.pow.event.CacheEth1BlockEvent;\n-import tech.pegasys.teku.util.config.Constants;\n \n public class Eth1DataCache {\n-\n   private final UnsignedLong cacheDuration;\n-  private volatile Optional<UnsignedLong> genesisTime = Optional.empty();\n+  private final Eth1VotingPeriod eth1VotingPeriod;\n \n   private final NavigableMap<UnsignedLong, Eth1Data> eth1ChainCache = new ConcurrentSkipListMap<>();\n \n-  public Eth1DataCache(EventBus eventBus) {\n-    eventBus.register(this);\n-    cacheDuration = calculateCacheDuration();\n+  public Eth1DataCache(final Eth1VotingPeriod eth1VotingPeriod) {\n+    this.eth1VotingPeriod = eth1VotingPeriod;\n+    cacheDuration = eth1VotingPeriod.getCacheDurationInSeconds();\n   }\n \n-  public void startBeaconChainMode(BeaconState headState) {\n-    this.genesisTime = Optional.of(headState.getGenesis_time());\n+  public void onBlockWithDeposit(final UnsignedLong blockTimestamp, final Eth1Data eth1Data) {\n+    eth1ChainCache.put(blockTimestamp, eth1Data);\n+    prune(blockTimestamp);\n   }\n \n-  @Subscribe\n-  public void onCacheEth1BlockEvent(CacheEth1BlockEvent cacheEth1BlockEvent) {\n-    final UnsignedLong latestBlockTimestamp = cacheEth1BlockEvent.getBlockTimestamp();\n-    eth1ChainCache.put(latestBlockTimestamp, createEth1Data(cacheEth1BlockEvent));\n-    prune(latestBlockTimestamp);\n+  public void onEth1Block(final Bytes32 blockHash, final UnsignedLong blockTimestamp) {\n+    final Entry<UnsignedLong, Eth1Data> previousBlock = eth1ChainCache.floorEntry(blockTimestamp);\n+    if (previousBlock == null) {\n+      // This block is either before any deposits so will never be voted for", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "65b333f34dc2610200a569b874aa3d2e66bd369f"}, "originalPosition": 56}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE4NDg1MDQ4", "url": "https://github.com/ConsenSys/teku/pull/1902#pullrequestreview-418485048", "createdAt": "2020-05-26T16:41:51Z", "commit": {"oid": "65b333f34dc2610200a569b874aa3d2e66bd369f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9ef674a8af2aa83d048b19636288bd259e18fa19", "author": {"user": {"login": "ajsutton", "name": "Adrian Sutton"}}, "url": "https://github.com/ConsenSys/teku/commit/9ef674a8af2aa83d048b19636288bd259e18fa19", "committedDate": "2020-05-26T22:04:47Z", "message": "Merge branch 'master' of github.com:PegaSysEng/teku into no-eth1-world-state"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9bbc9821b71b3cc4a49547107c2ade0db8343e88", "author": {"user": {"login": "ajsutton", "name": "Adrian Sutton"}}, "url": "https://github.com/ConsenSys/teku/commit/9bbc9821b71b3cc4a49547107c2ade0db8343e88", "committedDate": "2020-05-26T22:12:14Z", "message": "Review feedback."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4027, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}