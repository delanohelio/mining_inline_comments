{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk2NjEzNjcz", "number": 1510, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQyMToxNTowNFrODttWYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQyMjo1Njo0NVrODtvD7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MjU1NTIwOnYy", "diffSide": "RIGHT", "path": "storage/src/main/java/tech/pegasys/artemis/storage/rocksdb/RocksDbDatabase.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQyMToxNTowNFrOF_S34g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNToyMTo0MVrOF_wfwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTkxMzgyNg==", "bodyText": "Seems suspicious that we're storing the state in hot states and the blocks in finalised.  Suspect this should just be storing hot blocks by root.", "url": "https://github.com/ConsenSys/teku/pull/1510#discussion_r401913826", "createdAt": "2020-04-01T21:15:04Z", "author": {"login": "ajsutton"}, "path": "storage/src/main/java/tech/pegasys/artemis/storage/rocksdb/RocksDbDatabase.java", "diffHunk": "@@ -0,0 +1,669 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.storage.rocksdb;\n+\n+import static tech.pegasys.artemis.storage.rocksdb.RocksDbColumn.CHECKPOINT_STATES;\n+import static tech.pegasys.artemis.storage.rocksdb.RocksDbColumn.DEFAULT;\n+import static tech.pegasys.artemis.storage.rocksdb.RocksDbColumn.FINALIZED_BLOCKS_BY_ROOT;\n+import static tech.pegasys.artemis.storage.rocksdb.RocksDbColumn.FINALIZED_ROOTS_BY_SLOT;\n+import static tech.pegasys.artemis.storage.rocksdb.RocksDbColumn.FINALIZED_STATES_BY_ROOT;\n+import static tech.pegasys.artemis.storage.rocksdb.RocksDbColumn.HOT_BLOCKS_BY_ROOT;\n+import static tech.pegasys.artemis.storage.rocksdb.RocksDbColumn.HOT_STATES_BY_ROOT;\n+import static tech.pegasys.artemis.storage.rocksdb.RocksDbColumn.LATEST_MESSAGES;\n+import static tech.pegasys.artemis.storage.rocksdb.RocksDbDefaultColumnKey.BEST_JUSTIFIED_CHECKPOINT_KEY;\n+import static tech.pegasys.artemis.storage.rocksdb.RocksDbDefaultColumnKey.FINALIZED_CHECKPOINT_KEY;\n+import static tech.pegasys.artemis.storage.rocksdb.RocksDbDefaultColumnKey.GENESIS_TIME_KEY;\n+import static tech.pegasys.artemis.storage.rocksdb.RocksDbDefaultColumnKey.JUSTIFIED_CHECKPOINT_KEY;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.primitives.Longs;\n+import com.google.common.primitives.UnsignedLong;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.EnumSet;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentNavigableMap;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.rocksdb.BlockBasedTableConfig;\n+import org.rocksdb.ColumnFamilyDescriptor;\n+import org.rocksdb.ColumnFamilyHandle;\n+import org.rocksdb.ColumnFamilyOptions;\n+import org.rocksdb.DBOptions;\n+import org.rocksdb.Env;\n+import org.rocksdb.LRUCache;\n+import org.rocksdb.RocksDBException;\n+import org.rocksdb.RocksIterator;\n+import org.rocksdb.Statistics;\n+import org.rocksdb.Transaction;\n+import org.rocksdb.Transaction.TransactionState;\n+import org.rocksdb.TransactionDB;\n+import org.rocksdb.TransactionDBOptions;\n+import org.rocksdb.WriteOptions;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.state.BeaconStateImpl;\n+import tech.pegasys.artemis.datastructures.state.Checkpoint;\n+import tech.pegasys.artemis.datastructures.util.SimpleOffsetSerializer;\n+import tech.pegasys.artemis.storage.Store;\n+import tech.pegasys.artemis.storage.events.StorageUpdate;\n+import tech.pegasys.artemis.storage.events.StorageUpdateResult;\n+import tech.pegasys.artemis.storage.server.Database;\n+import tech.pegasys.artemis.storage.server.DatabaseStorageException;\n+import tech.pegasys.artemis.storage.server.StateStorageMode;\n+import tech.pegasys.artemis.util.sos.SimpleOffsetSerializable;\n+\n+public class RocksDbDatabase implements Database {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  static {\n+    RocksDbUtil.loadNativeLibrary();\n+  }\n+\n+  private final DBOptions options;\n+  private final TransactionDBOptions txOptions;\n+  private final AtomicBoolean closed = new AtomicBoolean(false);\n+  private final TransactionDB db;\n+  private final ImmutableMap<RocksDbColumn, ColumnFamilyHandle> columnHandlesByName;\n+  private final StateStorageMode stateStorageMode;\n+\n+  // In memory only\n+  private final ConcurrentNavigableMap<UnsignedLong, Set<Bytes32>> hotRootsBySlotCache =\n+      new ConcurrentSkipListMap<>();\n+\n+  public static Database createOnDisk(\n+      final RocksDbConfiguration configuration, final StateStorageMode stateStorageMode) {\n+    return new RocksDbDatabase(configuration, stateStorageMode);\n+  }\n+\n+  private RocksDbDatabase(\n+      final RocksDbConfiguration configuration, final StateStorageMode stateStorageMode) {\n+    this.stateStorageMode = stateStorageMode;\n+    final Statistics stats = new Statistics();\n+\n+    options =\n+        new DBOptions()\n+            .setCreateIfMissing(true)\n+            .setMaxOpenFiles(configuration.getMaxOpenFiles())\n+            .setMaxBackgroundCompactions(configuration.getMaxBackgroundCompactions())\n+            .setStatistics(stats)\n+            .setCreateMissingColumnFamilies(true)\n+            .setEnv(\n+                Env.getDefault().setBackgroundThreads(configuration.getBackgroundThreadCount()));\n+\n+    final ColumnFamilyOptions columnFamilyOptions =\n+        new ColumnFamilyOptions().setTableFormatConfig(createBlockBasedTableConfig(configuration));\n+    List<ColumnFamilyDescriptor> columnDescriptors =\n+        EnumSet.allOf(RocksDbColumn.class).stream()\n+            .map(col -> new ColumnFamilyDescriptor(col.getId(), columnFamilyOptions))\n+            .collect(Collectors.toList());\n+\n+    final List<ColumnFamilyHandle> columnHandles = new ArrayList<>(columnDescriptors.size());\n+\n+    Map<Bytes, RocksDbColumn> columnsById =\n+        EnumSet.allOf(RocksDbColumn.class).stream()\n+            .collect(Collectors.toMap(col -> Bytes.wrap(col.getId()), Function.identity()));\n+    txOptions = new TransactionDBOptions();\n+    try {\n+      db =\n+          TransactionDB.open(\n+              options,\n+              txOptions,\n+              configuration.getDatabaseDir().toString(),\n+              columnDescriptors,\n+              columnHandles);\n+\n+      final ImmutableMap.Builder<RocksDbColumn, ColumnFamilyHandle> builder =\n+          ImmutableMap.builder();\n+      for (ColumnFamilyHandle columnHandle : columnHandles) {\n+        final RocksDbColumn rocksDbColumn = columnsById.get(Bytes.wrap(columnHandle.getName()));\n+        builder.put(rocksDbColumn, columnHandle);\n+      }\n+      columnHandlesByName = builder.build();\n+\n+    } catch (RocksDBException e) {\n+      throw new DatabaseStorageException(\n+          \"Failed to open database at path: \" + configuration.getDatabaseDir(), e);\n+    }\n+  }\n+\n+  private BlockBasedTableConfig createBlockBasedTableConfig(final RocksDbConfiguration config) {\n+    final LRUCache cache = new LRUCache(config.getCacheCapacity());\n+    return new BlockBasedTableConfig().setBlockCache(cache);\n+  }\n+\n+  @Override\n+  public void storeGenesis(final Store store) {\n+    throwIfClosed();\n+    final WriteOptions options = new WriteOptions();\n+    try (Transaction transaction = db.beginTransaction(options)) {\n+      try {\n+        ColumnFamilyHandle defaultColumn = columnHandlesByName.get(DEFAULT);\n+        transaction.put(\n+            defaultColumn,\n+            GENESIS_TIME_KEY.getId(),\n+            Longs.toByteArray(store.getGenesisTime().longValue()));\n+        transaction.put(\n+            defaultColumn,\n+            RocksDbDefaultColumnKey.JUSTIFIED_CHECKPOINT_KEY.getId(),\n+            serialize(store.getJustifiedCheckpoint()));\n+        transaction.put(\n+            defaultColumn,\n+            RocksDbDefaultColumnKey.BEST_JUSTIFIED_CHECKPOINT_KEY.getId(),\n+            serialize(store.getBestJustifiedCheckpoint()));\n+        transaction.put(\n+            defaultColumn,\n+            FINALIZED_CHECKPOINT_KEY.getId(),\n+            serialize(store.getFinalizedCheckpoint()));\n+        store\n+            .getBlockRoots()\n+            .forEach(\n+                root -> {\n+                  final SignedBeaconBlock block = store.getSignedBlock(root);\n+                  final BeaconState state = store.getBlockState(root);\n+                  try {\n+                    addHotBlock(transaction, root, block);\n+                    byte[] rootArray = root.toArrayUnsafe();\n+                    transaction.put(\n+                        columnHandlesByName.get(HOT_STATES_BY_ROOT), rootArray, serialize(state));\n+                    transaction.put(\n+                        columnHandlesByName.get(FINALIZED_ROOTS_BY_SLOT),\n+                        Longs.toByteArray(block.getSlot().longValue()),\n+                        rootArray);\n+                    transaction.put(\n+                        columnHandlesByName.get(FINALIZED_BLOCKS_BY_ROOT),\n+                        rootArray,\n+                        serialize(block));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0854e863ab2e6ac565916341775df7639c3dee78"}, "originalPosition": 201}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjM3ODAxNA==", "bodyText": "We're storing state and blocks in both hot and cold storage here (we should only have 1 block / state here since we're handling genesis - the forEach is a little misleading): see addHotBlock on 190 and putFinalizedState on line 202.  We need the latest finalized block and state in both hot and cold storage - if we don't have any hot blocks / state we won't be able to restart because the fork choice and block import logic runs on top of RecentChainData.", "url": "https://github.com/ConsenSys/teku/pull/1510#discussion_r402378014", "createdAt": "2020-04-02T14:54:30Z", "author": {"login": "mbaxter"}, "path": "storage/src/main/java/tech/pegasys/artemis/storage/rocksdb/RocksDbDatabase.java", "diffHunk": "@@ -0,0 +1,669 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.storage.rocksdb;\n+\n+import static tech.pegasys.artemis.storage.rocksdb.RocksDbColumn.CHECKPOINT_STATES;\n+import static tech.pegasys.artemis.storage.rocksdb.RocksDbColumn.DEFAULT;\n+import static tech.pegasys.artemis.storage.rocksdb.RocksDbColumn.FINALIZED_BLOCKS_BY_ROOT;\n+import static tech.pegasys.artemis.storage.rocksdb.RocksDbColumn.FINALIZED_ROOTS_BY_SLOT;\n+import static tech.pegasys.artemis.storage.rocksdb.RocksDbColumn.FINALIZED_STATES_BY_ROOT;\n+import static tech.pegasys.artemis.storage.rocksdb.RocksDbColumn.HOT_BLOCKS_BY_ROOT;\n+import static tech.pegasys.artemis.storage.rocksdb.RocksDbColumn.HOT_STATES_BY_ROOT;\n+import static tech.pegasys.artemis.storage.rocksdb.RocksDbColumn.LATEST_MESSAGES;\n+import static tech.pegasys.artemis.storage.rocksdb.RocksDbDefaultColumnKey.BEST_JUSTIFIED_CHECKPOINT_KEY;\n+import static tech.pegasys.artemis.storage.rocksdb.RocksDbDefaultColumnKey.FINALIZED_CHECKPOINT_KEY;\n+import static tech.pegasys.artemis.storage.rocksdb.RocksDbDefaultColumnKey.GENESIS_TIME_KEY;\n+import static tech.pegasys.artemis.storage.rocksdb.RocksDbDefaultColumnKey.JUSTIFIED_CHECKPOINT_KEY;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.primitives.Longs;\n+import com.google.common.primitives.UnsignedLong;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.EnumSet;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentNavigableMap;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.rocksdb.BlockBasedTableConfig;\n+import org.rocksdb.ColumnFamilyDescriptor;\n+import org.rocksdb.ColumnFamilyHandle;\n+import org.rocksdb.ColumnFamilyOptions;\n+import org.rocksdb.DBOptions;\n+import org.rocksdb.Env;\n+import org.rocksdb.LRUCache;\n+import org.rocksdb.RocksDBException;\n+import org.rocksdb.RocksIterator;\n+import org.rocksdb.Statistics;\n+import org.rocksdb.Transaction;\n+import org.rocksdb.Transaction.TransactionState;\n+import org.rocksdb.TransactionDB;\n+import org.rocksdb.TransactionDBOptions;\n+import org.rocksdb.WriteOptions;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.state.BeaconStateImpl;\n+import tech.pegasys.artemis.datastructures.state.Checkpoint;\n+import tech.pegasys.artemis.datastructures.util.SimpleOffsetSerializer;\n+import tech.pegasys.artemis.storage.Store;\n+import tech.pegasys.artemis.storage.events.StorageUpdate;\n+import tech.pegasys.artemis.storage.events.StorageUpdateResult;\n+import tech.pegasys.artemis.storage.server.Database;\n+import tech.pegasys.artemis.storage.server.DatabaseStorageException;\n+import tech.pegasys.artemis.storage.server.StateStorageMode;\n+import tech.pegasys.artemis.util.sos.SimpleOffsetSerializable;\n+\n+public class RocksDbDatabase implements Database {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  static {\n+    RocksDbUtil.loadNativeLibrary();\n+  }\n+\n+  private final DBOptions options;\n+  private final TransactionDBOptions txOptions;\n+  private final AtomicBoolean closed = new AtomicBoolean(false);\n+  private final TransactionDB db;\n+  private final ImmutableMap<RocksDbColumn, ColumnFamilyHandle> columnHandlesByName;\n+  private final StateStorageMode stateStorageMode;\n+\n+  // In memory only\n+  private final ConcurrentNavigableMap<UnsignedLong, Set<Bytes32>> hotRootsBySlotCache =\n+      new ConcurrentSkipListMap<>();\n+\n+  public static Database createOnDisk(\n+      final RocksDbConfiguration configuration, final StateStorageMode stateStorageMode) {\n+    return new RocksDbDatabase(configuration, stateStorageMode);\n+  }\n+\n+  private RocksDbDatabase(\n+      final RocksDbConfiguration configuration, final StateStorageMode stateStorageMode) {\n+    this.stateStorageMode = stateStorageMode;\n+    final Statistics stats = new Statistics();\n+\n+    options =\n+        new DBOptions()\n+            .setCreateIfMissing(true)\n+            .setMaxOpenFiles(configuration.getMaxOpenFiles())\n+            .setMaxBackgroundCompactions(configuration.getMaxBackgroundCompactions())\n+            .setStatistics(stats)\n+            .setCreateMissingColumnFamilies(true)\n+            .setEnv(\n+                Env.getDefault().setBackgroundThreads(configuration.getBackgroundThreadCount()));\n+\n+    final ColumnFamilyOptions columnFamilyOptions =\n+        new ColumnFamilyOptions().setTableFormatConfig(createBlockBasedTableConfig(configuration));\n+    List<ColumnFamilyDescriptor> columnDescriptors =\n+        EnumSet.allOf(RocksDbColumn.class).stream()\n+            .map(col -> new ColumnFamilyDescriptor(col.getId(), columnFamilyOptions))\n+            .collect(Collectors.toList());\n+\n+    final List<ColumnFamilyHandle> columnHandles = new ArrayList<>(columnDescriptors.size());\n+\n+    Map<Bytes, RocksDbColumn> columnsById =\n+        EnumSet.allOf(RocksDbColumn.class).stream()\n+            .collect(Collectors.toMap(col -> Bytes.wrap(col.getId()), Function.identity()));\n+    txOptions = new TransactionDBOptions();\n+    try {\n+      db =\n+          TransactionDB.open(\n+              options,\n+              txOptions,\n+              configuration.getDatabaseDir().toString(),\n+              columnDescriptors,\n+              columnHandles);\n+\n+      final ImmutableMap.Builder<RocksDbColumn, ColumnFamilyHandle> builder =\n+          ImmutableMap.builder();\n+      for (ColumnFamilyHandle columnHandle : columnHandles) {\n+        final RocksDbColumn rocksDbColumn = columnsById.get(Bytes.wrap(columnHandle.getName()));\n+        builder.put(rocksDbColumn, columnHandle);\n+      }\n+      columnHandlesByName = builder.build();\n+\n+    } catch (RocksDBException e) {\n+      throw new DatabaseStorageException(\n+          \"Failed to open database at path: \" + configuration.getDatabaseDir(), e);\n+    }\n+  }\n+\n+  private BlockBasedTableConfig createBlockBasedTableConfig(final RocksDbConfiguration config) {\n+    final LRUCache cache = new LRUCache(config.getCacheCapacity());\n+    return new BlockBasedTableConfig().setBlockCache(cache);\n+  }\n+\n+  @Override\n+  public void storeGenesis(final Store store) {\n+    throwIfClosed();\n+    final WriteOptions options = new WriteOptions();\n+    try (Transaction transaction = db.beginTransaction(options)) {\n+      try {\n+        ColumnFamilyHandle defaultColumn = columnHandlesByName.get(DEFAULT);\n+        transaction.put(\n+            defaultColumn,\n+            GENESIS_TIME_KEY.getId(),\n+            Longs.toByteArray(store.getGenesisTime().longValue()));\n+        transaction.put(\n+            defaultColumn,\n+            RocksDbDefaultColumnKey.JUSTIFIED_CHECKPOINT_KEY.getId(),\n+            serialize(store.getJustifiedCheckpoint()));\n+        transaction.put(\n+            defaultColumn,\n+            RocksDbDefaultColumnKey.BEST_JUSTIFIED_CHECKPOINT_KEY.getId(),\n+            serialize(store.getBestJustifiedCheckpoint()));\n+        transaction.put(\n+            defaultColumn,\n+            FINALIZED_CHECKPOINT_KEY.getId(),\n+            serialize(store.getFinalizedCheckpoint()));\n+        store\n+            .getBlockRoots()\n+            .forEach(\n+                root -> {\n+                  final SignedBeaconBlock block = store.getSignedBlock(root);\n+                  final BeaconState state = store.getBlockState(root);\n+                  try {\n+                    addHotBlock(transaction, root, block);\n+                    byte[] rootArray = root.toArrayUnsafe();\n+                    transaction.put(\n+                        columnHandlesByName.get(HOT_STATES_BY_ROOT), rootArray, serialize(state));\n+                    transaction.put(\n+                        columnHandlesByName.get(FINALIZED_ROOTS_BY_SLOT),\n+                        Longs.toByteArray(block.getSlot().longValue()),\n+                        rootArray);\n+                    transaction.put(\n+                        columnHandlesByName.get(FINALIZED_BLOCKS_BY_ROOT),\n+                        rootArray,\n+                        serialize(block));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTkxMzgyNg=="}, "originalCommit": {"oid": "0854e863ab2e6ac565916341775df7639c3dee78"}, "originalPosition": 201}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjM5OTE3MA==", "bodyText": "I've added some extra comments to make this clearer.  And verified we have tests to cover this.", "url": "https://github.com/ConsenSys/teku/pull/1510#discussion_r402399170", "createdAt": "2020-04-02T15:21:41Z", "author": {"login": "mbaxter"}, "path": "storage/src/main/java/tech/pegasys/artemis/storage/rocksdb/RocksDbDatabase.java", "diffHunk": "@@ -0,0 +1,669 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.storage.rocksdb;\n+\n+import static tech.pegasys.artemis.storage.rocksdb.RocksDbColumn.CHECKPOINT_STATES;\n+import static tech.pegasys.artemis.storage.rocksdb.RocksDbColumn.DEFAULT;\n+import static tech.pegasys.artemis.storage.rocksdb.RocksDbColumn.FINALIZED_BLOCKS_BY_ROOT;\n+import static tech.pegasys.artemis.storage.rocksdb.RocksDbColumn.FINALIZED_ROOTS_BY_SLOT;\n+import static tech.pegasys.artemis.storage.rocksdb.RocksDbColumn.FINALIZED_STATES_BY_ROOT;\n+import static tech.pegasys.artemis.storage.rocksdb.RocksDbColumn.HOT_BLOCKS_BY_ROOT;\n+import static tech.pegasys.artemis.storage.rocksdb.RocksDbColumn.HOT_STATES_BY_ROOT;\n+import static tech.pegasys.artemis.storage.rocksdb.RocksDbColumn.LATEST_MESSAGES;\n+import static tech.pegasys.artemis.storage.rocksdb.RocksDbDefaultColumnKey.BEST_JUSTIFIED_CHECKPOINT_KEY;\n+import static tech.pegasys.artemis.storage.rocksdb.RocksDbDefaultColumnKey.FINALIZED_CHECKPOINT_KEY;\n+import static tech.pegasys.artemis.storage.rocksdb.RocksDbDefaultColumnKey.GENESIS_TIME_KEY;\n+import static tech.pegasys.artemis.storage.rocksdb.RocksDbDefaultColumnKey.JUSTIFIED_CHECKPOINT_KEY;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.primitives.Longs;\n+import com.google.common.primitives.UnsignedLong;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.EnumSet;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentNavigableMap;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.rocksdb.BlockBasedTableConfig;\n+import org.rocksdb.ColumnFamilyDescriptor;\n+import org.rocksdb.ColumnFamilyHandle;\n+import org.rocksdb.ColumnFamilyOptions;\n+import org.rocksdb.DBOptions;\n+import org.rocksdb.Env;\n+import org.rocksdb.LRUCache;\n+import org.rocksdb.RocksDBException;\n+import org.rocksdb.RocksIterator;\n+import org.rocksdb.Statistics;\n+import org.rocksdb.Transaction;\n+import org.rocksdb.Transaction.TransactionState;\n+import org.rocksdb.TransactionDB;\n+import org.rocksdb.TransactionDBOptions;\n+import org.rocksdb.WriteOptions;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.state.BeaconStateImpl;\n+import tech.pegasys.artemis.datastructures.state.Checkpoint;\n+import tech.pegasys.artemis.datastructures.util.SimpleOffsetSerializer;\n+import tech.pegasys.artemis.storage.Store;\n+import tech.pegasys.artemis.storage.events.StorageUpdate;\n+import tech.pegasys.artemis.storage.events.StorageUpdateResult;\n+import tech.pegasys.artemis.storage.server.Database;\n+import tech.pegasys.artemis.storage.server.DatabaseStorageException;\n+import tech.pegasys.artemis.storage.server.StateStorageMode;\n+import tech.pegasys.artemis.util.sos.SimpleOffsetSerializable;\n+\n+public class RocksDbDatabase implements Database {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  static {\n+    RocksDbUtil.loadNativeLibrary();\n+  }\n+\n+  private final DBOptions options;\n+  private final TransactionDBOptions txOptions;\n+  private final AtomicBoolean closed = new AtomicBoolean(false);\n+  private final TransactionDB db;\n+  private final ImmutableMap<RocksDbColumn, ColumnFamilyHandle> columnHandlesByName;\n+  private final StateStorageMode stateStorageMode;\n+\n+  // In memory only\n+  private final ConcurrentNavigableMap<UnsignedLong, Set<Bytes32>> hotRootsBySlotCache =\n+      new ConcurrentSkipListMap<>();\n+\n+  public static Database createOnDisk(\n+      final RocksDbConfiguration configuration, final StateStorageMode stateStorageMode) {\n+    return new RocksDbDatabase(configuration, stateStorageMode);\n+  }\n+\n+  private RocksDbDatabase(\n+      final RocksDbConfiguration configuration, final StateStorageMode stateStorageMode) {\n+    this.stateStorageMode = stateStorageMode;\n+    final Statistics stats = new Statistics();\n+\n+    options =\n+        new DBOptions()\n+            .setCreateIfMissing(true)\n+            .setMaxOpenFiles(configuration.getMaxOpenFiles())\n+            .setMaxBackgroundCompactions(configuration.getMaxBackgroundCompactions())\n+            .setStatistics(stats)\n+            .setCreateMissingColumnFamilies(true)\n+            .setEnv(\n+                Env.getDefault().setBackgroundThreads(configuration.getBackgroundThreadCount()));\n+\n+    final ColumnFamilyOptions columnFamilyOptions =\n+        new ColumnFamilyOptions().setTableFormatConfig(createBlockBasedTableConfig(configuration));\n+    List<ColumnFamilyDescriptor> columnDescriptors =\n+        EnumSet.allOf(RocksDbColumn.class).stream()\n+            .map(col -> new ColumnFamilyDescriptor(col.getId(), columnFamilyOptions))\n+            .collect(Collectors.toList());\n+\n+    final List<ColumnFamilyHandle> columnHandles = new ArrayList<>(columnDescriptors.size());\n+\n+    Map<Bytes, RocksDbColumn> columnsById =\n+        EnumSet.allOf(RocksDbColumn.class).stream()\n+            .collect(Collectors.toMap(col -> Bytes.wrap(col.getId()), Function.identity()));\n+    txOptions = new TransactionDBOptions();\n+    try {\n+      db =\n+          TransactionDB.open(\n+              options,\n+              txOptions,\n+              configuration.getDatabaseDir().toString(),\n+              columnDescriptors,\n+              columnHandles);\n+\n+      final ImmutableMap.Builder<RocksDbColumn, ColumnFamilyHandle> builder =\n+          ImmutableMap.builder();\n+      for (ColumnFamilyHandle columnHandle : columnHandles) {\n+        final RocksDbColumn rocksDbColumn = columnsById.get(Bytes.wrap(columnHandle.getName()));\n+        builder.put(rocksDbColumn, columnHandle);\n+      }\n+      columnHandlesByName = builder.build();\n+\n+    } catch (RocksDBException e) {\n+      throw new DatabaseStorageException(\n+          \"Failed to open database at path: \" + configuration.getDatabaseDir(), e);\n+    }\n+  }\n+\n+  private BlockBasedTableConfig createBlockBasedTableConfig(final RocksDbConfiguration config) {\n+    final LRUCache cache = new LRUCache(config.getCacheCapacity());\n+    return new BlockBasedTableConfig().setBlockCache(cache);\n+  }\n+\n+  @Override\n+  public void storeGenesis(final Store store) {\n+    throwIfClosed();\n+    final WriteOptions options = new WriteOptions();\n+    try (Transaction transaction = db.beginTransaction(options)) {\n+      try {\n+        ColumnFamilyHandle defaultColumn = columnHandlesByName.get(DEFAULT);\n+        transaction.put(\n+            defaultColumn,\n+            GENESIS_TIME_KEY.getId(),\n+            Longs.toByteArray(store.getGenesisTime().longValue()));\n+        transaction.put(\n+            defaultColumn,\n+            RocksDbDefaultColumnKey.JUSTIFIED_CHECKPOINT_KEY.getId(),\n+            serialize(store.getJustifiedCheckpoint()));\n+        transaction.put(\n+            defaultColumn,\n+            RocksDbDefaultColumnKey.BEST_JUSTIFIED_CHECKPOINT_KEY.getId(),\n+            serialize(store.getBestJustifiedCheckpoint()));\n+        transaction.put(\n+            defaultColumn,\n+            FINALIZED_CHECKPOINT_KEY.getId(),\n+            serialize(store.getFinalizedCheckpoint()));\n+        store\n+            .getBlockRoots()\n+            .forEach(\n+                root -> {\n+                  final SignedBeaconBlock block = store.getSignedBlock(root);\n+                  final BeaconState state = store.getBlockState(root);\n+                  try {\n+                    addHotBlock(transaction, root, block);\n+                    byte[] rootArray = root.toArrayUnsafe();\n+                    transaction.put(\n+                        columnHandlesByName.get(HOT_STATES_BY_ROOT), rootArray, serialize(state));\n+                    transaction.put(\n+                        columnHandlesByName.get(FINALIZED_ROOTS_BY_SLOT),\n+                        Longs.toByteArray(block.getSlot().longValue()),\n+                        rootArray);\n+                    transaction.put(\n+                        columnHandlesByName.get(FINALIZED_BLOCKS_BY_ROOT),\n+                        rootArray,\n+                        serialize(block));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTkxMzgyNg=="}, "originalCommit": {"oid": "0854e863ab2e6ac565916341775df7639c3dee78"}, "originalPosition": 201}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MjgzNTA2OnYy", "diffSide": "RIGHT", "path": "storage/src/test/java/tech/pegasys/artemis/storage/server/AbstractStorageBackedDatabaseTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQyMjo1NjozMVrOF_Vi2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNToyMDo0MFrOF_wc2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk1NzU5Mw==", "bodyText": "Why doesn't this use the @TempDir support?", "url": "https://github.com/ConsenSys/teku/pull/1510#discussion_r401957593", "createdAt": "2020-04-01T22:56:31Z", "author": {"login": "ajsutton"}, "path": "storage/src/test/java/tech/pegasys/artemis/storage/server/AbstractStorageBackedDatabaseTest.java", "diffHunk": "@@ -0,0 +1,155 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.storage.server;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.io.Files;\n+import com.google.common.primitives.UnsignedLong;\n+import java.io.File;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.io.TempDir;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.state.Checkpoint;\n+import tech.pegasys.artemis.storage.TrackingStorageUpdateChannel;\n+\n+public abstract class AbstractStorageBackedDatabaseTest extends AbstractDatabaseTest {\n+\n+  protected abstract Database createDatabase(\n+      final File tempDir, final StateStorageMode storageMode);\n+\n+  @Override\n+  protected Database createDatabase(final StateStorageMode storageMode) {\n+    final File tmpDir = Files.createTempDir();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f967b1517ec73cfe6ce75b248405e69a0025c26"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjM5ODQyNw==", "bodyText": "This is overriding the db create method from AbstractDatabaseTest, which covers all databases and doesn't assume that databases are storage-backed.  So, I didn't see a simple way to inject the @TempDir via a parameter without adding unnecessary file creation for memory-backed Database implementations.", "url": "https://github.com/ConsenSys/teku/pull/1510#discussion_r402398427", "createdAt": "2020-04-02T15:20:40Z", "author": {"login": "mbaxter"}, "path": "storage/src/test/java/tech/pegasys/artemis/storage/server/AbstractStorageBackedDatabaseTest.java", "diffHunk": "@@ -0,0 +1,155 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.storage.server;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.io.Files;\n+import com.google.common.primitives.UnsignedLong;\n+import java.io.File;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.io.TempDir;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.state.Checkpoint;\n+import tech.pegasys.artemis.storage.TrackingStorageUpdateChannel;\n+\n+public abstract class AbstractStorageBackedDatabaseTest extends AbstractDatabaseTest {\n+\n+  protected abstract Database createDatabase(\n+      final File tempDir, final StateStorageMode storageMode);\n+\n+  @Override\n+  protected Database createDatabase(final StateStorageMode storageMode) {\n+    final File tmpDir = Files.createTempDir();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk1NzU5Mw=="}, "originalCommit": {"oid": "8f967b1517ec73cfe6ce75b248405e69a0025c26"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5MjgzNTY3OnYy", "diffSide": "RIGHT", "path": "storage/src/test/java/tech/pegasys/artemis/storage/server/AbstractStorageBackedDatabaseTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQyMjo1Njo0NVrOF_VjQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMlQxNToyMTowNlrOF_weHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk1NzY5Nw==", "bodyText": "Does this work for a directory given it won't be empty by the time the test finishes?", "url": "https://github.com/ConsenSys/teku/pull/1510#discussion_r401957697", "createdAt": "2020-04-01T22:56:45Z", "author": {"login": "ajsutton"}, "path": "storage/src/test/java/tech/pegasys/artemis/storage/server/AbstractStorageBackedDatabaseTest.java", "diffHunk": "@@ -0,0 +1,155 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.storage.server;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.io.Files;\n+import com.google.common.primitives.UnsignedLong;\n+import java.io.File;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.io.TempDir;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.state.Checkpoint;\n+import tech.pegasys.artemis.storage.TrackingStorageUpdateChannel;\n+\n+public abstract class AbstractStorageBackedDatabaseTest extends AbstractDatabaseTest {\n+\n+  protected abstract Database createDatabase(\n+      final File tempDir, final StateStorageMode storageMode);\n+\n+  @Override\n+  protected Database createDatabase(final StateStorageMode storageMode) {\n+    final File tmpDir = Files.createTempDir();\n+    tmpDir.deleteOnExit();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8f967b1517ec73cfe6ce75b248405e69a0025c26"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjM5ODc0OA==", "bodyText": "Good catch - I've added extra cleanup logic for this.", "url": "https://github.com/ConsenSys/teku/pull/1510#discussion_r402398748", "createdAt": "2020-04-02T15:21:06Z", "author": {"login": "mbaxter"}, "path": "storage/src/test/java/tech/pegasys/artemis/storage/server/AbstractStorageBackedDatabaseTest.java", "diffHunk": "@@ -0,0 +1,155 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.storage.server;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.io.Files;\n+import com.google.common.primitives.UnsignedLong;\n+import java.io.File;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.io.TempDir;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.state.Checkpoint;\n+import tech.pegasys.artemis.storage.TrackingStorageUpdateChannel;\n+\n+public abstract class AbstractStorageBackedDatabaseTest extends AbstractDatabaseTest {\n+\n+  protected abstract Database createDatabase(\n+      final File tempDir, final StateStorageMode storageMode);\n+\n+  @Override\n+  protected Database createDatabase(final StateStorageMode storageMode) {\n+    final File tmpDir = Files.createTempDir();\n+    tmpDir.deleteOnExit();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTk1NzY5Nw=="}, "originalCommit": {"oid": "8f967b1517ec73cfe6ce75b248405e69a0025c26"}, "originalPosition": 43}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1787, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}