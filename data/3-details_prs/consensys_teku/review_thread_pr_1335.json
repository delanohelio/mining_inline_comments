{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg1ODc0MTMw", "number": 1335, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxNTo1ODoyMVrODmvsSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxNjowNjowMlrODmv6JQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxOTUzODY1OnYy", "diffSide": "RIGHT", "path": "events/src/main/java/tech/pegasys/artemis/events/EventChannel.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxNTo1ODoyMVrOF0Vlog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQyMjozMjo1NVrOF0jXww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQyMzk3MA==", "bodyText": "(nit) Might be worth some javadoc that explains numberOfThreads will be used at the discretion of the specific implementation as the target degree of processing parallelism or something like that.\nPossibly we could rename to something like:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public void subscribeMultithreaded(final T listener, final int numberOfThreads) {\n          \n          \n            \n              public void subscribe(final T listener, final int requestedParallelism) {\n          \n      \n    \n    \n  \n\nwhich is more generic, although maybe more obscure \ud83e\udd37\u200d\u2640", "url": "https://github.com/ConsenSys/teku/pull/1335#discussion_r390423970", "createdAt": "2020-03-10T15:58:21Z", "author": {"login": "mbaxter"}, "path": "events/src/main/java/tech/pegasys/artemis/events/EventChannel.java", "diffHunk": "@@ -134,11 +134,16 @@ public T getPublisher() {\n     return publisher;\n   }\n \n-  public void subscribe(T listener) {\n+  public void subscribe(final T listener) {\n+    subscribeMultithreaded(listener, 1);\n+  }\n+\n+  public void subscribeMultithreaded(final T listener, final int numberOfThreads) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d30f84cbea44968e56b8e7941500918a580a51db"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY0OTc5NQ==", "bodyText": "I've added some java doc.  I'm not too concerned about the fact that the number of threads is ignored for synchronous channels because we should only use those for testing anyway.\nI'm also more concerned that we'll accidentally make something multithreaded than that it will be single threaded.  So have stuck with subscribeMultithreaded as the name so it's really clear.", "url": "https://github.com/ConsenSys/teku/pull/1335#discussion_r390649795", "createdAt": "2020-03-10T22:32:55Z", "author": {"login": "ajsutton"}, "path": "events/src/main/java/tech/pegasys/artemis/events/EventChannel.java", "diffHunk": "@@ -134,11 +134,16 @@ public T getPublisher() {\n     return publisher;\n   }\n \n-  public void subscribe(T listener) {\n+  public void subscribe(final T listener) {\n+    subscribeMultithreaded(listener, 1);\n+  }\n+\n+  public void subscribeMultithreaded(final T listener, final int numberOfThreads) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQyMzk3MA=="}, "originalCommit": {"oid": "d30f84cbea44968e56b8e7941500918a580a51db"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQxOTU3NDEzOnYy", "diffSide": "RIGHT", "path": "events/src/test/java/tech/pegasys/artemis/events/EventChannelTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQxNjowNjowMlrOF0V7zw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xMFQyMjozNToyMlrOF0jbJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQyOTY0Nw==", "bodyText": "I think spying on started1 and saying verify(started1).await() would be more clear here,  because the constants and the time unit makes the reader go look for other constants.", "url": "https://github.com/ConsenSys/teku/pull/1335#discussion_r390429647", "createdAt": "2020-03-10T16:06:02Z", "author": {"login": "cemozerr"}, "path": "events/src/test/java/tech/pegasys/artemis/events/EventChannelTest.java", "diffHunk": "@@ -183,6 +196,54 @@ public void shouldDeliverEventsAsync() throws Exception {\n     inOrder.verifyNoMoreInteractions();\n   }\n \n+  @Test\n+  public void shouldDeliverAsyncEventsOnMultipleThreads() throws Exception {\n+    executor =\n+        Executors.newCachedThreadPool(\n+            new ThreadFactoryBuilder()\n+                .setDaemon(true)\n+                .setNameFormat(\"shoudlDeliverAsyncEventsOnMultipleThreads-%d\")\n+                .build());\n+    final EventChannel<WaitOnLatch> channel =\n+        EventChannel.createAsync(WaitOnLatch.class, executor, metricsSystem);\n+    final WaitOnLatch subscriber =\n+        (started, await, completed) -> {\n+          started.countDown();\n+          try {\n+            await.await();\n+            completed.countDown();\n+          } catch (InterruptedException e) {\n+            throw new RuntimeException(e);\n+          }\n+        };\n+    channel.subscribeMultithreaded(subscriber, 2); // Two subscribing threads\n+\n+    final CountDownLatch started1 = new CountDownLatch(1);\n+    final CountDownLatch await1 = new CountDownLatch(1);\n+    final CountDownLatch completed1 = new CountDownLatch(1);\n+    final CountDownLatch started2 = new CountDownLatch(1);\n+    final CountDownLatch await2 = new CountDownLatch(1);\n+    final CountDownLatch completed2 = new CountDownLatch(1);\n+\n+    // Publish two events\n+    channel.getPublisher().waitFor(started1, await1, completed1);\n+    channel.getPublisher().waitFor(started2, await2, completed2);\n+\n+    // Both events should start being processed\n+    assertThat(started1.await(5, TimeUnit.SECONDS)).isTrue();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d30f84cbea44968e56b8e7941500918a580a51db"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY1MDY2Mw==", "bodyText": "You can't use a spy in this case because the test is multithreaded and mockito is generally not thread safe.  I've extracted a private method to make it more readable though.", "url": "https://github.com/ConsenSys/teku/pull/1335#discussion_r390650663", "createdAt": "2020-03-10T22:35:22Z", "author": {"login": "ajsutton"}, "path": "events/src/test/java/tech/pegasys/artemis/events/EventChannelTest.java", "diffHunk": "@@ -183,6 +196,54 @@ public void shouldDeliverEventsAsync() throws Exception {\n     inOrder.verifyNoMoreInteractions();\n   }\n \n+  @Test\n+  public void shouldDeliverAsyncEventsOnMultipleThreads() throws Exception {\n+    executor =\n+        Executors.newCachedThreadPool(\n+            new ThreadFactoryBuilder()\n+                .setDaemon(true)\n+                .setNameFormat(\"shoudlDeliverAsyncEventsOnMultipleThreads-%d\")\n+                .build());\n+    final EventChannel<WaitOnLatch> channel =\n+        EventChannel.createAsync(WaitOnLatch.class, executor, metricsSystem);\n+    final WaitOnLatch subscriber =\n+        (started, await, completed) -> {\n+          started.countDown();\n+          try {\n+            await.await();\n+            completed.countDown();\n+          } catch (InterruptedException e) {\n+            throw new RuntimeException(e);\n+          }\n+        };\n+    channel.subscribeMultithreaded(subscriber, 2); // Two subscribing threads\n+\n+    final CountDownLatch started1 = new CountDownLatch(1);\n+    final CountDownLatch await1 = new CountDownLatch(1);\n+    final CountDownLatch completed1 = new CountDownLatch(1);\n+    final CountDownLatch started2 = new CountDownLatch(1);\n+    final CountDownLatch await2 = new CountDownLatch(1);\n+    final CountDownLatch completed2 = new CountDownLatch(1);\n+\n+    // Publish two events\n+    channel.getPublisher().waitFor(started1, await1, completed1);\n+    channel.getPublisher().waitFor(started2, await2, completed2);\n+\n+    // Both events should start being processed\n+    assertThat(started1.await(5, TimeUnit.SECONDS)).isTrue();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDQyOTY0Nw=="}, "originalCommit": {"oid": "d30f84cbea44968e56b8e7941500918a580a51db"}, "originalPosition": 69}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2522, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}