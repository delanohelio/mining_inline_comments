{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMxMDYyMDY2", "number": 3347, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwMjo0OTozN1rOFCGBHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNjo0NDo0NVrOFCdnWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3NzQwMDYxOnYy", "diffSide": "RIGHT", "path": "ssz/src/main/java/tech/pegasys/teku/ssz/backing/tree/SszNodeTemplate.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwMjo0OTozN1rOIBEdsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwMjo0OTozN1rOIBEdsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzk5MjYyNw==", "bodyText": "Understanding this took me way too long. But beautiful...", "url": "https://github.com/ConsenSys/teku/pull/3347#discussion_r537992627", "createdAt": "2020-12-08T02:49:37Z", "author": {"login": "cemozerr"}, "path": "ssz/src/main/java/tech/pegasys/teku/ssz/backing/tree/SszNodeTemplate.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.ssz.backing.tree;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static tech.pegasys.teku.ssz.backing.tree.GIndexUtil.LEFTMOST_G_INDEX;\n+import static tech.pegasys.teku.ssz.backing.tree.GIndexUtil.RIGHTMOST_G_INDEX;\n+import static tech.pegasys.teku.ssz.backing.tree.GIndexUtil.SELF_G_INDEX;\n+import static tech.pegasys.teku.ssz.backing.tree.GIndexUtil.gIdxIsSelf;\n+import static tech.pegasys.teku.ssz.backing.tree.GIndexUtil.gIdxLeftGIndex;\n+import static tech.pegasys.teku.ssz.backing.tree.GIndexUtil.gIdxRightGIndex;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.apache.tuweni.bytes.MutableBytes;\n+import org.apache.tuweni.crypto.Hash;\n+import tech.pegasys.teku.ssz.backing.type.ViewType;\n+\n+/**\n+ * Represents the tree structure for a fixed size SSZ type See {@link SszSuperNode} docs for more\n+ * details\n+ */\n+public class SszNodeTemplate {\n+\n+  static final class Location {\n+    private final int offset;\n+    private final int length;\n+    private final boolean leaf;\n+\n+    public Location(int offset, int length, boolean leaf) {\n+      this.offset = offset;\n+      this.length = length;\n+      this.leaf = leaf;\n+    }\n+\n+    public Location withAddedOffset(int addOffset) {\n+      return new Location(getOffset() + addOffset, getLength(), isLeaf());\n+    }\n+\n+    public int getOffset() {\n+      return offset;\n+    }\n+\n+    public int getLength() {\n+      return length;\n+    }\n+\n+    public boolean isLeaf() {\n+      return leaf;\n+    }\n+  }\n+\n+  public static SszNodeTemplate createFromType(ViewType viewType) {\n+    checkArgument(viewType.isFixedSize(), \"Only fixed size types supported\");\n+\n+    return createFromTree(viewType.getDefaultTree());\n+  }\n+\n+  // This should be CANONICAL binary tree\n+  private static SszNodeTemplate createFromTree(TreeNode defaultTree) {\n+    Map<Long, Location> gIdxToLoc =\n+        binaryTraverse(\n+            GIndexUtil.SELF_G_INDEX,\n+            defaultTree,\n+            new BinaryVisitor<>() {\n+              @Override\n+              public Map<Long, Location> visitLeaf(long gIndex, LeafNode node) {\n+                Map<Long, Location> ret = new HashMap<>();\n+                ret.put(gIndex, new Location(0, node.getData().size(), true));\n+                return ret;\n+              }\n+\n+              @Override\n+              public Map<Long, Location> visitBranch(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3d07885c2ff6ee726d799eb39df027de952319e"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4MDkzOTU2OnYy", "diffSide": "RIGHT", "path": "ssz/src/main/java/tech/pegasys/teku/ssz/backing/tree/SszSuperNode.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNTo1ODowNFrOIBla9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNzo0MTo0MFrOIBshGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODUzMjU5OQ==", "bodyText": "This might make the code easier to read and make the code more defensive.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  } else {\n          \n          \n            \n                  } else if (offset == ssz.size()) {\n          \n          \n            \n                    return DEFAULT_NODE.hashTreeRoot();\n          \n          \n            \n                  } else {\n          \n          \n            \n                    throw new IllegalStateException(\"Offset can not be greater than ssz length\");\n          \n          \n            \n                  }", "url": "https://github.com/ConsenSys/teku/pull/3347#discussion_r538532599", "createdAt": "2020-12-08T15:58:04Z", "author": {"login": "cemozerr"}, "path": "ssz/src/main/java/tech/pegasys/teku/ssz/backing/tree/SszSuperNode.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.ssz.backing.tree;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static tech.pegasys.teku.ssz.backing.tree.GIndexUtil.gIdxCompare;\n+import static tech.pegasys.teku.ssz.backing.tree.GIndexUtil.gIdxGetChildIndex;\n+import static tech.pegasys.teku.ssz.backing.tree.GIndexUtil.gIdxGetRelativeGIndex;\n+import static tech.pegasys.teku.ssz.backing.tree.GIndexUtil.gIdxIsSelf;\n+\n+import com.google.common.base.Supplier;\n+import com.google.common.base.Suppliers;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.apache.tuweni.bytes.MutableBytes;\n+import org.apache.tuweni.crypto.Hash;\n+import org.jetbrains.annotations.NotNull;\n+import tech.pegasys.teku.ssz.backing.tree.GIndexUtil.NodeRelation;\n+import tech.pegasys.teku.ssz.backing.tree.SszNodeTemplate.Location;\n+\n+/**\n+ * Stores consecutive elements of the same fixed size type as a single packed bytes of their leaves\n+ * (this representation exactly matches SSZ representation of elements sequence).\n+ *\n+ * <p>This node represents a subtree of binary merkle tree for sequence (list or vector) of elements\n+ * with maximum length of <code>2 ^ depth</code>. If the sequence has less than maximum elements\n+ * then <code>ssz</code> bytes store only existing elements (what again matches SSZ representation\n+ * of a list)\n+ *\n+ * <p>To address individual nodes inside elements and resolve their internal generalized indexes the\n+ * node uses {@link SszNodeTemplate} which represents element type tree structure\n+ *\n+ * <p>This node favors memory efficiency over update performance and thus is the best choice for\n+ * rarely updated and space consuming structures (e.g. Eth2 <code>BeaconState.validators</code>\n+ * list)\n+ */\n+public class SszSuperNode implements TreeNode, LeafDataNode {\n+  private static final TreeNode DEFAULT_NODE = LeafNode.EMPTY_LEAF;\n+\n+  private final int depth;\n+  private final SszNodeTemplate elementTemplate;\n+  private final Bytes ssz;\n+  private final Supplier<Bytes32> hashTreeRoot = Suppliers.memoize(this::calcHashTreeRoot);\n+\n+  public SszSuperNode(int depth, SszNodeTemplate elementTemplate, Bytes ssz) {\n+    this.depth = depth;\n+    this.elementTemplate = elementTemplate;\n+    this.ssz = ssz;\n+    checkArgument(ssz.size() % elementTemplate.getSszLength() == 0);\n+    checkArgument(getElementsCount() <= getMaxElements());\n+  }\n+\n+  private int getMaxElements() {\n+    return 1 << depth;\n+  }\n+\n+  private int getElementsCount() {\n+    return ssz.size() / elementTemplate.getSszLength();\n+  }\n+\n+  @Override\n+  public Bytes32 hashTreeRoot() {\n+    return hashTreeRoot.get();\n+  }\n+\n+  private Bytes32 calcHashTreeRoot() {\n+    return hashTreeRoot(0, 0);\n+  }\n+\n+  private Bytes32 hashTreeRoot(int curDepth, int offset) {\n+    if (curDepth == depth) {\n+      if (offset < ssz.size()) {\n+        return elementTemplate.calculateHashTreeRoot(ssz, offset);\n+      } else {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3d07885c2ff6ee726d799eb39df027de952319e"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODY0ODg1Ng==", "bodyText": "I've added the this check d6eec77 (as assert since this parameter is calculated internally and we probably wouldn't like to spend CPU in production for this)\noffset could be larger than ssz.size() cause you may have have ssz say just for 2 elements but the node capacity is say 256", "url": "https://github.com/ConsenSys/teku/pull/3347#discussion_r538648856", "createdAt": "2020-12-08T17:41:40Z", "author": {"login": "Nashatyrev"}, "path": "ssz/src/main/java/tech/pegasys/teku/ssz/backing/tree/SszSuperNode.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.ssz.backing.tree;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static tech.pegasys.teku.ssz.backing.tree.GIndexUtil.gIdxCompare;\n+import static tech.pegasys.teku.ssz.backing.tree.GIndexUtil.gIdxGetChildIndex;\n+import static tech.pegasys.teku.ssz.backing.tree.GIndexUtil.gIdxGetRelativeGIndex;\n+import static tech.pegasys.teku.ssz.backing.tree.GIndexUtil.gIdxIsSelf;\n+\n+import com.google.common.base.Supplier;\n+import com.google.common.base.Suppliers;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.apache.tuweni.bytes.MutableBytes;\n+import org.apache.tuweni.crypto.Hash;\n+import org.jetbrains.annotations.NotNull;\n+import tech.pegasys.teku.ssz.backing.tree.GIndexUtil.NodeRelation;\n+import tech.pegasys.teku.ssz.backing.tree.SszNodeTemplate.Location;\n+\n+/**\n+ * Stores consecutive elements of the same fixed size type as a single packed bytes of their leaves\n+ * (this representation exactly matches SSZ representation of elements sequence).\n+ *\n+ * <p>This node represents a subtree of binary merkle tree for sequence (list or vector) of elements\n+ * with maximum length of <code>2 ^ depth</code>. If the sequence has less than maximum elements\n+ * then <code>ssz</code> bytes store only existing elements (what again matches SSZ representation\n+ * of a list)\n+ *\n+ * <p>To address individual nodes inside elements and resolve their internal generalized indexes the\n+ * node uses {@link SszNodeTemplate} which represents element type tree structure\n+ *\n+ * <p>This node favors memory efficiency over update performance and thus is the best choice for\n+ * rarely updated and space consuming structures (e.g. Eth2 <code>BeaconState.validators</code>\n+ * list)\n+ */\n+public class SszSuperNode implements TreeNode, LeafDataNode {\n+  private static final TreeNode DEFAULT_NODE = LeafNode.EMPTY_LEAF;\n+\n+  private final int depth;\n+  private final SszNodeTemplate elementTemplate;\n+  private final Bytes ssz;\n+  private final Supplier<Bytes32> hashTreeRoot = Suppliers.memoize(this::calcHashTreeRoot);\n+\n+  public SszSuperNode(int depth, SszNodeTemplate elementTemplate, Bytes ssz) {\n+    this.depth = depth;\n+    this.elementTemplate = elementTemplate;\n+    this.ssz = ssz;\n+    checkArgument(ssz.size() % elementTemplate.getSszLength() == 0);\n+    checkArgument(getElementsCount() <= getMaxElements());\n+  }\n+\n+  private int getMaxElements() {\n+    return 1 << depth;\n+  }\n+\n+  private int getElementsCount() {\n+    return ssz.size() / elementTemplate.getSszLength();\n+  }\n+\n+  @Override\n+  public Bytes32 hashTreeRoot() {\n+    return hashTreeRoot.get();\n+  }\n+\n+  private Bytes32 calcHashTreeRoot() {\n+    return hashTreeRoot(0, 0);\n+  }\n+\n+  private Bytes32 hashTreeRoot(int curDepth, int offset) {\n+    if (curDepth == depth) {\n+      if (offset < ssz.size()) {\n+        return elementTemplate.calculateHashTreeRoot(ssz, offset);\n+      } else {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODUzMjU5OQ=="}, "originalCommit": {"oid": "b3d07885c2ff6ee726d799eb39df027de952319e"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4MTI2NjgyOnYy", "diffSide": "RIGHT", "path": "ssz/src/main/java/tech/pegasys/teku/ssz/backing/tree/SszSuperNode.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxNjo0NDo0NVrOIBoqUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQxODowMDo1M1rOIBtxrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODU4NTY4Mg==", "bodyText": "Would it make more sense to do the ssz update on the SszSuperNode object rather than the template? To me the template seems to almost exclusively deal with the structure/location of the trees", "url": "https://github.com/ConsenSys/teku/pull/3347#discussion_r538585682", "createdAt": "2020-12-08T16:44:45Z", "author": {"login": "cemozerr"}, "path": "ssz/src/main/java/tech/pegasys/teku/ssz/backing/tree/SszSuperNode.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.ssz.backing.tree;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static tech.pegasys.teku.ssz.backing.tree.GIndexUtil.gIdxCompare;\n+import static tech.pegasys.teku.ssz.backing.tree.GIndexUtil.gIdxGetChildIndex;\n+import static tech.pegasys.teku.ssz.backing.tree.GIndexUtil.gIdxGetRelativeGIndex;\n+import static tech.pegasys.teku.ssz.backing.tree.GIndexUtil.gIdxIsSelf;\n+\n+import com.google.common.base.Supplier;\n+import com.google.common.base.Suppliers;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.apache.tuweni.bytes.MutableBytes;\n+import org.apache.tuweni.crypto.Hash;\n+import org.jetbrains.annotations.NotNull;\n+import tech.pegasys.teku.ssz.backing.tree.GIndexUtil.NodeRelation;\n+import tech.pegasys.teku.ssz.backing.tree.SszNodeTemplate.Location;\n+\n+/**\n+ * Stores consecutive elements of the same fixed size type as a single packed bytes of their leaves\n+ * (this representation exactly matches SSZ representation of elements sequence).\n+ *\n+ * <p>This node represents a subtree of binary merkle tree for sequence (list or vector) of elements\n+ * with maximum length of <code>2 ^ depth</code>. If the sequence has less than maximum elements\n+ * then <code>ssz</code> bytes store only existing elements (what again matches SSZ representation\n+ * of a list)\n+ *\n+ * <p>To address individual nodes inside elements and resolve their internal generalized indexes the\n+ * node uses {@link SszNodeTemplate} which represents element type tree structure\n+ *\n+ * <p>This node favors memory efficiency over update performance and thus is the best choice for\n+ * rarely updated and space consuming structures (e.g. Eth2 <code>BeaconState.validators</code>\n+ * list)\n+ */\n+public class SszSuperNode implements TreeNode, LeafDataNode {\n+  private static final TreeNode DEFAULT_NODE = LeafNode.EMPTY_LEAF;\n+\n+  private final int depth;\n+  private final SszNodeTemplate elementTemplate;\n+  private final Bytes ssz;\n+  private final Supplier<Bytes32> hashTreeRoot = Suppliers.memoize(this::calcHashTreeRoot);\n+\n+  public SszSuperNode(int depth, SszNodeTemplate elementTemplate, Bytes ssz) {\n+    this.depth = depth;\n+    this.elementTemplate = elementTemplate;\n+    this.ssz = ssz;\n+    checkArgument(ssz.size() % elementTemplate.getSszLength() == 0);\n+    checkArgument(getElementsCount() <= getMaxElements());\n+  }\n+\n+  private int getMaxElements() {\n+    return 1 << depth;\n+  }\n+\n+  private int getElementsCount() {\n+    return ssz.size() / elementTemplate.getSszLength();\n+  }\n+\n+  @Override\n+  public Bytes32 hashTreeRoot() {\n+    return hashTreeRoot.get();\n+  }\n+\n+  private Bytes32 calcHashTreeRoot() {\n+    return hashTreeRoot(0, 0);\n+  }\n+\n+  private Bytes32 hashTreeRoot(int curDepth, int offset) {\n+    if (curDepth == depth) {\n+      if (offset < ssz.size()) {\n+        return elementTemplate.calculateHashTreeRoot(ssz, offset);\n+      } else {\n+        return DEFAULT_NODE.hashTreeRoot();\n+      }\n+    } else {\n+      return Hash.sha2_256(\n+          Bytes.wrap(\n+              hashTreeRoot(curDepth + 1, offset),\n+              hashTreeRoot(\n+                  curDepth + 1,\n+                  offset + elementTemplate.getSszLength() * (1 << ((depth - curDepth) - 1)))));\n+    }\n+  }\n+\n+  @NotNull\n+  @Override\n+  public TreeNode get(long generalizedIndex) {\n+    if (gIdxIsSelf(generalizedIndex)) {\n+      return this;\n+    }\n+    int childIndex = gIdxGetChildIndex(generalizedIndex, depth);\n+    int childOffset = childIndex * elementTemplate.getSszLength();\n+    checkArgument(childOffset < ssz.size(), \"Invalid index\");\n+    long relativeGIndex = gIdxGetRelativeGIndex(generalizedIndex, depth);\n+    Location nodeLoc = elementTemplate.getNodeSszLocation(relativeGIndex);\n+    if (nodeLoc.isLeaf()) {\n+      return LeafNode.create(ssz.slice(childOffset + nodeLoc.getOffset(), nodeLoc.getLength()));\n+    } else if (gIdxIsSelf(relativeGIndex)) {\n+      return new SszSuperNode(\n+          0, elementTemplate, ssz.slice(childOffset, elementTemplate.getSszLength()));\n+    } else {\n+      SszNodeTemplate subTemplate = elementTemplate.getSubTemplate(relativeGIndex);\n+      return new SszSuperNode(\n+          0, subTemplate, ssz.slice(childOffset + nodeLoc.getOffset(), nodeLoc.getLength()));\n+    }\n+  }\n+\n+  @Override\n+  public boolean iterate(\n+      long thisGeneralizedIndex, long startGeneralizedIndex, TreeVisitor visitor) {\n+    if (gIdxCompare(thisGeneralizedIndex, startGeneralizedIndex) == NodeRelation.Left) {\n+      return true;\n+    } else {\n+      return visitor.visit(this, thisGeneralizedIndex);\n+    }\n+  }\n+\n+  @Override\n+  public TreeNode updated(TreeUpdates newNodes) {\n+    if (newNodes.isEmpty()) {\n+      return this;\n+    }\n+    long leftmostUpdateIndex = newNodes.getRelativeGIndex(newNodes.size() - 1);\n+    int leftmostChildIndex = gIdxGetChildIndex(leftmostUpdateIndex, depth);\n+    int newSszSize = (leftmostChildIndex + 1) * elementTemplate.getSszLength();\n+    Bytes updatedSizeSsz =\n+        newSszSize <= ssz.size()\n+            ? ssz\n+            : Bytes.wrap(ssz, Bytes.wrap(new byte[newSszSize - ssz.size()]));\n+    MutableBytes mutableCopy = updatedSizeSsz.mutableCopy();\n+    for (int i = 0; i < newNodes.size(); i++) {\n+      long updateGIndex = newNodes.getRelativeGIndex(i);\n+      int childIndex = gIdxGetChildIndex(updateGIndex, depth);\n+      long childGIndex = gIdxGetRelativeGIndex(updateGIndex, depth);\n+      int childOffset = childIndex * elementTemplate.getSszLength();\n+      MutableBytes childMutableSlice =\n+          mutableCopy.mutableSlice(childOffset, elementTemplate.getSszLength());\n+      elementTemplate.update(childGIndex, newNodes.getNode(i), childMutableSlice);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b3d07885c2ff6ee726d799eb39df027de952319e"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODY2OTQ4Nw==", "bodyText": "Template (elementTemplate) here deals with the structure of the list/vector element while the SszSuperNode deals with a 'set' of elements. I've tried to move as much as possible of functionality specific to just element type to this template. I.e. a Node holds actual data and its template knows how to interpret it.\nI was even going to make another template class which would represent a set of elements (like SszSuperNode does now) and leave the SszSuperNode with even more weak functionality. But just stuck with this\nThis is how an 'ideal' node implementation would look like for me: https://gist.github.com/Nashatyrev/8f416e4d3be10347a7c5f6c6520b1f53", "url": "https://github.com/ConsenSys/teku/pull/3347#discussion_r538669487", "createdAt": "2020-12-08T18:00:53Z", "author": {"login": "Nashatyrev"}, "path": "ssz/src/main/java/tech/pegasys/teku/ssz/backing/tree/SszSuperNode.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.ssz.backing.tree;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static tech.pegasys.teku.ssz.backing.tree.GIndexUtil.gIdxCompare;\n+import static tech.pegasys.teku.ssz.backing.tree.GIndexUtil.gIdxGetChildIndex;\n+import static tech.pegasys.teku.ssz.backing.tree.GIndexUtil.gIdxGetRelativeGIndex;\n+import static tech.pegasys.teku.ssz.backing.tree.GIndexUtil.gIdxIsSelf;\n+\n+import com.google.common.base.Supplier;\n+import com.google.common.base.Suppliers;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.apache.tuweni.bytes.MutableBytes;\n+import org.apache.tuweni.crypto.Hash;\n+import org.jetbrains.annotations.NotNull;\n+import tech.pegasys.teku.ssz.backing.tree.GIndexUtil.NodeRelation;\n+import tech.pegasys.teku.ssz.backing.tree.SszNodeTemplate.Location;\n+\n+/**\n+ * Stores consecutive elements of the same fixed size type as a single packed bytes of their leaves\n+ * (this representation exactly matches SSZ representation of elements sequence).\n+ *\n+ * <p>This node represents a subtree of binary merkle tree for sequence (list or vector) of elements\n+ * with maximum length of <code>2 ^ depth</code>. If the sequence has less than maximum elements\n+ * then <code>ssz</code> bytes store only existing elements (what again matches SSZ representation\n+ * of a list)\n+ *\n+ * <p>To address individual nodes inside elements and resolve their internal generalized indexes the\n+ * node uses {@link SszNodeTemplate} which represents element type tree structure\n+ *\n+ * <p>This node favors memory efficiency over update performance and thus is the best choice for\n+ * rarely updated and space consuming structures (e.g. Eth2 <code>BeaconState.validators</code>\n+ * list)\n+ */\n+public class SszSuperNode implements TreeNode, LeafDataNode {\n+  private static final TreeNode DEFAULT_NODE = LeafNode.EMPTY_LEAF;\n+\n+  private final int depth;\n+  private final SszNodeTemplate elementTemplate;\n+  private final Bytes ssz;\n+  private final Supplier<Bytes32> hashTreeRoot = Suppliers.memoize(this::calcHashTreeRoot);\n+\n+  public SszSuperNode(int depth, SszNodeTemplate elementTemplate, Bytes ssz) {\n+    this.depth = depth;\n+    this.elementTemplate = elementTemplate;\n+    this.ssz = ssz;\n+    checkArgument(ssz.size() % elementTemplate.getSszLength() == 0);\n+    checkArgument(getElementsCount() <= getMaxElements());\n+  }\n+\n+  private int getMaxElements() {\n+    return 1 << depth;\n+  }\n+\n+  private int getElementsCount() {\n+    return ssz.size() / elementTemplate.getSszLength();\n+  }\n+\n+  @Override\n+  public Bytes32 hashTreeRoot() {\n+    return hashTreeRoot.get();\n+  }\n+\n+  private Bytes32 calcHashTreeRoot() {\n+    return hashTreeRoot(0, 0);\n+  }\n+\n+  private Bytes32 hashTreeRoot(int curDepth, int offset) {\n+    if (curDepth == depth) {\n+      if (offset < ssz.size()) {\n+        return elementTemplate.calculateHashTreeRoot(ssz, offset);\n+      } else {\n+        return DEFAULT_NODE.hashTreeRoot();\n+      }\n+    } else {\n+      return Hash.sha2_256(\n+          Bytes.wrap(\n+              hashTreeRoot(curDepth + 1, offset),\n+              hashTreeRoot(\n+                  curDepth + 1,\n+                  offset + elementTemplate.getSszLength() * (1 << ((depth - curDepth) - 1)))));\n+    }\n+  }\n+\n+  @NotNull\n+  @Override\n+  public TreeNode get(long generalizedIndex) {\n+    if (gIdxIsSelf(generalizedIndex)) {\n+      return this;\n+    }\n+    int childIndex = gIdxGetChildIndex(generalizedIndex, depth);\n+    int childOffset = childIndex * elementTemplate.getSszLength();\n+    checkArgument(childOffset < ssz.size(), \"Invalid index\");\n+    long relativeGIndex = gIdxGetRelativeGIndex(generalizedIndex, depth);\n+    Location nodeLoc = elementTemplate.getNodeSszLocation(relativeGIndex);\n+    if (nodeLoc.isLeaf()) {\n+      return LeafNode.create(ssz.slice(childOffset + nodeLoc.getOffset(), nodeLoc.getLength()));\n+    } else if (gIdxIsSelf(relativeGIndex)) {\n+      return new SszSuperNode(\n+          0, elementTemplate, ssz.slice(childOffset, elementTemplate.getSszLength()));\n+    } else {\n+      SszNodeTemplate subTemplate = elementTemplate.getSubTemplate(relativeGIndex);\n+      return new SszSuperNode(\n+          0, subTemplate, ssz.slice(childOffset + nodeLoc.getOffset(), nodeLoc.getLength()));\n+    }\n+  }\n+\n+  @Override\n+  public boolean iterate(\n+      long thisGeneralizedIndex, long startGeneralizedIndex, TreeVisitor visitor) {\n+    if (gIdxCompare(thisGeneralizedIndex, startGeneralizedIndex) == NodeRelation.Left) {\n+      return true;\n+    } else {\n+      return visitor.visit(this, thisGeneralizedIndex);\n+    }\n+  }\n+\n+  @Override\n+  public TreeNode updated(TreeUpdates newNodes) {\n+    if (newNodes.isEmpty()) {\n+      return this;\n+    }\n+    long leftmostUpdateIndex = newNodes.getRelativeGIndex(newNodes.size() - 1);\n+    int leftmostChildIndex = gIdxGetChildIndex(leftmostUpdateIndex, depth);\n+    int newSszSize = (leftmostChildIndex + 1) * elementTemplate.getSszLength();\n+    Bytes updatedSizeSsz =\n+        newSszSize <= ssz.size()\n+            ? ssz\n+            : Bytes.wrap(ssz, Bytes.wrap(new byte[newSszSize - ssz.size()]));\n+    MutableBytes mutableCopy = updatedSizeSsz.mutableCopy();\n+    for (int i = 0; i < newNodes.size(); i++) {\n+      long updateGIndex = newNodes.getRelativeGIndex(i);\n+      int childIndex = gIdxGetChildIndex(updateGIndex, depth);\n+      long childGIndex = gIdxGetRelativeGIndex(updateGIndex, depth);\n+      int childOffset = childIndex * elementTemplate.getSszLength();\n+      MutableBytes childMutableSlice =\n+          mutableCopy.mutableSlice(childOffset, elementTemplate.getSszLength());\n+      elementTemplate.update(childGIndex, newNodes.getNode(i), childMutableSlice);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODU4NTY4Mg=="}, "originalCommit": {"oid": "b3d07885c2ff6ee726d799eb39df027de952319e"}, "originalPosition": 153}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2907, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}