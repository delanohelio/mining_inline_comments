{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAyODE2NDYw", "number": 1577, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMjoxMTo1MlrODx12vw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMzozMDoxMVrODx29qQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNTg5MTgzOnYy", "diffSide": "RIGHT", "path": "ethereum/core/src/main/java/tech/pegasys/artemis/core/StateTransition.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMjoxMTo1MlrOGFi0gA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMjoxMTo1MlrOGFi0gA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ2NjU2MA==", "bodyText": "nit: checkArgument can actually do the format for you:\ncheckArgument(\n    preState.getSlot().compareTo(slot) <= 0,\n    \"process_slots: State slot %s higher than given slot %s\", preState.getSlot(), slot);", "url": "https://github.com/ConsenSys/teku/pull/1577#discussion_r408466560", "createdAt": "2020-04-14T22:11:52Z", "author": {"login": "ajsutton"}, "path": "ethereum/core/src/main/java/tech/pegasys/artemis/core/StateTransition.java", "diffHunk": "@@ -208,7 +208,8 @@ public BeaconState process_slots(BeaconState preState, UnsignedLong slot)\n     try {\n       checkArgument(\n           preState.getSlot().compareTo(slot) <= 0,\n-          \"process_slots: State slot higher than given slot\");\n+          String.format(\n+              \"process_slots: State slot %s higher than given slot %s\", preState.getSlot(), slot));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e40f58a1d95340bb76fc249260f11c1de9c5ee9c"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNTkyMDA0OnYy", "diffSide": "RIGHT", "path": "ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/blocks/BeaconBlockAndState.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMjoyMjoyN1rOGFjFCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMjoyMjoyN1rOGFjFCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3MDc5NQ==", "bodyText": "Nice to see these block and state data structures getting sorted out.", "url": "https://github.com/ConsenSys/teku/pull/1577#discussion_r408470795", "createdAt": "2020-04-14T22:22:27Z", "author": {"login": "ajsutton"}, "path": "ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/blocks/BeaconBlockAndState.java", "diffHunk": "@@ -13,24 +13,27 @@\n \n package tech.pegasys.artemis.datastructures.blocks;\n \n+import static com.google.common.base.Preconditions.checkArgument;\n+\n import com.google.common.base.MoreObjects;\n+import com.google.common.primitives.UnsignedLong;\n import java.util.Objects;\n import org.apache.tuweni.bytes.Bytes32;\n import tech.pegasys.artemis.datastructures.state.BeaconState;\n \n+/** Helper datastructure that holds an unsigned block with its corresponding state */\n public class BeaconBlockAndState {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e40f58a1d95340bb76fc249260f11c1de9c5ee9c"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNTkyNjUyOnYy", "diffSide": "RIGHT", "path": "ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/validator/LocalMessageSignerService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMjoyNDo1NFrOGFjI0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNDoyMDowNlrOGF8BYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3MTc2Mg==", "bodyText": "Not quite sure how we wound up with MessageSignerService in datastructures as it's actually a service.  Makes sense to have the LoalMessageSignerService with it, but we may need to think about moving them both somewhere more sensible (core? maybe even a dedicated module?).  Outside of the scope of this PR though I think.", "url": "https://github.com/ConsenSys/teku/pull/1577#discussion_r408471762", "createdAt": "2020-04-14T22:24:54Z", "author": {"login": "ajsutton"}, "path": "ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/validator/LocalMessageSignerService.java", "diffHunk": "@@ -11,13 +11,12 @@\n  * specific language governing permissions and limitations under the License.\n  */\n \n-package tech.pegasys.artemis.validator.client.signer;\n+package tech.pegasys.artemis.datastructures.validator;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e40f58a1d95340bb76fc249260f11c1de9c5ee9c"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODg3OTQ1Ng==", "bodyText": "Went ahead and move them into core.signatures", "url": "https://github.com/ConsenSys/teku/pull/1577#discussion_r408879456", "createdAt": "2020-04-15T14:20:06Z", "author": {"login": "mbaxter"}, "path": "ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/validator/LocalMessageSignerService.java", "diffHunk": "@@ -11,13 +11,12 @@\n  * specific language governing permissions and limitations under the License.\n  */\n \n-package tech.pegasys.artemis.validator.client.signer;\n+package tech.pegasys.artemis.datastructures.validator;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3MTc2Mg=="}, "originalCommit": {"oid": "e40f58a1d95340bb76fc249260f11c1de9c5ee9c"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNTk1Njc3OnYy", "diffSide": "RIGHT", "path": "storage/src/main/java/tech/pegasys/artemis/storage/server/rocksdb/RocksDbDatabase.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMjozNzozMlrOGFjbNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNDoyMjo0OVrOGF8Jww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3NjQ2OQ==", "bodyText": "Greater than seems wrong here.  We should be removing hot blocks that are less than the finalised slot. I think we are doing that given that we're getting the headMap in the updater so just the name that's wrong.", "url": "https://github.com/ConsenSys/teku/pull/1577#discussion_r408476469", "createdAt": "2020-04-14T22:37:32Z", "author": {"login": "ajsutton"}, "path": "storage/src/main/java/tech/pegasys/artemis/storage/server/rocksdb/RocksDbDatabase.java", "diffHunk": "@@ -259,52 +241,33 @@ private void addHotBlock(\n       return Collections.emptySet();\n     }\n     final UnsignedLong finalizedSlot = newlyFinalizedBlock.get().getSlot();\n-    final ConcurrentNavigableMap<UnsignedLong, Set<Bytes32>> toRemove =\n-        hotRootsBySlotCache.headMap(finalizedSlot);\n-    LOG.trace(\"Pruning slots {} from non-finalized pool\", toRemove::keySet);\n-    final Set<Bytes32> prunedRoots =\n-        toRemove.values().stream().flatMap(Set::stream).collect(Collectors.toSet());\n-    for (Set<Bytes32> hotRoots : toRemove.values()) {\n-      for (Bytes32 root : hotRoots) {\n-        transaction.delete(V2Schema.HOT_STATES_BY_ROOT, root);\n-        transaction.delete(V2Schema.HOT_BLOCKS_BY_ROOT, root);\n-      }\n-    }\n-    hotRootsBySlotCache.keySet().removeAll(toRemove.keySet());\n-    return prunedRoots;\n+    return updater.pruneHotBlocksAtSlotsGreaterThan(finalizedSlot);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e40f58a1d95340bb76fc249260f11c1de9c5ee9c"}, "originalPosition": 296}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODg4MTYwMw==", "bodyText": "whoops - fixed", "url": "https://github.com/ConsenSys/teku/pull/1577#discussion_r408881603", "createdAt": "2020-04-15T14:22:49Z", "author": {"login": "mbaxter"}, "path": "storage/src/main/java/tech/pegasys/artemis/storage/server/rocksdb/RocksDbDatabase.java", "diffHunk": "@@ -259,52 +241,33 @@ private void addHotBlock(\n       return Collections.emptySet();\n     }\n     final UnsignedLong finalizedSlot = newlyFinalizedBlock.get().getSlot();\n-    final ConcurrentNavigableMap<UnsignedLong, Set<Bytes32>> toRemove =\n-        hotRootsBySlotCache.headMap(finalizedSlot);\n-    LOG.trace(\"Pruning slots {} from non-finalized pool\", toRemove::keySet);\n-    final Set<Bytes32> prunedRoots =\n-        toRemove.values().stream().flatMap(Set::stream).collect(Collectors.toSet());\n-    for (Set<Bytes32> hotRoots : toRemove.values()) {\n-      for (Bytes32 root : hotRoots) {\n-        transaction.delete(V2Schema.HOT_STATES_BY_ROOT, root);\n-        transaction.delete(V2Schema.HOT_BLOCKS_BY_ROOT, root);\n-      }\n-    }\n-    hotRootsBySlotCache.keySet().removeAll(toRemove.keySet());\n-    return prunedRoots;\n+    return updater.pruneHotBlocksAtSlotsGreaterThan(finalizedSlot);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3NjQ2OQ=="}, "originalCommit": {"oid": "e40f58a1d95340bb76fc249260f11c1de9c5ee9c"}, "originalPosition": 296}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNTk2NjI4OnYy", "diffSide": "RIGHT", "path": "storage/src/main/java/tech/pegasys/artemis/storage/server/rocksdb/RocksDbDatabase.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMjo0MTo0MVrOGFjhRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNDoyNDoxMFrOGF8N-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3ODAyMg==", "bodyText": "It shouldn't ever matter, but should we set this to false up at line 269 when we actually find a finalised state.  That way if for some reason we miss one we're record the latest finalised state we do have rather than not updating it at all.", "url": "https://github.com/ConsenSys/teku/pull/1577#discussion_r408478022", "createdAt": "2020-04-14T22:41:41Z", "author": {"login": "ajsutton"}, "path": "storage/src/main/java/tech/pegasys/artemis/storage/server/rocksdb/RocksDbDatabase.java", "diffHunk": "@@ -313,6 +276,7 @@ private void recordFinalizedBlocks(\n       }\n \n       // Update for next round of iteration\n+      isLatestFinalizedBlock = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e40f58a1d95340bb76fc249260f11c1de9c5ee9c"}, "originalPosition": 345}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODg4MjY4Mw==", "bodyText": "good call", "url": "https://github.com/ConsenSys/teku/pull/1577#discussion_r408882683", "createdAt": "2020-04-15T14:24:10Z", "author": {"login": "mbaxter"}, "path": "storage/src/main/java/tech/pegasys/artemis/storage/server/rocksdb/RocksDbDatabase.java", "diffHunk": "@@ -313,6 +276,7 @@ private void recordFinalizedBlocks(\n       }\n \n       // Update for next round of iteration\n+      isLatestFinalizedBlock = false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3ODAyMg=="}, "originalCommit": {"oid": "e40f58a1d95340bb76fc249260f11c1de9c5ee9c"}, "originalPosition": 345}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNTk3NzAwOnYy", "diffSide": "RIGHT", "path": "storage/src/main/java/tech/pegasys/artemis/storage/server/rocksdb/dataaccess/V3RocksDbDao.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMjo0NjoyMFrOGFjnrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNDozMTo0OVrOGF8kuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3OTY2MQ==", "bodyText": "Non-canonical forks or forks that have a different finalised state (ie invalid/incompatible)?", "url": "https://github.com/ConsenSys/teku/pull/1577#discussion_r408479661", "createdAt": "2020-04-14T22:46:20Z", "author": {"login": "ajsutton"}, "path": "storage/src/main/java/tech/pegasys/artemis/storage/server/rocksdb/dataaccess/V3RocksDbDao.java", "diffHunk": "@@ -0,0 +1,387 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.storage.server.rocksdb.dataaccess;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.artemis.core.StateTransition;\n+import tech.pegasys.artemis.core.StateTransitionException;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.state.Checkpoint;\n+import tech.pegasys.artemis.storage.server.DatabaseStorageException;\n+import tech.pegasys.artemis.storage.server.rocksdb.core.ColumnEntry;\n+import tech.pegasys.artemis.storage.server.rocksdb.core.RocksDbInstance;\n+import tech.pegasys.artemis.storage.server.rocksdb.core.RocksDbInstance.Transaction;\n+import tech.pegasys.artemis.storage.server.rocksdb.schema.V3Schema;\n+\n+public class V3RocksDbDao implements RocksDbDAO {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  // Persistent data\n+  private final RocksDbInstance db;\n+  // In-memory data\n+  private final NavigableMap<UnsignedLong, Set<Bytes32>> hotRootsBySlotCache =\n+      new ConcurrentSkipListMap<>();\n+  private final Map<Bytes32, BeaconState> hotStates = new ConcurrentHashMap<>();\n+\n+  public V3RocksDbDao(final RocksDbInstance db) {\n+    this.db = db;\n+    initialize();\n+  }\n+\n+  @Override\n+  public Optional<UnsignedLong> getGenesisTime() {\n+    return db.get(V3Schema.GENESIS_TIME);\n+  }\n+\n+  @Override\n+  public Optional<Checkpoint> getJustifiedCheckpoint() {\n+    return db.get(V3Schema.JUSTIFIED_CHECKPOINT);\n+  }\n+\n+  @Override\n+  public Optional<Checkpoint> getBestJustifiedCheckpoint() {\n+    return db.get(V3Schema.BEST_JUSTIFIED_CHECKPOINT);\n+  }\n+\n+  @Override\n+  public Optional<Checkpoint> getFinalizedCheckpoint() {\n+    return db.get(V3Schema.FINALIZED_CHECKPOINT);\n+  }\n+\n+  @Override\n+  public Optional<UnsignedLong> getHighestFinalizedSlot() {\n+    return db.getLastEntry(V3Schema.FINALIZED_ROOTS_BY_SLOT).map(ColumnEntry::getKey);\n+  }\n+\n+  @Override\n+  public Optional<Bytes32> getFinalizedRootAtSlot(final UnsignedLong slot) {\n+    return db.get(V3Schema.FINALIZED_ROOTS_BY_SLOT, slot);\n+  }\n+\n+  @Override\n+  public Optional<Bytes32> getLatestFinalizedRootAtSlot(final UnsignedLong slot) {\n+    return db.getFloorEntry(V3Schema.FINALIZED_ROOTS_BY_SLOT, slot).map(ColumnEntry::getValue);\n+  }\n+\n+  @Override\n+  public Optional<SignedBeaconBlock> getHotBlock(final Bytes32 root) {\n+    return db.get(V3Schema.HOT_BLOCKS_BY_ROOT, root);\n+  }\n+\n+  @Override\n+  public Optional<SignedBeaconBlock> getFinalizedBlock(final Bytes32 root) {\n+    return db.get(V3Schema.FINALIZED_BLOCKS_BY_ROOT, root);\n+  }\n+\n+  @Override\n+  public Optional<BeaconState> getHotState(final Bytes32 root) {\n+    return Optional.ofNullable(hotStates.get(root));\n+  }\n+\n+  @Override\n+  public Optional<BeaconState> getFinalizedState(final Bytes32 root) {\n+    return db.get(V3Schema.FINALIZED_STATES_BY_ROOT, root);\n+  }\n+\n+  @Override\n+  public Map<Bytes32, SignedBeaconBlock> getHotBlocks() {\n+    return db.getAll(V3Schema.HOT_BLOCKS_BY_ROOT);\n+  }\n+\n+  @Override\n+  public Map<Bytes32, BeaconState> getHotStates() {\n+    return new HashMap<>(hotStates);\n+  }\n+\n+  @Override\n+  public Map<Checkpoint, BeaconState> getCheckpointStates() {\n+    return db.getAll(V3Schema.CHECKPOINT_STATES);\n+  }\n+\n+  @Override\n+  public Stream<ColumnEntry<Checkpoint, BeaconState>> streamCheckpointStates() {\n+    return db.stream(V3Schema.CHECKPOINT_STATES);\n+  }\n+\n+  private Optional<BeaconState> getLatestFinalizedState() {\n+    return db.get(V3Schema.LATEST_FINALIZED_STATE);\n+  }\n+\n+  public Optional<Bytes32> getLatestFinalizedRoot() {\n+    return db.getLastEntry(V3Schema.FINALIZED_ROOTS_BY_SLOT).map(ColumnEntry::getValue);\n+  }\n+\n+  @Override\n+  public Updater updater() {\n+    return new V3Updater(db, hotRootsBySlotCache, hotStates);\n+  }\n+\n+  @Override\n+  public void close() throws Exception {\n+    hotRootsBySlotCache.clear();\n+    db.close();\n+  }\n+\n+  private void initialize() {\n+    final Optional<BeaconState> finalizedState = getLatestFinalizedState();\n+    final Optional<Bytes32> finalizedRoot = getLatestFinalizedRoot();\n+    final Map<Bytes32, SignedBeaconBlock> hotBlocksByRoot = getHotBlocks();\n+\n+    if (finalizedRoot.isEmpty() && finalizedState.isEmpty() && hotBlocksByRoot.isEmpty()) {\n+      // Database is empty, nothing to initialize\n+      LOG.trace(\"Database appears to be empty.  Skip initialization of hot states.\");\n+      return;\n+    } else if (finalizedRoot.isEmpty() || finalizedState.isEmpty()) {\n+      throw new DatabaseStorageException(\"Missing latest finalized block information\");\n+    }\n+\n+    initializeHotStates(finalizedRoot.get(), finalizedState.get(), hotBlocksByRoot);\n+  }\n+\n+  private void initializeHotStates(\n+      final Bytes32 finalizedRoot,\n+      final BeaconState finalizedState,\n+      final Map<Bytes32, SignedBeaconBlock> hotBlocksByRoot) {\n+    // Initialize hot states with latest finalized state\n+    hotStates.put(finalizedRoot, finalizedState);\n+\n+    // Index blocks by parent root\n+    final Map<Bytes32, List<SignedBeaconBlock>> blocksByParent = new HashMap<>();\n+    for (Entry<Bytes32, SignedBeaconBlock> hotBlockEntry : hotBlocksByRoot.entrySet()) {\n+      final SignedBeaconBlock currentBlock = hotBlockEntry.getValue();\n+      final List<SignedBeaconBlock> blockList =\n+          blocksByParent.computeIfAbsent(currentBlock.getParent_root(), (key) -> new ArrayList<>());\n+      blockList.add(currentBlock);\n+    }\n+\n+    // Generate remaining hot states\n+    final Deque<Bytes32> parentRoots = new ArrayDeque<>();\n+    parentRoots.push(finalizedRoot);\n+    while (!parentRoots.isEmpty()) {\n+      final Bytes32 parentRoot = parentRoots.pop();\n+      final BeaconState parentState = hotStates.get(parentRoot);\n+      final List<SignedBeaconBlock> blocks =\n+          blocksByParent.computeIfAbsent(parentRoot, (key) -> Collections.emptyList());\n+      for (SignedBeaconBlock block : blocks) {\n+        final Bytes32 blockRoot = block.getMessage().hash_tree_root();\n+        processBlock(parentState, block)\n+            .ifPresent(\n+                state -> {\n+                  hotStates.put(blockRoot, state);\n+                  parentRoots.push(blockRoot);\n+                });\n+      }\n+    }\n+\n+    if (hotStates.size() != hotBlocksByRoot.size()) {\n+      LOG.trace(\n+          \"Only {} hot states produced for {} hot blocks.  Some hot blocks must belong to non-canonical forks.\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e40f58a1d95340bb76fc249260f11c1de9c5ee9c"}, "originalPosition": 209}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODg4ODUwNw==", "bodyText": "Hmm - I guess I've been using canonical to mean descending from the latest finalized block.    Will try to clarify.", "url": "https://github.com/ConsenSys/teku/pull/1577#discussion_r408888507", "createdAt": "2020-04-15T14:31:49Z", "author": {"login": "mbaxter"}, "path": "storage/src/main/java/tech/pegasys/artemis/storage/server/rocksdb/dataaccess/V3RocksDbDao.java", "diffHunk": "@@ -0,0 +1,387 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.storage.server.rocksdb.dataaccess;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.artemis.core.StateTransition;\n+import tech.pegasys.artemis.core.StateTransitionException;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.state.Checkpoint;\n+import tech.pegasys.artemis.storage.server.DatabaseStorageException;\n+import tech.pegasys.artemis.storage.server.rocksdb.core.ColumnEntry;\n+import tech.pegasys.artemis.storage.server.rocksdb.core.RocksDbInstance;\n+import tech.pegasys.artemis.storage.server.rocksdb.core.RocksDbInstance.Transaction;\n+import tech.pegasys.artemis.storage.server.rocksdb.schema.V3Schema;\n+\n+public class V3RocksDbDao implements RocksDbDAO {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  // Persistent data\n+  private final RocksDbInstance db;\n+  // In-memory data\n+  private final NavigableMap<UnsignedLong, Set<Bytes32>> hotRootsBySlotCache =\n+      new ConcurrentSkipListMap<>();\n+  private final Map<Bytes32, BeaconState> hotStates = new ConcurrentHashMap<>();\n+\n+  public V3RocksDbDao(final RocksDbInstance db) {\n+    this.db = db;\n+    initialize();\n+  }\n+\n+  @Override\n+  public Optional<UnsignedLong> getGenesisTime() {\n+    return db.get(V3Schema.GENESIS_TIME);\n+  }\n+\n+  @Override\n+  public Optional<Checkpoint> getJustifiedCheckpoint() {\n+    return db.get(V3Schema.JUSTIFIED_CHECKPOINT);\n+  }\n+\n+  @Override\n+  public Optional<Checkpoint> getBestJustifiedCheckpoint() {\n+    return db.get(V3Schema.BEST_JUSTIFIED_CHECKPOINT);\n+  }\n+\n+  @Override\n+  public Optional<Checkpoint> getFinalizedCheckpoint() {\n+    return db.get(V3Schema.FINALIZED_CHECKPOINT);\n+  }\n+\n+  @Override\n+  public Optional<UnsignedLong> getHighestFinalizedSlot() {\n+    return db.getLastEntry(V3Schema.FINALIZED_ROOTS_BY_SLOT).map(ColumnEntry::getKey);\n+  }\n+\n+  @Override\n+  public Optional<Bytes32> getFinalizedRootAtSlot(final UnsignedLong slot) {\n+    return db.get(V3Schema.FINALIZED_ROOTS_BY_SLOT, slot);\n+  }\n+\n+  @Override\n+  public Optional<Bytes32> getLatestFinalizedRootAtSlot(final UnsignedLong slot) {\n+    return db.getFloorEntry(V3Schema.FINALIZED_ROOTS_BY_SLOT, slot).map(ColumnEntry::getValue);\n+  }\n+\n+  @Override\n+  public Optional<SignedBeaconBlock> getHotBlock(final Bytes32 root) {\n+    return db.get(V3Schema.HOT_BLOCKS_BY_ROOT, root);\n+  }\n+\n+  @Override\n+  public Optional<SignedBeaconBlock> getFinalizedBlock(final Bytes32 root) {\n+    return db.get(V3Schema.FINALIZED_BLOCKS_BY_ROOT, root);\n+  }\n+\n+  @Override\n+  public Optional<BeaconState> getHotState(final Bytes32 root) {\n+    return Optional.ofNullable(hotStates.get(root));\n+  }\n+\n+  @Override\n+  public Optional<BeaconState> getFinalizedState(final Bytes32 root) {\n+    return db.get(V3Schema.FINALIZED_STATES_BY_ROOT, root);\n+  }\n+\n+  @Override\n+  public Map<Bytes32, SignedBeaconBlock> getHotBlocks() {\n+    return db.getAll(V3Schema.HOT_BLOCKS_BY_ROOT);\n+  }\n+\n+  @Override\n+  public Map<Bytes32, BeaconState> getHotStates() {\n+    return new HashMap<>(hotStates);\n+  }\n+\n+  @Override\n+  public Map<Checkpoint, BeaconState> getCheckpointStates() {\n+    return db.getAll(V3Schema.CHECKPOINT_STATES);\n+  }\n+\n+  @Override\n+  public Stream<ColumnEntry<Checkpoint, BeaconState>> streamCheckpointStates() {\n+    return db.stream(V3Schema.CHECKPOINT_STATES);\n+  }\n+\n+  private Optional<BeaconState> getLatestFinalizedState() {\n+    return db.get(V3Schema.LATEST_FINALIZED_STATE);\n+  }\n+\n+  public Optional<Bytes32> getLatestFinalizedRoot() {\n+    return db.getLastEntry(V3Schema.FINALIZED_ROOTS_BY_SLOT).map(ColumnEntry::getValue);\n+  }\n+\n+  @Override\n+  public Updater updater() {\n+    return new V3Updater(db, hotRootsBySlotCache, hotStates);\n+  }\n+\n+  @Override\n+  public void close() throws Exception {\n+    hotRootsBySlotCache.clear();\n+    db.close();\n+  }\n+\n+  private void initialize() {\n+    final Optional<BeaconState> finalizedState = getLatestFinalizedState();\n+    final Optional<Bytes32> finalizedRoot = getLatestFinalizedRoot();\n+    final Map<Bytes32, SignedBeaconBlock> hotBlocksByRoot = getHotBlocks();\n+\n+    if (finalizedRoot.isEmpty() && finalizedState.isEmpty() && hotBlocksByRoot.isEmpty()) {\n+      // Database is empty, nothing to initialize\n+      LOG.trace(\"Database appears to be empty.  Skip initialization of hot states.\");\n+      return;\n+    } else if (finalizedRoot.isEmpty() || finalizedState.isEmpty()) {\n+      throw new DatabaseStorageException(\"Missing latest finalized block information\");\n+    }\n+\n+    initializeHotStates(finalizedRoot.get(), finalizedState.get(), hotBlocksByRoot);\n+  }\n+\n+  private void initializeHotStates(\n+      final Bytes32 finalizedRoot,\n+      final BeaconState finalizedState,\n+      final Map<Bytes32, SignedBeaconBlock> hotBlocksByRoot) {\n+    // Initialize hot states with latest finalized state\n+    hotStates.put(finalizedRoot, finalizedState);\n+\n+    // Index blocks by parent root\n+    final Map<Bytes32, List<SignedBeaconBlock>> blocksByParent = new HashMap<>();\n+    for (Entry<Bytes32, SignedBeaconBlock> hotBlockEntry : hotBlocksByRoot.entrySet()) {\n+      final SignedBeaconBlock currentBlock = hotBlockEntry.getValue();\n+      final List<SignedBeaconBlock> blockList =\n+          blocksByParent.computeIfAbsent(currentBlock.getParent_root(), (key) -> new ArrayList<>());\n+      blockList.add(currentBlock);\n+    }\n+\n+    // Generate remaining hot states\n+    final Deque<Bytes32> parentRoots = new ArrayDeque<>();\n+    parentRoots.push(finalizedRoot);\n+    while (!parentRoots.isEmpty()) {\n+      final Bytes32 parentRoot = parentRoots.pop();\n+      final BeaconState parentState = hotStates.get(parentRoot);\n+      final List<SignedBeaconBlock> blocks =\n+          blocksByParent.computeIfAbsent(parentRoot, (key) -> Collections.emptyList());\n+      for (SignedBeaconBlock block : blocks) {\n+        final Bytes32 blockRoot = block.getMessage().hash_tree_root();\n+        processBlock(parentState, block)\n+            .ifPresent(\n+                state -> {\n+                  hotStates.put(blockRoot, state);\n+                  parentRoots.push(blockRoot);\n+                });\n+      }\n+    }\n+\n+    if (hotStates.size() != hotBlocksByRoot.size()) {\n+      LOG.trace(\n+          \"Only {} hot states produced for {} hot blocks.  Some hot blocks must belong to non-canonical forks.\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ3OTY2MQ=="}, "originalCommit": {"oid": "e40f58a1d95340bb76fc249260f11c1de9c5ee9c"}, "originalPosition": 209}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNTk3OTg3OnYy", "diffSide": "RIGHT", "path": "storage/src/main/java/tech/pegasys/artemis/storage/server/rocksdb/dataaccess/V3RocksDbDao.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMjo0NzozOVrOGFjpiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNToyMTowOFrOGF-76Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ4MDEzOQ==", "bodyText": "We should probably print a message via StatusLogger to indicate that we're reloading the hot states and then when we complete.  The process will take a little bit of time so we should let the user know what's going on.", "url": "https://github.com/ConsenSys/teku/pull/1577#discussion_r408480139", "createdAt": "2020-04-14T22:47:39Z", "author": {"login": "ajsutton"}, "path": "storage/src/main/java/tech/pegasys/artemis/storage/server/rocksdb/dataaccess/V3RocksDbDao.java", "diffHunk": "@@ -0,0 +1,387 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.storage.server.rocksdb.dataaccess;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.artemis.core.StateTransition;\n+import tech.pegasys.artemis.core.StateTransitionException;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.state.Checkpoint;\n+import tech.pegasys.artemis.storage.server.DatabaseStorageException;\n+import tech.pegasys.artemis.storage.server.rocksdb.core.ColumnEntry;\n+import tech.pegasys.artemis.storage.server.rocksdb.core.RocksDbInstance;\n+import tech.pegasys.artemis.storage.server.rocksdb.core.RocksDbInstance.Transaction;\n+import tech.pegasys.artemis.storage.server.rocksdb.schema.V3Schema;\n+\n+public class V3RocksDbDao implements RocksDbDAO {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  // Persistent data\n+  private final RocksDbInstance db;\n+  // In-memory data\n+  private final NavigableMap<UnsignedLong, Set<Bytes32>> hotRootsBySlotCache =\n+      new ConcurrentSkipListMap<>();\n+  private final Map<Bytes32, BeaconState> hotStates = new ConcurrentHashMap<>();\n+\n+  public V3RocksDbDao(final RocksDbInstance db) {\n+    this.db = db;\n+    initialize();\n+  }\n+\n+  @Override\n+  public Optional<UnsignedLong> getGenesisTime() {\n+    return db.get(V3Schema.GENESIS_TIME);\n+  }\n+\n+  @Override\n+  public Optional<Checkpoint> getJustifiedCheckpoint() {\n+    return db.get(V3Schema.JUSTIFIED_CHECKPOINT);\n+  }\n+\n+  @Override\n+  public Optional<Checkpoint> getBestJustifiedCheckpoint() {\n+    return db.get(V3Schema.BEST_JUSTIFIED_CHECKPOINT);\n+  }\n+\n+  @Override\n+  public Optional<Checkpoint> getFinalizedCheckpoint() {\n+    return db.get(V3Schema.FINALIZED_CHECKPOINT);\n+  }\n+\n+  @Override\n+  public Optional<UnsignedLong> getHighestFinalizedSlot() {\n+    return db.getLastEntry(V3Schema.FINALIZED_ROOTS_BY_SLOT).map(ColumnEntry::getKey);\n+  }\n+\n+  @Override\n+  public Optional<Bytes32> getFinalizedRootAtSlot(final UnsignedLong slot) {\n+    return db.get(V3Schema.FINALIZED_ROOTS_BY_SLOT, slot);\n+  }\n+\n+  @Override\n+  public Optional<Bytes32> getLatestFinalizedRootAtSlot(final UnsignedLong slot) {\n+    return db.getFloorEntry(V3Schema.FINALIZED_ROOTS_BY_SLOT, slot).map(ColumnEntry::getValue);\n+  }\n+\n+  @Override\n+  public Optional<SignedBeaconBlock> getHotBlock(final Bytes32 root) {\n+    return db.get(V3Schema.HOT_BLOCKS_BY_ROOT, root);\n+  }\n+\n+  @Override\n+  public Optional<SignedBeaconBlock> getFinalizedBlock(final Bytes32 root) {\n+    return db.get(V3Schema.FINALIZED_BLOCKS_BY_ROOT, root);\n+  }\n+\n+  @Override\n+  public Optional<BeaconState> getHotState(final Bytes32 root) {\n+    return Optional.ofNullable(hotStates.get(root));\n+  }\n+\n+  @Override\n+  public Optional<BeaconState> getFinalizedState(final Bytes32 root) {\n+    return db.get(V3Schema.FINALIZED_STATES_BY_ROOT, root);\n+  }\n+\n+  @Override\n+  public Map<Bytes32, SignedBeaconBlock> getHotBlocks() {\n+    return db.getAll(V3Schema.HOT_BLOCKS_BY_ROOT);\n+  }\n+\n+  @Override\n+  public Map<Bytes32, BeaconState> getHotStates() {\n+    return new HashMap<>(hotStates);\n+  }\n+\n+  @Override\n+  public Map<Checkpoint, BeaconState> getCheckpointStates() {\n+    return db.getAll(V3Schema.CHECKPOINT_STATES);\n+  }\n+\n+  @Override\n+  public Stream<ColumnEntry<Checkpoint, BeaconState>> streamCheckpointStates() {\n+    return db.stream(V3Schema.CHECKPOINT_STATES);\n+  }\n+\n+  private Optional<BeaconState> getLatestFinalizedState() {\n+    return db.get(V3Schema.LATEST_FINALIZED_STATE);\n+  }\n+\n+  public Optional<Bytes32> getLatestFinalizedRoot() {\n+    return db.getLastEntry(V3Schema.FINALIZED_ROOTS_BY_SLOT).map(ColumnEntry::getValue);\n+  }\n+\n+  @Override\n+  public Updater updater() {\n+    return new V3Updater(db, hotRootsBySlotCache, hotStates);\n+  }\n+\n+  @Override\n+  public void close() throws Exception {\n+    hotRootsBySlotCache.clear();\n+    db.close();\n+  }\n+\n+  private void initialize() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e40f58a1d95340bb76fc249260f11c1de9c5ee9c"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODkyNzIwOQ==", "bodyText": "This seemed kind of low-level / implementation-specific compared to the other StatusLogger messages.  So, I just added some Logger.info messages here, and then added some StatusLogger messages around chain data initialization as a whole (including hydrating the initial Store).", "url": "https://github.com/ConsenSys/teku/pull/1577#discussion_r408927209", "createdAt": "2020-04-15T15:21:08Z", "author": {"login": "mbaxter"}, "path": "storage/src/main/java/tech/pegasys/artemis/storage/server/rocksdb/dataaccess/V3RocksDbDao.java", "diffHunk": "@@ -0,0 +1,387 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.storage.server.rocksdb.dataaccess;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.artemis.core.StateTransition;\n+import tech.pegasys.artemis.core.StateTransitionException;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.state.Checkpoint;\n+import tech.pegasys.artemis.storage.server.DatabaseStorageException;\n+import tech.pegasys.artemis.storage.server.rocksdb.core.ColumnEntry;\n+import tech.pegasys.artemis.storage.server.rocksdb.core.RocksDbInstance;\n+import tech.pegasys.artemis.storage.server.rocksdb.core.RocksDbInstance.Transaction;\n+import tech.pegasys.artemis.storage.server.rocksdb.schema.V3Schema;\n+\n+public class V3RocksDbDao implements RocksDbDAO {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  // Persistent data\n+  private final RocksDbInstance db;\n+  // In-memory data\n+  private final NavigableMap<UnsignedLong, Set<Bytes32>> hotRootsBySlotCache =\n+      new ConcurrentSkipListMap<>();\n+  private final Map<Bytes32, BeaconState> hotStates = new ConcurrentHashMap<>();\n+\n+  public V3RocksDbDao(final RocksDbInstance db) {\n+    this.db = db;\n+    initialize();\n+  }\n+\n+  @Override\n+  public Optional<UnsignedLong> getGenesisTime() {\n+    return db.get(V3Schema.GENESIS_TIME);\n+  }\n+\n+  @Override\n+  public Optional<Checkpoint> getJustifiedCheckpoint() {\n+    return db.get(V3Schema.JUSTIFIED_CHECKPOINT);\n+  }\n+\n+  @Override\n+  public Optional<Checkpoint> getBestJustifiedCheckpoint() {\n+    return db.get(V3Schema.BEST_JUSTIFIED_CHECKPOINT);\n+  }\n+\n+  @Override\n+  public Optional<Checkpoint> getFinalizedCheckpoint() {\n+    return db.get(V3Schema.FINALIZED_CHECKPOINT);\n+  }\n+\n+  @Override\n+  public Optional<UnsignedLong> getHighestFinalizedSlot() {\n+    return db.getLastEntry(V3Schema.FINALIZED_ROOTS_BY_SLOT).map(ColumnEntry::getKey);\n+  }\n+\n+  @Override\n+  public Optional<Bytes32> getFinalizedRootAtSlot(final UnsignedLong slot) {\n+    return db.get(V3Schema.FINALIZED_ROOTS_BY_SLOT, slot);\n+  }\n+\n+  @Override\n+  public Optional<Bytes32> getLatestFinalizedRootAtSlot(final UnsignedLong slot) {\n+    return db.getFloorEntry(V3Schema.FINALIZED_ROOTS_BY_SLOT, slot).map(ColumnEntry::getValue);\n+  }\n+\n+  @Override\n+  public Optional<SignedBeaconBlock> getHotBlock(final Bytes32 root) {\n+    return db.get(V3Schema.HOT_BLOCKS_BY_ROOT, root);\n+  }\n+\n+  @Override\n+  public Optional<SignedBeaconBlock> getFinalizedBlock(final Bytes32 root) {\n+    return db.get(V3Schema.FINALIZED_BLOCKS_BY_ROOT, root);\n+  }\n+\n+  @Override\n+  public Optional<BeaconState> getHotState(final Bytes32 root) {\n+    return Optional.ofNullable(hotStates.get(root));\n+  }\n+\n+  @Override\n+  public Optional<BeaconState> getFinalizedState(final Bytes32 root) {\n+    return db.get(V3Schema.FINALIZED_STATES_BY_ROOT, root);\n+  }\n+\n+  @Override\n+  public Map<Bytes32, SignedBeaconBlock> getHotBlocks() {\n+    return db.getAll(V3Schema.HOT_BLOCKS_BY_ROOT);\n+  }\n+\n+  @Override\n+  public Map<Bytes32, BeaconState> getHotStates() {\n+    return new HashMap<>(hotStates);\n+  }\n+\n+  @Override\n+  public Map<Checkpoint, BeaconState> getCheckpointStates() {\n+    return db.getAll(V3Schema.CHECKPOINT_STATES);\n+  }\n+\n+  @Override\n+  public Stream<ColumnEntry<Checkpoint, BeaconState>> streamCheckpointStates() {\n+    return db.stream(V3Schema.CHECKPOINT_STATES);\n+  }\n+\n+  private Optional<BeaconState> getLatestFinalizedState() {\n+    return db.get(V3Schema.LATEST_FINALIZED_STATE);\n+  }\n+\n+  public Optional<Bytes32> getLatestFinalizedRoot() {\n+    return db.getLastEntry(V3Schema.FINALIZED_ROOTS_BY_SLOT).map(ColumnEntry::getValue);\n+  }\n+\n+  @Override\n+  public Updater updater() {\n+    return new V3Updater(db, hotRootsBySlotCache, hotStates);\n+  }\n+\n+  @Override\n+  public void close() throws Exception {\n+    hotRootsBySlotCache.clear();\n+    db.close();\n+  }\n+\n+  private void initialize() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ4MDEzOQ=="}, "originalCommit": {"oid": "e40f58a1d95340bb76fc249260f11c1de9c5ee9c"}, "originalPosition": 156}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNTk4Njc1OnYy", "diffSide": "RIGHT", "path": "storage/src/main/java/tech/pegasys/artemis/storage/server/rocksdb/dataaccess/V3RocksDbDao.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMjo1MDozNFrOGFjtpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNDo0Mjo0N1rOGF9GOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ4MTE4OQ==", "bodyText": "headMap returns a live view so we may not want to putAll into it or we've effectively committed part of this transaction early. It should be safe to do it the other way around though (putAll into hotRootsBySlotAdditions.headMap).", "url": "https://github.com/ConsenSys/teku/pull/1577#discussion_r408481189", "createdAt": "2020-04-14T22:50:34Z", "author": {"login": "ajsutton"}, "path": "storage/src/main/java/tech/pegasys/artemis/storage/server/rocksdb/dataaccess/V3RocksDbDao.java", "diffHunk": "@@ -0,0 +1,387 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.storage.server.rocksdb.dataaccess;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.artemis.core.StateTransition;\n+import tech.pegasys.artemis.core.StateTransitionException;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.state.Checkpoint;\n+import tech.pegasys.artemis.storage.server.DatabaseStorageException;\n+import tech.pegasys.artemis.storage.server.rocksdb.core.ColumnEntry;\n+import tech.pegasys.artemis.storage.server.rocksdb.core.RocksDbInstance;\n+import tech.pegasys.artemis.storage.server.rocksdb.core.RocksDbInstance.Transaction;\n+import tech.pegasys.artemis.storage.server.rocksdb.schema.V3Schema;\n+\n+public class V3RocksDbDao implements RocksDbDAO {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  // Persistent data\n+  private final RocksDbInstance db;\n+  // In-memory data\n+  private final NavigableMap<UnsignedLong, Set<Bytes32>> hotRootsBySlotCache =\n+      new ConcurrentSkipListMap<>();\n+  private final Map<Bytes32, BeaconState> hotStates = new ConcurrentHashMap<>();\n+\n+  public V3RocksDbDao(final RocksDbInstance db) {\n+    this.db = db;\n+    initialize();\n+  }\n+\n+  @Override\n+  public Optional<UnsignedLong> getGenesisTime() {\n+    return db.get(V3Schema.GENESIS_TIME);\n+  }\n+\n+  @Override\n+  public Optional<Checkpoint> getJustifiedCheckpoint() {\n+    return db.get(V3Schema.JUSTIFIED_CHECKPOINT);\n+  }\n+\n+  @Override\n+  public Optional<Checkpoint> getBestJustifiedCheckpoint() {\n+    return db.get(V3Schema.BEST_JUSTIFIED_CHECKPOINT);\n+  }\n+\n+  @Override\n+  public Optional<Checkpoint> getFinalizedCheckpoint() {\n+    return db.get(V3Schema.FINALIZED_CHECKPOINT);\n+  }\n+\n+  @Override\n+  public Optional<UnsignedLong> getHighestFinalizedSlot() {\n+    return db.getLastEntry(V3Schema.FINALIZED_ROOTS_BY_SLOT).map(ColumnEntry::getKey);\n+  }\n+\n+  @Override\n+  public Optional<Bytes32> getFinalizedRootAtSlot(final UnsignedLong slot) {\n+    return db.get(V3Schema.FINALIZED_ROOTS_BY_SLOT, slot);\n+  }\n+\n+  @Override\n+  public Optional<Bytes32> getLatestFinalizedRootAtSlot(final UnsignedLong slot) {\n+    return db.getFloorEntry(V3Schema.FINALIZED_ROOTS_BY_SLOT, slot).map(ColumnEntry::getValue);\n+  }\n+\n+  @Override\n+  public Optional<SignedBeaconBlock> getHotBlock(final Bytes32 root) {\n+    return db.get(V3Schema.HOT_BLOCKS_BY_ROOT, root);\n+  }\n+\n+  @Override\n+  public Optional<SignedBeaconBlock> getFinalizedBlock(final Bytes32 root) {\n+    return db.get(V3Schema.FINALIZED_BLOCKS_BY_ROOT, root);\n+  }\n+\n+  @Override\n+  public Optional<BeaconState> getHotState(final Bytes32 root) {\n+    return Optional.ofNullable(hotStates.get(root));\n+  }\n+\n+  @Override\n+  public Optional<BeaconState> getFinalizedState(final Bytes32 root) {\n+    return db.get(V3Schema.FINALIZED_STATES_BY_ROOT, root);\n+  }\n+\n+  @Override\n+  public Map<Bytes32, SignedBeaconBlock> getHotBlocks() {\n+    return db.getAll(V3Schema.HOT_BLOCKS_BY_ROOT);\n+  }\n+\n+  @Override\n+  public Map<Bytes32, BeaconState> getHotStates() {\n+    return new HashMap<>(hotStates);\n+  }\n+\n+  @Override\n+  public Map<Checkpoint, BeaconState> getCheckpointStates() {\n+    return db.getAll(V3Schema.CHECKPOINT_STATES);\n+  }\n+\n+  @Override\n+  public Stream<ColumnEntry<Checkpoint, BeaconState>> streamCheckpointStates() {\n+    return db.stream(V3Schema.CHECKPOINT_STATES);\n+  }\n+\n+  private Optional<BeaconState> getLatestFinalizedState() {\n+    return db.get(V3Schema.LATEST_FINALIZED_STATE);\n+  }\n+\n+  public Optional<Bytes32> getLatestFinalizedRoot() {\n+    return db.getLastEntry(V3Schema.FINALIZED_ROOTS_BY_SLOT).map(ColumnEntry::getValue);\n+  }\n+\n+  @Override\n+  public Updater updater() {\n+    return new V3Updater(db, hotRootsBySlotCache, hotStates);\n+  }\n+\n+  @Override\n+  public void close() throws Exception {\n+    hotRootsBySlotCache.clear();\n+    db.close();\n+  }\n+\n+  private void initialize() {\n+    final Optional<BeaconState> finalizedState = getLatestFinalizedState();\n+    final Optional<Bytes32> finalizedRoot = getLatestFinalizedRoot();\n+    final Map<Bytes32, SignedBeaconBlock> hotBlocksByRoot = getHotBlocks();\n+\n+    if (finalizedRoot.isEmpty() && finalizedState.isEmpty() && hotBlocksByRoot.isEmpty()) {\n+      // Database is empty, nothing to initialize\n+      LOG.trace(\"Database appears to be empty.  Skip initialization of hot states.\");\n+      return;\n+    } else if (finalizedRoot.isEmpty() || finalizedState.isEmpty()) {\n+      throw new DatabaseStorageException(\"Missing latest finalized block information\");\n+    }\n+\n+    initializeHotStates(finalizedRoot.get(), finalizedState.get(), hotBlocksByRoot);\n+  }\n+\n+  private void initializeHotStates(\n+      final Bytes32 finalizedRoot,\n+      final BeaconState finalizedState,\n+      final Map<Bytes32, SignedBeaconBlock> hotBlocksByRoot) {\n+    // Initialize hot states with latest finalized state\n+    hotStates.put(finalizedRoot, finalizedState);\n+\n+    // Index blocks by parent root\n+    final Map<Bytes32, List<SignedBeaconBlock>> blocksByParent = new HashMap<>();\n+    for (Entry<Bytes32, SignedBeaconBlock> hotBlockEntry : hotBlocksByRoot.entrySet()) {\n+      final SignedBeaconBlock currentBlock = hotBlockEntry.getValue();\n+      final List<SignedBeaconBlock> blockList =\n+          blocksByParent.computeIfAbsent(currentBlock.getParent_root(), (key) -> new ArrayList<>());\n+      blockList.add(currentBlock);\n+    }\n+\n+    // Generate remaining hot states\n+    final Deque<Bytes32> parentRoots = new ArrayDeque<>();\n+    parentRoots.push(finalizedRoot);\n+    while (!parentRoots.isEmpty()) {\n+      final Bytes32 parentRoot = parentRoots.pop();\n+      final BeaconState parentState = hotStates.get(parentRoot);\n+      final List<SignedBeaconBlock> blocks =\n+          blocksByParent.computeIfAbsent(parentRoot, (key) -> Collections.emptyList());\n+      for (SignedBeaconBlock block : blocks) {\n+        final Bytes32 blockRoot = block.getMessage().hash_tree_root();\n+        processBlock(parentState, block)\n+            .ifPresent(\n+                state -> {\n+                  hotStates.put(blockRoot, state);\n+                  parentRoots.push(blockRoot);\n+                });\n+      }\n+    }\n+\n+    if (hotStates.size() != hotBlocksByRoot.size()) {\n+      LOG.trace(\n+          \"Only {} hot states produced for {} hot blocks.  Some hot blocks must belong to non-canonical forks.\",\n+          hotStates.size(),\n+          hotBlocksByRoot.size());\n+    }\n+  }\n+\n+  private final Optional<BeaconState> processBlock(\n+      final BeaconState preState, final SignedBeaconBlock block) {\n+    StateTransition stateTransition = new StateTransition();\n+    try {\n+      final BeaconState postState = stateTransition.initiate(preState, block);\n+      return Optional.of(postState);\n+    } catch (StateTransitionException e) {\n+      LOG.error(\n+          \"Unable to produce state for block at slot {} ({})\",\n+          block.getSlot(),\n+          block.getMessage().hash_tree_root());\n+      return Optional.empty();\n+    }\n+  }\n+\n+  private static class V3Updater implements Updater {\n+\n+    private final Transaction transaction;\n+    private final NavigableMap<UnsignedLong, Set<Bytes32>> hotRootsBySlotCache;\n+    private final Map<Bytes32, BeaconState> hotStates;\n+\n+    // Hot root by slot updates\n+    private final NavigableMap<UnsignedLong, Set<Bytes32>> hotRootsBySlotAdditions =\n+        new ConcurrentSkipListMap<>();\n+    private final Set<UnsignedLong> prunedSlots = new HashSet<>();\n+\n+    // Hot state updates\n+    private final Map<Bytes32, BeaconState> newHotStates = new HashMap<>();\n+    private final Set<Bytes32> deletedStates = new HashSet<>();\n+\n+    V3Updater(\n+        final RocksDbInstance db,\n+        final NavigableMap<UnsignedLong, Set<Bytes32>> hotRootsBySlotCache,\n+        final Map<Bytes32, BeaconState> hotStates) {\n+      this.transaction = db.startTransaction();\n+      this.hotRootsBySlotCache = hotRootsBySlotCache;\n+      this.hotStates = hotStates;\n+    }\n+\n+    @Override\n+    public void setGenesisTime(final UnsignedLong genesisTime) {\n+      transaction.put(V3Schema.GENESIS_TIME, genesisTime);\n+    }\n+\n+    @Override\n+    public void setJustifiedCheckpoint(final Checkpoint checkpoint) {\n+      transaction.put(V3Schema.JUSTIFIED_CHECKPOINT, checkpoint);\n+    }\n+\n+    @Override\n+    public void setBestJustifiedCheckpoint(final Checkpoint checkpoint) {\n+      transaction.put(V3Schema.BEST_JUSTIFIED_CHECKPOINT, checkpoint);\n+    }\n+\n+    @Override\n+    public void setLatestFinalizedState(final BeaconState state) {\n+      transaction.put(V3Schema.LATEST_FINALIZED_STATE, state);\n+    }\n+\n+    @Override\n+    public void setFinalizedCheckpoint(final Checkpoint checkpoint) {\n+      transaction.put(V3Schema.FINALIZED_CHECKPOINT, checkpoint);\n+    }\n+\n+    @Override\n+    public void addCheckpointState(final Checkpoint checkpoint, final BeaconState state) {\n+      transaction.put(V3Schema.CHECKPOINT_STATES, checkpoint, state);\n+    }\n+\n+    @Override\n+    public void addCheckpointStates(final Map<Checkpoint, BeaconState> checkpointStates) {\n+      checkpointStates.forEach(this::addCheckpointState);\n+    }\n+\n+    @Override\n+    public void addHotBlock(final SignedBeaconBlock block) {\n+      final Bytes32 blockRoot = block.getMessage().hash_tree_root();\n+      transaction.put(V3Schema.HOT_BLOCKS_BY_ROOT, blockRoot, block);\n+      hotRootsBySlotAdditions\n+          .computeIfAbsent(block.getSlot(), key -> new HashSet<>())\n+          .add(blockRoot);\n+    }\n+\n+    @Override\n+    public void addFinalizedBlock(final SignedBeaconBlock block) {\n+      final Bytes32 root = block.getMessage().hash_tree_root();\n+      transaction.put(V3Schema.FINALIZED_ROOTS_BY_SLOT, block.getSlot(), root);\n+      transaction.put(V3Schema.FINALIZED_BLOCKS_BY_ROOT, root, block);\n+    }\n+\n+    @Override\n+    public void addHotState(final Bytes32 blockRoot, final BeaconState state) {\n+      newHotStates.put(blockRoot, state);\n+    }\n+\n+    @Override\n+    public void addFinalizedState(final Bytes32 blockRoot, final BeaconState state) {\n+      transaction.put(V3Schema.FINALIZED_STATES_BY_ROOT, blockRoot, state);\n+    }\n+\n+    @Override\n+    public void addHotBlocks(final Map<Bytes32, SignedBeaconBlock> blocks) {\n+      blocks.values().forEach(this::addHotBlock);\n+    }\n+\n+    @Override\n+    public void addHotStates(final Map<Bytes32, BeaconState> states) {\n+      states.forEach(this::addHotState);\n+    }\n+\n+    @Override\n+    public void deleteCheckpointState(final Checkpoint checkpoint) {\n+      transaction.delete(V3Schema.CHECKPOINT_STATES, checkpoint);\n+    }\n+\n+    @Override\n+    public Set<Bytes32> pruneHotBlocksAtSlotsGreaterThan(final UnsignedLong slot) {\n+      final Map<UnsignedLong, Set<Bytes32>> toRemove = hotRootsBySlotCache.headMap(slot);\n+      toRemove.putAll(hotRootsBySlotAdditions.headMap(slot));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e40f58a1d95340bb76fc249260f11c1de9c5ee9c"}, "originalPosition": 333}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODg5NzA4Mw==", "bodyText": "good catch!", "url": "https://github.com/ConsenSys/teku/pull/1577#discussion_r408897083", "createdAt": "2020-04-15T14:42:47Z", "author": {"login": "mbaxter"}, "path": "storage/src/main/java/tech/pegasys/artemis/storage/server/rocksdb/dataaccess/V3RocksDbDao.java", "diffHunk": "@@ -0,0 +1,387 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.storage.server.rocksdb.dataaccess;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.NavigableMap;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentSkipListMap;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.artemis.core.StateTransition;\n+import tech.pegasys.artemis.core.StateTransitionException;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.state.Checkpoint;\n+import tech.pegasys.artemis.storage.server.DatabaseStorageException;\n+import tech.pegasys.artemis.storage.server.rocksdb.core.ColumnEntry;\n+import tech.pegasys.artemis.storage.server.rocksdb.core.RocksDbInstance;\n+import tech.pegasys.artemis.storage.server.rocksdb.core.RocksDbInstance.Transaction;\n+import tech.pegasys.artemis.storage.server.rocksdb.schema.V3Schema;\n+\n+public class V3RocksDbDao implements RocksDbDAO {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  // Persistent data\n+  private final RocksDbInstance db;\n+  // In-memory data\n+  private final NavigableMap<UnsignedLong, Set<Bytes32>> hotRootsBySlotCache =\n+      new ConcurrentSkipListMap<>();\n+  private final Map<Bytes32, BeaconState> hotStates = new ConcurrentHashMap<>();\n+\n+  public V3RocksDbDao(final RocksDbInstance db) {\n+    this.db = db;\n+    initialize();\n+  }\n+\n+  @Override\n+  public Optional<UnsignedLong> getGenesisTime() {\n+    return db.get(V3Schema.GENESIS_TIME);\n+  }\n+\n+  @Override\n+  public Optional<Checkpoint> getJustifiedCheckpoint() {\n+    return db.get(V3Schema.JUSTIFIED_CHECKPOINT);\n+  }\n+\n+  @Override\n+  public Optional<Checkpoint> getBestJustifiedCheckpoint() {\n+    return db.get(V3Schema.BEST_JUSTIFIED_CHECKPOINT);\n+  }\n+\n+  @Override\n+  public Optional<Checkpoint> getFinalizedCheckpoint() {\n+    return db.get(V3Schema.FINALIZED_CHECKPOINT);\n+  }\n+\n+  @Override\n+  public Optional<UnsignedLong> getHighestFinalizedSlot() {\n+    return db.getLastEntry(V3Schema.FINALIZED_ROOTS_BY_SLOT).map(ColumnEntry::getKey);\n+  }\n+\n+  @Override\n+  public Optional<Bytes32> getFinalizedRootAtSlot(final UnsignedLong slot) {\n+    return db.get(V3Schema.FINALIZED_ROOTS_BY_SLOT, slot);\n+  }\n+\n+  @Override\n+  public Optional<Bytes32> getLatestFinalizedRootAtSlot(final UnsignedLong slot) {\n+    return db.getFloorEntry(V3Schema.FINALIZED_ROOTS_BY_SLOT, slot).map(ColumnEntry::getValue);\n+  }\n+\n+  @Override\n+  public Optional<SignedBeaconBlock> getHotBlock(final Bytes32 root) {\n+    return db.get(V3Schema.HOT_BLOCKS_BY_ROOT, root);\n+  }\n+\n+  @Override\n+  public Optional<SignedBeaconBlock> getFinalizedBlock(final Bytes32 root) {\n+    return db.get(V3Schema.FINALIZED_BLOCKS_BY_ROOT, root);\n+  }\n+\n+  @Override\n+  public Optional<BeaconState> getHotState(final Bytes32 root) {\n+    return Optional.ofNullable(hotStates.get(root));\n+  }\n+\n+  @Override\n+  public Optional<BeaconState> getFinalizedState(final Bytes32 root) {\n+    return db.get(V3Schema.FINALIZED_STATES_BY_ROOT, root);\n+  }\n+\n+  @Override\n+  public Map<Bytes32, SignedBeaconBlock> getHotBlocks() {\n+    return db.getAll(V3Schema.HOT_BLOCKS_BY_ROOT);\n+  }\n+\n+  @Override\n+  public Map<Bytes32, BeaconState> getHotStates() {\n+    return new HashMap<>(hotStates);\n+  }\n+\n+  @Override\n+  public Map<Checkpoint, BeaconState> getCheckpointStates() {\n+    return db.getAll(V3Schema.CHECKPOINT_STATES);\n+  }\n+\n+  @Override\n+  public Stream<ColumnEntry<Checkpoint, BeaconState>> streamCheckpointStates() {\n+    return db.stream(V3Schema.CHECKPOINT_STATES);\n+  }\n+\n+  private Optional<BeaconState> getLatestFinalizedState() {\n+    return db.get(V3Schema.LATEST_FINALIZED_STATE);\n+  }\n+\n+  public Optional<Bytes32> getLatestFinalizedRoot() {\n+    return db.getLastEntry(V3Schema.FINALIZED_ROOTS_BY_SLOT).map(ColumnEntry::getValue);\n+  }\n+\n+  @Override\n+  public Updater updater() {\n+    return new V3Updater(db, hotRootsBySlotCache, hotStates);\n+  }\n+\n+  @Override\n+  public void close() throws Exception {\n+    hotRootsBySlotCache.clear();\n+    db.close();\n+  }\n+\n+  private void initialize() {\n+    final Optional<BeaconState> finalizedState = getLatestFinalizedState();\n+    final Optional<Bytes32> finalizedRoot = getLatestFinalizedRoot();\n+    final Map<Bytes32, SignedBeaconBlock> hotBlocksByRoot = getHotBlocks();\n+\n+    if (finalizedRoot.isEmpty() && finalizedState.isEmpty() && hotBlocksByRoot.isEmpty()) {\n+      // Database is empty, nothing to initialize\n+      LOG.trace(\"Database appears to be empty.  Skip initialization of hot states.\");\n+      return;\n+    } else if (finalizedRoot.isEmpty() || finalizedState.isEmpty()) {\n+      throw new DatabaseStorageException(\"Missing latest finalized block information\");\n+    }\n+\n+    initializeHotStates(finalizedRoot.get(), finalizedState.get(), hotBlocksByRoot);\n+  }\n+\n+  private void initializeHotStates(\n+      final Bytes32 finalizedRoot,\n+      final BeaconState finalizedState,\n+      final Map<Bytes32, SignedBeaconBlock> hotBlocksByRoot) {\n+    // Initialize hot states with latest finalized state\n+    hotStates.put(finalizedRoot, finalizedState);\n+\n+    // Index blocks by parent root\n+    final Map<Bytes32, List<SignedBeaconBlock>> blocksByParent = new HashMap<>();\n+    for (Entry<Bytes32, SignedBeaconBlock> hotBlockEntry : hotBlocksByRoot.entrySet()) {\n+      final SignedBeaconBlock currentBlock = hotBlockEntry.getValue();\n+      final List<SignedBeaconBlock> blockList =\n+          blocksByParent.computeIfAbsent(currentBlock.getParent_root(), (key) -> new ArrayList<>());\n+      blockList.add(currentBlock);\n+    }\n+\n+    // Generate remaining hot states\n+    final Deque<Bytes32> parentRoots = new ArrayDeque<>();\n+    parentRoots.push(finalizedRoot);\n+    while (!parentRoots.isEmpty()) {\n+      final Bytes32 parentRoot = parentRoots.pop();\n+      final BeaconState parentState = hotStates.get(parentRoot);\n+      final List<SignedBeaconBlock> blocks =\n+          blocksByParent.computeIfAbsent(parentRoot, (key) -> Collections.emptyList());\n+      for (SignedBeaconBlock block : blocks) {\n+        final Bytes32 blockRoot = block.getMessage().hash_tree_root();\n+        processBlock(parentState, block)\n+            .ifPresent(\n+                state -> {\n+                  hotStates.put(blockRoot, state);\n+                  parentRoots.push(blockRoot);\n+                });\n+      }\n+    }\n+\n+    if (hotStates.size() != hotBlocksByRoot.size()) {\n+      LOG.trace(\n+          \"Only {} hot states produced for {} hot blocks.  Some hot blocks must belong to non-canonical forks.\",\n+          hotStates.size(),\n+          hotBlocksByRoot.size());\n+    }\n+  }\n+\n+  private final Optional<BeaconState> processBlock(\n+      final BeaconState preState, final SignedBeaconBlock block) {\n+    StateTransition stateTransition = new StateTransition();\n+    try {\n+      final BeaconState postState = stateTransition.initiate(preState, block);\n+      return Optional.of(postState);\n+    } catch (StateTransitionException e) {\n+      LOG.error(\n+          \"Unable to produce state for block at slot {} ({})\",\n+          block.getSlot(),\n+          block.getMessage().hash_tree_root());\n+      return Optional.empty();\n+    }\n+  }\n+\n+  private static class V3Updater implements Updater {\n+\n+    private final Transaction transaction;\n+    private final NavigableMap<UnsignedLong, Set<Bytes32>> hotRootsBySlotCache;\n+    private final Map<Bytes32, BeaconState> hotStates;\n+\n+    // Hot root by slot updates\n+    private final NavigableMap<UnsignedLong, Set<Bytes32>> hotRootsBySlotAdditions =\n+        new ConcurrentSkipListMap<>();\n+    private final Set<UnsignedLong> prunedSlots = new HashSet<>();\n+\n+    // Hot state updates\n+    private final Map<Bytes32, BeaconState> newHotStates = new HashMap<>();\n+    private final Set<Bytes32> deletedStates = new HashSet<>();\n+\n+    V3Updater(\n+        final RocksDbInstance db,\n+        final NavigableMap<UnsignedLong, Set<Bytes32>> hotRootsBySlotCache,\n+        final Map<Bytes32, BeaconState> hotStates) {\n+      this.transaction = db.startTransaction();\n+      this.hotRootsBySlotCache = hotRootsBySlotCache;\n+      this.hotStates = hotStates;\n+    }\n+\n+    @Override\n+    public void setGenesisTime(final UnsignedLong genesisTime) {\n+      transaction.put(V3Schema.GENESIS_TIME, genesisTime);\n+    }\n+\n+    @Override\n+    public void setJustifiedCheckpoint(final Checkpoint checkpoint) {\n+      transaction.put(V3Schema.JUSTIFIED_CHECKPOINT, checkpoint);\n+    }\n+\n+    @Override\n+    public void setBestJustifiedCheckpoint(final Checkpoint checkpoint) {\n+      transaction.put(V3Schema.BEST_JUSTIFIED_CHECKPOINT, checkpoint);\n+    }\n+\n+    @Override\n+    public void setLatestFinalizedState(final BeaconState state) {\n+      transaction.put(V3Schema.LATEST_FINALIZED_STATE, state);\n+    }\n+\n+    @Override\n+    public void setFinalizedCheckpoint(final Checkpoint checkpoint) {\n+      transaction.put(V3Schema.FINALIZED_CHECKPOINT, checkpoint);\n+    }\n+\n+    @Override\n+    public void addCheckpointState(final Checkpoint checkpoint, final BeaconState state) {\n+      transaction.put(V3Schema.CHECKPOINT_STATES, checkpoint, state);\n+    }\n+\n+    @Override\n+    public void addCheckpointStates(final Map<Checkpoint, BeaconState> checkpointStates) {\n+      checkpointStates.forEach(this::addCheckpointState);\n+    }\n+\n+    @Override\n+    public void addHotBlock(final SignedBeaconBlock block) {\n+      final Bytes32 blockRoot = block.getMessage().hash_tree_root();\n+      transaction.put(V3Schema.HOT_BLOCKS_BY_ROOT, blockRoot, block);\n+      hotRootsBySlotAdditions\n+          .computeIfAbsent(block.getSlot(), key -> new HashSet<>())\n+          .add(blockRoot);\n+    }\n+\n+    @Override\n+    public void addFinalizedBlock(final SignedBeaconBlock block) {\n+      final Bytes32 root = block.getMessage().hash_tree_root();\n+      transaction.put(V3Schema.FINALIZED_ROOTS_BY_SLOT, block.getSlot(), root);\n+      transaction.put(V3Schema.FINALIZED_BLOCKS_BY_ROOT, root, block);\n+    }\n+\n+    @Override\n+    public void addHotState(final Bytes32 blockRoot, final BeaconState state) {\n+      newHotStates.put(blockRoot, state);\n+    }\n+\n+    @Override\n+    public void addFinalizedState(final Bytes32 blockRoot, final BeaconState state) {\n+      transaction.put(V3Schema.FINALIZED_STATES_BY_ROOT, blockRoot, state);\n+    }\n+\n+    @Override\n+    public void addHotBlocks(final Map<Bytes32, SignedBeaconBlock> blocks) {\n+      blocks.values().forEach(this::addHotBlock);\n+    }\n+\n+    @Override\n+    public void addHotStates(final Map<Bytes32, BeaconState> states) {\n+      states.forEach(this::addHotState);\n+    }\n+\n+    @Override\n+    public void deleteCheckpointState(final Checkpoint checkpoint) {\n+      transaction.delete(V3Schema.CHECKPOINT_STATES, checkpoint);\n+    }\n+\n+    @Override\n+    public Set<Bytes32> pruneHotBlocksAtSlotsGreaterThan(final UnsignedLong slot) {\n+      final Map<UnsignedLong, Set<Bytes32>> toRemove = hotRootsBySlotCache.headMap(slot);\n+      toRemove.putAll(hotRootsBySlotAdditions.headMap(slot));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ4MTE4OQ=="}, "originalCommit": {"oid": "e40f58a1d95340bb76fc249260f11c1de9c5ee9c"}, "originalPosition": 333}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNjAwMzQ1OnYy", "diffSide": "RIGHT", "path": "storage/src/main/java/tech/pegasys/artemis/storage/server/rocksdb/dataaccess/RocksDbDAO.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMjo1Nzo1MVrOGFj3tA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMjo1Nzo1MVrOGFj3tA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ4Mzc2NA==", "bodyText": "nit: Should be RocksDbDao.", "url": "https://github.com/ConsenSys/teku/pull/1577#discussion_r408483764", "createdAt": "2020-04-14T22:57:51Z", "author": {"login": "ajsutton"}, "path": "storage/src/main/java/tech/pegasys/artemis/storage/server/rocksdb/dataaccess/RocksDbDAO.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.storage.server.rocksdb.dataaccess;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Stream;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.state.Checkpoint;\n+import tech.pegasys.artemis.storage.server.rocksdb.core.ColumnEntry;\n+\n+/**\n+ * A RocksDB \"data access object\" interface to abstract interactions with underlying database.\n+ *\n+ * @see <a href=\"https://en.wikipedia.org/wiki/Data_access_object\">DAO</a>\n+ */\n+public interface RocksDbDAO extends AutoCloseable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e40f58a1d95340bb76fc249260f11c1de9c5ee9c"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNjA1MzE1OnYy", "diffSide": "RIGHT", "path": "storage/src/test/java/tech/pegasys/artemis/storage/server/rocksdb/V3RocksDbDatabaseTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMzoyMDoyMFrOGFkU_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNDo0Mzo1MFrOGF9Jpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ5MTI2MQ==", "bodyText": "Should this be PRUNE not ARCHIVE?", "url": "https://github.com/ConsenSys/teku/pull/1577#discussion_r408491261", "createdAt": "2020-04-14T23:20:20Z", "author": {"login": "ajsutton"}, "path": "storage/src/test/java/tech/pegasys/artemis/storage/server/rocksdb/V3RocksDbDatabaseTest.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.storage.server.rocksdb;\n+\n+import static java.util.stream.Collectors.toList;\n+\n+import com.google.common.collect.Streams;\n+import java.io.File;\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.io.TempDir;\n+import tech.pegasys.artemis.core.ChainBuilder;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBlockAndState;\n+import tech.pegasys.artemis.datastructures.state.Checkpoint;\n+import tech.pegasys.artemis.storage.Store;\n+import tech.pegasys.artemis.storage.server.Database;\n+import tech.pegasys.artemis.storage.server.StateStorageMode;\n+\n+public class V3RocksDbDatabaseTest extends AbstractRocksDbDatabaseTest {\n+\n+  @Override\n+  protected Database createDatabase(final File tempDir, final StateStorageMode storageMode) {\n+    final RocksDbConfiguration config = RocksDbConfiguration.withDataDirectory(tempDir.toPath());\n+    return RocksDbDatabase.createV3(config, storageMode);\n+  }\n+\n+  @Test\n+  public void shouldHandleRestartWithUnrecoverableForkBlocks_archive(@TempDir final Path tempDir)\n+      throws Exception {\n+    testShouldHandleRestartWithUnrecoverableForkBlocks(tempDir, StateStorageMode.ARCHIVE);\n+  }\n+\n+  @Test\n+  public void shouldHandleRestartWithUnrecoverableForkBlocks_prune(@TempDir final Path tempDir)\n+      throws Exception {\n+    testShouldHandleRestartWithUnrecoverableForkBlocks(tempDir, StateStorageMode.ARCHIVE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e40f58a1d95340bb76fc249260f11c1de9c5ee9c"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODg5Nzk1OQ==", "bodyText": "yep - good catch", "url": "https://github.com/ConsenSys/teku/pull/1577#discussion_r408897959", "createdAt": "2020-04-15T14:43:50Z", "author": {"login": "mbaxter"}, "path": "storage/src/test/java/tech/pegasys/artemis/storage/server/rocksdb/V3RocksDbDatabaseTest.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.storage.server.rocksdb;\n+\n+import static java.util.stream.Collectors.toList;\n+\n+import com.google.common.collect.Streams;\n+import java.io.File;\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.io.TempDir;\n+import tech.pegasys.artemis.core.ChainBuilder;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBlockAndState;\n+import tech.pegasys.artemis.datastructures.state.Checkpoint;\n+import tech.pegasys.artemis.storage.Store;\n+import tech.pegasys.artemis.storage.server.Database;\n+import tech.pegasys.artemis.storage.server.StateStorageMode;\n+\n+public class V3RocksDbDatabaseTest extends AbstractRocksDbDatabaseTest {\n+\n+  @Override\n+  protected Database createDatabase(final File tempDir, final StateStorageMode storageMode) {\n+    final RocksDbConfiguration config = RocksDbConfiguration.withDataDirectory(tempDir.toPath());\n+    return RocksDbDatabase.createV3(config, storageMode);\n+  }\n+\n+  @Test\n+  public void shouldHandleRestartWithUnrecoverableForkBlocks_archive(@TempDir final Path tempDir)\n+      throws Exception {\n+    testShouldHandleRestartWithUnrecoverableForkBlocks(tempDir, StateStorageMode.ARCHIVE);\n+  }\n+\n+  @Test\n+  public void shouldHandleRestartWithUnrecoverableForkBlocks_prune(@TempDir final Path tempDir)\n+      throws Exception {\n+    testShouldHandleRestartWithUnrecoverableForkBlocks(tempDir, StateStorageMode.ARCHIVE);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ5MTI2MQ=="}, "originalCommit": {"oid": "e40f58a1d95340bb76fc249260f11c1de9c5ee9c"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNjA3MzM3OnYy", "diffSide": "RIGHT", "path": "storage/src/test/java/tech/pegasys/artemis/storage/server/rocksdb/V3RocksDbDatabaseTest.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMzozMDoxMVrOGFkhSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNToyOTozNFrOGF_Vog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ5NDQwOQ==", "bodyText": "Doesn't need to be addressed in this PR but we should actually be removing those blocks from the hot state and rejecting any new blocks that build on them.   Not sure if we're just wasting memory at the moment or if we're considering them as part of fork choice and might try to switch to a fork that conflicts with our finalised blocks.", "url": "https://github.com/ConsenSys/teku/pull/1577#discussion_r408494409", "createdAt": "2020-04-14T23:30:11Z", "author": {"login": "ajsutton"}, "path": "storage/src/test/java/tech/pegasys/artemis/storage/server/rocksdb/V3RocksDbDatabaseTest.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.storage.server.rocksdb;\n+\n+import static java.util.stream.Collectors.toList;\n+\n+import com.google.common.collect.Streams;\n+import java.io.File;\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.io.TempDir;\n+import tech.pegasys.artemis.core.ChainBuilder;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBlockAndState;\n+import tech.pegasys.artemis.datastructures.state.Checkpoint;\n+import tech.pegasys.artemis.storage.Store;\n+import tech.pegasys.artemis.storage.server.Database;\n+import tech.pegasys.artemis.storage.server.StateStorageMode;\n+\n+public class V3RocksDbDatabaseTest extends AbstractRocksDbDatabaseTest {\n+\n+  @Override\n+  protected Database createDatabase(final File tempDir, final StateStorageMode storageMode) {\n+    final RocksDbConfiguration config = RocksDbConfiguration.withDataDirectory(tempDir.toPath());\n+    return RocksDbDatabase.createV3(config, storageMode);\n+  }\n+\n+  @Test\n+  public void shouldHandleRestartWithUnrecoverableForkBlocks_archive(@TempDir final Path tempDir)\n+      throws Exception {\n+    testShouldHandleRestartWithUnrecoverableForkBlocks(tempDir, StateStorageMode.ARCHIVE);\n+  }\n+\n+  @Test\n+  public void shouldHandleRestartWithUnrecoverableForkBlocks_prune(@TempDir final Path tempDir)\n+      throws Exception {\n+    testShouldHandleRestartWithUnrecoverableForkBlocks(tempDir, StateStorageMode.ARCHIVE);\n+  }\n+\n+  private void testShouldHandleRestartWithUnrecoverableForkBlocks(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e40f58a1d95340bb76fc249260f11c1de9c5ee9c"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODkwMTgyNQ==", "bodyText": "I'm pretty sure we're just wasting memory right now.  We shouldn't be importing blocks or choosing head blocks that don't descend from the latest finalized block.\nI'll log a ticket to follow-up though.", "url": "https://github.com/ConsenSys/teku/pull/1577#discussion_r408901825", "createdAt": "2020-04-15T14:48:31Z", "author": {"login": "mbaxter"}, "path": "storage/src/test/java/tech/pegasys/artemis/storage/server/rocksdb/V3RocksDbDatabaseTest.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.storage.server.rocksdb;\n+\n+import static java.util.stream.Collectors.toList;\n+\n+import com.google.common.collect.Streams;\n+import java.io.File;\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.io.TempDir;\n+import tech.pegasys.artemis.core.ChainBuilder;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBlockAndState;\n+import tech.pegasys.artemis.datastructures.state.Checkpoint;\n+import tech.pegasys.artemis.storage.Store;\n+import tech.pegasys.artemis.storage.server.Database;\n+import tech.pegasys.artemis.storage.server.StateStorageMode;\n+\n+public class V3RocksDbDatabaseTest extends AbstractRocksDbDatabaseTest {\n+\n+  @Override\n+  protected Database createDatabase(final File tempDir, final StateStorageMode storageMode) {\n+    final RocksDbConfiguration config = RocksDbConfiguration.withDataDirectory(tempDir.toPath());\n+    return RocksDbDatabase.createV3(config, storageMode);\n+  }\n+\n+  @Test\n+  public void shouldHandleRestartWithUnrecoverableForkBlocks_archive(@TempDir final Path tempDir)\n+      throws Exception {\n+    testShouldHandleRestartWithUnrecoverableForkBlocks(tempDir, StateStorageMode.ARCHIVE);\n+  }\n+\n+  @Test\n+  public void shouldHandleRestartWithUnrecoverableForkBlocks_prune(@TempDir final Path tempDir)\n+      throws Exception {\n+    testShouldHandleRestartWithUnrecoverableForkBlocks(tempDir, StateStorageMode.ARCHIVE);\n+  }\n+\n+  private void testShouldHandleRestartWithUnrecoverableForkBlocks(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ5NDQwOQ=="}, "originalCommit": {"oid": "e40f58a1d95340bb76fc249260f11c1de9c5ee9c"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODkzMzc5NA==", "bodyText": "Ticket: https://pegasys1.atlassian.net/browse/BC-353", "url": "https://github.com/ConsenSys/teku/pull/1577#discussion_r408933794", "createdAt": "2020-04-15T15:29:34Z", "author": {"login": "mbaxter"}, "path": "storage/src/test/java/tech/pegasys/artemis/storage/server/rocksdb/V3RocksDbDatabaseTest.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.storage.server.rocksdb;\n+\n+import static java.util.stream.Collectors.toList;\n+\n+import com.google.common.collect.Streams;\n+import java.io.File;\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.io.TempDir;\n+import tech.pegasys.artemis.core.ChainBuilder;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBlockAndState;\n+import tech.pegasys.artemis.datastructures.state.Checkpoint;\n+import tech.pegasys.artemis.storage.Store;\n+import tech.pegasys.artemis.storage.server.Database;\n+import tech.pegasys.artemis.storage.server.StateStorageMode;\n+\n+public class V3RocksDbDatabaseTest extends AbstractRocksDbDatabaseTest {\n+\n+  @Override\n+  protected Database createDatabase(final File tempDir, final StateStorageMode storageMode) {\n+    final RocksDbConfiguration config = RocksDbConfiguration.withDataDirectory(tempDir.toPath());\n+    return RocksDbDatabase.createV3(config, storageMode);\n+  }\n+\n+  @Test\n+  public void shouldHandleRestartWithUnrecoverableForkBlocks_archive(@TempDir final Path tempDir)\n+      throws Exception {\n+    testShouldHandleRestartWithUnrecoverableForkBlocks(tempDir, StateStorageMode.ARCHIVE);\n+  }\n+\n+  @Test\n+  public void shouldHandleRestartWithUnrecoverableForkBlocks_prune(@TempDir final Path tempDir)\n+      throws Exception {\n+    testShouldHandleRestartWithUnrecoverableForkBlocks(tempDir, StateStorageMode.ARCHIVE);\n+  }\n+\n+  private void testShouldHandleRestartWithUnrecoverableForkBlocks(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ5NDQwOQ=="}, "originalCommit": {"oid": "e40f58a1d95340bb76fc249260f11c1de9c5ee9c"}, "originalPosition": 54}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1604, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}