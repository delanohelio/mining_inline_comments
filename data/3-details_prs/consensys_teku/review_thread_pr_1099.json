{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY1MDc0MTA5", "number": 1099, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxNzoxNDowOFrODZkjtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxNzozNjoxMFrODZk-gw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4MTM5OTU4OnYy", "diffSide": "RIGHT", "path": "ethereum/statetransition/src/main/java/tech/pegasys/artemis/statetransition/util/ForkChoiceUtil.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxNzoxNDowOFrOFgCEqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQyMDo1ODo1MVrOFgImBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTEzMjcxNA==", "bodyText": "Should this be renamed:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  return AttestationProcessingResult.FAILED_UNKNOWN_TARGET;\n          \n          \n            \n                  return AttestationProcessingResult.FAILED_UNKNOWN_BLOCK;\n          \n      \n    \n    \n  \n\n?", "url": "https://github.com/ConsenSys/teku/pull/1099#discussion_r369132714", "createdAt": "2020-01-21T17:14:08Z", "author": {"login": "mbaxter"}, "path": "ethereum/statetransition/src/main/java/tech/pegasys/artemis/statetransition/util/ForkChoiceUtil.java", "diffHunk": "@@ -417,65 +407,79 @@ private static boolean blockDescendsFromLatestFinalizedBlock(\n    * @see\n    *     <a>https://github.com/ethereum/eth2.0-specs/blob/v0.8.1/specs/core/0_fork-choice.md#on_attestation</a>\n    */\n-  public static void on_attestation(\n-      Store.Transaction store, Attestation attestation, StateTransition stateTransition)\n-      throws SlotProcessingException, EpochProcessingException {\n+  @CheckReturnValue\n+  public static AttestationProcessingResult on_attestation(\n+      Store.Transaction store, Attestation attestation, StateTransition stateTransition) {\n \n     Checkpoint target = attestation.getData().getTarget();\n \n-    UnsignedLong current_epoch = compute_epoch_at_slot(get_current_slot(store, true));\n+    UnsignedLong current_epoch = compute_epoch_at_slot(get_current_slot(store));\n \n     // Use GENESIS_EPOCH for previous when genesis to avoid underflow\n     UnsignedLong previous_epoch =\n         current_epoch.compareTo(UnsignedLong.valueOf(GENESIS_EPOCH)) > 0\n             ? current_epoch.minus(UnsignedLong.ONE)\n             : UnsignedLong.valueOf(GENESIS_EPOCH);\n \n-    List<UnsignedLong> epochs = List.of(current_epoch, previous_epoch);\n-    checkArgument(\n-        epochs.contains(target.getEpoch()),\n-        \"on_attestation: Attestations must be from the current or previous epoch\");\n+    if (!target.getEpoch().equals(previous_epoch) && !target.getEpoch().equals(current_epoch)) {\n+      return AttestationProcessingResult.invalid(\n+          \"on_attestation: Attestations must be from the current or previous epoch\");\n+    }\n+\n+    if (!target.getEpoch().equals(compute_epoch_at_slot(attestation.getData().getSlot()))) {\n+      return AttestationProcessingResult.invalid(\n+          \"on_attestation: Attestation slot must be within specified epoch\");\n+    }\n \n-    checkArgument(\n-        target.getEpoch().equals(compute_epoch_at_slot(attestation.getData().getSlot())),\n-        \"on_attestation: Attestation slot must be within specified epoch\");\n+    // Attestations can only affect the fork choice of subsequent slots.\n+    // Delay consideration in the fork choice until their slot is in the past.\n+    if (get_current_slot(store).compareTo(attestation.getData().getSlot()) <= 0) {\n+      return AttestationProcessingResult.FAILED_NOT_FROM_PAST;\n+    }\n \n-    checkArgument(\n-        store.getBlockRoots().contains(target.getRoot()),\n-        \"on_attestation: Attestations target must be for a known block. If a target block is unknown, delay consideration until the block is found\");\n+    if (!store.getBlockRoots().contains(target.getRoot())) {\n+      // Attestations target must be for a known block. If a target block is unknown, delay\n+      // consideration until the block is found\n+      return AttestationProcessingResult.FAILED_UNKNOWN_TARGET;\n+    }\n \n     // Attestations cannot be from future epochs. If they are, delay consideration until the epoch\n     // arrives\n-    BeaconState targetRootState = store.getBlockState(target.getRoot());\n-    checkArgument(\n-        get_current_slot(store).compareTo(compute_start_slot_at_epoch(target.getEpoch())) >= 0,\n-        \"on_attestation: Attestations cannot be from the future epochs\");\n-\n-    checkArgument(\n-        store.getBlockRoots().contains(attestation.getData().getBeacon_block_root()),\n-        \"on_attestation: Attestations must be for a known block. If block is unknown, delay consideration until the block is found\");\n-\n-    checkArgument(\n-        store\n-                .getBlock(attestation.getData().getBeacon_block_root())\n-                .getSlot()\n-                .compareTo(attestation.getData().getSlot())\n-            <= 0,\n-        \"on_attestation: Attestations must not be for blocks in the future. If not, the attestation should not be considered\");\n+    if (get_current_slot(store).compareTo(target.getEpochSlot()) < 0) {\n+      return AttestationProcessingResult.FAILED_FUTURE_EPOCH;\n+    }\n+\n+    if (!store.getBlockRoots().contains(attestation.getData().getBeacon_block_root())) {\n+      // Attestations must be for a known block. If block is unknown, delay consideration until the\n+      // block is found\n+      return AttestationProcessingResult.FAILED_UNKNOWN_TARGET;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b055528045a7915e996a1e5bf466edc0c05efea"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTIzOTU1Nw==", "bodyText": "Yeah makes sense.", "url": "https://github.com/ConsenSys/teku/pull/1099#discussion_r369239557", "createdAt": "2020-01-21T20:58:51Z", "author": {"login": "ajsutton"}, "path": "ethereum/statetransition/src/main/java/tech/pegasys/artemis/statetransition/util/ForkChoiceUtil.java", "diffHunk": "@@ -417,65 +407,79 @@ private static boolean blockDescendsFromLatestFinalizedBlock(\n    * @see\n    *     <a>https://github.com/ethereum/eth2.0-specs/blob/v0.8.1/specs/core/0_fork-choice.md#on_attestation</a>\n    */\n-  public static void on_attestation(\n-      Store.Transaction store, Attestation attestation, StateTransition stateTransition)\n-      throws SlotProcessingException, EpochProcessingException {\n+  @CheckReturnValue\n+  public static AttestationProcessingResult on_attestation(\n+      Store.Transaction store, Attestation attestation, StateTransition stateTransition) {\n \n     Checkpoint target = attestation.getData().getTarget();\n \n-    UnsignedLong current_epoch = compute_epoch_at_slot(get_current_slot(store, true));\n+    UnsignedLong current_epoch = compute_epoch_at_slot(get_current_slot(store));\n \n     // Use GENESIS_EPOCH for previous when genesis to avoid underflow\n     UnsignedLong previous_epoch =\n         current_epoch.compareTo(UnsignedLong.valueOf(GENESIS_EPOCH)) > 0\n             ? current_epoch.minus(UnsignedLong.ONE)\n             : UnsignedLong.valueOf(GENESIS_EPOCH);\n \n-    List<UnsignedLong> epochs = List.of(current_epoch, previous_epoch);\n-    checkArgument(\n-        epochs.contains(target.getEpoch()),\n-        \"on_attestation: Attestations must be from the current or previous epoch\");\n+    if (!target.getEpoch().equals(previous_epoch) && !target.getEpoch().equals(current_epoch)) {\n+      return AttestationProcessingResult.invalid(\n+          \"on_attestation: Attestations must be from the current or previous epoch\");\n+    }\n+\n+    if (!target.getEpoch().equals(compute_epoch_at_slot(attestation.getData().getSlot()))) {\n+      return AttestationProcessingResult.invalid(\n+          \"on_attestation: Attestation slot must be within specified epoch\");\n+    }\n \n-    checkArgument(\n-        target.getEpoch().equals(compute_epoch_at_slot(attestation.getData().getSlot())),\n-        \"on_attestation: Attestation slot must be within specified epoch\");\n+    // Attestations can only affect the fork choice of subsequent slots.\n+    // Delay consideration in the fork choice until their slot is in the past.\n+    if (get_current_slot(store).compareTo(attestation.getData().getSlot()) <= 0) {\n+      return AttestationProcessingResult.FAILED_NOT_FROM_PAST;\n+    }\n \n-    checkArgument(\n-        store.getBlockRoots().contains(target.getRoot()),\n-        \"on_attestation: Attestations target must be for a known block. If a target block is unknown, delay consideration until the block is found\");\n+    if (!store.getBlockRoots().contains(target.getRoot())) {\n+      // Attestations target must be for a known block. If a target block is unknown, delay\n+      // consideration until the block is found\n+      return AttestationProcessingResult.FAILED_UNKNOWN_TARGET;\n+    }\n \n     // Attestations cannot be from future epochs. If they are, delay consideration until the epoch\n     // arrives\n-    BeaconState targetRootState = store.getBlockState(target.getRoot());\n-    checkArgument(\n-        get_current_slot(store).compareTo(compute_start_slot_at_epoch(target.getEpoch())) >= 0,\n-        \"on_attestation: Attestations cannot be from the future epochs\");\n-\n-    checkArgument(\n-        store.getBlockRoots().contains(attestation.getData().getBeacon_block_root()),\n-        \"on_attestation: Attestations must be for a known block. If block is unknown, delay consideration until the block is found\");\n-\n-    checkArgument(\n-        store\n-                .getBlock(attestation.getData().getBeacon_block_root())\n-                .getSlot()\n-                .compareTo(attestation.getData().getSlot())\n-            <= 0,\n-        \"on_attestation: Attestations must not be for blocks in the future. If not, the attestation should not be considered\");\n+    if (get_current_slot(store).compareTo(target.getEpochSlot()) < 0) {\n+      return AttestationProcessingResult.FAILED_FUTURE_EPOCH;\n+    }\n+\n+    if (!store.getBlockRoots().contains(attestation.getData().getBeacon_block_root())) {\n+      // Attestations must be for a known block. If block is unknown, delay consideration until the\n+      // block is found\n+      return AttestationProcessingResult.FAILED_UNKNOWN_TARGET;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTEzMjcxNA=="}, "originalCommit": {"oid": "2b055528045a7915e996a1e5bf466edc0c05efea"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4MTQzMDMwOnYy", "diffSide": "RIGHT", "path": "sync/src/main/java/tech/pegasys/artemis/sync/AttestationManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxNzoyMzoyN1rOFgCX1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQyMDo1ODo0NVrOFgIl2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTEzNzYyMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                this.eventBus.post(new ProcessedAggregateEvent(attestation));\n          \n          \n            \n                this.eventBus.post(new ProcessedAttestationEvent(attestation));", "url": "https://github.com/ConsenSys/teku/pull/1099#discussion_r369137622", "createdAt": "2020-01-21T17:23:27Z", "author": {"login": "mbaxter"}, "path": "sync/src/main/java/tech/pegasys/artemis/sync/AttestationManager.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.sync;\n+\n+import static tech.pegasys.artemis.util.alogger.ALogger.STDOUT;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.eventbus.Subscribe;\n+import org.apache.logging.log4j.Level;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.datastructures.operations.AggregateAndProof;\n+import tech.pegasys.artemis.datastructures.operations.Attestation;\n+import tech.pegasys.artemis.service.serviceutils.Service;\n+import tech.pegasys.artemis.statetransition.StateTransition;\n+import tech.pegasys.artemis.statetransition.attestation.AttestationProcessingResult;\n+import tech.pegasys.artemis.statetransition.attestation.ForkChoiceAttestationProcessor;\n+import tech.pegasys.artemis.statetransition.events.BlockImportedEvent;\n+import tech.pegasys.artemis.statetransition.events.ProcessedAggregateEvent;\n+import tech.pegasys.artemis.storage.ChainStorageClient;\n+import tech.pegasys.artemis.storage.events.SlotEvent;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+\n+public class AttestationManager extends Service {\n+  private static final Logger LOG = LogManager.getLogger();\n+  private final EventBus eventBus;\n+  private final ForkChoiceAttestationProcessor attestationProcessor;\n+  private final PendingPool<Attestation> pendingAttestations;\n+  private final FutureItems<Attestation> futureAttestations;\n+\n+  AttestationManager(\n+      final EventBus eventBus,\n+      final ForkChoiceAttestationProcessor attestationProcessor,\n+      final PendingPool<Attestation> pendingAttestations,\n+      final FutureItems<Attestation> futureAttestations) {\n+    this.eventBus = eventBus;\n+    this.attestationProcessor = attestationProcessor;\n+    this.pendingAttestations = pendingAttestations;\n+    this.futureAttestations = futureAttestations;\n+  }\n+\n+  public static AttestationManager create(\n+      final EventBus eventBus, final ChainStorageClient storageClient) {\n+    final PendingPool<Attestation> pendingAttestations =\n+        PendingPool.createForAttestations(eventBus);\n+    final FutureItems<Attestation> futureAttestations =\n+        new FutureItems<>(Attestation::getEarliestSlotForProcessing);\n+    return new AttestationManager(\n+        eventBus,\n+        new ForkChoiceAttestationProcessor(storageClient, new StateTransition(false)),\n+        pendingAttestations,\n+        futureAttestations);\n+  }\n+\n+  @Subscribe\n+  @SuppressWarnings(\"unused\")\n+  private void onGossipedAttestation(final Attestation attestation) {\n+    processAttestation(attestation);\n+    // TODO: Should we post this if the attestation was invalid?\n+    // What if it was delayed?\n+    this.eventBus.post(new ProcessedAggregateEvent(attestation));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b055528045a7915e996a1e5bf466edc0c05efea"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTIzOTUxMg==", "bodyText": "Good spot.", "url": "https://github.com/ConsenSys/teku/pull/1099#discussion_r369239512", "createdAt": "2020-01-21T20:58:45Z", "author": {"login": "ajsutton"}, "path": "sync/src/main/java/tech/pegasys/artemis/sync/AttestationManager.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.sync;\n+\n+import static tech.pegasys.artemis.util.alogger.ALogger.STDOUT;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.eventbus.Subscribe;\n+import org.apache.logging.log4j.Level;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.datastructures.operations.AggregateAndProof;\n+import tech.pegasys.artemis.datastructures.operations.Attestation;\n+import tech.pegasys.artemis.service.serviceutils.Service;\n+import tech.pegasys.artemis.statetransition.StateTransition;\n+import tech.pegasys.artemis.statetransition.attestation.AttestationProcessingResult;\n+import tech.pegasys.artemis.statetransition.attestation.ForkChoiceAttestationProcessor;\n+import tech.pegasys.artemis.statetransition.events.BlockImportedEvent;\n+import tech.pegasys.artemis.statetransition.events.ProcessedAggregateEvent;\n+import tech.pegasys.artemis.storage.ChainStorageClient;\n+import tech.pegasys.artemis.storage.events.SlotEvent;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+\n+public class AttestationManager extends Service {\n+  private static final Logger LOG = LogManager.getLogger();\n+  private final EventBus eventBus;\n+  private final ForkChoiceAttestationProcessor attestationProcessor;\n+  private final PendingPool<Attestation> pendingAttestations;\n+  private final FutureItems<Attestation> futureAttestations;\n+\n+  AttestationManager(\n+      final EventBus eventBus,\n+      final ForkChoiceAttestationProcessor attestationProcessor,\n+      final PendingPool<Attestation> pendingAttestations,\n+      final FutureItems<Attestation> futureAttestations) {\n+    this.eventBus = eventBus;\n+    this.attestationProcessor = attestationProcessor;\n+    this.pendingAttestations = pendingAttestations;\n+    this.futureAttestations = futureAttestations;\n+  }\n+\n+  public static AttestationManager create(\n+      final EventBus eventBus, final ChainStorageClient storageClient) {\n+    final PendingPool<Attestation> pendingAttestations =\n+        PendingPool.createForAttestations(eventBus);\n+    final FutureItems<Attestation> futureAttestations =\n+        new FutureItems<>(Attestation::getEarliestSlotForProcessing);\n+    return new AttestationManager(\n+        eventBus,\n+        new ForkChoiceAttestationProcessor(storageClient, new StateTransition(false)),\n+        pendingAttestations,\n+        futureAttestations);\n+  }\n+\n+  @Subscribe\n+  @SuppressWarnings(\"unused\")\n+  private void onGossipedAttestation(final Attestation attestation) {\n+    processAttestation(attestation);\n+    // TODO: Should we post this if the attestation was invalid?\n+    // What if it was delayed?\n+    this.eventBus.post(new ProcessedAggregateEvent(attestation));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTEzNzYyMg=="}, "originalCommit": {"oid": "2b055528045a7915e996a1e5bf466edc0c05efea"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4MTQzMjYxOnYy", "diffSide": "RIGHT", "path": "sync/src/main/java/tech/pegasys/artemis/sync/AttestationManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxNzoyNDoxNlrOFgCZXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQyMTowMjoxMVrOFgIrfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTEzODAxNA==", "bodyText": "I'd think we only want to post records if they're valid - did you mean to keep these TODO's in here?", "url": "https://github.com/ConsenSys/teku/pull/1099#discussion_r369138014", "createdAt": "2020-01-21T17:24:16Z", "author": {"login": "mbaxter"}, "path": "sync/src/main/java/tech/pegasys/artemis/sync/AttestationManager.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.sync;\n+\n+import static tech.pegasys.artemis.util.alogger.ALogger.STDOUT;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.eventbus.Subscribe;\n+import org.apache.logging.log4j.Level;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.datastructures.operations.AggregateAndProof;\n+import tech.pegasys.artemis.datastructures.operations.Attestation;\n+import tech.pegasys.artemis.service.serviceutils.Service;\n+import tech.pegasys.artemis.statetransition.StateTransition;\n+import tech.pegasys.artemis.statetransition.attestation.AttestationProcessingResult;\n+import tech.pegasys.artemis.statetransition.attestation.ForkChoiceAttestationProcessor;\n+import tech.pegasys.artemis.statetransition.events.BlockImportedEvent;\n+import tech.pegasys.artemis.statetransition.events.ProcessedAggregateEvent;\n+import tech.pegasys.artemis.storage.ChainStorageClient;\n+import tech.pegasys.artemis.storage.events.SlotEvent;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+\n+public class AttestationManager extends Service {\n+  private static final Logger LOG = LogManager.getLogger();\n+  private final EventBus eventBus;\n+  private final ForkChoiceAttestationProcessor attestationProcessor;\n+  private final PendingPool<Attestation> pendingAttestations;\n+  private final FutureItems<Attestation> futureAttestations;\n+\n+  AttestationManager(\n+      final EventBus eventBus,\n+      final ForkChoiceAttestationProcessor attestationProcessor,\n+      final PendingPool<Attestation> pendingAttestations,\n+      final FutureItems<Attestation> futureAttestations) {\n+    this.eventBus = eventBus;\n+    this.attestationProcessor = attestationProcessor;\n+    this.pendingAttestations = pendingAttestations;\n+    this.futureAttestations = futureAttestations;\n+  }\n+\n+  public static AttestationManager create(\n+      final EventBus eventBus, final ChainStorageClient storageClient) {\n+    final PendingPool<Attestation> pendingAttestations =\n+        PendingPool.createForAttestations(eventBus);\n+    final FutureItems<Attestation> futureAttestations =\n+        new FutureItems<>(Attestation::getEarliestSlotForProcessing);\n+    return new AttestationManager(\n+        eventBus,\n+        new ForkChoiceAttestationProcessor(storageClient, new StateTransition(false)),\n+        pendingAttestations,\n+        futureAttestations);\n+  }\n+\n+  @Subscribe\n+  @SuppressWarnings(\"unused\")\n+  private void onGossipedAttestation(final Attestation attestation) {\n+    processAttestation(attestation);\n+    // TODO: Should we post this if the attestation was invalid?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b055528045a7915e996a1e5bf466edc0c05efea"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTI0MDk1Nw==", "bodyText": "The behaviour hasn't changed from what it was previously, but I added the TODO's because it seemed extremely weird that we'd always consider it processed.  I lean towards only posting these events once we actually have processed the attestations which may be delayed.  Will follow up in another PR. https://pegasys1.atlassian.net/browse/BC-243 created for good measure.", "url": "https://github.com/ConsenSys/teku/pull/1099#discussion_r369240957", "createdAt": "2020-01-21T21:02:11Z", "author": {"login": "ajsutton"}, "path": "sync/src/main/java/tech/pegasys/artemis/sync/AttestationManager.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.sync;\n+\n+import static tech.pegasys.artemis.util.alogger.ALogger.STDOUT;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.eventbus.Subscribe;\n+import org.apache.logging.log4j.Level;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.datastructures.operations.AggregateAndProof;\n+import tech.pegasys.artemis.datastructures.operations.Attestation;\n+import tech.pegasys.artemis.service.serviceutils.Service;\n+import tech.pegasys.artemis.statetransition.StateTransition;\n+import tech.pegasys.artemis.statetransition.attestation.AttestationProcessingResult;\n+import tech.pegasys.artemis.statetransition.attestation.ForkChoiceAttestationProcessor;\n+import tech.pegasys.artemis.statetransition.events.BlockImportedEvent;\n+import tech.pegasys.artemis.statetransition.events.ProcessedAggregateEvent;\n+import tech.pegasys.artemis.storage.ChainStorageClient;\n+import tech.pegasys.artemis.storage.events.SlotEvent;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+\n+public class AttestationManager extends Service {\n+  private static final Logger LOG = LogManager.getLogger();\n+  private final EventBus eventBus;\n+  private final ForkChoiceAttestationProcessor attestationProcessor;\n+  private final PendingPool<Attestation> pendingAttestations;\n+  private final FutureItems<Attestation> futureAttestations;\n+\n+  AttestationManager(\n+      final EventBus eventBus,\n+      final ForkChoiceAttestationProcessor attestationProcessor,\n+      final PendingPool<Attestation> pendingAttestations,\n+      final FutureItems<Attestation> futureAttestations) {\n+    this.eventBus = eventBus;\n+    this.attestationProcessor = attestationProcessor;\n+    this.pendingAttestations = pendingAttestations;\n+    this.futureAttestations = futureAttestations;\n+  }\n+\n+  public static AttestationManager create(\n+      final EventBus eventBus, final ChainStorageClient storageClient) {\n+    final PendingPool<Attestation> pendingAttestations =\n+        PendingPool.createForAttestations(eventBus);\n+    final FutureItems<Attestation> futureAttestations =\n+        new FutureItems<>(Attestation::getEarliestSlotForProcessing);\n+    return new AttestationManager(\n+        eventBus,\n+        new ForkChoiceAttestationProcessor(storageClient, new StateTransition(false)),\n+        pendingAttestations,\n+        futureAttestations);\n+  }\n+\n+  @Subscribe\n+  @SuppressWarnings(\"unused\")\n+  private void onGossipedAttestation(final Attestation attestation) {\n+    processAttestation(attestation);\n+    // TODO: Should we post this if the attestation was invalid?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTEzODAxNA=="}, "originalCommit": {"oid": "2b055528045a7915e996a1e5bf466edc0c05efea"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI4MTQ2ODE5OnYy", "diffSide": "RIGHT", "path": "sync/src/test/java/tech/pegasys/artemis/sync/AttestationManagerTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQxNzozNjoxMFrOFgCvWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMVQyMjo1MDoxM1rOFgLcWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE0MzY0Mg==", "bodyText": "Should we add a couple of tests to make sure that ProcessedAggregateEvent and ProcessedAttestationEvent events are being posted when the corresponding aggregation / attestation is successfully processed?", "url": "https://github.com/ConsenSys/teku/pull/1099#discussion_r369143642", "createdAt": "2020-01-21T17:36:10Z", "author": {"login": "mbaxter"}, "path": "sync/src/test/java/tech/pegasys/artemis/sync/AttestationManagerTest.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.sync;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.when;\n+import static tech.pegasys.artemis.statetransition.attestation.AttestationProcessingResult.FAILED_NOT_FROM_PAST;\n+import static tech.pegasys.artemis.statetransition.attestation.AttestationProcessingResult.FAILED_UNKNOWN_TARGET;\n+import static tech.pegasys.artemis.statetransition.attestation.AttestationProcessingResult.SUCCESSFUL;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.primitives.UnsignedLong;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.datastructures.operations.Attestation;\n+import tech.pegasys.artemis.datastructures.operations.AttestationData;\n+import tech.pegasys.artemis.datastructures.state.Checkpoint;\n+import tech.pegasys.artemis.datastructures.util.DataStructureUtil;\n+import tech.pegasys.artemis.statetransition.attestation.ForkChoiceAttestationProcessor;\n+import tech.pegasys.artemis.statetransition.events.BlockImportedEvent;\n+import tech.pegasys.artemis.storage.events.SlotEvent;\n+import tech.pegasys.artemis.util.SSZTypes.Bitlist;\n+import tech.pegasys.artemis.util.bls.BLSSignature;\n+\n+class AttestationManagerTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2b055528045a7915e996a1e5bf466edc0c05efea"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTI4NjIzMg==", "bodyText": "Added basic tests and will flesh out the corner cases in the next PR which fixes them to do the right thing. :)", "url": "https://github.com/ConsenSys/teku/pull/1099#discussion_r369286232", "createdAt": "2020-01-21T22:50:13Z", "author": {"login": "ajsutton"}, "path": "sync/src/test/java/tech/pegasys/artemis/sync/AttestationManagerTest.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.sync;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.when;\n+import static tech.pegasys.artemis.statetransition.attestation.AttestationProcessingResult.FAILED_NOT_FROM_PAST;\n+import static tech.pegasys.artemis.statetransition.attestation.AttestationProcessingResult.FAILED_UNKNOWN_TARGET;\n+import static tech.pegasys.artemis.statetransition.attestation.AttestationProcessingResult.SUCCESSFUL;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.primitives.UnsignedLong;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.datastructures.operations.Attestation;\n+import tech.pegasys.artemis.datastructures.operations.AttestationData;\n+import tech.pegasys.artemis.datastructures.state.Checkpoint;\n+import tech.pegasys.artemis.datastructures.util.DataStructureUtil;\n+import tech.pegasys.artemis.statetransition.attestation.ForkChoiceAttestationProcessor;\n+import tech.pegasys.artemis.statetransition.events.BlockImportedEvent;\n+import tech.pegasys.artemis.storage.events.SlotEvent;\n+import tech.pegasys.artemis.util.SSZTypes.Bitlist;\n+import tech.pegasys.artemis.util.bls.BLSSignature;\n+\n+class AttestationManagerTest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTE0MzY0Mg=="}, "originalCommit": {"oid": "2b055528045a7915e996a1e5bf466edc0c05efea"}, "originalPosition": 43}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2774, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}