{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDYyODU3ODA4", "number": 2501, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMzowNDoxM1rOEVMp0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwMDoyODowOVrOEVNq2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNjYyODY1OnYy", "diffSide": "RIGHT", "path": "data/provider/src/main/java/tech/pegasys/teku/api/ChainDataProvider.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQyMzowNDoxM1rOG70agQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQyMzozMTowM1rOG8eDUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM3NzkyMQ==", "bodyText": "This check means that if we have a span of time where no blocks are produced, we won't be able to query committee information for epochs ahead of the epoch after the latest block (from the REST API).  Is this right?", "url": "https://github.com/ConsenSys/teku/pull/2501#discussion_r465377921", "createdAt": "2020-08-04T23:04:13Z", "author": {"login": "mbaxter"}, "path": "data/provider/src/main/java/tech/pegasys/teku/api/ChainDataProvider.java", "diffHunk": "@@ -83,25 +81,22 @@ public GetForkResponse getForkInfo() {\n     if (!combinedChainDataClient.isChainDataFullyAvailable()) {\n       return chainUnavailable();\n     }\n-    final UnsignedLong committeesCalculatedAtEpoch = epoch.equals(ZERO) ? ZERO : epoch.minus(ONE);\n-    final UnsignedLong startingSlot = compute_start_slot_at_epoch(committeesCalculatedAtEpoch);\n-    final UnsignedLong slot = compute_start_slot_at_epoch(epoch);\n-\n-    // one epoch in future is available, beyond that cannot be calculated\n-    if (slot.compareTo(\n-            recentChainData.getBestSlot().plus(UnsignedLong.valueOf(Constants.SLOTS_PER_EPOCH)))\n-        > 0) {\n+\n+    final UnsignedLong earliestQueryableSlot =\n+        CommitteeUtil.getEarliestQueryableSlotForTargetEpoch(epoch);\n+    if (recentChainData.getBestSlot().compareTo(earliestQueryableSlot) < 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22967e863ee46c5670f19708ad0897ca98cb62e6"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQwMDkxOA==", "bodyText": "I think we now progress the best slot even if the slots are empty so this should work out ok.  Worth testing to be sure though.", "url": "https://github.com/ConsenSys/teku/pull/2501#discussion_r465400918", "createdAt": "2020-08-05T00:20:42Z", "author": {"login": "ajsutton"}, "path": "data/provider/src/main/java/tech/pegasys/teku/api/ChainDataProvider.java", "diffHunk": "@@ -83,25 +81,22 @@ public GetForkResponse getForkInfo() {\n     if (!combinedChainDataClient.isChainDataFullyAvailable()) {\n       return chainUnavailable();\n     }\n-    final UnsignedLong committeesCalculatedAtEpoch = epoch.equals(ZERO) ? ZERO : epoch.minus(ONE);\n-    final UnsignedLong startingSlot = compute_start_slot_at_epoch(committeesCalculatedAtEpoch);\n-    final UnsignedLong slot = compute_start_slot_at_epoch(epoch);\n-\n-    // one epoch in future is available, beyond that cannot be calculated\n-    if (slot.compareTo(\n-            recentChainData.getBestSlot().plus(UnsignedLong.valueOf(Constants.SLOTS_PER_EPOCH)))\n-        > 0) {\n+\n+    final UnsignedLong earliestQueryableSlot =\n+        CommitteeUtil.getEarliestQueryableSlotForTargetEpoch(epoch);\n+    if (recentChainData.getBestSlot().compareTo(earliestQueryableSlot) < 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM3NzkyMQ=="}, "originalCommit": {"oid": "22967e863ee46c5670f19708ad0897ca98cb62e6"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgyNDg2Nw==", "bodyText": "The slot we pull is the slot from the head block, not the latest slot processed.  I think what we probably want to do here is return an empty result if we're syncing, or return an error if the slot is from the future. \ud83e\udd14", "url": "https://github.com/ConsenSys/teku/pull/2501#discussion_r465824867", "createdAt": "2020-08-05T15:47:00Z", "author": {"login": "mbaxter"}, "path": "data/provider/src/main/java/tech/pegasys/teku/api/ChainDataProvider.java", "diffHunk": "@@ -83,25 +81,22 @@ public GetForkResponse getForkInfo() {\n     if (!combinedChainDataClient.isChainDataFullyAvailable()) {\n       return chainUnavailable();\n     }\n-    final UnsignedLong committeesCalculatedAtEpoch = epoch.equals(ZERO) ? ZERO : epoch.minus(ONE);\n-    final UnsignedLong startingSlot = compute_start_slot_at_epoch(committeesCalculatedAtEpoch);\n-    final UnsignedLong slot = compute_start_slot_at_epoch(epoch);\n-\n-    // one epoch in future is available, beyond that cannot be calculated\n-    if (slot.compareTo(\n-            recentChainData.getBestSlot().plus(UnsignedLong.valueOf(Constants.SLOTS_PER_EPOCH)))\n-        > 0) {\n+\n+    final UnsignedLong earliestQueryableSlot =\n+        CommitteeUtil.getEarliestQueryableSlotForTargetEpoch(epoch);\n+    if (recentChainData.getBestSlot().compareTo(earliestQueryableSlot) < 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM3NzkyMQ=="}, "originalCommit": {"oid": "22967e863ee46c5670f19708ad0897ca98cb62e6"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA2MDExNA==", "bodyText": "Hmm, you'er right but we do track the actual best slot - updateBestBlock is called with the nodeSlot even if the slot was empty to ensure we treat It as a reorg if we later import blocks at those slots.  So if getBestSlot (or possibly a new method) returned chainHead.getSlot() we'd get the current slot regardless of any empty slots.", "url": "https://github.com/ConsenSys/teku/pull/2501#discussion_r466060114", "createdAt": "2020-08-05T23:31:03Z", "author": {"login": "ajsutton"}, "path": "data/provider/src/main/java/tech/pegasys/teku/api/ChainDataProvider.java", "diffHunk": "@@ -83,25 +81,22 @@ public GetForkResponse getForkInfo() {\n     if (!combinedChainDataClient.isChainDataFullyAvailable()) {\n       return chainUnavailable();\n     }\n-    final UnsignedLong committeesCalculatedAtEpoch = epoch.equals(ZERO) ? ZERO : epoch.minus(ONE);\n-    final UnsignedLong startingSlot = compute_start_slot_at_epoch(committeesCalculatedAtEpoch);\n-    final UnsignedLong slot = compute_start_slot_at_epoch(epoch);\n-\n-    // one epoch in future is available, beyond that cannot be calculated\n-    if (slot.compareTo(\n-            recentChainData.getBestSlot().plus(UnsignedLong.valueOf(Constants.SLOTS_PER_EPOCH)))\n-        > 0) {\n+\n+    final UnsignedLong earliestQueryableSlot =\n+        CommitteeUtil.getEarliestQueryableSlotForTargetEpoch(epoch);\n+    if (recentChainData.getBestSlot().compareTo(earliestQueryableSlot) < 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTM3NzkyMQ=="}, "originalCommit": {"oid": "22967e863ee46c5670f19708ad0897ca98cb62e6"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNjc5NTE1OnYy", "diffSide": "RIGHT", "path": "ethereum/datastructures/src/main/java/tech/pegasys/teku/datastructures/state/CheckpointState.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwMDoyODowOVrOG718jQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQxNToyMTowMlrOG8OmVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQwMzAyMQ==", "bodyText": "This feels like a pretty expensive test to perform just to be defensive. I'm be tempted to omit it.", "url": "https://github.com/ConsenSys/teku/pull/2501#discussion_r465403021", "createdAt": "2020-08-05T00:28:09Z", "author": {"login": "ajsutton"}, "path": "ethereum/datastructures/src/main/java/tech/pegasys/teku/datastructures/state/CheckpointState.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.datastructures.state;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.base.MoreObjects;\n+import java.util.Objects;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.datastructures.blocks.BeaconBlockHeader;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+\n+public class CheckpointState {\n+\n+  private final Checkpoint checkpoint;\n+  private final SignedBeaconBlock block;\n+  private final BeaconState state;\n+\n+  public CheckpointState(\n+      final Checkpoint checkpoint, final SignedBeaconBlock block, final BeaconState state) {\n+    checkNotNull(checkpoint);\n+    checkNotNull(block);\n+    checkNotNull(state);\n+    checkArgument(checkpoint.getRoot().equals(block.getRoot()), \"Block must match checkpoint root\");\n+    checkArgument(\n+        state.getSlot().equals(checkpoint.getEpochStartSlot()),\n+        \"State must be advanced to checkpoint epoch boundary slot\");\n+    validateState(checkpoint, state);\n+\n+    this.checkpoint = checkpoint;\n+    this.block = block;\n+    this.state = state;\n+  }\n+\n+  private static void validateState(final Checkpoint checkpoint, final BeaconState state) {\n+    final Bytes32 blockRootFromState = deriveBlockHeaderFromState(state).hash_tree_root();\n+    checkArgument(\n+        blockRootFromState.equals(checkpoint.getRoot()), \"State must derive from checkpoint block\");\n+  }\n+\n+  private static BeaconBlockHeader deriveBlockHeaderFromState(final BeaconState state) {\n+    BeaconBlockHeader latestHeader = state.getLatest_block_header();\n+\n+    if (latestHeader.getState_root().isZero()) {\n+      // If the state root is empty, replace it with the current state root\n+      final Bytes32 stateRoot = state.hash_tree_root();\n+      latestHeader =\n+          new BeaconBlockHeader(\n+              latestHeader.getSlot(),\n+              latestHeader.getProposer_index(),\n+              latestHeader.getParent_root(),\n+              stateRoot,\n+              latestHeader.getBody_root());\n+    }\n+\n+    return latestHeader;\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1756bd1619b7fc6c5ae9db990a0e6baf262e0ac4"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgwNjkzNA==", "bodyText": "yeah - I think I got a little carried away trying to figure out how to validate this.  probably not worth including.", "url": "https://github.com/ConsenSys/teku/pull/2501#discussion_r465806934", "createdAt": "2020-08-05T15:21:02Z", "author": {"login": "mbaxter"}, "path": "ethereum/datastructures/src/main/java/tech/pegasys/teku/datastructures/state/CheckpointState.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.datastructures.state;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.base.MoreObjects;\n+import java.util.Objects;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.datastructures.blocks.BeaconBlockHeader;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+\n+public class CheckpointState {\n+\n+  private final Checkpoint checkpoint;\n+  private final SignedBeaconBlock block;\n+  private final BeaconState state;\n+\n+  public CheckpointState(\n+      final Checkpoint checkpoint, final SignedBeaconBlock block, final BeaconState state) {\n+    checkNotNull(checkpoint);\n+    checkNotNull(block);\n+    checkNotNull(state);\n+    checkArgument(checkpoint.getRoot().equals(block.getRoot()), \"Block must match checkpoint root\");\n+    checkArgument(\n+        state.getSlot().equals(checkpoint.getEpochStartSlot()),\n+        \"State must be advanced to checkpoint epoch boundary slot\");\n+    validateState(checkpoint, state);\n+\n+    this.checkpoint = checkpoint;\n+    this.block = block;\n+    this.state = state;\n+  }\n+\n+  private static void validateState(final Checkpoint checkpoint, final BeaconState state) {\n+    final Bytes32 blockRootFromState = deriveBlockHeaderFromState(state).hash_tree_root();\n+    checkArgument(\n+        blockRootFromState.equals(checkpoint.getRoot()), \"State must derive from checkpoint block\");\n+  }\n+\n+  private static BeaconBlockHeader deriveBlockHeaderFromState(final BeaconState state) {\n+    BeaconBlockHeader latestHeader = state.getLatest_block_header();\n+\n+    if (latestHeader.getState_root().isZero()) {\n+      // If the state root is empty, replace it with the current state root\n+      final Bytes32 stateRoot = state.hash_tree_root();\n+      latestHeader =\n+          new BeaconBlockHeader(\n+              latestHeader.getSlot(),\n+              latestHeader.getProposer_index(),\n+              latestHeader.getParent_root(),\n+              stateRoot,\n+              latestHeader.getBody_root());\n+    }\n+\n+    return latestHeader;\n+  }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQwMzAyMQ=="}, "originalCommit": {"oid": "1756bd1619b7fc6c5ae9db990a0e6baf262e0ac4"}, "originalPosition": 69}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3454, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}