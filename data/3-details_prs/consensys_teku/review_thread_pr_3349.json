{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTMxMjk2NjM2", "number": 3349, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQyMzowNzowMFrOE_2R2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQyMzowNzowMFrOE_2R2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1Mzg1MDQ4OnYy", "diffSide": "RIGHT", "path": "pow/src/main/java/tech/pegasys/teku/pow/MinimumGenesisTimeBlockFinder.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQyMzowNzowMFrOH9x6fw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wM1QxODo0OTozNVrOH-r6rA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDU0Mjk3NQ==", "bodyText": "This is the approach we talked about using - but I'm not sure it actually makes a lot of sense to search one by one through the ancestors.  I suppose it's possible that some historical blocks were filled in as the binary search runs, but it's also possible we spend a lot of time walking back through ancestors and don't find our target block.\nThoughts?", "url": "https://github.com/ConsenSys/teku/pull/3349#discussion_r534542975", "createdAt": "2020-12-02T23:07:00Z", "author": {"login": "mbaxter"}, "path": "pow/src/main/java/tech/pegasys/teku/pow/MinimumGenesisTimeBlockFinder.java", "diffHunk": "@@ -52,7 +60,93 @@ public MinimumGenesisTimeBlockFinder(\n   public SafeFuture<EthBlock.Block> findMinGenesisTimeBlockInHistory(\n       final BigInteger headBlockNumber) {\n     return binarySearchLoop(\n-        new SearchContext(eth1DepositContractDeployBlock.orElse(ZERO), headBlockNumber));\n+            new SearchContext(eth1DepositContractDeployBlock.orElse(ZERO), headBlockNumber))\n+        .thenCompose(this::confirmOrFindMinGenesisBlock);\n+  }\n+\n+  /**\n+   * The binary search may return a block that is too new (if historical blocks are unavailable\n+   * during the search), so walk back though chain to confirm or else pull the correct min genesis\n+   * block.\n+   *\n+   * @param candidateMinGenesisBlock A candidate block that may be the min genesis block\n+   * @return The confirmed min genesis block\n+   */\n+  @VisibleForTesting\n+  SafeFuture<EthBlock.Block> confirmOrFindMinGenesisBlock(\n+      final EthBlock.Block candidateMinGenesisBlock) {\n+    assertBlockIsAtOrAfterMinGenesis(candidateMinGenesisBlock);\n+    if (blockIsAtMinimalMinGenesisPosition(candidateMinGenesisBlock)) {\n+      // We've found min genesis\n+      traceWithBlock(\n+          \"Confirmed minimum genesis block at minimal position: \", candidateMinGenesisBlock);\n+      return SafeFuture.completedFuture(candidateMinGenesisBlock);\n+    }\n+\n+    traceWithBlock(\n+        \"Confirm minimum genesis block retrieved via binary search: \", candidateMinGenesisBlock);\n+    final SafeFuture<EthBlock.Block> minGenesisFuture = new SafeFuture<>();\n+\n+    final AtomicReference<EthBlock.Block> currentMinGenesisCandidate =\n+        new AtomicReference<>(candidateMinGenesisBlock);\n+    final AtomicInteger examinedAncestorsCount = new AtomicInteger(0);\n+    SafeFuture.asyncDoWhile(\n+            () ->\n+                eth1Provider\n+                    .getEth1BlockWithRetry(\n+                        currentMinGenesisCandidate.get().getParentHash(), Duration.ofSeconds(5), 3)\n+                    .thenApply(\n+                        parent -> {\n+                          examinedAncestorsCount.incrementAndGet();\n+                          if (blockIsPriorToMinGenesis(parent)) {\n+                            // We've confirmed the current candidate is at the boundary\n+                            traceWithBlock(\n+                                \"Confirmed min genesis block: \", currentMinGenesisCandidate.get());\n+                            minGenesisFuture.complete(currentMinGenesisCandidate.get());\n+                            return false;\n+                          } else if (blockIsAtMinGenesis(parent)) {\n+                            // We've found the min genesis block\n+                            traceWithBlock(\n+                                \"Confirmed min genesis block at exact genesis time: \", parent);\n+                            minGenesisFuture.complete(parent);\n+                            return false;\n+                          } else {\n+                            // The parent block is after min genesis\n+                            // Keep searching through ancestors up to our limit", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f375b72eee8da34ce3a3b174cf6bcb1cb194938e"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDU0OTQ3NQ==", "bodyText": "Yeah it is an awful lot of extra code for a very small corner case.  It only matters if we don't already have the genesis state baked in and the eth1 node doesn't have enough history to get back to the min genesis block but then it wouldn't have the deposit events anyway and we'd crash because of the deposit event ordering checks.\nI think its probably worth just dropping this - keep the assumption that if we can't get a block then min genesis time must be after that but don't bother walking back to verify it was right.", "url": "https://github.com/ConsenSys/teku/pull/3349#discussion_r534549475", "createdAt": "2020-12-02T23:20:53Z", "author": {"login": "ajsutton"}, "path": "pow/src/main/java/tech/pegasys/teku/pow/MinimumGenesisTimeBlockFinder.java", "diffHunk": "@@ -52,7 +60,93 @@ public MinimumGenesisTimeBlockFinder(\n   public SafeFuture<EthBlock.Block> findMinGenesisTimeBlockInHistory(\n       final BigInteger headBlockNumber) {\n     return binarySearchLoop(\n-        new SearchContext(eth1DepositContractDeployBlock.orElse(ZERO), headBlockNumber));\n+            new SearchContext(eth1DepositContractDeployBlock.orElse(ZERO), headBlockNumber))\n+        .thenCompose(this::confirmOrFindMinGenesisBlock);\n+  }\n+\n+  /**\n+   * The binary search may return a block that is too new (if historical blocks are unavailable\n+   * during the search), so walk back though chain to confirm or else pull the correct min genesis\n+   * block.\n+   *\n+   * @param candidateMinGenesisBlock A candidate block that may be the min genesis block\n+   * @return The confirmed min genesis block\n+   */\n+  @VisibleForTesting\n+  SafeFuture<EthBlock.Block> confirmOrFindMinGenesisBlock(\n+      final EthBlock.Block candidateMinGenesisBlock) {\n+    assertBlockIsAtOrAfterMinGenesis(candidateMinGenesisBlock);\n+    if (blockIsAtMinimalMinGenesisPosition(candidateMinGenesisBlock)) {\n+      // We've found min genesis\n+      traceWithBlock(\n+          \"Confirmed minimum genesis block at minimal position: \", candidateMinGenesisBlock);\n+      return SafeFuture.completedFuture(candidateMinGenesisBlock);\n+    }\n+\n+    traceWithBlock(\n+        \"Confirm minimum genesis block retrieved via binary search: \", candidateMinGenesisBlock);\n+    final SafeFuture<EthBlock.Block> minGenesisFuture = new SafeFuture<>();\n+\n+    final AtomicReference<EthBlock.Block> currentMinGenesisCandidate =\n+        new AtomicReference<>(candidateMinGenesisBlock);\n+    final AtomicInteger examinedAncestorsCount = new AtomicInteger(0);\n+    SafeFuture.asyncDoWhile(\n+            () ->\n+                eth1Provider\n+                    .getEth1BlockWithRetry(\n+                        currentMinGenesisCandidate.get().getParentHash(), Duration.ofSeconds(5), 3)\n+                    .thenApply(\n+                        parent -> {\n+                          examinedAncestorsCount.incrementAndGet();\n+                          if (blockIsPriorToMinGenesis(parent)) {\n+                            // We've confirmed the current candidate is at the boundary\n+                            traceWithBlock(\n+                                \"Confirmed min genesis block: \", currentMinGenesisCandidate.get());\n+                            minGenesisFuture.complete(currentMinGenesisCandidate.get());\n+                            return false;\n+                          } else if (blockIsAtMinGenesis(parent)) {\n+                            // We've found the min genesis block\n+                            traceWithBlock(\n+                                \"Confirmed min genesis block at exact genesis time: \", parent);\n+                            minGenesisFuture.complete(parent);\n+                            return false;\n+                          } else {\n+                            // The parent block is after min genesis\n+                            // Keep searching through ancestors up to our limit", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDU0Mjk3NQ=="}, "originalCommit": {"oid": "f375b72eee8da34ce3a3b174cf6bcb1cb194938e"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQ5MzI5Mg==", "bodyText": "I kept a single check to look up the parent block, but dropped the ancestor search which cut out a good chunk of code.", "url": "https://github.com/ConsenSys/teku/pull/3349#discussion_r535493292", "createdAt": "2020-12-03T18:49:35Z", "author": {"login": "mbaxter"}, "path": "pow/src/main/java/tech/pegasys/teku/pow/MinimumGenesisTimeBlockFinder.java", "diffHunk": "@@ -52,7 +60,93 @@ public MinimumGenesisTimeBlockFinder(\n   public SafeFuture<EthBlock.Block> findMinGenesisTimeBlockInHistory(\n       final BigInteger headBlockNumber) {\n     return binarySearchLoop(\n-        new SearchContext(eth1DepositContractDeployBlock.orElse(ZERO), headBlockNumber));\n+            new SearchContext(eth1DepositContractDeployBlock.orElse(ZERO), headBlockNumber))\n+        .thenCompose(this::confirmOrFindMinGenesisBlock);\n+  }\n+\n+  /**\n+   * The binary search may return a block that is too new (if historical blocks are unavailable\n+   * during the search), so walk back though chain to confirm or else pull the correct min genesis\n+   * block.\n+   *\n+   * @param candidateMinGenesisBlock A candidate block that may be the min genesis block\n+   * @return The confirmed min genesis block\n+   */\n+  @VisibleForTesting\n+  SafeFuture<EthBlock.Block> confirmOrFindMinGenesisBlock(\n+      final EthBlock.Block candidateMinGenesisBlock) {\n+    assertBlockIsAtOrAfterMinGenesis(candidateMinGenesisBlock);\n+    if (blockIsAtMinimalMinGenesisPosition(candidateMinGenesisBlock)) {\n+      // We've found min genesis\n+      traceWithBlock(\n+          \"Confirmed minimum genesis block at minimal position: \", candidateMinGenesisBlock);\n+      return SafeFuture.completedFuture(candidateMinGenesisBlock);\n+    }\n+\n+    traceWithBlock(\n+        \"Confirm minimum genesis block retrieved via binary search: \", candidateMinGenesisBlock);\n+    final SafeFuture<EthBlock.Block> minGenesisFuture = new SafeFuture<>();\n+\n+    final AtomicReference<EthBlock.Block> currentMinGenesisCandidate =\n+        new AtomicReference<>(candidateMinGenesisBlock);\n+    final AtomicInteger examinedAncestorsCount = new AtomicInteger(0);\n+    SafeFuture.asyncDoWhile(\n+            () ->\n+                eth1Provider\n+                    .getEth1BlockWithRetry(\n+                        currentMinGenesisCandidate.get().getParentHash(), Duration.ofSeconds(5), 3)\n+                    .thenApply(\n+                        parent -> {\n+                          examinedAncestorsCount.incrementAndGet();\n+                          if (blockIsPriorToMinGenesis(parent)) {\n+                            // We've confirmed the current candidate is at the boundary\n+                            traceWithBlock(\n+                                \"Confirmed min genesis block: \", currentMinGenesisCandidate.get());\n+                            minGenesisFuture.complete(currentMinGenesisCandidate.get());\n+                            return false;\n+                          } else if (blockIsAtMinGenesis(parent)) {\n+                            // We've found the min genesis block\n+                            traceWithBlock(\n+                                \"Confirmed min genesis block at exact genesis time: \", parent);\n+                            minGenesisFuture.complete(parent);\n+                            return false;\n+                          } else {\n+                            // The parent block is after min genesis\n+                            // Keep searching through ancestors up to our limit", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDU0Mjk3NQ=="}, "originalCommit": {"oid": "f375b72eee8da34ce3a3b174cf6bcb1cb194938e"}, "originalPosition": 90}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2909, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}