{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg5NTIxNjAx", "number": 2825, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNzoxNTowNlrOElw0sw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNzoxNTowNlrOElw0sw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA4MDMyNjkxOnYy", "diffSide": "RIGHT", "path": "ethereum/weaksubjectivity/src/main/java/tech/pegasys/teku/weaksubjectivity/WeakSubjectivityValidator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxNzoxNTowNlrOHVav0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yMVQxOTozMTo0OFrOHVfebQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjIyMDM2OQ==", "bodyText": "nit: It might be nice to log a warning if the chain moved passed the wsCheckpoint since we can't verify it anymore.", "url": "https://github.com/ConsenSys/teku/pull/2825#discussion_r492220369", "createdAt": "2020-09-21T17:15:06Z", "author": {"login": "cemozerr"}, "path": "ethereum/weaksubjectivity/src/main/java/tech/pegasys/teku/weaksubjectivity/WeakSubjectivityValidator.java", "diffHunk": "@@ -68,6 +110,35 @@ public void validateLatestFinalizedCheckpoint(\n     }\n   }\n \n+  public boolean isBlockValid(\n+      final SignedBeaconBlock block, ForkChoiceStrategy forkChoiceStrategy) {\n+    if (maybeWsCheckpoint.isEmpty()) {\n+      return true;\n+    }\n+    final Checkpoint wsCheckpoint = maybeWsCheckpoint.get();\n+\n+    UInt64 blockEpoch = compute_epoch_at_slot(block.getSlot());\n+    boolean blockAtEpochBoundary = compute_start_slot_at_epoch(blockEpoch).equals(block.getSlot());\n+    if (isWSCheckpointEpoch(blockEpoch) && blockAtEpochBoundary) {\n+      // Block is at ws checkpoint slot - so it must match the ws checkpoint block\n+      return isWSCheckpointBlock(block);\n+    } else if (isWSCheckpointBlock(block)) {\n+      // The block is the checkpoint\n+      return true;\n+    } else if (blockEpoch.isGreaterThanOrEqualTo(wsCheckpoint.getEpoch())) {\n+      // If the block is at or past the checkpoint, the wsCheckpoint must be an ancestor\n+      final Optional<Bytes32> ancestor =\n+          get_ancestor(\n+              forkChoiceStrategy, block.getParent_root(), wsCheckpoint.getEpochStartSlot());\n+      // If ancestor is not present, the chain must have moved passed the wsCheckpoint\n+      return ancestor.map(a -> a.equals(wsCheckpoint.getRoot())).orElse(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52b4055a19665fd9c3c9fe8a28fd441a712ba3b1"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI5NzgzNw==", "bodyText": "Yeah - the thought crossed my mind as well.  But we should be gating all imports with these checks, and validating consistency with the wsCheckpoint at startup, which should prevent us from following an inconsistent chain.  The only way we hit this is if we don't have the parent of the block being imported (which will get validated later), or the wsCheckpoint has fallen off behind the latest finalized block. Given that this is an expected case and could get really noisey, I thought it was best to just move on here.", "url": "https://github.com/ConsenSys/teku/pull/2825#discussion_r492297837", "createdAt": "2020-09-21T19:31:48Z", "author": {"login": "mbaxter"}, "path": "ethereum/weaksubjectivity/src/main/java/tech/pegasys/teku/weaksubjectivity/WeakSubjectivityValidator.java", "diffHunk": "@@ -68,6 +110,35 @@ public void validateLatestFinalizedCheckpoint(\n     }\n   }\n \n+  public boolean isBlockValid(\n+      final SignedBeaconBlock block, ForkChoiceStrategy forkChoiceStrategy) {\n+    if (maybeWsCheckpoint.isEmpty()) {\n+      return true;\n+    }\n+    final Checkpoint wsCheckpoint = maybeWsCheckpoint.get();\n+\n+    UInt64 blockEpoch = compute_epoch_at_slot(block.getSlot());\n+    boolean blockAtEpochBoundary = compute_start_slot_at_epoch(blockEpoch).equals(block.getSlot());\n+    if (isWSCheckpointEpoch(blockEpoch) && blockAtEpochBoundary) {\n+      // Block is at ws checkpoint slot - so it must match the ws checkpoint block\n+      return isWSCheckpointBlock(block);\n+    } else if (isWSCheckpointBlock(block)) {\n+      // The block is the checkpoint\n+      return true;\n+    } else if (blockEpoch.isGreaterThanOrEqualTo(wsCheckpoint.getEpoch())) {\n+      // If the block is at or past the checkpoint, the wsCheckpoint must be an ancestor\n+      final Optional<Bytes32> ancestor =\n+          get_ancestor(\n+              forkChoiceStrategy, block.getParent_root(), wsCheckpoint.getEpochStartSlot());\n+      // If ancestor is not present, the chain must have moved passed the wsCheckpoint\n+      return ancestor.map(a -> a.equals(wsCheckpoint.getRoot())).orElse(true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjIyMDM2OQ=="}, "originalCommit": {"oid": "52b4055a19665fd9c3c9fe8a28fd441a712ba3b1"}, "originalPosition": 122}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3273, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}