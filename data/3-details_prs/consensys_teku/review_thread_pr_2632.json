{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDcwOTA5MTA5", "number": 2632, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQyMzo1MTo1OVrOEavmJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQyMjozMTozOFrOEbw6Wg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2NDc4MjQ0OnYy", "diffSide": "RIGHT", "path": "ethereum/datastructures/src/main/java/tech/pegasys/teku/datastructures/attestation/ValidateableAttestation.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQyMzo1MTo1OVrOHEW9VQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQwNzo1NjozM1rOHEgtQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMzMjUwMQ==", "bodyText": "I think we should simplify this further to just store the randao rather than spending time calculating the entire shuffling seed.  If the randao matches, the shuffling seed will as well.  So just:\nget_randao_mix(state, compute_epoch_at_slot(attestation.getData().getSlot()))", "url": "https://github.com/ConsenSys/teku/pull/2632#discussion_r474332501", "createdAt": "2020-08-20T23:51:59Z", "author": {"login": "ajsutton"}, "path": "ethereum/datastructures/src/main/java/tech/pegasys/teku/datastructures/attestation/ValidateableAttestation.java", "diffHunk": "@@ -50,15 +56,37 @@ private ValidateableAttestation(\n     this.hashTreeRoot = Suppliers.memoize(attestation::hash_tree_root);\n   }\n \n+  public Optional<IndexedAttestation> getMaybeIndexedAttestation() {\n+    return maybeIndexedAttestation;\n+  }\n+\n   public IndexedAttestation getIndexedAttestation() {\n     return maybeIndexedAttestation.orElseThrow(\n         () ->\n             new UnsupportedOperationException(\n                 \"ValidateableAttestation does not have an IndexedAttestation yet.\"));\n   }\n \n-  public void setIndexedAttestation(IndexedAttestation maybeIndexedAttestation) {\n-    this.maybeIndexedAttestation = Optional.of(maybeIndexedAttestation);\n+  public Optional<Bytes32> getMaybeCommitteeShufflingSeed() {\n+    return maybeCommitteeShufflingSeed;\n+  }\n+\n+  public Bytes32 getCommitteeShufflingSeed() {\n+    return maybeCommitteeShufflingSeed.orElseThrow(\n+        () ->\n+            new UnsupportedOperationException(\n+                \"ValidateableAttestation does not have a committee shuffling seed yet.\"));\n+  }\n+\n+  public void setIndexedAttestation(IndexedAttestation indexedAttestation) {\n+    this.maybeIndexedAttestation = Optional.of(indexedAttestation);\n+  }\n+\n+  public void saveCommitteeShufflingSeed(BeaconState state) {\n+    Bytes32 committeeShufflingSeed =\n+        get_seed(\n+            state, compute_epoch_at_slot(attestation.getData().getSlot()), DOMAIN_BEACON_ATTESTER);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5eabee0d97e6ed77d5288232100bc2d7680040a"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMzNzA2MQ==", "bodyText": "Sorry, this is wrong - we need to do the same randaoIndex calculation as in get_seed so worth extracting that bit of get_seed as a method we can reuse but it effectively becomes:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Bytes32 committeeShufflingSeed =\n          \n          \n            \n                    get_seed(\n          \n          \n            \n                        state, compute_epoch_at_slot(attestation.getData().getSlot()), DOMAIN_BEACON_ATTESTER);\n          \n          \n            \n                UInt64 epoch = compute_epoch_at_slot(attestation.getData().getSlot());\n          \n          \n            \n                UInt64 randaoIndex = epoch.plus(EPOCHS_PER_HISTORICAL_VECTOR - MIN_SEED_LOOKAHEAD - 1);\n          \n          \n            \n                return get_randao_mix(state, randaoIndex);", "url": "https://github.com/ConsenSys/teku/pull/2632#discussion_r474337061", "createdAt": "2020-08-21T00:08:43Z", "author": {"login": "ajsutton"}, "path": "ethereum/datastructures/src/main/java/tech/pegasys/teku/datastructures/attestation/ValidateableAttestation.java", "diffHunk": "@@ -50,15 +56,37 @@ private ValidateableAttestation(\n     this.hashTreeRoot = Suppliers.memoize(attestation::hash_tree_root);\n   }\n \n+  public Optional<IndexedAttestation> getMaybeIndexedAttestation() {\n+    return maybeIndexedAttestation;\n+  }\n+\n   public IndexedAttestation getIndexedAttestation() {\n     return maybeIndexedAttestation.orElseThrow(\n         () ->\n             new UnsupportedOperationException(\n                 \"ValidateableAttestation does not have an IndexedAttestation yet.\"));\n   }\n \n-  public void setIndexedAttestation(IndexedAttestation maybeIndexedAttestation) {\n-    this.maybeIndexedAttestation = Optional.of(maybeIndexedAttestation);\n+  public Optional<Bytes32> getMaybeCommitteeShufflingSeed() {\n+    return maybeCommitteeShufflingSeed;\n+  }\n+\n+  public Bytes32 getCommitteeShufflingSeed() {\n+    return maybeCommitteeShufflingSeed.orElseThrow(\n+        () ->\n+            new UnsupportedOperationException(\n+                \"ValidateableAttestation does not have a committee shuffling seed yet.\"));\n+  }\n+\n+  public void setIndexedAttestation(IndexedAttestation indexedAttestation) {\n+    this.maybeIndexedAttestation = Optional.of(indexedAttestation);\n+  }\n+\n+  public void saveCommitteeShufflingSeed(BeaconState state) {\n+    Bytes32 committeeShufflingSeed =\n+        get_seed(\n+            state, compute_epoch_at_slot(attestation.getData().getSlot()), DOMAIN_BEACON_ATTESTER);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMzMjUwMQ=="}, "originalCommit": {"oid": "f5eabee0d97e6ed77d5288232100bc2d7680040a"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDM0MTA0Mw==", "bodyText": "Following conversation with Proto, sticking with seed probably does make sense - just make sure that we calculate the seed for the block only once, not once per attestation or group.", "url": "https://github.com/ConsenSys/teku/pull/2632#discussion_r474341043", "createdAt": "2020-08-21T00:22:54Z", "author": {"login": "ajsutton"}, "path": "ethereum/datastructures/src/main/java/tech/pegasys/teku/datastructures/attestation/ValidateableAttestation.java", "diffHunk": "@@ -50,15 +56,37 @@ private ValidateableAttestation(\n     this.hashTreeRoot = Suppliers.memoize(attestation::hash_tree_root);\n   }\n \n+  public Optional<IndexedAttestation> getMaybeIndexedAttestation() {\n+    return maybeIndexedAttestation;\n+  }\n+\n   public IndexedAttestation getIndexedAttestation() {\n     return maybeIndexedAttestation.orElseThrow(\n         () ->\n             new UnsupportedOperationException(\n                 \"ValidateableAttestation does not have an IndexedAttestation yet.\"));\n   }\n \n-  public void setIndexedAttestation(IndexedAttestation maybeIndexedAttestation) {\n-    this.maybeIndexedAttestation = Optional.of(maybeIndexedAttestation);\n+  public Optional<Bytes32> getMaybeCommitteeShufflingSeed() {\n+    return maybeCommitteeShufflingSeed;\n+  }\n+\n+  public Bytes32 getCommitteeShufflingSeed() {\n+    return maybeCommitteeShufflingSeed.orElseThrow(\n+        () ->\n+            new UnsupportedOperationException(\n+                \"ValidateableAttestation does not have a committee shuffling seed yet.\"));\n+  }\n+\n+  public void setIndexedAttestation(IndexedAttestation indexedAttestation) {\n+    this.maybeIndexedAttestation = Optional.of(indexedAttestation);\n+  }\n+\n+  public void saveCommitteeShufflingSeed(BeaconState state) {\n+    Bytes32 committeeShufflingSeed =\n+        get_seed(\n+            state, compute_epoch_at_slot(attestation.getData().getSlot()), DOMAIN_BEACON_ATTESTER);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMzMjUwMQ=="}, "originalCommit": {"oid": "f5eabee0d97e6ed77d5288232100bc2d7680040a"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ4OTU2OA==", "bodyText": "Makes sense to me.", "url": "https://github.com/ConsenSys/teku/pull/2632#discussion_r474489568", "createdAt": "2020-08-21T07:53:29Z", "author": {"login": "cemozerr"}, "path": "ethereum/datastructures/src/main/java/tech/pegasys/teku/datastructures/attestation/ValidateableAttestation.java", "diffHunk": "@@ -50,15 +56,37 @@ private ValidateableAttestation(\n     this.hashTreeRoot = Suppliers.memoize(attestation::hash_tree_root);\n   }\n \n+  public Optional<IndexedAttestation> getMaybeIndexedAttestation() {\n+    return maybeIndexedAttestation;\n+  }\n+\n   public IndexedAttestation getIndexedAttestation() {\n     return maybeIndexedAttestation.orElseThrow(\n         () ->\n             new UnsupportedOperationException(\n                 \"ValidateableAttestation does not have an IndexedAttestation yet.\"));\n   }\n \n-  public void setIndexedAttestation(IndexedAttestation maybeIndexedAttestation) {\n-    this.maybeIndexedAttestation = Optional.of(maybeIndexedAttestation);\n+  public Optional<Bytes32> getMaybeCommitteeShufflingSeed() {\n+    return maybeCommitteeShufflingSeed;\n+  }\n+\n+  public Bytes32 getCommitteeShufflingSeed() {\n+    return maybeCommitteeShufflingSeed.orElseThrow(\n+        () ->\n+            new UnsupportedOperationException(\n+                \"ValidateableAttestation does not have a committee shuffling seed yet.\"));\n+  }\n+\n+  public void setIndexedAttestation(IndexedAttestation indexedAttestation) {\n+    this.maybeIndexedAttestation = Optional.of(indexedAttestation);\n+  }\n+\n+  public void saveCommitteeShufflingSeed(BeaconState state) {\n+    Bytes32 committeeShufflingSeed =\n+        get_seed(\n+            state, compute_epoch_at_slot(attestation.getData().getSlot()), DOMAIN_BEACON_ATTESTER);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMzMjUwMQ=="}, "originalCommit": {"oid": "f5eabee0d97e6ed77d5288232100bc2d7680040a"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDQ5MjIyNA==", "bodyText": "Done.", "url": "https://github.com/ConsenSys/teku/pull/2632#discussion_r474492224", "createdAt": "2020-08-21T07:56:33Z", "author": {"login": "cemozerr"}, "path": "ethereum/datastructures/src/main/java/tech/pegasys/teku/datastructures/attestation/ValidateableAttestation.java", "diffHunk": "@@ -50,15 +56,37 @@ private ValidateableAttestation(\n     this.hashTreeRoot = Suppliers.memoize(attestation::hash_tree_root);\n   }\n \n+  public Optional<IndexedAttestation> getMaybeIndexedAttestation() {\n+    return maybeIndexedAttestation;\n+  }\n+\n   public IndexedAttestation getIndexedAttestation() {\n     return maybeIndexedAttestation.orElseThrow(\n         () ->\n             new UnsupportedOperationException(\n                 \"ValidateableAttestation does not have an IndexedAttestation yet.\"));\n   }\n \n-  public void setIndexedAttestation(IndexedAttestation maybeIndexedAttestation) {\n-    this.maybeIndexedAttestation = Optional.of(maybeIndexedAttestation);\n+  public Optional<Bytes32> getMaybeCommitteeShufflingSeed() {\n+    return maybeCommitteeShufflingSeed;\n+  }\n+\n+  public Bytes32 getCommitteeShufflingSeed() {\n+    return maybeCommitteeShufflingSeed.orElseThrow(\n+        () ->\n+            new UnsupportedOperationException(\n+                \"ValidateableAttestation does not have a committee shuffling seed yet.\"));\n+  }\n+\n+  public void setIndexedAttestation(IndexedAttestation indexedAttestation) {\n+    this.maybeIndexedAttestation = Optional.of(indexedAttestation);\n+  }\n+\n+  public void saveCommitteeShufflingSeed(BeaconState state) {\n+    Bytes32 committeeShufflingSeed =\n+        get_seed(\n+            state, compute_epoch_at_slot(attestation.getData().getSlot()), DOMAIN_BEACON_ATTESTER);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMzMjUwMQ=="}, "originalCommit": {"oid": "f5eabee0d97e6ed77d5288232100bc2d7680040a"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2NDc4ODAxOnYy", "diffSide": "RIGHT", "path": "ethereum/statetransition/src/main/java/tech/pegasys/teku/statetransition/attestation/AggregatingAttestationPool.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQyMzo1NTowOFrOHEXAqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQwODo1NTowOVrOHEj4-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMzMzM1NQ==", "bodyText": "We should apply this filter to the MatchingDataAttestationGroup as a whole rather than to every individual attestation.  If the attestation data matches and the signature is valid (both already checked), then either the entire group can be included, or the entire group can be excluded because they're all pointing to the same block root.\nAnd we should get the randao for the block's state prior to this stream so that we only get it once rather than for every group.", "url": "https://github.com/ConsenSys/teku/pull/2632#discussion_r474333355", "createdAt": "2020-08-20T23:55:08Z", "author": {"login": "ajsutton"}, "path": "ethereum/statetransition/src/main/java/tech/pegasys/teku/statetransition/attestation/AggregatingAttestationPool.java", "diffHunk": "@@ -126,11 +129,23 @@ public int getSize() {\n         .filter(group -> isValid(stateAtBlockSlot, group.getAttestationData()))\n         .flatMap(MatchingDataAttestationGroup::stream)\n         .limit(attestations.getMaxSize())\n+        .filter(attestation -> fromCorrectFork(stateAtBlockSlot, attestation))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5eabee0d97e6ed77d5288232100bc2d7680040a"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDU0NDA4MQ==", "bodyText": "The slot of the attestation data is important for the randao mix, so we have to get it for every group. Because different attestation groups might be from different epochs.\nMaybe if only attestation groups that point to the last two epochs are valid, we could get the randao mixes for those two epochs, and check if any groups randao mixes match those.", "url": "https://github.com/ConsenSys/teku/pull/2632#discussion_r474544081", "createdAt": "2020-08-21T08:54:50Z", "author": {"login": "cemozerr"}, "path": "ethereum/statetransition/src/main/java/tech/pegasys/teku/statetransition/attestation/AggregatingAttestationPool.java", "diffHunk": "@@ -126,11 +129,23 @@ public int getSize() {\n         .filter(group -> isValid(stateAtBlockSlot, group.getAttestationData()))\n         .flatMap(MatchingDataAttestationGroup::stream)\n         .limit(attestations.getMaxSize())\n+        .filter(attestation -> fromCorrectFork(stateAtBlockSlot, attestation))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMzMzM1NQ=="}, "originalCommit": {"oid": "f5eabee0d97e6ed77d5288232100bc2d7680040a"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDU0NDM3OQ==", "bodyText": "Applying the filter to the Group as a whole makes sense to me.", "url": "https://github.com/ConsenSys/teku/pull/2632#discussion_r474544379", "createdAt": "2020-08-21T08:55:09Z", "author": {"login": "cemozerr"}, "path": "ethereum/statetransition/src/main/java/tech/pegasys/teku/statetransition/attestation/AggregatingAttestationPool.java", "diffHunk": "@@ -126,11 +129,23 @@ public int getSize() {\n         .filter(group -> isValid(stateAtBlockSlot, group.getAttestationData()))\n         .flatMap(MatchingDataAttestationGroup::stream)\n         .limit(attestations.getMaxSize())\n+        .filter(attestation -> fromCorrectFork(stateAtBlockSlot, attestation))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMzMzM1NQ=="}, "originalCommit": {"oid": "f5eabee0d97e6ed77d5288232100bc2d7680040a"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2NDgwMDM3OnYy", "diffSide": "RIGHT", "path": "ethereum/statetransition/src/main/java/tech/pegasys/teku/statetransition/forkchoice/ForkChoice.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQwMDowMToyN1rOHEXHwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQwOTowODowNlrOHEknhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMzNTE3MA==", "bodyText": "This is going to destroy us performance-wise.   We will suddenly be missing checkpoint state caches a whole lot more.\nGiven that the target checkpoint must be for the epoch matching the slot we should continue using the state for the target state.  ie from ForkChoiceUtil.validateOnAttestation:\n    if (!target.getEpoch().equals(compute_epoch_at_slot(attestation.getData().getSlot()))) {\n      return AttestationProcessingResult.invalid(\"Attestation slot must be within specified epoch\");\n    }\n\nRemember that if the randao in the state we validate against was different to the one used when creating the attestation, the signature would be invalid because the committees wouldn't match up.  So we can safely validate against any state from one epoch prior to the attestation's slot.", "url": "https://github.com/ConsenSys/teku/pull/2632#discussion_r474335170", "createdAt": "2020-08-21T00:01:27Z", "author": {"login": "ajsutton"}, "path": "ethereum/statetransition/src/main/java/tech/pegasys/teku/statetransition/forkchoice/ForkChoice.java", "diffHunk": "@@ -136,15 +136,18 @@ private void processHead(Optional<UInt64> nodeSlot) {\n   public SafeFuture<AttestationProcessingResult> onAttestation(\n       final ValidateableAttestation attestation) {\n     return recentChainData\n-        .retrieveCheckpointState(attestation.getData().getTarget())\n+        .retrieveBlockState(attestation.getData().getBeacon_block_root())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f5eabee0d97e6ed77d5288232100bc2d7680040a"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDU1NjI5Mg==", "bodyText": "I had forgotten the rule above, i.e. target.getEpoch().equals(compute_epoch_at_slot(attestation.getData().getSlot()), in light of that, what you say makes total sense.", "url": "https://github.com/ConsenSys/teku/pull/2632#discussion_r474556292", "createdAt": "2020-08-21T09:08:06Z", "author": {"login": "cemozerr"}, "path": "ethereum/statetransition/src/main/java/tech/pegasys/teku/statetransition/forkchoice/ForkChoice.java", "diffHunk": "@@ -136,15 +136,18 @@ private void processHead(Optional<UInt64> nodeSlot) {\n   public SafeFuture<AttestationProcessingResult> onAttestation(\n       final ValidateableAttestation attestation) {\n     return recentChainData\n-        .retrieveCheckpointState(attestation.getData().getTarget())\n+        .retrieveBlockState(attestation.getData().getBeacon_block_root())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMzNTE3MA=="}, "originalCommit": {"oid": "f5eabee0d97e6ed77d5288232100bc2d7680040a"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3NTQ1NTYzOnYy", "diffSide": "RIGHT", "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/ForkChoiceUtil.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQyMjoxOTo1N1rOHF4PRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQwODo0MDo0MVrOHGNxUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTkyNjM0Mw==", "bodyText": "It may be cleaner to just call attestation.saveRandoMix here and have the method do nothing if it already has a randaoMix saved.  Otherwise it takes a bit of reasoning to understand why the absence of an indexed attestation means we need to save randao mix.", "url": "https://github.com/ConsenSys/teku/pull/2632#discussion_r475926343", "createdAt": "2020-08-24T22:19:57Z", "author": {"login": "ajsutton"}, "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/ForkChoiceUtil.java", "diffHunk": "@@ -399,6 +402,11 @@ private static AttestationProcessingResult indexAndValidateAttestation(\n         .ifSuccessful(\n             () -> {\n               attestation.setIndexedAttestation(indexedAttestation);\n+\n+              if (attestation.getMaybeIndexedAttestation().isEmpty()) {\n+                attestation.saveRandaoMix(targetState);\n+              }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8637bc4b5ef53d394ac63d2431d8ffa3ff622442"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTkzMzkzNA==", "bodyText": "My bad, I was actually trying to call attestation.getMaybeRandaoMix().isEmpty()", "url": "https://github.com/ConsenSys/teku/pull/2632#discussion_r475933934", "createdAt": "2020-08-24T22:41:26Z", "author": {"login": "cemozerr"}, "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/ForkChoiceUtil.java", "diffHunk": "@@ -399,6 +402,11 @@ private static AttestationProcessingResult indexAndValidateAttestation(\n         .ifSuccessful(\n             () -> {\n               attestation.setIndexedAttestation(indexedAttestation);\n+\n+              if (attestation.getMaybeIndexedAttestation().isEmpty()) {\n+                attestation.saveRandaoMix(targetState);\n+              }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTkyNjM0Mw=="}, "originalCommit": {"oid": "8637bc4b5ef53d394ac63d2431d8ffa3ff622442"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTkzNDEzMA==", "bodyText": "But your suggestion below makes sense. I'll apply that one.", "url": "https://github.com/ConsenSys/teku/pull/2632#discussion_r475934130", "createdAt": "2020-08-24T22:42:04Z", "author": {"login": "cemozerr"}, "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/ForkChoiceUtil.java", "diffHunk": "@@ -399,6 +402,11 @@ private static AttestationProcessingResult indexAndValidateAttestation(\n         .ifSuccessful(\n             () -> {\n               attestation.setIndexedAttestation(indexedAttestation);\n+\n+              if (attestation.getMaybeIndexedAttestation().isEmpty()) {\n+                attestation.saveRandaoMix(targetState);\n+              }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTkyNjM0Mw=="}, "originalCommit": {"oid": "8637bc4b5ef53d394ac63d2431d8ffa3ff622442"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjI3OTEyMA==", "bodyText": "Done.", "url": "https://github.com/ConsenSys/teku/pull/2632#discussion_r476279120", "createdAt": "2020-08-25T08:40:41Z", "author": {"login": "cemozerr"}, "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/ForkChoiceUtil.java", "diffHunk": "@@ -399,6 +402,11 @@ private static AttestationProcessingResult indexAndValidateAttestation(\n         .ifSuccessful(\n             () -> {\n               attestation.setIndexedAttestation(indexedAttestation);\n+\n+              if (attestation.getMaybeIndexedAttestation().isEmpty()) {\n+                attestation.saveRandaoMix(targetState);\n+              }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTkyNjM0Mw=="}, "originalCommit": {"oid": "8637bc4b5ef53d394ac63d2431d8ffa3ff622442"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3NTQ3NTk2OnYy", "diffSide": "RIGHT", "path": "ethereum/datastructures/src/main/java/tech/pegasys/teku/datastructures/attestation/ValidateableAttestation.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQyMjoyODoyMVrOHF4bZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQwOTowMDo0OFrOHGOlCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTkyOTQ0Nw==", "bodyText": "I'm not really a fan of the Maybe in these method names.  I'd be tempted to just move to having a single getRandaoMix which returns an optional and do the orElseThrow in the caller if desired (and same for getIndexedAttestation).", "url": "https://github.com/ConsenSys/teku/pull/2632#discussion_r475929447", "createdAt": "2020-08-24T22:28:21Z", "author": {"login": "ajsutton"}, "path": "ethereum/datastructures/src/main/java/tech/pegasys/teku/datastructures/attestation/ValidateableAttestation.java", "diffHunk": "@@ -50,15 +57,38 @@ private ValidateableAttestation(\n     this.hashTreeRoot = Suppliers.memoize(attestation::hash_tree_root);\n   }\n \n+  public Optional<IndexedAttestation> getMaybeIndexedAttestation() {\n+    return maybeIndexedAttestation;\n+  }\n+\n   public IndexedAttestation getIndexedAttestation() {\n     return maybeIndexedAttestation.orElseThrow(\n         () ->\n             new UnsupportedOperationException(\n                 \"ValidateableAttestation does not have an IndexedAttestation yet.\"));\n   }\n \n-  public void setIndexedAttestation(IndexedAttestation maybeIndexedAttestation) {\n-    this.maybeIndexedAttestation = Optional.of(maybeIndexedAttestation);\n+  public Optional<Bytes32> getMaybeRandaoMix() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8637bc4b5ef53d394ac63d2431d8ffa3ff622442"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjI5MjM2Mg==", "bodyText": "Done.", "url": "https://github.com/ConsenSys/teku/pull/2632#discussion_r476292362", "createdAt": "2020-08-25T09:00:48Z", "author": {"login": "cemozerr"}, "path": "ethereum/datastructures/src/main/java/tech/pegasys/teku/datastructures/attestation/ValidateableAttestation.java", "diffHunk": "@@ -50,15 +57,38 @@ private ValidateableAttestation(\n     this.hashTreeRoot = Suppliers.memoize(attestation::hash_tree_root);\n   }\n \n+  public Optional<IndexedAttestation> getMaybeIndexedAttestation() {\n+    return maybeIndexedAttestation;\n+  }\n+\n   public IndexedAttestation getIndexedAttestation() {\n     return maybeIndexedAttestation.orElseThrow(\n         () ->\n             new UnsupportedOperationException(\n                 \"ValidateableAttestation does not have an IndexedAttestation yet.\"));\n   }\n \n-  public void setIndexedAttestation(IndexedAttestation maybeIndexedAttestation) {\n-    this.maybeIndexedAttestation = Optional.of(maybeIndexedAttestation);\n+  public Optional<Bytes32> getMaybeRandaoMix() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTkyOTQ0Nw=="}, "originalCommit": {"oid": "8637bc4b5ef53d394ac63d2431d8ffa3ff622442"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3NTQ3ODA2OnYy", "diffSide": "RIGHT", "path": "ethereum/datastructures/src/main/java/tech/pegasys/teku/datastructures/attestation/ValidateableAttestation.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQyMjoyOToxOVrOHF4csQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQxMDowODoxOVrOHGRKZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTkyOTc3Nw==", "bodyText": "Didn't we circle back round to storing the seed? Sorry, I know I said randao mix but I was overthinking the performance implications I think.  As long as we don't have to calculate a seed for every attestation when producing blocks it will be fine.", "url": "https://github.com/ConsenSys/teku/pull/2632#discussion_r475929777", "createdAt": "2020-08-24T22:29:19Z", "author": {"login": "ajsutton"}, "path": "ethereum/datastructures/src/main/java/tech/pegasys/teku/datastructures/attestation/ValidateableAttestation.java", "diffHunk": "@@ -50,15 +57,38 @@ private ValidateableAttestation(\n     this.hashTreeRoot = Suppliers.memoize(attestation::hash_tree_root);\n   }\n \n+  public Optional<IndexedAttestation> getMaybeIndexedAttestation() {\n+    return maybeIndexedAttestation;\n+  }\n+\n   public IndexedAttestation getIndexedAttestation() {\n     return maybeIndexedAttestation.orElseThrow(\n         () ->\n             new UnsupportedOperationException(\n                 \"ValidateableAttestation does not have an IndexedAttestation yet.\"));\n   }\n \n-  public void setIndexedAttestation(IndexedAttestation maybeIndexedAttestation) {\n-    this.maybeIndexedAttestation = Optional.of(maybeIndexedAttestation);\n+  public Optional<Bytes32> getMaybeRandaoMix() {\n+    return maybeRandaoMix;\n+  }\n+\n+  public Bytes32 getRandaoMix() {\n+    return maybeRandaoMix.orElseThrow(\n+        () ->\n+            new UnsupportedOperationException(\n+                \"ValidateableAttestation does not have a randao mix yet.\"));\n+  }\n+\n+  public void setIndexedAttestation(IndexedAttestation indexedAttestation) {\n+    this.maybeIndexedAttestation = Optional.of(indexedAttestation);\n+  }\n+\n+  public void saveRandaoMix(BeaconState state) {\n+    UInt64 randaoIndex =\n+        compute_epoch_at_slot(attestation.getData().getSlot())\n+            .plus(EPOCHS_PER_HISTORICAL_VECTOR - MIN_SEED_LOOKAHEAD - 1);\n+    Bytes32 mix = get_randao_mix(state, randaoIndex);\n+    this.maybeRandaoMix = Optional.of(mix);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8637bc4b5ef53d394ac63d2431d8ffa3ff622442"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMzNDY5Mg==", "bodyText": "Done.", "url": "https://github.com/ConsenSys/teku/pull/2632#discussion_r476334692", "createdAt": "2020-08-25T10:08:19Z", "author": {"login": "cemozerr"}, "path": "ethereum/datastructures/src/main/java/tech/pegasys/teku/datastructures/attestation/ValidateableAttestation.java", "diffHunk": "@@ -50,15 +57,38 @@ private ValidateableAttestation(\n     this.hashTreeRoot = Suppliers.memoize(attestation::hash_tree_root);\n   }\n \n+  public Optional<IndexedAttestation> getMaybeIndexedAttestation() {\n+    return maybeIndexedAttestation;\n+  }\n+\n   public IndexedAttestation getIndexedAttestation() {\n     return maybeIndexedAttestation.orElseThrow(\n         () ->\n             new UnsupportedOperationException(\n                 \"ValidateableAttestation does not have an IndexedAttestation yet.\"));\n   }\n \n-  public void setIndexedAttestation(IndexedAttestation maybeIndexedAttestation) {\n-    this.maybeIndexedAttestation = Optional.of(maybeIndexedAttestation);\n+  public Optional<Bytes32> getMaybeRandaoMix() {\n+    return maybeRandaoMix;\n+  }\n+\n+  public Bytes32 getRandaoMix() {\n+    return maybeRandaoMix.orElseThrow(\n+        () ->\n+            new UnsupportedOperationException(\n+                \"ValidateableAttestation does not have a randao mix yet.\"));\n+  }\n+\n+  public void setIndexedAttestation(IndexedAttestation indexedAttestation) {\n+    this.maybeIndexedAttestation = Optional.of(indexedAttestation);\n+  }\n+\n+  public void saveRandaoMix(BeaconState state) {\n+    UInt64 randaoIndex =\n+        compute_epoch_at_slot(attestation.getData().getSlot())\n+            .plus(EPOCHS_PER_HISTORICAL_VECTOR - MIN_SEED_LOOKAHEAD - 1);\n+    Bytes32 mix = get_randao_mix(state, randaoIndex);\n+    this.maybeRandaoMix = Optional.of(mix);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTkyOTc3Nw=="}, "originalCommit": {"oid": "8637bc4b5ef53d394ac63d2431d8ffa3ff622442"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3NTQ4Mzc4OnYy", "diffSide": "RIGHT", "path": "ethereum/statetransition/src/main/java/tech/pegasys/teku/statetransition/attestation/AttestationForkChecker.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQyMjozMTozOFrOHF4f6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQyMjozMTozOFrOHF4f6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTkzMDYwMw==", "bodyText": "Good idea to make this its own class.", "url": "https://github.com/ConsenSys/teku/pull/2632#discussion_r475930603", "createdAt": "2020-08-24T22:31:38Z", "author": {"login": "ajsutton"}, "path": "ethereum/statetransition/src/main/java/tech/pegasys/teku/statetransition/attestation/AttestationForkChecker.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.statetransition.attestation;\n+\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.compute_epoch_at_slot;\n+import static tech.pegasys.teku.datastructures.util.BeaconStateUtil.get_randao_mix;\n+import static tech.pegasys.teku.util.config.Constants.EPOCHS_PER_HISTORICAL_VECTOR;\n+import static tech.pegasys.teku.util.config.Constants.MIN_SEED_LOOKAHEAD;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+\n+public class AttestationForkChecker {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8637bc4b5ef53d394ac63d2431d8ffa3ff622442"}, "originalPosition": 27}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3332, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}