{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTExMDA4Mjc4", "number": 3092, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxOTo1ODoxOFrOEyh9Gg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxOTo1ODoxOFrOEyh9Gg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNDIwNTcwOnYy", "diffSide": "RIGHT", "path": "storage/src/test/java/tech/pegasys/teku/storage/server/AbstractDatabaseTest.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxOTo1ODoxOFrOHpOj7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QyMDowNTo0NFrOHpO0Gw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk5MjIzNw==", "bodyText": "Why are we filtering for epoch boundary states?  Is this because we're storing hot states at every epoch boundary?", "url": "https://github.com/ConsenSys/teku/pull/3092#discussion_r512992237", "createdAt": "2020-10-27T19:58:18Z", "author": {"login": "mbaxter"}, "path": "storage/src/test/java/tech/pegasys/teku/storage/server/AbstractDatabaseTest.java", "diffHunk": "@@ -495,7 +495,19 @@ public void handleFinalizationWhenCacheLimitsExceeded() {\n     assertThat(tx.commit()).isCompleted();\n \n     // All finalized blocks and states should be available\n-    assertFinalizedBlocksAndStatesAvailable(newBlocks);\n+    final List<SignedBeaconBlock> expectedFinalizedBlocks =\n+        newBlocks.stream().map(SignedBlockAndState::getBlock).collect(toList());\n+    final Map<Bytes32, BeaconState> expectedFinalizedStates =\n+        newBlocks.stream()\n+            .filter(\n+                blockAndState ->\n+                    blockAndState\n+                        .getSlot()\n+                        .equals(compute_start_slot_at_epoch(blockAndState.getSlot())))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f99ef5200f076f9aabb79c945ed0e6cb502c1be0"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk5NDEyMQ==", "bodyText": "Probably worth a comment", "url": "https://github.com/ConsenSys/teku/pull/3092#discussion_r512994121", "createdAt": "2020-10-27T20:01:33Z", "author": {"login": "mbaxter"}, "path": "storage/src/test/java/tech/pegasys/teku/storage/server/AbstractDatabaseTest.java", "diffHunk": "@@ -495,7 +495,19 @@ public void handleFinalizationWhenCacheLimitsExceeded() {\n     assertThat(tx.commit()).isCompleted();\n \n     // All finalized blocks and states should be available\n-    assertFinalizedBlocksAndStatesAvailable(newBlocks);\n+    final List<SignedBeaconBlock> expectedFinalizedBlocks =\n+        newBlocks.stream().map(SignedBlockAndState::getBlock).collect(toList());\n+    final Map<Bytes32, BeaconState> expectedFinalizedStates =\n+        newBlocks.stream()\n+            .filter(\n+                blockAndState ->\n+                    blockAndState\n+                        .getSlot()\n+                        .equals(compute_start_slot_at_epoch(blockAndState.getSlot())))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk5MjIzNw=="}, "originalCommit": {"oid": "f99ef5200f076f9aabb79c945ed0e6cb502c1be0"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk5NjM3OQ==", "bodyText": "Yes the test configuration is setup to store a hot state every epoch. I'll add a comment.", "url": "https://github.com/ConsenSys/teku/pull/3092#discussion_r512996379", "createdAt": "2020-10-27T20:05:44Z", "author": {"login": "ajsutton"}, "path": "storage/src/test/java/tech/pegasys/teku/storage/server/AbstractDatabaseTest.java", "diffHunk": "@@ -495,7 +495,19 @@ public void handleFinalizationWhenCacheLimitsExceeded() {\n     assertThat(tx.commit()).isCompleted();\n \n     // All finalized blocks and states should be available\n-    assertFinalizedBlocksAndStatesAvailable(newBlocks);\n+    final List<SignedBeaconBlock> expectedFinalizedBlocks =\n+        newBlocks.stream().map(SignedBlockAndState::getBlock).collect(toList());\n+    final Map<Bytes32, BeaconState> expectedFinalizedStates =\n+        newBlocks.stream()\n+            .filter(\n+                blockAndState ->\n+                    blockAndState\n+                        .getSlot()\n+                        .equals(compute_start_slot_at_epoch(blockAndState.getSlot())))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk5MjIzNw=="}, "originalCommit": {"oid": "f99ef5200f076f9aabb79c945ed0e6cb502c1be0"}, "originalPosition": 13}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3102, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}