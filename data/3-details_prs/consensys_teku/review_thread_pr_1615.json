{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA1MjkyNjUx", "number": 1615, "reviewThreads": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMDoxMTowNVrODzB_nw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwNTowMDoxNVrODzi3PQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0ODM2NjM5OnYy", "diffSide": "RIGHT", "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/gossip/topics/validation/BlockValidator.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMDoxMTowNVrOGHbpYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMTozNToxMVrOGHdx9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0NjE3OA==", "bodyText": "We should use a ConcurrentLimitedSet here, so this collection doesn't grow forever:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private final Set<UnsignedLong> receivedValidSignatureBlockSlots = new HashSet<>();\n          \n          \n            \n              private final Set<UnsignedLong> receivedValidSignatureBlockSlots = ConcurrentLimitedSet.create(maxSize, DROP_LEAST_RECENTLY_ACCESSED);", "url": "https://github.com/ConsenSys/teku/pull/1615#discussion_r410446178", "createdAt": "2020-04-17T20:11:05Z", "author": {"login": "mbaxter"}, "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/gossip/topics/validation/BlockValidator.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package tech.pegasys.artemis.networking.eth2.gossip.topics.validation;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.artemis.bls.BLS;\n+import tech.pegasys.artemis.bls.BLSSignature;\n+import tech.pegasys.artemis.core.StateTransition;\n+import tech.pegasys.artemis.core.exceptions.EpochProcessingException;\n+import tech.pegasys.artemis.core.exceptions.SlotProcessingException;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.datastructures.forkchoice.ReadOnlyStore;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.state.Validator;\n+import tech.pegasys.artemis.storage.client.RecentChainData;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static com.google.common.primitives.UnsignedLong.valueOf;\n+import static java.lang.Math.toIntExact;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.compute_signing_root;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_beacon_proposer_index;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_domain;\n+import static tech.pegasys.artemis.statetransition.forkchoice.ForkChoiceUtil.getCurrentSlot;\n+import static tech.pegasys.artemis.util.config.Constants.DOMAIN_BEACON_PROPOSER;\n+import static tech.pegasys.artemis.util.config.Constants.MAXIMUM_GOSSIP_CLOCK_DISPARITY;\n+\n+public class BlockValidator {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final RecentChainData recentChainData;\n+  private final StateTransition stateTransition;\n+  private final Set<UnsignedLong> receivedValidSignatureBlockSlots = new HashSet<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e0fea79e98213e89eba344d803674ad53377051"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ3OTMzOA==", "bodyText": "Makes sense.", "url": "https://github.com/ConsenSys/teku/pull/1615#discussion_r410479338", "createdAt": "2020-04-17T21:30:11Z", "author": {"login": "cemozerr"}, "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/gossip/topics/validation/BlockValidator.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package tech.pegasys.artemis.networking.eth2.gossip.topics.validation;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.artemis.bls.BLS;\n+import tech.pegasys.artemis.bls.BLSSignature;\n+import tech.pegasys.artemis.core.StateTransition;\n+import tech.pegasys.artemis.core.exceptions.EpochProcessingException;\n+import tech.pegasys.artemis.core.exceptions.SlotProcessingException;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.datastructures.forkchoice.ReadOnlyStore;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.state.Validator;\n+import tech.pegasys.artemis.storage.client.RecentChainData;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static com.google.common.primitives.UnsignedLong.valueOf;\n+import static java.lang.Math.toIntExact;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.compute_signing_root;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_beacon_proposer_index;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_domain;\n+import static tech.pegasys.artemis.statetransition.forkchoice.ForkChoiceUtil.getCurrentSlot;\n+import static tech.pegasys.artemis.util.config.Constants.DOMAIN_BEACON_PROPOSER;\n+import static tech.pegasys.artemis.util.config.Constants.MAXIMUM_GOSSIP_CLOCK_DISPARITY;\n+\n+public class BlockValidator {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final RecentChainData recentChainData;\n+  private final StateTransition stateTransition;\n+  private final Set<UnsignedLong> receivedValidSignatureBlockSlots = new HashSet<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0NjE3OA=="}, "originalCommit": {"oid": "4e0fea79e98213e89eba344d803674ad53377051"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ4MDMyNg==", "bodyText": "I do think drop oldest element strategy would make more sense here.", "url": "https://github.com/ConsenSys/teku/pull/1615#discussion_r410480326", "createdAt": "2020-04-17T21:33:04Z", "author": {"login": "cemozerr"}, "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/gossip/topics/validation/BlockValidator.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package tech.pegasys.artemis.networking.eth2.gossip.topics.validation;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.artemis.bls.BLS;\n+import tech.pegasys.artemis.bls.BLSSignature;\n+import tech.pegasys.artemis.core.StateTransition;\n+import tech.pegasys.artemis.core.exceptions.EpochProcessingException;\n+import tech.pegasys.artemis.core.exceptions.SlotProcessingException;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.datastructures.forkchoice.ReadOnlyStore;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.state.Validator;\n+import tech.pegasys.artemis.storage.client.RecentChainData;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static com.google.common.primitives.UnsignedLong.valueOf;\n+import static java.lang.Math.toIntExact;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.compute_signing_root;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_beacon_proposer_index;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_domain;\n+import static tech.pegasys.artemis.statetransition.forkchoice.ForkChoiceUtil.getCurrentSlot;\n+import static tech.pegasys.artemis.util.config.Constants.DOMAIN_BEACON_PROPOSER;\n+import static tech.pegasys.artemis.util.config.Constants.MAXIMUM_GOSSIP_CLOCK_DISPARITY;\n+\n+public class BlockValidator {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final RecentChainData recentChainData;\n+  private final StateTransition stateTransition;\n+  private final Set<UnsignedLong> receivedValidSignatureBlockSlots = new HashSet<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0NjE3OA=="}, "originalCommit": {"oid": "4e0fea79e98213e89eba344d803674ad53377051"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ4MTE0MA==", "bodyText": "Done.", "url": "https://github.com/ConsenSys/teku/pull/1615#discussion_r410481140", "createdAt": "2020-04-17T21:35:11Z", "author": {"login": "cemozerr"}, "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/gossip/topics/validation/BlockValidator.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package tech.pegasys.artemis.networking.eth2.gossip.topics.validation;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.artemis.bls.BLS;\n+import tech.pegasys.artemis.bls.BLSSignature;\n+import tech.pegasys.artemis.core.StateTransition;\n+import tech.pegasys.artemis.core.exceptions.EpochProcessingException;\n+import tech.pegasys.artemis.core.exceptions.SlotProcessingException;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.datastructures.forkchoice.ReadOnlyStore;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.state.Validator;\n+import tech.pegasys.artemis.storage.client.RecentChainData;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static com.google.common.primitives.UnsignedLong.valueOf;\n+import static java.lang.Math.toIntExact;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.compute_signing_root;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_beacon_proposer_index;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_domain;\n+import static tech.pegasys.artemis.statetransition.forkchoice.ForkChoiceUtil.getCurrentSlot;\n+import static tech.pegasys.artemis.util.config.Constants.DOMAIN_BEACON_PROPOSER;\n+import static tech.pegasys.artemis.util.config.Constants.MAXIMUM_GOSSIP_CLOCK_DISPARITY;\n+\n+public class BlockValidator {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final RecentChainData recentChainData;\n+  private final StateTransition stateTransition;\n+  private final Set<UnsignedLong> receivedValidSignatureBlockSlots = new HashSet<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0NjE3OA=="}, "originalCommit": {"oid": "4e0fea79e98213e89eba344d803674ad53377051"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0ODM4OTU5OnYy", "diffSide": "RIGHT", "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/gossip/topics/validation/BlockValidator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMDoxOToyNVrOGHb4Ag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMTozNzoxM1rOGHd0vQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0OTkyMg==", "bodyText": "(nit) You could just use an Optional here:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                final BeaconState preState = recentChainData.getStore().getBlockState(block.getMessage().getParent_root());\n          \n          \n            \n                final Optional<BeaconState> preState = recentChainData.getBlockState(block.getMessage().getParent_root());\n          \n          \n            \n                if (preState.isEmpty() || !blockIsNotFromFutureSlot(block)) {", "url": "https://github.com/ConsenSys/teku/pull/1615#discussion_r410449922", "createdAt": "2020-04-17T20:19:25Z", "author": {"login": "mbaxter"}, "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/gossip/topics/validation/BlockValidator.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package tech.pegasys.artemis.networking.eth2.gossip.topics.validation;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.artemis.bls.BLS;\n+import tech.pegasys.artemis.bls.BLSSignature;\n+import tech.pegasys.artemis.core.StateTransition;\n+import tech.pegasys.artemis.core.exceptions.EpochProcessingException;\n+import tech.pegasys.artemis.core.exceptions.SlotProcessingException;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.datastructures.forkchoice.ReadOnlyStore;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.state.Validator;\n+import tech.pegasys.artemis.storage.client.RecentChainData;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static com.google.common.primitives.UnsignedLong.valueOf;\n+import static java.lang.Math.toIntExact;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.compute_signing_root;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_beacon_proposer_index;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_domain;\n+import static tech.pegasys.artemis.statetransition.forkchoice.ForkChoiceUtil.getCurrentSlot;\n+import static tech.pegasys.artemis.util.config.Constants.DOMAIN_BEACON_PROPOSER;\n+import static tech.pegasys.artemis.util.config.Constants.MAXIMUM_GOSSIP_CLOCK_DISPARITY;\n+\n+public class BlockValidator {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final RecentChainData recentChainData;\n+  private final StateTransition stateTransition;\n+  private final Set<UnsignedLong> receivedValidSignatureBlockSlots = new HashSet<>();\n+\n+  public BlockValidator(RecentChainData recentChainData,\n+                        StateTransition stateTransition) {\n+    this.recentChainData = recentChainData;\n+    this.stateTransition = stateTransition;\n+  }\n+\n+  public BlockValidationResult validate(SignedBeaconBlock block) {\n+\n+    if (!blockSlotIsGreaterThanLatestFinalizedSlot(block) || !blockIsFirstBlockWithValidSignatureForSlot(block)) {\n+      LOG.trace(\"BlockValidator: Block is either too old or is not the first block with valid signature for \" +\n+              \"its slot. It will be dropped\");\n+      return BlockValidationResult.INVALID;\n+    }\n+\n+    final BeaconState preState = recentChainData.getStore().getBlockState(block.getMessage().getParent_root());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e0fea79e98213e89eba344d803674ad53377051"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ4MTg1Mw==", "bodyText": "Good idea. done.", "url": "https://github.com/ConsenSys/teku/pull/1615#discussion_r410481853", "createdAt": "2020-04-17T21:37:13Z", "author": {"login": "cemozerr"}, "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/gossip/topics/validation/BlockValidator.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package tech.pegasys.artemis.networking.eth2.gossip.topics.validation;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.artemis.bls.BLS;\n+import tech.pegasys.artemis.bls.BLSSignature;\n+import tech.pegasys.artemis.core.StateTransition;\n+import tech.pegasys.artemis.core.exceptions.EpochProcessingException;\n+import tech.pegasys.artemis.core.exceptions.SlotProcessingException;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.datastructures.forkchoice.ReadOnlyStore;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.state.Validator;\n+import tech.pegasys.artemis.storage.client.RecentChainData;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static com.google.common.primitives.UnsignedLong.valueOf;\n+import static java.lang.Math.toIntExact;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.compute_signing_root;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_beacon_proposer_index;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_domain;\n+import static tech.pegasys.artemis.statetransition.forkchoice.ForkChoiceUtil.getCurrentSlot;\n+import static tech.pegasys.artemis.util.config.Constants.DOMAIN_BEACON_PROPOSER;\n+import static tech.pegasys.artemis.util.config.Constants.MAXIMUM_GOSSIP_CLOCK_DISPARITY;\n+\n+public class BlockValidator {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final RecentChainData recentChainData;\n+  private final StateTransition stateTransition;\n+  private final Set<UnsignedLong> receivedValidSignatureBlockSlots = new HashSet<>();\n+\n+  public BlockValidator(RecentChainData recentChainData,\n+                        StateTransition stateTransition) {\n+    this.recentChainData = recentChainData;\n+    this.stateTransition = stateTransition;\n+  }\n+\n+  public BlockValidationResult validate(SignedBeaconBlock block) {\n+\n+    if (!blockSlotIsGreaterThanLatestFinalizedSlot(block) || !blockIsFirstBlockWithValidSignatureForSlot(block)) {\n+      LOG.trace(\"BlockValidator: Block is either too old or is not the first block with valid signature for \" +\n+              \"its slot. It will be dropped\");\n+      return BlockValidationResult.INVALID;\n+    }\n+\n+    final BeaconState preState = recentChainData.getStore().getBlockState(block.getMessage().getParent_root());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ0OTkyMg=="}, "originalCommit": {"oid": "4e0fea79e98213e89eba344d803674ad53377051"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0ODM5Mzc5OnYy", "diffSide": "RIGHT", "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/gossip/topics/validation/BlockValidator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMDoyMDozOFrOGHb6eg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMTozOToyNFrOGHd36A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ1MDU1NA==", "bodyText": "The double-negative is a bit confusing:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (!blockPreStateDoesExist(preState) || !blockIsNotFromFutureSlot(block)) {\n          \n          \n            \n                if (!blockPreStateDoesExist(preState) || blockIsFromFutureSlot(block)) {", "url": "https://github.com/ConsenSys/teku/pull/1615#discussion_r410450554", "createdAt": "2020-04-17T20:20:38Z", "author": {"login": "mbaxter"}, "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/gossip/topics/validation/BlockValidator.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package tech.pegasys.artemis.networking.eth2.gossip.topics.validation;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.artemis.bls.BLS;\n+import tech.pegasys.artemis.bls.BLSSignature;\n+import tech.pegasys.artemis.core.StateTransition;\n+import tech.pegasys.artemis.core.exceptions.EpochProcessingException;\n+import tech.pegasys.artemis.core.exceptions.SlotProcessingException;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.datastructures.forkchoice.ReadOnlyStore;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.state.Validator;\n+import tech.pegasys.artemis.storage.client.RecentChainData;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static com.google.common.primitives.UnsignedLong.valueOf;\n+import static java.lang.Math.toIntExact;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.compute_signing_root;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_beacon_proposer_index;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_domain;\n+import static tech.pegasys.artemis.statetransition.forkchoice.ForkChoiceUtil.getCurrentSlot;\n+import static tech.pegasys.artemis.util.config.Constants.DOMAIN_BEACON_PROPOSER;\n+import static tech.pegasys.artemis.util.config.Constants.MAXIMUM_GOSSIP_CLOCK_DISPARITY;\n+\n+public class BlockValidator {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final RecentChainData recentChainData;\n+  private final StateTransition stateTransition;\n+  private final Set<UnsignedLong> receivedValidSignatureBlockSlots = new HashSet<>();\n+\n+  public BlockValidator(RecentChainData recentChainData,\n+                        StateTransition stateTransition) {\n+    this.recentChainData = recentChainData;\n+    this.stateTransition = stateTransition;\n+  }\n+\n+  public BlockValidationResult validate(SignedBeaconBlock block) {\n+\n+    if (!blockSlotIsGreaterThanLatestFinalizedSlot(block) || !blockIsFirstBlockWithValidSignatureForSlot(block)) {\n+      LOG.trace(\"BlockValidator: Block is either too old or is not the first block with valid signature for \" +\n+              \"its slot. It will be dropped\");\n+      return BlockValidationResult.INVALID;\n+    }\n+\n+    final BeaconState preState = recentChainData.getStore().getBlockState(block.getMessage().getParent_root());\n+    if (!blockPreStateDoesExist(preState) || !blockIsNotFromFutureSlot(block)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e0fea79e98213e89eba344d803674ad53377051"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ4MjY2NA==", "bodyText": "done.", "url": "https://github.com/ConsenSys/teku/pull/1615#discussion_r410482664", "createdAt": "2020-04-17T21:39:24Z", "author": {"login": "cemozerr"}, "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/gossip/topics/validation/BlockValidator.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package tech.pegasys.artemis.networking.eth2.gossip.topics.validation;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.artemis.bls.BLS;\n+import tech.pegasys.artemis.bls.BLSSignature;\n+import tech.pegasys.artemis.core.StateTransition;\n+import tech.pegasys.artemis.core.exceptions.EpochProcessingException;\n+import tech.pegasys.artemis.core.exceptions.SlotProcessingException;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.datastructures.forkchoice.ReadOnlyStore;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.state.Validator;\n+import tech.pegasys.artemis.storage.client.RecentChainData;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static com.google.common.primitives.UnsignedLong.valueOf;\n+import static java.lang.Math.toIntExact;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.compute_signing_root;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_beacon_proposer_index;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_domain;\n+import static tech.pegasys.artemis.statetransition.forkchoice.ForkChoiceUtil.getCurrentSlot;\n+import static tech.pegasys.artemis.util.config.Constants.DOMAIN_BEACON_PROPOSER;\n+import static tech.pegasys.artemis.util.config.Constants.MAXIMUM_GOSSIP_CLOCK_DISPARITY;\n+\n+public class BlockValidator {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final RecentChainData recentChainData;\n+  private final StateTransition stateTransition;\n+  private final Set<UnsignedLong> receivedValidSignatureBlockSlots = new HashSet<>();\n+\n+  public BlockValidator(RecentChainData recentChainData,\n+                        StateTransition stateTransition) {\n+    this.recentChainData = recentChainData;\n+    this.stateTransition = stateTransition;\n+  }\n+\n+  public BlockValidationResult validate(SignedBeaconBlock block) {\n+\n+    if (!blockSlotIsGreaterThanLatestFinalizedSlot(block) || !blockIsFirstBlockWithValidSignatureForSlot(block)) {\n+      LOG.trace(\"BlockValidator: Block is either too old or is not the first block with valid signature for \" +\n+              \"its slot. It will be dropped\");\n+      return BlockValidationResult.INVALID;\n+    }\n+\n+    final BeaconState preState = recentChainData.getStore().getBlockState(block.getMessage().getParent_root());\n+    if (!blockPreStateDoesExist(preState) || !blockIsNotFromFutureSlot(block)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ1MDU1NA=="}, "originalCommit": {"oid": "4e0fea79e98213e89eba344d803674ad53377051"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0ODQzOTcwOnYy", "diffSide": "RIGHT", "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/gossip/topics/validation/BlockValidator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMDozODozNVrOGHcX9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMTozOTozMFrOGHd3-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ1ODEwMw==", "bodyText": "In general, I'd probably cut back on the logging in this validator.  I think we probably just want to log a trace message if we encounter something that clearly violates the spec (invalid signature, unprocessable block, etc).", "url": "https://github.com/ConsenSys/teku/pull/1615#discussion_r410458103", "createdAt": "2020-04-17T20:38:35Z", "author": {"login": "mbaxter"}, "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/gossip/topics/validation/BlockValidator.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package tech.pegasys.artemis.networking.eth2.gossip.topics.validation;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.artemis.bls.BLS;\n+import tech.pegasys.artemis.bls.BLSSignature;\n+import tech.pegasys.artemis.core.StateTransition;\n+import tech.pegasys.artemis.core.exceptions.EpochProcessingException;\n+import tech.pegasys.artemis.core.exceptions.SlotProcessingException;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.datastructures.forkchoice.ReadOnlyStore;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.state.Validator;\n+import tech.pegasys.artemis.storage.client.RecentChainData;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static com.google.common.primitives.UnsignedLong.valueOf;\n+import static java.lang.Math.toIntExact;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.compute_signing_root;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_beacon_proposer_index;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_domain;\n+import static tech.pegasys.artemis.statetransition.forkchoice.ForkChoiceUtil.getCurrentSlot;\n+import static tech.pegasys.artemis.util.config.Constants.DOMAIN_BEACON_PROPOSER;\n+import static tech.pegasys.artemis.util.config.Constants.MAXIMUM_GOSSIP_CLOCK_DISPARITY;\n+\n+public class BlockValidator {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final RecentChainData recentChainData;\n+  private final StateTransition stateTransition;\n+  private final Set<UnsignedLong> receivedValidSignatureBlockSlots = new HashSet<>();\n+\n+  public BlockValidator(RecentChainData recentChainData,\n+                        StateTransition stateTransition) {\n+    this.recentChainData = recentChainData;\n+    this.stateTransition = stateTransition;\n+  }\n+\n+  public BlockValidationResult validate(SignedBeaconBlock block) {\n+\n+    if (!blockSlotIsGreaterThanLatestFinalizedSlot(block) || !blockIsFirstBlockWithValidSignatureForSlot(block)) {\n+      LOG.trace(\"BlockValidator: Block is either too old or is not the first block with valid signature for \" +\n+              \"its slot. It will be dropped\");\n+      return BlockValidationResult.INVALID;\n+    }\n+\n+    final BeaconState preState = recentChainData.getStore().getBlockState(block.getMessage().getParent_root());\n+    if (!blockPreStateDoesExist(preState) || !blockIsNotFromFutureSlot(block)) {\n+      LOG.trace(\"BlockValidator: Either block pre state does not exist or block is from the future. \" +\n+              \"It will be saved for future processing\");\n+      return BlockValidationResult.SAVED_FOR_FUTURE;\n+    }\n+\n+    try {\n+      BeaconState postState = stateTransition.process_slots(preState, block.getMessage().getSlot());\n+      if (blockIsProposedByTheExpectedProposer(block, postState) &&\n+              blockSignatureIsValidWithRespectToProposerIndex(block, preState, postState)) {\n+        LOG.trace(\"BlockValidator: Block has passed all gossip layer validation\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e0fea79e98213e89eba344d803674ad53377051"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ4MjY4Mw==", "bodyText": "done.", "url": "https://github.com/ConsenSys/teku/pull/1615#discussion_r410482683", "createdAt": "2020-04-17T21:39:30Z", "author": {"login": "cemozerr"}, "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/gossip/topics/validation/BlockValidator.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package tech.pegasys.artemis.networking.eth2.gossip.topics.validation;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.artemis.bls.BLS;\n+import tech.pegasys.artemis.bls.BLSSignature;\n+import tech.pegasys.artemis.core.StateTransition;\n+import tech.pegasys.artemis.core.exceptions.EpochProcessingException;\n+import tech.pegasys.artemis.core.exceptions.SlotProcessingException;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.datastructures.forkchoice.ReadOnlyStore;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.state.Validator;\n+import tech.pegasys.artemis.storage.client.RecentChainData;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static com.google.common.primitives.UnsignedLong.valueOf;\n+import static java.lang.Math.toIntExact;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.compute_signing_root;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_beacon_proposer_index;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_domain;\n+import static tech.pegasys.artemis.statetransition.forkchoice.ForkChoiceUtil.getCurrentSlot;\n+import static tech.pegasys.artemis.util.config.Constants.DOMAIN_BEACON_PROPOSER;\n+import static tech.pegasys.artemis.util.config.Constants.MAXIMUM_GOSSIP_CLOCK_DISPARITY;\n+\n+public class BlockValidator {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final RecentChainData recentChainData;\n+  private final StateTransition stateTransition;\n+  private final Set<UnsignedLong> receivedValidSignatureBlockSlots = new HashSet<>();\n+\n+  public BlockValidator(RecentChainData recentChainData,\n+                        StateTransition stateTransition) {\n+    this.recentChainData = recentChainData;\n+    this.stateTransition = stateTransition;\n+  }\n+\n+  public BlockValidationResult validate(SignedBeaconBlock block) {\n+\n+    if (!blockSlotIsGreaterThanLatestFinalizedSlot(block) || !blockIsFirstBlockWithValidSignatureForSlot(block)) {\n+      LOG.trace(\"BlockValidator: Block is either too old or is not the first block with valid signature for \" +\n+              \"its slot. It will be dropped\");\n+      return BlockValidationResult.INVALID;\n+    }\n+\n+    final BeaconState preState = recentChainData.getStore().getBlockState(block.getMessage().getParent_root());\n+    if (!blockPreStateDoesExist(preState) || !blockIsNotFromFutureSlot(block)) {\n+      LOG.trace(\"BlockValidator: Either block pre state does not exist or block is from the future. \" +\n+              \"It will be saved for future processing\");\n+      return BlockValidationResult.SAVED_FOR_FUTURE;\n+    }\n+\n+    try {\n+      BeaconState postState = stateTransition.process_slots(preState, block.getMessage().getSlot());\n+      if (blockIsProposedByTheExpectedProposer(block, postState) &&\n+              blockSignatureIsValidWithRespectToProposerIndex(block, preState, postState)) {\n+        LOG.trace(\"BlockValidator: Block has passed all gossip layer validation\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ1ODEwMw=="}, "originalCommit": {"oid": "4e0fea79e98213e89eba344d803674ad53377051"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0ODQ3Njg2OnYy", "diffSide": "RIGHT", "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/gossip/topics/validation/BlockValidator.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMDo1MzoxM1rOGHcv3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMTo0NjowMlrOGHeBaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ2NDIyMg==", "bodyText": "I don't think this calculation actually does anything (when MAXIMUM_GOSSIP_CLOCK_DISPARITY < 1000) ...  Should we do something like?:\nfinal long disparityInSeconds = Math.round((float) MAXIMUM_GOSSIP_CLOCK_DISPARITY / 1000.0);\nfinal UnsignedLong maxOffset = UnsignedLong.valueOf(disparityInSeconds);\nfinal UnsignedLong maxTime = store.getTime.plus(maxOffset);", "url": "https://github.com/ConsenSys/teku/pull/1615#discussion_r410464222", "createdAt": "2020-04-17T20:53:13Z", "author": {"login": "mbaxter"}, "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/gossip/topics/validation/BlockValidator.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package tech.pegasys.artemis.networking.eth2.gossip.topics.validation;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.artemis.bls.BLS;\n+import tech.pegasys.artemis.bls.BLSSignature;\n+import tech.pegasys.artemis.core.StateTransition;\n+import tech.pegasys.artemis.core.exceptions.EpochProcessingException;\n+import tech.pegasys.artemis.core.exceptions.SlotProcessingException;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.datastructures.forkchoice.ReadOnlyStore;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.state.Validator;\n+import tech.pegasys.artemis.storage.client.RecentChainData;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static com.google.common.primitives.UnsignedLong.valueOf;\n+import static java.lang.Math.toIntExact;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.compute_signing_root;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_beacon_proposer_index;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_domain;\n+import static tech.pegasys.artemis.statetransition.forkchoice.ForkChoiceUtil.getCurrentSlot;\n+import static tech.pegasys.artemis.util.config.Constants.DOMAIN_BEACON_PROPOSER;\n+import static tech.pegasys.artemis.util.config.Constants.MAXIMUM_GOSSIP_CLOCK_DISPARITY;\n+\n+public class BlockValidator {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final RecentChainData recentChainData;\n+  private final StateTransition stateTransition;\n+  private final Set<UnsignedLong> receivedValidSignatureBlockSlots = new HashSet<>();\n+\n+  public BlockValidator(RecentChainData recentChainData,\n+                        StateTransition stateTransition) {\n+    this.recentChainData = recentChainData;\n+    this.stateTransition = stateTransition;\n+  }\n+\n+  public BlockValidationResult validate(SignedBeaconBlock block) {\n+\n+    if (!blockSlotIsGreaterThanLatestFinalizedSlot(block) || !blockIsFirstBlockWithValidSignatureForSlot(block)) {\n+      LOG.trace(\"BlockValidator: Block is either too old or is not the first block with valid signature for \" +\n+              \"its slot. It will be dropped\");\n+      return BlockValidationResult.INVALID;\n+    }\n+\n+    final BeaconState preState = recentChainData.getStore().getBlockState(block.getMessage().getParent_root());\n+    if (!blockPreStateDoesExist(preState) || !blockIsNotFromFutureSlot(block)) {\n+      LOG.trace(\"BlockValidator: Either block pre state does not exist or block is from the future. \" +\n+              \"It will be saved for future processing\");\n+      return BlockValidationResult.SAVED_FOR_FUTURE;\n+    }\n+\n+    try {\n+      BeaconState postState = stateTransition.process_slots(preState, block.getMessage().getSlot());\n+      if (blockIsProposedByTheExpectedProposer(block, postState) &&\n+              blockSignatureIsValidWithRespectToProposerIndex(block, preState, postState)) {\n+        LOG.trace(\"BlockValidator: Block has passed all gossip layer validation\");\n+        return BlockValidationResult.VALID;\n+      }\n+    } catch (EpochProcessingException | SlotProcessingException e) {\n+      LOG.error(\"BlockValidator: Unable to process block state.\", e);\n+      return BlockValidationResult.INVALID;\n+    }\n+\n+    return BlockValidationResult.INVALID;\n+  }\n+\n+  private boolean blockIsNotFromFutureSlot(SignedBeaconBlock block) {\n+    ReadOnlyStore store = recentChainData.getStore();\n+    // .times() and .dividedBy() is to account for the fact that store.time is in seconds\n+    // and MAXIMUM_GOSSIP_CLOCK_DISPARITY is in ms.\n+    UnsignedLong maxTime = store.getTime()\n+            .times(valueOf(1000))\n+            .plus(MAXIMUM_GOSSIP_CLOCK_DISPARITY)\n+            .dividedBy(valueOf(1000));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e0fea79e98213e89eba344d803674ad53377051"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ4NDgxMg==", "bodyText": "Good catch. I don't think that's the perfect solution either, (we should potentially think of switching store.time to be in milliseconds at some point) however, I think we can live with your suggestion.", "url": "https://github.com/ConsenSys/teku/pull/1615#discussion_r410484812", "createdAt": "2020-04-17T21:45:17Z", "author": {"login": "cemozerr"}, "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/gossip/topics/validation/BlockValidator.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package tech.pegasys.artemis.networking.eth2.gossip.topics.validation;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.artemis.bls.BLS;\n+import tech.pegasys.artemis.bls.BLSSignature;\n+import tech.pegasys.artemis.core.StateTransition;\n+import tech.pegasys.artemis.core.exceptions.EpochProcessingException;\n+import tech.pegasys.artemis.core.exceptions.SlotProcessingException;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.datastructures.forkchoice.ReadOnlyStore;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.state.Validator;\n+import tech.pegasys.artemis.storage.client.RecentChainData;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static com.google.common.primitives.UnsignedLong.valueOf;\n+import static java.lang.Math.toIntExact;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.compute_signing_root;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_beacon_proposer_index;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_domain;\n+import static tech.pegasys.artemis.statetransition.forkchoice.ForkChoiceUtil.getCurrentSlot;\n+import static tech.pegasys.artemis.util.config.Constants.DOMAIN_BEACON_PROPOSER;\n+import static tech.pegasys.artemis.util.config.Constants.MAXIMUM_GOSSIP_CLOCK_DISPARITY;\n+\n+public class BlockValidator {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final RecentChainData recentChainData;\n+  private final StateTransition stateTransition;\n+  private final Set<UnsignedLong> receivedValidSignatureBlockSlots = new HashSet<>();\n+\n+  public BlockValidator(RecentChainData recentChainData,\n+                        StateTransition stateTransition) {\n+    this.recentChainData = recentChainData;\n+    this.stateTransition = stateTransition;\n+  }\n+\n+  public BlockValidationResult validate(SignedBeaconBlock block) {\n+\n+    if (!blockSlotIsGreaterThanLatestFinalizedSlot(block) || !blockIsFirstBlockWithValidSignatureForSlot(block)) {\n+      LOG.trace(\"BlockValidator: Block is either too old or is not the first block with valid signature for \" +\n+              \"its slot. It will be dropped\");\n+      return BlockValidationResult.INVALID;\n+    }\n+\n+    final BeaconState preState = recentChainData.getStore().getBlockState(block.getMessage().getParent_root());\n+    if (!blockPreStateDoesExist(preState) || !blockIsNotFromFutureSlot(block)) {\n+      LOG.trace(\"BlockValidator: Either block pre state does not exist or block is from the future. \" +\n+              \"It will be saved for future processing\");\n+      return BlockValidationResult.SAVED_FOR_FUTURE;\n+    }\n+\n+    try {\n+      BeaconState postState = stateTransition.process_slots(preState, block.getMessage().getSlot());\n+      if (blockIsProposedByTheExpectedProposer(block, postState) &&\n+              blockSignatureIsValidWithRespectToProposerIndex(block, preState, postState)) {\n+        LOG.trace(\"BlockValidator: Block has passed all gossip layer validation\");\n+        return BlockValidationResult.VALID;\n+      }\n+    } catch (EpochProcessingException | SlotProcessingException e) {\n+      LOG.error(\"BlockValidator: Unable to process block state.\", e);\n+      return BlockValidationResult.INVALID;\n+    }\n+\n+    return BlockValidationResult.INVALID;\n+  }\n+\n+  private boolean blockIsNotFromFutureSlot(SignedBeaconBlock block) {\n+    ReadOnlyStore store = recentChainData.getStore();\n+    // .times() and .dividedBy() is to account for the fact that store.time is in seconds\n+    // and MAXIMUM_GOSSIP_CLOCK_DISPARITY is in ms.\n+    UnsignedLong maxTime = store.getTime()\n+            .times(valueOf(1000))\n+            .plus(MAXIMUM_GOSSIP_CLOCK_DISPARITY)\n+            .dividedBy(valueOf(1000));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ2NDIyMg=="}, "originalCommit": {"oid": "4e0fea79e98213e89eba344d803674ad53377051"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ4NTA5OQ==", "bodyText": "Done.", "url": "https://github.com/ConsenSys/teku/pull/1615#discussion_r410485099", "createdAt": "2020-04-17T21:46:02Z", "author": {"login": "cemozerr"}, "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/gossip/topics/validation/BlockValidator.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package tech.pegasys.artemis.networking.eth2.gossip.topics.validation;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.artemis.bls.BLS;\n+import tech.pegasys.artemis.bls.BLSSignature;\n+import tech.pegasys.artemis.core.StateTransition;\n+import tech.pegasys.artemis.core.exceptions.EpochProcessingException;\n+import tech.pegasys.artemis.core.exceptions.SlotProcessingException;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.datastructures.forkchoice.ReadOnlyStore;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.state.Validator;\n+import tech.pegasys.artemis.storage.client.RecentChainData;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static com.google.common.primitives.UnsignedLong.valueOf;\n+import static java.lang.Math.toIntExact;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.compute_signing_root;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_beacon_proposer_index;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_domain;\n+import static tech.pegasys.artemis.statetransition.forkchoice.ForkChoiceUtil.getCurrentSlot;\n+import static tech.pegasys.artemis.util.config.Constants.DOMAIN_BEACON_PROPOSER;\n+import static tech.pegasys.artemis.util.config.Constants.MAXIMUM_GOSSIP_CLOCK_DISPARITY;\n+\n+public class BlockValidator {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final RecentChainData recentChainData;\n+  private final StateTransition stateTransition;\n+  private final Set<UnsignedLong> receivedValidSignatureBlockSlots = new HashSet<>();\n+\n+  public BlockValidator(RecentChainData recentChainData,\n+                        StateTransition stateTransition) {\n+    this.recentChainData = recentChainData;\n+    this.stateTransition = stateTransition;\n+  }\n+\n+  public BlockValidationResult validate(SignedBeaconBlock block) {\n+\n+    if (!blockSlotIsGreaterThanLatestFinalizedSlot(block) || !blockIsFirstBlockWithValidSignatureForSlot(block)) {\n+      LOG.trace(\"BlockValidator: Block is either too old or is not the first block with valid signature for \" +\n+              \"its slot. It will be dropped\");\n+      return BlockValidationResult.INVALID;\n+    }\n+\n+    final BeaconState preState = recentChainData.getStore().getBlockState(block.getMessage().getParent_root());\n+    if (!blockPreStateDoesExist(preState) || !blockIsNotFromFutureSlot(block)) {\n+      LOG.trace(\"BlockValidator: Either block pre state does not exist or block is from the future. \" +\n+              \"It will be saved for future processing\");\n+      return BlockValidationResult.SAVED_FOR_FUTURE;\n+    }\n+\n+    try {\n+      BeaconState postState = stateTransition.process_slots(preState, block.getMessage().getSlot());\n+      if (blockIsProposedByTheExpectedProposer(block, postState) &&\n+              blockSignatureIsValidWithRespectToProposerIndex(block, preState, postState)) {\n+        LOG.trace(\"BlockValidator: Block has passed all gossip layer validation\");\n+        return BlockValidationResult.VALID;\n+      }\n+    } catch (EpochProcessingException | SlotProcessingException e) {\n+      LOG.error(\"BlockValidator: Unable to process block state.\", e);\n+      return BlockValidationResult.INVALID;\n+    }\n+\n+    return BlockValidationResult.INVALID;\n+  }\n+\n+  private boolean blockIsNotFromFutureSlot(SignedBeaconBlock block) {\n+    ReadOnlyStore store = recentChainData.getStore();\n+    // .times() and .dividedBy() is to account for the fact that store.time is in seconds\n+    // and MAXIMUM_GOSSIP_CLOCK_DISPARITY is in ms.\n+    UnsignedLong maxTime = store.getTime()\n+            .times(valueOf(1000))\n+            .plus(MAXIMUM_GOSSIP_CLOCK_DISPARITY)\n+            .dividedBy(valueOf(1000));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ2NDIyMg=="}, "originalCommit": {"oid": "4e0fea79e98213e89eba344d803674ad53377051"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0ODQ5MjU4OnYy", "diffSide": "RIGHT", "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/gossip/topics/validation/BlockValidator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMDo1ODo1M1rOGHc5iA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMTo0ODoyOVrOGHeFPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ2NjY5Ng==", "bodyText": "The add method will return true if we successfully add a new element.  Suggest only continuing with processing if we successfully add to the collection.", "url": "https://github.com/ConsenSys/teku/pull/1615#discussion_r410466696", "createdAt": "2020-04-17T20:58:53Z", "author": {"login": "mbaxter"}, "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/gossip/topics/validation/BlockValidator.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package tech.pegasys.artemis.networking.eth2.gossip.topics.validation;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.artemis.bls.BLS;\n+import tech.pegasys.artemis.bls.BLSSignature;\n+import tech.pegasys.artemis.core.StateTransition;\n+import tech.pegasys.artemis.core.exceptions.EpochProcessingException;\n+import tech.pegasys.artemis.core.exceptions.SlotProcessingException;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.datastructures.forkchoice.ReadOnlyStore;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.state.Validator;\n+import tech.pegasys.artemis.storage.client.RecentChainData;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static com.google.common.primitives.UnsignedLong.valueOf;\n+import static java.lang.Math.toIntExact;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.compute_signing_root;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_beacon_proposer_index;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_domain;\n+import static tech.pegasys.artemis.statetransition.forkchoice.ForkChoiceUtil.getCurrentSlot;\n+import static tech.pegasys.artemis.util.config.Constants.DOMAIN_BEACON_PROPOSER;\n+import static tech.pegasys.artemis.util.config.Constants.MAXIMUM_GOSSIP_CLOCK_DISPARITY;\n+\n+public class BlockValidator {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final RecentChainData recentChainData;\n+  private final StateTransition stateTransition;\n+  private final Set<UnsignedLong> receivedValidSignatureBlockSlots = new HashSet<>();\n+\n+  public BlockValidator(RecentChainData recentChainData,\n+                        StateTransition stateTransition) {\n+    this.recentChainData = recentChainData;\n+    this.stateTransition = stateTransition;\n+  }\n+\n+  public BlockValidationResult validate(SignedBeaconBlock block) {\n+\n+    if (!blockSlotIsGreaterThanLatestFinalizedSlot(block) || !blockIsFirstBlockWithValidSignatureForSlot(block)) {\n+      LOG.trace(\"BlockValidator: Block is either too old or is not the first block with valid signature for \" +\n+              \"its slot. It will be dropped\");\n+      return BlockValidationResult.INVALID;\n+    }\n+\n+    final BeaconState preState = recentChainData.getStore().getBlockState(block.getMessage().getParent_root());\n+    if (!blockPreStateDoesExist(preState) || !blockIsNotFromFutureSlot(block)) {\n+      LOG.trace(\"BlockValidator: Either block pre state does not exist or block is from the future. \" +\n+              \"It will be saved for future processing\");\n+      return BlockValidationResult.SAVED_FOR_FUTURE;\n+    }\n+\n+    try {\n+      BeaconState postState = stateTransition.process_slots(preState, block.getMessage().getSlot());\n+      if (blockIsProposedByTheExpectedProposer(block, postState) &&\n+              blockSignatureIsValidWithRespectToProposerIndex(block, preState, postState)) {\n+        LOG.trace(\"BlockValidator: Block has passed all gossip layer validation\");\n+        return BlockValidationResult.VALID;\n+      }\n+    } catch (EpochProcessingException | SlotProcessingException e) {\n+      LOG.error(\"BlockValidator: Unable to process block state.\", e);\n+      return BlockValidationResult.INVALID;\n+    }\n+\n+    return BlockValidationResult.INVALID;\n+  }\n+\n+  private boolean blockIsNotFromFutureSlot(SignedBeaconBlock block) {\n+    ReadOnlyStore store = recentChainData.getStore();\n+    // .times() and .dividedBy() is to account for the fact that store.time is in seconds\n+    // and MAXIMUM_GOSSIP_CLOCK_DISPARITY is in ms.\n+    UnsignedLong maxTime = store.getTime()\n+            .times(valueOf(1000))\n+            .plus(MAXIMUM_GOSSIP_CLOCK_DISPARITY)\n+            .dividedBy(valueOf(1000));\n+    UnsignedLong maxCurrSlot = getCurrentSlot(maxTime, store.getGenesisTime());\n+    return block.getSlot().compareTo(maxCurrSlot) <= 0;\n+  }\n+\n+  private boolean blockSlotIsGreaterThanLatestFinalizedSlot(SignedBeaconBlock block) {\n+    UnsignedLong finalizedSlot = recentChainData.getStore().getFinalizedCheckpoint().getEpochStartSlot();\n+    return block.getSlot().compareTo(finalizedSlot) > 0;\n+  }\n+\n+  private boolean blockPreStateDoesExist(BeaconState preState) {\n+    return preState != null;\n+  }\n+\n+  private boolean blockIsFirstBlockWithValidSignatureForSlot(SignedBeaconBlock block) {\n+    return !receivedValidSignatureBlockSlots.contains(block.getSlot());\n+  }\n+\n+  private boolean blockSignatureIsValidWithRespectToProposerIndex(SignedBeaconBlock block,\n+                                                                  BeaconState preState,\n+                                                                  BeaconState postState) {\n+      Validator proposer = postState.getValidators().get(\n+              toIntExact(block.getMessage().getProposer_index().longValue())\n+      );\n+\n+      final Bytes domain = get_domain(preState, DOMAIN_BEACON_PROPOSER);\n+      final Bytes signing_root = compute_signing_root(block.getMessage(), domain);\n+      final BLSSignature signature = block.getSignature();\n+      boolean signatureValid = BLS.verify(proposer.getPubkey(), signing_root, signature);\n+\n+      if (signatureValid) {\n+        receivedValidSignatureBlockSlots.add(block.getSlot());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e0fea79e98213e89eba344d803674ad53377051"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ4NjA3OQ==", "bodyText": "Done.", "url": "https://github.com/ConsenSys/teku/pull/1615#discussion_r410486079", "createdAt": "2020-04-17T21:48:29Z", "author": {"login": "cemozerr"}, "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/gossip/topics/validation/BlockValidator.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package tech.pegasys.artemis.networking.eth2.gossip.topics.validation;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.artemis.bls.BLS;\n+import tech.pegasys.artemis.bls.BLSSignature;\n+import tech.pegasys.artemis.core.StateTransition;\n+import tech.pegasys.artemis.core.exceptions.EpochProcessingException;\n+import tech.pegasys.artemis.core.exceptions.SlotProcessingException;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.datastructures.forkchoice.ReadOnlyStore;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.state.Validator;\n+import tech.pegasys.artemis.storage.client.RecentChainData;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static com.google.common.primitives.UnsignedLong.valueOf;\n+import static java.lang.Math.toIntExact;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.compute_signing_root;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_beacon_proposer_index;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_domain;\n+import static tech.pegasys.artemis.statetransition.forkchoice.ForkChoiceUtil.getCurrentSlot;\n+import static tech.pegasys.artemis.util.config.Constants.DOMAIN_BEACON_PROPOSER;\n+import static tech.pegasys.artemis.util.config.Constants.MAXIMUM_GOSSIP_CLOCK_DISPARITY;\n+\n+public class BlockValidator {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final RecentChainData recentChainData;\n+  private final StateTransition stateTransition;\n+  private final Set<UnsignedLong> receivedValidSignatureBlockSlots = new HashSet<>();\n+\n+  public BlockValidator(RecentChainData recentChainData,\n+                        StateTransition stateTransition) {\n+    this.recentChainData = recentChainData;\n+    this.stateTransition = stateTransition;\n+  }\n+\n+  public BlockValidationResult validate(SignedBeaconBlock block) {\n+\n+    if (!blockSlotIsGreaterThanLatestFinalizedSlot(block) || !blockIsFirstBlockWithValidSignatureForSlot(block)) {\n+      LOG.trace(\"BlockValidator: Block is either too old or is not the first block with valid signature for \" +\n+              \"its slot. It will be dropped\");\n+      return BlockValidationResult.INVALID;\n+    }\n+\n+    final BeaconState preState = recentChainData.getStore().getBlockState(block.getMessage().getParent_root());\n+    if (!blockPreStateDoesExist(preState) || !blockIsNotFromFutureSlot(block)) {\n+      LOG.trace(\"BlockValidator: Either block pre state does not exist or block is from the future. \" +\n+              \"It will be saved for future processing\");\n+      return BlockValidationResult.SAVED_FOR_FUTURE;\n+    }\n+\n+    try {\n+      BeaconState postState = stateTransition.process_slots(preState, block.getMessage().getSlot());\n+      if (blockIsProposedByTheExpectedProposer(block, postState) &&\n+              blockSignatureIsValidWithRespectToProposerIndex(block, preState, postState)) {\n+        LOG.trace(\"BlockValidator: Block has passed all gossip layer validation\");\n+        return BlockValidationResult.VALID;\n+      }\n+    } catch (EpochProcessingException | SlotProcessingException e) {\n+      LOG.error(\"BlockValidator: Unable to process block state.\", e);\n+      return BlockValidationResult.INVALID;\n+    }\n+\n+    return BlockValidationResult.INVALID;\n+  }\n+\n+  private boolean blockIsNotFromFutureSlot(SignedBeaconBlock block) {\n+    ReadOnlyStore store = recentChainData.getStore();\n+    // .times() and .dividedBy() is to account for the fact that store.time is in seconds\n+    // and MAXIMUM_GOSSIP_CLOCK_DISPARITY is in ms.\n+    UnsignedLong maxTime = store.getTime()\n+            .times(valueOf(1000))\n+            .plus(MAXIMUM_GOSSIP_CLOCK_DISPARITY)\n+            .dividedBy(valueOf(1000));\n+    UnsignedLong maxCurrSlot = getCurrentSlot(maxTime, store.getGenesisTime());\n+    return block.getSlot().compareTo(maxCurrSlot) <= 0;\n+  }\n+\n+  private boolean blockSlotIsGreaterThanLatestFinalizedSlot(SignedBeaconBlock block) {\n+    UnsignedLong finalizedSlot = recentChainData.getStore().getFinalizedCheckpoint().getEpochStartSlot();\n+    return block.getSlot().compareTo(finalizedSlot) > 0;\n+  }\n+\n+  private boolean blockPreStateDoesExist(BeaconState preState) {\n+    return preState != null;\n+  }\n+\n+  private boolean blockIsFirstBlockWithValidSignatureForSlot(SignedBeaconBlock block) {\n+    return !receivedValidSignatureBlockSlots.contains(block.getSlot());\n+  }\n+\n+  private boolean blockSignatureIsValidWithRespectToProposerIndex(SignedBeaconBlock block,\n+                                                                  BeaconState preState,\n+                                                                  BeaconState postState) {\n+      Validator proposer = postState.getValidators().get(\n+              toIntExact(block.getMessage().getProposer_index().longValue())\n+      );\n+\n+      final Bytes domain = get_domain(preState, DOMAIN_BEACON_PROPOSER);\n+      final Bytes signing_root = compute_signing_root(block.getMessage(), domain);\n+      final BLSSignature signature = block.getSignature();\n+      boolean signatureValid = BLS.verify(proposer.getPubkey(), signing_root, signature);\n+\n+      if (signatureValid) {\n+        receivedValidSignatureBlockSlots.add(block.getSlot());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ2NjY5Ng=="}, "originalCommit": {"oid": "4e0fea79e98213e89eba344d803674ad53377051"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0ODUwMDI0OnYy", "diffSide": "RIGHT", "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/gossip/topics/validation/BlockValidator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMTowMTozN1rOGHc-Uw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMjoxMTo1NFrOGHel4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ2NzkyMw==", "bodyText": "I think we need to put slot/proposerIndex pairs in this collection ... What if there are multiple forks where we have different valid proposers for the same slot on different forks?", "url": "https://github.com/ConsenSys/teku/pull/1615#discussion_r410467923", "createdAt": "2020-04-17T21:01:37Z", "author": {"login": "mbaxter"}, "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/gossip/topics/validation/BlockValidator.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package tech.pegasys.artemis.networking.eth2.gossip.topics.validation;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.artemis.bls.BLS;\n+import tech.pegasys.artemis.bls.BLSSignature;\n+import tech.pegasys.artemis.core.StateTransition;\n+import tech.pegasys.artemis.core.exceptions.EpochProcessingException;\n+import tech.pegasys.artemis.core.exceptions.SlotProcessingException;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.datastructures.forkchoice.ReadOnlyStore;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.state.Validator;\n+import tech.pegasys.artemis.storage.client.RecentChainData;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static com.google.common.primitives.UnsignedLong.valueOf;\n+import static java.lang.Math.toIntExact;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.compute_signing_root;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_beacon_proposer_index;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_domain;\n+import static tech.pegasys.artemis.statetransition.forkchoice.ForkChoiceUtil.getCurrentSlot;\n+import static tech.pegasys.artemis.util.config.Constants.DOMAIN_BEACON_PROPOSER;\n+import static tech.pegasys.artemis.util.config.Constants.MAXIMUM_GOSSIP_CLOCK_DISPARITY;\n+\n+public class BlockValidator {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final RecentChainData recentChainData;\n+  private final StateTransition stateTransition;\n+  private final Set<UnsignedLong> receivedValidSignatureBlockSlots = new HashSet<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e0fea79e98213e89eba344d803674ad53377051"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ5NDQzNA==", "bodyText": "Done.", "url": "https://github.com/ConsenSys/teku/pull/1615#discussion_r410494434", "createdAt": "2020-04-17T22:11:54Z", "author": {"login": "cemozerr"}, "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/gossip/topics/validation/BlockValidator.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package tech.pegasys.artemis.networking.eth2.gossip.topics.validation;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.artemis.bls.BLS;\n+import tech.pegasys.artemis.bls.BLSSignature;\n+import tech.pegasys.artemis.core.StateTransition;\n+import tech.pegasys.artemis.core.exceptions.EpochProcessingException;\n+import tech.pegasys.artemis.core.exceptions.SlotProcessingException;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.datastructures.forkchoice.ReadOnlyStore;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.state.Validator;\n+import tech.pegasys.artemis.storage.client.RecentChainData;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static com.google.common.primitives.UnsignedLong.valueOf;\n+import static java.lang.Math.toIntExact;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.compute_signing_root;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_beacon_proposer_index;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_domain;\n+import static tech.pegasys.artemis.statetransition.forkchoice.ForkChoiceUtil.getCurrentSlot;\n+import static tech.pegasys.artemis.util.config.Constants.DOMAIN_BEACON_PROPOSER;\n+import static tech.pegasys.artemis.util.config.Constants.MAXIMUM_GOSSIP_CLOCK_DISPARITY;\n+\n+public class BlockValidator {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final RecentChainData recentChainData;\n+  private final StateTransition stateTransition;\n+  private final Set<UnsignedLong> receivedValidSignatureBlockSlots = new HashSet<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ2NzkyMw=="}, "originalCommit": {"oid": "4e0fea79e98213e89eba344d803674ad53377051"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0ODUyNDA5OnYy", "diffSide": "RIGHT", "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/gossip/topics/BlockTopicHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMToxMDoyN1rOGHdNAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMToxMDoyN1rOGHdNAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ3MTY4MA==", "bodyText": "nice :D", "url": "https://github.com/ConsenSys/teku/pull/1615#discussion_r410471680", "createdAt": "2020-04-17T21:10:27Z", "author": {"login": "mbaxter"}, "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/gossip/topics/BlockTopicHandler.java", "diffHunk": "@@ -66,49 +56,18 @@ protected SignedBeaconBlock deserialize(final Bytes bytes) throws SSZException {\n \n   @Override\n   protected boolean validateData(final SignedBeaconBlock block) {\n-    if (recentChainData.isPreGenesis()) {\n-      // We can't process blocks pre-genesis\n-      return false;\n-    }\n-\n-    final BeaconState preState =\n-        recentChainData.getStore().getBlockState(block.getMessage().getParent_root());\n-    if (preState == null) {\n-      // Post event even if we don't have the prestate\n-      eventBus.post(createEvent(block));\n-      return false;\n-    }\n-\n-    if (!isBlockSignatureValid(block, preState)) {\n-      LOG.trace(\"Dropping gossiped block with invalid signature: {}\", block);\n-      return false;\n-    }\n-\n-    final UnsignedLong currentSlot = get_current_slot(recentChainData.getStore());\n-    if (block.getSlot().compareTo(currentSlot) > 0) {\n-      // Don't gossip future blocks\n-      eventBus.post(createEvent(block));\n-      return false;\n-    }\n-\n-    return true;\n-  }\n-\n-  private boolean isBlockSignatureValid(final SignedBeaconBlock block, final BeaconState preState) {\n-    final StateTransition stateTransition = new StateTransition();\n-\n-    try {\n-      BeaconState postState = stateTransition.process_slots(preState, block.getMessage().getSlot());\n-      final int proposerIndex = get_beacon_proposer_index(postState);\n-      final Validator proposer = postState.getValidators().get(proposerIndex);\n-      final Bytes domain = get_domain(preState, DOMAIN_BEACON_PROPOSER);\n-      final Bytes signing_root = compute_signing_root(block.getMessage(), domain);\n-      final BLSSignature signature = block.getSignature();\n-      return BLS.verify(proposer.getPubkey(), signing_root, signature);\n-\n-    } catch (EpochProcessingException | SlotProcessingException e) {\n-      LOG.error(\"Unable to process block state.\", e);\n-      return false;\n+    BlockValidationResult blockValidationResult = blockValidator.validate(block);\n+    switch (blockValidationResult) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e0fea79e98213e89eba344d803674ad53377051"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU0ODUzMjg2OnYy", "diffSide": "RIGHT", "path": "networking/eth2/src/test/java/tech/pegasys/artemis/networking/eth2/gossip/BlockValidatorTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMToxMzo1OFrOGHdSYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMTo0OTozMFrOGHeHGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ3MzA1OA==", "bodyText": "Looks like a few test cases are missing for invalid signatures, missing prestate, duplicate block", "url": "https://github.com/ConsenSys/teku/pull/1615#discussion_r410473058", "createdAt": "2020-04-17T21:13:58Z", "author": {"login": "mbaxter"}, "path": "networking/eth2/src/test/java/tech/pegasys/artemis/networking/eth2/gossip/BlockValidatorTest.java", "diffHunk": "@@ -0,0 +1,69 @@\n+package tech.pegasys.artemis.networking.eth2.gossip;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.primitives.UnsignedLong;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import tech.pegasys.artemis.bls.BLSKeyGenerator;\n+import tech.pegasys.artemis.bls.BLSKeyPair;\n+import tech.pegasys.artemis.core.ChainBuilder;\n+import tech.pegasys.artemis.core.StateTransition;\n+import tech.pegasys.artemis.core.StateTransitionException;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.networking.eth2.gossip.topics.validation.BlockValidationResult;\n+import tech.pegasys.artemis.networking.eth2.gossip.topics.validation.BlockValidator;\n+import tech.pegasys.artemis.statetransition.BeaconChainUtil;\n+import tech.pegasys.artemis.storage.client.MemoryOnlyRecentChainData;\n+import tech.pegasys.artemis.storage.client.RecentChainData;\n+\n+import java.util.List;\n+\n+import static com.google.common.primitives.UnsignedLong.ONE;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.mock;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.compute_start_slot_at_epoch;\n+\n+public class BlockValidatorTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e0fea79e98213e89eba344d803674ad53377051"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ4NjU1NQ==", "bodyText": "Yeah, I put it up as a draft PR to get feedback. Gotta figure out how to make PR's actually draft.", "url": "https://github.com/ConsenSys/teku/pull/1615#discussion_r410486555", "createdAt": "2020-04-17T21:49:30Z", "author": {"login": "cemozerr"}, "path": "networking/eth2/src/test/java/tech/pegasys/artemis/networking/eth2/gossip/BlockValidatorTest.java", "diffHunk": "@@ -0,0 +1,69 @@\n+package tech.pegasys.artemis.networking.eth2.gossip;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.primitives.UnsignedLong;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import tech.pegasys.artemis.bls.BLSKeyGenerator;\n+import tech.pegasys.artemis.bls.BLSKeyPair;\n+import tech.pegasys.artemis.core.ChainBuilder;\n+import tech.pegasys.artemis.core.StateTransition;\n+import tech.pegasys.artemis.core.StateTransitionException;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.networking.eth2.gossip.topics.validation.BlockValidationResult;\n+import tech.pegasys.artemis.networking.eth2.gossip.topics.validation.BlockValidator;\n+import tech.pegasys.artemis.statetransition.BeaconChainUtil;\n+import tech.pegasys.artemis.storage.client.MemoryOnlyRecentChainData;\n+import tech.pegasys.artemis.storage.client.RecentChainData;\n+\n+import java.util.List;\n+\n+import static com.google.common.primitives.UnsignedLong.ONE;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.mock;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.compute_start_slot_at_epoch;\n+\n+public class BlockValidatorTest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ3MzA1OA=="}, "originalCommit": {"oid": "4e0fea79e98213e89eba344d803674ad53377051"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1MzcyMDA3OnYy", "diffSide": "RIGHT", "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/gossip/topics/BlockTopicHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwNDo0NTozOFrOGIC63A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNzoxNDozN1rOGIfB0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTA4OTYyOA==", "bodyText": "nit: We should provide a message here to indicate what the unexpected value was.", "url": "https://github.com/ConsenSys/teku/pull/1615#discussion_r411089628", "createdAt": "2020-04-20T04:45:38Z", "author": {"login": "ajsutton"}, "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/gossip/topics/BlockTopicHandler.java", "diffHunk": "@@ -66,49 +50,17 @@ protected SignedBeaconBlock deserialize(final Bytes bytes) throws SSZException {\n \n   @Override\n   protected boolean validateData(final SignedBeaconBlock block) {\n-    if (recentChainData.isPreGenesis()) {\n-      // We can't process blocks pre-genesis\n-      return false;\n-    }\n-\n-    final BeaconState preState =\n-        recentChainData.getStore().getBlockState(block.getMessage().getParent_root());\n-    if (preState == null) {\n-      // Post event even if we don't have the prestate\n-      eventBus.post(createEvent(block));\n-      return false;\n-    }\n-\n-    if (!isBlockSignatureValid(block, preState)) {\n-      LOG.trace(\"Dropping gossiped block with invalid signature: {}\", block);\n-      return false;\n-    }\n-\n-    final UnsignedLong currentSlot = get_current_slot(recentChainData.getStore());\n-    if (block.getSlot().compareTo(currentSlot) > 0) {\n-      // Don't gossip future blocks\n-      eventBus.post(createEvent(block));\n-      return false;\n-    }\n-\n-    return true;\n-  }\n-\n-  private boolean isBlockSignatureValid(final SignedBeaconBlock block, final BeaconState preState) {\n-    final StateTransition stateTransition = new StateTransition();\n-\n-    try {\n-      BeaconState postState = stateTransition.process_slots(preState, block.getMessage().getSlot());\n-      final int proposerIndex = get_beacon_proposer_index(postState);\n-      final Validator proposer = postState.getValidators().get(proposerIndex);\n-      final Bytes domain = get_domain(preState, DOMAIN_BEACON_PROPOSER);\n-      final Bytes signing_root = compute_signing_root(block.getMessage(), domain);\n-      final BLSSignature signature = block.getSignature();\n-      return BLS.verify(proposer.getPubkey(), signing_root, signature);\n-\n-    } catch (EpochProcessingException | SlotProcessingException e) {\n-      LOG.error(\"Unable to process block state.\", e);\n-      return false;\n+    BlockValidationResult blockValidationResult = blockValidator.validate(block);\n+    switch (blockValidationResult) {\n+      case INVALID:\n+        return false;\n+      case SAVED_FOR_FUTURE:\n+        eventBus.post(createEvent(block));\n+        return false;\n+      case VALID:\n+        return true;\n+      default:\n+        throw new UnsupportedOperationException();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a38713fa1922a8b1f6b348fd578ff01dd0ad066c"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU1MDE2MQ==", "bodyText": "done.", "url": "https://github.com/ConsenSys/teku/pull/1615#discussion_r411550161", "createdAt": "2020-04-20T17:14:37Z", "author": {"login": "cemozerr"}, "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/gossip/topics/BlockTopicHandler.java", "diffHunk": "@@ -66,49 +50,17 @@ protected SignedBeaconBlock deserialize(final Bytes bytes) throws SSZException {\n \n   @Override\n   protected boolean validateData(final SignedBeaconBlock block) {\n-    if (recentChainData.isPreGenesis()) {\n-      // We can't process blocks pre-genesis\n-      return false;\n-    }\n-\n-    final BeaconState preState =\n-        recentChainData.getStore().getBlockState(block.getMessage().getParent_root());\n-    if (preState == null) {\n-      // Post event even if we don't have the prestate\n-      eventBus.post(createEvent(block));\n-      return false;\n-    }\n-\n-    if (!isBlockSignatureValid(block, preState)) {\n-      LOG.trace(\"Dropping gossiped block with invalid signature: {}\", block);\n-      return false;\n-    }\n-\n-    final UnsignedLong currentSlot = get_current_slot(recentChainData.getStore());\n-    if (block.getSlot().compareTo(currentSlot) > 0) {\n-      // Don't gossip future blocks\n-      eventBus.post(createEvent(block));\n-      return false;\n-    }\n-\n-    return true;\n-  }\n-\n-  private boolean isBlockSignatureValid(final SignedBeaconBlock block, final BeaconState preState) {\n-    final StateTransition stateTransition = new StateTransition();\n-\n-    try {\n-      BeaconState postState = stateTransition.process_slots(preState, block.getMessage().getSlot());\n-      final int proposerIndex = get_beacon_proposer_index(postState);\n-      final Validator proposer = postState.getValidators().get(proposerIndex);\n-      final Bytes domain = get_domain(preState, DOMAIN_BEACON_PROPOSER);\n-      final Bytes signing_root = compute_signing_root(block.getMessage(), domain);\n-      final BLSSignature signature = block.getSignature();\n-      return BLS.verify(proposer.getPubkey(), signing_root, signature);\n-\n-    } catch (EpochProcessingException | SlotProcessingException e) {\n-      LOG.error(\"Unable to process block state.\", e);\n-      return false;\n+    BlockValidationResult blockValidationResult = blockValidator.validate(block);\n+    switch (blockValidationResult) {\n+      case INVALID:\n+        return false;\n+      case SAVED_FOR_FUTURE:\n+        eventBus.post(createEvent(block));\n+        return false;\n+      case VALID:\n+        return true;\n+      default:\n+        throw new UnsupportedOperationException();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTA4OTYyOA=="}, "originalCommit": {"oid": "a38713fa1922a8b1f6b348fd578ff01dd0ad066c"}, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1MzczOTQwOnYy", "diffSide": "RIGHT", "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/gossip/topics/validation/BlockValidator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwNDo1NDoxOFrOGIDE8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNzoxOTo1M1rOGIfPcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTA5MjIxMA==", "bodyText": "We should be using the caches for this via AttestationUtil.getValidatorPubKey (which probably should be moved to a public method in ValidatorsUtil.", "url": "https://github.com/ConsenSys/teku/pull/1615#discussion_r411092210", "createdAt": "2020-04-20T04:54:18Z", "author": {"login": "ajsutton"}, "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/gossip/topics/validation/BlockValidator.java", "diffHunk": "@@ -0,0 +1,155 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.networking.eth2.gossip.topics.validation;\n+\n+import static java.lang.Math.toIntExact;\n+import static tech.pegasys.artemis.core.ForkChoiceUtil.getCurrentSlot;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.compute_signing_root;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_beacon_proposer_index;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_domain;\n+import static tech.pegasys.artemis.util.config.Constants.DOMAIN_BEACON_PROPOSER;\n+import static tech.pegasys.artemis.util.config.Constants.MAXIMUM_GOSSIP_CLOCK_DISPARITY;\n+import static tech.pegasys.artemis.util.config.Constants.VALID_BLOCK_SET_SIZE;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.Optional;\n+import java.util.Set;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.artemis.bls.BLS;\n+import tech.pegasys.artemis.bls.BLSSignature;\n+import tech.pegasys.artemis.core.StateTransition;\n+import tech.pegasys.artemis.core.exceptions.EpochProcessingException;\n+import tech.pegasys.artemis.core.exceptions.SlotProcessingException;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.datastructures.forkchoice.ReadOnlyStore;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.state.Validator;\n+import tech.pegasys.artemis.storage.client.RecentChainData;\n+import tech.pegasys.artemis.util.collections.ConcurrentLimitedSet;\n+import tech.pegasys.artemis.util.collections.LimitStrategy;\n+\n+public class BlockValidator {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final RecentChainData recentChainData;\n+  private final StateTransition stateTransition;\n+  private final Set<SlotAndProposer> receivedValidBlockInfoSet =\n+      ConcurrentLimitedSet.create(VALID_BLOCK_SET_SIZE, LimitStrategy.DROP_OLDEST_ELEMENT);\n+\n+  public BlockValidator(RecentChainData recentChainData, StateTransition stateTransition) {\n+    this.recentChainData = recentChainData;\n+    this.stateTransition = stateTransition;\n+  }\n+\n+  public BlockValidationResult validate(SignedBeaconBlock block) {\n+\n+    if (!blockSlotIsGreaterThanLatestFinalizedSlot(block)\n+        || !blockIsFirstBlockWithValidSignatureForSlot(block)) {\n+      LOG.trace(\n+          \"BlockValidator: Block is either too old or is not the first block with valid signature for \"\n+              + \"its slot. It will be dropped\");\n+      return BlockValidationResult.INVALID;\n+    }\n+\n+    final Optional<BeaconState> preState =\n+        Optional.ofNullable(\n+            recentChainData.getStore().getBlockState(block.getMessage().getParent_root()));\n+    if (preState.isEmpty() || blockIsFromFutureSlot(block)) {\n+      LOG.trace(\n+          \"BlockValidator: Either block pre state does not exist or block is from the future. \"\n+              + \"It will be saved for future processing\");\n+      return BlockValidationResult.SAVED_FOR_FUTURE;\n+    }\n+\n+    try {\n+      BeaconState postState =\n+          stateTransition.process_slots(preState.get(), block.getMessage().getSlot());\n+      if (blockIsProposedByTheExpectedProposer(block, postState)\n+          && blockSignatureIsValidWithRespectToProposerIndex(block, preState.get(), postState)) {\n+        return BlockValidationResult.VALID;\n+      }\n+    } catch (EpochProcessingException | SlotProcessingException e) {\n+      LOG.error(\"BlockValidator: Unable to process block state.\", e);\n+      return BlockValidationResult.INVALID;\n+    }\n+\n+    return BlockValidationResult.INVALID;\n+  }\n+\n+  private boolean blockIsFromFutureSlot(SignedBeaconBlock block) {\n+    ReadOnlyStore store = recentChainData.getStore();\n+    final long disparityInSeconds = Math.round((float) MAXIMUM_GOSSIP_CLOCK_DISPARITY / 1000.0);\n+    final UnsignedLong maxOffset = UnsignedLong.valueOf(disparityInSeconds);\n+    final UnsignedLong maxTime = store.getTime().plus(maxOffset);\n+    UnsignedLong maxCurrSlot = getCurrentSlot(maxTime, store.getGenesisTime());\n+    return block.getSlot().compareTo(maxCurrSlot) > 0;\n+  }\n+\n+  private boolean blockSlotIsGreaterThanLatestFinalizedSlot(SignedBeaconBlock block) {\n+    UnsignedLong finalizedSlot =\n+        recentChainData.getStore().getFinalizedCheckpoint().getEpochStartSlot();\n+    return block.getSlot().compareTo(finalizedSlot) > 0;\n+  }\n+\n+  private boolean blockIsFirstBlockWithValidSignatureForSlot(SignedBeaconBlock block) {\n+    return !receivedValidBlockInfoSet.contains(new SlotAndProposer(block));\n+  }\n+\n+  private boolean blockSignatureIsValidWithRespectToProposerIndex(\n+      SignedBeaconBlock block, BeaconState preState, BeaconState postState) {\n+    Validator proposer =\n+        postState\n+            .getValidators()\n+            .get(toIntExact(block.getMessage().getProposer_index().longValue()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a38713fa1922a8b1f6b348fd578ff01dd0ad066c"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU1MzY0OQ==", "bodyText": "Both done.", "url": "https://github.com/ConsenSys/teku/pull/1615#discussion_r411553649", "createdAt": "2020-04-20T17:19:53Z", "author": {"login": "cemozerr"}, "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/gossip/topics/validation/BlockValidator.java", "diffHunk": "@@ -0,0 +1,155 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.networking.eth2.gossip.topics.validation;\n+\n+import static java.lang.Math.toIntExact;\n+import static tech.pegasys.artemis.core.ForkChoiceUtil.getCurrentSlot;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.compute_signing_root;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_beacon_proposer_index;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_domain;\n+import static tech.pegasys.artemis.util.config.Constants.DOMAIN_BEACON_PROPOSER;\n+import static tech.pegasys.artemis.util.config.Constants.MAXIMUM_GOSSIP_CLOCK_DISPARITY;\n+import static tech.pegasys.artemis.util.config.Constants.VALID_BLOCK_SET_SIZE;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.Optional;\n+import java.util.Set;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.artemis.bls.BLS;\n+import tech.pegasys.artemis.bls.BLSSignature;\n+import tech.pegasys.artemis.core.StateTransition;\n+import tech.pegasys.artemis.core.exceptions.EpochProcessingException;\n+import tech.pegasys.artemis.core.exceptions.SlotProcessingException;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.datastructures.forkchoice.ReadOnlyStore;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.state.Validator;\n+import tech.pegasys.artemis.storage.client.RecentChainData;\n+import tech.pegasys.artemis.util.collections.ConcurrentLimitedSet;\n+import tech.pegasys.artemis.util.collections.LimitStrategy;\n+\n+public class BlockValidator {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final RecentChainData recentChainData;\n+  private final StateTransition stateTransition;\n+  private final Set<SlotAndProposer> receivedValidBlockInfoSet =\n+      ConcurrentLimitedSet.create(VALID_BLOCK_SET_SIZE, LimitStrategy.DROP_OLDEST_ELEMENT);\n+\n+  public BlockValidator(RecentChainData recentChainData, StateTransition stateTransition) {\n+    this.recentChainData = recentChainData;\n+    this.stateTransition = stateTransition;\n+  }\n+\n+  public BlockValidationResult validate(SignedBeaconBlock block) {\n+\n+    if (!blockSlotIsGreaterThanLatestFinalizedSlot(block)\n+        || !blockIsFirstBlockWithValidSignatureForSlot(block)) {\n+      LOG.trace(\n+          \"BlockValidator: Block is either too old or is not the first block with valid signature for \"\n+              + \"its slot. It will be dropped\");\n+      return BlockValidationResult.INVALID;\n+    }\n+\n+    final Optional<BeaconState> preState =\n+        Optional.ofNullable(\n+            recentChainData.getStore().getBlockState(block.getMessage().getParent_root()));\n+    if (preState.isEmpty() || blockIsFromFutureSlot(block)) {\n+      LOG.trace(\n+          \"BlockValidator: Either block pre state does not exist or block is from the future. \"\n+              + \"It will be saved for future processing\");\n+      return BlockValidationResult.SAVED_FOR_FUTURE;\n+    }\n+\n+    try {\n+      BeaconState postState =\n+          stateTransition.process_slots(preState.get(), block.getMessage().getSlot());\n+      if (blockIsProposedByTheExpectedProposer(block, postState)\n+          && blockSignatureIsValidWithRespectToProposerIndex(block, preState.get(), postState)) {\n+        return BlockValidationResult.VALID;\n+      }\n+    } catch (EpochProcessingException | SlotProcessingException e) {\n+      LOG.error(\"BlockValidator: Unable to process block state.\", e);\n+      return BlockValidationResult.INVALID;\n+    }\n+\n+    return BlockValidationResult.INVALID;\n+  }\n+\n+  private boolean blockIsFromFutureSlot(SignedBeaconBlock block) {\n+    ReadOnlyStore store = recentChainData.getStore();\n+    final long disparityInSeconds = Math.round((float) MAXIMUM_GOSSIP_CLOCK_DISPARITY / 1000.0);\n+    final UnsignedLong maxOffset = UnsignedLong.valueOf(disparityInSeconds);\n+    final UnsignedLong maxTime = store.getTime().plus(maxOffset);\n+    UnsignedLong maxCurrSlot = getCurrentSlot(maxTime, store.getGenesisTime());\n+    return block.getSlot().compareTo(maxCurrSlot) > 0;\n+  }\n+\n+  private boolean blockSlotIsGreaterThanLatestFinalizedSlot(SignedBeaconBlock block) {\n+    UnsignedLong finalizedSlot =\n+        recentChainData.getStore().getFinalizedCheckpoint().getEpochStartSlot();\n+    return block.getSlot().compareTo(finalizedSlot) > 0;\n+  }\n+\n+  private boolean blockIsFirstBlockWithValidSignatureForSlot(SignedBeaconBlock block) {\n+    return !receivedValidBlockInfoSet.contains(new SlotAndProposer(block));\n+  }\n+\n+  private boolean blockSignatureIsValidWithRespectToProposerIndex(\n+      SignedBeaconBlock block, BeaconState preState, BeaconState postState) {\n+    Validator proposer =\n+        postState\n+            .getValidators()\n+            .get(toIntExact(block.getMessage().getProposer_index().longValue()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTA5MjIxMA=="}, "originalCommit": {"oid": "a38713fa1922a8b1f6b348fd578ff01dd0ad066c"}, "originalPosition": 117}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1Mzc0MjQxOnYy", "diffSide": "RIGHT", "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/gossip/topics/validation/BlockValidator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwNDo1NTo0MlrOGIDGiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNzoyMDo0NVrOGIfRnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTA5MjYxNw==", "bodyText": "Remove the toIntExact here and use long comparison (the int proposerIndex will be automatically up-cast to a long).  That way it will evaluate to false if proposer index is greater than Integer.MAX_VALUE rather than throwing an exception.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                return proposerIndex == toIntExact(block.getMessage().getProposer_index().longValue());\n          \n          \n            \n                return proposerIndex == block.getMessage().getProposer_index().longValue();", "url": "https://github.com/ConsenSys/teku/pull/1615#discussion_r411092617", "createdAt": "2020-04-20T04:55:42Z", "author": {"login": "ajsutton"}, "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/gossip/topics/validation/BlockValidator.java", "diffHunk": "@@ -0,0 +1,155 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.networking.eth2.gossip.topics.validation;\n+\n+import static java.lang.Math.toIntExact;\n+import static tech.pegasys.artemis.core.ForkChoiceUtil.getCurrentSlot;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.compute_signing_root;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_beacon_proposer_index;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_domain;\n+import static tech.pegasys.artemis.util.config.Constants.DOMAIN_BEACON_PROPOSER;\n+import static tech.pegasys.artemis.util.config.Constants.MAXIMUM_GOSSIP_CLOCK_DISPARITY;\n+import static tech.pegasys.artemis.util.config.Constants.VALID_BLOCK_SET_SIZE;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.Optional;\n+import java.util.Set;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.artemis.bls.BLS;\n+import tech.pegasys.artemis.bls.BLSSignature;\n+import tech.pegasys.artemis.core.StateTransition;\n+import tech.pegasys.artemis.core.exceptions.EpochProcessingException;\n+import tech.pegasys.artemis.core.exceptions.SlotProcessingException;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.datastructures.forkchoice.ReadOnlyStore;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.state.Validator;\n+import tech.pegasys.artemis.storage.client.RecentChainData;\n+import tech.pegasys.artemis.util.collections.ConcurrentLimitedSet;\n+import tech.pegasys.artemis.util.collections.LimitStrategy;\n+\n+public class BlockValidator {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final RecentChainData recentChainData;\n+  private final StateTransition stateTransition;\n+  private final Set<SlotAndProposer> receivedValidBlockInfoSet =\n+      ConcurrentLimitedSet.create(VALID_BLOCK_SET_SIZE, LimitStrategy.DROP_OLDEST_ELEMENT);\n+\n+  public BlockValidator(RecentChainData recentChainData, StateTransition stateTransition) {\n+    this.recentChainData = recentChainData;\n+    this.stateTransition = stateTransition;\n+  }\n+\n+  public BlockValidationResult validate(SignedBeaconBlock block) {\n+\n+    if (!blockSlotIsGreaterThanLatestFinalizedSlot(block)\n+        || !blockIsFirstBlockWithValidSignatureForSlot(block)) {\n+      LOG.trace(\n+          \"BlockValidator: Block is either too old or is not the first block with valid signature for \"\n+              + \"its slot. It will be dropped\");\n+      return BlockValidationResult.INVALID;\n+    }\n+\n+    final Optional<BeaconState> preState =\n+        Optional.ofNullable(\n+            recentChainData.getStore().getBlockState(block.getMessage().getParent_root()));\n+    if (preState.isEmpty() || blockIsFromFutureSlot(block)) {\n+      LOG.trace(\n+          \"BlockValidator: Either block pre state does not exist or block is from the future. \"\n+              + \"It will be saved for future processing\");\n+      return BlockValidationResult.SAVED_FOR_FUTURE;\n+    }\n+\n+    try {\n+      BeaconState postState =\n+          stateTransition.process_slots(preState.get(), block.getMessage().getSlot());\n+      if (blockIsProposedByTheExpectedProposer(block, postState)\n+          && blockSignatureIsValidWithRespectToProposerIndex(block, preState.get(), postState)) {\n+        return BlockValidationResult.VALID;\n+      }\n+    } catch (EpochProcessingException | SlotProcessingException e) {\n+      LOG.error(\"BlockValidator: Unable to process block state.\", e);\n+      return BlockValidationResult.INVALID;\n+    }\n+\n+    return BlockValidationResult.INVALID;\n+  }\n+\n+  private boolean blockIsFromFutureSlot(SignedBeaconBlock block) {\n+    ReadOnlyStore store = recentChainData.getStore();\n+    final long disparityInSeconds = Math.round((float) MAXIMUM_GOSSIP_CLOCK_DISPARITY / 1000.0);\n+    final UnsignedLong maxOffset = UnsignedLong.valueOf(disparityInSeconds);\n+    final UnsignedLong maxTime = store.getTime().plus(maxOffset);\n+    UnsignedLong maxCurrSlot = getCurrentSlot(maxTime, store.getGenesisTime());\n+    return block.getSlot().compareTo(maxCurrSlot) > 0;\n+  }\n+\n+  private boolean blockSlotIsGreaterThanLatestFinalizedSlot(SignedBeaconBlock block) {\n+    UnsignedLong finalizedSlot =\n+        recentChainData.getStore().getFinalizedCheckpoint().getEpochStartSlot();\n+    return block.getSlot().compareTo(finalizedSlot) > 0;\n+  }\n+\n+  private boolean blockIsFirstBlockWithValidSignatureForSlot(SignedBeaconBlock block) {\n+    return !receivedValidBlockInfoSet.contains(new SlotAndProposer(block));\n+  }\n+\n+  private boolean blockSignatureIsValidWithRespectToProposerIndex(\n+      SignedBeaconBlock block, BeaconState preState, BeaconState postState) {\n+    Validator proposer =\n+        postState\n+            .getValidators()\n+            .get(toIntExact(block.getMessage().getProposer_index().longValue()));\n+\n+    final Bytes domain = get_domain(preState, DOMAIN_BEACON_PROPOSER);\n+    final Bytes signing_root = compute_signing_root(block.getMessage(), domain);\n+    final BLSSignature signature = block.getSignature();\n+    boolean signatureValid = BLS.verify(proposer.getPubkey(), signing_root, signature);\n+\n+    return signatureValid && receivedValidBlockInfoSet.add(new SlotAndProposer(block));\n+  }\n+\n+  private boolean blockIsProposedByTheExpectedProposer(\n+      SignedBeaconBlock block, BeaconState postState) {\n+    final int proposerIndex = get_beacon_proposer_index(postState);\n+    return proposerIndex == toIntExact(block.getMessage().getProposer_index().longValue());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a38713fa1922a8b1f6b348fd578ff01dd0ad066c"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU1NDIwNQ==", "bodyText": "done.", "url": "https://github.com/ConsenSys/teku/pull/1615#discussion_r411554205", "createdAt": "2020-04-20T17:20:45Z", "author": {"login": "cemozerr"}, "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/gossip/topics/validation/BlockValidator.java", "diffHunk": "@@ -0,0 +1,155 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.networking.eth2.gossip.topics.validation;\n+\n+import static java.lang.Math.toIntExact;\n+import static tech.pegasys.artemis.core.ForkChoiceUtil.getCurrentSlot;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.compute_signing_root;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_beacon_proposer_index;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.get_domain;\n+import static tech.pegasys.artemis.util.config.Constants.DOMAIN_BEACON_PROPOSER;\n+import static tech.pegasys.artemis.util.config.Constants.MAXIMUM_GOSSIP_CLOCK_DISPARITY;\n+import static tech.pegasys.artemis.util.config.Constants.VALID_BLOCK_SET_SIZE;\n+\n+import com.google.common.base.Objects;\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.Optional;\n+import java.util.Set;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.artemis.bls.BLS;\n+import tech.pegasys.artemis.bls.BLSSignature;\n+import tech.pegasys.artemis.core.StateTransition;\n+import tech.pegasys.artemis.core.exceptions.EpochProcessingException;\n+import tech.pegasys.artemis.core.exceptions.SlotProcessingException;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.datastructures.forkchoice.ReadOnlyStore;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.state.Validator;\n+import tech.pegasys.artemis.storage.client.RecentChainData;\n+import tech.pegasys.artemis.util.collections.ConcurrentLimitedSet;\n+import tech.pegasys.artemis.util.collections.LimitStrategy;\n+\n+public class BlockValidator {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final RecentChainData recentChainData;\n+  private final StateTransition stateTransition;\n+  private final Set<SlotAndProposer> receivedValidBlockInfoSet =\n+      ConcurrentLimitedSet.create(VALID_BLOCK_SET_SIZE, LimitStrategy.DROP_OLDEST_ELEMENT);\n+\n+  public BlockValidator(RecentChainData recentChainData, StateTransition stateTransition) {\n+    this.recentChainData = recentChainData;\n+    this.stateTransition = stateTransition;\n+  }\n+\n+  public BlockValidationResult validate(SignedBeaconBlock block) {\n+\n+    if (!blockSlotIsGreaterThanLatestFinalizedSlot(block)\n+        || !blockIsFirstBlockWithValidSignatureForSlot(block)) {\n+      LOG.trace(\n+          \"BlockValidator: Block is either too old or is not the first block with valid signature for \"\n+              + \"its slot. It will be dropped\");\n+      return BlockValidationResult.INVALID;\n+    }\n+\n+    final Optional<BeaconState> preState =\n+        Optional.ofNullable(\n+            recentChainData.getStore().getBlockState(block.getMessage().getParent_root()));\n+    if (preState.isEmpty() || blockIsFromFutureSlot(block)) {\n+      LOG.trace(\n+          \"BlockValidator: Either block pre state does not exist or block is from the future. \"\n+              + \"It will be saved for future processing\");\n+      return BlockValidationResult.SAVED_FOR_FUTURE;\n+    }\n+\n+    try {\n+      BeaconState postState =\n+          stateTransition.process_slots(preState.get(), block.getMessage().getSlot());\n+      if (blockIsProposedByTheExpectedProposer(block, postState)\n+          && blockSignatureIsValidWithRespectToProposerIndex(block, preState.get(), postState)) {\n+        return BlockValidationResult.VALID;\n+      }\n+    } catch (EpochProcessingException | SlotProcessingException e) {\n+      LOG.error(\"BlockValidator: Unable to process block state.\", e);\n+      return BlockValidationResult.INVALID;\n+    }\n+\n+    return BlockValidationResult.INVALID;\n+  }\n+\n+  private boolean blockIsFromFutureSlot(SignedBeaconBlock block) {\n+    ReadOnlyStore store = recentChainData.getStore();\n+    final long disparityInSeconds = Math.round((float) MAXIMUM_GOSSIP_CLOCK_DISPARITY / 1000.0);\n+    final UnsignedLong maxOffset = UnsignedLong.valueOf(disparityInSeconds);\n+    final UnsignedLong maxTime = store.getTime().plus(maxOffset);\n+    UnsignedLong maxCurrSlot = getCurrentSlot(maxTime, store.getGenesisTime());\n+    return block.getSlot().compareTo(maxCurrSlot) > 0;\n+  }\n+\n+  private boolean blockSlotIsGreaterThanLatestFinalizedSlot(SignedBeaconBlock block) {\n+    UnsignedLong finalizedSlot =\n+        recentChainData.getStore().getFinalizedCheckpoint().getEpochStartSlot();\n+    return block.getSlot().compareTo(finalizedSlot) > 0;\n+  }\n+\n+  private boolean blockIsFirstBlockWithValidSignatureForSlot(SignedBeaconBlock block) {\n+    return !receivedValidBlockInfoSet.contains(new SlotAndProposer(block));\n+  }\n+\n+  private boolean blockSignatureIsValidWithRespectToProposerIndex(\n+      SignedBeaconBlock block, BeaconState preState, BeaconState postState) {\n+    Validator proposer =\n+        postState\n+            .getValidators()\n+            .get(toIntExact(block.getMessage().getProposer_index().longValue()));\n+\n+    final Bytes domain = get_domain(preState, DOMAIN_BEACON_PROPOSER);\n+    final Bytes signing_root = compute_signing_root(block.getMessage(), domain);\n+    final BLSSignature signature = block.getSignature();\n+    boolean signatureValid = BLS.verify(proposer.getPubkey(), signing_root, signature);\n+\n+    return signatureValid && receivedValidBlockInfoSet.add(new SlotAndProposer(block));\n+  }\n+\n+  private boolean blockIsProposedByTheExpectedProposer(\n+      SignedBeaconBlock block, BeaconState postState) {\n+    final int proposerIndex = get_beacon_proposer_index(postState);\n+    return proposerIndex == toIntExact(block.getMessage().getProposer_index().longValue());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTA5MjYxNw=="}, "originalCommit": {"oid": "a38713fa1922a8b1f6b348fd578ff01dd0ad066c"}, "originalPosition": 130}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1Mzc1MTY1OnYy", "diffSide": "RIGHT", "path": "networking/eth2/src/test/java/tech/pegasys/artemis/networking/eth2/gossip/BlockValidatorTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwNTowMDoxNVrOGIDLfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNzoyNjowM1rOGIffZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTA5Mzg4Nw==", "bodyText": "Still need a test for a block that's not from the future, but that we don't have the parent for.", "url": "https://github.com/ConsenSys/teku/pull/1615#discussion_r411093887", "createdAt": "2020-04-20T05:00:15Z", "author": {"login": "ajsutton"}, "path": "networking/eth2/src/test/java/tech/pegasys/artemis/networking/eth2/gossip/BlockValidatorTest.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.networking.eth2.gossip;\n+\n+import static com.google.common.primitives.UnsignedLong.ONE;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.compute_start_slot_at_epoch;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.primitives.UnsignedLong;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import tech.pegasys.artemis.bls.BLSSignature;\n+import tech.pegasys.artemis.core.StateTransition;\n+import tech.pegasys.artemis.core.signatures.Signer;\n+import tech.pegasys.artemis.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.networking.eth2.gossip.topics.validation.BlockValidationResult;\n+import tech.pegasys.artemis.networking.eth2.gossip.topics.validation.BlockValidator;\n+import tech.pegasys.artemis.statetransition.BeaconChainUtil;\n+import tech.pegasys.artemis.storage.client.MemoryOnlyRecentChainData;\n+import tech.pegasys.artemis.storage.client.RecentChainData;\n+\n+public class BlockValidatorTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a38713fa1922a8b1f6b348fd578ff01dd0ad066c"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU1NzczMw==", "bodyText": "added.", "url": "https://github.com/ConsenSys/teku/pull/1615#discussion_r411557733", "createdAt": "2020-04-20T17:26:03Z", "author": {"login": "cemozerr"}, "path": "networking/eth2/src/test/java/tech/pegasys/artemis/networking/eth2/gossip/BlockValidatorTest.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.networking.eth2.gossip;\n+\n+import static com.google.common.primitives.UnsignedLong.ONE;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static tech.pegasys.artemis.datastructures.util.BeaconStateUtil.compute_start_slot_at_epoch;\n+\n+import com.google.common.eventbus.EventBus;\n+import com.google.common.primitives.UnsignedLong;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import tech.pegasys.artemis.bls.BLSSignature;\n+import tech.pegasys.artemis.core.StateTransition;\n+import tech.pegasys.artemis.core.signatures.Signer;\n+import tech.pegasys.artemis.datastructures.blocks.BeaconBlock;\n+import tech.pegasys.artemis.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.artemis.networking.eth2.gossip.topics.validation.BlockValidationResult;\n+import tech.pegasys.artemis.networking.eth2.gossip.topics.validation.BlockValidator;\n+import tech.pegasys.artemis.statetransition.BeaconChainUtil;\n+import tech.pegasys.artemis.storage.client.MemoryOnlyRecentChainData;\n+import tech.pegasys.artemis.storage.client.RecentChainData;\n+\n+public class BlockValidatorTest {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTA5Mzg4Nw=="}, "originalCommit": {"oid": "a38713fa1922a8b1f6b348fd578ff01dd0ad066c"}, "originalPosition": 35}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1662, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}