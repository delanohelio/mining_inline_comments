{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA1NzYwODA2", "number": 1621, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwMjo0MDoyOFrODzhKpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNjo0Njo0N1rODz0qcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1MzQ3MzY2OnYy", "diffSide": "RIGHT", "path": "pow/src/test/java/tech/pegasys/artemis/pow/MinimumGenesisTimeBlockFinderTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwMjo0MDoyOFrOGIA6mg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwNTowODoxNFrOGIDUcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTA1Njc5NA==", "bodyText": "this test is the same as shouldAddGenesisDelayToBlockTimestampWhenConsideringIfItIsTheMinGenesisBlock", "url": "https://github.com/ConsenSys/teku/pull/1621#discussion_r411056794", "createdAt": "2020-04-20T02:40:28Z", "author": {"login": "macfarla"}, "path": "pow/src/test/java/tech/pegasys/artemis/pow/MinimumGenesisTimeBlockFinderTest.java", "diffHunk": "@@ -49,115 +46,69 @@ static void tearDown() {\n   }\n \n   @Test\n-  void minGenesisBlock_belowEstimatedBlock() {\n-    Constants.SECONDS_PER_ETH1_BLOCK = UnsignedLong.valueOf(5);\n-\n-    EthBlock.Block estimationBlock = mockBlockForEth1Provider(\"0xbf\", 1000, 1000);\n-\n-    setMinGenesisTime(500);\n-\n-    // 1002 - 502 = 500, 500 / 5 = 100, the estimated genesis block number should be:\n-    // 1000 - 100 = 900\n-\n-    mockBlockForEth1Provider(\"0x11\", 900, 600);\n-\n-    // since the estimated block still had higher timestamp than min genesis, we should explore\n-    // downwards\n-\n-    mockBlockForEth1Provider(\"0x08\", 899, 510);\n-\n-    // since the second requested block still had higher timestamp than min genesis, we should\n-    // explore downwards\n-\n-    mockBlockForEth1Provider(\"0x00\", 898, 490);\n-\n-    // since the last requested block now had lower timestamp than min genesis, we should publish\n-    // the block\n-    // right before this as the first valid block\n-\n-    EthBlock.Block minGenesisTimeBlock =\n-        minimumGenesisTimeBlockFinder.findMinGenesisTimeBlockInHistory(estimationBlock).join();\n-\n-    assertThatIsBlock(minGenesisTimeBlock, \"0x08\", 899, 510);\n+  public void shouldFindMinGenesisTime() {\n+    final long[] timestamps = {0, 1000, 2000, 3000, 4000, 5000, 6000, 7000, 8000};\n+    final Block[] blocks = withBlockTimestamps(timestamps);\n+    final int minGenesisTime = 3500;\n+    final Block expectedMinGenesisTimeBlock = blocks[4];\n+    assertMinGenesisBlock(blocks, minGenesisTime, expectedMinGenesisTimeBlock);\n   }\n \n   @Test\n-  void minGenesisBlock_AboveEstimatedBlock() {\n-    Constants.SECONDS_PER_ETH1_BLOCK = UnsignedLong.valueOf(5);\n-\n-    //    mockLatestCanonicalBlock(1000);\n-    EthBlock.Block estimationBlock = mockBlockForEth1Provider(\"0xbf\", 1000, 1000);\n-\n-    setMinGenesisTime(500);\n-\n-    // 1002 - 502 = 500, 500 / 5 = 100, the estimated genesis block number should be:\n-    // 1000 - 100 = 900\n-\n-    mockBlockForEth1Provider(\"0x08\", 900, 400);\n-\n-    // since the estimated block still had lower timestamp than min genesis, we should explore\n-    // upwards\n-\n-    mockBlockForEth1Provider(\"0x08\", 901, 450);\n-\n-    // since the second requested block still had lower timestamp than min genesis, we should\n-    // explore upwards\n-\n-    mockBlockForEth1Provider(\"0x08\", 902, 510);\n-\n-    // since the last requested block now had higher timestamp than min genesis, we should publish\n-    // the block\n-\n-    EthBlock.Block minGenesisTimeBlock =\n-        minimumGenesisTimeBlockFinder.findMinGenesisTimeBlockInHistory(estimationBlock).join();\n-\n-    assertThatIsBlock(minGenesisTimeBlock, \"0x08\", 902, 510);\n+  public void shouldAddGenesisDelayToBlockTimestampWhenConsideringIfItIsTheMinGenesisBlock() {\n+    final Block[] blocks = withBlockTimestamps(1000, 2000, 3000, 4000, 5000, 6000, 7000, 8000);\n+    final int minGenesisTime = 3002;\n+    final Block expectedMinGenesisTimeBlock = blocks[2];\n+    assertMinGenesisBlock(blocks, minGenesisTime, expectedMinGenesisTimeBlock);\n   }\n \n   @Test\n-  void minGenesisBlock_EstimatedBlockIsTheValidBlock() {\n-    Constants.SECONDS_PER_ETH1_BLOCK = UnsignedLong.valueOf(5);\n-\n-    //    mockLatestCanonicalBlock(1000);\n-    EthBlock.Block estimationBlock = mockBlockForEth1Provider(\"0xbf\", 1000, 1000);\n-\n-    setMinGenesisTime(502);\n-\n-    // 1002 - 502 = 500, 500 / 5 = 100, the estimated genesis block number should be:\n-    // 1000 - 100 = 900\n+  public void shouldFindMinGenesisTimeBlockAtVeryStartOfChain() {\n+    final Block[] blocks = withBlockTimestamps(4000, 5000, 6000, 7000, 8000);\n+    final int minGenesisTime = 3000;\n+    final Block expectedMinGenesisTimeBlock = blocks[0];\n+    assertMinGenesisBlock(blocks, minGenesisTime, expectedMinGenesisTimeBlock);\n+  }\n \n-    mockBlockForEth1Provider(\"0x08\", 900, 500);\n+  @Test\n+  public void shouldFindMinGenesisTimeBlockAtHeadOfChain() {\n+    final Block[] blocks = withBlockTimestamps(4000, 5000, 6000, 7000, 8000);\n+    final int minGenesisTime = 8000;\n+    final Block expectedMinGenesisTimeBlock = blocks[blocks.length - 1];\n+    assertMinGenesisBlock(blocks, minGenesisTime, expectedMinGenesisTimeBlock);\n+  }\n \n-    // since the genesis time calculated from the , we should publish the block\n+  @Test\n+  public void shouldFindMinGenesisTimeWithExactMatch() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa178c97d75fa413b1d38fcc5993be034c395645"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTA5NjE3Ng==", "bodyText": "True, only need one of them.", "url": "https://github.com/ConsenSys/teku/pull/1621#discussion_r411096176", "createdAt": "2020-04-20T05:08:14Z", "author": {"login": "ajsutton"}, "path": "pow/src/test/java/tech/pegasys/artemis/pow/MinimumGenesisTimeBlockFinderTest.java", "diffHunk": "@@ -49,115 +46,69 @@ static void tearDown() {\n   }\n \n   @Test\n-  void minGenesisBlock_belowEstimatedBlock() {\n-    Constants.SECONDS_PER_ETH1_BLOCK = UnsignedLong.valueOf(5);\n-\n-    EthBlock.Block estimationBlock = mockBlockForEth1Provider(\"0xbf\", 1000, 1000);\n-\n-    setMinGenesisTime(500);\n-\n-    // 1002 - 502 = 500, 500 / 5 = 100, the estimated genesis block number should be:\n-    // 1000 - 100 = 900\n-\n-    mockBlockForEth1Provider(\"0x11\", 900, 600);\n-\n-    // since the estimated block still had higher timestamp than min genesis, we should explore\n-    // downwards\n-\n-    mockBlockForEth1Provider(\"0x08\", 899, 510);\n-\n-    // since the second requested block still had higher timestamp than min genesis, we should\n-    // explore downwards\n-\n-    mockBlockForEth1Provider(\"0x00\", 898, 490);\n-\n-    // since the last requested block now had lower timestamp than min genesis, we should publish\n-    // the block\n-    // right before this as the first valid block\n-\n-    EthBlock.Block minGenesisTimeBlock =\n-        minimumGenesisTimeBlockFinder.findMinGenesisTimeBlockInHistory(estimationBlock).join();\n-\n-    assertThatIsBlock(minGenesisTimeBlock, \"0x08\", 899, 510);\n+  public void shouldFindMinGenesisTime() {\n+    final long[] timestamps = {0, 1000, 2000, 3000, 4000, 5000, 6000, 7000, 8000};\n+    final Block[] blocks = withBlockTimestamps(timestamps);\n+    final int minGenesisTime = 3500;\n+    final Block expectedMinGenesisTimeBlock = blocks[4];\n+    assertMinGenesisBlock(blocks, minGenesisTime, expectedMinGenesisTimeBlock);\n   }\n \n   @Test\n-  void minGenesisBlock_AboveEstimatedBlock() {\n-    Constants.SECONDS_PER_ETH1_BLOCK = UnsignedLong.valueOf(5);\n-\n-    //    mockLatestCanonicalBlock(1000);\n-    EthBlock.Block estimationBlock = mockBlockForEth1Provider(\"0xbf\", 1000, 1000);\n-\n-    setMinGenesisTime(500);\n-\n-    // 1002 - 502 = 500, 500 / 5 = 100, the estimated genesis block number should be:\n-    // 1000 - 100 = 900\n-\n-    mockBlockForEth1Provider(\"0x08\", 900, 400);\n-\n-    // since the estimated block still had lower timestamp than min genesis, we should explore\n-    // upwards\n-\n-    mockBlockForEth1Provider(\"0x08\", 901, 450);\n-\n-    // since the second requested block still had lower timestamp than min genesis, we should\n-    // explore upwards\n-\n-    mockBlockForEth1Provider(\"0x08\", 902, 510);\n-\n-    // since the last requested block now had higher timestamp than min genesis, we should publish\n-    // the block\n-\n-    EthBlock.Block minGenesisTimeBlock =\n-        minimumGenesisTimeBlockFinder.findMinGenesisTimeBlockInHistory(estimationBlock).join();\n-\n-    assertThatIsBlock(minGenesisTimeBlock, \"0x08\", 902, 510);\n+  public void shouldAddGenesisDelayToBlockTimestampWhenConsideringIfItIsTheMinGenesisBlock() {\n+    final Block[] blocks = withBlockTimestamps(1000, 2000, 3000, 4000, 5000, 6000, 7000, 8000);\n+    final int minGenesisTime = 3002;\n+    final Block expectedMinGenesisTimeBlock = blocks[2];\n+    assertMinGenesisBlock(blocks, minGenesisTime, expectedMinGenesisTimeBlock);\n   }\n \n   @Test\n-  void minGenesisBlock_EstimatedBlockIsTheValidBlock() {\n-    Constants.SECONDS_PER_ETH1_BLOCK = UnsignedLong.valueOf(5);\n-\n-    //    mockLatestCanonicalBlock(1000);\n-    EthBlock.Block estimationBlock = mockBlockForEth1Provider(\"0xbf\", 1000, 1000);\n-\n-    setMinGenesisTime(502);\n-\n-    // 1002 - 502 = 500, 500 / 5 = 100, the estimated genesis block number should be:\n-    // 1000 - 100 = 900\n+  public void shouldFindMinGenesisTimeBlockAtVeryStartOfChain() {\n+    final Block[] blocks = withBlockTimestamps(4000, 5000, 6000, 7000, 8000);\n+    final int minGenesisTime = 3000;\n+    final Block expectedMinGenesisTimeBlock = blocks[0];\n+    assertMinGenesisBlock(blocks, minGenesisTime, expectedMinGenesisTimeBlock);\n+  }\n \n-    mockBlockForEth1Provider(\"0x08\", 900, 500);\n+  @Test\n+  public void shouldFindMinGenesisTimeBlockAtHeadOfChain() {\n+    final Block[] blocks = withBlockTimestamps(4000, 5000, 6000, 7000, 8000);\n+    final int minGenesisTime = 8000;\n+    final Block expectedMinGenesisTimeBlock = blocks[blocks.length - 1];\n+    assertMinGenesisBlock(blocks, minGenesisTime, expectedMinGenesisTimeBlock);\n+  }\n \n-    // since the genesis time calculated from the , we should publish the block\n+  @Test\n+  public void shouldFindMinGenesisTimeWithExactMatch() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTA1Njc5NA=="}, "originalCommit": {"oid": "fa178c97d75fa413b1d38fcc5993be034c395645"}, "originalPosition": 145}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1MzQ3NjkyOnYy", "diffSide": "RIGHT", "path": "pow/src/test/java/tech/pegasys/artemis/pow/MinimumGenesisTimeBlockFinderTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwMjo0MjoyM1rOGIA8WQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQwNTowNzo1OFrOGIDT-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTA1NzI0MQ==", "bodyText": "I don't know if this comment is useful here?", "url": "https://github.com/ConsenSys/teku/pull/1621#discussion_r411057241", "createdAt": "2020-04-20T02:42:23Z", "author": {"login": "macfarla"}, "path": "pow/src/test/java/tech/pegasys/artemis/pow/MinimumGenesisTimeBlockFinderTest.java", "diffHunk": "@@ -20,27 +20,24 @@\n import com.google.common.primitives.UnsignedLong;\n import java.math.BigInteger;\n import org.junit.jupiter.api.AfterAll;\n-import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.BeforeAll;\n import org.junit.jupiter.api.Test;\n import org.web3j.protocol.core.methods.response.EthBlock;\n+import org.web3j.protocol.core.methods.response.EthBlock.Block;\n import tech.pegasys.artemis.util.async.SafeFuture;\n import tech.pegasys.artemis.util.config.Constants;\n \n public class MinimumGenesisTimeBlockFinderTest {\n \n-  private Eth1Provider eth1Provider;\n+  private Eth1Provider eth1Provider = mock(Eth1Provider.class);\n \n-  private MinimumGenesisTimeBlockFinder minimumGenesisTimeBlockFinder;\n-\n-  @BeforeEach\n-  void setUp() {\n-    eth1Provider = mock(Eth1Provider.class);\n-\n-    minimumGenesisTimeBlockFinder = new MinimumGenesisTimeBlockFinder(eth1Provider);\n+  private MinimumGenesisTimeBlockFinder minimumGenesisTimeBlockFinder =\n+      new MinimumGenesisTimeBlockFinder(eth1Provider);\n \n+  @BeforeAll\n+  static void setUp() {\n+    // calculateCandidateGenesisTimestamp will return blockTime + 2", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa178c97d75fa413b1d38fcc5993be034c395645"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTA5NjA1OA==", "bodyText": "It explains why the constant is being set and the effect it has on the genesis time derived from a block timestamp. I've tidied it up a bit.", "url": "https://github.com/ConsenSys/teku/pull/1621#discussion_r411096058", "createdAt": "2020-04-20T05:07:58Z", "author": {"login": "ajsutton"}, "path": "pow/src/test/java/tech/pegasys/artemis/pow/MinimumGenesisTimeBlockFinderTest.java", "diffHunk": "@@ -20,27 +20,24 @@\n import com.google.common.primitives.UnsignedLong;\n import java.math.BigInteger;\n import org.junit.jupiter.api.AfterAll;\n-import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.BeforeAll;\n import org.junit.jupiter.api.Test;\n import org.web3j.protocol.core.methods.response.EthBlock;\n+import org.web3j.protocol.core.methods.response.EthBlock.Block;\n import tech.pegasys.artemis.util.async.SafeFuture;\n import tech.pegasys.artemis.util.config.Constants;\n \n public class MinimumGenesisTimeBlockFinderTest {\n \n-  private Eth1Provider eth1Provider;\n+  private Eth1Provider eth1Provider = mock(Eth1Provider.class);\n \n-  private MinimumGenesisTimeBlockFinder minimumGenesisTimeBlockFinder;\n-\n-  @BeforeEach\n-  void setUp() {\n-    eth1Provider = mock(Eth1Provider.class);\n-\n-    minimumGenesisTimeBlockFinder = new MinimumGenesisTimeBlockFinder(eth1Provider);\n+  private MinimumGenesisTimeBlockFinder minimumGenesisTimeBlockFinder =\n+      new MinimumGenesisTimeBlockFinder(eth1Provider);\n \n+  @BeforeAll\n+  static void setUp() {\n+    // calculateCandidateGenesisTimestamp will return blockTime + 2", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTA1NzI0MQ=="}, "originalCommit": {"oid": "fa178c97d75fa413b1d38fcc5993be034c395645"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NjY2ODAyOnYy", "diffSide": "RIGHT", "path": "pow/src/main/java/tech/pegasys/artemis/pow/MinimumGenesisTimeBlockFinder.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNjo0Njo0N1rOGId5lg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMDo0MzoxOFrOGIm3gg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTUzMTY3MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                // The very first block is after min genesis so just use it\n          \n          \n            \n                                // The very first block of eth1 is after eth 2 min genesis so just use it", "url": "https://github.com/ConsenSys/teku/pull/1621#discussion_r411531670", "createdAt": "2020-04-20T16:46:47Z", "author": {"login": "cemozerr"}, "path": "pow/src/main/java/tech/pegasys/artemis/pow/MinimumGenesisTimeBlockFinder.java", "diffHunk": "@@ -37,75 +42,40 @@ public MinimumGenesisTimeBlockFinder(Eth1Provider eth1Provider) {\n   /**\n    * Find first block in history that has timestamp greater than MIN_GENESIS_TIME\n    *\n-   * @param estimationBlock estimationBlock that will be used for estimation\n+   * @param headBlock block at current chain head\n    * @return min genesis time block\n    */\n-  public SafeFuture<EthBlock.Block> findMinGenesisTimeBlockInHistory(\n-      EthBlock.Block estimationBlock) {\n-    UnsignedLong estimatedBlockNumber =\n-        getEstimatedMinGenesisTimeBlockNumber(estimationBlock, Constants.SECONDS_PER_ETH1_BLOCK);\n-    return eth1Provider\n-        .getEth1BlockFuture(estimatedBlockNumber)\n-        .thenCompose(\n-            block -> {\n-              int comparison = compareBlockTimestampToMinGenesisTime(block);\n-              if (comparison > 0) {\n-                // If block timestamp is greater than min genesis time\n-                // explore blocks downwards\n-                return exploreBlocksDownwards(block);\n-              } else if (comparison < 0) {\n-                // If block timestamp is less than min genesis time\n-                // explore blocks upwards\n-                return exploreBlocksUpwards(block);\n-              } else {\n-                return SafeFuture.completedFuture(block);\n-              }\n-            });\n+  public SafeFuture<EthBlock.Block> findMinGenesisTimeBlockInHistory(EthBlock.Block headBlock) {\n+    return binarySearchLoop(new SearchContext(headBlock));\n   }\n \n-  private SafeFuture<EthBlock.Block> exploreBlocksDownwards(EthBlock.Block previousBlock) {\n-    if (previousBlock.getNumber().equals(BigInteger.ZERO)) {\n-      // We reached genesis and thus should be returning genesis as the min genesis block.\n-      return SafeFuture.completedFuture(previousBlock);\n+  private SafeFuture<EthBlock.Block> binarySearchLoop(final SearchContext searchContext) {\n+    if (searchContext.low.compareTo(searchContext.high) <= 0) {\n+      final UnsignedLong mid = searchContext.low.plus(searchContext.high).dividedBy(TWO);\n+      return eth1Provider\n+          .getEth1BlockFuture(mid)\n+          .thenCompose(\n+              midBlock -> {\n+                final int cmp = compareBlockTimestampToMinGenesisTime(midBlock);\n+                if (cmp < 0) {\n+                  searchContext.low = mid.plus(ONE);\n+                  return binarySearchLoop(searchContext);\n+                } else if (cmp > 0) {\n+                  if (mid.equals(ZERO)) {\n+                    // The very first block is after min genesis so just use it", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca1e2c51f35d011b2fe681ddfe0b6869c0f3174e"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY3ODU5NA==", "bodyText": "Good idea. Done.", "url": "https://github.com/ConsenSys/teku/pull/1621#discussion_r411678594", "createdAt": "2020-04-20T20:43:18Z", "author": {"login": "ajsutton"}, "path": "pow/src/main/java/tech/pegasys/artemis/pow/MinimumGenesisTimeBlockFinder.java", "diffHunk": "@@ -37,75 +42,40 @@ public MinimumGenesisTimeBlockFinder(Eth1Provider eth1Provider) {\n   /**\n    * Find first block in history that has timestamp greater than MIN_GENESIS_TIME\n    *\n-   * @param estimationBlock estimationBlock that will be used for estimation\n+   * @param headBlock block at current chain head\n    * @return min genesis time block\n    */\n-  public SafeFuture<EthBlock.Block> findMinGenesisTimeBlockInHistory(\n-      EthBlock.Block estimationBlock) {\n-    UnsignedLong estimatedBlockNumber =\n-        getEstimatedMinGenesisTimeBlockNumber(estimationBlock, Constants.SECONDS_PER_ETH1_BLOCK);\n-    return eth1Provider\n-        .getEth1BlockFuture(estimatedBlockNumber)\n-        .thenCompose(\n-            block -> {\n-              int comparison = compareBlockTimestampToMinGenesisTime(block);\n-              if (comparison > 0) {\n-                // If block timestamp is greater than min genesis time\n-                // explore blocks downwards\n-                return exploreBlocksDownwards(block);\n-              } else if (comparison < 0) {\n-                // If block timestamp is less than min genesis time\n-                // explore blocks upwards\n-                return exploreBlocksUpwards(block);\n-              } else {\n-                return SafeFuture.completedFuture(block);\n-              }\n-            });\n+  public SafeFuture<EthBlock.Block> findMinGenesisTimeBlockInHistory(EthBlock.Block headBlock) {\n+    return binarySearchLoop(new SearchContext(headBlock));\n   }\n \n-  private SafeFuture<EthBlock.Block> exploreBlocksDownwards(EthBlock.Block previousBlock) {\n-    if (previousBlock.getNumber().equals(BigInteger.ZERO)) {\n-      // We reached genesis and thus should be returning genesis as the min genesis block.\n-      return SafeFuture.completedFuture(previousBlock);\n+  private SafeFuture<EthBlock.Block> binarySearchLoop(final SearchContext searchContext) {\n+    if (searchContext.low.compareTo(searchContext.high) <= 0) {\n+      final UnsignedLong mid = searchContext.low.plus(searchContext.high).dividedBy(TWO);\n+      return eth1Provider\n+          .getEth1BlockFuture(mid)\n+          .thenCompose(\n+              midBlock -> {\n+                final int cmp = compareBlockTimestampToMinGenesisTime(midBlock);\n+                if (cmp < 0) {\n+                  searchContext.low = mid.plus(ONE);\n+                  return binarySearchLoop(searchContext);\n+                } else if (cmp > 0) {\n+                  if (mid.equals(ZERO)) {\n+                    // The very first block is after min genesis so just use it", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTUzMTY3MA=="}, "originalCommit": {"oid": "ca1e2c51f35d011b2fe681ddfe0b6869c0f3174e"}, "originalPosition": 69}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1672, "cost": 1, "resetAt": "2021-11-12T19:05:54Z"}}}