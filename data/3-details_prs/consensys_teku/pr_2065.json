{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI4NzI0MzY3", "number": 2065, "title": "[Issue 1976] Limit hot states kept in memory", "bodyText": "PR Description\nLimit the number of states that are kept in memory.  If a state that has been dropped from memory is later requested, regenerate the missing state.\nFixed Issue(s)\nFixes #1976", "createdAt": "2020-06-05T20:13:07Z", "url": "https://github.com/ConsenSys/teku/pull/2065", "merged": true, "mergeCommit": {"oid": "b8505603e7773465acdd724368f2901f2d6260eb"}, "closed": true, "closedAt": "2020-06-10T14:57:53Z", "author": {"login": "mbaxter"}, "timelineItems": {"totalCount": 23, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcoYmSuABqjM0MTMxMTUwNTE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcp6vSHgH2gAyNDI4NzI0MzY3Ojk4ZmE0NjU4M2E2ZTI4NTkzNWI0ZDAxZjI3YmJiMTJiYTg3N2E4ZjE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1affa7775cb7ca6215981474a41fb18114153571", "author": {"user": {"login": "mbaxter", "name": null}}, "url": "https://github.com/ConsenSys/teku/commit/1affa7775cb7ca6215981474a41fb18114153571", "committedDate": "2020-06-05T19:47:46Z", "message": "Fix test - set finalized checkpoint that supersedes genesis"}, "afterCommit": {"oid": "32ec17a78f8b52bf713137e6512360dab0f3225c", "author": {"user": {"login": "mbaxter", "name": null}}, "url": "https://github.com/ConsenSys/teku/commit/32ec17a78f8b52bf713137e6512360dab0f3225c", "committedDate": "2020-06-05T20:21:35Z", "message": "Fix test - set finalized checkpoint that supersedes genesis"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1ODU0Nzcy", "url": "https://github.com/ConsenSys/teku/pull/2065#pullrequestreview-425854772", "createdAt": "2020-06-07T21:27:51Z", "commit": {"oid": "32ec17a78f8b52bf713137e6512360dab0f3225c"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QyMToyNzo1MVrOGgL9Rw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QyMTo1OTo1MFrOGgMGNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwMzUyNw==", "bodyText": "Would it be worth bailing out before attempting to recreate the state if block == null?  Performance-wise it won't make any significant difference but it feels weird to ask for something we already know we can't generate.  I think you could then just use a map:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                final SignedBeaconBlock block = getSignedBlock(blockRoot);\n          \n          \n            \n                final Optional<BeaconState> state = getOrGenerateBlockState(blockRoot);\n          \n          \n            \n                if (block == null || state.isEmpty()) {\n          \n          \n            \n                  return Optional.empty();\n          \n          \n            \n                }\n          \n          \n            \n                return Optional.of(new SignedBlockAndState(block, state.get()));\n          \n          \n            \n                final SignedBeaconBlock block = getSignedBlock(blockRoot);\n          \n          \n            \n                if (block == null) {\n          \n          \n            \n                  return Optional.empty();\n          \n          \n            \n                }\n          \n          \n            \n                return getOrGenerateBlockState(blockRoot).map(state -> new SignedBlockAndState(block, state));", "url": "https://github.com/ConsenSys/teku/pull/2065#discussion_r436403527", "createdAt": "2020-06-07T21:27:51Z", "author": {"login": "ajsutton"}, "path": "storage/src/main/java/tech/pegasys/teku/storage/store/Store.java", "diffHunk": "@@ -212,17 +233,12 @@ public SignedBeaconBlock getSignedBlock(Bytes32 blockRoot) {\n \n   @Override\n   public Optional<SignedBlockAndState> getBlockAndState(final Bytes32 blockRoot) {\n-    readLock.lock();\n-    try {\n-      final SignedBeaconBlock block = blocks.get(blockRoot);\n-      final BeaconState state = block_states.get(blockRoot);\n-      if (block == null || state == null) {\n-        return Optional.empty();\n-      }\n-      return Optional.of(new SignedBlockAndState(block, state));\n-    } finally {\n-      readLock.unlock();\n+    final SignedBeaconBlock block = getSignedBlock(blockRoot);\n+    final Optional<BeaconState> state = getOrGenerateBlockState(blockRoot);\n+    if (block == null || state.isEmpty()) {\n+      return Optional.empty();\n     }\n+    return Optional.of(new SignedBlockAndState(block, state.get()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32ec17a78f8b52bf713137e6512360dab0f3225c"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwNTE4OA==", "bodyText": "This could be a memory issue for us - say we'd wound up with the last finalised epoch being 10 and had gone on importing blocks so that now we've only got states from epoch 20 onwards in memory.  Then we get a request for a state in epoch 19, we'd regenerate all the states from epoch 10 to 19 and they'd all be in memory at once in that map which would cause use to run out of memory.\nI suspect we could just build up the list of blocks to import in slot order as we walk back to find the most recent state, then we can just iterate through them to regenerate the state.  Something like:\nprivate Optional<BeaconState> getOrGenerateBlockState(final Bytes32 blockRoot) {\n    Optional<BeaconState> state = getState(blockRoot);\n    if (state.isPresent()) {\n      return state;\n    }\n    final SignedBeaconBlock blockForState = getSignedBlock(blockRoot);\n    if (blockForState == null) {\n      // If we don't have the corresponding block, we can't possibly regenerate the state\n      return Optional.empty();\n    }\n\n    // Accumulate blocks until we find our base state to build from\n    SignedBlockAndState baseBlock = null;\n    final List<SignedBeaconBlock> blocks = new ArrayList<>(); // in reverse slot order\n    SignedBeaconBlock block = blockForState;\n    while (block != null) {\n      final Optional<BeaconState> blockState = getState(block.getRoot());\n      if (blockState.isPresent()) {\n        // We found a base state\n        baseBlock = new SignedBlockAndState(block, blockState.get());\n        break;\n      }\n      blocks.add(block);\n      block = getSignedBlock(block.getParent_root());\n    }\n\n    if (baseBlock == null) {\n      // If we haven't found a base state yet, we must have walked back to the latest finalized\n      // block, check here for the base state\n      final SignedBlockAndState finalizedBlock = getLatestFinalizedBlockAndState();\n      final SignedBeaconBlock earliestBlock = blocks.get(0);\n      if (!earliestBlock.getRoot().equals(finalizedBlock.getRoot())) {\n        // We must have finalized a new block while processing and moved past our target root\n        return Optional.empty();\n      }\n      baseBlock = finalizedBlock;\n    }\n\n    // Regenerate state\n    BeaconState regeneratedState = baseBlock.getState();\n    final StateGenerator stateGenerator = new StateGenerator();\n    for (int i = blocks.size() - 1; i >= 0; i--) {\n      regeneratedState = stateGenerator.processBlock(regeneratedState, blocks.get(i));\n    }\n    // Save regenerated state\n    putState(blockRoot, regeneratedState);\n\n    return Optional.of(regeneratedState);\n  }\n\nThough probably should move all the state reiteration to a new method in StateGenerator rather than doing it here. Need to double check the logic on checking if we've walked past the finalised state as well - I'd be slightly tempted to gather up the blocks to apply inside a read lock so we know the finalised state won't change, then once we have them release the lock and do the state transitions to generate the state.", "url": "https://github.com/ConsenSys/teku/pull/2065#discussion_r436405188", "createdAt": "2020-06-07T21:51:27Z", "author": {"login": "ajsutton"}, "path": "storage/src/main/java/tech/pegasys/teku/storage/store/Store.java", "diffHunk": "@@ -247,51 +263,110 @@ public boolean containsBlock(Bytes32 blockRoot) {\n \n   @Override\n   public BeaconState getBlockState(Bytes32 blockRoot) {\n+    return getOrGenerateBlockState(blockRoot).orElse(null);\n+  }\n+\n+  @Override\n+  public BeaconState getCheckpointState(Checkpoint checkpoint) {\n     readLock.lock();\n     try {\n-      return block_states.get(blockRoot);\n+      return checkpoint_states.get(checkpoint);\n     } finally {\n       readLock.unlock();\n     }\n   }\n \n   @Override\n-  public boolean containsBlockState(Bytes32 blockRoot) {\n+  public boolean containsCheckpointState(Checkpoint checkpoint) {\n     readLock.lock();\n     try {\n-      return block_states.containsKey(blockRoot);\n+      return checkpoint_states.containsKey(checkpoint);\n     } finally {\n       readLock.unlock();\n     }\n   }\n \n   @Override\n-  public BeaconState getCheckpointState(Checkpoint checkpoint) {\n+  public Set<UnsignedLong> getVotedValidatorIndices() {\n     readLock.lock();\n     try {\n-      return checkpoint_states.get(checkpoint);\n+      return votes.keySet();\n     } finally {\n       readLock.unlock();\n     }\n   }\n \n-  @Override\n-  public boolean containsCheckpointState(Checkpoint checkpoint) {\n+  private Optional<BeaconState> getOrGenerateBlockState(final Bytes32 blockRoot) {\n+    Optional<BeaconState> state = getState(blockRoot);\n+    if (state.isPresent()) {\n+      return state;\n+    }\n+    final SignedBeaconBlock blockForState = getSignedBlock(blockRoot);\n+    if (blockForState == null) {\n+      // If we don't have the corresponding block, we can't possibly regenerate the state\n+      return Optional.empty();\n+    }\n+\n+    // Accumulate blocks until we find our base state to build from\n+    SignedBlockAndState baseBlock = null;\n+    final Map<Bytes32, SignedBeaconBlock> blocks = new HashMap<>();\n+    SignedBeaconBlock block = blockForState;\n+    while (block != null) {\n+      final Optional<BeaconState> blockState = getState(block.getRoot());\n+      if (blockState.isPresent()) {\n+        // We found a base state\n+        baseBlock = new SignedBlockAndState(block, blockState.get());\n+        break;\n+      }\n+      blocks.put(block.getRoot(), block);\n+      block = getSignedBlock(block.getParent_root());\n+    }\n+\n+    if (baseBlock == null) {\n+      // If we haven't found a base state yet, we must have walked back to the latest finalized\n+      // block, check here for the base state\n+      final SignedBlockAndState finalizedBlock = getLatestFinalizedBlockAndState();\n+      if (!blocks.keySet().contains(finalizedBlock.getRoot())) {\n+        // We must have finalized a new block while processing and moved past our target root\n+        return Optional.empty();\n+      }\n+      baseBlock = finalizedBlock;\n+    }\n+\n+    // Regenerate state\n+    final StateGenerator stateGenerator = new StateGenerator();\n+    final Map<Bytes32, BeaconState> regeneratedStates =\n+        stateGenerator.produceStatesForBlocks(\n+            baseBlock.getRoot(), baseBlock.getState(), blocks.values());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32ec17a78f8b52bf713137e6512360dab0f3225c"}, "originalPosition": 177}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwNTgxNQ==", "bodyText": "Probably worth logging a ticket to revisit this in the future - it probably isn't smart to regenerate a bunch of states just to send them to disk (especially since if we're pruning they'll then be thrown away).  When our database is a bit more advanced we'll likely only store periodic state snapshots anyway so just not storing states we didn't have in memory seems like a good idea.", "url": "https://github.com/ConsenSys/teku/pull/2065#discussion_r436405815", "createdAt": "2020-06-07T21:59:50Z", "author": {"login": "ajsutton"}, "path": "storage/src/main/java/tech/pegasys/teku/storage/store/StoreTransactionUpdates.java", "diffHunk": "@@ -123,24 +131,35 @@ public static StoreTransactionUpdates calculate(final Store baseStore, final Tra\n   private static Map<Bytes32, SignedBlockAndState> calculateFinalizedChainData(\n       final StoreTransaction tx,\n       final CheckpointAndBlock prevFinalizedCheckpoint,\n-      final SignedBlockAndState newlyFinalizedBlock) {\n-    final Map<Bytes32, SignedBlockAndState> finalizedChainData = new HashMap<>();\n+      final SignedBeaconBlock newlyFinalizedBlock) {\n \n-    SignedBlockAndState oldestFinalizedBlock = newlyFinalizedBlock;\n-    SignedBlockAndState currentBlock = newlyFinalizedBlock;\n+    // Collect blocks\n+    final List<SignedBeaconBlock> blocks = new ArrayList<>();\n+    SignedBeaconBlock oldestFinalizedBlock = newlyFinalizedBlock;\n+    SignedBeaconBlock currentBlock = newlyFinalizedBlock;\n     while (currentBlock != null\n         && currentBlock.getSlot().compareTo(prevFinalizedCheckpoint.getBlockSlot()) > 0) {\n-      finalizedChainData.put(currentBlock.getRoot(), currentBlock);\n+      blocks.add(currentBlock);\n       oldestFinalizedBlock = currentBlock;\n-      currentBlock = tx.getBlockAndState(currentBlock.getParentRoot()).orElse(null);\n+      currentBlock = tx.getSignedBlock(currentBlock.getParent_root());\n     }\n \n     // Make sure we capture all finalized blocks\n-    if (!oldestFinalizedBlock.getParentRoot().equals(prevFinalizedCheckpoint.getRoot())) {\n+    if (!oldestFinalizedBlock.getParent_root().equals(prevFinalizedCheckpoint.getRoot())) {\n       throw new IllegalStateException(\"Unable to retrieve all finalized blocks\");\n     }\n \n-    return finalizedChainData;\n+    // Collect states in order and return finalized chain data map\n+    // State collection is done separately to avoid repeatedly regenerating state by processing\n+    // states in reverse-order.  See: Store.getOrGenerateBlockState\n+    Collections.reverse(blocks);\n+    return blocks.stream()\n+        .map(\n+            block -> {\n+              final BeaconState state = tx.getBlockState(block.getRoot());\n+              return new SignedBlockAndState(block, state);\n+            })\n+        .collect(Collectors.toMap(SignedBlockAndState::getRoot, Function.identity()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "32ec17a78f8b52bf713137e6512360dab0f3225c"}, "originalPosition": 132}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eb0096dba3583db101033a12ac9b43041112cd43", "author": {"user": {"login": "mbaxter", "name": null}}, "url": "https://github.com/ConsenSys/teku/commit/eb0096dba3583db101033a12ac9b43041112cd43", "committedDate": "2020-06-08T16:12:21Z", "message": "Limit the number of hot states kept in memory"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d8632dcf92f7190e7a879b32382ac0dbe3b4b69b", "author": {"user": {"login": "mbaxter", "name": null}}, "url": "https://github.com/ConsenSys/teku/commit/d8632dcf92f7190e7a879b32382ac0dbe3b4b69b", "committedDate": "2020-06-08T16:12:21Z", "message": "Revert \"Simplify finalized checkpoint handling\"\n\nThis reverts commit 478590d098a7ded563ef64d41cb1d51659a3fe04."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5011a704c04df557f60e579a2e4bd602b00c6ee0", "author": {"user": {"login": "mbaxter", "name": null}}, "url": "https://github.com/ConsenSys/teku/commit/5011a704c04df557f60e579a2e4bd602b00c6ee0", "committedDate": "2020-06-08T16:12:21Z", "message": "Don't hold the read lock while regenerating states\n\nKeep track of latest finalized block and state so we always have a\nbase state that allows us to rebuild any given a list of subsequent\nblocks."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b9d8bd16e97785c3cb6e6dac7054bafe37062c0d", "author": {"user": {"login": "mbaxter", "name": null}}, "url": "https://github.com/ConsenSys/teku/commit/b9d8bd16e97785c3cb6e6dac7054bafe37062c0d", "committedDate": "2020-06-08T16:12:21Z", "message": "Optimize state lookups when collecting finalized chain data"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8fa1075a2160b50805f898f4b69d9107546a7ca9", "author": {"user": {"login": "mbaxter", "name": null}}, "url": "https://github.com/ConsenSys/teku/commit/8fa1075a2160b50805f898f4b69d9107546a7ca9", "committedDate": "2020-06-08T16:12:21Z", "message": "Fix test - set finalized checkpoint that supersedes genesis"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "32ec17a78f8b52bf713137e6512360dab0f3225c", "author": {"user": {"login": "mbaxter", "name": null}}, "url": "https://github.com/ConsenSys/teku/commit/32ec17a78f8b52bf713137e6512360dab0f3225c", "committedDate": "2020-06-05T20:21:35Z", "message": "Fix test - set finalized checkpoint that supersedes genesis"}, "afterCommit": {"oid": "8fa1075a2160b50805f898f4b69d9107546a7ca9", "author": {"user": {"login": "mbaxter", "name": null}}, "url": "https://github.com/ConsenSys/teku/commit/8fa1075a2160b50805f898f4b69d9107546a7ca9", "committedDate": "2020-06-08T16:12:21Z", "message": "Fix test - set finalized checkpoint that supersedes genesis"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2ce8abb234029bfc7b38671b82368651783ffb3f", "author": {"user": {"login": "mbaxter", "name": null}}, "url": "https://github.com/ConsenSys/teku/commit/2ce8abb234029bfc7b38671b82368651783ffb3f", "committedDate": "2020-06-09T15:56:11Z", "message": "Make state generation logic more efficient\n\nDon't build all states at once, instead process regenerated states one\nat a time."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "708f29e9ad84a586cd50a63c9dc01dca20935e58", "author": {"user": {"login": "mbaxter", "name": null}}, "url": "https://github.com/ConsenSys/teku/commit/708f29e9ad84a586cd50a63c9dc01dca20935e58", "committedDate": "2020-06-09T17:53:48Z", "message": "Merge branch 'master' into issue-1976/limit-hot-states-kept-in-memory"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1e5bac7467d48af890719b5c742f81b60856bf46", "author": {"user": {"login": "mbaxter", "name": null}}, "url": "https://github.com/ConsenSys/teku/commit/1e5bac7467d48af890719b5c742f81b60856bf46", "committedDate": "2020-06-09T18:00:33Z", "message": "Exit getBlockAndState early if block is missing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4963b9098e9f92d28dd72e58ae01f6023439b8e2", "author": {"user": {"login": "mbaxter", "name": null}}, "url": "https://github.com/ConsenSys/teku/commit/4963b9098e9f92d28dd72e58ae01f6023439b8e2", "committedDate": "2020-06-09T18:17:38Z", "message": "Clarify variable names"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI3NDQxMTk5", "url": "https://github.com/ConsenSys/teku/pull/2065#pullrequestreview-427441199", "createdAt": "2020-06-09T18:41:34Z", "commit": {"oid": "4963b9098e9f92d28dd72e58ae01f6023439b8e2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxODo0MTozNFrOGhXgww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxODo0MTozNFrOGhXgww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY0MTQxMQ==", "bodyText": "For consistency, we're now only setting a new finalized checkpoint if the tx checkpoint made it through the epoch check (if the new finalized epoch is greater than the current finalized epoch): https://github.com/PegaSysEng/teku/blob/4963b9098e9f92d28dd72e58ae01f6023439b8e2/storage/src/main/java/tech/pegasys/teku/storage/store/StoreTransactionUpdates.java#L82-L84", "url": "https://github.com/ConsenSys/teku/pull/2065#discussion_r437641411", "createdAt": "2020-06-09T18:41:34Z", "author": {"login": "mbaxter"}, "path": "storage/src/main/java/tech/pegasys/teku/storage/store/StoreTransactionUpdates.java", "diffHunk": "@@ -210,17 +229,24 @@ public void applyToStore(final Store store) {\n     tx.time.ifPresent(value -> store.time = value);\n     tx.genesis_time.ifPresent(value -> store.genesis_time = value);\n     tx.justified_checkpoint.ifPresent(value -> store.justified_checkpoint = value);\n-    tx.finalized_checkpoint.ifPresent(value -> store.finalized_checkpoint = value);\n+    newFinalizedCheckpoint.ifPresent(value -> store.finalized_checkpoint = value.getCheckpoint());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4963b9098e9f92d28dd72e58ae01f6023439b8e2"}, "originalPosition": 150}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7c349b5927b93d6ec14f69df72730741c15d3a8f", "author": {"user": {"login": "mbaxter", "name": null}}, "url": "https://github.com/ConsenSys/teku/commit/7c349b5927b93d6ec14f69df72730741c15d3a8f", "committedDate": "2020-06-09T18:43:33Z", "message": "Clean up"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "acdbabed62fd6941c38abf3aa2d2b8c9937bbec4", "author": {"user": {"login": "mbaxter", "name": null}}, "url": "https://github.com/ConsenSys/teku/commit/acdbabed62fd6941c38abf3aa2d2b8c9937bbec4", "committedDate": "2020-06-09T20:00:29Z", "message": "Simplify code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "938891ae36c538c1db5198a4ff6fecd00db1a42f", "author": {"user": {"login": "mbaxter", "name": null}}, "url": "https://github.com/ConsenSys/teku/commit/938891ae36c538c1db5198a4ff6fecd00db1a42f", "committedDate": "2020-06-09T20:02:27Z", "message": "Revert \"Simplify code\" - this form ends up caching too many states\n\nThis reverts commit acdbabed62fd6941c38abf3aa2d2b8c9937bbec4."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI3NTIxNDI0", "url": "https://github.com/ConsenSys/teku/pull/2065#pullrequestreview-427521424", "createdAt": "2020-06-09T20:37:02Z", "commit": {"oid": "938891ae36c538c1db5198a4ff6fecd00db1a42f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQyMDozNzowMlrOGhbQRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQyMDozNzowMlrOGhbQRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzcwMjcyNA==", "bodyText": "Any opinions on a good default size here?  50 seems like a lot - maybe 25?", "url": "https://github.com/ConsenSys/teku/pull/2065#discussion_r437702724", "createdAt": "2020-06-09T20:37:02Z", "author": {"login": "mbaxter"}, "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/StateGenerator.java", "diffHunk": "@@ -13,64 +13,136 @@\n \n package tech.pegasys.teku.core;\n \n+import static com.google.common.base.Preconditions.checkArgument;\n+\n import java.util.ArrayDeque;\n import java.util.ArrayList;\n-import java.util.Collection;\n import java.util.Collections;\n import java.util.Deque;\n-import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.Optional;\n import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.datastructures.blocks.BlockTree;\n import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.util.collections.LimitStrategy;\n+import tech.pegasys.teku.util.collections.LimitedMap;\n \n+/** Utility for regenerating block states given a block tree and a root state. */\n public class StateGenerator {\n+  private static final int DEFAULT_STATE_CACHE_SIZE = 50;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "938891ae36c538c1db5198a4ff6fecd00db1a42f"}, "originalPosition": 24}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI3NTIyODgw", "url": "https://github.com/ConsenSys/teku/pull/2065#pullrequestreview-427522880", "createdAt": "2020-06-09T20:39:10Z", "commit": {"oid": "938891ae36c538c1db5198a4ff6fecd00db1a42f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQyMDozOToxMVrOGhbU5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQyMDozOToxMVrOGhbU5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzcwMzkwOQ==", "bodyText": "There's some unnecessary processing happening behind the scenes when we create the BlockTree.  I may try to simplify this some more, but I think it works okay as-is.", "url": "https://github.com/ConsenSys/teku/pull/2065#discussion_r437703909", "createdAt": "2020-06-09T20:39:11Z", "author": {"login": "mbaxter"}, "path": "storage/src/main/java/tech/pegasys/teku/storage/store/Store.java", "diffHunk": "@@ -247,51 +267,109 @@ public boolean containsBlock(Bytes32 blockRoot) {\n \n   @Override\n   public BeaconState getBlockState(Bytes32 blockRoot) {\n+    return getOrGenerateBlockState(blockRoot).orElse(null);\n+  }\n+\n+  @Override\n+  public BeaconState getCheckpointState(Checkpoint checkpoint) {\n     readLock.lock();\n     try {\n-      return block_states.get(blockRoot);\n+      return checkpoint_states.get(checkpoint);\n     } finally {\n       readLock.unlock();\n     }\n   }\n \n   @Override\n-  public boolean containsBlockState(Bytes32 blockRoot) {\n+  public boolean containsCheckpointState(Checkpoint checkpoint) {\n     readLock.lock();\n     try {\n-      return block_states.containsKey(blockRoot);\n+      return checkpoint_states.containsKey(checkpoint);\n     } finally {\n       readLock.unlock();\n     }\n   }\n \n   @Override\n-  public BeaconState getCheckpointState(Checkpoint checkpoint) {\n+  public Set<UnsignedLong> getVotedValidatorIndices() {\n     readLock.lock();\n     try {\n-      return checkpoint_states.get(checkpoint);\n+      return votes.keySet();\n     } finally {\n       readLock.unlock();\n     }\n   }\n \n-  @Override\n-  public boolean containsCheckpointState(Checkpoint checkpoint) {\n+  private Optional<BeaconState> getOrGenerateBlockState(final Bytes32 blockRoot) {\n+    Optional<BeaconState> state = getState(blockRoot);\n+    if (state.isPresent()) {\n+      return state;\n+    }\n+    final SignedBeaconBlock blockForState = getSignedBlock(blockRoot);\n+    if (blockForState == null) {\n+      // If we don't have the corresponding block, we can't possibly regenerate the state\n+      return Optional.empty();\n+    }\n+\n+    // Accumulate blocks until we find our base state to build from\n+    SignedBlockAndState baseBlock = null;\n+    final Map<Bytes32, SignedBeaconBlock> blocks = new HashMap<>();\n+    SignedBeaconBlock block = blockForState;\n+    while (block != null) {\n+      final Optional<BeaconState> blockState = getState(block.getRoot());\n+      if (blockState.isPresent()) {\n+        // We found a base state\n+        baseBlock = new SignedBlockAndState(block, blockState.get());\n+        break;\n+      }\n+      blocks.put(block.getRoot(), block);\n+      block = getSignedBlock(block.getParent_root());\n+    }\n+\n+    if (baseBlock == null) {\n+      // If we haven't found a base state yet, we must have walked back to the latest finalized\n+      // block, check here for the base state\n+      final SignedBlockAndState finalizedBlock = getLatestFinalizedBlockAndState();\n+      if (!blocks.keySet().contains(finalizedBlock.getRoot())) {\n+        // We must have finalized a new block while processing and moved past our target root\n+        return Optional.empty();\n+      }\n+      baseBlock = finalizedBlock;\n+    }\n+\n+    // Regenerate state\n+    final BlockTree tree =\n+        BlockTree.builder().rootBlock(baseBlock.getBlock()).blocks(blocks.values()).build();\n+    final StateGenerator stateGenerator = new StateGenerator(tree, baseBlock.getState());\n+    final BeaconState regeneratedState = stateGenerator.regenerateStateForBlock(blockRoot);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "938891ae36c538c1db5198a4ff6fecd00db1a42f"}, "originalPosition": 185}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1087e3efada98af844c0137200b6af99643834dc", "author": {"user": {"login": "mbaxter", "name": null}}, "url": "https://github.com/ConsenSys/teku/commit/1087e3efada98af844c0137200b6af99643834dc", "committedDate": "2020-06-09T21:05:18Z", "message": "Simplify list handling"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2bf25adf136d3c534e52a7a1748458e632bf8199", "author": {"user": {"login": "mbaxter", "name": null}}, "url": "https://github.com/ConsenSys/teku/commit/2bf25adf136d3c534e52a7a1748458e632bf8199", "committedDate": "2020-06-09T21:22:49Z", "message": "Merge branch 'master' into issue-1976/limit-hot-states-kept-in-memory"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI3NTkyMjA5", "url": "https://github.com/ConsenSys/teku/pull/2065#pullrequestreview-427592209", "createdAt": "2020-06-09T22:35:47Z", "commit": {"oid": "2bf25adf136d3c534e52a7a1748458e632bf8199"}, "state": "APPROVED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQyMjozNTo0N1rOGhevjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQyMzozNTo0MFrOGhf77Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc1OTg4NA==", "bodyText": "I'd rather err on the side of too much cache since the performance cost of misses is pretty severe.  We keep 5 epochs worth of states in the actual store so I'd stick with 50.  We can tune down if we have memory pressure but given this is run at startup we have more headroom than usual anyway.", "url": "https://github.com/ConsenSys/teku/pull/2065#discussion_r437759884", "createdAt": "2020-06-09T22:35:47Z", "author": {"login": "ajsutton"}, "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/StateGenerator.java", "diffHunk": "@@ -13,64 +13,136 @@\n \n package tech.pegasys.teku.core;\n \n+import static com.google.common.base.Preconditions.checkArgument;\n+\n import java.util.ArrayDeque;\n import java.util.ArrayList;\n-import java.util.Collection;\n import java.util.Collections;\n import java.util.Deque;\n-import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.Optional;\n import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.datastructures.blocks.BlockTree;\n import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.util.collections.LimitStrategy;\n+import tech.pegasys.teku.util.collections.LimitedMap;\n \n+/** Utility for regenerating block states given a block tree and a root state. */\n public class StateGenerator {\n+  private static final int DEFAULT_STATE_CACHE_SIZE = 50;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzcwMjcyNA=="}, "originalCommit": {"oid": "938891ae36c538c1db5198a4ff6fecd00db1a42f"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc2MTk0MA==", "bodyText": "nit: Given we're using indexed iteration anyway it's probably better to just iterate backwards through the list rather than using Collections.reverse on it.", "url": "https://github.com/ConsenSys/teku/pull/2065#discussion_r437761940", "createdAt": "2020-06-09T22:41:47Z", "author": {"login": "ajsutton"}, "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/StateGenerator.java", "diffHunk": "@@ -13,64 +13,137 @@\n \n package tech.pegasys.teku.core;\n \n+import static com.google.common.base.Preconditions.checkArgument;\n+\n import java.util.ArrayDeque;\n import java.util.ArrayList;\n-import java.util.Collection;\n import java.util.Collections;\n import java.util.Deque;\n-import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.Optional;\n import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.datastructures.blocks.BlockTree;\n import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.util.collections.LimitStrategy;\n+import tech.pegasys.teku.util.collections.LimitedMap;\n \n+/** Utility for regenerating block states given a block tree and a root state. */\n public class StateGenerator {\n+  private static final int DEFAULT_STATE_CACHE_SIZE = 50;\n+\n+  final BlockTree blockTree;\n+  final BeaconState rootState;\n+\n+  public StateGenerator(final BlockTree blockTree, final BeaconState rootState) {\n+    checkArgument(\n+        blockTree.getRootBlock().getStateRoot().equals(rootState.hash_tree_root()),\n+        \"Base state must match the base block of the blockTree\");\n+    this.blockTree = blockTree;\n+    this.rootState = rootState;\n+  }\n+\n   /**\n-   * Given a base state and a set of subsequent blocks, processes the given blocks on top of the\n-   * base state to produce the states belonging to each block.\n+   * Regenerate a state for a single block.\n    *\n-   * @param baseStateBlockRoot The block root corresponding to the base state.\n-   * @param baseState The base state to build on top of.\n-   * @param newBlocks A list of blocks to process on top of the base state.\n-   * @return A map from blockRoot to state containing the base state and all other states that could\n-   *     be successfully generated. Any blocks that do not descend from the base state will be\n-   *     ignored.\n+   * @param blockRoot The root of the block\n+   * @return\n    */\n-  public Map<Bytes32, BeaconState> produceStatesForBlocks(\n-      final Bytes32 baseStateBlockRoot,\n-      final BeaconState baseState,\n-      final Collection<SignedBeaconBlock> newBlocks) {\n-    final Map<Bytes32, BeaconState> statesByRoot = new HashMap<>();\n-\n-    // Initialize states with the base state\n-    statesByRoot.put(baseStateBlockRoot, baseState);\n-\n-    // Index blocks by parent root\n-    final Map<Bytes32, List<SignedBeaconBlock>> blocksByParent = new HashMap<>();\n-    for (SignedBeaconBlock currentBlock : newBlocks) {\n-      final List<SignedBeaconBlock> blockList =\n-          blocksByParent.computeIfAbsent(currentBlock.getParent_root(), (key) -> new ArrayList<>());\n-      blockList.add(currentBlock);\n+  public BeaconState regenerateStateForBlock(final Bytes32 blockRoot) {\n+    return regenerateStateForBlock(blockRoot, Collections.emptyMap());\n+  }\n+\n+  private BeaconState regenerateStateForBlock(\n+      final Bytes32 blockRoot, final Map<Bytes32, BeaconState> stateCache) {\n+    final Bytes32 rootBlockHash = blockTree.getRootBlock().getRoot();\n+    if (rootBlockHash.equals(blockRoot)) {\n+      return rootState;\n     }\n \n-    // Generate states\n-    final Deque<Bytes32> parentRoots = new ArrayDeque<>();\n-    parentRoots.push(baseStateBlockRoot);\n-    while (!parentRoots.isEmpty()) {\n-      final Bytes32 parentRoot = parentRoots.pop();\n-      final BeaconState parentState = statesByRoot.get(parentRoot);\n-      final List<SignedBeaconBlock> blocks =\n-          blocksByParent.computeIfAbsent(parentRoot, (key) -> Collections.emptyList());\n-      for (SignedBeaconBlock block : blocks) {\n-        final Bytes32 blockRoot = block.getMessage().hash_tree_root();\n-        final BeaconState state = processBlock(parentState, block);\n-        statesByRoot.put(blockRoot, state);\n-        parentRoots.push(blockRoot);\n+    // Walk from target block towards root of the tree, stopping when we find an available state\n+    final List<SignedBeaconBlock> blocks = new ArrayList<>();\n+    Optional<SignedBeaconBlock> block = blockTree.getBlock(blockRoot);\n+    BeaconState baseState = null;\n+    while (block.isPresent()) {\n+      final Bytes32 root = block.get().getRoot();\n+      baseState = root.equals(rootBlockHash) ? rootState : stateCache.get(block.get().getRoot());\n+      if (baseState != null) {\n+        break;\n       }\n+      blocks.add(block.get());\n+      block = blockTree.getBlock(block.get().getParent_root());\n+    }\n+    checkArgument(\n+        blocks.size() > 0,\n+        \"Block %s does not belong to this %s.\",\n+        blockRoot,\n+        getClass().getSimpleName());\n+\n+    // Process blocks in order\n+    Collections.reverse(blocks);\n+    BeaconState prevState = baseState;\n+    SignedBeaconBlock currentBlock = null;\n+    BeaconState currentState = null;\n+    for (int i = 0; i < blocks.size(); i++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2bf25adf136d3c534e52a7a1748458e632bf8199"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc2MzAyNQ==", "bodyText": "It's a bit confusing that after this loop we wind up using prevState for the resulting state after applying the last block.  Would probably be simpler to just remove prevState and use only currentState so this winds up as:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  currentState = processBlock(prevState, currentBlock);\n          \n          \n            \n                  prevState = currentState;\n          \n          \n            \n                  currentState = processBlock(currentState, currentBlock);", "url": "https://github.com/ConsenSys/teku/pull/2065#discussion_r437763025", "createdAt": "2020-06-09T22:45:11Z", "author": {"login": "ajsutton"}, "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/StateGenerator.java", "diffHunk": "@@ -13,64 +13,137 @@\n \n package tech.pegasys.teku.core;\n \n+import static com.google.common.base.Preconditions.checkArgument;\n+\n import java.util.ArrayDeque;\n import java.util.ArrayList;\n-import java.util.Collection;\n import java.util.Collections;\n import java.util.Deque;\n-import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.Optional;\n import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.datastructures.blocks.BlockTree;\n import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.util.collections.LimitStrategy;\n+import tech.pegasys.teku.util.collections.LimitedMap;\n \n+/** Utility for regenerating block states given a block tree and a root state. */\n public class StateGenerator {\n+  private static final int DEFAULT_STATE_CACHE_SIZE = 50;\n+\n+  final BlockTree blockTree;\n+  final BeaconState rootState;\n+\n+  public StateGenerator(final BlockTree blockTree, final BeaconState rootState) {\n+    checkArgument(\n+        blockTree.getRootBlock().getStateRoot().equals(rootState.hash_tree_root()),\n+        \"Base state must match the base block of the blockTree\");\n+    this.blockTree = blockTree;\n+    this.rootState = rootState;\n+  }\n+\n   /**\n-   * Given a base state and a set of subsequent blocks, processes the given blocks on top of the\n-   * base state to produce the states belonging to each block.\n+   * Regenerate a state for a single block.\n    *\n-   * @param baseStateBlockRoot The block root corresponding to the base state.\n-   * @param baseState The base state to build on top of.\n-   * @param newBlocks A list of blocks to process on top of the base state.\n-   * @return A map from blockRoot to state containing the base state and all other states that could\n-   *     be successfully generated. Any blocks that do not descend from the base state will be\n-   *     ignored.\n+   * @param blockRoot The root of the block\n+   * @return\n    */\n-  public Map<Bytes32, BeaconState> produceStatesForBlocks(\n-      final Bytes32 baseStateBlockRoot,\n-      final BeaconState baseState,\n-      final Collection<SignedBeaconBlock> newBlocks) {\n-    final Map<Bytes32, BeaconState> statesByRoot = new HashMap<>();\n-\n-    // Initialize states with the base state\n-    statesByRoot.put(baseStateBlockRoot, baseState);\n-\n-    // Index blocks by parent root\n-    final Map<Bytes32, List<SignedBeaconBlock>> blocksByParent = new HashMap<>();\n-    for (SignedBeaconBlock currentBlock : newBlocks) {\n-      final List<SignedBeaconBlock> blockList =\n-          blocksByParent.computeIfAbsent(currentBlock.getParent_root(), (key) -> new ArrayList<>());\n-      blockList.add(currentBlock);\n+  public BeaconState regenerateStateForBlock(final Bytes32 blockRoot) {\n+    return regenerateStateForBlock(blockRoot, Collections.emptyMap());\n+  }\n+\n+  private BeaconState regenerateStateForBlock(\n+      final Bytes32 blockRoot, final Map<Bytes32, BeaconState> stateCache) {\n+    final Bytes32 rootBlockHash = blockTree.getRootBlock().getRoot();\n+    if (rootBlockHash.equals(blockRoot)) {\n+      return rootState;\n     }\n \n-    // Generate states\n-    final Deque<Bytes32> parentRoots = new ArrayDeque<>();\n-    parentRoots.push(baseStateBlockRoot);\n-    while (!parentRoots.isEmpty()) {\n-      final Bytes32 parentRoot = parentRoots.pop();\n-      final BeaconState parentState = statesByRoot.get(parentRoot);\n-      final List<SignedBeaconBlock> blocks =\n-          blocksByParent.computeIfAbsent(parentRoot, (key) -> Collections.emptyList());\n-      for (SignedBeaconBlock block : blocks) {\n-        final Bytes32 blockRoot = block.getMessage().hash_tree_root();\n-        final BeaconState state = processBlock(parentState, block);\n-        statesByRoot.put(blockRoot, state);\n-        parentRoots.push(blockRoot);\n+    // Walk from target block towards root of the tree, stopping when we find an available state\n+    final List<SignedBeaconBlock> blocks = new ArrayList<>();\n+    Optional<SignedBeaconBlock> block = blockTree.getBlock(blockRoot);\n+    BeaconState baseState = null;\n+    while (block.isPresent()) {\n+      final Bytes32 root = block.get().getRoot();\n+      baseState = root.equals(rootBlockHash) ? rootState : stateCache.get(block.get().getRoot());\n+      if (baseState != null) {\n+        break;\n       }\n+      blocks.add(block.get());\n+      block = blockTree.getBlock(block.get().getParent_root());\n+    }\n+    checkArgument(\n+        blocks.size() > 0,\n+        \"Block %s does not belong to this %s.\",\n+        blockRoot,\n+        getClass().getSimpleName());\n+\n+    // Process blocks in order\n+    Collections.reverse(blocks);\n+    BeaconState prevState = baseState;\n+    SignedBeaconBlock currentBlock = null;\n+    BeaconState currentState = null;\n+    for (int i = 0; i < blocks.size(); i++) {\n+      currentBlock = blocks.get(i);\n+      currentState = processBlock(prevState, currentBlock);\n+      prevState = currentState;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2bf25adf136d3c534e52a7a1748458e632bf8199"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc2MzEyMQ==", "bodyText": "Possibly just state rather than currentState even.", "url": "https://github.com/ConsenSys/teku/pull/2065#discussion_r437763121", "createdAt": "2020-06-09T22:45:28Z", "author": {"login": "ajsutton"}, "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/StateGenerator.java", "diffHunk": "@@ -13,64 +13,137 @@\n \n package tech.pegasys.teku.core;\n \n+import static com.google.common.base.Preconditions.checkArgument;\n+\n import java.util.ArrayDeque;\n import java.util.ArrayList;\n-import java.util.Collection;\n import java.util.Collections;\n import java.util.Deque;\n-import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.Optional;\n import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.datastructures.blocks.BlockTree;\n import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.util.collections.LimitStrategy;\n+import tech.pegasys.teku.util.collections.LimitedMap;\n \n+/** Utility for regenerating block states given a block tree and a root state. */\n public class StateGenerator {\n+  private static final int DEFAULT_STATE_CACHE_SIZE = 50;\n+\n+  final BlockTree blockTree;\n+  final BeaconState rootState;\n+\n+  public StateGenerator(final BlockTree blockTree, final BeaconState rootState) {\n+    checkArgument(\n+        blockTree.getRootBlock().getStateRoot().equals(rootState.hash_tree_root()),\n+        \"Base state must match the base block of the blockTree\");\n+    this.blockTree = blockTree;\n+    this.rootState = rootState;\n+  }\n+\n   /**\n-   * Given a base state and a set of subsequent blocks, processes the given blocks on top of the\n-   * base state to produce the states belonging to each block.\n+   * Regenerate a state for a single block.\n    *\n-   * @param baseStateBlockRoot The block root corresponding to the base state.\n-   * @param baseState The base state to build on top of.\n-   * @param newBlocks A list of blocks to process on top of the base state.\n-   * @return A map from blockRoot to state containing the base state and all other states that could\n-   *     be successfully generated. Any blocks that do not descend from the base state will be\n-   *     ignored.\n+   * @param blockRoot The root of the block\n+   * @return\n    */\n-  public Map<Bytes32, BeaconState> produceStatesForBlocks(\n-      final Bytes32 baseStateBlockRoot,\n-      final BeaconState baseState,\n-      final Collection<SignedBeaconBlock> newBlocks) {\n-    final Map<Bytes32, BeaconState> statesByRoot = new HashMap<>();\n-\n-    // Initialize states with the base state\n-    statesByRoot.put(baseStateBlockRoot, baseState);\n-\n-    // Index blocks by parent root\n-    final Map<Bytes32, List<SignedBeaconBlock>> blocksByParent = new HashMap<>();\n-    for (SignedBeaconBlock currentBlock : newBlocks) {\n-      final List<SignedBeaconBlock> blockList =\n-          blocksByParent.computeIfAbsent(currentBlock.getParent_root(), (key) -> new ArrayList<>());\n-      blockList.add(currentBlock);\n+  public BeaconState regenerateStateForBlock(final Bytes32 blockRoot) {\n+    return regenerateStateForBlock(blockRoot, Collections.emptyMap());\n+  }\n+\n+  private BeaconState regenerateStateForBlock(\n+      final Bytes32 blockRoot, final Map<Bytes32, BeaconState> stateCache) {\n+    final Bytes32 rootBlockHash = blockTree.getRootBlock().getRoot();\n+    if (rootBlockHash.equals(blockRoot)) {\n+      return rootState;\n     }\n \n-    // Generate states\n-    final Deque<Bytes32> parentRoots = new ArrayDeque<>();\n-    parentRoots.push(baseStateBlockRoot);\n-    while (!parentRoots.isEmpty()) {\n-      final Bytes32 parentRoot = parentRoots.pop();\n-      final BeaconState parentState = statesByRoot.get(parentRoot);\n-      final List<SignedBeaconBlock> blocks =\n-          blocksByParent.computeIfAbsent(parentRoot, (key) -> Collections.emptyList());\n-      for (SignedBeaconBlock block : blocks) {\n-        final Bytes32 blockRoot = block.getMessage().hash_tree_root();\n-        final BeaconState state = processBlock(parentState, block);\n-        statesByRoot.put(blockRoot, state);\n-        parentRoots.push(blockRoot);\n+    // Walk from target block towards root of the tree, stopping when we find an available state\n+    final List<SignedBeaconBlock> blocks = new ArrayList<>();\n+    Optional<SignedBeaconBlock> block = blockTree.getBlock(blockRoot);\n+    BeaconState baseState = null;\n+    while (block.isPresent()) {\n+      final Bytes32 root = block.get().getRoot();\n+      baseState = root.equals(rootBlockHash) ? rootState : stateCache.get(block.get().getRoot());\n+      if (baseState != null) {\n+        break;\n       }\n+      blocks.add(block.get());\n+      block = blockTree.getBlock(block.get().getParent_root());\n+    }\n+    checkArgument(\n+        blocks.size() > 0,\n+        \"Block %s does not belong to this %s.\",\n+        blockRoot,\n+        getClass().getSimpleName());\n+\n+    // Process blocks in order\n+    Collections.reverse(blocks);\n+    BeaconState prevState = baseState;\n+    SignedBeaconBlock currentBlock = null;\n+    BeaconState currentState = null;\n+    for (int i = 0; i < blocks.size(); i++) {\n+      currentBlock = blocks.get(i);\n+      currentState = processBlock(prevState, currentBlock);\n+      prevState = currentState;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc2MzAyNQ=="}, "originalCommit": {"oid": "2bf25adf136d3c534e52a7a1748458e632bf8199"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc2NzYxNQ==", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    branchBlock = children.size() > 0 ? children.get(0) : null;\n          \n          \n            \n                    branchBlock = !children.isEmpty() ? children.get(0) : null;", "url": "https://github.com/ConsenSys/teku/pull/2065#discussion_r437767615", "createdAt": "2020-06-09T22:58:55Z", "author": {"login": "ajsutton"}, "path": "ethereum/core/src/main/java/tech/pegasys/teku/core/StateGenerator.java", "diffHunk": "@@ -13,64 +13,137 @@\n \n package tech.pegasys.teku.core;\n \n+import static com.google.common.base.Preconditions.checkArgument;\n+\n import java.util.ArrayDeque;\n import java.util.ArrayList;\n-import java.util.Collection;\n import java.util.Collections;\n import java.util.Deque;\n-import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.Optional;\n import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.teku.datastructures.blocks.BlockTree;\n import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n import tech.pegasys.teku.datastructures.state.BeaconState;\n+import tech.pegasys.teku.util.collections.LimitStrategy;\n+import tech.pegasys.teku.util.collections.LimitedMap;\n \n+/** Utility for regenerating block states given a block tree and a root state. */\n public class StateGenerator {\n+  private static final int DEFAULT_STATE_CACHE_SIZE = 50;\n+\n+  final BlockTree blockTree;\n+  final BeaconState rootState;\n+\n+  public StateGenerator(final BlockTree blockTree, final BeaconState rootState) {\n+    checkArgument(\n+        blockTree.getRootBlock().getStateRoot().equals(rootState.hash_tree_root()),\n+        \"Base state must match the base block of the blockTree\");\n+    this.blockTree = blockTree;\n+    this.rootState = rootState;\n+  }\n+\n   /**\n-   * Given a base state and a set of subsequent blocks, processes the given blocks on top of the\n-   * base state to produce the states belonging to each block.\n+   * Regenerate a state for a single block.\n    *\n-   * @param baseStateBlockRoot The block root corresponding to the base state.\n-   * @param baseState The base state to build on top of.\n-   * @param newBlocks A list of blocks to process on top of the base state.\n-   * @return A map from blockRoot to state containing the base state and all other states that could\n-   *     be successfully generated. Any blocks that do not descend from the base state will be\n-   *     ignored.\n+   * @param blockRoot The root of the block\n+   * @return\n    */\n-  public Map<Bytes32, BeaconState> produceStatesForBlocks(\n-      final Bytes32 baseStateBlockRoot,\n-      final BeaconState baseState,\n-      final Collection<SignedBeaconBlock> newBlocks) {\n-    final Map<Bytes32, BeaconState> statesByRoot = new HashMap<>();\n-\n-    // Initialize states with the base state\n-    statesByRoot.put(baseStateBlockRoot, baseState);\n-\n-    // Index blocks by parent root\n-    final Map<Bytes32, List<SignedBeaconBlock>> blocksByParent = new HashMap<>();\n-    for (SignedBeaconBlock currentBlock : newBlocks) {\n-      final List<SignedBeaconBlock> blockList =\n-          blocksByParent.computeIfAbsent(currentBlock.getParent_root(), (key) -> new ArrayList<>());\n-      blockList.add(currentBlock);\n+  public BeaconState regenerateStateForBlock(final Bytes32 blockRoot) {\n+    return regenerateStateForBlock(blockRoot, Collections.emptyMap());\n+  }\n+\n+  private BeaconState regenerateStateForBlock(\n+      final Bytes32 blockRoot, final Map<Bytes32, BeaconState> stateCache) {\n+    final Bytes32 rootBlockHash = blockTree.getRootBlock().getRoot();\n+    if (rootBlockHash.equals(blockRoot)) {\n+      return rootState;\n     }\n \n-    // Generate states\n-    final Deque<Bytes32> parentRoots = new ArrayDeque<>();\n-    parentRoots.push(baseStateBlockRoot);\n-    while (!parentRoots.isEmpty()) {\n-      final Bytes32 parentRoot = parentRoots.pop();\n-      final BeaconState parentState = statesByRoot.get(parentRoot);\n-      final List<SignedBeaconBlock> blocks =\n-          blocksByParent.computeIfAbsent(parentRoot, (key) -> Collections.emptyList());\n-      for (SignedBeaconBlock block : blocks) {\n-        final Bytes32 blockRoot = block.getMessage().hash_tree_root();\n-        final BeaconState state = processBlock(parentState, block);\n-        statesByRoot.put(blockRoot, state);\n-        parentRoots.push(blockRoot);\n+    // Walk from target block towards root of the tree, stopping when we find an available state\n+    final List<SignedBeaconBlock> blocks = new ArrayList<>();\n+    Optional<SignedBeaconBlock> block = blockTree.getBlock(blockRoot);\n+    BeaconState baseState = null;\n+    while (block.isPresent()) {\n+      final Bytes32 root = block.get().getRoot();\n+      baseState = root.equals(rootBlockHash) ? rootState : stateCache.get(block.get().getRoot());\n+      if (baseState != null) {\n+        break;\n       }\n+      blocks.add(block.get());\n+      block = blockTree.getBlock(block.get().getParent_root());\n+    }\n+    checkArgument(\n+        blocks.size() > 0,\n+        \"Block %s does not belong to this %s.\",\n+        blockRoot,\n+        getClass().getSimpleName());\n+\n+    // Process blocks in order\n+    Collections.reverse(blocks);\n+    BeaconState prevState = baseState;\n+    SignedBeaconBlock currentBlock = null;\n+    BeaconState currentState = null;\n+    for (int i = 0; i < blocks.size(); i++) {\n+      currentBlock = blocks.get(i);\n+      currentState = processBlock(prevState, currentBlock);\n+      prevState = currentState;\n     }\n \n-    return statesByRoot;\n+    // Validate result and return\n+    if (!currentBlock.getStateRoot().equals(currentState.hash_tree_root())) {\n+      final String msg =\n+          String.format(\n+              \"Failed to regenerate state for block root %s.  Generated state root %s does not match expected state root %s\",\n+              blockRoot, prevState.hash_tree_root(), currentBlock.getStateRoot());\n+      throw new IllegalStateException(msg);\n+    }\n+    return prevState;\n+  }\n+\n+  /**\n+   * Regenerate all states in the block tree.\n+   *\n+   * @param stateHandler A handler to process each state as it is generated.\n+   */\n+  public void regenerateAllStates(final StateHandler stateHandler) {\n+    regenerateAllStates(stateHandler, DEFAULT_STATE_CACHE_SIZE);\n+  }\n+\n+  void regenerateAllStates(final StateHandler stateHandler, final int maxCachedStates) {\n+    final Map<Bytes32, BeaconState> branchStateCache =\n+        LimitedMap.create(maxCachedStates, LimitStrategy.DROP_LEAST_RECENTLY_ACCESSED);\n+\n+    final Deque<SignedBeaconBlock> branchesToProcess = new ArrayDeque<>();\n+    final SignedBeaconBlock rootBlock = blockTree.getRootBlock();\n+    blockTree.getChildren(rootBlock).forEach(branchesToProcess::push);\n+\n+    while (!branchesToProcess.isEmpty()) {\n+      SignedBeaconBlock branchBlock = branchesToProcess.pop();\n+      BeaconState preState =\n+          branchStateCache.computeIfAbsent(\n+              branchBlock.getParent_root(),\n+              root -> regenerateStateForBlock(root, branchStateCache));\n+      while (branchBlock != null) {\n+        // Produce state for the current branch block\n+        final BeaconState branchBlockState = processBlock(preState, branchBlock);\n+        stateHandler.handle(branchBlock.getRoot(), branchBlockState);\n+\n+        // Process children\n+        final List<SignedBeaconBlock> children =\n+            new ArrayList<>(blockTree.getChildren(branchBlock.getRoot()));\n+        // Save branches for later processing\n+        if (children.size() > 1) {\n+          // Only cache the current state if there are other branches we need to come back to later\n+          branchStateCache.put(branchBlock.getRoot(), branchBlockState);\n+          children.subList(1, children.size()).forEach(branchesToProcess::push);\n+        }\n+        // Continue processing the first child\n+        branchBlock = children.size() > 0 ? children.get(0) : null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2bf25adf136d3c534e52a7a1748458e632bf8199"}, "originalPosition": 170}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc3OTQzNw==", "bodyText": "nice.", "url": "https://github.com/ConsenSys/teku/pull/2065#discussion_r437779437", "createdAt": "2020-06-09T23:35:40Z", "author": {"login": "ajsutton"}, "path": "storage/src/testFixtures/java/tech/pegasys/teku/storage/store/StoreAssertions.java", "diffHunk": "@@ -0,0 +1,25 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.storage.store;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+public class StoreAssertions {\n+\n+  public static void assertStoresMatch(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2bf25adf136d3c534e52a7a1748458e632bf8199"}, "originalPosition": 20}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a8f686bc227496fadca1bdae51e78e083708ab5b", "author": {"user": {"login": "mbaxter", "name": null}}, "url": "https://github.com/ConsenSys/teku/commit/a8f686bc227496fadca1bdae51e78e083708ab5b", "committedDate": "2020-06-10T14:43:02Z", "message": "Make vars private, clean up code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "98fa46583a6e285935b4d01f27bbb12ba877a8f1", "author": {"user": {"login": "mbaxter", "name": null}}, "url": "https://github.com/ConsenSys/teku/commit/98fa46583a6e285935b4d01f27bbb12ba877a8f1", "committedDate": "2020-06-10T14:43:07Z", "message": "Merge branch 'master' into issue-1976/limit-hot-states-kept-in-memory"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3857, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}