{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcwOTQ3ODk1", "number": 1133, "reviewThreads": {"totalCount": 36, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQxNjowMjo1OVrODh7dBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxNzo0OTozMlrODkXMNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2OTAzNjg0OnYy", "diffSide": "RIGHT", "path": "util/src/main/java/tech/pegasys/artemis/util/backing/CompositeViewWrite.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQxNjowMjo1OVrOFs7_4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQwODowOToyNVrOFt8CUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY2NDY3NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              void setIvalidator(Consumer<ViewWrite> listener);\n          \n          \n            \n              void setInvalidator(Consumer<ViewWrite> listener);", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r382664675", "createdAt": "2020-02-21T16:02:59Z", "author": {"login": "mbaxter"}, "path": "util/src/main/java/tech/pegasys/artemis/util/backing/CompositeViewWrite.java", "diffHunk": "@@ -0,0 +1,28 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.util.backing;\n+\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+public interface CompositeViewWrite<R> extends ViewWrite, CompositeViewRead<R> {\n+\n+  void setIvalidator(Consumer<ViewWrite> listener);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "436110f264a354c57d44a36f7cc9275565bc8fee"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzcxMzg3NQ==", "bodyText": "Thanks!", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r383713875", "createdAt": "2020-02-25T08:09:25Z", "author": {"login": "Nashatyrev"}, "path": "util/src/main/java/tech/pegasys/artemis/util/backing/CompositeViewWrite.java", "diffHunk": "@@ -0,0 +1,28 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.util.backing;\n+\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+public interface CompositeViewWrite<R> extends ViewWrite, CompositeViewRead<R> {\n+\n+  void setIvalidator(Consumer<ViewWrite> listener);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY2NDY3NQ=="}, "originalCommit": {"oid": "436110f264a354c57d44a36f7cc9275565bc8fee"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2OTA1MjE0OnYy", "diffSide": "RIGHT", "path": "eth-reference-tests/src/referenceTest/java/tech/pegasys/artemis/reference/phase0/epoch_processing/final_updates.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQxNjowNzoxOFrOFs8JRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQwODoxMDowM1rOFt8Ddg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY2NzA3OA==", "bodyText": "looks like most of these reference test methods should be able to use the BeaconState interface types (MutableBeaconState)", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r382667078", "createdAt": "2020-02-21T16:07:18Z", "author": {"login": "mbaxter"}, "path": "eth-reference-tests/src/referenceTest/java/tech/pegasys/artemis/reference/phase0/epoch_processing/final_updates.java", "diffHunk": "@@ -24,22 +24,22 @@\n import org.junit.jupiter.params.ParameterizedTest;\n import org.junit.jupiter.params.provider.Arguments;\n import org.junit.jupiter.params.provider.MethodSource;\n-import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.state.BeaconStateImpl;\n import tech.pegasys.artemis.ethtests.TestSuite;\n import tech.pegasys.artemis.statetransition.util.EpochProcessorUtil;\n \n @ExtendWith(BouncyCastleExtension.class)\n public class final_updates extends TestSuite {\n   @ParameterizedTest(name = \"{index}. process final updates pre={0} -> post={1}\")\n   @MethodSource(\"mainnetFinalUpdatesSetup\")\n-  void mainnetProcessFinalUpdates(BeaconState pre, BeaconState post) throws Exception {\n+  void mainnetProcessFinalUpdates(BeaconStateImpl pre, BeaconStateImpl post) throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff245c21e0cfa5fa580421708eb5e179d1fd22d8"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzcxNDE2Ng==", "bodyText": "Yes, ref tests are still on the way", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r383714166", "createdAt": "2020-02-25T08:10:03Z", "author": {"login": "Nashatyrev"}, "path": "eth-reference-tests/src/referenceTest/java/tech/pegasys/artemis/reference/phase0/epoch_processing/final_updates.java", "diffHunk": "@@ -24,22 +24,22 @@\n import org.junit.jupiter.params.ParameterizedTest;\n import org.junit.jupiter.params.provider.Arguments;\n import org.junit.jupiter.params.provider.MethodSource;\n-import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.state.BeaconStateImpl;\n import tech.pegasys.artemis.ethtests.TestSuite;\n import tech.pegasys.artemis.statetransition.util.EpochProcessorUtil;\n \n @ExtendWith(BouncyCastleExtension.class)\n public class final_updates extends TestSuite {\n   @ParameterizedTest(name = \"{index}. process final updates pre={0} -> post={1}\")\n   @MethodSource(\"mainnetFinalUpdatesSetup\")\n-  void mainnetProcessFinalUpdates(BeaconState pre, BeaconState post) throws Exception {\n+  void mainnetProcessFinalUpdates(BeaconStateImpl pre, BeaconStateImpl post) throws Exception {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY2NzA3OA=="}, "originalCommit": {"oid": "ff245c21e0cfa5fa580421708eb5e179d1fd22d8"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2OTA2ODA1OnYy", "diffSide": "RIGHT", "path": "util/src/main/java/tech/pegasys/artemis/util/backing/view/AbstractBasicView.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQxNjoxMjowN1rOFs8Tqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNToyMDoyNFrOFuKNiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY2OTczOQ==", "bodyText": "Is it possible to break up the interfaces in a more granular way so we don't end up needing these UnsupportedOperationException's ?", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r382669739", "createdAt": "2020-02-21T16:12:07Z", "author": {"login": "mbaxter"}, "path": "util/src/main/java/tech/pegasys/artemis/util/backing/view/AbstractBasicView.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.util.backing.view;\n+\n+import tech.pegasys.artemis.util.backing.BasicView;\n+import tech.pegasys.artemis.util.backing.ViewWrite;\n+import tech.pegasys.artemis.util.backing.tree.TreeNode;\n+import tech.pegasys.artemis.util.backing.type.BasicViewType;\n+\n+public abstract class AbstractBasicView<C, V extends AbstractBasicView<C, V>>\n+    implements BasicView<C> {\n+  private final BasicViewType<V> type;\n+  private final C value;\n+\n+  public AbstractBasicView(C value, BasicViewType<V> type) {\n+    this.type = type;\n+    this.value = value;\n+  }\n+\n+  @Override\n+  public C get() {\n+    return value;\n+  }\n+\n+  @Override\n+  public BasicViewType<V> getType() {\n+    return type;\n+  }\n+\n+  @Override\n+  public TreeNode getBackingNode() {\n+    return getType().createTreeNode(getThis());\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  protected V getThis() {\n+    return (V) this;\n+  }\n+\n+  @Override\n+  public ViewWrite createWritableCopy() {\n+    throw new UnsupportedOperationException(\"Basic view instances are immutable\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff245c21e0cfa5fa580421708eb5e179d1fd22d8"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzk0NjEyMQ==", "bodyText": "Very good question! :)\nI honestly tried to do this, but didn't succeeded. The reason is that mutable 'views' extends immutable, like this:\ninterface ImmutableA {\n    int getInt();\n}\ninterface MutableA extends ImmutableA {\n    void setInt(int i);\n}\n\ninterface ImmutableB {\n    ImmutableA getA();\n}\ninterface MutableB {\n    // here we can narrow return type to mutable\n    MutableA getA();\n}\nThis way you get the whole data hierarchy either immutable or mutable.\nSeparating immutable and mutable class hierarchies is possible though eliminates flexibility.\nE.g. beacon state transition functions requires MutableBeaconState but they use functions which need just readonly BeaconState. In the current design you just pass MutableBeaconState instance (which it subclass of BeaconState). If hierarchies are separated it would become less graceful.\nOh, just realized that I was explaining similar issue which is a bit different from your concern: my wish to prohibit the following methods for ViewWrite:\n\ncreateWriteableCopy\nhashTreeRoot\n\nAll my efforts to achieve finer interface granularity and generic type safety had resulted in a pretty complex and large interfaces set, so I just gave up finally\nAny ideas on improvements which don't lead to number of interfaces explosure are very welcome!", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r383946121", "createdAt": "2020-02-25T15:20:24Z", "author": {"login": "Nashatyrev"}, "path": "util/src/main/java/tech/pegasys/artemis/util/backing/view/AbstractBasicView.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.util.backing.view;\n+\n+import tech.pegasys.artemis.util.backing.BasicView;\n+import tech.pegasys.artemis.util.backing.ViewWrite;\n+import tech.pegasys.artemis.util.backing.tree.TreeNode;\n+import tech.pegasys.artemis.util.backing.type.BasicViewType;\n+\n+public abstract class AbstractBasicView<C, V extends AbstractBasicView<C, V>>\n+    implements BasicView<C> {\n+  private final BasicViewType<V> type;\n+  private final C value;\n+\n+  public AbstractBasicView(C value, BasicViewType<V> type) {\n+    this.type = type;\n+    this.value = value;\n+  }\n+\n+  @Override\n+  public C get() {\n+    return value;\n+  }\n+\n+  @Override\n+  public BasicViewType<V> getType() {\n+    return type;\n+  }\n+\n+  @Override\n+  public TreeNode getBackingNode() {\n+    return getType().createTreeNode(getThis());\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  protected V getThis() {\n+    return (V) this;\n+  }\n+\n+  @Override\n+  public ViewWrite createWritableCopy() {\n+    throw new UnsupportedOperationException(\"Basic view instances are immutable\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY2OTczOQ=="}, "originalCommit": {"oid": "ff245c21e0cfa5fa580421708eb5e179d1fd22d8"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2OTA5MDExOnYy", "diffSide": "RIGHT", "path": "ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/state/BeaconStateImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMVQxNjoxODo0NFrOFs8hww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQwODoxMjoyNVrOFt8Hag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY3MzM0Nw==", "bodyText": "looks like all these unused fields can go away?", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r382673347", "createdAt": "2020-02-21T16:18:44Z", "author": {"login": "mbaxter"}, "path": "ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/state/BeaconStateImpl.java", "diffHunk": "@@ -0,0 +1,719 @@\n+/*\n+ * Copyright 2019 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.datastructures.state;\n+\n+import com.google.common.base.MoreObjects;\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import jdk.jfr.Label;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.apache.tuweni.ssz.SSZ;\n+import tech.pegasys.artemis.datastructures.blocks.BeaconBlockHeader;\n+import tech.pegasys.artemis.datastructures.blocks.Eth1Data;\n+import tech.pegasys.artemis.datastructures.util.SimpleOffsetSerializer;\n+import tech.pegasys.artemis.util.SSZTypes.Bitvector;\n+import tech.pegasys.artemis.util.SSZTypes.SSZBackingList;\n+import tech.pegasys.artemis.util.SSZTypes.SSZBackingListRef;\n+import tech.pegasys.artemis.util.SSZTypes.SSZBackingVector;\n+import tech.pegasys.artemis.util.SSZTypes.SSZList;\n+import tech.pegasys.artemis.util.SSZTypes.SSZMutableList;\n+import tech.pegasys.artemis.util.SSZTypes.SSZMutableRefList;\n+import tech.pegasys.artemis.util.SSZTypes.SSZMutableVector;\n+import tech.pegasys.artemis.util.SSZTypes.SSZVector;\n+import tech.pegasys.artemis.util.backing.ContainerViewWrite;\n+import tech.pegasys.artemis.util.backing.ListViewWrite;\n+import tech.pegasys.artemis.util.backing.ListViewWriteRef;\n+import tech.pegasys.artemis.util.backing.VectorViewRead;\n+import tech.pegasys.artemis.util.backing.VectorViewWrite;\n+import tech.pegasys.artemis.util.backing.ViewRead;\n+import tech.pegasys.artemis.util.backing.tree.TreeNode;\n+import tech.pegasys.artemis.util.backing.type.BasicViewTypes;\n+import tech.pegasys.artemis.util.backing.type.ContainerViewType;\n+import tech.pegasys.artemis.util.backing.type.ListViewType;\n+import tech.pegasys.artemis.util.backing.type.VectorViewType;\n+import tech.pegasys.artemis.util.backing.view.AbstractBasicView;\n+import tech.pegasys.artemis.util.backing.view.BasicViews.BitView;\n+import tech.pegasys.artemis.util.backing.view.BasicViews.Bytes32View;\n+import tech.pegasys.artemis.util.backing.view.BasicViews.UInt64View;\n+import tech.pegasys.artemis.util.backing.view.ContainerViewImpl;\n+import tech.pegasys.artemis.util.backing.view.ViewUtils;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class BeaconStateImpl extends ContainerViewImpl<BeaconStateImpl>\n+    implements MutableBeaconState, BeaconStateCache {\n+\n+  // The number of SimpleSerialize basic types in this SSZ Container/POJO.\n+  public static final int SSZ_FIELD_COUNT = 14;\n+\n+  public static final ContainerViewType<BeaconStateImpl> TYPE =\n+      new ContainerViewType<>(\n+          List.of(\n+              BasicViewTypes.UINT64_TYPE,\n+              BasicViewTypes.UINT64_TYPE,\n+              Fork.TYPE,\n+              BeaconBlockHeader.TYPE,\n+              new VectorViewType<>(\n+                  BasicViewTypes.BYTES32_TYPE, Constants.SLOTS_PER_HISTORICAL_ROOT),\n+              new VectorViewType<>(\n+                  BasicViewTypes.BYTES32_TYPE, Constants.SLOTS_PER_HISTORICAL_ROOT),\n+              new ListViewType<>(BasicViewTypes.BYTES32_TYPE, Constants.HISTORICAL_ROOTS_LIMIT),\n+              Eth1Data.TYPE,\n+              new ListViewType<>(Eth1Data.TYPE, Constants.SLOTS_PER_ETH1_VOTING_PERIOD),\n+              BasicViewTypes.UINT64_TYPE,\n+              new ListViewType<>(ValidatorImpl.TYPE, Constants.VALIDATOR_REGISTRY_LIMIT),\n+              new ListViewType<>(BasicViewTypes.UINT64_TYPE, Constants.VALIDATOR_REGISTRY_LIMIT),\n+              new VectorViewType<>(\n+                  BasicViewTypes.BYTES32_TYPE, Constants.EPOCHS_PER_HISTORICAL_VECTOR),\n+              new VectorViewType<>(\n+                  BasicViewTypes.UINT64_TYPE, Constants.EPOCHS_PER_SLASHINGS_VECTOR),\n+              new ListViewType<>(\n+                  PendingAttestation.TYPE, Constants.MAX_ATTESTATIONS * Constants.SLOTS_PER_EPOCH),\n+              new ListViewType<>(\n+                  PendingAttestation.TYPE, Constants.MAX_ATTESTATIONS * Constants.SLOTS_PER_EPOCH),\n+              new VectorViewType<>(BasicViewTypes.BIT_TYPE, Constants.JUSTIFICATION_BITS_LENGTH),\n+              Checkpoint.TYPE,\n+              Checkpoint.TYPE,\n+              Checkpoint.TYPE),\n+          BeaconStateImpl::new);\n+\n+  @Label(\"sos-ignore\")\n+  private final TransitionCaches transitionCaches;\n+\n+  @Label(\"sos-ignore\")\n+  private final boolean builder;\n+\n+  // Versioning\n+  @SuppressWarnings(\"unused\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff245c21e0cfa5fa580421708eb5e179d1fd22d8"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzcxNTE3OA==", "bodyText": "Absolutely, but later, since SSZ SoS relies on fields via reflection for now", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r383715178", "createdAt": "2020-02-25T08:12:25Z", "author": {"login": "Nashatyrev"}, "path": "ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/state/BeaconStateImpl.java", "diffHunk": "@@ -0,0 +1,719 @@\n+/*\n+ * Copyright 2019 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.datastructures.state;\n+\n+import com.google.common.base.MoreObjects;\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import jdk.jfr.Label;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.apache.tuweni.ssz.SSZ;\n+import tech.pegasys.artemis.datastructures.blocks.BeaconBlockHeader;\n+import tech.pegasys.artemis.datastructures.blocks.Eth1Data;\n+import tech.pegasys.artemis.datastructures.util.SimpleOffsetSerializer;\n+import tech.pegasys.artemis.util.SSZTypes.Bitvector;\n+import tech.pegasys.artemis.util.SSZTypes.SSZBackingList;\n+import tech.pegasys.artemis.util.SSZTypes.SSZBackingListRef;\n+import tech.pegasys.artemis.util.SSZTypes.SSZBackingVector;\n+import tech.pegasys.artemis.util.SSZTypes.SSZList;\n+import tech.pegasys.artemis.util.SSZTypes.SSZMutableList;\n+import tech.pegasys.artemis.util.SSZTypes.SSZMutableRefList;\n+import tech.pegasys.artemis.util.SSZTypes.SSZMutableVector;\n+import tech.pegasys.artemis.util.SSZTypes.SSZVector;\n+import tech.pegasys.artemis.util.backing.ContainerViewWrite;\n+import tech.pegasys.artemis.util.backing.ListViewWrite;\n+import tech.pegasys.artemis.util.backing.ListViewWriteRef;\n+import tech.pegasys.artemis.util.backing.VectorViewRead;\n+import tech.pegasys.artemis.util.backing.VectorViewWrite;\n+import tech.pegasys.artemis.util.backing.ViewRead;\n+import tech.pegasys.artemis.util.backing.tree.TreeNode;\n+import tech.pegasys.artemis.util.backing.type.BasicViewTypes;\n+import tech.pegasys.artemis.util.backing.type.ContainerViewType;\n+import tech.pegasys.artemis.util.backing.type.ListViewType;\n+import tech.pegasys.artemis.util.backing.type.VectorViewType;\n+import tech.pegasys.artemis.util.backing.view.AbstractBasicView;\n+import tech.pegasys.artemis.util.backing.view.BasicViews.BitView;\n+import tech.pegasys.artemis.util.backing.view.BasicViews.Bytes32View;\n+import tech.pegasys.artemis.util.backing.view.BasicViews.UInt64View;\n+import tech.pegasys.artemis.util.backing.view.ContainerViewImpl;\n+import tech.pegasys.artemis.util.backing.view.ViewUtils;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class BeaconStateImpl extends ContainerViewImpl<BeaconStateImpl>\n+    implements MutableBeaconState, BeaconStateCache {\n+\n+  // The number of SimpleSerialize basic types in this SSZ Container/POJO.\n+  public static final int SSZ_FIELD_COUNT = 14;\n+\n+  public static final ContainerViewType<BeaconStateImpl> TYPE =\n+      new ContainerViewType<>(\n+          List.of(\n+              BasicViewTypes.UINT64_TYPE,\n+              BasicViewTypes.UINT64_TYPE,\n+              Fork.TYPE,\n+              BeaconBlockHeader.TYPE,\n+              new VectorViewType<>(\n+                  BasicViewTypes.BYTES32_TYPE, Constants.SLOTS_PER_HISTORICAL_ROOT),\n+              new VectorViewType<>(\n+                  BasicViewTypes.BYTES32_TYPE, Constants.SLOTS_PER_HISTORICAL_ROOT),\n+              new ListViewType<>(BasicViewTypes.BYTES32_TYPE, Constants.HISTORICAL_ROOTS_LIMIT),\n+              Eth1Data.TYPE,\n+              new ListViewType<>(Eth1Data.TYPE, Constants.SLOTS_PER_ETH1_VOTING_PERIOD),\n+              BasicViewTypes.UINT64_TYPE,\n+              new ListViewType<>(ValidatorImpl.TYPE, Constants.VALIDATOR_REGISTRY_LIMIT),\n+              new ListViewType<>(BasicViewTypes.UINT64_TYPE, Constants.VALIDATOR_REGISTRY_LIMIT),\n+              new VectorViewType<>(\n+                  BasicViewTypes.BYTES32_TYPE, Constants.EPOCHS_PER_HISTORICAL_VECTOR),\n+              new VectorViewType<>(\n+                  BasicViewTypes.UINT64_TYPE, Constants.EPOCHS_PER_SLASHINGS_VECTOR),\n+              new ListViewType<>(\n+                  PendingAttestation.TYPE, Constants.MAX_ATTESTATIONS * Constants.SLOTS_PER_EPOCH),\n+              new ListViewType<>(\n+                  PendingAttestation.TYPE, Constants.MAX_ATTESTATIONS * Constants.SLOTS_PER_EPOCH),\n+              new VectorViewType<>(BasicViewTypes.BIT_TYPE, Constants.JUSTIFICATION_BITS_LENGTH),\n+              Checkpoint.TYPE,\n+              Checkpoint.TYPE,\n+              Checkpoint.TYPE),\n+          BeaconStateImpl::new);\n+\n+  @Label(\"sos-ignore\")\n+  private final TransitionCaches transitionCaches;\n+\n+  @Label(\"sos-ignore\")\n+  private final boolean builder;\n+\n+  // Versioning\n+  @SuppressWarnings(\"unused\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjY3MzM0Nw=="}, "originalCommit": {"oid": "ff245c21e0cfa5fa580421708eb5e179d1fd22d8"}, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NjAxNzU1OnYy", "diffSide": "RIGHT", "path": "eth-benchmark-tests/src/jmh/java/tech/pegasys/artemis/benchmarks/ProfilingRun.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxNzozNzo1NlrOFvatww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxNzozNzo1NlrOFvatww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI2NTA5MQ==", "bodyText": "I too feel like that about the BeaconState sometimes \ud83d\ude09", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r385265091", "createdAt": "2020-02-27T17:37:56Z", "author": {"login": "protolambda"}, "path": "eth-benchmark-tests/src/jmh/java/tech/pegasys/artemis/benchmarks/ProfilingRun.java", "diffHunk": "@@ -81,4 +92,89 @@ public void importBlocks() throws Exception {\n       }\n     }\n   }\n+\n+  void compareHashes(BeaconState s1) {\n+    for (int i = 0; i < s1.size(); i++) {\n+      Bytes32 hash = s1.get(i).hashTreeRoot();\n+      System.out.println(i + \": \" + hash);\n+    }\n+    System.out.println(\"BS: \" + s1.hash_tree_root());\n+    System.out.println(\"BS: \" + old_hash_tree_root(s1));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85ccb05f20ba7b587c53c4a2d5007b969a49613b"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NjAzOTU2OnYy", "diffSide": "RIGHT", "path": "eth-reference-tests/src/referenceTest/java/tech/pegasys/artemis/reference/phase0/epoch_processing/justification_and_finalization.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxNzo0NDo0MVrOFva7pw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQwODowNjozN1rOFvsdsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI2ODY0Nw==", "bodyText": "Maybe just pass a mutable beaconstate as pre, since you always have to mutate pre to get post?", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r385268647", "createdAt": "2020-02-27T17:44:41Z", "author": {"login": "protolambda"}, "path": "eth-reference-tests/src/referenceTest/java/tech/pegasys/artemis/reference/phase0/epoch_processing/justification_and_finalization.java", "diffHunk": "@@ -25,25 +25,28 @@\n import org.junit.jupiter.params.provider.Arguments;\n import org.junit.jupiter.params.provider.MethodSource;\n import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.state.MutableBeaconState;\n import tech.pegasys.artemis.ethtests.TestSuite;\n import tech.pegasys.artemis.statetransition.util.EpochProcessorUtil;\n \n @ExtendWith(BouncyCastleExtension.class)\n public class justification_and_finalization extends TestSuite {\n-  @ParameterizedTest(name = \"{index}. process justification and finalization pre={0} -> post={1}\")\n+  @ParameterizedTest(name = \"{index}.{2} process justification and finalization\")\n   @MethodSource(\"mainnetProcessJusticationAndFinalizationSetup\")\n-  void mainnetProcessJusticationAndFinalization(BeaconState pre, BeaconState post)\n+  void mainnetProcessJusticationAndFinalization(BeaconState pre, BeaconState post, String testName)\n       throws Exception {\n-    EpochProcessorUtil.process_justification_and_finalization(pre);\n-    assertEquals(pre, post);\n+    MutableBeaconState wState = pre.createWritableCopy();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85ccb05f20ba7b587c53c4a2d5007b969a49613b"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTU1NTg4OA==", "bodyText": "I'd prefer to pass immutable structs whenever possible and mutate them in a limited scope only. Thanks to backing tree design - creating a copy costs almost nothing\nI'm planning to go further and replace createWritableCopy() with\ninterface BeaconState {\n    [ ... ]\n    BeaconState update(Consumer<MutableBeaconState> mutator);\n}\nThis is to explicitly limit mutating scope and restrict accidentally leaking of mutable instances", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r385555888", "createdAt": "2020-02-28T08:06:37Z", "author": {"login": "Nashatyrev"}, "path": "eth-reference-tests/src/referenceTest/java/tech/pegasys/artemis/reference/phase0/epoch_processing/justification_and_finalization.java", "diffHunk": "@@ -25,25 +25,28 @@\n import org.junit.jupiter.params.provider.Arguments;\n import org.junit.jupiter.params.provider.MethodSource;\n import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.state.MutableBeaconState;\n import tech.pegasys.artemis.ethtests.TestSuite;\n import tech.pegasys.artemis.statetransition.util.EpochProcessorUtil;\n \n @ExtendWith(BouncyCastleExtension.class)\n public class justification_and_finalization extends TestSuite {\n-  @ParameterizedTest(name = \"{index}. process justification and finalization pre={0} -> post={1}\")\n+  @ParameterizedTest(name = \"{index}.{2} process justification and finalization\")\n   @MethodSource(\"mainnetProcessJusticationAndFinalizationSetup\")\n-  void mainnetProcessJusticationAndFinalization(BeaconState pre, BeaconState post)\n+  void mainnetProcessJusticationAndFinalization(BeaconState pre, BeaconState post, String testName)\n       throws Exception {\n-    EpochProcessorUtil.process_justification_and_finalization(pre);\n-    assertEquals(pre, post);\n+    MutableBeaconState wState = pre.createWritableCopy();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI2ODY0Nw=="}, "originalCommit": {"oid": "85ccb05f20ba7b587c53c4a2d5007b969a49613b"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NjA1MDgwOnYy", "diffSide": "RIGHT", "path": "ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/blocks/Eth1Data.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxNzo0ODoxNlrOFvbC0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQwODoxMDowNlrOFvsiUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI3MDQ4Mw==", "bodyText": "Nitpick: surprised by the mixed casing, although it makes sense in some weird way. Hmm", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r385270483", "createdAt": "2020-02-27T17:48:16Z", "author": {"login": "protolambda"}, "path": "ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/blocks/Eth1Data.java", "diffHunk": "@@ -114,49 +134,33 @@ public boolean equals(Object obj) {\n   }\n \n   /** @return the deposit_root */\n+  @JsonProperty\n   public Bytes32 getDeposit_root() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85ccb05f20ba7b587c53c4a2d5007b969a49613b"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTU1NzA3Mw==", "bodyText": "This is a new java-pyspec casing \ud83d\ude04", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r385557073", "createdAt": "2020-02-28T08:10:06Z", "author": {"login": "Nashatyrev"}, "path": "ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/blocks/Eth1Data.java", "diffHunk": "@@ -114,49 +134,33 @@ public boolean equals(Object obj) {\n   }\n \n   /** @return the deposit_root */\n+  @JsonProperty\n   public Bytes32 getDeposit_root() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI3MDQ4Mw=="}, "originalCommit": {"oid": "85ccb05f20ba7b587c53c4a2d5007b969a49613b"}, "originalPosition": 127}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NjA3MTQwOnYy", "diffSide": "RIGHT", "path": "ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/state/BeaconStateImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxNzo1NDoxN1rOFvbPpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQwODoxNDo0MlrOFvsokw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI3Mzc2NQ==", "bodyText": "I'm sorry it gets so verbose with getters/setters, I had the same problem in Go, but moved half-way to see completion of Python + JS trees first. I'll complete the ZRNT transition to tree structures eventually though.", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r385273765", "createdAt": "2020-02-27T17:54:17Z", "author": {"login": "protolambda"}, "path": "ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/state/BeaconStateImpl.java", "diffHunk": "@@ -0,0 +1,729 @@\n+/*\n+ * Copyright 2019 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.datastructures.state;\n+\n+import com.google.common.base.MoreObjects;\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import jdk.jfr.Label;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.apache.tuweni.ssz.SSZ;\n+import tech.pegasys.artemis.datastructures.blocks.BeaconBlockHeader;\n+import tech.pegasys.artemis.datastructures.blocks.Eth1Data;\n+import tech.pegasys.artemis.datastructures.util.SimpleOffsetSerializer;\n+import tech.pegasys.artemis.util.SSZTypes.Bitvector;\n+import tech.pegasys.artemis.util.SSZTypes.SSZBackingList;\n+import tech.pegasys.artemis.util.SSZTypes.SSZBackingListRef;\n+import tech.pegasys.artemis.util.SSZTypes.SSZBackingVector;\n+import tech.pegasys.artemis.util.SSZTypes.SSZList;\n+import tech.pegasys.artemis.util.SSZTypes.SSZMutableList;\n+import tech.pegasys.artemis.util.SSZTypes.SSZMutableRefList;\n+import tech.pegasys.artemis.util.SSZTypes.SSZMutableVector;\n+import tech.pegasys.artemis.util.SSZTypes.SSZVector;\n+import tech.pegasys.artemis.util.backing.ContainerViewWrite;\n+import tech.pegasys.artemis.util.backing.ListViewWrite;\n+import tech.pegasys.artemis.util.backing.ListViewWriteRef;\n+import tech.pegasys.artemis.util.backing.VectorViewRead;\n+import tech.pegasys.artemis.util.backing.VectorViewWrite;\n+import tech.pegasys.artemis.util.backing.tree.TreeNode;\n+import tech.pegasys.artemis.util.backing.type.BasicViewTypes;\n+import tech.pegasys.artemis.util.backing.type.ContainerViewType;\n+import tech.pegasys.artemis.util.backing.type.ListViewType;\n+import tech.pegasys.artemis.util.backing.type.VectorViewType;\n+import tech.pegasys.artemis.util.backing.view.AbstractBasicView;\n+import tech.pegasys.artemis.util.backing.view.BasicViews.BitView;\n+import tech.pegasys.artemis.util.backing.view.BasicViews.Bytes32View;\n+import tech.pegasys.artemis.util.backing.view.BasicViews.UInt64View;\n+import tech.pegasys.artemis.util.backing.view.ContainerViewImpl;\n+import tech.pegasys.artemis.util.backing.view.ViewUtils;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class BeaconStateImpl extends ContainerViewImpl<BeaconStateImpl>\n+    implements MutableBeaconState, BeaconStateCache {\n+\n+  // The number of SimpleSerialize basic types in this SSZ Container/POJO.\n+  public static final int SSZ_FIELD_COUNT = 14;\n+\n+  private static volatile ContainerViewType<BeaconStateImpl> TYPE = null;\n+\n+  private static ContainerViewType<BeaconStateImpl> createSSZType() {\n+    return new ContainerViewType<>(\n+        List.of(\n+            BasicViewTypes.UINT64_TYPE,\n+            BasicViewTypes.UINT64_TYPE,\n+            Fork.TYPE,\n+            BeaconBlockHeader.TYPE,\n+            new VectorViewType<>(BasicViewTypes.BYTES32_TYPE, Constants.SLOTS_PER_HISTORICAL_ROOT),\n+            new VectorViewType<>(BasicViewTypes.BYTES32_TYPE, Constants.SLOTS_PER_HISTORICAL_ROOT),\n+            new ListViewType<>(BasicViewTypes.BYTES32_TYPE, Constants.HISTORICAL_ROOTS_LIMIT),\n+            Eth1Data.TYPE,\n+            new ListViewType<>(Eth1Data.TYPE, Constants.SLOTS_PER_ETH1_VOTING_PERIOD),\n+            BasicViewTypes.UINT64_TYPE,\n+            new ListViewType<>(ValidatorImpl.TYPE, Constants.VALIDATOR_REGISTRY_LIMIT),\n+            new ListViewType<>(BasicViewTypes.UINT64_TYPE, Constants.VALIDATOR_REGISTRY_LIMIT),\n+            new VectorViewType<>(\n+                BasicViewTypes.BYTES32_TYPE, Constants.EPOCHS_PER_HISTORICAL_VECTOR),\n+            new VectorViewType<>(BasicViewTypes.UINT64_TYPE, Constants.EPOCHS_PER_SLASHINGS_VECTOR),\n+            new ListViewType<>(\n+                PendingAttestation.TYPE, Constants.MAX_ATTESTATIONS * Constants.SLOTS_PER_EPOCH),\n+            new ListViewType<>(\n+                PendingAttestation.TYPE, Constants.MAX_ATTESTATIONS * Constants.SLOTS_PER_EPOCH),\n+            new VectorViewType<>(BasicViewTypes.BIT_TYPE, Constants.JUSTIFICATION_BITS_LENGTH),\n+            Checkpoint.TYPE,\n+            Checkpoint.TYPE,\n+            Checkpoint.TYPE),\n+        BeaconStateImpl::new);\n+  }\n+\n+  public static ContainerViewType<BeaconStateImpl> getSSZType() {\n+    if (TYPE == null) {\n+      TYPE = createSSZType();\n+    }\n+    return TYPE;\n+  }\n+\n+  public static void resetSSZType() {\n+    TYPE = null;\n+  }\n+\n+  @Label(\"sos-ignore\")\n+  private final TransitionCaches transitionCaches;\n+\n+  @Label(\"sos-ignore\")\n+  private final boolean builder;\n+\n+  // Versioning\n+  @SuppressWarnings(\"unused\")\n+  private final UnsignedLong genesis_time = null;\n+\n+  @SuppressWarnings(\"unused\")\n+  private final UnsignedLong slot = null;\n+\n+  @SuppressWarnings(\"unused\")\n+  private final Fork fork = null; // For versioning hard forks\n+\n+  // History\n+  @SuppressWarnings(\"unused\")\n+  private final BeaconBlockHeader latest_block_header = null;\n+\n+  @SuppressWarnings(\"unused\")\n+  private final SSZVector<Bytes32> block_roots =\n+      SSZVector.create(\n+          Bytes32.class,\n+          Constants.SLOTS_PER_HISTORICAL_ROOT); // Vector of length SLOTS_PER_HISTORICAL_ROOT\n+\n+  @SuppressWarnings(\"unused\")\n+  private final SSZVector<Bytes32> state_roots =\n+      SSZVector.create(\n+          Bytes32.class,\n+          Constants.SLOTS_PER_HISTORICAL_ROOT); // Vector of length SLOTS_PER_HISTORICAL_ROOT\n+\n+  @SuppressWarnings(\"unused\")\n+  private final SSZList<Bytes32> historical_roots =\n+      SSZList.create(\n+          Bytes32.class, Constants.HISTORICAL_ROOTS_LIMIT); // Bounded by HISTORICAL_ROOTS_LIMIT\n+\n+  // Ethereum 1.0 chain data\n+  @SuppressWarnings(\"unused\")\n+  private final Eth1Data eth1_data = null;\n+\n+  @SuppressWarnings(\"unused\")\n+  private final SSZList<Eth1Data> eth1_data_votes =\n+      SSZList.create(\n+          Eth1Data.class,\n+          Constants.SLOTS_PER_ETH1_VOTING_PERIOD); // List Bounded by SLOTS_PER_ETH1_VOTING_PERIOD\n+\n+  @SuppressWarnings(\"unused\")\n+  private final UnsignedLong eth1_deposit_index = null;\n+\n+  // Validator registry\n+  @SuppressWarnings(\"unused\")\n+  private final SSZList<ValidatorImpl> validators =\n+      SSZList.create(\n+          ValidatorImpl.class,\n+          Constants.VALIDATOR_REGISTRY_LIMIT); // List Bounded by VALIDATOR_REGISTRY_LIMIT\n+\n+  @SuppressWarnings(\"unused\")\n+  private final SSZList<UnsignedLong> balances =\n+      SSZList.create(\n+          UnsignedLong.class,\n+          Constants.VALIDATOR_REGISTRY_LIMIT); // List Bounded by VALIDATOR_REGISTRY_LIMIT\n+\n+  @SuppressWarnings(\"unused\")\n+  private final SSZVector<Bytes32> randao_mixes =\n+      SSZVector.create(\n+          Bytes32.class,\n+          Constants.EPOCHS_PER_HISTORICAL_VECTOR); // Vector of length EPOCHS_PER_HISTORICAL_VECTOR\n+\n+  // Slashings\n+  @SuppressWarnings(\"unused\")\n+  private final SSZVector<UnsignedLong> slashings =\n+      SSZVector.create(\n+          UnsignedLong.class,\n+          Constants.EPOCHS_PER_SLASHINGS_VECTOR); // Vector of length EPOCHS_PER_SLASHINGS_VECTOR\n+\n+  // Attestations\n+  @SuppressWarnings(\"unused\")\n+  private final SSZList<PendingAttestation> previous_epoch_attestations =\n+      SSZList.create(\n+          PendingAttestation.class,\n+          Constants.MAX_ATTESTATIONS\n+              * Constants.SLOTS_PER_EPOCH); // List bounded by MAX_ATTESTATIONS * SLOTS_PER_EPOCH\n+\n+  @SuppressWarnings(\"unused\")\n+  private final SSZList<PendingAttestation> current_epoch_attestations =\n+      SSZList.create(\n+          PendingAttestation.class,\n+          Constants.MAX_ATTESTATIONS\n+              * Constants.SLOTS_PER_EPOCH); // List bounded by MAX_ATTESTATIONS * SLOTS_PER_EPOCH\n+\n+  // Finality\n+  @SuppressWarnings(\"unused\")\n+  private final Bitvector justification_bits =\n+      new Bitvector(\n+          Constants.JUSTIFICATION_BITS_LENGTH); // Bitvector bounded by JUSTIFICATION_BITS_LENGTH\n+\n+  @SuppressWarnings(\"unused\")\n+  private final Checkpoint previous_justified_checkpoint = null;\n+\n+  @SuppressWarnings(\"unused\")\n+  private final Checkpoint current_justified_checkpoint = null;\n+\n+  @SuppressWarnings(\"unused\")\n+  private final Checkpoint finalized_checkpoint = null;\n+\n+  private BeaconStateImpl(\n+      ContainerViewType<? extends ContainerViewWrite> type, TreeNode backingNode) {\n+    super(type, backingNode);\n+    transitionCaches = TransitionCaches.createNewEmpty();\n+    builder = false;\n+  }\n+\n+  public BeaconStateImpl(\n+      // Versioning\n+      UnsignedLong genesis_time,\n+      UnsignedLong slot,\n+      Fork fork,\n+\n+      // History\n+      BeaconBlockHeader latest_block_header,\n+      SSZVector<Bytes32> block_roots,\n+      SSZVector<Bytes32> state_roots,\n+      SSZList<Bytes32> historical_roots,\n+\n+      // Eth1\n+      Eth1Data eth1_data,\n+      SSZList<Eth1Data> eth1_data_votes,\n+      UnsignedLong eth1_deposit_index,\n+\n+      // Registry\n+      SSZList<? extends Validator> validators,\n+      SSZList<UnsignedLong> balances,\n+\n+      // Randomness\n+      SSZVector<Bytes32> randao_mixes,\n+\n+      // Slashings\n+      SSZVector<UnsignedLong> slashings,\n+\n+      // Attestations\n+      SSZList<PendingAttestation> previous_epoch_attestations,\n+      SSZList<PendingAttestation> current_epoch_attestations,\n+\n+      // Finality\n+      Bitvector justification_bits,\n+      Checkpoint previous_justified_checkpoint,\n+      Checkpoint current_justified_checkpoint,\n+      Checkpoint finalized_checkpoint) {\n+    super(getSSZType());\n+    setGenesis_time(genesis_time);\n+    setSlot(slot);\n+    setFork(fork);\n+    setLatest_block_header(latest_block_header);\n+    getBlock_roots().setAll(block_roots);\n+    getState_roots().setAll(state_roots);\n+    getHistorical_roots().setAll(historical_roots);\n+    setEth1_data(eth1_data);\n+    getEth1_data_votes().setAll(eth1_data_votes);\n+    setEth1_deposit_index(eth1_deposit_index);\n+    getValidators().setAll(validators);\n+    getBalances().setAll(balances);\n+    getRandao_mixes().setAll(randao_mixes);\n+    getSlashings().setAll(slashings);\n+    getPrevious_epoch_attestations().setAll(previous_epoch_attestations);\n+    getCurrent_epoch_attestations().setAll(current_epoch_attestations);\n+    setJustification_bits(justification_bits);\n+    setPrevious_justified_checkpoint(previous_justified_checkpoint);\n+    setCurrent_justified_checkpoint(current_justified_checkpoint);\n+    setFinalized_checkpoint(finalized_checkpoint);\n+    this.transitionCaches = TransitionCaches.createNewEmpty();\n+    this.builder = false;\n+  }\n+\n+  public BeaconStateImpl() {\n+    this(false);\n+  }\n+\n+  public BeaconStateImpl(boolean builder) {\n+    super(getSSZType());\n+    this.builder = builder;\n+    transitionCaches = builder ? TransitionCaches.getNoOp() : TransitionCaches.createNewEmpty();\n+  }\n+\n+  BeaconStateImpl(BeaconState state) {\n+    super(getSSZType(), state.getBackingNode());\n+    this.builder = false;\n+    if (state instanceof BeaconStateImpl && ((BeaconStateImpl) state).builder) {\n+      transitionCaches = TransitionCaches.createNewEmpty();\n+    } else if (state instanceof BeaconStateCache) {\n+      transitionCaches = ((BeaconStateCache) state).getTransitionCaches().copy();\n+    } else {\n+      transitionCaches = TransitionCaches.createNewEmpty();\n+    }\n+  }\n+\n+  @Override\n+  public int getSSZFieldCount() {\n+    return SSZ_FIELD_COUNT\n+        + getFork().getSSZFieldCount()\n+        + getLatest_block_header().getSSZFieldCount()\n+        + getEth1_data().getSSZFieldCount()\n+        + getPrevious_justified_checkpoint().getSSZFieldCount()\n+        + getCurrent_justified_checkpoint().getSSZFieldCount()\n+        + getFinalized_checkpoint().getSSZFieldCount();\n+  }\n+\n+  @Override\n+  public List<Bytes> get_fixed_parts() {\n+    List<Bytes> fixedPartsList = new ArrayList<>();\n+    fixedPartsList.addAll(\n+        List.of(\n+            SSZ.encodeUInt64(getGenesis_time().longValue()),\n+            SSZ.encodeUInt64(getSlot().longValue()),\n+            SimpleOffsetSerializer.serialize(getFork()),\n+            SimpleOffsetSerializer.serialize(getLatest_block_header()),\n+            SSZ.encode(writer -> writer.writeFixedBytesVector(getBlock_roots().asList())),\n+            SSZ.encode(writer -> writer.writeFixedBytesVector(getState_roots().asList())),\n+            Bytes.EMPTY,\n+            SimpleOffsetSerializer.serialize(getEth1_data()),\n+            Bytes.EMPTY,\n+            SSZ.encodeUInt64(getEth1_deposit_index().longValue()),\n+            Bytes.EMPTY,\n+            Bytes.EMPTY,\n+            SSZ.encode(writer -> writer.writeFixedBytesVector(getRandao_mixes().asList())),\n+            SSZ.encode(\n+                writer ->\n+                    writer.writeFixedBytesVector(\n+                        getSlashings().stream()\n+                            .map(slashing -> SSZ.encodeUInt64(slashing.longValue()))\n+                            .collect(Collectors.toList()))),\n+            Bytes.EMPTY,\n+            Bytes.EMPTY,\n+            getJustification_bits().serialize(),\n+            SimpleOffsetSerializer.serialize(getPrevious_justified_checkpoint()),\n+            SimpleOffsetSerializer.serialize(getCurrent_justified_checkpoint()),\n+            SimpleOffsetSerializer.serialize(getFinalized_checkpoint())));\n+    return fixedPartsList;\n+  }\n+\n+  @Override\n+  public List<Bytes> get_variable_parts() {\n+    List<Bytes> variablePartsList = new ArrayList<>();\n+    variablePartsList.addAll(\n+        List.of(Bytes.EMPTY, Bytes.EMPTY, Bytes.EMPTY, Bytes.EMPTY, Bytes.EMPTY, Bytes.EMPTY));\n+    variablePartsList.add(\n+        SSZ.encode(writer -> writer.writeFixedBytesVector(getHistorical_roots().asList())));\n+    variablePartsList.add(Bytes.EMPTY);\n+    variablePartsList.add(SimpleOffsetSerializer.serializeFixedCompositeList(getEth1_data_votes()));\n+    variablePartsList.add(Bytes.EMPTY);\n+    variablePartsList.add(SimpleOffsetSerializer.serializeFixedCompositeList(getValidators()));\n+    // TODO The below lines are a hack while Tuweni SSZ/SOS is being upgraded.\n+    variablePartsList.add(\n+        Bytes.fromHexString(\n+            getBalances().stream()\n+                .map(value -> SSZ.encodeUInt64(value.longValue()).toHexString().substring(2))\n+                .collect(Collectors.joining())));\n+    variablePartsList.addAll(List.of(Bytes.EMPTY, Bytes.EMPTY));\n+    variablePartsList.add(\n+        SimpleOffsetSerializer.serializeVariableCompositeList(getPrevious_epoch_attestations()));\n+    variablePartsList.add(\n+        SimpleOffsetSerializer.serializeVariableCompositeList(getCurrent_epoch_attestations()));\n+    variablePartsList.addAll(List.of(Bytes.EMPTY, Bytes.EMPTY, Bytes.EMPTY));\n+    variablePartsList.addAll(\n+        Collections.nCopies(getPrevious_justified_checkpoint().getSSZFieldCount(), Bytes.EMPTY));\n+    variablePartsList.addAll(\n+        Collections.nCopies(getCurrent_justified_checkpoint().getSSZFieldCount(), Bytes.EMPTY));\n+    variablePartsList.addAll(\n+        Collections.nCopies(getFinalized_checkpoint().getSSZFieldCount(), Bytes.EMPTY));\n+    return variablePartsList;\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return Objects.hash(\n+        // Versioning\n+        getGenesis_time(),\n+        getSlot(),\n+        getFork(),\n+\n+        // History\n+        getLatest_block_header(),\n+        getBlock_roots(),\n+        getState_roots(),\n+        getHistorical_roots(),\n+\n+        // Eth1\n+        getEth1_data(),\n+        getEth1_data_votes(),\n+        getEth1_deposit_index(),\n+\n+        // Registry\n+        getValidators(),\n+        getBalances(),\n+\n+        // Randomness\n+        getRandao_mixes(),\n+\n+        // Slashings\n+        getSlashings(),\n+\n+        // Attestations\n+        getPrevious_epoch_attestations(),\n+        getCurrent_epoch_attestations(),\n+\n+        // Finality\n+        getJustification_bits(),\n+        getPrevious_justified_checkpoint(),\n+        getCurrent_justified_checkpoint(),\n+        getFinalized_checkpoint());\n+  }\n+\n+  @Override\n+  public boolean equals(Object obj) {\n+    if (Objects.isNull(obj)) {\n+      return false;\n+    }\n+\n+    if (this == obj) {\n+      return true;\n+    }\n+\n+    if (!(obj instanceof BeaconStateImpl)) {\n+      return false;\n+    }\n+\n+    BeaconStateImpl other = (BeaconStateImpl) obj;\n+    return Objects.equals(this.getGenesis_time(), other.getGenesis_time())\n+        && Objects.equals(getSlot(), other.getSlot())\n+        && Objects.equals(this.getFork(), other.getFork())\n+        && Objects.equals(this.getLatest_block_header(), other.getLatest_block_header())\n+        && Objects.equals(this.getBlock_roots(), other.getBlock_roots())\n+        && Objects.equals(this.getState_roots(), other.getState_roots())\n+        && Objects.equals(this.getHistorical_roots(), other.getHistorical_roots())\n+        && Objects.equals(this.getEth1_data(), other.getEth1_data())\n+        && Objects.equals(this.getEth1_data_votes(), other.getEth1_data_votes())\n+        && Objects.equals(this.getEth1_deposit_index(), other.getEth1_deposit_index())\n+        && Objects.equals(this.getValidators(), other.getValidators())\n+        && Objects.equals(this.getBalances(), other.getBalances())\n+        && Objects.equals(this.getRandao_mixes(), other.getRandao_mixes())\n+        && Objects.equals(this.getSlashings(), other.getSlashings())\n+        && Objects.equals(\n+            this.getPrevious_epoch_attestations(), other.getPrevious_epoch_attestations())\n+        && Objects.equals(\n+            this.getCurrent_epoch_attestations(), other.getCurrent_epoch_attestations())\n+        && Objects.equals(this.getJustification_bits(), other.getJustification_bits())\n+        && Objects.equals(\n+            this.getPrevious_justified_checkpoint(), other.getPrevious_justified_checkpoint())\n+        && Objects.equals(\n+            this.getCurrent_justified_checkpoint(), other.getCurrent_justified_checkpoint())\n+        && Objects.equals(this.getFinalized_checkpoint(), other.getFinalized_checkpoint());\n+  }\n+\n+  /** ****************** * GETTERS & SETTERS * * ******************* */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85ccb05f20ba7b587c53c4a2d5007b969a49613b"}, "originalPosition": 459}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTU1ODY3NQ==", "bodyText": "I'm planning to refactor hashCode()/equals() for hash_tree_root() usage. Should be short and fast", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r385558675", "createdAt": "2020-02-28T08:14:42Z", "author": {"login": "Nashatyrev"}, "path": "ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/state/BeaconStateImpl.java", "diffHunk": "@@ -0,0 +1,729 @@\n+/*\n+ * Copyright 2019 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.datastructures.state;\n+\n+import com.google.common.base.MoreObjects;\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import jdk.jfr.Label;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.apache.tuweni.ssz.SSZ;\n+import tech.pegasys.artemis.datastructures.blocks.BeaconBlockHeader;\n+import tech.pegasys.artemis.datastructures.blocks.Eth1Data;\n+import tech.pegasys.artemis.datastructures.util.SimpleOffsetSerializer;\n+import tech.pegasys.artemis.util.SSZTypes.Bitvector;\n+import tech.pegasys.artemis.util.SSZTypes.SSZBackingList;\n+import tech.pegasys.artemis.util.SSZTypes.SSZBackingListRef;\n+import tech.pegasys.artemis.util.SSZTypes.SSZBackingVector;\n+import tech.pegasys.artemis.util.SSZTypes.SSZList;\n+import tech.pegasys.artemis.util.SSZTypes.SSZMutableList;\n+import tech.pegasys.artemis.util.SSZTypes.SSZMutableRefList;\n+import tech.pegasys.artemis.util.SSZTypes.SSZMutableVector;\n+import tech.pegasys.artemis.util.SSZTypes.SSZVector;\n+import tech.pegasys.artemis.util.backing.ContainerViewWrite;\n+import tech.pegasys.artemis.util.backing.ListViewWrite;\n+import tech.pegasys.artemis.util.backing.ListViewWriteRef;\n+import tech.pegasys.artemis.util.backing.VectorViewRead;\n+import tech.pegasys.artemis.util.backing.VectorViewWrite;\n+import tech.pegasys.artemis.util.backing.tree.TreeNode;\n+import tech.pegasys.artemis.util.backing.type.BasicViewTypes;\n+import tech.pegasys.artemis.util.backing.type.ContainerViewType;\n+import tech.pegasys.artemis.util.backing.type.ListViewType;\n+import tech.pegasys.artemis.util.backing.type.VectorViewType;\n+import tech.pegasys.artemis.util.backing.view.AbstractBasicView;\n+import tech.pegasys.artemis.util.backing.view.BasicViews.BitView;\n+import tech.pegasys.artemis.util.backing.view.BasicViews.Bytes32View;\n+import tech.pegasys.artemis.util.backing.view.BasicViews.UInt64View;\n+import tech.pegasys.artemis.util.backing.view.ContainerViewImpl;\n+import tech.pegasys.artemis.util.backing.view.ViewUtils;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class BeaconStateImpl extends ContainerViewImpl<BeaconStateImpl>\n+    implements MutableBeaconState, BeaconStateCache {\n+\n+  // The number of SimpleSerialize basic types in this SSZ Container/POJO.\n+  public static final int SSZ_FIELD_COUNT = 14;\n+\n+  private static volatile ContainerViewType<BeaconStateImpl> TYPE = null;\n+\n+  private static ContainerViewType<BeaconStateImpl> createSSZType() {\n+    return new ContainerViewType<>(\n+        List.of(\n+            BasicViewTypes.UINT64_TYPE,\n+            BasicViewTypes.UINT64_TYPE,\n+            Fork.TYPE,\n+            BeaconBlockHeader.TYPE,\n+            new VectorViewType<>(BasicViewTypes.BYTES32_TYPE, Constants.SLOTS_PER_HISTORICAL_ROOT),\n+            new VectorViewType<>(BasicViewTypes.BYTES32_TYPE, Constants.SLOTS_PER_HISTORICAL_ROOT),\n+            new ListViewType<>(BasicViewTypes.BYTES32_TYPE, Constants.HISTORICAL_ROOTS_LIMIT),\n+            Eth1Data.TYPE,\n+            new ListViewType<>(Eth1Data.TYPE, Constants.SLOTS_PER_ETH1_VOTING_PERIOD),\n+            BasicViewTypes.UINT64_TYPE,\n+            new ListViewType<>(ValidatorImpl.TYPE, Constants.VALIDATOR_REGISTRY_LIMIT),\n+            new ListViewType<>(BasicViewTypes.UINT64_TYPE, Constants.VALIDATOR_REGISTRY_LIMIT),\n+            new VectorViewType<>(\n+                BasicViewTypes.BYTES32_TYPE, Constants.EPOCHS_PER_HISTORICAL_VECTOR),\n+            new VectorViewType<>(BasicViewTypes.UINT64_TYPE, Constants.EPOCHS_PER_SLASHINGS_VECTOR),\n+            new ListViewType<>(\n+                PendingAttestation.TYPE, Constants.MAX_ATTESTATIONS * Constants.SLOTS_PER_EPOCH),\n+            new ListViewType<>(\n+                PendingAttestation.TYPE, Constants.MAX_ATTESTATIONS * Constants.SLOTS_PER_EPOCH),\n+            new VectorViewType<>(BasicViewTypes.BIT_TYPE, Constants.JUSTIFICATION_BITS_LENGTH),\n+            Checkpoint.TYPE,\n+            Checkpoint.TYPE,\n+            Checkpoint.TYPE),\n+        BeaconStateImpl::new);\n+  }\n+\n+  public static ContainerViewType<BeaconStateImpl> getSSZType() {\n+    if (TYPE == null) {\n+      TYPE = createSSZType();\n+    }\n+    return TYPE;\n+  }\n+\n+  public static void resetSSZType() {\n+    TYPE = null;\n+  }\n+\n+  @Label(\"sos-ignore\")\n+  private final TransitionCaches transitionCaches;\n+\n+  @Label(\"sos-ignore\")\n+  private final boolean builder;\n+\n+  // Versioning\n+  @SuppressWarnings(\"unused\")\n+  private final UnsignedLong genesis_time = null;\n+\n+  @SuppressWarnings(\"unused\")\n+  private final UnsignedLong slot = null;\n+\n+  @SuppressWarnings(\"unused\")\n+  private final Fork fork = null; // For versioning hard forks\n+\n+  // History\n+  @SuppressWarnings(\"unused\")\n+  private final BeaconBlockHeader latest_block_header = null;\n+\n+  @SuppressWarnings(\"unused\")\n+  private final SSZVector<Bytes32> block_roots =\n+      SSZVector.create(\n+          Bytes32.class,\n+          Constants.SLOTS_PER_HISTORICAL_ROOT); // Vector of length SLOTS_PER_HISTORICAL_ROOT\n+\n+  @SuppressWarnings(\"unused\")\n+  private final SSZVector<Bytes32> state_roots =\n+      SSZVector.create(\n+          Bytes32.class,\n+          Constants.SLOTS_PER_HISTORICAL_ROOT); // Vector of length SLOTS_PER_HISTORICAL_ROOT\n+\n+  @SuppressWarnings(\"unused\")\n+  private final SSZList<Bytes32> historical_roots =\n+      SSZList.create(\n+          Bytes32.class, Constants.HISTORICAL_ROOTS_LIMIT); // Bounded by HISTORICAL_ROOTS_LIMIT\n+\n+  // Ethereum 1.0 chain data\n+  @SuppressWarnings(\"unused\")\n+  private final Eth1Data eth1_data = null;\n+\n+  @SuppressWarnings(\"unused\")\n+  private final SSZList<Eth1Data> eth1_data_votes =\n+      SSZList.create(\n+          Eth1Data.class,\n+          Constants.SLOTS_PER_ETH1_VOTING_PERIOD); // List Bounded by SLOTS_PER_ETH1_VOTING_PERIOD\n+\n+  @SuppressWarnings(\"unused\")\n+  private final UnsignedLong eth1_deposit_index = null;\n+\n+  // Validator registry\n+  @SuppressWarnings(\"unused\")\n+  private final SSZList<ValidatorImpl> validators =\n+      SSZList.create(\n+          ValidatorImpl.class,\n+          Constants.VALIDATOR_REGISTRY_LIMIT); // List Bounded by VALIDATOR_REGISTRY_LIMIT\n+\n+  @SuppressWarnings(\"unused\")\n+  private final SSZList<UnsignedLong> balances =\n+      SSZList.create(\n+          UnsignedLong.class,\n+          Constants.VALIDATOR_REGISTRY_LIMIT); // List Bounded by VALIDATOR_REGISTRY_LIMIT\n+\n+  @SuppressWarnings(\"unused\")\n+  private final SSZVector<Bytes32> randao_mixes =\n+      SSZVector.create(\n+          Bytes32.class,\n+          Constants.EPOCHS_PER_HISTORICAL_VECTOR); // Vector of length EPOCHS_PER_HISTORICAL_VECTOR\n+\n+  // Slashings\n+  @SuppressWarnings(\"unused\")\n+  private final SSZVector<UnsignedLong> slashings =\n+      SSZVector.create(\n+          UnsignedLong.class,\n+          Constants.EPOCHS_PER_SLASHINGS_VECTOR); // Vector of length EPOCHS_PER_SLASHINGS_VECTOR\n+\n+  // Attestations\n+  @SuppressWarnings(\"unused\")\n+  private final SSZList<PendingAttestation> previous_epoch_attestations =\n+      SSZList.create(\n+          PendingAttestation.class,\n+          Constants.MAX_ATTESTATIONS\n+              * Constants.SLOTS_PER_EPOCH); // List bounded by MAX_ATTESTATIONS * SLOTS_PER_EPOCH\n+\n+  @SuppressWarnings(\"unused\")\n+  private final SSZList<PendingAttestation> current_epoch_attestations =\n+      SSZList.create(\n+          PendingAttestation.class,\n+          Constants.MAX_ATTESTATIONS\n+              * Constants.SLOTS_PER_EPOCH); // List bounded by MAX_ATTESTATIONS * SLOTS_PER_EPOCH\n+\n+  // Finality\n+  @SuppressWarnings(\"unused\")\n+  private final Bitvector justification_bits =\n+      new Bitvector(\n+          Constants.JUSTIFICATION_BITS_LENGTH); // Bitvector bounded by JUSTIFICATION_BITS_LENGTH\n+\n+  @SuppressWarnings(\"unused\")\n+  private final Checkpoint previous_justified_checkpoint = null;\n+\n+  @SuppressWarnings(\"unused\")\n+  private final Checkpoint current_justified_checkpoint = null;\n+\n+  @SuppressWarnings(\"unused\")\n+  private final Checkpoint finalized_checkpoint = null;\n+\n+  private BeaconStateImpl(\n+      ContainerViewType<? extends ContainerViewWrite> type, TreeNode backingNode) {\n+    super(type, backingNode);\n+    transitionCaches = TransitionCaches.createNewEmpty();\n+    builder = false;\n+  }\n+\n+  public BeaconStateImpl(\n+      // Versioning\n+      UnsignedLong genesis_time,\n+      UnsignedLong slot,\n+      Fork fork,\n+\n+      // History\n+      BeaconBlockHeader latest_block_header,\n+      SSZVector<Bytes32> block_roots,\n+      SSZVector<Bytes32> state_roots,\n+      SSZList<Bytes32> historical_roots,\n+\n+      // Eth1\n+      Eth1Data eth1_data,\n+      SSZList<Eth1Data> eth1_data_votes,\n+      UnsignedLong eth1_deposit_index,\n+\n+      // Registry\n+      SSZList<? extends Validator> validators,\n+      SSZList<UnsignedLong> balances,\n+\n+      // Randomness\n+      SSZVector<Bytes32> randao_mixes,\n+\n+      // Slashings\n+      SSZVector<UnsignedLong> slashings,\n+\n+      // Attestations\n+      SSZList<PendingAttestation> previous_epoch_attestations,\n+      SSZList<PendingAttestation> current_epoch_attestations,\n+\n+      // Finality\n+      Bitvector justification_bits,\n+      Checkpoint previous_justified_checkpoint,\n+      Checkpoint current_justified_checkpoint,\n+      Checkpoint finalized_checkpoint) {\n+    super(getSSZType());\n+    setGenesis_time(genesis_time);\n+    setSlot(slot);\n+    setFork(fork);\n+    setLatest_block_header(latest_block_header);\n+    getBlock_roots().setAll(block_roots);\n+    getState_roots().setAll(state_roots);\n+    getHistorical_roots().setAll(historical_roots);\n+    setEth1_data(eth1_data);\n+    getEth1_data_votes().setAll(eth1_data_votes);\n+    setEth1_deposit_index(eth1_deposit_index);\n+    getValidators().setAll(validators);\n+    getBalances().setAll(balances);\n+    getRandao_mixes().setAll(randao_mixes);\n+    getSlashings().setAll(slashings);\n+    getPrevious_epoch_attestations().setAll(previous_epoch_attestations);\n+    getCurrent_epoch_attestations().setAll(current_epoch_attestations);\n+    setJustification_bits(justification_bits);\n+    setPrevious_justified_checkpoint(previous_justified_checkpoint);\n+    setCurrent_justified_checkpoint(current_justified_checkpoint);\n+    setFinalized_checkpoint(finalized_checkpoint);\n+    this.transitionCaches = TransitionCaches.createNewEmpty();\n+    this.builder = false;\n+  }\n+\n+  public BeaconStateImpl() {\n+    this(false);\n+  }\n+\n+  public BeaconStateImpl(boolean builder) {\n+    super(getSSZType());\n+    this.builder = builder;\n+    transitionCaches = builder ? TransitionCaches.getNoOp() : TransitionCaches.createNewEmpty();\n+  }\n+\n+  BeaconStateImpl(BeaconState state) {\n+    super(getSSZType(), state.getBackingNode());\n+    this.builder = false;\n+    if (state instanceof BeaconStateImpl && ((BeaconStateImpl) state).builder) {\n+      transitionCaches = TransitionCaches.createNewEmpty();\n+    } else if (state instanceof BeaconStateCache) {\n+      transitionCaches = ((BeaconStateCache) state).getTransitionCaches().copy();\n+    } else {\n+      transitionCaches = TransitionCaches.createNewEmpty();\n+    }\n+  }\n+\n+  @Override\n+  public int getSSZFieldCount() {\n+    return SSZ_FIELD_COUNT\n+        + getFork().getSSZFieldCount()\n+        + getLatest_block_header().getSSZFieldCount()\n+        + getEth1_data().getSSZFieldCount()\n+        + getPrevious_justified_checkpoint().getSSZFieldCount()\n+        + getCurrent_justified_checkpoint().getSSZFieldCount()\n+        + getFinalized_checkpoint().getSSZFieldCount();\n+  }\n+\n+  @Override\n+  public List<Bytes> get_fixed_parts() {\n+    List<Bytes> fixedPartsList = new ArrayList<>();\n+    fixedPartsList.addAll(\n+        List.of(\n+            SSZ.encodeUInt64(getGenesis_time().longValue()),\n+            SSZ.encodeUInt64(getSlot().longValue()),\n+            SimpleOffsetSerializer.serialize(getFork()),\n+            SimpleOffsetSerializer.serialize(getLatest_block_header()),\n+            SSZ.encode(writer -> writer.writeFixedBytesVector(getBlock_roots().asList())),\n+            SSZ.encode(writer -> writer.writeFixedBytesVector(getState_roots().asList())),\n+            Bytes.EMPTY,\n+            SimpleOffsetSerializer.serialize(getEth1_data()),\n+            Bytes.EMPTY,\n+            SSZ.encodeUInt64(getEth1_deposit_index().longValue()),\n+            Bytes.EMPTY,\n+            Bytes.EMPTY,\n+            SSZ.encode(writer -> writer.writeFixedBytesVector(getRandao_mixes().asList())),\n+            SSZ.encode(\n+                writer ->\n+                    writer.writeFixedBytesVector(\n+                        getSlashings().stream()\n+                            .map(slashing -> SSZ.encodeUInt64(slashing.longValue()))\n+                            .collect(Collectors.toList()))),\n+            Bytes.EMPTY,\n+            Bytes.EMPTY,\n+            getJustification_bits().serialize(),\n+            SimpleOffsetSerializer.serialize(getPrevious_justified_checkpoint()),\n+            SimpleOffsetSerializer.serialize(getCurrent_justified_checkpoint()),\n+            SimpleOffsetSerializer.serialize(getFinalized_checkpoint())));\n+    return fixedPartsList;\n+  }\n+\n+  @Override\n+  public List<Bytes> get_variable_parts() {\n+    List<Bytes> variablePartsList = new ArrayList<>();\n+    variablePartsList.addAll(\n+        List.of(Bytes.EMPTY, Bytes.EMPTY, Bytes.EMPTY, Bytes.EMPTY, Bytes.EMPTY, Bytes.EMPTY));\n+    variablePartsList.add(\n+        SSZ.encode(writer -> writer.writeFixedBytesVector(getHistorical_roots().asList())));\n+    variablePartsList.add(Bytes.EMPTY);\n+    variablePartsList.add(SimpleOffsetSerializer.serializeFixedCompositeList(getEth1_data_votes()));\n+    variablePartsList.add(Bytes.EMPTY);\n+    variablePartsList.add(SimpleOffsetSerializer.serializeFixedCompositeList(getValidators()));\n+    // TODO The below lines are a hack while Tuweni SSZ/SOS is being upgraded.\n+    variablePartsList.add(\n+        Bytes.fromHexString(\n+            getBalances().stream()\n+                .map(value -> SSZ.encodeUInt64(value.longValue()).toHexString().substring(2))\n+                .collect(Collectors.joining())));\n+    variablePartsList.addAll(List.of(Bytes.EMPTY, Bytes.EMPTY));\n+    variablePartsList.add(\n+        SimpleOffsetSerializer.serializeVariableCompositeList(getPrevious_epoch_attestations()));\n+    variablePartsList.add(\n+        SimpleOffsetSerializer.serializeVariableCompositeList(getCurrent_epoch_attestations()));\n+    variablePartsList.addAll(List.of(Bytes.EMPTY, Bytes.EMPTY, Bytes.EMPTY));\n+    variablePartsList.addAll(\n+        Collections.nCopies(getPrevious_justified_checkpoint().getSSZFieldCount(), Bytes.EMPTY));\n+    variablePartsList.addAll(\n+        Collections.nCopies(getCurrent_justified_checkpoint().getSSZFieldCount(), Bytes.EMPTY));\n+    variablePartsList.addAll(\n+        Collections.nCopies(getFinalized_checkpoint().getSSZFieldCount(), Bytes.EMPTY));\n+    return variablePartsList;\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return Objects.hash(\n+        // Versioning\n+        getGenesis_time(),\n+        getSlot(),\n+        getFork(),\n+\n+        // History\n+        getLatest_block_header(),\n+        getBlock_roots(),\n+        getState_roots(),\n+        getHistorical_roots(),\n+\n+        // Eth1\n+        getEth1_data(),\n+        getEth1_data_votes(),\n+        getEth1_deposit_index(),\n+\n+        // Registry\n+        getValidators(),\n+        getBalances(),\n+\n+        // Randomness\n+        getRandao_mixes(),\n+\n+        // Slashings\n+        getSlashings(),\n+\n+        // Attestations\n+        getPrevious_epoch_attestations(),\n+        getCurrent_epoch_attestations(),\n+\n+        // Finality\n+        getJustification_bits(),\n+        getPrevious_justified_checkpoint(),\n+        getCurrent_justified_checkpoint(),\n+        getFinalized_checkpoint());\n+  }\n+\n+  @Override\n+  public boolean equals(Object obj) {\n+    if (Objects.isNull(obj)) {\n+      return false;\n+    }\n+\n+    if (this == obj) {\n+      return true;\n+    }\n+\n+    if (!(obj instanceof BeaconStateImpl)) {\n+      return false;\n+    }\n+\n+    BeaconStateImpl other = (BeaconStateImpl) obj;\n+    return Objects.equals(this.getGenesis_time(), other.getGenesis_time())\n+        && Objects.equals(getSlot(), other.getSlot())\n+        && Objects.equals(this.getFork(), other.getFork())\n+        && Objects.equals(this.getLatest_block_header(), other.getLatest_block_header())\n+        && Objects.equals(this.getBlock_roots(), other.getBlock_roots())\n+        && Objects.equals(this.getState_roots(), other.getState_roots())\n+        && Objects.equals(this.getHistorical_roots(), other.getHistorical_roots())\n+        && Objects.equals(this.getEth1_data(), other.getEth1_data())\n+        && Objects.equals(this.getEth1_data_votes(), other.getEth1_data_votes())\n+        && Objects.equals(this.getEth1_deposit_index(), other.getEth1_deposit_index())\n+        && Objects.equals(this.getValidators(), other.getValidators())\n+        && Objects.equals(this.getBalances(), other.getBalances())\n+        && Objects.equals(this.getRandao_mixes(), other.getRandao_mixes())\n+        && Objects.equals(this.getSlashings(), other.getSlashings())\n+        && Objects.equals(\n+            this.getPrevious_epoch_attestations(), other.getPrevious_epoch_attestations())\n+        && Objects.equals(\n+            this.getCurrent_epoch_attestations(), other.getCurrent_epoch_attestations())\n+        && Objects.equals(this.getJustification_bits(), other.getJustification_bits())\n+        && Objects.equals(\n+            this.getPrevious_justified_checkpoint(), other.getPrevious_justified_checkpoint())\n+        && Objects.equals(\n+            this.getCurrent_justified_checkpoint(), other.getCurrent_justified_checkpoint())\n+        && Objects.equals(this.getFinalized_checkpoint(), other.getFinalized_checkpoint());\n+  }\n+\n+  /** ****************** * GETTERS & SETTERS * * ******************* */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI3Mzc2NQ=="}, "originalCommit": {"oid": "85ccb05f20ba7b587c53c4a2d5007b969a49613b"}, "originalPosition": 459}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NjA4MTIyOnYy", "diffSide": "RIGHT", "path": "ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/state/HistoricalBatch.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxNzo1NzoxNVrOFvbV-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQwODoxNzo1MVrOFvstQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI3NTM4Nw==", "bodyText": "Is copy just a new reference to the same backing tree? Can be much faster now this way. Doesn't happen too often though.", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r385275387", "createdAt": "2020-02-27T17:57:15Z", "author": {"login": "protolambda"}, "path": "ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/state/HistoricalBatch.java", "diffHunk": "@@ -43,19 +43,13 @@ public HistoricalBatch(SSZVector<Bytes32> block_roots, SSZVector<Bytes32> state_\n   }\n \n   public HistoricalBatch() {\n-    this.block_roots = new SSZVector<>(Constants.SLOTS_PER_HISTORICAL_ROOT, Bytes32.ZERO);\n-    this.state_roots = new SSZVector<>(Constants.SLOTS_PER_HISTORICAL_ROOT, Bytes32.ZERO);\n+    this.block_roots = SSZVector.create(Constants.SLOTS_PER_HISTORICAL_ROOT, Bytes32.ZERO);\n+    this.state_roots = SSZVector.create(Constants.SLOTS_PER_HISTORICAL_ROOT, Bytes32.ZERO);\n   }\n \n-  public HistoricalBatch(HistoricalBatch historicalBatch) {\n-    this.block_roots =\n-        copyBytesList(\n-            historicalBatch.getBlockRoots(),\n-            new SSZVector<>(Constants.SLOTS_PER_HISTORICAL_ROOT, Bytes32.ZERO));\n-    this.state_roots =\n-        copyBytesList(\n-            historicalBatch.getStateRoots(),\n-            new SSZVector<>(Constants.SLOTS_PER_HISTORICAL_ROOT, Bytes32.ZERO));\n+  private HistoricalBatch(HistoricalBatch historicalBatch) {\n+    this.block_roots = SSZVector.copy(historicalBatch.getBlockRoots());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85ccb05f20ba7b587c53c4a2d5007b969a49613b"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTU1OTg3Mg==", "bodyText": "Keep calm, this is still on TODO list :)", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r385559872", "createdAt": "2020-02-28T08:17:51Z", "author": {"login": "Nashatyrev"}, "path": "ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/state/HistoricalBatch.java", "diffHunk": "@@ -43,19 +43,13 @@ public HistoricalBatch(SSZVector<Bytes32> block_roots, SSZVector<Bytes32> state_\n   }\n \n   public HistoricalBatch() {\n-    this.block_roots = new SSZVector<>(Constants.SLOTS_PER_HISTORICAL_ROOT, Bytes32.ZERO);\n-    this.state_roots = new SSZVector<>(Constants.SLOTS_PER_HISTORICAL_ROOT, Bytes32.ZERO);\n+    this.block_roots = SSZVector.create(Constants.SLOTS_PER_HISTORICAL_ROOT, Bytes32.ZERO);\n+    this.state_roots = SSZVector.create(Constants.SLOTS_PER_HISTORICAL_ROOT, Bytes32.ZERO);\n   }\n \n-  public HistoricalBatch(HistoricalBatch historicalBatch) {\n-    this.block_roots =\n-        copyBytesList(\n-            historicalBatch.getBlockRoots(),\n-            new SSZVector<>(Constants.SLOTS_PER_HISTORICAL_ROOT, Bytes32.ZERO));\n-    this.state_roots =\n-        copyBytesList(\n-            historicalBatch.getStateRoots(),\n-            new SSZVector<>(Constants.SLOTS_PER_HISTORICAL_ROOT, Bytes32.ZERO));\n+  private HistoricalBatch(HistoricalBatch historicalBatch) {\n+    this.block_roots = SSZVector.copy(historicalBatch.getBlockRoots());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI3NTM4Nw=="}, "originalCommit": {"oid": "85ccb05f20ba7b587c53c4a2d5007b969a49613b"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NjEwODI5OnYy", "diffSide": "RIGHT", "path": "ethereum/statetransition/src/main/java/tech/pegasys/artemis/statetransition/util/EpochProcessorUtil.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxODowNTo1MFrOFvbnew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxODowNTo1MFrOFvbnew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI3OTg2Nw==", "bodyText": "Similar to a copy by referencing the same immutable value, setting a field can also just reference the immutable subtree; no need to set all values.", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r385279867", "createdAt": "2020-02-27T18:05:50Z", "author": {"login": "protolambda"}, "path": "ethereum/statetransition/src/main/java/tech/pegasys/artemis/statetransition/util/EpochProcessorUtil.java", "diffHunk": "@@ -620,8 +618,9 @@ public static void process_final_updates(BeaconState state) {\n     }\n \n     // Rotate current/previous epoch attestations\n-    state.setPrevious_epoch_attestations(state.getCurrent_epoch_attestations());\n-    state.setCurrent_epoch_attestations(\n-        new SSZList<>(PendingAttestation.class, MAX_ATTESTATIONS * SLOTS_PER_EPOCH));\n+    state.getPrevious_epoch_attestations().setAll(state.getCurrent_epoch_attestations());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85ccb05f20ba7b587c53c4a2d5007b969a49613b"}, "originalPosition": 237}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NjEyNDE4OnYy", "diffSide": "RIGHT", "path": "util/src/main/java/tech/pegasys/artemis/util/SSZTypes/SSZMutableCollection.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxODoxMDo1OFrOFvbxZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQwODoyMjowNFrOFvszZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI4MjQwNw==", "bodyText": "Nice to have, but check cases where you're overwriting every element, and the collection type is the same. In that case, you can just replace the complete backing, instead of setting every single element.", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r385282407", "createdAt": "2020-02-27T18:10:58Z", "author": {"login": "protolambda"}, "path": "util/src/main/java/tech/pegasys/artemis/util/SSZTypes/SSZMutableCollection.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.util.SSZTypes;\n+\n+public interface SSZMutableCollection<E> extends SSZImmutableCollection<E> {\n+\n+  /**\n+   * Removes all of the elements from this collection (optional operation). The collection will be\n+   * empty after this method returns.\n+   *\n+   * @throws UnsupportedOperationException if the {@code clear} operation is not supported by this\n+   *     collection\n+   */\n+  void clear();\n+\n+  /**\n+   * Replaces the element at the specified position in this list with the specified element\n+   * (optional operation).\n+   *\n+   * @param index index of the element to replace\n+   * @param element element to be stored at the specified position\n+   */\n+  void set(int index, E element);\n+\n+  default void setAll(SSZImmutableCollection<? extends E> other) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85ccb05f20ba7b587c53c4a2d5007b969a49613b"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTU2MTQ0NA==", "bodyText": "Also in my TODO list. Those classes now is a kind of temporary bridge between old and new design. I'm planning to finally get rid of all of them.", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r385561444", "createdAt": "2020-02-28T08:22:04Z", "author": {"login": "Nashatyrev"}, "path": "util/src/main/java/tech/pegasys/artemis/util/SSZTypes/SSZMutableCollection.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.util.SSZTypes;\n+\n+public interface SSZMutableCollection<E> extends SSZImmutableCollection<E> {\n+\n+  /**\n+   * Removes all of the elements from this collection (optional operation). The collection will be\n+   * empty after this method returns.\n+   *\n+   * @throws UnsupportedOperationException if the {@code clear} operation is not supported by this\n+   *     collection\n+   */\n+  void clear();\n+\n+  /**\n+   * Replaces the element at the specified position in this list with the specified element\n+   * (optional operation).\n+   *\n+   * @param index index of the element to replace\n+   * @param element element to be stored at the specified position\n+   */\n+  void set(int index, E element);\n+\n+  default void setAll(SSZImmutableCollection<? extends E> other) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI4MjQwNw=="}, "originalCommit": {"oid": "85ccb05f20ba7b587c53c4a2d5007b969a49613b"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NjEyNzc1OnYy", "diffSide": "RIGHT", "path": "util/src/main/java/tech/pegasys/artemis/util/SSZTypes/SSZVector.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxODoxMjowNlrOFvbzog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQwODoyMjozNVrOFvs0Fw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI4Mjk3OA==", "bodyText": "copy by referencing same backing should be much cheaper", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r385282978", "createdAt": "2020-02-27T18:12:06Z", "author": {"login": "protolambda"}, "path": "util/src/main/java/tech/pegasys/artemis/util/SSZTypes/SSZVector.java", "diffHunk": "@@ -13,63 +13,23 @@\n \n package tech.pegasys.artemis.util.SSZTypes;\n \n-import com.fasterxml.jackson.annotation.JsonCreator;\n-import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n-import java.util.ArrayList;\n-import java.util.Collections;\n import java.util.List;\n \n-@JsonSerialize(as = ArrayList.class)\n-public class SSZVector<T> extends ArrayList<T> {\n+public interface SSZVector<T> extends SSZImmutableCollection<T> {\n \n-  private int maxSize;\n-  private Class<T> classInfo;\n-\n-  public SSZVector() throws UnsupportedOperationException {\n-    throw new UnsupportedOperationException(\"SSZVector must have specified size\");\n-  }\n-\n-  @SuppressWarnings(\"unchecked\")\n-  public SSZVector(int size, T object) {\n-    super(Collections.nCopies(size, object));\n-    this.maxSize = size;\n-    classInfo = (Class<T>) object.getClass();\n-  }\n-\n-  public SSZVector(List<T> list, Class<T> classInfo) {\n-    super(list);\n-    maxSize = list.size();\n-    this.classInfo = classInfo;\n-  }\n-\n-  @JsonCreator\n-  @SuppressWarnings(\"unchecked\")\n-  public SSZVector(List<T> list) {\n-    super(list);\n-    maxSize = list.size();\n-    if (maxSize < 1) {\n-      throw new UnsupportedOperationException(\n-          \"SSZVector must have at least 1 element in the list used to initialize\");\n-    }\n-    this.classInfo = (Class<T>) list.get(0).getClass();\n-  }\n-\n-  public SSZVector(SSZVector<T> list) {\n-    super(list);\n-    maxSize = list.size();\n-    this.classInfo = list.getElementType();\n+  static <T> SSZMutableVector<T> create(int size, T object) {\n+    return new SSZArrayCollection<T>(size, object, true);\n   }\n \n-  public int getSize() {\n-    return maxSize;\n+  static <T> SSZMutableVector<T> create(Class<T> classInfo, int size) {\n+    return new SSZArrayCollection<T>(classInfo, size, true);\n   }\n \n-  @Override\n-  public boolean add(T object) {\n-    throw new UnsupportedOperationException(\"SSZVector does not support add, only set\");\n+  static <T> SSZMutableVector<T> create(List<T> list, Class<T> classInfo) {\n+    return new SSZArrayCollection<>(list, list.size(), classInfo, true);\n   }\n \n-  public Class<T> getElementType() {\n-    return classInfo;\n+  static <T> SSZVector<T> copy(SSZVector<T> vector) {\n+    return new SSZArrayCollection<T>(vector.asList(), vector.size(), vector.getElementType(), true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85ccb05f20ba7b587c53c4a2d5007b969a49613b"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTU2MTYyMw==", "bodyText": "Also in my TODO list", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r385561623", "createdAt": "2020-02-28T08:22:35Z", "author": {"login": "Nashatyrev"}, "path": "util/src/main/java/tech/pegasys/artemis/util/SSZTypes/SSZVector.java", "diffHunk": "@@ -13,63 +13,23 @@\n \n package tech.pegasys.artemis.util.SSZTypes;\n \n-import com.fasterxml.jackson.annotation.JsonCreator;\n-import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n-import java.util.ArrayList;\n-import java.util.Collections;\n import java.util.List;\n \n-@JsonSerialize(as = ArrayList.class)\n-public class SSZVector<T> extends ArrayList<T> {\n+public interface SSZVector<T> extends SSZImmutableCollection<T> {\n \n-  private int maxSize;\n-  private Class<T> classInfo;\n-\n-  public SSZVector() throws UnsupportedOperationException {\n-    throw new UnsupportedOperationException(\"SSZVector must have specified size\");\n-  }\n-\n-  @SuppressWarnings(\"unchecked\")\n-  public SSZVector(int size, T object) {\n-    super(Collections.nCopies(size, object));\n-    this.maxSize = size;\n-    classInfo = (Class<T>) object.getClass();\n-  }\n-\n-  public SSZVector(List<T> list, Class<T> classInfo) {\n-    super(list);\n-    maxSize = list.size();\n-    this.classInfo = classInfo;\n-  }\n-\n-  @JsonCreator\n-  @SuppressWarnings(\"unchecked\")\n-  public SSZVector(List<T> list) {\n-    super(list);\n-    maxSize = list.size();\n-    if (maxSize < 1) {\n-      throw new UnsupportedOperationException(\n-          \"SSZVector must have at least 1 element in the list used to initialize\");\n-    }\n-    this.classInfo = (Class<T>) list.get(0).getClass();\n-  }\n-\n-  public SSZVector(SSZVector<T> list) {\n-    super(list);\n-    maxSize = list.size();\n-    this.classInfo = list.getElementType();\n+  static <T> SSZMutableVector<T> create(int size, T object) {\n+    return new SSZArrayCollection<T>(size, object, true);\n   }\n \n-  public int getSize() {\n-    return maxSize;\n+  static <T> SSZMutableVector<T> create(Class<T> classInfo, int size) {\n+    return new SSZArrayCollection<T>(classInfo, size, true);\n   }\n \n-  @Override\n-  public boolean add(T object) {\n-    throw new UnsupportedOperationException(\"SSZVector does not support add, only set\");\n+  static <T> SSZMutableVector<T> create(List<T> list, Class<T> classInfo) {\n+    return new SSZArrayCollection<>(list, list.size(), classInfo, true);\n   }\n \n-  public Class<T> getElementType() {\n-    return classInfo;\n+  static <T> SSZVector<T> copy(SSZVector<T> vector) {\n+    return new SSZArrayCollection<T>(vector.asList(), vector.size(), vector.getElementType(), true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI4Mjk3OA=="}, "originalCommit": {"oid": "85ccb05f20ba7b587c53c4a2d5007b969a49613b"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NjE0Nzk0OnYy", "diffSide": "RIGHT", "path": "util/src/main/java/tech/pegasys/artemis/util/backing/tree/TreeNodeImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxODoxODozNlrOFvcAsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQwODoyNTo1OFrOFvs40w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI4NjMyMw==", "bodyText": "Why trim leading zeroes at all? Can we not just print the 32 bytes in hex?", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r385286323", "createdAt": "2020-02-27T18:18:36Z", "author": {"login": "protolambda"}, "path": "util/src/main/java/tech/pegasys/artemis/util/backing/tree/TreeNodeImpl.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.util.backing.tree;\n+\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.jetbrains.annotations.NotNull;\n+import tech.pegasys.artemis.util.backing.tree.TreeNode.Commit;\n+import tech.pegasys.artemis.util.backing.tree.TreeNode.Root;\n+\n+class TreeNodeImpl {\n+\n+  static class RootImpl implements Root {\n+    private final Bytes32 root;\n+\n+    public RootImpl(Bytes32 root) {\n+      this.root = root;\n+    }\n+\n+    @Override\n+    public Bytes32 getRoot() {\n+      return root;\n+    }\n+\n+    @Override\n+    public String toString() {\n+      Bytes trimmed = root.trimLeadingZeros();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85ccb05f20ba7b587c53c4a2d5007b969a49613b"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTU2MjgzNQ==", "bodyText": "Yep, this is debugging artifact. Fixed.", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r385562835", "createdAt": "2020-02-28T08:25:58Z", "author": {"login": "Nashatyrev"}, "path": "util/src/main/java/tech/pegasys/artemis/util/backing/tree/TreeNodeImpl.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.util.backing.tree;\n+\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.jetbrains.annotations.NotNull;\n+import tech.pegasys.artemis.util.backing.tree.TreeNode.Commit;\n+import tech.pegasys.artemis.util.backing.tree.TreeNode.Root;\n+\n+class TreeNodeImpl {\n+\n+  static class RootImpl implements Root {\n+    private final Bytes32 root;\n+\n+    public RootImpl(Bytes32 root) {\n+      this.root = root;\n+    }\n+\n+    @Override\n+    public Bytes32 getRoot() {\n+      return root;\n+    }\n+\n+    @Override\n+    public String toString() {\n+      Bytes trimmed = root.trimLeadingZeros();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI4NjMyMw=="}, "originalCommit": {"oid": "85ccb05f20ba7b587c53c4a2d5007b969a49613b"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NjE2Nzg4OnYy", "diffSide": "RIGHT", "path": "util/src/main/java/tech/pegasys/artemis/util/backing/tree/TreeUtil.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxODoyNDoyNFrOFvcM-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxMzoyMjoyMVrOFv0wKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI4OTQ2Nw==", "bodyText": "Is the allocation of a list for each level cheaper than a simple recursive implementation? Recursive implementations can make the padding more elegant, by not allocating unnecessary tree nodes for that (just the nodes that contain a higher order zero hash)", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r385289467", "createdAt": "2020-02-27T18:24:24Z", "author": {"login": "protolambda"}, "path": "util/src/main/java/tech/pegasys/artemis/util/backing/tree/TreeUtil.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.util.backing.tree;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.artemis.util.backing.Utils;\n+import tech.pegasys.artemis.util.backing.tree.TreeNode.Commit;\n+import tech.pegasys.artemis.util.backing.tree.TreeNode.Root;\n+import tech.pegasys.artemis.util.backing.tree.TreeNodeImpl.CommitImpl;\n+import tech.pegasys.artemis.util.backing.tree.TreeNodeImpl.RootImpl;\n+\n+/** Misc Backing binary tree utils */\n+public class TreeUtil {\n+\n+  private static final TreeNode ZERO_LEAF = new RootImpl(Bytes32.ZERO);\n+  private static final TreeNode[] ZERO_TREES;\n+\n+  static {\n+    ZERO_TREES = new TreeNode[64];\n+    ZERO_TREES[0] = ZERO_LEAF;\n+    for (int i = 1; i < ZERO_TREES.length; i++) {\n+      ZERO_TREES[i] = new CommitImpl(ZERO_TREES[i - 1], ZERO_TREES[i - 1]);\n+      ZERO_TREES[i].hashTreeRoot(); // pre-cache\n+    }\n+  }\n+\n+  /**\n+   * Creates a binary tree with `nextPowerOf2(maxLength)` width and following leaf nodes <code>\n+   * [zeroElement] * maxLength + [ZERO_LEAF] * (nextPowerOf2(maxLength) - maxLength)\n+   * </code>\n+   *\n+   * @param maxLength max number of leaf nodes\n+   * @param zeroElement default leaf element. For complex vectors it could be default vector element\n+   *     struct subtree\n+   */\n+  public static TreeNode createDefaultTree(int maxLength, TreeNode zeroElement) {\n+    List<TreeNode> nodes =\n+        Stream.concat(\n+                IntStream.range(0, maxLength).mapToObj(i -> zeroElement),\n+                IntStream.range(maxLength, (int) Utils.nextPowerOf2(maxLength))\n+                    .mapToObj(i -> ZERO_LEAF))\n+            .collect(Collectors.toList());\n+    while (nodes.size() > 1) {\n+      List<TreeNode> parentNodes = new ArrayList<>(nodes.size() / 2);\n+      for (int i = 0; i < nodes.size(); i += 2) {\n+        parentNodes.add(new CommitImpl(nodes.get(i), nodes.get(i + 1)));\n+      }\n+      nodes = parentNodes;\n+    }\n+    return nodes.get(0);\n+  }\n+\n+  /** Creates a binary tree with `nextPowerOf2(maxLength)` width and ZERO leaf nodes. */\n+  public static TreeNode createZeroTree(long maxLength) {\n+    return ZERO_TREES[treeDepth(maxLength)];\n+  }\n+\n+  /** Creates a binary tree of width `nextPowerOf2(leafNodes.size())` with specific leaf nodes */\n+  public static TreeNode createTree(List<TreeNode> leafNodes) {\n+    int treeWidth = (int) Utils.nextPowerOf2(leafNodes.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85ccb05f20ba7b587c53c4a2d5007b969a49613b"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY5MTY5MA==", "bodyText": "Just made this method the first way that came to my mind. Was trying to avoid premature optimization. But you've inspired me to refactor that part :)", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r385691690", "createdAt": "2020-02-28T13:22:21Z", "author": {"login": "Nashatyrev"}, "path": "util/src/main/java/tech/pegasys/artemis/util/backing/tree/TreeUtil.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.util.backing.tree;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.artemis.util.backing.Utils;\n+import tech.pegasys.artemis.util.backing.tree.TreeNode.Commit;\n+import tech.pegasys.artemis.util.backing.tree.TreeNode.Root;\n+import tech.pegasys.artemis.util.backing.tree.TreeNodeImpl.CommitImpl;\n+import tech.pegasys.artemis.util.backing.tree.TreeNodeImpl.RootImpl;\n+\n+/** Misc Backing binary tree utils */\n+public class TreeUtil {\n+\n+  private static final TreeNode ZERO_LEAF = new RootImpl(Bytes32.ZERO);\n+  private static final TreeNode[] ZERO_TREES;\n+\n+  static {\n+    ZERO_TREES = new TreeNode[64];\n+    ZERO_TREES[0] = ZERO_LEAF;\n+    for (int i = 1; i < ZERO_TREES.length; i++) {\n+      ZERO_TREES[i] = new CommitImpl(ZERO_TREES[i - 1], ZERO_TREES[i - 1]);\n+      ZERO_TREES[i].hashTreeRoot(); // pre-cache\n+    }\n+  }\n+\n+  /**\n+   * Creates a binary tree with `nextPowerOf2(maxLength)` width and following leaf nodes <code>\n+   * [zeroElement] * maxLength + [ZERO_LEAF] * (nextPowerOf2(maxLength) - maxLength)\n+   * </code>\n+   *\n+   * @param maxLength max number of leaf nodes\n+   * @param zeroElement default leaf element. For complex vectors it could be default vector element\n+   *     struct subtree\n+   */\n+  public static TreeNode createDefaultTree(int maxLength, TreeNode zeroElement) {\n+    List<TreeNode> nodes =\n+        Stream.concat(\n+                IntStream.range(0, maxLength).mapToObj(i -> zeroElement),\n+                IntStream.range(maxLength, (int) Utils.nextPowerOf2(maxLength))\n+                    .mapToObj(i -> ZERO_LEAF))\n+            .collect(Collectors.toList());\n+    while (nodes.size() > 1) {\n+      List<TreeNode> parentNodes = new ArrayList<>(nodes.size() / 2);\n+      for (int i = 0; i < nodes.size(); i += 2) {\n+        parentNodes.add(new CommitImpl(nodes.get(i), nodes.get(i + 1)));\n+      }\n+      nodes = parentNodes;\n+    }\n+    return nodes.get(0);\n+  }\n+\n+  /** Creates a binary tree with `nextPowerOf2(maxLength)` width and ZERO leaf nodes. */\n+  public static TreeNode createZeroTree(long maxLength) {\n+    return ZERO_TREES[treeDepth(maxLength)];\n+  }\n+\n+  /** Creates a binary tree of width `nextPowerOf2(leafNodes.size())` with specific leaf nodes */\n+  public static TreeNode createTree(List<TreeNode> leafNodes) {\n+    int treeWidth = (int) Utils.nextPowerOf2(leafNodes.size());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI4OTQ2Nw=="}, "originalCommit": {"oid": "85ccb05f20ba7b587c53c4a2d5007b969a49613b"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NjE5ODg1OnYy", "diffSide": "RIGHT", "path": "util/src/main/java/tech/pegasys/artemis/util/backing/type/ListViewType.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxODozMzo1MlrOFvcgzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxMzoyMzo1NlrOFv0zCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI5NDU0Mw==", "bodyText": "If all nodes are the same, and immutable, a recursive implementation can construct a list/vector very elegantly, yet efficiently: v[0] = default node, v[1] = commit(v[0], v[0]), v[2] = commit(v[1], v[1]), v[2] = commit(v[1], v[1]), etc... Same as is done with zero-hashes, except that you only really need the last v as the anchor node of the subtree.", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r385294543", "createdAt": "2020-02-27T18:33:52Z", "author": {"login": "protolambda"}, "path": "util/src/main/java/tech/pegasys/artemis/util/backing/type/ListViewType.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.util.backing.type;\n+\n+import tech.pegasys.artemis.util.backing.ListViewRead;\n+import tech.pegasys.artemis.util.backing.ViewRead;\n+import tech.pegasys.artemis.util.backing.ViewType;\n+import tech.pegasys.artemis.util.backing.tree.TreeNode;\n+import tech.pegasys.artemis.util.backing.view.ListViewImpl;\n+\n+public class ListViewType<C extends ViewRead> extends CollectionViewType {\n+\n+  public ListViewType(VectorViewType<C> vectorType) {\n+    this(vectorType.getElementType(), vectorType.getMaxLength());\n+  }\n+\n+  public ListViewType(ViewType elementType, long maxLength) {\n+    super(maxLength, elementType);\n+  }\n+\n+  @Override\n+  public TreeNode createDefaultTree() {\n+    return createDefault().getBackingNode();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85ccb05f20ba7b587c53c4a2d5007b969a49613b"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY5MjQyNQ==", "bodyText": "Default TreeNode is cached now", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r385692425", "createdAt": "2020-02-28T13:23:56Z", "author": {"login": "Nashatyrev"}, "path": "util/src/main/java/tech/pegasys/artemis/util/backing/type/ListViewType.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.util.backing.type;\n+\n+import tech.pegasys.artemis.util.backing.ListViewRead;\n+import tech.pegasys.artemis.util.backing.ViewRead;\n+import tech.pegasys.artemis.util.backing.ViewType;\n+import tech.pegasys.artemis.util.backing.tree.TreeNode;\n+import tech.pegasys.artemis.util.backing.view.ListViewImpl;\n+\n+public class ListViewType<C extends ViewRead> extends CollectionViewType {\n+\n+  public ListViewType(VectorViewType<C> vectorType) {\n+    this(vectorType.getElementType(), vectorType.getMaxLength());\n+  }\n+\n+  public ListViewType(ViewType elementType, long maxLength) {\n+    super(maxLength, elementType);\n+  }\n+\n+  @Override\n+  public TreeNode createDefaultTree() {\n+    return createDefault().getBackingNode();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTI5NDU0Mw=="}, "originalCommit": {"oid": "85ccb05f20ba7b587c53c4a2d5007b969a49613b"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5MDEzMDUzOnYy", "diffSide": "RIGHT", "path": "util/src/main/java/tech/pegasys/artemis/util/backing/ViewType.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQyMDoxNzo1MlrOFwBqgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxMTozNDoyMFrOFxCQwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkwMzIzNA==", "bodyText": "(nit) Looks like most of the methods elsewhere use \"backing node\" over \"tree node\" nomenclature,  suggest using one naming style consistently:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              default ViewRead createFromTreeNode(TreeNode node, int internalIndex) {\n          \n          \n            \n              default ViewRead createFromBackingNode(TreeNode node, int internalIndex) {", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r385903234", "createdAt": "2020-02-28T20:17:52Z", "author": {"login": "mbaxter"}, "path": "util/src/main/java/tech/pegasys/artemis/util/backing/ViewType.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.util.backing;\n+\n+import tech.pegasys.artemis.util.backing.tree.TreeNode;\n+\n+/**\n+ * Base class for any SSZ type like Vector, List, Container, basic types\n+ * (https://github.com/ethereum/eth2.0-specs/blob/dev/ssz/simple-serialize.md#typing)\n+ */\n+public interface ViewType {\n+\n+  /**\n+   * Creates a default backing binary tree for this type E.g. if the type is basic then normally\n+   * just a single leaf node is created E.g. if the type is a complex structure with multi-level\n+   * nested vectors and containers then the complete tree including all descendant members subtrees\n+   * is created\n+   */\n+  TreeNode getDefaultTree();\n+\n+  /**\n+   * Creates immutable View over the tree which should correspond to this type If the tree structure\n+   * doesn't correspond this type that fact could only be detected later during access to View\n+   * members\n+   */\n+  ViewRead createFromTreeNode(TreeNode node);\n+\n+  /** Creates a default immutable View */\n+  default ViewRead getDefault() {\n+    return createFromTreeNode(getDefaultTree());\n+  }\n+\n+  /**\n+   * Returns the number of bits the element of this type occupies in a tree node More correct\n+   * definition is: how many elements of this type one tree node may contain All complex types\n+   * occupies the whole tree node and their bitsize assumed to be 256 Normally the bitsize < 256 is\n+   * for basic types that can be packed into a single leaf node\n+   */\n+  default int getBitsSize() {\n+    return 256;\n+  }\n+\n+  /**\n+   * For packed basic values. Extracts a packed value from the tree node by its 'internal index'.\n+   * For example in `Bitvector(512)` the bit value at index `300` is stored at the second leaf node\n+   * and it's 'internal index' in this node would be `45`\n+   */\n+  default ViewRead createFromTreeNode(TreeNode node, int internalIndex) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4fc41d2f455ad3019095470229fa3cd5922d9c6"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njk2MTYwMQ==", "bodyText": "Totally makes sense \ud83d\udc4d Thanks\ne7e4d18", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r386961601", "createdAt": "2020-03-03T11:34:20Z", "author": {"login": "Nashatyrev"}, "path": "util/src/main/java/tech/pegasys/artemis/util/backing/ViewType.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.util.backing;\n+\n+import tech.pegasys.artemis.util.backing.tree.TreeNode;\n+\n+/**\n+ * Base class for any SSZ type like Vector, List, Container, basic types\n+ * (https://github.com/ethereum/eth2.0-specs/blob/dev/ssz/simple-serialize.md#typing)\n+ */\n+public interface ViewType {\n+\n+  /**\n+   * Creates a default backing binary tree for this type E.g. if the type is basic then normally\n+   * just a single leaf node is created E.g. if the type is a complex structure with multi-level\n+   * nested vectors and containers then the complete tree including all descendant members subtrees\n+   * is created\n+   */\n+  TreeNode getDefaultTree();\n+\n+  /**\n+   * Creates immutable View over the tree which should correspond to this type If the tree structure\n+   * doesn't correspond this type that fact could only be detected later during access to View\n+   * members\n+   */\n+  ViewRead createFromTreeNode(TreeNode node);\n+\n+  /** Creates a default immutable View */\n+  default ViewRead getDefault() {\n+    return createFromTreeNode(getDefaultTree());\n+  }\n+\n+  /**\n+   * Returns the number of bits the element of this type occupies in a tree node More correct\n+   * definition is: how many elements of this type one tree node may contain All complex types\n+   * occupies the whole tree node and their bitsize assumed to be 256 Normally the bitsize < 256 is\n+   * for basic types that can be packed into a single leaf node\n+   */\n+  default int getBitsSize() {\n+    return 256;\n+  }\n+\n+  /**\n+   * For packed basic values. Extracts a packed value from the tree node by its 'internal index'.\n+   * For example in `Bitvector(512)` the bit value at index `300` is stored at the second leaf node\n+   * and it's 'internal index' in this node would be `45`\n+   */\n+  default ViewRead createFromTreeNode(TreeNode node, int internalIndex) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkwMzIzNA=="}, "originalCommit": {"oid": "d4fc41d2f455ad3019095470229fa3cd5922d9c6"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5MDI3ODQzOnYy", "diffSide": "RIGHT", "path": "util/src/main/java/tech/pegasys/artemis/util/backing/ViewType.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQyMToxODo1MlrOFwDGUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxMTozNjoyMVrOFxCU6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkyNjczNw==", "bodyText": "Should this class be in the tech.pegasys.artemis.util.backing.type package?", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r385926737", "createdAt": "2020-02-28T21:18:52Z", "author": {"login": "mbaxter"}, "path": "util/src/main/java/tech/pegasys/artemis/util/backing/ViewType.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.util.backing;\n+\n+import tech.pegasys.artemis.util.backing.tree.TreeNode;\n+\n+/**\n+ * Base class for any SSZ type like Vector, List, Container, basic types\n+ * (https://github.com/ethereum/eth2.0-specs/blob/dev/ssz/simple-serialize.md#typing)\n+ */\n+public interface ViewType {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4fc41d2f455ad3019095470229fa3cd5922d9c6"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njk2MjY2Nw==", "bodyText": "Moved it a couple of times forth and back :) Let it be in type", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r386962667", "createdAt": "2020-03-03T11:36:21Z", "author": {"login": "Nashatyrev"}, "path": "util/src/main/java/tech/pegasys/artemis/util/backing/ViewType.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.util.backing;\n+\n+import tech.pegasys.artemis.util.backing.tree.TreeNode;\n+\n+/**\n+ * Base class for any SSZ type like Vector, List, Container, basic types\n+ * (https://github.com/ethereum/eth2.0-specs/blob/dev/ssz/simple-serialize.md#typing)\n+ */\n+public interface ViewType {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkyNjczNw=="}, "originalCommit": {"oid": "d4fc41d2f455ad3019095470229fa3cd5922d9c6"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5MDQxNDQwOnYy", "diffSide": "RIGHT", "path": "ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/operations/AttestationData.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQyMjoxNzozMFrOFwEZmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxMTo0NToyM1rOFxCkrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk0ODA1Nw==", "bodyText": "I think rather than adding jackson annotations to these core types, we'd be better off adding custom methods to JsonProvider that know how to serialize these various types.  We can log a follow-up ticket to clean this up though.", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r385948057", "createdAt": "2020-02-28T22:17:30Z", "author": {"login": "mbaxter"}, "path": "ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/operations/AttestationData.java", "diffHunk": "@@ -13,74 +13,103 @@\n \n package tech.pegasys.artemis.datastructures.operations;\n \n+import com.fasterxml.jackson.annotation.JsonAutoDetect;\n+import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;\n import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n import com.google.common.primitives.UnsignedLong;\n import java.util.ArrayList;\n-import java.util.Arrays;\n import java.util.List;\n import java.util.Objects;\n import org.apache.tuweni.bytes.Bytes;\n import org.apache.tuweni.bytes.Bytes32;\n import org.apache.tuweni.ssz.SSZ;\n import tech.pegasys.artemis.datastructures.state.Checkpoint;\n import tech.pegasys.artemis.util.SSZTypes.SSZContainer;\n-import tech.pegasys.artemis.util.hashtree.HashTreeUtil;\n-import tech.pegasys.artemis.util.hashtree.HashTreeUtil.SSZTypes;\n+import tech.pegasys.artemis.util.backing.ContainerViewWrite;\n+import tech.pegasys.artemis.util.backing.tree.TreeNode;\n+import tech.pegasys.artemis.util.backing.type.BasicViewTypes;\n+import tech.pegasys.artemis.util.backing.type.ContainerViewType;\n+import tech.pegasys.artemis.util.backing.view.BasicViews.Bytes32View;\n+import tech.pegasys.artemis.util.backing.view.BasicViews.UInt64View;\n+import tech.pegasys.artemis.util.backing.view.ContainerViewImpl;\n import tech.pegasys.artemis.util.hashtree.Merkleizable;\n import tech.pegasys.artemis.util.sos.SimpleOffsetSerializable;\n \n-public class AttestationData implements SimpleOffsetSerializable, Merkleizable, SSZContainer {\n+@JsonAutoDetect(getterVisibility = Visibility.NONE)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4fc41d2f455ad3019095470229fa3cd5922d9c6"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njk2NjcwMQ==", "bodyText": "Agree, I'm also not a big fan of burdening core classes with serialization details.\nHowever this may make sense when the structure is changing from time to time and you need not forget to update your serializers in different places\nTicket for me: #1267", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r386966701", "createdAt": "2020-03-03T11:45:23Z", "author": {"login": "Nashatyrev"}, "path": "ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/operations/AttestationData.java", "diffHunk": "@@ -13,74 +13,103 @@\n \n package tech.pegasys.artemis.datastructures.operations;\n \n+import com.fasterxml.jackson.annotation.JsonAutoDetect;\n+import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;\n import com.fasterxml.jackson.annotation.JsonIgnore;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n import com.google.common.primitives.UnsignedLong;\n import java.util.ArrayList;\n-import java.util.Arrays;\n import java.util.List;\n import java.util.Objects;\n import org.apache.tuweni.bytes.Bytes;\n import org.apache.tuweni.bytes.Bytes32;\n import org.apache.tuweni.ssz.SSZ;\n import tech.pegasys.artemis.datastructures.state.Checkpoint;\n import tech.pegasys.artemis.util.SSZTypes.SSZContainer;\n-import tech.pegasys.artemis.util.hashtree.HashTreeUtil;\n-import tech.pegasys.artemis.util.hashtree.HashTreeUtil.SSZTypes;\n+import tech.pegasys.artemis.util.backing.ContainerViewWrite;\n+import tech.pegasys.artemis.util.backing.tree.TreeNode;\n+import tech.pegasys.artemis.util.backing.type.BasicViewTypes;\n+import tech.pegasys.artemis.util.backing.type.ContainerViewType;\n+import tech.pegasys.artemis.util.backing.view.BasicViews.Bytes32View;\n+import tech.pegasys.artemis.util.backing.view.BasicViews.UInt64View;\n+import tech.pegasys.artemis.util.backing.view.ContainerViewImpl;\n import tech.pegasys.artemis.util.hashtree.Merkleizable;\n import tech.pegasys.artemis.util.sos.SimpleOffsetSerializable;\n \n-public class AttestationData implements SimpleOffsetSerializable, Merkleizable, SSZContainer {\n+@JsonAutoDetect(getterVisibility = Visibility.NONE)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk0ODA1Nw=="}, "originalCommit": {"oid": "d4fc41d2f455ad3019095470229fa3cd5922d9c6"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5MDQ2MDMxOnYy", "diffSide": "LEFT", "path": "ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/blocks/Eth1Data.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQyMjozOToxMVrOFwE04Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxMzowMzoyOFrOFxE3nA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk1NTA0MQ==", "bodyText": "These classes look immutable, but mutations are still possible via the ancestor view write methods (ViewWrite.clear(), CompositeViewWrite.update(), etc).  Should we do something like have an immutable Eth1Data interface + Eth1DataImpl ?", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r385955041", "createdAt": "2020-02-28T22:39:11Z", "author": {"login": "mbaxter"}, "path": "ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/blocks/Eth1Data.java", "diffHunk": "@@ -114,49 +134,33 @@ public boolean equals(Object obj) {\n   }\n \n   /** @return the deposit_root */\n+  @JsonProperty\n   public Bytes32 getDeposit_root() {\n-    return deposit_root;\n-  }\n-\n-  /** @param deposit_root the deposit_root to set */\n-  public void setDeposit_root(Bytes32 deposit_root) {\n-    this.deposit_root = deposit_root;\n+    return ((Bytes32View) get(0)).get();\n   }\n \n+  @JsonProperty\n   public UnsignedLong getDeposit_count() {\n-    return deposit_count;\n-  }\n-\n-  public void setDeposit_count(UnsignedLong deposit_count) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4fc41d2f455ad3019095470229fa3cd5922d9c6"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzAwNDMxNg==", "bodyText": "Oh yeah, that was lost in my todo list. I'm not sure if it worth spreading interfaces for such small immutable structs.\nI think it is better to create a base container class for those immutable structs: b69db95", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r387004316", "createdAt": "2020-03-03T13:03:28Z", "author": {"login": "Nashatyrev"}, "path": "ethereum/datastructures/src/main/java/tech/pegasys/artemis/datastructures/blocks/Eth1Data.java", "diffHunk": "@@ -114,49 +134,33 @@ public boolean equals(Object obj) {\n   }\n \n   /** @return the deposit_root */\n+  @JsonProperty\n   public Bytes32 getDeposit_root() {\n-    return deposit_root;\n-  }\n-\n-  /** @param deposit_root the deposit_root to set */\n-  public void setDeposit_root(Bytes32 deposit_root) {\n-    this.deposit_root = deposit_root;\n+    return ((Bytes32View) get(0)).get();\n   }\n \n+  @JsonProperty\n   public UnsignedLong getDeposit_count() {\n-    return deposit_count;\n-  }\n-\n-  public void setDeposit_count(UnsignedLong deposit_count) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk1NTA0MQ=="}, "originalCommit": {"oid": "d4fc41d2f455ad3019095470229fa3cd5922d9c6"}, "originalPosition": 142}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5MTgxNzEyOnYy", "diffSide": "RIGHT", "path": "util/src/main/java/tech/pegasys/artemis/util/backing/CompositeViewWriteRef.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMVQxOToxNDo0MFrOFwPq4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxMjoxMTowM1rOFxDSeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjEzMjcwNA==", "bodyText": "Stray comment here:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public interface CompositeViewWriteRef<R extends ViewRead, W extends R /* & ViewWrite */>\n          \n          \n            \n            public interface CompositeViewWriteRef<R extends ViewRead, W extends R>", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r386132704", "createdAt": "2020-03-01T19:14:40Z", "author": {"login": "mbaxter"}, "path": "util/src/main/java/tech/pegasys/artemis/util/backing/CompositeViewWriteRef.java", "diffHunk": "@@ -0,0 +1,30 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.util.backing;\n+\n+/**\n+ * Represents a mutable composite view which is able to return a mutable child 'by reference' Any\n+ * modifications made to such child are reflected in this structure and its backing tree\n+ */\n+public interface CompositeViewWriteRef<R extends ViewRead, W extends R /* & ViewWrite */>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4fc41d2f455ad3019095470229fa3cd5922d9c6"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njk3ODQyNQ==", "bodyText": "Removed", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r386978425", "createdAt": "2020-03-03T12:11:03Z", "author": {"login": "Nashatyrev"}, "path": "util/src/main/java/tech/pegasys/artemis/util/backing/CompositeViewWriteRef.java", "diffHunk": "@@ -0,0 +1,30 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.util.backing;\n+\n+/**\n+ * Represents a mutable composite view which is able to return a mutable child 'by reference' Any\n+ * modifications made to such child are reflected in this structure and its backing tree\n+ */\n+public interface CompositeViewWriteRef<R extends ViewRead, W extends R /* & ViewWrite */>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjEzMjcwNA=="}, "originalCommit": {"oid": "d4fc41d2f455ad3019095470229fa3cd5922d9c6"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5MTgyNzAxOnYy", "diffSide": "RIGHT", "path": "util/src/main/java/tech/pegasys/artemis/util/backing/ViewType.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMVQxOTozMjo1M1rOFwPvyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxMjoxODoyNVrOFxDfXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjEzMzk2MQ==", "bodyText": "In general, I'd avoid setting defaults that only apply to some subtypes.\nSuggest moving this default implementation to CompositeViewType:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              default int getBitsSize() {\n          \n          \n            \n              int getBitsSize();", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r386133961", "createdAt": "2020-03-01T19:32:53Z", "author": {"login": "mbaxter"}, "path": "util/src/main/java/tech/pegasys/artemis/util/backing/ViewType.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.util.backing;\n+\n+import tech.pegasys.artemis.util.backing.tree.TreeNode;\n+\n+/**\n+ * Base class for any SSZ type like Vector, List, Container, basic types\n+ * (https://github.com/ethereum/eth2.0-specs/blob/dev/ssz/simple-serialize.md#typing)\n+ */\n+public interface ViewType {\n+\n+  /**\n+   * Creates a default backing binary tree for this type E.g. if the type is basic then normally\n+   * just a single leaf node is created E.g. if the type is a complex structure with multi-level\n+   * nested vectors and containers then the complete tree including all descendant members subtrees\n+   * is created\n+   */\n+  TreeNode getDefaultTree();\n+\n+  /**\n+   * Creates immutable View over the tree which should correspond to this type If the tree structure\n+   * doesn't correspond this type that fact could only be detected later during access to View\n+   * members\n+   */\n+  ViewRead createFromTreeNode(TreeNode node);\n+\n+  /** Creates a default immutable View */\n+  default ViewRead getDefault() {\n+    return createFromTreeNode(getDefaultTree());\n+  }\n+\n+  /**\n+   * Returns the number of bits the element of this type occupies in a tree node More correct\n+   * definition is: how many elements of this type one tree node may contain All complex types\n+   * occupies the whole tree node and their bitsize assumed to be 256 Normally the bitsize < 256 is\n+   * for basic types that can be packed into a single leaf node\n+   */\n+  default int getBitsSize() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4fc41d2f455ad3019095470229fa3cd5922d9c6"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njk4MTcyNQ==", "bodyText": "Yep, very good general rule \ud83d\udc4d\nChanged.", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r386981725", "createdAt": "2020-03-03T12:18:25Z", "author": {"login": "Nashatyrev"}, "path": "util/src/main/java/tech/pegasys/artemis/util/backing/ViewType.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.util.backing;\n+\n+import tech.pegasys.artemis.util.backing.tree.TreeNode;\n+\n+/**\n+ * Base class for any SSZ type like Vector, List, Container, basic types\n+ * (https://github.com/ethereum/eth2.0-specs/blob/dev/ssz/simple-serialize.md#typing)\n+ */\n+public interface ViewType {\n+\n+  /**\n+   * Creates a default backing binary tree for this type E.g. if the type is basic then normally\n+   * just a single leaf node is created E.g. if the type is a complex structure with multi-level\n+   * nested vectors and containers then the complete tree including all descendant members subtrees\n+   * is created\n+   */\n+  TreeNode getDefaultTree();\n+\n+  /**\n+   * Creates immutable View over the tree which should correspond to this type If the tree structure\n+   * doesn't correspond this type that fact could only be detected later during access to View\n+   * members\n+   */\n+  ViewRead createFromTreeNode(TreeNode node);\n+\n+  /** Creates a default immutable View */\n+  default ViewRead getDefault() {\n+    return createFromTreeNode(getDefaultTree());\n+  }\n+\n+  /**\n+   * Returns the number of bits the element of this type occupies in a tree node More correct\n+   * definition is: how many elements of this type one tree node may contain All complex types\n+   * occupies the whole tree node and their bitsize assumed to be 256 Normally the bitsize < 256 is\n+   * for basic types that can be packed into a single leaf node\n+   */\n+  default int getBitsSize() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjEzMzk2MQ=="}, "originalCommit": {"oid": "d4fc41d2f455ad3019095470229fa3cd5922d9c6"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5MTk2MjAwOnYy", "diffSide": "RIGHT", "path": "util/src/test/java/tech/pegasys/artemis/util/backing/BasicListViewTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMVQyMzoyNjoxM1rOFwQ1PA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxMzoyNTowOFrOFxFkGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE1MTc0MA==", "bodyText": "(nit) If you think its useful to keep these logs, I'd log them via Logger.trace()", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r386151740", "createdAt": "2020-03-01T23:26:13Z", "author": {"login": "mbaxter"}, "path": "util/src/test/java/tech/pegasys/artemis/util/backing/BasicListViewTest.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.util.backing;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import tech.pegasys.artemis.util.backing.tree.TreeNode;\n+import tech.pegasys.artemis.util.backing.type.BasicViewTypes;\n+import tech.pegasys.artemis.util.backing.type.ListViewType;\n+import tech.pegasys.artemis.util.backing.view.BasicViews.UInt64View;\n+\n+public class BasicListViewTest {\n+\n+  @Test\n+  public void simpleUInt64ListTest() {\n+    ListViewType<UInt64View> listType = new ListViewType<>(BasicViewTypes.UINT64_TYPE, 7);\n+    ListViewWrite<UInt64View> listView = listType.getDefault().createWritableCopy();\n+    TreeNode n0 = listView.getBackingNode();\n+    listView.append(new UInt64View(UnsignedLong.valueOf(0x111)));\n+    TreeNode n1 = listView.getBackingNode();\n+    listView.append(new UInt64View(UnsignedLong.valueOf(0x222)));\n+    listView.append(new UInt64View(UnsignedLong.valueOf(0x333)));\n+    listView.append(new UInt64View(UnsignedLong.valueOf(0x444)));\n+    TreeNode n2 = listView.getBackingNode();\n+    listView.append(new UInt64View(UnsignedLong.valueOf(0x555)));\n+    TreeNode n3 = listView.getBackingNode();\n+    listView.append(new UInt64View(UnsignedLong.valueOf(0x666)));\n+    listView.append(new UInt64View(UnsignedLong.valueOf(0x777)));\n+    TreeNode n4 = listView.getBackingNode();\n+    listView.set(0, new UInt64View(UnsignedLong.valueOf(0x800)));\n+    TreeNode n5 = listView.getBackingNode();\n+    listView.set(1, new UInt64View(UnsignedLong.valueOf(0x801)));\n+    listView.set(2, new UInt64View(UnsignedLong.valueOf(0x802)));\n+    listView.set(3, new UInt64View(UnsignedLong.valueOf(0x803)));\n+    listView.set(4, new UInt64View(UnsignedLong.valueOf(0x804)));\n+    TreeNode n6 = listView.getBackingNode();\n+    System.out.println(n0);\n+    System.out.println(n1);\n+    System.out.println(n2);\n+    System.out.println(n3);\n+    System.out.println(n4);\n+    System.out.println(n5);\n+    System.out.println(n6);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4fc41d2f455ad3019095470229fa3cd5922d9c6"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzAxNTcwNg==", "bodyText": "Removed", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r387015706", "createdAt": "2020-03-03T13:25:08Z", "author": {"login": "Nashatyrev"}, "path": "util/src/test/java/tech/pegasys/artemis/util/backing/BasicListViewTest.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.util.backing;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import tech.pegasys.artemis.util.backing.tree.TreeNode;\n+import tech.pegasys.artemis.util.backing.type.BasicViewTypes;\n+import tech.pegasys.artemis.util.backing.type.ListViewType;\n+import tech.pegasys.artemis.util.backing.view.BasicViews.UInt64View;\n+\n+public class BasicListViewTest {\n+\n+  @Test\n+  public void simpleUInt64ListTest() {\n+    ListViewType<UInt64View> listType = new ListViewType<>(BasicViewTypes.UINT64_TYPE, 7);\n+    ListViewWrite<UInt64View> listView = listType.getDefault().createWritableCopy();\n+    TreeNode n0 = listView.getBackingNode();\n+    listView.append(new UInt64View(UnsignedLong.valueOf(0x111)));\n+    TreeNode n1 = listView.getBackingNode();\n+    listView.append(new UInt64View(UnsignedLong.valueOf(0x222)));\n+    listView.append(new UInt64View(UnsignedLong.valueOf(0x333)));\n+    listView.append(new UInt64View(UnsignedLong.valueOf(0x444)));\n+    TreeNode n2 = listView.getBackingNode();\n+    listView.append(new UInt64View(UnsignedLong.valueOf(0x555)));\n+    TreeNode n3 = listView.getBackingNode();\n+    listView.append(new UInt64View(UnsignedLong.valueOf(0x666)));\n+    listView.append(new UInt64View(UnsignedLong.valueOf(0x777)));\n+    TreeNode n4 = listView.getBackingNode();\n+    listView.set(0, new UInt64View(UnsignedLong.valueOf(0x800)));\n+    TreeNode n5 = listView.getBackingNode();\n+    listView.set(1, new UInt64View(UnsignedLong.valueOf(0x801)));\n+    listView.set(2, new UInt64View(UnsignedLong.valueOf(0x802)));\n+    listView.set(3, new UInt64View(UnsignedLong.valueOf(0x803)));\n+    listView.set(4, new UInt64View(UnsignedLong.valueOf(0x804)));\n+    TreeNode n6 = listView.getBackingNode();\n+    System.out.println(n0);\n+    System.out.println(n1);\n+    System.out.println(n2);\n+    System.out.println(n3);\n+    System.out.println(n4);\n+    System.out.println(n5);\n+    System.out.println(n6);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE1MTc0MA=="}, "originalCommit": {"oid": "d4fc41d2f455ad3019095470229fa3cd5922d9c6"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5MTk4NTE1OnYy", "diffSide": "RIGHT", "path": "util/src/main/java/tech/pegasys/artemis/util/SSZTypes/SSZList.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQwMDowMzoyMFrOFwRBzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxNzoxMDoyOFrOFxO2EQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE1NDk1Nw==", "bodyText": "(optional) I've seen naming conventions where this would be modified() because it returns a new object that is modified, vs a method modify() that would mutate the current instance.", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r386154957", "createdAt": "2020-03-02T00:03:20Z", "author": {"login": "mbaxter"}, "path": "util/src/main/java/tech/pegasys/artemis/util/SSZTypes/SSZList.java", "diffHunk": "@@ -13,48 +13,77 @@\n \n package tech.pegasys.artemis.util.SSZTypes;\n \n-import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n-import java.util.ArrayList;\n-import java.util.List;\n+import com.google.common.base.Preconditions;\n+import java.lang.reflect.Array;\n+import java.util.Collection;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n-@JsonSerialize(as = ArrayList.class)\n-public class SSZList<T> extends ArrayList<T> {\n+public interface SSZList<T> extends SSZImmutableCollection<T> {\n \n-  private long maxSize;\n-  private Class<T> classInfo;\n+  static <T> SSZMutableList<T> create(Class<? extends T> classInfo, long maxSize) {\n+    return new SSZArrayCollection<>(classInfo, maxSize, false);\n+  }\n+\n+  static <T> SSZMutableList<T> create(Stream<T> list, long maxSize, Class<? extends T> classInfo) {\n+    return new SSZArrayCollection<>(list.collect(Collectors.toList()), maxSize, classInfo, false);\n+  }\n \n-  public SSZList(Class<T> classInfo, long maxSize) {\n-    super();\n-    this.classInfo = classInfo;\n-    this.maxSize = maxSize;\n+  static <T> SSZMutableList<T> create(\n+      Collection<T> list, long maxSize, Class<? extends T> classInfo) {\n+    return create(list.stream(), maxSize, classInfo);\n   }\n \n-  public SSZList(SSZList<T> list) {\n-    super(list);\n-    maxSize = list.getMaxSize();\n-    this.classInfo = list.getElementType();\n+  static <T> SSZMutableList<T> create(SSZImmutableCollection<? extends T> list) {\n+    return new SSZArrayCollection<>(list.asList(), list.getMaxSize(), list.getElementType(), false);\n   }\n \n-  public SSZList(List<T> list, long maxSize, Class<T> classInfo) {\n-    super(list);\n-    this.maxSize = maxSize;\n-    this.classInfo = classInfo;\n+  static <T> SSZMutableList<T> concat(\n+      SSZImmutableCollection<? extends T> left, SSZImmutableCollection<? extends T> right) {\n+    Preconditions.checkArgument(\n+        left.getElementType().equals(right.getElementType()),\n+        \"Incompatible list types: %s != %s\",\n+        left.getElementType(),\n+        right.getElementType());\n+    SSZMutableList<T> ret = create(left.getElementType(), left.getMaxSize() + right.getMaxSize());\n+    ret.addAll(left);\n+    ret.addAll(right);\n+    return ret;\n   }\n \n-  @Override\n-  public boolean add(T object) {\n-    if (super.size() < maxSize) {\n-      return super.add(object);\n-    } else {\n-      return false;\n+  static <T> SSZList<T> singleton(T obj) {\n+    return new SSZArrayCollection<>(1, obj, false);\n+  }\n+\n+  default SSZList<T> reverse() {\n+    SSZMutableList<T> ret = create(getElementType(), getMaxSize());\n+    for (int i = size() - 1; i >= 0; i--) {\n+      ret.add(get(i));\n     }\n+    return ret;\n+  }\n+\n+  default SSZList<T> modify(Function<Stream<T>, Stream<T>> streamer) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4fc41d2f455ad3019095470229fa3cd5922d9c6"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzAzNjA1Ng==", "bodyText": "Yes, exactly! I was also feeling some discomfort with modify name for immutable class. Renamed reverse -> reversed as well: 5a08d51\nAlso there is a couple of methods with the same semantics TreeNode.update() and TreeNode.set():\nhttps://github.com/PegaSysEng/teku/blob/546616c5e906bf249707cc7c3ec83a5a40026fbc/util/src/main/java/tech/pegasys/artemis/util/backing/tree/TreeNode.java#L143-L157\nMay be you have ideas on how to name them? Especially set sounds confusing for me", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r387036056", "createdAt": "2020-03-03T13:59:21Z", "author": {"login": "Nashatyrev"}, "path": "util/src/main/java/tech/pegasys/artemis/util/SSZTypes/SSZList.java", "diffHunk": "@@ -13,48 +13,77 @@\n \n package tech.pegasys.artemis.util.SSZTypes;\n \n-import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n-import java.util.ArrayList;\n-import java.util.List;\n+import com.google.common.base.Preconditions;\n+import java.lang.reflect.Array;\n+import java.util.Collection;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n-@JsonSerialize(as = ArrayList.class)\n-public class SSZList<T> extends ArrayList<T> {\n+public interface SSZList<T> extends SSZImmutableCollection<T> {\n \n-  private long maxSize;\n-  private Class<T> classInfo;\n+  static <T> SSZMutableList<T> create(Class<? extends T> classInfo, long maxSize) {\n+    return new SSZArrayCollection<>(classInfo, maxSize, false);\n+  }\n+\n+  static <T> SSZMutableList<T> create(Stream<T> list, long maxSize, Class<? extends T> classInfo) {\n+    return new SSZArrayCollection<>(list.collect(Collectors.toList()), maxSize, classInfo, false);\n+  }\n \n-  public SSZList(Class<T> classInfo, long maxSize) {\n-    super();\n-    this.classInfo = classInfo;\n-    this.maxSize = maxSize;\n+  static <T> SSZMutableList<T> create(\n+      Collection<T> list, long maxSize, Class<? extends T> classInfo) {\n+    return create(list.stream(), maxSize, classInfo);\n   }\n \n-  public SSZList(SSZList<T> list) {\n-    super(list);\n-    maxSize = list.getMaxSize();\n-    this.classInfo = list.getElementType();\n+  static <T> SSZMutableList<T> create(SSZImmutableCollection<? extends T> list) {\n+    return new SSZArrayCollection<>(list.asList(), list.getMaxSize(), list.getElementType(), false);\n   }\n \n-  public SSZList(List<T> list, long maxSize, Class<T> classInfo) {\n-    super(list);\n-    this.maxSize = maxSize;\n-    this.classInfo = classInfo;\n+  static <T> SSZMutableList<T> concat(\n+      SSZImmutableCollection<? extends T> left, SSZImmutableCollection<? extends T> right) {\n+    Preconditions.checkArgument(\n+        left.getElementType().equals(right.getElementType()),\n+        \"Incompatible list types: %s != %s\",\n+        left.getElementType(),\n+        right.getElementType());\n+    SSZMutableList<T> ret = create(left.getElementType(), left.getMaxSize() + right.getMaxSize());\n+    ret.addAll(left);\n+    ret.addAll(right);\n+    return ret;\n   }\n \n-  @Override\n-  public boolean add(T object) {\n-    if (super.size() < maxSize) {\n-      return super.add(object);\n-    } else {\n-      return false;\n+  static <T> SSZList<T> singleton(T obj) {\n+    return new SSZArrayCollection<>(1, obj, false);\n+  }\n+\n+  default SSZList<T> reverse() {\n+    SSZMutableList<T> ret = create(getElementType(), getMaxSize());\n+    for (int i = size() - 1; i >= 0; i--) {\n+      ret.add(get(i));\n     }\n+    return ret;\n+  }\n+\n+  default SSZList<T> modify(Function<Stream<T>, Stream<T>> streamer) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE1NDk1Nw=="}, "originalCommit": {"oid": "d4fc41d2f455ad3019095470229fa3cd5922d9c6"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzA0MjU1NA==", "bodyText": "Maybe change both set and update to updated()?", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r387042554", "createdAt": "2020-03-03T14:09:56Z", "author": {"login": "mbaxter"}, "path": "util/src/main/java/tech/pegasys/artemis/util/SSZTypes/SSZList.java", "diffHunk": "@@ -13,48 +13,77 @@\n \n package tech.pegasys.artemis.util.SSZTypes;\n \n-import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n-import java.util.ArrayList;\n-import java.util.List;\n+import com.google.common.base.Preconditions;\n+import java.lang.reflect.Array;\n+import java.util.Collection;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n-@JsonSerialize(as = ArrayList.class)\n-public class SSZList<T> extends ArrayList<T> {\n+public interface SSZList<T> extends SSZImmutableCollection<T> {\n \n-  private long maxSize;\n-  private Class<T> classInfo;\n+  static <T> SSZMutableList<T> create(Class<? extends T> classInfo, long maxSize) {\n+    return new SSZArrayCollection<>(classInfo, maxSize, false);\n+  }\n+\n+  static <T> SSZMutableList<T> create(Stream<T> list, long maxSize, Class<? extends T> classInfo) {\n+    return new SSZArrayCollection<>(list.collect(Collectors.toList()), maxSize, classInfo, false);\n+  }\n \n-  public SSZList(Class<T> classInfo, long maxSize) {\n-    super();\n-    this.classInfo = classInfo;\n-    this.maxSize = maxSize;\n+  static <T> SSZMutableList<T> create(\n+      Collection<T> list, long maxSize, Class<? extends T> classInfo) {\n+    return create(list.stream(), maxSize, classInfo);\n   }\n \n-  public SSZList(SSZList<T> list) {\n-    super(list);\n-    maxSize = list.getMaxSize();\n-    this.classInfo = list.getElementType();\n+  static <T> SSZMutableList<T> create(SSZImmutableCollection<? extends T> list) {\n+    return new SSZArrayCollection<>(list.asList(), list.getMaxSize(), list.getElementType(), false);\n   }\n \n-  public SSZList(List<T> list, long maxSize, Class<T> classInfo) {\n-    super(list);\n-    this.maxSize = maxSize;\n-    this.classInfo = classInfo;\n+  static <T> SSZMutableList<T> concat(\n+      SSZImmutableCollection<? extends T> left, SSZImmutableCollection<? extends T> right) {\n+    Preconditions.checkArgument(\n+        left.getElementType().equals(right.getElementType()),\n+        \"Incompatible list types: %s != %s\",\n+        left.getElementType(),\n+        right.getElementType());\n+    SSZMutableList<T> ret = create(left.getElementType(), left.getMaxSize() + right.getMaxSize());\n+    ret.addAll(left);\n+    ret.addAll(right);\n+    return ret;\n   }\n \n-  @Override\n-  public boolean add(T object) {\n-    if (super.size() < maxSize) {\n-      return super.add(object);\n-    } else {\n-      return false;\n+  static <T> SSZList<T> singleton(T obj) {\n+    return new SSZArrayCollection<>(1, obj, false);\n+  }\n+\n+  default SSZList<T> reverse() {\n+    SSZMutableList<T> ret = create(getElementType(), getMaxSize());\n+    for (int i = size() - 1; i >= 0; i--) {\n+      ret.add(get(i));\n     }\n+    return ret;\n+  }\n+\n+  default SSZList<T> modify(Function<Stream<T>, Stream<T>> streamer) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE1NDk1Nw=="}, "originalCommit": {"oid": "d4fc41d2f455ad3019095470229fa3cd5922d9c6"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE2Nzc2MQ==", "bodyText": "Sounds good \ud83d\udc4d", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r387167761", "createdAt": "2020-03-03T17:10:28Z", "author": {"login": "Nashatyrev"}, "path": "util/src/main/java/tech/pegasys/artemis/util/SSZTypes/SSZList.java", "diffHunk": "@@ -13,48 +13,77 @@\n \n package tech.pegasys.artemis.util.SSZTypes;\n \n-import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n-import java.util.ArrayList;\n-import java.util.List;\n+import com.google.common.base.Preconditions;\n+import java.lang.reflect.Array;\n+import java.util.Collection;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n-@JsonSerialize(as = ArrayList.class)\n-public class SSZList<T> extends ArrayList<T> {\n+public interface SSZList<T> extends SSZImmutableCollection<T> {\n \n-  private long maxSize;\n-  private Class<T> classInfo;\n+  static <T> SSZMutableList<T> create(Class<? extends T> classInfo, long maxSize) {\n+    return new SSZArrayCollection<>(classInfo, maxSize, false);\n+  }\n+\n+  static <T> SSZMutableList<T> create(Stream<T> list, long maxSize, Class<? extends T> classInfo) {\n+    return new SSZArrayCollection<>(list.collect(Collectors.toList()), maxSize, classInfo, false);\n+  }\n \n-  public SSZList(Class<T> classInfo, long maxSize) {\n-    super();\n-    this.classInfo = classInfo;\n-    this.maxSize = maxSize;\n+  static <T> SSZMutableList<T> create(\n+      Collection<T> list, long maxSize, Class<? extends T> classInfo) {\n+    return create(list.stream(), maxSize, classInfo);\n   }\n \n-  public SSZList(SSZList<T> list) {\n-    super(list);\n-    maxSize = list.getMaxSize();\n-    this.classInfo = list.getElementType();\n+  static <T> SSZMutableList<T> create(SSZImmutableCollection<? extends T> list) {\n+    return new SSZArrayCollection<>(list.asList(), list.getMaxSize(), list.getElementType(), false);\n   }\n \n-  public SSZList(List<T> list, long maxSize, Class<T> classInfo) {\n-    super(list);\n-    this.maxSize = maxSize;\n-    this.classInfo = classInfo;\n+  static <T> SSZMutableList<T> concat(\n+      SSZImmutableCollection<? extends T> left, SSZImmutableCollection<? extends T> right) {\n+    Preconditions.checkArgument(\n+        left.getElementType().equals(right.getElementType()),\n+        \"Incompatible list types: %s != %s\",\n+        left.getElementType(),\n+        right.getElementType());\n+    SSZMutableList<T> ret = create(left.getElementType(), left.getMaxSize() + right.getMaxSize());\n+    ret.addAll(left);\n+    ret.addAll(right);\n+    return ret;\n   }\n \n-  @Override\n-  public boolean add(T object) {\n-    if (super.size() < maxSize) {\n-      return super.add(object);\n-    } else {\n-      return false;\n+  static <T> SSZList<T> singleton(T obj) {\n+    return new SSZArrayCollection<>(1, obj, false);\n+  }\n+\n+  default SSZList<T> reverse() {\n+    SSZMutableList<T> ret = create(getElementType(), getMaxSize());\n+    for (int i = size() - 1; i >= 0; i--) {\n+      ret.add(get(i));\n     }\n+    return ret;\n+  }\n+\n+  default SSZList<T> modify(Function<Stream<T>, Stream<T>> streamer) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE1NDk1Nw=="}, "originalCommit": {"oid": "d4fc41d2f455ad3019095470229fa3cd5922d9c6"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5MTk5NDg2OnYy", "diffSide": "RIGHT", "path": "util/src/main/java/tech/pegasys/artemis/util/backing/view/ContainerViewImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQwMDoyMDoyMFrOFwRHVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxNDoxMjowM1rOFxHSfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE1NjM3NQ==", "bodyText": "Might be clearer if we add a utility for calculating the generalized index:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                backingNode = backingNode.set(type.treeWidth() + index, child.getBackingNode());\n          \n          \n            \n                backingNode = backingNode.set(type.getGeneralizedIndex(index), child.getBackingNode());", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r386156375", "createdAt": "2020-03-02T00:20:20Z", "author": {"login": "mbaxter"}, "path": "util/src/main/java/tech/pegasys/artemis/util/backing/view/ContainerViewImpl.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.util.backing.view;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+\n+import tech.pegasys.artemis.util.backing.CompositeViewWrite;\n+import tech.pegasys.artemis.util.backing.ContainerViewWrite;\n+import tech.pegasys.artemis.util.backing.ContainerViewWriteRef;\n+import tech.pegasys.artemis.util.backing.ViewRead;\n+import tech.pegasys.artemis.util.backing.ViewWrite;\n+import tech.pegasys.artemis.util.backing.tree.TreeNode;\n+import tech.pegasys.artemis.util.backing.type.ContainerViewType;\n+\n+public class ContainerViewImpl<C extends ContainerViewImpl<C>>\n+    extends AbstractCompositeViewWrite<C, ViewRead> implements ContainerViewWriteRef {\n+\n+  private final ContainerViewType<? extends ContainerViewWrite> type;\n+  private TreeNode backingNode;\n+\n+  public ContainerViewImpl(ContainerViewType<? extends ContainerViewWrite> type) {\n+    this(type, type.getDefaultTree());\n+  }\n+\n+  public ContainerViewImpl(\n+      ContainerViewType<? extends ContainerViewWrite> type, TreeNode backingNode) {\n+    this.type = type;\n+    this.backingNode = backingNode;\n+  }\n+\n+  public ContainerViewImpl(\n+      ContainerViewType<? extends ContainerViewWrite> type, ViewRead... memberValues) {\n+    this(type, type.getDefaultTree());\n+    checkArgument(\n+        memberValues.length == getType().getMaxLength(),\n+        \"Wrong number of member values: %s\",\n+        memberValues.length);\n+    for (int i = 0; i < memberValues.length; i++) {\n+      set(i, memberValues[i]);\n+    }\n+  }\n+\n+  @Override\n+  public ContainerViewType<? extends ContainerViewWrite> getType() {\n+    return type;\n+  }\n+\n+  @Override\n+  public TreeNode getBackingNode() {\n+    return backingNode;\n+  }\n+\n+  @Override\n+  public ViewRead get(int index) {\n+    checkIndex(index);\n+    TreeNode node = backingNode.get(type.treeWidth() + index);\n+    return type.getChildType(index).createFromTreeNode(node);\n+  }\n+\n+  @Override\n+  public ViewWrite getByRef(int index) {\n+    ViewWrite writableCopy = get(index).createWritableCopy();\n+    if (writableCopy instanceof CompositeViewWrite) {\n+      ((CompositeViewWrite<?>) writableCopy).setInvalidator(viewWrite -> set(index, viewWrite));\n+    }\n+    return writableCopy;\n+  }\n+\n+  @Override\n+  public void set(int index, ViewRead child) {\n+    checkIndex(index);\n+    checkArgument(\n+        child.getType().equals(type.getChildType(index)),\n+        \"Wrong child type at index %s. Expected: %s, was %s\",\n+        index,\n+        type.getChildType(index),\n+        child.getType());\n+    backingNode = backingNode.set(type.treeWidth() + index, child.getBackingNode());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4fc41d2f455ad3019095470229fa3cd5922d9c6"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzA0Mzk2Ng==", "bodyText": "Your way is much cleaner \ud83d\udc4d\na3a5138", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r387043966", "createdAt": "2020-03-03T14:12:03Z", "author": {"login": "Nashatyrev"}, "path": "util/src/main/java/tech/pegasys/artemis/util/backing/view/ContainerViewImpl.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.util.backing.view;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+\n+import tech.pegasys.artemis.util.backing.CompositeViewWrite;\n+import tech.pegasys.artemis.util.backing.ContainerViewWrite;\n+import tech.pegasys.artemis.util.backing.ContainerViewWriteRef;\n+import tech.pegasys.artemis.util.backing.ViewRead;\n+import tech.pegasys.artemis.util.backing.ViewWrite;\n+import tech.pegasys.artemis.util.backing.tree.TreeNode;\n+import tech.pegasys.artemis.util.backing.type.ContainerViewType;\n+\n+public class ContainerViewImpl<C extends ContainerViewImpl<C>>\n+    extends AbstractCompositeViewWrite<C, ViewRead> implements ContainerViewWriteRef {\n+\n+  private final ContainerViewType<? extends ContainerViewWrite> type;\n+  private TreeNode backingNode;\n+\n+  public ContainerViewImpl(ContainerViewType<? extends ContainerViewWrite> type) {\n+    this(type, type.getDefaultTree());\n+  }\n+\n+  public ContainerViewImpl(\n+      ContainerViewType<? extends ContainerViewWrite> type, TreeNode backingNode) {\n+    this.type = type;\n+    this.backingNode = backingNode;\n+  }\n+\n+  public ContainerViewImpl(\n+      ContainerViewType<? extends ContainerViewWrite> type, ViewRead... memberValues) {\n+    this(type, type.getDefaultTree());\n+    checkArgument(\n+        memberValues.length == getType().getMaxLength(),\n+        \"Wrong number of member values: %s\",\n+        memberValues.length);\n+    for (int i = 0; i < memberValues.length; i++) {\n+      set(i, memberValues[i]);\n+    }\n+  }\n+\n+  @Override\n+  public ContainerViewType<? extends ContainerViewWrite> getType() {\n+    return type;\n+  }\n+\n+  @Override\n+  public TreeNode getBackingNode() {\n+    return backingNode;\n+  }\n+\n+  @Override\n+  public ViewRead get(int index) {\n+    checkIndex(index);\n+    TreeNode node = backingNode.get(type.treeWidth() + index);\n+    return type.getChildType(index).createFromTreeNode(node);\n+  }\n+\n+  @Override\n+  public ViewWrite getByRef(int index) {\n+    ViewWrite writableCopy = get(index).createWritableCopy();\n+    if (writableCopy instanceof CompositeViewWrite) {\n+      ((CompositeViewWrite<?>) writableCopy).setInvalidator(viewWrite -> set(index, viewWrite));\n+    }\n+    return writableCopy;\n+  }\n+\n+  @Override\n+  public void set(int index, ViewRead child) {\n+    checkIndex(index);\n+    checkArgument(\n+        child.getType().equals(type.getChildType(index)),\n+        \"Wrong child type at index %s. Expected: %s, was %s\",\n+        index,\n+        type.getChildType(index),\n+        child.getType());\n+    backingNode = backingNode.set(type.treeWidth() + index, child.getBackingNode());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE1NjM3NQ=="}, "originalCommit": {"oid": "d4fc41d2f455ad3019095470229fa3cd5922d9c6"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5MjAwNTc3OnYy", "diffSide": "RIGHT", "path": "util/src/main/java/tech/pegasys/artemis/util/SSZTypes/SSZBackingVector.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQwMDozNTowNVrOFwRNSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxNDozNjo0MlrOFxIThg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE1Nzg5Ng==", "bodyText": "Would be nice to try to add more descriptive type parameters.  For example:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public class SSZBackingVector<C, R extends ViewRead> extends SSZAbstractCollection<C>\n          \n          \n            \n            public class SSZBackingVector<TValue, TView extends ViewRead> extends SSZAbstractCollection<TValue>", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r386157896", "createdAt": "2020-03-02T00:35:05Z", "author": {"login": "mbaxter"}, "path": "util/src/main/java/tech/pegasys/artemis/util/SSZTypes/SSZBackingVector.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.util.SSZTypes;\n+\n+import java.util.function.Function;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.artemis.util.backing.VectorViewWrite;\n+import tech.pegasys.artemis.util.backing.ViewRead;\n+\n+public class SSZBackingVector<C, R extends ViewRead> extends SSZAbstractCollection<C>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4fc41d2f455ad3019095470229fa3cd5922d9c6"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzA2MDYxNA==", "bodyText": "Agree. But let me consider this for subsequent refactor since these classes are most likely to be removed ?", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r387060614", "createdAt": "2020-03-03T14:36:42Z", "author": {"login": "Nashatyrev"}, "path": "util/src/main/java/tech/pegasys/artemis/util/SSZTypes/SSZBackingVector.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.util.SSZTypes;\n+\n+import java.util.function.Function;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.artemis.util.backing.VectorViewWrite;\n+import tech.pegasys.artemis.util.backing.ViewRead;\n+\n+public class SSZBackingVector<C, R extends ViewRead> extends SSZAbstractCollection<C>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE1Nzg5Ng=="}, "originalCommit": {"oid": "d4fc41d2f455ad3019095470229fa3cd5922d9c6"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5NDA4Nzg2OnYy", "diffSide": "RIGHT", "path": "util/src/main/java/tech/pegasys/artemis/util/backing/type/BasicViewType.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxNTo0OToyM1rOFwkl1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxNDo0MjowMFrOFxIhxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ3NTQ3Ng==", "bodyText": "Should we enforce the constraint that bitSize should evenly divide 256?", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r386475476", "createdAt": "2020-03-02T15:49:23Z", "author": {"login": "mbaxter"}, "path": "util/src/main/java/tech/pegasys/artemis/util/backing/type/BasicViewType.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.util.backing.type;\n+\n+import tech.pegasys.artemis.util.backing.ViewRead;\n+import tech.pegasys.artemis.util.backing.ViewType;\n+import tech.pegasys.artemis.util.backing.tree.TreeNode;\n+import tech.pegasys.artemis.util.backing.tree.TreeUtil;\n+\n+/**\n+ * Represents primitive view type\n+ *\n+ * @param <C> Class of the basic view of this type\n+ */\n+public abstract class BasicViewType<C extends ViewRead> implements ViewType {\n+\n+  private final int bitsSize;\n+\n+  BasicViewType(int bitsSize) {\n+    this.bitsSize = bitsSize;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4fc41d2f455ad3019095470229fa3cd5922d9c6"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzA2NDI2MQ==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r387064261", "createdAt": "2020-03-03T14:42:00Z", "author": {"login": "Nashatyrev"}, "path": "util/src/main/java/tech/pegasys/artemis/util/backing/type/BasicViewType.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.util.backing.type;\n+\n+import tech.pegasys.artemis.util.backing.ViewRead;\n+import tech.pegasys.artemis.util.backing.ViewType;\n+import tech.pegasys.artemis.util.backing.tree.TreeNode;\n+import tech.pegasys.artemis.util.backing.tree.TreeUtil;\n+\n+/**\n+ * Represents primitive view type\n+ *\n+ * @param <C> Class of the basic view of this type\n+ */\n+public abstract class BasicViewType<C extends ViewRead> implements ViewType {\n+\n+  private final int bitsSize;\n+\n+  BasicViewType(int bitsSize) {\n+    this.bitsSize = bitsSize;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ3NTQ3Ng=="}, "originalCommit": {"oid": "d4fc41d2f455ad3019095470229fa3cd5922d9c6"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5NDIzNDQyOnYy", "diffSide": "RIGHT", "path": "util/src/main/java/tech/pegasys/artemis/util/backing/tree/TreeUtil.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxNjoyMzo0NFrOFwmAbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxMzoyNjoyNlrOFxFnAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ5ODY2OQ==", "bodyText": "(nit) Would be nice if this returned a String instead of printing directly", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r386498669", "createdAt": "2020-03-02T16:23:44Z", "author": {"login": "mbaxter"}, "path": "util/src/main/java/tech/pegasys/artemis/util/backing/tree/TreeUtil.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.util.backing.tree;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+\n+import java.util.List;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.artemis.util.backing.Utils;\n+import tech.pegasys.artemis.util.backing.tree.TreeNode.Commit;\n+import tech.pegasys.artemis.util.backing.tree.TreeNode.Root;\n+import tech.pegasys.artemis.util.backing.tree.TreeNodeImpl.CommitImpl;\n+import tech.pegasys.artemis.util.backing.tree.TreeNodeImpl.RootImpl;\n+\n+/** Misc Backing binary tree utils */\n+public class TreeUtil {\n+\n+  public static final TreeNode ZERO_LEAF = new RootImpl(Bytes32.ZERO);\n+  private static final TreeNode[] ZERO_TREES;\n+\n+  static {\n+    ZERO_TREES = new TreeNode[64];\n+    ZERO_TREES[0] = ZERO_LEAF;\n+    for (int i = 1; i < ZERO_TREES.length; i++) {\n+      ZERO_TREES[i] = new CommitImpl(ZERO_TREES[i - 1], ZERO_TREES[i - 1]);\n+      ZERO_TREES[i].hashTreeRoot(); // pre-cache\n+    }\n+  }\n+\n+  /**\n+   * Creates a binary tree with `nextPowerOf2(maxLength)` width and following leaf nodes <code>\n+   * [zeroElement] * maxLength + [ZERO_LEAF] * (nextPowerOf2(maxLength) - maxLength)\n+   * </code>\n+   *\n+   * @param maxLength max number of leaf nodes\n+   * @param defaultNode default leaf element. For complex vectors it could be default vector element\n+   *     struct subtree\n+   */\n+  public static TreeNode createDefaultTree(long maxLength, TreeNode defaultNode) {\n+    return createTree(\n+        defaultNode, ZERO_LEAF.equals(defaultNode) ? 0 : maxLength, treeDepth(maxLength));\n+  }\n+\n+  /** Creates a binary tree of width `nextPowerOf2(leafNodes.size())` with specific leaf nodes */\n+  public static TreeNode createTree(List<TreeNode> leafNodes) {\n+    return createTree(leafNodes, treeDepth(leafNodes.size()));\n+  }\n+\n+  private static TreeNode createTree(TreeNode defaultNode, long defaultNodesCount, int depth) {\n+    if (defaultNodesCount == 0) {\n+      return ZERO_TREES[depth];\n+    } else if (depth == 0) {\n+      checkArgument(defaultNodesCount == 1);\n+      return defaultNode;\n+    } else {\n+      long leftNodesCount = Math.min(defaultNodesCount, 1 << (depth - 1));\n+      long rightNodesCount = defaultNodesCount - leftNodesCount;\n+      TreeNode lTree = createTree(defaultNode, leftNodesCount, depth - 1);\n+      TreeNode rTree =\n+          leftNodesCount == rightNodesCount\n+              ? lTree\n+              : createTree(defaultNode, rightNodesCount, depth - 1);\n+      return new CommitImpl(lTree, rTree);\n+    }\n+  }\n+\n+  private static TreeNode createTree(List<TreeNode> leafNodes, int depth) {\n+    if (leafNodes.isEmpty()) {\n+      return ZERO_TREES[depth];\n+    } else if (depth == 0) {\n+      checkArgument(leafNodes.size() == 1);\n+      return leafNodes.get(0);\n+    } else {\n+      long index = 1L << (depth - 1);\n+      int iIndex = index > leafNodes.size() ? leafNodes.size() : (int) index;\n+\n+      List<TreeNode> leftSublist = leafNodes.subList(0, iIndex);\n+      List<TreeNode> rightSublist = leafNodes.subList(iIndex, leafNodes.size());\n+      return new CommitImpl(\n+          createTree(leftSublist, depth - 1), createTree(rightSublist, depth - 1));\n+    }\n+  }\n+\n+  public static int treeDepth(long maxChunks) {\n+    return Long.bitCount(Utils.nextPowerOf2(maxChunks) - 1);\n+  }\n+\n+  /** Estimates the number of 'non-default' tree nodes */\n+  public static int estimateNonDefaultNodes(TreeNode node) {\n+    if (node instanceof Root) {\n+      return 1;\n+    } else {\n+      Commit commitNode = (Commit) node;\n+      if (commitNode.left() == commitNode.right()) {\n+        return 0;\n+      } else {\n+        return estimateNonDefaultNodes(commitNode.left())\n+            + estimateNonDefaultNodes(commitNode.right())\n+            + 1;\n+      }\n+    }\n+  }\n+\n+  /** Dumps the tree to stdout */\n+  public static void dumpBinaryTree(TreeNode node) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4fc41d2f455ad3019095470229fa3cd5922d9c6"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzAxNjQ0OA==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r387016448", "createdAt": "2020-03-03T13:26:26Z", "author": {"login": "Nashatyrev"}, "path": "util/src/main/java/tech/pegasys/artemis/util/backing/tree/TreeUtil.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.util.backing.tree;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+\n+import java.util.List;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.artemis.util.backing.Utils;\n+import tech.pegasys.artemis.util.backing.tree.TreeNode.Commit;\n+import tech.pegasys.artemis.util.backing.tree.TreeNode.Root;\n+import tech.pegasys.artemis.util.backing.tree.TreeNodeImpl.CommitImpl;\n+import tech.pegasys.artemis.util.backing.tree.TreeNodeImpl.RootImpl;\n+\n+/** Misc Backing binary tree utils */\n+public class TreeUtil {\n+\n+  public static final TreeNode ZERO_LEAF = new RootImpl(Bytes32.ZERO);\n+  private static final TreeNode[] ZERO_TREES;\n+\n+  static {\n+    ZERO_TREES = new TreeNode[64];\n+    ZERO_TREES[0] = ZERO_LEAF;\n+    for (int i = 1; i < ZERO_TREES.length; i++) {\n+      ZERO_TREES[i] = new CommitImpl(ZERO_TREES[i - 1], ZERO_TREES[i - 1]);\n+      ZERO_TREES[i].hashTreeRoot(); // pre-cache\n+    }\n+  }\n+\n+  /**\n+   * Creates a binary tree with `nextPowerOf2(maxLength)` width and following leaf nodes <code>\n+   * [zeroElement] * maxLength + [ZERO_LEAF] * (nextPowerOf2(maxLength) - maxLength)\n+   * </code>\n+   *\n+   * @param maxLength max number of leaf nodes\n+   * @param defaultNode default leaf element. For complex vectors it could be default vector element\n+   *     struct subtree\n+   */\n+  public static TreeNode createDefaultTree(long maxLength, TreeNode defaultNode) {\n+    return createTree(\n+        defaultNode, ZERO_LEAF.equals(defaultNode) ? 0 : maxLength, treeDepth(maxLength));\n+  }\n+\n+  /** Creates a binary tree of width `nextPowerOf2(leafNodes.size())` with specific leaf nodes */\n+  public static TreeNode createTree(List<TreeNode> leafNodes) {\n+    return createTree(leafNodes, treeDepth(leafNodes.size()));\n+  }\n+\n+  private static TreeNode createTree(TreeNode defaultNode, long defaultNodesCount, int depth) {\n+    if (defaultNodesCount == 0) {\n+      return ZERO_TREES[depth];\n+    } else if (depth == 0) {\n+      checkArgument(defaultNodesCount == 1);\n+      return defaultNode;\n+    } else {\n+      long leftNodesCount = Math.min(defaultNodesCount, 1 << (depth - 1));\n+      long rightNodesCount = defaultNodesCount - leftNodesCount;\n+      TreeNode lTree = createTree(defaultNode, leftNodesCount, depth - 1);\n+      TreeNode rTree =\n+          leftNodesCount == rightNodesCount\n+              ? lTree\n+              : createTree(defaultNode, rightNodesCount, depth - 1);\n+      return new CommitImpl(lTree, rTree);\n+    }\n+  }\n+\n+  private static TreeNode createTree(List<TreeNode> leafNodes, int depth) {\n+    if (leafNodes.isEmpty()) {\n+      return ZERO_TREES[depth];\n+    } else if (depth == 0) {\n+      checkArgument(leafNodes.size() == 1);\n+      return leafNodes.get(0);\n+    } else {\n+      long index = 1L << (depth - 1);\n+      int iIndex = index > leafNodes.size() ? leafNodes.size() : (int) index;\n+\n+      List<TreeNode> leftSublist = leafNodes.subList(0, iIndex);\n+      List<TreeNode> rightSublist = leafNodes.subList(iIndex, leafNodes.size());\n+      return new CommitImpl(\n+          createTree(leftSublist, depth - 1), createTree(rightSublist, depth - 1));\n+    }\n+  }\n+\n+  public static int treeDepth(long maxChunks) {\n+    return Long.bitCount(Utils.nextPowerOf2(maxChunks) - 1);\n+  }\n+\n+  /** Estimates the number of 'non-default' tree nodes */\n+  public static int estimateNonDefaultNodes(TreeNode node) {\n+    if (node instanceof Root) {\n+      return 1;\n+    } else {\n+      Commit commitNode = (Commit) node;\n+      if (commitNode.left() == commitNode.right()) {\n+        return 0;\n+      } else {\n+        return estimateNonDefaultNodes(commitNode.left())\n+            + estimateNonDefaultNodes(commitNode.right())\n+            + 1;\n+      }\n+    }\n+  }\n+\n+  /** Dumps the tree to stdout */\n+  public static void dumpBinaryTree(TreeNode node) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQ5ODY2OQ=="}, "originalCommit": {"oid": "d4fc41d2f455ad3019095470229fa3cd5922d9c6"}, "originalPosition": 116}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5NDI1OTE4OnYy", "diffSide": "RIGHT", "path": "util/src/test/java/tech/pegasys/artemis/util/backing/ContainerViewTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxNjoyOTo0NVrOFwmPzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxNDoxNjozNlrOFxHeOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjUwMjYwNg==", "bodyText": "These tests don't have any assertions - should we either add some assertions or cut these tests?", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r386502606", "createdAt": "2020-03-02T16:29:45Z", "author": {"login": "mbaxter"}, "path": "util/src/test/java/tech/pegasys/artemis/util/backing/ContainerViewTest.java", "diffHunk": "@@ -0,0 +1,365 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.util.backing;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.List;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import tech.pegasys.artemis.util.backing.tree.TreeNode;\n+import tech.pegasys.artemis.util.backing.tree.TreeUtil;\n+import tech.pegasys.artemis.util.backing.type.BasicViewTypes;\n+import tech.pegasys.artemis.util.backing.type.ContainerViewType;\n+import tech.pegasys.artemis.util.backing.type.ListViewType;\n+import tech.pegasys.artemis.util.backing.type.VectorViewType;\n+import tech.pegasys.artemis.util.backing.view.BasicViews.Bytes32View;\n+import tech.pegasys.artemis.util.backing.view.BasicViews.UInt64View;\n+import tech.pegasys.artemis.util.backing.view.ContainerViewImpl;\n+\n+public class ContainerViewTest {\n+\n+  public interface ImmutableSubContainer extends ContainerViewRead {\n+\n+    UnsignedLong getLong1();\n+\n+    Bytes32 getBytes1();\n+  }\n+\n+  public interface SubContainerRead extends ContainerViewRead {\n+\n+    UnsignedLong getLong1();\n+\n+    UnsignedLong getLong2();\n+  }\n+\n+  public interface SubContainerWrite extends SubContainerRead, ContainerViewWrite {\n+\n+    void setLong1(UnsignedLong val);\n+\n+    void setLong2(UnsignedLong val);\n+  }\n+\n+  public interface ContainerRead extends ContainerViewRead {\n+\n+    UnsignedLong getLong1();\n+\n+    UnsignedLong getLong2();\n+\n+    SubContainerRead getSub1();\n+\n+    ListViewRead<UInt64View> getList1();\n+\n+    ListViewRead<SubContainerRead> getList2();\n+\n+    VectorViewRead<ImmutableSubContainer> getList3();\n+\n+    @Override\n+    ContainerWrite createWritableCopy();\n+  }\n+\n+  public interface ContainerWrite extends ContainerRead, ContainerViewWriteRef {\n+\n+    void setLong1(UnsignedLong val);\n+\n+    void setLong2(UnsignedLong val);\n+\n+    @Override\n+    SubContainerWrite getSub1();\n+\n+    @Override\n+    ListViewWrite<UInt64View> getList1();\n+\n+    @Override\n+    ListViewWriteRef<SubContainerRead, SubContainerWrite> getList2();\n+\n+    @Override\n+    VectorViewWrite<ImmutableSubContainer> getList3();\n+\n+    @Override\n+    ContainerRead commitChanges();\n+  }\n+\n+  public static class ImmutableSubContainerImpl extends ContainerViewImpl<ImmutableSubContainerImpl>\n+      implements ImmutableSubContainer {\n+\n+    public static final ContainerViewType<ImmutableSubContainerImpl> TYPE =\n+        new ContainerViewType<>(\n+            List.of(BasicViewTypes.UINT64_TYPE, BasicViewTypes.BYTES32_TYPE),\n+            ImmutableSubContainerImpl::new);\n+\n+    private ImmutableSubContainerImpl(\n+        ContainerViewType<ImmutableSubContainerImpl> type, TreeNode backingNode) {\n+      super(type, backingNode);\n+    }\n+\n+    public ImmutableSubContainerImpl(UnsignedLong long1, Bytes32 bytes1) {\n+      super(TYPE, new UInt64View(long1), new Bytes32View(bytes1));\n+    }\n+\n+    @Override\n+    public UnsignedLong getLong1() {\n+      return ((UInt64View) get(0)).get();\n+    }\n+\n+    @Override\n+    public Bytes32 getBytes1() {\n+      return ((Bytes32View) get(1)).get();\n+    }\n+  }\n+\n+  public static class SubContainerImpl extends ContainerViewImpl<SubContainerImpl>\n+      implements SubContainerWrite {\n+\n+    public static final ContainerViewType<SubContainerImpl> TYPE =\n+        new ContainerViewType<>(\n+            List.of(BasicViewTypes.UINT64_TYPE, BasicViewTypes.UINT64_TYPE), SubContainerImpl::new);\n+\n+    private SubContainerImpl(ContainerViewType<SubContainerImpl> type, TreeNode backingNode) {\n+      super(type, backingNode);\n+    }\n+\n+    @Override\n+    public UnsignedLong getLong1() {\n+      return ((UInt64View) get(0)).get();\n+    }\n+\n+    @Override\n+    public UnsignedLong getLong2() {\n+      return ((UInt64View) get(1)).get();\n+    }\n+\n+    @Override\n+    public void setLong1(UnsignedLong val) {\n+      set(0, new UInt64View(val));\n+    }\n+\n+    @Override\n+    public void setLong2(UnsignedLong val) {\n+      set(1, new UInt64View(val));\n+    }\n+  }\n+\n+  public static class ContainerImpl extends ContainerViewImpl<ContainerImpl>\n+      implements ContainerWrite {\n+\n+    public static final ContainerViewType<ContainerImpl> TYPE =\n+        new ContainerViewType<>(\n+            List.of(\n+                BasicViewTypes.UINT64_TYPE,\n+                BasicViewTypes.UINT64_TYPE,\n+                SubContainerImpl.TYPE,\n+                new ListViewType<>(BasicViewTypes.UINT64_TYPE, 10),\n+                new ListViewType<>(SubContainerImpl.TYPE, 2),\n+                new VectorViewType<>(ImmutableSubContainerImpl.TYPE, 2)),\n+            ContainerImpl::new);\n+\n+    public ContainerImpl(ContainerViewType<ContainerImpl> type, TreeNode backingNode) {\n+      super(type, backingNode);\n+    }\n+\n+    public static ContainerRead createDefault() {\n+      return TYPE.getDefault();\n+    }\n+\n+    @Override\n+    public UnsignedLong getLong1() {\n+      return ((UInt64View) get(0)).get();\n+    }\n+\n+    @Override\n+    public UnsignedLong getLong2() {\n+      return ((UInt64View) get(1)).get();\n+    }\n+\n+    @Override\n+    public SubContainerImpl getSub1() {\n+      return (SubContainerImpl) getByRef(2);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public ListViewWrite<UInt64View> getList1() {\n+      return (ListViewWrite<UInt64View>) getByRef(3);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public ListViewWriteRef<SubContainerRead, SubContainerWrite> getList2() {\n+      return (ListViewWriteRef<SubContainerRead, SubContainerWrite>) getByRef(4);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public VectorViewWrite<ImmutableSubContainer> getList3() {\n+      return (VectorViewWrite<ImmutableSubContainer>) getByRef(5);\n+    }\n+\n+    @Override\n+    public void setLong1(UnsignedLong val) {\n+      set(0, new UInt64View(val));\n+    }\n+\n+    @Override\n+    public void setLong2(UnsignedLong val) {\n+      set(1, new UInt64View(val));\n+    }\n+  }\n+\n+  @Test\n+  public void readWriteContainerTest1() {\n+    ContainerRead c1 = ContainerImpl.createDefault();\n+\n+    {\n+      Assertions.assertEquals(UnsignedLong.ZERO, c1.getSub1().getLong1());\n+      Assertions.assertTrue(c1.getList1().isEmpty());\n+      Assertions.assertTrue(c1.getList2().isEmpty());\n+      Assertions.assertEquals(UnsignedLong.ZERO, c1.getList3().get(0).getLong1());\n+      Assertions.assertEquals(Bytes32.ZERO, c1.getList3().get(0).getBytes1());\n+      Assertions.assertEquals(UnsignedLong.ZERO, c1.getList3().get(1).getLong1());\n+      Assertions.assertEquals(Bytes32.ZERO, c1.getList3().get(1).getBytes1());\n+      Assertions.assertThrows(\n+          IndexOutOfBoundsException.class,\n+          () -> {\n+            c1.getList3().get(2);\n+          });\n+    }\n+\n+    ContainerWrite c1w = c1.createWritableCopy();\n+    c1w.setLong1(UnsignedLong.valueOf(0x1));\n+    c1w.setLong2(UnsignedLong.valueOf(0x2));\n+\n+    c1w.getSub1().setLong1(UnsignedLong.valueOf(0x111));\n+    c1w.getSub1().setLong2(UnsignedLong.valueOf(0x222));\n+\n+    c1w.getList1().append(UInt64View.fromLong(0x333));\n+    c1w.getList1().append(UInt64View.fromLong(0x444));\n+\n+    c1w.getList2()\n+        .append(\n+            sc -> {\n+              sc.setLong1(UnsignedLong.valueOf(0x555));\n+              sc.setLong2(UnsignedLong.valueOf(0x666));\n+            });\n+    SubContainerWrite sc1w = c1w.getList2().append();\n+    sc1w.setLong1(UnsignedLong.valueOf(0x777));\n+    sc1w.setLong2(UnsignedLong.valueOf(0x888));\n+\n+    c1w.getList3()\n+        .set(\n+            1,\n+            new ImmutableSubContainerImpl(\n+                UnsignedLong.valueOf(0x999), Bytes32.leftPad(Bytes.fromHexString(\"0xa999\"))));\n+\n+    {\n+      Assertions.assertEquals(UnsignedLong.ZERO, c1.getSub1().getLong1());\n+      Assertions.assertTrue(c1.getList1().isEmpty());\n+      Assertions.assertTrue(c1.getList2().isEmpty());\n+      Assertions.assertEquals(UnsignedLong.ZERO, c1.getList3().get(0).getLong1());\n+      Assertions.assertEquals(Bytes32.ZERO, c1.getList3().get(0).getBytes1());\n+      Assertions.assertEquals(UnsignedLong.ZERO, c1.getList3().get(1).getLong1());\n+      Assertions.assertEquals(Bytes32.ZERO, c1.getList3().get(1).getBytes1());\n+\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x1), c1w.getLong1());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x2), c1w.getLong2());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x111), c1w.getSub1().getLong1());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x222), c1w.getSub1().getLong2());\n+      Assertions.assertEquals(2, c1w.getList1().size());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x333), c1w.getList1().get(0).get());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x444), c1w.getList1().get(1).get());\n+      Assertions.assertThrows(\n+          IndexOutOfBoundsException.class,\n+          () -> {\n+            c1w.getList1().get(2);\n+          });\n+      Assertions.assertEquals(2, c1w.getList2().size());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x555), c1w.getList2().get(0).getLong1());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x666), c1w.getList2().get(0).getLong2());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x777), c1w.getList2().get(1).getLong1());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x888), c1w.getList2().get(1).getLong2());\n+      Assertions.assertEquals(UnsignedLong.ZERO, c1w.getList3().get(0).getLong1());\n+      Assertions.assertEquals(Bytes32.ZERO, c1w.getList3().get(0).getBytes1());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x999), c1w.getList3().get(1).getLong1());\n+      Assertions.assertEquals(\n+          Bytes32.leftPad(Bytes.fromHexString(\"0xa999\")), c1w.getList3().get(1).getBytes1());\n+    }\n+\n+    ContainerRead c1r = c1w.commitChanges();\n+    TreeUtil.dumpBinaryTree(c1r.getBackingNode());\n+\n+    {\n+      Assertions.assertEquals(UnsignedLong.ZERO, c1.getSub1().getLong1());\n+      Assertions.assertTrue(c1.getList1().isEmpty());\n+      Assertions.assertTrue(c1.getList2().isEmpty());\n+      Assertions.assertEquals(UnsignedLong.ZERO, c1.getList3().get(0).getLong1());\n+      Assertions.assertEquals(Bytes32.ZERO, c1.getList3().get(0).getBytes1());\n+      Assertions.assertEquals(UnsignedLong.ZERO, c1.getList3().get(1).getLong1());\n+      Assertions.assertEquals(Bytes32.ZERO, c1.getList3().get(1).getBytes1());\n+\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x1), c1r.getLong1());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x2), c1r.getLong2());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x111), c1r.getSub1().getLong1());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x222), c1r.getSub1().getLong2());\n+      Assertions.assertEquals(2, c1r.getList1().size());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x333), c1r.getList1().get(0).get());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x444), c1r.getList1().get(1).get());\n+      Assertions.assertThrows(\n+          IndexOutOfBoundsException.class,\n+          () -> {\n+            c1r.getList1().get(2);\n+          });\n+      Assertions.assertEquals(2, c1r.getList2().size());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x555), c1r.getList2().get(0).getLong1());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x666), c1r.getList2().get(0).getLong2());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x777), c1r.getList2().get(1).getLong1());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x888), c1r.getList2().get(1).getLong2());\n+      Assertions.assertEquals(UnsignedLong.ZERO, c1r.getList3().get(0).getLong1());\n+      Assertions.assertEquals(Bytes32.ZERO, c1r.getList3().get(0).getBytes1());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x999), c1r.getList3().get(1).getLong1());\n+      Assertions.assertEquals(\n+          Bytes32.leftPad(Bytes.fromHexString(\"0xa999\")), c1r.getList3().get(1).getBytes1());\n+    }\n+\n+    ContainerWrite c2w = c1r.createWritableCopy();\n+    c2w.getList2().getByRef(1).setLong2(UnsignedLong.valueOf(0xaaa));\n+    ContainerRead c2r = c2w.commitChanges();\n+\n+    Assertions.assertEquals(UnsignedLong.valueOf(0x888), c1r.getList2().get(1).getLong2());\n+    Assertions.assertEquals(UnsignedLong.valueOf(0xaaa), c2r.getList2().get(1).getLong2());\n+  }\n+\n+  @Test\n+  public void readWriteContainerTest2() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4fc41d2f455ad3019095470229fa3cd5922d9c6"}, "originalPosition": 344}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzA0Njk2OQ==", "bodyText": "Removed", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r387046969", "createdAt": "2020-03-03T14:16:36Z", "author": {"login": "Nashatyrev"}, "path": "util/src/test/java/tech/pegasys/artemis/util/backing/ContainerViewTest.java", "diffHunk": "@@ -0,0 +1,365 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.util.backing;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.List;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import tech.pegasys.artemis.util.backing.tree.TreeNode;\n+import tech.pegasys.artemis.util.backing.tree.TreeUtil;\n+import tech.pegasys.artemis.util.backing.type.BasicViewTypes;\n+import tech.pegasys.artemis.util.backing.type.ContainerViewType;\n+import tech.pegasys.artemis.util.backing.type.ListViewType;\n+import tech.pegasys.artemis.util.backing.type.VectorViewType;\n+import tech.pegasys.artemis.util.backing.view.BasicViews.Bytes32View;\n+import tech.pegasys.artemis.util.backing.view.BasicViews.UInt64View;\n+import tech.pegasys.artemis.util.backing.view.ContainerViewImpl;\n+\n+public class ContainerViewTest {\n+\n+  public interface ImmutableSubContainer extends ContainerViewRead {\n+\n+    UnsignedLong getLong1();\n+\n+    Bytes32 getBytes1();\n+  }\n+\n+  public interface SubContainerRead extends ContainerViewRead {\n+\n+    UnsignedLong getLong1();\n+\n+    UnsignedLong getLong2();\n+  }\n+\n+  public interface SubContainerWrite extends SubContainerRead, ContainerViewWrite {\n+\n+    void setLong1(UnsignedLong val);\n+\n+    void setLong2(UnsignedLong val);\n+  }\n+\n+  public interface ContainerRead extends ContainerViewRead {\n+\n+    UnsignedLong getLong1();\n+\n+    UnsignedLong getLong2();\n+\n+    SubContainerRead getSub1();\n+\n+    ListViewRead<UInt64View> getList1();\n+\n+    ListViewRead<SubContainerRead> getList2();\n+\n+    VectorViewRead<ImmutableSubContainer> getList3();\n+\n+    @Override\n+    ContainerWrite createWritableCopy();\n+  }\n+\n+  public interface ContainerWrite extends ContainerRead, ContainerViewWriteRef {\n+\n+    void setLong1(UnsignedLong val);\n+\n+    void setLong2(UnsignedLong val);\n+\n+    @Override\n+    SubContainerWrite getSub1();\n+\n+    @Override\n+    ListViewWrite<UInt64View> getList1();\n+\n+    @Override\n+    ListViewWriteRef<SubContainerRead, SubContainerWrite> getList2();\n+\n+    @Override\n+    VectorViewWrite<ImmutableSubContainer> getList3();\n+\n+    @Override\n+    ContainerRead commitChanges();\n+  }\n+\n+  public static class ImmutableSubContainerImpl extends ContainerViewImpl<ImmutableSubContainerImpl>\n+      implements ImmutableSubContainer {\n+\n+    public static final ContainerViewType<ImmutableSubContainerImpl> TYPE =\n+        new ContainerViewType<>(\n+            List.of(BasicViewTypes.UINT64_TYPE, BasicViewTypes.BYTES32_TYPE),\n+            ImmutableSubContainerImpl::new);\n+\n+    private ImmutableSubContainerImpl(\n+        ContainerViewType<ImmutableSubContainerImpl> type, TreeNode backingNode) {\n+      super(type, backingNode);\n+    }\n+\n+    public ImmutableSubContainerImpl(UnsignedLong long1, Bytes32 bytes1) {\n+      super(TYPE, new UInt64View(long1), new Bytes32View(bytes1));\n+    }\n+\n+    @Override\n+    public UnsignedLong getLong1() {\n+      return ((UInt64View) get(0)).get();\n+    }\n+\n+    @Override\n+    public Bytes32 getBytes1() {\n+      return ((Bytes32View) get(1)).get();\n+    }\n+  }\n+\n+  public static class SubContainerImpl extends ContainerViewImpl<SubContainerImpl>\n+      implements SubContainerWrite {\n+\n+    public static final ContainerViewType<SubContainerImpl> TYPE =\n+        new ContainerViewType<>(\n+            List.of(BasicViewTypes.UINT64_TYPE, BasicViewTypes.UINT64_TYPE), SubContainerImpl::new);\n+\n+    private SubContainerImpl(ContainerViewType<SubContainerImpl> type, TreeNode backingNode) {\n+      super(type, backingNode);\n+    }\n+\n+    @Override\n+    public UnsignedLong getLong1() {\n+      return ((UInt64View) get(0)).get();\n+    }\n+\n+    @Override\n+    public UnsignedLong getLong2() {\n+      return ((UInt64View) get(1)).get();\n+    }\n+\n+    @Override\n+    public void setLong1(UnsignedLong val) {\n+      set(0, new UInt64View(val));\n+    }\n+\n+    @Override\n+    public void setLong2(UnsignedLong val) {\n+      set(1, new UInt64View(val));\n+    }\n+  }\n+\n+  public static class ContainerImpl extends ContainerViewImpl<ContainerImpl>\n+      implements ContainerWrite {\n+\n+    public static final ContainerViewType<ContainerImpl> TYPE =\n+        new ContainerViewType<>(\n+            List.of(\n+                BasicViewTypes.UINT64_TYPE,\n+                BasicViewTypes.UINT64_TYPE,\n+                SubContainerImpl.TYPE,\n+                new ListViewType<>(BasicViewTypes.UINT64_TYPE, 10),\n+                new ListViewType<>(SubContainerImpl.TYPE, 2),\n+                new VectorViewType<>(ImmutableSubContainerImpl.TYPE, 2)),\n+            ContainerImpl::new);\n+\n+    public ContainerImpl(ContainerViewType<ContainerImpl> type, TreeNode backingNode) {\n+      super(type, backingNode);\n+    }\n+\n+    public static ContainerRead createDefault() {\n+      return TYPE.getDefault();\n+    }\n+\n+    @Override\n+    public UnsignedLong getLong1() {\n+      return ((UInt64View) get(0)).get();\n+    }\n+\n+    @Override\n+    public UnsignedLong getLong2() {\n+      return ((UInt64View) get(1)).get();\n+    }\n+\n+    @Override\n+    public SubContainerImpl getSub1() {\n+      return (SubContainerImpl) getByRef(2);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public ListViewWrite<UInt64View> getList1() {\n+      return (ListViewWrite<UInt64View>) getByRef(3);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public ListViewWriteRef<SubContainerRead, SubContainerWrite> getList2() {\n+      return (ListViewWriteRef<SubContainerRead, SubContainerWrite>) getByRef(4);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public VectorViewWrite<ImmutableSubContainer> getList3() {\n+      return (VectorViewWrite<ImmutableSubContainer>) getByRef(5);\n+    }\n+\n+    @Override\n+    public void setLong1(UnsignedLong val) {\n+      set(0, new UInt64View(val));\n+    }\n+\n+    @Override\n+    public void setLong2(UnsignedLong val) {\n+      set(1, new UInt64View(val));\n+    }\n+  }\n+\n+  @Test\n+  public void readWriteContainerTest1() {\n+    ContainerRead c1 = ContainerImpl.createDefault();\n+\n+    {\n+      Assertions.assertEquals(UnsignedLong.ZERO, c1.getSub1().getLong1());\n+      Assertions.assertTrue(c1.getList1().isEmpty());\n+      Assertions.assertTrue(c1.getList2().isEmpty());\n+      Assertions.assertEquals(UnsignedLong.ZERO, c1.getList3().get(0).getLong1());\n+      Assertions.assertEquals(Bytes32.ZERO, c1.getList3().get(0).getBytes1());\n+      Assertions.assertEquals(UnsignedLong.ZERO, c1.getList3().get(1).getLong1());\n+      Assertions.assertEquals(Bytes32.ZERO, c1.getList3().get(1).getBytes1());\n+      Assertions.assertThrows(\n+          IndexOutOfBoundsException.class,\n+          () -> {\n+            c1.getList3().get(2);\n+          });\n+    }\n+\n+    ContainerWrite c1w = c1.createWritableCopy();\n+    c1w.setLong1(UnsignedLong.valueOf(0x1));\n+    c1w.setLong2(UnsignedLong.valueOf(0x2));\n+\n+    c1w.getSub1().setLong1(UnsignedLong.valueOf(0x111));\n+    c1w.getSub1().setLong2(UnsignedLong.valueOf(0x222));\n+\n+    c1w.getList1().append(UInt64View.fromLong(0x333));\n+    c1w.getList1().append(UInt64View.fromLong(0x444));\n+\n+    c1w.getList2()\n+        .append(\n+            sc -> {\n+              sc.setLong1(UnsignedLong.valueOf(0x555));\n+              sc.setLong2(UnsignedLong.valueOf(0x666));\n+            });\n+    SubContainerWrite sc1w = c1w.getList2().append();\n+    sc1w.setLong1(UnsignedLong.valueOf(0x777));\n+    sc1w.setLong2(UnsignedLong.valueOf(0x888));\n+\n+    c1w.getList3()\n+        .set(\n+            1,\n+            new ImmutableSubContainerImpl(\n+                UnsignedLong.valueOf(0x999), Bytes32.leftPad(Bytes.fromHexString(\"0xa999\"))));\n+\n+    {\n+      Assertions.assertEquals(UnsignedLong.ZERO, c1.getSub1().getLong1());\n+      Assertions.assertTrue(c1.getList1().isEmpty());\n+      Assertions.assertTrue(c1.getList2().isEmpty());\n+      Assertions.assertEquals(UnsignedLong.ZERO, c1.getList3().get(0).getLong1());\n+      Assertions.assertEquals(Bytes32.ZERO, c1.getList3().get(0).getBytes1());\n+      Assertions.assertEquals(UnsignedLong.ZERO, c1.getList3().get(1).getLong1());\n+      Assertions.assertEquals(Bytes32.ZERO, c1.getList3().get(1).getBytes1());\n+\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x1), c1w.getLong1());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x2), c1w.getLong2());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x111), c1w.getSub1().getLong1());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x222), c1w.getSub1().getLong2());\n+      Assertions.assertEquals(2, c1w.getList1().size());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x333), c1w.getList1().get(0).get());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x444), c1w.getList1().get(1).get());\n+      Assertions.assertThrows(\n+          IndexOutOfBoundsException.class,\n+          () -> {\n+            c1w.getList1().get(2);\n+          });\n+      Assertions.assertEquals(2, c1w.getList2().size());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x555), c1w.getList2().get(0).getLong1());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x666), c1w.getList2().get(0).getLong2());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x777), c1w.getList2().get(1).getLong1());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x888), c1w.getList2().get(1).getLong2());\n+      Assertions.assertEquals(UnsignedLong.ZERO, c1w.getList3().get(0).getLong1());\n+      Assertions.assertEquals(Bytes32.ZERO, c1w.getList3().get(0).getBytes1());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x999), c1w.getList3().get(1).getLong1());\n+      Assertions.assertEquals(\n+          Bytes32.leftPad(Bytes.fromHexString(\"0xa999\")), c1w.getList3().get(1).getBytes1());\n+    }\n+\n+    ContainerRead c1r = c1w.commitChanges();\n+    TreeUtil.dumpBinaryTree(c1r.getBackingNode());\n+\n+    {\n+      Assertions.assertEquals(UnsignedLong.ZERO, c1.getSub1().getLong1());\n+      Assertions.assertTrue(c1.getList1().isEmpty());\n+      Assertions.assertTrue(c1.getList2().isEmpty());\n+      Assertions.assertEquals(UnsignedLong.ZERO, c1.getList3().get(0).getLong1());\n+      Assertions.assertEquals(Bytes32.ZERO, c1.getList3().get(0).getBytes1());\n+      Assertions.assertEquals(UnsignedLong.ZERO, c1.getList3().get(1).getLong1());\n+      Assertions.assertEquals(Bytes32.ZERO, c1.getList3().get(1).getBytes1());\n+\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x1), c1r.getLong1());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x2), c1r.getLong2());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x111), c1r.getSub1().getLong1());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x222), c1r.getSub1().getLong2());\n+      Assertions.assertEquals(2, c1r.getList1().size());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x333), c1r.getList1().get(0).get());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x444), c1r.getList1().get(1).get());\n+      Assertions.assertThrows(\n+          IndexOutOfBoundsException.class,\n+          () -> {\n+            c1r.getList1().get(2);\n+          });\n+      Assertions.assertEquals(2, c1r.getList2().size());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x555), c1r.getList2().get(0).getLong1());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x666), c1r.getList2().get(0).getLong2());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x777), c1r.getList2().get(1).getLong1());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x888), c1r.getList2().get(1).getLong2());\n+      Assertions.assertEquals(UnsignedLong.ZERO, c1r.getList3().get(0).getLong1());\n+      Assertions.assertEquals(Bytes32.ZERO, c1r.getList3().get(0).getBytes1());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x999), c1r.getList3().get(1).getLong1());\n+      Assertions.assertEquals(\n+          Bytes32.leftPad(Bytes.fromHexString(\"0xa999\")), c1r.getList3().get(1).getBytes1());\n+    }\n+\n+    ContainerWrite c2w = c1r.createWritableCopy();\n+    c2w.getList2().getByRef(1).setLong2(UnsignedLong.valueOf(0xaaa));\n+    ContainerRead c2r = c2w.commitChanges();\n+\n+    Assertions.assertEquals(UnsignedLong.valueOf(0x888), c1r.getList2().get(1).getLong2());\n+    Assertions.assertEquals(UnsignedLong.valueOf(0xaaa), c2r.getList2().get(1).getLong2());\n+  }\n+\n+  @Test\n+  public void readWriteContainerTest2() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjUwMjYwNg=="}, "originalCommit": {"oid": "d4fc41d2f455ad3019095470229fa3cd5922d9c6"}, "originalPosition": 344}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5NDI2NjEyOnYy", "diffSide": "RIGHT", "path": "util/src/test/java/tech/pegasys/artemis/util/backing/ContainerViewTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxNjozMTozMFrOFwmUNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxNTo1NzozN1rOFxLzMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjUwMzczMw==", "bodyText": "As a general standard, we usually use assertJ for test assertions:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Assertions.assertEquals(UnsignedLong.valueOf(0xaaa), c2r.getList2().get(1).getLong2());\n          \n          \n            \n                assertThat(c2r.getList2().get(1).getLong2()).isEqualTo(UnsignedLong.valueOf(0xaaa));", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r386503733", "createdAt": "2020-03-02T16:31:30Z", "author": {"login": "mbaxter"}, "path": "util/src/test/java/tech/pegasys/artemis/util/backing/ContainerViewTest.java", "diffHunk": "@@ -0,0 +1,365 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.util.backing;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.List;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import tech.pegasys.artemis.util.backing.tree.TreeNode;\n+import tech.pegasys.artemis.util.backing.tree.TreeUtil;\n+import tech.pegasys.artemis.util.backing.type.BasicViewTypes;\n+import tech.pegasys.artemis.util.backing.type.ContainerViewType;\n+import tech.pegasys.artemis.util.backing.type.ListViewType;\n+import tech.pegasys.artemis.util.backing.type.VectorViewType;\n+import tech.pegasys.artemis.util.backing.view.BasicViews.Bytes32View;\n+import tech.pegasys.artemis.util.backing.view.BasicViews.UInt64View;\n+import tech.pegasys.artemis.util.backing.view.ContainerViewImpl;\n+\n+public class ContainerViewTest {\n+\n+  public interface ImmutableSubContainer extends ContainerViewRead {\n+\n+    UnsignedLong getLong1();\n+\n+    Bytes32 getBytes1();\n+  }\n+\n+  public interface SubContainerRead extends ContainerViewRead {\n+\n+    UnsignedLong getLong1();\n+\n+    UnsignedLong getLong2();\n+  }\n+\n+  public interface SubContainerWrite extends SubContainerRead, ContainerViewWrite {\n+\n+    void setLong1(UnsignedLong val);\n+\n+    void setLong2(UnsignedLong val);\n+  }\n+\n+  public interface ContainerRead extends ContainerViewRead {\n+\n+    UnsignedLong getLong1();\n+\n+    UnsignedLong getLong2();\n+\n+    SubContainerRead getSub1();\n+\n+    ListViewRead<UInt64View> getList1();\n+\n+    ListViewRead<SubContainerRead> getList2();\n+\n+    VectorViewRead<ImmutableSubContainer> getList3();\n+\n+    @Override\n+    ContainerWrite createWritableCopy();\n+  }\n+\n+  public interface ContainerWrite extends ContainerRead, ContainerViewWriteRef {\n+\n+    void setLong1(UnsignedLong val);\n+\n+    void setLong2(UnsignedLong val);\n+\n+    @Override\n+    SubContainerWrite getSub1();\n+\n+    @Override\n+    ListViewWrite<UInt64View> getList1();\n+\n+    @Override\n+    ListViewWriteRef<SubContainerRead, SubContainerWrite> getList2();\n+\n+    @Override\n+    VectorViewWrite<ImmutableSubContainer> getList3();\n+\n+    @Override\n+    ContainerRead commitChanges();\n+  }\n+\n+  public static class ImmutableSubContainerImpl extends ContainerViewImpl<ImmutableSubContainerImpl>\n+      implements ImmutableSubContainer {\n+\n+    public static final ContainerViewType<ImmutableSubContainerImpl> TYPE =\n+        new ContainerViewType<>(\n+            List.of(BasicViewTypes.UINT64_TYPE, BasicViewTypes.BYTES32_TYPE),\n+            ImmutableSubContainerImpl::new);\n+\n+    private ImmutableSubContainerImpl(\n+        ContainerViewType<ImmutableSubContainerImpl> type, TreeNode backingNode) {\n+      super(type, backingNode);\n+    }\n+\n+    public ImmutableSubContainerImpl(UnsignedLong long1, Bytes32 bytes1) {\n+      super(TYPE, new UInt64View(long1), new Bytes32View(bytes1));\n+    }\n+\n+    @Override\n+    public UnsignedLong getLong1() {\n+      return ((UInt64View) get(0)).get();\n+    }\n+\n+    @Override\n+    public Bytes32 getBytes1() {\n+      return ((Bytes32View) get(1)).get();\n+    }\n+  }\n+\n+  public static class SubContainerImpl extends ContainerViewImpl<SubContainerImpl>\n+      implements SubContainerWrite {\n+\n+    public static final ContainerViewType<SubContainerImpl> TYPE =\n+        new ContainerViewType<>(\n+            List.of(BasicViewTypes.UINT64_TYPE, BasicViewTypes.UINT64_TYPE), SubContainerImpl::new);\n+\n+    private SubContainerImpl(ContainerViewType<SubContainerImpl> type, TreeNode backingNode) {\n+      super(type, backingNode);\n+    }\n+\n+    @Override\n+    public UnsignedLong getLong1() {\n+      return ((UInt64View) get(0)).get();\n+    }\n+\n+    @Override\n+    public UnsignedLong getLong2() {\n+      return ((UInt64View) get(1)).get();\n+    }\n+\n+    @Override\n+    public void setLong1(UnsignedLong val) {\n+      set(0, new UInt64View(val));\n+    }\n+\n+    @Override\n+    public void setLong2(UnsignedLong val) {\n+      set(1, new UInt64View(val));\n+    }\n+  }\n+\n+  public static class ContainerImpl extends ContainerViewImpl<ContainerImpl>\n+      implements ContainerWrite {\n+\n+    public static final ContainerViewType<ContainerImpl> TYPE =\n+        new ContainerViewType<>(\n+            List.of(\n+                BasicViewTypes.UINT64_TYPE,\n+                BasicViewTypes.UINT64_TYPE,\n+                SubContainerImpl.TYPE,\n+                new ListViewType<>(BasicViewTypes.UINT64_TYPE, 10),\n+                new ListViewType<>(SubContainerImpl.TYPE, 2),\n+                new VectorViewType<>(ImmutableSubContainerImpl.TYPE, 2)),\n+            ContainerImpl::new);\n+\n+    public ContainerImpl(ContainerViewType<ContainerImpl> type, TreeNode backingNode) {\n+      super(type, backingNode);\n+    }\n+\n+    public static ContainerRead createDefault() {\n+      return TYPE.getDefault();\n+    }\n+\n+    @Override\n+    public UnsignedLong getLong1() {\n+      return ((UInt64View) get(0)).get();\n+    }\n+\n+    @Override\n+    public UnsignedLong getLong2() {\n+      return ((UInt64View) get(1)).get();\n+    }\n+\n+    @Override\n+    public SubContainerImpl getSub1() {\n+      return (SubContainerImpl) getByRef(2);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public ListViewWrite<UInt64View> getList1() {\n+      return (ListViewWrite<UInt64View>) getByRef(3);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public ListViewWriteRef<SubContainerRead, SubContainerWrite> getList2() {\n+      return (ListViewWriteRef<SubContainerRead, SubContainerWrite>) getByRef(4);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public VectorViewWrite<ImmutableSubContainer> getList3() {\n+      return (VectorViewWrite<ImmutableSubContainer>) getByRef(5);\n+    }\n+\n+    @Override\n+    public void setLong1(UnsignedLong val) {\n+      set(0, new UInt64View(val));\n+    }\n+\n+    @Override\n+    public void setLong2(UnsignedLong val) {\n+      set(1, new UInt64View(val));\n+    }\n+  }\n+\n+  @Test\n+  public void readWriteContainerTest1() {\n+    ContainerRead c1 = ContainerImpl.createDefault();\n+\n+    {\n+      Assertions.assertEquals(UnsignedLong.ZERO, c1.getSub1().getLong1());\n+      Assertions.assertTrue(c1.getList1().isEmpty());\n+      Assertions.assertTrue(c1.getList2().isEmpty());\n+      Assertions.assertEquals(UnsignedLong.ZERO, c1.getList3().get(0).getLong1());\n+      Assertions.assertEquals(Bytes32.ZERO, c1.getList3().get(0).getBytes1());\n+      Assertions.assertEquals(UnsignedLong.ZERO, c1.getList3().get(1).getLong1());\n+      Assertions.assertEquals(Bytes32.ZERO, c1.getList3().get(1).getBytes1());\n+      Assertions.assertThrows(\n+          IndexOutOfBoundsException.class,\n+          () -> {\n+            c1.getList3().get(2);\n+          });\n+    }\n+\n+    ContainerWrite c1w = c1.createWritableCopy();\n+    c1w.setLong1(UnsignedLong.valueOf(0x1));\n+    c1w.setLong2(UnsignedLong.valueOf(0x2));\n+\n+    c1w.getSub1().setLong1(UnsignedLong.valueOf(0x111));\n+    c1w.getSub1().setLong2(UnsignedLong.valueOf(0x222));\n+\n+    c1w.getList1().append(UInt64View.fromLong(0x333));\n+    c1w.getList1().append(UInt64View.fromLong(0x444));\n+\n+    c1w.getList2()\n+        .append(\n+            sc -> {\n+              sc.setLong1(UnsignedLong.valueOf(0x555));\n+              sc.setLong2(UnsignedLong.valueOf(0x666));\n+            });\n+    SubContainerWrite sc1w = c1w.getList2().append();\n+    sc1w.setLong1(UnsignedLong.valueOf(0x777));\n+    sc1w.setLong2(UnsignedLong.valueOf(0x888));\n+\n+    c1w.getList3()\n+        .set(\n+            1,\n+            new ImmutableSubContainerImpl(\n+                UnsignedLong.valueOf(0x999), Bytes32.leftPad(Bytes.fromHexString(\"0xa999\"))));\n+\n+    {\n+      Assertions.assertEquals(UnsignedLong.ZERO, c1.getSub1().getLong1());\n+      Assertions.assertTrue(c1.getList1().isEmpty());\n+      Assertions.assertTrue(c1.getList2().isEmpty());\n+      Assertions.assertEquals(UnsignedLong.ZERO, c1.getList3().get(0).getLong1());\n+      Assertions.assertEquals(Bytes32.ZERO, c1.getList3().get(0).getBytes1());\n+      Assertions.assertEquals(UnsignedLong.ZERO, c1.getList3().get(1).getLong1());\n+      Assertions.assertEquals(Bytes32.ZERO, c1.getList3().get(1).getBytes1());\n+\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x1), c1w.getLong1());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x2), c1w.getLong2());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x111), c1w.getSub1().getLong1());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x222), c1w.getSub1().getLong2());\n+      Assertions.assertEquals(2, c1w.getList1().size());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x333), c1w.getList1().get(0).get());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x444), c1w.getList1().get(1).get());\n+      Assertions.assertThrows(\n+          IndexOutOfBoundsException.class,\n+          () -> {\n+            c1w.getList1().get(2);\n+          });\n+      Assertions.assertEquals(2, c1w.getList2().size());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x555), c1w.getList2().get(0).getLong1());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x666), c1w.getList2().get(0).getLong2());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x777), c1w.getList2().get(1).getLong1());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x888), c1w.getList2().get(1).getLong2());\n+      Assertions.assertEquals(UnsignedLong.ZERO, c1w.getList3().get(0).getLong1());\n+      Assertions.assertEquals(Bytes32.ZERO, c1w.getList3().get(0).getBytes1());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x999), c1w.getList3().get(1).getLong1());\n+      Assertions.assertEquals(\n+          Bytes32.leftPad(Bytes.fromHexString(\"0xa999\")), c1w.getList3().get(1).getBytes1());\n+    }\n+\n+    ContainerRead c1r = c1w.commitChanges();\n+    TreeUtil.dumpBinaryTree(c1r.getBackingNode());\n+\n+    {\n+      Assertions.assertEquals(UnsignedLong.ZERO, c1.getSub1().getLong1());\n+      Assertions.assertTrue(c1.getList1().isEmpty());\n+      Assertions.assertTrue(c1.getList2().isEmpty());\n+      Assertions.assertEquals(UnsignedLong.ZERO, c1.getList3().get(0).getLong1());\n+      Assertions.assertEquals(Bytes32.ZERO, c1.getList3().get(0).getBytes1());\n+      Assertions.assertEquals(UnsignedLong.ZERO, c1.getList3().get(1).getLong1());\n+      Assertions.assertEquals(Bytes32.ZERO, c1.getList3().get(1).getBytes1());\n+\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x1), c1r.getLong1());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x2), c1r.getLong2());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x111), c1r.getSub1().getLong1());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x222), c1r.getSub1().getLong2());\n+      Assertions.assertEquals(2, c1r.getList1().size());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x333), c1r.getList1().get(0).get());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x444), c1r.getList1().get(1).get());\n+      Assertions.assertThrows(\n+          IndexOutOfBoundsException.class,\n+          () -> {\n+            c1r.getList1().get(2);\n+          });\n+      Assertions.assertEquals(2, c1r.getList2().size());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x555), c1r.getList2().get(0).getLong1());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x666), c1r.getList2().get(0).getLong2());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x777), c1r.getList2().get(1).getLong1());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x888), c1r.getList2().get(1).getLong2());\n+      Assertions.assertEquals(UnsignedLong.ZERO, c1r.getList3().get(0).getLong1());\n+      Assertions.assertEquals(Bytes32.ZERO, c1r.getList3().get(0).getBytes1());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x999), c1r.getList3().get(1).getLong1());\n+      Assertions.assertEquals(\n+          Bytes32.leftPad(Bytes.fromHexString(\"0xa999\")), c1r.getList3().get(1).getBytes1());\n+    }\n+\n+    ContainerWrite c2w = c1r.createWritableCopy();\n+    c2w.getList2().getByRef(1).setLong2(UnsignedLong.valueOf(0xaaa));\n+    ContainerRead c2r = c2w.commitChanges();\n+\n+    Assertions.assertEquals(UnsignedLong.valueOf(0x888), c1r.getList2().get(1).getLong2());\n+    Assertions.assertEquals(UnsignedLong.valueOf(0xaaa), c2r.getList2().get(1).getLong2());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4fc41d2f455ad3019095470229fa3cd5922d9c6"}, "originalPosition": 340}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzExNzg3Mg==", "bodyText": "Migrated tests.", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r387117872", "createdAt": "2020-03-03T15:57:37Z", "author": {"login": "Nashatyrev"}, "path": "util/src/test/java/tech/pegasys/artemis/util/backing/ContainerViewTest.java", "diffHunk": "@@ -0,0 +1,365 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.util.backing;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.List;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+import tech.pegasys.artemis.util.backing.tree.TreeNode;\n+import tech.pegasys.artemis.util.backing.tree.TreeUtil;\n+import tech.pegasys.artemis.util.backing.type.BasicViewTypes;\n+import tech.pegasys.artemis.util.backing.type.ContainerViewType;\n+import tech.pegasys.artemis.util.backing.type.ListViewType;\n+import tech.pegasys.artemis.util.backing.type.VectorViewType;\n+import tech.pegasys.artemis.util.backing.view.BasicViews.Bytes32View;\n+import tech.pegasys.artemis.util.backing.view.BasicViews.UInt64View;\n+import tech.pegasys.artemis.util.backing.view.ContainerViewImpl;\n+\n+public class ContainerViewTest {\n+\n+  public interface ImmutableSubContainer extends ContainerViewRead {\n+\n+    UnsignedLong getLong1();\n+\n+    Bytes32 getBytes1();\n+  }\n+\n+  public interface SubContainerRead extends ContainerViewRead {\n+\n+    UnsignedLong getLong1();\n+\n+    UnsignedLong getLong2();\n+  }\n+\n+  public interface SubContainerWrite extends SubContainerRead, ContainerViewWrite {\n+\n+    void setLong1(UnsignedLong val);\n+\n+    void setLong2(UnsignedLong val);\n+  }\n+\n+  public interface ContainerRead extends ContainerViewRead {\n+\n+    UnsignedLong getLong1();\n+\n+    UnsignedLong getLong2();\n+\n+    SubContainerRead getSub1();\n+\n+    ListViewRead<UInt64View> getList1();\n+\n+    ListViewRead<SubContainerRead> getList2();\n+\n+    VectorViewRead<ImmutableSubContainer> getList3();\n+\n+    @Override\n+    ContainerWrite createWritableCopy();\n+  }\n+\n+  public interface ContainerWrite extends ContainerRead, ContainerViewWriteRef {\n+\n+    void setLong1(UnsignedLong val);\n+\n+    void setLong2(UnsignedLong val);\n+\n+    @Override\n+    SubContainerWrite getSub1();\n+\n+    @Override\n+    ListViewWrite<UInt64View> getList1();\n+\n+    @Override\n+    ListViewWriteRef<SubContainerRead, SubContainerWrite> getList2();\n+\n+    @Override\n+    VectorViewWrite<ImmutableSubContainer> getList3();\n+\n+    @Override\n+    ContainerRead commitChanges();\n+  }\n+\n+  public static class ImmutableSubContainerImpl extends ContainerViewImpl<ImmutableSubContainerImpl>\n+      implements ImmutableSubContainer {\n+\n+    public static final ContainerViewType<ImmutableSubContainerImpl> TYPE =\n+        new ContainerViewType<>(\n+            List.of(BasicViewTypes.UINT64_TYPE, BasicViewTypes.BYTES32_TYPE),\n+            ImmutableSubContainerImpl::new);\n+\n+    private ImmutableSubContainerImpl(\n+        ContainerViewType<ImmutableSubContainerImpl> type, TreeNode backingNode) {\n+      super(type, backingNode);\n+    }\n+\n+    public ImmutableSubContainerImpl(UnsignedLong long1, Bytes32 bytes1) {\n+      super(TYPE, new UInt64View(long1), new Bytes32View(bytes1));\n+    }\n+\n+    @Override\n+    public UnsignedLong getLong1() {\n+      return ((UInt64View) get(0)).get();\n+    }\n+\n+    @Override\n+    public Bytes32 getBytes1() {\n+      return ((Bytes32View) get(1)).get();\n+    }\n+  }\n+\n+  public static class SubContainerImpl extends ContainerViewImpl<SubContainerImpl>\n+      implements SubContainerWrite {\n+\n+    public static final ContainerViewType<SubContainerImpl> TYPE =\n+        new ContainerViewType<>(\n+            List.of(BasicViewTypes.UINT64_TYPE, BasicViewTypes.UINT64_TYPE), SubContainerImpl::new);\n+\n+    private SubContainerImpl(ContainerViewType<SubContainerImpl> type, TreeNode backingNode) {\n+      super(type, backingNode);\n+    }\n+\n+    @Override\n+    public UnsignedLong getLong1() {\n+      return ((UInt64View) get(0)).get();\n+    }\n+\n+    @Override\n+    public UnsignedLong getLong2() {\n+      return ((UInt64View) get(1)).get();\n+    }\n+\n+    @Override\n+    public void setLong1(UnsignedLong val) {\n+      set(0, new UInt64View(val));\n+    }\n+\n+    @Override\n+    public void setLong2(UnsignedLong val) {\n+      set(1, new UInt64View(val));\n+    }\n+  }\n+\n+  public static class ContainerImpl extends ContainerViewImpl<ContainerImpl>\n+      implements ContainerWrite {\n+\n+    public static final ContainerViewType<ContainerImpl> TYPE =\n+        new ContainerViewType<>(\n+            List.of(\n+                BasicViewTypes.UINT64_TYPE,\n+                BasicViewTypes.UINT64_TYPE,\n+                SubContainerImpl.TYPE,\n+                new ListViewType<>(BasicViewTypes.UINT64_TYPE, 10),\n+                new ListViewType<>(SubContainerImpl.TYPE, 2),\n+                new VectorViewType<>(ImmutableSubContainerImpl.TYPE, 2)),\n+            ContainerImpl::new);\n+\n+    public ContainerImpl(ContainerViewType<ContainerImpl> type, TreeNode backingNode) {\n+      super(type, backingNode);\n+    }\n+\n+    public static ContainerRead createDefault() {\n+      return TYPE.getDefault();\n+    }\n+\n+    @Override\n+    public UnsignedLong getLong1() {\n+      return ((UInt64View) get(0)).get();\n+    }\n+\n+    @Override\n+    public UnsignedLong getLong2() {\n+      return ((UInt64View) get(1)).get();\n+    }\n+\n+    @Override\n+    public SubContainerImpl getSub1() {\n+      return (SubContainerImpl) getByRef(2);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public ListViewWrite<UInt64View> getList1() {\n+      return (ListViewWrite<UInt64View>) getByRef(3);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public ListViewWriteRef<SubContainerRead, SubContainerWrite> getList2() {\n+      return (ListViewWriteRef<SubContainerRead, SubContainerWrite>) getByRef(4);\n+    }\n+\n+    @Override\n+    @SuppressWarnings(\"unchecked\")\n+    public VectorViewWrite<ImmutableSubContainer> getList3() {\n+      return (VectorViewWrite<ImmutableSubContainer>) getByRef(5);\n+    }\n+\n+    @Override\n+    public void setLong1(UnsignedLong val) {\n+      set(0, new UInt64View(val));\n+    }\n+\n+    @Override\n+    public void setLong2(UnsignedLong val) {\n+      set(1, new UInt64View(val));\n+    }\n+  }\n+\n+  @Test\n+  public void readWriteContainerTest1() {\n+    ContainerRead c1 = ContainerImpl.createDefault();\n+\n+    {\n+      Assertions.assertEquals(UnsignedLong.ZERO, c1.getSub1().getLong1());\n+      Assertions.assertTrue(c1.getList1().isEmpty());\n+      Assertions.assertTrue(c1.getList2().isEmpty());\n+      Assertions.assertEquals(UnsignedLong.ZERO, c1.getList3().get(0).getLong1());\n+      Assertions.assertEquals(Bytes32.ZERO, c1.getList3().get(0).getBytes1());\n+      Assertions.assertEquals(UnsignedLong.ZERO, c1.getList3().get(1).getLong1());\n+      Assertions.assertEquals(Bytes32.ZERO, c1.getList3().get(1).getBytes1());\n+      Assertions.assertThrows(\n+          IndexOutOfBoundsException.class,\n+          () -> {\n+            c1.getList3().get(2);\n+          });\n+    }\n+\n+    ContainerWrite c1w = c1.createWritableCopy();\n+    c1w.setLong1(UnsignedLong.valueOf(0x1));\n+    c1w.setLong2(UnsignedLong.valueOf(0x2));\n+\n+    c1w.getSub1().setLong1(UnsignedLong.valueOf(0x111));\n+    c1w.getSub1().setLong2(UnsignedLong.valueOf(0x222));\n+\n+    c1w.getList1().append(UInt64View.fromLong(0x333));\n+    c1w.getList1().append(UInt64View.fromLong(0x444));\n+\n+    c1w.getList2()\n+        .append(\n+            sc -> {\n+              sc.setLong1(UnsignedLong.valueOf(0x555));\n+              sc.setLong2(UnsignedLong.valueOf(0x666));\n+            });\n+    SubContainerWrite sc1w = c1w.getList2().append();\n+    sc1w.setLong1(UnsignedLong.valueOf(0x777));\n+    sc1w.setLong2(UnsignedLong.valueOf(0x888));\n+\n+    c1w.getList3()\n+        .set(\n+            1,\n+            new ImmutableSubContainerImpl(\n+                UnsignedLong.valueOf(0x999), Bytes32.leftPad(Bytes.fromHexString(\"0xa999\"))));\n+\n+    {\n+      Assertions.assertEquals(UnsignedLong.ZERO, c1.getSub1().getLong1());\n+      Assertions.assertTrue(c1.getList1().isEmpty());\n+      Assertions.assertTrue(c1.getList2().isEmpty());\n+      Assertions.assertEquals(UnsignedLong.ZERO, c1.getList3().get(0).getLong1());\n+      Assertions.assertEquals(Bytes32.ZERO, c1.getList3().get(0).getBytes1());\n+      Assertions.assertEquals(UnsignedLong.ZERO, c1.getList3().get(1).getLong1());\n+      Assertions.assertEquals(Bytes32.ZERO, c1.getList3().get(1).getBytes1());\n+\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x1), c1w.getLong1());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x2), c1w.getLong2());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x111), c1w.getSub1().getLong1());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x222), c1w.getSub1().getLong2());\n+      Assertions.assertEquals(2, c1w.getList1().size());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x333), c1w.getList1().get(0).get());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x444), c1w.getList1().get(1).get());\n+      Assertions.assertThrows(\n+          IndexOutOfBoundsException.class,\n+          () -> {\n+            c1w.getList1().get(2);\n+          });\n+      Assertions.assertEquals(2, c1w.getList2().size());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x555), c1w.getList2().get(0).getLong1());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x666), c1w.getList2().get(0).getLong2());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x777), c1w.getList2().get(1).getLong1());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x888), c1w.getList2().get(1).getLong2());\n+      Assertions.assertEquals(UnsignedLong.ZERO, c1w.getList3().get(0).getLong1());\n+      Assertions.assertEquals(Bytes32.ZERO, c1w.getList3().get(0).getBytes1());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x999), c1w.getList3().get(1).getLong1());\n+      Assertions.assertEquals(\n+          Bytes32.leftPad(Bytes.fromHexString(\"0xa999\")), c1w.getList3().get(1).getBytes1());\n+    }\n+\n+    ContainerRead c1r = c1w.commitChanges();\n+    TreeUtil.dumpBinaryTree(c1r.getBackingNode());\n+\n+    {\n+      Assertions.assertEquals(UnsignedLong.ZERO, c1.getSub1().getLong1());\n+      Assertions.assertTrue(c1.getList1().isEmpty());\n+      Assertions.assertTrue(c1.getList2().isEmpty());\n+      Assertions.assertEquals(UnsignedLong.ZERO, c1.getList3().get(0).getLong1());\n+      Assertions.assertEquals(Bytes32.ZERO, c1.getList3().get(0).getBytes1());\n+      Assertions.assertEquals(UnsignedLong.ZERO, c1.getList3().get(1).getLong1());\n+      Assertions.assertEquals(Bytes32.ZERO, c1.getList3().get(1).getBytes1());\n+\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x1), c1r.getLong1());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x2), c1r.getLong2());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x111), c1r.getSub1().getLong1());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x222), c1r.getSub1().getLong2());\n+      Assertions.assertEquals(2, c1r.getList1().size());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x333), c1r.getList1().get(0).get());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x444), c1r.getList1().get(1).get());\n+      Assertions.assertThrows(\n+          IndexOutOfBoundsException.class,\n+          () -> {\n+            c1r.getList1().get(2);\n+          });\n+      Assertions.assertEquals(2, c1r.getList2().size());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x555), c1r.getList2().get(0).getLong1());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x666), c1r.getList2().get(0).getLong2());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x777), c1r.getList2().get(1).getLong1());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x888), c1r.getList2().get(1).getLong2());\n+      Assertions.assertEquals(UnsignedLong.ZERO, c1r.getList3().get(0).getLong1());\n+      Assertions.assertEquals(Bytes32.ZERO, c1r.getList3().get(0).getBytes1());\n+      Assertions.assertEquals(UnsignedLong.valueOf(0x999), c1r.getList3().get(1).getLong1());\n+      Assertions.assertEquals(\n+          Bytes32.leftPad(Bytes.fromHexString(\"0xa999\")), c1r.getList3().get(1).getBytes1());\n+    }\n+\n+    ContainerWrite c2w = c1r.createWritableCopy();\n+    c2w.getList2().getByRef(1).setLong2(UnsignedLong.valueOf(0xaaa));\n+    ContainerRead c2r = c2w.commitChanges();\n+\n+    Assertions.assertEquals(UnsignedLong.valueOf(0x888), c1r.getList2().get(1).getLong2());\n+    Assertions.assertEquals(UnsignedLong.valueOf(0xaaa), c2r.getList2().get(1).getLong2());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjUwMzczMw=="}, "originalCommit": {"oid": "d4fc41d2f455ad3019095470229fa3cd5922d9c6"}, "originalPosition": 340}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5NDI5OTY4OnYy", "diffSide": "RIGHT", "path": "util/src/main/java/tech/pegasys/artemis/util/backing/view/ListViewImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxNjozOTo0MVrOFwmo3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxNjo1MTowN1rOFxOGHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjUwOTAyMw==", "bodyText": "Do we need this work around right now?  Standard configs should work fine, right?  Even if there is an error in the config, it seems like it would be better to just throw in that case.", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r386509023", "createdAt": "2020-03-02T16:39:41Z", "author": {"login": "mbaxter"}, "path": "util/src/main/java/tech/pegasys/artemis/util/backing/view/ListViewImpl.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.util.backing.view;\n+\n+import static com.google.common.base.Preconditions.checkPositionIndex;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.Arrays;\n+import java.util.List;\n+import tech.pegasys.artemis.util.backing.CompositeViewWrite;\n+import tech.pegasys.artemis.util.backing.ContainerViewWrite;\n+import tech.pegasys.artemis.util.backing.ListViewWriteRef;\n+import tech.pegasys.artemis.util.backing.VectorViewWrite;\n+import tech.pegasys.artemis.util.backing.ViewRead;\n+import tech.pegasys.artemis.util.backing.tree.TreeNode;\n+import tech.pegasys.artemis.util.backing.type.BasicViewTypes;\n+import tech.pegasys.artemis.util.backing.type.ContainerViewType;\n+import tech.pegasys.artemis.util.backing.type.ListViewType;\n+import tech.pegasys.artemis.util.backing.type.VectorViewType;\n+import tech.pegasys.artemis.util.backing.view.BasicViews.UInt64View;\n+\n+public class ListViewImpl<R extends ViewRead, W extends R>\n+    extends AbstractCompositeViewWrite<ListViewImpl<R, W>, R> implements ListViewWriteRef<R, W> {\n+\n+  // TODO: temp workaround for the case\n+  // SLOTS_PER_ETH1_VOTING_PERIOD % SLOTS_PER_EPOCH != 0\n+  // see https://github.com/ethereum/eth2.0-specs/pull/1625\n+  public static boolean THROW_OUT_OF_BOUNDS = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4fc41d2f455ad3019095470229fa3cd5922d9c6"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE1NTQ4NA==", "bodyText": "Yep, this relates just to my benchmark configs (6-slots epoch). Switched all the stuff to the 'mainnet' config.", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r387155484", "createdAt": "2020-03-03T16:51:07Z", "author": {"login": "Nashatyrev"}, "path": "util/src/main/java/tech/pegasys/artemis/util/backing/view/ListViewImpl.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.util.backing.view;\n+\n+import static com.google.common.base.Preconditions.checkPositionIndex;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.Arrays;\n+import java.util.List;\n+import tech.pegasys.artemis.util.backing.CompositeViewWrite;\n+import tech.pegasys.artemis.util.backing.ContainerViewWrite;\n+import tech.pegasys.artemis.util.backing.ListViewWriteRef;\n+import tech.pegasys.artemis.util.backing.VectorViewWrite;\n+import tech.pegasys.artemis.util.backing.ViewRead;\n+import tech.pegasys.artemis.util.backing.tree.TreeNode;\n+import tech.pegasys.artemis.util.backing.type.BasicViewTypes;\n+import tech.pegasys.artemis.util.backing.type.ContainerViewType;\n+import tech.pegasys.artemis.util.backing.type.ListViewType;\n+import tech.pegasys.artemis.util.backing.type.VectorViewType;\n+import tech.pegasys.artemis.util.backing.view.BasicViews.UInt64View;\n+\n+public class ListViewImpl<R extends ViewRead, W extends R>\n+    extends AbstractCompositeViewWrite<ListViewImpl<R, W>, R> implements ListViewWriteRef<R, W> {\n+\n+  // TODO: temp workaround for the case\n+  // SLOTS_PER_ETH1_VOTING_PERIOD % SLOTS_PER_EPOCH != 0\n+  // see https://github.com/ethereum/eth2.0-specs/pull/1625\n+  public static boolean THROW_OUT_OF_BOUNDS = true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjUwOTAyMw=="}, "originalCommit": {"oid": "d4fc41d2f455ad3019095470229fa3cd5922d9c6"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5NDMwNTYxOnYy", "diffSide": "RIGHT", "path": "util/src/main/java/tech/pegasys/artemis/util/SSZTypes/SSZList.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxNjo0MTowM1rOFwmsTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxNDoxNzowNFrOFxHfeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjUwOTkwMw==", "bodyText": "(optional) Perhaps we should make it more explicit that these methods are creating mutable lists:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              static <T> SSZMutableList<T> create(Class<? extends T> classInfo, long maxSize) {\n          \n          \n            \n              static <T> SSZMutableList<T> createMutable(Class<? extends T> classInfo, long maxSize) {", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r386509903", "createdAt": "2020-03-02T16:41:03Z", "author": {"login": "mbaxter"}, "path": "util/src/main/java/tech/pegasys/artemis/util/SSZTypes/SSZList.java", "diffHunk": "@@ -13,48 +13,77 @@\n \n package tech.pegasys.artemis.util.SSZTypes;\n \n-import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n-import java.util.ArrayList;\n-import java.util.List;\n+import com.google.common.base.Preconditions;\n+import java.lang.reflect.Array;\n+import java.util.Collection;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n-@JsonSerialize(as = ArrayList.class)\n-public class SSZList<T> extends ArrayList<T> {\n+public interface SSZList<T> extends SSZImmutableCollection<T> {\n \n-  private long maxSize;\n-  private Class<T> classInfo;\n+  static <T> SSZMutableList<T> create(Class<? extends T> classInfo, long maxSize) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4fc41d2f455ad3019095470229fa3cd5922d9c6"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzA0NzI5MA==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r387047290", "createdAt": "2020-03-03T14:17:04Z", "author": {"login": "Nashatyrev"}, "path": "util/src/main/java/tech/pegasys/artemis/util/SSZTypes/SSZList.java", "diffHunk": "@@ -13,48 +13,77 @@\n \n package tech.pegasys.artemis.util.SSZTypes;\n \n-import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n-import java.util.ArrayList;\n-import java.util.List;\n+import com.google.common.base.Preconditions;\n+import java.lang.reflect.Array;\n+import java.util.Collection;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n \n-@JsonSerialize(as = ArrayList.class)\n-public class SSZList<T> extends ArrayList<T> {\n+public interface SSZList<T> extends SSZImmutableCollection<T> {\n \n-  private long maxSize;\n-  private Class<T> classInfo;\n+  static <T> SSZMutableList<T> create(Class<? extends T> classInfo, long maxSize) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjUwOTkwMw=="}, "originalCommit": {"oid": "d4fc41d2f455ad3019095470229fa3cd5922d9c6"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5NDQyNzYwOnYy", "diffSide": "RIGHT", "path": "util/src/main/java/tech/pegasys/artemis/util/backing/ListViewRead.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxNzoxMjozM1rOFwn3MQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxNDozNDowNFrOFxIMYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjUyOTA3Mw==", "bodyText": "Why can't we make writeable copies of lists?", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r386529073", "createdAt": "2020-03-02T17:12:33Z", "author": {"login": "mbaxter"}, "path": "util/src/main/java/tech/pegasys/artemis/util/backing/ListViewRead.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.util.backing;\n+\n+import tech.pegasys.artemis.util.backing.type.ListViewType;\n+\n+/**\n+ * Immutable List view\n+ *\n+ * @param <R> Type of list elements\n+ */\n+public interface ListViewRead<R extends ViewRead> extends CompositeViewRead<R> {\n+\n+  @Override\n+  default ListViewWrite<R> createWritableCopy() {\n+    throw new UnsupportedOperationException();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4fc41d2f455ad3019095470229fa3cd5922d9c6"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzA1ODc4Nw==", "bodyText": "\ud83d\udc4d Was just development artifacts", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r387058787", "createdAt": "2020-03-03T14:34:04Z", "author": {"login": "Nashatyrev"}, "path": "util/src/main/java/tech/pegasys/artemis/util/backing/ListViewRead.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.util.backing;\n+\n+import tech.pegasys.artemis.util.backing.type.ListViewType;\n+\n+/**\n+ * Immutable List view\n+ *\n+ * @param <R> Type of list elements\n+ */\n+public interface ListViewRead<R extends ViewRead> extends CompositeViewRead<R> {\n+\n+  @Override\n+  default ListViewWrite<R> createWritableCopy() {\n+    throw new UnsupportedOperationException();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjUyOTA3Mw=="}, "originalCommit": {"oid": "d4fc41d2f455ad3019095470229fa3cd5922d9c6"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5NDQ4MDE4OnYy", "diffSide": "RIGHT", "path": "util/src/main/java/tech/pegasys/artemis/util/backing/tree/TreeNode.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxNzoyODoyMlrOFwoX3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxNzozNjoyNFrOFxPu9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjUzNzQzOA==", "bodyText": "I find the naming of these types a bit confusing.  What about:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              interface Root extends TreeNode {\n          \n          \n            \n              interface LeafNode extends TreeNode {", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r386537438", "createdAt": "2020-03-02T17:28:22Z", "author": {"login": "mbaxter"}, "path": "util/src/main/java/tech/pegasys/artemis/util/backing/tree/TreeNode.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.util.backing.tree;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+\n+import java.util.function.Function;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.apache.tuweni.crypto.Hash;\n+import org.jetbrains.annotations.NotNull;\n+import tech.pegasys.artemis.util.backing.tree.TreeNodeImpl.RootImpl;\n+\n+/**\n+ * Basic interface for Backing Tree node Backing Binary Tree concept for SSZ structures is described\n+ * here: https://github.com/protolambda/eth-merkle-trees/blob/master/typing_partials.md#tree\n+ *\n+ * <p>Tree node is immutable by design. Any update on a tree creates new nodes which refer both new\n+ * data nodes and old unmodified nodes\n+ */\n+public interface TreeNode {\n+\n+  static TreeNode createRoot(Bytes32 val) {\n+    return new RootImpl(val);\n+  }\n+\n+  /** Leaf node of a tree which contains 'bytes32' value */\n+  interface Root extends TreeNode {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4fc41d2f455ad3019095470229fa3cd5922d9c6"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzEyMDc0NA==", "bodyText": "I'm also not too comfortable with Root and Commit terms, but this is exactly how they are defined in the spec: https://github.com/protolambda/eth-merkle-trees/blob/master/typing_partials.md#structure\nI would prefer to stick with spec to avoid confusion, since the javadoc refers to this spec in several places.", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r387120744", "createdAt": "2020-03-03T16:01:37Z", "author": {"login": "Nashatyrev"}, "path": "util/src/main/java/tech/pegasys/artemis/util/backing/tree/TreeNode.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.util.backing.tree;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+\n+import java.util.function.Function;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.apache.tuweni.crypto.Hash;\n+import org.jetbrains.annotations.NotNull;\n+import tech.pegasys.artemis.util.backing.tree.TreeNodeImpl.RootImpl;\n+\n+/**\n+ * Basic interface for Backing Tree node Backing Binary Tree concept for SSZ structures is described\n+ * here: https://github.com/protolambda/eth-merkle-trees/blob/master/typing_partials.md#tree\n+ *\n+ * <p>Tree node is immutable by design. Any update on a tree creates new nodes which refer both new\n+ * data nodes and old unmodified nodes\n+ */\n+public interface TreeNode {\n+\n+  static TreeNode createRoot(Bytes32 val) {\n+    return new RootImpl(val);\n+  }\n+\n+  /** Leaf node of a tree which contains 'bytes32' value */\n+  interface Root extends TreeNode {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjUzNzQzOA=="}, "originalCommit": {"oid": "d4fc41d2f455ad3019095470229fa3cd5922d9c6"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzEzMDg5Mw==", "bodyText": "I'd prefer clarifying the java names, and making a note that \"LeafNode\" corresponds to \"Root\" in the linked spec, etc.  But happy to leave the decision with you.", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r387130893", "createdAt": "2020-03-03T16:15:57Z", "author": {"login": "mbaxter"}, "path": "util/src/main/java/tech/pegasys/artemis/util/backing/tree/TreeNode.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.util.backing.tree;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+\n+import java.util.function.Function;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.apache.tuweni.crypto.Hash;\n+import org.jetbrains.annotations.NotNull;\n+import tech.pegasys.artemis.util.backing.tree.TreeNodeImpl.RootImpl;\n+\n+/**\n+ * Basic interface for Backing Tree node Backing Binary Tree concept for SSZ structures is described\n+ * here: https://github.com/protolambda/eth-merkle-trees/blob/master/typing_partials.md#tree\n+ *\n+ * <p>Tree node is immutable by design. Any update on a tree creates new nodes which refer both new\n+ * data nodes and old unmodified nodes\n+ */\n+public interface TreeNode {\n+\n+  static TreeNode createRoot(Bytes32 val) {\n+    return new RootImpl(val);\n+  }\n+\n+  /** Leaf node of a tree which contains 'bytes32' value */\n+  interface Root extends TreeNode {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjUzNzQzOA=="}, "originalCommit": {"oid": "d4fc41d2f455ad3019095470229fa3cd5922d9c6"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE2NTUyNw==", "bodyText": "Let's rename them. I remember Root class name confused me a couple of times during development", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r387165527", "createdAt": "2020-03-03T17:06:50Z", "author": {"login": "Nashatyrev"}, "path": "util/src/main/java/tech/pegasys/artemis/util/backing/tree/TreeNode.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.util.backing.tree;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+\n+import java.util.function.Function;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.apache.tuweni.crypto.Hash;\n+import org.jetbrains.annotations.NotNull;\n+import tech.pegasys.artemis.util.backing.tree.TreeNodeImpl.RootImpl;\n+\n+/**\n+ * Basic interface for Backing Tree node Backing Binary Tree concept for SSZ structures is described\n+ * here: https://github.com/protolambda/eth-merkle-trees/blob/master/typing_partials.md#tree\n+ *\n+ * <p>Tree node is immutable by design. Any update on a tree creates new nodes which refer both new\n+ * data nodes and old unmodified nodes\n+ */\n+public interface TreeNode {\n+\n+  static TreeNode createRoot(Bytes32 val) {\n+    return new RootImpl(val);\n+  }\n+\n+  /** Leaf node of a tree which contains 'bytes32' value */\n+  interface Root extends TreeNode {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjUzNzQzOA=="}, "originalCommit": {"oid": "d4fc41d2f455ad3019095470229fa3cd5922d9c6"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE4MjMyNw==", "bodyText": "dc71008", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r387182327", "createdAt": "2020-03-03T17:36:24Z", "author": {"login": "Nashatyrev"}, "path": "util/src/main/java/tech/pegasys/artemis/util/backing/tree/TreeNode.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.util.backing.tree;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+\n+import java.util.function.Function;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.apache.tuweni.crypto.Hash;\n+import org.jetbrains.annotations.NotNull;\n+import tech.pegasys.artemis.util.backing.tree.TreeNodeImpl.RootImpl;\n+\n+/**\n+ * Basic interface for Backing Tree node Backing Binary Tree concept for SSZ structures is described\n+ * here: https://github.com/protolambda/eth-merkle-trees/blob/master/typing_partials.md#tree\n+ *\n+ * <p>Tree node is immutable by design. Any update on a tree creates new nodes which refer both new\n+ * data nodes and old unmodified nodes\n+ */\n+public interface TreeNode {\n+\n+  static TreeNode createRoot(Bytes32 val) {\n+    return new RootImpl(val);\n+  }\n+\n+  /** Leaf node of a tree which contains 'bytes32' value */\n+  interface Root extends TreeNode {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjUzNzQzOA=="}, "originalCommit": {"oid": "d4fc41d2f455ad3019095470229fa3cd5922d9c6"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5NDQ4MTkxOnYy", "diffSide": "RIGHT", "path": "util/src/main/java/tech/pegasys/artemis/util/backing/tree/TreeNode.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxNzoyODo1NVrOFwoZAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxNzoyNDoxMFrOFxPVmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjUzNzczMA==", "bodyText": "What do you think of:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              interface Commit extends TreeNode {\n          \n          \n            \n              interface InternalTreeNode extends TreeNode {", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r386537730", "createdAt": "2020-03-02T17:28:55Z", "author": {"login": "mbaxter"}, "path": "util/src/main/java/tech/pegasys/artemis/util/backing/tree/TreeNode.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.util.backing.tree;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+\n+import java.util.function.Function;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.apache.tuweni.crypto.Hash;\n+import org.jetbrains.annotations.NotNull;\n+import tech.pegasys.artemis.util.backing.tree.TreeNodeImpl.RootImpl;\n+\n+/**\n+ * Basic interface for Backing Tree node Backing Binary Tree concept for SSZ structures is described\n+ * here: https://github.com/protolambda/eth-merkle-trees/blob/master/typing_partials.md#tree\n+ *\n+ * <p>Tree node is immutable by design. Any update on a tree creates new nodes which refer both new\n+ * data nodes and old unmodified nodes\n+ */\n+public interface TreeNode {\n+\n+  static TreeNode createRoot(Bytes32 val) {\n+    return new RootImpl(val);\n+  }\n+\n+  /** Leaf node of a tree which contains 'bytes32' value */\n+  interface Root extends TreeNode {\n+\n+    /** Returns node value */\n+    Bytes32 getRoot();\n+\n+    @Override\n+    default Bytes32 hashTreeRoot() {\n+      return getRoot();\n+    }\n+\n+    /**\n+     * @param target generalized index. Should be equal to 1\n+     * @return this node if 'target' == 1\n+     * @throws IllegalArgumentException if 'target' != 1\n+     */\n+    @NotNull\n+    @Override\n+    default TreeNode get(long target) {\n+      checkArgument(target == 1, \"Invalid root index: %s\", target);\n+      return this;\n+    }\n+\n+    @Override\n+    default TreeNode update(long target, Function<TreeNode, TreeNode> nodeUpdater) {\n+      checkArgument(target == 1, \"Invalid root index: %s\", target);\n+      return nodeUpdater.apply(this);\n+    }\n+  }\n+\n+  /** Branch node of a tree */\n+  interface Commit extends TreeNode {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4fc41d2f455ad3019095470229fa3cd5922d9c6"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzEyMTE3OQ==", "bodyText": "(#1133 (comment))", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r387121179", "createdAt": "2020-03-03T16:02:16Z", "author": {"login": "Nashatyrev"}, "path": "util/src/main/java/tech/pegasys/artemis/util/backing/tree/TreeNode.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.util.backing.tree;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+\n+import java.util.function.Function;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.apache.tuweni.crypto.Hash;\n+import org.jetbrains.annotations.NotNull;\n+import tech.pegasys.artemis.util.backing.tree.TreeNodeImpl.RootImpl;\n+\n+/**\n+ * Basic interface for Backing Tree node Backing Binary Tree concept for SSZ structures is described\n+ * here: https://github.com/protolambda/eth-merkle-trees/blob/master/typing_partials.md#tree\n+ *\n+ * <p>Tree node is immutable by design. Any update on a tree creates new nodes which refer both new\n+ * data nodes and old unmodified nodes\n+ */\n+public interface TreeNode {\n+\n+  static TreeNode createRoot(Bytes32 val) {\n+    return new RootImpl(val);\n+  }\n+\n+  /** Leaf node of a tree which contains 'bytes32' value */\n+  interface Root extends TreeNode {\n+\n+    /** Returns node value */\n+    Bytes32 getRoot();\n+\n+    @Override\n+    default Bytes32 hashTreeRoot() {\n+      return getRoot();\n+    }\n+\n+    /**\n+     * @param target generalized index. Should be equal to 1\n+     * @return this node if 'target' == 1\n+     * @throws IllegalArgumentException if 'target' != 1\n+     */\n+    @NotNull\n+    @Override\n+    default TreeNode get(long target) {\n+      checkArgument(target == 1, \"Invalid root index: %s\", target);\n+      return this;\n+    }\n+\n+    @Override\n+    default TreeNode update(long target, Function<TreeNode, TreeNode> nodeUpdater) {\n+      checkArgument(target == 1, \"Invalid root index: %s\", target);\n+      return nodeUpdater.apply(this);\n+    }\n+  }\n+\n+  /** Branch node of a tree */\n+  interface Commit extends TreeNode {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjUzNzczMA=="}, "originalCommit": {"oid": "d4fc41d2f455ad3019095470229fa3cd5922d9c6"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE2NDQ4Nw==", "bodyText": "@mbaxter then may be BranchNode would be better? That sounds to me as more widespread term", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r387164487", "createdAt": "2020-03-03T17:05:10Z", "author": {"login": "Nashatyrev"}, "path": "util/src/main/java/tech/pegasys/artemis/util/backing/tree/TreeNode.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.util.backing.tree;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+\n+import java.util.function.Function;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.apache.tuweni.crypto.Hash;\n+import org.jetbrains.annotations.NotNull;\n+import tech.pegasys.artemis.util.backing.tree.TreeNodeImpl.RootImpl;\n+\n+/**\n+ * Basic interface for Backing Tree node Backing Binary Tree concept for SSZ structures is described\n+ * here: https://github.com/protolambda/eth-merkle-trees/blob/master/typing_partials.md#tree\n+ *\n+ * <p>Tree node is immutable by design. Any update on a tree creates new nodes which refer both new\n+ * data nodes and old unmodified nodes\n+ */\n+public interface TreeNode {\n+\n+  static TreeNode createRoot(Bytes32 val) {\n+    return new RootImpl(val);\n+  }\n+\n+  /** Leaf node of a tree which contains 'bytes32' value */\n+  interface Root extends TreeNode {\n+\n+    /** Returns node value */\n+    Bytes32 getRoot();\n+\n+    @Override\n+    default Bytes32 hashTreeRoot() {\n+      return getRoot();\n+    }\n+\n+    /**\n+     * @param target generalized index. Should be equal to 1\n+     * @return this node if 'target' == 1\n+     * @throws IllegalArgumentException if 'target' != 1\n+     */\n+    @NotNull\n+    @Override\n+    default TreeNode get(long target) {\n+      checkArgument(target == 1, \"Invalid root index: %s\", target);\n+      return this;\n+    }\n+\n+    @Override\n+    default TreeNode update(long target, Function<TreeNode, TreeNode> nodeUpdater) {\n+      checkArgument(target == 1, \"Invalid root index: %s\", target);\n+      return nodeUpdater.apply(this);\n+    }\n+  }\n+\n+  /** Branch node of a tree */\n+  interface Commit extends TreeNode {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjUzNzczMA=="}, "originalCommit": {"oid": "d4fc41d2f455ad3019095470229fa3cd5922d9c6"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE3NTgzMw==", "bodyText": "sure - sounds good to me", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r387175833", "createdAt": "2020-03-03T17:24:10Z", "author": {"login": "mbaxter"}, "path": "util/src/main/java/tech/pegasys/artemis/util/backing/tree/TreeNode.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.util.backing.tree;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+\n+import java.util.function.Function;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.apache.tuweni.crypto.Hash;\n+import org.jetbrains.annotations.NotNull;\n+import tech.pegasys.artemis.util.backing.tree.TreeNodeImpl.RootImpl;\n+\n+/**\n+ * Basic interface for Backing Tree node Backing Binary Tree concept for SSZ structures is described\n+ * here: https://github.com/protolambda/eth-merkle-trees/blob/master/typing_partials.md#tree\n+ *\n+ * <p>Tree node is immutable by design. Any update on a tree creates new nodes which refer both new\n+ * data nodes and old unmodified nodes\n+ */\n+public interface TreeNode {\n+\n+  static TreeNode createRoot(Bytes32 val) {\n+    return new RootImpl(val);\n+  }\n+\n+  /** Leaf node of a tree which contains 'bytes32' value */\n+  interface Root extends TreeNode {\n+\n+    /** Returns node value */\n+    Bytes32 getRoot();\n+\n+    @Override\n+    default Bytes32 hashTreeRoot() {\n+      return getRoot();\n+    }\n+\n+    /**\n+     * @param target generalized index. Should be equal to 1\n+     * @return this node if 'target' == 1\n+     * @throws IllegalArgumentException if 'target' != 1\n+     */\n+    @NotNull\n+    @Override\n+    default TreeNode get(long target) {\n+      checkArgument(target == 1, \"Invalid root index: %s\", target);\n+      return this;\n+    }\n+\n+    @Override\n+    default TreeNode update(long target, Function<TreeNode, TreeNode> nodeUpdater) {\n+      checkArgument(target == 1, \"Invalid root index: %s\", target);\n+      return nodeUpdater.apply(this);\n+    }\n+  }\n+\n+  /** Branch node of a tree */\n+  interface Commit extends TreeNode {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjUzNzczMA=="}, "originalCommit": {"oid": "d4fc41d2f455ad3019095470229fa3cd5922d9c6"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5NDUwMjMyOnYy", "diffSide": "RIGHT", "path": "util/src/main/java/tech/pegasys/artemis/util/backing/tree/TreeUtil.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxNzozNDozNVrOFwolUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxNTo0NDo1MlrOFxLP1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjU0MDg4MQ==", "bodyText": "May be clearer with:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                return Long.bitCount(Utils.nextPowerOf2(maxChunks) - 1);\n          \n          \n            \n                return Long.highestOneBit(Utils.nextPowerOf2(maxChunks)) - 1;\n          \n      \n    \n    \n  \n\n??", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r386540881", "createdAt": "2020-03-02T17:34:35Z", "author": {"login": "mbaxter"}, "path": "util/src/main/java/tech/pegasys/artemis/util/backing/tree/TreeUtil.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.util.backing.tree;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+\n+import java.util.List;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.artemis.util.backing.Utils;\n+import tech.pegasys.artemis.util.backing.tree.TreeNode.Commit;\n+import tech.pegasys.artemis.util.backing.tree.TreeNode.Root;\n+import tech.pegasys.artemis.util.backing.tree.TreeNodeImpl.CommitImpl;\n+import tech.pegasys.artemis.util.backing.tree.TreeNodeImpl.RootImpl;\n+\n+/** Misc Backing binary tree utils */\n+public class TreeUtil {\n+\n+  public static final TreeNode ZERO_LEAF = new RootImpl(Bytes32.ZERO);\n+  private static final TreeNode[] ZERO_TREES;\n+\n+  static {\n+    ZERO_TREES = new TreeNode[64];\n+    ZERO_TREES[0] = ZERO_LEAF;\n+    for (int i = 1; i < ZERO_TREES.length; i++) {\n+      ZERO_TREES[i] = new CommitImpl(ZERO_TREES[i - 1], ZERO_TREES[i - 1]);\n+      ZERO_TREES[i].hashTreeRoot(); // pre-cache\n+    }\n+  }\n+\n+  /**\n+   * Creates a binary tree with `nextPowerOf2(maxLength)` width and following leaf nodes <code>\n+   * [zeroElement] * maxLength + [ZERO_LEAF] * (nextPowerOf2(maxLength) - maxLength)\n+   * </code>\n+   *\n+   * @param maxLength max number of leaf nodes\n+   * @param defaultNode default leaf element. For complex vectors it could be default vector element\n+   *     struct subtree\n+   */\n+  public static TreeNode createDefaultTree(long maxLength, TreeNode defaultNode) {\n+    return createTree(\n+        defaultNode, ZERO_LEAF.equals(defaultNode) ? 0 : maxLength, treeDepth(maxLength));\n+  }\n+\n+  /** Creates a binary tree of width `nextPowerOf2(leafNodes.size())` with specific leaf nodes */\n+  public static TreeNode createTree(List<TreeNode> leafNodes) {\n+    return createTree(leafNodes, treeDepth(leafNodes.size()));\n+  }\n+\n+  private static TreeNode createTree(TreeNode defaultNode, long defaultNodesCount, int depth) {\n+    if (defaultNodesCount == 0) {\n+      return ZERO_TREES[depth];\n+    } else if (depth == 0) {\n+      checkArgument(defaultNodesCount == 1);\n+      return defaultNode;\n+    } else {\n+      long leftNodesCount = Math.min(defaultNodesCount, 1 << (depth - 1));\n+      long rightNodesCount = defaultNodesCount - leftNodesCount;\n+      TreeNode lTree = createTree(defaultNode, leftNodesCount, depth - 1);\n+      TreeNode rTree =\n+          leftNodesCount == rightNodesCount\n+              ? lTree\n+              : createTree(defaultNode, rightNodesCount, depth - 1);\n+      return new CommitImpl(lTree, rTree);\n+    }\n+  }\n+\n+  private static TreeNode createTree(List<TreeNode> leafNodes, int depth) {\n+    if (leafNodes.isEmpty()) {\n+      return ZERO_TREES[depth];\n+    } else if (depth == 0) {\n+      checkArgument(leafNodes.size() == 1);\n+      return leafNodes.get(0);\n+    } else {\n+      long index = 1L << (depth - 1);\n+      int iIndex = index > leafNodes.size() ? leafNodes.size() : (int) index;\n+\n+      List<TreeNode> leftSublist = leafNodes.subList(0, iIndex);\n+      List<TreeNode> rightSublist = leafNodes.subList(iIndex, leafNodes.size());\n+      return new CommitImpl(\n+          createTree(leftSublist, depth - 1), createTree(rightSublist, depth - 1));\n+    }\n+  }\n+\n+  public static int treeDepth(long maxChunks) {\n+    return Long.bitCount(Utils.nextPowerOf2(maxChunks) - 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4fc41d2f455ad3019095470229fa3cd5922d9c6"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzA1NjExMQ==", "bodyText": "Hm, your variant definitelty doesn't calculate tree depth. Did you mean to write anything else ?", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r387056111", "createdAt": "2020-03-03T14:29:59Z", "author": {"login": "Nashatyrev"}, "path": "util/src/main/java/tech/pegasys/artemis/util/backing/tree/TreeUtil.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.util.backing.tree;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+\n+import java.util.List;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.artemis.util.backing.Utils;\n+import tech.pegasys.artemis.util.backing.tree.TreeNode.Commit;\n+import tech.pegasys.artemis.util.backing.tree.TreeNode.Root;\n+import tech.pegasys.artemis.util.backing.tree.TreeNodeImpl.CommitImpl;\n+import tech.pegasys.artemis.util.backing.tree.TreeNodeImpl.RootImpl;\n+\n+/** Misc Backing binary tree utils */\n+public class TreeUtil {\n+\n+  public static final TreeNode ZERO_LEAF = new RootImpl(Bytes32.ZERO);\n+  private static final TreeNode[] ZERO_TREES;\n+\n+  static {\n+    ZERO_TREES = new TreeNode[64];\n+    ZERO_TREES[0] = ZERO_LEAF;\n+    for (int i = 1; i < ZERO_TREES.length; i++) {\n+      ZERO_TREES[i] = new CommitImpl(ZERO_TREES[i - 1], ZERO_TREES[i - 1]);\n+      ZERO_TREES[i].hashTreeRoot(); // pre-cache\n+    }\n+  }\n+\n+  /**\n+   * Creates a binary tree with `nextPowerOf2(maxLength)` width and following leaf nodes <code>\n+   * [zeroElement] * maxLength + [ZERO_LEAF] * (nextPowerOf2(maxLength) - maxLength)\n+   * </code>\n+   *\n+   * @param maxLength max number of leaf nodes\n+   * @param defaultNode default leaf element. For complex vectors it could be default vector element\n+   *     struct subtree\n+   */\n+  public static TreeNode createDefaultTree(long maxLength, TreeNode defaultNode) {\n+    return createTree(\n+        defaultNode, ZERO_LEAF.equals(defaultNode) ? 0 : maxLength, treeDepth(maxLength));\n+  }\n+\n+  /** Creates a binary tree of width `nextPowerOf2(leafNodes.size())` with specific leaf nodes */\n+  public static TreeNode createTree(List<TreeNode> leafNodes) {\n+    return createTree(leafNodes, treeDepth(leafNodes.size()));\n+  }\n+\n+  private static TreeNode createTree(TreeNode defaultNode, long defaultNodesCount, int depth) {\n+    if (defaultNodesCount == 0) {\n+      return ZERO_TREES[depth];\n+    } else if (depth == 0) {\n+      checkArgument(defaultNodesCount == 1);\n+      return defaultNode;\n+    } else {\n+      long leftNodesCount = Math.min(defaultNodesCount, 1 << (depth - 1));\n+      long rightNodesCount = defaultNodesCount - leftNodesCount;\n+      TreeNode lTree = createTree(defaultNode, leftNodesCount, depth - 1);\n+      TreeNode rTree =\n+          leftNodesCount == rightNodesCount\n+              ? lTree\n+              : createTree(defaultNode, rightNodesCount, depth - 1);\n+      return new CommitImpl(lTree, rTree);\n+    }\n+  }\n+\n+  private static TreeNode createTree(List<TreeNode> leafNodes, int depth) {\n+    if (leafNodes.isEmpty()) {\n+      return ZERO_TREES[depth];\n+    } else if (depth == 0) {\n+      checkArgument(leafNodes.size() == 1);\n+      return leafNodes.get(0);\n+    } else {\n+      long index = 1L << (depth - 1);\n+      int iIndex = index > leafNodes.size() ? leafNodes.size() : (int) index;\n+\n+      List<TreeNode> leftSublist = leafNodes.subList(0, iIndex);\n+      List<TreeNode> rightSublist = leafNodes.subList(iIndex, leafNodes.size());\n+      return new CommitImpl(\n+          createTree(leftSublist, depth - 1), createTree(rightSublist, depth - 1));\n+    }\n+  }\n+\n+  public static int treeDepth(long maxChunks) {\n+    return Long.bitCount(Utils.nextPowerOf2(maxChunks) - 1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjU0MDg4MQ=="}, "originalCommit": {"oid": "d4fc41d2f455ad3019095470229fa3cd5922d9c6"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzEwODgyMQ==", "bodyText": "nm - thought highestOneBit gave us the index of the highest bit", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r387108821", "createdAt": "2020-03-03T15:44:52Z", "author": {"login": "mbaxter"}, "path": "util/src/main/java/tech/pegasys/artemis/util/backing/tree/TreeUtil.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.util.backing.tree;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+\n+import java.util.List;\n+import org.apache.tuweni.bytes.Bytes32;\n+import tech.pegasys.artemis.util.backing.Utils;\n+import tech.pegasys.artemis.util.backing.tree.TreeNode.Commit;\n+import tech.pegasys.artemis.util.backing.tree.TreeNode.Root;\n+import tech.pegasys.artemis.util.backing.tree.TreeNodeImpl.CommitImpl;\n+import tech.pegasys.artemis.util.backing.tree.TreeNodeImpl.RootImpl;\n+\n+/** Misc Backing binary tree utils */\n+public class TreeUtil {\n+\n+  public static final TreeNode ZERO_LEAF = new RootImpl(Bytes32.ZERO);\n+  private static final TreeNode[] ZERO_TREES;\n+\n+  static {\n+    ZERO_TREES = new TreeNode[64];\n+    ZERO_TREES[0] = ZERO_LEAF;\n+    for (int i = 1; i < ZERO_TREES.length; i++) {\n+      ZERO_TREES[i] = new CommitImpl(ZERO_TREES[i - 1], ZERO_TREES[i - 1]);\n+      ZERO_TREES[i].hashTreeRoot(); // pre-cache\n+    }\n+  }\n+\n+  /**\n+   * Creates a binary tree with `nextPowerOf2(maxLength)` width and following leaf nodes <code>\n+   * [zeroElement] * maxLength + [ZERO_LEAF] * (nextPowerOf2(maxLength) - maxLength)\n+   * </code>\n+   *\n+   * @param maxLength max number of leaf nodes\n+   * @param defaultNode default leaf element. For complex vectors it could be default vector element\n+   *     struct subtree\n+   */\n+  public static TreeNode createDefaultTree(long maxLength, TreeNode defaultNode) {\n+    return createTree(\n+        defaultNode, ZERO_LEAF.equals(defaultNode) ? 0 : maxLength, treeDepth(maxLength));\n+  }\n+\n+  /** Creates a binary tree of width `nextPowerOf2(leafNodes.size())` with specific leaf nodes */\n+  public static TreeNode createTree(List<TreeNode> leafNodes) {\n+    return createTree(leafNodes, treeDepth(leafNodes.size()));\n+  }\n+\n+  private static TreeNode createTree(TreeNode defaultNode, long defaultNodesCount, int depth) {\n+    if (defaultNodesCount == 0) {\n+      return ZERO_TREES[depth];\n+    } else if (depth == 0) {\n+      checkArgument(defaultNodesCount == 1);\n+      return defaultNode;\n+    } else {\n+      long leftNodesCount = Math.min(defaultNodesCount, 1 << (depth - 1));\n+      long rightNodesCount = defaultNodesCount - leftNodesCount;\n+      TreeNode lTree = createTree(defaultNode, leftNodesCount, depth - 1);\n+      TreeNode rTree =\n+          leftNodesCount == rightNodesCount\n+              ? lTree\n+              : createTree(defaultNode, rightNodesCount, depth - 1);\n+      return new CommitImpl(lTree, rTree);\n+    }\n+  }\n+\n+  private static TreeNode createTree(List<TreeNode> leafNodes, int depth) {\n+    if (leafNodes.isEmpty()) {\n+      return ZERO_TREES[depth];\n+    } else if (depth == 0) {\n+      checkArgument(leafNodes.size() == 1);\n+      return leafNodes.get(0);\n+    } else {\n+      long index = 1L << (depth - 1);\n+      int iIndex = index > leafNodes.size() ? leafNodes.size() : (int) index;\n+\n+      List<TreeNode> leftSublist = leafNodes.subList(0, iIndex);\n+      List<TreeNode> rightSublist = leafNodes.subList(iIndex, leafNodes.size());\n+      return new CommitImpl(\n+          createTree(leftSublist, depth - 1), createTree(rightSublist, depth - 1));\n+    }\n+  }\n+\n+  public static int treeDepth(long maxChunks) {\n+    return Long.bitCount(Utils.nextPowerOf2(maxChunks) - 1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjU0MDg4MQ=="}, "originalCommit": {"oid": "d4fc41d2f455ad3019095470229fa3cd5922d9c6"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5NDU1Mjg3OnYy", "diffSide": "RIGHT", "path": "util/src/main/java/tech/pegasys/artemis/util/backing/BasicView.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxNzo0OTozMlrOFwpEJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QxNDoyMjoyOFrOFxHtjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjU0ODc3NQ==", "bodyText": "(optional) Not sure how much of a headache it would be to move this package, but I think we should avoid dropping big libraries into util and instead try to make independent packages:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            package tech.pegasys.artemis.util.backing;\n          \n          \n            \n            package tech.pegasys.artemis.backingtree;", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r386548775", "createdAt": "2020-03-02T17:49:32Z", "author": {"login": "mbaxter"}, "path": "util/src/main/java/tech/pegasys/artemis/util/backing/BasicView.java", "diffHunk": "@@ -0,0 +1,21 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.util.backing;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4fc41d2f455ad3019095470229fa3cd5922d9c6"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzA1MDg5NQ==", "bodyText": "I'm thinking about merging backing and SSZTypes packages and then we can probably create a distinct sub-module for all the ssz related stuff. Let's consider this option for the subsequent refactor?", "url": "https://github.com/ConsenSys/teku/pull/1133#discussion_r387050895", "createdAt": "2020-03-03T14:22:28Z", "author": {"login": "Nashatyrev"}, "path": "util/src/main/java/tech/pegasys/artemis/util/backing/BasicView.java", "diffHunk": "@@ -0,0 +1,21 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.util.backing;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjU0ODc3NQ=="}, "originalCommit": {"oid": "d4fc41d2f455ad3019095470229fa3cd5922d9c6"}, "originalPosition": 14}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2838, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}