{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc5OTE5MDI1", "number": 1228, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwMDo1MDoyNFrODi6DsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxOTozNjo1M1rODjNj0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3OTI5MzkzOnYy", "diffSide": "RIGHT", "path": "pow/src/main/java/tech/pegasys/artemis/pow/Eth1MinGenesisTimeBlockFinder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwMDo1MDoyNFrOFuatnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNjo1ODo0NFrOFuz9hA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIxNjQ3Nw==", "bodyText": "compare doesn't have to return 1, 0 or -1 just anything positive or negative so we need to either use a signum kind of function or an if to check for < 0 & > 0 rather than 1 and -1 specifically.", "url": "https://github.com/ConsenSys/teku/pull/1228#discussion_r384216477", "createdAt": "2020-02-26T00:50:24Z", "author": {"login": "ajsutton"}, "path": "pow/src/main/java/tech/pegasys/artemis/pow/Eth1MinGenesisTimeBlockFinder.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import io.reactivex.disposables.Disposable;\n+import java.math.BigInteger;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.api.MinGenesisTimeBlockEventChannel;\n+import tech.pegasys.artemis.pow.event.MinGenesisTimeBlockEvent;\n+import tech.pegasys.artemis.util.async.AsyncRunner;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class Eth1MinGenesisTimeBlockFinder {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final Eth1Provider eth1Provider;\n+  private final MinGenesisTimeBlockEventChannel minGenesisTimeBlockEventChannel;\n+  private final AsyncRunner asyncRunner;\n+\n+  private volatile Disposable latestBlockDisposable;\n+\n+  public Eth1MinGenesisTimeBlockFinder(\n+      Eth1Provider eth1Provider,\n+      MinGenesisTimeBlockEventChannel minGenesisTimeBlockEventChannel,\n+      AsyncRunner asyncRunner) {\n+    this.eth1Provider = eth1Provider;\n+    this.minGenesisTimeBlockEventChannel = minGenesisTimeBlockEventChannel;\n+    this.asyncRunner = asyncRunner;\n+  }\n+\n+  public void start() {\n+    findAndPublishFirstValidBlock()\n+        .finish(\n+            () ->\n+                LOG.info(\n+                    \"Eth1MinGenesisBlockFinder successfully found first \"\n+                        + \"(time) valid genesis block\"));\n+  }\n+\n+  public SafeFuture<Void> findAndPublishFirstValidBlock() {\n+    return eth1Provider\n+        .getLatestEth1BlockFuture()\n+        .thenApply(EthBlock.Block::getNumber)\n+        .thenApply(number -> number.subtract(Constants.ETH1_FOLLOW_DISTANCE.bigIntegerValue()))\n+        .thenApply(UnsignedLong::valueOf)\n+        .thenCompose(eth1Provider::getEth1BlockFuture)\n+        .thenCompose(\n+            block -> {\n+              SafeFuture<EthBlock.Block> firstValidBlockFuture;\n+              switch (compareBlockTimestampToMinGenesisTime(block)) {\n+                case 1:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "061392c0279932768bc51cc872347b2c2f3940c3"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDYzMDE0OA==", "bodyText": "done.", "url": "https://github.com/ConsenSys/teku/pull/1228#discussion_r384630148", "createdAt": "2020-02-26T16:58:44Z", "author": {"login": "cemozerr"}, "path": "pow/src/main/java/tech/pegasys/artemis/pow/Eth1MinGenesisTimeBlockFinder.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import io.reactivex.disposables.Disposable;\n+import java.math.BigInteger;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.api.MinGenesisTimeBlockEventChannel;\n+import tech.pegasys.artemis.pow.event.MinGenesisTimeBlockEvent;\n+import tech.pegasys.artemis.util.async.AsyncRunner;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class Eth1MinGenesisTimeBlockFinder {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final Eth1Provider eth1Provider;\n+  private final MinGenesisTimeBlockEventChannel minGenesisTimeBlockEventChannel;\n+  private final AsyncRunner asyncRunner;\n+\n+  private volatile Disposable latestBlockDisposable;\n+\n+  public Eth1MinGenesisTimeBlockFinder(\n+      Eth1Provider eth1Provider,\n+      MinGenesisTimeBlockEventChannel minGenesisTimeBlockEventChannel,\n+      AsyncRunner asyncRunner) {\n+    this.eth1Provider = eth1Provider;\n+    this.minGenesisTimeBlockEventChannel = minGenesisTimeBlockEventChannel;\n+    this.asyncRunner = asyncRunner;\n+  }\n+\n+  public void start() {\n+    findAndPublishFirstValidBlock()\n+        .finish(\n+            () ->\n+                LOG.info(\n+                    \"Eth1MinGenesisBlockFinder successfully found first \"\n+                        + \"(time) valid genesis block\"));\n+  }\n+\n+  public SafeFuture<Void> findAndPublishFirstValidBlock() {\n+    return eth1Provider\n+        .getLatestEth1BlockFuture()\n+        .thenApply(EthBlock.Block::getNumber)\n+        .thenApply(number -> number.subtract(Constants.ETH1_FOLLOW_DISTANCE.bigIntegerValue()))\n+        .thenApply(UnsignedLong::valueOf)\n+        .thenCompose(eth1Provider::getEth1BlockFuture)\n+        .thenCompose(\n+            block -> {\n+              SafeFuture<EthBlock.Block> firstValidBlockFuture;\n+              switch (compareBlockTimestampToMinGenesisTime(block)) {\n+                case 1:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIxNjQ3Nw=="}, "originalCommit": {"oid": "061392c0279932768bc51cc872347b2c2f3940c3"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3OTMwMDM5OnYy", "diffSide": "RIGHT", "path": "pow/src/main/java/tech/pegasys/artemis/pow/Eth1MinGenesisTimeBlockFinder.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwMDo1MzoxOVrOFuaxZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNzowOToyMlrOFu0Wvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIxNzQ0NA==", "bodyText": "nit: just return exploreBlocksDownwards(block)", "url": "https://github.com/ConsenSys/teku/pull/1228#discussion_r384217444", "createdAt": "2020-02-26T00:53:19Z", "author": {"login": "ajsutton"}, "path": "pow/src/main/java/tech/pegasys/artemis/pow/Eth1MinGenesisTimeBlockFinder.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import io.reactivex.disposables.Disposable;\n+import java.math.BigInteger;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.api.MinGenesisTimeBlockEventChannel;\n+import tech.pegasys.artemis.pow.event.MinGenesisTimeBlockEvent;\n+import tech.pegasys.artemis.util.async.AsyncRunner;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class Eth1MinGenesisTimeBlockFinder {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final Eth1Provider eth1Provider;\n+  private final MinGenesisTimeBlockEventChannel minGenesisTimeBlockEventChannel;\n+  private final AsyncRunner asyncRunner;\n+\n+  private volatile Disposable latestBlockDisposable;\n+\n+  public Eth1MinGenesisTimeBlockFinder(\n+      Eth1Provider eth1Provider,\n+      MinGenesisTimeBlockEventChannel minGenesisTimeBlockEventChannel,\n+      AsyncRunner asyncRunner) {\n+    this.eth1Provider = eth1Provider;\n+    this.minGenesisTimeBlockEventChannel = minGenesisTimeBlockEventChannel;\n+    this.asyncRunner = asyncRunner;\n+  }\n+\n+  public void start() {\n+    findAndPublishFirstValidBlock()\n+        .finish(\n+            () ->\n+                LOG.info(\n+                    \"Eth1MinGenesisBlockFinder successfully found first \"\n+                        + \"(time) valid genesis block\"));\n+  }\n+\n+  public SafeFuture<Void> findAndPublishFirstValidBlock() {\n+    return eth1Provider\n+        .getLatestEth1BlockFuture()\n+        .thenApply(EthBlock.Block::getNumber)\n+        .thenApply(number -> number.subtract(Constants.ETH1_FOLLOW_DISTANCE.bigIntegerValue()))\n+        .thenApply(UnsignedLong::valueOf)\n+        .thenCompose(eth1Provider::getEth1BlockFuture)\n+        .thenCompose(\n+            block -> {\n+              SafeFuture<EthBlock.Block> firstValidBlockFuture;\n+              switch (compareBlockTimestampToMinGenesisTime(block)) {\n+                case 1:\n+                  // If block timestamp is greater than min genesis time\n+                  // find first valid block in history\n+                  firstValidBlockFuture = findFirstValidBlockInHistory(block);\n+                  break;\n+                case 0:\n+                  firstValidBlockFuture = SafeFuture.completedFuture(block);\n+                  break;\n+                case -1:\n+                  // If block timestamp is less than min genesis time\n+                  // subscribe to new block events and wait for the first\n+                  // valid block\n+                  firstValidBlockFuture = waitForFirstValidBlock();\n+                  break;\n+                default:\n+                  throw new IllegalStateException(\n+                      \"Unexpected value: \"\n+                          + calculateCandidateGenesisTimestamp(block.getTimestamp())\n+                              .compareTo(Constants.MIN_GENESIS_TIME));\n+              }\n+              return firstValidBlockFuture;\n+            })\n+        .thenAccept(this::publishFirstValidBlock)\n+        .exceptionallyCompose(\n+            err -> {\n+              LOG.debug(\n+                  \"Eth1MinGenesisTimeBlockFinder failed to find first valid block. Retry in \"\n+                      + Constants.ETH1_MIN_GENESIS_TIME_BLOCK_RETRY_TIMEOUT\n+                      + \" seconds\",\n+                  err);\n+\n+              return asyncRunner.runAfterDelay(\n+                  this::findAndPublishFirstValidBlock,\n+                  Constants.ETH1_MIN_GENESIS_TIME_BLOCK_RETRY_TIMEOUT,\n+                  TimeUnit.SECONDS);\n+            });\n+  }\n+\n+  private void publishFirstValidBlock(EthBlock.Block block) {\n+    minGenesisTimeBlockEventChannel.onMinGenesisTimeBlock(\n+        new MinGenesisTimeBlockEvent(\n+            UnsignedLong.valueOf(block.getTimestamp()),\n+            UnsignedLong.valueOf(block.getNumber()),\n+            Bytes32.fromHexString(block.getHash())));\n+  }\n+\n+  /**\n+   * Find first estimationBlock that has timestamp that is greater than MIN_GENESIS_TIME\n+   *\n+   * @param estimationBlock estimationBlock that will be used for estimation\n+   * @return first valid block in history\n+   */\n+  private SafeFuture<EthBlock.Block> findFirstValidBlockInHistory(EthBlock.Block estimationBlock) {\n+    UnsignedLong estimatedFirstValidBlockNumber =\n+        getEstimatedFirstValidBlockNumber(estimationBlock, Constants.SECONDS_PER_ETH1_BLOCK);\n+    return eth1Provider\n+        .getEth1BlockFuture(estimatedFirstValidBlockNumber)\n+        .thenCompose(\n+            block -> {\n+              SafeFuture<EthBlock.Block> firstValidBlock;\n+              switch (compareBlockTimestampToMinGenesisTime(block)) {\n+                case 1:\n+                  // If block timestamp is greater than min genesis time\n+                  // explore blocks downwards\n+                  firstValidBlock = exploreBlocksDownwards(block);\n+                  break;\n+                case 0:\n+                  firstValidBlock = SafeFuture.completedFuture(block);\n+                  break;\n+                case -1:\n+                  // If block timestamp is less than min genesis time\n+                  // explore blocks upwards\n+                  firstValidBlock = exploreBlocksUpwards(block);\n+                  break;\n+                default:\n+                  throw new IllegalStateException(\n+                      \"Unexpected value: \"\n+                          + calculateCandidateGenesisTimestamp(block.getTimestamp())\n+                              .compareTo(Constants.MIN_GENESIS_TIME));\n+              }\n+              return firstValidBlock;\n+            });\n+  }\n+\n+  private SafeFuture<EthBlock.Block> exploreBlocksDownwards(EthBlock.Block previousBlock) {\n+    UnsignedLong previousBlockNumber = UnsignedLong.valueOf(previousBlock.getNumber());\n+    UnsignedLong newBlockNumber = previousBlockNumber.minus(UnsignedLong.ONE);\n+    SafeFuture<EthBlock.Block> blockFuture = eth1Provider.getEth1BlockFuture(newBlockNumber);\n+    return blockFuture.thenCompose(\n+        block -> {\n+          SafeFuture<EthBlock.Block> firstValidBlock;\n+          switch (compareBlockTimestampToMinGenesisTime(block)) {\n+            case 1:\n+              // If exploring downwards and block timestamp > min genesis time,\n+              // then block must still be downwards.\n+              firstValidBlock = exploreBlocksDownwards(block);\n+              break;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "061392c0279932768bc51cc872347b2c2f3940c3"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDYyMTc5NQ==", "bodyText": "3 return statements just looked ugly so I did this, but I can change it.", "url": "https://github.com/ConsenSys/teku/pull/1228#discussion_r384621795", "createdAt": "2020-02-26T16:45:53Z", "author": {"login": "cemozerr"}, "path": "pow/src/main/java/tech/pegasys/artemis/pow/Eth1MinGenesisTimeBlockFinder.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import io.reactivex.disposables.Disposable;\n+import java.math.BigInteger;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.api.MinGenesisTimeBlockEventChannel;\n+import tech.pegasys.artemis.pow.event.MinGenesisTimeBlockEvent;\n+import tech.pegasys.artemis.util.async.AsyncRunner;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class Eth1MinGenesisTimeBlockFinder {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final Eth1Provider eth1Provider;\n+  private final MinGenesisTimeBlockEventChannel minGenesisTimeBlockEventChannel;\n+  private final AsyncRunner asyncRunner;\n+\n+  private volatile Disposable latestBlockDisposable;\n+\n+  public Eth1MinGenesisTimeBlockFinder(\n+      Eth1Provider eth1Provider,\n+      MinGenesisTimeBlockEventChannel minGenesisTimeBlockEventChannel,\n+      AsyncRunner asyncRunner) {\n+    this.eth1Provider = eth1Provider;\n+    this.minGenesisTimeBlockEventChannel = minGenesisTimeBlockEventChannel;\n+    this.asyncRunner = asyncRunner;\n+  }\n+\n+  public void start() {\n+    findAndPublishFirstValidBlock()\n+        .finish(\n+            () ->\n+                LOG.info(\n+                    \"Eth1MinGenesisBlockFinder successfully found first \"\n+                        + \"(time) valid genesis block\"));\n+  }\n+\n+  public SafeFuture<Void> findAndPublishFirstValidBlock() {\n+    return eth1Provider\n+        .getLatestEth1BlockFuture()\n+        .thenApply(EthBlock.Block::getNumber)\n+        .thenApply(number -> number.subtract(Constants.ETH1_FOLLOW_DISTANCE.bigIntegerValue()))\n+        .thenApply(UnsignedLong::valueOf)\n+        .thenCompose(eth1Provider::getEth1BlockFuture)\n+        .thenCompose(\n+            block -> {\n+              SafeFuture<EthBlock.Block> firstValidBlockFuture;\n+              switch (compareBlockTimestampToMinGenesisTime(block)) {\n+                case 1:\n+                  // If block timestamp is greater than min genesis time\n+                  // find first valid block in history\n+                  firstValidBlockFuture = findFirstValidBlockInHistory(block);\n+                  break;\n+                case 0:\n+                  firstValidBlockFuture = SafeFuture.completedFuture(block);\n+                  break;\n+                case -1:\n+                  // If block timestamp is less than min genesis time\n+                  // subscribe to new block events and wait for the first\n+                  // valid block\n+                  firstValidBlockFuture = waitForFirstValidBlock();\n+                  break;\n+                default:\n+                  throw new IllegalStateException(\n+                      \"Unexpected value: \"\n+                          + calculateCandidateGenesisTimestamp(block.getTimestamp())\n+                              .compareTo(Constants.MIN_GENESIS_TIME));\n+              }\n+              return firstValidBlockFuture;\n+            })\n+        .thenAccept(this::publishFirstValidBlock)\n+        .exceptionallyCompose(\n+            err -> {\n+              LOG.debug(\n+                  \"Eth1MinGenesisTimeBlockFinder failed to find first valid block. Retry in \"\n+                      + Constants.ETH1_MIN_GENESIS_TIME_BLOCK_RETRY_TIMEOUT\n+                      + \" seconds\",\n+                  err);\n+\n+              return asyncRunner.runAfterDelay(\n+                  this::findAndPublishFirstValidBlock,\n+                  Constants.ETH1_MIN_GENESIS_TIME_BLOCK_RETRY_TIMEOUT,\n+                  TimeUnit.SECONDS);\n+            });\n+  }\n+\n+  private void publishFirstValidBlock(EthBlock.Block block) {\n+    minGenesisTimeBlockEventChannel.onMinGenesisTimeBlock(\n+        new MinGenesisTimeBlockEvent(\n+            UnsignedLong.valueOf(block.getTimestamp()),\n+            UnsignedLong.valueOf(block.getNumber()),\n+            Bytes32.fromHexString(block.getHash())));\n+  }\n+\n+  /**\n+   * Find first estimationBlock that has timestamp that is greater than MIN_GENESIS_TIME\n+   *\n+   * @param estimationBlock estimationBlock that will be used for estimation\n+   * @return first valid block in history\n+   */\n+  private SafeFuture<EthBlock.Block> findFirstValidBlockInHistory(EthBlock.Block estimationBlock) {\n+    UnsignedLong estimatedFirstValidBlockNumber =\n+        getEstimatedFirstValidBlockNumber(estimationBlock, Constants.SECONDS_PER_ETH1_BLOCK);\n+    return eth1Provider\n+        .getEth1BlockFuture(estimatedFirstValidBlockNumber)\n+        .thenCompose(\n+            block -> {\n+              SafeFuture<EthBlock.Block> firstValidBlock;\n+              switch (compareBlockTimestampToMinGenesisTime(block)) {\n+                case 1:\n+                  // If block timestamp is greater than min genesis time\n+                  // explore blocks downwards\n+                  firstValidBlock = exploreBlocksDownwards(block);\n+                  break;\n+                case 0:\n+                  firstValidBlock = SafeFuture.completedFuture(block);\n+                  break;\n+                case -1:\n+                  // If block timestamp is less than min genesis time\n+                  // explore blocks upwards\n+                  firstValidBlock = exploreBlocksUpwards(block);\n+                  break;\n+                default:\n+                  throw new IllegalStateException(\n+                      \"Unexpected value: \"\n+                          + calculateCandidateGenesisTimestamp(block.getTimestamp())\n+                              .compareTo(Constants.MIN_GENESIS_TIME));\n+              }\n+              return firstValidBlock;\n+            });\n+  }\n+\n+  private SafeFuture<EthBlock.Block> exploreBlocksDownwards(EthBlock.Block previousBlock) {\n+    UnsignedLong previousBlockNumber = UnsignedLong.valueOf(previousBlock.getNumber());\n+    UnsignedLong newBlockNumber = previousBlockNumber.minus(UnsignedLong.ONE);\n+    SafeFuture<EthBlock.Block> blockFuture = eth1Provider.getEth1BlockFuture(newBlockNumber);\n+    return blockFuture.thenCompose(\n+        block -> {\n+          SafeFuture<EthBlock.Block> firstValidBlock;\n+          switch (compareBlockTimestampToMinGenesisTime(block)) {\n+            case 1:\n+              // If exploring downwards and block timestamp > min genesis time,\n+              // then block must still be downwards.\n+              firstValidBlock = exploreBlocksDownwards(block);\n+              break;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIxNzQ0NA=="}, "originalCommit": {"oid": "061392c0279932768bc51cc872347b2c2f3940c3"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDYzNjYwNg==", "bodyText": "done.", "url": "https://github.com/ConsenSys/teku/pull/1228#discussion_r384636606", "createdAt": "2020-02-26T17:09:22Z", "author": {"login": "cemozerr"}, "path": "pow/src/main/java/tech/pegasys/artemis/pow/Eth1MinGenesisTimeBlockFinder.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import io.reactivex.disposables.Disposable;\n+import java.math.BigInteger;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.api.MinGenesisTimeBlockEventChannel;\n+import tech.pegasys.artemis.pow.event.MinGenesisTimeBlockEvent;\n+import tech.pegasys.artemis.util.async.AsyncRunner;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class Eth1MinGenesisTimeBlockFinder {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final Eth1Provider eth1Provider;\n+  private final MinGenesisTimeBlockEventChannel minGenesisTimeBlockEventChannel;\n+  private final AsyncRunner asyncRunner;\n+\n+  private volatile Disposable latestBlockDisposable;\n+\n+  public Eth1MinGenesisTimeBlockFinder(\n+      Eth1Provider eth1Provider,\n+      MinGenesisTimeBlockEventChannel minGenesisTimeBlockEventChannel,\n+      AsyncRunner asyncRunner) {\n+    this.eth1Provider = eth1Provider;\n+    this.minGenesisTimeBlockEventChannel = minGenesisTimeBlockEventChannel;\n+    this.asyncRunner = asyncRunner;\n+  }\n+\n+  public void start() {\n+    findAndPublishFirstValidBlock()\n+        .finish(\n+            () ->\n+                LOG.info(\n+                    \"Eth1MinGenesisBlockFinder successfully found first \"\n+                        + \"(time) valid genesis block\"));\n+  }\n+\n+  public SafeFuture<Void> findAndPublishFirstValidBlock() {\n+    return eth1Provider\n+        .getLatestEth1BlockFuture()\n+        .thenApply(EthBlock.Block::getNumber)\n+        .thenApply(number -> number.subtract(Constants.ETH1_FOLLOW_DISTANCE.bigIntegerValue()))\n+        .thenApply(UnsignedLong::valueOf)\n+        .thenCompose(eth1Provider::getEth1BlockFuture)\n+        .thenCompose(\n+            block -> {\n+              SafeFuture<EthBlock.Block> firstValidBlockFuture;\n+              switch (compareBlockTimestampToMinGenesisTime(block)) {\n+                case 1:\n+                  // If block timestamp is greater than min genesis time\n+                  // find first valid block in history\n+                  firstValidBlockFuture = findFirstValidBlockInHistory(block);\n+                  break;\n+                case 0:\n+                  firstValidBlockFuture = SafeFuture.completedFuture(block);\n+                  break;\n+                case -1:\n+                  // If block timestamp is less than min genesis time\n+                  // subscribe to new block events and wait for the first\n+                  // valid block\n+                  firstValidBlockFuture = waitForFirstValidBlock();\n+                  break;\n+                default:\n+                  throw new IllegalStateException(\n+                      \"Unexpected value: \"\n+                          + calculateCandidateGenesisTimestamp(block.getTimestamp())\n+                              .compareTo(Constants.MIN_GENESIS_TIME));\n+              }\n+              return firstValidBlockFuture;\n+            })\n+        .thenAccept(this::publishFirstValidBlock)\n+        .exceptionallyCompose(\n+            err -> {\n+              LOG.debug(\n+                  \"Eth1MinGenesisTimeBlockFinder failed to find first valid block. Retry in \"\n+                      + Constants.ETH1_MIN_GENESIS_TIME_BLOCK_RETRY_TIMEOUT\n+                      + \" seconds\",\n+                  err);\n+\n+              return asyncRunner.runAfterDelay(\n+                  this::findAndPublishFirstValidBlock,\n+                  Constants.ETH1_MIN_GENESIS_TIME_BLOCK_RETRY_TIMEOUT,\n+                  TimeUnit.SECONDS);\n+            });\n+  }\n+\n+  private void publishFirstValidBlock(EthBlock.Block block) {\n+    minGenesisTimeBlockEventChannel.onMinGenesisTimeBlock(\n+        new MinGenesisTimeBlockEvent(\n+            UnsignedLong.valueOf(block.getTimestamp()),\n+            UnsignedLong.valueOf(block.getNumber()),\n+            Bytes32.fromHexString(block.getHash())));\n+  }\n+\n+  /**\n+   * Find first estimationBlock that has timestamp that is greater than MIN_GENESIS_TIME\n+   *\n+   * @param estimationBlock estimationBlock that will be used for estimation\n+   * @return first valid block in history\n+   */\n+  private SafeFuture<EthBlock.Block> findFirstValidBlockInHistory(EthBlock.Block estimationBlock) {\n+    UnsignedLong estimatedFirstValidBlockNumber =\n+        getEstimatedFirstValidBlockNumber(estimationBlock, Constants.SECONDS_PER_ETH1_BLOCK);\n+    return eth1Provider\n+        .getEth1BlockFuture(estimatedFirstValidBlockNumber)\n+        .thenCompose(\n+            block -> {\n+              SafeFuture<EthBlock.Block> firstValidBlock;\n+              switch (compareBlockTimestampToMinGenesisTime(block)) {\n+                case 1:\n+                  // If block timestamp is greater than min genesis time\n+                  // explore blocks downwards\n+                  firstValidBlock = exploreBlocksDownwards(block);\n+                  break;\n+                case 0:\n+                  firstValidBlock = SafeFuture.completedFuture(block);\n+                  break;\n+                case -1:\n+                  // If block timestamp is less than min genesis time\n+                  // explore blocks upwards\n+                  firstValidBlock = exploreBlocksUpwards(block);\n+                  break;\n+                default:\n+                  throw new IllegalStateException(\n+                      \"Unexpected value: \"\n+                          + calculateCandidateGenesisTimestamp(block.getTimestamp())\n+                              .compareTo(Constants.MIN_GENESIS_TIME));\n+              }\n+              return firstValidBlock;\n+            });\n+  }\n+\n+  private SafeFuture<EthBlock.Block> exploreBlocksDownwards(EthBlock.Block previousBlock) {\n+    UnsignedLong previousBlockNumber = UnsignedLong.valueOf(previousBlock.getNumber());\n+    UnsignedLong newBlockNumber = previousBlockNumber.minus(UnsignedLong.ONE);\n+    SafeFuture<EthBlock.Block> blockFuture = eth1Provider.getEth1BlockFuture(newBlockNumber);\n+    return blockFuture.thenCompose(\n+        block -> {\n+          SafeFuture<EthBlock.Block> firstValidBlock;\n+          switch (compareBlockTimestampToMinGenesisTime(block)) {\n+            case 1:\n+              // If exploring downwards and block timestamp > min genesis time,\n+              // then block must still be downwards.\n+              firstValidBlock = exploreBlocksDownwards(block);\n+              break;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDIxNzQ0NA=="}, "originalCommit": {"oid": "061392c0279932768bc51cc872347b2c2f3940c3"}, "originalPosition": 167}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3OTQ1ODUyOnYy", "diffSide": "RIGHT", "path": "pow/src/main/java/tech/pegasys/artemis/pow/Eth1MinGenesisTimeBlockFinder.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwMjoyMTozNlrOFucRTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNzoxNTozNFrOFu0l8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI0MTk5Ng==", "bodyText": "What happens if this fails?", "url": "https://github.com/ConsenSys/teku/pull/1228#discussion_r384241996", "createdAt": "2020-02-26T02:21:36Z", "author": {"login": "ajsutton"}, "path": "pow/src/main/java/tech/pegasys/artemis/pow/Eth1MinGenesisTimeBlockFinder.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import io.reactivex.disposables.Disposable;\n+import java.math.BigInteger;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.api.MinGenesisTimeBlockEventChannel;\n+import tech.pegasys.artemis.pow.event.MinGenesisTimeBlockEvent;\n+import tech.pegasys.artemis.util.async.AsyncRunner;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class Eth1MinGenesisTimeBlockFinder {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final Eth1Provider eth1Provider;\n+  private final MinGenesisTimeBlockEventChannel minGenesisTimeBlockEventChannel;\n+  private final AsyncRunner asyncRunner;\n+\n+  private volatile Disposable latestBlockDisposable;\n+\n+  public Eth1MinGenesisTimeBlockFinder(\n+      Eth1Provider eth1Provider,\n+      MinGenesisTimeBlockEventChannel minGenesisTimeBlockEventChannel,\n+      AsyncRunner asyncRunner) {\n+    this.eth1Provider = eth1Provider;\n+    this.minGenesisTimeBlockEventChannel = minGenesisTimeBlockEventChannel;\n+    this.asyncRunner = asyncRunner;\n+  }\n+\n+  public void start() {\n+    findAndPublishFirstValidBlock()\n+        .finish(\n+            () ->\n+                LOG.info(\n+                    \"Eth1MinGenesisBlockFinder successfully found first \"\n+                        + \"(time) valid genesis block\"));\n+  }\n+\n+  public SafeFuture<Void> findAndPublishFirstValidBlock() {\n+    return eth1Provider\n+        .getLatestEth1BlockFuture()\n+        .thenApply(EthBlock.Block::getNumber)\n+        .thenApply(number -> number.subtract(Constants.ETH1_FOLLOW_DISTANCE.bigIntegerValue()))\n+        .thenApply(UnsignedLong::valueOf)\n+        .thenCompose(eth1Provider::getEth1BlockFuture)\n+        .thenCompose(\n+            block -> {\n+              SafeFuture<EthBlock.Block> firstValidBlockFuture;\n+              switch (compareBlockTimestampToMinGenesisTime(block)) {\n+                case 1:\n+                  // If block timestamp is greater than min genesis time\n+                  // find first valid block in history\n+                  firstValidBlockFuture = findFirstValidBlockInHistory(block);\n+                  break;\n+                case 0:\n+                  firstValidBlockFuture = SafeFuture.completedFuture(block);\n+                  break;\n+                case -1:\n+                  // If block timestamp is less than min genesis time\n+                  // subscribe to new block events and wait for the first\n+                  // valid block\n+                  firstValidBlockFuture = waitForFirstValidBlock();\n+                  break;\n+                default:\n+                  throw new IllegalStateException(\n+                      \"Unexpected value: \"\n+                          + calculateCandidateGenesisTimestamp(block.getTimestamp())\n+                              .compareTo(Constants.MIN_GENESIS_TIME));\n+              }\n+              return firstValidBlockFuture;\n+            })\n+        .thenAccept(this::publishFirstValidBlock)\n+        .exceptionallyCompose(\n+            err -> {\n+              LOG.debug(\n+                  \"Eth1MinGenesisTimeBlockFinder failed to find first valid block. Retry in \"\n+                      + Constants.ETH1_MIN_GENESIS_TIME_BLOCK_RETRY_TIMEOUT\n+                      + \" seconds\",\n+                  err);\n+\n+              return asyncRunner.runAfterDelay(\n+                  this::findAndPublishFirstValidBlock,\n+                  Constants.ETH1_MIN_GENESIS_TIME_BLOCK_RETRY_TIMEOUT,\n+                  TimeUnit.SECONDS);\n+            });\n+  }\n+\n+  private void publishFirstValidBlock(EthBlock.Block block) {\n+    minGenesisTimeBlockEventChannel.onMinGenesisTimeBlock(\n+        new MinGenesisTimeBlockEvent(\n+            UnsignedLong.valueOf(block.getTimestamp()),\n+            UnsignedLong.valueOf(block.getNumber()),\n+            Bytes32.fromHexString(block.getHash())));\n+  }\n+\n+  /**\n+   * Find first estimationBlock that has timestamp that is greater than MIN_GENESIS_TIME\n+   *\n+   * @param estimationBlock estimationBlock that will be used for estimation\n+   * @return first valid block in history\n+   */\n+  private SafeFuture<EthBlock.Block> findFirstValidBlockInHistory(EthBlock.Block estimationBlock) {\n+    UnsignedLong estimatedFirstValidBlockNumber =\n+        getEstimatedFirstValidBlockNumber(estimationBlock, Constants.SECONDS_PER_ETH1_BLOCK);\n+    return eth1Provider\n+        .getEth1BlockFuture(estimatedFirstValidBlockNumber)\n+        .thenCompose(\n+            block -> {\n+              SafeFuture<EthBlock.Block> firstValidBlock;\n+              switch (compareBlockTimestampToMinGenesisTime(block)) {\n+                case 1:\n+                  // If block timestamp is greater than min genesis time\n+                  // explore blocks downwards\n+                  firstValidBlock = exploreBlocksDownwards(block);\n+                  break;\n+                case 0:\n+                  firstValidBlock = SafeFuture.completedFuture(block);\n+                  break;\n+                case -1:\n+                  // If block timestamp is less than min genesis time\n+                  // explore blocks upwards\n+                  firstValidBlock = exploreBlocksUpwards(block);\n+                  break;\n+                default:\n+                  throw new IllegalStateException(\n+                      \"Unexpected value: \"\n+                          + calculateCandidateGenesisTimestamp(block.getTimestamp())\n+                              .compareTo(Constants.MIN_GENESIS_TIME));\n+              }\n+              return firstValidBlock;\n+            });\n+  }\n+\n+  private SafeFuture<EthBlock.Block> exploreBlocksDownwards(EthBlock.Block previousBlock) {\n+    UnsignedLong previousBlockNumber = UnsignedLong.valueOf(previousBlock.getNumber());\n+    UnsignedLong newBlockNumber = previousBlockNumber.minus(UnsignedLong.ONE);\n+    SafeFuture<EthBlock.Block> blockFuture = eth1Provider.getEth1BlockFuture(newBlockNumber);\n+    return blockFuture.thenCompose(\n+        block -> {\n+          SafeFuture<EthBlock.Block> firstValidBlock;\n+          switch (compareBlockTimestampToMinGenesisTime(block)) {\n+            case 1:\n+              // If exploring downwards and block timestamp > min genesis time,\n+              // then block must still be downwards.\n+              firstValidBlock = exploreBlocksDownwards(block);\n+              break;\n+            case 0:\n+              firstValidBlock = SafeFuture.completedFuture(block);\n+              break;\n+            case -1:\n+              // If exploring downwards and block timestamp < min genesis time,\n+              // then previous block must have been the first valid block.\n+              firstValidBlock = SafeFuture.completedFuture(previousBlock);\n+              break;\n+            default:\n+              throw new IllegalStateException(\n+                  \"Unexpected value: \"\n+                      + calculateCandidateGenesisTimestamp(block.getTimestamp())\n+                          .compareTo(Constants.MIN_GENESIS_TIME));\n+          }\n+          return firstValidBlock;\n+        });\n+  }\n+\n+  private SafeFuture<EthBlock.Block> exploreBlocksUpwards(EthBlock.Block previousBlock) {\n+    UnsignedLong previousBlockNumber = UnsignedLong.valueOf(previousBlock.getNumber());\n+    UnsignedLong newBlockNumber = previousBlockNumber.plus(UnsignedLong.ONE);\n+    SafeFuture<EthBlock.Block> blockFuture = eth1Provider.getEth1BlockFuture(newBlockNumber);\n+    return blockFuture.thenCompose(\n+        block -> {\n+          SafeFuture<EthBlock.Block> firstValidBlock;\n+          switch (compareBlockTimestampToMinGenesisTime(block)) {\n+            case 1:\n+            case 0:\n+              // If exploring upwards and block timestamp >= min genesis time,\n+              // then current block must be the first valid block.\n+              firstValidBlock = SafeFuture.completedFuture(block);\n+              break;\n+            case -1:\n+              // If exploring upwards and block timestamp < min genesis time,\n+              // then previous block must have been the first valid block.\n+              firstValidBlock = exploreBlocksUpwards(block);\n+              break;\n+            default:\n+              throw new IllegalStateException(\n+                  \"Unexpected value: \"\n+                      + calculateCandidateGenesisTimestamp(block.getTimestamp())\n+                          .compareTo(Constants.MIN_GENESIS_TIME));\n+          }\n+          return firstValidBlock;\n+        });\n+  }\n+\n+  /**\n+   * Subscribes to latest block events and sees if the latest canonical block, i.e. the block at\n+   * follow distance, is the first valid block.\n+   *\n+   * @return first valid block\n+   */\n+  private SafeFuture<EthBlock.Block> waitForFirstValidBlock() {\n+    SafeFuture<EthBlock.Block> firstValidBlockFuture = new SafeFuture<>();\n+\n+    latestBlockDisposable =\n+        eth1Provider\n+            .getLatestBlockFlowable()\n+            .map(EthBlock.Block::getNumber)\n+            .map(number -> number.subtract(ETH1_FOLLOW_DISTANCE.bigIntegerValue()))\n+            .map(UnsignedLong::valueOf)\n+            .subscribe(\n+                blockNumber -> onNewBlock(blockNumber, firstValidBlockFuture),\n+                firstValidBlockFuture::completeExceptionally);\n+\n+    return firstValidBlockFuture;\n+  }\n+\n+  private void onNewBlock(\n+      UnsignedLong blockNumber, SafeFuture<EthBlock.Block> firstValidBlockFuture) {\n+    eth1Provider\n+        .getEth1BlockFuture(blockNumber)\n+        .thenAccept(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "061392c0279932768bc51cc872347b2c2f3940c3"}, "originalPosition": 241}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDYyMjIwMA==", "bodyText": "There is an exceptionally compose at the end of the whole findFirstValidBlockAndPublish() so it gets run again. There is a test for it.", "url": "https://github.com/ConsenSys/teku/pull/1228#discussion_r384622200", "createdAt": "2020-02-26T16:46:34Z", "author": {"login": "cemozerr"}, "path": "pow/src/main/java/tech/pegasys/artemis/pow/Eth1MinGenesisTimeBlockFinder.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import io.reactivex.disposables.Disposable;\n+import java.math.BigInteger;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.api.MinGenesisTimeBlockEventChannel;\n+import tech.pegasys.artemis.pow.event.MinGenesisTimeBlockEvent;\n+import tech.pegasys.artemis.util.async.AsyncRunner;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class Eth1MinGenesisTimeBlockFinder {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final Eth1Provider eth1Provider;\n+  private final MinGenesisTimeBlockEventChannel minGenesisTimeBlockEventChannel;\n+  private final AsyncRunner asyncRunner;\n+\n+  private volatile Disposable latestBlockDisposable;\n+\n+  public Eth1MinGenesisTimeBlockFinder(\n+      Eth1Provider eth1Provider,\n+      MinGenesisTimeBlockEventChannel minGenesisTimeBlockEventChannel,\n+      AsyncRunner asyncRunner) {\n+    this.eth1Provider = eth1Provider;\n+    this.minGenesisTimeBlockEventChannel = minGenesisTimeBlockEventChannel;\n+    this.asyncRunner = asyncRunner;\n+  }\n+\n+  public void start() {\n+    findAndPublishFirstValidBlock()\n+        .finish(\n+            () ->\n+                LOG.info(\n+                    \"Eth1MinGenesisBlockFinder successfully found first \"\n+                        + \"(time) valid genesis block\"));\n+  }\n+\n+  public SafeFuture<Void> findAndPublishFirstValidBlock() {\n+    return eth1Provider\n+        .getLatestEth1BlockFuture()\n+        .thenApply(EthBlock.Block::getNumber)\n+        .thenApply(number -> number.subtract(Constants.ETH1_FOLLOW_DISTANCE.bigIntegerValue()))\n+        .thenApply(UnsignedLong::valueOf)\n+        .thenCompose(eth1Provider::getEth1BlockFuture)\n+        .thenCompose(\n+            block -> {\n+              SafeFuture<EthBlock.Block> firstValidBlockFuture;\n+              switch (compareBlockTimestampToMinGenesisTime(block)) {\n+                case 1:\n+                  // If block timestamp is greater than min genesis time\n+                  // find first valid block in history\n+                  firstValidBlockFuture = findFirstValidBlockInHistory(block);\n+                  break;\n+                case 0:\n+                  firstValidBlockFuture = SafeFuture.completedFuture(block);\n+                  break;\n+                case -1:\n+                  // If block timestamp is less than min genesis time\n+                  // subscribe to new block events and wait for the first\n+                  // valid block\n+                  firstValidBlockFuture = waitForFirstValidBlock();\n+                  break;\n+                default:\n+                  throw new IllegalStateException(\n+                      \"Unexpected value: \"\n+                          + calculateCandidateGenesisTimestamp(block.getTimestamp())\n+                              .compareTo(Constants.MIN_GENESIS_TIME));\n+              }\n+              return firstValidBlockFuture;\n+            })\n+        .thenAccept(this::publishFirstValidBlock)\n+        .exceptionallyCompose(\n+            err -> {\n+              LOG.debug(\n+                  \"Eth1MinGenesisTimeBlockFinder failed to find first valid block. Retry in \"\n+                      + Constants.ETH1_MIN_GENESIS_TIME_BLOCK_RETRY_TIMEOUT\n+                      + \" seconds\",\n+                  err);\n+\n+              return asyncRunner.runAfterDelay(\n+                  this::findAndPublishFirstValidBlock,\n+                  Constants.ETH1_MIN_GENESIS_TIME_BLOCK_RETRY_TIMEOUT,\n+                  TimeUnit.SECONDS);\n+            });\n+  }\n+\n+  private void publishFirstValidBlock(EthBlock.Block block) {\n+    minGenesisTimeBlockEventChannel.onMinGenesisTimeBlock(\n+        new MinGenesisTimeBlockEvent(\n+            UnsignedLong.valueOf(block.getTimestamp()),\n+            UnsignedLong.valueOf(block.getNumber()),\n+            Bytes32.fromHexString(block.getHash())));\n+  }\n+\n+  /**\n+   * Find first estimationBlock that has timestamp that is greater than MIN_GENESIS_TIME\n+   *\n+   * @param estimationBlock estimationBlock that will be used for estimation\n+   * @return first valid block in history\n+   */\n+  private SafeFuture<EthBlock.Block> findFirstValidBlockInHistory(EthBlock.Block estimationBlock) {\n+    UnsignedLong estimatedFirstValidBlockNumber =\n+        getEstimatedFirstValidBlockNumber(estimationBlock, Constants.SECONDS_PER_ETH1_BLOCK);\n+    return eth1Provider\n+        .getEth1BlockFuture(estimatedFirstValidBlockNumber)\n+        .thenCompose(\n+            block -> {\n+              SafeFuture<EthBlock.Block> firstValidBlock;\n+              switch (compareBlockTimestampToMinGenesisTime(block)) {\n+                case 1:\n+                  // If block timestamp is greater than min genesis time\n+                  // explore blocks downwards\n+                  firstValidBlock = exploreBlocksDownwards(block);\n+                  break;\n+                case 0:\n+                  firstValidBlock = SafeFuture.completedFuture(block);\n+                  break;\n+                case -1:\n+                  // If block timestamp is less than min genesis time\n+                  // explore blocks upwards\n+                  firstValidBlock = exploreBlocksUpwards(block);\n+                  break;\n+                default:\n+                  throw new IllegalStateException(\n+                      \"Unexpected value: \"\n+                          + calculateCandidateGenesisTimestamp(block.getTimestamp())\n+                              .compareTo(Constants.MIN_GENESIS_TIME));\n+              }\n+              return firstValidBlock;\n+            });\n+  }\n+\n+  private SafeFuture<EthBlock.Block> exploreBlocksDownwards(EthBlock.Block previousBlock) {\n+    UnsignedLong previousBlockNumber = UnsignedLong.valueOf(previousBlock.getNumber());\n+    UnsignedLong newBlockNumber = previousBlockNumber.minus(UnsignedLong.ONE);\n+    SafeFuture<EthBlock.Block> blockFuture = eth1Provider.getEth1BlockFuture(newBlockNumber);\n+    return blockFuture.thenCompose(\n+        block -> {\n+          SafeFuture<EthBlock.Block> firstValidBlock;\n+          switch (compareBlockTimestampToMinGenesisTime(block)) {\n+            case 1:\n+              // If exploring downwards and block timestamp > min genesis time,\n+              // then block must still be downwards.\n+              firstValidBlock = exploreBlocksDownwards(block);\n+              break;\n+            case 0:\n+              firstValidBlock = SafeFuture.completedFuture(block);\n+              break;\n+            case -1:\n+              // If exploring downwards and block timestamp < min genesis time,\n+              // then previous block must have been the first valid block.\n+              firstValidBlock = SafeFuture.completedFuture(previousBlock);\n+              break;\n+            default:\n+              throw new IllegalStateException(\n+                  \"Unexpected value: \"\n+                      + calculateCandidateGenesisTimestamp(block.getTimestamp())\n+                          .compareTo(Constants.MIN_GENESIS_TIME));\n+          }\n+          return firstValidBlock;\n+        });\n+  }\n+\n+  private SafeFuture<EthBlock.Block> exploreBlocksUpwards(EthBlock.Block previousBlock) {\n+    UnsignedLong previousBlockNumber = UnsignedLong.valueOf(previousBlock.getNumber());\n+    UnsignedLong newBlockNumber = previousBlockNumber.plus(UnsignedLong.ONE);\n+    SafeFuture<EthBlock.Block> blockFuture = eth1Provider.getEth1BlockFuture(newBlockNumber);\n+    return blockFuture.thenCompose(\n+        block -> {\n+          SafeFuture<EthBlock.Block> firstValidBlock;\n+          switch (compareBlockTimestampToMinGenesisTime(block)) {\n+            case 1:\n+            case 0:\n+              // If exploring upwards and block timestamp >= min genesis time,\n+              // then current block must be the first valid block.\n+              firstValidBlock = SafeFuture.completedFuture(block);\n+              break;\n+            case -1:\n+              // If exploring upwards and block timestamp < min genesis time,\n+              // then previous block must have been the first valid block.\n+              firstValidBlock = exploreBlocksUpwards(block);\n+              break;\n+            default:\n+              throw new IllegalStateException(\n+                  \"Unexpected value: \"\n+                      + calculateCandidateGenesisTimestamp(block.getTimestamp())\n+                          .compareTo(Constants.MIN_GENESIS_TIME));\n+          }\n+          return firstValidBlock;\n+        });\n+  }\n+\n+  /**\n+   * Subscribes to latest block events and sees if the latest canonical block, i.e. the block at\n+   * follow distance, is the first valid block.\n+   *\n+   * @return first valid block\n+   */\n+  private SafeFuture<EthBlock.Block> waitForFirstValidBlock() {\n+    SafeFuture<EthBlock.Block> firstValidBlockFuture = new SafeFuture<>();\n+\n+    latestBlockDisposable =\n+        eth1Provider\n+            .getLatestBlockFlowable()\n+            .map(EthBlock.Block::getNumber)\n+            .map(number -> number.subtract(ETH1_FOLLOW_DISTANCE.bigIntegerValue()))\n+            .map(UnsignedLong::valueOf)\n+            .subscribe(\n+                blockNumber -> onNewBlock(blockNumber, firstValidBlockFuture),\n+                firstValidBlockFuture::completeExceptionally);\n+\n+    return firstValidBlockFuture;\n+  }\n+\n+  private void onNewBlock(\n+      UnsignedLong blockNumber, SafeFuture<EthBlock.Block> firstValidBlockFuture) {\n+    eth1Provider\n+        .getEth1BlockFuture(blockNumber)\n+        .thenAccept(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI0MTk5Ng=="}, "originalCommit": {"oid": "061392c0279932768bc51cc872347b2c2f3940c3"}, "originalPosition": 241}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDYyMjUwMQ==", "bodyText": "https://github.com/PegaSysEng/teku/pull/1228/files#diff-b00a71e2a2f564197b1d296f0075e6c4R194", "url": "https://github.com/ConsenSys/teku/pull/1228#discussion_r384622501", "createdAt": "2020-02-26T16:46:59Z", "author": {"login": "cemozerr"}, "path": "pow/src/main/java/tech/pegasys/artemis/pow/Eth1MinGenesisTimeBlockFinder.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import io.reactivex.disposables.Disposable;\n+import java.math.BigInteger;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.api.MinGenesisTimeBlockEventChannel;\n+import tech.pegasys.artemis.pow.event.MinGenesisTimeBlockEvent;\n+import tech.pegasys.artemis.util.async.AsyncRunner;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class Eth1MinGenesisTimeBlockFinder {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final Eth1Provider eth1Provider;\n+  private final MinGenesisTimeBlockEventChannel minGenesisTimeBlockEventChannel;\n+  private final AsyncRunner asyncRunner;\n+\n+  private volatile Disposable latestBlockDisposable;\n+\n+  public Eth1MinGenesisTimeBlockFinder(\n+      Eth1Provider eth1Provider,\n+      MinGenesisTimeBlockEventChannel minGenesisTimeBlockEventChannel,\n+      AsyncRunner asyncRunner) {\n+    this.eth1Provider = eth1Provider;\n+    this.minGenesisTimeBlockEventChannel = minGenesisTimeBlockEventChannel;\n+    this.asyncRunner = asyncRunner;\n+  }\n+\n+  public void start() {\n+    findAndPublishFirstValidBlock()\n+        .finish(\n+            () ->\n+                LOG.info(\n+                    \"Eth1MinGenesisBlockFinder successfully found first \"\n+                        + \"(time) valid genesis block\"));\n+  }\n+\n+  public SafeFuture<Void> findAndPublishFirstValidBlock() {\n+    return eth1Provider\n+        .getLatestEth1BlockFuture()\n+        .thenApply(EthBlock.Block::getNumber)\n+        .thenApply(number -> number.subtract(Constants.ETH1_FOLLOW_DISTANCE.bigIntegerValue()))\n+        .thenApply(UnsignedLong::valueOf)\n+        .thenCompose(eth1Provider::getEth1BlockFuture)\n+        .thenCompose(\n+            block -> {\n+              SafeFuture<EthBlock.Block> firstValidBlockFuture;\n+              switch (compareBlockTimestampToMinGenesisTime(block)) {\n+                case 1:\n+                  // If block timestamp is greater than min genesis time\n+                  // find first valid block in history\n+                  firstValidBlockFuture = findFirstValidBlockInHistory(block);\n+                  break;\n+                case 0:\n+                  firstValidBlockFuture = SafeFuture.completedFuture(block);\n+                  break;\n+                case -1:\n+                  // If block timestamp is less than min genesis time\n+                  // subscribe to new block events and wait for the first\n+                  // valid block\n+                  firstValidBlockFuture = waitForFirstValidBlock();\n+                  break;\n+                default:\n+                  throw new IllegalStateException(\n+                      \"Unexpected value: \"\n+                          + calculateCandidateGenesisTimestamp(block.getTimestamp())\n+                              .compareTo(Constants.MIN_GENESIS_TIME));\n+              }\n+              return firstValidBlockFuture;\n+            })\n+        .thenAccept(this::publishFirstValidBlock)\n+        .exceptionallyCompose(\n+            err -> {\n+              LOG.debug(\n+                  \"Eth1MinGenesisTimeBlockFinder failed to find first valid block. Retry in \"\n+                      + Constants.ETH1_MIN_GENESIS_TIME_BLOCK_RETRY_TIMEOUT\n+                      + \" seconds\",\n+                  err);\n+\n+              return asyncRunner.runAfterDelay(\n+                  this::findAndPublishFirstValidBlock,\n+                  Constants.ETH1_MIN_GENESIS_TIME_BLOCK_RETRY_TIMEOUT,\n+                  TimeUnit.SECONDS);\n+            });\n+  }\n+\n+  private void publishFirstValidBlock(EthBlock.Block block) {\n+    minGenesisTimeBlockEventChannel.onMinGenesisTimeBlock(\n+        new MinGenesisTimeBlockEvent(\n+            UnsignedLong.valueOf(block.getTimestamp()),\n+            UnsignedLong.valueOf(block.getNumber()),\n+            Bytes32.fromHexString(block.getHash())));\n+  }\n+\n+  /**\n+   * Find first estimationBlock that has timestamp that is greater than MIN_GENESIS_TIME\n+   *\n+   * @param estimationBlock estimationBlock that will be used for estimation\n+   * @return first valid block in history\n+   */\n+  private SafeFuture<EthBlock.Block> findFirstValidBlockInHistory(EthBlock.Block estimationBlock) {\n+    UnsignedLong estimatedFirstValidBlockNumber =\n+        getEstimatedFirstValidBlockNumber(estimationBlock, Constants.SECONDS_PER_ETH1_BLOCK);\n+    return eth1Provider\n+        .getEth1BlockFuture(estimatedFirstValidBlockNumber)\n+        .thenCompose(\n+            block -> {\n+              SafeFuture<EthBlock.Block> firstValidBlock;\n+              switch (compareBlockTimestampToMinGenesisTime(block)) {\n+                case 1:\n+                  // If block timestamp is greater than min genesis time\n+                  // explore blocks downwards\n+                  firstValidBlock = exploreBlocksDownwards(block);\n+                  break;\n+                case 0:\n+                  firstValidBlock = SafeFuture.completedFuture(block);\n+                  break;\n+                case -1:\n+                  // If block timestamp is less than min genesis time\n+                  // explore blocks upwards\n+                  firstValidBlock = exploreBlocksUpwards(block);\n+                  break;\n+                default:\n+                  throw new IllegalStateException(\n+                      \"Unexpected value: \"\n+                          + calculateCandidateGenesisTimestamp(block.getTimestamp())\n+                              .compareTo(Constants.MIN_GENESIS_TIME));\n+              }\n+              return firstValidBlock;\n+            });\n+  }\n+\n+  private SafeFuture<EthBlock.Block> exploreBlocksDownwards(EthBlock.Block previousBlock) {\n+    UnsignedLong previousBlockNumber = UnsignedLong.valueOf(previousBlock.getNumber());\n+    UnsignedLong newBlockNumber = previousBlockNumber.minus(UnsignedLong.ONE);\n+    SafeFuture<EthBlock.Block> blockFuture = eth1Provider.getEth1BlockFuture(newBlockNumber);\n+    return blockFuture.thenCompose(\n+        block -> {\n+          SafeFuture<EthBlock.Block> firstValidBlock;\n+          switch (compareBlockTimestampToMinGenesisTime(block)) {\n+            case 1:\n+              // If exploring downwards and block timestamp > min genesis time,\n+              // then block must still be downwards.\n+              firstValidBlock = exploreBlocksDownwards(block);\n+              break;\n+            case 0:\n+              firstValidBlock = SafeFuture.completedFuture(block);\n+              break;\n+            case -1:\n+              // If exploring downwards and block timestamp < min genesis time,\n+              // then previous block must have been the first valid block.\n+              firstValidBlock = SafeFuture.completedFuture(previousBlock);\n+              break;\n+            default:\n+              throw new IllegalStateException(\n+                  \"Unexpected value: \"\n+                      + calculateCandidateGenesisTimestamp(block.getTimestamp())\n+                          .compareTo(Constants.MIN_GENESIS_TIME));\n+          }\n+          return firstValidBlock;\n+        });\n+  }\n+\n+  private SafeFuture<EthBlock.Block> exploreBlocksUpwards(EthBlock.Block previousBlock) {\n+    UnsignedLong previousBlockNumber = UnsignedLong.valueOf(previousBlock.getNumber());\n+    UnsignedLong newBlockNumber = previousBlockNumber.plus(UnsignedLong.ONE);\n+    SafeFuture<EthBlock.Block> blockFuture = eth1Provider.getEth1BlockFuture(newBlockNumber);\n+    return blockFuture.thenCompose(\n+        block -> {\n+          SafeFuture<EthBlock.Block> firstValidBlock;\n+          switch (compareBlockTimestampToMinGenesisTime(block)) {\n+            case 1:\n+            case 0:\n+              // If exploring upwards and block timestamp >= min genesis time,\n+              // then current block must be the first valid block.\n+              firstValidBlock = SafeFuture.completedFuture(block);\n+              break;\n+            case -1:\n+              // If exploring upwards and block timestamp < min genesis time,\n+              // then previous block must have been the first valid block.\n+              firstValidBlock = exploreBlocksUpwards(block);\n+              break;\n+            default:\n+              throw new IllegalStateException(\n+                  \"Unexpected value: \"\n+                      + calculateCandidateGenesisTimestamp(block.getTimestamp())\n+                          .compareTo(Constants.MIN_GENESIS_TIME));\n+          }\n+          return firstValidBlock;\n+        });\n+  }\n+\n+  /**\n+   * Subscribes to latest block events and sees if the latest canonical block, i.e. the block at\n+   * follow distance, is the first valid block.\n+   *\n+   * @return first valid block\n+   */\n+  private SafeFuture<EthBlock.Block> waitForFirstValidBlock() {\n+    SafeFuture<EthBlock.Block> firstValidBlockFuture = new SafeFuture<>();\n+\n+    latestBlockDisposable =\n+        eth1Provider\n+            .getLatestBlockFlowable()\n+            .map(EthBlock.Block::getNumber)\n+            .map(number -> number.subtract(ETH1_FOLLOW_DISTANCE.bigIntegerValue()))\n+            .map(UnsignedLong::valueOf)\n+            .subscribe(\n+                blockNumber -> onNewBlock(blockNumber, firstValidBlockFuture),\n+                firstValidBlockFuture::completeExceptionally);\n+\n+    return firstValidBlockFuture;\n+  }\n+\n+  private void onNewBlock(\n+      UnsignedLong blockNumber, SafeFuture<EthBlock.Block> firstValidBlockFuture) {\n+    eth1Provider\n+        .getEth1BlockFuture(blockNumber)\n+        .thenAccept(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI0MTk5Ng=="}, "originalCommit": {"oid": "061392c0279932768bc51cc872347b2c2f3940c3"}, "originalPosition": 241}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY0MDQ5Ng==", "bodyText": "Oh nvm, I misread what you wrote. I will make sure this is handled.", "url": "https://github.com/ConsenSys/teku/pull/1228#discussion_r384640496", "createdAt": "2020-02-26T17:15:34Z", "author": {"login": "cemozerr"}, "path": "pow/src/main/java/tech/pegasys/artemis/pow/Eth1MinGenesisTimeBlockFinder.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import io.reactivex.disposables.Disposable;\n+import java.math.BigInteger;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.api.MinGenesisTimeBlockEventChannel;\n+import tech.pegasys.artemis.pow.event.MinGenesisTimeBlockEvent;\n+import tech.pegasys.artemis.util.async.AsyncRunner;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class Eth1MinGenesisTimeBlockFinder {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final Eth1Provider eth1Provider;\n+  private final MinGenesisTimeBlockEventChannel minGenesisTimeBlockEventChannel;\n+  private final AsyncRunner asyncRunner;\n+\n+  private volatile Disposable latestBlockDisposable;\n+\n+  public Eth1MinGenesisTimeBlockFinder(\n+      Eth1Provider eth1Provider,\n+      MinGenesisTimeBlockEventChannel minGenesisTimeBlockEventChannel,\n+      AsyncRunner asyncRunner) {\n+    this.eth1Provider = eth1Provider;\n+    this.minGenesisTimeBlockEventChannel = minGenesisTimeBlockEventChannel;\n+    this.asyncRunner = asyncRunner;\n+  }\n+\n+  public void start() {\n+    findAndPublishFirstValidBlock()\n+        .finish(\n+            () ->\n+                LOG.info(\n+                    \"Eth1MinGenesisBlockFinder successfully found first \"\n+                        + \"(time) valid genesis block\"));\n+  }\n+\n+  public SafeFuture<Void> findAndPublishFirstValidBlock() {\n+    return eth1Provider\n+        .getLatestEth1BlockFuture()\n+        .thenApply(EthBlock.Block::getNumber)\n+        .thenApply(number -> number.subtract(Constants.ETH1_FOLLOW_DISTANCE.bigIntegerValue()))\n+        .thenApply(UnsignedLong::valueOf)\n+        .thenCompose(eth1Provider::getEth1BlockFuture)\n+        .thenCompose(\n+            block -> {\n+              SafeFuture<EthBlock.Block> firstValidBlockFuture;\n+              switch (compareBlockTimestampToMinGenesisTime(block)) {\n+                case 1:\n+                  // If block timestamp is greater than min genesis time\n+                  // find first valid block in history\n+                  firstValidBlockFuture = findFirstValidBlockInHistory(block);\n+                  break;\n+                case 0:\n+                  firstValidBlockFuture = SafeFuture.completedFuture(block);\n+                  break;\n+                case -1:\n+                  // If block timestamp is less than min genesis time\n+                  // subscribe to new block events and wait for the first\n+                  // valid block\n+                  firstValidBlockFuture = waitForFirstValidBlock();\n+                  break;\n+                default:\n+                  throw new IllegalStateException(\n+                      \"Unexpected value: \"\n+                          + calculateCandidateGenesisTimestamp(block.getTimestamp())\n+                              .compareTo(Constants.MIN_GENESIS_TIME));\n+              }\n+              return firstValidBlockFuture;\n+            })\n+        .thenAccept(this::publishFirstValidBlock)\n+        .exceptionallyCompose(\n+            err -> {\n+              LOG.debug(\n+                  \"Eth1MinGenesisTimeBlockFinder failed to find first valid block. Retry in \"\n+                      + Constants.ETH1_MIN_GENESIS_TIME_BLOCK_RETRY_TIMEOUT\n+                      + \" seconds\",\n+                  err);\n+\n+              return asyncRunner.runAfterDelay(\n+                  this::findAndPublishFirstValidBlock,\n+                  Constants.ETH1_MIN_GENESIS_TIME_BLOCK_RETRY_TIMEOUT,\n+                  TimeUnit.SECONDS);\n+            });\n+  }\n+\n+  private void publishFirstValidBlock(EthBlock.Block block) {\n+    minGenesisTimeBlockEventChannel.onMinGenesisTimeBlock(\n+        new MinGenesisTimeBlockEvent(\n+            UnsignedLong.valueOf(block.getTimestamp()),\n+            UnsignedLong.valueOf(block.getNumber()),\n+            Bytes32.fromHexString(block.getHash())));\n+  }\n+\n+  /**\n+   * Find first estimationBlock that has timestamp that is greater than MIN_GENESIS_TIME\n+   *\n+   * @param estimationBlock estimationBlock that will be used for estimation\n+   * @return first valid block in history\n+   */\n+  private SafeFuture<EthBlock.Block> findFirstValidBlockInHistory(EthBlock.Block estimationBlock) {\n+    UnsignedLong estimatedFirstValidBlockNumber =\n+        getEstimatedFirstValidBlockNumber(estimationBlock, Constants.SECONDS_PER_ETH1_BLOCK);\n+    return eth1Provider\n+        .getEth1BlockFuture(estimatedFirstValidBlockNumber)\n+        .thenCompose(\n+            block -> {\n+              SafeFuture<EthBlock.Block> firstValidBlock;\n+              switch (compareBlockTimestampToMinGenesisTime(block)) {\n+                case 1:\n+                  // If block timestamp is greater than min genesis time\n+                  // explore blocks downwards\n+                  firstValidBlock = exploreBlocksDownwards(block);\n+                  break;\n+                case 0:\n+                  firstValidBlock = SafeFuture.completedFuture(block);\n+                  break;\n+                case -1:\n+                  // If block timestamp is less than min genesis time\n+                  // explore blocks upwards\n+                  firstValidBlock = exploreBlocksUpwards(block);\n+                  break;\n+                default:\n+                  throw new IllegalStateException(\n+                      \"Unexpected value: \"\n+                          + calculateCandidateGenesisTimestamp(block.getTimestamp())\n+                              .compareTo(Constants.MIN_GENESIS_TIME));\n+              }\n+              return firstValidBlock;\n+            });\n+  }\n+\n+  private SafeFuture<EthBlock.Block> exploreBlocksDownwards(EthBlock.Block previousBlock) {\n+    UnsignedLong previousBlockNumber = UnsignedLong.valueOf(previousBlock.getNumber());\n+    UnsignedLong newBlockNumber = previousBlockNumber.minus(UnsignedLong.ONE);\n+    SafeFuture<EthBlock.Block> blockFuture = eth1Provider.getEth1BlockFuture(newBlockNumber);\n+    return blockFuture.thenCompose(\n+        block -> {\n+          SafeFuture<EthBlock.Block> firstValidBlock;\n+          switch (compareBlockTimestampToMinGenesisTime(block)) {\n+            case 1:\n+              // If exploring downwards and block timestamp > min genesis time,\n+              // then block must still be downwards.\n+              firstValidBlock = exploreBlocksDownwards(block);\n+              break;\n+            case 0:\n+              firstValidBlock = SafeFuture.completedFuture(block);\n+              break;\n+            case -1:\n+              // If exploring downwards and block timestamp < min genesis time,\n+              // then previous block must have been the first valid block.\n+              firstValidBlock = SafeFuture.completedFuture(previousBlock);\n+              break;\n+            default:\n+              throw new IllegalStateException(\n+                  \"Unexpected value: \"\n+                      + calculateCandidateGenesisTimestamp(block.getTimestamp())\n+                          .compareTo(Constants.MIN_GENESIS_TIME));\n+          }\n+          return firstValidBlock;\n+        });\n+  }\n+\n+  private SafeFuture<EthBlock.Block> exploreBlocksUpwards(EthBlock.Block previousBlock) {\n+    UnsignedLong previousBlockNumber = UnsignedLong.valueOf(previousBlock.getNumber());\n+    UnsignedLong newBlockNumber = previousBlockNumber.plus(UnsignedLong.ONE);\n+    SafeFuture<EthBlock.Block> blockFuture = eth1Provider.getEth1BlockFuture(newBlockNumber);\n+    return blockFuture.thenCompose(\n+        block -> {\n+          SafeFuture<EthBlock.Block> firstValidBlock;\n+          switch (compareBlockTimestampToMinGenesisTime(block)) {\n+            case 1:\n+            case 0:\n+              // If exploring upwards and block timestamp >= min genesis time,\n+              // then current block must be the first valid block.\n+              firstValidBlock = SafeFuture.completedFuture(block);\n+              break;\n+            case -1:\n+              // If exploring upwards and block timestamp < min genesis time,\n+              // then previous block must have been the first valid block.\n+              firstValidBlock = exploreBlocksUpwards(block);\n+              break;\n+            default:\n+              throw new IllegalStateException(\n+                  \"Unexpected value: \"\n+                      + calculateCandidateGenesisTimestamp(block.getTimestamp())\n+                          .compareTo(Constants.MIN_GENESIS_TIME));\n+          }\n+          return firstValidBlock;\n+        });\n+  }\n+\n+  /**\n+   * Subscribes to latest block events and sees if the latest canonical block, i.e. the block at\n+   * follow distance, is the first valid block.\n+   *\n+   * @return first valid block\n+   */\n+  private SafeFuture<EthBlock.Block> waitForFirstValidBlock() {\n+    SafeFuture<EthBlock.Block> firstValidBlockFuture = new SafeFuture<>();\n+\n+    latestBlockDisposable =\n+        eth1Provider\n+            .getLatestBlockFlowable()\n+            .map(EthBlock.Block::getNumber)\n+            .map(number -> number.subtract(ETH1_FOLLOW_DISTANCE.bigIntegerValue()))\n+            .map(UnsignedLong::valueOf)\n+            .subscribe(\n+                blockNumber -> onNewBlock(blockNumber, firstValidBlockFuture),\n+                firstValidBlockFuture::completeExceptionally);\n+\n+    return firstValidBlockFuture;\n+  }\n+\n+  private void onNewBlock(\n+      UnsignedLong blockNumber, SafeFuture<EthBlock.Block> firstValidBlockFuture) {\n+    eth1Provider\n+        .getEth1BlockFuture(blockNumber)\n+        .thenAccept(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI0MTk5Ng=="}, "originalCommit": {"oid": "061392c0279932768bc51cc872347b2c2f3940c3"}, "originalPosition": 241}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3OTQ2ODA1OnYy", "diffSide": "RIGHT", "path": "pow/src/main/java/tech/pegasys/artemis/pow/Eth1MinGenesisTimeBlockFinder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwMjoyNjo1NlrOFucW7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNjo0OTowM1rOFuzkzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI0MzQzOA==", "bodyText": "Probably need to handle the case where we reach the ETH1 genesis block and are still after min genesis time.", "url": "https://github.com/ConsenSys/teku/pull/1228#discussion_r384243438", "createdAt": "2020-02-26T02:26:56Z", "author": {"login": "ajsutton"}, "path": "pow/src/main/java/tech/pegasys/artemis/pow/Eth1MinGenesisTimeBlockFinder.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import io.reactivex.disposables.Disposable;\n+import java.math.BigInteger;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.api.MinGenesisTimeBlockEventChannel;\n+import tech.pegasys.artemis.pow.event.MinGenesisTimeBlockEvent;\n+import tech.pegasys.artemis.util.async.AsyncRunner;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class Eth1MinGenesisTimeBlockFinder {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final Eth1Provider eth1Provider;\n+  private final MinGenesisTimeBlockEventChannel minGenesisTimeBlockEventChannel;\n+  private final AsyncRunner asyncRunner;\n+\n+  private volatile Disposable latestBlockDisposable;\n+\n+  public Eth1MinGenesisTimeBlockFinder(\n+      Eth1Provider eth1Provider,\n+      MinGenesisTimeBlockEventChannel minGenesisTimeBlockEventChannel,\n+      AsyncRunner asyncRunner) {\n+    this.eth1Provider = eth1Provider;\n+    this.minGenesisTimeBlockEventChannel = minGenesisTimeBlockEventChannel;\n+    this.asyncRunner = asyncRunner;\n+  }\n+\n+  public void start() {\n+    findAndPublishFirstValidBlock()\n+        .finish(\n+            () ->\n+                LOG.info(\n+                    \"Eth1MinGenesisBlockFinder successfully found first \"\n+                        + \"(time) valid genesis block\"));\n+  }\n+\n+  public SafeFuture<Void> findAndPublishFirstValidBlock() {\n+    return eth1Provider\n+        .getLatestEth1BlockFuture()\n+        .thenApply(EthBlock.Block::getNumber)\n+        .thenApply(number -> number.subtract(Constants.ETH1_FOLLOW_DISTANCE.bigIntegerValue()))\n+        .thenApply(UnsignedLong::valueOf)\n+        .thenCompose(eth1Provider::getEth1BlockFuture)\n+        .thenCompose(\n+            block -> {\n+              SafeFuture<EthBlock.Block> firstValidBlockFuture;\n+              switch (compareBlockTimestampToMinGenesisTime(block)) {\n+                case 1:\n+                  // If block timestamp is greater than min genesis time\n+                  // find first valid block in history\n+                  firstValidBlockFuture = findFirstValidBlockInHistory(block);\n+                  break;\n+                case 0:\n+                  firstValidBlockFuture = SafeFuture.completedFuture(block);\n+                  break;\n+                case -1:\n+                  // If block timestamp is less than min genesis time\n+                  // subscribe to new block events and wait for the first\n+                  // valid block\n+                  firstValidBlockFuture = waitForFirstValidBlock();\n+                  break;\n+                default:\n+                  throw new IllegalStateException(\n+                      \"Unexpected value: \"\n+                          + calculateCandidateGenesisTimestamp(block.getTimestamp())\n+                              .compareTo(Constants.MIN_GENESIS_TIME));\n+              }\n+              return firstValidBlockFuture;\n+            })\n+        .thenAccept(this::publishFirstValidBlock)\n+        .exceptionallyCompose(\n+            err -> {\n+              LOG.debug(\n+                  \"Eth1MinGenesisTimeBlockFinder failed to find first valid block. Retry in \"\n+                      + Constants.ETH1_MIN_GENESIS_TIME_BLOCK_RETRY_TIMEOUT\n+                      + \" seconds\",\n+                  err);\n+\n+              return asyncRunner.runAfterDelay(\n+                  this::findAndPublishFirstValidBlock,\n+                  Constants.ETH1_MIN_GENESIS_TIME_BLOCK_RETRY_TIMEOUT,\n+                  TimeUnit.SECONDS);\n+            });\n+  }\n+\n+  private void publishFirstValidBlock(EthBlock.Block block) {\n+    minGenesisTimeBlockEventChannel.onMinGenesisTimeBlock(\n+        new MinGenesisTimeBlockEvent(\n+            UnsignedLong.valueOf(block.getTimestamp()),\n+            UnsignedLong.valueOf(block.getNumber()),\n+            Bytes32.fromHexString(block.getHash())));\n+  }\n+\n+  /**\n+   * Find first estimationBlock that has timestamp that is greater than MIN_GENESIS_TIME\n+   *\n+   * @param estimationBlock estimationBlock that will be used for estimation\n+   * @return first valid block in history\n+   */\n+  private SafeFuture<EthBlock.Block> findFirstValidBlockInHistory(EthBlock.Block estimationBlock) {\n+    UnsignedLong estimatedFirstValidBlockNumber =\n+        getEstimatedFirstValidBlockNumber(estimationBlock, Constants.SECONDS_PER_ETH1_BLOCK);\n+    return eth1Provider\n+        .getEth1BlockFuture(estimatedFirstValidBlockNumber)\n+        .thenCompose(\n+            block -> {\n+              SafeFuture<EthBlock.Block> firstValidBlock;\n+              switch (compareBlockTimestampToMinGenesisTime(block)) {\n+                case 1:\n+                  // If block timestamp is greater than min genesis time\n+                  // explore blocks downwards\n+                  firstValidBlock = exploreBlocksDownwards(block);\n+                  break;\n+                case 0:\n+                  firstValidBlock = SafeFuture.completedFuture(block);\n+                  break;\n+                case -1:\n+                  // If block timestamp is less than min genesis time\n+                  // explore blocks upwards\n+                  firstValidBlock = exploreBlocksUpwards(block);\n+                  break;\n+                default:\n+                  throw new IllegalStateException(\n+                      \"Unexpected value: \"\n+                          + calculateCandidateGenesisTimestamp(block.getTimestamp())\n+                              .compareTo(Constants.MIN_GENESIS_TIME));\n+              }\n+              return firstValidBlock;\n+            });\n+  }\n+\n+  private SafeFuture<EthBlock.Block> exploreBlocksDownwards(EthBlock.Block previousBlock) {\n+    UnsignedLong previousBlockNumber = UnsignedLong.valueOf(previousBlock.getNumber());\n+    UnsignedLong newBlockNumber = previousBlockNumber.minus(UnsignedLong.ONE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "061392c0279932768bc51cc872347b2c2f3940c3"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDYyMzgyMQ==", "bodyText": "done.", "url": "https://github.com/ConsenSys/teku/pull/1228#discussion_r384623821", "createdAt": "2020-02-26T16:49:03Z", "author": {"login": "cemozerr"}, "path": "pow/src/main/java/tech/pegasys/artemis/pow/Eth1MinGenesisTimeBlockFinder.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import io.reactivex.disposables.Disposable;\n+import java.math.BigInteger;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.api.MinGenesisTimeBlockEventChannel;\n+import tech.pegasys.artemis.pow.event.MinGenesisTimeBlockEvent;\n+import tech.pegasys.artemis.util.async.AsyncRunner;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class Eth1MinGenesisTimeBlockFinder {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final Eth1Provider eth1Provider;\n+  private final MinGenesisTimeBlockEventChannel minGenesisTimeBlockEventChannel;\n+  private final AsyncRunner asyncRunner;\n+\n+  private volatile Disposable latestBlockDisposable;\n+\n+  public Eth1MinGenesisTimeBlockFinder(\n+      Eth1Provider eth1Provider,\n+      MinGenesisTimeBlockEventChannel minGenesisTimeBlockEventChannel,\n+      AsyncRunner asyncRunner) {\n+    this.eth1Provider = eth1Provider;\n+    this.minGenesisTimeBlockEventChannel = minGenesisTimeBlockEventChannel;\n+    this.asyncRunner = asyncRunner;\n+  }\n+\n+  public void start() {\n+    findAndPublishFirstValidBlock()\n+        .finish(\n+            () ->\n+                LOG.info(\n+                    \"Eth1MinGenesisBlockFinder successfully found first \"\n+                        + \"(time) valid genesis block\"));\n+  }\n+\n+  public SafeFuture<Void> findAndPublishFirstValidBlock() {\n+    return eth1Provider\n+        .getLatestEth1BlockFuture()\n+        .thenApply(EthBlock.Block::getNumber)\n+        .thenApply(number -> number.subtract(Constants.ETH1_FOLLOW_DISTANCE.bigIntegerValue()))\n+        .thenApply(UnsignedLong::valueOf)\n+        .thenCompose(eth1Provider::getEth1BlockFuture)\n+        .thenCompose(\n+            block -> {\n+              SafeFuture<EthBlock.Block> firstValidBlockFuture;\n+              switch (compareBlockTimestampToMinGenesisTime(block)) {\n+                case 1:\n+                  // If block timestamp is greater than min genesis time\n+                  // find first valid block in history\n+                  firstValidBlockFuture = findFirstValidBlockInHistory(block);\n+                  break;\n+                case 0:\n+                  firstValidBlockFuture = SafeFuture.completedFuture(block);\n+                  break;\n+                case -1:\n+                  // If block timestamp is less than min genesis time\n+                  // subscribe to new block events and wait for the first\n+                  // valid block\n+                  firstValidBlockFuture = waitForFirstValidBlock();\n+                  break;\n+                default:\n+                  throw new IllegalStateException(\n+                      \"Unexpected value: \"\n+                          + calculateCandidateGenesisTimestamp(block.getTimestamp())\n+                              .compareTo(Constants.MIN_GENESIS_TIME));\n+              }\n+              return firstValidBlockFuture;\n+            })\n+        .thenAccept(this::publishFirstValidBlock)\n+        .exceptionallyCompose(\n+            err -> {\n+              LOG.debug(\n+                  \"Eth1MinGenesisTimeBlockFinder failed to find first valid block. Retry in \"\n+                      + Constants.ETH1_MIN_GENESIS_TIME_BLOCK_RETRY_TIMEOUT\n+                      + \" seconds\",\n+                  err);\n+\n+              return asyncRunner.runAfterDelay(\n+                  this::findAndPublishFirstValidBlock,\n+                  Constants.ETH1_MIN_GENESIS_TIME_BLOCK_RETRY_TIMEOUT,\n+                  TimeUnit.SECONDS);\n+            });\n+  }\n+\n+  private void publishFirstValidBlock(EthBlock.Block block) {\n+    minGenesisTimeBlockEventChannel.onMinGenesisTimeBlock(\n+        new MinGenesisTimeBlockEvent(\n+            UnsignedLong.valueOf(block.getTimestamp()),\n+            UnsignedLong.valueOf(block.getNumber()),\n+            Bytes32.fromHexString(block.getHash())));\n+  }\n+\n+  /**\n+   * Find first estimationBlock that has timestamp that is greater than MIN_GENESIS_TIME\n+   *\n+   * @param estimationBlock estimationBlock that will be used for estimation\n+   * @return first valid block in history\n+   */\n+  private SafeFuture<EthBlock.Block> findFirstValidBlockInHistory(EthBlock.Block estimationBlock) {\n+    UnsignedLong estimatedFirstValidBlockNumber =\n+        getEstimatedFirstValidBlockNumber(estimationBlock, Constants.SECONDS_PER_ETH1_BLOCK);\n+    return eth1Provider\n+        .getEth1BlockFuture(estimatedFirstValidBlockNumber)\n+        .thenCompose(\n+            block -> {\n+              SafeFuture<EthBlock.Block> firstValidBlock;\n+              switch (compareBlockTimestampToMinGenesisTime(block)) {\n+                case 1:\n+                  // If block timestamp is greater than min genesis time\n+                  // explore blocks downwards\n+                  firstValidBlock = exploreBlocksDownwards(block);\n+                  break;\n+                case 0:\n+                  firstValidBlock = SafeFuture.completedFuture(block);\n+                  break;\n+                case -1:\n+                  // If block timestamp is less than min genesis time\n+                  // explore blocks upwards\n+                  firstValidBlock = exploreBlocksUpwards(block);\n+                  break;\n+                default:\n+                  throw new IllegalStateException(\n+                      \"Unexpected value: \"\n+                          + calculateCandidateGenesisTimestamp(block.getTimestamp())\n+                              .compareTo(Constants.MIN_GENESIS_TIME));\n+              }\n+              return firstValidBlock;\n+            });\n+  }\n+\n+  private SafeFuture<EthBlock.Block> exploreBlocksDownwards(EthBlock.Block previousBlock) {\n+    UnsignedLong previousBlockNumber = UnsignedLong.valueOf(previousBlock.getNumber());\n+    UnsignedLong newBlockNumber = previousBlockNumber.minus(UnsignedLong.ONE);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI0MzQzOA=="}, "originalCommit": {"oid": "061392c0279932768bc51cc872347b2c2f3940c3"}, "originalPosition": 157}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3OTQ2OTExOnYy", "diffSide": "RIGHT", "path": "pow/README.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQwMjoyNzozN1rOFucXlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxNjo0NDoxNFrOFuzYnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI0MzYwNA==", "bodyText": "Stray character got inserted here.", "url": "https://github.com/ConsenSys/teku/pull/1228#discussion_r384243604", "createdAt": "2020-02-26T02:27:37Z", "author": {"login": "ajsutton"}, "path": "pow/README.md", "diffHunk": "@@ -1,4 +1,4 @@\n-## Proof of Work Chain Environmental Setup\n+\uffff## Proof of Work Chain Environmental Setup", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "061392c0279932768bc51cc872347b2c2f3940c3"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDYyMDcwMw==", "bodyText": "removed.", "url": "https://github.com/ConsenSys/teku/pull/1228#discussion_r384620703", "createdAt": "2020-02-26T16:44:14Z", "author": {"login": "cemozerr"}, "path": "pow/README.md", "diffHunk": "@@ -1,4 +1,4 @@\n-## Proof of Work Chain Environmental Setup\n+\uffff## Proof of Work Chain Environmental Setup", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI0MzYwNA=="}, "originalCommit": {"oid": "061392c0279932768bc51cc872347b2c2f3940c3"}, "originalPosition": 2}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4MjQ4OTEzOnYy", "diffSide": "RIGHT", "path": "pow/src/main/java/tech/pegasys/artemis/pow/Eth1MinGenesisTimeBlockFinder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQxOTozNjo1M1rOFu5Vjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNlQyMDoyNjowNlrOFu696w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcxODIyMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        (err) -> firstValidBlockFuture.completeExceptionally(new RuntimeException(err)));\n          \n          \n            \n                        (err) -> firstValidBlockFuture.completeExceptionally(err));", "url": "https://github.com/ConsenSys/teku/pull/1228#discussion_r384718223", "createdAt": "2020-02-26T19:36:53Z", "author": {"login": "ajsutton"}, "path": "pow/src/main/java/tech/pegasys/artemis/pow/Eth1MinGenesisTimeBlockFinder.java", "diffHunk": "@@ -0,0 +1,249 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import io.reactivex.disposables.Disposable;\n+import java.math.BigInteger;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.api.MinGenesisTimeBlockEventChannel;\n+import tech.pegasys.artemis.pow.event.MinGenesisTimeBlockEvent;\n+import tech.pegasys.artemis.util.async.AsyncRunner;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class Eth1MinGenesisTimeBlockFinder {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final Eth1Provider eth1Provider;\n+  private final MinGenesisTimeBlockEventChannel minGenesisTimeBlockEventChannel;\n+  private final AsyncRunner asyncRunner;\n+\n+  private volatile Disposable latestBlockDisposable;\n+\n+  public Eth1MinGenesisTimeBlockFinder(\n+      Eth1Provider eth1Provider,\n+      MinGenesisTimeBlockEventChannel minGenesisTimeBlockEventChannel,\n+      AsyncRunner asyncRunner) {\n+    this.eth1Provider = eth1Provider;\n+    this.minGenesisTimeBlockEventChannel = minGenesisTimeBlockEventChannel;\n+    this.asyncRunner = asyncRunner;\n+  }\n+\n+  public void start() {\n+    findAndPublishFirstValidBlock()\n+        .finish(\n+            () ->\n+                LOG.info(\n+                    \"Eth1MinGenesisBlockFinder successfully found first \"\n+                        + \"(time) valid genesis block\"));\n+  }\n+\n+  public SafeFuture<Void> findAndPublishFirstValidBlock() {\n+    return eth1Provider\n+        .getLatestEth1BlockFuture()\n+        .thenApply(EthBlock.Block::getNumber)\n+        .thenApply(number -> number.subtract(Constants.ETH1_FOLLOW_DISTANCE.bigIntegerValue()))\n+        .thenApply(UnsignedLong::valueOf)\n+        .thenCompose(eth1Provider::getEth1BlockFuture)\n+        .thenCompose(\n+            block -> {\n+              int comparison = compareBlockTimestampToMinGenesisTime(block);\n+              if (comparison > 0) {\n+                // If block timestamp is greater than min genesis time\n+                // find first valid block in history\n+                return findFirstValidBlockInHistory(block);\n+              } else if (comparison < 0) {\n+                // If block timestamp is less than min genesis time\n+                // subscribe to new block events and wait for the first\n+                // valid block\n+                return waitForFirstValidBlock();\n+              } else {\n+                return SafeFuture.completedFuture(block);\n+              }\n+            })\n+        .thenAccept(this::publishFirstValidBlock)\n+        .exceptionallyCompose(\n+            err -> {\n+              LOG.debug(\n+                  \"Eth1MinGenesisTimeBlockFinder failed to find first valid block. Retry in \"\n+                      + Constants.ETH1_MIN_GENESIS_TIME_BLOCK_RETRY_TIMEOUT\n+                      + \" seconds\",\n+                  err);\n+\n+              return asyncRunner.runAfterDelay(\n+                  this::findAndPublishFirstValidBlock,\n+                  Constants.ETH1_MIN_GENESIS_TIME_BLOCK_RETRY_TIMEOUT,\n+                  TimeUnit.SECONDS);\n+            });\n+  }\n+\n+  private void publishFirstValidBlock(EthBlock.Block block) {\n+    minGenesisTimeBlockEventChannel.onMinGenesisTimeBlock(\n+        new MinGenesisTimeBlockEvent(\n+            UnsignedLong.valueOf(block.getTimestamp()),\n+            UnsignedLong.valueOf(block.getNumber()),\n+            Bytes32.fromHexString(block.getHash())));\n+  }\n+\n+  /**\n+   * Find first estimationBlock that has timestamp that is greater than MIN_GENESIS_TIME\n+   *\n+   * @param estimationBlock estimationBlock that will be used for estimation\n+   * @return first valid block in history\n+   */\n+  private SafeFuture<EthBlock.Block> findFirstValidBlockInHistory(EthBlock.Block estimationBlock) {\n+    UnsignedLong estimatedFirstValidBlockNumber =\n+        getEstimatedFirstValidBlockNumber(estimationBlock, Constants.SECONDS_PER_ETH1_BLOCK);\n+    return eth1Provider\n+        .getEth1BlockFuture(estimatedFirstValidBlockNumber)\n+        .thenCompose(\n+            block -> {\n+              int comparison = compareBlockTimestampToMinGenesisTime(block);\n+              if (comparison > 0) {\n+                // If block timestamp is greater than min genesis time\n+                // explore blocks downwards\n+                return exploreBlocksDownwards(block);\n+              } else if (comparison < 0) {\n+                // If block timestamp is less than min genesis time\n+                // explore blocks upwards\n+                return exploreBlocksUpwards(block);\n+              } else {\n+                return SafeFuture.completedFuture(block);\n+              }\n+            });\n+  }\n+\n+  private SafeFuture<EthBlock.Block> exploreBlocksDownwards(EthBlock.Block previousBlock) {\n+    if (previousBlock.getNumber().equals(BigInteger.ZERO)) {\n+      throw new RuntimeException(\n+          \"Reached Eth1Genesis before reaching a valid min Eth2 genesis time, \"\n+              + \"MIN_GENESIS_TIME constant must be wrong\");\n+    }\n+    UnsignedLong previousBlockNumber = UnsignedLong.valueOf(previousBlock.getNumber());\n+    UnsignedLong newBlockNumber = previousBlockNumber.minus(UnsignedLong.ONE);\n+    SafeFuture<EthBlock.Block> blockFuture = eth1Provider.getEth1BlockFuture(newBlockNumber);\n+    return blockFuture.thenCompose(\n+        block -> {\n+          int comparison = compareBlockTimestampToMinGenesisTime(block);\n+          if (comparison > 0) {\n+            // If exploring downwards and block timestamp > min genesis time,\n+            // then block must still be downwards.\n+            return exploreBlocksDownwards(block);\n+          } else if (comparison < 0) {\n+            // If exploring downwards and block timestamp < min genesis time,\n+            // then previous block must have been the first valid block.\n+            return SafeFuture.completedFuture(previousBlock);\n+          } else {\n+            return SafeFuture.completedFuture(block);\n+          }\n+        });\n+  }\n+\n+  private SafeFuture<EthBlock.Block> exploreBlocksUpwards(EthBlock.Block previousBlock) {\n+    UnsignedLong previousBlockNumber = UnsignedLong.valueOf(previousBlock.getNumber());\n+    UnsignedLong newBlockNumber = previousBlockNumber.plus(UnsignedLong.ONE);\n+    SafeFuture<EthBlock.Block> blockFuture = eth1Provider.getEth1BlockFuture(newBlockNumber);\n+    return blockFuture.thenCompose(\n+        block -> {\n+          int comparison = compareBlockTimestampToMinGenesisTime(block);\n+          if (comparison >= 0) {\n+            // If exploring upwards and block timestamp >= min genesis time,\n+            // then current block must be the first valid block.\n+            return SafeFuture.completedFuture(block);\n+          } else {\n+            // If exploring upwards and block timestamp < min genesis time,\n+            // then previous block must have been the first valid block.\n+            return exploreBlocksUpwards(block);\n+          }\n+        });\n+  }\n+\n+  /**\n+   * Subscribes to latest block events and sees if the latest canonical block, i.e. the block at\n+   * follow distance, is the first valid block.\n+   *\n+   * @return first valid block\n+   */\n+  private SafeFuture<EthBlock.Block> waitForFirstValidBlock() {\n+    SafeFuture<EthBlock.Block> firstValidBlockFuture = new SafeFuture<>();\n+\n+    latestBlockDisposable =\n+        eth1Provider\n+            .getLatestBlockFlowable()\n+            .map(EthBlock.Block::getNumber)\n+            .map(number -> number.subtract(ETH1_FOLLOW_DISTANCE.bigIntegerValue()))\n+            .map(UnsignedLong::valueOf)\n+            .subscribe(\n+                blockNumber -> onNewBlock(blockNumber, firstValidBlockFuture),\n+                firstValidBlockFuture::completeExceptionally);\n+\n+    return firstValidBlockFuture;\n+  }\n+\n+  private void onNewBlock(\n+      UnsignedLong blockNumber, SafeFuture<EthBlock.Block> firstValidBlockFuture) {\n+\n+    eth1Provider\n+        .getEth1BlockFuture(blockNumber)\n+        .thenAccept(\n+            block -> {\n+              if (compareBlockTimestampToMinGenesisTime(block) >= 0) {\n+                firstValidBlockFuture.complete(block);\n+                latestBlockDisposable.dispose();\n+              }\n+            })\n+        .finish(\n+            () -> {},\n+            (err) -> firstValidBlockFuture.completeExceptionally(new RuntimeException(err)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7bfe18f34a7d08a069c96896020f03f08b8df06b"}, "originalPosition": 216}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc0NDkzOQ==", "bodyText": "done.", "url": "https://github.com/ConsenSys/teku/pull/1228#discussion_r384744939", "createdAt": "2020-02-26T20:26:06Z", "author": {"login": "cemozerr"}, "path": "pow/src/main/java/tech/pegasys/artemis/pow/Eth1MinGenesisTimeBlockFinder.java", "diffHunk": "@@ -0,0 +1,249 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.pow;\n+\n+import static tech.pegasys.artemis.util.config.Constants.ETH1_FOLLOW_DISTANCE;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import io.reactivex.disposables.Disposable;\n+import java.math.BigInteger;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.web3j.protocol.core.methods.response.EthBlock;\n+import tech.pegasys.artemis.pow.api.MinGenesisTimeBlockEventChannel;\n+import tech.pegasys.artemis.pow.event.MinGenesisTimeBlockEvent;\n+import tech.pegasys.artemis.util.async.AsyncRunner;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class Eth1MinGenesisTimeBlockFinder {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final Eth1Provider eth1Provider;\n+  private final MinGenesisTimeBlockEventChannel minGenesisTimeBlockEventChannel;\n+  private final AsyncRunner asyncRunner;\n+\n+  private volatile Disposable latestBlockDisposable;\n+\n+  public Eth1MinGenesisTimeBlockFinder(\n+      Eth1Provider eth1Provider,\n+      MinGenesisTimeBlockEventChannel minGenesisTimeBlockEventChannel,\n+      AsyncRunner asyncRunner) {\n+    this.eth1Provider = eth1Provider;\n+    this.minGenesisTimeBlockEventChannel = minGenesisTimeBlockEventChannel;\n+    this.asyncRunner = asyncRunner;\n+  }\n+\n+  public void start() {\n+    findAndPublishFirstValidBlock()\n+        .finish(\n+            () ->\n+                LOG.info(\n+                    \"Eth1MinGenesisBlockFinder successfully found first \"\n+                        + \"(time) valid genesis block\"));\n+  }\n+\n+  public SafeFuture<Void> findAndPublishFirstValidBlock() {\n+    return eth1Provider\n+        .getLatestEth1BlockFuture()\n+        .thenApply(EthBlock.Block::getNumber)\n+        .thenApply(number -> number.subtract(Constants.ETH1_FOLLOW_DISTANCE.bigIntegerValue()))\n+        .thenApply(UnsignedLong::valueOf)\n+        .thenCompose(eth1Provider::getEth1BlockFuture)\n+        .thenCompose(\n+            block -> {\n+              int comparison = compareBlockTimestampToMinGenesisTime(block);\n+              if (comparison > 0) {\n+                // If block timestamp is greater than min genesis time\n+                // find first valid block in history\n+                return findFirstValidBlockInHistory(block);\n+              } else if (comparison < 0) {\n+                // If block timestamp is less than min genesis time\n+                // subscribe to new block events and wait for the first\n+                // valid block\n+                return waitForFirstValidBlock();\n+              } else {\n+                return SafeFuture.completedFuture(block);\n+              }\n+            })\n+        .thenAccept(this::publishFirstValidBlock)\n+        .exceptionallyCompose(\n+            err -> {\n+              LOG.debug(\n+                  \"Eth1MinGenesisTimeBlockFinder failed to find first valid block. Retry in \"\n+                      + Constants.ETH1_MIN_GENESIS_TIME_BLOCK_RETRY_TIMEOUT\n+                      + \" seconds\",\n+                  err);\n+\n+              return asyncRunner.runAfterDelay(\n+                  this::findAndPublishFirstValidBlock,\n+                  Constants.ETH1_MIN_GENESIS_TIME_BLOCK_RETRY_TIMEOUT,\n+                  TimeUnit.SECONDS);\n+            });\n+  }\n+\n+  private void publishFirstValidBlock(EthBlock.Block block) {\n+    minGenesisTimeBlockEventChannel.onMinGenesisTimeBlock(\n+        new MinGenesisTimeBlockEvent(\n+            UnsignedLong.valueOf(block.getTimestamp()),\n+            UnsignedLong.valueOf(block.getNumber()),\n+            Bytes32.fromHexString(block.getHash())));\n+  }\n+\n+  /**\n+   * Find first estimationBlock that has timestamp that is greater than MIN_GENESIS_TIME\n+   *\n+   * @param estimationBlock estimationBlock that will be used for estimation\n+   * @return first valid block in history\n+   */\n+  private SafeFuture<EthBlock.Block> findFirstValidBlockInHistory(EthBlock.Block estimationBlock) {\n+    UnsignedLong estimatedFirstValidBlockNumber =\n+        getEstimatedFirstValidBlockNumber(estimationBlock, Constants.SECONDS_PER_ETH1_BLOCK);\n+    return eth1Provider\n+        .getEth1BlockFuture(estimatedFirstValidBlockNumber)\n+        .thenCompose(\n+            block -> {\n+              int comparison = compareBlockTimestampToMinGenesisTime(block);\n+              if (comparison > 0) {\n+                // If block timestamp is greater than min genesis time\n+                // explore blocks downwards\n+                return exploreBlocksDownwards(block);\n+              } else if (comparison < 0) {\n+                // If block timestamp is less than min genesis time\n+                // explore blocks upwards\n+                return exploreBlocksUpwards(block);\n+              } else {\n+                return SafeFuture.completedFuture(block);\n+              }\n+            });\n+  }\n+\n+  private SafeFuture<EthBlock.Block> exploreBlocksDownwards(EthBlock.Block previousBlock) {\n+    if (previousBlock.getNumber().equals(BigInteger.ZERO)) {\n+      throw new RuntimeException(\n+          \"Reached Eth1Genesis before reaching a valid min Eth2 genesis time, \"\n+              + \"MIN_GENESIS_TIME constant must be wrong\");\n+    }\n+    UnsignedLong previousBlockNumber = UnsignedLong.valueOf(previousBlock.getNumber());\n+    UnsignedLong newBlockNumber = previousBlockNumber.minus(UnsignedLong.ONE);\n+    SafeFuture<EthBlock.Block> blockFuture = eth1Provider.getEth1BlockFuture(newBlockNumber);\n+    return blockFuture.thenCompose(\n+        block -> {\n+          int comparison = compareBlockTimestampToMinGenesisTime(block);\n+          if (comparison > 0) {\n+            // If exploring downwards and block timestamp > min genesis time,\n+            // then block must still be downwards.\n+            return exploreBlocksDownwards(block);\n+          } else if (comparison < 0) {\n+            // If exploring downwards and block timestamp < min genesis time,\n+            // then previous block must have been the first valid block.\n+            return SafeFuture.completedFuture(previousBlock);\n+          } else {\n+            return SafeFuture.completedFuture(block);\n+          }\n+        });\n+  }\n+\n+  private SafeFuture<EthBlock.Block> exploreBlocksUpwards(EthBlock.Block previousBlock) {\n+    UnsignedLong previousBlockNumber = UnsignedLong.valueOf(previousBlock.getNumber());\n+    UnsignedLong newBlockNumber = previousBlockNumber.plus(UnsignedLong.ONE);\n+    SafeFuture<EthBlock.Block> blockFuture = eth1Provider.getEth1BlockFuture(newBlockNumber);\n+    return blockFuture.thenCompose(\n+        block -> {\n+          int comparison = compareBlockTimestampToMinGenesisTime(block);\n+          if (comparison >= 0) {\n+            // If exploring upwards and block timestamp >= min genesis time,\n+            // then current block must be the first valid block.\n+            return SafeFuture.completedFuture(block);\n+          } else {\n+            // If exploring upwards and block timestamp < min genesis time,\n+            // then previous block must have been the first valid block.\n+            return exploreBlocksUpwards(block);\n+          }\n+        });\n+  }\n+\n+  /**\n+   * Subscribes to latest block events and sees if the latest canonical block, i.e. the block at\n+   * follow distance, is the first valid block.\n+   *\n+   * @return first valid block\n+   */\n+  private SafeFuture<EthBlock.Block> waitForFirstValidBlock() {\n+    SafeFuture<EthBlock.Block> firstValidBlockFuture = new SafeFuture<>();\n+\n+    latestBlockDisposable =\n+        eth1Provider\n+            .getLatestBlockFlowable()\n+            .map(EthBlock.Block::getNumber)\n+            .map(number -> number.subtract(ETH1_FOLLOW_DISTANCE.bigIntegerValue()))\n+            .map(UnsignedLong::valueOf)\n+            .subscribe(\n+                blockNumber -> onNewBlock(blockNumber, firstValidBlockFuture),\n+                firstValidBlockFuture::completeExceptionally);\n+\n+    return firstValidBlockFuture;\n+  }\n+\n+  private void onNewBlock(\n+      UnsignedLong blockNumber, SafeFuture<EthBlock.Block> firstValidBlockFuture) {\n+\n+    eth1Provider\n+        .getEth1BlockFuture(blockNumber)\n+        .thenAccept(\n+            block -> {\n+              if (compareBlockTimestampToMinGenesisTime(block) >= 0) {\n+                firstValidBlockFuture.complete(block);\n+                latestBlockDisposable.dispose();\n+              }\n+            })\n+        .finish(\n+            () -> {},\n+            (err) -> firstValidBlockFuture.completeExceptionally(new RuntimeException(err)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcxODIyMw=="}, "originalCommit": {"oid": "7bfe18f34a7d08a069c96896020f03f08b8df06b"}, "originalPosition": 216}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2676, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}