{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzU5NjAzMTA0", "number": 1081, "title": "[BC-175] Isolate libp2p dependencies", "bodyText": "PR Description\nCreate more explicit p2p rpc API's and reorganize eth2 rpc logic in order to use these new API's and remove libp2p-specific dependencies (Protocol, Connection, ChannelHandlerContext, etc).\nThe bulk of the changes here involve breaking up the old RpcMessageHandler across the new classes RpcHandler, Eth2IncomingRequestHandler, and Eth2OutgoingRequestHandler and consolidating rpc-method-related logic in the new Eth2RpcMethod class.", "createdAt": "2020-01-06T16:00:27Z", "url": "https://github.com/ConsenSys/teku/pull/1081", "merged": true, "mergeCommit": {"oid": "6f7f58cf968c035b2dcc0845adb3259dfe8a877c"}, "closed": true, "closedAt": "2020-01-06T21:58:14Z", "author": {"login": "mbaxter"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb3t7bOAH2gAyMzU5NjAzMTA0OjUwNGVlMjQ0MjEyNDk3ZDcyYzhjZDk0ZGQ5OTlhZTkyYTQ5OTVmOGQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb31ASngFqTMzODk2MjExMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "504ee244212497d72c8cd94dd999ae92a4995f8d", "author": {"user": {"login": "mbaxter", "name": null}}, "url": "https://github.com/ConsenSys/teku/commit/504ee244212497d72c8cd94dd999ae92a4995f8d", "committedDate": "2020-01-06T15:31:24Z", "message": "Reduce eth2 dependencies on netty / libp2p"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cc65b988c06d325625b55a7cb16c9469bed6f8fe", "author": {"user": {"login": "mbaxter", "name": null}}, "url": "https://github.com/ConsenSys/teku/commit/cc65b988c06d325625b55a7cb16c9469bed6f8fe", "committedDate": "2020-01-06T15:42:12Z", "message": "Remove RpcMethods interface"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "13b30f84b345493ec2b540b9d270fcef30af2874", "author": {"user": {"login": "mbaxter", "name": null}}, "url": "https://github.com/ConsenSys/teku/commit/13b30f84b345493ec2b540b9d270fcef30af2874", "committedDate": "2020-01-06T15:59:37Z", "message": "Cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a611f69918fd335005063890d78e20e25c061116", "author": {"user": {"login": "mbaxter", "name": null}}, "url": "https://github.com/ConsenSys/teku/commit/a611f69918fd335005063890d78e20e25c061116", "committedDate": "2020-01-06T17:49:25Z", "message": "Add handlerRemoved logic back in, rework RpcRequestHandler API"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0025d7b941e51b3032ba2167ba71fe6a4ed24e42", "author": {"user": {"login": "mbaxter", "name": null}}, "url": "https://github.com/ConsenSys/teku/commit/0025d7b941e51b3032ba2167ba71fe6a4ed24e42", "committedDate": "2020-01-06T18:17:30Z", "message": "Fix disconnect logic"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM4ODkzODUw", "url": "https://github.com/ConsenSys/teku/pull/1081#pullrequestreview-338893850", "createdAt": "2020-01-06T21:04:00Z", "commit": {"oid": "0025d7b941e51b3032ba2167ba71fe6a4ed24e42"}, "state": "APPROVED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wNlQyMTowNDowMFrOFapLfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wNlQyMToxMDo0M1rOFapVgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzQ4MTk4MQ==", "bodyText": "Strictly these should probably be get prefixed, but it is one of those cases where it feels right to break the rule (and I'm usually a big fan of get prefixes...).", "url": "https://github.com/ConsenSys/teku/pull/1081#discussion_r363481981", "createdAt": "2020-01-06T21:04:00Z", "author": {"login": "ajsutton"}, "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/rpc/beaconchain/BeaconChainMethods.java", "diffHunk": "@@ -25,57 +28,126 @@\n import tech.pegasys.artemis.networking.eth2.rpc.beaconchain.methods.GoodbyeMessageHandler;\n import tech.pegasys.artemis.networking.eth2.rpc.beaconchain.methods.StatusMessageFactory;\n import tech.pegasys.artemis.networking.eth2.rpc.beaconchain.methods.StatusMessageHandler;\n-import tech.pegasys.artemis.networking.eth2.rpc.core.RpcMessageHandler;\n-import tech.pegasys.artemis.networking.eth2.rpc.core.RpcMethod;\n-import tech.pegasys.artemis.networking.eth2.rpc.core.RpcMethods;\n+import tech.pegasys.artemis.networking.eth2.rpc.core.Eth2RpcMethod;\n import tech.pegasys.artemis.networking.eth2.rpc.core.encodings.RpcEncoding;\n+import tech.pegasys.artemis.networking.p2p.rpc.RpcMethod;\n import tech.pegasys.artemis.storage.ChainStorageClient;\n import tech.pegasys.artemis.storage.CombinedChainDataClient;\n \n public class BeaconChainMethods {\n-  public static final RpcMethod<StatusMessage, StatusMessage> STATUS =\n-      new RpcMethod<>(\n-          \"/eth2/beacon_chain/req/status/1\",\n-          RpcEncoding.SSZ,\n-          StatusMessage.class,\n-          StatusMessage.class);\n-  public static final RpcMethod<GoodbyeMessage, GoodbyeMessage> GOODBYE =\n-      new RpcMethod<>(\n-          \"/eth2/beacon_chain/req/goodbye/1\",\n-          RpcEncoding.SSZ,\n-          GoodbyeMessage.class,\n-          GoodbyeMessage.class);\n-  public static final RpcMethod<BeaconBlocksByRootRequestMessage, BeaconBlock>\n-      BEACON_BLOCKS_BY_ROOT =\n-          new RpcMethod<>(\n-              \"/eth2/beacon_chain/req/beacon_blocks_by_root/1\",\n-              RpcEncoding.SSZ,\n-              BeaconBlocksByRootRequestMessage.class,\n-              BeaconBlock.class);\n-  public static final RpcMethod<BeaconBlocksByRangeRequestMessage, BeaconBlock>\n-      BEACON_BLOCKS_BY_RANGE =\n-          new RpcMethod<>(\n-              \"/eth2/beacon_chain/req/beacon_blocks_by_range/1\",\n-              RpcEncoding.SSZ,\n-              BeaconBlocksByRangeRequestMessage.class,\n-              BeaconBlock.class);\n-\n-  public static RpcMethods createRpcMethods(\n-      PeerLookup peerLookup,\n+  private static final String STATUS = \"/eth2/beacon_chain/req/status/1\";\n+  private static final String GOODBYE = \"/eth2/beacon_chain/req/goodbye/1\";\n+  private static final String BEACON_BLOCKS_BY_ROOT =\n+      \"/eth2/beacon_chain/req/beacon_blocks_by_root/1\";\n+  private static final String BEACON_BLOCKS_BY_RANGE =\n+      \"/eth2/beacon_chain/req/beacon_blocks_by_range/1\";\n+\n+  private final Eth2RpcMethod<StatusMessage, StatusMessage> status;\n+  private final Eth2RpcMethod<GoodbyeMessage, GoodbyeMessage> goodBye;\n+  private final Eth2RpcMethod<BeaconBlocksByRootRequestMessage, BeaconBlock> beaconBlocksByRoot;\n+  private final Eth2RpcMethod<BeaconBlocksByRangeRequestMessage, BeaconBlock> beaconBlocksByRange;\n+\n+  private final Collection<Eth2RpcMethod<?, ?>> allMethods;\n+\n+  private BeaconChainMethods(\n+      final Eth2RpcMethod<StatusMessage, StatusMessage> status,\n+      final Eth2RpcMethod<GoodbyeMessage, GoodbyeMessage> goodBye,\n+      final Eth2RpcMethod<BeaconBlocksByRootRequestMessage, BeaconBlock> beaconBlocksByRoot,\n+      final Eth2RpcMethod<BeaconBlocksByRangeRequestMessage, BeaconBlock> beaconBlocksByRange) {\n+    this.status = status;\n+    this.goodBye = goodBye;\n+    this.beaconBlocksByRoot = beaconBlocksByRoot;\n+    this.beaconBlocksByRange = beaconBlocksByRange;\n+    allMethods = List.of(status, goodBye, beaconBlocksByRoot, beaconBlocksByRange);\n+  }\n+\n+  public static BeaconChainMethods create(\n+      final PeerLookup peerLookup,\n       final CombinedChainDataClient combinedChainDataClient,\n       final ChainStorageClient chainStorageClient,\n       final MetricsSystem metricsSystem,\n       final StatusMessageFactory statusMessageFactory) {\n+    return new BeaconChainMethods(\n+        createStatus(statusMessageFactory, peerLookup),\n+        createGoodBye(metricsSystem, peerLookup),\n+        createBeaconBlocksByRoot(chainStorageClient, peerLookup),\n+        createBeaconBlocksByRange(combinedChainDataClient, peerLookup));\n+  }\n+\n+  private static Eth2RpcMethod<StatusMessage, StatusMessage> createStatus(\n+      final StatusMessageFactory statusMessageFactory, final PeerLookup peerLookup) {\n     final StatusMessageHandler statusHandler = new StatusMessageHandler(statusMessageFactory);\n+    return new Eth2RpcMethod<>(\n+        STATUS,\n+        RpcEncoding.SSZ,\n+        StatusMessage.class,\n+        StatusMessage.class,\n+        false,\n+        statusHandler,\n+        peerLookup);\n+  }\n+\n+  private static Eth2RpcMethod<GoodbyeMessage, GoodbyeMessage> createGoodBye(\n+      final MetricsSystem metricsSystem, final PeerLookup peerLookup) {\n     final GoodbyeMessageHandler goodbyeHandler = new GoodbyeMessageHandler(metricsSystem);\n+    return new Eth2RpcMethod<>(\n+        GOODBYE,\n+        RpcEncoding.SSZ,\n+        GoodbyeMessage.class,\n+        GoodbyeMessage.class,\n+        true,\n+        goodbyeHandler,\n+        peerLookup);\n+  }\n+\n+  private static Eth2RpcMethod<BeaconBlocksByRootRequestMessage, BeaconBlock>\n+      createBeaconBlocksByRoot(\n+          final ChainStorageClient chainStorageClient, final PeerLookup peerLookup) {\n     final BeaconBlocksByRootMessageHandler beaconBlocksByRootHandler =\n         new BeaconBlocksByRootMessageHandler(chainStorageClient);\n+    return new Eth2RpcMethod<>(\n+        BEACON_BLOCKS_BY_ROOT,\n+        RpcEncoding.SSZ,\n+        BeaconBlocksByRootRequestMessage.class,\n+        BeaconBlock.class,\n+        false,\n+        beaconBlocksByRootHandler,\n+        peerLookup);\n+  }\n+\n+  private static Eth2RpcMethod<BeaconBlocksByRangeRequestMessage, BeaconBlock>\n+      createBeaconBlocksByRange(\n+          final CombinedChainDataClient combinedChainDataClient, final PeerLookup peerLookup) {\n+\n     final BeaconBlocksByRangeMessageHandler beaconBlocksByRangeHandler =\n         new BeaconBlocksByRangeMessageHandler(combinedChainDataClient);\n-    return new RpcMethods(\n-        new RpcMessageHandler<>(STATUS, peerLookup, statusHandler),\n-        new RpcMessageHandler<>(GOODBYE, peerLookup, goodbyeHandler).setCloseNotification(),\n-        new RpcMessageHandler<>(BEACON_BLOCKS_BY_ROOT, peerLookup, beaconBlocksByRootHandler),\n-        new RpcMessageHandler<>(BEACON_BLOCKS_BY_RANGE, peerLookup, beaconBlocksByRangeHandler));\n+    return new Eth2RpcMethod<>(\n+        BEACON_BLOCKS_BY_RANGE,\n+        RpcEncoding.SSZ,\n+        BeaconBlocksByRangeRequestMessage.class,\n+        BeaconBlock.class,\n+        false,\n+        beaconBlocksByRangeHandler,\n+        peerLookup);\n+  }\n+\n+  public Collection<RpcMethod> all() {\n+    return Collections.unmodifiableCollection(allMethods);\n+  }\n+\n+  public Eth2RpcMethod<StatusMessage, StatusMessage> status() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0025d7b941e51b3032ba2167ba71fe6a4ed24e42"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzQ4MzA1NA==", "bodyText": "Does this need reportExceptions()?", "url": "https://github.com/ConsenSys/teku/pull/1081#discussion_r363483054", "createdAt": "2020-01-06T21:06:42Z", "author": {"login": "ajsutton"}, "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/rpc/core/RpcResponseCallback.java", "diffHunk": "@@ -13,57 +13,36 @@\n \n package tech.pegasys.artemis.networking.eth2.rpc.core;\n \n-import io.libp2p.core.Connection;\n-import io.netty.buffer.ByteBuf;\n-import io.netty.channel.ChannelHandlerContext;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n-import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.artemis.networking.p2p.rpc.RpcStream;\n \n class RpcResponseCallback<TResponse> implements ResponseCallback<TResponse> {\n   private static final Logger LOG = LogManager.getLogger();\n-  private final ChannelHandlerContext ctx;\n   private final RpcEncoder rpcEncoder;\n-  private final boolean closeNotification;\n-  private final Connection connection;\n+  private final RpcStream rpcStream;\n \n-  public RpcResponseCallback(\n-      final ChannelHandlerContext ctx,\n-      final RpcEncoder rpcEncoder,\n-      final boolean closeNotification,\n-      final Connection connection) {\n-    this.ctx = ctx;\n+  public RpcResponseCallback(final RpcStream rpcStream, final RpcEncoder rpcEncoder) {\n+    this.rpcStream = rpcStream;\n     this.rpcEncoder = rpcEncoder;\n-    this.closeNotification = closeNotification;\n-    this.connection = connection;\n   }\n \n   @Override\n   public void respond(final TResponse data) {\n-    writeResponse(ctx, rpcEncoder.encodeSuccessfulResponse(data));\n+    rpcStream.writeBytes(rpcEncoder.encodeSuccessfulResponse(data)).reportExceptions();\n   }\n \n   @Override\n   @SuppressWarnings(\"FutureReturnValueIgnored\")\n   public void completeSuccessfully() {\n-    ctx.channel().disconnect();\n-    if (closeNotification) {\n-      connection.getNettyChannel().close();\n-    }\n+    rpcStream.disconnect().reportExceptions();\n   }\n \n   @Override\n   @SuppressWarnings(\"FutureReturnValueIgnored\")\n   public void completeWithError(final RpcException error) {\n     LOG.debug(\"Responding to RPC request with error: {}\", error.getErrorMessage());\n-    writeResponse(ctx, rpcEncoder.encodeErrorResponse(error));\n-    ctx.channel().disconnect();\n-  }\n-\n-  @SuppressWarnings(\"FutureReturnValueIgnored\")\n-  private void writeResponse(final ChannelHandlerContext ctx, final Bytes encoded) {\n-    ByteBuf respBuf = ctx.alloc().buffer();\n-    respBuf.writeBytes(encoded.toArrayUnsafe());\n-    ctx.writeAndFlush(respBuf);\n+    rpcStream.writeBytes(rpcEncoder.encodeErrorResponse(error));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0025d7b941e51b3032ba2167ba71fe6a4ed24e42"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzQ4Mzg3OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  throw new IllegalArgumentException(\"Unknown rpc method method invoked: \" + rpcMethod.getId());\n          \n          \n            \n                  throw new IllegalArgumentException(\"Unknown rpc method invoked: \" + rpcMethod.getId());", "url": "https://github.com/ConsenSys/teku/pull/1081#discussion_r363483879", "createdAt": "2020-01-06T21:08:51Z", "author": {"login": "ajsutton"}, "path": "networking/p2p/src/main/java/tech/pegasys/artemis/networking/p2p/libp2p/LibP2PPeer.java", "diffHunk": "@@ -39,8 +50,19 @@ public boolean isConnected() {\n   }\n \n   @Override\n-  public Connection getConnection() {\n-    return connection;\n+  @SuppressWarnings(\"FutureReturnValueIgnored\")\n+  public void disconnect() {\n+    connection.getNettyChannel().close();\n+  }\n+\n+  @Override\n+  public SafeFuture<RpcStream> sendRequest(\n+      RpcMethod rpcMethod, final Bytes initialPayload, final RpcRequestHandler handler) {\n+    RpcHandler rpcHandler = rpcHandlers.get(rpcMethod);\n+    if (rpcHandler == null) {\n+      throw new IllegalArgumentException(\"Unknown rpc method method invoked: \" + rpcMethod.getId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0025d7b941e51b3032ba2167ba71fe6a4ed24e42"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzQ4NDU0NA==", "bodyText": "Really like this abstraction to hide the Netty APIs.", "url": "https://github.com/ConsenSys/teku/pull/1081#discussion_r363484544", "createdAt": "2020-01-06T21:10:43Z", "author": {"login": "ajsutton"}, "path": "networking/p2p/src/main/java/tech/pegasys/artemis/networking/p2p/libp2p/rpc/LibP2PRpcStream.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.networking.p2p.libp2p.rpc;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelHandlerContext;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import org.apache.tuweni.bytes.Bytes;\n+import tech.pegasys.artemis.networking.p2p.rpc.RpcStream;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+\n+public class LibP2PRpcStream implements RpcStream {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0025d7b941e51b3032ba2167ba71fe6a4ed24e42"}, "originalPosition": 24}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7a64f4874fdd501a33002ed097b7588823e458ba", "author": {"user": {"login": "mbaxter", "name": null}}, "url": "https://github.com/ConsenSys/teku/commit/7a64f4874fdd501a33002ed097b7588823e458ba", "committedDate": "2020-01-06T21:28:19Z", "message": "Fix exception message\n\nCo-Authored-By: Adrian Sutton <adrian@symphonious.net>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2f595fe18d74b172d596dfa4cdbd24d1e75364ac", "author": {"user": {"login": "mbaxter", "name": null}}, "url": "https://github.com/ConsenSys/teku/commit/2f595fe18d74b172d596dfa4cdbd24d1e75364ac", "committedDate": "2020-01-06T21:49:42Z", "message": "Report exception if writeBytes fails"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM4OTYyMTEw", "url": "https://github.com/ConsenSys/teku/pull/1081#pullrequestreview-338962110", "createdAt": "2020-01-06T23:46:03Z", "commit": {"oid": "2f595fe18d74b172d596dfa4cdbd24d1e75364ac"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wNlQyMzo0NjowM1rOFascjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wNlQyMzo0NjowM1rOFascjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2MzUzNTUwMg==", "bodyText": "is the 0 here on the method name on purpose?", "url": "https://github.com/ConsenSys/teku/pull/1081#discussion_r363535502", "createdAt": "2020-01-06T23:46:03Z", "author": {"login": "cemozerr"}, "path": "networking/p2p/src/main/java/tech/pegasys/artemis/networking/p2p/libp2p/rpc/RpcHandler.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Copyright 2019 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.networking.p2p.libp2p.rpc;\n+\n+import io.libp2p.core.Connection;\n+import io.libp2p.core.P2PAbstractChannel;\n+import io.libp2p.core.multistream.Mode;\n+import io.libp2p.core.multistream.Multistream;\n+import io.libp2p.core.multistream.ProtocolBinding;\n+import io.libp2p.core.multistream.ProtocolMatcher;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.jetbrains.annotations.NotNull;\n+import tech.pegasys.artemis.networking.p2p.libp2p.LibP2PNodeId;\n+import tech.pegasys.artemis.networking.p2p.libp2p.rpc.RpcHandler.Controller;\n+import tech.pegasys.artemis.networking.p2p.peer.NodeId;\n+import tech.pegasys.artemis.networking.p2p.rpc.RpcMethod;\n+import tech.pegasys.artemis.networking.p2p.rpc.RpcRequestHandler;\n+import tech.pegasys.artemis.networking.p2p.rpc.RpcStream;\n+import tech.pegasys.artemis.util.async.SafeFuture;\n+\n+public class RpcHandler implements ProtocolBinding<Controller> {\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final RpcMethod rpcMethod;\n+\n+  public RpcHandler(RpcMethod rpcMethod) {\n+    this.rpcMethod = rpcMethod;\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  public SafeFuture<RpcStream> sendRequest(\n+      Connection connection, Bytes initialPayload, RpcRequestHandler handler) {\n+    return SafeFuture.of(\n+            connection\n+                .getMuxerSession()\n+                .createStream(\n+                    Multistream.create(this.toInitiator(rpcMethod.getId())).toStreamHandler())\n+                .getControler())\n+        .thenCompose(\n+            ctr -> {\n+              ctr.setRequestHandler(handler);\n+              return ctr.getRpcStream()\n+                  .writeBytes(initialPayload)\n+                  .thenApply(f -> ctr.getRpcStream());\n+            });\n+  }\n+\n+  @NotNull\n+  @Override\n+  public String getAnnounce() {\n+    return rpcMethod.getId();\n+  }\n+\n+  @NotNull\n+  @Override\n+  public ProtocolMatcher getMatcher() {\n+    return new ProtocolMatcher(Mode.STRICT, getAnnounce(), null);\n+  }\n+\n+  @NotNull\n+  @Override\n+  public SafeFuture<Controller> initChannel(P2PAbstractChannel channel, String s) {\n+    // TODO timeout handlers\n+    final Connection connection = ((io.libp2p.core.Stream) channel).getConn();\n+    final NodeId nodeId = new LibP2PNodeId(connection.getSecureSession().getRemoteId());\n+    Controller controller = new Controller(nodeId);\n+    if (!channel.isInitiator()) {\n+      controller.setRequestHandler(rpcMethod.createIncomingRequestHandler());\n+    }\n+    channel.getNettyChannel().pipeline().addLast(controller);\n+    return controller.activeFuture;\n+  }\n+\n+  static class Controller extends SimpleChannelInboundHandler<ByteBuf> {\n+    private final NodeId nodeId;\n+    private RpcRequestHandler rpcRequestHandler;\n+    private RpcStream rpcStream;\n+    private List<ByteBuf> bufferedData = new ArrayList<>();\n+\n+    protected final SafeFuture<Controller> activeFuture = new SafeFuture<>();\n+\n+    private Controller(final NodeId nodeId) {\n+      this.nodeId = nodeId;\n+    }\n+\n+    @Override\n+    public void channelActive(ChannelHandlerContext ctx) {\n+      rpcStream = new LibP2PRpcStream(ctx);\n+      activeFuture.complete(this);\n+    }\n+\n+    public RpcStream getRpcStream() {\n+      return rpcStream;\n+    }\n+\n+    @Override\n+    protected void channelRead0(final ChannelHandlerContext ctx, final ByteBuf msg) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f595fe18d74b172d596dfa4cdbd24d1e75364ac"}, "originalPosition": 115}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4179, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}