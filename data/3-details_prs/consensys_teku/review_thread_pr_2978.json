{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAzNzc0Njky", "number": 2978, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQwMzoyNTozNFrOEtwxOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQwMzoyNjo1OVrOEtwyIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2NDIwNDA5OnYy", "diffSide": "RIGHT", "path": "validator/beaconnode/src/main/java/tech/pegasys/teku/validator/beaconnode/TimeBasedEventAdapter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQwMzoyNTozNFrOHhvbjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQwMzo0NTo1NlrOHhvvAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTE0MjE1Nw==", "bodyText": "Could this continue using genesisDataProvider.getGenesisTime()?", "url": "https://github.com/ConsenSys/teku/pull/2978#discussion_r505142157", "createdAt": "2020-10-15T03:25:34Z", "author": {"login": "ajsutton"}, "path": "validator/beaconnode/src/main/java/tech/pegasys/teku/validator/beaconnode/TimeBasedEventAdapter.java", "diffHunk": "@@ -87,7 +88,7 @@ private boolean isTooLate(final UInt64 scheduledTime, final UInt64 actualTime) {\n   public SafeFuture<Void> start() {\n     // Don't wait for the genesis time to be available before considering startup complete\n     // The beacon node may not be available or genesis may not yet be known.\n-    genesisTimeProvider.getGenesisTime().thenAccept(this::start).reportExceptions();\n+    genesisDataProvider.getGenesisData().thenAccept(this::start).reportExceptions();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "144ad0df72b9cdbf8900bdc5fd776c52212c6ed5"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTE0NzEzOQ==", "bodyText": "yep it got caught in a rename", "url": "https://github.com/ConsenSys/teku/pull/2978#discussion_r505147139", "createdAt": "2020-10-15T03:45:56Z", "author": {"login": "rolfyone"}, "path": "validator/beaconnode/src/main/java/tech/pegasys/teku/validator/beaconnode/TimeBasedEventAdapter.java", "diffHunk": "@@ -87,7 +88,7 @@ private boolean isTooLate(final UInt64 scheduledTime, final UInt64 actualTime) {\n   public SafeFuture<Void> start() {\n     // Don't wait for the genesis time to be available before considering startup complete\n     // The beacon node may not be available or genesis may not yet be known.\n-    genesisTimeProvider.getGenesisTime().thenAccept(this::start).reportExceptions();\n+    genesisDataProvider.getGenesisData().thenAccept(this::start).reportExceptions();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTE0MjE1Nw=="}, "originalCommit": {"oid": "144ad0df72b9cdbf8900bdc5fd776c52212c6ed5"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE2NDIwNjQwOnYy", "diffSide": "RIGHT", "path": "validator/beaconnode/src/test/java/tech/pegasys/teku/validator/beaconnode/GenesisDataProviderTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQwMzoyNjo1OVrOHhvc4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQwMzo1MDoyOVrOHhvzHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTE0MjQ5Ng==", "bodyText": "This case is the same as shouldRetryWhenGenesisTimeIsNotYetKnown", "url": "https://github.com/ConsenSys/teku/pull/2978#discussion_r505142496", "createdAt": "2020-10-15T03:26:59Z", "author": {"login": "ajsutton"}, "path": "validator/beaconnode/src/test/java/tech/pegasys/teku/validator/beaconnode/GenesisDataProviderTest.java", "diffHunk": "@@ -23,79 +23,107 @@\n import static tech.pegasys.teku.infrastructure.async.SafeFuture.failedFuture;\n \n import java.util.Optional;\n+import org.apache.tuweni.bytes.Bytes32;\n import org.assertj.core.api.Assertions;\n import org.junit.jupiter.api.Test;\n+import tech.pegasys.teku.datastructures.genesis.GenesisData;\n import tech.pegasys.teku.infrastructure.async.SafeFuture;\n import tech.pegasys.teku.infrastructure.async.StubAsyncRunner;\n import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n import tech.pegasys.teku.validator.api.ValidatorApiChannel;\n \n-class GenesisTimeProviderTest {\n+class GenesisDataProviderTest {\n \n   private static final UInt64 GENESIS_TIME = UInt64.valueOf(12341234);\n+  private static final Bytes32 GENESIS_VALIDATORS_ROOT = Bytes32.fromHexString(\"0x01\");\n   private final StubAsyncRunner asyncRunner = new StubAsyncRunner();\n   private final ValidatorApiChannel validatorApiChannel = mock(ValidatorApiChannel.class);\n \n-  private final GenesisTimeProvider genesisTimeProvider =\n-      new GenesisTimeProvider(asyncRunner, validatorApiChannel);\n+  private final GenesisDataProvider genesisDataProvider =\n+      new GenesisDataProvider(asyncRunner, validatorApiChannel);\n \n   @Test\n   void shouldRequestGenesisTimeWhenNotPreviouslyLoaded() {\n-    final SafeFuture<Optional<UInt64>> request = new SafeFuture<>();\n-    when(validatorApiChannel.getGenesisTime()).thenReturn(request);\n+    final SafeFuture<Optional<GenesisData>> request = new SafeFuture<>();\n+    when(validatorApiChannel.getGenesisData()).thenReturn(request);\n \n-    final SafeFuture<UInt64> result = genesisTimeProvider.getGenesisTime();\n+    final SafeFuture<UInt64> result = genesisDataProvider.getGenesisTime();\n     assertThat(result).isNotDone();\n \n-    request.complete(Optional.of(GENESIS_TIME));\n+    request.complete(Optional.of(new GenesisData(GENESIS_TIME, GENESIS_VALIDATORS_ROOT)));\n     assertThat(result).isCompletedWithValue(GENESIS_TIME);\n   }\n \n   @Test\n   void shouldReturnCachedGenesisTimeWhenPreviouslyLoaded() {\n-    when(validatorApiChannel.getGenesisTime())\n-        .thenReturn(SafeFuture.completedFuture(Optional.of(GENESIS_TIME)));\n-    assertThat(genesisTimeProvider.getGenesisTime()).isCompletedWithValue(GENESIS_TIME);\n-    verify(validatorApiChannel).getGenesisTime();\n+    when(validatorApiChannel.getGenesisData())\n+        .thenReturn(\n+            SafeFuture.completedFuture(\n+                Optional.of(new GenesisData(GENESIS_TIME, GENESIS_VALIDATORS_ROOT))));\n+    assertThat(genesisDataProvider.getGenesisData())\n+        .isCompletedWithValue(new GenesisData(GENESIS_TIME, GENESIS_VALIDATORS_ROOT));\n+    verify(validatorApiChannel).getGenesisData();\n \n     // Subsequent requests just return the cached version\n-    assertThat(genesisTimeProvider.getGenesisTime()).isCompletedWithValue(GENESIS_TIME);\n+    assertThat(genesisDataProvider.getGenesisData())\n+        .isCompletedWithValue(new GenesisData(GENESIS_TIME, GENESIS_VALIDATORS_ROOT));\n     verifyNoMoreInteractions(validatorApiChannel);\n   }\n \n   @Test\n   void shouldRetryWhenGenesisTimeFailsToLoad() {\n-    when(validatorApiChannel.getGenesisTime())\n+    when(validatorApiChannel.getGenesisData())\n         .thenReturn(failedFuture(new RuntimeException(\"Nope\")))\n-        .thenReturn(completedFuture(Optional.of(GENESIS_TIME)));\n+        .thenReturn(\n+            completedFuture(Optional.of(new GenesisData(GENESIS_TIME, GENESIS_VALIDATORS_ROOT))));\n \n     // First request fails\n-    final SafeFuture<UInt64> result = genesisTimeProvider.getGenesisTime();\n-    verify(validatorApiChannel).getGenesisTime();\n+    final SafeFuture<UInt64> result = genesisDataProvider.getGenesisTime();\n+    verify(validatorApiChannel).getGenesisData();\n     assertThat(result).isNotDone();\n     Assertions.assertThat(asyncRunner.hasDelayedActions()).isTrue();\n \n     // Retry is scheduled.\n     asyncRunner.executeQueuedActions();\n-    verify(validatorApiChannel, times(2)).getGenesisTime();\n+    verify(validatorApiChannel, times(2)).getGenesisData();\n     assertThat(result).isCompletedWithValue(GENESIS_TIME);\n   }\n \n   @Test\n   void shouldRetryWhenGenesisTimeIsNotYetKnown() {\n-    when(validatorApiChannel.getGenesisTime())\n+    when(validatorApiChannel.getGenesisData())\n         .thenReturn(completedFuture(Optional.empty()))\n-        .thenReturn(completedFuture(Optional.of(GENESIS_TIME)));\n+        .thenReturn(\n+            completedFuture(Optional.of(new GenesisData(GENESIS_TIME, GENESIS_VALIDATORS_ROOT))));\n \n     // First request fails\n-    final SafeFuture<UInt64> result = genesisTimeProvider.getGenesisTime();\n-    verify(validatorApiChannel).getGenesisTime();\n+    final SafeFuture<UInt64> result = genesisDataProvider.getGenesisTime();\n+    verify(validatorApiChannel).getGenesisData();\n     assertThat(result).isNotDone();\n     Assertions.assertThat(asyncRunner.hasDelayedActions()).isTrue();\n \n     // Retry is scheduled.\n     asyncRunner.executeQueuedActions();\n-    verify(validatorApiChannel, times(2)).getGenesisTime();\n+    verify(validatorApiChannel, times(2)).getGenesisData();\n     assertThat(result).isCompletedWithValue(GENESIS_TIME);\n   }\n+\n+  @Test\n+  void shouldRetryWhenGenesisValidatorsRootIsNotYetKnown() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "144ad0df72b9cdbf8900bdc5fd776c52212c6ed5"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTE0NzI1OQ==", "bodyText": "yep that's what i copied, i wanted to show that validatorsRoot would work, i'll think of something trivial", "url": "https://github.com/ConsenSys/teku/pull/2978#discussion_r505147259", "createdAt": "2020-10-15T03:46:31Z", "author": {"login": "rolfyone"}, "path": "validator/beaconnode/src/test/java/tech/pegasys/teku/validator/beaconnode/GenesisDataProviderTest.java", "diffHunk": "@@ -23,79 +23,107 @@\n import static tech.pegasys.teku.infrastructure.async.SafeFuture.failedFuture;\n \n import java.util.Optional;\n+import org.apache.tuweni.bytes.Bytes32;\n import org.assertj.core.api.Assertions;\n import org.junit.jupiter.api.Test;\n+import tech.pegasys.teku.datastructures.genesis.GenesisData;\n import tech.pegasys.teku.infrastructure.async.SafeFuture;\n import tech.pegasys.teku.infrastructure.async.StubAsyncRunner;\n import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n import tech.pegasys.teku.validator.api.ValidatorApiChannel;\n \n-class GenesisTimeProviderTest {\n+class GenesisDataProviderTest {\n \n   private static final UInt64 GENESIS_TIME = UInt64.valueOf(12341234);\n+  private static final Bytes32 GENESIS_VALIDATORS_ROOT = Bytes32.fromHexString(\"0x01\");\n   private final StubAsyncRunner asyncRunner = new StubAsyncRunner();\n   private final ValidatorApiChannel validatorApiChannel = mock(ValidatorApiChannel.class);\n \n-  private final GenesisTimeProvider genesisTimeProvider =\n-      new GenesisTimeProvider(asyncRunner, validatorApiChannel);\n+  private final GenesisDataProvider genesisDataProvider =\n+      new GenesisDataProvider(asyncRunner, validatorApiChannel);\n \n   @Test\n   void shouldRequestGenesisTimeWhenNotPreviouslyLoaded() {\n-    final SafeFuture<Optional<UInt64>> request = new SafeFuture<>();\n-    when(validatorApiChannel.getGenesisTime()).thenReturn(request);\n+    final SafeFuture<Optional<GenesisData>> request = new SafeFuture<>();\n+    when(validatorApiChannel.getGenesisData()).thenReturn(request);\n \n-    final SafeFuture<UInt64> result = genesisTimeProvider.getGenesisTime();\n+    final SafeFuture<UInt64> result = genesisDataProvider.getGenesisTime();\n     assertThat(result).isNotDone();\n \n-    request.complete(Optional.of(GENESIS_TIME));\n+    request.complete(Optional.of(new GenesisData(GENESIS_TIME, GENESIS_VALIDATORS_ROOT)));\n     assertThat(result).isCompletedWithValue(GENESIS_TIME);\n   }\n \n   @Test\n   void shouldReturnCachedGenesisTimeWhenPreviouslyLoaded() {\n-    when(validatorApiChannel.getGenesisTime())\n-        .thenReturn(SafeFuture.completedFuture(Optional.of(GENESIS_TIME)));\n-    assertThat(genesisTimeProvider.getGenesisTime()).isCompletedWithValue(GENESIS_TIME);\n-    verify(validatorApiChannel).getGenesisTime();\n+    when(validatorApiChannel.getGenesisData())\n+        .thenReturn(\n+            SafeFuture.completedFuture(\n+                Optional.of(new GenesisData(GENESIS_TIME, GENESIS_VALIDATORS_ROOT))));\n+    assertThat(genesisDataProvider.getGenesisData())\n+        .isCompletedWithValue(new GenesisData(GENESIS_TIME, GENESIS_VALIDATORS_ROOT));\n+    verify(validatorApiChannel).getGenesisData();\n \n     // Subsequent requests just return the cached version\n-    assertThat(genesisTimeProvider.getGenesisTime()).isCompletedWithValue(GENESIS_TIME);\n+    assertThat(genesisDataProvider.getGenesisData())\n+        .isCompletedWithValue(new GenesisData(GENESIS_TIME, GENESIS_VALIDATORS_ROOT));\n     verifyNoMoreInteractions(validatorApiChannel);\n   }\n \n   @Test\n   void shouldRetryWhenGenesisTimeFailsToLoad() {\n-    when(validatorApiChannel.getGenesisTime())\n+    when(validatorApiChannel.getGenesisData())\n         .thenReturn(failedFuture(new RuntimeException(\"Nope\")))\n-        .thenReturn(completedFuture(Optional.of(GENESIS_TIME)));\n+        .thenReturn(\n+            completedFuture(Optional.of(new GenesisData(GENESIS_TIME, GENESIS_VALIDATORS_ROOT))));\n \n     // First request fails\n-    final SafeFuture<UInt64> result = genesisTimeProvider.getGenesisTime();\n-    verify(validatorApiChannel).getGenesisTime();\n+    final SafeFuture<UInt64> result = genesisDataProvider.getGenesisTime();\n+    verify(validatorApiChannel).getGenesisData();\n     assertThat(result).isNotDone();\n     Assertions.assertThat(asyncRunner.hasDelayedActions()).isTrue();\n \n     // Retry is scheduled.\n     asyncRunner.executeQueuedActions();\n-    verify(validatorApiChannel, times(2)).getGenesisTime();\n+    verify(validatorApiChannel, times(2)).getGenesisData();\n     assertThat(result).isCompletedWithValue(GENESIS_TIME);\n   }\n \n   @Test\n   void shouldRetryWhenGenesisTimeIsNotYetKnown() {\n-    when(validatorApiChannel.getGenesisTime())\n+    when(validatorApiChannel.getGenesisData())\n         .thenReturn(completedFuture(Optional.empty()))\n-        .thenReturn(completedFuture(Optional.of(GENESIS_TIME)));\n+        .thenReturn(\n+            completedFuture(Optional.of(new GenesisData(GENESIS_TIME, GENESIS_VALIDATORS_ROOT))));\n \n     // First request fails\n-    final SafeFuture<UInt64> result = genesisTimeProvider.getGenesisTime();\n-    verify(validatorApiChannel).getGenesisTime();\n+    final SafeFuture<UInt64> result = genesisDataProvider.getGenesisTime();\n+    verify(validatorApiChannel).getGenesisData();\n     assertThat(result).isNotDone();\n     Assertions.assertThat(asyncRunner.hasDelayedActions()).isTrue();\n \n     // Retry is scheduled.\n     asyncRunner.executeQueuedActions();\n-    verify(validatorApiChannel, times(2)).getGenesisTime();\n+    verify(validatorApiChannel, times(2)).getGenesisData();\n     assertThat(result).isCompletedWithValue(GENESIS_TIME);\n   }\n+\n+  @Test\n+  void shouldRetryWhenGenesisValidatorsRootIsNotYetKnown() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTE0MjQ5Ng=="}, "originalCommit": {"oid": "144ad0df72b9cdbf8900bdc5fd776c52212c6ed5"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTE0ODE4OA==", "bodyText": "But both are just testing getGenesisData.  I don't think we need to individually check that the shortcut getGenesisTime and getGenesisValidatorRoot methods work - they are a trivial map from getGenesisData.", "url": "https://github.com/ConsenSys/teku/pull/2978#discussion_r505148188", "createdAt": "2020-10-15T03:50:29Z", "author": {"login": "ajsutton"}, "path": "validator/beaconnode/src/test/java/tech/pegasys/teku/validator/beaconnode/GenesisDataProviderTest.java", "diffHunk": "@@ -23,79 +23,107 @@\n import static tech.pegasys.teku.infrastructure.async.SafeFuture.failedFuture;\n \n import java.util.Optional;\n+import org.apache.tuweni.bytes.Bytes32;\n import org.assertj.core.api.Assertions;\n import org.junit.jupiter.api.Test;\n+import tech.pegasys.teku.datastructures.genesis.GenesisData;\n import tech.pegasys.teku.infrastructure.async.SafeFuture;\n import tech.pegasys.teku.infrastructure.async.StubAsyncRunner;\n import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n import tech.pegasys.teku.validator.api.ValidatorApiChannel;\n \n-class GenesisTimeProviderTest {\n+class GenesisDataProviderTest {\n \n   private static final UInt64 GENESIS_TIME = UInt64.valueOf(12341234);\n+  private static final Bytes32 GENESIS_VALIDATORS_ROOT = Bytes32.fromHexString(\"0x01\");\n   private final StubAsyncRunner asyncRunner = new StubAsyncRunner();\n   private final ValidatorApiChannel validatorApiChannel = mock(ValidatorApiChannel.class);\n \n-  private final GenesisTimeProvider genesisTimeProvider =\n-      new GenesisTimeProvider(asyncRunner, validatorApiChannel);\n+  private final GenesisDataProvider genesisDataProvider =\n+      new GenesisDataProvider(asyncRunner, validatorApiChannel);\n \n   @Test\n   void shouldRequestGenesisTimeWhenNotPreviouslyLoaded() {\n-    final SafeFuture<Optional<UInt64>> request = new SafeFuture<>();\n-    when(validatorApiChannel.getGenesisTime()).thenReturn(request);\n+    final SafeFuture<Optional<GenesisData>> request = new SafeFuture<>();\n+    when(validatorApiChannel.getGenesisData()).thenReturn(request);\n \n-    final SafeFuture<UInt64> result = genesisTimeProvider.getGenesisTime();\n+    final SafeFuture<UInt64> result = genesisDataProvider.getGenesisTime();\n     assertThat(result).isNotDone();\n \n-    request.complete(Optional.of(GENESIS_TIME));\n+    request.complete(Optional.of(new GenesisData(GENESIS_TIME, GENESIS_VALIDATORS_ROOT)));\n     assertThat(result).isCompletedWithValue(GENESIS_TIME);\n   }\n \n   @Test\n   void shouldReturnCachedGenesisTimeWhenPreviouslyLoaded() {\n-    when(validatorApiChannel.getGenesisTime())\n-        .thenReturn(SafeFuture.completedFuture(Optional.of(GENESIS_TIME)));\n-    assertThat(genesisTimeProvider.getGenesisTime()).isCompletedWithValue(GENESIS_TIME);\n-    verify(validatorApiChannel).getGenesisTime();\n+    when(validatorApiChannel.getGenesisData())\n+        .thenReturn(\n+            SafeFuture.completedFuture(\n+                Optional.of(new GenesisData(GENESIS_TIME, GENESIS_VALIDATORS_ROOT))));\n+    assertThat(genesisDataProvider.getGenesisData())\n+        .isCompletedWithValue(new GenesisData(GENESIS_TIME, GENESIS_VALIDATORS_ROOT));\n+    verify(validatorApiChannel).getGenesisData();\n \n     // Subsequent requests just return the cached version\n-    assertThat(genesisTimeProvider.getGenesisTime()).isCompletedWithValue(GENESIS_TIME);\n+    assertThat(genesisDataProvider.getGenesisData())\n+        .isCompletedWithValue(new GenesisData(GENESIS_TIME, GENESIS_VALIDATORS_ROOT));\n     verifyNoMoreInteractions(validatorApiChannel);\n   }\n \n   @Test\n   void shouldRetryWhenGenesisTimeFailsToLoad() {\n-    when(validatorApiChannel.getGenesisTime())\n+    when(validatorApiChannel.getGenesisData())\n         .thenReturn(failedFuture(new RuntimeException(\"Nope\")))\n-        .thenReturn(completedFuture(Optional.of(GENESIS_TIME)));\n+        .thenReturn(\n+            completedFuture(Optional.of(new GenesisData(GENESIS_TIME, GENESIS_VALIDATORS_ROOT))));\n \n     // First request fails\n-    final SafeFuture<UInt64> result = genesisTimeProvider.getGenesisTime();\n-    verify(validatorApiChannel).getGenesisTime();\n+    final SafeFuture<UInt64> result = genesisDataProvider.getGenesisTime();\n+    verify(validatorApiChannel).getGenesisData();\n     assertThat(result).isNotDone();\n     Assertions.assertThat(asyncRunner.hasDelayedActions()).isTrue();\n \n     // Retry is scheduled.\n     asyncRunner.executeQueuedActions();\n-    verify(validatorApiChannel, times(2)).getGenesisTime();\n+    verify(validatorApiChannel, times(2)).getGenesisData();\n     assertThat(result).isCompletedWithValue(GENESIS_TIME);\n   }\n \n   @Test\n   void shouldRetryWhenGenesisTimeIsNotYetKnown() {\n-    when(validatorApiChannel.getGenesisTime())\n+    when(validatorApiChannel.getGenesisData())\n         .thenReturn(completedFuture(Optional.empty()))\n-        .thenReturn(completedFuture(Optional.of(GENESIS_TIME)));\n+        .thenReturn(\n+            completedFuture(Optional.of(new GenesisData(GENESIS_TIME, GENESIS_VALIDATORS_ROOT))));\n \n     // First request fails\n-    final SafeFuture<UInt64> result = genesisTimeProvider.getGenesisTime();\n-    verify(validatorApiChannel).getGenesisTime();\n+    final SafeFuture<UInt64> result = genesisDataProvider.getGenesisTime();\n+    verify(validatorApiChannel).getGenesisData();\n     assertThat(result).isNotDone();\n     Assertions.assertThat(asyncRunner.hasDelayedActions()).isTrue();\n \n     // Retry is scheduled.\n     asyncRunner.executeQueuedActions();\n-    verify(validatorApiChannel, times(2)).getGenesisTime();\n+    verify(validatorApiChannel, times(2)).getGenesisData();\n     assertThat(result).isCompletedWithValue(GENESIS_TIME);\n   }\n+\n+  @Test\n+  void shouldRetryWhenGenesisValidatorsRootIsNotYetKnown() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTE0MjQ5Ng=="}, "originalCommit": {"oid": "144ad0df72b9cdbf8900bdc5fd776c52212c6ed5"}, "originalPosition": 112}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3203, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}