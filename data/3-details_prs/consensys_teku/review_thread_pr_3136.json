{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE0NjQwNjY4", "number": 3136, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxOToyMToyMVrOE1XU3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxNToxOToxNVrOE3v9Cg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0MzkyMTU2OnYy", "diffSide": "RIGHT", "path": "storage/src/main/java/tech/pegasys/teku/storage/store/StoreTransactionUpdatesFactory.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxOToyMToyMVrOHtmZKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwMzo1MjoxNVrOHw9K5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU3NzAwMQ==", "bodyText": "I think you need to process the base blocks first so the parentRoot-based filtering works", "url": "https://github.com/ConsenSys/teku/pull/3136#discussion_r517577001", "createdAt": "2020-11-04T19:21:21Z", "author": {"login": "mbaxter"}, "path": "storage/src/main/java/tech/pegasys/teku/storage/store/StoreTransactionUpdatesFactory.java", "diffHunk": "@@ -159,10 +170,37 @@ private StoreTransactionUpdates buildFinalizedUpdates(final Checkpoint finalized\n     return states;\n   }\n \n-  private void calculatePrunedHotBlockRoots(StoreTransaction tx, final BlockTree prunedTree) {\n-    tx.getBlockRoots().stream()\n-        .filter(root -> !prunedTree.contains(root))\n-        .forEach(prunedHotBlockRoots::add);\n+  private boolean shouldPrune(\n+      final SignedBeaconBlock finalizedBlock,\n+      final Bytes32 blockRoot,\n+      final UInt64 slot,\n+      final Bytes32 parentRoot) {\n+    return (slot.isLessThanOrEqualTo(finalizedBlock.getSlot())\n+            || prunedHotBlockRoots.contains(parentRoot))\n+        // Keep the actual finalized block\n+        && !blockRoot.equals(finalizedBlock.getRoot());\n+  }\n+\n+  private void calculatePrunedHotBlockRoots() {\n+    final SignedBeaconBlock finalizedBlock = tx.getLatestFinalized().getBlock();\n+    tx.blockAndStates.values().stream()\n+        // Iterate new blocks in slot order to guarantee we see parents first\n+        .sorted(Comparator.comparing(SignedBlockAndState::getSlot))\n+        .filter(\n+            newBlockAndState ->\n+                shouldPrune(\n+                    finalizedBlock,\n+                    newBlockAndState.getRoot(),\n+                    newBlockAndState.getSlot(),\n+                    newBlockAndState.getParentRoot()))\n+        .forEach(newBlockAndState -> prunedHotBlockRoots.add(newBlockAndState.getRoot()));\n+\n+    baseStore.blockMetadata.processAllInOrder(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ea5e8a16538f39db0dc10b729a5e5c407dea7f0"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzYyMTUwNQ==", "bodyText": "ooo, good spot.", "url": "https://github.com/ConsenSys/teku/pull/3136#discussion_r517621505", "createdAt": "2020-11-04T20:46:38Z", "author": {"login": "ajsutton"}, "path": "storage/src/main/java/tech/pegasys/teku/storage/store/StoreTransactionUpdatesFactory.java", "diffHunk": "@@ -159,10 +170,37 @@ private StoreTransactionUpdates buildFinalizedUpdates(final Checkpoint finalized\n     return states;\n   }\n \n-  private void calculatePrunedHotBlockRoots(StoreTransaction tx, final BlockTree prunedTree) {\n-    tx.getBlockRoots().stream()\n-        .filter(root -> !prunedTree.contains(root))\n-        .forEach(prunedHotBlockRoots::add);\n+  private boolean shouldPrune(\n+      final SignedBeaconBlock finalizedBlock,\n+      final Bytes32 blockRoot,\n+      final UInt64 slot,\n+      final Bytes32 parentRoot) {\n+    return (slot.isLessThanOrEqualTo(finalizedBlock.getSlot())\n+            || prunedHotBlockRoots.contains(parentRoot))\n+        // Keep the actual finalized block\n+        && !blockRoot.equals(finalizedBlock.getRoot());\n+  }\n+\n+  private void calculatePrunedHotBlockRoots() {\n+    final SignedBeaconBlock finalizedBlock = tx.getLatestFinalized().getBlock();\n+    tx.blockAndStates.values().stream()\n+        // Iterate new blocks in slot order to guarantee we see parents first\n+        .sorted(Comparator.comparing(SignedBlockAndState::getSlot))\n+        .filter(\n+            newBlockAndState ->\n+                shouldPrune(\n+                    finalizedBlock,\n+                    newBlockAndState.getRoot(),\n+                    newBlockAndState.getSlot(),\n+                    newBlockAndState.getParentRoot()))\n+        .forEach(newBlockAndState -> prunedHotBlockRoots.add(newBlockAndState.getRoot()));\n+\n+    baseStore.blockMetadata.processAllInOrder(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU3NzAwMQ=="}, "originalCommit": {"oid": "4ea5e8a16538f39db0dc10b729a5e5c407dea7f0"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc1Mzg4Nw==", "bodyText": "We should add a test that covers this if we don't already have one.", "url": "https://github.com/ConsenSys/teku/pull/3136#discussion_r520753887", "createdAt": "2020-11-10T17:47:49Z", "author": {"login": "mbaxter"}, "path": "storage/src/main/java/tech/pegasys/teku/storage/store/StoreTransactionUpdatesFactory.java", "diffHunk": "@@ -159,10 +170,37 @@ private StoreTransactionUpdates buildFinalizedUpdates(final Checkpoint finalized\n     return states;\n   }\n \n-  private void calculatePrunedHotBlockRoots(StoreTransaction tx, final BlockTree prunedTree) {\n-    tx.getBlockRoots().stream()\n-        .filter(root -> !prunedTree.contains(root))\n-        .forEach(prunedHotBlockRoots::add);\n+  private boolean shouldPrune(\n+      final SignedBeaconBlock finalizedBlock,\n+      final Bytes32 blockRoot,\n+      final UInt64 slot,\n+      final Bytes32 parentRoot) {\n+    return (slot.isLessThanOrEqualTo(finalizedBlock.getSlot())\n+            || prunedHotBlockRoots.contains(parentRoot))\n+        // Keep the actual finalized block\n+        && !blockRoot.equals(finalizedBlock.getRoot());\n+  }\n+\n+  private void calculatePrunedHotBlockRoots() {\n+    final SignedBeaconBlock finalizedBlock = tx.getLatestFinalized().getBlock();\n+    tx.blockAndStates.values().stream()\n+        // Iterate new blocks in slot order to guarantee we see parents first\n+        .sorted(Comparator.comparing(SignedBlockAndState::getSlot))\n+        .filter(\n+            newBlockAndState ->\n+                shouldPrune(\n+                    finalizedBlock,\n+                    newBlockAndState.getRoot(),\n+                    newBlockAndState.getSlot(),\n+                    newBlockAndState.getParentRoot()))\n+        .forEach(newBlockAndState -> prunedHotBlockRoots.add(newBlockAndState.getRoot()));\n+\n+    baseStore.blockMetadata.processAllInOrder(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU3NzAwMQ=="}, "originalCommit": {"oid": "4ea5e8a16538f39db0dc10b729a5e5c407dea7f0"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTA5NTkwOA==", "bodyText": "Done.", "url": "https://github.com/ConsenSys/teku/pull/3136#discussion_r521095908", "createdAt": "2020-11-11T03:52:15Z", "author": {"login": "ajsutton"}, "path": "storage/src/main/java/tech/pegasys/teku/storage/store/StoreTransactionUpdatesFactory.java", "diffHunk": "@@ -159,10 +170,37 @@ private StoreTransactionUpdates buildFinalizedUpdates(final Checkpoint finalized\n     return states;\n   }\n \n-  private void calculatePrunedHotBlockRoots(StoreTransaction tx, final BlockTree prunedTree) {\n-    tx.getBlockRoots().stream()\n-        .filter(root -> !prunedTree.contains(root))\n-        .forEach(prunedHotBlockRoots::add);\n+  private boolean shouldPrune(\n+      final SignedBeaconBlock finalizedBlock,\n+      final Bytes32 blockRoot,\n+      final UInt64 slot,\n+      final Bytes32 parentRoot) {\n+    return (slot.isLessThanOrEqualTo(finalizedBlock.getSlot())\n+            || prunedHotBlockRoots.contains(parentRoot))\n+        // Keep the actual finalized block\n+        && !blockRoot.equals(finalizedBlock.getRoot());\n+  }\n+\n+  private void calculatePrunedHotBlockRoots() {\n+    final SignedBeaconBlock finalizedBlock = tx.getLatestFinalized().getBlock();\n+    tx.blockAndStates.values().stream()\n+        // Iterate new blocks in slot order to guarantee we see parents first\n+        .sorted(Comparator.comparing(SignedBlockAndState::getSlot))\n+        .filter(\n+            newBlockAndState ->\n+                shouldPrune(\n+                    finalizedBlock,\n+                    newBlockAndState.getRoot(),\n+                    newBlockAndState.getSlot(),\n+                    newBlockAndState.getParentRoot()))\n+        .forEach(newBlockAndState -> prunedHotBlockRoots.add(newBlockAndState.getRoot()));\n+\n+    baseStore.blockMetadata.processAllInOrder(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU3NzAwMQ=="}, "originalCommit": {"oid": "4ea5e8a16538f39db0dc10b729a5e5c407dea7f0"}, "originalPosition": 189}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NDkzNzc0OnYy", "diffSide": "RIGHT", "path": "storage/src/main/java/tech/pegasys/teku/storage/store/StoreTransaction.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxODo1ODowM1rOHwrKxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwMDo0NTo0M1rOHw1Ptw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgwMDk2Ng==", "bodyText": "Why are we invoking this from store rather than just holding the logic in the tx object?", "url": "https://github.com/ConsenSys/teku/pull/3136#discussion_r520800966", "createdAt": "2020-11-10T18:58:03Z", "author": {"login": "mbaxter"}, "path": "storage/src/main/java/tech/pegasys/teku/storage/store/StoreTransaction.java", "diffHunk": "@@ -137,6 +137,15 @@ public VoteTracker getVote(UInt64 validatorIndex) {\n     return vote;\n   }\n \n+  @Override\n+  public Bytes32 applyForkChoiceScoreChanges(\n+      final Checkpoint finalizedCheckpoint,\n+      final Checkpoint justifiedCheckpoint,\n+      final BeaconState justifiedCheckpointState) {\n+    return store.applyForkChoiceScoreChanges(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36b261539eb2193410edaf5bf205516b9df1718c"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk2NTQ3Mg==", "bodyText": "Mostly because exposing the Store locks made me really, really nervous.  I'll give it a go and see what happens.", "url": "https://github.com/ConsenSys/teku/pull/3136#discussion_r520965472", "createdAt": "2020-11-11T00:43:53Z", "author": {"login": "ajsutton"}, "path": "storage/src/main/java/tech/pegasys/teku/storage/store/StoreTransaction.java", "diffHunk": "@@ -137,6 +137,15 @@ public VoteTracker getVote(UInt64 validatorIndex) {\n     return vote;\n   }\n \n+  @Override\n+  public Bytes32 applyForkChoiceScoreChanges(\n+      final Checkpoint finalizedCheckpoint,\n+      final Checkpoint justifiedCheckpoint,\n+      final BeaconState justifiedCheckpointState) {\n+    return store.applyForkChoiceScoreChanges(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgwMDk2Ng=="}, "originalCommit": {"oid": "36b261539eb2193410edaf5bf205516b9df1718c"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk2NjA3MQ==", "bodyText": "oh look, the lock is already passed to the transaction - I totally missed that....", "url": "https://github.com/ConsenSys/teku/pull/3136#discussion_r520966071", "createdAt": "2020-11-11T00:45:43Z", "author": {"login": "ajsutton"}, "path": "storage/src/main/java/tech/pegasys/teku/storage/store/StoreTransaction.java", "diffHunk": "@@ -137,6 +137,15 @@ public VoteTracker getVote(UInt64 validatorIndex) {\n     return vote;\n   }\n \n+  @Override\n+  public Bytes32 applyForkChoiceScoreChanges(\n+      final Checkpoint finalizedCheckpoint,\n+      final Checkpoint justifiedCheckpoint,\n+      final BeaconState justifiedCheckpointState) {\n+    return store.applyForkChoiceScoreChanges(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgwMDk2Ng=="}, "originalCommit": {"oid": "36b261539eb2193410edaf5bf205516b9df1718c"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NTAwMjk2OnYy", "diffSide": "RIGHT", "path": "protoarray/src/main/java/tech/pegasys/teku/protoarray/ProtoArray.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxOToxMzozMFrOHwr0aw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwMDo1Njo1NVrOHw1pQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgxMTYyNw==", "bodyText": "Probably worth adding some comments on the indices and nodes variables / getters explaining how they differ wrt pruning.", "url": "https://github.com/ConsenSys/teku/pull/3136#discussion_r520811627", "createdAt": "2020-11-10T19:13:30Z", "author": {"login": "mbaxter"}, "path": "protoarray/src/main/java/tech/pegasys/teku/protoarray/ProtoArray.java", "diffHunk": "@@ -405,4 +405,8 @@ public UInt64 getFinalizedEpoch() {\n   public UInt64 getInitialEpoch() {\n     return initialEpoch;\n   }\n+\n+  public void removeBlockRoot(final Bytes32 blockRoot) {\n+    indices.remove(blockRoot);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36b261539eb2193410edaf5bf205516b9df1718c"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDk3MjYxMA==", "bodyText": "Added comments.", "url": "https://github.com/ConsenSys/teku/pull/3136#discussion_r520972610", "createdAt": "2020-11-11T00:56:55Z", "author": {"login": "ajsutton"}, "path": "protoarray/src/main/java/tech/pegasys/teku/protoarray/ProtoArray.java", "diffHunk": "@@ -405,4 +405,8 @@ public UInt64 getFinalizedEpoch() {\n   public UInt64 getInitialEpoch() {\n     return initialEpoch;\n   }\n+\n+  public void removeBlockRoot(final Bytes32 blockRoot) {\n+    indices.remove(blockRoot);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgxMTYyNw=="}, "originalCommit": {"oid": "36b261539eb2193410edaf5bf205516b9df1718c"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NTAxMDg2OnYy", "diffSide": "RIGHT", "path": "ethereum/core/src/test/java/tech/pegasys/teku/core/ForkChoiceUtilTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxOToxNTozN1rOHwr5aQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxOToxNTozN1rOHwr5aQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgxMjkwNQ==", "bodyText": "There's also:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                final UInt64 epoch = BeaconStateUtil.compute_epoch_at_slot(block.getSlot()).plus(1);\n          \n          \n            \n                final UInt64 epoch = BeaconStateUtil.compute_next_epoch_boundary(block.getSlot());\n          \n      \n    \n    \n  \n\n:D", "url": "https://github.com/ConsenSys/teku/pull/3136#discussion_r520812905", "createdAt": "2020-11-10T19:15:37Z", "author": {"login": "mbaxter"}, "path": "ethereum/core/src/test/java/tech/pegasys/teku/core/ForkChoiceUtilTest.java", "diffHunk": "@@ -97,6 +102,11 @@ void getAncestors_shouldGetSequenceOfRootsWhenStartIsPriorToFinalizedCheckpoint(\n     assertThat(rootsBySlot).containsExactlyEntriesOf(getRootsForBlocks(5, 7));\n   }\n \n+  private Checkpoint createCheckpointFromBlock(final SignedBeaconBlock block) {\n+    final UInt64 epoch = BeaconStateUtil.compute_epoch_at_slot(block.getSlot()).plus(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36b261539eb2193410edaf5bf205516b9df1718c"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NTEwOTU5OnYy", "diffSide": "LEFT", "path": "ethereum/statetransition/src/main/java/tech/pegasys/teku/statetransition/forkchoice/ForkChoice.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxOTo0MjowOVrOHws1gg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwMTo0OToyNVrOHw34Ew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgyODI5MA==", "bodyText": "Looks like ForkChoiceStrategy.onBlock is no longer used in production.  We should probably see if we can get rid of this method - looks like its used in some storage-related tests which could be interfering with test outcomes ...", "url": "https://github.com/ConsenSys/teku/pull/3136#discussion_r520828290", "createdAt": "2020-11-10T19:42:09Z", "author": {"login": "mbaxter"}, "path": "ethereum/statetransition/src/main/java/tech/pegasys/teku/statetransition/forkchoice/ForkChoice.java", "diffHunk": "@@ -149,20 +148,17 @@ private void processHead(Optional<UInt64> nodeSlot) {\n                       forkChoiceStrategy.onAttestation(transaction, indexedAttestation));\n           return transaction\n               .commit()\n-              .thenRun(() -> updateForkChoiceForImportedBlock(block, forkChoiceStrategy, result))\n+              .thenRun(() -> updateForkChoiceForImportedBlock(block, result))\n               .thenApply(__ -> result);\n         });\n   }\n \n   private void updateForkChoiceForImportedBlock(\n-      final SignedBeaconBlock block,\n-      final ForkChoiceStrategy forkChoiceStrategy,\n-      final BlockImportResult result) {\n+      final SignedBeaconBlock block, final BlockImportResult result) {\n     result\n         .getBlockProcessingRecord()\n         .ifPresent(\n             record -> {\n-              forkChoiceStrategy.onBlock(block.getMessage(), record.getPostState());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36b261539eb2193410edaf5bf205516b9df1718c"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTAwOTE3MQ==", "bodyText": "Removed.  Hopefully tests should pass because the protoarray gets updated as part of adding a block in a transaction now, but I guess we'll find out.", "url": "https://github.com/ConsenSys/teku/pull/3136#discussion_r521009171", "createdAt": "2020-11-11T01:49:25Z", "author": {"login": "ajsutton"}, "path": "ethereum/statetransition/src/main/java/tech/pegasys/teku/statetransition/forkchoice/ForkChoice.java", "diffHunk": "@@ -149,20 +148,17 @@ private void processHead(Optional<UInt64> nodeSlot) {\n                       forkChoiceStrategy.onAttestation(transaction, indexedAttestation));\n           return transaction\n               .commit()\n-              .thenRun(() -> updateForkChoiceForImportedBlock(block, forkChoiceStrategy, result))\n+              .thenRun(() -> updateForkChoiceForImportedBlock(block, result))\n               .thenApply(__ -> result);\n         });\n   }\n \n   private void updateForkChoiceForImportedBlock(\n-      final SignedBeaconBlock block,\n-      final ForkChoiceStrategy forkChoiceStrategy,\n-      final BlockImportResult result) {\n+      final SignedBeaconBlock block, final BlockImportResult result) {\n     result\n         .getBlockProcessingRecord()\n         .ifPresent(\n             record -> {\n-              forkChoiceStrategy.onBlock(block.getMessage(), record.getPostState());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgyODI5MA=="}, "originalCommit": {"oid": "36b261539eb2193410edaf5bf205516b9df1718c"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NTEzOTE4OnYy", "diffSide": "RIGHT", "path": "protoarray/src/main/java/tech/pegasys/teku/protoarray/ProtoArrayForkChoiceStrategy.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxOTo1MDowN1rOHwtH-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwMjo1MTozNFrOHw6gYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgzMzAxNw==", "bodyText": "Maybe we should add some methods like getTrackedNodeCount() and getNonFinalNodeCount() or similar to make it clearer what these size values mean.", "url": "https://github.com/ConsenSys/teku/pull/3136#discussion_r520833017", "createdAt": "2020-11-10T19:50:07Z", "author": {"login": "mbaxter"}, "path": "protoarray/src/main/java/tech/pegasys/teku/protoarray/ProtoArrayForkChoiceStrategy.java", "diffHunk": "@@ -234,7 +230,11 @@ Bytes32 findHead(\n \n       List<Long> deltas =\n           ProtoArrayScoreCalculator.computeDeltas(\n-              store, protoArray.getIndices(), oldBalances, newBalances);\n+              store,\n+              protoArray.getNodes().size(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36b261539eb2193410edaf5bf205516b9df1718c"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTA1MjI1Nw==", "bodyText": "Added getTotalTrackedNodeCount. I don't think we ever use the number of nodes in the index map.", "url": "https://github.com/ConsenSys/teku/pull/3136#discussion_r521052257", "createdAt": "2020-11-11T02:51:34Z", "author": {"login": "ajsutton"}, "path": "protoarray/src/main/java/tech/pegasys/teku/protoarray/ProtoArrayForkChoiceStrategy.java", "diffHunk": "@@ -234,7 +230,11 @@ Bytes32 findHead(\n \n       List<Long> deltas =\n           ProtoArrayScoreCalculator.computeDeltas(\n-              store, protoArray.getIndices(), oldBalances, newBalances);\n+              store,\n+              protoArray.getNodes().size(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgzMzAxNw=="}, "originalCommit": {"oid": "36b261539eb2193410edaf5bf205516b9df1718c"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NTIwMTEyOnYy", "diffSide": "RIGHT", "path": "protoarray/src/test/java/tech/pegasys/teku/protoarray/AbstractBlockMetadataStoreTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMDowNzoyMlrOHwtuDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwMjo1NDo1OFrOHw6tCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg0Mjc2Ng==", "bodyText": "Shouldn't we check that these were processed in order?", "url": "https://github.com/ConsenSys/teku/pull/3136#discussion_r520842766", "createdAt": "2020-11-10T20:07:22Z", "author": {"login": "mbaxter"}, "path": "protoarray/src/test/java/tech/pegasys/teku/protoarray/AbstractBlockMetadataStoreTest.java", "diffHunk": "@@ -0,0 +1,260 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.protoarray;\n+\n+import static java.util.stream.Collectors.toList;\n+import static java.util.stream.Collectors.toSet;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static tech.pegasys.teku.util.config.Constants.GENESIS_EPOCH;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Stream;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.api.Test;\n+import tech.pegasys.teku.core.ChainBuilder;\n+import tech.pegasys.teku.datastructures.blocks.BlockAndCheckpointEpochs;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.blocks.SignedBlockAndState;\n+import tech.pegasys.teku.datastructures.blocks.StateAndBlockSummary;\n+import tech.pegasys.teku.datastructures.state.Checkpoint;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+\n+abstract class AbstractBlockMetadataStoreTest {\n+\n+  private final ChainBuilder chainBuilder = ChainBuilder.createDefault();\n+  private final SignedBlockAndState genesis = chainBuilder.generateGenesis();\n+  private final Checkpoint genesisCheckpoint =\n+      new Checkpoint(UInt64.valueOf(GENESIS_EPOCH), genesis.getRoot());\n+\n+  @Test\n+  void contains_shouldOnlyContainBlocksThatExist() {\n+    final BlockMetadataStore store = createBlockMetadataStore(chainBuilder);\n+    assertThat(store.contains(genesis.getRoot())).isTrue();\n+    assertThat(store.contains(Bytes32.ZERO)).isFalse();\n+  }\n+\n+  @Test\n+  void contains_shouldContainAddedBlocks() {\n+    final BlockMetadataStore store = createBlockMetadataStore(chainBuilder);\n+    final BlockAndCheckpointEpochs block1 =\n+        BlockAndCheckpointEpochs.fromBlockAndState(chainBuilder.generateBlockAtSlot(1));\n+    final BlockAndCheckpointEpochs block2 =\n+        BlockAndCheckpointEpochs.fromBlockAndState(chainBuilder.generateBlockAtSlot(2));\n+    final BlockAndCheckpointEpochs block3 =\n+        BlockAndCheckpointEpochs.fromBlockAndState(chainBuilder.generateBlockAtSlot(3));\n+\n+    final BlockMetadataStore updatedStore =\n+        store.applyUpdate(\n+            List.of(block1, block2, block3), Collections.emptySet(), genesisCheckpoint);\n+\n+    chainBuilder\n+        .streamBlocksAndStates()\n+        .forEach(block -> assertThat(updatedStore.contains(block.getRoot())).isTrue());\n+  }\n+\n+  @Test\n+  void contains_shouldNotContainRemovedBlocks() {\n+    BlockMetadataStore store = createBlockMetadataStore(chainBuilder);\n+    final BlockAndCheckpointEpochs block1 =\n+        BlockAndCheckpointEpochs.fromBlockAndState(chainBuilder.generateBlockAtSlot(1));\n+    final BlockAndCheckpointEpochs block2 =\n+        BlockAndCheckpointEpochs.fromBlockAndState(chainBuilder.generateBlockAtSlot(2));\n+    final BlockAndCheckpointEpochs block3 =\n+        BlockAndCheckpointEpochs.fromBlockAndState(chainBuilder.generateBlockAtSlot(3));\n+\n+    store =\n+        store.applyUpdate(\n+            List.of(block1, block2, block3),\n+            Set.of(genesis.getRoot(), block1.getRoot()),\n+            new Checkpoint(UInt64.ONE, block2.getRoot()));\n+\n+    assertThat(store.contains(genesis.getRoot())).isFalse();\n+    assertThat(store.contains(block1.getRoot())).isFalse();\n+    assertThat(store.contains(block2.getRoot())).isTrue();\n+    assertThat(store.contains(block3.getRoot())).isTrue();\n+  }\n+\n+  @Test\n+  void processAllInOrder_shouldVisitAllBlocksInSingleChain() {\n+    final int lastSlot = 10;\n+    chainBuilder.generateBlocksUpToSlot(lastSlot);\n+    final BlockMetadataStore store = createBlockMetadataStore(chainBuilder);\n+    final AtomicInteger expectedNextSlot = new AtomicInteger(0);\n+    store.processAllInOrder(\n+        (childRoot, slot, parentRoot) -> {\n+          assertThat(slot).isEqualTo(UInt64.valueOf(expectedNextSlot.getAndIncrement()));\n+          final SignedBeaconBlock block = chainBuilder.getBlockAtSlot(slot);\n+          assertThat(childRoot).isEqualTo(block.getRoot());\n+          assertThat(slot).isEqualTo(block.getSlot());\n+          assertThat(parentRoot).isEqualTo(block.getParentRoot());\n+        });\n+    // We should have processed the block in the last slot and now be expected the one after\n+    assertThat(expectedNextSlot).hasValue(lastSlot + 1);\n+  }\n+\n+  @Test\n+  void processAllInOrder_shouldVisitParentBlocksBeforeChildBlocksInForks() {\n+    // First chain has all blocks up to 10\n+    // Fork chain has 0-5, skips 6 and then has 7-10\n+    chainBuilder.generateBlocksUpToSlot(5);\n+    final ChainBuilder forkBuilder = chainBuilder.fork();\n+    chainBuilder.generateBlocksUpToSlot(10);\n+    forkBuilder.generateBlockAtSlot(7);\n+    forkBuilder.generateBlocksUpToSlot(10);\n+    final BlockMetadataStore store =\n+        createBlockMetadataStore(chainBuilder)\n+            .applyUpdate(\n+                forkBuilder\n+                    .streamBlocksAndStates()\n+                    .map(BlockAndCheckpointEpochs::fromBlockAndState)\n+                    .collect(toList()),\n+                Collections.emptySet(),\n+                genesisCheckpoint);\n+\n+    final Set<Bytes32> seenBlocks = new HashSet<>();\n+\n+    store.processAllInOrder(\n+        (childRoot, slot, parentRoot) -> {\n+          assertThat(seenBlocks).doesNotContain(childRoot);\n+          if (!seenBlocks.isEmpty()) {\n+            // First block won't have visited the parent\n+            assertThat(seenBlocks).contains(parentRoot);\n+          }\n+\n+          seenBlocks.add(childRoot);\n+\n+          final SignedBeaconBlock block =\n+              chainBuilder\n+                  .getBlock(childRoot)\n+                  .or(() -> forkBuilder.getBlock(childRoot))\n+                  .orElseThrow();\n+          assertThat(childRoot).isEqualTo(block.getRoot());\n+          assertThat(slot).isEqualTo(block.getSlot());\n+          assertThat(parentRoot).isEqualTo(block.getParentRoot());\n+        });\n+    // Check every block was seen\n+    final Set<Bytes32> expectedSeenRoots =\n+        Stream.concat(chainBuilder.streamBlocksAndStates(), forkBuilder.streamBlocksAndStates())\n+            .map(StateAndBlockSummary::getRoot)\n+            .collect(toSet());\n+\n+    assertThat(seenBlocks).containsExactlyInAnyOrderElementsOf(expectedSeenRoots);\n+  }\n+\n+  @Test\n+  void processHashesInChain_shouldWalkUpSpecifiedChain() {\n+    // First chain has all blocks up to 10\n+    // Fork chain has 0-5, skips 6 and then has 7-10\n+    chainBuilder.generateBlocksUpToSlot(5);\n+    final ChainBuilder forkBuilder = chainBuilder.fork();\n+    chainBuilder.generateBlocksUpToSlot(10);\n+    forkBuilder.generateBlockAtSlot(7);\n+    forkBuilder.generateBlocksUpToSlot(10);\n+    final BlockMetadataStore store =\n+        createBlockMetadataStore(chainBuilder)\n+            .applyUpdate(\n+                forkBuilder\n+                    .streamBlocksAndStates()\n+                    .map(BlockAndCheckpointEpochs::fromBlockAndState)\n+                    .collect(toList()),\n+                Collections.emptySet(),\n+                genesisCheckpoint);\n+\n+    verifyHashesInChain(\n+        store,\n+        forkBuilder,\n+        forkBuilder.getLatestBlockAndState().getRoot(),\n+        forkBuilder.streamBlocksAndStates());\n+    verifyHashesInChain(\n+        store,\n+        chainBuilder,\n+        chainBuilder.getLatestBlockAndState().getRoot(),\n+        chainBuilder.streamBlocksAndStates());\n+\n+    // And check we can start from part way along the chain\n+    verifyHashesInChain(\n+        store,\n+        chainBuilder,\n+        chainBuilder.getBlockAtSlot(6).getRoot(),\n+        chainBuilder.streamBlocksAndStates(0, 6));\n+  }\n+\n+  @Test\n+  void processHashesInChainWhile_shouldStopProcessingWhenProcessorReturnsFalse() {\n+    chainBuilder.generateBlocksUpToSlot(10);\n+    final BlockMetadataStore store = createBlockMetadataStore(chainBuilder);\n+\n+    // And check we can start from part way along the chain\n+    final Bytes32 headRoot = chainBuilder.getBlockAtSlot(6).getRoot();\n+    final Stream<SignedBlockAndState> expectedBlocks = chainBuilder.streamBlocksAndStates(3, 6);\n+\n+    final Set<Bytes32> seenBlocks = new HashSet<>();\n+\n+    final AtomicReference<Bytes32> expectedBlock = new AtomicReference<>(headRoot);\n+    store.processHashesInChainWhile(\n+        headRoot,\n+        (childRoot, slot, parentRoot) -> {\n+          assertThat(seenBlocks).doesNotContain(childRoot);\n+          seenBlocks.add(childRoot);\n+\n+          final SignedBeaconBlock block = chainBuilder.getBlock(expectedBlock.get()).orElseThrow();\n+          assertThat(childRoot).isEqualTo(block.getRoot());\n+          assertThat(slot).isEqualTo(block.getSlot());\n+          assertThat(parentRoot).isEqualTo(block.getParentRoot());\n+\n+          expectedBlock.set(block.getParentRoot());\n+          return !slot.equals(UInt64.valueOf(3));\n+        });\n+    // Check all fork blocks were seen\n+    final Set<Bytes32> expectedSeenRoots =\n+        expectedBlocks.map(StateAndBlockSummary::getRoot).collect(toSet());\n+\n+    assertThat(seenBlocks).containsExactlyInAnyOrderElementsOf(expectedSeenRoots);\n+  }\n+\n+  private void verifyHashesInChain(\n+      final BlockMetadataStore store,\n+      final ChainBuilder chain,\n+      final Bytes32 headRoot,\n+      final Stream<SignedBlockAndState> expectedBlocks) {\n+    final Set<Bytes32> seenBlocks = new HashSet<>();\n+\n+    final AtomicReference<Bytes32> expectedBlock = new AtomicReference<>(headRoot);\n+    store.processHashesInChain(\n+        headRoot,\n+        (childRoot, slot, parentRoot) -> {\n+          assertThat(seenBlocks).doesNotContain(childRoot);\n+          seenBlocks.add(childRoot);\n+\n+          final SignedBeaconBlock block = chain.getBlock(expectedBlock.get()).orElseThrow();\n+          assertThat(childRoot).isEqualTo(block.getRoot());\n+          assertThat(slot).isEqualTo(block.getSlot());\n+          assertThat(parentRoot).isEqualTo(block.getParentRoot());\n+\n+          expectedBlock.set(block.getParentRoot());\n+        });\n+    // Check all fork blocks were seen\n+    final Set<Bytes32> expectedSeenRoots =\n+        expectedBlocks.map(StateAndBlockSummary::getRoot).collect(toSet());\n+\n+    assertThat(seenBlocks).containsExactlyInAnyOrderElementsOf(expectedSeenRoots);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36b261539eb2193410edaf5bf205516b9df1718c"}, "originalPosition": 256}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTA1NTQ5Nw==", "bodyText": "We're tracking that we go from child to parent on each step which also checks order.", "url": "https://github.com/ConsenSys/teku/pull/3136#discussion_r521055497", "createdAt": "2020-11-11T02:54:58Z", "author": {"login": "ajsutton"}, "path": "protoarray/src/test/java/tech/pegasys/teku/protoarray/AbstractBlockMetadataStoreTest.java", "diffHunk": "@@ -0,0 +1,260 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.protoarray;\n+\n+import static java.util.stream.Collectors.toList;\n+import static java.util.stream.Collectors.toSet;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static tech.pegasys.teku.util.config.Constants.GENESIS_EPOCH;\n+\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Stream;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.jupiter.api.Test;\n+import tech.pegasys.teku.core.ChainBuilder;\n+import tech.pegasys.teku.datastructures.blocks.BlockAndCheckpointEpochs;\n+import tech.pegasys.teku.datastructures.blocks.SignedBeaconBlock;\n+import tech.pegasys.teku.datastructures.blocks.SignedBlockAndState;\n+import tech.pegasys.teku.datastructures.blocks.StateAndBlockSummary;\n+import tech.pegasys.teku.datastructures.state.Checkpoint;\n+import tech.pegasys.teku.infrastructure.unsigned.UInt64;\n+\n+abstract class AbstractBlockMetadataStoreTest {\n+\n+  private final ChainBuilder chainBuilder = ChainBuilder.createDefault();\n+  private final SignedBlockAndState genesis = chainBuilder.generateGenesis();\n+  private final Checkpoint genesisCheckpoint =\n+      new Checkpoint(UInt64.valueOf(GENESIS_EPOCH), genesis.getRoot());\n+\n+  @Test\n+  void contains_shouldOnlyContainBlocksThatExist() {\n+    final BlockMetadataStore store = createBlockMetadataStore(chainBuilder);\n+    assertThat(store.contains(genesis.getRoot())).isTrue();\n+    assertThat(store.contains(Bytes32.ZERO)).isFalse();\n+  }\n+\n+  @Test\n+  void contains_shouldContainAddedBlocks() {\n+    final BlockMetadataStore store = createBlockMetadataStore(chainBuilder);\n+    final BlockAndCheckpointEpochs block1 =\n+        BlockAndCheckpointEpochs.fromBlockAndState(chainBuilder.generateBlockAtSlot(1));\n+    final BlockAndCheckpointEpochs block2 =\n+        BlockAndCheckpointEpochs.fromBlockAndState(chainBuilder.generateBlockAtSlot(2));\n+    final BlockAndCheckpointEpochs block3 =\n+        BlockAndCheckpointEpochs.fromBlockAndState(chainBuilder.generateBlockAtSlot(3));\n+\n+    final BlockMetadataStore updatedStore =\n+        store.applyUpdate(\n+            List.of(block1, block2, block3), Collections.emptySet(), genesisCheckpoint);\n+\n+    chainBuilder\n+        .streamBlocksAndStates()\n+        .forEach(block -> assertThat(updatedStore.contains(block.getRoot())).isTrue());\n+  }\n+\n+  @Test\n+  void contains_shouldNotContainRemovedBlocks() {\n+    BlockMetadataStore store = createBlockMetadataStore(chainBuilder);\n+    final BlockAndCheckpointEpochs block1 =\n+        BlockAndCheckpointEpochs.fromBlockAndState(chainBuilder.generateBlockAtSlot(1));\n+    final BlockAndCheckpointEpochs block2 =\n+        BlockAndCheckpointEpochs.fromBlockAndState(chainBuilder.generateBlockAtSlot(2));\n+    final BlockAndCheckpointEpochs block3 =\n+        BlockAndCheckpointEpochs.fromBlockAndState(chainBuilder.generateBlockAtSlot(3));\n+\n+    store =\n+        store.applyUpdate(\n+            List.of(block1, block2, block3),\n+            Set.of(genesis.getRoot(), block1.getRoot()),\n+            new Checkpoint(UInt64.ONE, block2.getRoot()));\n+\n+    assertThat(store.contains(genesis.getRoot())).isFalse();\n+    assertThat(store.contains(block1.getRoot())).isFalse();\n+    assertThat(store.contains(block2.getRoot())).isTrue();\n+    assertThat(store.contains(block3.getRoot())).isTrue();\n+  }\n+\n+  @Test\n+  void processAllInOrder_shouldVisitAllBlocksInSingleChain() {\n+    final int lastSlot = 10;\n+    chainBuilder.generateBlocksUpToSlot(lastSlot);\n+    final BlockMetadataStore store = createBlockMetadataStore(chainBuilder);\n+    final AtomicInteger expectedNextSlot = new AtomicInteger(0);\n+    store.processAllInOrder(\n+        (childRoot, slot, parentRoot) -> {\n+          assertThat(slot).isEqualTo(UInt64.valueOf(expectedNextSlot.getAndIncrement()));\n+          final SignedBeaconBlock block = chainBuilder.getBlockAtSlot(slot);\n+          assertThat(childRoot).isEqualTo(block.getRoot());\n+          assertThat(slot).isEqualTo(block.getSlot());\n+          assertThat(parentRoot).isEqualTo(block.getParentRoot());\n+        });\n+    // We should have processed the block in the last slot and now be expected the one after\n+    assertThat(expectedNextSlot).hasValue(lastSlot + 1);\n+  }\n+\n+  @Test\n+  void processAllInOrder_shouldVisitParentBlocksBeforeChildBlocksInForks() {\n+    // First chain has all blocks up to 10\n+    // Fork chain has 0-5, skips 6 and then has 7-10\n+    chainBuilder.generateBlocksUpToSlot(5);\n+    final ChainBuilder forkBuilder = chainBuilder.fork();\n+    chainBuilder.generateBlocksUpToSlot(10);\n+    forkBuilder.generateBlockAtSlot(7);\n+    forkBuilder.generateBlocksUpToSlot(10);\n+    final BlockMetadataStore store =\n+        createBlockMetadataStore(chainBuilder)\n+            .applyUpdate(\n+                forkBuilder\n+                    .streamBlocksAndStates()\n+                    .map(BlockAndCheckpointEpochs::fromBlockAndState)\n+                    .collect(toList()),\n+                Collections.emptySet(),\n+                genesisCheckpoint);\n+\n+    final Set<Bytes32> seenBlocks = new HashSet<>();\n+\n+    store.processAllInOrder(\n+        (childRoot, slot, parentRoot) -> {\n+          assertThat(seenBlocks).doesNotContain(childRoot);\n+          if (!seenBlocks.isEmpty()) {\n+            // First block won't have visited the parent\n+            assertThat(seenBlocks).contains(parentRoot);\n+          }\n+\n+          seenBlocks.add(childRoot);\n+\n+          final SignedBeaconBlock block =\n+              chainBuilder\n+                  .getBlock(childRoot)\n+                  .or(() -> forkBuilder.getBlock(childRoot))\n+                  .orElseThrow();\n+          assertThat(childRoot).isEqualTo(block.getRoot());\n+          assertThat(slot).isEqualTo(block.getSlot());\n+          assertThat(parentRoot).isEqualTo(block.getParentRoot());\n+        });\n+    // Check every block was seen\n+    final Set<Bytes32> expectedSeenRoots =\n+        Stream.concat(chainBuilder.streamBlocksAndStates(), forkBuilder.streamBlocksAndStates())\n+            .map(StateAndBlockSummary::getRoot)\n+            .collect(toSet());\n+\n+    assertThat(seenBlocks).containsExactlyInAnyOrderElementsOf(expectedSeenRoots);\n+  }\n+\n+  @Test\n+  void processHashesInChain_shouldWalkUpSpecifiedChain() {\n+    // First chain has all blocks up to 10\n+    // Fork chain has 0-5, skips 6 and then has 7-10\n+    chainBuilder.generateBlocksUpToSlot(5);\n+    final ChainBuilder forkBuilder = chainBuilder.fork();\n+    chainBuilder.generateBlocksUpToSlot(10);\n+    forkBuilder.generateBlockAtSlot(7);\n+    forkBuilder.generateBlocksUpToSlot(10);\n+    final BlockMetadataStore store =\n+        createBlockMetadataStore(chainBuilder)\n+            .applyUpdate(\n+                forkBuilder\n+                    .streamBlocksAndStates()\n+                    .map(BlockAndCheckpointEpochs::fromBlockAndState)\n+                    .collect(toList()),\n+                Collections.emptySet(),\n+                genesisCheckpoint);\n+\n+    verifyHashesInChain(\n+        store,\n+        forkBuilder,\n+        forkBuilder.getLatestBlockAndState().getRoot(),\n+        forkBuilder.streamBlocksAndStates());\n+    verifyHashesInChain(\n+        store,\n+        chainBuilder,\n+        chainBuilder.getLatestBlockAndState().getRoot(),\n+        chainBuilder.streamBlocksAndStates());\n+\n+    // And check we can start from part way along the chain\n+    verifyHashesInChain(\n+        store,\n+        chainBuilder,\n+        chainBuilder.getBlockAtSlot(6).getRoot(),\n+        chainBuilder.streamBlocksAndStates(0, 6));\n+  }\n+\n+  @Test\n+  void processHashesInChainWhile_shouldStopProcessingWhenProcessorReturnsFalse() {\n+    chainBuilder.generateBlocksUpToSlot(10);\n+    final BlockMetadataStore store = createBlockMetadataStore(chainBuilder);\n+\n+    // And check we can start from part way along the chain\n+    final Bytes32 headRoot = chainBuilder.getBlockAtSlot(6).getRoot();\n+    final Stream<SignedBlockAndState> expectedBlocks = chainBuilder.streamBlocksAndStates(3, 6);\n+\n+    final Set<Bytes32> seenBlocks = new HashSet<>();\n+\n+    final AtomicReference<Bytes32> expectedBlock = new AtomicReference<>(headRoot);\n+    store.processHashesInChainWhile(\n+        headRoot,\n+        (childRoot, slot, parentRoot) -> {\n+          assertThat(seenBlocks).doesNotContain(childRoot);\n+          seenBlocks.add(childRoot);\n+\n+          final SignedBeaconBlock block = chainBuilder.getBlock(expectedBlock.get()).orElseThrow();\n+          assertThat(childRoot).isEqualTo(block.getRoot());\n+          assertThat(slot).isEqualTo(block.getSlot());\n+          assertThat(parentRoot).isEqualTo(block.getParentRoot());\n+\n+          expectedBlock.set(block.getParentRoot());\n+          return !slot.equals(UInt64.valueOf(3));\n+        });\n+    // Check all fork blocks were seen\n+    final Set<Bytes32> expectedSeenRoots =\n+        expectedBlocks.map(StateAndBlockSummary::getRoot).collect(toSet());\n+\n+    assertThat(seenBlocks).containsExactlyInAnyOrderElementsOf(expectedSeenRoots);\n+  }\n+\n+  private void verifyHashesInChain(\n+      final BlockMetadataStore store,\n+      final ChainBuilder chain,\n+      final Bytes32 headRoot,\n+      final Stream<SignedBlockAndState> expectedBlocks) {\n+    final Set<Bytes32> seenBlocks = new HashSet<>();\n+\n+    final AtomicReference<Bytes32> expectedBlock = new AtomicReference<>(headRoot);\n+    store.processHashesInChain(\n+        headRoot,\n+        (childRoot, slot, parentRoot) -> {\n+          assertThat(seenBlocks).doesNotContain(childRoot);\n+          seenBlocks.add(childRoot);\n+\n+          final SignedBeaconBlock block = chain.getBlock(expectedBlock.get()).orElseThrow();\n+          assertThat(childRoot).isEqualTo(block.getRoot());\n+          assertThat(slot).isEqualTo(block.getSlot());\n+          assertThat(parentRoot).isEqualTo(block.getParentRoot());\n+\n+          expectedBlock.set(block.getParentRoot());\n+        });\n+    // Check all fork blocks were seen\n+    final Set<Bytes32> expectedSeenRoots =\n+        expectedBlocks.map(StateAndBlockSummary::getRoot).collect(toSet());\n+\n+    assertThat(seenBlocks).containsExactlyInAnyOrderElementsOf(expectedSeenRoots);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg0Mjc2Ng=="}, "originalCommit": {"oid": "36b261539eb2193410edaf5bf205516b9df1718c"}, "originalPosition": 256}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NTI0NjA5OnYy", "diffSide": "RIGHT", "path": "storage/src/main/java/tech/pegasys/teku/storage/store/Store.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMDoyMDozN1rOHwuJvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMDoyMDozN1rOHwuJvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg0OTg1NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      ProtoArrayForkChoiceStrategy.initialize(store, protoArrayStorageChannel).join();\n          \n          \n            \n                      ProtoArrayForkChoiceStrategy.initializeAndMigrateStorage(store, protoArrayStorageChannel).join();", "url": "https://github.com/ConsenSys/teku/pull/3136#discussion_r520849855", "createdAt": "2020-11-10T20:20:37Z", "author": {"login": "mbaxter"}, "path": "storage/src/main/java/tech/pegasys/teku/storage/store/Store.java", "diffHunk": "@@ -169,33 +183,88 @@ public static UpdatableStore create(\n         CachingTaskQueue.create(\n             asyncRunner, metricsSystem, \"memory_states\", config.getStateCacheSize());\n \n-    // Build block tree structure\n-    HashTree.Builder treeBuilder = HashTree.builder().rootHash(finalizedAnchor.getRoot());\n-    childToParentRoot.forEach(treeBuilder::childAndParentRoots);\n-    final BlockTree blockTree = BlockTree.create(treeBuilder.build(), rootToSlotMap);\n-    if (blockTree.size() < childToParentRoot.size()) {\n-      final int invalidBlockCount = childToParentRoot.size() - blockTree.size();\n-      throw new IllegalStateException(\n-          invalidBlockCount\n-              + \" invalid non-canonical block(s) supplied to Store that do not descend from the latest finalized block.\");\n+    final Optional<ProtoArrayForkChoiceStrategy> maybeForkChoiceStrategy =\n+        buildProtoArray(blockInfoByRoot, initialCheckpoint, justifiedCheckpoint, finalizedAnchor)\n+            .map(ProtoArrayForkChoiceStrategy::initialize);\n+\n+    final BlockMetadataStore blockMetadataStore =\n+        maybeForkChoiceStrategy\n+            .<BlockMetadataStore>map(a -> a)\n+            .orElseGet(\n+                () -> {\n+                  // Build block tree structure\n+                  final Map<Bytes32, Bytes32> childToParentRoot =\n+                      Maps.transformValues(blockInfoByRoot, StoredBlockMetadata::getParentRoot);\n+                  final Map<Bytes32, UInt64> rootToSlotMap =\n+                      Maps.transformValues(blockInfoByRoot, StoredBlockMetadata::getBlockSlot);\n+                  HashTree.Builder treeBuilder =\n+                      HashTree.builder().rootHash(finalizedAnchor.getRoot());\n+                  childToParentRoot.forEach(treeBuilder::childAndParentRoots);\n+                  final BlockTree blockTree = BlockTree.create(treeBuilder.build(), rootToSlotMap);\n+                  if (blockTree.size() < childToParentRoot.size()) {\n+                    final int invalidBlockCount = childToParentRoot.size() - blockTree.size();\n+                    throw new IllegalStateException(\n+                        invalidBlockCount\n+                            + \" invalid non-canonical block(s) supplied to Store that do not descend from the latest finalized block.\");\n+                  }\n+                  return blockTree;\n+                });\n+\n+    final Store store =\n+        new Store(\n+            metricsSystem,\n+            config.getHotStatePersistenceFrequencyInEpochs(),\n+            blockProvider,\n+            stateAndBlockProvider,\n+            stateTaskQueue,\n+            initialCheckpoint,\n+            time,\n+            genesisTime,\n+            finalizedAnchor,\n+            justifiedCheckpoint,\n+            bestJustifiedCheckpoint,\n+            blockMetadataStore,\n+            votes,\n+            blocks,\n+            checkpointStateTaskQueue);\n+    if (maybeForkChoiceStrategy.isEmpty()) {\n+      final ProtoArrayForkChoiceStrategy forkChoiceStrategy =\n+          ProtoArrayForkChoiceStrategy.initialize(store, protoArrayStorageChannel).join();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36b261539eb2193410edaf5bf205516b9df1718c"}, "originalPosition": 149}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NTM0OTA4OnYy", "diffSide": "RIGHT", "path": "storage/src/main/java/tech/pegasys/teku/storage/store/Store.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMDo1MTowN1rOHwvIAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwMjo1NzowMFrOHw61Aw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg2NTc5Mg==", "bodyText": "To make sure I understand, the deadlock would happen in the following way?:\n\nWe enter this method, run findHead and acquire the protoarray locks\nAnother transaction finishes, acquires store locks, and tries to acquire protoarray locks in BlockMetadataStore.applyUpdates, but can't\nfindHead now tries to acquire the store locks but can't", "url": "https://github.com/ConsenSys/teku/pull/3136#discussion_r520865792", "createdAt": "2020-11-10T20:51:07Z", "author": {"login": "mbaxter"}, "path": "storage/src/main/java/tech/pegasys/teku/storage/store/Store.java", "diffHunk": "@@ -597,4 +676,21 @@ private void putBlock(final SignedBeaconBlock block) {\n       writeLock.unlock();\n     }\n   }\n+\n+  Bytes32 applyForkChoiceScoreChanges(\n+      final MutableStore transaction,\n+      final Checkpoint finalizedCheckpoint,\n+      final Checkpoint justifiedCheckpoint,\n+      final BeaconState justifiedCheckpointState) {\n+    // Ensure the store lock is taken before entering forkChoiceStrategy. Otherwise it takes the\n+    // protoArray lock first, and may deadlock when it later needs to get votes which requires the\n+    // store lock.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36b261539eb2193410edaf5bf205516b9df1718c"}, "originalPosition": 354}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg2OTA2NQ==", "bodyText": "And ProtoArrayForkChoiceStrategy.onAttestation doesn't create a similar problem because it's only acquiring the votesLock?", "url": "https://github.com/ConsenSys/teku/pull/3136#discussion_r520869065", "createdAt": "2020-11-10T20:57:12Z", "author": {"login": "mbaxter"}, "path": "storage/src/main/java/tech/pegasys/teku/storage/store/Store.java", "diffHunk": "@@ -597,4 +676,21 @@ private void putBlock(final SignedBeaconBlock block) {\n       writeLock.unlock();\n     }\n   }\n+\n+  Bytes32 applyForkChoiceScoreChanges(\n+      final MutableStore transaction,\n+      final Checkpoint finalizedCheckpoint,\n+      final Checkpoint justifiedCheckpoint,\n+      final BeaconState justifiedCheckpointState) {\n+    // Ensure the store lock is taken before entering forkChoiceStrategy. Otherwise it takes the\n+    // protoArray lock first, and may deadlock when it later needs to get votes which requires the\n+    // store lock.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg2NTc5Mg=="}, "originalCommit": {"oid": "36b261539eb2193410edaf5bf205516b9df1718c"}, "originalPosition": 354}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTA1NzUzOQ==", "bodyText": "Correct on both counts. The deadlock is between two transactions, one that's running through findHead and one that's importing blocks.", "url": "https://github.com/ConsenSys/teku/pull/3136#discussion_r521057539", "createdAt": "2020-11-11T02:57:00Z", "author": {"login": "ajsutton"}, "path": "storage/src/main/java/tech/pegasys/teku/storage/store/Store.java", "diffHunk": "@@ -597,4 +676,21 @@ private void putBlock(final SignedBeaconBlock block) {\n       writeLock.unlock();\n     }\n   }\n+\n+  Bytes32 applyForkChoiceScoreChanges(\n+      final MutableStore transaction,\n+      final Checkpoint finalizedCheckpoint,\n+      final Checkpoint justifiedCheckpoint,\n+      final BeaconState justifiedCheckpointState) {\n+    // Ensure the store lock is taken before entering forkChoiceStrategy. Otherwise it takes the\n+    // protoArray lock first, and may deadlock when it later needs to get votes which requires the\n+    // store lock.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg2NTc5Mg=="}, "originalCommit": {"oid": "36b261539eb2193410edaf5bf205516b9df1718c"}, "originalPosition": 354}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2NTQyMTkzOnYy", "diffSide": "RIGHT", "path": "storage/src/main/java/tech/pegasys/teku/storage/store/Store.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQyMToxNDowMlrOHwv12g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQwMjo1Nzo1MFrOHw64MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg3NzUzMA==", "bodyText": "Doesn't this only save the first epoch boundary seen as processing hashes on the chain instead of saving the latest one?", "url": "https://github.com/ConsenSys/teku/pull/3136#discussion_r520877530", "createdAt": "2020-11-10T21:14:02Z", "author": {"login": "cemozerr"}, "path": "storage/src/main/java/tech/pegasys/teku/storage/store/Store.java", "diffHunk": "@@ -500,17 +566,14 @@ VoteTracker getVote(UInt64 validatorIndex) {\n     final AtomicReference<SlotAndBlockRoot> latestEpochBoundary = new AtomicReference<>();\n     readLock.lock();\n     try {\n-      blockTree\n-          .getHashTree()\n-          .processHashesInChain(\n-              blockRoot,\n-              (root, parent) -> {\n-                treeBuilder.childAndParentRoots(root, parent);\n-                if (shouldPersistState(blockTree, root)) {\n-                  latestEpochBoundary.compareAndExchange(\n-                      null, new SlotAndBlockRoot(blockTree.getSlot(root), root));\n-                }\n-              });\n+      blockMetadata.processHashesInChain(\n+          blockRoot,\n+          (root, slot, parent) -> {\n+            treeBuilder.childAndParentRoots(root, parent);\n+            if (shouldPersistState(slot, parent)) {\n+              latestEpochBoundary.compareAndExchange(null, new SlotAndBlockRoot(slot, root));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36b261539eb2193410edaf5bf205516b9df1718c"}, "originalPosition": 269}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg3Nzg5NA==", "bodyText": ".compareAndExchange seems to only set the value to the second argument, if the reference is equal to the first argument.", "url": "https://github.com/ConsenSys/teku/pull/3136#discussion_r520877894", "createdAt": "2020-11-10T21:14:43Z", "author": {"login": "cemozerr"}, "path": "storage/src/main/java/tech/pegasys/teku/storage/store/Store.java", "diffHunk": "@@ -500,17 +566,14 @@ VoteTracker getVote(UInt64 validatorIndex) {\n     final AtomicReference<SlotAndBlockRoot> latestEpochBoundary = new AtomicReference<>();\n     readLock.lock();\n     try {\n-      blockTree\n-          .getHashTree()\n-          .processHashesInChain(\n-              blockRoot,\n-              (root, parent) -> {\n-                treeBuilder.childAndParentRoots(root, parent);\n-                if (shouldPersistState(blockTree, root)) {\n-                  latestEpochBoundary.compareAndExchange(\n-                      null, new SlotAndBlockRoot(blockTree.getSlot(root), root));\n-                }\n-              });\n+      blockMetadata.processHashesInChain(\n+          blockRoot,\n+          (root, slot, parent) -> {\n+            treeBuilder.childAndParentRoots(root, parent);\n+            if (shouldPersistState(slot, parent)) {\n+              latestEpochBoundary.compareAndExchange(null, new SlotAndBlockRoot(slot, root));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg3NzUzMA=="}, "originalCommit": {"oid": "36b261539eb2193410edaf5bf205516b9df1718c"}, "originalPosition": 269}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTA1ODM1Mw==", "bodyText": "We're walking from the head backwards through the chain and want to capture the one closest to head, which will be the first one seen.", "url": "https://github.com/ConsenSys/teku/pull/3136#discussion_r521058353", "createdAt": "2020-11-11T02:57:50Z", "author": {"login": "ajsutton"}, "path": "storage/src/main/java/tech/pegasys/teku/storage/store/Store.java", "diffHunk": "@@ -500,17 +566,14 @@ VoteTracker getVote(UInt64 validatorIndex) {\n     final AtomicReference<SlotAndBlockRoot> latestEpochBoundary = new AtomicReference<>();\n     readLock.lock();\n     try {\n-      blockTree\n-          .getHashTree()\n-          .processHashesInChain(\n-              blockRoot,\n-              (root, parent) -> {\n-                treeBuilder.childAndParentRoots(root, parent);\n-                if (shouldPersistState(blockTree, root)) {\n-                  latestEpochBoundary.compareAndExchange(\n-                      null, new SlotAndBlockRoot(blockTree.getSlot(root), root));\n-                }\n-              });\n+      blockMetadata.processHashesInChain(\n+          blockRoot,\n+          (root, slot, parent) -> {\n+            treeBuilder.childAndParentRoots(root, parent);\n+            if (shouldPersistState(slot, parent)) {\n+              latestEpochBoundary.compareAndExchange(null, new SlotAndBlockRoot(slot, root));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg3NzUzMA=="}, "originalCommit": {"oid": "36b261539eb2193410edaf5bf205516b9df1718c"}, "originalPosition": 269}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI2ODkyODEwOnYy", "diffSide": "RIGHT", "path": "protoarray/src/main/java/tech/pegasys/teku/protoarray/ProtoArray.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxNToxOToxNVrOHxRn8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMVQxNToxOToxNVrOHxRn8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTQzMTAyNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * <p>The list may contain nodes which have been removed from the array either because they are\n          \n          \n            \n               * <p>The list may contain nodes which have been removed from the indices collection either because they are", "url": "https://github.com/ConsenSys/teku/pull/3136#discussion_r521431026", "createdAt": "2020-11-11T15:19:15Z", "author": {"login": "mbaxter"}, "path": "protoarray/src/main/java/tech/pegasys/teku/protoarray/ProtoArray.java", "diffHunk": "@@ -33,7 +33,24 @@\n   // When starting from genesis, this value is zero (genesis epoch)\n   private final UInt64 initialEpoch;\n \n+  /**\n+   * Lists all the known nodes. It is guaranteed that a node will be after its parent in the list.\n+   *\n+   * <p>The list may contain nodes which have been removed from the array either because they are", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8dce8b0b1396439ed7ed4e85a37b4b2d0feb93d"}, "originalPosition": 7}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3133, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}