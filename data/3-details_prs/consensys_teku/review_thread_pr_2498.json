{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDYyNDg5NjAw", "number": 2498, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwMzo0NToxMlrOEVPxhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwMzo0NToxMlrOEVPxhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkwNzEzOTg5OnYy", "diffSide": "RIGHT", "path": "ethereum/core/src/test/java/tech/pegasys/teku/core/signatures/ValidatorSigningRecordTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwMzo0NToxMlrOG75E9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNVQwMzo1NjoyMFrOG75PdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ1NDMyNA==", "bodyText": "potentially if the ValidatorSigningRecord declaration is pulled out so this can collapse to one line, then it'd be a lot more readable.\nspotless wrapping it in this way really makes it difficult to read.", "url": "https://github.com/ConsenSys/teku/pull/2498#discussion_r465454324", "createdAt": "2020-08-05T03:45:12Z", "author": {"login": "rolfyone"}, "path": "ethereum/core/src/test/java/tech/pegasys/teku/core/signatures/ValidatorSigningRecordTest.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.core.signatures;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.List;\n+import java.util.Optional;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import tech.pegasys.teku.core.signatures.record.ValidatorSigningRecord;\n+\n+class ValidatorSigningRecordTest {\n+\n+  @Test\n+  void shouldRoundTripDefaultValuesToBytes() {\n+    final ValidatorSigningRecord record = new ValidatorSigningRecord();\n+    final Bytes bytes = record.toBytes();\n+    final ValidatorSigningRecord result = ValidatorSigningRecord.fromBytes(bytes);\n+    assertThat(result).isEqualToComparingFieldByField(record);\n+  }\n+\n+  @Test\n+  void shouldRoundTripToBytes() {\n+    final ValidatorSigningRecord record =\n+        new ValidatorSigningRecord(\n+            UnsignedLong.valueOf(10), UnsignedLong.valueOf(20), UnsignedLong.valueOf(30));\n+    final Bytes bytes = record.toBytes();\n+    final ValidatorSigningRecord result = ValidatorSigningRecord.fromBytes(bytes);\n+    assertThat(result).isEqualToComparingFieldByField(record);\n+  }\n+\n+  @ParameterizedTest(name = \"signBlock({0})\")\n+  @MethodSource(\"blockCases\")\n+  void signBlock(\n+      @SuppressWarnings(\"unused\") final String name,\n+      final ValidatorSigningRecord input,\n+      final UnsignedLong slot,\n+      final Optional<ValidatorSigningRecord> expectedResult) {\n+    assertThat(input.maySignBlock(slot)).isEqualTo(expectedResult);\n+  }\n+\n+  static List<Arguments> blockCases() {\n+    final ValidatorSigningRecord startingRecord =\n+        new ValidatorSigningRecord(\n+            UnsignedLong.valueOf(3), UnsignedLong.valueOf(6), UnsignedLong.valueOf(7));\n+    return List.of(\n+        Arguments.of(\n+            \"noExistingRecord\",\n+            new ValidatorSigningRecord(),\n+            UnsignedLong.ONE,\n+            Optional.of(\n+                new ValidatorSigningRecord(\n+                    UnsignedLong.ONE,\n+                    ValidatorSigningRecord.NEVER_SIGNED,\n+                    ValidatorSigningRecord.NEVER_SIGNED))),\n+        Arguments.of(\"=\", startingRecord, UnsignedLong.valueOf(3), Optional.empty()),\n+        Arguments.of(\"<\", startingRecord, UnsignedLong.valueOf(2), Optional.empty()),\n+        Arguments.of(\n+            \">\",\n+            startingRecord,\n+            UnsignedLong.valueOf(4),\n+            Optional.of(\n+                new ValidatorSigningRecord(\n+                    UnsignedLong.valueOf(4), UnsignedLong.valueOf(6), UnsignedLong.valueOf(7)))));\n+  }\n+\n+  @ParameterizedTest(name = \"maySignAttestation({0})\")\n+  @MethodSource(\"attestationCases\")\n+  void maySignAttestation(\n+      @SuppressWarnings(\"unused\") final String name,\n+      final ValidatorSigningRecord input,\n+      final UnsignedLong sourceEpoch,\n+      final UnsignedLong targetEpoch,\n+      final Optional<ValidatorSigningRecord> expectedResult) {\n+    assertThat(input.maySignAttestation(sourceEpoch, targetEpoch)).isEqualTo(expectedResult);\n+  }\n+\n+  static List<Arguments> attestationCases() {\n+    final ValidatorSigningRecord startingRecord =\n+        new ValidatorSigningRecord(\n+            UnsignedLong.ONE, UnsignedLong.valueOf(4), UnsignedLong.valueOf(6));\n+    return List.of(\n+        // No record\n+        attestationArguments(\n+            \"NEVER_SIGNED\",\n+            \"NEVER_SIGNED\",\n+            new ValidatorSigningRecord(),\n+            1,\n+            2,\n+            Optional.of(\n+                new ValidatorSigningRecord(\n+                    UnsignedLong.ZERO, UnsignedLong.valueOf(1), UnsignedLong.valueOf(2)))),\n+        attestationArguments(\"=\", \"=\", startingRecord, 4, 6, Optional.empty()),\n+        attestationArguments(\"=\", \"<\", startingRecord, 4, 5, Optional.empty()),\n+        attestationArguments(\n+            \"=\",\n+            \">\",\n+            startingRecord,\n+            4,\n+            7,\n+            Optional.of(\n+                new ValidatorSigningRecord(\n+                    UnsignedLong.ONE, UnsignedLong.valueOf(4), UnsignedLong.valueOf(7)))),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7569c2b70ad02a5600090d37d637f22175addea7"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ1NzAxMg==", "bodyText": "Found some utility methods I could extract to make it work better with spotless.", "url": "https://github.com/ConsenSys/teku/pull/2498#discussion_r465457012", "createdAt": "2020-08-05T03:56:20Z", "author": {"login": "ajsutton"}, "path": "ethereum/core/src/test/java/tech/pegasys/teku/core/signatures/ValidatorSigningRecordTest.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.core.signatures;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.List;\n+import java.util.Optional;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import tech.pegasys.teku.core.signatures.record.ValidatorSigningRecord;\n+\n+class ValidatorSigningRecordTest {\n+\n+  @Test\n+  void shouldRoundTripDefaultValuesToBytes() {\n+    final ValidatorSigningRecord record = new ValidatorSigningRecord();\n+    final Bytes bytes = record.toBytes();\n+    final ValidatorSigningRecord result = ValidatorSigningRecord.fromBytes(bytes);\n+    assertThat(result).isEqualToComparingFieldByField(record);\n+  }\n+\n+  @Test\n+  void shouldRoundTripToBytes() {\n+    final ValidatorSigningRecord record =\n+        new ValidatorSigningRecord(\n+            UnsignedLong.valueOf(10), UnsignedLong.valueOf(20), UnsignedLong.valueOf(30));\n+    final Bytes bytes = record.toBytes();\n+    final ValidatorSigningRecord result = ValidatorSigningRecord.fromBytes(bytes);\n+    assertThat(result).isEqualToComparingFieldByField(record);\n+  }\n+\n+  @ParameterizedTest(name = \"signBlock({0})\")\n+  @MethodSource(\"blockCases\")\n+  void signBlock(\n+      @SuppressWarnings(\"unused\") final String name,\n+      final ValidatorSigningRecord input,\n+      final UnsignedLong slot,\n+      final Optional<ValidatorSigningRecord> expectedResult) {\n+    assertThat(input.maySignBlock(slot)).isEqualTo(expectedResult);\n+  }\n+\n+  static List<Arguments> blockCases() {\n+    final ValidatorSigningRecord startingRecord =\n+        new ValidatorSigningRecord(\n+            UnsignedLong.valueOf(3), UnsignedLong.valueOf(6), UnsignedLong.valueOf(7));\n+    return List.of(\n+        Arguments.of(\n+            \"noExistingRecord\",\n+            new ValidatorSigningRecord(),\n+            UnsignedLong.ONE,\n+            Optional.of(\n+                new ValidatorSigningRecord(\n+                    UnsignedLong.ONE,\n+                    ValidatorSigningRecord.NEVER_SIGNED,\n+                    ValidatorSigningRecord.NEVER_SIGNED))),\n+        Arguments.of(\"=\", startingRecord, UnsignedLong.valueOf(3), Optional.empty()),\n+        Arguments.of(\"<\", startingRecord, UnsignedLong.valueOf(2), Optional.empty()),\n+        Arguments.of(\n+            \">\",\n+            startingRecord,\n+            UnsignedLong.valueOf(4),\n+            Optional.of(\n+                new ValidatorSigningRecord(\n+                    UnsignedLong.valueOf(4), UnsignedLong.valueOf(6), UnsignedLong.valueOf(7)))));\n+  }\n+\n+  @ParameterizedTest(name = \"maySignAttestation({0})\")\n+  @MethodSource(\"attestationCases\")\n+  void maySignAttestation(\n+      @SuppressWarnings(\"unused\") final String name,\n+      final ValidatorSigningRecord input,\n+      final UnsignedLong sourceEpoch,\n+      final UnsignedLong targetEpoch,\n+      final Optional<ValidatorSigningRecord> expectedResult) {\n+    assertThat(input.maySignAttestation(sourceEpoch, targetEpoch)).isEqualTo(expectedResult);\n+  }\n+\n+  static List<Arguments> attestationCases() {\n+    final ValidatorSigningRecord startingRecord =\n+        new ValidatorSigningRecord(\n+            UnsignedLong.ONE, UnsignedLong.valueOf(4), UnsignedLong.valueOf(6));\n+    return List.of(\n+        // No record\n+        attestationArguments(\n+            \"NEVER_SIGNED\",\n+            \"NEVER_SIGNED\",\n+            new ValidatorSigningRecord(),\n+            1,\n+            2,\n+            Optional.of(\n+                new ValidatorSigningRecord(\n+                    UnsignedLong.ZERO, UnsignedLong.valueOf(1), UnsignedLong.valueOf(2)))),\n+        attestationArguments(\"=\", \"=\", startingRecord, 4, 6, Optional.empty()),\n+        attestationArguments(\"=\", \"<\", startingRecord, 4, 5, Optional.empty()),\n+        attestationArguments(\n+            \"=\",\n+            \">\",\n+            startingRecord,\n+            4,\n+            7,\n+            Optional.of(\n+                new ValidatorSigningRecord(\n+                    UnsignedLong.ONE, UnsignedLong.valueOf(4), UnsignedLong.valueOf(7)))),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ1NDMyNA=="}, "originalCommit": {"oid": "7569c2b70ad02a5600090d37d637f22175addea7"}, "originalPosition": 119}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3453, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}