{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM0Mjc4MTY4", "number": 2150, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxNTowODo0NlrOEGy2Mg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxNjoyNzo0NlrOEG01XQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1NTU5OTg2OnYy", "diffSide": "RIGHT", "path": "services/serviceutils/src/main/java/tech/pegasys/teku/service/serviceutils/ScheduledExecutorAsyncRunner.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxNTowODo0NlrOGlz1Ow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMDo1NjowMFrOGl_6EQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjI5OTcwNw==", "bodyText": "Should we not be returning a failed future here?", "url": "https://github.com/ConsenSys/teku/pull/2150#discussion_r442299707", "createdAt": "2020-06-18T15:08:46Z", "author": {"login": "cemozerr"}, "path": "services/serviceutils/src/main/java/tech/pegasys/teku/service/serviceutils/ScheduledExecutorAsyncRunner.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.service.serviceutils;\n+\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.SynchronousQueue;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.hyperledger.besu.plugin.services.MetricsSystem;\n+import tech.pegasys.teku.metrics.TekuMetricCategory;\n+import tech.pegasys.teku.util.async.AsyncRunner;\n+import tech.pegasys.teku.util.async.SafeFuture;\n+\n+class ScheduledExecutorAsyncRunner implements AsyncRunner {\n+  private static final Logger LOG = LogManager.getLogger();\n+  private final AtomicBoolean shutdown = new AtomicBoolean(false);\n+  private final ScheduledExecutorService scheduler;\n+  private final ExecutorService workerPool;\n+\n+  ScheduledExecutorAsyncRunner(\n+      final ScheduledExecutorService scheduler, final ExecutorService workerPool) {\n+    this.scheduler = scheduler;\n+    this.workerPool = workerPool;\n+  }\n+\n+  static AsyncRunner create(\n+      final String name, final int maxThreads, final MetricsSystem metricsSystem) {\n+    final ScheduledExecutorService scheduler =\n+        Executors.newSingleThreadScheduledExecutor(\n+            new ThreadFactoryBuilder()\n+                .setNameFormat(name + \"-async-scheduler-%d\")\n+                .setDaemon(true)\n+                .build());\n+    final ThreadPoolExecutor workerPool =\n+        new ThreadPoolExecutor(\n+            1,\n+            maxThreads,\n+            60,\n+            TimeUnit.SECONDS,\n+            new SynchronousQueue<>(),\n+            new ThreadFactoryBuilder().setNameFormat(name + \"-async-%d\").setDaemon(true).build());\n+\n+    metricsSystem.createIntegerGauge(\n+        TekuMetricCategory.EXECUTOR,\n+        name + \"_queue_size\",\n+        \"Current size of the executor task queue\",\n+        () -> workerPool.getQueue().size());\n+    metricsSystem.createIntegerGauge(\n+        TekuMetricCategory.EXECUTOR,\n+        name + \"_thread_pool_size\",\n+        \"Current number of threads in the executor thread pool\",\n+        workerPool::getPoolSize);\n+    metricsSystem.createIntegerGauge(\n+        TekuMetricCategory.EXECUTOR,\n+        name + \"_thread_active_count\",\n+        \"Current number of threads executing tasks for this executor\",\n+        workerPool::getActiveCount);\n+\n+    return new ScheduledExecutorAsyncRunner(scheduler, workerPool);\n+  }\n+\n+  @Override\n+  public <U> SafeFuture<U> runAsync(final Supplier<SafeFuture<U>> action) {\n+    return runTask(action, workerPool::execute);\n+  }\n+\n+  @Override\n+  @SuppressWarnings(\"FutureReturnValueIgnored\")\n+  public <U> SafeFuture<U> runAfterDelay(\n+      final Supplier<SafeFuture<U>> action, final long delayAmount, final TimeUnit delayUnit) {\n+    return runTask(\n+        action, task -> scheduler.schedule(() -> workerPool.execute(task), delayAmount, delayUnit));\n+  }\n+\n+  @Override\n+  public void shutdown() {\n+    // All threads are daemon threads so don't wait for them to actually stop\n+    shutdown.set(true);\n+    scheduler.shutdownNow();\n+    workerPool.shutdownNow();\n+  }\n+\n+  private <U> SafeFuture<U> runTask(\n+      final Supplier<SafeFuture<U>> action, final Consumer<Runnable> scheduler) {\n+    if (shutdown.get()) {\n+      LOG.debug(\"Ignoring async task because shutdown is in progress\");\n+      return new SafeFuture<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1212649f42d4f8df66e19d65d91d243945199047"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ5NzU1Mw==", "bodyText": "No we're deliberately just not executing the task.  This is the same as if the task had been submitted before shutdown but hadn't yet been executed - we'd shutdown without ever completing the future.  Otherwise we have to go round the code base ignoring RejectedExecutionException everywhere.", "url": "https://github.com/ConsenSys/teku/pull/2150#discussion_r442497553", "createdAt": "2020-06-18T20:56:00Z", "author": {"login": "ajsutton"}, "path": "services/serviceutils/src/main/java/tech/pegasys/teku/service/serviceutils/ScheduledExecutorAsyncRunner.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.service.serviceutils;\n+\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.SynchronousQueue;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.hyperledger.besu.plugin.services.MetricsSystem;\n+import tech.pegasys.teku.metrics.TekuMetricCategory;\n+import tech.pegasys.teku.util.async.AsyncRunner;\n+import tech.pegasys.teku.util.async.SafeFuture;\n+\n+class ScheduledExecutorAsyncRunner implements AsyncRunner {\n+  private static final Logger LOG = LogManager.getLogger();\n+  private final AtomicBoolean shutdown = new AtomicBoolean(false);\n+  private final ScheduledExecutorService scheduler;\n+  private final ExecutorService workerPool;\n+\n+  ScheduledExecutorAsyncRunner(\n+      final ScheduledExecutorService scheduler, final ExecutorService workerPool) {\n+    this.scheduler = scheduler;\n+    this.workerPool = workerPool;\n+  }\n+\n+  static AsyncRunner create(\n+      final String name, final int maxThreads, final MetricsSystem metricsSystem) {\n+    final ScheduledExecutorService scheduler =\n+        Executors.newSingleThreadScheduledExecutor(\n+            new ThreadFactoryBuilder()\n+                .setNameFormat(name + \"-async-scheduler-%d\")\n+                .setDaemon(true)\n+                .build());\n+    final ThreadPoolExecutor workerPool =\n+        new ThreadPoolExecutor(\n+            1,\n+            maxThreads,\n+            60,\n+            TimeUnit.SECONDS,\n+            new SynchronousQueue<>(),\n+            new ThreadFactoryBuilder().setNameFormat(name + \"-async-%d\").setDaemon(true).build());\n+\n+    metricsSystem.createIntegerGauge(\n+        TekuMetricCategory.EXECUTOR,\n+        name + \"_queue_size\",\n+        \"Current size of the executor task queue\",\n+        () -> workerPool.getQueue().size());\n+    metricsSystem.createIntegerGauge(\n+        TekuMetricCategory.EXECUTOR,\n+        name + \"_thread_pool_size\",\n+        \"Current number of threads in the executor thread pool\",\n+        workerPool::getPoolSize);\n+    metricsSystem.createIntegerGauge(\n+        TekuMetricCategory.EXECUTOR,\n+        name + \"_thread_active_count\",\n+        \"Current number of threads executing tasks for this executor\",\n+        workerPool::getActiveCount);\n+\n+    return new ScheduledExecutorAsyncRunner(scheduler, workerPool);\n+  }\n+\n+  @Override\n+  public <U> SafeFuture<U> runAsync(final Supplier<SafeFuture<U>> action) {\n+    return runTask(action, workerPool::execute);\n+  }\n+\n+  @Override\n+  @SuppressWarnings(\"FutureReturnValueIgnored\")\n+  public <U> SafeFuture<U> runAfterDelay(\n+      final Supplier<SafeFuture<U>> action, final long delayAmount, final TimeUnit delayUnit) {\n+    return runTask(\n+        action, task -> scheduler.schedule(() -> workerPool.execute(task), delayAmount, delayUnit));\n+  }\n+\n+  @Override\n+  public void shutdown() {\n+    // All threads are daemon threads so don't wait for them to actually stop\n+    shutdown.set(true);\n+    scheduler.shutdownNow();\n+    workerPool.shutdownNow();\n+  }\n+\n+  private <U> SafeFuture<U> runTask(\n+      final Supplier<SafeFuture<U>> action, final Consumer<Runnable> scheduler) {\n+    if (shutdown.get()) {\n+      LOG.debug(\"Ignoring async task because shutdown is in progress\");\n+      return new SafeFuture<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjI5OTcwNw=="}, "originalCommit": {"oid": "1212649f42d4f8df66e19d65d91d243945199047"}, "originalPosition": 106}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1NTY4MTM5OnYy", "diffSide": "RIGHT", "path": "services/serviceutils/src/main/java/tech/pegasys/teku/service/serviceutils/ScheduledExecutorAsyncRunner.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxNToyNzo1NlrOGl0pHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxNToyNzo1NlrOGl0pHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjMxMjk4OA==", "bodyText": "nit: The argument name scheduler here is a bit confusing since we have a ScheduledExecutorService object used in this class with the variable name scheduler. Can we rename this to something similar to runner?", "url": "https://github.com/ConsenSys/teku/pull/2150#discussion_r442312988", "createdAt": "2020-06-18T15:27:56Z", "author": {"login": "cemozerr"}, "path": "services/serviceutils/src/main/java/tech/pegasys/teku/service/serviceutils/ScheduledExecutorAsyncRunner.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.teku.service.serviceutils;\n+\n+import com.google.common.util.concurrent.ThreadFactoryBuilder;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.SynchronousQueue;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.hyperledger.besu.plugin.services.MetricsSystem;\n+import tech.pegasys.teku.metrics.TekuMetricCategory;\n+import tech.pegasys.teku.util.async.AsyncRunner;\n+import tech.pegasys.teku.util.async.SafeFuture;\n+\n+class ScheduledExecutorAsyncRunner implements AsyncRunner {\n+  private static final Logger LOG = LogManager.getLogger();\n+  private final AtomicBoolean shutdown = new AtomicBoolean(false);\n+  private final ScheduledExecutorService scheduler;\n+  private final ExecutorService workerPool;\n+\n+  ScheduledExecutorAsyncRunner(\n+      final ScheduledExecutorService scheduler, final ExecutorService workerPool) {\n+    this.scheduler = scheduler;\n+    this.workerPool = workerPool;\n+  }\n+\n+  static AsyncRunner create(\n+      final String name, final int maxThreads, final MetricsSystem metricsSystem) {\n+    final ScheduledExecutorService scheduler =\n+        Executors.newSingleThreadScheduledExecutor(\n+            new ThreadFactoryBuilder()\n+                .setNameFormat(name + \"-async-scheduler-%d\")\n+                .setDaemon(true)\n+                .build());\n+    final ThreadPoolExecutor workerPool =\n+        new ThreadPoolExecutor(\n+            1,\n+            maxThreads,\n+            60,\n+            TimeUnit.SECONDS,\n+            new SynchronousQueue<>(),\n+            new ThreadFactoryBuilder().setNameFormat(name + \"-async-%d\").setDaemon(true).build());\n+\n+    metricsSystem.createIntegerGauge(\n+        TekuMetricCategory.EXECUTOR,\n+        name + \"_queue_size\",\n+        \"Current size of the executor task queue\",\n+        () -> workerPool.getQueue().size());\n+    metricsSystem.createIntegerGauge(\n+        TekuMetricCategory.EXECUTOR,\n+        name + \"_thread_pool_size\",\n+        \"Current number of threads in the executor thread pool\",\n+        workerPool::getPoolSize);\n+    metricsSystem.createIntegerGauge(\n+        TekuMetricCategory.EXECUTOR,\n+        name + \"_thread_active_count\",\n+        \"Current number of threads executing tasks for this executor\",\n+        workerPool::getActiveCount);\n+\n+    return new ScheduledExecutorAsyncRunner(scheduler, workerPool);\n+  }\n+\n+  @Override\n+  public <U> SafeFuture<U> runAsync(final Supplier<SafeFuture<U>> action) {\n+    return runTask(action, workerPool::execute);\n+  }\n+\n+  @Override\n+  @SuppressWarnings(\"FutureReturnValueIgnored\")\n+  public <U> SafeFuture<U> runAfterDelay(\n+      final Supplier<SafeFuture<U>> action, final long delayAmount, final TimeUnit delayUnit) {\n+    return runTask(\n+        action, task -> scheduler.schedule(() -> workerPool.execute(task), delayAmount, delayUnit));\n+  }\n+\n+  @Override\n+  public void shutdown() {\n+    // All threads are daemon threads so don't wait for them to actually stop\n+    shutdown.set(true);\n+    scheduler.shutdownNow();\n+    workerPool.shutdownNow();\n+  }\n+\n+  private <U> SafeFuture<U> runTask(\n+      final Supplier<SafeFuture<U>> action, final Consumer<Runnable> scheduler) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1212649f42d4f8df66e19d65d91d243945199047"}, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1NTkyNTQxOnYy", "diffSide": "RIGHT", "path": "sync/src/main/java/tech/pegasys/teku/sync/SyncManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxNjoyNzo0NlrOGl3EXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxNjoyNzo0NlrOGl3EXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM1MjczNQ==", "bodyText": "Nice.", "url": "https://github.com/ConsenSys/teku/pull/2150#discussion_r442352735", "createdAt": "2020-06-18T16:27:46Z", "author": {"login": "cemozerr"}, "path": "sync/src/main/java/tech/pegasys/teku/sync/SyncManager.java", "diffHunk": "@@ -193,7 +194,12 @@ public SyncingStatus getSyncStatus() {\n             })\n         .exceptionally(\n             error -> {\n-              LOG.error(\"Error during sync to peer \" + syncPeer, error);\n+              if (Throwables.getRootCause(error) instanceof PeerDisconnectedException) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1212649f42d4f8df66e19d65d91d243945199047"}, "originalPosition": 39}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3599, "cost": 1, "resetAt": "2021-11-12T11:57:46Z"}}}