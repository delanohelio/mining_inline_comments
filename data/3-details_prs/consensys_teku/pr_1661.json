{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA4MjgxNDM4", "number": 1661, "title": "Implement attestation gossip validation requirements", "bodyText": "PR Description\nImplement AttestationValidator to perform all the required validation on attestations prior to gossiping them.\nAlso means that attestations are deferred if we receive them before the block they are attesting to has been processed.", "createdAt": "2020-04-24T01:35:09Z", "url": "https://github.com/ConsenSys/teku/pull/1661", "merged": true, "mergeCommit": {"oid": "f79f65fdc23414dd08d2e0c5d93211df3fa52665"}, "closed": true, "closedAt": "2020-04-26T21:15:19Z", "author": {"login": "ajsutton"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcamcaCAH2gAyNDA4MjgxNDM4OmNlOTljNGE3ODYzNGMzODAzYzdjZmRkMDU1ZWU1MmFiMWFkZTk3MWU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcbhD_mAH2gAyNDA4MjgxNDM4OjAyYzllNDZhM2Y0MmM0Y2VkYjY1NTQ3OWU3MmFiODg5NjM1ZDlkYTQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "ce99c4a78634c3803c7cfdd055ee52ab1ade971e", "author": {"user": {"login": "ajsutton", "name": "Adrian Sutton"}}, "url": "https://github.com/ConsenSys/teku/commit/ce99c4a78634c3803c7cfdd055ee52ab1ade971e", "committedDate": "2020-04-24T00:35:32Z", "message": "Introduce AttestationValidator"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8689e47a47ec5274a364f4b1adc0926724aa8726", "author": {"user": {"login": "ajsutton", "name": "Adrian Sutton"}}, "url": "https://github.com/ConsenSys/teku/commit/8689e47a47ec5274a364f4b1adc0926724aa8726", "committedDate": "2020-04-24T01:10:31Z", "message": "Use AttestationValidator in AttestationTopicHandler."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "832fb0f151823dfc43126620c4dc6ab7b6fc3314", "author": {"user": {"login": "ajsutton", "name": "Adrian Sutton"}}, "url": "https://github.com/ConsenSys/teku/commit/832fb0f151823dfc43126620c4dc6ab7b6fc3314", "committedDate": "2020-04-24T01:35:21Z", "message": "Merge branch 'master' of github.com:PegaSysEng/teku into validate-attestations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "26c99d852716324f6fa6ee953df3ded930f94393", "author": {"user": {"login": "ajsutton", "name": "Adrian Sutton"}}, "url": "https://github.com/ConsenSys/teku/commit/26c99d852716324f6fa6ee953df3ded930f94393", "committedDate": "2020-04-24T01:45:19Z", "message": "Tidy up."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwMDAzODg3", "url": "https://github.com/ConsenSys/teku/pull/1661#pullrequestreview-400003887", "createdAt": "2020-04-24T14:36:02Z", "commit": {"oid": "26c99d852716324f6fa6ee953df3ded930f94393"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNDozNjowMlrOGLat5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNDozNjowMlrOGLat5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDYyNTI1Mw==", "bodyText": "I think this should be:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private static final UnsignedLong MILLIS_PER_SECOND = UnsignedLong.valueOf(10000);\n          \n          \n            \n              private static final UnsignedLong MILLIS_PER_SECOND = UnsignedLong.valueOf(1000);", "url": "https://github.com/ConsenSys/teku/pull/1661#discussion_r414625253", "createdAt": "2020-04-24T14:36:02Z", "author": {"login": "cemozerr"}, "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/gossip/topics/validation/AttestationValidator.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.networking.eth2.gossip.topics.validation;\n+\n+import static com.google.common.primitives.UnsignedLong.ONE;\n+import static com.google.common.primitives.UnsignedLong.ZERO;\n+import static tech.pegasys.artemis.datastructures.util.AttestationUtil.get_indexed_attestation;\n+import static tech.pegasys.artemis.datastructures.util.AttestationUtil.is_valid_indexed_attestation;\n+import static tech.pegasys.artemis.networking.eth2.gossip.topics.validation.ValidationResult.INVALID;\n+import static tech.pegasys.artemis.networking.eth2.gossip.topics.validation.ValidationResult.SAVED_FOR_FUTURE;\n+import static tech.pegasys.artemis.networking.eth2.gossip.topics.validation.ValidationResult.VALID;\n+import static tech.pegasys.artemis.util.config.Constants.ATTESTATION_PROPAGATION_SLOT_RANGE;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_SLOT;\n+import static tech.pegasys.artemis.util.config.Constants.VALID_ATTESTATION_SET_SIZE;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import tech.pegasys.artemis.datastructures.operations.Attestation;\n+import tech.pegasys.artemis.datastructures.operations.IndexedAttestation;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.util.CommitteeUtil;\n+import tech.pegasys.artemis.storage.client.RecentChainData;\n+import tech.pegasys.artemis.util.collections.ConcurrentLimitedSet;\n+import tech.pegasys.artemis.util.collections.LimitStrategy;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class AttestationValidator {\n+\n+  private static final UnsignedLong MILLIS_PER_SECOND = UnsignedLong.valueOf(10000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "26c99d852716324f6fa6ee953df3ded930f94393"}, "originalPosition": 42}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwMDE0NDE5", "url": "https://github.com/ConsenSys/teku/pull/1661#pullrequestreview-400014419", "createdAt": "2020-04-24T14:47:45Z", "commit": {"oid": "26c99d852716324f6fa6ee953df3ded930f94393"}, "state": "APPROVED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNDo0Nzo0NVrOGLbRiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxNToxNzozNVrOGLcpbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDYzNDM3Ng==", "bodyText": "smart strategy.", "url": "https://github.com/ConsenSys/teku/pull/1661#discussion_r414634376", "createdAt": "2020-04-24T14:47:45Z", "author": {"login": "cemozerr"}, "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/gossip/topics/validation/AttestationValidator.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.networking.eth2.gossip.topics.validation;\n+\n+import static com.google.common.primitives.UnsignedLong.ONE;\n+import static com.google.common.primitives.UnsignedLong.ZERO;\n+import static tech.pegasys.artemis.datastructures.util.AttestationUtil.get_indexed_attestation;\n+import static tech.pegasys.artemis.datastructures.util.AttestationUtil.is_valid_indexed_attestation;\n+import static tech.pegasys.artemis.networking.eth2.gossip.topics.validation.ValidationResult.INVALID;\n+import static tech.pegasys.artemis.networking.eth2.gossip.topics.validation.ValidationResult.SAVED_FOR_FUTURE;\n+import static tech.pegasys.artemis.networking.eth2.gossip.topics.validation.ValidationResult.VALID;\n+import static tech.pegasys.artemis.util.config.Constants.ATTESTATION_PROPAGATION_SLOT_RANGE;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_SLOT;\n+import static tech.pegasys.artemis.util.config.Constants.VALID_ATTESTATION_SET_SIZE;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import tech.pegasys.artemis.datastructures.operations.Attestation;\n+import tech.pegasys.artemis.datastructures.operations.IndexedAttestation;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.util.CommitteeUtil;\n+import tech.pegasys.artemis.storage.client.RecentChainData;\n+import tech.pegasys.artemis.util.collections.ConcurrentLimitedSet;\n+import tech.pegasys.artemis.util.collections.LimitStrategy;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class AttestationValidator {\n+\n+  private static final UnsignedLong MILLIS_PER_SECOND = UnsignedLong.valueOf(10000);\n+  private static final UnsignedLong MAXIMUM_GOSSIP_CLOCK_DISPARITY =\n+      UnsignedLong.valueOf(Constants.MAXIMUM_GOSSIP_CLOCK_DISPARITY);\n+\n+  private final Set<ValidatorAndSlot> receivedValidAttestations =\n+      ConcurrentLimitedSet.create(VALID_ATTESTATION_SET_SIZE, LimitStrategy.DROP_OLDEST_ELEMENT);\n+  private final RecentChainData recentChainData;\n+\n+  public AttestationValidator(final RecentChainData recentChainData) {\n+    this.recentChainData = recentChainData;\n+  }\n+\n+  public ValidationResult validate(\n+      final Attestation attestation, final UnsignedLong receivedOnSubnetId) {\n+    ValidationResult validationResult = singleAttestationChecks(attestation, receivedOnSubnetId);\n+    if (validationResult != VALID) {\n+      return validationResult;\n+    }\n+\n+    validationResult = singleOrAggregateAttestationChecks(attestation);\n+    if (validationResult != VALID) {\n+      return validationResult;\n+    }\n+\n+    return firstValidAttestationCheck(attestation);\n+  }\n+\n+  private ValidationResult firstValidAttestationCheck(final Attestation attestation) {\n+    // The attestation is the first valid attestation received for the participating validator for\n+    // the slot, attestation.data.slot.\n+    if (!receivedValidAttestations.add(getValidatorAndSlot(attestation))) {\n+      return INVALID;\n+    }\n+    return VALID;\n+  }\n+\n+  private ValidationResult singleAttestationChecks(\n+      final Attestation attestation, final UnsignedLong receivedOnSubnetId) {\n+    // The attestation's committee index (attestation.data.index) is for the correct subnet.\n+    if (!CommitteeUtil.getSubnetId(attestation).equals(receivedOnSubnetId)) {\n+      return INVALID;\n+    }\n+\n+    // The attestation is unaggregated -- that is, it has exactly one participating validator\n+    // (len([bit for bit in attestation.aggregation_bits if bit == 0b1]) == 1).\n+    if (attestation.getAggregation_bits().countSetBits() != 1) {\n+      return INVALID;\n+    }\n+\n+    // The attestation is the first valid attestation received for the participating validator for\n+    // the slot, attestation.data.slot.\n+    if (receivedValidAttestations.contains(getValidatorAndSlot(attestation))) {\n+      return INVALID;\n+    }\n+    return VALID;\n+  }\n+\n+  private ValidationResult singleOrAggregateAttestationChecks(final Attestation attestation) {\n+    // attestation.data.slot is within the last ATTESTATION_PROPAGATION_SLOT_RANGE slots (within a\n+    // MAXIMUM_GOSSIP_CLOCK_DISPARITY allowance) -- i.e. attestation.data.slot +\n+    // ATTESTATION_PROPAGATION_SLOT_RANGE >= current_slot >= attestation.data.slot (a client MAY\n+    // queue\n+    // future attestations for processing at the appropriate slot).\n+    final UnsignedLong currentTimeMillis = secondsToMillis(recentChainData.getStore().getTime());\n+    if (isAfterPropagationSlotRange(currentTimeMillis, attestation)) {\n+      return INVALID;\n+    }\n+    if (isBeforeMinimumBroadcastTime(attestation, currentTimeMillis) < 0) {\n+      return SAVED_FOR_FUTURE;\n+    }\n+\n+    // The block being voted for (attestation.data.beacon_block_root) passes validation.\n+    // It must pass validation to be in the store.\n+    // If it's not in the store, it may not have been processed yet so save for future.\n+    final Optional<BeaconState> maybeState =\n+        recentChainData.getBlockState(attestation.getData().getBeacon_block_root());\n+    if (maybeState.isEmpty()) {\n+      return SAVED_FOR_FUTURE;\n+    }\n+\n+    final BeaconState state = maybeState.get();\n+\n+    // The signature of attestation is valid.\n+    final IndexedAttestation indexedAttestation = get_indexed_attestation(state, attestation);\n+    if (!is_valid_indexed_attestation(state, indexedAttestation)) {\n+      return INVALID;\n+    }\n+    return VALID;\n+  }\n+\n+  private ValidatorAndSlot getValidatorAndSlot(final Attestation attestation) {\n+    return new ValidatorAndSlot(\n+        attestation.getData().getSlot(),\n+        attestation.getData().getIndex(),\n+        attestation.getAggregation_bits().streamAllSetBits().findFirst().orElseThrow());\n+  }\n+\n+  private int isBeforeMinimumBroadcastTime(\n+      final Attestation attestation, final UnsignedLong currentTimeMillis) {\n+    final UnsignedLong minimumBroadcastTimeMillis =\n+        minimumBroadcastTimeMillis(attestation.getData().getSlot());\n+    return currentTimeMillis.compareTo(minimumBroadcastTimeMillis);\n+  }\n+\n+  private boolean isAfterPropagationSlotRange(\n+      final UnsignedLong currentTimeMillis, final Attestation aggregate) {\n+    final UnsignedLong aggregateSlot = aggregate.getData().getSlot();\n+    return maximumBroadcastTimeMillis(aggregateSlot).compareTo(currentTimeMillis) < 0;\n+  }\n+\n+  private UnsignedLong secondsToMillis(final UnsignedLong seconds) {\n+    return seconds.times(MILLIS_PER_SECOND);\n+  }\n+\n+  private UnsignedLong minimumBroadcastTimeMillis(final UnsignedLong aggregateSlot) {\n+    final UnsignedLong lastAllowedTime =\n+        recentChainData\n+            .getGenesisTime()\n+            .plus(aggregateSlot.times(UnsignedLong.valueOf(SECONDS_PER_SLOT)));\n+    final UnsignedLong lastAllowedTimeMillis = secondsToMillis(lastAllowedTime);\n+    return lastAllowedTimeMillis.compareTo(MAXIMUM_GOSSIP_CLOCK_DISPARITY) >= 0\n+        ? lastAllowedTimeMillis.minus(MAXIMUM_GOSSIP_CLOCK_DISPARITY)\n+        : ZERO;\n+  }\n+\n+  private UnsignedLong maximumBroadcastTimeMillis(final UnsignedLong aggregateSlot) {\n+    final UnsignedLong lastAllowedSlot = aggregateSlot.plus(ATTESTATION_PROPAGATION_SLOT_RANGE);\n+    // The last allowed time is the end of the lastAllowedSlot.\n+    final UnsignedLong lastAllowedTime =\n+        recentChainData\n+            .getGenesisTime()\n+            .plus(lastAllowedSlot.plus(ONE).times(UnsignedLong.valueOf(SECONDS_PER_SLOT)));\n+\n+    // Add allowed clock disparity\n+    return secondsToMillis(lastAllowedTime).plus(MAXIMUM_GOSSIP_CLOCK_DISPARITY);\n+  }\n+\n+  private static class ValidatorAndSlot {\n+    private final UnsignedLong slot;\n+    // Validator is identified via committee index and position to avoid resolving the actual\n+    // validator ID before checking for duplicates", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "26c99d852716324f6fa6ee953df3ded930f94393"}, "originalPosition": 182}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDYzODEyMA==", "bodyText": "nit: (it's an attestation regardless)\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  final UnsignedLong currentTimeMillis, final Attestation aggregate) {\n          \n          \n            \n                  final UnsignedLong currentTimeMillis, final Attestation attestation) {", "url": "https://github.com/ConsenSys/teku/pull/1661#discussion_r414638120", "createdAt": "2020-04-24T14:52:43Z", "author": {"login": "cemozerr"}, "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/gossip/topics/validation/AttestationValidator.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.networking.eth2.gossip.topics.validation;\n+\n+import static com.google.common.primitives.UnsignedLong.ONE;\n+import static com.google.common.primitives.UnsignedLong.ZERO;\n+import static tech.pegasys.artemis.datastructures.util.AttestationUtil.get_indexed_attestation;\n+import static tech.pegasys.artemis.datastructures.util.AttestationUtil.is_valid_indexed_attestation;\n+import static tech.pegasys.artemis.networking.eth2.gossip.topics.validation.ValidationResult.INVALID;\n+import static tech.pegasys.artemis.networking.eth2.gossip.topics.validation.ValidationResult.SAVED_FOR_FUTURE;\n+import static tech.pegasys.artemis.networking.eth2.gossip.topics.validation.ValidationResult.VALID;\n+import static tech.pegasys.artemis.util.config.Constants.ATTESTATION_PROPAGATION_SLOT_RANGE;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_SLOT;\n+import static tech.pegasys.artemis.util.config.Constants.VALID_ATTESTATION_SET_SIZE;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import tech.pegasys.artemis.datastructures.operations.Attestation;\n+import tech.pegasys.artemis.datastructures.operations.IndexedAttestation;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.util.CommitteeUtil;\n+import tech.pegasys.artemis.storage.client.RecentChainData;\n+import tech.pegasys.artemis.util.collections.ConcurrentLimitedSet;\n+import tech.pegasys.artemis.util.collections.LimitStrategy;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class AttestationValidator {\n+\n+  private static final UnsignedLong MILLIS_PER_SECOND = UnsignedLong.valueOf(10000);\n+  private static final UnsignedLong MAXIMUM_GOSSIP_CLOCK_DISPARITY =\n+      UnsignedLong.valueOf(Constants.MAXIMUM_GOSSIP_CLOCK_DISPARITY);\n+\n+  private final Set<ValidatorAndSlot> receivedValidAttestations =\n+      ConcurrentLimitedSet.create(VALID_ATTESTATION_SET_SIZE, LimitStrategy.DROP_OLDEST_ELEMENT);\n+  private final RecentChainData recentChainData;\n+\n+  public AttestationValidator(final RecentChainData recentChainData) {\n+    this.recentChainData = recentChainData;\n+  }\n+\n+  public ValidationResult validate(\n+      final Attestation attestation, final UnsignedLong receivedOnSubnetId) {\n+    ValidationResult validationResult = singleAttestationChecks(attestation, receivedOnSubnetId);\n+    if (validationResult != VALID) {\n+      return validationResult;\n+    }\n+\n+    validationResult = singleOrAggregateAttestationChecks(attestation);\n+    if (validationResult != VALID) {\n+      return validationResult;\n+    }\n+\n+    return firstValidAttestationCheck(attestation);\n+  }\n+\n+  private ValidationResult firstValidAttestationCheck(final Attestation attestation) {\n+    // The attestation is the first valid attestation received for the participating validator for\n+    // the slot, attestation.data.slot.\n+    if (!receivedValidAttestations.add(getValidatorAndSlot(attestation))) {\n+      return INVALID;\n+    }\n+    return VALID;\n+  }\n+\n+  private ValidationResult singleAttestationChecks(\n+      final Attestation attestation, final UnsignedLong receivedOnSubnetId) {\n+    // The attestation's committee index (attestation.data.index) is for the correct subnet.\n+    if (!CommitteeUtil.getSubnetId(attestation).equals(receivedOnSubnetId)) {\n+      return INVALID;\n+    }\n+\n+    // The attestation is unaggregated -- that is, it has exactly one participating validator\n+    // (len([bit for bit in attestation.aggregation_bits if bit == 0b1]) == 1).\n+    if (attestation.getAggregation_bits().countSetBits() != 1) {\n+      return INVALID;\n+    }\n+\n+    // The attestation is the first valid attestation received for the participating validator for\n+    // the slot, attestation.data.slot.\n+    if (receivedValidAttestations.contains(getValidatorAndSlot(attestation))) {\n+      return INVALID;\n+    }\n+    return VALID;\n+  }\n+\n+  private ValidationResult singleOrAggregateAttestationChecks(final Attestation attestation) {\n+    // attestation.data.slot is within the last ATTESTATION_PROPAGATION_SLOT_RANGE slots (within a\n+    // MAXIMUM_GOSSIP_CLOCK_DISPARITY allowance) -- i.e. attestation.data.slot +\n+    // ATTESTATION_PROPAGATION_SLOT_RANGE >= current_slot >= attestation.data.slot (a client MAY\n+    // queue\n+    // future attestations for processing at the appropriate slot).\n+    final UnsignedLong currentTimeMillis = secondsToMillis(recentChainData.getStore().getTime());\n+    if (isAfterPropagationSlotRange(currentTimeMillis, attestation)) {\n+      return INVALID;\n+    }\n+    if (isBeforeMinimumBroadcastTime(attestation, currentTimeMillis) < 0) {\n+      return SAVED_FOR_FUTURE;\n+    }\n+\n+    // The block being voted for (attestation.data.beacon_block_root) passes validation.\n+    // It must pass validation to be in the store.\n+    // If it's not in the store, it may not have been processed yet so save for future.\n+    final Optional<BeaconState> maybeState =\n+        recentChainData.getBlockState(attestation.getData().getBeacon_block_root());\n+    if (maybeState.isEmpty()) {\n+      return SAVED_FOR_FUTURE;\n+    }\n+\n+    final BeaconState state = maybeState.get();\n+\n+    // The signature of attestation is valid.\n+    final IndexedAttestation indexedAttestation = get_indexed_attestation(state, attestation);\n+    if (!is_valid_indexed_attestation(state, indexedAttestation)) {\n+      return INVALID;\n+    }\n+    return VALID;\n+  }\n+\n+  private ValidatorAndSlot getValidatorAndSlot(final Attestation attestation) {\n+    return new ValidatorAndSlot(\n+        attestation.getData().getSlot(),\n+        attestation.getData().getIndex(),\n+        attestation.getAggregation_bits().streamAllSetBits().findFirst().orElseThrow());\n+  }\n+\n+  private int isBeforeMinimumBroadcastTime(\n+      final Attestation attestation, final UnsignedLong currentTimeMillis) {\n+    final UnsignedLong minimumBroadcastTimeMillis =\n+        minimumBroadcastTimeMillis(attestation.getData().getSlot());\n+    return currentTimeMillis.compareTo(minimumBroadcastTimeMillis);\n+  }\n+\n+  private boolean isAfterPropagationSlotRange(\n+      final UnsignedLong currentTimeMillis, final Attestation aggregate) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "26c99d852716324f6fa6ee953df3ded930f94393"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY0MDYwOQ==", "bodyText": "Why do we need .plus(ONE) here?", "url": "https://github.com/ConsenSys/teku/pull/1661#discussion_r414640609", "createdAt": "2020-04-24T14:55:57Z", "author": {"login": "cemozerr"}, "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/gossip/topics/validation/AttestationValidator.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.networking.eth2.gossip.topics.validation;\n+\n+import static com.google.common.primitives.UnsignedLong.ONE;\n+import static com.google.common.primitives.UnsignedLong.ZERO;\n+import static tech.pegasys.artemis.datastructures.util.AttestationUtil.get_indexed_attestation;\n+import static tech.pegasys.artemis.datastructures.util.AttestationUtil.is_valid_indexed_attestation;\n+import static tech.pegasys.artemis.networking.eth2.gossip.topics.validation.ValidationResult.INVALID;\n+import static tech.pegasys.artemis.networking.eth2.gossip.topics.validation.ValidationResult.SAVED_FOR_FUTURE;\n+import static tech.pegasys.artemis.networking.eth2.gossip.topics.validation.ValidationResult.VALID;\n+import static tech.pegasys.artemis.util.config.Constants.ATTESTATION_PROPAGATION_SLOT_RANGE;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_SLOT;\n+import static tech.pegasys.artemis.util.config.Constants.VALID_ATTESTATION_SET_SIZE;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import tech.pegasys.artemis.datastructures.operations.Attestation;\n+import tech.pegasys.artemis.datastructures.operations.IndexedAttestation;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.util.CommitteeUtil;\n+import tech.pegasys.artemis.storage.client.RecentChainData;\n+import tech.pegasys.artemis.util.collections.ConcurrentLimitedSet;\n+import tech.pegasys.artemis.util.collections.LimitStrategy;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class AttestationValidator {\n+\n+  private static final UnsignedLong MILLIS_PER_SECOND = UnsignedLong.valueOf(10000);\n+  private static final UnsignedLong MAXIMUM_GOSSIP_CLOCK_DISPARITY =\n+      UnsignedLong.valueOf(Constants.MAXIMUM_GOSSIP_CLOCK_DISPARITY);\n+\n+  private final Set<ValidatorAndSlot> receivedValidAttestations =\n+      ConcurrentLimitedSet.create(VALID_ATTESTATION_SET_SIZE, LimitStrategy.DROP_OLDEST_ELEMENT);\n+  private final RecentChainData recentChainData;\n+\n+  public AttestationValidator(final RecentChainData recentChainData) {\n+    this.recentChainData = recentChainData;\n+  }\n+\n+  public ValidationResult validate(\n+      final Attestation attestation, final UnsignedLong receivedOnSubnetId) {\n+    ValidationResult validationResult = singleAttestationChecks(attestation, receivedOnSubnetId);\n+    if (validationResult != VALID) {\n+      return validationResult;\n+    }\n+\n+    validationResult = singleOrAggregateAttestationChecks(attestation);\n+    if (validationResult != VALID) {\n+      return validationResult;\n+    }\n+\n+    return firstValidAttestationCheck(attestation);\n+  }\n+\n+  private ValidationResult firstValidAttestationCheck(final Attestation attestation) {\n+    // The attestation is the first valid attestation received for the participating validator for\n+    // the slot, attestation.data.slot.\n+    if (!receivedValidAttestations.add(getValidatorAndSlot(attestation))) {\n+      return INVALID;\n+    }\n+    return VALID;\n+  }\n+\n+  private ValidationResult singleAttestationChecks(\n+      final Attestation attestation, final UnsignedLong receivedOnSubnetId) {\n+    // The attestation's committee index (attestation.data.index) is for the correct subnet.\n+    if (!CommitteeUtil.getSubnetId(attestation).equals(receivedOnSubnetId)) {\n+      return INVALID;\n+    }\n+\n+    // The attestation is unaggregated -- that is, it has exactly one participating validator\n+    // (len([bit for bit in attestation.aggregation_bits if bit == 0b1]) == 1).\n+    if (attestation.getAggregation_bits().countSetBits() != 1) {\n+      return INVALID;\n+    }\n+\n+    // The attestation is the first valid attestation received for the participating validator for\n+    // the slot, attestation.data.slot.\n+    if (receivedValidAttestations.contains(getValidatorAndSlot(attestation))) {\n+      return INVALID;\n+    }\n+    return VALID;\n+  }\n+\n+  private ValidationResult singleOrAggregateAttestationChecks(final Attestation attestation) {\n+    // attestation.data.slot is within the last ATTESTATION_PROPAGATION_SLOT_RANGE slots (within a\n+    // MAXIMUM_GOSSIP_CLOCK_DISPARITY allowance) -- i.e. attestation.data.slot +\n+    // ATTESTATION_PROPAGATION_SLOT_RANGE >= current_slot >= attestation.data.slot (a client MAY\n+    // queue\n+    // future attestations for processing at the appropriate slot).\n+    final UnsignedLong currentTimeMillis = secondsToMillis(recentChainData.getStore().getTime());\n+    if (isAfterPropagationSlotRange(currentTimeMillis, attestation)) {\n+      return INVALID;\n+    }\n+    if (isBeforeMinimumBroadcastTime(attestation, currentTimeMillis) < 0) {\n+      return SAVED_FOR_FUTURE;\n+    }\n+\n+    // The block being voted for (attestation.data.beacon_block_root) passes validation.\n+    // It must pass validation to be in the store.\n+    // If it's not in the store, it may not have been processed yet so save for future.\n+    final Optional<BeaconState> maybeState =\n+        recentChainData.getBlockState(attestation.getData().getBeacon_block_root());\n+    if (maybeState.isEmpty()) {\n+      return SAVED_FOR_FUTURE;\n+    }\n+\n+    final BeaconState state = maybeState.get();\n+\n+    // The signature of attestation is valid.\n+    final IndexedAttestation indexedAttestation = get_indexed_attestation(state, attestation);\n+    if (!is_valid_indexed_attestation(state, indexedAttestation)) {\n+      return INVALID;\n+    }\n+    return VALID;\n+  }\n+\n+  private ValidatorAndSlot getValidatorAndSlot(final Attestation attestation) {\n+    return new ValidatorAndSlot(\n+        attestation.getData().getSlot(),\n+        attestation.getData().getIndex(),\n+        attestation.getAggregation_bits().streamAllSetBits().findFirst().orElseThrow());\n+  }\n+\n+  private int isBeforeMinimumBroadcastTime(\n+      final Attestation attestation, final UnsignedLong currentTimeMillis) {\n+    final UnsignedLong minimumBroadcastTimeMillis =\n+        minimumBroadcastTimeMillis(attestation.getData().getSlot());\n+    return currentTimeMillis.compareTo(minimumBroadcastTimeMillis);\n+  }\n+\n+  private boolean isAfterPropagationSlotRange(\n+      final UnsignedLong currentTimeMillis, final Attestation aggregate) {\n+    final UnsignedLong aggregateSlot = aggregate.getData().getSlot();\n+    return maximumBroadcastTimeMillis(aggregateSlot).compareTo(currentTimeMillis) < 0;\n+  }\n+\n+  private UnsignedLong secondsToMillis(final UnsignedLong seconds) {\n+    return seconds.times(MILLIS_PER_SECOND);\n+  }\n+\n+  private UnsignedLong minimumBroadcastTimeMillis(final UnsignedLong aggregateSlot) {\n+    final UnsignedLong lastAllowedTime =\n+        recentChainData\n+            .getGenesisTime()\n+            .plus(aggregateSlot.times(UnsignedLong.valueOf(SECONDS_PER_SLOT)));\n+    final UnsignedLong lastAllowedTimeMillis = secondsToMillis(lastAllowedTime);\n+    return lastAllowedTimeMillis.compareTo(MAXIMUM_GOSSIP_CLOCK_DISPARITY) >= 0\n+        ? lastAllowedTimeMillis.minus(MAXIMUM_GOSSIP_CLOCK_DISPARITY)\n+        : ZERO;\n+  }\n+\n+  private UnsignedLong maximumBroadcastTimeMillis(final UnsignedLong aggregateSlot) {\n+    final UnsignedLong lastAllowedSlot = aggregateSlot.plus(ATTESTATION_PROPAGATION_SLOT_RANGE);\n+    // The last allowed time is the end of the lastAllowedSlot.\n+    final UnsignedLong lastAllowedTime =\n+        recentChainData\n+            .getGenesisTime()\n+            .plus(lastAllowedSlot.plus(ONE).times(UnsignedLong.valueOf(SECONDS_PER_SLOT)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "26c99d852716324f6fa6ee953df3ded930f94393"}, "originalPosition": 173}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY0NzUxOA==", "bodyText": "The first check seems a bit redundant and makes the code hard to read since Unix time starts back in the 1970s", "url": "https://github.com/ConsenSys/teku/pull/1661#discussion_r414647518", "createdAt": "2020-04-24T15:04:48Z", "author": {"login": "cemozerr"}, "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/gossip/topics/validation/AttestationValidator.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.networking.eth2.gossip.topics.validation;\n+\n+import static com.google.common.primitives.UnsignedLong.ONE;\n+import static com.google.common.primitives.UnsignedLong.ZERO;\n+import static tech.pegasys.artemis.datastructures.util.AttestationUtil.get_indexed_attestation;\n+import static tech.pegasys.artemis.datastructures.util.AttestationUtil.is_valid_indexed_attestation;\n+import static tech.pegasys.artemis.networking.eth2.gossip.topics.validation.ValidationResult.INVALID;\n+import static tech.pegasys.artemis.networking.eth2.gossip.topics.validation.ValidationResult.SAVED_FOR_FUTURE;\n+import static tech.pegasys.artemis.networking.eth2.gossip.topics.validation.ValidationResult.VALID;\n+import static tech.pegasys.artemis.util.config.Constants.ATTESTATION_PROPAGATION_SLOT_RANGE;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_SLOT;\n+import static tech.pegasys.artemis.util.config.Constants.VALID_ATTESTATION_SET_SIZE;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import tech.pegasys.artemis.datastructures.operations.Attestation;\n+import tech.pegasys.artemis.datastructures.operations.IndexedAttestation;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.util.CommitteeUtil;\n+import tech.pegasys.artemis.storage.client.RecentChainData;\n+import tech.pegasys.artemis.util.collections.ConcurrentLimitedSet;\n+import tech.pegasys.artemis.util.collections.LimitStrategy;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class AttestationValidator {\n+\n+  private static final UnsignedLong MILLIS_PER_SECOND = UnsignedLong.valueOf(10000);\n+  private static final UnsignedLong MAXIMUM_GOSSIP_CLOCK_DISPARITY =\n+      UnsignedLong.valueOf(Constants.MAXIMUM_GOSSIP_CLOCK_DISPARITY);\n+\n+  private final Set<ValidatorAndSlot> receivedValidAttestations =\n+      ConcurrentLimitedSet.create(VALID_ATTESTATION_SET_SIZE, LimitStrategy.DROP_OLDEST_ELEMENT);\n+  private final RecentChainData recentChainData;\n+\n+  public AttestationValidator(final RecentChainData recentChainData) {\n+    this.recentChainData = recentChainData;\n+  }\n+\n+  public ValidationResult validate(\n+      final Attestation attestation, final UnsignedLong receivedOnSubnetId) {\n+    ValidationResult validationResult = singleAttestationChecks(attestation, receivedOnSubnetId);\n+    if (validationResult != VALID) {\n+      return validationResult;\n+    }\n+\n+    validationResult = singleOrAggregateAttestationChecks(attestation);\n+    if (validationResult != VALID) {\n+      return validationResult;\n+    }\n+\n+    return firstValidAttestationCheck(attestation);\n+  }\n+\n+  private ValidationResult firstValidAttestationCheck(final Attestation attestation) {\n+    // The attestation is the first valid attestation received for the participating validator for\n+    // the slot, attestation.data.slot.\n+    if (!receivedValidAttestations.add(getValidatorAndSlot(attestation))) {\n+      return INVALID;\n+    }\n+    return VALID;\n+  }\n+\n+  private ValidationResult singleAttestationChecks(\n+      final Attestation attestation, final UnsignedLong receivedOnSubnetId) {\n+    // The attestation's committee index (attestation.data.index) is for the correct subnet.\n+    if (!CommitteeUtil.getSubnetId(attestation).equals(receivedOnSubnetId)) {\n+      return INVALID;\n+    }\n+\n+    // The attestation is unaggregated -- that is, it has exactly one participating validator\n+    // (len([bit for bit in attestation.aggregation_bits if bit == 0b1]) == 1).\n+    if (attestation.getAggregation_bits().countSetBits() != 1) {\n+      return INVALID;\n+    }\n+\n+    // The attestation is the first valid attestation received for the participating validator for\n+    // the slot, attestation.data.slot.\n+    if (receivedValidAttestations.contains(getValidatorAndSlot(attestation))) {\n+      return INVALID;\n+    }\n+    return VALID;\n+  }\n+\n+  private ValidationResult singleOrAggregateAttestationChecks(final Attestation attestation) {\n+    // attestation.data.slot is within the last ATTESTATION_PROPAGATION_SLOT_RANGE slots (within a\n+    // MAXIMUM_GOSSIP_CLOCK_DISPARITY allowance) -- i.e. attestation.data.slot +\n+    // ATTESTATION_PROPAGATION_SLOT_RANGE >= current_slot >= attestation.data.slot (a client MAY\n+    // queue\n+    // future attestations for processing at the appropriate slot).\n+    final UnsignedLong currentTimeMillis = secondsToMillis(recentChainData.getStore().getTime());\n+    if (isAfterPropagationSlotRange(currentTimeMillis, attestation)) {\n+      return INVALID;\n+    }\n+    if (isBeforeMinimumBroadcastTime(attestation, currentTimeMillis) < 0) {\n+      return SAVED_FOR_FUTURE;\n+    }\n+\n+    // The block being voted for (attestation.data.beacon_block_root) passes validation.\n+    // It must pass validation to be in the store.\n+    // If it's not in the store, it may not have been processed yet so save for future.\n+    final Optional<BeaconState> maybeState =\n+        recentChainData.getBlockState(attestation.getData().getBeacon_block_root());\n+    if (maybeState.isEmpty()) {\n+      return SAVED_FOR_FUTURE;\n+    }\n+\n+    final BeaconState state = maybeState.get();\n+\n+    // The signature of attestation is valid.\n+    final IndexedAttestation indexedAttestation = get_indexed_attestation(state, attestation);\n+    if (!is_valid_indexed_attestation(state, indexedAttestation)) {\n+      return INVALID;\n+    }\n+    return VALID;\n+  }\n+\n+  private ValidatorAndSlot getValidatorAndSlot(final Attestation attestation) {\n+    return new ValidatorAndSlot(\n+        attestation.getData().getSlot(),\n+        attestation.getData().getIndex(),\n+        attestation.getAggregation_bits().streamAllSetBits().findFirst().orElseThrow());\n+  }\n+\n+  private int isBeforeMinimumBroadcastTime(\n+      final Attestation attestation, final UnsignedLong currentTimeMillis) {\n+    final UnsignedLong minimumBroadcastTimeMillis =\n+        minimumBroadcastTimeMillis(attestation.getData().getSlot());\n+    return currentTimeMillis.compareTo(minimumBroadcastTimeMillis);\n+  }\n+\n+  private boolean isAfterPropagationSlotRange(\n+      final UnsignedLong currentTimeMillis, final Attestation aggregate) {\n+    final UnsignedLong aggregateSlot = aggregate.getData().getSlot();\n+    return maximumBroadcastTimeMillis(aggregateSlot).compareTo(currentTimeMillis) < 0;\n+  }\n+\n+  private UnsignedLong secondsToMillis(final UnsignedLong seconds) {\n+    return seconds.times(MILLIS_PER_SECOND);\n+  }\n+\n+  private UnsignedLong minimumBroadcastTimeMillis(final UnsignedLong aggregateSlot) {\n+    final UnsignedLong lastAllowedTime =\n+        recentChainData\n+            .getGenesisTime()\n+            .plus(aggregateSlot.times(UnsignedLong.valueOf(SECONDS_PER_SLOT)));\n+    final UnsignedLong lastAllowedTimeMillis = secondsToMillis(lastAllowedTime);\n+    return lastAllowedTimeMillis.compareTo(MAXIMUM_GOSSIP_CLOCK_DISPARITY) >= 0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "26c99d852716324f6fa6ee953df3ded930f94393"}, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY1MzQwNg==", "bodyText": "nit: it's better to have these two functions match each other's style\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (isAfterPropagationSlotRange(currentTimeMillis, attestation)) {\n          \n          \n            \n                  return INVALID;\n          \n          \n            \n                }\n          \n          \n            \n                if (isBeforeMinimumBroadcastTime(attestation, currentTimeMillis) < 0) {\n          \n          \n            \n                if (isAfterPropagationSlotRange(currentTimeMillis, attestation)) {\n          \n          \n            \n                  return INVALID;\n          \n          \n            \n                }\n          \n          \n            \n                if (isBeforeMinimumBroadcastTime(attestation, currentTimeMillis)) {", "url": "https://github.com/ConsenSys/teku/pull/1661#discussion_r414653406", "createdAt": "2020-04-24T15:12:46Z", "author": {"login": "cemozerr"}, "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/gossip/topics/validation/AttestationValidator.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.networking.eth2.gossip.topics.validation;\n+\n+import static com.google.common.primitives.UnsignedLong.ONE;\n+import static com.google.common.primitives.UnsignedLong.ZERO;\n+import static tech.pegasys.artemis.datastructures.util.AttestationUtil.get_indexed_attestation;\n+import static tech.pegasys.artemis.datastructures.util.AttestationUtil.is_valid_indexed_attestation;\n+import static tech.pegasys.artemis.networking.eth2.gossip.topics.validation.ValidationResult.INVALID;\n+import static tech.pegasys.artemis.networking.eth2.gossip.topics.validation.ValidationResult.SAVED_FOR_FUTURE;\n+import static tech.pegasys.artemis.networking.eth2.gossip.topics.validation.ValidationResult.VALID;\n+import static tech.pegasys.artemis.util.config.Constants.ATTESTATION_PROPAGATION_SLOT_RANGE;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_SLOT;\n+import static tech.pegasys.artemis.util.config.Constants.VALID_ATTESTATION_SET_SIZE;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import tech.pegasys.artemis.datastructures.operations.Attestation;\n+import tech.pegasys.artemis.datastructures.operations.IndexedAttestation;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.util.CommitteeUtil;\n+import tech.pegasys.artemis.storage.client.RecentChainData;\n+import tech.pegasys.artemis.util.collections.ConcurrentLimitedSet;\n+import tech.pegasys.artemis.util.collections.LimitStrategy;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class AttestationValidator {\n+\n+  private static final UnsignedLong MILLIS_PER_SECOND = UnsignedLong.valueOf(10000);\n+  private static final UnsignedLong MAXIMUM_GOSSIP_CLOCK_DISPARITY =\n+      UnsignedLong.valueOf(Constants.MAXIMUM_GOSSIP_CLOCK_DISPARITY);\n+\n+  private final Set<ValidatorAndSlot> receivedValidAttestations =\n+      ConcurrentLimitedSet.create(VALID_ATTESTATION_SET_SIZE, LimitStrategy.DROP_OLDEST_ELEMENT);\n+  private final RecentChainData recentChainData;\n+\n+  public AttestationValidator(final RecentChainData recentChainData) {\n+    this.recentChainData = recentChainData;\n+  }\n+\n+  public ValidationResult validate(\n+      final Attestation attestation, final UnsignedLong receivedOnSubnetId) {\n+    ValidationResult validationResult = singleAttestationChecks(attestation, receivedOnSubnetId);\n+    if (validationResult != VALID) {\n+      return validationResult;\n+    }\n+\n+    validationResult = singleOrAggregateAttestationChecks(attestation);\n+    if (validationResult != VALID) {\n+      return validationResult;\n+    }\n+\n+    return firstValidAttestationCheck(attestation);\n+  }\n+\n+  private ValidationResult firstValidAttestationCheck(final Attestation attestation) {\n+    // The attestation is the first valid attestation received for the participating validator for\n+    // the slot, attestation.data.slot.\n+    if (!receivedValidAttestations.add(getValidatorAndSlot(attestation))) {\n+      return INVALID;\n+    }\n+    return VALID;\n+  }\n+\n+  private ValidationResult singleAttestationChecks(\n+      final Attestation attestation, final UnsignedLong receivedOnSubnetId) {\n+    // The attestation's committee index (attestation.data.index) is for the correct subnet.\n+    if (!CommitteeUtil.getSubnetId(attestation).equals(receivedOnSubnetId)) {\n+      return INVALID;\n+    }\n+\n+    // The attestation is unaggregated -- that is, it has exactly one participating validator\n+    // (len([bit for bit in attestation.aggregation_bits if bit == 0b1]) == 1).\n+    if (attestation.getAggregation_bits().countSetBits() != 1) {\n+      return INVALID;\n+    }\n+\n+    // The attestation is the first valid attestation received for the participating validator for\n+    // the slot, attestation.data.slot.\n+    if (receivedValidAttestations.contains(getValidatorAndSlot(attestation))) {\n+      return INVALID;\n+    }\n+    return VALID;\n+  }\n+\n+  private ValidationResult singleOrAggregateAttestationChecks(final Attestation attestation) {\n+    // attestation.data.slot is within the last ATTESTATION_PROPAGATION_SLOT_RANGE slots (within a\n+    // MAXIMUM_GOSSIP_CLOCK_DISPARITY allowance) -- i.e. attestation.data.slot +\n+    // ATTESTATION_PROPAGATION_SLOT_RANGE >= current_slot >= attestation.data.slot (a client MAY\n+    // queue\n+    // future attestations for processing at the appropriate slot).\n+    final UnsignedLong currentTimeMillis = secondsToMillis(recentChainData.getStore().getTime());\n+    if (isAfterPropagationSlotRange(currentTimeMillis, attestation)) {\n+      return INVALID;\n+    }\n+    if (isBeforeMinimumBroadcastTime(attestation, currentTimeMillis) < 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "26c99d852716324f6fa6ee953df3ded930f94393"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDY1Njg3Ng==", "bodyText": "nit: this might be a little bit more appropriate\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private ValidationResult firstValidAttestationCheck(final Attestation attestation) {\n          \n          \n            \n              private ValidationResult addAndCheckFirstValidAttestation(final Attestation attestation) {", "url": "https://github.com/ConsenSys/teku/pull/1661#discussion_r414656876", "createdAt": "2020-04-24T15:17:35Z", "author": {"login": "cemozerr"}, "path": "networking/eth2/src/main/java/tech/pegasys/artemis/networking/eth2/gossip/topics/validation/AttestationValidator.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Copyright 2020 ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ */\n+\n+package tech.pegasys.artemis.networking.eth2.gossip.topics.validation;\n+\n+import static com.google.common.primitives.UnsignedLong.ONE;\n+import static com.google.common.primitives.UnsignedLong.ZERO;\n+import static tech.pegasys.artemis.datastructures.util.AttestationUtil.get_indexed_attestation;\n+import static tech.pegasys.artemis.datastructures.util.AttestationUtil.is_valid_indexed_attestation;\n+import static tech.pegasys.artemis.networking.eth2.gossip.topics.validation.ValidationResult.INVALID;\n+import static tech.pegasys.artemis.networking.eth2.gossip.topics.validation.ValidationResult.SAVED_FOR_FUTURE;\n+import static tech.pegasys.artemis.networking.eth2.gossip.topics.validation.ValidationResult.VALID;\n+import static tech.pegasys.artemis.util.config.Constants.ATTESTATION_PROPAGATION_SLOT_RANGE;\n+import static tech.pegasys.artemis.util.config.Constants.SECONDS_PER_SLOT;\n+import static tech.pegasys.artemis.util.config.Constants.VALID_ATTESTATION_SET_SIZE;\n+\n+import com.google.common.primitives.UnsignedLong;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import tech.pegasys.artemis.datastructures.operations.Attestation;\n+import tech.pegasys.artemis.datastructures.operations.IndexedAttestation;\n+import tech.pegasys.artemis.datastructures.state.BeaconState;\n+import tech.pegasys.artemis.datastructures.util.CommitteeUtil;\n+import tech.pegasys.artemis.storage.client.RecentChainData;\n+import tech.pegasys.artemis.util.collections.ConcurrentLimitedSet;\n+import tech.pegasys.artemis.util.collections.LimitStrategy;\n+import tech.pegasys.artemis.util.config.Constants;\n+\n+public class AttestationValidator {\n+\n+  private static final UnsignedLong MILLIS_PER_SECOND = UnsignedLong.valueOf(10000);\n+  private static final UnsignedLong MAXIMUM_GOSSIP_CLOCK_DISPARITY =\n+      UnsignedLong.valueOf(Constants.MAXIMUM_GOSSIP_CLOCK_DISPARITY);\n+\n+  private final Set<ValidatorAndSlot> receivedValidAttestations =\n+      ConcurrentLimitedSet.create(VALID_ATTESTATION_SET_SIZE, LimitStrategy.DROP_OLDEST_ELEMENT);\n+  private final RecentChainData recentChainData;\n+\n+  public AttestationValidator(final RecentChainData recentChainData) {\n+    this.recentChainData = recentChainData;\n+  }\n+\n+  public ValidationResult validate(\n+      final Attestation attestation, final UnsignedLong receivedOnSubnetId) {\n+    ValidationResult validationResult = singleAttestationChecks(attestation, receivedOnSubnetId);\n+    if (validationResult != VALID) {\n+      return validationResult;\n+    }\n+\n+    validationResult = singleOrAggregateAttestationChecks(attestation);\n+    if (validationResult != VALID) {\n+      return validationResult;\n+    }\n+\n+    return firstValidAttestationCheck(attestation);\n+  }\n+\n+  private ValidationResult firstValidAttestationCheck(final Attestation attestation) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "26c99d852716324f6fa6ee953df3ded930f94393"}, "originalPosition": 69}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "49508e3c6a63ffc01466f1b6a1671206e05182e9", "author": {"user": {"login": "ajsutton", "name": "Adrian Sutton"}}, "url": "https://github.com/ConsenSys/teku/commit/49508e3c6a63ffc01466f1b6a1671206e05182e9", "committedDate": "2020-04-26T20:33:32Z", "message": "Merge branch 'master' of github.com:PegaSysEng/teku into validate-attestations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3886bd23501adf01030d8eee127190bfc526d3d4", "author": {"user": {"login": "ajsutton", "name": "Adrian Sutton"}}, "url": "https://github.com/ConsenSys/teku/commit/3886bd23501adf01030d8eee127190bfc526d3d4", "committedDate": "2020-04-26T20:33:59Z", "message": "Fix merge error."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7b6b64592857e9fe0d2e6a378599784657e93efd", "author": {"user": {"login": "ajsutton", "name": "Adrian Sutton"}}, "url": "https://github.com/ConsenSys/teku/commit/7b6b64592857e9fe0d2e6a378599784657e93efd", "committedDate": "2020-04-26T20:35:25Z", "message": "Fix mixed renames of aggregate back to attestation."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8be2acf8823d53746bef6a8fcc181afa2167dc50", "author": {"user": {"login": "ajsutton", "name": "Adrian Sutton"}}, "url": "https://github.com/ConsenSys/teku/commit/8be2acf8823d53746bef6a8fcc181afa2167dc50", "committedDate": "2020-04-26T20:37:14Z", "message": "Clarify comment."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "07f82a2a9720292c6a30ca9a1cca0ae68b7539ee", "author": {"user": {"login": "ajsutton", "name": "Adrian Sutton"}}, "url": "https://github.com/ConsenSys/teku/commit/07f82a2a9720292c6a30ca9a1cca0ae68b7539ee", "committedDate": "2020-04-26T20:52:02Z", "message": "Review feedback."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "02c9e46a3f42c4cedb655479e72ab889635d9da4", "author": {"user": {"login": "ajsutton", "name": "Adrian Sutton"}}, "url": "https://github.com/ConsenSys/teku/commit/02c9e46a3f42c4cedb655479e72ab889635d9da4", "committedDate": "2020-04-26T20:53:16Z", "message": "Merge branch 'master' of github.com:PegaSysEng/teku into validate-attestations"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4113, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}