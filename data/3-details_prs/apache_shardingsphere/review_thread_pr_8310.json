{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI2MjA3OTg4", "number": 8310, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQwNTowNTowMVrOE9enlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yOFQxNDozODoyNlrOE-Rarw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyOTAwMjQ1OnYy", "diffSide": "RIGHT", "path": "shardingsphere-features/shardingsphere-sharding/shardingsphere-sharding-route/src/main/java/org/apache/shardingsphere/sharding/route/engine/validator/dml/impl/ShardingSelectStatementValidator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQwNTowNTowMVrOH6L-kg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQwMDoyNDozOVrOH7omPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDc3NTY5OA==", "bodyText": "Please remove this extra blank line. \ud83d\ude09", "url": "https://github.com/apache/shardingsphere/pull/8310#discussion_r530775698", "createdAt": "2020-11-26T05:05:01Z", "author": {"login": "strongduanmu"}, "path": "shardingsphere-features/shardingsphere-sharding/shardingsphere-sharding-route/src/main/java/org/apache/shardingsphere/sharding/route/engine/validator/dml/impl/ShardingSelectStatementValidator.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.shardingsphere.sharding.route.engine.validator.dml.impl;\n+\n+import org.apache.shardingsphere.infra.binder.statement.SQLStatementContext;\n+import org.apache.shardingsphere.infra.binder.statement.dml.SelectStatementContext;\n+import org.apache.shardingsphere.infra.hint.HintManager;\n+import org.apache.shardingsphere.infra.metadata.schema.ShardingSphereSchema;\n+import org.apache.shardingsphere.infra.route.context.RouteContext;\n+import org.apache.shardingsphere.sharding.api.config.strategy.sharding.HintShardingStrategyConfiguration;\n+import org.apache.shardingsphere.sharding.route.engine.condition.ShardingCondition;\n+import org.apache.shardingsphere.sharding.route.engine.condition.ShardingConditions;\n+import org.apache.shardingsphere.sharding.route.engine.condition.engine.ShardingConditionEngine;\n+import org.apache.shardingsphere.sharding.route.engine.condition.engine.impl.WhereClauseShardingConditionEngine;\n+import org.apache.shardingsphere.sharding.route.engine.condition.value.ListShardingConditionValue;\n+import org.apache.shardingsphere.sharding.route.engine.condition.value.RangeShardingConditionValue;\n+import org.apache.shardingsphere.sharding.route.engine.condition.value.ShardingConditionValue;\n+import org.apache.shardingsphere.sharding.route.engine.validator.dml.ShardingDMLStatementValidator;\n+import org.apache.shardingsphere.sharding.rule.BindingTableRule;\n+import org.apache.shardingsphere.sharding.rule.ShardingRule;\n+import org.apache.shardingsphere.sharding.rule.TableRule;\n+import org.apache.shardingsphere.sql.parser.sql.common.statement.dml.DMLStatement;\n+import org.apache.shardingsphere.sql.parser.sql.common.statement.dml.SelectStatement;\n+import org.apache.shardingsphere.sql.parser.sql.common.util.SafeNumberOperationUtils;\n+\n+import com.google.common.base.Preconditions;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * Sharding select statement validator.\n+ */\n+public final class ShardingSelectStatementValidator extends ShardingDMLStatementValidator<SelectStatement> {\n+    \n+    @Override\n+    public void preValidate(final ShardingRule shardingRule, final SQLStatementContext<SelectStatement> sqlStatementContext, \n+                            final List<Object> parameters, final ShardingSphereSchema schema) {\n+        if (isNeedMergeShardingValues(sqlStatementContext, shardingRule)) {\n+            checkSubqueryShardingValues(shardingRule, sqlStatementContext, parameters, schema);\n+        }\n+    }\n+    \n+    private boolean isNeedMergeShardingValues(final SQLStatementContext<?> sqlStatementContext, final ShardingRule rule) {\n+        boolean selectContainsSubquery = sqlStatementContext instanceof SelectStatementContext && ((SelectStatementContext) sqlStatementContext).isContainsSubquery();\n+        return selectContainsSubquery && !rule.getShardingLogicTableNames(sqlStatementContext.getTablesContext().getTableNames()).isEmpty();\n+    }\n+    \n+    private void checkSubqueryShardingValues(final ShardingRule shardingRule, final SQLStatementContext<SelectStatement> sqlStatementContext,\n+        final List<Object> parameters, final ShardingSphereSchema schema) {\n+        for (String each : sqlStatementContext.getTablesContext().getTableNames()) {\n+            Optional<TableRule> tableRule = shardingRule.findTableRule(each);\n+            if (tableRule.isPresent() && isRoutingByHint(shardingRule, tableRule.get())\n+                && !HintManager.getDatabaseShardingValues(each).isEmpty() && !HintManager.getTableShardingValues(each).isEmpty()) {\n+                return;\n+            }\n+        }\n+        ShardingConditions shardingConditions = createShardingConditions(sqlStatementContext, parameters, schema, shardingRule);\n+        if (shardingConditions.getConditions().size() > 1) {\n+            Preconditions.checkState(isSameShardingCondition(shardingRule, shardingConditions), \"Sharding value must same with subquery.\");\n+        }\n+    }\n+    \n+    private boolean isRoutingByHint(final ShardingRule shardingRule, final TableRule tableRule) {\n+        return shardingRule.getDatabaseShardingStrategyConfiguration(tableRule) instanceof HintShardingStrategyConfiguration\n+            && shardingRule.getTableShardingStrategyConfiguration(tableRule) instanceof HintShardingStrategyConfiguration;\n+    }\n+    \n+    private boolean isSameShardingCondition(final ShardingRule shardingRule, final ShardingConditions shardingConditions) {\n+        ShardingCondition example = shardingConditions.getConditions().remove(shardingConditions.getConditions().size() - 1);\n+        for (ShardingCondition each : shardingConditions.getConditions()) {\n+            if (!isSameShardingCondition(shardingRule, example, each)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+    \n+    private boolean isSameShardingCondition(final ShardingRule shardingRule, final ShardingCondition shardingCondition1, final ShardingCondition shardingCondition2) {\n+        if (shardingCondition1.getValues().size() != shardingCondition2.getValues().size()) {\n+            return false;\n+        }\n+        for (int i = 0; i < shardingCondition1.getValues().size(); i++) {\n+            ShardingConditionValue shardingConditionValue1 = shardingCondition1.getValues().get(i);\n+            ShardingConditionValue shardingConditionValue2 = shardingCondition2.getValues().get(i);\n+            if (!isSameShardingConditionValue(shardingRule, shardingConditionValue1, shardingConditionValue2)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+    \n+    private boolean isSameShardingConditionValue(final ShardingRule shardingRule, final ShardingConditionValue shardingConditionValue1, final ShardingConditionValue shardingConditionValue2) {\n+        return isSameLogicTable(shardingRule, shardingConditionValue1, shardingConditionValue2) && shardingConditionValue1.getColumnName().equals(shardingConditionValue2.getColumnName());\n+    }\n+    \n+    private boolean isSameLogicTable(final ShardingRule shardingRule, final ShardingConditionValue shardingValue1, final ShardingConditionValue shardingValue2) {\n+        return shardingValue1.getTableName().equals(shardingValue2.getTableName()) || isBindingTable(shardingRule, shardingValue1, shardingValue2);\n+    }\n+    \n+    private boolean isBindingTable(final ShardingRule shardingRule, final ShardingConditionValue shardingValue1, final ShardingConditionValue shardingValue2) {\n+        Optional<BindingTableRule> bindingRule = shardingRule.findBindingTableRule(shardingValue1.getTableName());\n+        return bindingRule.isPresent() && bindingRule.get().hasLogicTable(shardingValue2.getTableName());\n+    }\n+    \n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    private boolean isSameValue(final ShardingConditionValue shardingConditionValue1, final ShardingConditionValue shardingConditionValue2) {\n+        if (shardingConditionValue1 instanceof ListShardingConditionValue && shardingConditionValue2 instanceof ListShardingConditionValue) {\n+            return SafeNumberOperationUtils.safeCollectionEquals(\n+                ((ListShardingConditionValue) shardingConditionValue1).getValues(), ((ListShardingConditionValue) shardingConditionValue2).getValues());\n+        } else if (shardingConditionValue1 instanceof RangeShardingConditionValue && shardingConditionValue2 instanceof RangeShardingConditionValue) {\n+            return SafeNumberOperationUtils.safeRangeEquals(\n+                ((RangeShardingConditionValue) shardingConditionValue1).getValueRange(), ((RangeShardingConditionValue) shardingConditionValue2).getValueRange());\n+        }\n+        return false;\n+    }\n+    \n+    private ShardingConditions createShardingConditions(final SQLStatementContext<SelectStatement> sqlStatementContext,\n+        final List<Object> parameters, final ShardingSphereSchema schema, final ShardingRule rule) {\n+        List<ShardingCondition> shardingConditions;\n+        if (sqlStatementContext.getSqlStatement() instanceof DMLStatement) {\n+            ShardingConditionEngine shardingConditionEngine = new WhereClauseShardingConditionEngine(rule, schema);\n+            shardingConditions = shardingConditionEngine.createShardingConditions(sqlStatementContext, parameters);\n+        } else {\n+            shardingConditions = Collections.emptyList();\n+        }\n+        return new ShardingConditions(shardingConditions);\n+    }\n+    \n+    @Override\n+    public void postValidate(final SelectStatement sqlStatement, final RouteContext routeContext) {\n+    }\n+    ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0d71dee29ebe19dd7b56177e96fcc3d326c4290"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjI5MzE4MQ==", "bodyText": "OK", "url": "https://github.com/apache/shardingsphere/pull/8310#discussion_r532293181", "createdAt": "2020-11-30T00:24:39Z", "author": {"login": "wgy8283335"}, "path": "shardingsphere-features/shardingsphere-sharding/shardingsphere-sharding-route/src/main/java/org/apache/shardingsphere/sharding/route/engine/validator/dml/impl/ShardingSelectStatementValidator.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.shardingsphere.sharding.route.engine.validator.dml.impl;\n+\n+import org.apache.shardingsphere.infra.binder.statement.SQLStatementContext;\n+import org.apache.shardingsphere.infra.binder.statement.dml.SelectStatementContext;\n+import org.apache.shardingsphere.infra.hint.HintManager;\n+import org.apache.shardingsphere.infra.metadata.schema.ShardingSphereSchema;\n+import org.apache.shardingsphere.infra.route.context.RouteContext;\n+import org.apache.shardingsphere.sharding.api.config.strategy.sharding.HintShardingStrategyConfiguration;\n+import org.apache.shardingsphere.sharding.route.engine.condition.ShardingCondition;\n+import org.apache.shardingsphere.sharding.route.engine.condition.ShardingConditions;\n+import org.apache.shardingsphere.sharding.route.engine.condition.engine.ShardingConditionEngine;\n+import org.apache.shardingsphere.sharding.route.engine.condition.engine.impl.WhereClauseShardingConditionEngine;\n+import org.apache.shardingsphere.sharding.route.engine.condition.value.ListShardingConditionValue;\n+import org.apache.shardingsphere.sharding.route.engine.condition.value.RangeShardingConditionValue;\n+import org.apache.shardingsphere.sharding.route.engine.condition.value.ShardingConditionValue;\n+import org.apache.shardingsphere.sharding.route.engine.validator.dml.ShardingDMLStatementValidator;\n+import org.apache.shardingsphere.sharding.rule.BindingTableRule;\n+import org.apache.shardingsphere.sharding.rule.ShardingRule;\n+import org.apache.shardingsphere.sharding.rule.TableRule;\n+import org.apache.shardingsphere.sql.parser.sql.common.statement.dml.DMLStatement;\n+import org.apache.shardingsphere.sql.parser.sql.common.statement.dml.SelectStatement;\n+import org.apache.shardingsphere.sql.parser.sql.common.util.SafeNumberOperationUtils;\n+\n+import com.google.common.base.Preconditions;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+\n+/**\n+ * Sharding select statement validator.\n+ */\n+public final class ShardingSelectStatementValidator extends ShardingDMLStatementValidator<SelectStatement> {\n+    \n+    @Override\n+    public void preValidate(final ShardingRule shardingRule, final SQLStatementContext<SelectStatement> sqlStatementContext, \n+                            final List<Object> parameters, final ShardingSphereSchema schema) {\n+        if (isNeedMergeShardingValues(sqlStatementContext, shardingRule)) {\n+            checkSubqueryShardingValues(shardingRule, sqlStatementContext, parameters, schema);\n+        }\n+    }\n+    \n+    private boolean isNeedMergeShardingValues(final SQLStatementContext<?> sqlStatementContext, final ShardingRule rule) {\n+        boolean selectContainsSubquery = sqlStatementContext instanceof SelectStatementContext && ((SelectStatementContext) sqlStatementContext).isContainsSubquery();\n+        return selectContainsSubquery && !rule.getShardingLogicTableNames(sqlStatementContext.getTablesContext().getTableNames()).isEmpty();\n+    }\n+    \n+    private void checkSubqueryShardingValues(final ShardingRule shardingRule, final SQLStatementContext<SelectStatement> sqlStatementContext,\n+        final List<Object> parameters, final ShardingSphereSchema schema) {\n+        for (String each : sqlStatementContext.getTablesContext().getTableNames()) {\n+            Optional<TableRule> tableRule = shardingRule.findTableRule(each);\n+            if (tableRule.isPresent() && isRoutingByHint(shardingRule, tableRule.get())\n+                && !HintManager.getDatabaseShardingValues(each).isEmpty() && !HintManager.getTableShardingValues(each).isEmpty()) {\n+                return;\n+            }\n+        }\n+        ShardingConditions shardingConditions = createShardingConditions(sqlStatementContext, parameters, schema, shardingRule);\n+        if (shardingConditions.getConditions().size() > 1) {\n+            Preconditions.checkState(isSameShardingCondition(shardingRule, shardingConditions), \"Sharding value must same with subquery.\");\n+        }\n+    }\n+    \n+    private boolean isRoutingByHint(final ShardingRule shardingRule, final TableRule tableRule) {\n+        return shardingRule.getDatabaseShardingStrategyConfiguration(tableRule) instanceof HintShardingStrategyConfiguration\n+            && shardingRule.getTableShardingStrategyConfiguration(tableRule) instanceof HintShardingStrategyConfiguration;\n+    }\n+    \n+    private boolean isSameShardingCondition(final ShardingRule shardingRule, final ShardingConditions shardingConditions) {\n+        ShardingCondition example = shardingConditions.getConditions().remove(shardingConditions.getConditions().size() - 1);\n+        for (ShardingCondition each : shardingConditions.getConditions()) {\n+            if (!isSameShardingCondition(shardingRule, example, each)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+    \n+    private boolean isSameShardingCondition(final ShardingRule shardingRule, final ShardingCondition shardingCondition1, final ShardingCondition shardingCondition2) {\n+        if (shardingCondition1.getValues().size() != shardingCondition2.getValues().size()) {\n+            return false;\n+        }\n+        for (int i = 0; i < shardingCondition1.getValues().size(); i++) {\n+            ShardingConditionValue shardingConditionValue1 = shardingCondition1.getValues().get(i);\n+            ShardingConditionValue shardingConditionValue2 = shardingCondition2.getValues().get(i);\n+            if (!isSameShardingConditionValue(shardingRule, shardingConditionValue1, shardingConditionValue2)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+    \n+    private boolean isSameShardingConditionValue(final ShardingRule shardingRule, final ShardingConditionValue shardingConditionValue1, final ShardingConditionValue shardingConditionValue2) {\n+        return isSameLogicTable(shardingRule, shardingConditionValue1, shardingConditionValue2) && shardingConditionValue1.getColumnName().equals(shardingConditionValue2.getColumnName());\n+    }\n+    \n+    private boolean isSameLogicTable(final ShardingRule shardingRule, final ShardingConditionValue shardingValue1, final ShardingConditionValue shardingValue2) {\n+        return shardingValue1.getTableName().equals(shardingValue2.getTableName()) || isBindingTable(shardingRule, shardingValue1, shardingValue2);\n+    }\n+    \n+    private boolean isBindingTable(final ShardingRule shardingRule, final ShardingConditionValue shardingValue1, final ShardingConditionValue shardingValue2) {\n+        Optional<BindingTableRule> bindingRule = shardingRule.findBindingTableRule(shardingValue1.getTableName());\n+        return bindingRule.isPresent() && bindingRule.get().hasLogicTable(shardingValue2.getTableName());\n+    }\n+    \n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    private boolean isSameValue(final ShardingConditionValue shardingConditionValue1, final ShardingConditionValue shardingConditionValue2) {\n+        if (shardingConditionValue1 instanceof ListShardingConditionValue && shardingConditionValue2 instanceof ListShardingConditionValue) {\n+            return SafeNumberOperationUtils.safeCollectionEquals(\n+                ((ListShardingConditionValue) shardingConditionValue1).getValues(), ((ListShardingConditionValue) shardingConditionValue2).getValues());\n+        } else if (shardingConditionValue1 instanceof RangeShardingConditionValue && shardingConditionValue2 instanceof RangeShardingConditionValue) {\n+            return SafeNumberOperationUtils.safeRangeEquals(\n+                ((RangeShardingConditionValue) shardingConditionValue1).getValueRange(), ((RangeShardingConditionValue) shardingConditionValue2).getValueRange());\n+        }\n+        return false;\n+    }\n+    \n+    private ShardingConditions createShardingConditions(final SQLStatementContext<SelectStatement> sqlStatementContext,\n+        final List<Object> parameters, final ShardingSphereSchema schema, final ShardingRule rule) {\n+        List<ShardingCondition> shardingConditions;\n+        if (sqlStatementContext.getSqlStatement() instanceof DMLStatement) {\n+            ShardingConditionEngine shardingConditionEngine = new WhereClauseShardingConditionEngine(rule, schema);\n+            shardingConditions = shardingConditionEngine.createShardingConditions(sqlStatementContext, parameters);\n+        } else {\n+            shardingConditions = Collections.emptyList();\n+        }\n+        return new ShardingConditions(shardingConditions);\n+    }\n+    \n+    @Override\n+    public void postValidate(final SelectStatement sqlStatement, final RouteContext routeContext) {\n+    }\n+    ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDc3NTY5OA=="}, "originalCommit": {"oid": "e0d71dee29ebe19dd7b56177e96fcc3d326c4290"}, "originalPosition": 149}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNzMxMTY3OnYy", "diffSide": "RIGHT", "path": "shardingsphere-features/shardingsphere-sharding/shardingsphere-sharding-route/src/main/java/org/apache/shardingsphere/sharding/route/engine/validator/dml/impl/ShardingInsertStatementValidator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yOFQxNDoyMTozMlrOH7ZeqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQwMDo0ODozNVrOH7o0ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjA0NTQ4MQ==", "bodyText": "The checkSubqueryShardingValues method is duplicated with the method in ShardingSelectStatementValidator class, and it might be better to extract it into ShardingDMLStatementValidator class.", "url": "https://github.com/apache/shardingsphere/pull/8310#discussion_r532045481", "createdAt": "2020-11-28T14:21:32Z", "author": {"login": "strongduanmu"}, "path": "shardingsphere-features/shardingsphere-sharding/shardingsphere-sharding-route/src/main/java/org/apache/shardingsphere/sharding/route/engine/validator/dml/impl/ShardingInsertStatementValidator.java", "diffHunk": "@@ -84,6 +103,94 @@ private boolean isContainsKeyGenerateColumn(final ShardingRule shardingRule, fin\n     private boolean isAllSameTables(final Collection<String> tableNames) {\n         return 1 == tableNames.stream().distinct().count();\n     }\n+\n+    private void checkSubqueryShardingValues(final ShardingRule shardingRule, final SQLStatementContext<InsertStatement> sqlStatementContext,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0d71dee29ebe19dd7b56177e96fcc3d326c4290"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjI5Njg2Mg==", "bodyText": "OK", "url": "https://github.com/apache/shardingsphere/pull/8310#discussion_r532296862", "createdAt": "2020-11-30T00:48:35Z", "author": {"login": "wgy8283335"}, "path": "shardingsphere-features/shardingsphere-sharding/shardingsphere-sharding-route/src/main/java/org/apache/shardingsphere/sharding/route/engine/validator/dml/impl/ShardingInsertStatementValidator.java", "diffHunk": "@@ -84,6 +103,94 @@ private boolean isContainsKeyGenerateColumn(final ShardingRule shardingRule, fin\n     private boolean isAllSameTables(final Collection<String> tableNames) {\n         return 1 == tableNames.stream().distinct().count();\n     }\n+\n+    private void checkSubqueryShardingValues(final ShardingRule shardingRule, final SQLStatementContext<InsertStatement> sqlStatementContext,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjA0NTQ4MQ=="}, "originalCommit": {"oid": "e0d71dee29ebe19dd7b56177e96fcc3d326c4290"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNzMxOTE5OnYy", "diffSide": "RIGHT", "path": "shardingsphere-features/shardingsphere-sharding/shardingsphere-sharding-route/src/main/java/org/apache/shardingsphere/sharding/route/engine/validator/dml/impl/ShardingInsertStatementValidator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yOFQxNDozMDo0NFrOH7ZiGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQwMDo1MjoxMFrOH7o3Og==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjA0NjM2MQ==", "bodyText": "I think this check is redundant because we've already judged insertSelectSegment.isPresent(), and we can use insertSelectStatement directly to determine whether sub-queries are included. BTW, this method can also be extracted into the ShardingDMLStatementValidator class. What do you think ?", "url": "https://github.com/apache/shardingsphere/pull/8310#discussion_r532046361", "createdAt": "2020-11-28T14:30:44Z", "author": {"login": "strongduanmu"}, "path": "shardingsphere-features/shardingsphere-sharding/shardingsphere-sharding-route/src/main/java/org/apache/shardingsphere/sharding/route/engine/validator/dml/impl/ShardingInsertStatementValidator.java", "diffHunk": "@@ -84,6 +103,94 @@ private boolean isContainsKeyGenerateColumn(final ShardingRule shardingRule, fin\n     private boolean isAllSameTables(final Collection<String> tableNames) {\n         return 1 == tableNames.stream().distinct().count();\n     }\n+\n+    private void checkSubqueryShardingValues(final ShardingRule shardingRule, final SQLStatementContext<InsertStatement> sqlStatementContext,\n+        final List<Object> parameters, final ShardingSphereSchema schema) {\n+        for (String each : sqlStatementContext.getTablesContext().getTableNames()) {\n+            Optional<TableRule> tableRule = shardingRule.findTableRule(each);\n+            if (tableRule.isPresent() && isRoutingByHint(shardingRule, tableRule.get())\n+                && !HintManager.getDatabaseShardingValues(each).isEmpty() && !HintManager.getTableShardingValues(each).isEmpty()) {\n+                return;\n+            }\n+        }\n+        ShardingConditions shardingConditions = createShardingConditions(sqlStatementContext, parameters, schema, shardingRule);\n+        if (shardingConditions.getConditions().size() > 1) {\n+            Preconditions.checkState(isSameShardingCondition(shardingRule, shardingConditions), \"Sharding value must same with subquery.\");\n+        }\n+    }\n+\n+    private boolean isRoutingByHint(final ShardingRule shardingRule, final TableRule tableRule) {\n+        return shardingRule.getDatabaseShardingStrategyConfiguration(tableRule) instanceof HintShardingStrategyConfiguration\n+            && shardingRule.getTableShardingStrategyConfiguration(tableRule) instanceof HintShardingStrategyConfiguration;\n+    }\n+\n+    private boolean isSameShardingCondition(final ShardingRule shardingRule, final ShardingConditions shardingConditions) {\n+        ShardingCondition example = shardingConditions.getConditions().remove(shardingConditions.getConditions().size() - 1);\n+        for (ShardingCondition each : shardingConditions.getConditions()) {\n+            if (!isSameShardingCondition(shardingRule, example, each)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private boolean isSameShardingCondition(final ShardingRule shardingRule, final ShardingCondition shardingCondition1, final ShardingCondition shardingCondition2) {\n+        if (shardingCondition1.getValues().size() != shardingCondition2.getValues().size()) {\n+            return false;\n+        }\n+        for (int i = 0; i < shardingCondition1.getValues().size(); i++) {\n+            ShardingConditionValue shardingConditionValue1 = shardingCondition1.getValues().get(i);\n+            ShardingConditionValue shardingConditionValue2 = shardingCondition2.getValues().get(i);\n+            if (!isSameShardingConditionValue(shardingRule, shardingConditionValue1, shardingConditionValue2)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private boolean isSameShardingConditionValue(final ShardingRule shardingRule, final ShardingConditionValue shardingConditionValue1, final ShardingConditionValue shardingConditionValue2) {\n+        return isSameLogicTable(shardingRule, shardingConditionValue1, shardingConditionValue2) && shardingConditionValue1.getColumnName().equals(shardingConditionValue2.getColumnName())\n+            && isSameValue(shardingConditionValue1, shardingConditionValue2);\n+    }\n+\n+    private boolean isSameLogicTable(final ShardingRule shardingRule, final ShardingConditionValue shardingValue1, final ShardingConditionValue shardingValue2) {\n+        return shardingValue1.getTableName().equals(shardingValue2.getTableName()) || isBindingTable(shardingRule, shardingValue1, shardingValue2);\n+    }\n+\n+    private boolean isBindingTable(final ShardingRule shardingRule, final ShardingConditionValue shardingValue1, final ShardingConditionValue shardingValue2) {\n+        Optional<BindingTableRule> bindingRule = shardingRule.findBindingTableRule(shardingValue1.getTableName());\n+        return bindingRule.isPresent() && bindingRule.get().hasLogicTable(shardingValue2.getTableName());\n+    }\n+\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    private boolean isSameValue(final ShardingConditionValue shardingConditionValue1, final ShardingConditionValue shardingConditionValue2) {\n+        if (shardingConditionValue1 instanceof ListShardingConditionValue && shardingConditionValue2 instanceof ListShardingConditionValue) {\n+            return SafeNumberOperationUtils.safeCollectionEquals(\n+                ((ListShardingConditionValue) shardingConditionValue1).getValues(), ((ListShardingConditionValue) shardingConditionValue2).getValues());\n+        } else if (shardingConditionValue1 instanceof RangeShardingConditionValue && shardingConditionValue2 instanceof RangeShardingConditionValue) {\n+            return SafeNumberOperationUtils.safeRangeEquals(\n+                ((RangeShardingConditionValue) shardingConditionValue1).getValueRange(), ((RangeShardingConditionValue) shardingConditionValue2).getValueRange());\n+        }\n+        return false;\n+    }\n+\n+    private ShardingConditions createShardingConditions(final SQLStatementContext<InsertStatement> sqlStatementContext,\n+        final List<Object> parameters, final ShardingSphereSchema schema, final ShardingRule rule) {\n+        List<ShardingCondition> shardingConditions;\n+        if (sqlStatementContext.getSqlStatement() instanceof DMLStatement) {\n+            ShardingConditionEngine shardingConditionEngine = new WhereClauseShardingConditionEngine(rule, schema);\n+            shardingConditions = shardingConditionEngine.createShardingConditions(sqlStatementContext, parameters);\n+        } else {\n+            shardingConditions = Collections.emptyList();\n+        }\n+        return new ShardingConditions(shardingConditions);\n+    }\n+\n+    private boolean isNeedMergeShardingValues(final SQLStatementContext<?> sqlStatementContext, final ShardingRule rule) {\n+        boolean insertSelectContainsSubquery = sqlStatementContext instanceof InsertStatementContext && null != ((InsertStatementContext) sqlStatementContext).getInsertSelectContext()\n+            && ((InsertStatementContext) sqlStatementContext).getInsertSelectContext().getSelectStatementContext().isContainsSubquery();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0d71dee29ebe19dd7b56177e96fcc3d326c4290"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjI5NzUzMA==", "bodyText": "I think to move this method to the ShardingDMLStatementValidator is better.", "url": "https://github.com/apache/shardingsphere/pull/8310#discussion_r532297530", "createdAt": "2020-11-30T00:52:10Z", "author": {"login": "wgy8283335"}, "path": "shardingsphere-features/shardingsphere-sharding/shardingsphere-sharding-route/src/main/java/org/apache/shardingsphere/sharding/route/engine/validator/dml/impl/ShardingInsertStatementValidator.java", "diffHunk": "@@ -84,6 +103,94 @@ private boolean isContainsKeyGenerateColumn(final ShardingRule shardingRule, fin\n     private boolean isAllSameTables(final Collection<String> tableNames) {\n         return 1 == tableNames.stream().distinct().count();\n     }\n+\n+    private void checkSubqueryShardingValues(final ShardingRule shardingRule, final SQLStatementContext<InsertStatement> sqlStatementContext,\n+        final List<Object> parameters, final ShardingSphereSchema schema) {\n+        for (String each : sqlStatementContext.getTablesContext().getTableNames()) {\n+            Optional<TableRule> tableRule = shardingRule.findTableRule(each);\n+            if (tableRule.isPresent() && isRoutingByHint(shardingRule, tableRule.get())\n+                && !HintManager.getDatabaseShardingValues(each).isEmpty() && !HintManager.getTableShardingValues(each).isEmpty()) {\n+                return;\n+            }\n+        }\n+        ShardingConditions shardingConditions = createShardingConditions(sqlStatementContext, parameters, schema, shardingRule);\n+        if (shardingConditions.getConditions().size() > 1) {\n+            Preconditions.checkState(isSameShardingCondition(shardingRule, shardingConditions), \"Sharding value must same with subquery.\");\n+        }\n+    }\n+\n+    private boolean isRoutingByHint(final ShardingRule shardingRule, final TableRule tableRule) {\n+        return shardingRule.getDatabaseShardingStrategyConfiguration(tableRule) instanceof HintShardingStrategyConfiguration\n+            && shardingRule.getTableShardingStrategyConfiguration(tableRule) instanceof HintShardingStrategyConfiguration;\n+    }\n+\n+    private boolean isSameShardingCondition(final ShardingRule shardingRule, final ShardingConditions shardingConditions) {\n+        ShardingCondition example = shardingConditions.getConditions().remove(shardingConditions.getConditions().size() - 1);\n+        for (ShardingCondition each : shardingConditions.getConditions()) {\n+            if (!isSameShardingCondition(shardingRule, example, each)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private boolean isSameShardingCondition(final ShardingRule shardingRule, final ShardingCondition shardingCondition1, final ShardingCondition shardingCondition2) {\n+        if (shardingCondition1.getValues().size() != shardingCondition2.getValues().size()) {\n+            return false;\n+        }\n+        for (int i = 0; i < shardingCondition1.getValues().size(); i++) {\n+            ShardingConditionValue shardingConditionValue1 = shardingCondition1.getValues().get(i);\n+            ShardingConditionValue shardingConditionValue2 = shardingCondition2.getValues().get(i);\n+            if (!isSameShardingConditionValue(shardingRule, shardingConditionValue1, shardingConditionValue2)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private boolean isSameShardingConditionValue(final ShardingRule shardingRule, final ShardingConditionValue shardingConditionValue1, final ShardingConditionValue shardingConditionValue2) {\n+        return isSameLogicTable(shardingRule, shardingConditionValue1, shardingConditionValue2) && shardingConditionValue1.getColumnName().equals(shardingConditionValue2.getColumnName())\n+            && isSameValue(shardingConditionValue1, shardingConditionValue2);\n+    }\n+\n+    private boolean isSameLogicTable(final ShardingRule shardingRule, final ShardingConditionValue shardingValue1, final ShardingConditionValue shardingValue2) {\n+        return shardingValue1.getTableName().equals(shardingValue2.getTableName()) || isBindingTable(shardingRule, shardingValue1, shardingValue2);\n+    }\n+\n+    private boolean isBindingTable(final ShardingRule shardingRule, final ShardingConditionValue shardingValue1, final ShardingConditionValue shardingValue2) {\n+        Optional<BindingTableRule> bindingRule = shardingRule.findBindingTableRule(shardingValue1.getTableName());\n+        return bindingRule.isPresent() && bindingRule.get().hasLogicTable(shardingValue2.getTableName());\n+    }\n+\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    private boolean isSameValue(final ShardingConditionValue shardingConditionValue1, final ShardingConditionValue shardingConditionValue2) {\n+        if (shardingConditionValue1 instanceof ListShardingConditionValue && shardingConditionValue2 instanceof ListShardingConditionValue) {\n+            return SafeNumberOperationUtils.safeCollectionEquals(\n+                ((ListShardingConditionValue) shardingConditionValue1).getValues(), ((ListShardingConditionValue) shardingConditionValue2).getValues());\n+        } else if (shardingConditionValue1 instanceof RangeShardingConditionValue && shardingConditionValue2 instanceof RangeShardingConditionValue) {\n+            return SafeNumberOperationUtils.safeRangeEquals(\n+                ((RangeShardingConditionValue) shardingConditionValue1).getValueRange(), ((RangeShardingConditionValue) shardingConditionValue2).getValueRange());\n+        }\n+        return false;\n+    }\n+\n+    private ShardingConditions createShardingConditions(final SQLStatementContext<InsertStatement> sqlStatementContext,\n+        final List<Object> parameters, final ShardingSphereSchema schema, final ShardingRule rule) {\n+        List<ShardingCondition> shardingConditions;\n+        if (sqlStatementContext.getSqlStatement() instanceof DMLStatement) {\n+            ShardingConditionEngine shardingConditionEngine = new WhereClauseShardingConditionEngine(rule, schema);\n+            shardingConditions = shardingConditionEngine.createShardingConditions(sqlStatementContext, parameters);\n+        } else {\n+            shardingConditions = Collections.emptyList();\n+        }\n+        return new ShardingConditions(shardingConditions);\n+    }\n+\n+    private boolean isNeedMergeShardingValues(final SQLStatementContext<?> sqlStatementContext, final ShardingRule rule) {\n+        boolean insertSelectContainsSubquery = sqlStatementContext instanceof InsertStatementContext && null != ((InsertStatementContext) sqlStatementContext).getInsertSelectContext()\n+            && ((InsertStatementContext) sqlStatementContext).getInsertSelectContext().getSelectStatementContext().isContainsSubquery();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjA0NjM2MQ=="}, "originalCommit": {"oid": "e0d71dee29ebe19dd7b56177e96fcc3d326c4290"}, "originalPosition": 134}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzNzMyNTI3OnYy", "diffSide": "RIGHT", "path": "shardingsphere-features/shardingsphere-sharding/shardingsphere-sharding-route/src/main/java/org/apache/shardingsphere/sharding/route/engine/validator/dml/impl/ShardingInsertStatementValidator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yOFQxNDozODoyNlrOH7Zk3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQwMDo0ODo0MVrOH7o0rA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjA0NzA3MQ==", "bodyText": "Have you forgotten to remove the checkSubqueryShardingValues method from the ShardingSQLRouter class? \ud83d\ude09", "url": "https://github.com/apache/shardingsphere/pull/8310#discussion_r532047071", "createdAt": "2020-11-28T14:38:26Z", "author": {"login": "strongduanmu"}, "path": "shardingsphere-features/shardingsphere-sharding/shardingsphere-sharding-route/src/main/java/org/apache/shardingsphere/sharding/route/engine/validator/dml/impl/ShardingInsertStatementValidator.java", "diffHunk": "@@ -62,6 +78,9 @@ public void preValidate(final ShardingRule shardingRule, final SQLStatementConte\n         if (insertSelectSegment.isPresent() && !isAllSameTables(tablesContext.getTableNames()) && !shardingRule.isAllBindingTables(tablesContext.getTableNames())) {\n             throw new ShardingSphereException(\"The table inserted and the table selected must be the same or bind tables.\");\n         }\n+        if (insertSelectSegment.isPresent() && isNeedMergeShardingValues(sqlStatementContext, shardingRule)) {\n+            checkSubqueryShardingValues(shardingRule, sqlStatementContext, parameters, schema);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e0d71dee29ebe19dd7b56177e96fcc3d326c4290"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjI5Njg3Ng==", "bodyText": "OK", "url": "https://github.com/apache/shardingsphere/pull/8310#discussion_r532296876", "createdAt": "2020-11-30T00:48:41Z", "author": {"login": "wgy8283335"}, "path": "shardingsphere-features/shardingsphere-sharding/shardingsphere-sharding-route/src/main/java/org/apache/shardingsphere/sharding/route/engine/validator/dml/impl/ShardingInsertStatementValidator.java", "diffHunk": "@@ -62,6 +78,9 @@ public void preValidate(final ShardingRule shardingRule, final SQLStatementConte\n         if (insertSelectSegment.isPresent() && !isAllSameTables(tablesContext.getTableNames()) && !shardingRule.isAllBindingTables(tablesContext.getTableNames())) {\n             throw new ShardingSphereException(\"The table inserted and the table selected must be the same or bind tables.\");\n         }\n+        if (insertSelectSegment.isPresent() && isNeedMergeShardingValues(sqlStatementContext, shardingRule)) {\n+            checkSubqueryShardingValues(shardingRule, sqlStatementContext, parameters, schema);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjA0NzA3MQ=="}, "originalCommit": {"oid": "e0d71dee29ebe19dd7b56177e96fcc3d326c4290"}, "originalPosition": 40}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 558, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}