{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA5OTI1MzE3", "number": 5363, "title": "a custom datetime shard algorithm used to shard tables by days/weeks/months/QUARTER_OF_YEAR", "bodyText": "Ref #5282.\nChanges proposed in this pull request:\n\nsupply a sharding algorithm used to shard tables by days/weeks/months/QUARTER_OF_YEAR/...\nusage examples\n\nshard by QUARTER_OF_YEAR (\u6309\u5b63\u5ea6\u5206\u8868)\n\n    actualDataNodes: ds.t_order_20${10..20}0${1..4}\n    tableStrategy:\n      standard:\n        shardingColumn: created_at\n        shardingAlgorithm:\n          type: CUSTOM_DATE_TIME\n          props:\n            datetime.format: yyyy-MM-dd HH:mm:ss\n            table.suffix.format: yyyyQQ\n            datetime.lower: \"2010-01-01 00:00:00.000\"\n            datetime.upper: \"2020-12-31 00:00:00.000\"\n            datetime.step.unit: Months\n            datetime.step.amount: 3\n\nconfig detail can refer to java doc of org.apache.shardingsphere.core.strategy.algorithm.sharding.CustomDateTimeShardingAlgorithmTest", "createdAt": "2020-04-28T07:06:36Z", "url": "https://github.com/apache/shardingsphere/pull/5363", "merged": true, "mergeCommit": {"oid": "5b01ffd415428831067ae05f1aaf39653400f0a8"}, "closed": true, "closedAt": "2020-04-29T02:21:02Z", "author": {"login": "SanmuWangZJU"}, "timelineItems": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcb-DwJgH2gAyNDA5OTI1MzE3OjgyNDBiOGU5MTBmOGFmMmMwMzYzMzVhZThkZTI5MWE0NzM3NzA0M2M=", "endCursor": "Y3Vyc29yOnYyOpPPAAABccO2ZfgFqTQwMjMyNzg3Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "8240b8e910f8af2c036335ae8de291a47377043c", "author": {"user": null}, "url": "https://github.com/apache/shardingsphere/commit/8240b8e910f8af2c036335ae8de291a47377043c", "committedDate": "2020-04-28T06:40:15Z", "message": "datetime shard algorithm used to shard tables by days/weeks/months/QUARTER_OF_YEAR"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "152cb6d960cc23164b9044f1d4f9320ab2923905", "author": {"user": null}, "url": "https://github.com/apache/shardingsphere/commit/152cb6d960cc23164b9044f1d4f9320ab2923905", "committedDate": "2020-04-28T07:03:44Z", "message": "add half range sharding tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAxNjA3MDQ4", "url": "https://github.com/apache/shardingsphere/pull/5363#pullrequestreview-401607048", "createdAt": "2020-04-28T08:23:56Z", "commit": {"oid": "152cb6d960cc23164b9044f1d4f9320ab2923905"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQwODoyMzo1NlrOGNIlPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQwODo0NzoxNFrOGNJhPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQyNTI3Nw==", "bodyText": "I like this detailed java doc.", "url": "https://github.com/apache/shardingsphere/pull/5363#discussion_r416425277", "createdAt": "2020-04-28T08:23:56Z", "author": {"login": "tristaZero"}, "path": "sharding-core/sharding-core-common/src/main/java/org/apache/shardingsphere/core/strategy/algorithm/sharding/CustomDateTimeShardingAlgorithm.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.shardingsphere.core.strategy.algorithm.sharding;\n+\n+import com.google.common.base.Preconditions;\n+import lombok.Getter;\n+import lombok.Setter;\n+import org.apache.shardingsphere.api.sharding.standard.PreciseShardingValue;\n+import org.apache.shardingsphere.api.sharding.standard.RangeShardingValue;\n+import org.apache.shardingsphere.api.sharding.standard.StandardShardingAlgorithm;\n+\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.ChronoUnit;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalField;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Properties;\n+import java.util.Set;\n+\n+/**\n+ * Datetime sharding algorithm that adapt various shard method by define properties below.\n+ *\n+ * <p>properties defined here:\n+ *\n+ * <p>datetime.format: the datetime format used by applications, must can be transformed to {@link LocalDateTime},\n+ * used by {@link LocalDateTime#parse(CharSequence, DateTimeFormatter)}.\n+ *\n+ * <p>table.suffix.format: suffix for sharded tables, used by {@link LocalDateTime#format(DateTimeFormatter)},\n+ * examples:\n+ * suffix=yyyyQQ means shard by {@link IsoFields#QUARTER_OF_YEAR};\n+ * suffix=yyyyMMdd means shard by {@link ChronoField#DAY_OF_YEAR}.\n+ *\n+ * <p>detail explain for each char in datetime.format and table.suffix.format can refer {@link TemporalField}.\n+ *\n+ * <p>datetime.lower and datetime.upper: if app query with only half bound, lower and upper helps to build other half bound,\n+ * datetime.lower must be specified and datetime.upper has a default value to {@link LocalDateTime#now}\n+ * (default value of datetime.upper could only be used when query sql needn't get result that time larger than query time).\n+ *\n+ * <p>datetime.step.unit and datetime.step.amount used for calculate tables for range shard, datetime.step.unit is name of\n+ * {@link ChronoUnit}, default unit is Days and amount is 1, amount + unit should not be larger than but close to your shard range.\n+ *", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "152cb6d960cc23164b9044f1d4f9320ab2923905"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQyODMxMQ==", "bodyText": "A redundant blank line is recommended to remove.", "url": "https://github.com/apache/shardingsphere/pull/5363#discussion_r416428311", "createdAt": "2020-04-28T08:28:29Z", "author": {"login": "tristaZero"}, "path": "sharding-core/sharding-core-common/src/test/java/org/apache/shardingsphere/core/strategy/algorithm/sharding/CustomDateTimeShardingAlgorithmTest.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.shardingsphere.core.strategy.algorithm.sharding;\n+\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Range;\n+import org.apache.shardingsphere.api.config.sharding.strategy.StandardShardingStrategyConfiguration;\n+import org.apache.shardingsphere.core.strategy.route.standard.StandardShardingStrategy;\n+import org.apache.shardingsphere.core.strategy.route.value.ListRouteValue;\n+import org.apache.shardingsphere.core.strategy.route.value.RangeRouteValue;\n+import org.apache.shardingsphere.core.strategy.route.value.RouteValue;\n+import org.apache.shardingsphere.underlying.common.config.properties.ConfigurationProperties;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Properties;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * datetime sharding algorithm test.\n+ */\n+public class CustomDateTimeShardingAlgorithmTest {\n+\n+    private final List<String> availableTables = new ArrayList<>();\n+\n+    private StandardShardingStrategy shardingStrategy;\n+\n+    @Before\n+    public void setup() {\n+        CustomDateTimeShardingAlgorithm shardingAlgorithm = new CustomDateTimeShardingAlgorithm();\n+        shardingAlgorithm.getProperties().setProperty(\"datetime.format\", \"yyyy-MM-dd HH:mm:ss\");\n+        shardingAlgorithm.getProperties().setProperty(\"table.suffix.format\", \"yyyyQQ\");\n+        shardingAlgorithm.getProperties().setProperty(\"datetime.lower\", \"2016-01-01 00:00:00.000\");\n+        shardingAlgorithm.getProperties().setProperty(\"datetime.upper\", \"2021-12-31 00:00:00.000\");\n+        shardingAlgorithm.getProperties().setProperty(\"datetime.step.unit\", \"Months\");\n+        shardingAlgorithm.getProperties().setProperty(\"datetime.step.amount\", \"3\");\n+        StandardShardingStrategyConfiguration shardingStrategyConfig = new StandardShardingStrategyConfiguration(\"create_time\", shardingAlgorithm);\n+        this.shardingStrategy = new StandardShardingStrategy(shardingStrategyConfig);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "152cb6d960cc23164b9044f1d4f9320ab2923905"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQyOTExNA==", "bodyText": "Considering the consistent function names, assertFormat is better.", "url": "https://github.com/apache/shardingsphere/pull/5363#discussion_r416429114", "createdAt": "2020-04-28T08:29:38Z", "author": {"login": "tristaZero"}, "path": "sharding-core/sharding-core-common/src/test/java/org/apache/shardingsphere/core/strategy/algorithm/sharding/CustomDateTimeShardingAlgorithmTest.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.shardingsphere.core.strategy.algorithm.sharding;\n+\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Range;\n+import org.apache.shardingsphere.api.config.sharding.strategy.StandardShardingStrategyConfiguration;\n+import org.apache.shardingsphere.core.strategy.route.standard.StandardShardingStrategy;\n+import org.apache.shardingsphere.core.strategy.route.value.ListRouteValue;\n+import org.apache.shardingsphere.core.strategy.route.value.RangeRouteValue;\n+import org.apache.shardingsphere.core.strategy.route.value.RouteValue;\n+import org.apache.shardingsphere.underlying.common.config.properties.ConfigurationProperties;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Properties;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * datetime sharding algorithm test.\n+ */\n+public class CustomDateTimeShardingAlgorithmTest {\n+\n+    private final List<String> availableTables = new ArrayList<>();\n+\n+    private StandardShardingStrategy shardingStrategy;\n+\n+    @Before\n+    public void setup() {\n+        CustomDateTimeShardingAlgorithm shardingAlgorithm = new CustomDateTimeShardingAlgorithm();\n+        shardingAlgorithm.getProperties().setProperty(\"datetime.format\", \"yyyy-MM-dd HH:mm:ss\");\n+        shardingAlgorithm.getProperties().setProperty(\"table.suffix.format\", \"yyyyQQ\");\n+        shardingAlgorithm.getProperties().setProperty(\"datetime.lower\", \"2016-01-01 00:00:00.000\");\n+        shardingAlgorithm.getProperties().setProperty(\"datetime.upper\", \"2021-12-31 00:00:00.000\");\n+        shardingAlgorithm.getProperties().setProperty(\"datetime.step.unit\", \"Months\");\n+        shardingAlgorithm.getProperties().setProperty(\"datetime.step.amount\", \"3\");\n+        StandardShardingStrategyConfiguration shardingStrategyConfig = new StandardShardingStrategyConfiguration(\"create_time\", shardingAlgorithm);\n+        this.shardingStrategy = new StandardShardingStrategy(shardingStrategyConfig);\n+\n+        for (int i = 2016; i <= 2020; i++) {\n+            for (int j = 1; j <= 4; j++) {\n+                availableTables.add(String.format(\"t_order_%04d%02d\", i, j));\n+            }\n+        }\n+    }\n+\n+    @Test\n+    public void assertPreciseDoSharding() {\n+        List<RouteValue> shardingValues = Lists.newArrayList(new ListRouteValue<>(\"create_time\", \"t_order\",\n+                Lists.newArrayList(\"2020-01-01 00:00:01\", \"2020-01-01 00:00:02\", \"2020-04-15 10:59:08\")));\n+        Collection<String> actual = shardingStrategy.doSharding(availableTables, shardingValues, new ConfigurationProperties(new Properties()));\n+        assertThat(actual.size(), is(2));\n+        assertTrue(actual.contains(\"t_order_202001\"));\n+        assertTrue(actual.contains(\"t_order_202002\"));\n+    }\n+\n+    @Test\n+    public void assertRangeDoSharding() {\n+        Range<String> rangeValue = Range.closed(\"2019-10-15 10:59:08\", \"2020-04-08 10:59:08\");\n+        List<RouteValue> shardingValues = Lists.newArrayList(new RangeRouteValue<>(\"create_time\", \"t_order\", rangeValue));\n+        Collection<String> actual = shardingStrategy.doSharding(availableTables, shardingValues, new ConfigurationProperties(new Properties()));\n+        assertThat(actual.size(), is(3));\n+    }\n+\n+    @Test\n+    public void assertLowerHalfRangeDoSharding() {\n+        Range<String> rangeValue = Range.atLeast(\"2018-10-15 10:59:08\");\n+        List<RouteValue> shardingValues = Lists.newArrayList(new RangeRouteValue<>(\"create_time\", \"t_order\", rangeValue));\n+        Collection<String> actual = shardingStrategy.doSharding(availableTables, shardingValues, new ConfigurationProperties(new Properties()));\n+        assertThat(actual.size(), is(9));\n+    }\n+\n+    @Test\n+    public void assertUpperHalfRangeDoSharding() {\n+        Range<String> rangeValue = Range.atMost(\"2019-09-01 00:00:00\");\n+        List<RouteValue> shardingValues = Lists.newArrayList(new RangeRouteValue<>(\"create_time\", \"t_order\", rangeValue));\n+        Collection<String> actual = shardingStrategy.doSharding(availableTables, shardingValues, new ConfigurationProperties(new Properties()));\n+        assertThat(actual.size(), is(15));\n+    }\n+\n+    @Test\n+    public void testFormat() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "152cb6d960cc23164b9044f1d4f9320ab2923905"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQ0MDYzOA==", "bodyText": "This is a great practice t shard by quarter. Besides, could you provide another test case like sharding by month or day to present its flexibility to our users?\nYou know, a cool algorithm needs more examples to express its features.", "url": "https://github.com/apache/shardingsphere/pull/5363#discussion_r416440638", "createdAt": "2020-04-28T08:47:14Z", "author": {"login": "tristaZero"}, "path": "sharding-core/sharding-core-common/src/test/java/org/apache/shardingsphere/core/strategy/algorithm/sharding/CustomDateTimeShardingAlgorithmTest.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.shardingsphere.core.strategy.algorithm.sharding;\n+\n+import com.google.common.collect.Lists;\n+import com.google.common.collect.Range;\n+import org.apache.shardingsphere.api.config.sharding.strategy.StandardShardingStrategyConfiguration;\n+import org.apache.shardingsphere.core.strategy.route.standard.StandardShardingStrategy;\n+import org.apache.shardingsphere.core.strategy.route.value.ListRouteValue;\n+import org.apache.shardingsphere.core.strategy.route.value.RangeRouteValue;\n+import org.apache.shardingsphere.core.strategy.route.value.RouteValue;\n+import org.apache.shardingsphere.underlying.common.config.properties.ConfigurationProperties;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Properties;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.assertTrue;\n+\n+/**\n+ * datetime sharding algorithm test.\n+ */\n+public class CustomDateTimeShardingAlgorithmTest {\n+\n+    private final List<String> availableTables = new ArrayList<>();\n+\n+    private StandardShardingStrategy shardingStrategy;\n+\n+    @Before\n+    public void setup() {\n+        CustomDateTimeShardingAlgorithm shardingAlgorithm = new CustomDateTimeShardingAlgorithm();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "152cb6d960cc23164b9044f1d4f9320ab2923905"}, "originalPosition": 54}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAxNjY1ODg3", "url": "https://github.com/apache/shardingsphere/pull/5363#pullrequestreview-401665887", "createdAt": "2020-04-28T09:37:47Z", "commit": {"oid": "152cb6d960cc23164b9044f1d4f9320ab2923905"}, "state": "DISMISSED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQwOTozNzo0N1rOGNLh7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQwOTo1NTo1MlrOGNMNcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQ3MzU4MA==", "bodyText": "Me too", "url": "https://github.com/apache/shardingsphere/pull/5363#discussion_r416473580", "createdAt": "2020-04-28T09:37:47Z", "author": {"login": "kimmking"}, "path": "sharding-core/sharding-core-common/src/main/java/org/apache/shardingsphere/core/strategy/algorithm/sharding/CustomDateTimeShardingAlgorithm.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.shardingsphere.core.strategy.algorithm.sharding;\n+\n+import com.google.common.base.Preconditions;\n+import lombok.Getter;\n+import lombok.Setter;\n+import org.apache.shardingsphere.api.sharding.standard.PreciseShardingValue;\n+import org.apache.shardingsphere.api.sharding.standard.RangeShardingValue;\n+import org.apache.shardingsphere.api.sharding.standard.StandardShardingAlgorithm;\n+\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.ChronoUnit;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalField;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Properties;\n+import java.util.Set;\n+\n+/**\n+ * Datetime sharding algorithm that adapt various shard method by define properties below.\n+ *\n+ * <p>properties defined here:\n+ *\n+ * <p>datetime.format: the datetime format used by applications, must can be transformed to {@link LocalDateTime},\n+ * used by {@link LocalDateTime#parse(CharSequence, DateTimeFormatter)}.\n+ *\n+ * <p>table.suffix.format: suffix for sharded tables, used by {@link LocalDateTime#format(DateTimeFormatter)},\n+ * examples:\n+ * suffix=yyyyQQ means shard by {@link IsoFields#QUARTER_OF_YEAR};\n+ * suffix=yyyyMMdd means shard by {@link ChronoField#DAY_OF_YEAR}.\n+ *\n+ * <p>detail explain for each char in datetime.format and table.suffix.format can refer {@link TemporalField}.\n+ *\n+ * <p>datetime.lower and datetime.upper: if app query with only half bound, lower and upper helps to build other half bound,\n+ * datetime.lower must be specified and datetime.upper has a default value to {@link LocalDateTime#now}\n+ * (default value of datetime.upper could only be used when query sql needn't get result that time larger than query time).\n+ *\n+ * <p>datetime.step.unit and datetime.step.amount used for calculate tables for range shard, datetime.step.unit is name of\n+ * {@link ChronoUnit}, default unit is Days and amount is 1, amount + unit should not be larger than but close to your shard range.\n+ *", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQyNTI3Nw=="}, "originalCommit": {"oid": "152cb6d960cc23164b9044f1d4f9320ab2923905"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQ3NjE4Nw==", "bodyText": "remove tepUnit =", "url": "https://github.com/apache/shardingsphere/pull/5363#discussion_r416476187", "createdAt": "2020-04-28T09:42:04Z", "author": {"login": "kimmking"}, "path": "sharding-core/sharding-core-common/src/main/java/org/apache/shardingsphere/core/strategy/algorithm/sharding/CustomDateTimeShardingAlgorithm.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.shardingsphere.core.strategy.algorithm.sharding;\n+\n+import com.google.common.base.Preconditions;\n+import lombok.Getter;\n+import lombok.Setter;\n+import org.apache.shardingsphere.api.sharding.standard.PreciseShardingValue;\n+import org.apache.shardingsphere.api.sharding.standard.RangeShardingValue;\n+import org.apache.shardingsphere.api.sharding.standard.StandardShardingAlgorithm;\n+\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.ChronoUnit;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalField;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Properties;\n+import java.util.Set;\n+\n+/**\n+ * Datetime sharding algorithm that adapt various shard method by define properties below.\n+ *\n+ * <p>properties defined here:\n+ *\n+ * <p>datetime.format: the datetime format used by applications, must can be transformed to {@link LocalDateTime},\n+ * used by {@link LocalDateTime#parse(CharSequence, DateTimeFormatter)}.\n+ *\n+ * <p>table.suffix.format: suffix for sharded tables, used by {@link LocalDateTime#format(DateTimeFormatter)},\n+ * examples:\n+ * suffix=yyyyQQ means shard by {@link IsoFields#QUARTER_OF_YEAR};\n+ * suffix=yyyyMMdd means shard by {@link ChronoField#DAY_OF_YEAR}.\n+ *\n+ * <p>detail explain for each char in datetime.format and table.suffix.format can refer {@link TemporalField}.\n+ *\n+ * <p>datetime.lower and datetime.upper: if app query with only half bound, lower and upper helps to build other half bound,\n+ * datetime.lower must be specified and datetime.upper has a default value to {@link LocalDateTime#now}\n+ * (default value of datetime.upper could only be used when query sql needn't get result that time larger than query time).\n+ *\n+ * <p>datetime.step.unit and datetime.step.amount used for calculate tables for range shard, datetime.step.unit is name of\n+ * {@link ChronoUnit}, default unit is Days and amount is 1, amount + unit should not be larger than but close to your shard range.\n+ *\n+ * <p>examples: when shard by {@link IsoFields#QUARTER_OF_YEAR}, datetime.step.unit = Months and datetime.step.amount = 3 is a better choice.\n+ */\n+public class CustomDateTimeShardingAlgorithm implements StandardShardingAlgorithm<Comparable<?>> {\n+\n+    private static final String DATE_TIME_FORMAT = \"datetime.format\";\n+\n+    private static final String TABLE_SUFFIX_FORMAT = \"table.suffix.format\";\n+\n+    private static final String DEFAULT_LOWER = \"datetime.lower\";\n+\n+    private static final String DEFAULT_UPPER = \"datetime.upper\";\n+\n+    private static final String STEP_UNIT = \"datetime.step.unit\";\n+\n+    private static final String STEP_AMOUNT = \"datetime.step.amount\";\n+\n+    private DateTimeFormatter datetimeFormatter;\n+\n+    private ChronoUnit stepUnit;\n+\n+    private int stepAmount;\n+\n+    private volatile boolean init;\n+\n+    @Getter\n+    @Setter\n+    private Properties properties = new Properties();\n+\n+    @Override\n+    public String doSharding(final Collection<String> availableTargetNames, final PreciseShardingValue<Comparable<?>> shardingValue) {\n+        checkInit();\n+        return availableTargetNames.stream()\n+                .filter(tableName -> tableName.endsWith(formatForDateTime(parseDateTimeForValue(shardingValue.getValue().toString()))))\n+                .findFirst().orElseThrow(() -> new UnsupportedOperationException(\n+                        String.format(\"failed to shard value %s, and availableTables %s\", shardingValue, availableTargetNames)));\n+    }\n+\n+    @Override\n+    public Collection<String> doSharding(final Collection<String> availableTargetNames, final RangeShardingValue<Comparable<?>> shardingValue) {\n+        checkInit();\n+        boolean hasStart = shardingValue.getValueRange().hasLowerBound();\n+        boolean hasEnd = shardingValue.getValueRange().hasUpperBound();\n+        Set<String> tables = new HashSet<>();\n+        if (!hasStart && !hasEnd) {\n+            return availableTargetNames;\n+        }\n+        LocalDateTime start = hasStart\n+                ? parseDateTimeForValue(shardingValue.getValueRange().lowerEndpoint().toString())\n+                : parseDateTimeForValue(properties.getProperty(DEFAULT_LOWER));\n+        LocalDateTime end = hasEnd\n+                ? parseDateTimeForValue(shardingValue.getValueRange().upperEndpoint().toString())\n+                : properties.getProperty(DEFAULT_UPPER) == null\n+                ? LocalDateTime.now()\n+                : parseDateTimeForValue(properties.getProperty(DEFAULT_UPPER));\n+        LocalDateTime tmp = start;\n+        while (!tmp.isAfter(end)) {\n+            mergeTableIfMatch(tmp, tables, availableTargetNames);\n+            tmp = tmp.plus(stepAmount, stepUnit);\n+        }\n+        mergeTableIfMatch(end, tables, availableTargetNames);\n+        return tables;\n+    }\n+\n+    private LocalDateTime parseDateTimeForValue(final String value) {\n+        return LocalDateTime.parse(value.substring(0, properties.getProperty(DATE_TIME_FORMAT).length()), datetimeFormatter);\n+    }\n+\n+    private String formatForDateTime(final LocalDateTime localDateTime) {\n+        return localDateTime.format(DateTimeFormatter.ofPattern(properties.get(TABLE_SUFFIX_FORMAT).toString()));\n+    }\n+\n+    private void mergeTableIfMatch(final LocalDateTime dateTime, final Collection<String> tables, final Collection<String> availableTargetNames) {\n+        String suffix = formatForDateTime(dateTime);\n+        availableTargetNames.parallelStream().filter(tableName -> tableName.endsWith(suffix)).findAny().map(tables::add);\n+    }\n+\n+    private void checkInit() {\n+        if (!init) {\n+            synchronized (this) {\n+                if (!init) {\n+                    verifyProperties();\n+                    init = true;\n+                }\n+            }\n+        }\n+    }\n+\n+    private void verifyProperties() {\n+        Preconditions.checkNotNull(properties.getProperty(DATE_TIME_FORMAT));\n+        Preconditions.checkNotNull(properties.getProperty(TABLE_SUFFIX_FORMAT));\n+        Preconditions.checkNotNull(properties.getProperty(DEFAULT_LOWER));\n+        stepUnit = properties.getProperty(STEP_UNIT) == null\n+                ? stepUnit = ChronoUnit.DAYS", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "152cb6d960cc23164b9044f1d4f9320ab2923905"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQ4MTA5NA==", "bodyText": "why add sync block here\uff1f", "url": "https://github.com/apache/shardingsphere/pull/5363#discussion_r416481094", "createdAt": "2020-04-28T09:49:56Z", "author": {"login": "kimmking"}, "path": "sharding-core/sharding-core-common/src/main/java/org/apache/shardingsphere/core/strategy/algorithm/sharding/CustomDateTimeShardingAlgorithm.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.shardingsphere.core.strategy.algorithm.sharding;\n+\n+import com.google.common.base.Preconditions;\n+import lombok.Getter;\n+import lombok.Setter;\n+import org.apache.shardingsphere.api.sharding.standard.PreciseShardingValue;\n+import org.apache.shardingsphere.api.sharding.standard.RangeShardingValue;\n+import org.apache.shardingsphere.api.sharding.standard.StandardShardingAlgorithm;\n+\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.ChronoUnit;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalField;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Properties;\n+import java.util.Set;\n+\n+/**\n+ * Datetime sharding algorithm that adapt various shard method by define properties below.\n+ *\n+ * <p>properties defined here:\n+ *\n+ * <p>datetime.format: the datetime format used by applications, must can be transformed to {@link LocalDateTime},\n+ * used by {@link LocalDateTime#parse(CharSequence, DateTimeFormatter)}.\n+ *\n+ * <p>table.suffix.format: suffix for sharded tables, used by {@link LocalDateTime#format(DateTimeFormatter)},\n+ * examples:\n+ * suffix=yyyyQQ means shard by {@link IsoFields#QUARTER_OF_YEAR};\n+ * suffix=yyyyMMdd means shard by {@link ChronoField#DAY_OF_YEAR}.\n+ *\n+ * <p>detail explain for each char in datetime.format and table.suffix.format can refer {@link TemporalField}.\n+ *\n+ * <p>datetime.lower and datetime.upper: if app query with only half bound, lower and upper helps to build other half bound,\n+ * datetime.lower must be specified and datetime.upper has a default value to {@link LocalDateTime#now}\n+ * (default value of datetime.upper could only be used when query sql needn't get result that time larger than query time).\n+ *\n+ * <p>datetime.step.unit and datetime.step.amount used for calculate tables for range shard, datetime.step.unit is name of\n+ * {@link ChronoUnit}, default unit is Days and amount is 1, amount + unit should not be larger than but close to your shard range.\n+ *\n+ * <p>examples: when shard by {@link IsoFields#QUARTER_OF_YEAR}, datetime.step.unit = Months and datetime.step.amount = 3 is a better choice.\n+ */\n+public class CustomDateTimeShardingAlgorithm implements StandardShardingAlgorithm<Comparable<?>> {\n+\n+    private static final String DATE_TIME_FORMAT = \"datetime.format\";\n+\n+    private static final String TABLE_SUFFIX_FORMAT = \"table.suffix.format\";\n+\n+    private static final String DEFAULT_LOWER = \"datetime.lower\";\n+\n+    private static final String DEFAULT_UPPER = \"datetime.upper\";\n+\n+    private static final String STEP_UNIT = \"datetime.step.unit\";\n+\n+    private static final String STEP_AMOUNT = \"datetime.step.amount\";\n+\n+    private DateTimeFormatter datetimeFormatter;\n+\n+    private ChronoUnit stepUnit;\n+\n+    private int stepAmount;\n+\n+    private volatile boolean init;\n+\n+    @Getter\n+    @Setter\n+    private Properties properties = new Properties();\n+\n+    @Override\n+    public String doSharding(final Collection<String> availableTargetNames, final PreciseShardingValue<Comparable<?>> shardingValue) {\n+        checkInit();\n+        return availableTargetNames.stream()\n+                .filter(tableName -> tableName.endsWith(formatForDateTime(parseDateTimeForValue(shardingValue.getValue().toString()))))\n+                .findFirst().orElseThrow(() -> new UnsupportedOperationException(\n+                        String.format(\"failed to shard value %s, and availableTables %s\", shardingValue, availableTargetNames)));\n+    }\n+\n+    @Override\n+    public Collection<String> doSharding(final Collection<String> availableTargetNames, final RangeShardingValue<Comparable<?>> shardingValue) {\n+        checkInit();\n+        boolean hasStart = shardingValue.getValueRange().hasLowerBound();\n+        boolean hasEnd = shardingValue.getValueRange().hasUpperBound();\n+        Set<String> tables = new HashSet<>();\n+        if (!hasStart && !hasEnd) {\n+            return availableTargetNames;\n+        }\n+        LocalDateTime start = hasStart\n+                ? parseDateTimeForValue(shardingValue.getValueRange().lowerEndpoint().toString())\n+                : parseDateTimeForValue(properties.getProperty(DEFAULT_LOWER));\n+        LocalDateTime end = hasEnd\n+                ? parseDateTimeForValue(shardingValue.getValueRange().upperEndpoint().toString())\n+                : properties.getProperty(DEFAULT_UPPER) == null\n+                ? LocalDateTime.now()\n+                : parseDateTimeForValue(properties.getProperty(DEFAULT_UPPER));\n+        LocalDateTime tmp = start;\n+        while (!tmp.isAfter(end)) {\n+            mergeTableIfMatch(tmp, tables, availableTargetNames);\n+            tmp = tmp.plus(stepAmount, stepUnit);\n+        }\n+        mergeTableIfMatch(end, tables, availableTargetNames);\n+        return tables;\n+    }\n+\n+    private LocalDateTime parseDateTimeForValue(final String value) {\n+        return LocalDateTime.parse(value.substring(0, properties.getProperty(DATE_TIME_FORMAT).length()), datetimeFormatter);\n+    }\n+\n+    private String formatForDateTime(final LocalDateTime localDateTime) {\n+        return localDateTime.format(DateTimeFormatter.ofPattern(properties.get(TABLE_SUFFIX_FORMAT).toString()));\n+    }\n+\n+    private void mergeTableIfMatch(final LocalDateTime dateTime, final Collection<String> tables, final Collection<String> availableTargetNames) {\n+        String suffix = formatForDateTime(dateTime);\n+        availableTargetNames.parallelStream().filter(tableName -> tableName.endsWith(suffix)).findAny().map(tables::add);\n+    }\n+\n+    private void checkInit() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "152cb6d960cc23164b9044f1d4f9320ab2923905"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQ4NDcyMw==", "bodyText": "yyyyMM is also a common style.", "url": "https://github.com/apache/shardingsphere/pull/5363#discussion_r416484723", "createdAt": "2020-04-28T09:55:52Z", "author": {"login": "kimmking"}, "path": "sharding-core/sharding-core-common/src/main/java/org/apache/shardingsphere/core/strategy/algorithm/sharding/CustomDateTimeShardingAlgorithm.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.shardingsphere.core.strategy.algorithm.sharding;\n+\n+import com.google.common.base.Preconditions;\n+import lombok.Getter;\n+import lombok.Setter;\n+import org.apache.shardingsphere.api.sharding.standard.PreciseShardingValue;\n+import org.apache.shardingsphere.api.sharding.standard.RangeShardingValue;\n+import org.apache.shardingsphere.api.sharding.standard.StandardShardingAlgorithm;\n+\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.ChronoUnit;\n+import java.time.temporal.IsoFields;\n+import java.time.temporal.TemporalField;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Properties;\n+import java.util.Set;\n+\n+/**\n+ * Datetime sharding algorithm that adapt various shard method by define properties below.\n+ *\n+ * <p>properties defined here:\n+ *\n+ * <p>datetime.format: the datetime format used by applications, must can be transformed to {@link LocalDateTime},\n+ * used by {@link LocalDateTime#parse(CharSequence, DateTimeFormatter)}.\n+ *\n+ * <p>table.suffix.format: suffix for sharded tables, used by {@link LocalDateTime#format(DateTimeFormatter)},\n+ * examples:\n+ * suffix=yyyyQQ means shard by {@link IsoFields#QUARTER_OF_YEAR};\n+ * suffix=yyyyMMdd means shard by {@link ChronoField#DAY_OF_YEAR}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "152cb6d960cc23164b9044f1d4f9320ab2923905"}, "originalPosition": 50}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "97e416ce28a0c706c1b6a7c06859dabea6a092f5", "author": {"user": null}, "url": "https://github.com/apache/shardingsphere/commit/97e416ce28a0c706c1b6a7c06859dabea6a092f5", "committedDate": "2020-04-28T11:46:25Z", "message": "add test case for yyyyMM and fix format issue"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAyMzI3ODcy", "url": "https://github.com/apache/shardingsphere/pull/5363#pullrequestreview-402327872", "createdAt": "2020-04-29T02:14:03Z", "commit": {"oid": "97e416ce28a0c706c1b6a7c06859dabea6a092f5"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3679, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}