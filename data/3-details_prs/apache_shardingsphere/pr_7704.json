{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk4NTA0NzI3", "number": 7704, "title": "add create function and procedure validator", "bodyText": "Fixes #6498.\nChanges proposed in this pull request:\n\nparse create function and procedure g4 file\nadd create function and procedure validator", "createdAt": "2020-10-06T12:34:03Z", "url": "https://github.com/apache/shardingsphere/pull/7704", "merged": true, "mergeCommit": {"oid": "e3bb018d4366da9d5f1ba51197ae3403a2596c99"}, "closed": true, "closedAt": "2020-10-09T04:38:01Z", "author": {"login": "strongduanmu"}, "timelineItems": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdP1jFDgH2gAyNDk4NTA0NzI3OmM5YmY0MDAzNGYyMzBkZGQ3ODg2OWY1ZTg4YWNlNzE2Y2JkZjFkYWQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdQumFHgFqTUwNTM1ODEwNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "c9bf40034f230ddd78869f5e88ace716cbdf1dad", "author": {"user": {"login": "strongduanmu", "name": "Zhengqiang Duan"}}, "url": "https://github.com/apache/shardingsphere/commit/c9bf40034f230ddd78869f5e88ace716cbdf1dad", "committedDate": "2020-10-06T10:09:23Z", "message": "add create function and procedure validator"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAzODA4NzQ5", "url": "https://github.com/apache/shardingsphere/pull/7704#pullrequestreview-503808749", "createdAt": "2020-10-07T12:09:07Z", "commit": {"oid": "c9bf40034f230ddd78869f5e88ace716cbdf1dad"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxMjowOTowN1rOHdwG7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxMzoxNzo1MVrOHdy2Lw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDk1ODk1Ng==", "bodyText": "Carefully examined. \ud83d\udc4d", "url": "https://github.com/apache/shardingsphere/pull/7704#discussion_r500958956", "createdAt": "2020-10-07T12:09:07Z", "author": {"login": "tristaZero"}, "path": "shardingsphere-sql-parser/shardingsphere-sql-parser-statement/src/test/java/org/apache/shardingsphere/sql/parser/sql/dialect/handler/ddl/DropIndexStatementHandlerTest.java", "diffHunk": "@@ -28,7 +28,7 @@\n import static org.junit.Assert.assertFalse;\n import static org.junit.Assert.assertTrue;\n \n-public class DropIndexStatementHandlerTest {\n+public final class DropIndexStatementHandlerTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c9bf40034f230ddd78869f5e88ace716cbdf1dad"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDk4Mzc4Nw==", "bodyText": "if MySQLDMLVisitor is necessary, do you think moving the content of MySQLDMLVisitor to MySQLVisitor will be better than createParseTreeVisitor?", "url": "https://github.com/apache/shardingsphere/pull/7704#discussion_r500983787", "createdAt": "2020-10-07T12:48:28Z", "author": {"login": "tristaZero"}, "path": "shardingsphere-sql-parser/shardingsphere-sql-parser-dialect/shardingsphere-sql-parser-mysql/src/main/java/org/apache/shardingsphere/sql/parser/mysql/visitor/impl/MySQLDDLVisitor.java", "diffHunk": "@@ -461,92 +483,256 @@ public ASTNode visitKeyParts_(final KeyParts_Context ctx) {\n         }\n         return result;\n     }\n-\n+    \n     @Override\n     public ASTNode visitCreateProcedure(final CreateProcedureContext ctx) {\n-        return new MySQLCreateProcedureStatement();\n+        MySQLCreateProcedureStatement result = new MySQLCreateProcedureStatement();\n+        result.setRoutineBody((RoutineBodySegment) visit(ctx.routineBody()));\n+        return result;\n     }\n-\n+    \n     @Override\n     public ASTNode visitAlterProcedure(final AlterProcedureContext ctx) {\n         return new MySQLAlterProcedureStatement();\n     }\n-\n+    \n     @Override\n     public ASTNode visitDropProcedure(final DropProcedureContext ctx) {\n         return new MySQLDropProcedureStatement();\n     }\n-\n+    \n     @Override\n     public ASTNode visitCreateFunction(final CreateFunctionContext ctx) {\n-        return new MySQLCreateFunctionStatement();\n+        MySQLCreateFunctionStatement result = new MySQLCreateFunctionStatement();\n+        result.setRoutineBody((RoutineBodySegment) visit(ctx.routineBody()));\n+        return result;\n     }\n-\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public ASTNode visitRoutineBody(final RoutineBodyContext ctx) {\n+        RoutineBodySegment result = new RoutineBodySegment(ctx.start.getStartIndex(), ctx.stop.getStopIndex());\n+        CollectionValue<ValidStatementSegment> validStatements;\n+        if (null != ctx.simpleStatement()) {\n+            validStatements = (CollectionValue<ValidStatementSegment>) visit(ctx.simpleStatement());\n+        } else {\n+            validStatements = (CollectionValue<ValidStatementSegment>) visit(ctx.compoundStatement());\n+        }\n+        result.getValidStatements().addAll(validStatements.getValue());\n+        return result;\n+    }\n+    \n+    @Override\n+    public ASTNode visitSimpleStatement(final SimpleStatementContext ctx) {\n+        return visit(ctx.validStatement());\n+    }\n+    \n+    @Override\n+    public ASTNode visitCompoundStatement(final CompoundStatementContext ctx) {\n+        return visit(ctx.beginStatement());\n+    }\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public ASTNode visitBeginStatement(final BeginStatementContext ctx) {\n+        CollectionValue<ValidStatementSegment> result = new CollectionValue<>();\n+        for (ValidStatementContext each : ctx.validStatement()) {\n+            result.combine((CollectionValue<ValidStatementSegment>) visit(each));\n+        }\n+        return result;\n+    }\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public ASTNode visitValidStatement(final ValidStatementContext ctx) {\n+        CollectionValue<ValidStatementSegment> result = new CollectionValue<>();\n+        ValidStatementSegment validStatement = new ValidStatementSegment(ctx.start.getStartIndex(), ctx.stop.getStopIndex());\n+        if (null != ctx.createTable()) {\n+            validStatement.setCreateTable((MySQLCreateTableStatement) visit(ctx.createTable()));\n+            result.getValue().add(validStatement);\n+        } else if (null != ctx.alterTable()) {\n+            validStatement.setAlterTable((MySQLAlterTableStatement) visit(ctx.alterTable()));\n+            result.getValue().add(validStatement);\n+        } else if (null != ctx.dropTable()) {\n+            validStatement.setDropTable((MySQLDropTableStatement) visit(ctx.dropTable()));\n+            result.getValue().add(validStatement);\n+        } else if (null != ctx.truncateTable()) {\n+            validStatement.setTruncate((MySQLTruncateStatement) visit(ctx.truncateTable()));\n+            result.getValue().add(validStatement);\n+        }\n+        if (null != ctx.validDMLStatement()) {\n+            result.combine((CollectionValue<ValidStatementSegment>) visit(ctx.validDMLStatement()));\n+        }\n+        if (null != ctx.beginStatement()) {\n+            result.combine((CollectionValue<ValidStatementSegment>) visit(ctx.beginStatement()));\n+        }\n+        if (null != ctx.flowControlStatement()) {\n+            result.combine((CollectionValue<ValidStatementSegment>) visit(ctx.flowControlStatement()));\n+        }\n+        return result;\n+    }\n+    \n+    @Override\n+    public ASTNode visitValidDMLStatement(final ValidDMLStatementContext ctx) {\n+        CollectionValue<ValidStatementSegment> result = new CollectionValue<>();\n+        ValidStatementSegment validStatement = new ValidStatementSegment(ctx.start.getStartIndex(), ctx.stop.getStopIndex());\n+        if (null != ctx.insert()) {\n+            validStatement.setInsert((MySQLInsertStatement) createParseTreeVisitor(ctx.insert().getClass()).visit(ctx.insert()));\n+        } else if (null != ctx.replace()) {\n+            validStatement.setReplace((MySQLInsertStatement) createParseTreeVisitor(ctx.replace().getClass()).visit(ctx.replace()));\n+        } else if (null != ctx.update()) {\n+            validStatement.setUpdate((MySQLUpdateStatement) createParseTreeVisitor(ctx.update().getClass()).visit(ctx.update()));\n+        } else if (null != ctx.delete()) {\n+            validStatement.setDelete((MySQLDeleteStatement) createParseTreeVisitor(ctx.delete().getClass()).visit(ctx.delete()));\n+        } else if (null != ctx.select()) {\n+            validStatement.setSelect((MySQLSelectStatement) createParseTreeVisitor(ctx.select().getClass()).visit(ctx.select()));\n+        }\n+        result.getValue().add(validStatement);\n+        return result;\n+    }\n+    \n+    @SuppressWarnings(\"rawtypes\")\n+    private ParseTreeVisitor createParseTreeVisitor(final Class<? extends ParseTree> parseTreeClass) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c9bf40034f230ddd78869f5e88ace716cbdf1dad"}, "originalPosition": 191}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDk4NzE3NA==", "bodyText": "I suppose validDMLStatement is just for your convenience.  If  MySQLVisitor contains the content of MySQLDMLStatement, this rule is unneeded, right? As there is no such concept in the SQL grammar of MySQL, I guess.", "url": "https://github.com/apache/shardingsphere/pull/7704#discussion_r500987174", "createdAt": "2020-10-07T12:53:28Z", "author": {"login": "tristaZero"}, "path": "shardingsphere-sql-parser/shardingsphere-sql-parser-dialect/shardingsphere-sql-parser-mysql/src/main/antlr4/imports/mysql/DDLStatement.g4", "diffHunk": "@@ -625,10 +625,13 @@ compoundStatement\n     ;\n \n validStatement\n-    : (createTable | alterTable | dropTable | truncateTable \n-    | insert | replace | update | delete | select | call\n+    : (createTable | alterTable | dropTable | truncateTable | validDMLStatement\n     | setVariable | beginStatement | declareStatement | flowControlStatement | cursorStatement | conditionHandlingStatement) SEMI_?\n     ;\n+    \n+validDMLStatement", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c9bf40034f230ddd78869f5e88ace716cbdf1dad"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDk4ODQxNg==", "bodyText": "A function will make it intelligible. :-)", "url": "https://github.com/apache/shardingsphere/pull/7704#discussion_r500988416", "createdAt": "2020-10-07T12:55:15Z", "author": {"login": "tristaZero"}, "path": "shardingsphere-features/shardingsphere-sharding/shardingsphere-sharding-route/src/main/java/org/apache/shardingsphere/sharding/route/engine/validator/impl/ShardingCreateFunctionStatementValidator.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.shardingsphere.sharding.route.engine.validator.impl;\n+\n+import org.apache.shardingsphere.infra.exception.ShardingSphereException;\n+import org.apache.shardingsphere.infra.metadata.ShardingSphereMetaData;\n+import org.apache.shardingsphere.infra.route.context.RouteContext;\n+import org.apache.shardingsphere.sharding.route.engine.exception.NoSuchTableException;\n+import org.apache.shardingsphere.sharding.route.engine.exception.TableExistsException;\n+import org.apache.shardingsphere.sharding.route.engine.validator.ShardingStatementValidator;\n+import org.apache.shardingsphere.sharding.rule.ShardingRule;\n+import org.apache.shardingsphere.sql.parser.binder.statement.SQLStatementContext;\n+import org.apache.shardingsphere.sql.parser.binder.statement.ddl.CreateFunctionStatementContext;\n+import org.apache.shardingsphere.sql.parser.sql.common.segment.generic.table.SimpleTableSegment;\n+import org.apache.shardingsphere.sql.parser.sql.common.statement.ddl.CreateFunctionStatement;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Sharding create function statement validator.\n+ */\n+public final class ShardingCreateFunctionStatementValidator implements ShardingStatementValidator<CreateFunctionStatement> {\n+    \n+    @Override\n+    public void preValidate(final ShardingRule shardingRule, final SQLStatementContext<CreateFunctionStatement> sqlStatementContext,\n+                            final List<Object> parameters, final ShardingSphereMetaData metaData) {\n+        for (SimpleTableSegment each : ((CreateFunctionStatementContext) sqlStatementContext).getExistTables()) {\n+            String tableName = each.getTableName().getIdentifier().getValue();\n+            if (metaData.getRuleSchemaMetaData().getConfiguredSchemaMetaData().getAllTableNames().contains(tableName)) {\n+                throw new ShardingSphereException(\"Create function statement can not support sharding table '%s'.\", tableName);\n+            }\n+            for (Map.Entry<String, Collection<String>> entry : metaData.getRuleSchemaMetaData().getUnconfiguredSchemaMetaDataMap().entrySet()) {\n+                if (!entry.getValue().contains(tableName)) {\n+                    throw new NoSuchTableException(entry.getKey(), tableName);\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c9bf40034f230ddd78869f5e88ace716cbdf1dad"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDk5MDE3MQ==", "bodyText": "Same. But it is not a big problem.  Just an optional tip.", "url": "https://github.com/apache/shardingsphere/pull/7704#discussion_r500990171", "createdAt": "2020-10-07T12:57:54Z", "author": {"login": "tristaZero"}, "path": "shardingsphere-features/shardingsphere-sharding/shardingsphere-sharding-route/src/main/java/org/apache/shardingsphere/sharding/route/engine/validator/impl/ShardingCreateFunctionStatementValidator.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.shardingsphere.sharding.route.engine.validator.impl;\n+\n+import org.apache.shardingsphere.infra.exception.ShardingSphereException;\n+import org.apache.shardingsphere.infra.metadata.ShardingSphereMetaData;\n+import org.apache.shardingsphere.infra.route.context.RouteContext;\n+import org.apache.shardingsphere.sharding.route.engine.exception.NoSuchTableException;\n+import org.apache.shardingsphere.sharding.route.engine.exception.TableExistsException;\n+import org.apache.shardingsphere.sharding.route.engine.validator.ShardingStatementValidator;\n+import org.apache.shardingsphere.sharding.rule.ShardingRule;\n+import org.apache.shardingsphere.sql.parser.binder.statement.SQLStatementContext;\n+import org.apache.shardingsphere.sql.parser.binder.statement.ddl.CreateFunctionStatementContext;\n+import org.apache.shardingsphere.sql.parser.sql.common.segment.generic.table.SimpleTableSegment;\n+import org.apache.shardingsphere.sql.parser.sql.common.statement.ddl.CreateFunctionStatement;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Sharding create function statement validator.\n+ */\n+public final class ShardingCreateFunctionStatementValidator implements ShardingStatementValidator<CreateFunctionStatement> {\n+    \n+    @Override\n+    public void preValidate(final ShardingRule shardingRule, final SQLStatementContext<CreateFunctionStatement> sqlStatementContext,\n+                            final List<Object> parameters, final ShardingSphereMetaData metaData) {\n+        for (SimpleTableSegment each : ((CreateFunctionStatementContext) sqlStatementContext).getExistTables()) {\n+            String tableName = each.getTableName().getIdentifier().getValue();\n+            if (metaData.getRuleSchemaMetaData().getConfiguredSchemaMetaData().getAllTableNames().contains(tableName)) {\n+                throw new ShardingSphereException(\"Create function statement can not support sharding table '%s'.\", tableName);\n+            }\n+            for (Map.Entry<String, Collection<String>> entry : metaData.getRuleSchemaMetaData().getUnconfiguredSchemaMetaDataMap().entrySet()) {\n+                if (!entry.getValue().contains(tableName)) {\n+                    throw new NoSuchTableException(entry.getKey(), tableName);\n+                }\n+            }\n+        }\n+        for (SimpleTableSegment each : ((CreateFunctionStatementContext) sqlStatementContext).getNotExistTables()) {\n+            String tableName = each.getTableName().getIdentifier().getValue();\n+            if (metaData.getRuleSchemaMetaData().getAllTableNames().contains(tableName)) {\n+                throw new TableExistsException(tableName);\n+            }\n+        }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c9bf40034f230ddd78869f5e88ace716cbdf1dad"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDk5Mjk2OQ==", "bodyText": "From your changes,  I suppose two of there are no more than checking,  aren't they?\nThat way, why do not we move routineBody -> existTables.addAll(extractor.extractExistTableFromRoutineBody(routineBody) to validator?", "url": "https://github.com/apache/shardingsphere/pull/7704#discussion_r500992969", "createdAt": "2020-10-07T13:02:05Z", "author": {"login": "tristaZero"}, "path": "shardingsphere-sql-parser/shardingsphere-sql-parser-binder/src/main/java/org/apache/shardingsphere/sql/parser/binder/statement/ddl/CreateFunctionStatementContext.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.shardingsphere.sql.parser.binder.statement.ddl;\n+\n+import lombok.Getter;\n+import org.apache.shardingsphere.sql.parser.binder.statement.CommonSQLStatementContext;\n+import org.apache.shardingsphere.sql.parser.sql.common.extractor.TableExtractor;\n+import org.apache.shardingsphere.sql.parser.sql.common.segment.ddl.routine.RoutineBodySegment;\n+import org.apache.shardingsphere.sql.parser.sql.common.segment.generic.table.SimpleTableSegment;\n+import org.apache.shardingsphere.sql.parser.sql.common.statement.ddl.CreateFunctionStatement;\n+import org.apache.shardingsphere.sql.parser.sql.dialect.handler.ddl.CreateFunctionStatementHandler;\n+\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.Optional;\n+\n+/**\n+ * Create function statement context.\n+ */\n+@Getter\n+public final class CreateFunctionStatementContext extends CommonSQLStatementContext<CreateFunctionStatement> {\n+    \n+    private final Collection<SimpleTableSegment> existTables = new LinkedList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c9bf40034f230ddd78869f5e88ace716cbdf1dad"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTAwMzgyMw==", "bodyText": "There only will be one of them at a time, right?  Plus, currently, do we indeed care about the concrete class type of this object?  I mean, do you think it is possible to merge them as a SQLStatement?", "url": "https://github.com/apache/shardingsphere/pull/7704#discussion_r501003823", "createdAt": "2020-10-07T13:17:51Z", "author": {"login": "tristaZero"}, "path": "shardingsphere-sql-parser/shardingsphere-sql-parser-statement/src/main/java/org/apache/shardingsphere/sql/parser/sql/common/segment/ddl/routine/ValidStatementSegment.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.shardingsphere.sql.parser.sql.common.segment.ddl.routine;\n+\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.Setter;\n+import org.apache.shardingsphere.sql.parser.sql.common.segment.SQLSegment;\n+import org.apache.shardingsphere.sql.parser.sql.common.statement.ddl.AlterTableStatement;\n+import org.apache.shardingsphere.sql.parser.sql.common.statement.ddl.CreateTableStatement;\n+import org.apache.shardingsphere.sql.parser.sql.common.statement.ddl.DropTableStatement;\n+import org.apache.shardingsphere.sql.parser.sql.common.statement.ddl.TruncateStatement;\n+import org.apache.shardingsphere.sql.parser.sql.common.statement.dml.DeleteStatement;\n+import org.apache.shardingsphere.sql.parser.sql.common.statement.dml.InsertStatement;\n+import org.apache.shardingsphere.sql.parser.sql.common.statement.dml.SelectStatement;\n+import org.apache.shardingsphere.sql.parser.sql.common.statement.dml.UpdateStatement;\n+\n+import java.util.Optional;\n+\n+/**\n+ * Valid statement segment.\n+ */\n+@RequiredArgsConstructor\n+@Getter\n+@Setter\n+public class ValidStatementSegment implements SQLSegment {\n+    \n+    private final int startIndex;\n+    \n+    private final int stopIndex;\n+    \n+    private CreateTableStatement createTable;\n+    \n+    private AlterTableStatement alterTable;\n+    \n+    private DropTableStatement dropTable;\n+    \n+    private TruncateStatement truncate;\n+    \n+    private InsertStatement insert;\n+    \n+    private InsertStatement replace;\n+    \n+    private UpdateStatement update;\n+    \n+    private DeleteStatement delete;\n+    \n+    private SelectStatement select;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c9bf40034f230ddd78869f5e88ace716cbdf1dad"}, "originalPosition": 63}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0NDEwMzc5", "url": "https://github.com/apache/shardingsphere/pull/7704#pullrequestreview-504410379", "createdAt": "2020-10-08T03:51:23Z", "commit": {"oid": "c9bf40034f230ddd78869f5e88ace716cbdf1dad"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQwMzo1MToyM1rOHeNBjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOFQwNDoxMjozMVrOHeNUqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQzMjcxOA==", "bodyText": "we need to extract the tables contained in the various statements during parsing.\n\nI think the visitor handling could retain the same, even though here its member is SQLStatement.\nWe should visit out the concrete SQLStatement, IMO, since that is in line with its g4 definition. However, I wonder whether a generic SQLStatment instead of a list of possible types is adequate to reflect its composition. What's more, the following functions like getCreateTable() seem to help give more descriptions of a SQLStatement to the outer calls.\nIt seems these public functions rather than its members are more likely to be called,  doesn't it?  That way, do you think this list of member options seems a lit bloated (as you said before:-))?", "url": "https://github.com/apache/shardingsphere/pull/7704#discussion_r501432718", "createdAt": "2020-10-08T03:51:23Z", "author": {"login": "tristaZero"}, "path": "shardingsphere-sql-parser/shardingsphere-sql-parser-statement/src/main/java/org/apache/shardingsphere/sql/parser/sql/common/segment/ddl/routine/ValidStatementSegment.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.shardingsphere.sql.parser.sql.common.segment.ddl.routine;\n+\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.Setter;\n+import org.apache.shardingsphere.sql.parser.sql.common.segment.SQLSegment;\n+import org.apache.shardingsphere.sql.parser.sql.common.statement.ddl.AlterTableStatement;\n+import org.apache.shardingsphere.sql.parser.sql.common.statement.ddl.CreateTableStatement;\n+import org.apache.shardingsphere.sql.parser.sql.common.statement.ddl.DropTableStatement;\n+import org.apache.shardingsphere.sql.parser.sql.common.statement.ddl.TruncateStatement;\n+import org.apache.shardingsphere.sql.parser.sql.common.statement.dml.DeleteStatement;\n+import org.apache.shardingsphere.sql.parser.sql.common.statement.dml.InsertStatement;\n+import org.apache.shardingsphere.sql.parser.sql.common.statement.dml.SelectStatement;\n+import org.apache.shardingsphere.sql.parser.sql.common.statement.dml.UpdateStatement;\n+\n+import java.util.Optional;\n+\n+/**\n+ * Valid statement segment.\n+ */\n+@RequiredArgsConstructor\n+@Getter\n+@Setter\n+public class ValidStatementSegment implements SQLSegment {\n+    \n+    private final int startIndex;\n+    \n+    private final int stopIndex;\n+    \n+    private CreateTableStatement createTable;\n+    \n+    private AlterTableStatement alterTable;\n+    \n+    private DropTableStatement dropTable;\n+    \n+    private TruncateStatement truncate;\n+    \n+    private InsertStatement insert;\n+    \n+    private InsertStatement replace;\n+    \n+    private UpdateStatement update;\n+    \n+    private DeleteStatement delete;\n+    \n+    private SelectStatement select;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTAwMzgyMw=="}, "originalCommit": {"oid": "c9bf40034f230ddd78869f5e88ace716cbdf1dad"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQzNzYwOA==", "bodyText": "Yep, I buy that  MySQLVisitor is supposed to contain the generic functions and items. But if MySQLDDLVisitor needs to use these functions of MySQLDMLVisitor,  the relevant ones will become shared one for DMLVisitor and DDLVisitor, and is possible to move them to MySQLVisitor, though which will create a bloated father class.\nWhat's more, as you know, the currentParameterIndex makes MySQLVisitor not as a simple utility. If you create a new instance of DMLVisitor in DDLVisitor, I guess there will be an incorrect parameterIndex.\nHonestly speaking, I have no better method to handle this issue. :-(\nActually, for some of the other SQL parser engines like druid or hive, they put all the visitors and g4 files together, as they do not have a complete and an awful lot of SQL definitions. \ud83d\ude05", "url": "https://github.com/apache/shardingsphere/pull/7704#discussion_r501437608", "createdAt": "2020-10-08T04:12:31Z", "author": {"login": "tristaZero"}, "path": "shardingsphere-sql-parser/shardingsphere-sql-parser-dialect/shardingsphere-sql-parser-mysql/src/main/java/org/apache/shardingsphere/sql/parser/mysql/visitor/impl/MySQLDDLVisitor.java", "diffHunk": "@@ -461,92 +483,256 @@ public ASTNode visitKeyParts_(final KeyParts_Context ctx) {\n         }\n         return result;\n     }\n-\n+    \n     @Override\n     public ASTNode visitCreateProcedure(final CreateProcedureContext ctx) {\n-        return new MySQLCreateProcedureStatement();\n+        MySQLCreateProcedureStatement result = new MySQLCreateProcedureStatement();\n+        result.setRoutineBody((RoutineBodySegment) visit(ctx.routineBody()));\n+        return result;\n     }\n-\n+    \n     @Override\n     public ASTNode visitAlterProcedure(final AlterProcedureContext ctx) {\n         return new MySQLAlterProcedureStatement();\n     }\n-\n+    \n     @Override\n     public ASTNode visitDropProcedure(final DropProcedureContext ctx) {\n         return new MySQLDropProcedureStatement();\n     }\n-\n+    \n     @Override\n     public ASTNode visitCreateFunction(final CreateFunctionContext ctx) {\n-        return new MySQLCreateFunctionStatement();\n+        MySQLCreateFunctionStatement result = new MySQLCreateFunctionStatement();\n+        result.setRoutineBody((RoutineBodySegment) visit(ctx.routineBody()));\n+        return result;\n     }\n-\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public ASTNode visitRoutineBody(final RoutineBodyContext ctx) {\n+        RoutineBodySegment result = new RoutineBodySegment(ctx.start.getStartIndex(), ctx.stop.getStopIndex());\n+        CollectionValue<ValidStatementSegment> validStatements;\n+        if (null != ctx.simpleStatement()) {\n+            validStatements = (CollectionValue<ValidStatementSegment>) visit(ctx.simpleStatement());\n+        } else {\n+            validStatements = (CollectionValue<ValidStatementSegment>) visit(ctx.compoundStatement());\n+        }\n+        result.getValidStatements().addAll(validStatements.getValue());\n+        return result;\n+    }\n+    \n+    @Override\n+    public ASTNode visitSimpleStatement(final SimpleStatementContext ctx) {\n+        return visit(ctx.validStatement());\n+    }\n+    \n+    @Override\n+    public ASTNode visitCompoundStatement(final CompoundStatementContext ctx) {\n+        return visit(ctx.beginStatement());\n+    }\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public ASTNode visitBeginStatement(final BeginStatementContext ctx) {\n+        CollectionValue<ValidStatementSegment> result = new CollectionValue<>();\n+        for (ValidStatementContext each : ctx.validStatement()) {\n+            result.combine((CollectionValue<ValidStatementSegment>) visit(each));\n+        }\n+        return result;\n+    }\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public ASTNode visitValidStatement(final ValidStatementContext ctx) {\n+        CollectionValue<ValidStatementSegment> result = new CollectionValue<>();\n+        ValidStatementSegment validStatement = new ValidStatementSegment(ctx.start.getStartIndex(), ctx.stop.getStopIndex());\n+        if (null != ctx.createTable()) {\n+            validStatement.setCreateTable((MySQLCreateTableStatement) visit(ctx.createTable()));\n+            result.getValue().add(validStatement);\n+        } else if (null != ctx.alterTable()) {\n+            validStatement.setAlterTable((MySQLAlterTableStatement) visit(ctx.alterTable()));\n+            result.getValue().add(validStatement);\n+        } else if (null != ctx.dropTable()) {\n+            validStatement.setDropTable((MySQLDropTableStatement) visit(ctx.dropTable()));\n+            result.getValue().add(validStatement);\n+        } else if (null != ctx.truncateTable()) {\n+            validStatement.setTruncate((MySQLTruncateStatement) visit(ctx.truncateTable()));\n+            result.getValue().add(validStatement);\n+        }\n+        if (null != ctx.validDMLStatement()) {\n+            result.combine((CollectionValue<ValidStatementSegment>) visit(ctx.validDMLStatement()));\n+        }\n+        if (null != ctx.beginStatement()) {\n+            result.combine((CollectionValue<ValidStatementSegment>) visit(ctx.beginStatement()));\n+        }\n+        if (null != ctx.flowControlStatement()) {\n+            result.combine((CollectionValue<ValidStatementSegment>) visit(ctx.flowControlStatement()));\n+        }\n+        return result;\n+    }\n+    \n+    @Override\n+    public ASTNode visitValidDMLStatement(final ValidDMLStatementContext ctx) {\n+        CollectionValue<ValidStatementSegment> result = new CollectionValue<>();\n+        ValidStatementSegment validStatement = new ValidStatementSegment(ctx.start.getStartIndex(), ctx.stop.getStopIndex());\n+        if (null != ctx.insert()) {\n+            validStatement.setInsert((MySQLInsertStatement) createParseTreeVisitor(ctx.insert().getClass()).visit(ctx.insert()));\n+        } else if (null != ctx.replace()) {\n+            validStatement.setReplace((MySQLInsertStatement) createParseTreeVisitor(ctx.replace().getClass()).visit(ctx.replace()));\n+        } else if (null != ctx.update()) {\n+            validStatement.setUpdate((MySQLUpdateStatement) createParseTreeVisitor(ctx.update().getClass()).visit(ctx.update()));\n+        } else if (null != ctx.delete()) {\n+            validStatement.setDelete((MySQLDeleteStatement) createParseTreeVisitor(ctx.delete().getClass()).visit(ctx.delete()));\n+        } else if (null != ctx.select()) {\n+            validStatement.setSelect((MySQLSelectStatement) createParseTreeVisitor(ctx.select().getClass()).visit(ctx.select()));\n+        }\n+        result.getValue().add(validStatement);\n+        return result;\n+    }\n+    \n+    @SuppressWarnings(\"rawtypes\")\n+    private ParseTreeVisitor createParseTreeVisitor(final Class<? extends ParseTree> parseTreeClass) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDk4Mzc4Nw=="}, "originalCommit": {"oid": "c9bf40034f230ddd78869f5e88ace716cbdf1dad"}, "originalPosition": 191}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "17a9e2eff8ceb0bad8a73b8c7e4efb4bca3ac4b0", "author": {"user": {"login": "strongduanmu", "name": "Zhengqiang Duan"}}, "url": "https://github.com/apache/shardingsphere/commit/17a9e2eff8ceb0bad8a73b8c7e4efb4bca3ac4b0", "committedDate": "2020-10-08T15:13:38Z", "message": "optimize create function and procedure validator"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA1MzU4MTA0", "url": "https://github.com/apache/shardingsphere/pull/7704#pullrequestreview-505358104", "createdAt": "2020-10-09T04:37:15Z", "commit": {"oid": "17a9e2eff8ceb0bad8a73b8c7e4efb4bca3ac4b0"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3953, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}