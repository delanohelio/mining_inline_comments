{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAxOTE0NzMy", "number": 2000, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QwOTo0MjozMFrOEs9KfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QwOTo1ODo0NlrOEs9j2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1NTc0OTA5OnYy", "diffSide": "RIGHT", "path": "dependencies/bom/pom.xml", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QwOTo0MjozMFrOHgeVSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQwMzo0MToyM1rOHhBDEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzgxMzQ0OQ==", "bodyText": "delete this", "url": "https://github.com/apache/servicecomb-java-chassis/pull/2000#discussion_r503813449", "createdAt": "2020-10-13T09:42:30Z", "author": {"login": "liubao68"}, "path": "dependencies/bom/pom.xml", "diffHunk": "@@ -174,6 +174,11 @@\n         <artifactId>foundation-vertx</artifactId>\n         <version>${project.version}</version>\n       </dependency>\n+      <dependency>\n+        <groupId>org.apache.servicecomb</groupId>\n+        <artifactId>foundation-auth</artifactId>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a83440f7cf9303935be433ceb31e9e4588a7f10"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDM4MjIyNA==", "bodyText": "done", "url": "https://github.com/apache/servicecomb-java-chassis/pull/2000#discussion_r504382224", "createdAt": "2020-10-14T03:41:23Z", "author": {"login": "jeho0815"}, "path": "dependencies/bom/pom.xml", "diffHunk": "@@ -174,6 +174,11 @@\n         <artifactId>foundation-vertx</artifactId>\n         <version>${project.version}</version>\n       </dependency>\n+      <dependency>\n+        <groupId>org.apache.servicecomb</groupId>\n+        <artifactId>foundation-auth</artifactId>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzgxMzQ0OQ=="}, "originalCommit": {"oid": "1a83440f7cf9303935be433ceb31e9e4588a7f10"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1NTc5NDg1OnYy", "diffSide": "RIGHT", "path": "service-registry/registry-service-center/src/main/java/org/apache/servicecomb/serviceregistry/auth/TokenAuthHeaderProvider.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QwOTo1Mzo0OVrOHgex3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQwMzo0MjozOVrOHhBEaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzgyMDc2NQ==", "bodyText": "registryName need support configuration", "url": "https://github.com/apache/servicecomb-java-chassis/pull/2000#discussion_r503820765", "createdAt": "2020-10-13T09:53:49Z", "author": {"login": "liubao68"}, "path": "service-registry/registry-service-center/src/main/java/org/apache/servicecomb/serviceregistry/auth/TokenAuthHeaderProvider.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.servicecomb.serviceregistry.auth;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.servicecomb.foundation.auth.AuthHeaderProvider;\n+import org.apache.servicecomb.foundation.auth.Cipher;\n+import org.apache.servicecomb.foundation.auth.DefaultCipher;\n+import org.apache.servicecomb.foundation.common.utils.BeanUtils;\n+import org.apache.servicecomb.serviceregistry.ServiceRegistry;\n+\n+import com.netflix.config.DynamicPropertyFactory;\n+\n+public class TokenAuthHeaderProvider implements AuthHeaderProvider {\n+  public static final String ACCOUNT_NAME_KEY = \"servicecomb.credentials.account.name\";\n+\n+  public static final String PASSWORD_KEY = \"servicecomb.credentials.account.password\";\n+\n+  public static final String CIPHER_KEY = \"servicecomb.credentials.cipher\";\n+\n+  private String registryName;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a83440f7cf9303935be433ceb31e9e4588a7f10"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDM4MjU2OA==", "bodyText": "the default constructor use the default name, if somebody want to use multi servicecenter, the can use TokenAuthHeaderProvider(String registryName, String accountName, String password, String cipherName)", "url": "https://github.com/apache/servicecomb-java-chassis/pull/2000#discussion_r504382568", "createdAt": "2020-10-14T03:42:39Z", "author": {"login": "jeho0815"}, "path": "service-registry/registry-service-center/src/main/java/org/apache/servicecomb/serviceregistry/auth/TokenAuthHeaderProvider.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.servicecomb.serviceregistry.auth;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.servicecomb.foundation.auth.AuthHeaderProvider;\n+import org.apache.servicecomb.foundation.auth.Cipher;\n+import org.apache.servicecomb.foundation.auth.DefaultCipher;\n+import org.apache.servicecomb.foundation.common.utils.BeanUtils;\n+import org.apache.servicecomb.serviceregistry.ServiceRegistry;\n+\n+import com.netflix.config.DynamicPropertyFactory;\n+\n+public class TokenAuthHeaderProvider implements AuthHeaderProvider {\n+  public static final String ACCOUNT_NAME_KEY = \"servicecomb.credentials.account.name\";\n+\n+  public static final String PASSWORD_KEY = \"servicecomb.credentials.account.password\";\n+\n+  public static final String CIPHER_KEY = \"servicecomb.credentials.cipher\";\n+\n+  private String registryName;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzgyMDc2NQ=="}, "originalCommit": {"oid": "1a83440f7cf9303935be433ceb31e9e4588a7f10"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1NTc5ODQ0OnYy", "diffSide": "RIGHT", "path": "service-registry/registry-service-center/src/main/java/org/apache/servicecomb/serviceregistry/auth/TokenAuthHeaderProvider.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QwOTo1NDo0NlrOHge0NA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQwMzo0MzoxOVrOHhBFFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzgyMTM2NA==", "bodyText": "This constructor never used, can be deleted", "url": "https://github.com/apache/servicecomb-java-chassis/pull/2000#discussion_r503821364", "createdAt": "2020-10-13T09:54:46Z", "author": {"login": "liubao68"}, "path": "service-registry/registry-service-center/src/main/java/org/apache/servicecomb/serviceregistry/auth/TokenAuthHeaderProvider.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.servicecomb.serviceregistry.auth;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.servicecomb.foundation.auth.AuthHeaderProvider;\n+import org.apache.servicecomb.foundation.auth.Cipher;\n+import org.apache.servicecomb.foundation.auth.DefaultCipher;\n+import org.apache.servicecomb.foundation.common.utils.BeanUtils;\n+import org.apache.servicecomb.serviceregistry.ServiceRegistry;\n+\n+import com.netflix.config.DynamicPropertyFactory;\n+\n+public class TokenAuthHeaderProvider implements AuthHeaderProvider {\n+  public static final String ACCOUNT_NAME_KEY = \"servicecomb.credentials.account.name\";\n+\n+  public static final String PASSWORD_KEY = \"servicecomb.credentials.account.password\";\n+\n+  public static final String CIPHER_KEY = \"servicecomb.credentials.cipher\";\n+\n+  private String registryName;\n+\n+  private String accountName;\n+\n+  private String password;\n+\n+  private String cipherName;\n+\n+  public TokenAuthHeaderProvider() {\n+    this.registryName = ServiceRegistry.DEFAULT_REGISTRY_NAME;\n+    this.accountName = DynamicPropertyFactory.getInstance()\n+        .getStringProperty(ACCOUNT_NAME_KEY, null).get();\n+    this.password = DynamicPropertyFactory.getInstance()\n+        .getStringProperty(PASSWORD_KEY, null).get();\n+    this.cipherName = DynamicPropertyFactory.getInstance()\n+        .getStringProperty(CIPHER_KEY, DefaultCipher.DEFAULT_CYPHER).get();\n+    if (StringUtils.isNotEmpty(accountName)) {\n+      TokenCacheManager.getInstance().addTokenCache(registryName, accountName, password, getCipher());\n+    }\n+  }\n+\n+  public TokenAuthHeaderProvider(String registryName, String accountName, String password, String cipherName) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a83440f7cf9303935be433ceb31e9e4588a7f10"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDM4Mjc0Mg==", "bodyText": "this is used to multi service center scence", "url": "https://github.com/apache/servicecomb-java-chassis/pull/2000#discussion_r504382742", "createdAt": "2020-10-14T03:43:19Z", "author": {"login": "jeho0815"}, "path": "service-registry/registry-service-center/src/main/java/org/apache/servicecomb/serviceregistry/auth/TokenAuthHeaderProvider.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.servicecomb.serviceregistry.auth;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.servicecomb.foundation.auth.AuthHeaderProvider;\n+import org.apache.servicecomb.foundation.auth.Cipher;\n+import org.apache.servicecomb.foundation.auth.DefaultCipher;\n+import org.apache.servicecomb.foundation.common.utils.BeanUtils;\n+import org.apache.servicecomb.serviceregistry.ServiceRegistry;\n+\n+import com.netflix.config.DynamicPropertyFactory;\n+\n+public class TokenAuthHeaderProvider implements AuthHeaderProvider {\n+  public static final String ACCOUNT_NAME_KEY = \"servicecomb.credentials.account.name\";\n+\n+  public static final String PASSWORD_KEY = \"servicecomb.credentials.account.password\";\n+\n+  public static final String CIPHER_KEY = \"servicecomb.credentials.cipher\";\n+\n+  private String registryName;\n+\n+  private String accountName;\n+\n+  private String password;\n+\n+  private String cipherName;\n+\n+  public TokenAuthHeaderProvider() {\n+    this.registryName = ServiceRegistry.DEFAULT_REGISTRY_NAME;\n+    this.accountName = DynamicPropertyFactory.getInstance()\n+        .getStringProperty(ACCOUNT_NAME_KEY, null).get();\n+    this.password = DynamicPropertyFactory.getInstance()\n+        .getStringProperty(PASSWORD_KEY, null).get();\n+    this.cipherName = DynamicPropertyFactory.getInstance()\n+        .getStringProperty(CIPHER_KEY, DefaultCipher.DEFAULT_CYPHER).get();\n+    if (StringUtils.isNotEmpty(accountName)) {\n+      TokenCacheManager.getInstance().addTokenCache(registryName, accountName, password, getCipher());\n+    }\n+  }\n+\n+  public TokenAuthHeaderProvider(String registryName, String accountName, String password, String cipherName) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzgyMTM2NA=="}, "originalCommit": {"oid": "1a83440f7cf9303935be433ceb31e9e4588a7f10"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1NTgxNDAyOnYy", "diffSide": "RIGHT", "path": "service-registry/registry-service-center/src/main/java/org/apache/servicecomb/serviceregistry/auth/TokenCacheManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xM1QwOTo1ODo0NlrOHge97g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNFQwMzo0MzozNFrOHhBFUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzgyMzg1NA==", "bodyText": "should not retry when using old version of service center and stop scheduler service", "url": "https://github.com/apache/servicecomb-java-chassis/pull/2000#discussion_r503823854", "createdAt": "2020-10-13T09:58:46Z", "author": {"login": "liubao68"}, "path": "service-registry/registry-service-center/src/main/java/org/apache/servicecomb/serviceregistry/auth/TokenCacheManager.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.servicecomb.serviceregistry.auth;\n+\n+import java.time.Clock;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import javax.annotation.Nonnull;\n+import javax.ws.rs.core.Response.Status;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.servicecomb.foundation.auth.Cipher;\n+import org.apache.servicecomb.foundation.common.concurrency.SuppressedRunnableWrapper;\n+import org.apache.servicecomb.foundation.common.concurrent.ConcurrentHashMapEx;\n+import org.apache.servicecomb.foundation.common.utils.TimeUtils;\n+import org.apache.servicecomb.foundation.vertx.client.http.HttpClients;\n+import org.apache.servicecomb.serviceregistry.RegistryUtils;\n+import org.apache.servicecomb.serviceregistry.ServiceRegistry;\n+import org.apache.servicecomb.serviceregistry.api.request.RbacTokenRequest;\n+import org.apache.servicecomb.serviceregistry.api.response.RbacTokenResponse;\n+import org.apache.servicecomb.serviceregistry.client.ServiceRegistryClient;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public final class TokenCacheManager {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(TokenCacheManager.class);\n+\n+  private static final TokenCacheManager INSTANCE = new TokenCacheManager();\n+\n+  private Clock clock = TimeUtils.getSystemDefaultZoneClock();\n+\n+  private ScheduledExecutorService tokenCacheWorker;\n+\n+  private Map<String, TokenCache> tokenCacheMap;\n+\n+  public static TokenCacheManager getInstance() {\n+    return INSTANCE;\n+  }\n+\n+  private TokenCacheManager() {\n+    tokenCacheWorker = Executors.newScheduledThreadPool(2, new ThreadFactory() {\n+      private final AtomicInteger threadIndexer = new AtomicInteger();\n+\n+      @Override\n+      public Thread newThread(@Nonnull Runnable r) {\n+        Thread thread = new Thread(r, \"auth-token-cache-\" + threadIndexer.getAndIncrement());\n+        thread.setDaemon(true);\n+        return thread;\n+      }\n+    });\n+    tokenCacheMap = new ConcurrentHashMapEx<>();\n+  }\n+\n+  public void addTokenCache(String registryName, String accountName, String password, Cipher cipher) {\n+    Objects.requireNonNull(registryName, \"registryName should not be null!\");\n+    if (tokenCacheMap.containsKey(registryName)) {\n+      LOGGER.warn(\"duplicate token cache registration for serviceRegistry[{}]\", registryName);\n+      return;\n+    }\n+\n+    TokenCache tokenCache = new TokenCache(registryName, accountName, password, cipher, this.clock);\n+    tokenCache.setTokenCacheWorker(this.tokenCacheWorker);\n+    tokenCacheMap.put(registryName, tokenCache);\n+    HttpClients.load();\n+    RegistryUtils.init();\n+    tokenCache.refreshToken();\n+  }\n+\n+  public String getToken(String registryName) {\n+    return Optional.ofNullable(tokenCacheMap.get(registryName))\n+        .map(TokenCache::getToken)\n+        .orElse(\"\");\n+  }\n+\n+  public static class TokenCache {\n+    private final String registryName;\n+\n+    private final String accountName;\n+\n+    private final String password;\n+\n+    private final Clock clock;\n+\n+    private String token;\n+\n+    private long nextRefreshTime;\n+\n+    private boolean wrongPassword;\n+\n+    /**\n+     * The life cycle period of a token, in millisecond.\n+     * After the {@code tokenLife} time since the token created, it should be refreshed.\n+     * <p>\n+     * Default life time in sc is 30min, give 2min buffer\n+     * </p>\n+     */\n+    private long tokenLife = TimeUnit.MINUTES.toMillis(30 - 2);\n+\n+    private ScheduledExecutorService tokenCacheWorker;\n+\n+    private Cipher cipher;\n+\n+    public TokenCache(String registryName, String accountName, String password,\n+        Cipher cipher, Clock clock) {\n+      this.registryName = registryName;\n+      this.accountName = accountName;\n+      this.password = password;\n+      this.cipher = cipher;\n+      this.clock = clock;\n+    }\n+\n+    public String getToken() {\n+      return token == null ? \"\" : token;\n+    }\n+\n+    public void setTokenCacheWorker(ScheduledExecutorService tokenCacheWorker) {\n+      Objects.requireNonNull(tokenCacheWorker, \"input tokenCacheWorker is null\");\n+      if (this.tokenCacheWorker != null) {\n+        throw new IllegalStateException(\"tokenCacheWorker already set!\");\n+      }\n+\n+      this.tokenCacheWorker = tokenCacheWorker;\n+      startTokenRefreshTask();\n+    }\n+\n+    private void startTokenRefreshTask() {\n+      this.tokenCacheWorker.scheduleAtFixedRate(\n+          new SuppressedRunnableWrapper(() -> {\n+            if (isTokenOutdated()) {\n+              refreshToken();\n+            }\n+          }),\n+          1,\n+          5,\n+          TimeUnit.SECONDS);\n+    }\n+\n+    private boolean isTokenOutdated() {\n+      return clock.millis() > nextRefreshTime;\n+    }\n+\n+    private void refreshToken() {\n+      if (wrongPassword) {\n+        return;\n+      }\n+      ServiceRegistry serviceRegistry = RegistryUtils.getServiceRegistry(registryName);\n+      ServiceRegistryClient serviceRegistryClient =\n+          serviceRegistry == null ? null : serviceRegistry.getServiceRegistryClient();\n+      if ((serviceRegistry == null || serviceRegistryClient == null)\n+          && ServiceRegistry.DEFAULT_REGISTRY_NAME.equals(registryName)) {\n+        LOGGER.error(\"failed to get default serviceRegistry\");\n+        tokenCacheWorker.schedule( // retry after 1 second\n+            this::refreshToken, 1, TimeUnit.SECONDS);\n+        return;\n+      }\n+      RbacTokenRequest request = new RbacTokenRequest();\n+      request.setAccountName(new String(cipher.decrypt(accountName.toCharArray())));\n+      request.setPassword(new String(cipher.decrypt(password.toCharArray())));\n+      RbacTokenResponse rbacTokenResponse = serviceRegistryClient.getRbacToken(request);\n+      LOGGER.info(\"refresh token successfully {}\", rbacTokenResponse.getStatusCode());\n+      if (StringUtils.isEmpty(this.token) && Status.UNAUTHORIZED.getStatusCode() == rbacTokenResponse.getStatusCode()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a83440f7cf9303935be433ceb31e9e4588a7f10"}, "originalPosition": 183}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDM4MjgwMg==", "bodyText": "done", "url": "https://github.com/apache/servicecomb-java-chassis/pull/2000#discussion_r504382802", "createdAt": "2020-10-14T03:43:34Z", "author": {"login": "jeho0815"}, "path": "service-registry/registry-service-center/src/main/java/org/apache/servicecomb/serviceregistry/auth/TokenCacheManager.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.servicecomb.serviceregistry.auth;\n+\n+import java.time.Clock;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import javax.annotation.Nonnull;\n+import javax.ws.rs.core.Response.Status;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.servicecomb.foundation.auth.Cipher;\n+import org.apache.servicecomb.foundation.common.concurrency.SuppressedRunnableWrapper;\n+import org.apache.servicecomb.foundation.common.concurrent.ConcurrentHashMapEx;\n+import org.apache.servicecomb.foundation.common.utils.TimeUtils;\n+import org.apache.servicecomb.foundation.vertx.client.http.HttpClients;\n+import org.apache.servicecomb.serviceregistry.RegistryUtils;\n+import org.apache.servicecomb.serviceregistry.ServiceRegistry;\n+import org.apache.servicecomb.serviceregistry.api.request.RbacTokenRequest;\n+import org.apache.servicecomb.serviceregistry.api.response.RbacTokenResponse;\n+import org.apache.servicecomb.serviceregistry.client.ServiceRegistryClient;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public final class TokenCacheManager {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(TokenCacheManager.class);\n+\n+  private static final TokenCacheManager INSTANCE = new TokenCacheManager();\n+\n+  private Clock clock = TimeUtils.getSystemDefaultZoneClock();\n+\n+  private ScheduledExecutorService tokenCacheWorker;\n+\n+  private Map<String, TokenCache> tokenCacheMap;\n+\n+  public static TokenCacheManager getInstance() {\n+    return INSTANCE;\n+  }\n+\n+  private TokenCacheManager() {\n+    tokenCacheWorker = Executors.newScheduledThreadPool(2, new ThreadFactory() {\n+      private final AtomicInteger threadIndexer = new AtomicInteger();\n+\n+      @Override\n+      public Thread newThread(@Nonnull Runnable r) {\n+        Thread thread = new Thread(r, \"auth-token-cache-\" + threadIndexer.getAndIncrement());\n+        thread.setDaemon(true);\n+        return thread;\n+      }\n+    });\n+    tokenCacheMap = new ConcurrentHashMapEx<>();\n+  }\n+\n+  public void addTokenCache(String registryName, String accountName, String password, Cipher cipher) {\n+    Objects.requireNonNull(registryName, \"registryName should not be null!\");\n+    if (tokenCacheMap.containsKey(registryName)) {\n+      LOGGER.warn(\"duplicate token cache registration for serviceRegistry[{}]\", registryName);\n+      return;\n+    }\n+\n+    TokenCache tokenCache = new TokenCache(registryName, accountName, password, cipher, this.clock);\n+    tokenCache.setTokenCacheWorker(this.tokenCacheWorker);\n+    tokenCacheMap.put(registryName, tokenCache);\n+    HttpClients.load();\n+    RegistryUtils.init();\n+    tokenCache.refreshToken();\n+  }\n+\n+  public String getToken(String registryName) {\n+    return Optional.ofNullable(tokenCacheMap.get(registryName))\n+        .map(TokenCache::getToken)\n+        .orElse(\"\");\n+  }\n+\n+  public static class TokenCache {\n+    private final String registryName;\n+\n+    private final String accountName;\n+\n+    private final String password;\n+\n+    private final Clock clock;\n+\n+    private String token;\n+\n+    private long nextRefreshTime;\n+\n+    private boolean wrongPassword;\n+\n+    /**\n+     * The life cycle period of a token, in millisecond.\n+     * After the {@code tokenLife} time since the token created, it should be refreshed.\n+     * <p>\n+     * Default life time in sc is 30min, give 2min buffer\n+     * </p>\n+     */\n+    private long tokenLife = TimeUnit.MINUTES.toMillis(30 - 2);\n+\n+    private ScheduledExecutorService tokenCacheWorker;\n+\n+    private Cipher cipher;\n+\n+    public TokenCache(String registryName, String accountName, String password,\n+        Cipher cipher, Clock clock) {\n+      this.registryName = registryName;\n+      this.accountName = accountName;\n+      this.password = password;\n+      this.cipher = cipher;\n+      this.clock = clock;\n+    }\n+\n+    public String getToken() {\n+      return token == null ? \"\" : token;\n+    }\n+\n+    public void setTokenCacheWorker(ScheduledExecutorService tokenCacheWorker) {\n+      Objects.requireNonNull(tokenCacheWorker, \"input tokenCacheWorker is null\");\n+      if (this.tokenCacheWorker != null) {\n+        throw new IllegalStateException(\"tokenCacheWorker already set!\");\n+      }\n+\n+      this.tokenCacheWorker = tokenCacheWorker;\n+      startTokenRefreshTask();\n+    }\n+\n+    private void startTokenRefreshTask() {\n+      this.tokenCacheWorker.scheduleAtFixedRate(\n+          new SuppressedRunnableWrapper(() -> {\n+            if (isTokenOutdated()) {\n+              refreshToken();\n+            }\n+          }),\n+          1,\n+          5,\n+          TimeUnit.SECONDS);\n+    }\n+\n+    private boolean isTokenOutdated() {\n+      return clock.millis() > nextRefreshTime;\n+    }\n+\n+    private void refreshToken() {\n+      if (wrongPassword) {\n+        return;\n+      }\n+      ServiceRegistry serviceRegistry = RegistryUtils.getServiceRegistry(registryName);\n+      ServiceRegistryClient serviceRegistryClient =\n+          serviceRegistry == null ? null : serviceRegistry.getServiceRegistryClient();\n+      if ((serviceRegistry == null || serviceRegistryClient == null)\n+          && ServiceRegistry.DEFAULT_REGISTRY_NAME.equals(registryName)) {\n+        LOGGER.error(\"failed to get default serviceRegistry\");\n+        tokenCacheWorker.schedule( // retry after 1 second\n+            this::refreshToken, 1, TimeUnit.SECONDS);\n+        return;\n+      }\n+      RbacTokenRequest request = new RbacTokenRequest();\n+      request.setAccountName(new String(cipher.decrypt(accountName.toCharArray())));\n+      request.setPassword(new String(cipher.decrypt(password.toCharArray())));\n+      RbacTokenResponse rbacTokenResponse = serviceRegistryClient.getRbacToken(request);\n+      LOGGER.info(\"refresh token successfully {}\", rbacTokenResponse.getStatusCode());\n+      if (StringUtils.isEmpty(this.token) && Status.UNAUTHORIZED.getStatusCode() == rbacTokenResponse.getStatusCode()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzgyMzg1NA=="}, "originalCommit": {"oid": "1a83440f7cf9303935be433ceb31e9e4588a7f10"}, "originalPosition": 183}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1238, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}