{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIwNDM1MjYz", "number": 1766, "reviewThreads": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwMTozODowMlrOD-B36w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwODoyNjowNFrOD-HF3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MzY5MDAzOnYy", "diffSide": "RIGHT", "path": "service-registry/registry-zero-config/src/test/java/org/apache/servicecomb/serviceregistry/client/TestZeroConfigRegistryClientImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwMTozODowMlrOGX4VZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwMjozMzo0OFrOGX5Oig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY5MzQxMg==", "bodyText": "This line is too long. use etc/*xml code template to format files.", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427693412", "createdAt": "2020-05-20T01:38:02Z", "author": {"login": "liubao68"}, "path": "service-registry/registry-zero-config/src/test/java/org/apache/servicecomb/serviceregistry/client/TestZeroConfigRegistryClientImpl.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.servicecomb.serviceregistry.client;\n+\n+import org.apache.servicecomb.serviceregistry.api.registry.MicroserviceInstance;\n+import org.apache.servicecomb.serviceregistry.api.registry.MicroserviceInstanceStatus;\n+import org.apache.servicecomb.serviceregistry.api.response.HeartbeatResponse;\n+import org.apache.servicecomb.serviceregistry.client.http.MicroserviceInstances;\n+import org.apache.servicecomb.serviceregistry.server.ServerMicroserviceInstance;\n+import org.mockito.Mock;\n+\n+import static org.apache.servicecomb.serviceregistry.ZeroConfigRegistryConstants.INSTANCE_ID;\n+import static org.apache.servicecomb.serviceregistry.ZeroConfigRegistryConstants.SCHEMA_CONTENT_ENDPOINT_BASE_PATH;\n+import static org.apache.servicecomb.serviceregistry.ZeroConfigRegistryConstants.SCHEMA_CONTENT_ENDPOINT_QUERY_KEYWORD;\n+import static org.apache.servicecomb.serviceregistry.ZeroConfigRegistryConstants.SCHEMA_CONTENT_ENDPOINT_SUBPATH;\n+import static org.apache.servicecomb.serviceregistry.ZeroConfigRegistryConstants.INSTANCE_HEARTBEAT_RESPONSE_MESSAGE_OK;\n+import static org.mockito.Matchers.anyObject;\n+import static org.mockito.Mockito.when;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyZeroInteractions;\n+\n+import org.apache.servicecomb.serviceregistry.api.registry.Microservice;\n+import org.apache.servicecomb.serviceregistry.server.ZeroConfigRegistryService;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.MockitoAnnotations;\n+import org.springframework.web.client.RestTemplate;\n+\n+import java.io.IOException;\n+import java.net.MulticastSocket;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+public class TestZeroConfigRegistryClientImpl {\n+\n+    ZeroConfigRegistryClientImpl target;\n+\n+    @Mock\n+    ZeroConfigRegistryService zeroConfigRegistryService;\n+\n+    @Mock\n+    MulticastSocket multicastSocket;\n+\n+    @Mock\n+    RestTemplate restTemplate;\n+\n+    // testing data\n+    String selfServiceId = \"123\";\n+    String selfInstanceId = \"instanceId\";\n+    String otherServiceId = \"456\";\n+    String appId = \"appId\";\n+    String serviceName = \"serviceName\";\n+    String version = \"0.0.0.1\";\n+    String status = \"UP\";\n+    String host = \"host\";\n+    String schemaId1 = \"schemaId1\";\n+    String schemaContent1 = \"schemaContent1\";\n+    String newSchemaId = \"newSchemaId\";\n+    String newSchemaContent = \"newSchemaContent\";\n+    String nonExistSchemaId = \"nonExistSchemaId\";\n+    String endpoint1 = \"endpoint1\";\n+    String strVersionRule = \"0.0.0.0+\";\n+\n+    @Before\n+    public void setUp() {\n+        MockitoAnnotations.initMocks(this);\n+        target = new ZeroConfigRegistryClientImpl(zeroConfigRegistryService, multicastSocket, restTemplate);\n+    }\n+\n+    private Microservice prepareService(String serviceId, boolean withId){\n+        Microservice microservice = new Microservice();\n+        if (withId){\n+            microservice.setServiceId(serviceId);\n+        }\n+        microservice.setServiceName(serviceName);\n+        microservice.setAppId(appId);\n+        microservice.setVersion(version);\n+        microservice.setStatus(status);\n+        List<String> schemas = new ArrayList<>();\n+        schemas.add(schemaId1);\n+        microservice.setSchemas(schemas);\n+        microservice.addSchema(schemaId1, schemaContent1);\n+        return microservice;\n+    }\n+\n+    private MicroserviceInstance prepareInstance(String instanceId, boolean withId){\n+        MicroserviceInstance instance = new MicroserviceInstance();\n+        if (withId){\n+            instance.setInstanceId(instanceId);\n+        }\n+        instance.setServiceId(selfServiceId);\n+        List<String> endpointList = new ArrayList<>();\n+        endpointList.add(endpoint1);\n+        instance.setEndpoints(endpointList);\n+        instance.setStatus(MicroserviceInstanceStatus.UP);\n+        instance.setHostName(host);\n+        return instance;\n+    }\n+\n+    private ServerMicroserviceInstance prepareServerServiceInstance(boolean withEndpoint){\n+        ServerMicroserviceInstance serverServiceInstance = new ServerMicroserviceInstance();\n+        serverServiceInstance.setServiceId(otherServiceId);\n+        serverServiceInstance.setInstanceId(selfInstanceId);\n+        serverServiceInstance.setServiceName(serviceName);\n+        serverServiceInstance.setAppId(appId);\n+        serverServiceInstance.setVersion(version);\n+        serverServiceInstance.setStatus(status);\n+        List<String> schemas = new ArrayList<>();\n+        schemas.add(schemaId1);\n+        serverServiceInstance.setSchemas(schemas);\n+        if (withEndpoint) {\n+            List<String> endpointList = new ArrayList<>();\n+            endpointList.add(endpoint1);\n+            serverServiceInstance.setEndpoints(endpointList);\n+        }\n+        serverServiceInstance.setHostName(host);\n+        return serverServiceInstance;\n+    }\n+\n+    @After\n+    public void tearDown() throws Exception {\n+\n+    }\n+\n+    @Test\n+    public void test_registerMicroservice_withID_shouldReturnSameID(){\n+        Microservice selfService = prepareService(selfServiceId, true);\n+        ClientUtil.microserviceSelf = selfService;\n+\n+        String returnedServiceId = target.registerMicroservice(selfService);\n+\n+        Assert.assertEquals(selfServiceId, returnedServiceId);\n+    }\n+\n+    @Test\n+    public void test_registerMicroservice_withoutID_shouldReturnGeneratedID(){\n+        Microservice serviceWithoutID = prepareService(selfServiceId, false);\n+        ClientUtil.microserviceSelf = serviceWithoutID;\n+\n+        String returnedServiceId = target.registerMicroservice(serviceWithoutID);\n+\n+        Assert.assertEquals(ClientUtil.generateServiceId(serviceWithoutID), returnedServiceId);\n+    }\n+\n+    @Test\n+    public void test_getMicroservice_forItself_shouldReturnItself_And_NotCallZeroConfigRegistryService (){\n+        ClientUtil.microserviceSelf = prepareService(selfServiceId, true);;\n+\n+        Microservice microservice = target.getMicroservice(selfServiceId);\n+\n+        Assert.assertEquals(microservice.getServiceId(), ClientUtil.microserviceSelf.getServiceId());\n+        verifyZeroInteractions(zeroConfigRegistryService);\n+    }\n+\n+    @Test\n+    public void test_getMicroservice_forItself_shouldReturnOtherService_And_CallZeroConfigRegistryService (){\n+        ClientUtil.microserviceSelf = prepareService(selfServiceId, true);\n+\n+        when(zeroConfigRegistryService.getMicroservice(otherServiceId)).thenReturn(prepareServerServiceInstance(true));\n+\n+        Microservice returnedMicroservice = target.getMicroservice(otherServiceId);\n+\n+        Assert.assertEquals(otherServiceId, returnedMicroservice.getServiceId());\n+        verify(zeroConfigRegistryService, times(1)).getMicroservice(otherServiceId);\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void test_isSchemaExist_whenServiceIdIsNull_shouldThrowIllegalArgumentException(){\n+        ClientUtil.microserviceSelf = prepareService(selfServiceId, false);\n+\n+        target.isSchemaExist(selfServiceId, schemaId1);\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void test_isSchemaExist_whenServiceIdIsNotItselfId_shouldThrowIllegalArgumentException(){\n+        ClientUtil.microserviceSelf = prepareService(otherServiceId, true);\n+\n+        target.isSchemaExist(selfServiceId, schemaId1);\n+    }\n+\n+    @Test\n+    public void test_isSchemaExist_whenServiceIdIsItselfId_shouldReturnTrue(){\n+        ClientUtil.microserviceSelf = prepareService(selfServiceId, true);\n+\n+        boolean returnedResult = target.isSchemaExist(selfServiceId, schemaId1);\n+        Assert.assertTrue(returnedResult);\n+    }\n+\n+    @Test\n+    public void test_isSchemaExist_whenSchemaNotExist_shouldReturnFalse(){\n+        ClientUtil.microserviceSelf =  prepareService(selfServiceId, true);\n+\n+        boolean returnedResult = target.isSchemaExist(selfServiceId, nonExistSchemaId);\n+        Assert.assertFalse(returnedResult);\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void test_registerSchema_whenServiceIdIsNull_shouldThrowIllegalArgumentException(){\n+        ClientUtil.microserviceSelf =  prepareService(selfServiceId, false);\n+\n+        target.registerSchema(selfServiceId, schemaId1, schemaContent1);\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void test_registerSchema_whenServiceIdIsNotItSelfId_shouldThrowIllegalArgumentException(){\n+        ClientUtil.microserviceSelf =  prepareService(selfServiceId, true);\n+\n+        target.registerSchema(otherServiceId, schemaId1, schemaContent1);\n+    }\n+\n+    @Test\n+    public void test_registerSchema_whenReigsterForItself_shouldSuceed(){\n+        ClientUtil.microserviceSelf =  prepareService(selfServiceId, true);\n+\n+        boolean returnedResult = target.registerSchema(selfServiceId, newSchemaId, newSchemaContent);\n+        Assert.assertTrue(returnedResult);\n+        Assert.assertEquals(newSchemaContent, ClientUtil.microserviceSelf.getSchemaMap().computeIfPresent(newSchemaId, (k, v) -> {\n+            return v;\n+        }));\n+    }\n+\n+    @Test\n+    public void test_getSchema_whenForSelfMicroservice_shouldSuceed(){\n+        ClientUtil.microserviceSelf = prepareService(selfServiceId, true);\n+\n+        String returnedSchemaContent = target.getSchema(selfServiceId, schemaId1);\n+        Assert.assertEquals(schemaContent1, returnedSchemaContent);\n+    }\n+\n+    @Test\n+    public void test_getSchema_whenForSelfMicroservice_shouldNotCallZeroConfigRegistryServiceAndSucceed(){\n+        ClientUtil.microserviceSelf = prepareService(selfServiceId, true);\n+\n+        String returnedSchemaContent = target.getSchema(selfServiceId, schemaId1);\n+\n+        Assert.assertEquals(schemaContent1, returnedSchemaContent);\n+        verifyZeroInteractions(zeroConfigRegistryService);\n+    }\n+\n+    @Test\n+    public void test_getSchema_whenForOtherMicroservice_shouldCallZeroConfigRegistryService(){\n+        ClientUtil.microserviceSelf = prepareService(selfServiceId, true);\n+        when(zeroConfigRegistryService.getMicroservice(otherServiceId)).thenReturn(prepareServerServiceInstance(true));\n+        String schemaContentEndpoint = endpoint1 + SCHEMA_CONTENT_ENDPOINT_BASE_PATH + SCHEMA_CONTENT_ENDPOINT_SUBPATH + \"?\" + SCHEMA_CONTENT_ENDPOINT_QUERY_KEYWORD + \"=\" + schemaId1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bfeca6e794add76bc7216c490d93af6b20fe5931"}, "originalPosition": 263}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcwODA0Mg==", "bodyText": "after removing those \"long\" constant\uff0c now. it's much shorter:)", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427708042", "createdAt": "2020-05-20T02:33:48Z", "author": {"login": "jungan21"}, "path": "service-registry/registry-zero-config/src/test/java/org/apache/servicecomb/serviceregistry/client/TestZeroConfigRegistryClientImpl.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.servicecomb.serviceregistry.client;\n+\n+import org.apache.servicecomb.serviceregistry.api.registry.MicroserviceInstance;\n+import org.apache.servicecomb.serviceregistry.api.registry.MicroserviceInstanceStatus;\n+import org.apache.servicecomb.serviceregistry.api.response.HeartbeatResponse;\n+import org.apache.servicecomb.serviceregistry.client.http.MicroserviceInstances;\n+import org.apache.servicecomb.serviceregistry.server.ServerMicroserviceInstance;\n+import org.mockito.Mock;\n+\n+import static org.apache.servicecomb.serviceregistry.ZeroConfigRegistryConstants.INSTANCE_ID;\n+import static org.apache.servicecomb.serviceregistry.ZeroConfigRegistryConstants.SCHEMA_CONTENT_ENDPOINT_BASE_PATH;\n+import static org.apache.servicecomb.serviceregistry.ZeroConfigRegistryConstants.SCHEMA_CONTENT_ENDPOINT_QUERY_KEYWORD;\n+import static org.apache.servicecomb.serviceregistry.ZeroConfigRegistryConstants.SCHEMA_CONTENT_ENDPOINT_SUBPATH;\n+import static org.apache.servicecomb.serviceregistry.ZeroConfigRegistryConstants.INSTANCE_HEARTBEAT_RESPONSE_MESSAGE_OK;\n+import static org.mockito.Matchers.anyObject;\n+import static org.mockito.Mockito.when;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.doNothing;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyZeroInteractions;\n+\n+import org.apache.servicecomb.serviceregistry.api.registry.Microservice;\n+import org.apache.servicecomb.serviceregistry.server.ZeroConfigRegistryService;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.MockitoAnnotations;\n+import org.springframework.web.client.RestTemplate;\n+\n+import java.io.IOException;\n+import java.net.MulticastSocket;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+\n+public class TestZeroConfigRegistryClientImpl {\n+\n+    ZeroConfigRegistryClientImpl target;\n+\n+    @Mock\n+    ZeroConfigRegistryService zeroConfigRegistryService;\n+\n+    @Mock\n+    MulticastSocket multicastSocket;\n+\n+    @Mock\n+    RestTemplate restTemplate;\n+\n+    // testing data\n+    String selfServiceId = \"123\";\n+    String selfInstanceId = \"instanceId\";\n+    String otherServiceId = \"456\";\n+    String appId = \"appId\";\n+    String serviceName = \"serviceName\";\n+    String version = \"0.0.0.1\";\n+    String status = \"UP\";\n+    String host = \"host\";\n+    String schemaId1 = \"schemaId1\";\n+    String schemaContent1 = \"schemaContent1\";\n+    String newSchemaId = \"newSchemaId\";\n+    String newSchemaContent = \"newSchemaContent\";\n+    String nonExistSchemaId = \"nonExistSchemaId\";\n+    String endpoint1 = \"endpoint1\";\n+    String strVersionRule = \"0.0.0.0+\";\n+\n+    @Before\n+    public void setUp() {\n+        MockitoAnnotations.initMocks(this);\n+        target = new ZeroConfigRegistryClientImpl(zeroConfigRegistryService, multicastSocket, restTemplate);\n+    }\n+\n+    private Microservice prepareService(String serviceId, boolean withId){\n+        Microservice microservice = new Microservice();\n+        if (withId){\n+            microservice.setServiceId(serviceId);\n+        }\n+        microservice.setServiceName(serviceName);\n+        microservice.setAppId(appId);\n+        microservice.setVersion(version);\n+        microservice.setStatus(status);\n+        List<String> schemas = new ArrayList<>();\n+        schemas.add(schemaId1);\n+        microservice.setSchemas(schemas);\n+        microservice.addSchema(schemaId1, schemaContent1);\n+        return microservice;\n+    }\n+\n+    private MicroserviceInstance prepareInstance(String instanceId, boolean withId){\n+        MicroserviceInstance instance = new MicroserviceInstance();\n+        if (withId){\n+            instance.setInstanceId(instanceId);\n+        }\n+        instance.setServiceId(selfServiceId);\n+        List<String> endpointList = new ArrayList<>();\n+        endpointList.add(endpoint1);\n+        instance.setEndpoints(endpointList);\n+        instance.setStatus(MicroserviceInstanceStatus.UP);\n+        instance.setHostName(host);\n+        return instance;\n+    }\n+\n+    private ServerMicroserviceInstance prepareServerServiceInstance(boolean withEndpoint){\n+        ServerMicroserviceInstance serverServiceInstance = new ServerMicroserviceInstance();\n+        serverServiceInstance.setServiceId(otherServiceId);\n+        serverServiceInstance.setInstanceId(selfInstanceId);\n+        serverServiceInstance.setServiceName(serviceName);\n+        serverServiceInstance.setAppId(appId);\n+        serverServiceInstance.setVersion(version);\n+        serverServiceInstance.setStatus(status);\n+        List<String> schemas = new ArrayList<>();\n+        schemas.add(schemaId1);\n+        serverServiceInstance.setSchemas(schemas);\n+        if (withEndpoint) {\n+            List<String> endpointList = new ArrayList<>();\n+            endpointList.add(endpoint1);\n+            serverServiceInstance.setEndpoints(endpointList);\n+        }\n+        serverServiceInstance.setHostName(host);\n+        return serverServiceInstance;\n+    }\n+\n+    @After\n+    public void tearDown() throws Exception {\n+\n+    }\n+\n+    @Test\n+    public void test_registerMicroservice_withID_shouldReturnSameID(){\n+        Microservice selfService = prepareService(selfServiceId, true);\n+        ClientUtil.microserviceSelf = selfService;\n+\n+        String returnedServiceId = target.registerMicroservice(selfService);\n+\n+        Assert.assertEquals(selfServiceId, returnedServiceId);\n+    }\n+\n+    @Test\n+    public void test_registerMicroservice_withoutID_shouldReturnGeneratedID(){\n+        Microservice serviceWithoutID = prepareService(selfServiceId, false);\n+        ClientUtil.microserviceSelf = serviceWithoutID;\n+\n+        String returnedServiceId = target.registerMicroservice(serviceWithoutID);\n+\n+        Assert.assertEquals(ClientUtil.generateServiceId(serviceWithoutID), returnedServiceId);\n+    }\n+\n+    @Test\n+    public void test_getMicroservice_forItself_shouldReturnItself_And_NotCallZeroConfigRegistryService (){\n+        ClientUtil.microserviceSelf = prepareService(selfServiceId, true);;\n+\n+        Microservice microservice = target.getMicroservice(selfServiceId);\n+\n+        Assert.assertEquals(microservice.getServiceId(), ClientUtil.microserviceSelf.getServiceId());\n+        verifyZeroInteractions(zeroConfigRegistryService);\n+    }\n+\n+    @Test\n+    public void test_getMicroservice_forItself_shouldReturnOtherService_And_CallZeroConfigRegistryService (){\n+        ClientUtil.microserviceSelf = prepareService(selfServiceId, true);\n+\n+        when(zeroConfigRegistryService.getMicroservice(otherServiceId)).thenReturn(prepareServerServiceInstance(true));\n+\n+        Microservice returnedMicroservice = target.getMicroservice(otherServiceId);\n+\n+        Assert.assertEquals(otherServiceId, returnedMicroservice.getServiceId());\n+        verify(zeroConfigRegistryService, times(1)).getMicroservice(otherServiceId);\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void test_isSchemaExist_whenServiceIdIsNull_shouldThrowIllegalArgumentException(){\n+        ClientUtil.microserviceSelf = prepareService(selfServiceId, false);\n+\n+        target.isSchemaExist(selfServiceId, schemaId1);\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void test_isSchemaExist_whenServiceIdIsNotItselfId_shouldThrowIllegalArgumentException(){\n+        ClientUtil.microserviceSelf = prepareService(otherServiceId, true);\n+\n+        target.isSchemaExist(selfServiceId, schemaId1);\n+    }\n+\n+    @Test\n+    public void test_isSchemaExist_whenServiceIdIsItselfId_shouldReturnTrue(){\n+        ClientUtil.microserviceSelf = prepareService(selfServiceId, true);\n+\n+        boolean returnedResult = target.isSchemaExist(selfServiceId, schemaId1);\n+        Assert.assertTrue(returnedResult);\n+    }\n+\n+    @Test\n+    public void test_isSchemaExist_whenSchemaNotExist_shouldReturnFalse(){\n+        ClientUtil.microserviceSelf =  prepareService(selfServiceId, true);\n+\n+        boolean returnedResult = target.isSchemaExist(selfServiceId, nonExistSchemaId);\n+        Assert.assertFalse(returnedResult);\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void test_registerSchema_whenServiceIdIsNull_shouldThrowIllegalArgumentException(){\n+        ClientUtil.microserviceSelf =  prepareService(selfServiceId, false);\n+\n+        target.registerSchema(selfServiceId, schemaId1, schemaContent1);\n+    }\n+\n+    @Test(expected = IllegalArgumentException.class)\n+    public void test_registerSchema_whenServiceIdIsNotItSelfId_shouldThrowIllegalArgumentException(){\n+        ClientUtil.microserviceSelf =  prepareService(selfServiceId, true);\n+\n+        target.registerSchema(otherServiceId, schemaId1, schemaContent1);\n+    }\n+\n+    @Test\n+    public void test_registerSchema_whenReigsterForItself_shouldSuceed(){\n+        ClientUtil.microserviceSelf =  prepareService(selfServiceId, true);\n+\n+        boolean returnedResult = target.registerSchema(selfServiceId, newSchemaId, newSchemaContent);\n+        Assert.assertTrue(returnedResult);\n+        Assert.assertEquals(newSchemaContent, ClientUtil.microserviceSelf.getSchemaMap().computeIfPresent(newSchemaId, (k, v) -> {\n+            return v;\n+        }));\n+    }\n+\n+    @Test\n+    public void test_getSchema_whenForSelfMicroservice_shouldSuceed(){\n+        ClientUtil.microserviceSelf = prepareService(selfServiceId, true);\n+\n+        String returnedSchemaContent = target.getSchema(selfServiceId, schemaId1);\n+        Assert.assertEquals(schemaContent1, returnedSchemaContent);\n+    }\n+\n+    @Test\n+    public void test_getSchema_whenForSelfMicroservice_shouldNotCallZeroConfigRegistryServiceAndSucceed(){\n+        ClientUtil.microserviceSelf = prepareService(selfServiceId, true);\n+\n+        String returnedSchemaContent = target.getSchema(selfServiceId, schemaId1);\n+\n+        Assert.assertEquals(schemaContent1, returnedSchemaContent);\n+        verifyZeroInteractions(zeroConfigRegistryService);\n+    }\n+\n+    @Test\n+    public void test_getSchema_whenForOtherMicroservice_shouldCallZeroConfigRegistryService(){\n+        ClientUtil.microserviceSelf = prepareService(selfServiceId, true);\n+        when(zeroConfigRegistryService.getMicroservice(otherServiceId)).thenReturn(prepareServerServiceInstance(true));\n+        String schemaContentEndpoint = endpoint1 + SCHEMA_CONTENT_ENDPOINT_BASE_PATH + SCHEMA_CONTENT_ENDPOINT_SUBPATH + \"?\" + SCHEMA_CONTENT_ENDPOINT_QUERY_KEYWORD + \"=\" + schemaId1;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY5MzQxMg=="}, "originalCommit": {"oid": "bfeca6e794add76bc7216c490d93af6b20fe5931"}, "originalPosition": 263}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MzY5NjM1OnYy", "diffSide": "RIGHT", "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/SchemaContentEndpoint.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwMTo0MTo1NFrOGX4ZNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwMjozMzoxOVrOGX5OCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY5NDM4OQ==", "bodyText": "Suggestions: path and name only used in endpoints, I think use literal is more readable than using a constant, we can easly get what's the url and param from method signature without a code jump.", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427694389", "createdAt": "2020-05-20T01:41:54Z", "author": {"login": "liubao68"}, "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/SchemaContentEndpoint.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.servicecomb.serviceregistry;\n+\n+import org.apache.servicecomb.provider.rest.common.RestSchema;\n+\n+import org.apache.servicecomb.serviceregistry.client.ClientUtil;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RequestMethod;\n+import org.springframework.web.bind.annotation.RequestParam;\n+import javax.ws.rs.core.MediaType;\n+import java.util.Map;\n+\n+import static org.apache.servicecomb.serviceregistry.ZeroConfigRegistryConstants.*;\n+\n+@RestSchema(schemaId = SCHEMA_CONTENT_ENDPOINT)\n+@RequestMapping(path = SCHEMA_CONTENT_ENDPOINT_BASE_PATH)\n+public class SchemaContentEndpoint {\n+    // each service self-expose this endpoint for others(consumers) to retrieve the schema content\n+    @RequestMapping(path = SCHEMA_CONTENT_ENDPOINT_SUBPATH, produces = MediaType.TEXT_PLAIN, method = RequestMethod.POST )", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bfeca6e794add76bc7216c490d93af6b20fe5931"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcwNzkxNA==", "bodyText": "sure. cleared those constant", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427707914", "createdAt": "2020-05-20T02:33:19Z", "author": {"login": "jungan21"}, "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/SchemaContentEndpoint.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.servicecomb.serviceregistry;\n+\n+import org.apache.servicecomb.provider.rest.common.RestSchema;\n+\n+import org.apache.servicecomb.serviceregistry.client.ClientUtil;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RequestMethod;\n+import org.springframework.web.bind.annotation.RequestParam;\n+import javax.ws.rs.core.MediaType;\n+import java.util.Map;\n+\n+import static org.apache.servicecomb.serviceregistry.ZeroConfigRegistryConstants.*;\n+\n+@RestSchema(schemaId = SCHEMA_CONTENT_ENDPOINT)\n+@RequestMapping(path = SCHEMA_CONTENT_ENDPOINT_BASE_PATH)\n+public class SchemaContentEndpoint {\n+    // each service self-expose this endpoint for others(consumers) to retrieve the schema content\n+    @RequestMapping(path = SCHEMA_CONTENT_ENDPOINT_SUBPATH, produces = MediaType.TEXT_PLAIN, method = RequestMethod.POST )", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY5NDM4OQ=="}, "originalCommit": {"oid": "bfeca6e794add76bc7216c490d93af6b20fe5931"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MzY5NzYyOnYy", "diffSide": "RIGHT", "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/client/ClientUtil.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwMTo0MjozOFrOGX4aBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwMjozMjo1NlrOGX5NtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY5NDU5OQ==", "bodyText": "Suggestions: package name can rename to org.apache.serviecomb.zeroconfig", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427694599", "createdAt": "2020-05-20T01:42:38Z", "author": {"login": "liubao68"}, "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/client/ClientUtil.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bfeca6e794add76bc7216c490d93af6b20fe5931"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcwNzgyOA==", "bodyText": "agree. will renmae package naeme", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427707828", "createdAt": "2020-05-20T02:32:56Z", "author": {"login": "jungan21"}, "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/client/ClientUtil.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY5NDU5OQ=="}, "originalCommit": {"oid": "bfeca6e794add76bc7216c490d93af6b20fe5931"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MzcyNjI2OnYy", "diffSide": "RIGHT", "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/SchemaContentEndpoint.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwMTo1ODo0MFrOGX4q4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQyMTowOTo1MVrOGZC93w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY5ODkxNQ==", "bodyText": "better to use JAX-RS annotation, because not all project depend on swagger-generator-springmvc", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427698915", "createdAt": "2020-05-20T01:58:40Z", "author": {"login": "wujimin"}, "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/SchemaContentEndpoint.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.servicecomb.serviceregistry;\n+\n+import org.apache.servicecomb.provider.rest.common.RestSchema;\n+\n+import org.apache.servicecomb.serviceregistry.client.ClientUtil;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RequestMethod;\n+import org.springframework.web.bind.annotation.RequestParam;\n+import javax.ws.rs.core.MediaType;\n+import java.util.Map;\n+\n+import static org.apache.servicecomb.serviceregistry.ZeroConfigRegistryConstants.*;\n+\n+@RestSchema(schemaId = SCHEMA_CONTENT_ENDPOINT)\n+@RequestMapping(path = SCHEMA_CONTENT_ENDPOINT_BASE_PATH)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bfeca6e794add76bc7216c490d93af6b20fe5931"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcwODcxNA==", "bodyText": "I see. thx for the reminder, Since I tested for Spingmvc version already.  I will make this change to JAX-RS version in next PR. thx", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427708714", "createdAt": "2020-05-20T02:36:11Z", "author": {"login": "jungan21"}, "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/SchemaContentEndpoint.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.servicecomb.serviceregistry;\n+\n+import org.apache.servicecomb.provider.rest.common.RestSchema;\n+\n+import org.apache.servicecomb.serviceregistry.client.ClientUtil;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RequestMethod;\n+import org.springframework.web.bind.annotation.RequestParam;\n+import javax.ws.rs.core.MediaType;\n+import java.util.Map;\n+\n+import static org.apache.servicecomb.serviceregistry.ZeroConfigRegistryConstants.*;\n+\n+@RestSchema(schemaId = SCHEMA_CONTENT_ENDPOINT)\n+@RequestMapping(path = SCHEMA_CONTENT_ENDPOINT_BASE_PATH)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY5ODkxNQ=="}, "originalCommit": {"oid": "bfeca6e794add76bc7216c490d93af6b20fe5931"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkxNjE5MQ==", "bodyText": "I tried with pure JAX-RS annotation today It seems our swagger generator has issue for processing JAX-RS @QueryParam and @PathParam.  When there is no path parameter annotation, it's OK. Below please find the details.\n**1. Error when parsing JAX-RS @QueryParam annotation to take in query parameter. I\n\n@RestSchema(schemaId = \"schemaContentEndpoint\")\n@Path(\"/schemaEndpoint\")\n@Produces(MediaType.TEXT_PLAIN)\npublic class SchemaContentEndpoint {\n\n    @Path(\"/schemas\")\n    @GET\n    public String getSchemaEndpoint(**@QueryParam**(\"schemaId\") String schemaId) {\n        Map<String, String> schemaMap = ClientUtil.microserviceSelf.getSchemaMap();\n        return schemaMap.get(schemaId);\n    }\n}\n\nError message:\nCaused by: java.lang.IllegalStateException: parameter name is not present, method=org.apache.servicecomb.zeroconfigsc.SchemaContentEndpoint:getSchemaEndpoint\nsolution:\n  change pom.xml, add compiler argument: -parameters, for example:\n    <plugin>\n      <groupId>org.apache.maven.plugins</groupId>\n      <artifactId>maven-compiler-plugin</artifactId>\n      <configuration>\n        <compilerArgument>-parameters</compilerArgument>\n      </configuration>\n    </plugin>\n\tat org.apache.servicecomb.swagger.generator.SwaggerGeneratorUtils.collectParameterName(SwaggerGeneratorUtils.java:192)\n\tat org.apache.servicecomb.swagger.generator.ParameterGenerator.<init>(ParameterGenerator.java:55)\n\tat org.apache.servicecomb.swagger.generator.ParameterGenerator.<init>(ParameterGenerator.java:66)\n\tat org.apache.servicecomb.swagger.generator.core.AbstractOperationGenerator.initMethodParameterGenerators(AbstractOperationGenerator.java:230)\n\nBTW, if I replace @QueryParam with SpringMVC @RequestParameter, it works fine. Also If I remove @QueryParam, it works fine too.\nBased on the error message, it seems name attribute is required for swagger generator to be able to process/parse the Annotation.\n`", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r428916191", "createdAt": "2020-05-21T21:09:51Z", "author": {"login": "jungan21"}, "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/SchemaContentEndpoint.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.servicecomb.serviceregistry;\n+\n+import org.apache.servicecomb.provider.rest.common.RestSchema;\n+\n+import org.apache.servicecomb.serviceregistry.client.ClientUtil;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RequestMethod;\n+import org.springframework.web.bind.annotation.RequestParam;\n+import javax.ws.rs.core.MediaType;\n+import java.util.Map;\n+\n+import static org.apache.servicecomb.serviceregistry.ZeroConfigRegistryConstants.*;\n+\n+@RestSchema(schemaId = SCHEMA_CONTENT_ENDPOINT)\n+@RequestMapping(path = SCHEMA_CONTENT_ENDPOINT_BASE_PATH)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY5ODkxNQ=="}, "originalCommit": {"oid": "bfeca6e794add76bc7216c490d93af6b20fe5931"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2Mzc1MjA1OnYy", "diffSide": "RIGHT", "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/SchemaContentEndpoint.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwMjoxNDoxMVrOGX46yA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwMjozMjozOFrOGX5NVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcwMjk4NA==", "bodyText": "seems http method should be GET", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427702984", "createdAt": "2020-05-20T02:14:11Z", "author": {"login": "wujimin"}, "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/SchemaContentEndpoint.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.servicecomb.serviceregistry;\n+\n+import org.apache.servicecomb.provider.rest.common.RestSchema;\n+\n+import org.apache.servicecomb.serviceregistry.client.ClientUtil;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RequestMethod;\n+import org.springframework.web.bind.annotation.RequestParam;\n+import javax.ws.rs.core.MediaType;\n+import java.util.Map;\n+\n+import static org.apache.servicecomb.serviceregistry.ZeroConfigRegistryConstants.*;\n+\n+@RestSchema(schemaId = SCHEMA_CONTENT_ENDPOINT)\n+@RequestMapping(path = SCHEMA_CONTENT_ENDPOINT_BASE_PATH)\n+public class SchemaContentEndpoint {\n+    // each service self-expose this endpoint for others(consumers) to retrieve the schema content\n+    @RequestMapping(path = SCHEMA_CONTENT_ENDPOINT_SUBPATH, produces = MediaType.TEXT_PLAIN, method = RequestMethod.POST )", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bfeca6e794add76bc7216c490d93af6b20fe5931"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcwNzczNA==", "bodyText": "yup . agree", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427707734", "createdAt": "2020-05-20T02:32:38Z", "author": {"login": "jungan21"}, "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/SchemaContentEndpoint.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.servicecomb.serviceregistry;\n+\n+import org.apache.servicecomb.provider.rest.common.RestSchema;\n+\n+import org.apache.servicecomb.serviceregistry.client.ClientUtil;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RequestMethod;\n+import org.springframework.web.bind.annotation.RequestParam;\n+import javax.ws.rs.core.MediaType;\n+import java.util.Map;\n+\n+import static org.apache.servicecomb.serviceregistry.ZeroConfigRegistryConstants.*;\n+\n+@RestSchema(schemaId = SCHEMA_CONTENT_ENDPOINT)\n+@RequestMapping(path = SCHEMA_CONTENT_ENDPOINT_BASE_PATH)\n+public class SchemaContentEndpoint {\n+    // each service self-expose this endpoint for others(consumers) to retrieve the schema content\n+    @RequestMapping(path = SCHEMA_CONTENT_ENDPOINT_SUBPATH, produces = MediaType.TEXT_PLAIN, method = RequestMethod.POST )", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcwMjk4NA=="}, "originalCommit": {"oid": "bfeca6e794add76bc7216c490d93af6b20fe5931"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2Mzc5MDkyOnYy", "diffSide": "RIGHT", "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/SchemaContentEndpoint.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwMjozODoyN1rOGX5TXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwMjo0MzoyM1rOGX5YEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcwOTI3OQ==", "bodyText": "utils with data is not so good\neven a utils with data, should provide a getter method, not access it directly", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427709279", "createdAt": "2020-05-20T02:38:27Z", "author": {"login": "wujimin"}, "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/SchemaContentEndpoint.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.servicecomb.serviceregistry;\n+\n+import org.apache.servicecomb.provider.rest.common.RestSchema;\n+\n+import org.apache.servicecomb.serviceregistry.client.ClientUtil;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RequestMethod;\n+import org.springframework.web.bind.annotation.RequestParam;\n+import javax.ws.rs.core.MediaType;\n+import java.util.Map;\n+\n+import static org.apache.servicecomb.serviceregistry.ZeroConfigRegistryConstants.*;\n+\n+@RestSchema(schemaId = SCHEMA_CONTENT_ENDPOINT)\n+@RequestMapping(path = SCHEMA_CONTENT_ENDPOINT_BASE_PATH)\n+public class SchemaContentEndpoint {\n+    // each service self-expose this endpoint for others(consumers) to retrieve the schema content\n+    @RequestMapping(path = SCHEMA_CONTENT_ENDPOINT_SUBPATH, produces = MediaType.TEXT_PLAIN, method = RequestMethod.POST )\n+    public String getSchemaEndpoint(@RequestParam(name = SCHEMA_CONTENT_ENDPOINT_QUERY_KEYWORD) String schemaId) {\n+        Map<String, String> schemaMap = ClientUtil.microserviceSelf.getSchemaMap();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bfeca6e794add76bc7216c490d93af6b20fe5931"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcxMDQ4MA==", "bodyText": ":), it's eaiser for unit test", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427710480", "createdAt": "2020-05-20T02:43:23Z", "author": {"login": "jungan21"}, "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/SchemaContentEndpoint.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.servicecomb.serviceregistry;\n+\n+import org.apache.servicecomb.provider.rest.common.RestSchema;\n+\n+import org.apache.servicecomb.serviceregistry.client.ClientUtil;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RequestMethod;\n+import org.springframework.web.bind.annotation.RequestParam;\n+import javax.ws.rs.core.MediaType;\n+import java.util.Map;\n+\n+import static org.apache.servicecomb.serviceregistry.ZeroConfigRegistryConstants.*;\n+\n+@RestSchema(schemaId = SCHEMA_CONTENT_ENDPOINT)\n+@RequestMapping(path = SCHEMA_CONTENT_ENDPOINT_BASE_PATH)\n+public class SchemaContentEndpoint {\n+    // each service self-expose this endpoint for others(consumers) to retrieve the schema content\n+    @RequestMapping(path = SCHEMA_CONTENT_ENDPOINT_SUBPATH, produces = MediaType.TEXT_PLAIN, method = RequestMethod.POST )\n+    public String getSchemaEndpoint(@RequestParam(name = SCHEMA_CONTENT_ENDPOINT_QUERY_KEYWORD) String schemaId) {\n+        Map<String, String> schemaMap = ClientUtil.microserviceSelf.getSchemaMap();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcwOTI3OQ=="}, "originalCommit": {"oid": "bfeca6e794add76bc7216c490d93af6b20fe5931"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2Mzc5NzUzOnYy", "diffSide": "RIGHT", "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/client/ClientUtil.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwMjo0MzowMlrOGX5Xtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwMjo0NTozMVrOGX5aEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcxMDM5MA==", "bodyText": "please import codestyle:  etc/intellij-java-google-style.xml\nand then reformat new code.", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427710390", "createdAt": "2020-05-20T02:43:02Z", "author": {"login": "wujimin"}, "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/client/ClientUtil.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.servicecomb.serviceregistry.client;\n+\n+import org.apache.servicecomb.serviceregistry.api.registry.Microservice;\n+import org.apache.servicecomb.serviceregistry.api.registry.MicroserviceInstance;\n+import org.apache.servicecomb.serviceregistry.api.registry.MicroserviceInstanceStatus;\n+import org.apache.servicecomb.serviceregistry.server.ServerMicroserviceInstance;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.net.DatagramPacket;\n+import java.net.InetAddress;\n+import java.net.MulticastSocket;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.apache.servicecomb.serviceregistry.ZeroConfigRegistryConstants.*;\n+\n+public class ClientUtil {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(ClientUtil.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bfeca6e794add76bc7216c490d93af6b20fe5931"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcxMDk5NA==", "bodyText": "will do . thx", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427710994", "createdAt": "2020-05-20T02:45:31Z", "author": {"login": "jungan21"}, "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/client/ClientUtil.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.servicecomb.serviceregistry.client;\n+\n+import org.apache.servicecomb.serviceregistry.api.registry.Microservice;\n+import org.apache.servicecomb.serviceregistry.api.registry.MicroserviceInstance;\n+import org.apache.servicecomb.serviceregistry.api.registry.MicroserviceInstanceStatus;\n+import org.apache.servicecomb.serviceregistry.server.ServerMicroserviceInstance;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.net.DatagramPacket;\n+import java.net.InetAddress;\n+import java.net.MulticastSocket;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.apache.servicecomb.serviceregistry.ZeroConfigRegistryConstants.*;\n+\n+public class ClientUtil {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(ClientUtil.class);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcxMDM5MA=="}, "originalCommit": {"oid": "bfeca6e794add76bc7216c490d93af6b20fe5931"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2Mzc5OTAwOnYy", "diffSide": "RIGHT", "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/client/ClientUtil.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwMjo0NDowOVrOGX5YrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwMjo0OTo0NlrOGX5eJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcxMDYzNw==", "bodyText": "must new for each times?", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427710637", "createdAt": "2020-05-20T02:44:09Z", "author": {"login": "wujimin"}, "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/client/ClientUtil.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.servicecomb.serviceregistry.client;\n+\n+import org.apache.servicecomb.serviceregistry.api.registry.Microservice;\n+import org.apache.servicecomb.serviceregistry.api.registry.MicroserviceInstance;\n+import org.apache.servicecomb.serviceregistry.api.registry.MicroserviceInstanceStatus;\n+import org.apache.servicecomb.serviceregistry.server.ServerMicroserviceInstance;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.net.DatagramPacket;\n+import java.net.InetAddress;\n+import java.net.MulticastSocket;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.apache.servicecomb.serviceregistry.ZeroConfigRegistryConstants.*;\n+\n+public class ClientUtil {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(ClientUtil.class);\n+\n+    private static ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();\n+\n+    public static Microservice microserviceSelf = new Microservice();\n+\n+    public static Map<String, String> serviceInstanceMapForHeartbeat = null;\n+\n+    public static synchronized void init(){\n+        Runnable heartbeatRunnable = new Runnable() {\n+            @Override\n+            public void run() {\n+                if (serviceInstanceMapForHeartbeat != null && !serviceInstanceMapForHeartbeat.isEmpty()){\n+                    // after first registration succeeds\n+                    try {\n+                        byte[] heartbeatEventDataBytes = serviceInstanceMapForHeartbeat.toString().getBytes();\n+                        MulticastSocket multicastSocket = new MulticastSocket();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bfeca6e794add76bc7216c490d93af6b20fe5931"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcxMjAzOQ==", "bodyText": "no necessary.. will make change", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427712039", "createdAt": "2020-05-20T02:49:46Z", "author": {"login": "jungan21"}, "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/client/ClientUtil.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.servicecomb.serviceregistry.client;\n+\n+import org.apache.servicecomb.serviceregistry.api.registry.Microservice;\n+import org.apache.servicecomb.serviceregistry.api.registry.MicroserviceInstance;\n+import org.apache.servicecomb.serviceregistry.api.registry.MicroserviceInstanceStatus;\n+import org.apache.servicecomb.serviceregistry.server.ServerMicroserviceInstance;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.net.DatagramPacket;\n+import java.net.InetAddress;\n+import java.net.MulticastSocket;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.apache.servicecomb.serviceregistry.ZeroConfigRegistryConstants.*;\n+\n+public class ClientUtil {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(ClientUtil.class);\n+\n+    private static ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();\n+\n+    public static Microservice microserviceSelf = new Microservice();\n+\n+    public static Map<String, String> serviceInstanceMapForHeartbeat = null;\n+\n+    public static synchronized void init(){\n+        Runnable heartbeatRunnable = new Runnable() {\n+            @Override\n+            public void run() {\n+                if (serviceInstanceMapForHeartbeat != null && !serviceInstanceMapForHeartbeat.isEmpty()){\n+                    // after first registration succeeds\n+                    try {\n+                        byte[] heartbeatEventDataBytes = serviceInstanceMapForHeartbeat.toString().getBytes();\n+                        MulticastSocket multicastSocket = new MulticastSocket();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcxMDYzNw=="}, "originalCommit": {"oid": "bfeca6e794add76bc7216c490d93af6b20fe5931"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MzgwNjI5OnYy", "diffSide": "RIGHT", "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/client/ClientUtil.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwMjo0ODo0N1rOGX5dLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwMjo1NTo0OVrOGX5kIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcxMTc4OA==", "bodyText": "String.join(\",\", list)", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427711788", "createdAt": "2020-05-20T02:48:47Z", "author": {"login": "wujimin"}, "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/client/ClientUtil.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.servicecomb.serviceregistry.client;\n+\n+import org.apache.servicecomb.serviceregistry.api.registry.Microservice;\n+import org.apache.servicecomb.serviceregistry.api.registry.MicroserviceInstance;\n+import org.apache.servicecomb.serviceregistry.api.registry.MicroserviceInstanceStatus;\n+import org.apache.servicecomb.serviceregistry.server.ServerMicroserviceInstance;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.net.DatagramPacket;\n+import java.net.InetAddress;\n+import java.net.MulticastSocket;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.apache.servicecomb.serviceregistry.ZeroConfigRegistryConstants.*;\n+\n+public class ClientUtil {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(ClientUtil.class);\n+\n+    private static ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();\n+\n+    public static Microservice microserviceSelf = new Microservice();\n+\n+    public static Map<String, String> serviceInstanceMapForHeartbeat = null;\n+\n+    public static synchronized void init(){\n+        Runnable heartbeatRunnable = new Runnable() {\n+            @Override\n+            public void run() {\n+                if (serviceInstanceMapForHeartbeat != null && !serviceInstanceMapForHeartbeat.isEmpty()){\n+                    // after first registration succeeds\n+                    try {\n+                        byte[] heartbeatEventDataBytes = serviceInstanceMapForHeartbeat.toString().getBytes();\n+                        MulticastSocket multicastSocket = new MulticastSocket();\n+                        multicastSocket.setLoopbackMode(false);\n+                        multicastSocket.setTimeToLive(TIME_TO_LIVE);\n+\n+                        DatagramPacket instanceDataPacket = new DatagramPacket(heartbeatEventDataBytes, heartbeatEventDataBytes.length,\n+                                InetAddress.getByName(GROUP), PORT);\n+\n+                        multicastSocket.send(instanceDataPacket);\n+                    } catch (Exception e) {\n+                        LOGGER.error(\"Failed to send heartbeat event for object: {}\", serviceInstanceMapForHeartbeat, e);\n+                    }\n+                }\n+            }\n+        };\n+        executor.scheduleAtFixedRate(heartbeatRunnable, CLIENT_DELAY, HEALTH_CHECK_INTERVAL, TimeUnit.SECONDS);\n+    }\n+\n+    public static Optional<Map<String, String>> convertToRegisterDataModel(String serviceId, String microserviceInstanceId,\n+                                                                           MicroserviceInstance microserviceInstance, Microservice microservice) {\n+        Map<String, String> serviceInstanceTextAttributesMap = new HashMap<>();\n+\n+        serviceInstanceTextAttributesMap.put(EVENT, REGISTER_EVENT);\n+        serviceInstanceTextAttributesMap.put(VERSION, microservice.getVersion());\n+        serviceInstanceTextAttributesMap.put(SERVICE_ID, serviceId);\n+        serviceInstanceTextAttributesMap.put(INSTANCE_ID, microserviceInstanceId);\n+        serviceInstanceTextAttributesMap.put(STATUS, microserviceInstance.getStatus().toString());\n+        serviceInstanceTextAttributesMap.put(APP_ID, microservice.getAppId());\n+        serviceInstanceTextAttributesMap.put(SERVICE_NAME, microservice.getServiceName());\n+\n+        String hostName = microserviceInstance.getHostName();\n+        serviceInstanceTextAttributesMap.put(HOST_NAME, hostName);\n+\n+        // schema1$schema2\n+        serviceInstanceTextAttributesMap.put(ENDPOINTS, convertListToString(microserviceInstance.getEndpoints()));\n+        serviceInstanceTextAttributesMap.put(SCHEMA_IDS, convertListToString(microservice.getSchemas()));\n+\n+        return Optional.of(serviceInstanceTextAttributesMap);\n+    }\n+\n+    private static String convertListToString (List<String> list){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bfeca6e794add76bc7216c490d93af6b20fe5931"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcxMzU2OA==", "bodyText": "Thanks! clean code :)", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427713568", "createdAt": "2020-05-20T02:55:49Z", "author": {"login": "jungan21"}, "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/client/ClientUtil.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.servicecomb.serviceregistry.client;\n+\n+import org.apache.servicecomb.serviceregistry.api.registry.Microservice;\n+import org.apache.servicecomb.serviceregistry.api.registry.MicroserviceInstance;\n+import org.apache.servicecomb.serviceregistry.api.registry.MicroserviceInstanceStatus;\n+import org.apache.servicecomb.serviceregistry.server.ServerMicroserviceInstance;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.net.DatagramPacket;\n+import java.net.InetAddress;\n+import java.net.MulticastSocket;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.apache.servicecomb.serviceregistry.ZeroConfigRegistryConstants.*;\n+\n+public class ClientUtil {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(ClientUtil.class);\n+\n+    private static ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();\n+\n+    public static Microservice microserviceSelf = new Microservice();\n+\n+    public static Map<String, String> serviceInstanceMapForHeartbeat = null;\n+\n+    public static synchronized void init(){\n+        Runnable heartbeatRunnable = new Runnable() {\n+            @Override\n+            public void run() {\n+                if (serviceInstanceMapForHeartbeat != null && !serviceInstanceMapForHeartbeat.isEmpty()){\n+                    // after first registration succeeds\n+                    try {\n+                        byte[] heartbeatEventDataBytes = serviceInstanceMapForHeartbeat.toString().getBytes();\n+                        MulticastSocket multicastSocket = new MulticastSocket();\n+                        multicastSocket.setLoopbackMode(false);\n+                        multicastSocket.setTimeToLive(TIME_TO_LIVE);\n+\n+                        DatagramPacket instanceDataPacket = new DatagramPacket(heartbeatEventDataBytes, heartbeatEventDataBytes.length,\n+                                InetAddress.getByName(GROUP), PORT);\n+\n+                        multicastSocket.send(instanceDataPacket);\n+                    } catch (Exception e) {\n+                        LOGGER.error(\"Failed to send heartbeat event for object: {}\", serviceInstanceMapForHeartbeat, e);\n+                    }\n+                }\n+            }\n+        };\n+        executor.scheduleAtFixedRate(heartbeatRunnable, CLIENT_DELAY, HEALTH_CHECK_INTERVAL, TimeUnit.SECONDS);\n+    }\n+\n+    public static Optional<Map<String, String>> convertToRegisterDataModel(String serviceId, String microserviceInstanceId,\n+                                                                           MicroserviceInstance microserviceInstance, Microservice microservice) {\n+        Map<String, String> serviceInstanceTextAttributesMap = new HashMap<>();\n+\n+        serviceInstanceTextAttributesMap.put(EVENT, REGISTER_EVENT);\n+        serviceInstanceTextAttributesMap.put(VERSION, microservice.getVersion());\n+        serviceInstanceTextAttributesMap.put(SERVICE_ID, serviceId);\n+        serviceInstanceTextAttributesMap.put(INSTANCE_ID, microserviceInstanceId);\n+        serviceInstanceTextAttributesMap.put(STATUS, microserviceInstance.getStatus().toString());\n+        serviceInstanceTextAttributesMap.put(APP_ID, microservice.getAppId());\n+        serviceInstanceTextAttributesMap.put(SERVICE_NAME, microservice.getServiceName());\n+\n+        String hostName = microserviceInstance.getHostName();\n+        serviceInstanceTextAttributesMap.put(HOST_NAME, hostName);\n+\n+        // schema1$schema2\n+        serviceInstanceTextAttributesMap.put(ENDPOINTS, convertListToString(microserviceInstance.getEndpoints()));\n+        serviceInstanceTextAttributesMap.put(SCHEMA_IDS, convertListToString(microservice.getSchemas()));\n+\n+        return Optional.of(serviceInstanceTextAttributesMap);\n+    }\n+\n+    private static String convertListToString (List<String> list){", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcxMTc4OA=="}, "originalCommit": {"oid": "bfeca6e794add76bc7216c490d93af6b20fe5931"}, "originalPosition": 98}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MzgxNzczOnYy", "diffSide": "RIGHT", "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/SchemaContentEndpoint.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwMjo1NTo1NlrOGX5kOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwMjo1Njo1M1rOGX5lEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcxMzU5NA==", "bodyText": "why schemaMap can be null?", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427713594", "createdAt": "2020-05-20T02:55:56Z", "author": {"login": "wujimin"}, "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/SchemaContentEndpoint.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.servicecomb.serviceregistry;\n+\n+import org.apache.servicecomb.provider.rest.common.RestSchema;\n+\n+import org.apache.servicecomb.serviceregistry.client.ClientUtil;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RequestMethod;\n+import org.springframework.web.bind.annotation.RequestParam;\n+import javax.ws.rs.core.MediaType;\n+import java.util.Map;\n+\n+import static org.apache.servicecomb.serviceregistry.ZeroConfigRegistryConstants.*;\n+\n+@RestSchema(schemaId = SCHEMA_CONTENT_ENDPOINT)\n+@RequestMapping(path = SCHEMA_CONTENT_ENDPOINT_BASE_PATH)\n+public class SchemaContentEndpoint {\n+    // each service self-expose this endpoint for others(consumers) to retrieve the schema content\n+    @RequestMapping(path = SCHEMA_CONTENT_ENDPOINT_SUBPATH, produces = MediaType.TEXT_PLAIN, method = RequestMethod.POST )\n+    public String getSchemaEndpoint(@RequestParam(name = SCHEMA_CONTENT_ENDPOINT_QUERY_KEYWORD) String schemaId) {\n+        Map<String, String> schemaMap = ClientUtil.microserviceSelf.getSchemaMap();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bfeca6e794add76bc7216c490d93af6b20fe5931"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcxMzgxMA==", "bodyText": "I relaized this too... can only be empy \ud83d\udc4d", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427713810", "createdAt": "2020-05-20T02:56:53Z", "author": {"login": "jungan21"}, "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/SchemaContentEndpoint.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.servicecomb.serviceregistry;\n+\n+import org.apache.servicecomb.provider.rest.common.RestSchema;\n+\n+import org.apache.servicecomb.serviceregistry.client.ClientUtil;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RequestMethod;\n+import org.springframework.web.bind.annotation.RequestParam;\n+import javax.ws.rs.core.MediaType;\n+import java.util.Map;\n+\n+import static org.apache.servicecomb.serviceregistry.ZeroConfigRegistryConstants.*;\n+\n+@RestSchema(schemaId = SCHEMA_CONTENT_ENDPOINT)\n+@RequestMapping(path = SCHEMA_CONTENT_ENDPOINT_BASE_PATH)\n+public class SchemaContentEndpoint {\n+    // each service self-expose this endpoint for others(consumers) to retrieve the schema content\n+    @RequestMapping(path = SCHEMA_CONTENT_ENDPOINT_SUBPATH, produces = MediaType.TEXT_PLAIN, method = RequestMethod.POST )\n+    public String getSchemaEndpoint(@RequestParam(name = SCHEMA_CONTENT_ENDPOINT_QUERY_KEYWORD) String schemaId) {\n+        Map<String, String> schemaMap = ClientUtil.microserviceSelf.getSchemaMap();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcxMzU5NA=="}, "originalCommit": {"oid": "bfeca6e794add76bc7216c490d93af6b20fe5931"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MzgxOTE3OnYy", "diffSide": "RIGHT", "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/SchemaContentEndpoint.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwMjo1Njo1OFrOGX5lIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwMjo1OTowMlrOGX5m_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcxMzgyNA==", "bodyText": "schemaMap.computeIfPresent(schemaId,  (key, schemaContent) -> { return schemaContent;}) \nwhat's the difference to schemaMap.get(schemaId)", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427713824", "createdAt": "2020-05-20T02:56:58Z", "author": {"login": "wujimin"}, "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/SchemaContentEndpoint.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.servicecomb.serviceregistry;\n+\n+import org.apache.servicecomb.provider.rest.common.RestSchema;\n+\n+import org.apache.servicecomb.serviceregistry.client.ClientUtil;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RequestMethod;\n+import org.springframework.web.bind.annotation.RequestParam;\n+import javax.ws.rs.core.MediaType;\n+import java.util.Map;\n+\n+import static org.apache.servicecomb.serviceregistry.ZeroConfigRegistryConstants.*;\n+\n+@RestSchema(schemaId = SCHEMA_CONTENT_ENDPOINT)\n+@RequestMapping(path = SCHEMA_CONTENT_ENDPOINT_BASE_PATH)\n+public class SchemaContentEndpoint {\n+    // each service self-expose this endpoint for others(consumers) to retrieve the schema content\n+    @RequestMapping(path = SCHEMA_CONTENT_ENDPOINT_SUBPATH, produces = MediaType.TEXT_PLAIN, method = RequestMethod.POST )\n+    public String getSchemaEndpoint(@RequestParam(name = SCHEMA_CONTENT_ENDPOINT_QUERY_KEYWORD) String schemaId) {\n+        Map<String, String> schemaMap = ClientUtil.microserviceSelf.getSchemaMap();\n+        return schemaMap != null ? schemaMap.computeIfPresent(schemaId,  (key, schemaContent) -> { return schemaContent;}) : null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bfeca6e794add76bc7216c490d93af6b20fe5931"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcxNDMwMg==", "bodyText": "will change this piece of code to the following:\n    Map<String, String> schemaMap = ClientUtil.microserviceSelf.getSchemaMap();\n    return schemaMap.get(schemaId);", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427714302", "createdAt": "2020-05-20T02:59:02Z", "author": {"login": "jungan21"}, "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/serviceregistry/SchemaContentEndpoint.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.servicecomb.serviceregistry;\n+\n+import org.apache.servicecomb.provider.rest.common.RestSchema;\n+\n+import org.apache.servicecomb.serviceregistry.client.ClientUtil;\n+import org.springframework.web.bind.annotation.RequestMapping;\n+import org.springframework.web.bind.annotation.RequestMethod;\n+import org.springframework.web.bind.annotation.RequestParam;\n+import javax.ws.rs.core.MediaType;\n+import java.util.Map;\n+\n+import static org.apache.servicecomb.serviceregistry.ZeroConfigRegistryConstants.*;\n+\n+@RestSchema(schemaId = SCHEMA_CONTENT_ENDPOINT)\n+@RequestMapping(path = SCHEMA_CONTENT_ENDPOINT_BASE_PATH)\n+public class SchemaContentEndpoint {\n+    // each service self-expose this endpoint for others(consumers) to retrieve the schema content\n+    @RequestMapping(path = SCHEMA_CONTENT_ENDPOINT_SUBPATH, produces = MediaType.TEXT_PLAIN, method = RequestMethod.POST )\n+    public String getSchemaEndpoint(@RequestParam(name = SCHEMA_CONTENT_ENDPOINT_QUERY_KEYWORD) String schemaId) {\n+        Map<String, String> schemaMap = ClientUtil.microserviceSelf.getSchemaMap();\n+        return schemaMap != null ? schemaMap.computeIfPresent(schemaId,  (key, schemaContent) -> { return schemaContent;}) : null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcxMzgyNA=="}, "originalCommit": {"oid": "bfeca6e794add76bc7216c490d93af6b20fe5931"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NDUxMDk1OnYy", "diffSide": "RIGHT", "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/zeroconfig/ZeroConfigRegistryApplicationListener.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwODoxNzoxMlrOGYAUxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxNToxMzoxM1rOGY24ww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzgyNDMyNw==", "bodyText": "It's better to use the same configuratioin mechansim, see: https://docs.servicecomb.io/java-chassis/zh_CN/config/general-config/\nand use a boolean value, e.g 'DynamicPropertyFacotry.getInstance().getBooleanProperty(\"servicecomb.zeroconfig.enabled\", true).get()`", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427824327", "createdAt": "2020-05-20T08:17:12Z", "author": {"login": "liubao68"}, "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/zeroconfig/ZeroConfigRegistryApplicationListener.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.servicecomb.zeroconfig;\n+\n+import org.apache.servicecomb.foundation.common.utils.BeanUtils;\n+import org.apache.servicecomb.serviceregistry.ServiceRegistry;\n+import org.apache.servicecomb.serviceregistry.client.ServiceRegistryClient;\n+import org.apache.servicecomb.serviceregistry.config.ServiceRegistryConfig;\n+\n+import org.apache.servicecomb.zeroconfig.client.ClientUtil;\n+import org.apache.servicecomb.zeroconfig.client.ZeroConfigRegistryClientImpl;\n+import org.apache.servicecomb.zeroconfig.server.ServerUtil;\n+import org.apache.servicecomb.zeroconfig.server.ZeroConfigRegistryService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.BeansException;\n+import org.springframework.context.ApplicationContext;\n+import org.springframework.context.ApplicationContextAware;\n+import org.springframework.context.ApplicationEvent;\n+import org.springframework.context.ApplicationListener;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.core.annotation.Order;\n+import org.springframework.web.client.RestTemplate;\n+\n+import java.io.IOException;\n+import java.net.MulticastSocket;\n+import java.util.function.Function;\n+\n+/**\n+ * ZeroConfigServiceRegistryClientImpl is injected before cse application listener (order is -1000)\n+ */\n+\n+@Configuration\n+@Order(-1001)\n+public class ZeroConfigRegistryApplicationListener implements ApplicationListener<ApplicationEvent>,\n+    ApplicationContextAware {\n+\n+  private static final Logger LOGGER = LoggerFactory\n+      .getLogger(ZeroConfigRegistryApplicationListener.class);\n+\n+  private ApplicationContext applicationContext;\n+  private MulticastSocket multicastSocket;\n+\n+  @Override\n+  public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\n+\n+    // same mechanism as Local registry to enable the Zero Config registry\n+    String flag = System.getProperty(ZeroConfigRegistryConstants.ZERO_CONFIG_REGISTRY_FLAG);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d708cd13939d8fcae02511228266a41868cbf013"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODcwNTYzNg==", "bodyText": "Thanks for sharing . will take a look at this mechanism", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r428705636", "createdAt": "2020-05-21T14:56:05Z", "author": {"login": "jungan21"}, "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/zeroconfig/ZeroConfigRegistryApplicationListener.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.servicecomb.zeroconfig;\n+\n+import org.apache.servicecomb.foundation.common.utils.BeanUtils;\n+import org.apache.servicecomb.serviceregistry.ServiceRegistry;\n+import org.apache.servicecomb.serviceregistry.client.ServiceRegistryClient;\n+import org.apache.servicecomb.serviceregistry.config.ServiceRegistryConfig;\n+\n+import org.apache.servicecomb.zeroconfig.client.ClientUtil;\n+import org.apache.servicecomb.zeroconfig.client.ZeroConfigRegistryClientImpl;\n+import org.apache.servicecomb.zeroconfig.server.ServerUtil;\n+import org.apache.servicecomb.zeroconfig.server.ZeroConfigRegistryService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.BeansException;\n+import org.springframework.context.ApplicationContext;\n+import org.springframework.context.ApplicationContextAware;\n+import org.springframework.context.ApplicationEvent;\n+import org.springframework.context.ApplicationListener;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.core.annotation.Order;\n+import org.springframework.web.client.RestTemplate;\n+\n+import java.io.IOException;\n+import java.net.MulticastSocket;\n+import java.util.function.Function;\n+\n+/**\n+ * ZeroConfigServiceRegistryClientImpl is injected before cse application listener (order is -1000)\n+ */\n+\n+@Configuration\n+@Order(-1001)\n+public class ZeroConfigRegistryApplicationListener implements ApplicationListener<ApplicationEvent>,\n+    ApplicationContextAware {\n+\n+  private static final Logger LOGGER = LoggerFactory\n+      .getLogger(ZeroConfigRegistryApplicationListener.class);\n+\n+  private ApplicationContext applicationContext;\n+  private MulticastSocket multicastSocket;\n+\n+  @Override\n+  public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\n+\n+    // same mechanism as Local registry to enable the Zero Config registry\n+    String flag = System.getProperty(ZeroConfigRegistryConstants.ZERO_CONFIG_REGISTRY_FLAG);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzgyNDMyNw=="}, "originalCommit": {"oid": "d708cd13939d8fcae02511228266a41868cbf013"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODcxODI3NQ==", "bodyText": "just to be safe,I will set default value to false.... for now", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r428718275", "createdAt": "2020-05-21T15:13:13Z", "author": {"login": "jungan21"}, "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/zeroconfig/ZeroConfigRegistryApplicationListener.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.servicecomb.zeroconfig;\n+\n+import org.apache.servicecomb.foundation.common.utils.BeanUtils;\n+import org.apache.servicecomb.serviceregistry.ServiceRegistry;\n+import org.apache.servicecomb.serviceregistry.client.ServiceRegistryClient;\n+import org.apache.servicecomb.serviceregistry.config.ServiceRegistryConfig;\n+\n+import org.apache.servicecomb.zeroconfig.client.ClientUtil;\n+import org.apache.servicecomb.zeroconfig.client.ZeroConfigRegistryClientImpl;\n+import org.apache.servicecomb.zeroconfig.server.ServerUtil;\n+import org.apache.servicecomb.zeroconfig.server.ZeroConfigRegistryService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.BeansException;\n+import org.springframework.context.ApplicationContext;\n+import org.springframework.context.ApplicationContextAware;\n+import org.springframework.context.ApplicationEvent;\n+import org.springframework.context.ApplicationListener;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.core.annotation.Order;\n+import org.springframework.web.client.RestTemplate;\n+\n+import java.io.IOException;\n+import java.net.MulticastSocket;\n+import java.util.function.Function;\n+\n+/**\n+ * ZeroConfigServiceRegistryClientImpl is injected before cse application listener (order is -1000)\n+ */\n+\n+@Configuration\n+@Order(-1001)\n+public class ZeroConfigRegistryApplicationListener implements ApplicationListener<ApplicationEvent>,\n+    ApplicationContextAware {\n+\n+  private static final Logger LOGGER = LoggerFactory\n+      .getLogger(ZeroConfigRegistryApplicationListener.class);\n+\n+  private ApplicationContext applicationContext;\n+  private MulticastSocket multicastSocket;\n+\n+  @Override\n+  public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\n+\n+    // same mechanism as Local registry to enable the Zero Config registry\n+    String flag = System.getProperty(ZeroConfigRegistryConstants.ZERO_CONFIG_REGISTRY_FLAG);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzgyNDMyNw=="}, "originalCommit": {"oid": "d708cd13939d8fcae02511228266a41868cbf013"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NDU0MTU3OnYy", "diffSide": "RIGHT", "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/zeroconfig/ZeroConfigRegistryApplicationListener.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwODoyNToxMlrOGYAoLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxNjoyOTo0MlrOGY58CQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzgyOTI5NQ==", "bodyText": "This attrubite is set but never read", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427829295", "createdAt": "2020-05-20T08:25:12Z", "author": {"login": "liubao68"}, "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/zeroconfig/ZeroConfigRegistryApplicationListener.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.servicecomb.zeroconfig;\n+\n+import org.apache.servicecomb.foundation.common.utils.BeanUtils;\n+import org.apache.servicecomb.serviceregistry.ServiceRegistry;\n+import org.apache.servicecomb.serviceregistry.client.ServiceRegistryClient;\n+import org.apache.servicecomb.serviceregistry.config.ServiceRegistryConfig;\n+\n+import org.apache.servicecomb.zeroconfig.client.ClientUtil;\n+import org.apache.servicecomb.zeroconfig.client.ZeroConfigRegistryClientImpl;\n+import org.apache.servicecomb.zeroconfig.server.ServerUtil;\n+import org.apache.servicecomb.zeroconfig.server.ZeroConfigRegistryService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.BeansException;\n+import org.springframework.context.ApplicationContext;\n+import org.springframework.context.ApplicationContextAware;\n+import org.springframework.context.ApplicationEvent;\n+import org.springframework.context.ApplicationListener;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.core.annotation.Order;\n+import org.springframework.web.client.RestTemplate;\n+\n+import java.io.IOException;\n+import java.net.MulticastSocket;\n+import java.util.function.Function;\n+\n+/**\n+ * ZeroConfigServiceRegistryClientImpl is injected before cse application listener (order is -1000)\n+ */\n+\n+@Configuration\n+@Order(-1001)\n+public class ZeroConfigRegistryApplicationListener implements ApplicationListener<ApplicationEvent>,\n+    ApplicationContextAware {\n+\n+  private static final Logger LOGGER = LoggerFactory\n+      .getLogger(ZeroConfigRegistryApplicationListener.class);\n+\n+  private ApplicationContext applicationContext;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d708cd13939d8fcae02511228266a41868cbf013"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODc2ODI2NQ==", "bodyText": "will deleted private ApplicationContext applicationContext; variable", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r428768265", "createdAt": "2020-05-21T16:29:42Z", "author": {"login": "jungan21"}, "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/zeroconfig/ZeroConfigRegistryApplicationListener.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.servicecomb.zeroconfig;\n+\n+import org.apache.servicecomb.foundation.common.utils.BeanUtils;\n+import org.apache.servicecomb.serviceregistry.ServiceRegistry;\n+import org.apache.servicecomb.serviceregistry.client.ServiceRegistryClient;\n+import org.apache.servicecomb.serviceregistry.config.ServiceRegistryConfig;\n+\n+import org.apache.servicecomb.zeroconfig.client.ClientUtil;\n+import org.apache.servicecomb.zeroconfig.client.ZeroConfigRegistryClientImpl;\n+import org.apache.servicecomb.zeroconfig.server.ServerUtil;\n+import org.apache.servicecomb.zeroconfig.server.ZeroConfigRegistryService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.BeansException;\n+import org.springframework.context.ApplicationContext;\n+import org.springframework.context.ApplicationContextAware;\n+import org.springframework.context.ApplicationEvent;\n+import org.springframework.context.ApplicationListener;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.core.annotation.Order;\n+import org.springframework.web.client.RestTemplate;\n+\n+import java.io.IOException;\n+import java.net.MulticastSocket;\n+import java.util.function.Function;\n+\n+/**\n+ * ZeroConfigServiceRegistryClientImpl is injected before cse application listener (order is -1000)\n+ */\n+\n+@Configuration\n+@Order(-1001)\n+public class ZeroConfigRegistryApplicationListener implements ApplicationListener<ApplicationEvent>,\n+    ApplicationContextAware {\n+\n+  private static final Logger LOGGER = LoggerFactory\n+      .getLogger(ZeroConfigRegistryApplicationListener.class);\n+\n+  private ApplicationContext applicationContext;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzgyOTI5NQ=="}, "originalCommit": {"oid": "d708cd13939d8fcae02511228266a41868cbf013"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NDU0NDkzOnYy", "diffSide": "RIGHT", "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/zeroconfig/ZeroConfigRegistryApplicationListener.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQwODoyNjowNFrOGYAqSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxNDo1ODowN1rOGY2Oyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzgyOTgzMw==", "bodyText": "Why need this line of code?", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r427829833", "createdAt": "2020-05-20T08:26:04Z", "author": {"login": "liubao68"}, "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/zeroconfig/ZeroConfigRegistryApplicationListener.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.servicecomb.zeroconfig;\n+\n+import org.apache.servicecomb.foundation.common.utils.BeanUtils;\n+import org.apache.servicecomb.serviceregistry.ServiceRegistry;\n+import org.apache.servicecomb.serviceregistry.client.ServiceRegistryClient;\n+import org.apache.servicecomb.serviceregistry.config.ServiceRegistryConfig;\n+\n+import org.apache.servicecomb.zeroconfig.client.ClientUtil;\n+import org.apache.servicecomb.zeroconfig.client.ZeroConfigRegistryClientImpl;\n+import org.apache.servicecomb.zeroconfig.server.ServerUtil;\n+import org.apache.servicecomb.zeroconfig.server.ZeroConfigRegistryService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.BeansException;\n+import org.springframework.context.ApplicationContext;\n+import org.springframework.context.ApplicationContextAware;\n+import org.springframework.context.ApplicationEvent;\n+import org.springframework.context.ApplicationListener;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.core.annotation.Order;\n+import org.springframework.web.client.RestTemplate;\n+\n+import java.io.IOException;\n+import java.net.MulticastSocket;\n+import java.util.function.Function;\n+\n+/**\n+ * ZeroConfigServiceRegistryClientImpl is injected before cse application listener (order is -1000)\n+ */\n+\n+@Configuration\n+@Order(-1001)\n+public class ZeroConfigRegistryApplicationListener implements ApplicationListener<ApplicationEvent>,\n+    ApplicationContextAware {\n+\n+  private static final Logger LOGGER = LoggerFactory\n+      .getLogger(ZeroConfigRegistryApplicationListener.class);\n+\n+  private ApplicationContext applicationContext;\n+  private MulticastSocket multicastSocket;\n+\n+  @Override\n+  public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\n+\n+    // same mechanism as Local registry to enable the Zero Config registry\n+    String flag = System.getProperty(ZeroConfigRegistryConstants.ZERO_CONFIG_REGISTRY_FLAG);\n+    if (flag != null && flag.equals(ZeroConfigRegistryConstants.ZERO_CONFIG_REGISTRY_ENABLE_FLAG)) {\n+      this.applicationContext = applicationContext;\n+      BeanUtils.setContext(applicationContext);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d708cd13939d8fcae02511228266a41868cbf013"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODcwNzUzMQ==", "bodyText": "it seems not necessary.. as we will st applicationContext in the  CseApplicationListener.  just to confirm, I will remove the following two lines:\n    this.applicationContext = applicationContext;\n     BeanUtils.setContext(applicationContext);", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1766#discussion_r428707531", "createdAt": "2020-05-21T14:58:07Z", "author": {"login": "jungan21"}, "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/zeroconfig/ZeroConfigRegistryApplicationListener.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.servicecomb.zeroconfig;\n+\n+import org.apache.servicecomb.foundation.common.utils.BeanUtils;\n+import org.apache.servicecomb.serviceregistry.ServiceRegistry;\n+import org.apache.servicecomb.serviceregistry.client.ServiceRegistryClient;\n+import org.apache.servicecomb.serviceregistry.config.ServiceRegistryConfig;\n+\n+import org.apache.servicecomb.zeroconfig.client.ClientUtil;\n+import org.apache.servicecomb.zeroconfig.client.ZeroConfigRegistryClientImpl;\n+import org.apache.servicecomb.zeroconfig.server.ServerUtil;\n+import org.apache.servicecomb.zeroconfig.server.ZeroConfigRegistryService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.BeansException;\n+import org.springframework.context.ApplicationContext;\n+import org.springframework.context.ApplicationContextAware;\n+import org.springframework.context.ApplicationEvent;\n+import org.springframework.context.ApplicationListener;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.core.annotation.Order;\n+import org.springframework.web.client.RestTemplate;\n+\n+import java.io.IOException;\n+import java.net.MulticastSocket;\n+import java.util.function.Function;\n+\n+/**\n+ * ZeroConfigServiceRegistryClientImpl is injected before cse application listener (order is -1000)\n+ */\n+\n+@Configuration\n+@Order(-1001)\n+public class ZeroConfigRegistryApplicationListener implements ApplicationListener<ApplicationEvent>,\n+    ApplicationContextAware {\n+\n+  private static final Logger LOGGER = LoggerFactory\n+      .getLogger(ZeroConfigRegistryApplicationListener.class);\n+\n+  private ApplicationContext applicationContext;\n+  private MulticastSocket multicastSocket;\n+\n+  @Override\n+  public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\n+\n+    // same mechanism as Local registry to enable the Zero Config registry\n+    String flag = System.getProperty(ZeroConfigRegistryConstants.ZERO_CONFIG_REGISTRY_FLAG);\n+    if (flag != null && flag.equals(ZeroConfigRegistryConstants.ZERO_CONFIG_REGISTRY_ENABLE_FLAG)) {\n+      this.applicationContext = applicationContext;\n+      BeanUtils.setContext(applicationContext);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzgyOTgzMw=="}, "originalCommit": {"oid": "d708cd13939d8fcae02511228266a41868cbf013"}, "originalPosition": 65}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1255, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}