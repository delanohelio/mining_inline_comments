{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDYyNDA4MjAx", "number": 3355, "reviewThreads": {"totalCount": 31, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNzo1MDoxOFrOEWTYeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNjowMTo1NlrOEXR1hA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxODIxNjkwOnYy", "diffSide": "RIGHT", "path": "spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/ZeroMqProxy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNzo1MDoxOFrOG9isRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNzo1MDoxOFrOG9isRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE4NDcwOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            /**\n          \n          \n            \n             * This class encapsulates a logic to configure and manage ZeroMQ proxy.\n          \n          \n            \n             * It binds frontend and backend sockets over TCP on all the available network interfaces\n          \n          \n            \n             * with provided ports or randomly selected otherwise.\n          \n          \n            \n             * <p>\n          \n          \n            \n             * The {@link ZeroMqProxy.Type} dictates which pair of ZeroMQ sockets to bind with this proxy\n          \n          \n            \n             * to implement any possible patterns for ZeroMQ intermediary. Defaults to @link {@link ZeroMqProxy.Type#PULL_PUSH}.\n          \n          \n            \n             * <p>\n          \n          \n            \n             * The control socket is exposed as a {@link SocketType#PAIR} with an inter-thread transport\n          \n          \n            \n             * on tne {@code \"inproc://\" + beanName + \".control\"} address - can be obtained via {@link #getControlAddress()}.\n          \n          \n            \n             * Should be used with the same application from {@link SocketType#PAIR} socket to send\n          \n          \n            \n             * {@link zmq.ZMQ#PROXY_TERMINATE}, {@link zmq.ZMQ#PROXY_PAUSE} and/or {@link zmq.ZMQ#PROXY_RESUME} commands.\n          \n          \n            \n             * <p>\n          \n          \n            \n             * If proxy cannot be started for some reason, the error message is logged respectively and this component is\n          \n          \n            \n             * left in the non-starting state.\n          \n          \n            \n            /**\n          \n          \n            \n             * This class encapsulates the logic to configure and manage a ZeroMQ proxy.\n          \n          \n            \n             * It binds frontend and backend sockets over TCP on all the available network interfaces\n          \n          \n            \n             * with either provided or randomly selected ports.\n          \n          \n            \n             * <p>\n          \n          \n            \n             * The {@link ZeroMqProxy.Type} dictates which pair of ZeroMQ sockets to bind with this proxy\n          \n          \n            \n             * to implement any possible patterns for ZeroMQ intermediary. Defaults to @link {@link ZeroMqProxy.Type#PULL_PUSH}.\n          \n          \n            \n             * <p>\n          \n          \n            \n             * The control socket is exposed as a {@link SocketType#PAIR} with an inter-thread transport\n          \n          \n            \n             * on tne {@code \"inproc://\" + beanName + \".control\"} address; it can be obtained via {@link #getControlAddress()}.\n          \n          \n            \n             * Should be used with the same application from {@link SocketType#PAIR} socket to send\n          \n          \n            \n             * {@link zmq.ZMQ#PROXY_TERMINATE}, {@link zmq.ZMQ#PROXY_PAUSE} and/or {@link zmq.ZMQ#PROXY_RESUME} commands.\n          \n          \n            \n             * <p>\n          \n          \n            \n             * If the proxy cannot be started for some reason, an error message is logged and this component is\n          \n          \n            \n             * left in the non-started state.", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r467184709", "createdAt": "2020-08-07T17:50:18Z", "author": {"login": "garyrussell"}, "path": "spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/ZeroMqProxy.java", "diffHunk": "@@ -0,0 +1,281 @@\n+/*\n+ * Copyright 2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.integration.zeromq;\n+\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Consumer;\n+\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.zeromq.SocketType;\n+import org.zeromq.ZContext;\n+import org.zeromq.ZMQ;\n+\n+import org.springframework.beans.factory.BeanNameAware;\n+import org.springframework.beans.factory.InitializingBean;\n+import org.springframework.context.SmartLifecycle;\n+import org.springframework.lang.Nullable;\n+import org.springframework.scheduling.concurrent.CustomizableThreadFactory;\n+import org.springframework.util.Assert;\n+\n+/**\n+ * This class encapsulates a logic to configure and manage ZeroMQ proxy.\n+ * It binds frontend and backend sockets over TCP on all the available network interfaces\n+ * with provided ports or randomly selected otherwise.\n+ * <p>\n+ * The {@link ZeroMqProxy.Type} dictates which pair of ZeroMQ sockets to bind with this proxy\n+ * to implement any possible patterns for ZeroMQ intermediary. Defaults to @link {@link ZeroMqProxy.Type#PULL_PUSH}.\n+ * <p>\n+ * The control socket is exposed as a {@link SocketType#PAIR} with an inter-thread transport\n+ * on tne {@code \"inproc://\" + beanName + \".control\"} address - can be obtained via {@link #getControlAddress()}.\n+ * Should be used with the same application from {@link SocketType#PAIR} socket to send\n+ * {@link zmq.ZMQ#PROXY_TERMINATE}, {@link zmq.ZMQ#PROXY_PAUSE} and/or {@link zmq.ZMQ#PROXY_RESUME} commands.\n+ * <p>\n+ * If proxy cannot be started for some reason, the error message is logged respectively and this component is\n+ * left in the non-starting state.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eec1ff14146553e7e03d2842232d05c770884183"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxODIyMjgyOnYy", "diffSide": "RIGHT", "path": "spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/ZeroMqProxy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNzo1MjoxNFrOG9iv4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxODowODo0MVrOG9jOxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE4NTYzMw==", "bodyText": "Needs DisposableBean to shut down the internal executor, if any.", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r467185633", "createdAt": "2020-08-07T17:52:14Z", "author": {"login": "garyrussell"}, "path": "spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/ZeroMqProxy.java", "diffHunk": "@@ -0,0 +1,281 @@\n+/*\n+ * Copyright 2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.integration.zeromq;\n+\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Consumer;\n+\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.zeromq.SocketType;\n+import org.zeromq.ZContext;\n+import org.zeromq.ZMQ;\n+\n+import org.springframework.beans.factory.BeanNameAware;\n+import org.springframework.beans.factory.InitializingBean;\n+import org.springframework.context.SmartLifecycle;\n+import org.springframework.lang.Nullable;\n+import org.springframework.scheduling.concurrent.CustomizableThreadFactory;\n+import org.springframework.util.Assert;\n+\n+/**\n+ * This class encapsulates a logic to configure and manage ZeroMQ proxy.\n+ * It binds frontend and backend sockets over TCP on all the available network interfaces\n+ * with provided ports or randomly selected otherwise.\n+ * <p>\n+ * The {@link ZeroMqProxy.Type} dictates which pair of ZeroMQ sockets to bind with this proxy\n+ * to implement any possible patterns for ZeroMQ intermediary. Defaults to @link {@link ZeroMqProxy.Type#PULL_PUSH}.\n+ * <p>\n+ * The control socket is exposed as a {@link SocketType#PAIR} with an inter-thread transport\n+ * on tne {@code \"inproc://\" + beanName + \".control\"} address - can be obtained via {@link #getControlAddress()}.\n+ * Should be used with the same application from {@link SocketType#PAIR} socket to send\n+ * {@link zmq.ZMQ#PROXY_TERMINATE}, {@link zmq.ZMQ#PROXY_PAUSE} and/or {@link zmq.ZMQ#PROXY_RESUME} commands.\n+ * <p>\n+ * If proxy cannot be started for some reason, the error message is logged respectively and this component is\n+ * left in the non-starting state.\n+ *\n+ * @author Artem Bilan\n+ *\n+ * @since 5.4\n+ *\n+ * @see ZMQ#proxy(ZMQ.Socket, ZMQ.Socket, ZMQ.Socket)\n+ */\n+public class ZeroMqProxy implements InitializingBean, SmartLifecycle, BeanNameAware {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eec1ff14146553e7e03d2842232d05c770884183"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE5MzU0MQ==", "bodyText": "I thought about that, but probably it is harmless since Executors.newSingleThreadExecutor() is a FinalizableDelegatedExecutorService.\nAlthough you might mean to still clean up the resource we don't hold any more...", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r467193541", "createdAt": "2020-08-07T18:08:41Z", "author": {"login": "artembilan"}, "path": "spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/ZeroMqProxy.java", "diffHunk": "@@ -0,0 +1,281 @@\n+/*\n+ * Copyright 2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.integration.zeromq;\n+\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Consumer;\n+\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.zeromq.SocketType;\n+import org.zeromq.ZContext;\n+import org.zeromq.ZMQ;\n+\n+import org.springframework.beans.factory.BeanNameAware;\n+import org.springframework.beans.factory.InitializingBean;\n+import org.springframework.context.SmartLifecycle;\n+import org.springframework.lang.Nullable;\n+import org.springframework.scheduling.concurrent.CustomizableThreadFactory;\n+import org.springframework.util.Assert;\n+\n+/**\n+ * This class encapsulates a logic to configure and manage ZeroMQ proxy.\n+ * It binds frontend and backend sockets over TCP on all the available network interfaces\n+ * with provided ports or randomly selected otherwise.\n+ * <p>\n+ * The {@link ZeroMqProxy.Type} dictates which pair of ZeroMQ sockets to bind with this proxy\n+ * to implement any possible patterns for ZeroMQ intermediary. Defaults to @link {@link ZeroMqProxy.Type#PULL_PUSH}.\n+ * <p>\n+ * The control socket is exposed as a {@link SocketType#PAIR} with an inter-thread transport\n+ * on tne {@code \"inproc://\" + beanName + \".control\"} address - can be obtained via {@link #getControlAddress()}.\n+ * Should be used with the same application from {@link SocketType#PAIR} socket to send\n+ * {@link zmq.ZMQ#PROXY_TERMINATE}, {@link zmq.ZMQ#PROXY_PAUSE} and/or {@link zmq.ZMQ#PROXY_RESUME} commands.\n+ * <p>\n+ * If proxy cannot be started for some reason, the error message is logged respectively and this component is\n+ * left in the non-starting state.\n+ *\n+ * @author Artem Bilan\n+ *\n+ * @since 5.4\n+ *\n+ * @see ZMQ#proxy(ZMQ.Socket, ZMQ.Socket, ZMQ.Socket)\n+ */\n+public class ZeroMqProxy implements InitializingBean, SmartLifecycle, BeanNameAware {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE4NTYzMw=="}, "originalCommit": {"oid": "eec1ff14146553e7e03d2842232d05c770884183"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxODIzMjgyOnYy", "diffSide": "RIGHT", "path": "spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/channel/ZeroMqChannel.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNzo1NToyM1rOG9i16w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMFQxNDozMTo1NlrOG-RIZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE4NzE3OQ==", "bodyText": "Need Meters?\nWhat about send failures?", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r467187179", "createdAt": "2020-08-07T17:55:23Z", "author": {"login": "garyrussell"}, "path": "spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/channel/ZeroMqChannel.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Copyright 2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.integration.zeromq.channel;\n+\n+import java.time.Duration;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.function.Supplier;\n+\n+import org.zeromq.SocketType;\n+import org.zeromq.ZContext;\n+import org.zeromq.ZMQ;\n+\n+import org.springframework.integration.channel.AbstractMessageChannel;\n+import org.springframework.integration.mapping.BytesMessageMapper;\n+import org.springframework.integration.support.json.EmbeddedJsonHeadersMessageMapper;\n+import org.springframework.lang.Nullable;\n+import org.springframework.messaging.Message;\n+import org.springframework.messaging.MessageHandler;\n+import org.springframework.messaging.SubscribableChannel;\n+import org.springframework.util.Assert;\n+\n+import reactor.core.Disposable;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+/**\n+ * @author Artem Bilan\n+ *\n+ * @since 5.4\n+ */\n+public class ZeroMqChannel extends AbstractMessageChannel implements SubscribableChannel {\n+\n+\tprivate final Map<MessageHandler, Disposable> subscribers = new HashMap<>();\n+\n+\tprivate final Scheduler publisherScheduler = Schedulers.newSingle(\"publisherScheduler\");\n+\n+\tprivate final Scheduler subscriberScheduler = Schedulers.newSingle(\"subscriberScheduler\");\n+\n+\tprivate final ZContext context;\n+\n+\tprivate final boolean pubSub;\n+\n+\tprivate final Mono<ZMQ.Socket> sendSocket;\n+\n+\tprivate final Mono<ZMQ.Socket> subscribeSocket;\n+\n+\tprivate final Flux<? extends Message<?>> subscriberData;\n+\n+\tprivate BytesMessageMapper messageMapper = new EmbeddedJsonHeadersMessageMapper();\n+\n+\t@Nullable\n+\tprivate volatile String connectSendUrl;\n+\n+\t@Nullable\n+\tprivate volatile String connectSubscribeUrl;\n+\n+\t@Nullable\n+\tprivate volatile Disposable subscriberDataDisposable;\n+\n+\tprivate volatile boolean initialized;\n+\n+\tpublic ZeroMqChannel(ZContext context) {\n+\t\tthis(context, false);\n+\t}\n+\n+\tpublic ZeroMqChannel(ZContext context, boolean pubSub) {\n+\t\tAssert.notNull(context, \"'context' must not be null\");\n+\t\tthis.context = context;\n+\t\tthis.pubSub = pubSub;\n+\n+\t\tSupplier<String> localPairConnection = () -> \"inproc://\" + getComponentName() + \".pair\";\n+\n+\t\tthis.sendSocket =\n+\t\t\t\tMono.fromCallable(() ->\n+\t\t\t\t\t\tthis.context.createSocket(\n+\t\t\t\t\t\t\t\tthis.connectSendUrl == null\n+\t\t\t\t\t\t\t\t\t\t? SocketType.PAIR\n+\t\t\t\t\t\t\t\t\t\t: (this.pubSub ? SocketType.XPUB : SocketType.PUSH))\n+\t\t\t\t)\n+\t\t\t\t\t\t.publishOn(this.publisherScheduler)\n+\t\t\t\t\t\t.doOnNext((socket) ->\n+\t\t\t\t\t\t\t\tsocket.connect(this.connectSendUrl != null\n+\t\t\t\t\t\t\t\t\t\t? this.connectSendUrl\n+\t\t\t\t\t\t\t\t\t\t: localPairConnection.get()))\n+\t\t\t\t\t\t.delayUntil((socket) -> (this.pubSub && this.connectSendUrl != null)\n+\t\t\t\t\t\t\t\t? Mono.just(socket).map(ZMQ.Socket::recv)\n+\t\t\t\t\t\t\t\t: Mono.empty())\n+\t\t\t\t\t\t.cache();\n+\n+\t\tthis.subscribeSocket =\n+\t\t\t\tMono.fromCallable(() ->\n+\t\t\t\t\t\tthis.context.createSocket(\n+\t\t\t\t\t\t\t\tthis.connectSubscribeUrl == null\n+\t\t\t\t\t\t\t\t\t\t? SocketType.PAIR\n+\t\t\t\t\t\t\t\t\t\t: (this.pubSub ? SocketType.SUB : SocketType.PULL)))\n+\t\t\t\t\t\t.publishOn(this.subscriberScheduler)\n+\t\t\t\t\t\t.doOnNext((socket) -> {\n+\t\t\t\t\t\t\tif (this.connectSubscribeUrl != null) {\n+\t\t\t\t\t\t\t\tsocket.connect(this.connectSubscribeUrl);\n+\t\t\t\t\t\t\t\tif (this.pubSub) {\n+\t\t\t\t\t\t\t\t\tsocket.subscribe(ZMQ.SUBSCRIPTION_ALL);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\telse {\n+\t\t\t\t\t\t\t\tsocket.bind(localPairConnection.get());\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t})\n+\t\t\t\t\t\t.cache();\n+\n+\t\tFlux<? extends Message<?>> receiveData =\n+\t\t\t\tthis.subscribeSocket\n+\t\t\t\t\t\t.flatMap((socket) -> {\n+\t\t\t\t\t\t\tif (this.initialized) {\n+\t\t\t\t\t\t\t\tbyte[] data = socket.recv(ZMQ.NOBLOCK);\n+\t\t\t\t\t\t\t\tif (data != null) {\n+\t\t\t\t\t\t\t\t\treturn Mono.just(data);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\treturn Mono.empty();\n+\t\t\t\t\t\t})\n+\t\t\t\t\t\t.publishOn(Schedulers.parallel())\n+\t\t\t\t\t\t.map(this.messageMapper::toMessage)\n+\t\t\t\t\t\t.doOnError((error) -> logger.error(\"Error processing ZeroMQ message\", error))\n+\t\t\t\t\t\t.repeatWhenEmpty((repeat) ->\n+\t\t\t\t\t\t\t\tthis.initialized\n+\t\t\t\t\t\t\t\t\t\t? repeat.delayElements(Duration.ofMillis(100))\n+\t\t\t\t\t\t\t\t\t\t: repeat)\n+\t\t\t\t\t\t.repeat(() -> this.initialized);\n+\n+\t\tif (this.pubSub) {\n+\t\t\treceiveData = receiveData.publish()\n+\t\t\t\t\t.autoConnect(1, (disposable) -> this.subscriberDataDisposable = disposable);\n+\t\t}\n+\n+\t\tthis.subscriberData = receiveData;\n+\n+\t}\n+\n+\tpublic void setConnectUrl(@Nullable String connectUrl) {\n+\t\tif (connectUrl != null) {\n+\t\t\tthis.connectSendUrl = connectUrl.substring(0, connectUrl.lastIndexOf(':'));\n+\t\t\tthis.connectSubscribeUrl =\n+\t\t\t\t\tthis.connectSendUrl.substring(0, this.connectSendUrl.lastIndexOf(':'))\n+\t\t\t\t\t\t\t+ connectUrl.substring(connectUrl.lastIndexOf(':'));\n+\t\t}\n+\t}\n+\n+\tpublic void setMessageMapper(BytesMessageMapper messageMapper) {\n+\t\tAssert.notNull(messageMapper, \"'messageMapper' must not be null\");\n+\t\tthis.messageMapper = messageMapper;\n+\t}\n+\n+\t@Override\n+\tprotected void onInit() {\n+\t\tsuper.onInit();\n+\t\tthis.sendSocket.subscribe();\n+\t\tthis.initialized = true;\n+\t}\n+\n+\t@Override\n+\tprotected boolean doSend(Message<?> message, long timeout) {\n+\t\tAssert.state(this.initialized, \"the channel is not initialized yet or already destroyed\");\n+\n+\t\tbyte[] data = this.messageMapper.fromMessage(message);\n+\t\tAssert.state(data != null, () -> \"The '\" + this.messageMapper + \"' returned null for '\" + message + '\\'');\n+\n+\t\tMono<Boolean> sendMono = this.sendSocket.map((socket) -> socket.send(data));\n+\t\tBoolean sent =\n+\t\t\t\ttimeout > 0\n+\t\t\t\t\t\t? sendMono.block(Duration.ofMillis(timeout))\n+\t\t\t\t\t\t: sendMono.block();\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eec1ff14146553e7e03d2842232d05c770884183"}, "originalPosition": 190}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE5MjUxMQ==", "bodyText": "Send failure is going to be bubbled from this block as an exception.\nnot sure what you mean with meters.\nThis is doSend() impl. I think AbstractMessageChannel covers us with them...", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r467192511", "createdAt": "2020-08-07T18:06:31Z", "author": {"login": "artembilan"}, "path": "spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/channel/ZeroMqChannel.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Copyright 2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.integration.zeromq.channel;\n+\n+import java.time.Duration;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.function.Supplier;\n+\n+import org.zeromq.SocketType;\n+import org.zeromq.ZContext;\n+import org.zeromq.ZMQ;\n+\n+import org.springframework.integration.channel.AbstractMessageChannel;\n+import org.springframework.integration.mapping.BytesMessageMapper;\n+import org.springframework.integration.support.json.EmbeddedJsonHeadersMessageMapper;\n+import org.springframework.lang.Nullable;\n+import org.springframework.messaging.Message;\n+import org.springframework.messaging.MessageHandler;\n+import org.springframework.messaging.SubscribableChannel;\n+import org.springframework.util.Assert;\n+\n+import reactor.core.Disposable;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+/**\n+ * @author Artem Bilan\n+ *\n+ * @since 5.4\n+ */\n+public class ZeroMqChannel extends AbstractMessageChannel implements SubscribableChannel {\n+\n+\tprivate final Map<MessageHandler, Disposable> subscribers = new HashMap<>();\n+\n+\tprivate final Scheduler publisherScheduler = Schedulers.newSingle(\"publisherScheduler\");\n+\n+\tprivate final Scheduler subscriberScheduler = Schedulers.newSingle(\"subscriberScheduler\");\n+\n+\tprivate final ZContext context;\n+\n+\tprivate final boolean pubSub;\n+\n+\tprivate final Mono<ZMQ.Socket> sendSocket;\n+\n+\tprivate final Mono<ZMQ.Socket> subscribeSocket;\n+\n+\tprivate final Flux<? extends Message<?>> subscriberData;\n+\n+\tprivate BytesMessageMapper messageMapper = new EmbeddedJsonHeadersMessageMapper();\n+\n+\t@Nullable\n+\tprivate volatile String connectSendUrl;\n+\n+\t@Nullable\n+\tprivate volatile String connectSubscribeUrl;\n+\n+\t@Nullable\n+\tprivate volatile Disposable subscriberDataDisposable;\n+\n+\tprivate volatile boolean initialized;\n+\n+\tpublic ZeroMqChannel(ZContext context) {\n+\t\tthis(context, false);\n+\t}\n+\n+\tpublic ZeroMqChannel(ZContext context, boolean pubSub) {\n+\t\tAssert.notNull(context, \"'context' must not be null\");\n+\t\tthis.context = context;\n+\t\tthis.pubSub = pubSub;\n+\n+\t\tSupplier<String> localPairConnection = () -> \"inproc://\" + getComponentName() + \".pair\";\n+\n+\t\tthis.sendSocket =\n+\t\t\t\tMono.fromCallable(() ->\n+\t\t\t\t\t\tthis.context.createSocket(\n+\t\t\t\t\t\t\t\tthis.connectSendUrl == null\n+\t\t\t\t\t\t\t\t\t\t? SocketType.PAIR\n+\t\t\t\t\t\t\t\t\t\t: (this.pubSub ? SocketType.XPUB : SocketType.PUSH))\n+\t\t\t\t)\n+\t\t\t\t\t\t.publishOn(this.publisherScheduler)\n+\t\t\t\t\t\t.doOnNext((socket) ->\n+\t\t\t\t\t\t\t\tsocket.connect(this.connectSendUrl != null\n+\t\t\t\t\t\t\t\t\t\t? this.connectSendUrl\n+\t\t\t\t\t\t\t\t\t\t: localPairConnection.get()))\n+\t\t\t\t\t\t.delayUntil((socket) -> (this.pubSub && this.connectSendUrl != null)\n+\t\t\t\t\t\t\t\t? Mono.just(socket).map(ZMQ.Socket::recv)\n+\t\t\t\t\t\t\t\t: Mono.empty())\n+\t\t\t\t\t\t.cache();\n+\n+\t\tthis.subscribeSocket =\n+\t\t\t\tMono.fromCallable(() ->\n+\t\t\t\t\t\tthis.context.createSocket(\n+\t\t\t\t\t\t\t\tthis.connectSubscribeUrl == null\n+\t\t\t\t\t\t\t\t\t\t? SocketType.PAIR\n+\t\t\t\t\t\t\t\t\t\t: (this.pubSub ? SocketType.SUB : SocketType.PULL)))\n+\t\t\t\t\t\t.publishOn(this.subscriberScheduler)\n+\t\t\t\t\t\t.doOnNext((socket) -> {\n+\t\t\t\t\t\t\tif (this.connectSubscribeUrl != null) {\n+\t\t\t\t\t\t\t\tsocket.connect(this.connectSubscribeUrl);\n+\t\t\t\t\t\t\t\tif (this.pubSub) {\n+\t\t\t\t\t\t\t\t\tsocket.subscribe(ZMQ.SUBSCRIPTION_ALL);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\telse {\n+\t\t\t\t\t\t\t\tsocket.bind(localPairConnection.get());\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t})\n+\t\t\t\t\t\t.cache();\n+\n+\t\tFlux<? extends Message<?>> receiveData =\n+\t\t\t\tthis.subscribeSocket\n+\t\t\t\t\t\t.flatMap((socket) -> {\n+\t\t\t\t\t\t\tif (this.initialized) {\n+\t\t\t\t\t\t\t\tbyte[] data = socket.recv(ZMQ.NOBLOCK);\n+\t\t\t\t\t\t\t\tif (data != null) {\n+\t\t\t\t\t\t\t\t\treturn Mono.just(data);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\treturn Mono.empty();\n+\t\t\t\t\t\t})\n+\t\t\t\t\t\t.publishOn(Schedulers.parallel())\n+\t\t\t\t\t\t.map(this.messageMapper::toMessage)\n+\t\t\t\t\t\t.doOnError((error) -> logger.error(\"Error processing ZeroMQ message\", error))\n+\t\t\t\t\t\t.repeatWhenEmpty((repeat) ->\n+\t\t\t\t\t\t\t\tthis.initialized\n+\t\t\t\t\t\t\t\t\t\t? repeat.delayElements(Duration.ofMillis(100))\n+\t\t\t\t\t\t\t\t\t\t: repeat)\n+\t\t\t\t\t\t.repeat(() -> this.initialized);\n+\n+\t\tif (this.pubSub) {\n+\t\t\treceiveData = receiveData.publish()\n+\t\t\t\t\t.autoConnect(1, (disposable) -> this.subscriberDataDisposable = disposable);\n+\t\t}\n+\n+\t\tthis.subscriberData = receiveData;\n+\n+\t}\n+\n+\tpublic void setConnectUrl(@Nullable String connectUrl) {\n+\t\tif (connectUrl != null) {\n+\t\t\tthis.connectSendUrl = connectUrl.substring(0, connectUrl.lastIndexOf(':'));\n+\t\t\tthis.connectSubscribeUrl =\n+\t\t\t\t\tthis.connectSendUrl.substring(0, this.connectSendUrl.lastIndexOf(':'))\n+\t\t\t\t\t\t\t+ connectUrl.substring(connectUrl.lastIndexOf(':'));\n+\t\t}\n+\t}\n+\n+\tpublic void setMessageMapper(BytesMessageMapper messageMapper) {\n+\t\tAssert.notNull(messageMapper, \"'messageMapper' must not be null\");\n+\t\tthis.messageMapper = messageMapper;\n+\t}\n+\n+\t@Override\n+\tprotected void onInit() {\n+\t\tsuper.onInit();\n+\t\tthis.sendSocket.subscribe();\n+\t\tthis.initialized = true;\n+\t}\n+\n+\t@Override\n+\tprotected boolean doSend(Message<?> message, long timeout) {\n+\t\tAssert.state(this.initialized, \"the channel is not initialized yet or already destroyed\");\n+\n+\t\tbyte[] data = this.messageMapper.fromMessage(message);\n+\t\tAssert.state(data != null, () -> \"The '\" + this.messageMapper + \"' returned null for '\" + message + '\\'');\n+\n+\t\tMono<Boolean> sendMono = this.sendSocket.map((socket) -> socket.send(data));\n+\t\tBoolean sent =\n+\t\t\t\ttimeout > 0\n+\t\t\t\t\t\t? sendMono.block(Duration.ofMillis(timeout))\n+\t\t\t\t\t\t: sendMono.block();\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE4NzE3OQ=="}, "originalCommit": {"oid": "eec1ff14146553e7e03d2842232d05c770884183"}, "originalPosition": 190}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzk0NTU3NQ==", "bodyText": "Oh; right - I was thinking about amqp and jms having meters - but that's for pollable channels.", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r467945575", "createdAt": "2020-08-10T14:31:56Z", "author": {"login": "garyrussell"}, "path": "spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/channel/ZeroMqChannel.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Copyright 2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.integration.zeromq.channel;\n+\n+import java.time.Duration;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.function.Supplier;\n+\n+import org.zeromq.SocketType;\n+import org.zeromq.ZContext;\n+import org.zeromq.ZMQ;\n+\n+import org.springframework.integration.channel.AbstractMessageChannel;\n+import org.springframework.integration.mapping.BytesMessageMapper;\n+import org.springframework.integration.support.json.EmbeddedJsonHeadersMessageMapper;\n+import org.springframework.lang.Nullable;\n+import org.springframework.messaging.Message;\n+import org.springframework.messaging.MessageHandler;\n+import org.springframework.messaging.SubscribableChannel;\n+import org.springframework.util.Assert;\n+\n+import reactor.core.Disposable;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+/**\n+ * @author Artem Bilan\n+ *\n+ * @since 5.4\n+ */\n+public class ZeroMqChannel extends AbstractMessageChannel implements SubscribableChannel {\n+\n+\tprivate final Map<MessageHandler, Disposable> subscribers = new HashMap<>();\n+\n+\tprivate final Scheduler publisherScheduler = Schedulers.newSingle(\"publisherScheduler\");\n+\n+\tprivate final Scheduler subscriberScheduler = Schedulers.newSingle(\"subscriberScheduler\");\n+\n+\tprivate final ZContext context;\n+\n+\tprivate final boolean pubSub;\n+\n+\tprivate final Mono<ZMQ.Socket> sendSocket;\n+\n+\tprivate final Mono<ZMQ.Socket> subscribeSocket;\n+\n+\tprivate final Flux<? extends Message<?>> subscriberData;\n+\n+\tprivate BytesMessageMapper messageMapper = new EmbeddedJsonHeadersMessageMapper();\n+\n+\t@Nullable\n+\tprivate volatile String connectSendUrl;\n+\n+\t@Nullable\n+\tprivate volatile String connectSubscribeUrl;\n+\n+\t@Nullable\n+\tprivate volatile Disposable subscriberDataDisposable;\n+\n+\tprivate volatile boolean initialized;\n+\n+\tpublic ZeroMqChannel(ZContext context) {\n+\t\tthis(context, false);\n+\t}\n+\n+\tpublic ZeroMqChannel(ZContext context, boolean pubSub) {\n+\t\tAssert.notNull(context, \"'context' must not be null\");\n+\t\tthis.context = context;\n+\t\tthis.pubSub = pubSub;\n+\n+\t\tSupplier<String> localPairConnection = () -> \"inproc://\" + getComponentName() + \".pair\";\n+\n+\t\tthis.sendSocket =\n+\t\t\t\tMono.fromCallable(() ->\n+\t\t\t\t\t\tthis.context.createSocket(\n+\t\t\t\t\t\t\t\tthis.connectSendUrl == null\n+\t\t\t\t\t\t\t\t\t\t? SocketType.PAIR\n+\t\t\t\t\t\t\t\t\t\t: (this.pubSub ? SocketType.XPUB : SocketType.PUSH))\n+\t\t\t\t)\n+\t\t\t\t\t\t.publishOn(this.publisherScheduler)\n+\t\t\t\t\t\t.doOnNext((socket) ->\n+\t\t\t\t\t\t\t\tsocket.connect(this.connectSendUrl != null\n+\t\t\t\t\t\t\t\t\t\t? this.connectSendUrl\n+\t\t\t\t\t\t\t\t\t\t: localPairConnection.get()))\n+\t\t\t\t\t\t.delayUntil((socket) -> (this.pubSub && this.connectSendUrl != null)\n+\t\t\t\t\t\t\t\t? Mono.just(socket).map(ZMQ.Socket::recv)\n+\t\t\t\t\t\t\t\t: Mono.empty())\n+\t\t\t\t\t\t.cache();\n+\n+\t\tthis.subscribeSocket =\n+\t\t\t\tMono.fromCallable(() ->\n+\t\t\t\t\t\tthis.context.createSocket(\n+\t\t\t\t\t\t\t\tthis.connectSubscribeUrl == null\n+\t\t\t\t\t\t\t\t\t\t? SocketType.PAIR\n+\t\t\t\t\t\t\t\t\t\t: (this.pubSub ? SocketType.SUB : SocketType.PULL)))\n+\t\t\t\t\t\t.publishOn(this.subscriberScheduler)\n+\t\t\t\t\t\t.doOnNext((socket) -> {\n+\t\t\t\t\t\t\tif (this.connectSubscribeUrl != null) {\n+\t\t\t\t\t\t\t\tsocket.connect(this.connectSubscribeUrl);\n+\t\t\t\t\t\t\t\tif (this.pubSub) {\n+\t\t\t\t\t\t\t\t\tsocket.subscribe(ZMQ.SUBSCRIPTION_ALL);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\telse {\n+\t\t\t\t\t\t\t\tsocket.bind(localPairConnection.get());\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t})\n+\t\t\t\t\t\t.cache();\n+\n+\t\tFlux<? extends Message<?>> receiveData =\n+\t\t\t\tthis.subscribeSocket\n+\t\t\t\t\t\t.flatMap((socket) -> {\n+\t\t\t\t\t\t\tif (this.initialized) {\n+\t\t\t\t\t\t\t\tbyte[] data = socket.recv(ZMQ.NOBLOCK);\n+\t\t\t\t\t\t\t\tif (data != null) {\n+\t\t\t\t\t\t\t\t\treturn Mono.just(data);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\treturn Mono.empty();\n+\t\t\t\t\t\t})\n+\t\t\t\t\t\t.publishOn(Schedulers.parallel())\n+\t\t\t\t\t\t.map(this.messageMapper::toMessage)\n+\t\t\t\t\t\t.doOnError((error) -> logger.error(\"Error processing ZeroMQ message\", error))\n+\t\t\t\t\t\t.repeatWhenEmpty((repeat) ->\n+\t\t\t\t\t\t\t\tthis.initialized\n+\t\t\t\t\t\t\t\t\t\t? repeat.delayElements(Duration.ofMillis(100))\n+\t\t\t\t\t\t\t\t\t\t: repeat)\n+\t\t\t\t\t\t.repeat(() -> this.initialized);\n+\n+\t\tif (this.pubSub) {\n+\t\t\treceiveData = receiveData.publish()\n+\t\t\t\t\t.autoConnect(1, (disposable) -> this.subscriberDataDisposable = disposable);\n+\t\t}\n+\n+\t\tthis.subscriberData = receiveData;\n+\n+\t}\n+\n+\tpublic void setConnectUrl(@Nullable String connectUrl) {\n+\t\tif (connectUrl != null) {\n+\t\t\tthis.connectSendUrl = connectUrl.substring(0, connectUrl.lastIndexOf(':'));\n+\t\t\tthis.connectSubscribeUrl =\n+\t\t\t\t\tthis.connectSendUrl.substring(0, this.connectSendUrl.lastIndexOf(':'))\n+\t\t\t\t\t\t\t+ connectUrl.substring(connectUrl.lastIndexOf(':'));\n+\t\t}\n+\t}\n+\n+\tpublic void setMessageMapper(BytesMessageMapper messageMapper) {\n+\t\tAssert.notNull(messageMapper, \"'messageMapper' must not be null\");\n+\t\tthis.messageMapper = messageMapper;\n+\t}\n+\n+\t@Override\n+\tprotected void onInit() {\n+\t\tsuper.onInit();\n+\t\tthis.sendSocket.subscribe();\n+\t\tthis.initialized = true;\n+\t}\n+\n+\t@Override\n+\tprotected boolean doSend(Message<?> message, long timeout) {\n+\t\tAssert.state(this.initialized, \"the channel is not initialized yet or already destroyed\");\n+\n+\t\tbyte[] data = this.messageMapper.fromMessage(message);\n+\t\tAssert.state(data != null, () -> \"The '\" + this.messageMapper + \"' returned null for '\" + message + '\\'');\n+\n+\t\tMono<Boolean> sendMono = this.sendSocket.map((socket) -> socket.send(data));\n+\t\tBoolean sent =\n+\t\t\t\ttimeout > 0\n+\t\t\t\t\t\t? sendMono.block(Duration.ofMillis(timeout))\n+\t\t\t\t\t\t: sendMono.block();\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE4NzE3OQ=="}, "originalCommit": {"oid": "eec1ff14146553e7e03d2842232d05c770884183"}, "originalPosition": 190}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyMDc4NjkwOnYy", "diffSide": "RIGHT", "path": "spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/ZeroMqProxy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOVQwNjo1NjowMFrOG94uLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOVQwNjo1NjowMFrOG94uLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzU0NTY0NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * on tne {@code \"inproc://\" + beanName + \".control\"} address; it can be obtained via {@link #getControlAddress()}.\n          \n          \n            \n             * on the {@code \"inproc://\" + beanName + \".control\"} address; it can be obtained via {@link #getControlAddress()}.", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r467545645", "createdAt": "2020-08-09T06:56:00Z", "author": {"login": "oli-ver"}, "path": "spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/ZeroMqProxy.java", "diffHunk": "@@ -0,0 +1,341 @@\n+/*\n+ * Copyright 2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.integration.zeromq;\n+\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Consumer;\n+\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.zeromq.SocketType;\n+import org.zeromq.ZContext;\n+import org.zeromq.ZMQ;\n+\n+import org.springframework.beans.factory.BeanNameAware;\n+import org.springframework.beans.factory.DisposableBean;\n+import org.springframework.beans.factory.InitializingBean;\n+import org.springframework.context.SmartLifecycle;\n+import org.springframework.lang.Nullable;\n+import org.springframework.scheduling.concurrent.CustomizableThreadFactory;\n+import org.springframework.util.Assert;\n+\n+/**\n+ * This class encapsulates the logic to configure and manage a ZeroMQ proxy.\n+ * It binds frontend and backend sockets over TCP on all the available network interfaces\n+ * with either provided or randomly selected ports.\n+ * <p>\n+ * The {@link ZeroMqProxy.Type} dictates which pair of ZeroMQ sockets to bind with this proxy\n+ * to implement any possible patterns for ZeroMQ intermediary. Defaults to @link {@link ZeroMqProxy.Type#PULL_PUSH}.\n+ * <p>\n+ * The control socket is exposed as a {@link SocketType#PAIR} with an inter-thread transport\n+ * on tne {@code \"inproc://\" + beanName + \".control\"} address; it can be obtained via {@link #getControlAddress()}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5e3ec53931af67b8c15a833721162f70e276855"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyMDc5MDA3OnYy", "diffSide": "RIGHT", "path": "spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/channel/ZeroMqChannel.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOVQwNzowMDozM1rOG94vow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOVQwNzowMDozM1rOG94vow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzU0NjAxOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * This way a sending and receiving operations on this channel are similar to interaction over a messaging broker.\n          \n          \n            \n             * This way sending and receiving operations on this channel are similar to interaction over a messaging broker.", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r467546019", "createdAt": "2020-08-09T07:00:33Z", "author": {"login": "oli-ver"}, "path": "spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/channel/ZeroMqChannel.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/*\n+ * Copyright 2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.integration.zeromq.channel;\n+\n+import java.time.Duration;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.function.Supplier;\n+\n+import org.zeromq.SocketType;\n+import org.zeromq.ZContext;\n+import org.zeromq.ZMQ;\n+\n+import org.springframework.integration.channel.AbstractMessageChannel;\n+import org.springframework.integration.mapping.BytesMessageMapper;\n+import org.springframework.integration.support.json.EmbeddedJsonHeadersMessageMapper;\n+import org.springframework.lang.Nullable;\n+import org.springframework.messaging.Message;\n+import org.springframework.messaging.MessageHandler;\n+import org.springframework.messaging.SubscribableChannel;\n+import org.springframework.util.Assert;\n+\n+import reactor.core.Disposable;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+/**\n+ * The {@link SubscribableChannel} implementation over ZeroMQ sockets.\n+ * It can work in two messaging models:\n+ * - {@code push-pull}, where sent messages are distributed to subscribers in a round-robin manner\n+ * according a respective ZeroMQ {@link SocketType#PUSH} and {@link SocketType#PULL} socket types logic;\n+ * - {@code pub-sub}, where sent messages are distributed to all subscribers;\n+ * <p>\n+ * This message channel can work in local mode, when a pair of ZeroMQ sockets of {@link SocketType#PAIR} type\n+ * are connected between publisher (send operation) and subscriber using inter-thread transport binding.\n+ * <p>\n+ * In distributed mode this channel has to be connected to an externally managed ZeroMQ proxy.\n+ * The {@link #setConnectUrl(String)} has to be as a standard ZeroMQ connect string, but with an extra port\n+ * over the colon - representing a frontend and backend sockets pair on ZeroMQ proxy.\n+ * For example: {@code tcp://localhost:6001:6002}.\n+ * This way a sending and receiving operations on this channel are similar to interaction over a messaging broker.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5e3ec53931af67b8c15a833721162f70e276855"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNzc4MDk3OnYy", "diffSide": "RIGHT", "path": "src/reference/asciidoc/zeromq.adoc", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMzo0MDozMVrOG-4R-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMzo0MDozMVrOG-4R-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU4NzAwMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            An implementation is based on well-supported Java API in https://github.com/zeromq/jeromq[JeroMQ] library.\n          \n          \n            \n            The implementation is based on the well-supported Java API of the https://github.com/zeromq/jeromq[JeroMQ] library.", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r468587002", "createdAt": "2020-08-11T13:40:31Z", "author": {"login": "oli-ver"}, "path": "src/reference/asciidoc/zeromq.adoc", "diffHunk": "@@ -0,0 +1,104 @@\n+[[zeromq]]\n+== ZeroMQ Support\n+\n+Spring Integration provides components to support https://zeromq.org/[ZeroMQ] communication in the application.\n+An implementation is based on well-supported Java API in https://github.com/zeromq/jeromq[JeroMQ] library.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e0c2d1d3bc5218ab20e42a8cfef5759cfdb4fa5"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNzc4NDM1OnYy", "diffSide": "RIGHT", "path": "src/reference/asciidoc/zeromq.adoc", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMzo0MToxM1rOG-4UCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMzo0MToxM1rOG-4UCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU4NzUzMQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            All components encapsulates ZeroMQ socket lifecycles and manages threads for them internally making an interaction with these components as lock-free and thread-safe.\n          \n          \n            \n            All components encapsulate ZeroMQ socket lifecycles and manage threads for them internally making an interaction with these components lock-free and thread-safe.", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r468587531", "createdAt": "2020-08-11T13:41:13Z", "author": {"login": "oli-ver"}, "path": "src/reference/asciidoc/zeromq.adoc", "diffHunk": "@@ -0,0 +1,104 @@\n+[[zeromq]]\n+== ZeroMQ Support\n+\n+Spring Integration provides components to support https://zeromq.org/[ZeroMQ] communication in the application.\n+An implementation is based on well-supported Java API in https://github.com/zeromq/jeromq[JeroMQ] library.\n+All components encapsulates ZeroMQ socket lifecycles and manages threads for them internally making an interaction with these components as lock-free and thread-safe.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e0c2d1d3bc5218ab20e42a8cfef5759cfdb4fa5"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNzc4NjY1OnYy", "diffSide": "RIGHT", "path": "src/reference/asciidoc/zeromq.adoc", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMzo0MTo0NFrOG-4VfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMzo0MTo0NFrOG-4VfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU4NzkwMQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The `ZeroMqProxy` is Spring-friendly wrapper for the built-in `ZMQ.proxy()` http://zguide.zeromq.org/page:chapter2#toc15[function].\n          \n          \n            \n            The `ZeroMqProxy` is a Spring-friendly wrapper for the built-in `ZMQ.proxy()` http://zguide.zeromq.org/page:chapter2#toc15[function].", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r468587901", "createdAt": "2020-08-11T13:41:44Z", "author": {"login": "oli-ver"}, "path": "src/reference/asciidoc/zeromq.adoc", "diffHunk": "@@ -0,0 +1,104 @@\n+[[zeromq]]\n+== ZeroMQ Support\n+\n+Spring Integration provides components to support https://zeromq.org/[ZeroMQ] communication in the application.\n+An implementation is based on well-supported Java API in https://github.com/zeromq/jeromq[JeroMQ] library.\n+All components encapsulates ZeroMQ socket lifecycles and manages threads for them internally making an interaction with these components as lock-free and thread-safe.\n+\n+You need to include this dependency into your project:\n+\n+====\n+.Maven\n+[source, xml, subs=\"normal\"]\n+----\n+<dependency>\n+    <groupId>org.springframework.integration</groupId>\n+    <artifactId>spring-integration-zeromq</artifactId>\n+    <version>{project-version}</version>\n+</dependency>\n+----\n+\n+.Gradle\n+[source, groovy, subs=\"normal\"]\n+----\n+compile \"org.springframework.integration:spring-integration-zeromq:{project-version}\"\n+----\n+====\n+\n+[[zeromq-proxy]]\n+=== ZeroMQ Proxy\n+\n+The `ZeroMqProxy` is Spring-friendly wrapper for the built-in `ZMQ.proxy()` http://zguide.zeromq.org/page:chapter2#toc15[function].", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e0c2d1d3bc5218ab20e42a8cfef5759cfdb4fa5"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNzc5MTU1OnYy", "diffSide": "RIGHT", "path": "src/reference/asciidoc/zeromq.adoc", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMzo0Mjo0NlrOG-4YYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMzo0Mjo0NlrOG-4YYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU4ODY0MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Along side with the standard `ZContext` it requires one of the well-know ZeroMQ proxy mode: SUB/PUB, PULL/PUSH or ROUTER/DEALER.\n          \n          \n            \n            Alongside with the standard `ZContext` it requires one of the well-known ZeroMQ proxy modes: SUB/PUB, PULL/PUSH or ROUTER/DEALER.", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r468588640", "createdAt": "2020-08-11T13:42:46Z", "author": {"login": "oli-ver"}, "path": "src/reference/asciidoc/zeromq.adoc", "diffHunk": "@@ -0,0 +1,104 @@\n+[[zeromq]]\n+== ZeroMQ Support\n+\n+Spring Integration provides components to support https://zeromq.org/[ZeroMQ] communication in the application.\n+An implementation is based on well-supported Java API in https://github.com/zeromq/jeromq[JeroMQ] library.\n+All components encapsulates ZeroMQ socket lifecycles and manages threads for them internally making an interaction with these components as lock-free and thread-safe.\n+\n+You need to include this dependency into your project:\n+\n+====\n+.Maven\n+[source, xml, subs=\"normal\"]\n+----\n+<dependency>\n+    <groupId>org.springframework.integration</groupId>\n+    <artifactId>spring-integration-zeromq</artifactId>\n+    <version>{project-version}</version>\n+</dependency>\n+----\n+\n+.Gradle\n+[source, groovy, subs=\"normal\"]\n+----\n+compile \"org.springframework.integration:spring-integration-zeromq:{project-version}\"\n+----\n+====\n+\n+[[zeromq-proxy]]\n+=== ZeroMQ Proxy\n+\n+The `ZeroMqProxy` is Spring-friendly wrapper for the built-in `ZMQ.proxy()` http://zguide.zeromq.org/page:chapter2#toc15[function].\n+It encapsulates socket lifecycles and thread management.\n+The clients of this proxy still can use a standard ZeroMQ socket connection and interaction API.\n+Along side with the standard `ZContext` it requires one of the well-know ZeroMQ proxy mode: SUB/PUB, PULL/PUSH or ROUTER/DEALER.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e0c2d1d3bc5218ab20e42a8cfef5759cfdb4fa5"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNzc5MzA4OnYy", "diffSide": "RIGHT", "path": "src/reference/asciidoc/zeromq.adoc", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMzo0MzowNlrOG-4ZTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMzo0MzowNlrOG-4ZTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU4ODg3Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            This way an appropriate pair of ZeroMQ socket types are used for frontend and backend of the proxy.\n          \n          \n            \n            This way an appropriate pair of ZeroMQ socket types are used for the frontend and backend of the proxy.", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r468588876", "createdAt": "2020-08-11T13:43:06Z", "author": {"login": "oli-ver"}, "path": "src/reference/asciidoc/zeromq.adoc", "diffHunk": "@@ -0,0 +1,104 @@\n+[[zeromq]]\n+== ZeroMQ Support\n+\n+Spring Integration provides components to support https://zeromq.org/[ZeroMQ] communication in the application.\n+An implementation is based on well-supported Java API in https://github.com/zeromq/jeromq[JeroMQ] library.\n+All components encapsulates ZeroMQ socket lifecycles and manages threads for them internally making an interaction with these components as lock-free and thread-safe.\n+\n+You need to include this dependency into your project:\n+\n+====\n+.Maven\n+[source, xml, subs=\"normal\"]\n+----\n+<dependency>\n+    <groupId>org.springframework.integration</groupId>\n+    <artifactId>spring-integration-zeromq</artifactId>\n+    <version>{project-version}</version>\n+</dependency>\n+----\n+\n+.Gradle\n+[source, groovy, subs=\"normal\"]\n+----\n+compile \"org.springframework.integration:spring-integration-zeromq:{project-version}\"\n+----\n+====\n+\n+[[zeromq-proxy]]\n+=== ZeroMQ Proxy\n+\n+The `ZeroMqProxy` is Spring-friendly wrapper for the built-in `ZMQ.proxy()` http://zguide.zeromq.org/page:chapter2#toc15[function].\n+It encapsulates socket lifecycles and thread management.\n+The clients of this proxy still can use a standard ZeroMQ socket connection and interaction API.\n+Along side with the standard `ZContext` it requires one of the well-know ZeroMQ proxy mode: SUB/PUB, PULL/PUSH or ROUTER/DEALER.\n+This way an appropriate pair of ZeroMQ socket types are used for frontend and backend of the proxy.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e0c2d1d3bc5218ab20e42a8cfef5759cfdb4fa5"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNzgyNzkzOnYy", "diffSide": "RIGHT", "path": "src/reference/asciidoc/zeromq.adoc", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMzo1MDo0MlrOG-4vPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMzo1MDo0MlrOG-4vPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU5NDQ5NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The `ZeroMqProxy` implements a `SmartLifecycle` to to create, bind, configure all the sockets and starts `ZMQ.proxy()` in a dedicated thread from an `Executor` (if any).\n          \n          \n            \n            The `ZeroMqProxy` implements a `SmartLifecycle` to create, bind and configure all the sockets and to start `ZMQ.proxy()` in a dedicated thread from an `Executor` (if any).", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r468594494", "createdAt": "2020-08-11T13:50:42Z", "author": {"login": "oli-ver"}, "path": "src/reference/asciidoc/zeromq.adoc", "diffHunk": "@@ -0,0 +1,104 @@\n+[[zeromq]]\n+== ZeroMQ Support\n+\n+Spring Integration provides components to support https://zeromq.org/[ZeroMQ] communication in the application.\n+An implementation is based on well-supported Java API in https://github.com/zeromq/jeromq[JeroMQ] library.\n+All components encapsulates ZeroMQ socket lifecycles and manages threads for them internally making an interaction with these components as lock-free and thread-safe.\n+\n+You need to include this dependency into your project:\n+\n+====\n+.Maven\n+[source, xml, subs=\"normal\"]\n+----\n+<dependency>\n+    <groupId>org.springframework.integration</groupId>\n+    <artifactId>spring-integration-zeromq</artifactId>\n+    <version>{project-version}</version>\n+</dependency>\n+----\n+\n+.Gradle\n+[source, groovy, subs=\"normal\"]\n+----\n+compile \"org.springframework.integration:spring-integration-zeromq:{project-version}\"\n+----\n+====\n+\n+[[zeromq-proxy]]\n+=== ZeroMQ Proxy\n+\n+The `ZeroMqProxy` is Spring-friendly wrapper for the built-in `ZMQ.proxy()` http://zguide.zeromq.org/page:chapter2#toc15[function].\n+It encapsulates socket lifecycles and thread management.\n+The clients of this proxy still can use a standard ZeroMQ socket connection and interaction API.\n+Along side with the standard `ZContext` it requires one of the well-know ZeroMQ proxy mode: SUB/PUB, PULL/PUSH or ROUTER/DEALER.\n+This way an appropriate pair of ZeroMQ socket types are used for frontend and backend of the proxy.\n+See `ZeroMqProxy.Type` for details.\n+\n+The `ZeroMqProxy` implements a `SmartLifecycle` to to create, bind, configure all the sockets and starts `ZMQ.proxy()` in a dedicated thread from an `Executor` (if any).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e0c2d1d3bc5218ab20e42a8cfef5759cfdb4fa5"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyODAyMDY3OnYy", "diffSide": "RIGHT", "path": "src/reference/asciidoc/zeromq.adoc", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNDoyNjozM1rOG-6iMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNDoyNjozM1rOG-6iMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODYyMzkyMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            In fact `ZeroMqProxy` uses performs a `ZMQ.PROXY_TERMINATE` command when `stop()` is called for its lifecycle to terminate `ZMQ.proxy()` loop and close all the bound sockets gracefully.\n          \n          \n            \n            In fact `ZeroMqProxy` performs a `ZMQ.PROXY_TERMINATE` command when `stop()` is called for its lifecycle to terminate `ZMQ.proxy()` loop and close all the bound sockets gracefully.", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r468623922", "createdAt": "2020-08-11T14:26:33Z", "author": {"login": "oli-ver"}, "path": "src/reference/asciidoc/zeromq.adoc", "diffHunk": "@@ -0,0 +1,104 @@\n+[[zeromq]]\n+== ZeroMQ Support\n+\n+Spring Integration provides components to support https://zeromq.org/[ZeroMQ] communication in the application.\n+The implementation is based on the well-supported Java API of the https://github.com/zeromq/jeromq[JeroMQ] library.\n+All components encapsulate ZeroMQ socket lifecycles and manage threads for them internally making an interaction with these components as lock-free and thread-safe.\n+\n+You need to include this dependency into your project:\n+\n+====\n+.Maven\n+[source, xml, subs=\"normal\"]\n+----\n+<dependency>\n+    <groupId>org.springframework.integration</groupId>\n+    <artifactId>spring-integration-zeromq</artifactId>\n+    <version>{project-version}</version>\n+</dependency>\n+----\n+\n+.Gradle\n+[source, groovy, subs=\"normal\"]\n+----\n+compile \"org.springframework.integration:spring-integration-zeromq:{project-version}\"\n+----\n+====\n+\n+[[zeromq-proxy]]\n+=== ZeroMQ Proxy\n+\n+The `ZeroMqProxy` is a Spring-friendly wrapper for the built-in `ZMQ.proxy()` https://zguide.zeromq.org/page:chapter2#toc15[function].\n+It encapsulates socket lifecycles and thread management.\n+The clients of this proxy still can use a standard ZeroMQ socket connection and interaction API.\n+Alongside with the standard `ZContext` it requires one of the well-known ZeroMQ proxy modes: SUB/PUB, PULL/PUSH or ROUTER/DEALER.\n+This way an appropriate pair of ZeroMQ socket types are used for the frontend and backend of the proxy.\n+See `ZeroMqProxy.Type` for details.\n+\n+The `ZeroMqProxy` implements a `SmartLifecycle` to create, bind and configure all the sockets and to start `ZMQ.proxy()` in a dedicated thread from an `Executor` (if any).\n+The binding for frontend and backend sockets is done over `tcp://` protocol onto all the available network interfaces with the provided ports.\n+Otherwise they are bound to random ports which could be obtained later via a respective `getFrontendPort()` and `getBackendPort()` API.\n+\n+The control socket is exposed as a `SocketType.PAIR` with an inter-thread transport on the `\"inproc://\" + beanName + \".control\"` address; it can be obtained via `getControlAddress()`.\n+Should be used with the same application from another `SocketType.PAIR` socket to send `ZMQ.PROXY_TERMINATE`, `ZMQ.PROXY_PAUSE` and/or `ZMQ.PROXY_RESUME` commands.\n+In fact `ZeroMqProxy` uses performs a `ZMQ.PROXY_TERMINATE` command when `stop()` is called for its lifecycle to terminate `ZMQ.proxy()` loop and close all the bound sockets gracefully.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "642247cbf31fd5010e5fff2082f7786c66912f5d"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyODA1MjYzOnYy", "diffSide": "RIGHT", "path": "src/reference/asciidoc/zeromq.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNDozMzo0NlrOG-62UQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNDozMzo0NlrOG-62UQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODYyOTA3Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The `ZeroMqProxy` could be provides as simple bean like this:\n          \n          \n            \n            The `ZeroMqProxy` could be provided as simple bean like this:", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r468629073", "createdAt": "2020-08-11T14:33:46Z", "author": {"login": "oli-ver"}, "path": "src/reference/asciidoc/zeromq.adoc", "diffHunk": "@@ -0,0 +1,104 @@\n+[[zeromq]]\n+== ZeroMQ Support\n+\n+Spring Integration provides components to support https://zeromq.org/[ZeroMQ] communication in the application.\n+The implementation is based on the well-supported Java API of the https://github.com/zeromq/jeromq[JeroMQ] library.\n+All components encapsulate ZeroMQ socket lifecycles and manage threads for them internally making an interaction with these components as lock-free and thread-safe.\n+\n+You need to include this dependency into your project:\n+\n+====\n+.Maven\n+[source, xml, subs=\"normal\"]\n+----\n+<dependency>\n+    <groupId>org.springframework.integration</groupId>\n+    <artifactId>spring-integration-zeromq</artifactId>\n+    <version>{project-version}</version>\n+</dependency>\n+----\n+\n+.Gradle\n+[source, groovy, subs=\"normal\"]\n+----\n+compile \"org.springframework.integration:spring-integration-zeromq:{project-version}\"\n+----\n+====\n+\n+[[zeromq-proxy]]\n+=== ZeroMQ Proxy\n+\n+The `ZeroMqProxy` is a Spring-friendly wrapper for the built-in `ZMQ.proxy()` https://zguide.zeromq.org/page:chapter2#toc15[function].\n+It encapsulates socket lifecycles and thread management.\n+The clients of this proxy still can use a standard ZeroMQ socket connection and interaction API.\n+Alongside with the standard `ZContext` it requires one of the well-known ZeroMQ proxy modes: SUB/PUB, PULL/PUSH or ROUTER/DEALER.\n+This way an appropriate pair of ZeroMQ socket types are used for the frontend and backend of the proxy.\n+See `ZeroMqProxy.Type` for details.\n+\n+The `ZeroMqProxy` implements a `SmartLifecycle` to create, bind and configure all the sockets and to start `ZMQ.proxy()` in a dedicated thread from an `Executor` (if any).\n+The binding for frontend and backend sockets is done over `tcp://` protocol onto all the available network interfaces with the provided ports.\n+Otherwise they are bound to random ports which could be obtained later via a respective `getFrontendPort()` and `getBackendPort()` API.\n+\n+The control socket is exposed as a `SocketType.PAIR` with an inter-thread transport on the `\"inproc://\" + beanName + \".control\"` address; it can be obtained via `getControlAddress()`.\n+Should be used with the same application from another `SocketType.PAIR` socket to send `ZMQ.PROXY_TERMINATE`, `ZMQ.PROXY_PAUSE` and/or `ZMQ.PROXY_RESUME` commands.\n+In fact `ZeroMqProxy` uses performs a `ZMQ.PROXY_TERMINATE` command when `stop()` is called for its lifecycle to terminate `ZMQ.proxy()` loop and close all the bound sockets gracefully.\n+\n+A `setExposeCaptureSocket(boolean)` option makes this component to bind additional inter-thread socket with `SocketType.PUB` to capture and publish all the communication between frontend and backend sockets as it states with `ZMQ.proxy()` implementation.\n+This socket is bound into the `\"inproc://\" + beanName + \".capture\"` address and doesn't expect any specific subscription for filtering.\n+\n+The frontend and backend sockets can be customized for any additional properties, like read/write timeout or security.\n+This customization is available through `setFrontendSocketConfigurer(Consumer<ZMQ.Socket>)` and `setBackendSocketConfigurer(Consumer<ZMQ.Socket>)` callbacks, respectively.\n+\n+The `ZeroMqProxy` could be provides as simple bean like this:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "642247cbf31fd5010e5fff2082f7786c66912f5d"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyODE3OTEyOnYy", "diffSide": "RIGHT", "path": "src/reference/asciidoc/zeromq.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNTowMDo1NlrOG-8GCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNTowMDo1NlrOG-8GCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY0OTQ4Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            All the client nodes should connect to host of this proxy via `tcp://` and use respective port of their interest.\n          \n          \n            \n            All the client nodes should connect to the host of this proxy via `tcp://` and use the respective port of their interest.", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r468649482", "createdAt": "2020-08-11T15:00:56Z", "author": {"login": "oli-ver"}, "path": "src/reference/asciidoc/zeromq.adoc", "diffHunk": "@@ -0,0 +1,104 @@\n+[[zeromq]]\n+== ZeroMQ Support\n+\n+Spring Integration provides components to support https://zeromq.org/[ZeroMQ] communication in the application.\n+The implementation is based on the well-supported Java API of the https://github.com/zeromq/jeromq[JeroMQ] library.\n+All components encapsulate ZeroMQ socket lifecycles and manage threads for them internally making an interaction with these components as lock-free and thread-safe.\n+\n+You need to include this dependency into your project:\n+\n+====\n+.Maven\n+[source, xml, subs=\"normal\"]\n+----\n+<dependency>\n+    <groupId>org.springframework.integration</groupId>\n+    <artifactId>spring-integration-zeromq</artifactId>\n+    <version>{project-version}</version>\n+</dependency>\n+----\n+\n+.Gradle\n+[source, groovy, subs=\"normal\"]\n+----\n+compile \"org.springframework.integration:spring-integration-zeromq:{project-version}\"\n+----\n+====\n+\n+[[zeromq-proxy]]\n+=== ZeroMQ Proxy\n+\n+The `ZeroMqProxy` is a Spring-friendly wrapper for the built-in `ZMQ.proxy()` https://zguide.zeromq.org/page:chapter2#toc15[function].\n+It encapsulates socket lifecycles and thread management.\n+The clients of this proxy still can use a standard ZeroMQ socket connection and interaction API.\n+Alongside with the standard `ZContext` it requires one of the well-known ZeroMQ proxy modes: SUB/PUB, PULL/PUSH or ROUTER/DEALER.\n+This way an appropriate pair of ZeroMQ socket types are used for the frontend and backend of the proxy.\n+See `ZeroMqProxy.Type` for details.\n+\n+The `ZeroMqProxy` implements a `SmartLifecycle` to create, bind and configure all the sockets and to start `ZMQ.proxy()` in a dedicated thread from an `Executor` (if any).\n+The binding for frontend and backend sockets is done over `tcp://` protocol onto all the available network interfaces with the provided ports.\n+Otherwise they are bound to random ports which could be obtained later via a respective `getFrontendPort()` and `getBackendPort()` API.\n+\n+The control socket is exposed as a `SocketType.PAIR` with an inter-thread transport on the `\"inproc://\" + beanName + \".control\"` address; it can be obtained via `getControlAddress()`.\n+Should be used with the same application from another `SocketType.PAIR` socket to send `ZMQ.PROXY_TERMINATE`, `ZMQ.PROXY_PAUSE` and/or `ZMQ.PROXY_RESUME` commands.\n+In fact `ZeroMqProxy` uses performs a `ZMQ.PROXY_TERMINATE` command when `stop()` is called for its lifecycle to terminate `ZMQ.proxy()` loop and close all the bound sockets gracefully.\n+\n+A `setExposeCaptureSocket(boolean)` option makes this component to bind additional inter-thread socket with `SocketType.PUB` to capture and publish all the communication between frontend and backend sockets as it states with `ZMQ.proxy()` implementation.\n+This socket is bound into the `\"inproc://\" + beanName + \".capture\"` address and doesn't expect any specific subscription for filtering.\n+\n+The frontend and backend sockets can be customized for any additional properties, like read/write timeout or security.\n+This customization is available through `setFrontendSocketConfigurer(Consumer<ZMQ.Socket>)` and `setBackendSocketConfigurer(Consumer<ZMQ.Socket>)` callbacks, respectively.\n+\n+The `ZeroMqProxy` could be provides as simple bean like this:\n+\n+====\n+[source,java]\n+----\n+@Bean\n+ZeroMqProxy zeroMqProxy() {\n+    ZeroMqProxy proxy = new ZeroMqProxy(CONTEXT, ZeroMqProxy.Type.SUB_PUB);\n+    proxy.setExposeCaptureSocket(true);\n+    proxy.setFrontendPort(6001);\n+    proxy.setBackendPort(6002);\n+    return proxy;\n+}\n+----\n+====\n+\n+All the client nodes should connect to host of this proxy via `tcp://` and use respective port of their interest.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "642247cbf31fd5010e5fff2082f7786c66912f5d"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyODE4NDUwOnYy", "diffSide": "RIGHT", "path": "src/reference/asciidoc/zeromq.adoc", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNTowMjowMVrOG-8JSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNTowMjowMVrOG-8JSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY1MDMxMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            In the distributed mode it has to be connected to externally managed ZeroMQ proxy, where it can exchange messages with other similar channels connected to the same proxy.\n          \n          \n            \n            In the distributed mode it has to be connected to an externally managed ZeroMQ proxy, where it can exchange messages with other similar channels connected to the same proxy.", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r468650313", "createdAt": "2020-08-11T15:02:01Z", "author": {"login": "oli-ver"}, "path": "src/reference/asciidoc/zeromq.adoc", "diffHunk": "@@ -0,0 +1,104 @@\n+[[zeromq]]\n+== ZeroMQ Support\n+\n+Spring Integration provides components to support https://zeromq.org/[ZeroMQ] communication in the application.\n+The implementation is based on the well-supported Java API of the https://github.com/zeromq/jeromq[JeroMQ] library.\n+All components encapsulate ZeroMQ socket lifecycles and manage threads for them internally making an interaction with these components as lock-free and thread-safe.\n+\n+You need to include this dependency into your project:\n+\n+====\n+.Maven\n+[source, xml, subs=\"normal\"]\n+----\n+<dependency>\n+    <groupId>org.springframework.integration</groupId>\n+    <artifactId>spring-integration-zeromq</artifactId>\n+    <version>{project-version}</version>\n+</dependency>\n+----\n+\n+.Gradle\n+[source, groovy, subs=\"normal\"]\n+----\n+compile \"org.springframework.integration:spring-integration-zeromq:{project-version}\"\n+----\n+====\n+\n+[[zeromq-proxy]]\n+=== ZeroMQ Proxy\n+\n+The `ZeroMqProxy` is a Spring-friendly wrapper for the built-in `ZMQ.proxy()` https://zguide.zeromq.org/page:chapter2#toc15[function].\n+It encapsulates socket lifecycles and thread management.\n+The clients of this proxy still can use a standard ZeroMQ socket connection and interaction API.\n+Alongside with the standard `ZContext` it requires one of the well-known ZeroMQ proxy modes: SUB/PUB, PULL/PUSH or ROUTER/DEALER.\n+This way an appropriate pair of ZeroMQ socket types are used for the frontend and backend of the proxy.\n+See `ZeroMqProxy.Type` for details.\n+\n+The `ZeroMqProxy` implements a `SmartLifecycle` to create, bind and configure all the sockets and to start `ZMQ.proxy()` in a dedicated thread from an `Executor` (if any).\n+The binding for frontend and backend sockets is done over `tcp://` protocol onto all the available network interfaces with the provided ports.\n+Otherwise they are bound to random ports which could be obtained later via a respective `getFrontendPort()` and `getBackendPort()` API.\n+\n+The control socket is exposed as a `SocketType.PAIR` with an inter-thread transport on the `\"inproc://\" + beanName + \".control\"` address; it can be obtained via `getControlAddress()`.\n+Should be used with the same application from another `SocketType.PAIR` socket to send `ZMQ.PROXY_TERMINATE`, `ZMQ.PROXY_PAUSE` and/or `ZMQ.PROXY_RESUME` commands.\n+In fact `ZeroMqProxy` uses performs a `ZMQ.PROXY_TERMINATE` command when `stop()` is called for its lifecycle to terminate `ZMQ.proxy()` loop and close all the bound sockets gracefully.\n+\n+A `setExposeCaptureSocket(boolean)` option makes this component to bind additional inter-thread socket with `SocketType.PUB` to capture and publish all the communication between frontend and backend sockets as it states with `ZMQ.proxy()` implementation.\n+This socket is bound into the `\"inproc://\" + beanName + \".capture\"` address and doesn't expect any specific subscription for filtering.\n+\n+The frontend and backend sockets can be customized for any additional properties, like read/write timeout or security.\n+This customization is available through `setFrontendSocketConfigurer(Consumer<ZMQ.Socket>)` and `setBackendSocketConfigurer(Consumer<ZMQ.Socket>)` callbacks, respectively.\n+\n+The `ZeroMqProxy` could be provides as simple bean like this:\n+\n+====\n+[source,java]\n+----\n+@Bean\n+ZeroMqProxy zeroMqProxy() {\n+    ZeroMqProxy proxy = new ZeroMqProxy(CONTEXT, ZeroMqProxy.Type.SUB_PUB);\n+    proxy.setExposeCaptureSocket(true);\n+    proxy.setFrontendPort(6001);\n+    proxy.setBackendPort(6002);\n+    return proxy;\n+}\n+----\n+====\n+\n+All the client nodes should connect to host of this proxy via `tcp://` and use respective port of their interest.\n+\n+[[zeromq-message-channel]]\n+=== ZeroMQ Message Channel\n+\n+The `ZeroMqChannel` is a `SubscribableChannel` which uses a pair of ZeroMQ sockets to connect publishers and subscribers for messaging interaction.\n+It can work in a PUB/SUB mode (defaults to PUSH/PULL); could be as local inter-thread channel (uses `PAIR` sockets) - the `connectUrl` is not provided.\n+In the distributed mode it has to be connected to externally managed ZeroMQ proxy, where it can exchange messages with other similar channels connected to the same proxy.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "642247cbf31fd5010e5fff2082f7786c66912f5d"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyODE5MDI1OnYy", "diffSide": "RIGHT", "path": "src/reference/asciidoc/zeromq.adoc", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNTowMzoxM1rOG-8M3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNTowMzoxM1rOG-8M3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY1MTIyOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            In fact, for convenience, the channel could be supplied with the `ZeroMqProxy` instance instead of connection string, if it is configured in the same application as proxy.\n          \n          \n            \n            In fact, for convenience, the channel could be supplied with the `ZeroMqProxy` instance instead of a connection string, if it is configured in the same application as proxy.\n          \n      \n    \n    \n  \n\nThanks :)", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r468651228", "createdAt": "2020-08-11T15:03:13Z", "author": {"login": "oli-ver"}, "path": "src/reference/asciidoc/zeromq.adoc", "diffHunk": "@@ -0,0 +1,104 @@\n+[[zeromq]]\n+== ZeroMQ Support\n+\n+Spring Integration provides components to support https://zeromq.org/[ZeroMQ] communication in the application.\n+The implementation is based on the well-supported Java API of the https://github.com/zeromq/jeromq[JeroMQ] library.\n+All components encapsulate ZeroMQ socket lifecycles and manage threads for them internally making an interaction with these components as lock-free and thread-safe.\n+\n+You need to include this dependency into your project:\n+\n+====\n+.Maven\n+[source, xml, subs=\"normal\"]\n+----\n+<dependency>\n+    <groupId>org.springframework.integration</groupId>\n+    <artifactId>spring-integration-zeromq</artifactId>\n+    <version>{project-version}</version>\n+</dependency>\n+----\n+\n+.Gradle\n+[source, groovy, subs=\"normal\"]\n+----\n+compile \"org.springframework.integration:spring-integration-zeromq:{project-version}\"\n+----\n+====\n+\n+[[zeromq-proxy]]\n+=== ZeroMQ Proxy\n+\n+The `ZeroMqProxy` is a Spring-friendly wrapper for the built-in `ZMQ.proxy()` https://zguide.zeromq.org/page:chapter2#toc15[function].\n+It encapsulates socket lifecycles and thread management.\n+The clients of this proxy still can use a standard ZeroMQ socket connection and interaction API.\n+Alongside with the standard `ZContext` it requires one of the well-known ZeroMQ proxy modes: SUB/PUB, PULL/PUSH or ROUTER/DEALER.\n+This way an appropriate pair of ZeroMQ socket types are used for the frontend and backend of the proxy.\n+See `ZeroMqProxy.Type` for details.\n+\n+The `ZeroMqProxy` implements a `SmartLifecycle` to create, bind and configure all the sockets and to start `ZMQ.proxy()` in a dedicated thread from an `Executor` (if any).\n+The binding for frontend and backend sockets is done over `tcp://` protocol onto all the available network interfaces with the provided ports.\n+Otherwise they are bound to random ports which could be obtained later via a respective `getFrontendPort()` and `getBackendPort()` API.\n+\n+The control socket is exposed as a `SocketType.PAIR` with an inter-thread transport on the `\"inproc://\" + beanName + \".control\"` address; it can be obtained via `getControlAddress()`.\n+Should be used with the same application from another `SocketType.PAIR` socket to send `ZMQ.PROXY_TERMINATE`, `ZMQ.PROXY_PAUSE` and/or `ZMQ.PROXY_RESUME` commands.\n+In fact `ZeroMqProxy` uses performs a `ZMQ.PROXY_TERMINATE` command when `stop()` is called for its lifecycle to terminate `ZMQ.proxy()` loop and close all the bound sockets gracefully.\n+\n+A `setExposeCaptureSocket(boolean)` option makes this component to bind additional inter-thread socket with `SocketType.PUB` to capture and publish all the communication between frontend and backend sockets as it states with `ZMQ.proxy()` implementation.\n+This socket is bound into the `\"inproc://\" + beanName + \".capture\"` address and doesn't expect any specific subscription for filtering.\n+\n+The frontend and backend sockets can be customized for any additional properties, like read/write timeout or security.\n+This customization is available through `setFrontendSocketConfigurer(Consumer<ZMQ.Socket>)` and `setBackendSocketConfigurer(Consumer<ZMQ.Socket>)` callbacks, respectively.\n+\n+The `ZeroMqProxy` could be provides as simple bean like this:\n+\n+====\n+[source,java]\n+----\n+@Bean\n+ZeroMqProxy zeroMqProxy() {\n+    ZeroMqProxy proxy = new ZeroMqProxy(CONTEXT, ZeroMqProxy.Type.SUB_PUB);\n+    proxy.setExposeCaptureSocket(true);\n+    proxy.setFrontendPort(6001);\n+    proxy.setBackendPort(6002);\n+    return proxy;\n+}\n+----\n+====\n+\n+All the client nodes should connect to host of this proxy via `tcp://` and use respective port of their interest.\n+\n+[[zeromq-message-channel]]\n+=== ZeroMQ Message Channel\n+\n+The `ZeroMqChannel` is a `SubscribableChannel` which uses a pair of ZeroMQ sockets to connect publishers and subscribers for messaging interaction.\n+It can work in a PUB/SUB mode (defaults to PUSH/PULL); could be as local inter-thread channel (uses `PAIR` sockets) - the `connectUrl` is not provided.\n+In the distributed mode it has to be connected to externally managed ZeroMQ proxy, where it can exchange messages with other similar channels connected to the same proxy.\n+The connect url option is a standard ZeroMQ connection string with the protocol and host and a pair of ports over colon for frontend and backend sockets of the ZeroMQ proxy.\n+In fact, for convenience, the channel could be supplied with the `ZeroMqProxy` instance instead of connection string, if it is configured in the same application as proxy.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "642247cbf31fd5010e5fff2082f7786c66912f5d"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyODIxMDcwOnYy", "diffSide": "RIGHT", "path": "spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/ZeroMqProxy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNTowNzo1N1rOG-8Z-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNTowNzo1N1rOG-8Z-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY1NDU4Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t * Configure an executor to perform a a ZeroMQ proxy loop.\n          \n          \n            \n            \t * Configure an executor to perform a ZeroMQ proxy loop.", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r468654587", "createdAt": "2020-08-11T15:07:57Z", "author": {"login": "oli-ver"}, "path": "spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/ZeroMqProxy.java", "diffHunk": "@@ -100,28 +101,53 @@\n \n \tprivate int phase;\n \n+\t/**\n+\t * Create a {@link ZeroMqProxy} instance based on the provided {@link ZContext}\n+\t * and {@link Type#PULL_PUSH} as default mode.\n+\t * @param context the {@link ZContext} to use\n+\t */\n \tpublic ZeroMqProxy(ZContext context) {\n \t\tthis(context, Type.PULL_PUSH);\n \t}\n \n+\t/**\n+\t * Create a {@link ZeroMqProxy} instance based on the provided {@link ZContext}\n+\t * and {@link Type}.\n+\t * @param context the {@link ZContext} to use\n+\t * @param type the {@link Type} to use.\n+\t */\n \tpublic ZeroMqProxy(ZContext context, Type type) {\n \t\tAssert.notNull(context, \"'context' must not be null\");\n \t\tAssert.notNull(type, \"'type' must not be null\");\n \t\tthis.context = context;\n \t\tthis.type = type;\n \t}\n \n+\t/**\n+\t * Configure an executor to perform a a ZeroMQ proxy loop.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8c0291d441c6cc09299d5d4d60e3c558f6eddc0"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyODIxNTEzOnYy", "diffSide": "RIGHT", "path": "spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/channel/ZeroMqChannel.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNTowODo1NFrOG-8cmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNTowODo1NFrOG-8cmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY1NTI1Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * frontend and backend ports are evaluated from this proxy and respective connection string is built from them.\n          \n          \n            \n             * frontend and backend ports are evaluated from this proxy and the respective connection string is built from them.", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r468655257", "createdAt": "2020-08-11T15:08:54Z", "author": {"login": "oli-ver"}, "path": "spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/channel/ZeroMqChannel.java", "diffHunk": "@@ -55,7 +57,10 @@\n  * The {@link #setConnectUrl(String)} has to be as a standard ZeroMQ connect string, but with an extra port\n  * over the colon - representing a frontend and backend sockets pair on ZeroMQ proxy.\n  * For example: {@code tcp://localhost:6001:6002}.\n- * This way a sending and receiving operations on this channel are similar to interaction over a messaging broker.\n+ * Another option is to provide a reference to the {@link ZeroMqProxy} instance managed in the same application:\n+ * frontend and backend ports are evaluated from this proxy and respective connection string is built from them.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8c0291d441c6cc09299d5d4d60e3c558f6eddc0"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyODI0ODU4OnYy", "diffSide": "RIGHT", "path": "spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/channel/ZeroMqChannel.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNToxNjoxMFrOG-8xOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNjoyNToyMlrOG-_phw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY2MDUzOA==", "bodyText": "I think you could use the consumeDelay also here.", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r468660538", "createdAt": "2020-08-11T15:16:10Z", "author": {"login": "oli-ver"}, "path": "spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/channel/ZeroMqChannel.java", "diffHunk": "@@ -107,30 +123,51 @@ public ZeroMqChannel(ZContext context, boolean pubSub) {\n \n \t\tSupplier<String> localPairConnection = () -> \"inproc://\" + getComponentName() + \".pair\";\n \n+\t\tMono<?> proxyMono =\n+\t\t\t\tMono.defer(() -> {\n+\t\t\t\t\tif (this.zeroMqProxy != null) {\n+\t\t\t\t\t\treturn Mono.just(this.zeroMqProxy.getBackendPort())\n+\t\t\t\t\t\t\t\t.filter((port) -> port > 0)\n+\t\t\t\t\t\t\t\t.repeatWhenEmpty((repeat) -> repeat.delayElements(Duration.ofMillis(100))) // NOSONAR", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8c0291d441c6cc09299d5d4d60e3c558f6eddc0"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY2MTE5Nw==", "bodyText": "Ah wait: It's another delay, only 100 millis. Perhaps worth another repeatDelay variable?", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r468661197", "createdAt": "2020-08-11T15:17:04Z", "author": {"login": "oli-ver"}, "path": "spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/channel/ZeroMqChannel.java", "diffHunk": "@@ -107,30 +123,51 @@ public ZeroMqChannel(ZContext context, boolean pubSub) {\n \n \t\tSupplier<String> localPairConnection = () -> \"inproc://\" + getComponentName() + \".pair\";\n \n+\t\tMono<?> proxyMono =\n+\t\t\t\tMono.defer(() -> {\n+\t\t\t\t\tif (this.zeroMqProxy != null) {\n+\t\t\t\t\t\treturn Mono.just(this.zeroMqProxy.getBackendPort())\n+\t\t\t\t\t\t\t\t.filter((port) -> port > 0)\n+\t\t\t\t\t\t\t\t.repeatWhenEmpty((repeat) -> repeat.delayElements(Duration.ofMillis(100))) // NOSONAR", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY2MDUzOA=="}, "originalCommit": {"oid": "b8c0291d441c6cc09299d5d4d60e3c558f6eddc0"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODcwNzcxOQ==", "bodyText": "Yeah... I don't think so. This is really just busy-spin until the proxy is started with selected port.\nIt is fully not related to the end-user logic.", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r468707719", "createdAt": "2020-08-11T16:25:22Z", "author": {"login": "artembilan"}, "path": "spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/channel/ZeroMqChannel.java", "diffHunk": "@@ -107,30 +123,51 @@ public ZeroMqChannel(ZContext context, boolean pubSub) {\n \n \t\tSupplier<String> localPairConnection = () -> \"inproc://\" + getComponentName() + \".pair\";\n \n+\t\tMono<?> proxyMono =\n+\t\t\t\tMono.defer(() -> {\n+\t\t\t\t\tif (this.zeroMqProxy != null) {\n+\t\t\t\t\t\treturn Mono.just(this.zeroMqProxy.getBackendPort())\n+\t\t\t\t\t\t\t\t.filter((port) -> port > 0)\n+\t\t\t\t\t\t\t\t.repeatWhenEmpty((repeat) -> repeat.delayElements(Duration.ofMillis(100))) // NOSONAR", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY2MDUzOA=="}, "originalCommit": {"oid": "b8c0291d441c6cc09299d5d4d60e3c558f6eddc0"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyODI4MzA0OnYy", "diffSide": "RIGHT", "path": "spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/channel/ZeroMqChannel.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNToyMzowN1rOG-9GGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNToyMzowN1rOG-9GGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY2NTg4MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t\"Or 'zeroMqProxy' or 'connectUrl' can be provided (or none), but not both.\");\n          \n          \n            \n            \t\t\t\t\"A 'zeroMqProxy' or 'connectUrl' can be provided (or none), but not both.\");", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r468665881", "createdAt": "2020-08-11T15:23:07Z", "author": {"login": "oli-ver"}, "path": "spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/channel/ZeroMqChannel.java", "diffHunk": "@@ -182,13 +225,40 @@ public void setConnectUrl(@Nullable String connectUrl) {\n \t\t}\n \t}\n \n+\t/**\n+\t * Specify a reference to a {@link ZeroMqProxy} instance in the same application\n+\t * to rely on its ports configuration and make a natural lifecycle dependency without guessing\n+\t * when the proxy is started. Mutually exclusive with the {@link #setConnectUrl(String)}.\n+\t * @param zeroMqProxy the {@link ZeroMqProxy} instance to use\n+\t */\n+\tpublic void setZeroMqProxy(@Nullable ZeroMqProxy zeroMqProxy) {\n+\t\tthis.zeroMqProxy = zeroMqProxy;\n+\t}\n+\n+\tpublic void setConsumeDelay(Duration consumeDelay) {\n+\t\tAssert.notNull(consumeDelay, \"'consumeDelay' must not be null\");\n+\t\tthis.consumeDelay = consumeDelay;\n+\t}\n+\n \tpublic void setMessageMapper(BytesMessageMapper messageMapper) {\n \t\tAssert.notNull(messageMapper, \"'messageMapper' must not be null\");\n \t\tthis.messageMapper = messageMapper;\n \t}\n \n+\tpublic void setSendSocketConfigurer(Consumer<ZMQ.Socket> sendSocketConfigurer) {\n+\t\tAssert.notNull(sendSocketConfigurer, \"'sendSocketConfigurer' must not be null\");\n+\t\tthis.sendSocketConfigurer = sendSocketConfigurer;\n+\t}\n+\n+\tpublic void setSubscribeSocketConfigurer(Consumer<ZMQ.Socket> subscribeSocketConfigurer) {\n+\t\tAssert.notNull(subscribeSocketConfigurer, \"'subscribeSocketConfigurer' must not be null\");\n+\t\tthis.subscribeSocketConfigurer = subscribeSocketConfigurer;\n+\t}\n+\n \t@Override\n \tprotected void onInit() {\n+\t\tAssert.state(this.zeroMqProxy == null || this.connectSendUrl == null,\n+\t\t\t\t\"Or 'zeroMqProxy' or 'connectUrl' can be provided (or none), but not both.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8c0291d441c6cc09299d5d4d60e3c558f6eddc0"}, "originalPosition": 180}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyODMyMDE1OnYy", "diffSide": "RIGHT", "path": "src/reference/asciidoc/zeromq.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNTozMToxMlrOG-9dDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNTozMToxMlrOG-9dDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY3MTc1OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            All components encapsulate ZeroMQ socket lifecycles and manage threads for them internally making an interaction with these components as lock-free and thread-safe.\n          \n          \n            \n            All components encapsulate ZeroMQ socket lifecycles and manage threads for them internally making interactions with these components lock-free and thread-safe.", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r468671759", "createdAt": "2020-08-11T15:31:12Z", "author": {"login": "garyrussell"}, "path": "src/reference/asciidoc/zeromq.adoc", "diffHunk": "@@ -0,0 +1,104 @@\n+[[zeromq]]\n+== ZeroMQ Support\n+\n+Spring Integration provides components to support https://zeromq.org/[ZeroMQ] communication in the application.\n+The implementation is based on the well-supported Java API of the https://github.com/zeromq/jeromq[JeroMQ] library.\n+All components encapsulate ZeroMQ socket lifecycles and manage threads for them internally making an interaction with these components as lock-free and thread-safe.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "642247cbf31fd5010e5fff2082f7786c66912f5d"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyODMzMTQyOnYy", "diffSide": "RIGHT", "path": "src/reference/asciidoc/zeromq.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNTozMzo1OFrOG-9kMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNTozMzo1OFrOG-9kMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY3MzU4NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The `ZeroMqProxy` implements a `SmartLifecycle` to create, bind and configure all the sockets and to start `ZMQ.proxy()` in a dedicated thread from an `Executor` (if any).\n          \n          \n            \n            The binding for frontend and backend sockets is done over `tcp://` protocol onto all the available network interfaces with the provided ports.\n          \n          \n            \n            Otherwise they are bound to random ports which could be obtained later via a respective `getFrontendPort()` and `getBackendPort()` API.\n          \n          \n            \n            The `ZeroMqProxy` implements `SmartLifecycle` to create, bind and configure the sockets and to start `ZMQ.proxy()` in a dedicated thread from an `Executor` (if any).\n          \n          \n            \n            The binding for frontend and backend sockets is done over the `tcp://` protocol onto all of the available network interfaces with the provided ports.\n          \n          \n            \n            Otherwise they are bound to random ports which can be obtained later via the respective `getFrontendPort()` and `getBackendPort()` API methods.", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r468673585", "createdAt": "2020-08-11T15:33:58Z", "author": {"login": "garyrussell"}, "path": "src/reference/asciidoc/zeromq.adoc", "diffHunk": "@@ -0,0 +1,104 @@\n+[[zeromq]]\n+== ZeroMQ Support\n+\n+Spring Integration provides components to support https://zeromq.org/[ZeroMQ] communication in the application.\n+The implementation is based on the well-supported Java API of the https://github.com/zeromq/jeromq[JeroMQ] library.\n+All components encapsulate ZeroMQ socket lifecycles and manage threads for them internally making an interaction with these components as lock-free and thread-safe.\n+\n+You need to include this dependency into your project:\n+\n+====\n+.Maven\n+[source, xml, subs=\"normal\"]\n+----\n+<dependency>\n+    <groupId>org.springframework.integration</groupId>\n+    <artifactId>spring-integration-zeromq</artifactId>\n+    <version>{project-version}</version>\n+</dependency>\n+----\n+\n+.Gradle\n+[source, groovy, subs=\"normal\"]\n+----\n+compile \"org.springframework.integration:spring-integration-zeromq:{project-version}\"\n+----\n+====\n+\n+[[zeromq-proxy]]\n+=== ZeroMQ Proxy\n+\n+The `ZeroMqProxy` is a Spring-friendly wrapper for the built-in `ZMQ.proxy()` https://zguide.zeromq.org/page:chapter2#toc15[function].\n+It encapsulates socket lifecycles and thread management.\n+The clients of this proxy still can use a standard ZeroMQ socket connection and interaction API.\n+Alongside with the standard `ZContext` it requires one of the well-known ZeroMQ proxy modes: SUB/PUB, PULL/PUSH or ROUTER/DEALER.\n+This way an appropriate pair of ZeroMQ socket types are used for the frontend and backend of the proxy.\n+See `ZeroMqProxy.Type` for details.\n+\n+The `ZeroMqProxy` implements a `SmartLifecycle` to create, bind and configure all the sockets and to start `ZMQ.proxy()` in a dedicated thread from an `Executor` (if any).\n+The binding for frontend and backend sockets is done over `tcp://` protocol onto all the available network interfaces with the provided ports.\n+Otherwise they are bound to random ports which could be obtained later via a respective `getFrontendPort()` and `getBackendPort()` API.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "642247cbf31fd5010e5fff2082f7786c66912f5d"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyODM0MDY1OnYy", "diffSide": "RIGHT", "path": "src/reference/asciidoc/zeromq.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNTozNTo1N1rOG-9ptw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNTozNTo1N1rOG-9ptw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY3NDk5OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Should be used with the same application from another `SocketType.PAIR` socket to send `ZMQ.PROXY_TERMINATE`, `ZMQ.PROXY_PAUSE` and/or `ZMQ.PROXY_RESUME` commands.\n          \n          \n            \n            In fact `ZeroMqProxy` uses performs a `ZMQ.PROXY_TERMINATE` command when `stop()` is called for its lifecycle to terminate `ZMQ.proxy()` loop and close all the bound sockets gracefully.\n          \n          \n            \n            It should be used with the same application from another `SocketType.PAIR` socket to send `ZMQ.PROXY_TERMINATE`, `ZMQ.PROXY_PAUSE` and/or `ZMQ.PROXY_RESUME` commands.\n          \n          \n            \n            The `ZeroMqProxy` performs a `ZMQ.PROXY_TERMINATE` command when `stop()` is called for its lifecycle to terminate the `ZMQ.proxy()` loop and close all the bound sockets gracefully.", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r468674999", "createdAt": "2020-08-11T15:35:57Z", "author": {"login": "garyrussell"}, "path": "src/reference/asciidoc/zeromq.adoc", "diffHunk": "@@ -0,0 +1,104 @@\n+[[zeromq]]\n+== ZeroMQ Support\n+\n+Spring Integration provides components to support https://zeromq.org/[ZeroMQ] communication in the application.\n+The implementation is based on the well-supported Java API of the https://github.com/zeromq/jeromq[JeroMQ] library.\n+All components encapsulate ZeroMQ socket lifecycles and manage threads for them internally making an interaction with these components as lock-free and thread-safe.\n+\n+You need to include this dependency into your project:\n+\n+====\n+.Maven\n+[source, xml, subs=\"normal\"]\n+----\n+<dependency>\n+    <groupId>org.springframework.integration</groupId>\n+    <artifactId>spring-integration-zeromq</artifactId>\n+    <version>{project-version}</version>\n+</dependency>\n+----\n+\n+.Gradle\n+[source, groovy, subs=\"normal\"]\n+----\n+compile \"org.springframework.integration:spring-integration-zeromq:{project-version}\"\n+----\n+====\n+\n+[[zeromq-proxy]]\n+=== ZeroMQ Proxy\n+\n+The `ZeroMqProxy` is a Spring-friendly wrapper for the built-in `ZMQ.proxy()` https://zguide.zeromq.org/page:chapter2#toc15[function].\n+It encapsulates socket lifecycles and thread management.\n+The clients of this proxy still can use a standard ZeroMQ socket connection and interaction API.\n+Alongside with the standard `ZContext` it requires one of the well-known ZeroMQ proxy modes: SUB/PUB, PULL/PUSH or ROUTER/DEALER.\n+This way an appropriate pair of ZeroMQ socket types are used for the frontend and backend of the proxy.\n+See `ZeroMqProxy.Type` for details.\n+\n+The `ZeroMqProxy` implements a `SmartLifecycle` to create, bind and configure all the sockets and to start `ZMQ.proxy()` in a dedicated thread from an `Executor` (if any).\n+The binding for frontend and backend sockets is done over `tcp://` protocol onto all the available network interfaces with the provided ports.\n+Otherwise they are bound to random ports which could be obtained later via a respective `getFrontendPort()` and `getBackendPort()` API.\n+\n+The control socket is exposed as a `SocketType.PAIR` with an inter-thread transport on the `\"inproc://\" + beanName + \".control\"` address; it can be obtained via `getControlAddress()`.\n+Should be used with the same application from another `SocketType.PAIR` socket to send `ZMQ.PROXY_TERMINATE`, `ZMQ.PROXY_PAUSE` and/or `ZMQ.PROXY_RESUME` commands.\n+In fact `ZeroMqProxy` uses performs a `ZMQ.PROXY_TERMINATE` command when `stop()` is called for its lifecycle to terminate `ZMQ.proxy()` loop and close all the bound sockets gracefully.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "642247cbf31fd5010e5fff2082f7786c66912f5d"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyODM0ODI4OnYy", "diffSide": "RIGHT", "path": "src/reference/asciidoc/zeromq.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNTozNzozM1rOG-9ulA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNTozNzozM1rOG-9ulA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY3NjI0NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            A `setExposeCaptureSocket(boolean)` option makes this component to bind additional inter-thread socket with `SocketType.PUB` to capture and publish all the communication between frontend and backend sockets as it states with `ZMQ.proxy()` implementation.\n          \n          \n            \n            This socket is bound into the `\"inproc://\" + beanName + \".capture\"` address and doesn't expect any specific subscription for filtering.\n          \n          \n            \n            The `setExposeCaptureSocket(boolean)` option causes this component to bind an additional inter-thread socket with `SocketType.PUB` to capture and publish all the communication between the frontend and backend sockets as it states with `ZMQ.proxy()` implementation.\n          \n          \n            \n            This socket is bound to the `\"inproc://\" + beanName + \".capture\"` address and doesn't expect any specific subscription for filtering.", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r468676244", "createdAt": "2020-08-11T15:37:33Z", "author": {"login": "garyrussell"}, "path": "src/reference/asciidoc/zeromq.adoc", "diffHunk": "@@ -0,0 +1,104 @@\n+[[zeromq]]\n+== ZeroMQ Support\n+\n+Spring Integration provides components to support https://zeromq.org/[ZeroMQ] communication in the application.\n+The implementation is based on the well-supported Java API of the https://github.com/zeromq/jeromq[JeroMQ] library.\n+All components encapsulate ZeroMQ socket lifecycles and manage threads for them internally making an interaction with these components as lock-free and thread-safe.\n+\n+You need to include this dependency into your project:\n+\n+====\n+.Maven\n+[source, xml, subs=\"normal\"]\n+----\n+<dependency>\n+    <groupId>org.springframework.integration</groupId>\n+    <artifactId>spring-integration-zeromq</artifactId>\n+    <version>{project-version}</version>\n+</dependency>\n+----\n+\n+.Gradle\n+[source, groovy, subs=\"normal\"]\n+----\n+compile \"org.springframework.integration:spring-integration-zeromq:{project-version}\"\n+----\n+====\n+\n+[[zeromq-proxy]]\n+=== ZeroMQ Proxy\n+\n+The `ZeroMqProxy` is a Spring-friendly wrapper for the built-in `ZMQ.proxy()` https://zguide.zeromq.org/page:chapter2#toc15[function].\n+It encapsulates socket lifecycles and thread management.\n+The clients of this proxy still can use a standard ZeroMQ socket connection and interaction API.\n+Alongside with the standard `ZContext` it requires one of the well-known ZeroMQ proxy modes: SUB/PUB, PULL/PUSH or ROUTER/DEALER.\n+This way an appropriate pair of ZeroMQ socket types are used for the frontend and backend of the proxy.\n+See `ZeroMqProxy.Type` for details.\n+\n+The `ZeroMqProxy` implements a `SmartLifecycle` to create, bind and configure all the sockets and to start `ZMQ.proxy()` in a dedicated thread from an `Executor` (if any).\n+The binding for frontend and backend sockets is done over `tcp://` protocol onto all the available network interfaces with the provided ports.\n+Otherwise they are bound to random ports which could be obtained later via a respective `getFrontendPort()` and `getBackendPort()` API.\n+\n+The control socket is exposed as a `SocketType.PAIR` with an inter-thread transport on the `\"inproc://\" + beanName + \".control\"` address; it can be obtained via `getControlAddress()`.\n+Should be used with the same application from another `SocketType.PAIR` socket to send `ZMQ.PROXY_TERMINATE`, `ZMQ.PROXY_PAUSE` and/or `ZMQ.PROXY_RESUME` commands.\n+In fact `ZeroMqProxy` uses performs a `ZMQ.PROXY_TERMINATE` command when `stop()` is called for its lifecycle to terminate `ZMQ.proxy()` loop and close all the bound sockets gracefully.\n+\n+A `setExposeCaptureSocket(boolean)` option makes this component to bind additional inter-thread socket with `SocketType.PUB` to capture and publish all the communication between frontend and backend sockets as it states with `ZMQ.proxy()` implementation.\n+This socket is bound into the `\"inproc://\" + beanName + \".capture\"` address and doesn't expect any specific subscription for filtering.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "642247cbf31fd5010e5fff2082f7786c66912f5d"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyODM1MzIxOnYy", "diffSide": "RIGHT", "path": "src/reference/asciidoc/zeromq.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNTozODo0NlrOG-9x8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNTozODo0NlrOG-9x8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY3NzEwNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The frontend and backend sockets can be customized for any additional properties, like read/write timeout or security.\n          \n          \n            \n            This customization is available through `setFrontendSocketConfigurer(Consumer<ZMQ.Socket>)` and `setBackendSocketConfigurer(Consumer<ZMQ.Socket>)` callbacks, respectively.\n          \n          \n            \n            The frontend and backend sockets can be customized with additional properties, such as read/write timeout or security.\n          \n          \n            \n            This customization is available through `setFrontendSocketConfigurer(Consumer<ZMQ.Socket>)` and `setBackendSocketConfigurer(Consumer<ZMQ.Socket>)` callbacks, respectively.", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r468677107", "createdAt": "2020-08-11T15:38:46Z", "author": {"login": "garyrussell"}, "path": "src/reference/asciidoc/zeromq.adoc", "diffHunk": "@@ -0,0 +1,104 @@\n+[[zeromq]]\n+== ZeroMQ Support\n+\n+Spring Integration provides components to support https://zeromq.org/[ZeroMQ] communication in the application.\n+The implementation is based on the well-supported Java API of the https://github.com/zeromq/jeromq[JeroMQ] library.\n+All components encapsulate ZeroMQ socket lifecycles and manage threads for them internally making an interaction with these components as lock-free and thread-safe.\n+\n+You need to include this dependency into your project:\n+\n+====\n+.Maven\n+[source, xml, subs=\"normal\"]\n+----\n+<dependency>\n+    <groupId>org.springframework.integration</groupId>\n+    <artifactId>spring-integration-zeromq</artifactId>\n+    <version>{project-version}</version>\n+</dependency>\n+----\n+\n+.Gradle\n+[source, groovy, subs=\"normal\"]\n+----\n+compile \"org.springframework.integration:spring-integration-zeromq:{project-version}\"\n+----\n+====\n+\n+[[zeromq-proxy]]\n+=== ZeroMQ Proxy\n+\n+The `ZeroMqProxy` is a Spring-friendly wrapper for the built-in `ZMQ.proxy()` https://zguide.zeromq.org/page:chapter2#toc15[function].\n+It encapsulates socket lifecycles and thread management.\n+The clients of this proxy still can use a standard ZeroMQ socket connection and interaction API.\n+Alongside with the standard `ZContext` it requires one of the well-known ZeroMQ proxy modes: SUB/PUB, PULL/PUSH or ROUTER/DEALER.\n+This way an appropriate pair of ZeroMQ socket types are used for the frontend and backend of the proxy.\n+See `ZeroMqProxy.Type` for details.\n+\n+The `ZeroMqProxy` implements a `SmartLifecycle` to create, bind and configure all the sockets and to start `ZMQ.proxy()` in a dedicated thread from an `Executor` (if any).\n+The binding for frontend and backend sockets is done over `tcp://` protocol onto all the available network interfaces with the provided ports.\n+Otherwise they are bound to random ports which could be obtained later via a respective `getFrontendPort()` and `getBackendPort()` API.\n+\n+The control socket is exposed as a `SocketType.PAIR` with an inter-thread transport on the `\"inproc://\" + beanName + \".control\"` address; it can be obtained via `getControlAddress()`.\n+Should be used with the same application from another `SocketType.PAIR` socket to send `ZMQ.PROXY_TERMINATE`, `ZMQ.PROXY_PAUSE` and/or `ZMQ.PROXY_RESUME` commands.\n+In fact `ZeroMqProxy` uses performs a `ZMQ.PROXY_TERMINATE` command when `stop()` is called for its lifecycle to terminate `ZMQ.proxy()` loop and close all the bound sockets gracefully.\n+\n+A `setExposeCaptureSocket(boolean)` option makes this component to bind additional inter-thread socket with `SocketType.PUB` to capture and publish all the communication between frontend and backend sockets as it states with `ZMQ.proxy()` implementation.\n+This socket is bound into the `\"inproc://\" + beanName + \".capture\"` address and doesn't expect any specific subscription for filtering.\n+\n+The frontend and backend sockets can be customized for any additional properties, like read/write timeout or security.\n+This customization is available through `setFrontendSocketConfigurer(Consumer<ZMQ.Socket>)` and `setBackendSocketConfigurer(Consumer<ZMQ.Socket>)` callbacks, respectively.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "642247cbf31fd5010e5fff2082f7786c66912f5d"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyODM2NzE5OnYy", "diffSide": "RIGHT", "path": "src/reference/asciidoc/zeromq.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNTo0MjowMFrOG-96tg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNTo0MjowMFrOG-96tg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY3OTM1MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The `ZeroMqChannel` is a `SubscribableChannel` which uses a pair of ZeroMQ sockets to connect publishers and subscribers for messaging interaction.\n          \n          \n            \n            It can work in a PUB/SUB mode (defaults to PUSH/PULL); could be as local inter-thread channel (uses `PAIR` sockets) - the `connectUrl` is not provided.\n          \n          \n            \n            In the distributed mode it has to be connected to externally managed ZeroMQ proxy, where it can exchange messages with other similar channels connected to the same proxy.\n          \n          \n            \n            The connect url option is a standard ZeroMQ connection string with the protocol and host and a pair of ports over colon for frontend and backend sockets of the ZeroMQ proxy.\n          \n          \n            \n            In fact, for convenience, the channel could be supplied with the `ZeroMqProxy` instance instead of connection string, if it is configured in the same application as proxy.\n          \n          \n            \n            The `ZeroMqChannel` is a `SubscribableChannel` which uses a pair of ZeroMQ sockets to connect publishers and subscribers for messaging interaction.\n          \n          \n            \n            It can work in a PUB/SUB mode (defaults to PUSH/PULL); it can also be used as a local inter-thread channel (uses `PAIR` sockets) - the `connectUrl` is not provided in this case.\n          \n          \n            \n            In distributed mode it has to be connected to an externally managed ZeroMQ proxy, where it can exchange messages with other similar channels connected to the same proxy.\n          \n          \n            \n            The connect url option is a standard ZeroMQ connection string with the protocol and host and a pair of ports over colon for frontend and backend sockets of the ZeroMQ proxy.\n          \n          \n            \n            For convenience, the channel could be supplied with the `ZeroMqProxy` instance instead of connection string, if it is configured in the same application as the proxy.", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r468679350", "createdAt": "2020-08-11T15:42:00Z", "author": {"login": "garyrussell"}, "path": "src/reference/asciidoc/zeromq.adoc", "diffHunk": "@@ -0,0 +1,104 @@\n+[[zeromq]]\n+== ZeroMQ Support\n+\n+Spring Integration provides components to support https://zeromq.org/[ZeroMQ] communication in the application.\n+The implementation is based on the well-supported Java API of the https://github.com/zeromq/jeromq[JeroMQ] library.\n+All components encapsulate ZeroMQ socket lifecycles and manage threads for them internally making an interaction with these components as lock-free and thread-safe.\n+\n+You need to include this dependency into your project:\n+\n+====\n+.Maven\n+[source, xml, subs=\"normal\"]\n+----\n+<dependency>\n+    <groupId>org.springframework.integration</groupId>\n+    <artifactId>spring-integration-zeromq</artifactId>\n+    <version>{project-version}</version>\n+</dependency>\n+----\n+\n+.Gradle\n+[source, groovy, subs=\"normal\"]\n+----\n+compile \"org.springframework.integration:spring-integration-zeromq:{project-version}\"\n+----\n+====\n+\n+[[zeromq-proxy]]\n+=== ZeroMQ Proxy\n+\n+The `ZeroMqProxy` is a Spring-friendly wrapper for the built-in `ZMQ.proxy()` https://zguide.zeromq.org/page:chapter2#toc15[function].\n+It encapsulates socket lifecycles and thread management.\n+The clients of this proxy still can use a standard ZeroMQ socket connection and interaction API.\n+Alongside with the standard `ZContext` it requires one of the well-known ZeroMQ proxy modes: SUB/PUB, PULL/PUSH or ROUTER/DEALER.\n+This way an appropriate pair of ZeroMQ socket types are used for the frontend and backend of the proxy.\n+See `ZeroMqProxy.Type` for details.\n+\n+The `ZeroMqProxy` implements a `SmartLifecycle` to create, bind and configure all the sockets and to start `ZMQ.proxy()` in a dedicated thread from an `Executor` (if any).\n+The binding for frontend and backend sockets is done over `tcp://` protocol onto all the available network interfaces with the provided ports.\n+Otherwise they are bound to random ports which could be obtained later via a respective `getFrontendPort()` and `getBackendPort()` API.\n+\n+The control socket is exposed as a `SocketType.PAIR` with an inter-thread transport on the `\"inproc://\" + beanName + \".control\"` address; it can be obtained via `getControlAddress()`.\n+Should be used with the same application from another `SocketType.PAIR` socket to send `ZMQ.PROXY_TERMINATE`, `ZMQ.PROXY_PAUSE` and/or `ZMQ.PROXY_RESUME` commands.\n+In fact `ZeroMqProxy` uses performs a `ZMQ.PROXY_TERMINATE` command when `stop()` is called for its lifecycle to terminate `ZMQ.proxy()` loop and close all the bound sockets gracefully.\n+\n+A `setExposeCaptureSocket(boolean)` option makes this component to bind additional inter-thread socket with `SocketType.PUB` to capture and publish all the communication between frontend and backend sockets as it states with `ZMQ.proxy()` implementation.\n+This socket is bound into the `\"inproc://\" + beanName + \".capture\"` address and doesn't expect any specific subscription for filtering.\n+\n+The frontend and backend sockets can be customized for any additional properties, like read/write timeout or security.\n+This customization is available through `setFrontendSocketConfigurer(Consumer<ZMQ.Socket>)` and `setBackendSocketConfigurer(Consumer<ZMQ.Socket>)` callbacks, respectively.\n+\n+The `ZeroMqProxy` could be provides as simple bean like this:\n+\n+====\n+[source,java]\n+----\n+@Bean\n+ZeroMqProxy zeroMqProxy() {\n+    ZeroMqProxy proxy = new ZeroMqProxy(CONTEXT, ZeroMqProxy.Type.SUB_PUB);\n+    proxy.setExposeCaptureSocket(true);\n+    proxy.setFrontendPort(6001);\n+    proxy.setBackendPort(6002);\n+    return proxy;\n+}\n+----\n+====\n+\n+All the client nodes should connect to host of this proxy via `tcp://` and use respective port of their interest.\n+\n+[[zeromq-message-channel]]\n+=== ZeroMQ Message Channel\n+\n+The `ZeroMqChannel` is a `SubscribableChannel` which uses a pair of ZeroMQ sockets to connect publishers and subscribers for messaging interaction.\n+It can work in a PUB/SUB mode (defaults to PUSH/PULL); could be as local inter-thread channel (uses `PAIR` sockets) - the `connectUrl` is not provided.\n+In the distributed mode it has to be connected to externally managed ZeroMQ proxy, where it can exchange messages with other similar channels connected to the same proxy.\n+The connect url option is a standard ZeroMQ connection string with the protocol and host and a pair of ports over colon for frontend and backend sockets of the ZeroMQ proxy.\n+In fact, for convenience, the channel could be supplied with the `ZeroMqProxy` instance instead of connection string, if it is configured in the same application as proxy.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "642247cbf31fd5010e5fff2082f7786c66912f5d"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyODM3MjI1OnYy", "diffSide": "RIGHT", "path": "src/reference/asciidoc/zeromq.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNTo0MzoxMFrOG-99yw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNTo0MzoxMFrOG-99yw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY4MDEzOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            By default the `ZeroMqChannel` uses an `EmbeddedJsonHeadersMessageMapper` to (de)serialize the `Message` (including headers) from/to `byte[]` using Jackson JSON processor.\n          \n          \n            \n            By default the `ZeroMqChannel` uses an `EmbeddedJsonHeadersMessageMapper` to (de)serialize the `Message` (including headers) from/to `byte[]` using a Jackson JSON processor.", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r468680139", "createdAt": "2020-08-11T15:43:10Z", "author": {"login": "garyrussell"}, "path": "src/reference/asciidoc/zeromq.adoc", "diffHunk": "@@ -0,0 +1,104 @@\n+[[zeromq]]\n+== ZeroMQ Support\n+\n+Spring Integration provides components to support https://zeromq.org/[ZeroMQ] communication in the application.\n+The implementation is based on the well-supported Java API of the https://github.com/zeromq/jeromq[JeroMQ] library.\n+All components encapsulate ZeroMQ socket lifecycles and manage threads for them internally making an interaction with these components as lock-free and thread-safe.\n+\n+You need to include this dependency into your project:\n+\n+====\n+.Maven\n+[source, xml, subs=\"normal\"]\n+----\n+<dependency>\n+    <groupId>org.springframework.integration</groupId>\n+    <artifactId>spring-integration-zeromq</artifactId>\n+    <version>{project-version}</version>\n+</dependency>\n+----\n+\n+.Gradle\n+[source, groovy, subs=\"normal\"]\n+----\n+compile \"org.springframework.integration:spring-integration-zeromq:{project-version}\"\n+----\n+====\n+\n+[[zeromq-proxy]]\n+=== ZeroMQ Proxy\n+\n+The `ZeroMqProxy` is a Spring-friendly wrapper for the built-in `ZMQ.proxy()` https://zguide.zeromq.org/page:chapter2#toc15[function].\n+It encapsulates socket lifecycles and thread management.\n+The clients of this proxy still can use a standard ZeroMQ socket connection and interaction API.\n+Alongside with the standard `ZContext` it requires one of the well-known ZeroMQ proxy modes: SUB/PUB, PULL/PUSH or ROUTER/DEALER.\n+This way an appropriate pair of ZeroMQ socket types are used for the frontend and backend of the proxy.\n+See `ZeroMqProxy.Type` for details.\n+\n+The `ZeroMqProxy` implements a `SmartLifecycle` to create, bind and configure all the sockets and to start `ZMQ.proxy()` in a dedicated thread from an `Executor` (if any).\n+The binding for frontend and backend sockets is done over `tcp://` protocol onto all the available network interfaces with the provided ports.\n+Otherwise they are bound to random ports which could be obtained later via a respective `getFrontendPort()` and `getBackendPort()` API.\n+\n+The control socket is exposed as a `SocketType.PAIR` with an inter-thread transport on the `\"inproc://\" + beanName + \".control\"` address; it can be obtained via `getControlAddress()`.\n+Should be used with the same application from another `SocketType.PAIR` socket to send `ZMQ.PROXY_TERMINATE`, `ZMQ.PROXY_PAUSE` and/or `ZMQ.PROXY_RESUME` commands.\n+In fact `ZeroMqProxy` uses performs a `ZMQ.PROXY_TERMINATE` command when `stop()` is called for its lifecycle to terminate `ZMQ.proxy()` loop and close all the bound sockets gracefully.\n+\n+A `setExposeCaptureSocket(boolean)` option makes this component to bind additional inter-thread socket with `SocketType.PUB` to capture and publish all the communication between frontend and backend sockets as it states with `ZMQ.proxy()` implementation.\n+This socket is bound into the `\"inproc://\" + beanName + \".capture\"` address and doesn't expect any specific subscription for filtering.\n+\n+The frontend and backend sockets can be customized for any additional properties, like read/write timeout or security.\n+This customization is available through `setFrontendSocketConfigurer(Consumer<ZMQ.Socket>)` and `setBackendSocketConfigurer(Consumer<ZMQ.Socket>)` callbacks, respectively.\n+\n+The `ZeroMqProxy` could be provides as simple bean like this:\n+\n+====\n+[source,java]\n+----\n+@Bean\n+ZeroMqProxy zeroMqProxy() {\n+    ZeroMqProxy proxy = new ZeroMqProxy(CONTEXT, ZeroMqProxy.Type.SUB_PUB);\n+    proxy.setExposeCaptureSocket(true);\n+    proxy.setFrontendPort(6001);\n+    proxy.setBackendPort(6002);\n+    return proxy;\n+}\n+----\n+====\n+\n+All the client nodes should connect to host of this proxy via `tcp://` and use respective port of their interest.\n+\n+[[zeromq-message-channel]]\n+=== ZeroMQ Message Channel\n+\n+The `ZeroMqChannel` is a `SubscribableChannel` which uses a pair of ZeroMQ sockets to connect publishers and subscribers for messaging interaction.\n+It can work in a PUB/SUB mode (defaults to PUSH/PULL); could be as local inter-thread channel (uses `PAIR` sockets) - the `connectUrl` is not provided.\n+In the distributed mode it has to be connected to externally managed ZeroMQ proxy, where it can exchange messages with other similar channels connected to the same proxy.\n+The connect url option is a standard ZeroMQ connection string with the protocol and host and a pair of ports over colon for frontend and backend sockets of the ZeroMQ proxy.\n+In fact, for convenience, the channel could be supplied with the `ZeroMqProxy` instance instead of connection string, if it is configured in the same application as proxy.\n+\n+Both sending and receiving sockets are managed in their own dedicated threads making this channel concurrency-friendly.\n+This way we can publish and consume to/from a `ZeroMqChannel` from different threads without synchronization.\n+\n+By default the `ZeroMqChannel` uses an `EmbeddedJsonHeadersMessageMapper` to (de)serialize the `Message` (including headers) from/to `byte[]` using Jackson JSON processor.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "642247cbf31fd5010e5fff2082f7786c66912f5d"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyODM3NTI3OnYy", "diffSide": "RIGHT", "path": "src/reference/asciidoc/zeromq.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNTo0Mzo1NVrOG-9_uw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNTo0Mzo1NVrOG-9_uw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY4MDYzNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Sending and receiving sockets can be customized for any options (e.g. read/write timeout, security etc.) via respective `setSendSocketConfigurer(Consumer<ZMQ.Socket>)` and `setSubscribeSocketConfigurer(Consumer<ZMQ.Socket>)` callbacks.\n          \n          \n            \n            Sending and receiving sockets can be customized for any options (read/write timeout, security etc.) via respective `setSendSocketConfigurer(Consumer<ZMQ.Socket>)` and `setSubscribeSocketConfigurer(Consumer<ZMQ.Socket>)` callbacks.", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r468680635", "createdAt": "2020-08-11T15:43:55Z", "author": {"login": "garyrussell"}, "path": "src/reference/asciidoc/zeromq.adoc", "diffHunk": "@@ -0,0 +1,104 @@\n+[[zeromq]]\n+== ZeroMQ Support\n+\n+Spring Integration provides components to support https://zeromq.org/[ZeroMQ] communication in the application.\n+The implementation is based on the well-supported Java API of the https://github.com/zeromq/jeromq[JeroMQ] library.\n+All components encapsulate ZeroMQ socket lifecycles and manage threads for them internally making an interaction with these components as lock-free and thread-safe.\n+\n+You need to include this dependency into your project:\n+\n+====\n+.Maven\n+[source, xml, subs=\"normal\"]\n+----\n+<dependency>\n+    <groupId>org.springframework.integration</groupId>\n+    <artifactId>spring-integration-zeromq</artifactId>\n+    <version>{project-version}</version>\n+</dependency>\n+----\n+\n+.Gradle\n+[source, groovy, subs=\"normal\"]\n+----\n+compile \"org.springframework.integration:spring-integration-zeromq:{project-version}\"\n+----\n+====\n+\n+[[zeromq-proxy]]\n+=== ZeroMQ Proxy\n+\n+The `ZeroMqProxy` is a Spring-friendly wrapper for the built-in `ZMQ.proxy()` https://zguide.zeromq.org/page:chapter2#toc15[function].\n+It encapsulates socket lifecycles and thread management.\n+The clients of this proxy still can use a standard ZeroMQ socket connection and interaction API.\n+Alongside with the standard `ZContext` it requires one of the well-known ZeroMQ proxy modes: SUB/PUB, PULL/PUSH or ROUTER/DEALER.\n+This way an appropriate pair of ZeroMQ socket types are used for the frontend and backend of the proxy.\n+See `ZeroMqProxy.Type` for details.\n+\n+The `ZeroMqProxy` implements a `SmartLifecycle` to create, bind and configure all the sockets and to start `ZMQ.proxy()` in a dedicated thread from an `Executor` (if any).\n+The binding for frontend and backend sockets is done over `tcp://` protocol onto all the available network interfaces with the provided ports.\n+Otherwise they are bound to random ports which could be obtained later via a respective `getFrontendPort()` and `getBackendPort()` API.\n+\n+The control socket is exposed as a `SocketType.PAIR` with an inter-thread transport on the `\"inproc://\" + beanName + \".control\"` address; it can be obtained via `getControlAddress()`.\n+Should be used with the same application from another `SocketType.PAIR` socket to send `ZMQ.PROXY_TERMINATE`, `ZMQ.PROXY_PAUSE` and/or `ZMQ.PROXY_RESUME` commands.\n+In fact `ZeroMqProxy` uses performs a `ZMQ.PROXY_TERMINATE` command when `stop()` is called for its lifecycle to terminate `ZMQ.proxy()` loop and close all the bound sockets gracefully.\n+\n+A `setExposeCaptureSocket(boolean)` option makes this component to bind additional inter-thread socket with `SocketType.PUB` to capture and publish all the communication between frontend and backend sockets as it states with `ZMQ.proxy()` implementation.\n+This socket is bound into the `\"inproc://\" + beanName + \".capture\"` address and doesn't expect any specific subscription for filtering.\n+\n+The frontend and backend sockets can be customized for any additional properties, like read/write timeout or security.\n+This customization is available through `setFrontendSocketConfigurer(Consumer<ZMQ.Socket>)` and `setBackendSocketConfigurer(Consumer<ZMQ.Socket>)` callbacks, respectively.\n+\n+The `ZeroMqProxy` could be provides as simple bean like this:\n+\n+====\n+[source,java]\n+----\n+@Bean\n+ZeroMqProxy zeroMqProxy() {\n+    ZeroMqProxy proxy = new ZeroMqProxy(CONTEXT, ZeroMqProxy.Type.SUB_PUB);\n+    proxy.setExposeCaptureSocket(true);\n+    proxy.setFrontendPort(6001);\n+    proxy.setBackendPort(6002);\n+    return proxy;\n+}\n+----\n+====\n+\n+All the client nodes should connect to host of this proxy via `tcp://` and use respective port of their interest.\n+\n+[[zeromq-message-channel]]\n+=== ZeroMQ Message Channel\n+\n+The `ZeroMqChannel` is a `SubscribableChannel` which uses a pair of ZeroMQ sockets to connect publishers and subscribers for messaging interaction.\n+It can work in a PUB/SUB mode (defaults to PUSH/PULL); could be as local inter-thread channel (uses `PAIR` sockets) - the `connectUrl` is not provided.\n+In the distributed mode it has to be connected to externally managed ZeroMQ proxy, where it can exchange messages with other similar channels connected to the same proxy.\n+The connect url option is a standard ZeroMQ connection string with the protocol and host and a pair of ports over colon for frontend and backend sockets of the ZeroMQ proxy.\n+In fact, for convenience, the channel could be supplied with the `ZeroMqProxy` instance instead of connection string, if it is configured in the same application as proxy.\n+\n+Both sending and receiving sockets are managed in their own dedicated threads making this channel concurrency-friendly.\n+This way we can publish and consume to/from a `ZeroMqChannel` from different threads without synchronization.\n+\n+By default the `ZeroMqChannel` uses an `EmbeddedJsonHeadersMessageMapper` to (de)serialize the `Message` (including headers) from/to `byte[]` using Jackson JSON processor.\n+This logic can be configured via `setMessageMapper(BytesMessageMapper)`.\n+\n+Sending and receiving sockets can be customized for any options (e.g. read/write timeout, security etc.) via respective `setSendSocketConfigurer(Consumer<ZMQ.Socket>)` and `setSubscribeSocketConfigurer(Consumer<ZMQ.Socket>)` callbacks.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "642247cbf31fd5010e5fff2082f7786c66912f5d"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyODM4MzIzOnYy", "diffSide": "RIGHT", "path": "src/reference/asciidoc/zeromq.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNTo0NTo0NFrOG--Esg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNTo0NTo0NFrOG--Esg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY4MTkwNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            An internal logic of the `ZeroMqChannel` is based on the reactive streams via Project Reactor `Flux` and `Mono` operators.\n          \n          \n            \n            It gives us an easier threading control and allows to have a lock-free concurrent publication and consumption to/from the channel.\n          \n          \n            \n            A local PUB/SUB logic is implemented as a `Flux.publish()` operator to allow all the local subscribers to this channel to have the same published message, as distributed subscribers to the `PUB` socket.\n          \n          \n            \n            The internal logic of the `ZeroMqChannel` is based on the reactive streams via Project Reactor `Flux` and `Mono` operators.\n          \n          \n            \n            This provides easier threading control and allows lock-free concurrent publication and consumption to/from the channel.\n          \n          \n            \n            Local PUB/SUB logic is implemented as a `Flux.publish()` operator to allow all of the local subscribers to this channel to receive the same published message, as distributed subscribers to the `PUB` socket.", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r468681906", "createdAt": "2020-08-11T15:45:44Z", "author": {"login": "garyrussell"}, "path": "src/reference/asciidoc/zeromq.adoc", "diffHunk": "@@ -0,0 +1,104 @@\n+[[zeromq]]\n+== ZeroMQ Support\n+\n+Spring Integration provides components to support https://zeromq.org/[ZeroMQ] communication in the application.\n+The implementation is based on the well-supported Java API of the https://github.com/zeromq/jeromq[JeroMQ] library.\n+All components encapsulate ZeroMQ socket lifecycles and manage threads for them internally making an interaction with these components as lock-free and thread-safe.\n+\n+You need to include this dependency into your project:\n+\n+====\n+.Maven\n+[source, xml, subs=\"normal\"]\n+----\n+<dependency>\n+    <groupId>org.springframework.integration</groupId>\n+    <artifactId>spring-integration-zeromq</artifactId>\n+    <version>{project-version}</version>\n+</dependency>\n+----\n+\n+.Gradle\n+[source, groovy, subs=\"normal\"]\n+----\n+compile \"org.springframework.integration:spring-integration-zeromq:{project-version}\"\n+----\n+====\n+\n+[[zeromq-proxy]]\n+=== ZeroMQ Proxy\n+\n+The `ZeroMqProxy` is a Spring-friendly wrapper for the built-in `ZMQ.proxy()` https://zguide.zeromq.org/page:chapter2#toc15[function].\n+It encapsulates socket lifecycles and thread management.\n+The clients of this proxy still can use a standard ZeroMQ socket connection and interaction API.\n+Alongside with the standard `ZContext` it requires one of the well-known ZeroMQ proxy modes: SUB/PUB, PULL/PUSH or ROUTER/DEALER.\n+This way an appropriate pair of ZeroMQ socket types are used for the frontend and backend of the proxy.\n+See `ZeroMqProxy.Type` for details.\n+\n+The `ZeroMqProxy` implements a `SmartLifecycle` to create, bind and configure all the sockets and to start `ZMQ.proxy()` in a dedicated thread from an `Executor` (if any).\n+The binding for frontend and backend sockets is done over `tcp://` protocol onto all the available network interfaces with the provided ports.\n+Otherwise they are bound to random ports which could be obtained later via a respective `getFrontendPort()` and `getBackendPort()` API.\n+\n+The control socket is exposed as a `SocketType.PAIR` with an inter-thread transport on the `\"inproc://\" + beanName + \".control\"` address; it can be obtained via `getControlAddress()`.\n+Should be used with the same application from another `SocketType.PAIR` socket to send `ZMQ.PROXY_TERMINATE`, `ZMQ.PROXY_PAUSE` and/or `ZMQ.PROXY_RESUME` commands.\n+In fact `ZeroMqProxy` uses performs a `ZMQ.PROXY_TERMINATE` command when `stop()` is called for its lifecycle to terminate `ZMQ.proxy()` loop and close all the bound sockets gracefully.\n+\n+A `setExposeCaptureSocket(boolean)` option makes this component to bind additional inter-thread socket with `SocketType.PUB` to capture and publish all the communication between frontend and backend sockets as it states with `ZMQ.proxy()` implementation.\n+This socket is bound into the `\"inproc://\" + beanName + \".capture\"` address and doesn't expect any specific subscription for filtering.\n+\n+The frontend and backend sockets can be customized for any additional properties, like read/write timeout or security.\n+This customization is available through `setFrontendSocketConfigurer(Consumer<ZMQ.Socket>)` and `setBackendSocketConfigurer(Consumer<ZMQ.Socket>)` callbacks, respectively.\n+\n+The `ZeroMqProxy` could be provides as simple bean like this:\n+\n+====\n+[source,java]\n+----\n+@Bean\n+ZeroMqProxy zeroMqProxy() {\n+    ZeroMqProxy proxy = new ZeroMqProxy(CONTEXT, ZeroMqProxy.Type.SUB_PUB);\n+    proxy.setExposeCaptureSocket(true);\n+    proxy.setFrontendPort(6001);\n+    proxy.setBackendPort(6002);\n+    return proxy;\n+}\n+----\n+====\n+\n+All the client nodes should connect to host of this proxy via `tcp://` and use respective port of their interest.\n+\n+[[zeromq-message-channel]]\n+=== ZeroMQ Message Channel\n+\n+The `ZeroMqChannel` is a `SubscribableChannel` which uses a pair of ZeroMQ sockets to connect publishers and subscribers for messaging interaction.\n+It can work in a PUB/SUB mode (defaults to PUSH/PULL); could be as local inter-thread channel (uses `PAIR` sockets) - the `connectUrl` is not provided.\n+In the distributed mode it has to be connected to externally managed ZeroMQ proxy, where it can exchange messages with other similar channels connected to the same proxy.\n+The connect url option is a standard ZeroMQ connection string with the protocol and host and a pair of ports over colon for frontend and backend sockets of the ZeroMQ proxy.\n+In fact, for convenience, the channel could be supplied with the `ZeroMqProxy` instance instead of connection string, if it is configured in the same application as proxy.\n+\n+Both sending and receiving sockets are managed in their own dedicated threads making this channel concurrency-friendly.\n+This way we can publish and consume to/from a `ZeroMqChannel` from different threads without synchronization.\n+\n+By default the `ZeroMqChannel` uses an `EmbeddedJsonHeadersMessageMapper` to (de)serialize the `Message` (including headers) from/to `byte[]` using Jackson JSON processor.\n+This logic can be configured via `setMessageMapper(BytesMessageMapper)`.\n+\n+Sending and receiving sockets can be customized for any options (e.g. read/write timeout, security etc.) via respective `setSendSocketConfigurer(Consumer<ZMQ.Socket>)` and `setSubscribeSocketConfigurer(Consumer<ZMQ.Socket>)` callbacks.\n+\n+An internal logic of the `ZeroMqChannel` is based on the reactive streams via Project Reactor `Flux` and `Mono` operators.\n+It gives us an easier threading control and allows to have a lock-free concurrent publication and consumption to/from the channel.\n+A local PUB/SUB logic is implemented as a `Flux.publish()` operator to allow all the local subscribers to this channel to have the same published message, as distributed subscribers to the `PUB` socket.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "642247cbf31fd5010e5fff2082f7786c66912f5d"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyODM5MTE4OnYy", "diffSide": "RIGHT", "path": "src/reference/asciidoc/zeromq.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNTo0Nzo0NVrOG--JxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNTo0Nzo0NVrOG--JxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY4MzIwNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The simple configuration for the `ZeroMqChannel` bean is like this:\n          \n          \n            \n            The following is a simple example of a `ZeroMqChannel` configuration:", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r468683204", "createdAt": "2020-08-11T15:47:45Z", "author": {"login": "garyrussell"}, "path": "src/reference/asciidoc/zeromq.adoc", "diffHunk": "@@ -0,0 +1,104 @@\n+[[zeromq]]\n+== ZeroMQ Support\n+\n+Spring Integration provides components to support https://zeromq.org/[ZeroMQ] communication in the application.\n+The implementation is based on the well-supported Java API of the https://github.com/zeromq/jeromq[JeroMQ] library.\n+All components encapsulate ZeroMQ socket lifecycles and manage threads for them internally making an interaction with these components as lock-free and thread-safe.\n+\n+You need to include this dependency into your project:\n+\n+====\n+.Maven\n+[source, xml, subs=\"normal\"]\n+----\n+<dependency>\n+    <groupId>org.springframework.integration</groupId>\n+    <artifactId>spring-integration-zeromq</artifactId>\n+    <version>{project-version}</version>\n+</dependency>\n+----\n+\n+.Gradle\n+[source, groovy, subs=\"normal\"]\n+----\n+compile \"org.springframework.integration:spring-integration-zeromq:{project-version}\"\n+----\n+====\n+\n+[[zeromq-proxy]]\n+=== ZeroMQ Proxy\n+\n+The `ZeroMqProxy` is a Spring-friendly wrapper for the built-in `ZMQ.proxy()` https://zguide.zeromq.org/page:chapter2#toc15[function].\n+It encapsulates socket lifecycles and thread management.\n+The clients of this proxy still can use a standard ZeroMQ socket connection and interaction API.\n+Alongside with the standard `ZContext` it requires one of the well-known ZeroMQ proxy modes: SUB/PUB, PULL/PUSH or ROUTER/DEALER.\n+This way an appropriate pair of ZeroMQ socket types are used for the frontend and backend of the proxy.\n+See `ZeroMqProxy.Type` for details.\n+\n+The `ZeroMqProxy` implements a `SmartLifecycle` to create, bind and configure all the sockets and to start `ZMQ.proxy()` in a dedicated thread from an `Executor` (if any).\n+The binding for frontend and backend sockets is done over `tcp://` protocol onto all the available network interfaces with the provided ports.\n+Otherwise they are bound to random ports which could be obtained later via a respective `getFrontendPort()` and `getBackendPort()` API.\n+\n+The control socket is exposed as a `SocketType.PAIR` with an inter-thread transport on the `\"inproc://\" + beanName + \".control\"` address; it can be obtained via `getControlAddress()`.\n+Should be used with the same application from another `SocketType.PAIR` socket to send `ZMQ.PROXY_TERMINATE`, `ZMQ.PROXY_PAUSE` and/or `ZMQ.PROXY_RESUME` commands.\n+In fact `ZeroMqProxy` uses performs a `ZMQ.PROXY_TERMINATE` command when `stop()` is called for its lifecycle to terminate `ZMQ.proxy()` loop and close all the bound sockets gracefully.\n+\n+A `setExposeCaptureSocket(boolean)` option makes this component to bind additional inter-thread socket with `SocketType.PUB` to capture and publish all the communication between frontend and backend sockets as it states with `ZMQ.proxy()` implementation.\n+This socket is bound into the `\"inproc://\" + beanName + \".capture\"` address and doesn't expect any specific subscription for filtering.\n+\n+The frontend and backend sockets can be customized for any additional properties, like read/write timeout or security.\n+This customization is available through `setFrontendSocketConfigurer(Consumer<ZMQ.Socket>)` and `setBackendSocketConfigurer(Consumer<ZMQ.Socket>)` callbacks, respectively.\n+\n+The `ZeroMqProxy` could be provides as simple bean like this:\n+\n+====\n+[source,java]\n+----\n+@Bean\n+ZeroMqProxy zeroMqProxy() {\n+    ZeroMqProxy proxy = new ZeroMqProxy(CONTEXT, ZeroMqProxy.Type.SUB_PUB);\n+    proxy.setExposeCaptureSocket(true);\n+    proxy.setFrontendPort(6001);\n+    proxy.setBackendPort(6002);\n+    return proxy;\n+}\n+----\n+====\n+\n+All the client nodes should connect to host of this proxy via `tcp://` and use respective port of their interest.\n+\n+[[zeromq-message-channel]]\n+=== ZeroMQ Message Channel\n+\n+The `ZeroMqChannel` is a `SubscribableChannel` which uses a pair of ZeroMQ sockets to connect publishers and subscribers for messaging interaction.\n+It can work in a PUB/SUB mode (defaults to PUSH/PULL); could be as local inter-thread channel (uses `PAIR` sockets) - the `connectUrl` is not provided.\n+In the distributed mode it has to be connected to externally managed ZeroMQ proxy, where it can exchange messages with other similar channels connected to the same proxy.\n+The connect url option is a standard ZeroMQ connection string with the protocol and host and a pair of ports over colon for frontend and backend sockets of the ZeroMQ proxy.\n+In fact, for convenience, the channel could be supplied with the `ZeroMqProxy` instance instead of connection string, if it is configured in the same application as proxy.\n+\n+Both sending and receiving sockets are managed in their own dedicated threads making this channel concurrency-friendly.\n+This way we can publish and consume to/from a `ZeroMqChannel` from different threads without synchronization.\n+\n+By default the `ZeroMqChannel` uses an `EmbeddedJsonHeadersMessageMapper` to (de)serialize the `Message` (including headers) from/to `byte[]` using Jackson JSON processor.\n+This logic can be configured via `setMessageMapper(BytesMessageMapper)`.\n+\n+Sending and receiving sockets can be customized for any options (e.g. read/write timeout, security etc.) via respective `setSendSocketConfigurer(Consumer<ZMQ.Socket>)` and `setSubscribeSocketConfigurer(Consumer<ZMQ.Socket>)` callbacks.\n+\n+An internal logic of the `ZeroMqChannel` is based on the reactive streams via Project Reactor `Flux` and `Mono` operators.\n+It gives us an easier threading control and allows to have a lock-free concurrent publication and consumption to/from the channel.\n+A local PUB/SUB logic is implemented as a `Flux.publish()` operator to allow all the local subscribers to this channel to have the same published message, as distributed subscribers to the `PUB` socket.\n+\n+The simple configuration for the `ZeroMqChannel` bean is like this:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "642247cbf31fd5010e5fff2082f7786c66912f5d"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyODQ0OTMyOnYy", "diffSide": "RIGHT", "path": "spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/channel/ZeroMqChannel.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNjowMTo1NlrOG--u4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNjozODozMlrOG_AKrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY5MjcwNA==", "bodyText": "Should this perhaps be handeled by an Assertstatement? This way it's just silently ignored when someone tries to set the connectUrl to null.", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r468692704", "createdAt": "2020-08-11T16:01:56Z", "author": {"login": "oli-ver"}, "path": "spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/channel/ZeroMqChannel.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/*\n+ * Copyright 2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.integration.zeromq.channel;\n+\n+import java.time.Duration;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+\n+import org.zeromq.SocketType;\n+import org.zeromq.ZContext;\n+import org.zeromq.ZMQ;\n+\n+import org.springframework.integration.channel.AbstractMessageChannel;\n+import org.springframework.integration.mapping.BytesMessageMapper;\n+import org.springframework.integration.support.json.EmbeddedJsonHeadersMessageMapper;\n+import org.springframework.integration.zeromq.ZeroMqProxy;\n+import org.springframework.lang.Nullable;\n+import org.springframework.messaging.Message;\n+import org.springframework.messaging.MessageHandler;\n+import org.springframework.messaging.SubscribableChannel;\n+import org.springframework.util.Assert;\n+\n+import reactor.core.Disposable;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+/**\n+ * The {@link SubscribableChannel} implementation over ZeroMQ sockets.\n+ * It can work in two messaging models:\n+ * - {@code push-pull}, where sent messages are distributed to subscribers in a round-robin manner\n+ * according a respective ZeroMQ {@link SocketType#PUSH} and {@link SocketType#PULL} socket types logic;\n+ * - {@code pub-sub}, where sent messages are distributed to all subscribers;\n+ * <p>\n+ * This message channel can work in local mode, when a pair of ZeroMQ sockets of {@link SocketType#PAIR} type\n+ * are connected between publisher (send operation) and subscriber using inter-thread transport binding.\n+ * <p>\n+ * In distributed mode this channel has to be connected to an externally managed ZeroMQ proxy.\n+ * The {@link #setConnectUrl(String)} has to be as a standard ZeroMQ connect string, but with an extra port\n+ * over the colon - representing a frontend and backend sockets pair on ZeroMQ proxy.\n+ * For example: {@code tcp://localhost:6001:6002}.\n+ * Another option is to provide a reference to the {@link ZeroMqProxy} instance managed in the same application:\n+ * frontend and backend ports are evaluated from this proxy and respective connection string is built from them.\n+ * <p>\n+ * This way sending and receiving operations on this channel are similar to interaction over a messaging broker.\n+ * <p>\n+ * An internal logic of this message channel implementation is based on the project Reactor using its\n+ * {@link Mono}, {@link Flux} and {@link Scheduler} API for better thead model and flow control to avoid\n+ * concurrency primitives for multi-publisher(subscriber) communication within the same application.\n+ *\n+ * @author Artem Bilan\n+ *\n+ * @since 5.4\n+ */\n+public class ZeroMqChannel extends AbstractMessageChannel implements SubscribableChannel {\n+\n+\tpublic static final Duration DEFAULT_CONSUME_DELAY = Duration.ofSeconds(1);\n+\n+\tprivate final Map<MessageHandler, Disposable> subscribers = new HashMap<>();\n+\n+\tprivate final Scheduler publisherScheduler = Schedulers.newSingle(\"publisherScheduler\");\n+\n+\tprivate final Scheduler subscriberScheduler = Schedulers.newSingle(\"subscriberScheduler\");\n+\n+\tprivate final ZContext context;\n+\n+\tprivate final boolean pubSub;\n+\n+\tprivate final Mono<ZMQ.Socket> sendSocket;\n+\n+\tprivate final Mono<ZMQ.Socket> subscribeSocket;\n+\n+\tprivate final Flux<? extends Message<?>> subscriberData;\n+\n+\tprivate Duration consumeDelay = DEFAULT_CONSUME_DELAY;\n+\n+\tprivate BytesMessageMapper messageMapper = new EmbeddedJsonHeadersMessageMapper();\n+\n+\tprivate Consumer<ZMQ.Socket> sendSocketConfigurer = (socket) -> { };\n+\n+\tprivate Consumer<ZMQ.Socket> subscribeSocketConfigurer = (socket) -> { };\n+\n+\t@Nullable\n+\tprivate ZeroMqProxy zeroMqProxy;\n+\n+\t@Nullable\n+\tprivate volatile String connectSendUrl;\n+\n+\t@Nullable\n+\tprivate volatile String connectSubscribeUrl;\n+\n+\t@Nullable\n+\tprivate volatile Disposable subscriberDataDisposable;\n+\n+\tprivate volatile boolean initialized;\n+\n+\tpublic ZeroMqChannel(ZContext context) {\n+\t\tthis(context, false);\n+\t}\n+\n+\tpublic ZeroMqChannel(ZContext context, boolean pubSub) {\n+\t\tAssert.notNull(context, \"'context' must not be null\");\n+\t\tthis.context = context;\n+\t\tthis.pubSub = pubSub;\n+\n+\t\tSupplier<String> localPairConnection = () -> \"inproc://\" + getComponentName() + \".pair\";\n+\n+\t\tMono<?> proxyMono =\n+\t\t\t\tMono.defer(() -> {\n+\t\t\t\t\tif (this.zeroMqProxy != null) {\n+\t\t\t\t\t\treturn Mono.just(this.zeroMqProxy.getBackendPort())\n+\t\t\t\t\t\t\t\t.filter((port) -> port > 0)\n+\t\t\t\t\t\t\t\t.repeatWhenEmpty((repeat) -> repeat.delayElements(Duration.ofMillis(100))) // NOSONAR\n+\t\t\t\t\t\t\t\t.doOnNext((port) ->\n+\t\t\t\t\t\t\t\t\t\tsetConnectUrl(\"tcp://localhost:\" + this.zeroMqProxy.getFrontendPort() +\n+\t\t\t\t\t\t\t\t\t\t\t\t':' + this.zeroMqProxy.getBackendPort()));\n+\t\t\t\t\t}\n+\t\t\t\t\telse {\n+\t\t\t\t\t\treturn Mono.empty();\n+\t\t\t\t\t}\n+\t\t\t\t})\n+\t\t\t\t\t\t.cache();\n+\n+\t\tthis.sendSocket =\n+\t\t\t\tproxyMono\n+\t\t\t\t\t\t.publishOn(this.publisherScheduler)\n+\t\t\t\t\t\t.then(Mono.fromCallable(() ->\n+\t\t\t\t\t\t\t\tthis.context.createSocket(\n+\t\t\t\t\t\t\t\t\t\tthis.connectSendUrl == null\n+\t\t\t\t\t\t\t\t\t\t\t\t? SocketType.PAIR\n+\t\t\t\t\t\t\t\t\t\t\t\t: (this.pubSub ? SocketType.XPUB : SocketType.PUSH))\n+\t\t\t\t\t\t))\n+\t\t\t\t\t\t.doOnNext(this.sendSocketConfigurer)\n+\t\t\t\t\t\t.doOnNext((socket) ->\n+\t\t\t\t\t\t\t\tsocket.connect(this.connectSendUrl != null\n+\t\t\t\t\t\t\t\t\t\t? this.connectSendUrl\n+\t\t\t\t\t\t\t\t\t\t: localPairConnection.get()))\n+\t\t\t\t\t\t.delayUntil((socket) ->\n+\t\t\t\t\t\t\t\t(this.pubSub && this.connectSendUrl != null)\n+\t\t\t\t\t\t\t\t\t\t? Mono.just(socket).map(ZMQ.Socket::recv)\n+\t\t\t\t\t\t\t\t\t\t: Mono.empty())\n+\t\t\t\t\t\t.cache();\n+\n+\t\tthis.subscribeSocket =\n+\t\t\t\tproxyMono\n+\t\t\t\t\t\t.publishOn(this.subscriberScheduler)\n+\t\t\t\t\t\t.then(Mono.fromCallable(() ->\n+\t\t\t\t\t\t\t\tthis.context.createSocket(\n+\t\t\t\t\t\t\t\t\t\tthis.connectSubscribeUrl == null\n+\t\t\t\t\t\t\t\t\t\t\t\t? SocketType.PAIR\n+\t\t\t\t\t\t\t\t\t\t\t\t: (this.pubSub ? SocketType.SUB : SocketType.PULL))))\n+\t\t\t\t\t\t.doOnNext(this.subscribeSocketConfigurer)\n+\t\t\t\t\t\t.doOnNext((socket) -> {\n+\t\t\t\t\t\t\tif (this.connectSubscribeUrl != null) {\n+\t\t\t\t\t\t\t\tsocket.connect(this.connectSubscribeUrl);\n+\t\t\t\t\t\t\t\tif (this.pubSub) {\n+\t\t\t\t\t\t\t\t\tsocket.subscribe(ZMQ.SUBSCRIPTION_ALL);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\telse {\n+\t\t\t\t\t\t\t\tsocket.bind(localPairConnection.get());\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t})\n+\t\t\t\t\t\t.cache();\n+\n+\t\tFlux<? extends Message<?>> receiveData =\n+\t\t\t\tthis.subscribeSocket\n+\t\t\t\t\t\t.flatMap((socket) -> {\n+\t\t\t\t\t\t\tif (this.initialized) {\n+\t\t\t\t\t\t\t\tbyte[] data = socket.recv(ZMQ.NOBLOCK);\n+\t\t\t\t\t\t\t\tif (data != null) {\n+\t\t\t\t\t\t\t\t\treturn Mono.just(data);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\treturn Mono.empty();\n+\t\t\t\t\t\t})\n+\t\t\t\t\t\t.publishOn(Schedulers.parallel())\n+\t\t\t\t\t\t.map(this.messageMapper::toMessage)\n+\t\t\t\t\t\t.doOnError((error) -> logger.error(\"Error processing ZeroMQ message\", error))\n+\t\t\t\t\t\t.repeatWhenEmpty((repeat) ->\n+\t\t\t\t\t\t\t\tthis.initialized\n+\t\t\t\t\t\t\t\t\t\t? repeat.delayElements(this.consumeDelay)\n+\t\t\t\t\t\t\t\t\t\t: repeat)\n+\t\t\t\t\t\t.repeat(() -> this.initialized);\n+\n+\t\tif (this.pubSub) {\n+\t\t\treceiveData = receiveData.publish()\n+\t\t\t\t\t.autoConnect(1, (disposable) -> this.subscriberDataDisposable = disposable);\n+\t\t}\n+\n+\t\tthis.subscriberData = receiveData;\n+\n+\t}\n+\n+\t/**\n+\t * Configure a connection to the ZeroMQ proxy with the pair of ports over colon\n+\t * for proxy frontend and backend sockets. Mutually exclusive with the {@link #setZeroMqProxy(ZeroMqProxy)}.\n+\t * @param connectUrl the connection string in format {@code PROTOCOL://HOST:FRONTEND_PORT:BACKEND_PORT},\n+\t *                    e.g. {@code tcp://localhost:6001:6002}\n+\t */\n+\tpublic void setConnectUrl(@Nullable String connectUrl) {\n+\t\tif (connectUrl != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "642247cbf31fd5010e5fff2082f7786c66912f5d"}, "originalPosition": 220}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODcxNjIwNA==", "bodyText": "I don't think so. This option really can be as a null.\nImagine a Spring Boot configuration property when you just propagate it into this setter.\nIn one environment it can be empty (or missed) and will make this channel in a local mode, e.g. for testing.\nIn another env it is going to have some reasonable value for connection to the proxy.\nIndependently of the env your code around this channel configuration is going to be the same.", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r468716204", "createdAt": "2020-08-11T16:38:32Z", "author": {"login": "artembilan"}, "path": "spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/channel/ZeroMqChannel.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/*\n+ * Copyright 2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.integration.zeromq.channel;\n+\n+import java.time.Duration;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+\n+import org.zeromq.SocketType;\n+import org.zeromq.ZContext;\n+import org.zeromq.ZMQ;\n+\n+import org.springframework.integration.channel.AbstractMessageChannel;\n+import org.springframework.integration.mapping.BytesMessageMapper;\n+import org.springframework.integration.support.json.EmbeddedJsonHeadersMessageMapper;\n+import org.springframework.integration.zeromq.ZeroMqProxy;\n+import org.springframework.lang.Nullable;\n+import org.springframework.messaging.Message;\n+import org.springframework.messaging.MessageHandler;\n+import org.springframework.messaging.SubscribableChannel;\n+import org.springframework.util.Assert;\n+\n+import reactor.core.Disposable;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+/**\n+ * The {@link SubscribableChannel} implementation over ZeroMQ sockets.\n+ * It can work in two messaging models:\n+ * - {@code push-pull}, where sent messages are distributed to subscribers in a round-robin manner\n+ * according a respective ZeroMQ {@link SocketType#PUSH} and {@link SocketType#PULL} socket types logic;\n+ * - {@code pub-sub}, where sent messages are distributed to all subscribers;\n+ * <p>\n+ * This message channel can work in local mode, when a pair of ZeroMQ sockets of {@link SocketType#PAIR} type\n+ * are connected between publisher (send operation) and subscriber using inter-thread transport binding.\n+ * <p>\n+ * In distributed mode this channel has to be connected to an externally managed ZeroMQ proxy.\n+ * The {@link #setConnectUrl(String)} has to be as a standard ZeroMQ connect string, but with an extra port\n+ * over the colon - representing a frontend and backend sockets pair on ZeroMQ proxy.\n+ * For example: {@code tcp://localhost:6001:6002}.\n+ * Another option is to provide a reference to the {@link ZeroMqProxy} instance managed in the same application:\n+ * frontend and backend ports are evaluated from this proxy and respective connection string is built from them.\n+ * <p>\n+ * This way sending and receiving operations on this channel are similar to interaction over a messaging broker.\n+ * <p>\n+ * An internal logic of this message channel implementation is based on the project Reactor using its\n+ * {@link Mono}, {@link Flux} and {@link Scheduler} API for better thead model and flow control to avoid\n+ * concurrency primitives for multi-publisher(subscriber) communication within the same application.\n+ *\n+ * @author Artem Bilan\n+ *\n+ * @since 5.4\n+ */\n+public class ZeroMqChannel extends AbstractMessageChannel implements SubscribableChannel {\n+\n+\tpublic static final Duration DEFAULT_CONSUME_DELAY = Duration.ofSeconds(1);\n+\n+\tprivate final Map<MessageHandler, Disposable> subscribers = new HashMap<>();\n+\n+\tprivate final Scheduler publisherScheduler = Schedulers.newSingle(\"publisherScheduler\");\n+\n+\tprivate final Scheduler subscriberScheduler = Schedulers.newSingle(\"subscriberScheduler\");\n+\n+\tprivate final ZContext context;\n+\n+\tprivate final boolean pubSub;\n+\n+\tprivate final Mono<ZMQ.Socket> sendSocket;\n+\n+\tprivate final Mono<ZMQ.Socket> subscribeSocket;\n+\n+\tprivate final Flux<? extends Message<?>> subscriberData;\n+\n+\tprivate Duration consumeDelay = DEFAULT_CONSUME_DELAY;\n+\n+\tprivate BytesMessageMapper messageMapper = new EmbeddedJsonHeadersMessageMapper();\n+\n+\tprivate Consumer<ZMQ.Socket> sendSocketConfigurer = (socket) -> { };\n+\n+\tprivate Consumer<ZMQ.Socket> subscribeSocketConfigurer = (socket) -> { };\n+\n+\t@Nullable\n+\tprivate ZeroMqProxy zeroMqProxy;\n+\n+\t@Nullable\n+\tprivate volatile String connectSendUrl;\n+\n+\t@Nullable\n+\tprivate volatile String connectSubscribeUrl;\n+\n+\t@Nullable\n+\tprivate volatile Disposable subscriberDataDisposable;\n+\n+\tprivate volatile boolean initialized;\n+\n+\tpublic ZeroMqChannel(ZContext context) {\n+\t\tthis(context, false);\n+\t}\n+\n+\tpublic ZeroMqChannel(ZContext context, boolean pubSub) {\n+\t\tAssert.notNull(context, \"'context' must not be null\");\n+\t\tthis.context = context;\n+\t\tthis.pubSub = pubSub;\n+\n+\t\tSupplier<String> localPairConnection = () -> \"inproc://\" + getComponentName() + \".pair\";\n+\n+\t\tMono<?> proxyMono =\n+\t\t\t\tMono.defer(() -> {\n+\t\t\t\t\tif (this.zeroMqProxy != null) {\n+\t\t\t\t\t\treturn Mono.just(this.zeroMqProxy.getBackendPort())\n+\t\t\t\t\t\t\t\t.filter((port) -> port > 0)\n+\t\t\t\t\t\t\t\t.repeatWhenEmpty((repeat) -> repeat.delayElements(Duration.ofMillis(100))) // NOSONAR\n+\t\t\t\t\t\t\t\t.doOnNext((port) ->\n+\t\t\t\t\t\t\t\t\t\tsetConnectUrl(\"tcp://localhost:\" + this.zeroMqProxy.getFrontendPort() +\n+\t\t\t\t\t\t\t\t\t\t\t\t':' + this.zeroMqProxy.getBackendPort()));\n+\t\t\t\t\t}\n+\t\t\t\t\telse {\n+\t\t\t\t\t\treturn Mono.empty();\n+\t\t\t\t\t}\n+\t\t\t\t})\n+\t\t\t\t\t\t.cache();\n+\n+\t\tthis.sendSocket =\n+\t\t\t\tproxyMono\n+\t\t\t\t\t\t.publishOn(this.publisherScheduler)\n+\t\t\t\t\t\t.then(Mono.fromCallable(() ->\n+\t\t\t\t\t\t\t\tthis.context.createSocket(\n+\t\t\t\t\t\t\t\t\t\tthis.connectSendUrl == null\n+\t\t\t\t\t\t\t\t\t\t\t\t? SocketType.PAIR\n+\t\t\t\t\t\t\t\t\t\t\t\t: (this.pubSub ? SocketType.XPUB : SocketType.PUSH))\n+\t\t\t\t\t\t))\n+\t\t\t\t\t\t.doOnNext(this.sendSocketConfigurer)\n+\t\t\t\t\t\t.doOnNext((socket) ->\n+\t\t\t\t\t\t\t\tsocket.connect(this.connectSendUrl != null\n+\t\t\t\t\t\t\t\t\t\t? this.connectSendUrl\n+\t\t\t\t\t\t\t\t\t\t: localPairConnection.get()))\n+\t\t\t\t\t\t.delayUntil((socket) ->\n+\t\t\t\t\t\t\t\t(this.pubSub && this.connectSendUrl != null)\n+\t\t\t\t\t\t\t\t\t\t? Mono.just(socket).map(ZMQ.Socket::recv)\n+\t\t\t\t\t\t\t\t\t\t: Mono.empty())\n+\t\t\t\t\t\t.cache();\n+\n+\t\tthis.subscribeSocket =\n+\t\t\t\tproxyMono\n+\t\t\t\t\t\t.publishOn(this.subscriberScheduler)\n+\t\t\t\t\t\t.then(Mono.fromCallable(() ->\n+\t\t\t\t\t\t\t\tthis.context.createSocket(\n+\t\t\t\t\t\t\t\t\t\tthis.connectSubscribeUrl == null\n+\t\t\t\t\t\t\t\t\t\t\t\t? SocketType.PAIR\n+\t\t\t\t\t\t\t\t\t\t\t\t: (this.pubSub ? SocketType.SUB : SocketType.PULL))))\n+\t\t\t\t\t\t.doOnNext(this.subscribeSocketConfigurer)\n+\t\t\t\t\t\t.doOnNext((socket) -> {\n+\t\t\t\t\t\t\tif (this.connectSubscribeUrl != null) {\n+\t\t\t\t\t\t\t\tsocket.connect(this.connectSubscribeUrl);\n+\t\t\t\t\t\t\t\tif (this.pubSub) {\n+\t\t\t\t\t\t\t\t\tsocket.subscribe(ZMQ.SUBSCRIPTION_ALL);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\telse {\n+\t\t\t\t\t\t\t\tsocket.bind(localPairConnection.get());\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t})\n+\t\t\t\t\t\t.cache();\n+\n+\t\tFlux<? extends Message<?>> receiveData =\n+\t\t\t\tthis.subscribeSocket\n+\t\t\t\t\t\t.flatMap((socket) -> {\n+\t\t\t\t\t\t\tif (this.initialized) {\n+\t\t\t\t\t\t\t\tbyte[] data = socket.recv(ZMQ.NOBLOCK);\n+\t\t\t\t\t\t\t\tif (data != null) {\n+\t\t\t\t\t\t\t\t\treturn Mono.just(data);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\treturn Mono.empty();\n+\t\t\t\t\t\t})\n+\t\t\t\t\t\t.publishOn(Schedulers.parallel())\n+\t\t\t\t\t\t.map(this.messageMapper::toMessage)\n+\t\t\t\t\t\t.doOnError((error) -> logger.error(\"Error processing ZeroMQ message\", error))\n+\t\t\t\t\t\t.repeatWhenEmpty((repeat) ->\n+\t\t\t\t\t\t\t\tthis.initialized\n+\t\t\t\t\t\t\t\t\t\t? repeat.delayElements(this.consumeDelay)\n+\t\t\t\t\t\t\t\t\t\t: repeat)\n+\t\t\t\t\t\t.repeat(() -> this.initialized);\n+\n+\t\tif (this.pubSub) {\n+\t\t\treceiveData = receiveData.publish()\n+\t\t\t\t\t.autoConnect(1, (disposable) -> this.subscriberDataDisposable = disposable);\n+\t\t}\n+\n+\t\tthis.subscriberData = receiveData;\n+\n+\t}\n+\n+\t/**\n+\t * Configure a connection to the ZeroMQ proxy with the pair of ports over colon\n+\t * for proxy frontend and backend sockets. Mutually exclusive with the {@link #setZeroMqProxy(ZeroMqProxy)}.\n+\t * @param connectUrl the connection string in format {@code PROTOCOL://HOST:FRONTEND_PORT:BACKEND_PORT},\n+\t *                    e.g. {@code tcp://localhost:6001:6002}\n+\t */\n+\tpublic void setConnectUrl(@Nullable String connectUrl) {\n+\t\tif (connectUrl != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY5MjcwNA=="}, "originalCommit": {"oid": "642247cbf31fd5010e5fff2082f7786c66912f5d"}, "originalPosition": 220}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1887, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}