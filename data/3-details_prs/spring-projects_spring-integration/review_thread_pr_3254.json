{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA3NDY1MTA4", "number": 3254, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMTo0Nzo0MlrOD0_MWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMTo1MDoyNFrOD0_P9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2ODg3ODk4OnYy", "diffSide": "RIGHT", "path": "src/reference/asciidoc/reactive-streams.adoc", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMTo0Nzo0MlrOGKNQHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMTo0Nzo0MlrOGKNQHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM1NjA2MQ==", "bodyText": "mentioned", "url": "https://github.com/spring-projects/spring-integration/pull/3254#discussion_r413356061", "createdAt": "2020-04-22T21:47:42Z", "author": {"login": "garyrussell"}, "path": "src/reference/asciidoc/reactive-streams.adoc", "diffHunk": "@@ -89,6 +89,17 @@ The channel adapter goes to a stopped state when a subscription to the `Publishe\n Calling `stop()` on such a channel adapter completes the producing from the source `Publisher`.\n The channel adapter can be restarted with automatic subscription to a newly created source `Publisher`.\n \n+=== Message Source to Reactive Streams\n+\n+Starting with version 5.3, a `ReactiveMessageSourceProducer` is provided.\n+It is a combination of a provided `MessageSource` and event-driven production into the configured `outputChannel`.\n+Internally it wraps a `MessageSource` into the repeatedly resubscribed `Mono` producing a `Flux<Message<?>>` to be subscribed in the `subscribeToPublisher(Publisher<? extends Message<?>>)` mention above.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ff705cba5e38ff213c4186a1671044df15256ba"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2ODg4MTE1OnYy", "diffSide": "RIGHT", "path": "src/reference/asciidoc/reactive-streams.adoc", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMTo0ODoyMVrOGKNRZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMTo0ODoyMVrOGKNRZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM1NjM4OQ==", "bodyText": "it is 1 second.", "url": "https://github.com/spring-projects/spring-integration/pull/3254#discussion_r413356389", "createdAt": "2020-04-22T21:48:21Z", "author": {"login": "garyrussell"}, "path": "src/reference/asciidoc/reactive-streams.adoc", "diffHunk": "@@ -89,6 +89,17 @@ The channel adapter goes to a stopped state when a subscription to the `Publishe\n Calling `stop()` on such a channel adapter completes the producing from the source `Publisher`.\n The channel adapter can be restarted with automatic subscription to a newly created source `Publisher`.\n \n+=== Message Source to Reactive Streams\n+\n+Starting with version 5.3, a `ReactiveMessageSourceProducer` is provided.\n+It is a combination of a provided `MessageSource` and event-driven production into the configured `outputChannel`.\n+Internally it wraps a `MessageSource` into the repeatedly resubscribed `Mono` producing a `Flux<Message<?>>` to be subscribed in the `subscribeToPublisher(Publisher<? extends Message<?>>)` mention above.\n+The subscription for this `Mono` is done using `Schedulers.boundedElastic()` to avoid possible blocking in the target `MessageSource`.\n+When the message source returns `null` (no data to pull), the `Mono` is turned into a `repeatWhenEmpty()` state with a `delay` for a subsequent re-subscription based on a `IntegrationReactiveUtils.DELAY_WHEN_EMPTY_KEY` `Duration` entry from the subscriber context.\n+By default it is a 1 second.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ff705cba5e38ff213c4186a1671044df15256ba"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2ODg4Mzg5OnYy", "diffSide": "RIGHT", "path": "src/reference/asciidoc/reactive-streams.adoc", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMTo0OTowN1rOGKNS9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMTo0OTowN1rOGKNS9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM1Njc5MA==", "bodyText": "in the headers\nif the downstream flow throws\nwith the failed messagee", "url": "https://github.com/spring-projects/spring-integration/pull/3254#discussion_r413356790", "createdAt": "2020-04-22T21:49:07Z", "author": {"login": "garyrussell"}, "path": "src/reference/asciidoc/reactive-streams.adoc", "diffHunk": "@@ -89,6 +89,17 @@ The channel adapter goes to a stopped state when a subscription to the `Publishe\n Calling `stop()` on such a channel adapter completes the producing from the source `Publisher`.\n The channel adapter can be restarted with automatic subscription to a newly created source `Publisher`.\n \n+=== Message Source to Reactive Streams\n+\n+Starting with version 5.3, a `ReactiveMessageSourceProducer` is provided.\n+It is a combination of a provided `MessageSource` and event-driven production into the configured `outputChannel`.\n+Internally it wraps a `MessageSource` into the repeatedly resubscribed `Mono` producing a `Flux<Message<?>>` to be subscribed in the `subscribeToPublisher(Publisher<? extends Message<?>>)` mention above.\n+The subscription for this `Mono` is done using `Schedulers.boundedElastic()` to avoid possible blocking in the target `MessageSource`.\n+When the message source returns `null` (no data to pull), the `Mono` is turned into a `repeatWhenEmpty()` state with a `delay` for a subsequent re-subscription based on a `IntegrationReactiveUtils.DELAY_WHEN_EMPTY_KEY` `Duration` entry from the subscriber context.\n+By default it is a 1 second.\n+If the `MessageSource` produces messages with a `IntegrationMessageHeaderAccessor.ACKNOWLEDGMENT_CALLBACK` information in headers, it is acknowledged (if necessary) in the `doOnSuccess()` of the original `Mono` and rejected in the `doOnError()` if downstream flow throws a `MessagingException` with failed message to reject.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ff705cba5e38ff213c4186a1671044df15256ba"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2ODg4NjgyOnYy", "diffSide": "RIGHT", "path": "src/reference/asciidoc/reactive-streams.adoc", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMTo0OTo1N1rOGKNUvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMTo0OTo1N1rOGKNUvg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM1NzI0Ng==", "bodyText": "a polling channel adapter's features", "url": "https://github.com/spring-projects/spring-integration/pull/3254#discussion_r413357246", "createdAt": "2020-04-22T21:49:57Z", "author": {"login": "garyrussell"}, "path": "src/reference/asciidoc/reactive-streams.adoc", "diffHunk": "@@ -89,6 +89,17 @@ The channel adapter goes to a stopped state when a subscription to the `Publishe\n Calling `stop()` on such a channel adapter completes the producing from the source `Publisher`.\n The channel adapter can be restarted with automatic subscription to a newly created source `Publisher`.\n \n+=== Message Source to Reactive Streams\n+\n+Starting with version 5.3, a `ReactiveMessageSourceProducer` is provided.\n+It is a combination of a provided `MessageSource` and event-driven production into the configured `outputChannel`.\n+Internally it wraps a `MessageSource` into the repeatedly resubscribed `Mono` producing a `Flux<Message<?>>` to be subscribed in the `subscribeToPublisher(Publisher<? extends Message<?>>)` mention above.\n+The subscription for this `Mono` is done using `Schedulers.boundedElastic()` to avoid possible blocking in the target `MessageSource`.\n+When the message source returns `null` (no data to pull), the `Mono` is turned into a `repeatWhenEmpty()` state with a `delay` for a subsequent re-subscription based on a `IntegrationReactiveUtils.DELAY_WHEN_EMPTY_KEY` `Duration` entry from the subscriber context.\n+By default it is a 1 second.\n+If the `MessageSource` produces messages with a `IntegrationMessageHeaderAccessor.ACKNOWLEDGMENT_CALLBACK` information in headers, it is acknowledged (if necessary) in the `doOnSuccess()` of the original `Mono` and rejected in the `doOnError()` if downstream flow throws a `MessagingException` with failed message to reject.\n+This `ReactiveMessageSourceProducer` could be used for any use-case when a polling channel adapter features should be turned into a reactive, on demand solution for any existing `MessageSource<?>` implementation.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ff705cba5e38ff213c4186a1671044df15256ba"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2ODg4ODIzOnYy", "diffSide": "RIGHT", "path": "src/reference/asciidoc/whats-new.adoc", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMTo1MDoyNFrOGKNVkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQyMTo1MDoyNFrOGKNVkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzM1NzQ1Ng==", "bodyText": "into a Flux", "url": "https://github.com/spring-projects/spring-integration/pull/3254#discussion_r413357456", "createdAt": "2020-04-22T21:50:24Z", "author": {"login": "garyrussell"}, "path": "src/reference/asciidoc/whats-new.adoc", "diffHunk": "@@ -27,6 +27,13 @@ See its JavaDocs and <<./graph.adoc#integration-graph,Integration Graph>> for mo\n The `ReactiveMessageHandler` is now natively supported in the framework.\n See <<./reactive-streams.adoc#reactive-message-handler,ReactiveMessageHandler>> for more information.\n \n+\n+[[x5.3-reactive-message-source-producer]]\n+==== `ReactiveMessageSourceProducer`\n+\n+The `ReactiveMessageSourceProducer` is a reactive implementation of the `MessageProducerSupport` to wrap a provided `MessageSource` into the `Flux` for on demand `receive()` calls.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ff705cba5e38ff213c4186a1671044df15256ba"}, "originalPosition": 8}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2027, "cost": 1, "resetAt": "2021-11-13T12:26:42Z"}}}