{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDYyNDA4MjAx", "number": 3355, "title": "INT-3045: Add `ZeroMqChannel` support", "bodyText": "JIRA: https://jira.spring.io/browse/INT-3045\nProvide a SubscribableChannel implementation for ZeroMQ\nThe general idea is to let to have a distributed channel implementation\nwhere every client can connect to a single server backed by the channel.\nThe logic in the channel is fully transparent for end-user and there is just\nenough to send message to it and subscribe for receiving on the other side.\nIf PUB/SUB model is used, all the subscribes (even over the network) going to\nreceive the same published message.\nIn case of PUSH/PULL only one subscriber in the whole cluster is going to get\nthe published message\n\nUse Reactor for better threading control\nJeroMQ is not interruptible-friendly: use control sockets to stop proxy loop\nName Reactor's schedulers to avoid daemon threads", "createdAt": "2020-08-03T21:33:23Z", "url": "https://github.com/spring-projects/spring-integration/pull/3355", "merged": true, "mergeCommit": {"oid": "a76bb24965a3ff7b7abc666e115c4e117e892ce6"}, "closed": true, "closedAt": "2020-08-11T19:04:03Z", "author": {"login": "artembilan"}, "timelineItems": {"totalCount": 35, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc8WHCOABqjM2MzA3Nzg5NDc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc97jxYAFqTQ2NTM0NTM3Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "dae62f1c8e7b1769d7db9f8125de474297bc876c", "author": {"user": {"login": "artembilan", "name": "Artem Bilan"}}, "url": "https://github.com/spring-projects/spring-integration/commit/dae62f1c8e7b1769d7db9f8125de474297bc876c", "committedDate": "2020-08-04T02:17:19Z", "message": "* Use try-catch-with-resource to close sockets automatically\n* Fix Checkstyle violations\n* Use `Mono.handle()` to receive data from the socket"}, "afterCommit": {"oid": "351f2706e8800ae0e2284e25cb55d0cc19b201fb", "author": {"user": {"login": "artembilan", "name": "Artem Bilan"}}, "url": "https://github.com/spring-projects/spring-integration/commit/351f2706e8800ae0e2284e25cb55d0cc19b201fb", "committedDate": "2020-08-06T20:46:57Z", "message": "* Fix subscriber scheduler name\n* Optimize socket create logic\n* Add PUSH/PULL over TCP test\n* Implement PUB/SUB over TCP"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzNDk2MjY1", "url": "https://github.com/spring-projects/spring-integration/pull/3355#pullrequestreview-463496265", "createdAt": "2020-08-07T17:50:18Z", "commit": {"oid": "eec1ff14146553e7e03d2842232d05c770884183"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNzo1MDoxOFrOG9isRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxNzo1NToyM1rOG9i16w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE4NDcwOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            /**\n          \n          \n            \n             * This class encapsulates a logic to configure and manage ZeroMQ proxy.\n          \n          \n            \n             * It binds frontend and backend sockets over TCP on all the available network interfaces\n          \n          \n            \n             * with provided ports or randomly selected otherwise.\n          \n          \n            \n             * <p>\n          \n          \n            \n             * The {@link ZeroMqProxy.Type} dictates which pair of ZeroMQ sockets to bind with this proxy\n          \n          \n            \n             * to implement any possible patterns for ZeroMQ intermediary. Defaults to @link {@link ZeroMqProxy.Type#PULL_PUSH}.\n          \n          \n            \n             * <p>\n          \n          \n            \n             * The control socket is exposed as a {@link SocketType#PAIR} with an inter-thread transport\n          \n          \n            \n             * on tne {@code \"inproc://\" + beanName + \".control\"} address - can be obtained via {@link #getControlAddress()}.\n          \n          \n            \n             * Should be used with the same application from {@link SocketType#PAIR} socket to send\n          \n          \n            \n             * {@link zmq.ZMQ#PROXY_TERMINATE}, {@link zmq.ZMQ#PROXY_PAUSE} and/or {@link zmq.ZMQ#PROXY_RESUME} commands.\n          \n          \n            \n             * <p>\n          \n          \n            \n             * If proxy cannot be started for some reason, the error message is logged respectively and this component is\n          \n          \n            \n             * left in the non-starting state.\n          \n          \n            \n            /**\n          \n          \n            \n             * This class encapsulates the logic to configure and manage a ZeroMQ proxy.\n          \n          \n            \n             * It binds frontend and backend sockets over TCP on all the available network interfaces\n          \n          \n            \n             * with either provided or randomly selected ports.\n          \n          \n            \n             * <p>\n          \n          \n            \n             * The {@link ZeroMqProxy.Type} dictates which pair of ZeroMQ sockets to bind with this proxy\n          \n          \n            \n             * to implement any possible patterns for ZeroMQ intermediary. Defaults to @link {@link ZeroMqProxy.Type#PULL_PUSH}.\n          \n          \n            \n             * <p>\n          \n          \n            \n             * The control socket is exposed as a {@link SocketType#PAIR} with an inter-thread transport\n          \n          \n            \n             * on tne {@code \"inproc://\" + beanName + \".control\"} address; it can be obtained via {@link #getControlAddress()}.\n          \n          \n            \n             * Should be used with the same application from {@link SocketType#PAIR} socket to send\n          \n          \n            \n             * {@link zmq.ZMQ#PROXY_TERMINATE}, {@link zmq.ZMQ#PROXY_PAUSE} and/or {@link zmq.ZMQ#PROXY_RESUME} commands.\n          \n          \n            \n             * <p>\n          \n          \n            \n             * If the proxy cannot be started for some reason, an error message is logged and this component is\n          \n          \n            \n             * left in the non-started state.", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r467184709", "createdAt": "2020-08-07T17:50:18Z", "author": {"login": "garyrussell"}, "path": "spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/ZeroMqProxy.java", "diffHunk": "@@ -0,0 +1,281 @@\n+/*\n+ * Copyright 2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.integration.zeromq;\n+\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Consumer;\n+\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.zeromq.SocketType;\n+import org.zeromq.ZContext;\n+import org.zeromq.ZMQ;\n+\n+import org.springframework.beans.factory.BeanNameAware;\n+import org.springframework.beans.factory.InitializingBean;\n+import org.springframework.context.SmartLifecycle;\n+import org.springframework.lang.Nullable;\n+import org.springframework.scheduling.concurrent.CustomizableThreadFactory;\n+import org.springframework.util.Assert;\n+\n+/**\n+ * This class encapsulates a logic to configure and manage ZeroMQ proxy.\n+ * It binds frontend and backend sockets over TCP on all the available network interfaces\n+ * with provided ports or randomly selected otherwise.\n+ * <p>\n+ * The {@link ZeroMqProxy.Type} dictates which pair of ZeroMQ sockets to bind with this proxy\n+ * to implement any possible patterns for ZeroMQ intermediary. Defaults to @link {@link ZeroMqProxy.Type#PULL_PUSH}.\n+ * <p>\n+ * The control socket is exposed as a {@link SocketType#PAIR} with an inter-thread transport\n+ * on tne {@code \"inproc://\" + beanName + \".control\"} address - can be obtained via {@link #getControlAddress()}.\n+ * Should be used with the same application from {@link SocketType#PAIR} socket to send\n+ * {@link zmq.ZMQ#PROXY_TERMINATE}, {@link zmq.ZMQ#PROXY_PAUSE} and/or {@link zmq.ZMQ#PROXY_RESUME} commands.\n+ * <p>\n+ * If proxy cannot be started for some reason, the error message is logged respectively and this component is\n+ * left in the non-starting state.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eec1ff14146553e7e03d2842232d05c770884183"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE4NTYzMw==", "bodyText": "Needs DisposableBean to shut down the internal executor, if any.", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r467185633", "createdAt": "2020-08-07T17:52:14Z", "author": {"login": "garyrussell"}, "path": "spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/ZeroMqProxy.java", "diffHunk": "@@ -0,0 +1,281 @@\n+/*\n+ * Copyright 2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.integration.zeromq;\n+\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Consumer;\n+\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.zeromq.SocketType;\n+import org.zeromq.ZContext;\n+import org.zeromq.ZMQ;\n+\n+import org.springframework.beans.factory.BeanNameAware;\n+import org.springframework.beans.factory.InitializingBean;\n+import org.springframework.context.SmartLifecycle;\n+import org.springframework.lang.Nullable;\n+import org.springframework.scheduling.concurrent.CustomizableThreadFactory;\n+import org.springframework.util.Assert;\n+\n+/**\n+ * This class encapsulates a logic to configure and manage ZeroMQ proxy.\n+ * It binds frontend and backend sockets over TCP on all the available network interfaces\n+ * with provided ports or randomly selected otherwise.\n+ * <p>\n+ * The {@link ZeroMqProxy.Type} dictates which pair of ZeroMQ sockets to bind with this proxy\n+ * to implement any possible patterns for ZeroMQ intermediary. Defaults to @link {@link ZeroMqProxy.Type#PULL_PUSH}.\n+ * <p>\n+ * The control socket is exposed as a {@link SocketType#PAIR} with an inter-thread transport\n+ * on tne {@code \"inproc://\" + beanName + \".control\"} address - can be obtained via {@link #getControlAddress()}.\n+ * Should be used with the same application from {@link SocketType#PAIR} socket to send\n+ * {@link zmq.ZMQ#PROXY_TERMINATE}, {@link zmq.ZMQ#PROXY_PAUSE} and/or {@link zmq.ZMQ#PROXY_RESUME} commands.\n+ * <p>\n+ * If proxy cannot be started for some reason, the error message is logged respectively and this component is\n+ * left in the non-starting state.\n+ *\n+ * @author Artem Bilan\n+ *\n+ * @since 5.4\n+ *\n+ * @see ZMQ#proxy(ZMQ.Socket, ZMQ.Socket, ZMQ.Socket)\n+ */\n+public class ZeroMqProxy implements InitializingBean, SmartLifecycle, BeanNameAware {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eec1ff14146553e7e03d2842232d05c770884183"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE4NzE3OQ==", "bodyText": "Need Meters?\nWhat about send failures?", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r467187179", "createdAt": "2020-08-07T17:55:23Z", "author": {"login": "garyrussell"}, "path": "spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/channel/ZeroMqChannel.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Copyright 2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.integration.zeromq.channel;\n+\n+import java.time.Duration;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.function.Supplier;\n+\n+import org.zeromq.SocketType;\n+import org.zeromq.ZContext;\n+import org.zeromq.ZMQ;\n+\n+import org.springframework.integration.channel.AbstractMessageChannel;\n+import org.springframework.integration.mapping.BytesMessageMapper;\n+import org.springframework.integration.support.json.EmbeddedJsonHeadersMessageMapper;\n+import org.springframework.lang.Nullable;\n+import org.springframework.messaging.Message;\n+import org.springframework.messaging.MessageHandler;\n+import org.springframework.messaging.SubscribableChannel;\n+import org.springframework.util.Assert;\n+\n+import reactor.core.Disposable;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+/**\n+ * @author Artem Bilan\n+ *\n+ * @since 5.4\n+ */\n+public class ZeroMqChannel extends AbstractMessageChannel implements SubscribableChannel {\n+\n+\tprivate final Map<MessageHandler, Disposable> subscribers = new HashMap<>();\n+\n+\tprivate final Scheduler publisherScheduler = Schedulers.newSingle(\"publisherScheduler\");\n+\n+\tprivate final Scheduler subscriberScheduler = Schedulers.newSingle(\"subscriberScheduler\");\n+\n+\tprivate final ZContext context;\n+\n+\tprivate final boolean pubSub;\n+\n+\tprivate final Mono<ZMQ.Socket> sendSocket;\n+\n+\tprivate final Mono<ZMQ.Socket> subscribeSocket;\n+\n+\tprivate final Flux<? extends Message<?>> subscriberData;\n+\n+\tprivate BytesMessageMapper messageMapper = new EmbeddedJsonHeadersMessageMapper();\n+\n+\t@Nullable\n+\tprivate volatile String connectSendUrl;\n+\n+\t@Nullable\n+\tprivate volatile String connectSubscribeUrl;\n+\n+\t@Nullable\n+\tprivate volatile Disposable subscriberDataDisposable;\n+\n+\tprivate volatile boolean initialized;\n+\n+\tpublic ZeroMqChannel(ZContext context) {\n+\t\tthis(context, false);\n+\t}\n+\n+\tpublic ZeroMqChannel(ZContext context, boolean pubSub) {\n+\t\tAssert.notNull(context, \"'context' must not be null\");\n+\t\tthis.context = context;\n+\t\tthis.pubSub = pubSub;\n+\n+\t\tSupplier<String> localPairConnection = () -> \"inproc://\" + getComponentName() + \".pair\";\n+\n+\t\tthis.sendSocket =\n+\t\t\t\tMono.fromCallable(() ->\n+\t\t\t\t\t\tthis.context.createSocket(\n+\t\t\t\t\t\t\t\tthis.connectSendUrl == null\n+\t\t\t\t\t\t\t\t\t\t? SocketType.PAIR\n+\t\t\t\t\t\t\t\t\t\t: (this.pubSub ? SocketType.XPUB : SocketType.PUSH))\n+\t\t\t\t)\n+\t\t\t\t\t\t.publishOn(this.publisherScheduler)\n+\t\t\t\t\t\t.doOnNext((socket) ->\n+\t\t\t\t\t\t\t\tsocket.connect(this.connectSendUrl != null\n+\t\t\t\t\t\t\t\t\t\t? this.connectSendUrl\n+\t\t\t\t\t\t\t\t\t\t: localPairConnection.get()))\n+\t\t\t\t\t\t.delayUntil((socket) -> (this.pubSub && this.connectSendUrl != null)\n+\t\t\t\t\t\t\t\t? Mono.just(socket).map(ZMQ.Socket::recv)\n+\t\t\t\t\t\t\t\t: Mono.empty())\n+\t\t\t\t\t\t.cache();\n+\n+\t\tthis.subscribeSocket =\n+\t\t\t\tMono.fromCallable(() ->\n+\t\t\t\t\t\tthis.context.createSocket(\n+\t\t\t\t\t\t\t\tthis.connectSubscribeUrl == null\n+\t\t\t\t\t\t\t\t\t\t? SocketType.PAIR\n+\t\t\t\t\t\t\t\t\t\t: (this.pubSub ? SocketType.SUB : SocketType.PULL)))\n+\t\t\t\t\t\t.publishOn(this.subscriberScheduler)\n+\t\t\t\t\t\t.doOnNext((socket) -> {\n+\t\t\t\t\t\t\tif (this.connectSubscribeUrl != null) {\n+\t\t\t\t\t\t\t\tsocket.connect(this.connectSubscribeUrl);\n+\t\t\t\t\t\t\t\tif (this.pubSub) {\n+\t\t\t\t\t\t\t\t\tsocket.subscribe(ZMQ.SUBSCRIPTION_ALL);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\telse {\n+\t\t\t\t\t\t\t\tsocket.bind(localPairConnection.get());\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t})\n+\t\t\t\t\t\t.cache();\n+\n+\t\tFlux<? extends Message<?>> receiveData =\n+\t\t\t\tthis.subscribeSocket\n+\t\t\t\t\t\t.flatMap((socket) -> {\n+\t\t\t\t\t\t\tif (this.initialized) {\n+\t\t\t\t\t\t\t\tbyte[] data = socket.recv(ZMQ.NOBLOCK);\n+\t\t\t\t\t\t\t\tif (data != null) {\n+\t\t\t\t\t\t\t\t\treturn Mono.just(data);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\treturn Mono.empty();\n+\t\t\t\t\t\t})\n+\t\t\t\t\t\t.publishOn(Schedulers.parallel())\n+\t\t\t\t\t\t.map(this.messageMapper::toMessage)\n+\t\t\t\t\t\t.doOnError((error) -> logger.error(\"Error processing ZeroMQ message\", error))\n+\t\t\t\t\t\t.repeatWhenEmpty((repeat) ->\n+\t\t\t\t\t\t\t\tthis.initialized\n+\t\t\t\t\t\t\t\t\t\t? repeat.delayElements(Duration.ofMillis(100))\n+\t\t\t\t\t\t\t\t\t\t: repeat)\n+\t\t\t\t\t\t.repeat(() -> this.initialized);\n+\n+\t\tif (this.pubSub) {\n+\t\t\treceiveData = receiveData.publish()\n+\t\t\t\t\t.autoConnect(1, (disposable) -> this.subscriberDataDisposable = disposable);\n+\t\t}\n+\n+\t\tthis.subscriberData = receiveData;\n+\n+\t}\n+\n+\tpublic void setConnectUrl(@Nullable String connectUrl) {\n+\t\tif (connectUrl != null) {\n+\t\t\tthis.connectSendUrl = connectUrl.substring(0, connectUrl.lastIndexOf(':'));\n+\t\t\tthis.connectSubscribeUrl =\n+\t\t\t\t\tthis.connectSendUrl.substring(0, this.connectSendUrl.lastIndexOf(':'))\n+\t\t\t\t\t\t\t+ connectUrl.substring(connectUrl.lastIndexOf(':'));\n+\t\t}\n+\t}\n+\n+\tpublic void setMessageMapper(BytesMessageMapper messageMapper) {\n+\t\tAssert.notNull(messageMapper, \"'messageMapper' must not be null\");\n+\t\tthis.messageMapper = messageMapper;\n+\t}\n+\n+\t@Override\n+\tprotected void onInit() {\n+\t\tsuper.onInit();\n+\t\tthis.sendSocket.subscribe();\n+\t\tthis.initialized = true;\n+\t}\n+\n+\t@Override\n+\tprotected boolean doSend(Message<?> message, long timeout) {\n+\t\tAssert.state(this.initialized, \"the channel is not initialized yet or already destroyed\");\n+\n+\t\tbyte[] data = this.messageMapper.fromMessage(message);\n+\t\tAssert.state(data != null, () -> \"The '\" + this.messageMapper + \"' returned null for '\" + message + '\\'');\n+\n+\t\tMono<Boolean> sendMono = this.sendSocket.map((socket) -> socket.send(data));\n+\t\tBoolean sent =\n+\t\t\t\ttimeout > 0\n+\t\t\t\t\t\t? sendMono.block(Duration.ofMillis(timeout))\n+\t\t\t\t\t\t: sendMono.block();\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eec1ff14146553e7e03d2842232d05c770884183"}, "originalPosition": 190}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "eec1ff14146553e7e03d2842232d05c770884183", "author": {"user": {"login": "artembilan", "name": "Artem Bilan"}}, "url": "https://github.com/spring-projects/spring-integration/commit/eec1ff14146553e7e03d2842232d05c770884183", "committedDate": "2020-08-07T16:18:48Z", "message": "* Introduce `ZeroMqProxy` - Spring-friendly component to configure and manage ZeroMq proxy\n* Use this `ZeroMqProxy` logic as an external component for `ZeroMqChannel` testing"}, "afterCommit": {"oid": "e2454e13593e24f37639fcdd5e3bfeda43f24090", "author": {"user": {"login": "artembilan", "name": "Artem Bilan"}}, "url": "https://github.com/spring-projects/spring-integration/commit/e2454e13593e24f37639fcdd5e3bfeda43f24090", "committedDate": "2020-08-07T22:04:59Z", "message": "* Fix Checkstyle\n* Apply docs polishing\n* Expose a capture socket on the proxy\n* Implement `DisposableBean` in the `ZeroMqProxy` to destroy an internal executor service\n* Add JavaDocs to `ZeroMqChannel`\n* Add one more `ZeroMqChannel` to TCP test to be sure that proxy distribution works well"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzODQ4NDgw", "url": "https://github.com/spring-projects/spring-integration/pull/3355#pullrequestreview-463848480", "createdAt": "2020-08-09T06:56:00Z", "commit": {"oid": "e5e3ec53931af67b8c15a833721162f70e276855"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOVQwNjo1NjowMFrOG94uLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOVQwNjo1NjowMFrOG94uLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzU0NTY0NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * on tne {@code \"inproc://\" + beanName + \".control\"} address; it can be obtained via {@link #getControlAddress()}.\n          \n          \n            \n             * on the {@code \"inproc://\" + beanName + \".control\"} address; it can be obtained via {@link #getControlAddress()}.", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r467545645", "createdAt": "2020-08-09T06:56:00Z", "author": {"login": "oli-ver"}, "path": "spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/ZeroMqProxy.java", "diffHunk": "@@ -0,0 +1,341 @@\n+/*\n+ * Copyright 2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.integration.zeromq;\n+\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.Consumer;\n+\n+import org.apache.commons.logging.Log;\n+import org.apache.commons.logging.LogFactory;\n+import org.zeromq.SocketType;\n+import org.zeromq.ZContext;\n+import org.zeromq.ZMQ;\n+\n+import org.springframework.beans.factory.BeanNameAware;\n+import org.springframework.beans.factory.DisposableBean;\n+import org.springframework.beans.factory.InitializingBean;\n+import org.springframework.context.SmartLifecycle;\n+import org.springframework.lang.Nullable;\n+import org.springframework.scheduling.concurrent.CustomizableThreadFactory;\n+import org.springframework.util.Assert;\n+\n+/**\n+ * This class encapsulates the logic to configure and manage a ZeroMQ proxy.\n+ * It binds frontend and backend sockets over TCP on all the available network interfaces\n+ * with either provided or randomly selected ports.\n+ * <p>\n+ * The {@link ZeroMqProxy.Type} dictates which pair of ZeroMQ sockets to bind with this proxy\n+ * to implement any possible patterns for ZeroMQ intermediary. Defaults to @link {@link ZeroMqProxy.Type#PULL_PUSH}.\n+ * <p>\n+ * The control socket is exposed as a {@link SocketType#PAIR} with an inter-thread transport\n+ * on tne {@code \"inproc://\" + beanName + \".control\"} address; it can be obtained via {@link #getControlAddress()}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5e3ec53931af67b8c15a833721162f70e276855"}, "originalPosition": 49}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzODQ4Njk4", "url": "https://github.com/spring-projects/spring-integration/pull/3355#pullrequestreview-463848698", "createdAt": "2020-08-09T07:00:33Z", "commit": {"oid": "e5e3ec53931af67b8c15a833721162f70e276855"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOVQwNzowMDozM1rOG94vow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wOVQwNzowMDozM1rOG94vow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzU0NjAxOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * This way a sending and receiving operations on this channel are similar to interaction over a messaging broker.\n          \n          \n            \n             * This way sending and receiving operations on this channel are similar to interaction over a messaging broker.", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r467546019", "createdAt": "2020-08-09T07:00:33Z", "author": {"login": "oli-ver"}, "path": "spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/channel/ZeroMqChannel.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/*\n+ * Copyright 2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.integration.zeromq.channel;\n+\n+import java.time.Duration;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.function.Supplier;\n+\n+import org.zeromq.SocketType;\n+import org.zeromq.ZContext;\n+import org.zeromq.ZMQ;\n+\n+import org.springframework.integration.channel.AbstractMessageChannel;\n+import org.springframework.integration.mapping.BytesMessageMapper;\n+import org.springframework.integration.support.json.EmbeddedJsonHeadersMessageMapper;\n+import org.springframework.lang.Nullable;\n+import org.springframework.messaging.Message;\n+import org.springframework.messaging.MessageHandler;\n+import org.springframework.messaging.SubscribableChannel;\n+import org.springframework.util.Assert;\n+\n+import reactor.core.Disposable;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+/**\n+ * The {@link SubscribableChannel} implementation over ZeroMQ sockets.\n+ * It can work in two messaging models:\n+ * - {@code push-pull}, where sent messages are distributed to subscribers in a round-robin manner\n+ * according a respective ZeroMQ {@link SocketType#PUSH} and {@link SocketType#PULL} socket types logic;\n+ * - {@code pub-sub}, where sent messages are distributed to all subscribers;\n+ * <p>\n+ * This message channel can work in local mode, when a pair of ZeroMQ sockets of {@link SocketType#PAIR} type\n+ * are connected between publisher (send operation) and subscriber using inter-thread transport binding.\n+ * <p>\n+ * In distributed mode this channel has to be connected to an externally managed ZeroMQ proxy.\n+ * The {@link #setConnectUrl(String)} has to be as a standard ZeroMQ connect string, but with an extra port\n+ * over the colon - representing a frontend and backend sockets pair on ZeroMQ proxy.\n+ * For example: {@code tcp://localhost:6001:6002}.\n+ * This way a sending and receiving operations on this channel are similar to interaction over a messaging broker.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e5e3ec53931af67b8c15a833721162f70e276855"}, "originalPosition": 58}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e5e3ec53931af67b8c15a833721162f70e276855", "author": {"user": {"login": "artembilan", "name": "Artem Bilan"}}, "url": "https://github.com/spring-projects/spring-integration/commit/e5e3ec53931af67b8c15a833721162f70e276855", "committedDate": "2020-08-08T17:33:26Z", "message": "* Add `hamcrest-core` dependency for Awatility"}, "afterCommit": {"oid": "dc37be3c6ec2631e9cce12d7f37cbca621a75c6d", "author": {"user": {"login": "artembilan", "name": "Artem Bilan"}}, "url": "https://github.com/spring-projects/spring-integration/commit/dc37be3c6ec2631e9cce12d7f37cbca621a75c6d", "committedDate": "2020-08-10T15:14:38Z", "message": "* Add more JavaDocs to `ZeroMqProxy` and `ZeroMqChannel`\n* Expose `ZeroMqChannel.setZeroMqProxy()` option for easier\nconfiguration within the same application context\n* Make `ZeroMqChannel` sockets configuration and connection\ndependant on provided `ZeroMqProxy` (if any)\n* Add `Consumer<ZMQ.Socket>` configuration callbacks to the `ZeroMqChannel`\n* Expose `ZeroMqChannel.consumeDelay` option"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "dc37be3c6ec2631e9cce12d7f37cbca621a75c6d", "author": {"user": {"login": "artembilan", "name": "Artem Bilan"}}, "url": "https://github.com/spring-projects/spring-integration/commit/dc37be3c6ec2631e9cce12d7f37cbca621a75c6d", "committedDate": "2020-08-10T15:14:38Z", "message": "* Add more JavaDocs to `ZeroMqProxy` and `ZeroMqChannel`\n* Expose `ZeroMqChannel.setZeroMqProxy()` option for easier\nconfiguration within the same application context\n* Make `ZeroMqChannel` sockets configuration and connection\ndependant on provided `ZeroMqProxy` (if any)\n* Add `Consumer<ZMQ.Socket>` configuration callbacks to the `ZeroMqChannel`\n* Expose `ZeroMqChannel.consumeDelay` option"}, "afterCommit": {"oid": "20e962cbc46ab3a484e8fee845bc2e49cacc6863", "author": {"user": {"login": "artembilan", "name": "Artem Bilan"}}, "url": "https://github.com/spring-projects/spring-integration/commit/20e962cbc46ab3a484e8fee845bc2e49cacc6863", "committedDate": "2020-08-10T20:31:52Z", "message": "* Add more JavaDocs to `ZeroMqProxy` and `ZeroMqChannel`\n* Expose `ZeroMqChannel.setZeroMqProxy()` option for easier\nconfiguration within the same application context\n* Make `ZeroMqChannel` sockets configuration and connection\ndependant on provided `ZeroMqProxy` (if any)\n* Add `Consumer<ZMQ.Socket>` configuration callbacks to the `ZeroMqChannel`\n* Expose `ZeroMqChannel.consumeDelay` option"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1MDc0NzAz", "url": "https://github.com/spring-projects/spring-integration/pull/3355#pullrequestreview-465074703", "createdAt": "2020-08-11T13:40:31Z", "commit": {"oid": "8e0c2d1d3bc5218ab20e42a8cfef5759cfdb4fa5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMzo0MDozMVrOG-4R-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMzo0MDozMVrOG-4R-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU4NzAwMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            An implementation is based on well-supported Java API in https://github.com/zeromq/jeromq[JeroMQ] library.\n          \n          \n            \n            The implementation is based on the well-supported Java API of the https://github.com/zeromq/jeromq[JeroMQ] library.", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r468587002", "createdAt": "2020-08-11T13:40:31Z", "author": {"login": "oli-ver"}, "path": "src/reference/asciidoc/zeromq.adoc", "diffHunk": "@@ -0,0 +1,104 @@\n+[[zeromq]]\n+== ZeroMQ Support\n+\n+Spring Integration provides components to support https://zeromq.org/[ZeroMQ] communication in the application.\n+An implementation is based on well-supported Java API in https://github.com/zeromq/jeromq[JeroMQ] library.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e0c2d1d3bc5218ab20e42a8cfef5759cfdb4fa5"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1MDc1Mzcw", "url": "https://github.com/spring-projects/spring-integration/pull/3355#pullrequestreview-465075370", "createdAt": "2020-08-11T13:41:13Z", "commit": {"oid": "8e0c2d1d3bc5218ab20e42a8cfef5759cfdb4fa5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMzo0MToxM1rOG-4UCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMzo0MToxM1rOG-4UCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU4NzUzMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            All components encapsulates ZeroMQ socket lifecycles and manages threads for them internally making an interaction with these components as lock-free and thread-safe.\n          \n          \n            \n            All components encapsulate ZeroMQ socket lifecycles and manage threads for them internally making an interaction with these components lock-free and thread-safe.", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r468587531", "createdAt": "2020-08-11T13:41:13Z", "author": {"login": "oli-ver"}, "path": "src/reference/asciidoc/zeromq.adoc", "diffHunk": "@@ -0,0 +1,104 @@\n+[[zeromq]]\n+== ZeroMQ Support\n+\n+Spring Integration provides components to support https://zeromq.org/[ZeroMQ] communication in the application.\n+An implementation is based on well-supported Java API in https://github.com/zeromq/jeromq[JeroMQ] library.\n+All components encapsulates ZeroMQ socket lifecycles and manages threads for them internally making an interaction with these components as lock-free and thread-safe.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e0c2d1d3bc5218ab20e42a8cfef5759cfdb4fa5"}, "originalPosition": 6}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1MDc1ODUw", "url": "https://github.com/spring-projects/spring-integration/pull/3355#pullrequestreview-465075850", "createdAt": "2020-08-11T13:41:43Z", "commit": {"oid": "8e0c2d1d3bc5218ab20e42a8cfef5759cfdb4fa5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMzo0MTo0NFrOG-4VfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMzo0MTo0NFrOG-4VfQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU4NzkwMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The `ZeroMqProxy` is Spring-friendly wrapper for the built-in `ZMQ.proxy()` http://zguide.zeromq.org/page:chapter2#toc15[function].\n          \n          \n            \n            The `ZeroMqProxy` is a Spring-friendly wrapper for the built-in `ZMQ.proxy()` http://zguide.zeromq.org/page:chapter2#toc15[function].", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r468587901", "createdAt": "2020-08-11T13:41:44Z", "author": {"login": "oli-ver"}, "path": "src/reference/asciidoc/zeromq.adoc", "diffHunk": "@@ -0,0 +1,104 @@\n+[[zeromq]]\n+== ZeroMQ Support\n+\n+Spring Integration provides components to support https://zeromq.org/[ZeroMQ] communication in the application.\n+An implementation is based on well-supported Java API in https://github.com/zeromq/jeromq[JeroMQ] library.\n+All components encapsulates ZeroMQ socket lifecycles and manages threads for them internally making an interaction with these components as lock-free and thread-safe.\n+\n+You need to include this dependency into your project:\n+\n+====\n+.Maven\n+[source, xml, subs=\"normal\"]\n+----\n+<dependency>\n+    <groupId>org.springframework.integration</groupId>\n+    <artifactId>spring-integration-zeromq</artifactId>\n+    <version>{project-version}</version>\n+</dependency>\n+----\n+\n+.Gradle\n+[source, groovy, subs=\"normal\"]\n+----\n+compile \"org.springframework.integration:spring-integration-zeromq:{project-version}\"\n+----\n+====\n+\n+[[zeromq-proxy]]\n+=== ZeroMQ Proxy\n+\n+The `ZeroMqProxy` is Spring-friendly wrapper for the built-in `ZMQ.proxy()` http://zguide.zeromq.org/page:chapter2#toc15[function].", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e0c2d1d3bc5218ab20e42a8cfef5759cfdb4fa5"}, "originalPosition": 31}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1MDc2ODEz", "url": "https://github.com/spring-projects/spring-integration/pull/3355#pullrequestreview-465076813", "createdAt": "2020-08-11T13:42:46Z", "commit": {"oid": "8e0c2d1d3bc5218ab20e42a8cfef5759cfdb4fa5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMzo0Mjo0NlrOG-4YYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMzo0Mjo0NlrOG-4YYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU4ODY0MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Along side with the standard `ZContext` it requires one of the well-know ZeroMQ proxy mode: SUB/PUB, PULL/PUSH or ROUTER/DEALER.\n          \n          \n            \n            Alongside with the standard `ZContext` it requires one of the well-known ZeroMQ proxy modes: SUB/PUB, PULL/PUSH or ROUTER/DEALER.", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r468588640", "createdAt": "2020-08-11T13:42:46Z", "author": {"login": "oli-ver"}, "path": "src/reference/asciidoc/zeromq.adoc", "diffHunk": "@@ -0,0 +1,104 @@\n+[[zeromq]]\n+== ZeroMQ Support\n+\n+Spring Integration provides components to support https://zeromq.org/[ZeroMQ] communication in the application.\n+An implementation is based on well-supported Java API in https://github.com/zeromq/jeromq[JeroMQ] library.\n+All components encapsulates ZeroMQ socket lifecycles and manages threads for them internally making an interaction with these components as lock-free and thread-safe.\n+\n+You need to include this dependency into your project:\n+\n+====\n+.Maven\n+[source, xml, subs=\"normal\"]\n+----\n+<dependency>\n+    <groupId>org.springframework.integration</groupId>\n+    <artifactId>spring-integration-zeromq</artifactId>\n+    <version>{project-version}</version>\n+</dependency>\n+----\n+\n+.Gradle\n+[source, groovy, subs=\"normal\"]\n+----\n+compile \"org.springframework.integration:spring-integration-zeromq:{project-version}\"\n+----\n+====\n+\n+[[zeromq-proxy]]\n+=== ZeroMQ Proxy\n+\n+The `ZeroMqProxy` is Spring-friendly wrapper for the built-in `ZMQ.proxy()` http://zguide.zeromq.org/page:chapter2#toc15[function].\n+It encapsulates socket lifecycles and thread management.\n+The clients of this proxy still can use a standard ZeroMQ socket connection and interaction API.\n+Along side with the standard `ZContext` it requires one of the well-know ZeroMQ proxy mode: SUB/PUB, PULL/PUSH or ROUTER/DEALER.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e0c2d1d3bc5218ab20e42a8cfef5759cfdb4fa5"}, "originalPosition": 34}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1MDc3MTM5", "url": "https://github.com/spring-projects/spring-integration/pull/3355#pullrequestreview-465077139", "createdAt": "2020-08-11T13:43:06Z", "commit": {"oid": "8e0c2d1d3bc5218ab20e42a8cfef5759cfdb4fa5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMzo0MzowNlrOG-4ZTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMzo0MzowNlrOG-4ZTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU4ODg3Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            This way an appropriate pair of ZeroMQ socket types are used for frontend and backend of the proxy.\n          \n          \n            \n            This way an appropriate pair of ZeroMQ socket types are used for the frontend and backend of the proxy.", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r468588876", "createdAt": "2020-08-11T13:43:06Z", "author": {"login": "oli-ver"}, "path": "src/reference/asciidoc/zeromq.adoc", "diffHunk": "@@ -0,0 +1,104 @@\n+[[zeromq]]\n+== ZeroMQ Support\n+\n+Spring Integration provides components to support https://zeromq.org/[ZeroMQ] communication in the application.\n+An implementation is based on well-supported Java API in https://github.com/zeromq/jeromq[JeroMQ] library.\n+All components encapsulates ZeroMQ socket lifecycles and manages threads for them internally making an interaction with these components as lock-free and thread-safe.\n+\n+You need to include this dependency into your project:\n+\n+====\n+.Maven\n+[source, xml, subs=\"normal\"]\n+----\n+<dependency>\n+    <groupId>org.springframework.integration</groupId>\n+    <artifactId>spring-integration-zeromq</artifactId>\n+    <version>{project-version}</version>\n+</dependency>\n+----\n+\n+.Gradle\n+[source, groovy, subs=\"normal\"]\n+----\n+compile \"org.springframework.integration:spring-integration-zeromq:{project-version}\"\n+----\n+====\n+\n+[[zeromq-proxy]]\n+=== ZeroMQ Proxy\n+\n+The `ZeroMqProxy` is Spring-friendly wrapper for the built-in `ZMQ.proxy()` http://zguide.zeromq.org/page:chapter2#toc15[function].\n+It encapsulates socket lifecycles and thread management.\n+The clients of this proxy still can use a standard ZeroMQ socket connection and interaction API.\n+Along side with the standard `ZContext` it requires one of the well-know ZeroMQ proxy mode: SUB/PUB, PULL/PUSH or ROUTER/DEALER.\n+This way an appropriate pair of ZeroMQ socket types are used for frontend and backend of the proxy.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e0c2d1d3bc5218ab20e42a8cfef5759cfdb4fa5"}, "originalPosition": 35}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1MDg0Mzg4", "url": "https://github.com/spring-projects/spring-integration/pull/3355#pullrequestreview-465084388", "createdAt": "2020-08-11T13:50:42Z", "commit": {"oid": "8e0c2d1d3bc5218ab20e42a8cfef5759cfdb4fa5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMzo1MDo0MlrOG-4vPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMzo1MDo0MlrOG-4vPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU5NDQ5NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The `ZeroMqProxy` implements a `SmartLifecycle` to to create, bind, configure all the sockets and starts `ZMQ.proxy()` in a dedicated thread from an `Executor` (if any).\n          \n          \n            \n            The `ZeroMqProxy` implements a `SmartLifecycle` to create, bind and configure all the sockets and to start `ZMQ.proxy()` in a dedicated thread from an `Executor` (if any).", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r468594494", "createdAt": "2020-08-11T13:50:42Z", "author": {"login": "oli-ver"}, "path": "src/reference/asciidoc/zeromq.adoc", "diffHunk": "@@ -0,0 +1,104 @@\n+[[zeromq]]\n+== ZeroMQ Support\n+\n+Spring Integration provides components to support https://zeromq.org/[ZeroMQ] communication in the application.\n+An implementation is based on well-supported Java API in https://github.com/zeromq/jeromq[JeroMQ] library.\n+All components encapsulates ZeroMQ socket lifecycles and manages threads for them internally making an interaction with these components as lock-free and thread-safe.\n+\n+You need to include this dependency into your project:\n+\n+====\n+.Maven\n+[source, xml, subs=\"normal\"]\n+----\n+<dependency>\n+    <groupId>org.springframework.integration</groupId>\n+    <artifactId>spring-integration-zeromq</artifactId>\n+    <version>{project-version}</version>\n+</dependency>\n+----\n+\n+.Gradle\n+[source, groovy, subs=\"normal\"]\n+----\n+compile \"org.springframework.integration:spring-integration-zeromq:{project-version}\"\n+----\n+====\n+\n+[[zeromq-proxy]]\n+=== ZeroMQ Proxy\n+\n+The `ZeroMqProxy` is Spring-friendly wrapper for the built-in `ZMQ.proxy()` http://zguide.zeromq.org/page:chapter2#toc15[function].\n+It encapsulates socket lifecycles and thread management.\n+The clients of this proxy still can use a standard ZeroMQ socket connection and interaction API.\n+Along side with the standard `ZContext` it requires one of the well-know ZeroMQ proxy mode: SUB/PUB, PULL/PUSH or ROUTER/DEALER.\n+This way an appropriate pair of ZeroMQ socket types are used for frontend and backend of the proxy.\n+See `ZeroMqProxy.Type` for details.\n+\n+The `ZeroMqProxy` implements a `SmartLifecycle` to to create, bind, configure all the sockets and starts `ZMQ.proxy()` in a dedicated thread from an `Executor` (if any).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8e0c2d1d3bc5218ab20e42a8cfef5759cfdb4fa5"}, "originalPosition": 38}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a47b49849fbe2a08247bc916a95d55065090c26a", "author": {"user": {"login": "artembilan", "name": "Artem Bilan"}}, "url": "https://github.com/spring-projects/spring-integration/commit/a47b49849fbe2a08247bc916a95d55065090c26a", "committedDate": "2020-08-11T13:55:31Z", "message": "INT-3045: Add `ZeroMqChannel` support\n\nJIRA: https://jira.spring.io/browse/INT-3045\n\nProvide a `SubscribableChannel` implementation for ZeroMQ\n\nThe general idea is to let to have a distributed channel implementation\nwhere every client can connect to a single server backed by the channel.\n\nThe logic in the channel is fully transparent for end-user and there is just\nenough to send message to it and subscribe for receiving on the other side.\nIf PUB/SUB model is used, all the subscribes (even over the network) going to\nreceive the same published message.\nIn case of PUSH/PULL only one subscriber in the whole cluster is going to get\nthe published message\n\n* Use Reactor for better threading control\n* JeroMQ is not interruptible-friendly: use control sockets to stop proxy loop\n* Name Reactor's schedulers to avoid daemon threads"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c8bf4152f8be63de83f739f7bf7b77e36af81bc6", "author": {"user": {"login": "artembilan", "name": "Artem Bilan"}}, "url": "https://github.com/spring-projects/spring-integration/commit/c8bf4152f8be63de83f739f7bf7b77e36af81bc6", "committedDate": "2020-08-11T13:55:31Z", "message": "* Use try-catch-with-resource to close sockets automatically\n* Fix Checkstyle violations\n* Use `Mono.handle()` to receive data from the socket"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "19c194b0888a8dc1128feb700c3439749902d434", "author": {"user": {"login": "artembilan", "name": "Artem Bilan"}}, "url": "https://github.com/spring-projects/spring-integration/commit/19c194b0888a8dc1128feb700c3439749902d434", "committedDate": "2020-08-11T13:55:31Z", "message": "* Optimize local for just a couple of PAIR sockets\n* Implement TCP binding\n* Add PUB/SUB tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "df58afe07e8e5e2c227c9cef8a6eb24f0c09a527", "author": {"user": {"login": "artembilan", "name": "Artem Bilan"}}, "url": "https://github.com/spring-projects/spring-integration/commit/df58afe07e8e5e2c227c9cef8a6eb24f0c09a527", "committedDate": "2020-08-11T13:55:31Z", "message": "* Fix subscriber scheduler name\n* Optimize socket create logic\n* Add PUSH/PULL over TCP test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7cc4c45a4fb0b004fc71f11b09deb329c84c23da", "author": {"user": {"login": "artembilan", "name": "Artem Bilan"}}, "url": "https://github.com/spring-projects/spring-integration/commit/7cc4c45a4fb0b004fc71f11b09deb329c84c23da", "committedDate": "2020-08-11T13:55:31Z", "message": "* Fix subscriber scheduler name\n* Optimize socket create logic\n* Add PUSH/PULL over TCP test\n* Implement PUB/SUB over TCP"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dc4f8c7fded4b8f4154d385df32dbf4dff201533", "author": {"user": {"login": "artembilan", "name": "Artem Bilan"}}, "url": "https://github.com/spring-projects/spring-integration/commit/dc4f8c7fded4b8f4154d385df32dbf4dff201533", "committedDate": "2020-08-11T13:55:31Z", "message": "* Introduce `ZeroMqProxy` - Spring-friendly component to configure and manage ZeroMq proxy\n* Use this `ZeroMqProxy` logic as an external component for `ZeroMqChannel` testing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1cc2b3fd6ca54edd5f4475383251fbbd61496015", "author": {"user": {"login": "artembilan", "name": "Artem Bilan"}}, "url": "https://github.com/spring-projects/spring-integration/commit/1cc2b3fd6ca54edd5f4475383251fbbd61496015", "committedDate": "2020-08-11T13:55:31Z", "message": "* Fix Checkstyle\n* Apply docs polishing\n* Expose a capture socket on the proxy\n* Implement `DisposableBean` in the `ZeroMqProxy` to destroy an internal executor service\n* Add JavaDocs to `ZeroMqChannel`\n* Add one more `ZeroMqChannel` to TCP test to be sure that proxy distribution works well"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a71f11bebb38e1d6409c2facf28f3bb2a7b321fe", "author": {"user": {"login": "artembilan", "name": "Artem Bilan"}}, "url": "https://github.com/spring-projects/spring-integration/commit/a71f11bebb38e1d6409c2facf28f3bb2a7b321fe", "committedDate": "2020-08-11T13:55:31Z", "message": "* Add `hamcrest-core` dependency for Awatility"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b8c0291d441c6cc09299d5d4d60e3c558f6eddc0", "author": {"user": {"login": "artembilan", "name": "Artem Bilan"}}, "url": "https://github.com/spring-projects/spring-integration/commit/b8c0291d441c6cc09299d5d4d60e3c558f6eddc0", "committedDate": "2020-08-11T13:55:31Z", "message": "* Add more JavaDocs to `ZeroMqProxy` and `ZeroMqChannel`\n* Expose `ZeroMqChannel.setZeroMqProxy()` option for easier\nconfiguration within the same application context\n* Make `ZeroMqChannel` sockets configuration and connection\ndependant on provided `ZeroMqProxy` (if any)\n* Add `Consumer<ZMQ.Socket>` configuration callbacks to the `ZeroMqChannel`\n* Expose `ZeroMqChannel.consumeDelay` option"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "411232586565cb8459e0c03d013311d61467bffa", "author": {"user": {"login": "artembilan", "name": "Artem Bilan"}}, "url": "https://github.com/spring-projects/spring-integration/commit/411232586565cb8459e0c03d013311d61467bffa", "committedDate": "2020-08-11T13:55:31Z", "message": "* Add docs for ZeroMQ\n* Some additions into a `reactive-streams.adoc`\n* Fix typo in the `xmpp.adoc`"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "95499c0e6e82bb9ded1eda37c901599d0dd732c4", "author": {"user": {"login": "artembilan", "name": "Artem Bilan"}}, "url": "https://github.com/spring-projects/spring-integration/commit/95499c0e6e82bb9ded1eda37c901599d0dd732c4", "committedDate": "2020-08-11T13:55:31Z", "message": "* Add `optional` `jackson-databind` since `ZeroMqChannel` uses it by default\n* More words into docs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "642247cbf31fd5010e5fff2082f7786c66912f5d", "author": {"user": {"login": "artembilan", "name": "Artem Bilan"}}, "url": "https://github.com/spring-projects/spring-integration/commit/642247cbf31fd5010e5fff2082f7786c66912f5d", "committedDate": "2020-08-11T14:10:32Z", "message": "* Fix language in docs according review"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8e0c2d1d3bc5218ab20e42a8cfef5759cfdb4fa5", "author": {"user": {"login": "artembilan", "name": "Artem Bilan"}}, "url": "https://github.com/spring-projects/spring-integration/commit/8e0c2d1d3bc5218ab20e42a8cfef5759cfdb4fa5", "committedDate": "2020-08-11T13:05:18Z", "message": "* Add `optional` `jackson-databind` since `ZeroMqChannel` uses it by default\n* More words into docs"}, "afterCommit": {"oid": "642247cbf31fd5010e5fff2082f7786c66912f5d", "author": {"user": {"login": "artembilan", "name": "Artem Bilan"}}, "url": "https://github.com/spring-projects/spring-integration/commit/642247cbf31fd5010e5fff2082f7786c66912f5d", "committedDate": "2020-08-11T14:10:32Z", "message": "* Fix language in docs according review"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1MTg0MjY1", "url": "https://github.com/spring-projects/spring-integration/pull/3355#pullrequestreview-465184265", "createdAt": "2020-08-11T15:31:12Z", "commit": {"oid": "642247cbf31fd5010e5fff2082f7786c66912f5d"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNTozMToxMlrOG-9dDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNTo0Nzo0NVrOG--JxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY3MTc1OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            All components encapsulate ZeroMQ socket lifecycles and manage threads for them internally making an interaction with these components as lock-free and thread-safe.\n          \n          \n            \n            All components encapsulate ZeroMQ socket lifecycles and manage threads for them internally making interactions with these components lock-free and thread-safe.", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r468671759", "createdAt": "2020-08-11T15:31:12Z", "author": {"login": "garyrussell"}, "path": "src/reference/asciidoc/zeromq.adoc", "diffHunk": "@@ -0,0 +1,104 @@\n+[[zeromq]]\n+== ZeroMQ Support\n+\n+Spring Integration provides components to support https://zeromq.org/[ZeroMQ] communication in the application.\n+The implementation is based on the well-supported Java API of the https://github.com/zeromq/jeromq[JeroMQ] library.\n+All components encapsulate ZeroMQ socket lifecycles and manage threads for them internally making an interaction with these components as lock-free and thread-safe.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "642247cbf31fd5010e5fff2082f7786c66912f5d"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY3MzU4NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The `ZeroMqProxy` implements a `SmartLifecycle` to create, bind and configure all the sockets and to start `ZMQ.proxy()` in a dedicated thread from an `Executor` (if any).\n          \n          \n            \n            The binding for frontend and backend sockets is done over `tcp://` protocol onto all the available network interfaces with the provided ports.\n          \n          \n            \n            Otherwise they are bound to random ports which could be obtained later via a respective `getFrontendPort()` and `getBackendPort()` API.\n          \n          \n            \n            The `ZeroMqProxy` implements `SmartLifecycle` to create, bind and configure the sockets and to start `ZMQ.proxy()` in a dedicated thread from an `Executor` (if any).\n          \n          \n            \n            The binding for frontend and backend sockets is done over the `tcp://` protocol onto all of the available network interfaces with the provided ports.\n          \n          \n            \n            Otherwise they are bound to random ports which can be obtained later via the respective `getFrontendPort()` and `getBackendPort()` API methods.", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r468673585", "createdAt": "2020-08-11T15:33:58Z", "author": {"login": "garyrussell"}, "path": "src/reference/asciidoc/zeromq.adoc", "diffHunk": "@@ -0,0 +1,104 @@\n+[[zeromq]]\n+== ZeroMQ Support\n+\n+Spring Integration provides components to support https://zeromq.org/[ZeroMQ] communication in the application.\n+The implementation is based on the well-supported Java API of the https://github.com/zeromq/jeromq[JeroMQ] library.\n+All components encapsulate ZeroMQ socket lifecycles and manage threads for them internally making an interaction with these components as lock-free and thread-safe.\n+\n+You need to include this dependency into your project:\n+\n+====\n+.Maven\n+[source, xml, subs=\"normal\"]\n+----\n+<dependency>\n+    <groupId>org.springframework.integration</groupId>\n+    <artifactId>spring-integration-zeromq</artifactId>\n+    <version>{project-version}</version>\n+</dependency>\n+----\n+\n+.Gradle\n+[source, groovy, subs=\"normal\"]\n+----\n+compile \"org.springframework.integration:spring-integration-zeromq:{project-version}\"\n+----\n+====\n+\n+[[zeromq-proxy]]\n+=== ZeroMQ Proxy\n+\n+The `ZeroMqProxy` is a Spring-friendly wrapper for the built-in `ZMQ.proxy()` https://zguide.zeromq.org/page:chapter2#toc15[function].\n+It encapsulates socket lifecycles and thread management.\n+The clients of this proxy still can use a standard ZeroMQ socket connection and interaction API.\n+Alongside with the standard `ZContext` it requires one of the well-known ZeroMQ proxy modes: SUB/PUB, PULL/PUSH or ROUTER/DEALER.\n+This way an appropriate pair of ZeroMQ socket types are used for the frontend and backend of the proxy.\n+See `ZeroMqProxy.Type` for details.\n+\n+The `ZeroMqProxy` implements a `SmartLifecycle` to create, bind and configure all the sockets and to start `ZMQ.proxy()` in a dedicated thread from an `Executor` (if any).\n+The binding for frontend and backend sockets is done over `tcp://` protocol onto all the available network interfaces with the provided ports.\n+Otherwise they are bound to random ports which could be obtained later via a respective `getFrontendPort()` and `getBackendPort()` API.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "642247cbf31fd5010e5fff2082f7786c66912f5d"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY3NDk5OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Should be used with the same application from another `SocketType.PAIR` socket to send `ZMQ.PROXY_TERMINATE`, `ZMQ.PROXY_PAUSE` and/or `ZMQ.PROXY_RESUME` commands.\n          \n          \n            \n            In fact `ZeroMqProxy` uses performs a `ZMQ.PROXY_TERMINATE` command when `stop()` is called for its lifecycle to terminate `ZMQ.proxy()` loop and close all the bound sockets gracefully.\n          \n          \n            \n            It should be used with the same application from another `SocketType.PAIR` socket to send `ZMQ.PROXY_TERMINATE`, `ZMQ.PROXY_PAUSE` and/or `ZMQ.PROXY_RESUME` commands.\n          \n          \n            \n            The `ZeroMqProxy` performs a `ZMQ.PROXY_TERMINATE` command when `stop()` is called for its lifecycle to terminate the `ZMQ.proxy()` loop and close all the bound sockets gracefully.", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r468674999", "createdAt": "2020-08-11T15:35:57Z", "author": {"login": "garyrussell"}, "path": "src/reference/asciidoc/zeromq.adoc", "diffHunk": "@@ -0,0 +1,104 @@\n+[[zeromq]]\n+== ZeroMQ Support\n+\n+Spring Integration provides components to support https://zeromq.org/[ZeroMQ] communication in the application.\n+The implementation is based on the well-supported Java API of the https://github.com/zeromq/jeromq[JeroMQ] library.\n+All components encapsulate ZeroMQ socket lifecycles and manage threads for them internally making an interaction with these components as lock-free and thread-safe.\n+\n+You need to include this dependency into your project:\n+\n+====\n+.Maven\n+[source, xml, subs=\"normal\"]\n+----\n+<dependency>\n+    <groupId>org.springframework.integration</groupId>\n+    <artifactId>spring-integration-zeromq</artifactId>\n+    <version>{project-version}</version>\n+</dependency>\n+----\n+\n+.Gradle\n+[source, groovy, subs=\"normal\"]\n+----\n+compile \"org.springframework.integration:spring-integration-zeromq:{project-version}\"\n+----\n+====\n+\n+[[zeromq-proxy]]\n+=== ZeroMQ Proxy\n+\n+The `ZeroMqProxy` is a Spring-friendly wrapper for the built-in `ZMQ.proxy()` https://zguide.zeromq.org/page:chapter2#toc15[function].\n+It encapsulates socket lifecycles and thread management.\n+The clients of this proxy still can use a standard ZeroMQ socket connection and interaction API.\n+Alongside with the standard `ZContext` it requires one of the well-known ZeroMQ proxy modes: SUB/PUB, PULL/PUSH or ROUTER/DEALER.\n+This way an appropriate pair of ZeroMQ socket types are used for the frontend and backend of the proxy.\n+See `ZeroMqProxy.Type` for details.\n+\n+The `ZeroMqProxy` implements a `SmartLifecycle` to create, bind and configure all the sockets and to start `ZMQ.proxy()` in a dedicated thread from an `Executor` (if any).\n+The binding for frontend and backend sockets is done over `tcp://` protocol onto all the available network interfaces with the provided ports.\n+Otherwise they are bound to random ports which could be obtained later via a respective `getFrontendPort()` and `getBackendPort()` API.\n+\n+The control socket is exposed as a `SocketType.PAIR` with an inter-thread transport on the `\"inproc://\" + beanName + \".control\"` address; it can be obtained via `getControlAddress()`.\n+Should be used with the same application from another `SocketType.PAIR` socket to send `ZMQ.PROXY_TERMINATE`, `ZMQ.PROXY_PAUSE` and/or `ZMQ.PROXY_RESUME` commands.\n+In fact `ZeroMqProxy` uses performs a `ZMQ.PROXY_TERMINATE` command when `stop()` is called for its lifecycle to terminate `ZMQ.proxy()` loop and close all the bound sockets gracefully.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "642247cbf31fd5010e5fff2082f7786c66912f5d"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY3NjI0NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            A `setExposeCaptureSocket(boolean)` option makes this component to bind additional inter-thread socket with `SocketType.PUB` to capture and publish all the communication between frontend and backend sockets as it states with `ZMQ.proxy()` implementation.\n          \n          \n            \n            This socket is bound into the `\"inproc://\" + beanName + \".capture\"` address and doesn't expect any specific subscription for filtering.\n          \n          \n            \n            The `setExposeCaptureSocket(boolean)` option causes this component to bind an additional inter-thread socket with `SocketType.PUB` to capture and publish all the communication between the frontend and backend sockets as it states with `ZMQ.proxy()` implementation.\n          \n          \n            \n            This socket is bound to the `\"inproc://\" + beanName + \".capture\"` address and doesn't expect any specific subscription for filtering.", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r468676244", "createdAt": "2020-08-11T15:37:33Z", "author": {"login": "garyrussell"}, "path": "src/reference/asciidoc/zeromq.adoc", "diffHunk": "@@ -0,0 +1,104 @@\n+[[zeromq]]\n+== ZeroMQ Support\n+\n+Spring Integration provides components to support https://zeromq.org/[ZeroMQ] communication in the application.\n+The implementation is based on the well-supported Java API of the https://github.com/zeromq/jeromq[JeroMQ] library.\n+All components encapsulate ZeroMQ socket lifecycles and manage threads for them internally making an interaction with these components as lock-free and thread-safe.\n+\n+You need to include this dependency into your project:\n+\n+====\n+.Maven\n+[source, xml, subs=\"normal\"]\n+----\n+<dependency>\n+    <groupId>org.springframework.integration</groupId>\n+    <artifactId>spring-integration-zeromq</artifactId>\n+    <version>{project-version}</version>\n+</dependency>\n+----\n+\n+.Gradle\n+[source, groovy, subs=\"normal\"]\n+----\n+compile \"org.springframework.integration:spring-integration-zeromq:{project-version}\"\n+----\n+====\n+\n+[[zeromq-proxy]]\n+=== ZeroMQ Proxy\n+\n+The `ZeroMqProxy` is a Spring-friendly wrapper for the built-in `ZMQ.proxy()` https://zguide.zeromq.org/page:chapter2#toc15[function].\n+It encapsulates socket lifecycles and thread management.\n+The clients of this proxy still can use a standard ZeroMQ socket connection and interaction API.\n+Alongside with the standard `ZContext` it requires one of the well-known ZeroMQ proxy modes: SUB/PUB, PULL/PUSH or ROUTER/DEALER.\n+This way an appropriate pair of ZeroMQ socket types are used for the frontend and backend of the proxy.\n+See `ZeroMqProxy.Type` for details.\n+\n+The `ZeroMqProxy` implements a `SmartLifecycle` to create, bind and configure all the sockets and to start `ZMQ.proxy()` in a dedicated thread from an `Executor` (if any).\n+The binding for frontend and backend sockets is done over `tcp://` protocol onto all the available network interfaces with the provided ports.\n+Otherwise they are bound to random ports which could be obtained later via a respective `getFrontendPort()` and `getBackendPort()` API.\n+\n+The control socket is exposed as a `SocketType.PAIR` with an inter-thread transport on the `\"inproc://\" + beanName + \".control\"` address; it can be obtained via `getControlAddress()`.\n+Should be used with the same application from another `SocketType.PAIR` socket to send `ZMQ.PROXY_TERMINATE`, `ZMQ.PROXY_PAUSE` and/or `ZMQ.PROXY_RESUME` commands.\n+In fact `ZeroMqProxy` uses performs a `ZMQ.PROXY_TERMINATE` command when `stop()` is called for its lifecycle to terminate `ZMQ.proxy()` loop and close all the bound sockets gracefully.\n+\n+A `setExposeCaptureSocket(boolean)` option makes this component to bind additional inter-thread socket with `SocketType.PUB` to capture and publish all the communication between frontend and backend sockets as it states with `ZMQ.proxy()` implementation.\n+This socket is bound into the `\"inproc://\" + beanName + \".capture\"` address and doesn't expect any specific subscription for filtering.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "642247cbf31fd5010e5fff2082f7786c66912f5d"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY3NzEwNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The frontend and backend sockets can be customized for any additional properties, like read/write timeout or security.\n          \n          \n            \n            This customization is available through `setFrontendSocketConfigurer(Consumer<ZMQ.Socket>)` and `setBackendSocketConfigurer(Consumer<ZMQ.Socket>)` callbacks, respectively.\n          \n          \n            \n            The frontend and backend sockets can be customized with additional properties, such as read/write timeout or security.\n          \n          \n            \n            This customization is available through `setFrontendSocketConfigurer(Consumer<ZMQ.Socket>)` and `setBackendSocketConfigurer(Consumer<ZMQ.Socket>)` callbacks, respectively.", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r468677107", "createdAt": "2020-08-11T15:38:46Z", "author": {"login": "garyrussell"}, "path": "src/reference/asciidoc/zeromq.adoc", "diffHunk": "@@ -0,0 +1,104 @@\n+[[zeromq]]\n+== ZeroMQ Support\n+\n+Spring Integration provides components to support https://zeromq.org/[ZeroMQ] communication in the application.\n+The implementation is based on the well-supported Java API of the https://github.com/zeromq/jeromq[JeroMQ] library.\n+All components encapsulate ZeroMQ socket lifecycles and manage threads for them internally making an interaction with these components as lock-free and thread-safe.\n+\n+You need to include this dependency into your project:\n+\n+====\n+.Maven\n+[source, xml, subs=\"normal\"]\n+----\n+<dependency>\n+    <groupId>org.springframework.integration</groupId>\n+    <artifactId>spring-integration-zeromq</artifactId>\n+    <version>{project-version}</version>\n+</dependency>\n+----\n+\n+.Gradle\n+[source, groovy, subs=\"normal\"]\n+----\n+compile \"org.springframework.integration:spring-integration-zeromq:{project-version}\"\n+----\n+====\n+\n+[[zeromq-proxy]]\n+=== ZeroMQ Proxy\n+\n+The `ZeroMqProxy` is a Spring-friendly wrapper for the built-in `ZMQ.proxy()` https://zguide.zeromq.org/page:chapter2#toc15[function].\n+It encapsulates socket lifecycles and thread management.\n+The clients of this proxy still can use a standard ZeroMQ socket connection and interaction API.\n+Alongside with the standard `ZContext` it requires one of the well-known ZeroMQ proxy modes: SUB/PUB, PULL/PUSH or ROUTER/DEALER.\n+This way an appropriate pair of ZeroMQ socket types are used for the frontend and backend of the proxy.\n+See `ZeroMqProxy.Type` for details.\n+\n+The `ZeroMqProxy` implements a `SmartLifecycle` to create, bind and configure all the sockets and to start `ZMQ.proxy()` in a dedicated thread from an `Executor` (if any).\n+The binding for frontend and backend sockets is done over `tcp://` protocol onto all the available network interfaces with the provided ports.\n+Otherwise they are bound to random ports which could be obtained later via a respective `getFrontendPort()` and `getBackendPort()` API.\n+\n+The control socket is exposed as a `SocketType.PAIR` with an inter-thread transport on the `\"inproc://\" + beanName + \".control\"` address; it can be obtained via `getControlAddress()`.\n+Should be used with the same application from another `SocketType.PAIR` socket to send `ZMQ.PROXY_TERMINATE`, `ZMQ.PROXY_PAUSE` and/or `ZMQ.PROXY_RESUME` commands.\n+In fact `ZeroMqProxy` uses performs a `ZMQ.PROXY_TERMINATE` command when `stop()` is called for its lifecycle to terminate `ZMQ.proxy()` loop and close all the bound sockets gracefully.\n+\n+A `setExposeCaptureSocket(boolean)` option makes this component to bind additional inter-thread socket with `SocketType.PUB` to capture and publish all the communication between frontend and backend sockets as it states with `ZMQ.proxy()` implementation.\n+This socket is bound into the `\"inproc://\" + beanName + \".capture\"` address and doesn't expect any specific subscription for filtering.\n+\n+The frontend and backend sockets can be customized for any additional properties, like read/write timeout or security.\n+This customization is available through `setFrontendSocketConfigurer(Consumer<ZMQ.Socket>)` and `setBackendSocketConfigurer(Consumer<ZMQ.Socket>)` callbacks, respectively.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "642247cbf31fd5010e5fff2082f7786c66912f5d"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY3OTM1MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The `ZeroMqChannel` is a `SubscribableChannel` which uses a pair of ZeroMQ sockets to connect publishers and subscribers for messaging interaction.\n          \n          \n            \n            It can work in a PUB/SUB mode (defaults to PUSH/PULL); could be as local inter-thread channel (uses `PAIR` sockets) - the `connectUrl` is not provided.\n          \n          \n            \n            In the distributed mode it has to be connected to externally managed ZeroMQ proxy, where it can exchange messages with other similar channels connected to the same proxy.\n          \n          \n            \n            The connect url option is a standard ZeroMQ connection string with the protocol and host and a pair of ports over colon for frontend and backend sockets of the ZeroMQ proxy.\n          \n          \n            \n            In fact, for convenience, the channel could be supplied with the `ZeroMqProxy` instance instead of connection string, if it is configured in the same application as proxy.\n          \n          \n            \n            The `ZeroMqChannel` is a `SubscribableChannel` which uses a pair of ZeroMQ sockets to connect publishers and subscribers for messaging interaction.\n          \n          \n            \n            It can work in a PUB/SUB mode (defaults to PUSH/PULL); it can also be used as a local inter-thread channel (uses `PAIR` sockets) - the `connectUrl` is not provided in this case.\n          \n          \n            \n            In distributed mode it has to be connected to an externally managed ZeroMQ proxy, where it can exchange messages with other similar channels connected to the same proxy.\n          \n          \n            \n            The connect url option is a standard ZeroMQ connection string with the protocol and host and a pair of ports over colon for frontend and backend sockets of the ZeroMQ proxy.\n          \n          \n            \n            For convenience, the channel could be supplied with the `ZeroMqProxy` instance instead of connection string, if it is configured in the same application as the proxy.", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r468679350", "createdAt": "2020-08-11T15:42:00Z", "author": {"login": "garyrussell"}, "path": "src/reference/asciidoc/zeromq.adoc", "diffHunk": "@@ -0,0 +1,104 @@\n+[[zeromq]]\n+== ZeroMQ Support\n+\n+Spring Integration provides components to support https://zeromq.org/[ZeroMQ] communication in the application.\n+The implementation is based on the well-supported Java API of the https://github.com/zeromq/jeromq[JeroMQ] library.\n+All components encapsulate ZeroMQ socket lifecycles and manage threads for them internally making an interaction with these components as lock-free and thread-safe.\n+\n+You need to include this dependency into your project:\n+\n+====\n+.Maven\n+[source, xml, subs=\"normal\"]\n+----\n+<dependency>\n+    <groupId>org.springframework.integration</groupId>\n+    <artifactId>spring-integration-zeromq</artifactId>\n+    <version>{project-version}</version>\n+</dependency>\n+----\n+\n+.Gradle\n+[source, groovy, subs=\"normal\"]\n+----\n+compile \"org.springframework.integration:spring-integration-zeromq:{project-version}\"\n+----\n+====\n+\n+[[zeromq-proxy]]\n+=== ZeroMQ Proxy\n+\n+The `ZeroMqProxy` is a Spring-friendly wrapper for the built-in `ZMQ.proxy()` https://zguide.zeromq.org/page:chapter2#toc15[function].\n+It encapsulates socket lifecycles and thread management.\n+The clients of this proxy still can use a standard ZeroMQ socket connection and interaction API.\n+Alongside with the standard `ZContext` it requires one of the well-known ZeroMQ proxy modes: SUB/PUB, PULL/PUSH or ROUTER/DEALER.\n+This way an appropriate pair of ZeroMQ socket types are used for the frontend and backend of the proxy.\n+See `ZeroMqProxy.Type` for details.\n+\n+The `ZeroMqProxy` implements a `SmartLifecycle` to create, bind and configure all the sockets and to start `ZMQ.proxy()` in a dedicated thread from an `Executor` (if any).\n+The binding for frontend and backend sockets is done over `tcp://` protocol onto all the available network interfaces with the provided ports.\n+Otherwise they are bound to random ports which could be obtained later via a respective `getFrontendPort()` and `getBackendPort()` API.\n+\n+The control socket is exposed as a `SocketType.PAIR` with an inter-thread transport on the `\"inproc://\" + beanName + \".control\"` address; it can be obtained via `getControlAddress()`.\n+Should be used with the same application from another `SocketType.PAIR` socket to send `ZMQ.PROXY_TERMINATE`, `ZMQ.PROXY_PAUSE` and/or `ZMQ.PROXY_RESUME` commands.\n+In fact `ZeroMqProxy` uses performs a `ZMQ.PROXY_TERMINATE` command when `stop()` is called for its lifecycle to terminate `ZMQ.proxy()` loop and close all the bound sockets gracefully.\n+\n+A `setExposeCaptureSocket(boolean)` option makes this component to bind additional inter-thread socket with `SocketType.PUB` to capture and publish all the communication between frontend and backend sockets as it states with `ZMQ.proxy()` implementation.\n+This socket is bound into the `\"inproc://\" + beanName + \".capture\"` address and doesn't expect any specific subscription for filtering.\n+\n+The frontend and backend sockets can be customized for any additional properties, like read/write timeout or security.\n+This customization is available through `setFrontendSocketConfigurer(Consumer<ZMQ.Socket>)` and `setBackendSocketConfigurer(Consumer<ZMQ.Socket>)` callbacks, respectively.\n+\n+The `ZeroMqProxy` could be provides as simple bean like this:\n+\n+====\n+[source,java]\n+----\n+@Bean\n+ZeroMqProxy zeroMqProxy() {\n+    ZeroMqProxy proxy = new ZeroMqProxy(CONTEXT, ZeroMqProxy.Type.SUB_PUB);\n+    proxy.setExposeCaptureSocket(true);\n+    proxy.setFrontendPort(6001);\n+    proxy.setBackendPort(6002);\n+    return proxy;\n+}\n+----\n+====\n+\n+All the client nodes should connect to host of this proxy via `tcp://` and use respective port of their interest.\n+\n+[[zeromq-message-channel]]\n+=== ZeroMQ Message Channel\n+\n+The `ZeroMqChannel` is a `SubscribableChannel` which uses a pair of ZeroMQ sockets to connect publishers and subscribers for messaging interaction.\n+It can work in a PUB/SUB mode (defaults to PUSH/PULL); could be as local inter-thread channel (uses `PAIR` sockets) - the `connectUrl` is not provided.\n+In the distributed mode it has to be connected to externally managed ZeroMQ proxy, where it can exchange messages with other similar channels connected to the same proxy.\n+The connect url option is a standard ZeroMQ connection string with the protocol and host and a pair of ports over colon for frontend and backend sockets of the ZeroMQ proxy.\n+In fact, for convenience, the channel could be supplied with the `ZeroMqProxy` instance instead of connection string, if it is configured in the same application as proxy.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "642247cbf31fd5010e5fff2082f7786c66912f5d"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY4MDEzOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            By default the `ZeroMqChannel` uses an `EmbeddedJsonHeadersMessageMapper` to (de)serialize the `Message` (including headers) from/to `byte[]` using Jackson JSON processor.\n          \n          \n            \n            By default the `ZeroMqChannel` uses an `EmbeddedJsonHeadersMessageMapper` to (de)serialize the `Message` (including headers) from/to `byte[]` using a Jackson JSON processor.", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r468680139", "createdAt": "2020-08-11T15:43:10Z", "author": {"login": "garyrussell"}, "path": "src/reference/asciidoc/zeromq.adoc", "diffHunk": "@@ -0,0 +1,104 @@\n+[[zeromq]]\n+== ZeroMQ Support\n+\n+Spring Integration provides components to support https://zeromq.org/[ZeroMQ] communication in the application.\n+The implementation is based on the well-supported Java API of the https://github.com/zeromq/jeromq[JeroMQ] library.\n+All components encapsulate ZeroMQ socket lifecycles and manage threads for them internally making an interaction with these components as lock-free and thread-safe.\n+\n+You need to include this dependency into your project:\n+\n+====\n+.Maven\n+[source, xml, subs=\"normal\"]\n+----\n+<dependency>\n+    <groupId>org.springframework.integration</groupId>\n+    <artifactId>spring-integration-zeromq</artifactId>\n+    <version>{project-version}</version>\n+</dependency>\n+----\n+\n+.Gradle\n+[source, groovy, subs=\"normal\"]\n+----\n+compile \"org.springframework.integration:spring-integration-zeromq:{project-version}\"\n+----\n+====\n+\n+[[zeromq-proxy]]\n+=== ZeroMQ Proxy\n+\n+The `ZeroMqProxy` is a Spring-friendly wrapper for the built-in `ZMQ.proxy()` https://zguide.zeromq.org/page:chapter2#toc15[function].\n+It encapsulates socket lifecycles and thread management.\n+The clients of this proxy still can use a standard ZeroMQ socket connection and interaction API.\n+Alongside with the standard `ZContext` it requires one of the well-known ZeroMQ proxy modes: SUB/PUB, PULL/PUSH or ROUTER/DEALER.\n+This way an appropriate pair of ZeroMQ socket types are used for the frontend and backend of the proxy.\n+See `ZeroMqProxy.Type` for details.\n+\n+The `ZeroMqProxy` implements a `SmartLifecycle` to create, bind and configure all the sockets and to start `ZMQ.proxy()` in a dedicated thread from an `Executor` (if any).\n+The binding for frontend and backend sockets is done over `tcp://` protocol onto all the available network interfaces with the provided ports.\n+Otherwise they are bound to random ports which could be obtained later via a respective `getFrontendPort()` and `getBackendPort()` API.\n+\n+The control socket is exposed as a `SocketType.PAIR` with an inter-thread transport on the `\"inproc://\" + beanName + \".control\"` address; it can be obtained via `getControlAddress()`.\n+Should be used with the same application from another `SocketType.PAIR` socket to send `ZMQ.PROXY_TERMINATE`, `ZMQ.PROXY_PAUSE` and/or `ZMQ.PROXY_RESUME` commands.\n+In fact `ZeroMqProxy` uses performs a `ZMQ.PROXY_TERMINATE` command when `stop()` is called for its lifecycle to terminate `ZMQ.proxy()` loop and close all the bound sockets gracefully.\n+\n+A `setExposeCaptureSocket(boolean)` option makes this component to bind additional inter-thread socket with `SocketType.PUB` to capture and publish all the communication between frontend and backend sockets as it states with `ZMQ.proxy()` implementation.\n+This socket is bound into the `\"inproc://\" + beanName + \".capture\"` address and doesn't expect any specific subscription for filtering.\n+\n+The frontend and backend sockets can be customized for any additional properties, like read/write timeout or security.\n+This customization is available through `setFrontendSocketConfigurer(Consumer<ZMQ.Socket>)` and `setBackendSocketConfigurer(Consumer<ZMQ.Socket>)` callbacks, respectively.\n+\n+The `ZeroMqProxy` could be provides as simple bean like this:\n+\n+====\n+[source,java]\n+----\n+@Bean\n+ZeroMqProxy zeroMqProxy() {\n+    ZeroMqProxy proxy = new ZeroMqProxy(CONTEXT, ZeroMqProxy.Type.SUB_PUB);\n+    proxy.setExposeCaptureSocket(true);\n+    proxy.setFrontendPort(6001);\n+    proxy.setBackendPort(6002);\n+    return proxy;\n+}\n+----\n+====\n+\n+All the client nodes should connect to host of this proxy via `tcp://` and use respective port of their interest.\n+\n+[[zeromq-message-channel]]\n+=== ZeroMQ Message Channel\n+\n+The `ZeroMqChannel` is a `SubscribableChannel` which uses a pair of ZeroMQ sockets to connect publishers and subscribers for messaging interaction.\n+It can work in a PUB/SUB mode (defaults to PUSH/PULL); could be as local inter-thread channel (uses `PAIR` sockets) - the `connectUrl` is not provided.\n+In the distributed mode it has to be connected to externally managed ZeroMQ proxy, where it can exchange messages with other similar channels connected to the same proxy.\n+The connect url option is a standard ZeroMQ connection string with the protocol and host and a pair of ports over colon for frontend and backend sockets of the ZeroMQ proxy.\n+In fact, for convenience, the channel could be supplied with the `ZeroMqProxy` instance instead of connection string, if it is configured in the same application as proxy.\n+\n+Both sending and receiving sockets are managed in their own dedicated threads making this channel concurrency-friendly.\n+This way we can publish and consume to/from a `ZeroMqChannel` from different threads without synchronization.\n+\n+By default the `ZeroMqChannel` uses an `EmbeddedJsonHeadersMessageMapper` to (de)serialize the `Message` (including headers) from/to `byte[]` using Jackson JSON processor.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "642247cbf31fd5010e5fff2082f7786c66912f5d"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY4MDYzNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Sending and receiving sockets can be customized for any options (e.g. read/write timeout, security etc.) via respective `setSendSocketConfigurer(Consumer<ZMQ.Socket>)` and `setSubscribeSocketConfigurer(Consumer<ZMQ.Socket>)` callbacks.\n          \n          \n            \n            Sending and receiving sockets can be customized for any options (read/write timeout, security etc.) via respective `setSendSocketConfigurer(Consumer<ZMQ.Socket>)` and `setSubscribeSocketConfigurer(Consumer<ZMQ.Socket>)` callbacks.", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r468680635", "createdAt": "2020-08-11T15:43:55Z", "author": {"login": "garyrussell"}, "path": "src/reference/asciidoc/zeromq.adoc", "diffHunk": "@@ -0,0 +1,104 @@\n+[[zeromq]]\n+== ZeroMQ Support\n+\n+Spring Integration provides components to support https://zeromq.org/[ZeroMQ] communication in the application.\n+The implementation is based on the well-supported Java API of the https://github.com/zeromq/jeromq[JeroMQ] library.\n+All components encapsulate ZeroMQ socket lifecycles and manage threads for them internally making an interaction with these components as lock-free and thread-safe.\n+\n+You need to include this dependency into your project:\n+\n+====\n+.Maven\n+[source, xml, subs=\"normal\"]\n+----\n+<dependency>\n+    <groupId>org.springframework.integration</groupId>\n+    <artifactId>spring-integration-zeromq</artifactId>\n+    <version>{project-version}</version>\n+</dependency>\n+----\n+\n+.Gradle\n+[source, groovy, subs=\"normal\"]\n+----\n+compile \"org.springframework.integration:spring-integration-zeromq:{project-version}\"\n+----\n+====\n+\n+[[zeromq-proxy]]\n+=== ZeroMQ Proxy\n+\n+The `ZeroMqProxy` is a Spring-friendly wrapper for the built-in `ZMQ.proxy()` https://zguide.zeromq.org/page:chapter2#toc15[function].\n+It encapsulates socket lifecycles and thread management.\n+The clients of this proxy still can use a standard ZeroMQ socket connection and interaction API.\n+Alongside with the standard `ZContext` it requires one of the well-known ZeroMQ proxy modes: SUB/PUB, PULL/PUSH or ROUTER/DEALER.\n+This way an appropriate pair of ZeroMQ socket types are used for the frontend and backend of the proxy.\n+See `ZeroMqProxy.Type` for details.\n+\n+The `ZeroMqProxy` implements a `SmartLifecycle` to create, bind and configure all the sockets and to start `ZMQ.proxy()` in a dedicated thread from an `Executor` (if any).\n+The binding for frontend and backend sockets is done over `tcp://` protocol onto all the available network interfaces with the provided ports.\n+Otherwise they are bound to random ports which could be obtained later via a respective `getFrontendPort()` and `getBackendPort()` API.\n+\n+The control socket is exposed as a `SocketType.PAIR` with an inter-thread transport on the `\"inproc://\" + beanName + \".control\"` address; it can be obtained via `getControlAddress()`.\n+Should be used with the same application from another `SocketType.PAIR` socket to send `ZMQ.PROXY_TERMINATE`, `ZMQ.PROXY_PAUSE` and/or `ZMQ.PROXY_RESUME` commands.\n+In fact `ZeroMqProxy` uses performs a `ZMQ.PROXY_TERMINATE` command when `stop()` is called for its lifecycle to terminate `ZMQ.proxy()` loop and close all the bound sockets gracefully.\n+\n+A `setExposeCaptureSocket(boolean)` option makes this component to bind additional inter-thread socket with `SocketType.PUB` to capture and publish all the communication between frontend and backend sockets as it states with `ZMQ.proxy()` implementation.\n+This socket is bound into the `\"inproc://\" + beanName + \".capture\"` address and doesn't expect any specific subscription for filtering.\n+\n+The frontend and backend sockets can be customized for any additional properties, like read/write timeout or security.\n+This customization is available through `setFrontendSocketConfigurer(Consumer<ZMQ.Socket>)` and `setBackendSocketConfigurer(Consumer<ZMQ.Socket>)` callbacks, respectively.\n+\n+The `ZeroMqProxy` could be provides as simple bean like this:\n+\n+====\n+[source,java]\n+----\n+@Bean\n+ZeroMqProxy zeroMqProxy() {\n+    ZeroMqProxy proxy = new ZeroMqProxy(CONTEXT, ZeroMqProxy.Type.SUB_PUB);\n+    proxy.setExposeCaptureSocket(true);\n+    proxy.setFrontendPort(6001);\n+    proxy.setBackendPort(6002);\n+    return proxy;\n+}\n+----\n+====\n+\n+All the client nodes should connect to host of this proxy via `tcp://` and use respective port of their interest.\n+\n+[[zeromq-message-channel]]\n+=== ZeroMQ Message Channel\n+\n+The `ZeroMqChannel` is a `SubscribableChannel` which uses a pair of ZeroMQ sockets to connect publishers and subscribers for messaging interaction.\n+It can work in a PUB/SUB mode (defaults to PUSH/PULL); could be as local inter-thread channel (uses `PAIR` sockets) - the `connectUrl` is not provided.\n+In the distributed mode it has to be connected to externally managed ZeroMQ proxy, where it can exchange messages with other similar channels connected to the same proxy.\n+The connect url option is a standard ZeroMQ connection string with the protocol and host and a pair of ports over colon for frontend and backend sockets of the ZeroMQ proxy.\n+In fact, for convenience, the channel could be supplied with the `ZeroMqProxy` instance instead of connection string, if it is configured in the same application as proxy.\n+\n+Both sending and receiving sockets are managed in their own dedicated threads making this channel concurrency-friendly.\n+This way we can publish and consume to/from a `ZeroMqChannel` from different threads without synchronization.\n+\n+By default the `ZeroMqChannel` uses an `EmbeddedJsonHeadersMessageMapper` to (de)serialize the `Message` (including headers) from/to `byte[]` using Jackson JSON processor.\n+This logic can be configured via `setMessageMapper(BytesMessageMapper)`.\n+\n+Sending and receiving sockets can be customized for any options (e.g. read/write timeout, security etc.) via respective `setSendSocketConfigurer(Consumer<ZMQ.Socket>)` and `setSubscribeSocketConfigurer(Consumer<ZMQ.Socket>)` callbacks.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "642247cbf31fd5010e5fff2082f7786c66912f5d"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY4MTkwNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            An internal logic of the `ZeroMqChannel` is based on the reactive streams via Project Reactor `Flux` and `Mono` operators.\n          \n          \n            \n            It gives us an easier threading control and allows to have a lock-free concurrent publication and consumption to/from the channel.\n          \n          \n            \n            A local PUB/SUB logic is implemented as a `Flux.publish()` operator to allow all the local subscribers to this channel to have the same published message, as distributed subscribers to the `PUB` socket.\n          \n          \n            \n            The internal logic of the `ZeroMqChannel` is based on the reactive streams via Project Reactor `Flux` and `Mono` operators.\n          \n          \n            \n            This provides easier threading control and allows lock-free concurrent publication and consumption to/from the channel.\n          \n          \n            \n            Local PUB/SUB logic is implemented as a `Flux.publish()` operator to allow all of the local subscribers to this channel to receive the same published message, as distributed subscribers to the `PUB` socket.", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r468681906", "createdAt": "2020-08-11T15:45:44Z", "author": {"login": "garyrussell"}, "path": "src/reference/asciidoc/zeromq.adoc", "diffHunk": "@@ -0,0 +1,104 @@\n+[[zeromq]]\n+== ZeroMQ Support\n+\n+Spring Integration provides components to support https://zeromq.org/[ZeroMQ] communication in the application.\n+The implementation is based on the well-supported Java API of the https://github.com/zeromq/jeromq[JeroMQ] library.\n+All components encapsulate ZeroMQ socket lifecycles and manage threads for them internally making an interaction with these components as lock-free and thread-safe.\n+\n+You need to include this dependency into your project:\n+\n+====\n+.Maven\n+[source, xml, subs=\"normal\"]\n+----\n+<dependency>\n+    <groupId>org.springframework.integration</groupId>\n+    <artifactId>spring-integration-zeromq</artifactId>\n+    <version>{project-version}</version>\n+</dependency>\n+----\n+\n+.Gradle\n+[source, groovy, subs=\"normal\"]\n+----\n+compile \"org.springframework.integration:spring-integration-zeromq:{project-version}\"\n+----\n+====\n+\n+[[zeromq-proxy]]\n+=== ZeroMQ Proxy\n+\n+The `ZeroMqProxy` is a Spring-friendly wrapper for the built-in `ZMQ.proxy()` https://zguide.zeromq.org/page:chapter2#toc15[function].\n+It encapsulates socket lifecycles and thread management.\n+The clients of this proxy still can use a standard ZeroMQ socket connection and interaction API.\n+Alongside with the standard `ZContext` it requires one of the well-known ZeroMQ proxy modes: SUB/PUB, PULL/PUSH or ROUTER/DEALER.\n+This way an appropriate pair of ZeroMQ socket types are used for the frontend and backend of the proxy.\n+See `ZeroMqProxy.Type` for details.\n+\n+The `ZeroMqProxy` implements a `SmartLifecycle` to create, bind and configure all the sockets and to start `ZMQ.proxy()` in a dedicated thread from an `Executor` (if any).\n+The binding for frontend and backend sockets is done over `tcp://` protocol onto all the available network interfaces with the provided ports.\n+Otherwise they are bound to random ports which could be obtained later via a respective `getFrontendPort()` and `getBackendPort()` API.\n+\n+The control socket is exposed as a `SocketType.PAIR` with an inter-thread transport on the `\"inproc://\" + beanName + \".control\"` address; it can be obtained via `getControlAddress()`.\n+Should be used with the same application from another `SocketType.PAIR` socket to send `ZMQ.PROXY_TERMINATE`, `ZMQ.PROXY_PAUSE` and/or `ZMQ.PROXY_RESUME` commands.\n+In fact `ZeroMqProxy` uses performs a `ZMQ.PROXY_TERMINATE` command when `stop()` is called for its lifecycle to terminate `ZMQ.proxy()` loop and close all the bound sockets gracefully.\n+\n+A `setExposeCaptureSocket(boolean)` option makes this component to bind additional inter-thread socket with `SocketType.PUB` to capture and publish all the communication between frontend and backend sockets as it states with `ZMQ.proxy()` implementation.\n+This socket is bound into the `\"inproc://\" + beanName + \".capture\"` address and doesn't expect any specific subscription for filtering.\n+\n+The frontend and backend sockets can be customized for any additional properties, like read/write timeout or security.\n+This customization is available through `setFrontendSocketConfigurer(Consumer<ZMQ.Socket>)` and `setBackendSocketConfigurer(Consumer<ZMQ.Socket>)` callbacks, respectively.\n+\n+The `ZeroMqProxy` could be provides as simple bean like this:\n+\n+====\n+[source,java]\n+----\n+@Bean\n+ZeroMqProxy zeroMqProxy() {\n+    ZeroMqProxy proxy = new ZeroMqProxy(CONTEXT, ZeroMqProxy.Type.SUB_PUB);\n+    proxy.setExposeCaptureSocket(true);\n+    proxy.setFrontendPort(6001);\n+    proxy.setBackendPort(6002);\n+    return proxy;\n+}\n+----\n+====\n+\n+All the client nodes should connect to host of this proxy via `tcp://` and use respective port of their interest.\n+\n+[[zeromq-message-channel]]\n+=== ZeroMQ Message Channel\n+\n+The `ZeroMqChannel` is a `SubscribableChannel` which uses a pair of ZeroMQ sockets to connect publishers and subscribers for messaging interaction.\n+It can work in a PUB/SUB mode (defaults to PUSH/PULL); could be as local inter-thread channel (uses `PAIR` sockets) - the `connectUrl` is not provided.\n+In the distributed mode it has to be connected to externally managed ZeroMQ proxy, where it can exchange messages with other similar channels connected to the same proxy.\n+The connect url option is a standard ZeroMQ connection string with the protocol and host and a pair of ports over colon for frontend and backend sockets of the ZeroMQ proxy.\n+In fact, for convenience, the channel could be supplied with the `ZeroMqProxy` instance instead of connection string, if it is configured in the same application as proxy.\n+\n+Both sending and receiving sockets are managed in their own dedicated threads making this channel concurrency-friendly.\n+This way we can publish and consume to/from a `ZeroMqChannel` from different threads without synchronization.\n+\n+By default the `ZeroMqChannel` uses an `EmbeddedJsonHeadersMessageMapper` to (de)serialize the `Message` (including headers) from/to `byte[]` using Jackson JSON processor.\n+This logic can be configured via `setMessageMapper(BytesMessageMapper)`.\n+\n+Sending and receiving sockets can be customized for any options (e.g. read/write timeout, security etc.) via respective `setSendSocketConfigurer(Consumer<ZMQ.Socket>)` and `setSubscribeSocketConfigurer(Consumer<ZMQ.Socket>)` callbacks.\n+\n+An internal logic of the `ZeroMqChannel` is based on the reactive streams via Project Reactor `Flux` and `Mono` operators.\n+It gives us an easier threading control and allows to have a lock-free concurrent publication and consumption to/from the channel.\n+A local PUB/SUB logic is implemented as a `Flux.publish()` operator to allow all the local subscribers to this channel to have the same published message, as distributed subscribers to the `PUB` socket.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "642247cbf31fd5010e5fff2082f7786c66912f5d"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY4MzIwNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The simple configuration for the `ZeroMqChannel` bean is like this:\n          \n          \n            \n            The following is a simple example of a `ZeroMqChannel` configuration:", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r468683204", "createdAt": "2020-08-11T15:47:45Z", "author": {"login": "garyrussell"}, "path": "src/reference/asciidoc/zeromq.adoc", "diffHunk": "@@ -0,0 +1,104 @@\n+[[zeromq]]\n+== ZeroMQ Support\n+\n+Spring Integration provides components to support https://zeromq.org/[ZeroMQ] communication in the application.\n+The implementation is based on the well-supported Java API of the https://github.com/zeromq/jeromq[JeroMQ] library.\n+All components encapsulate ZeroMQ socket lifecycles and manage threads for them internally making an interaction with these components as lock-free and thread-safe.\n+\n+You need to include this dependency into your project:\n+\n+====\n+.Maven\n+[source, xml, subs=\"normal\"]\n+----\n+<dependency>\n+    <groupId>org.springframework.integration</groupId>\n+    <artifactId>spring-integration-zeromq</artifactId>\n+    <version>{project-version}</version>\n+</dependency>\n+----\n+\n+.Gradle\n+[source, groovy, subs=\"normal\"]\n+----\n+compile \"org.springframework.integration:spring-integration-zeromq:{project-version}\"\n+----\n+====\n+\n+[[zeromq-proxy]]\n+=== ZeroMQ Proxy\n+\n+The `ZeroMqProxy` is a Spring-friendly wrapper for the built-in `ZMQ.proxy()` https://zguide.zeromq.org/page:chapter2#toc15[function].\n+It encapsulates socket lifecycles and thread management.\n+The clients of this proxy still can use a standard ZeroMQ socket connection and interaction API.\n+Alongside with the standard `ZContext` it requires one of the well-known ZeroMQ proxy modes: SUB/PUB, PULL/PUSH or ROUTER/DEALER.\n+This way an appropriate pair of ZeroMQ socket types are used for the frontend and backend of the proxy.\n+See `ZeroMqProxy.Type` for details.\n+\n+The `ZeroMqProxy` implements a `SmartLifecycle` to create, bind and configure all the sockets and to start `ZMQ.proxy()` in a dedicated thread from an `Executor` (if any).\n+The binding for frontend and backend sockets is done over `tcp://` protocol onto all the available network interfaces with the provided ports.\n+Otherwise they are bound to random ports which could be obtained later via a respective `getFrontendPort()` and `getBackendPort()` API.\n+\n+The control socket is exposed as a `SocketType.PAIR` with an inter-thread transport on the `\"inproc://\" + beanName + \".control\"` address; it can be obtained via `getControlAddress()`.\n+Should be used with the same application from another `SocketType.PAIR` socket to send `ZMQ.PROXY_TERMINATE`, `ZMQ.PROXY_PAUSE` and/or `ZMQ.PROXY_RESUME` commands.\n+In fact `ZeroMqProxy` uses performs a `ZMQ.PROXY_TERMINATE` command when `stop()` is called for its lifecycle to terminate `ZMQ.proxy()` loop and close all the bound sockets gracefully.\n+\n+A `setExposeCaptureSocket(boolean)` option makes this component to bind additional inter-thread socket with `SocketType.PUB` to capture and publish all the communication between frontend and backend sockets as it states with `ZMQ.proxy()` implementation.\n+This socket is bound into the `\"inproc://\" + beanName + \".capture\"` address and doesn't expect any specific subscription for filtering.\n+\n+The frontend and backend sockets can be customized for any additional properties, like read/write timeout or security.\n+This customization is available through `setFrontendSocketConfigurer(Consumer<ZMQ.Socket>)` and `setBackendSocketConfigurer(Consumer<ZMQ.Socket>)` callbacks, respectively.\n+\n+The `ZeroMqProxy` could be provides as simple bean like this:\n+\n+====\n+[source,java]\n+----\n+@Bean\n+ZeroMqProxy zeroMqProxy() {\n+    ZeroMqProxy proxy = new ZeroMqProxy(CONTEXT, ZeroMqProxy.Type.SUB_PUB);\n+    proxy.setExposeCaptureSocket(true);\n+    proxy.setFrontendPort(6001);\n+    proxy.setBackendPort(6002);\n+    return proxy;\n+}\n+----\n+====\n+\n+All the client nodes should connect to host of this proxy via `tcp://` and use respective port of their interest.\n+\n+[[zeromq-message-channel]]\n+=== ZeroMQ Message Channel\n+\n+The `ZeroMqChannel` is a `SubscribableChannel` which uses a pair of ZeroMQ sockets to connect publishers and subscribers for messaging interaction.\n+It can work in a PUB/SUB mode (defaults to PUSH/PULL); could be as local inter-thread channel (uses `PAIR` sockets) - the `connectUrl` is not provided.\n+In the distributed mode it has to be connected to externally managed ZeroMQ proxy, where it can exchange messages with other similar channels connected to the same proxy.\n+The connect url option is a standard ZeroMQ connection string with the protocol and host and a pair of ports over colon for frontend and backend sockets of the ZeroMQ proxy.\n+In fact, for convenience, the channel could be supplied with the `ZeroMqProxy` instance instead of connection string, if it is configured in the same application as proxy.\n+\n+Both sending and receiving sockets are managed in their own dedicated threads making this channel concurrency-friendly.\n+This way we can publish and consume to/from a `ZeroMqChannel` from different threads without synchronization.\n+\n+By default the `ZeroMqChannel` uses an `EmbeddedJsonHeadersMessageMapper` to (de)serialize the `Message` (including headers) from/to `byte[]` using Jackson JSON processor.\n+This logic can be configured via `setMessageMapper(BytesMessageMapper)`.\n+\n+Sending and receiving sockets can be customized for any options (e.g. read/write timeout, security etc.) via respective `setSendSocketConfigurer(Consumer<ZMQ.Socket>)` and `setSubscribeSocketConfigurer(Consumer<ZMQ.Socket>)` callbacks.\n+\n+An internal logic of the `ZeroMqChannel` is based on the reactive streams via Project Reactor `Flux` and `Mono` operators.\n+It gives us an easier threading control and allows to have a lock-free concurrent publication and consumption to/from the channel.\n+A local PUB/SUB logic is implemented as a `Flux.publish()` operator to allow all the local subscribers to this channel to have the same published message, as distributed subscribers to the `PUB` socket.\n+\n+The simple configuration for the `ZeroMqChannel` bean is like this:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "642247cbf31fd5010e5fff2082f7786c66912f5d"}, "originalPosition": 91}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9e5e23ca35f8b8feb4d0138298c2ed2c0be9c1c5", "author": {"user": {"login": "artembilan", "name": "Artem Bilan"}}, "url": "https://github.com/spring-projects/spring-integration/commit/9e5e23ca35f8b8feb4d0138298c2ed2c0be9c1c5", "committedDate": "2020-08-11T16:04:32Z", "message": "Fix language in docs according review\n\nCo-authored-by: Gary Russell <grussell@vmware.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1MTIxMzcw", "url": "https://github.com/spring-projects/spring-integration/pull/3355#pullrequestreview-465121370", "createdAt": "2020-08-11T14:25:49Z", "commit": {"oid": "8e0c2d1d3bc5218ab20e42a8cfef5759cfdb4fa5"}, "state": "APPROVED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNDoyNjozM1rOG-6iMg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNjowMTo1NlrOG--u4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODYyMzkyMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            In fact `ZeroMqProxy` uses performs a `ZMQ.PROXY_TERMINATE` command when `stop()` is called for its lifecycle to terminate `ZMQ.proxy()` loop and close all the bound sockets gracefully.\n          \n          \n            \n            In fact `ZeroMqProxy` performs a `ZMQ.PROXY_TERMINATE` command when `stop()` is called for its lifecycle to terminate `ZMQ.proxy()` loop and close all the bound sockets gracefully.", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r468623922", "createdAt": "2020-08-11T14:26:33Z", "author": {"login": "oli-ver"}, "path": "src/reference/asciidoc/zeromq.adoc", "diffHunk": "@@ -0,0 +1,104 @@\n+[[zeromq]]\n+== ZeroMQ Support\n+\n+Spring Integration provides components to support https://zeromq.org/[ZeroMQ] communication in the application.\n+The implementation is based on the well-supported Java API of the https://github.com/zeromq/jeromq[JeroMQ] library.\n+All components encapsulate ZeroMQ socket lifecycles and manage threads for them internally making an interaction with these components as lock-free and thread-safe.\n+\n+You need to include this dependency into your project:\n+\n+====\n+.Maven\n+[source, xml, subs=\"normal\"]\n+----\n+<dependency>\n+    <groupId>org.springframework.integration</groupId>\n+    <artifactId>spring-integration-zeromq</artifactId>\n+    <version>{project-version}</version>\n+</dependency>\n+----\n+\n+.Gradle\n+[source, groovy, subs=\"normal\"]\n+----\n+compile \"org.springframework.integration:spring-integration-zeromq:{project-version}\"\n+----\n+====\n+\n+[[zeromq-proxy]]\n+=== ZeroMQ Proxy\n+\n+The `ZeroMqProxy` is a Spring-friendly wrapper for the built-in `ZMQ.proxy()` https://zguide.zeromq.org/page:chapter2#toc15[function].\n+It encapsulates socket lifecycles and thread management.\n+The clients of this proxy still can use a standard ZeroMQ socket connection and interaction API.\n+Alongside with the standard `ZContext` it requires one of the well-known ZeroMQ proxy modes: SUB/PUB, PULL/PUSH or ROUTER/DEALER.\n+This way an appropriate pair of ZeroMQ socket types are used for the frontend and backend of the proxy.\n+See `ZeroMqProxy.Type` for details.\n+\n+The `ZeroMqProxy` implements a `SmartLifecycle` to create, bind and configure all the sockets and to start `ZMQ.proxy()` in a dedicated thread from an `Executor` (if any).\n+The binding for frontend and backend sockets is done over `tcp://` protocol onto all the available network interfaces with the provided ports.\n+Otherwise they are bound to random ports which could be obtained later via a respective `getFrontendPort()` and `getBackendPort()` API.\n+\n+The control socket is exposed as a `SocketType.PAIR` with an inter-thread transport on the `\"inproc://\" + beanName + \".control\"` address; it can be obtained via `getControlAddress()`.\n+Should be used with the same application from another `SocketType.PAIR` socket to send `ZMQ.PROXY_TERMINATE`, `ZMQ.PROXY_PAUSE` and/or `ZMQ.PROXY_RESUME` commands.\n+In fact `ZeroMqProxy` uses performs a `ZMQ.PROXY_TERMINATE` command when `stop()` is called for its lifecycle to terminate `ZMQ.proxy()` loop and close all the bound sockets gracefully.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "642247cbf31fd5010e5fff2082f7786c66912f5d"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODYyOTA3Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The `ZeroMqProxy` could be provides as simple bean like this:\n          \n          \n            \n            The `ZeroMqProxy` could be provided as simple bean like this:", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r468629073", "createdAt": "2020-08-11T14:33:46Z", "author": {"login": "oli-ver"}, "path": "src/reference/asciidoc/zeromq.adoc", "diffHunk": "@@ -0,0 +1,104 @@\n+[[zeromq]]\n+== ZeroMQ Support\n+\n+Spring Integration provides components to support https://zeromq.org/[ZeroMQ] communication in the application.\n+The implementation is based on the well-supported Java API of the https://github.com/zeromq/jeromq[JeroMQ] library.\n+All components encapsulate ZeroMQ socket lifecycles and manage threads for them internally making an interaction with these components as lock-free and thread-safe.\n+\n+You need to include this dependency into your project:\n+\n+====\n+.Maven\n+[source, xml, subs=\"normal\"]\n+----\n+<dependency>\n+    <groupId>org.springframework.integration</groupId>\n+    <artifactId>spring-integration-zeromq</artifactId>\n+    <version>{project-version}</version>\n+</dependency>\n+----\n+\n+.Gradle\n+[source, groovy, subs=\"normal\"]\n+----\n+compile \"org.springframework.integration:spring-integration-zeromq:{project-version}\"\n+----\n+====\n+\n+[[zeromq-proxy]]\n+=== ZeroMQ Proxy\n+\n+The `ZeroMqProxy` is a Spring-friendly wrapper for the built-in `ZMQ.proxy()` https://zguide.zeromq.org/page:chapter2#toc15[function].\n+It encapsulates socket lifecycles and thread management.\n+The clients of this proxy still can use a standard ZeroMQ socket connection and interaction API.\n+Alongside with the standard `ZContext` it requires one of the well-known ZeroMQ proxy modes: SUB/PUB, PULL/PUSH or ROUTER/DEALER.\n+This way an appropriate pair of ZeroMQ socket types are used for the frontend and backend of the proxy.\n+See `ZeroMqProxy.Type` for details.\n+\n+The `ZeroMqProxy` implements a `SmartLifecycle` to create, bind and configure all the sockets and to start `ZMQ.proxy()` in a dedicated thread from an `Executor` (if any).\n+The binding for frontend and backend sockets is done over `tcp://` protocol onto all the available network interfaces with the provided ports.\n+Otherwise they are bound to random ports which could be obtained later via a respective `getFrontendPort()` and `getBackendPort()` API.\n+\n+The control socket is exposed as a `SocketType.PAIR` with an inter-thread transport on the `\"inproc://\" + beanName + \".control\"` address; it can be obtained via `getControlAddress()`.\n+Should be used with the same application from another `SocketType.PAIR` socket to send `ZMQ.PROXY_TERMINATE`, `ZMQ.PROXY_PAUSE` and/or `ZMQ.PROXY_RESUME` commands.\n+In fact `ZeroMqProxy` uses performs a `ZMQ.PROXY_TERMINATE` command when `stop()` is called for its lifecycle to terminate `ZMQ.proxy()` loop and close all the bound sockets gracefully.\n+\n+A `setExposeCaptureSocket(boolean)` option makes this component to bind additional inter-thread socket with `SocketType.PUB` to capture and publish all the communication between frontend and backend sockets as it states with `ZMQ.proxy()` implementation.\n+This socket is bound into the `\"inproc://\" + beanName + \".capture\"` address and doesn't expect any specific subscription for filtering.\n+\n+The frontend and backend sockets can be customized for any additional properties, like read/write timeout or security.\n+This customization is available through `setFrontendSocketConfigurer(Consumer<ZMQ.Socket>)` and `setBackendSocketConfigurer(Consumer<ZMQ.Socket>)` callbacks, respectively.\n+\n+The `ZeroMqProxy` could be provides as simple bean like this:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "642247cbf31fd5010e5fff2082f7786c66912f5d"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY0OTQ4Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            All the client nodes should connect to host of this proxy via `tcp://` and use respective port of their interest.\n          \n          \n            \n            All the client nodes should connect to the host of this proxy via `tcp://` and use the respective port of their interest.", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r468649482", "createdAt": "2020-08-11T15:00:56Z", "author": {"login": "oli-ver"}, "path": "src/reference/asciidoc/zeromq.adoc", "diffHunk": "@@ -0,0 +1,104 @@\n+[[zeromq]]\n+== ZeroMQ Support\n+\n+Spring Integration provides components to support https://zeromq.org/[ZeroMQ] communication in the application.\n+The implementation is based on the well-supported Java API of the https://github.com/zeromq/jeromq[JeroMQ] library.\n+All components encapsulate ZeroMQ socket lifecycles and manage threads for them internally making an interaction with these components as lock-free and thread-safe.\n+\n+You need to include this dependency into your project:\n+\n+====\n+.Maven\n+[source, xml, subs=\"normal\"]\n+----\n+<dependency>\n+    <groupId>org.springframework.integration</groupId>\n+    <artifactId>spring-integration-zeromq</artifactId>\n+    <version>{project-version}</version>\n+</dependency>\n+----\n+\n+.Gradle\n+[source, groovy, subs=\"normal\"]\n+----\n+compile \"org.springframework.integration:spring-integration-zeromq:{project-version}\"\n+----\n+====\n+\n+[[zeromq-proxy]]\n+=== ZeroMQ Proxy\n+\n+The `ZeroMqProxy` is a Spring-friendly wrapper for the built-in `ZMQ.proxy()` https://zguide.zeromq.org/page:chapter2#toc15[function].\n+It encapsulates socket lifecycles and thread management.\n+The clients of this proxy still can use a standard ZeroMQ socket connection and interaction API.\n+Alongside with the standard `ZContext` it requires one of the well-known ZeroMQ proxy modes: SUB/PUB, PULL/PUSH or ROUTER/DEALER.\n+This way an appropriate pair of ZeroMQ socket types are used for the frontend and backend of the proxy.\n+See `ZeroMqProxy.Type` for details.\n+\n+The `ZeroMqProxy` implements a `SmartLifecycle` to create, bind and configure all the sockets and to start `ZMQ.proxy()` in a dedicated thread from an `Executor` (if any).\n+The binding for frontend and backend sockets is done over `tcp://` protocol onto all the available network interfaces with the provided ports.\n+Otherwise they are bound to random ports which could be obtained later via a respective `getFrontendPort()` and `getBackendPort()` API.\n+\n+The control socket is exposed as a `SocketType.PAIR` with an inter-thread transport on the `\"inproc://\" + beanName + \".control\"` address; it can be obtained via `getControlAddress()`.\n+Should be used with the same application from another `SocketType.PAIR` socket to send `ZMQ.PROXY_TERMINATE`, `ZMQ.PROXY_PAUSE` and/or `ZMQ.PROXY_RESUME` commands.\n+In fact `ZeroMqProxy` uses performs a `ZMQ.PROXY_TERMINATE` command when `stop()` is called for its lifecycle to terminate `ZMQ.proxy()` loop and close all the bound sockets gracefully.\n+\n+A `setExposeCaptureSocket(boolean)` option makes this component to bind additional inter-thread socket with `SocketType.PUB` to capture and publish all the communication between frontend and backend sockets as it states with `ZMQ.proxy()` implementation.\n+This socket is bound into the `\"inproc://\" + beanName + \".capture\"` address and doesn't expect any specific subscription for filtering.\n+\n+The frontend and backend sockets can be customized for any additional properties, like read/write timeout or security.\n+This customization is available through `setFrontendSocketConfigurer(Consumer<ZMQ.Socket>)` and `setBackendSocketConfigurer(Consumer<ZMQ.Socket>)` callbacks, respectively.\n+\n+The `ZeroMqProxy` could be provides as simple bean like this:\n+\n+====\n+[source,java]\n+----\n+@Bean\n+ZeroMqProxy zeroMqProxy() {\n+    ZeroMqProxy proxy = new ZeroMqProxy(CONTEXT, ZeroMqProxy.Type.SUB_PUB);\n+    proxy.setExposeCaptureSocket(true);\n+    proxy.setFrontendPort(6001);\n+    proxy.setBackendPort(6002);\n+    return proxy;\n+}\n+----\n+====\n+\n+All the client nodes should connect to host of this proxy via `tcp://` and use respective port of their interest.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "642247cbf31fd5010e5fff2082f7786c66912f5d"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY1MDMxMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            In the distributed mode it has to be connected to externally managed ZeroMQ proxy, where it can exchange messages with other similar channels connected to the same proxy.\n          \n          \n            \n            In the distributed mode it has to be connected to an externally managed ZeroMQ proxy, where it can exchange messages with other similar channels connected to the same proxy.", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r468650313", "createdAt": "2020-08-11T15:02:01Z", "author": {"login": "oli-ver"}, "path": "src/reference/asciidoc/zeromq.adoc", "diffHunk": "@@ -0,0 +1,104 @@\n+[[zeromq]]\n+== ZeroMQ Support\n+\n+Spring Integration provides components to support https://zeromq.org/[ZeroMQ] communication in the application.\n+The implementation is based on the well-supported Java API of the https://github.com/zeromq/jeromq[JeroMQ] library.\n+All components encapsulate ZeroMQ socket lifecycles and manage threads for them internally making an interaction with these components as lock-free and thread-safe.\n+\n+You need to include this dependency into your project:\n+\n+====\n+.Maven\n+[source, xml, subs=\"normal\"]\n+----\n+<dependency>\n+    <groupId>org.springframework.integration</groupId>\n+    <artifactId>spring-integration-zeromq</artifactId>\n+    <version>{project-version}</version>\n+</dependency>\n+----\n+\n+.Gradle\n+[source, groovy, subs=\"normal\"]\n+----\n+compile \"org.springframework.integration:spring-integration-zeromq:{project-version}\"\n+----\n+====\n+\n+[[zeromq-proxy]]\n+=== ZeroMQ Proxy\n+\n+The `ZeroMqProxy` is a Spring-friendly wrapper for the built-in `ZMQ.proxy()` https://zguide.zeromq.org/page:chapter2#toc15[function].\n+It encapsulates socket lifecycles and thread management.\n+The clients of this proxy still can use a standard ZeroMQ socket connection and interaction API.\n+Alongside with the standard `ZContext` it requires one of the well-known ZeroMQ proxy modes: SUB/PUB, PULL/PUSH or ROUTER/DEALER.\n+This way an appropriate pair of ZeroMQ socket types are used for the frontend and backend of the proxy.\n+See `ZeroMqProxy.Type` for details.\n+\n+The `ZeroMqProxy` implements a `SmartLifecycle` to create, bind and configure all the sockets and to start `ZMQ.proxy()` in a dedicated thread from an `Executor` (if any).\n+The binding for frontend and backend sockets is done over `tcp://` protocol onto all the available network interfaces with the provided ports.\n+Otherwise they are bound to random ports which could be obtained later via a respective `getFrontendPort()` and `getBackendPort()` API.\n+\n+The control socket is exposed as a `SocketType.PAIR` with an inter-thread transport on the `\"inproc://\" + beanName + \".control\"` address; it can be obtained via `getControlAddress()`.\n+Should be used with the same application from another `SocketType.PAIR` socket to send `ZMQ.PROXY_TERMINATE`, `ZMQ.PROXY_PAUSE` and/or `ZMQ.PROXY_RESUME` commands.\n+In fact `ZeroMqProxy` uses performs a `ZMQ.PROXY_TERMINATE` command when `stop()` is called for its lifecycle to terminate `ZMQ.proxy()` loop and close all the bound sockets gracefully.\n+\n+A `setExposeCaptureSocket(boolean)` option makes this component to bind additional inter-thread socket with `SocketType.PUB` to capture and publish all the communication between frontend and backend sockets as it states with `ZMQ.proxy()` implementation.\n+This socket is bound into the `\"inproc://\" + beanName + \".capture\"` address and doesn't expect any specific subscription for filtering.\n+\n+The frontend and backend sockets can be customized for any additional properties, like read/write timeout or security.\n+This customization is available through `setFrontendSocketConfigurer(Consumer<ZMQ.Socket>)` and `setBackendSocketConfigurer(Consumer<ZMQ.Socket>)` callbacks, respectively.\n+\n+The `ZeroMqProxy` could be provides as simple bean like this:\n+\n+====\n+[source,java]\n+----\n+@Bean\n+ZeroMqProxy zeroMqProxy() {\n+    ZeroMqProxy proxy = new ZeroMqProxy(CONTEXT, ZeroMqProxy.Type.SUB_PUB);\n+    proxy.setExposeCaptureSocket(true);\n+    proxy.setFrontendPort(6001);\n+    proxy.setBackendPort(6002);\n+    return proxy;\n+}\n+----\n+====\n+\n+All the client nodes should connect to host of this proxy via `tcp://` and use respective port of their interest.\n+\n+[[zeromq-message-channel]]\n+=== ZeroMQ Message Channel\n+\n+The `ZeroMqChannel` is a `SubscribableChannel` which uses a pair of ZeroMQ sockets to connect publishers and subscribers for messaging interaction.\n+It can work in a PUB/SUB mode (defaults to PUSH/PULL); could be as local inter-thread channel (uses `PAIR` sockets) - the `connectUrl` is not provided.\n+In the distributed mode it has to be connected to externally managed ZeroMQ proxy, where it can exchange messages with other similar channels connected to the same proxy.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "642247cbf31fd5010e5fff2082f7786c66912f5d"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY1MTIyOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            In fact, for convenience, the channel could be supplied with the `ZeroMqProxy` instance instead of connection string, if it is configured in the same application as proxy.\n          \n          \n            \n            In fact, for convenience, the channel could be supplied with the `ZeroMqProxy` instance instead of a connection string, if it is configured in the same application as proxy.\n          \n      \n    \n    \n  \n\nThanks :)", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r468651228", "createdAt": "2020-08-11T15:03:13Z", "author": {"login": "oli-ver"}, "path": "src/reference/asciidoc/zeromq.adoc", "diffHunk": "@@ -0,0 +1,104 @@\n+[[zeromq]]\n+== ZeroMQ Support\n+\n+Spring Integration provides components to support https://zeromq.org/[ZeroMQ] communication in the application.\n+The implementation is based on the well-supported Java API of the https://github.com/zeromq/jeromq[JeroMQ] library.\n+All components encapsulate ZeroMQ socket lifecycles and manage threads for them internally making an interaction with these components as lock-free and thread-safe.\n+\n+You need to include this dependency into your project:\n+\n+====\n+.Maven\n+[source, xml, subs=\"normal\"]\n+----\n+<dependency>\n+    <groupId>org.springframework.integration</groupId>\n+    <artifactId>spring-integration-zeromq</artifactId>\n+    <version>{project-version}</version>\n+</dependency>\n+----\n+\n+.Gradle\n+[source, groovy, subs=\"normal\"]\n+----\n+compile \"org.springframework.integration:spring-integration-zeromq:{project-version}\"\n+----\n+====\n+\n+[[zeromq-proxy]]\n+=== ZeroMQ Proxy\n+\n+The `ZeroMqProxy` is a Spring-friendly wrapper for the built-in `ZMQ.proxy()` https://zguide.zeromq.org/page:chapter2#toc15[function].\n+It encapsulates socket lifecycles and thread management.\n+The clients of this proxy still can use a standard ZeroMQ socket connection and interaction API.\n+Alongside with the standard `ZContext` it requires one of the well-known ZeroMQ proxy modes: SUB/PUB, PULL/PUSH or ROUTER/DEALER.\n+This way an appropriate pair of ZeroMQ socket types are used for the frontend and backend of the proxy.\n+See `ZeroMqProxy.Type` for details.\n+\n+The `ZeroMqProxy` implements a `SmartLifecycle` to create, bind and configure all the sockets and to start `ZMQ.proxy()` in a dedicated thread from an `Executor` (if any).\n+The binding for frontend and backend sockets is done over `tcp://` protocol onto all the available network interfaces with the provided ports.\n+Otherwise they are bound to random ports which could be obtained later via a respective `getFrontendPort()` and `getBackendPort()` API.\n+\n+The control socket is exposed as a `SocketType.PAIR` with an inter-thread transport on the `\"inproc://\" + beanName + \".control\"` address; it can be obtained via `getControlAddress()`.\n+Should be used with the same application from another `SocketType.PAIR` socket to send `ZMQ.PROXY_TERMINATE`, `ZMQ.PROXY_PAUSE` and/or `ZMQ.PROXY_RESUME` commands.\n+In fact `ZeroMqProxy` uses performs a `ZMQ.PROXY_TERMINATE` command when `stop()` is called for its lifecycle to terminate `ZMQ.proxy()` loop and close all the bound sockets gracefully.\n+\n+A `setExposeCaptureSocket(boolean)` option makes this component to bind additional inter-thread socket with `SocketType.PUB` to capture and publish all the communication between frontend and backend sockets as it states with `ZMQ.proxy()` implementation.\n+This socket is bound into the `\"inproc://\" + beanName + \".capture\"` address and doesn't expect any specific subscription for filtering.\n+\n+The frontend and backend sockets can be customized for any additional properties, like read/write timeout or security.\n+This customization is available through `setFrontendSocketConfigurer(Consumer<ZMQ.Socket>)` and `setBackendSocketConfigurer(Consumer<ZMQ.Socket>)` callbacks, respectively.\n+\n+The `ZeroMqProxy` could be provides as simple bean like this:\n+\n+====\n+[source,java]\n+----\n+@Bean\n+ZeroMqProxy zeroMqProxy() {\n+    ZeroMqProxy proxy = new ZeroMqProxy(CONTEXT, ZeroMqProxy.Type.SUB_PUB);\n+    proxy.setExposeCaptureSocket(true);\n+    proxy.setFrontendPort(6001);\n+    proxy.setBackendPort(6002);\n+    return proxy;\n+}\n+----\n+====\n+\n+All the client nodes should connect to host of this proxy via `tcp://` and use respective port of their interest.\n+\n+[[zeromq-message-channel]]\n+=== ZeroMQ Message Channel\n+\n+The `ZeroMqChannel` is a `SubscribableChannel` which uses a pair of ZeroMQ sockets to connect publishers and subscribers for messaging interaction.\n+It can work in a PUB/SUB mode (defaults to PUSH/PULL); could be as local inter-thread channel (uses `PAIR` sockets) - the `connectUrl` is not provided.\n+In the distributed mode it has to be connected to externally managed ZeroMQ proxy, where it can exchange messages with other similar channels connected to the same proxy.\n+The connect url option is a standard ZeroMQ connection string with the protocol and host and a pair of ports over colon for frontend and backend sockets of the ZeroMQ proxy.\n+In fact, for convenience, the channel could be supplied with the `ZeroMqProxy` instance instead of connection string, if it is configured in the same application as proxy.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "642247cbf31fd5010e5fff2082f7786c66912f5d"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY1NDU4Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t * Configure an executor to perform a a ZeroMQ proxy loop.\n          \n          \n            \n            \t * Configure an executor to perform a ZeroMQ proxy loop.", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r468654587", "createdAt": "2020-08-11T15:07:57Z", "author": {"login": "oli-ver"}, "path": "spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/ZeroMqProxy.java", "diffHunk": "@@ -100,28 +101,53 @@\n \n \tprivate int phase;\n \n+\t/**\n+\t * Create a {@link ZeroMqProxy} instance based on the provided {@link ZContext}\n+\t * and {@link Type#PULL_PUSH} as default mode.\n+\t * @param context the {@link ZContext} to use\n+\t */\n \tpublic ZeroMqProxy(ZContext context) {\n \t\tthis(context, Type.PULL_PUSH);\n \t}\n \n+\t/**\n+\t * Create a {@link ZeroMqProxy} instance based on the provided {@link ZContext}\n+\t * and {@link Type}.\n+\t * @param context the {@link ZContext} to use\n+\t * @param type the {@link Type} to use.\n+\t */\n \tpublic ZeroMqProxy(ZContext context, Type type) {\n \t\tAssert.notNull(context, \"'context' must not be null\");\n \t\tAssert.notNull(type, \"'type' must not be null\");\n \t\tthis.context = context;\n \t\tthis.type = type;\n \t}\n \n+\t/**\n+\t * Configure an executor to perform a a ZeroMQ proxy loop.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8c0291d441c6cc09299d5d4d60e3c558f6eddc0"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY1NTI1Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * frontend and backend ports are evaluated from this proxy and respective connection string is built from them.\n          \n          \n            \n             * frontend and backend ports are evaluated from this proxy and the respective connection string is built from them.", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r468655257", "createdAt": "2020-08-11T15:08:54Z", "author": {"login": "oli-ver"}, "path": "spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/channel/ZeroMqChannel.java", "diffHunk": "@@ -55,7 +57,10 @@\n  * The {@link #setConnectUrl(String)} has to be as a standard ZeroMQ connect string, but with an extra port\n  * over the colon - representing a frontend and backend sockets pair on ZeroMQ proxy.\n  * For example: {@code tcp://localhost:6001:6002}.\n- * This way a sending and receiving operations on this channel are similar to interaction over a messaging broker.\n+ * Another option is to provide a reference to the {@link ZeroMqProxy} instance managed in the same application:\n+ * frontend and backend ports are evaluated from this proxy and respective connection string is built from them.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8c0291d441c6cc09299d5d4d60e3c558f6eddc0"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY2MDUzOA==", "bodyText": "I think you could use the consumeDelay also here.", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r468660538", "createdAt": "2020-08-11T15:16:10Z", "author": {"login": "oli-ver"}, "path": "spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/channel/ZeroMqChannel.java", "diffHunk": "@@ -107,30 +123,51 @@ public ZeroMqChannel(ZContext context, boolean pubSub) {\n \n \t\tSupplier<String> localPairConnection = () -> \"inproc://\" + getComponentName() + \".pair\";\n \n+\t\tMono<?> proxyMono =\n+\t\t\t\tMono.defer(() -> {\n+\t\t\t\t\tif (this.zeroMqProxy != null) {\n+\t\t\t\t\t\treturn Mono.just(this.zeroMqProxy.getBackendPort())\n+\t\t\t\t\t\t\t\t.filter((port) -> port > 0)\n+\t\t\t\t\t\t\t\t.repeatWhenEmpty((repeat) -> repeat.delayElements(Duration.ofMillis(100))) // NOSONAR", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8c0291d441c6cc09299d5d4d60e3c558f6eddc0"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY2MTE5Nw==", "bodyText": "Ah wait: It's another delay, only 100 millis. Perhaps worth another repeatDelay variable?", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r468661197", "createdAt": "2020-08-11T15:17:04Z", "author": {"login": "oli-ver"}, "path": "spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/channel/ZeroMqChannel.java", "diffHunk": "@@ -107,30 +123,51 @@ public ZeroMqChannel(ZContext context, boolean pubSub) {\n \n \t\tSupplier<String> localPairConnection = () -> \"inproc://\" + getComponentName() + \".pair\";\n \n+\t\tMono<?> proxyMono =\n+\t\t\t\tMono.defer(() -> {\n+\t\t\t\t\tif (this.zeroMqProxy != null) {\n+\t\t\t\t\t\treturn Mono.just(this.zeroMqProxy.getBackendPort())\n+\t\t\t\t\t\t\t\t.filter((port) -> port > 0)\n+\t\t\t\t\t\t\t\t.repeatWhenEmpty((repeat) -> repeat.delayElements(Duration.ofMillis(100))) // NOSONAR", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY2MDUzOA=="}, "originalCommit": {"oid": "b8c0291d441c6cc09299d5d4d60e3c558f6eddc0"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY2NTg4MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t\"Or 'zeroMqProxy' or 'connectUrl' can be provided (or none), but not both.\");\n          \n          \n            \n            \t\t\t\t\"A 'zeroMqProxy' or 'connectUrl' can be provided (or none), but not both.\");", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r468665881", "createdAt": "2020-08-11T15:23:07Z", "author": {"login": "oli-ver"}, "path": "spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/channel/ZeroMqChannel.java", "diffHunk": "@@ -182,13 +225,40 @@ public void setConnectUrl(@Nullable String connectUrl) {\n \t\t}\n \t}\n \n+\t/**\n+\t * Specify a reference to a {@link ZeroMqProxy} instance in the same application\n+\t * to rely on its ports configuration and make a natural lifecycle dependency without guessing\n+\t * when the proxy is started. Mutually exclusive with the {@link #setConnectUrl(String)}.\n+\t * @param zeroMqProxy the {@link ZeroMqProxy} instance to use\n+\t */\n+\tpublic void setZeroMqProxy(@Nullable ZeroMqProxy zeroMqProxy) {\n+\t\tthis.zeroMqProxy = zeroMqProxy;\n+\t}\n+\n+\tpublic void setConsumeDelay(Duration consumeDelay) {\n+\t\tAssert.notNull(consumeDelay, \"'consumeDelay' must not be null\");\n+\t\tthis.consumeDelay = consumeDelay;\n+\t}\n+\n \tpublic void setMessageMapper(BytesMessageMapper messageMapper) {\n \t\tAssert.notNull(messageMapper, \"'messageMapper' must not be null\");\n \t\tthis.messageMapper = messageMapper;\n \t}\n \n+\tpublic void setSendSocketConfigurer(Consumer<ZMQ.Socket> sendSocketConfigurer) {\n+\t\tAssert.notNull(sendSocketConfigurer, \"'sendSocketConfigurer' must not be null\");\n+\t\tthis.sendSocketConfigurer = sendSocketConfigurer;\n+\t}\n+\n+\tpublic void setSubscribeSocketConfigurer(Consumer<ZMQ.Socket> subscribeSocketConfigurer) {\n+\t\tAssert.notNull(subscribeSocketConfigurer, \"'subscribeSocketConfigurer' must not be null\");\n+\t\tthis.subscribeSocketConfigurer = subscribeSocketConfigurer;\n+\t}\n+\n \t@Override\n \tprotected void onInit() {\n+\t\tAssert.state(this.zeroMqProxy == null || this.connectSendUrl == null,\n+\t\t\t\t\"Or 'zeroMqProxy' or 'connectUrl' can be provided (or none), but not both.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b8c0291d441c6cc09299d5d4d60e3c558f6eddc0"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY5MjcwNA==", "bodyText": "Should this perhaps be handeled by an Assertstatement? This way it's just silently ignored when someone tries to set the connectUrl to null.", "url": "https://github.com/spring-projects/spring-integration/pull/3355#discussion_r468692704", "createdAt": "2020-08-11T16:01:56Z", "author": {"login": "oli-ver"}, "path": "spring-integration-zeromq/src/main/java/org/springframework/integration/zeromq/channel/ZeroMqChannel.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/*\n+ * Copyright 2020 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.integration.zeromq.channel;\n+\n+import java.time.Duration;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+\n+import org.zeromq.SocketType;\n+import org.zeromq.ZContext;\n+import org.zeromq.ZMQ;\n+\n+import org.springframework.integration.channel.AbstractMessageChannel;\n+import org.springframework.integration.mapping.BytesMessageMapper;\n+import org.springframework.integration.support.json.EmbeddedJsonHeadersMessageMapper;\n+import org.springframework.integration.zeromq.ZeroMqProxy;\n+import org.springframework.lang.Nullable;\n+import org.springframework.messaging.Message;\n+import org.springframework.messaging.MessageHandler;\n+import org.springframework.messaging.SubscribableChannel;\n+import org.springframework.util.Assert;\n+\n+import reactor.core.Disposable;\n+import reactor.core.publisher.Flux;\n+import reactor.core.publisher.Mono;\n+import reactor.core.scheduler.Scheduler;\n+import reactor.core.scheduler.Schedulers;\n+\n+/**\n+ * The {@link SubscribableChannel} implementation over ZeroMQ sockets.\n+ * It can work in two messaging models:\n+ * - {@code push-pull}, where sent messages are distributed to subscribers in a round-robin manner\n+ * according a respective ZeroMQ {@link SocketType#PUSH} and {@link SocketType#PULL} socket types logic;\n+ * - {@code pub-sub}, where sent messages are distributed to all subscribers;\n+ * <p>\n+ * This message channel can work in local mode, when a pair of ZeroMQ sockets of {@link SocketType#PAIR} type\n+ * are connected between publisher (send operation) and subscriber using inter-thread transport binding.\n+ * <p>\n+ * In distributed mode this channel has to be connected to an externally managed ZeroMQ proxy.\n+ * The {@link #setConnectUrl(String)} has to be as a standard ZeroMQ connect string, but with an extra port\n+ * over the colon - representing a frontend and backend sockets pair on ZeroMQ proxy.\n+ * For example: {@code tcp://localhost:6001:6002}.\n+ * Another option is to provide a reference to the {@link ZeroMqProxy} instance managed in the same application:\n+ * frontend and backend ports are evaluated from this proxy and respective connection string is built from them.\n+ * <p>\n+ * This way sending and receiving operations on this channel are similar to interaction over a messaging broker.\n+ * <p>\n+ * An internal logic of this message channel implementation is based on the project Reactor using its\n+ * {@link Mono}, {@link Flux} and {@link Scheduler} API for better thead model and flow control to avoid\n+ * concurrency primitives for multi-publisher(subscriber) communication within the same application.\n+ *\n+ * @author Artem Bilan\n+ *\n+ * @since 5.4\n+ */\n+public class ZeroMqChannel extends AbstractMessageChannel implements SubscribableChannel {\n+\n+\tpublic static final Duration DEFAULT_CONSUME_DELAY = Duration.ofSeconds(1);\n+\n+\tprivate final Map<MessageHandler, Disposable> subscribers = new HashMap<>();\n+\n+\tprivate final Scheduler publisherScheduler = Schedulers.newSingle(\"publisherScheduler\");\n+\n+\tprivate final Scheduler subscriberScheduler = Schedulers.newSingle(\"subscriberScheduler\");\n+\n+\tprivate final ZContext context;\n+\n+\tprivate final boolean pubSub;\n+\n+\tprivate final Mono<ZMQ.Socket> sendSocket;\n+\n+\tprivate final Mono<ZMQ.Socket> subscribeSocket;\n+\n+\tprivate final Flux<? extends Message<?>> subscriberData;\n+\n+\tprivate Duration consumeDelay = DEFAULT_CONSUME_DELAY;\n+\n+\tprivate BytesMessageMapper messageMapper = new EmbeddedJsonHeadersMessageMapper();\n+\n+\tprivate Consumer<ZMQ.Socket> sendSocketConfigurer = (socket) -> { };\n+\n+\tprivate Consumer<ZMQ.Socket> subscribeSocketConfigurer = (socket) -> { };\n+\n+\t@Nullable\n+\tprivate ZeroMqProxy zeroMqProxy;\n+\n+\t@Nullable\n+\tprivate volatile String connectSendUrl;\n+\n+\t@Nullable\n+\tprivate volatile String connectSubscribeUrl;\n+\n+\t@Nullable\n+\tprivate volatile Disposable subscriberDataDisposable;\n+\n+\tprivate volatile boolean initialized;\n+\n+\tpublic ZeroMqChannel(ZContext context) {\n+\t\tthis(context, false);\n+\t}\n+\n+\tpublic ZeroMqChannel(ZContext context, boolean pubSub) {\n+\t\tAssert.notNull(context, \"'context' must not be null\");\n+\t\tthis.context = context;\n+\t\tthis.pubSub = pubSub;\n+\n+\t\tSupplier<String> localPairConnection = () -> \"inproc://\" + getComponentName() + \".pair\";\n+\n+\t\tMono<?> proxyMono =\n+\t\t\t\tMono.defer(() -> {\n+\t\t\t\t\tif (this.zeroMqProxy != null) {\n+\t\t\t\t\t\treturn Mono.just(this.zeroMqProxy.getBackendPort())\n+\t\t\t\t\t\t\t\t.filter((port) -> port > 0)\n+\t\t\t\t\t\t\t\t.repeatWhenEmpty((repeat) -> repeat.delayElements(Duration.ofMillis(100))) // NOSONAR\n+\t\t\t\t\t\t\t\t.doOnNext((port) ->\n+\t\t\t\t\t\t\t\t\t\tsetConnectUrl(\"tcp://localhost:\" + this.zeroMqProxy.getFrontendPort() +\n+\t\t\t\t\t\t\t\t\t\t\t\t':' + this.zeroMqProxy.getBackendPort()));\n+\t\t\t\t\t}\n+\t\t\t\t\telse {\n+\t\t\t\t\t\treturn Mono.empty();\n+\t\t\t\t\t}\n+\t\t\t\t})\n+\t\t\t\t\t\t.cache();\n+\n+\t\tthis.sendSocket =\n+\t\t\t\tproxyMono\n+\t\t\t\t\t\t.publishOn(this.publisherScheduler)\n+\t\t\t\t\t\t.then(Mono.fromCallable(() ->\n+\t\t\t\t\t\t\t\tthis.context.createSocket(\n+\t\t\t\t\t\t\t\t\t\tthis.connectSendUrl == null\n+\t\t\t\t\t\t\t\t\t\t\t\t? SocketType.PAIR\n+\t\t\t\t\t\t\t\t\t\t\t\t: (this.pubSub ? SocketType.XPUB : SocketType.PUSH))\n+\t\t\t\t\t\t))\n+\t\t\t\t\t\t.doOnNext(this.sendSocketConfigurer)\n+\t\t\t\t\t\t.doOnNext((socket) ->\n+\t\t\t\t\t\t\t\tsocket.connect(this.connectSendUrl != null\n+\t\t\t\t\t\t\t\t\t\t? this.connectSendUrl\n+\t\t\t\t\t\t\t\t\t\t: localPairConnection.get()))\n+\t\t\t\t\t\t.delayUntil((socket) ->\n+\t\t\t\t\t\t\t\t(this.pubSub && this.connectSendUrl != null)\n+\t\t\t\t\t\t\t\t\t\t? Mono.just(socket).map(ZMQ.Socket::recv)\n+\t\t\t\t\t\t\t\t\t\t: Mono.empty())\n+\t\t\t\t\t\t.cache();\n+\n+\t\tthis.subscribeSocket =\n+\t\t\t\tproxyMono\n+\t\t\t\t\t\t.publishOn(this.subscriberScheduler)\n+\t\t\t\t\t\t.then(Mono.fromCallable(() ->\n+\t\t\t\t\t\t\t\tthis.context.createSocket(\n+\t\t\t\t\t\t\t\t\t\tthis.connectSubscribeUrl == null\n+\t\t\t\t\t\t\t\t\t\t\t\t? SocketType.PAIR\n+\t\t\t\t\t\t\t\t\t\t\t\t: (this.pubSub ? SocketType.SUB : SocketType.PULL))))\n+\t\t\t\t\t\t.doOnNext(this.subscribeSocketConfigurer)\n+\t\t\t\t\t\t.doOnNext((socket) -> {\n+\t\t\t\t\t\t\tif (this.connectSubscribeUrl != null) {\n+\t\t\t\t\t\t\t\tsocket.connect(this.connectSubscribeUrl);\n+\t\t\t\t\t\t\t\tif (this.pubSub) {\n+\t\t\t\t\t\t\t\t\tsocket.subscribe(ZMQ.SUBSCRIPTION_ALL);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\telse {\n+\t\t\t\t\t\t\t\tsocket.bind(localPairConnection.get());\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t})\n+\t\t\t\t\t\t.cache();\n+\n+\t\tFlux<? extends Message<?>> receiveData =\n+\t\t\t\tthis.subscribeSocket\n+\t\t\t\t\t\t.flatMap((socket) -> {\n+\t\t\t\t\t\t\tif (this.initialized) {\n+\t\t\t\t\t\t\t\tbyte[] data = socket.recv(ZMQ.NOBLOCK);\n+\t\t\t\t\t\t\t\tif (data != null) {\n+\t\t\t\t\t\t\t\t\treturn Mono.just(data);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\treturn Mono.empty();\n+\t\t\t\t\t\t})\n+\t\t\t\t\t\t.publishOn(Schedulers.parallel())\n+\t\t\t\t\t\t.map(this.messageMapper::toMessage)\n+\t\t\t\t\t\t.doOnError((error) -> logger.error(\"Error processing ZeroMQ message\", error))\n+\t\t\t\t\t\t.repeatWhenEmpty((repeat) ->\n+\t\t\t\t\t\t\t\tthis.initialized\n+\t\t\t\t\t\t\t\t\t\t? repeat.delayElements(this.consumeDelay)\n+\t\t\t\t\t\t\t\t\t\t: repeat)\n+\t\t\t\t\t\t.repeat(() -> this.initialized);\n+\n+\t\tif (this.pubSub) {\n+\t\t\treceiveData = receiveData.publish()\n+\t\t\t\t\t.autoConnect(1, (disposable) -> this.subscriberDataDisposable = disposable);\n+\t\t}\n+\n+\t\tthis.subscriberData = receiveData;\n+\n+\t}\n+\n+\t/**\n+\t * Configure a connection to the ZeroMQ proxy with the pair of ports over colon\n+\t * for proxy frontend and backend sockets. Mutually exclusive with the {@link #setZeroMqProxy(ZeroMqProxy)}.\n+\t * @param connectUrl the connection string in format {@code PROTOCOL://HOST:FRONTEND_PORT:BACKEND_PORT},\n+\t *                    e.g. {@code tcp://localhost:6001:6002}\n+\t */\n+\tpublic void setConnectUrl(@Nullable String connectUrl) {\n+\t\tif (connectUrl != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "642247cbf31fd5010e5fff2082f7786c66912f5d"}, "originalPosition": 220}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cafc55c858e29e541e311d1ba8cba437a1c61319", "author": {"user": {"login": "artembilan", "name": "Artem Bilan"}}, "url": "https://github.com/spring-projects/spring-integration/commit/cafc55c858e29e541e311d1ba8cba437a1c61319", "committedDate": "2020-08-11T16:39:09Z", "message": "Apply suggestions from code review\n\nCo-authored-by: Oliver <oli-ver@users.noreply.github.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0a656cc16fac20779baf41ea6a504a446541a6fd", "author": {"user": {"login": "artembilan", "name": "Artem Bilan"}}, "url": "https://github.com/spring-projects/spring-integration/commit/0a656cc16fac20779baf41ea6a504a446541a6fd", "committedDate": "2020-08-11T17:48:00Z", "message": "* Fix threading using a `publishOn()` for specific scheduler after `cache()`"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "624714550ddd330aedf551f16a4371e73643ea57", "author": {"user": {"login": "artembilan", "name": "Artem Bilan"}}, "url": "https://github.com/spring-projects/spring-integration/commit/624714550ddd330aedf551f16a4371e73643ea57", "committedDate": "2020-08-11T17:55:19Z", "message": "* Remove unused import"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bff5d8df71fa53fae6cb309c6afc1be52dcc3edf", "author": {"user": {"login": "artembilan", "name": "Artem Bilan"}}, "url": "https://github.com/spring-projects/spring-integration/commit/bff5d8df71fa53fae6cb309c6afc1be52dcc3edf", "committedDate": "2020-08-11T18:37:45Z", "message": "* Change proxy port check from static `Mono.just()` to `Mono.fromCallable()`\nto really evaluate the current port state on every repeat\n* Add finite `100` repeat number to avoid infinite blocking when proxy is not started at all\n* Add `doOnError()` for proxy `Mono` to log `ERROR` when repeat is exhausted"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "afff1d317311648bfeb9db87565985ab2f87b331", "author": {"user": {"login": "artembilan", "name": "Artem Bilan"}}, "url": "https://github.com/spring-projects/spring-integration/commit/afff1d317311648bfeb9db87565985ab2f87b331", "committedDate": "2020-08-11T18:54:23Z", "message": "* Fix Checkstyle violation"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1MzQ1Mzcy", "url": "https://github.com/spring-projects/spring-integration/pull/3355#pullrequestreview-465345372", "createdAt": "2020-08-11T18:58:56Z", "commit": {"oid": "afff1d317311648bfeb9db87565985ab2f87b331"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 106, "cost": 1, "resetAt": "2021-11-02T10:47:05Z"}}}