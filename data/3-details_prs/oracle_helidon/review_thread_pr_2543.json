{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTI2MzY4Mjg4", "number": 2543, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yOVQyMDo0MjoyN1rOE-b40w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNlQxODo1OTo0NVrOFBfyWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzOTA0MDgzOnYy", "diffSide": "RIGHT", "path": "messaging/connectors/jms/src/main/java/io/helidon/messaging/connectors/jms/JmsConnector.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yOVQyMDo0MjoyN1rOH7myEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxMDo0NDo1NlrOH71YQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjI2MzQ0MQ==", "bodyText": "This class should use a builder. If we need a separate constructor for CDI, so be it, but there should be a constructor with a builder, that allows explicit configuration of everything that can be configured through config.\nIn SE, there is always a choice for developer - either build everything by hand, or use a config, or a combination\nFor example the executor services must be configurable, as user may want to reuse an executor service for multiple components", "url": "https://github.com/oracle/helidon/pull/2543#discussion_r532263441", "createdAt": "2020-11-29T20:42:27Z", "author": {"login": "tomas-langer"}, "path": "messaging/connectors/jms/src/main/java/io/helidon/messaging/connectors/jms/JmsConnector.java", "diffHunk": "@@ -122,6 +122,34 @@\n     private final ExecutorService executor;\n     private final Map<String, SessionMetadata> sessionRegister = new HashMap<>();\n \n+    /**\n+     * Creates a new instance of JmsConnector with the required configuration.\n+     *\n+     * @param config Helidon {@link io.helidon.config.Config config}\n+     * @return the new instance\n+     */\n+    public static JmsConnector create(io.helidon.config.Config config) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1feca78ea3e0efc443bb716b893f290fd355e1f4"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjUwMjU5Mw==", "bodyText": "Great idea, fixed", "url": "https://github.com/oracle/helidon/pull/2543#discussion_r532502593", "createdAt": "2020-11-30T10:44:56Z", "author": {"login": "danielkec"}, "path": "messaging/connectors/jms/src/main/java/io/helidon/messaging/connectors/jms/JmsConnector.java", "diffHunk": "@@ -122,6 +122,34 @@\n     private final ExecutorService executor;\n     private final Map<String, SessionMetadata> sessionRegister = new HashMap<>();\n \n+    /**\n+     * Creates a new instance of JmsConnector with the required configuration.\n+     *\n+     * @param config Helidon {@link io.helidon.config.Config config}\n+     * @return the new instance\n+     */\n+    public static JmsConnector create(io.helidon.config.Config config) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjI2MzQ0MQ=="}, "originalCommit": {"oid": "1feca78ea3e0efc443bb716b893f290fd355e1f4"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NDk1Nzg1OnYy", "diffSide": "RIGHT", "path": "messaging/connectors/jms/src/main/java/io/helidon/messaging/connectors/jms/JmsConnector.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwODoyNzoxNFrOH8c9ew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMDoxNzozOVrOH8kwgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzE1MTA5OQ==", "bodyText": "The Builder should be a static inner class of JmsConnector, not a standalone class - is there a reason for breaking this rule?", "url": "https://github.com/oracle/helidon/pull/2543#discussion_r533151099", "createdAt": "2020-12-01T08:27:14Z", "author": {"login": "tomas-langer"}, "path": "messaging/connectors/jms/src/main/java/io/helidon/messaging/connectors/jms/JmsConnector.java", "diffHunk": "@@ -116,20 +116,24 @@\n     static final String TYPE_PROP_DEFAULT = \"queue\";\n     static final String JNDI_JMS_FACTORY_DEFAULT = \"ConnectionFactory\";\n \n+    static final String SCHEDULER_THREAD_NAME_PREFIX = \"jms-poll-\";\n+    static final String EXECUTOR_THREAD_NAME_PREFIX = \"jms-\";\n+\n     private final Instance<ConnectionFactory> connectionFactories;\n \n     private final ScheduledExecutorService scheduler;\n     private final ExecutorService executor;\n     private final Map<String, SessionMetadata> sessionRegister = new HashMap<>();\n+    private Map<String, ConnectionFactory> connectionFactoryMap;\n \n     /**\n-     * Creates a new instance of JmsConnector with the required configuration.\n+     * Provides a {@link io.helidon.messaging.connectors.jms.JmsConnectorBuilder} for creating\n+     * a {@link io.helidon.messaging.connectors.jms.JmsConnector} instance.\n      *\n-     * @param config Helidon {@link io.helidon.config.Config config}\n-     * @return the new instance\n+     * @return new Builder instance\n      */\n-    public static JmsConnector create(io.helidon.config.Config config) {\n-        return new JmsConnector(config, null);\n+    public static JmsConnectorBuilder builder() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb40fa513b83fb9c0efc5d1beb1f90757076f191"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI3ODg1MA==", "bodyText": "no reason, fixed", "url": "https://github.com/oracle/helidon/pull/2543#discussion_r533278850", "createdAt": "2020-12-01T10:17:39Z", "author": {"login": "danielkec"}, "path": "messaging/connectors/jms/src/main/java/io/helidon/messaging/connectors/jms/JmsConnector.java", "diffHunk": "@@ -116,20 +116,24 @@\n     static final String TYPE_PROP_DEFAULT = \"queue\";\n     static final String JNDI_JMS_FACTORY_DEFAULT = \"ConnectionFactory\";\n \n+    static final String SCHEDULER_THREAD_NAME_PREFIX = \"jms-poll-\";\n+    static final String EXECUTOR_THREAD_NAME_PREFIX = \"jms-\";\n+\n     private final Instance<ConnectionFactory> connectionFactories;\n \n     private final ScheduledExecutorService scheduler;\n     private final ExecutorService executor;\n     private final Map<String, SessionMetadata> sessionRegister = new HashMap<>();\n+    private Map<String, ConnectionFactory> connectionFactoryMap;\n \n     /**\n-     * Creates a new instance of JmsConnector with the required configuration.\n+     * Provides a {@link io.helidon.messaging.connectors.jms.JmsConnectorBuilder} for creating\n+     * a {@link io.helidon.messaging.connectors.jms.JmsConnector} instance.\n      *\n-     * @param config Helidon {@link io.helidon.config.Config config}\n-     * @return the new instance\n+     * @return new Builder instance\n      */\n-    public static JmsConnector create(io.helidon.config.Config config) {\n-        return new JmsConnector(config, null);\n+    public static JmsConnectorBuilder builder() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzE1MTA5OQ=="}, "originalCommit": {"oid": "eb40fa513b83fb9c0efc5d1beb1f90757076f191"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0NDk2MTE1OnYy", "diffSide": "RIGHT", "path": "messaging/connectors/jms/src/main/java/io/helidon/messaging/connectors/jms/JmsConnectorBuilder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQwODoyODoxM1rOH8c_jg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMDoxNzo0OFrOH8kxNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzE1MTYzMA==", "bodyText": "Please also add methods for Supplier<ExecutorService> (and Supplier<ScheduledExecutorServer> below) so we can pass our ThreadPoolSupplier directly.", "url": "https://github.com/oracle/helidon/pull/2543#discussion_r533151630", "createdAt": "2020-12-01T08:28:13Z", "author": {"login": "tomas-langer"}, "path": "messaging/connectors/jms/src/main/java/io/helidon/messaging/connectors/jms/JmsConnectorBuilder.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright (c)  2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.messaging.connectors.jms;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+import javax.jms.ConnectionFactory;\n+\n+import io.helidon.common.Builder;\n+import io.helidon.common.configurable.ScheduledThreadPoolSupplier;\n+import io.helidon.common.configurable.ThreadPoolSupplier;\n+import io.helidon.config.Config;\n+\n+/**\n+ * Builder for {@link io.helidon.messaging.connectors.jms.JmsConnector}.\n+ */\n+public class JmsConnectorBuilder implements Builder<JmsConnector> {\n+\n+    private final Map<String, ConnectionFactory> connectionFactoryMap = new HashMap<>();\n+    private ScheduledExecutorService scheduler;\n+    private ExecutorService executor;\n+    private Config config;\n+\n+    /**\n+     * Add custom {@link javax.jms.ConnectionFactory ConnectionFactory} referencable by supplied name with\n+     * {@link JmsConnector#NAMED_FACTORY_ATTRIBUTE}.\n+     *\n+     * @param name              referencable connection factory name\n+     * @param connectionFactory custom connection factory\n+     * @return this builder\n+     */\n+    public JmsConnectorBuilder connectionFactory(String name, ConnectionFactory connectionFactory) {\n+        connectionFactoryMap.put(name, connectionFactory);\n+        return this;\n+    }\n+\n+    /**\n+     * Custom configuration for connector.\n+     *\n+     * @param config custom config\n+     * @return this builder\n+     */\n+    public JmsConnectorBuilder config(Config config) {\n+        this.config = config;\n+        return this;\n+    }\n+\n+    /**\n+     * Custom executor for asynchronous operations like acknowledgement.\n+     *\n+     * @param executor custom executor service\n+     * @return this builder\n+     */\n+    public JmsConnectorBuilder executor(ExecutorService executor) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb40fa513b83fb9c0efc5d1beb1f90757076f191"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI3OTAzMQ==", "bodyText": "added", "url": "https://github.com/oracle/helidon/pull/2543#discussion_r533279031", "createdAt": "2020-12-01T10:17:48Z", "author": {"login": "danielkec"}, "path": "messaging/connectors/jms/src/main/java/io/helidon/messaging/connectors/jms/JmsConnectorBuilder.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright (c)  2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.messaging.connectors.jms;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+import javax.jms.ConnectionFactory;\n+\n+import io.helidon.common.Builder;\n+import io.helidon.common.configurable.ScheduledThreadPoolSupplier;\n+import io.helidon.common.configurable.ThreadPoolSupplier;\n+import io.helidon.config.Config;\n+\n+/**\n+ * Builder for {@link io.helidon.messaging.connectors.jms.JmsConnector}.\n+ */\n+public class JmsConnectorBuilder implements Builder<JmsConnector> {\n+\n+    private final Map<String, ConnectionFactory> connectionFactoryMap = new HashMap<>();\n+    private ScheduledExecutorService scheduler;\n+    private ExecutorService executor;\n+    private Config config;\n+\n+    /**\n+     * Add custom {@link javax.jms.ConnectionFactory ConnectionFactory} referencable by supplied name with\n+     * {@link JmsConnector#NAMED_FACTORY_ATTRIBUTE}.\n+     *\n+     * @param name              referencable connection factory name\n+     * @param connectionFactory custom connection factory\n+     * @return this builder\n+     */\n+    public JmsConnectorBuilder connectionFactory(String name, ConnectionFactory connectionFactory) {\n+        connectionFactoryMap.put(name, connectionFactory);\n+        return this;\n+    }\n+\n+    /**\n+     * Custom configuration for connector.\n+     *\n+     * @param config custom config\n+     * @return this builder\n+     */\n+    public JmsConnectorBuilder config(Config config) {\n+        this.config = config;\n+        return this;\n+    }\n+\n+    /**\n+     * Custom executor for asynchronous operations like acknowledgement.\n+     *\n+     * @param executor custom executor service\n+     * @return this builder\n+     */\n+    public JmsConnectorBuilder executor(ExecutorService executor) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzE1MTYzMA=="}, "originalCommit": {"oid": "eb40fa513b83fb9c0efc5d1beb1f90757076f191"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM1MTExNTk2OnYy", "diffSide": "RIGHT", "path": "messaging/connectors/aq/src/main/java/module-info.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxMjowMzowOVrOH9XyDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMlQxMjowMzowOVrOH9XyDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDExNDgzMA==", "bodyText": "This should be require static as well", "url": "https://github.com/oracle/helidon/pull/2543#discussion_r534114830", "createdAt": "2020-12-02T12:03:09Z", "author": {"login": "tomas-langer"}, "path": "messaging/connectors/aq/src/main/java/module-info.java", "diffHunk": "@@ -18,6 +18,7 @@\n     requires transitive io.helidon.messaging.connectors.jms;\n     requires java.logging;\n     requires javax.jms.api;\n+    requires io.helidon.config.mp;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "95c47f1e47667c3696da8158b9f3b86ff7bd80ee"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3MTEyNjY5OnYy", "diffSide": "RIGHT", "path": "dependencies/pom.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNlQxODo1MjozNlrOIAOBaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNlQxOTozMDo1OVrOIAOaSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzEwMDY0OQ==", "bodyText": "There is already version.lib.transaction-api - this is a different version and naming. This seems wrong", "url": "https://github.com/oracle/helidon/pull/2543#discussion_r537100649", "createdAt": "2020-12-06T18:52:36Z", "author": {"login": "tomas-langer"}, "path": "dependencies/pom.xml", "diffHunk": "@@ -79,6 +79,7 @@\n         <version.lib.jsonb-api>1.0.2</version.lib.jsonb-api>\n         <version.lib.jsonp-api>1.1.6</version.lib.jsonp-api>\n         <version.lib.jsonp-impl>1.1.6</version.lib.jsonp-impl>\n+        <version.lib.jta>1.1</version.lib.jta>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac75ee059b23e47481b5f05d3084d2583a4b18f6"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzEwNzAxNg==", "bodyText": "yay thx thats leftover", "url": "https://github.com/oracle/helidon/pull/2543#discussion_r537107016", "createdAt": "2020-12-06T19:30:59Z", "author": {"login": "danielkec"}, "path": "dependencies/pom.xml", "diffHunk": "@@ -79,6 +79,7 @@\n         <version.lib.jsonb-api>1.0.2</version.lib.jsonb-api>\n         <version.lib.jsonp-api>1.1.6</version.lib.jsonp-api>\n         <version.lib.jsonp-impl>1.1.6</version.lib.jsonp-impl>\n+        <version.lib.jta>1.1</version.lib.jta>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzEwMDY0OQ=="}, "originalCommit": {"oid": "ac75ee059b23e47481b5f05d3084d2583a4b18f6"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3MTEzNDEwOnYy", "diffSide": "RIGHT", "path": "messaging/connectors/aq/src/main/java/io/helidon/messaging/connectors/aq/AqConnector.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNlQxODo1NzozOFrOIAOEvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQwODoxMDo0MlrOIBMXTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzEwMTUwMw==", "bodyText": "Using Config.create() may not be correct - do you really want to add environment variables, system properties and the default configuration source (such as application.yaml) to this configuration instance?", "url": "https://github.com/oracle/helidon/pull/2543#discussion_r537101503", "createdAt": "2020-12-06T18:57:38Z", "author": {"login": "tomas-langer"}, "path": "messaging/connectors/aq/src/main/java/io/helidon/messaging/connectors/aq/AqConnector.java", "diffHunk": "@@ -12,152 +12,172 @@\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n- *\n  */\n \n package io.helidon.messaging.connectors.aq;\n \n-import java.util.Optional;\n-import java.util.concurrent.Executor;\n-import java.util.function.BiConsumer;\n-\n-import javax.enterprise.context.ApplicationScoped;\n-import javax.enterprise.inject.Instance;\n-import javax.enterprise.inject.literal.NamedLiteral;\n-import javax.enterprise.inject.spi.CDI;\n-import javax.inject.Inject;\n-import javax.jms.ConnectionFactory;\n-import javax.jms.JMSException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n import javax.sql.DataSource;\n \n-import io.helidon.config.Config;\n-import io.helidon.config.ConfigValue;\n-import io.helidon.messaging.MessagingException;\n-import io.helidon.messaging.connectors.jms.ConnectionContext;\n-import io.helidon.messaging.connectors.jms.JmsConnector;\n-import io.helidon.messaging.connectors.jms.JmsMessage;\n-import io.helidon.messaging.connectors.jms.SessionMetadata;\n+import io.helidon.common.Builder;\n+import io.helidon.common.configurable.ScheduledThreadPoolSupplier;\n+import io.helidon.common.configurable.ThreadPoolSupplier;\n \n-import oracle.jms.AQjmsConnectionFactory;\n-import org.eclipse.microprofile.reactive.messaging.Message;\n-import org.eclipse.microprofile.reactive.messaging.spi.Connector;\n+import org.eclipse.microprofile.reactive.messaging.spi.ConnectorFactory;\n \n /**\n- * MicroProfile Reactive Messaging Oracle AQ connector.\n+ * Reactive Messaging Oracle AQ connector.\n  */\n-@ApplicationScoped\n-@Connector(AqConnector.CONNECTOR_NAME)\n-public class AqConnector extends JmsConnector {\n+public interface AqConnector extends ConnectorFactory {\n \n     /**\n-     * Microprofile messaging Oracle AQ connector name.\n+     * Oracle AQ connector name.\n      */\n-    public static final String CONNECTOR_NAME = \"helidon-aq\";\n+    String CONNECTOR_NAME = \"helidon-aq\";\n \n-    private static final String DATASOURCE_ATTRIBUTE = \"data-source\";\n-    private static final String URL_ATTRIBUTE = \"url\";\n+    /**\n+     * Configuration key for data source identifier.\n+     */\n+    String DATASOURCE_ATTRIBUTE = \"data-source\";\n \n-    private final Instance<AQjmsConnectionFactory> connectionFactories;\n+    /**\n+     * Configuration key for Oracle db connection string.\n+     */\n+    String URL_ATTRIBUTE = \"url\";\n \n     /**\n-     * Create new AQConnector.\n-     *\n-     * @param config root config for thread context\n+     * Configuration key for thread name prefix used for asynchronous operations like acknowledgement.\n      */\n-    @Inject\n-    AqConnector(Config config, Instance<AQjmsConnectionFactory> connectionFactories) {\n-        super(config, null);\n-        this.connectionFactories = connectionFactories;\n-    }\n+    String EXECUTOR_THREAD_NAME_PREFIX = \"aq-\";\n \n-    @Override\n-    protected Optional<? extends ConnectionFactory> getFactory(ConnectionContext ctx) {\n-\n-        // Named factory\n-        ConfigValue<String> factoryName = ctx.config().get(NAMED_FACTORY_ATTRIBUTE).asString();\n-        if (factoryName.isPresent()) {\n-            Config factory = ctx.config().get(\"factory\").get(factoryName.get());\n-            if (factory.exists()) {\n-                // from config\n-                try {\n-                    return Optional.of(createAqFactory(factory));\n-                } catch (JMSException e) {\n-                    throw new MessagingException(\"Error when preparing AQjmsConnectionFactory \" + factoryName.get(), e);\n-                }\n-            } else {\n-                // or named bean\n-                return Optional.ofNullable(connectionFactories)\n-                        .flatMap(s -> s.stream().findFirst());\n-            }\n-        }\n+    /**\n+     * Configuration key for thread name prefix used for polling.\n+     */\n+    String SCHEDULER_THREAD_NAME_PREFIX = \"aq-poll-\";\n \n-        // per channel config\n-        if (ctx.config().get(URL_ATTRIBUTE).exists() || ctx.config().get(DATASOURCE_ATTRIBUTE).exists()) {\n-            try {\n-                return Optional.of(createAqFactory(ctx.config()));\n-            } catch (JMSException e) {\n-                throw new MessagingException(\"Error when preparing AQjmsConnectionFactory\", e);\n-            }\n-        }\n+    /**\n+     * Provides a {@link io.helidon.messaging.connectors.jms.JmsConnector.JmsConnectorBuilder} for creating\n+     * a {@link io.helidon.messaging.connectors.jms.JmsConnector} instance.\n+     *\n+     * @return new Builder instance\n+     */\n+    static AqConnectorBuilder builder() {\n+        return new AqConnectorBuilder();\n+    }\n \n-        // Check out not named beans\n-        return Optional.ofNullable(connectionFactories)\n-                .flatMap(s -> s.stream()\n-                        .filter(AQjmsConnectionFactory.class::isInstance)\n-                        .findFirst()\n-                );\n+    /**\n+     * Custom config builder for AQ connector.\n+     *\n+     * @return new AQ specific config builder\n+     */\n+    static AqConfigBuilder configBuilder() {\n+        return new AqConfigBuilder();\n     }\n \n-    private AQjmsConnectionFactory createAqFactory(Config c) throws JMSException {\n-        ConfigValue<String> user = c.get(USERNAME_ATTRIBUTE).asString();\n-        ConfigValue<String> password = c.get(PASSWORD_ATTRIBUTE).asString();\n-        ConfigValue<String> url = c.get(URL_ATTRIBUTE).asString();\n-        ConfigValue<String> dataSourceName = c.get(DATASOURCE_ATTRIBUTE).asString();\n-        AQjmsConnectionFactory fact = new AQjmsConnectionFactory();\n-        if (dataSourceName.isPresent()) {\n-            if (user.isPresent()) {\n-                throw new MessagingException(\"When \" + DATASOURCE_ATTRIBUTE + \" is set, properties \"\n-                        + String.join(\", \", USERNAME_ATTRIBUTE, PASSWORD_ATTRIBUTE, URL_ATTRIBUTE)\n-                        + \" are forbidden!\");\n-            }\n+    /**\n+     * Builder for {@link AqConnectorImpl}.\n+     */\n+    class AqConnectorBuilder implements Builder<AqConnectorImpl> {\n+\n+        private final Map<String, DataSource> dataSourceMap = new HashMap<>();\n+        private ScheduledExecutorService scheduler;\n+        private ExecutorService executor;\n+        private io.helidon.config.Config config;\n+\n+        /**\n+         * Add custom {@link javax.jms.ConnectionFactory ConnectionFactory} referencable by supplied name with\n+         * {@link io.helidon.messaging.connectors.jms.JmsConnector#NAMED_FACTORY_ATTRIBUTE}.\n+         *\n+         * @param name       referencable connection factory name\n+         * @param dataSource custom connection factory\n+         * @return this builder\n+         */\n+        public AqConnectorBuilder dataSource(String name, DataSource dataSource) {\n+            dataSourceMap.put(name, dataSource);\n+            return this;\n+        }\n \n-            Instance<DataSource> dataSources = CDI.current().select(DataSource.class, NamedLiteral.of(dataSourceName.get()));\n-            if (dataSources.isResolvable()) {\n-                fact.setDatasource(dataSources.get());\n-            } else {\n-                throw new MessagingException(\"Datasource \" + dataSourceName.get()\n-                        + (dataSources.isAmbiguous() ? \" is ambiguous!\" : \" not found!\"));\n-            }\n+        /**\n+         * Custom configuration for connector.\n+         *\n+         * @param config custom config\n+         * @return this builder\n+         */\n+        public AqConnectorBuilder config(io.helidon.config.Config config) {\n+            this.config = config;\n+            return this;\n         }\n-        if (url.isPresent()) {\n-            fact.setJdbcURL(url.get());\n+\n+        /**\n+         * Custom executor for asynchronous operations like acknowledgement.\n+         *\n+         * @param executor custom executor service\n+         * @return this builder\n+         */\n+        public AqConnectorBuilder executor(ExecutorService executor) {\n+            this.executor = executor;\n+            return this;\n         }\n-        if (user.isPresent()) {\n-            fact.setUsername(user.get());\n+\n+        /**\n+         * Custom executor for loop pulling messages from JMS.\n+         *\n+         * @param scheduler custom scheduled executor service\n+         * @return this builder\n+         */\n+        public AqConnectorBuilder scheduler(ScheduledExecutorService scheduler) {\n+            this.scheduler = scheduler;\n+            return this;\n         }\n-        if (password.isPresent()) {\n-            fact.setPassword(password.get());\n+\n+        /**\n+         * Custom executor supplier for asynchronous operations like acknowledgement.\n+         *\n+         * @param executorSupplier custom executor service\n+         * @return this builder\n+         */\n+        public AqConnectorBuilder executor(ThreadPoolSupplier executorSupplier) {\n+            this.executor = executorSupplier.get();\n+            return this;\n         }\n-        return fact;\n-    }\n \n+        /**\n+         * Custom executor supplier for loop pulling messages from JMS.\n+         *\n+         * @param schedulerPoolSupplier custom scheduled executor service\n+         * @return this builder\n+         */\n+        public AqConnectorBuilder scheduler(ScheduledThreadPoolSupplier schedulerPoolSupplier) {\n+            this.scheduler = schedulerPoolSupplier.get();\n+            return this;\n+        }\n \n-    @Override\n-    protected JmsMessage<?> createMessage(javax.jms.Message message,\n-                                          Executor executor,\n-                                          SessionMetadata sessionMetadata) {\n-        return new AqMessageImpl<>(super.createMessage(message, executor, sessionMetadata), sessionMetadata);\n-    }\n+        @Override\n+        public AqConnectorImpl build() {\n+            if (config == null) {\n+                config = io.helidon.config.Config.create();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac75ee059b23e47481b5f05d3084d2583a4b18f6"}, "originalPosition": 257}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzEwNTU1MQ==", "bodyText": "That was the idea, connector without any configuration is useless", "url": "https://github.com/oracle/helidon/pull/2543#discussion_r537105551", "createdAt": "2020-12-06T19:22:00Z", "author": {"login": "danielkec"}, "path": "messaging/connectors/aq/src/main/java/io/helidon/messaging/connectors/aq/AqConnector.java", "diffHunk": "@@ -12,152 +12,172 @@\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n- *\n  */\n \n package io.helidon.messaging.connectors.aq;\n \n-import java.util.Optional;\n-import java.util.concurrent.Executor;\n-import java.util.function.BiConsumer;\n-\n-import javax.enterprise.context.ApplicationScoped;\n-import javax.enterprise.inject.Instance;\n-import javax.enterprise.inject.literal.NamedLiteral;\n-import javax.enterprise.inject.spi.CDI;\n-import javax.inject.Inject;\n-import javax.jms.ConnectionFactory;\n-import javax.jms.JMSException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n import javax.sql.DataSource;\n \n-import io.helidon.config.Config;\n-import io.helidon.config.ConfigValue;\n-import io.helidon.messaging.MessagingException;\n-import io.helidon.messaging.connectors.jms.ConnectionContext;\n-import io.helidon.messaging.connectors.jms.JmsConnector;\n-import io.helidon.messaging.connectors.jms.JmsMessage;\n-import io.helidon.messaging.connectors.jms.SessionMetadata;\n+import io.helidon.common.Builder;\n+import io.helidon.common.configurable.ScheduledThreadPoolSupplier;\n+import io.helidon.common.configurable.ThreadPoolSupplier;\n \n-import oracle.jms.AQjmsConnectionFactory;\n-import org.eclipse.microprofile.reactive.messaging.Message;\n-import org.eclipse.microprofile.reactive.messaging.spi.Connector;\n+import org.eclipse.microprofile.reactive.messaging.spi.ConnectorFactory;\n \n /**\n- * MicroProfile Reactive Messaging Oracle AQ connector.\n+ * Reactive Messaging Oracle AQ connector.\n  */\n-@ApplicationScoped\n-@Connector(AqConnector.CONNECTOR_NAME)\n-public class AqConnector extends JmsConnector {\n+public interface AqConnector extends ConnectorFactory {\n \n     /**\n-     * Microprofile messaging Oracle AQ connector name.\n+     * Oracle AQ connector name.\n      */\n-    public static final String CONNECTOR_NAME = \"helidon-aq\";\n+    String CONNECTOR_NAME = \"helidon-aq\";\n \n-    private static final String DATASOURCE_ATTRIBUTE = \"data-source\";\n-    private static final String URL_ATTRIBUTE = \"url\";\n+    /**\n+     * Configuration key for data source identifier.\n+     */\n+    String DATASOURCE_ATTRIBUTE = \"data-source\";\n \n-    private final Instance<AQjmsConnectionFactory> connectionFactories;\n+    /**\n+     * Configuration key for Oracle db connection string.\n+     */\n+    String URL_ATTRIBUTE = \"url\";\n \n     /**\n-     * Create new AQConnector.\n-     *\n-     * @param config root config for thread context\n+     * Configuration key for thread name prefix used for asynchronous operations like acknowledgement.\n      */\n-    @Inject\n-    AqConnector(Config config, Instance<AQjmsConnectionFactory> connectionFactories) {\n-        super(config, null);\n-        this.connectionFactories = connectionFactories;\n-    }\n+    String EXECUTOR_THREAD_NAME_PREFIX = \"aq-\";\n \n-    @Override\n-    protected Optional<? extends ConnectionFactory> getFactory(ConnectionContext ctx) {\n-\n-        // Named factory\n-        ConfigValue<String> factoryName = ctx.config().get(NAMED_FACTORY_ATTRIBUTE).asString();\n-        if (factoryName.isPresent()) {\n-            Config factory = ctx.config().get(\"factory\").get(factoryName.get());\n-            if (factory.exists()) {\n-                // from config\n-                try {\n-                    return Optional.of(createAqFactory(factory));\n-                } catch (JMSException e) {\n-                    throw new MessagingException(\"Error when preparing AQjmsConnectionFactory \" + factoryName.get(), e);\n-                }\n-            } else {\n-                // or named bean\n-                return Optional.ofNullable(connectionFactories)\n-                        .flatMap(s -> s.stream().findFirst());\n-            }\n-        }\n+    /**\n+     * Configuration key for thread name prefix used for polling.\n+     */\n+    String SCHEDULER_THREAD_NAME_PREFIX = \"aq-poll-\";\n \n-        // per channel config\n-        if (ctx.config().get(URL_ATTRIBUTE).exists() || ctx.config().get(DATASOURCE_ATTRIBUTE).exists()) {\n-            try {\n-                return Optional.of(createAqFactory(ctx.config()));\n-            } catch (JMSException e) {\n-                throw new MessagingException(\"Error when preparing AQjmsConnectionFactory\", e);\n-            }\n-        }\n+    /**\n+     * Provides a {@link io.helidon.messaging.connectors.jms.JmsConnector.JmsConnectorBuilder} for creating\n+     * a {@link io.helidon.messaging.connectors.jms.JmsConnector} instance.\n+     *\n+     * @return new Builder instance\n+     */\n+    static AqConnectorBuilder builder() {\n+        return new AqConnectorBuilder();\n+    }\n \n-        // Check out not named beans\n-        return Optional.ofNullable(connectionFactories)\n-                .flatMap(s -> s.stream()\n-                        .filter(AQjmsConnectionFactory.class::isInstance)\n-                        .findFirst()\n-                );\n+    /**\n+     * Custom config builder for AQ connector.\n+     *\n+     * @return new AQ specific config builder\n+     */\n+    static AqConfigBuilder configBuilder() {\n+        return new AqConfigBuilder();\n     }\n \n-    private AQjmsConnectionFactory createAqFactory(Config c) throws JMSException {\n-        ConfigValue<String> user = c.get(USERNAME_ATTRIBUTE).asString();\n-        ConfigValue<String> password = c.get(PASSWORD_ATTRIBUTE).asString();\n-        ConfigValue<String> url = c.get(URL_ATTRIBUTE).asString();\n-        ConfigValue<String> dataSourceName = c.get(DATASOURCE_ATTRIBUTE).asString();\n-        AQjmsConnectionFactory fact = new AQjmsConnectionFactory();\n-        if (dataSourceName.isPresent()) {\n-            if (user.isPresent()) {\n-                throw new MessagingException(\"When \" + DATASOURCE_ATTRIBUTE + \" is set, properties \"\n-                        + String.join(\", \", USERNAME_ATTRIBUTE, PASSWORD_ATTRIBUTE, URL_ATTRIBUTE)\n-                        + \" are forbidden!\");\n-            }\n+    /**\n+     * Builder for {@link AqConnectorImpl}.\n+     */\n+    class AqConnectorBuilder implements Builder<AqConnectorImpl> {\n+\n+        private final Map<String, DataSource> dataSourceMap = new HashMap<>();\n+        private ScheduledExecutorService scheduler;\n+        private ExecutorService executor;\n+        private io.helidon.config.Config config;\n+\n+        /**\n+         * Add custom {@link javax.jms.ConnectionFactory ConnectionFactory} referencable by supplied name with\n+         * {@link io.helidon.messaging.connectors.jms.JmsConnector#NAMED_FACTORY_ATTRIBUTE}.\n+         *\n+         * @param name       referencable connection factory name\n+         * @param dataSource custom connection factory\n+         * @return this builder\n+         */\n+        public AqConnectorBuilder dataSource(String name, DataSource dataSource) {\n+            dataSourceMap.put(name, dataSource);\n+            return this;\n+        }\n \n-            Instance<DataSource> dataSources = CDI.current().select(DataSource.class, NamedLiteral.of(dataSourceName.get()));\n-            if (dataSources.isResolvable()) {\n-                fact.setDatasource(dataSources.get());\n-            } else {\n-                throw new MessagingException(\"Datasource \" + dataSourceName.get()\n-                        + (dataSources.isAmbiguous() ? \" is ambiguous!\" : \" not found!\"));\n-            }\n+        /**\n+         * Custom configuration for connector.\n+         *\n+         * @param config custom config\n+         * @return this builder\n+         */\n+        public AqConnectorBuilder config(io.helidon.config.Config config) {\n+            this.config = config;\n+            return this;\n         }\n-        if (url.isPresent()) {\n-            fact.setJdbcURL(url.get());\n+\n+        /**\n+         * Custom executor for asynchronous operations like acknowledgement.\n+         *\n+         * @param executor custom executor service\n+         * @return this builder\n+         */\n+        public AqConnectorBuilder executor(ExecutorService executor) {\n+            this.executor = executor;\n+            return this;\n         }\n-        if (user.isPresent()) {\n-            fact.setUsername(user.get());\n+\n+        /**\n+         * Custom executor for loop pulling messages from JMS.\n+         *\n+         * @param scheduler custom scheduled executor service\n+         * @return this builder\n+         */\n+        public AqConnectorBuilder scheduler(ScheduledExecutorService scheduler) {\n+            this.scheduler = scheduler;\n+            return this;\n         }\n-        if (password.isPresent()) {\n-            fact.setPassword(password.get());\n+\n+        /**\n+         * Custom executor supplier for asynchronous operations like acknowledgement.\n+         *\n+         * @param executorSupplier custom executor service\n+         * @return this builder\n+         */\n+        public AqConnectorBuilder executor(ThreadPoolSupplier executorSupplier) {\n+            this.executor = executorSupplier.get();\n+            return this;\n         }\n-        return fact;\n-    }\n \n+        /**\n+         * Custom executor supplier for loop pulling messages from JMS.\n+         *\n+         * @param schedulerPoolSupplier custom scheduled executor service\n+         * @return this builder\n+         */\n+        public AqConnectorBuilder scheduler(ScheduledThreadPoolSupplier schedulerPoolSupplier) {\n+            this.scheduler = schedulerPoolSupplier.get();\n+            return this;\n+        }\n \n-    @Override\n-    protected JmsMessage<?> createMessage(javax.jms.Message message,\n-                                          Executor executor,\n-                                          SessionMetadata sessionMetadata) {\n-        return new AqMessageImpl<>(super.createMessage(message, executor, sessionMetadata), sessionMetadata);\n-    }\n+        @Override\n+        public AqConnectorImpl build() {\n+            if (config == null) {\n+                config = io.helidon.config.Config.create();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzEwMTUwMw=="}, "originalCommit": {"oid": "ac75ee059b23e47481b5f05d3084d2583a4b18f6"}, "originalPosition": 257}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODEyMjA2MA==", "bodyText": "We have agreed to use empty config, as that is the expectation by user. Config.create() may pick up unexpected configuration files.", "url": "https://github.com/oracle/helidon/pull/2543#discussion_r538122060", "createdAt": "2020-12-08T08:10:42Z", "author": {"login": "tomas-langer"}, "path": "messaging/connectors/aq/src/main/java/io/helidon/messaging/connectors/aq/AqConnector.java", "diffHunk": "@@ -12,152 +12,172 @@\n  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  * See the License for the specific language governing permissions and\n  * limitations under the License.\n- *\n  */\n \n package io.helidon.messaging.connectors.aq;\n \n-import java.util.Optional;\n-import java.util.concurrent.Executor;\n-import java.util.function.BiConsumer;\n-\n-import javax.enterprise.context.ApplicationScoped;\n-import javax.enterprise.inject.Instance;\n-import javax.enterprise.inject.literal.NamedLiteral;\n-import javax.enterprise.inject.spi.CDI;\n-import javax.inject.Inject;\n-import javax.jms.ConnectionFactory;\n-import javax.jms.JMSException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n import javax.sql.DataSource;\n \n-import io.helidon.config.Config;\n-import io.helidon.config.ConfigValue;\n-import io.helidon.messaging.MessagingException;\n-import io.helidon.messaging.connectors.jms.ConnectionContext;\n-import io.helidon.messaging.connectors.jms.JmsConnector;\n-import io.helidon.messaging.connectors.jms.JmsMessage;\n-import io.helidon.messaging.connectors.jms.SessionMetadata;\n+import io.helidon.common.Builder;\n+import io.helidon.common.configurable.ScheduledThreadPoolSupplier;\n+import io.helidon.common.configurable.ThreadPoolSupplier;\n \n-import oracle.jms.AQjmsConnectionFactory;\n-import org.eclipse.microprofile.reactive.messaging.Message;\n-import org.eclipse.microprofile.reactive.messaging.spi.Connector;\n+import org.eclipse.microprofile.reactive.messaging.spi.ConnectorFactory;\n \n /**\n- * MicroProfile Reactive Messaging Oracle AQ connector.\n+ * Reactive Messaging Oracle AQ connector.\n  */\n-@ApplicationScoped\n-@Connector(AqConnector.CONNECTOR_NAME)\n-public class AqConnector extends JmsConnector {\n+public interface AqConnector extends ConnectorFactory {\n \n     /**\n-     * Microprofile messaging Oracle AQ connector name.\n+     * Oracle AQ connector name.\n      */\n-    public static final String CONNECTOR_NAME = \"helidon-aq\";\n+    String CONNECTOR_NAME = \"helidon-aq\";\n \n-    private static final String DATASOURCE_ATTRIBUTE = \"data-source\";\n-    private static final String URL_ATTRIBUTE = \"url\";\n+    /**\n+     * Configuration key for data source identifier.\n+     */\n+    String DATASOURCE_ATTRIBUTE = \"data-source\";\n \n-    private final Instance<AQjmsConnectionFactory> connectionFactories;\n+    /**\n+     * Configuration key for Oracle db connection string.\n+     */\n+    String URL_ATTRIBUTE = \"url\";\n \n     /**\n-     * Create new AQConnector.\n-     *\n-     * @param config root config for thread context\n+     * Configuration key for thread name prefix used for asynchronous operations like acknowledgement.\n      */\n-    @Inject\n-    AqConnector(Config config, Instance<AQjmsConnectionFactory> connectionFactories) {\n-        super(config, null);\n-        this.connectionFactories = connectionFactories;\n-    }\n+    String EXECUTOR_THREAD_NAME_PREFIX = \"aq-\";\n \n-    @Override\n-    protected Optional<? extends ConnectionFactory> getFactory(ConnectionContext ctx) {\n-\n-        // Named factory\n-        ConfigValue<String> factoryName = ctx.config().get(NAMED_FACTORY_ATTRIBUTE).asString();\n-        if (factoryName.isPresent()) {\n-            Config factory = ctx.config().get(\"factory\").get(factoryName.get());\n-            if (factory.exists()) {\n-                // from config\n-                try {\n-                    return Optional.of(createAqFactory(factory));\n-                } catch (JMSException e) {\n-                    throw new MessagingException(\"Error when preparing AQjmsConnectionFactory \" + factoryName.get(), e);\n-                }\n-            } else {\n-                // or named bean\n-                return Optional.ofNullable(connectionFactories)\n-                        .flatMap(s -> s.stream().findFirst());\n-            }\n-        }\n+    /**\n+     * Configuration key for thread name prefix used for polling.\n+     */\n+    String SCHEDULER_THREAD_NAME_PREFIX = \"aq-poll-\";\n \n-        // per channel config\n-        if (ctx.config().get(URL_ATTRIBUTE).exists() || ctx.config().get(DATASOURCE_ATTRIBUTE).exists()) {\n-            try {\n-                return Optional.of(createAqFactory(ctx.config()));\n-            } catch (JMSException e) {\n-                throw new MessagingException(\"Error when preparing AQjmsConnectionFactory\", e);\n-            }\n-        }\n+    /**\n+     * Provides a {@link io.helidon.messaging.connectors.jms.JmsConnector.JmsConnectorBuilder} for creating\n+     * a {@link io.helidon.messaging.connectors.jms.JmsConnector} instance.\n+     *\n+     * @return new Builder instance\n+     */\n+    static AqConnectorBuilder builder() {\n+        return new AqConnectorBuilder();\n+    }\n \n-        // Check out not named beans\n-        return Optional.ofNullable(connectionFactories)\n-                .flatMap(s -> s.stream()\n-                        .filter(AQjmsConnectionFactory.class::isInstance)\n-                        .findFirst()\n-                );\n+    /**\n+     * Custom config builder for AQ connector.\n+     *\n+     * @return new AQ specific config builder\n+     */\n+    static AqConfigBuilder configBuilder() {\n+        return new AqConfigBuilder();\n     }\n \n-    private AQjmsConnectionFactory createAqFactory(Config c) throws JMSException {\n-        ConfigValue<String> user = c.get(USERNAME_ATTRIBUTE).asString();\n-        ConfigValue<String> password = c.get(PASSWORD_ATTRIBUTE).asString();\n-        ConfigValue<String> url = c.get(URL_ATTRIBUTE).asString();\n-        ConfigValue<String> dataSourceName = c.get(DATASOURCE_ATTRIBUTE).asString();\n-        AQjmsConnectionFactory fact = new AQjmsConnectionFactory();\n-        if (dataSourceName.isPresent()) {\n-            if (user.isPresent()) {\n-                throw new MessagingException(\"When \" + DATASOURCE_ATTRIBUTE + \" is set, properties \"\n-                        + String.join(\", \", USERNAME_ATTRIBUTE, PASSWORD_ATTRIBUTE, URL_ATTRIBUTE)\n-                        + \" are forbidden!\");\n-            }\n+    /**\n+     * Builder for {@link AqConnectorImpl}.\n+     */\n+    class AqConnectorBuilder implements Builder<AqConnectorImpl> {\n+\n+        private final Map<String, DataSource> dataSourceMap = new HashMap<>();\n+        private ScheduledExecutorService scheduler;\n+        private ExecutorService executor;\n+        private io.helidon.config.Config config;\n+\n+        /**\n+         * Add custom {@link javax.jms.ConnectionFactory ConnectionFactory} referencable by supplied name with\n+         * {@link io.helidon.messaging.connectors.jms.JmsConnector#NAMED_FACTORY_ATTRIBUTE}.\n+         *\n+         * @param name       referencable connection factory name\n+         * @param dataSource custom connection factory\n+         * @return this builder\n+         */\n+        public AqConnectorBuilder dataSource(String name, DataSource dataSource) {\n+            dataSourceMap.put(name, dataSource);\n+            return this;\n+        }\n \n-            Instance<DataSource> dataSources = CDI.current().select(DataSource.class, NamedLiteral.of(dataSourceName.get()));\n-            if (dataSources.isResolvable()) {\n-                fact.setDatasource(dataSources.get());\n-            } else {\n-                throw new MessagingException(\"Datasource \" + dataSourceName.get()\n-                        + (dataSources.isAmbiguous() ? \" is ambiguous!\" : \" not found!\"));\n-            }\n+        /**\n+         * Custom configuration for connector.\n+         *\n+         * @param config custom config\n+         * @return this builder\n+         */\n+        public AqConnectorBuilder config(io.helidon.config.Config config) {\n+            this.config = config;\n+            return this;\n         }\n-        if (url.isPresent()) {\n-            fact.setJdbcURL(url.get());\n+\n+        /**\n+         * Custom executor for asynchronous operations like acknowledgement.\n+         *\n+         * @param executor custom executor service\n+         * @return this builder\n+         */\n+        public AqConnectorBuilder executor(ExecutorService executor) {\n+            this.executor = executor;\n+            return this;\n         }\n-        if (user.isPresent()) {\n-            fact.setUsername(user.get());\n+\n+        /**\n+         * Custom executor for loop pulling messages from JMS.\n+         *\n+         * @param scheduler custom scheduled executor service\n+         * @return this builder\n+         */\n+        public AqConnectorBuilder scheduler(ScheduledExecutorService scheduler) {\n+            this.scheduler = scheduler;\n+            return this;\n         }\n-        if (password.isPresent()) {\n-            fact.setPassword(password.get());\n+\n+        /**\n+         * Custom executor supplier for asynchronous operations like acknowledgement.\n+         *\n+         * @param executorSupplier custom executor service\n+         * @return this builder\n+         */\n+        public AqConnectorBuilder executor(ThreadPoolSupplier executorSupplier) {\n+            this.executor = executorSupplier.get();\n+            return this;\n         }\n-        return fact;\n-    }\n \n+        /**\n+         * Custom executor supplier for loop pulling messages from JMS.\n+         *\n+         * @param schedulerPoolSupplier custom scheduled executor service\n+         * @return this builder\n+         */\n+        public AqConnectorBuilder scheduler(ScheduledThreadPoolSupplier schedulerPoolSupplier) {\n+            this.scheduler = schedulerPoolSupplier.get();\n+            return this;\n+        }\n \n-    @Override\n-    protected JmsMessage<?> createMessage(javax.jms.Message message,\n-                                          Executor executor,\n-                                          SessionMetadata sessionMetadata) {\n-        return new AqMessageImpl<>(super.createMessage(message, executor, sessionMetadata), sessionMetadata);\n-    }\n+        @Override\n+        public AqConnectorImpl build() {\n+            if (config == null) {\n+                config = io.helidon.config.Config.create();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzEwMTUwMw=="}, "originalCommit": {"oid": "ac75ee059b23e47481b5f05d3084d2583a4b18f6"}, "originalPosition": 257}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM3MTEzNjkwOnYy", "diffSide": "RIGHT", "path": "messaging/connectors/jms/src/main/java/io/helidon/messaging/connectors/jms/JmsConnector.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNlQxODo1OTo0NVrOIAOGBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNlQyMDozNjo1NVrOIAPHHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzEwMTgyOQ==", "bodyText": "The map should be final", "url": "https://github.com/oracle/helidon/pull/2543#discussion_r537101829", "createdAt": "2020-12-06T18:59:45Z", "author": {"login": "tomas-langer"}, "path": "messaging/connectors/jms/src/main/java/io/helidon/messaging/connectors/jms/JmsConnector.java", "diffHunk": "@@ -116,11 +117,43 @@\n     static final String TYPE_PROP_DEFAULT = \"queue\";\n     static final String JNDI_JMS_FACTORY_DEFAULT = \"ConnectionFactory\";\n \n+    static final String SCHEDULER_THREAD_NAME_PREFIX = \"jms-poll-\";\n+    static final String EXECUTOR_THREAD_NAME_PREFIX = \"jms-\";\n+\n     private final Instance<ConnectionFactory> connectionFactories;\n \n     private final ScheduledExecutorService scheduler;\n     private final ExecutorService executor;\n     private final Map<String, SessionMetadata> sessionRegister = new HashMap<>();\n+    private Map<String, ConnectionFactory> connectionFactoryMap;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac75ee059b23e47481b5f05d3084d2583a4b18f6"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzExODQ5NQ==", "bodyText": "fixed", "url": "https://github.com/oracle/helidon/pull/2543#discussion_r537118495", "createdAt": "2020-12-06T20:36:55Z", "author": {"login": "danielkec"}, "path": "messaging/connectors/jms/src/main/java/io/helidon/messaging/connectors/jms/JmsConnector.java", "diffHunk": "@@ -116,11 +117,43 @@\n     static final String TYPE_PROP_DEFAULT = \"queue\";\n     static final String JNDI_JMS_FACTORY_DEFAULT = \"ConnectionFactory\";\n \n+    static final String SCHEDULER_THREAD_NAME_PREFIX = \"jms-poll-\";\n+    static final String EXECUTOR_THREAD_NAME_PREFIX = \"jms-\";\n+\n     private final Instance<ConnectionFactory> connectionFactories;\n \n     private final ScheduledExecutorService scheduler;\n     private final ExecutorService executor;\n     private final Map<String, SessionMetadata> sessionRegister = new HashMap<>();\n+    private Map<String, ConnectionFactory> connectionFactoryMap;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzEwMTgyOQ=="}, "originalCommit": {"oid": "ac75ee059b23e47481b5f05d3084d2583a4b18f6"}, "originalPosition": 20}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 362, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}