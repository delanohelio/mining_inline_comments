{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYwNTQ0MzU4", "number": 1280, "title": "Integration of WebSockets POC into Helidon 2.0", "bodyText": "Support for WebSockets in SE and MP.", "createdAt": "2020-01-08T16:30:20Z", "url": "https://github.com/oracle/helidon/pull/1280", "merged": true, "mergeCommit": {"oid": "3df2c2279a50f05e2458ff72e0f74693f1a0f5ac"}, "closed": true, "closedAt": "2020-02-13T20:19:24Z", "author": {"login": "spericas"}, "timelineItems": {"totalCount": 42, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb4HPDeAH2gAyMzYwNTQ0MzU4OjMwMmNkMWVjMDE1MTNhMzI3OTZhMTBiMzM1NjJmOTE1NzFlMDY5Y2Q=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcEAuLUgFqTM1ODUxODU1NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "302cd1ec01513a32796a10b33562f91571e069cd", "author": {"user": {"login": "spericas", "name": "Santiago Pericasgeertsen"}}, "url": "https://github.com/oracle/helidon/commit/302cd1ec01513a32796a10b33562f91571e069cd", "committedDate": "2020-01-07T21:00:28Z", "message": "Initial integration of Tyrus integration POC into 2.0 branch."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0d6080d8dc0bc2b7818f3ffab5efda107580bb69", "author": {"user": {"login": "spericas", "name": "Santiago Pericasgeertsen"}}, "url": "https://github.com/oracle/helidon/commit/0d6080d8dc0bc2b7818f3ffab5efda107580bb69", "committedDate": "2020-01-08T14:02:38Z", "message": "Merge branch 'master' into websockets20"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "423a91e00393b34df7174395988abec4ccd62778", "author": {"user": {"login": "spericas", "name": "Santiago Pericasgeertsen"}}, "url": "https://github.com/oracle/helidon/commit/423a91e00393b34df7174395988abec4ccd62778", "committedDate": "2020-01-08T14:24:21Z", "message": "Moved new dependencies to parent POM, fixed copyright and checkstyle problems.\n\nSigned-off-by: Santiago Pericas-Geertsen <santiago.pericasgeertsen@oracle.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0b717818ed3d86e8f59c6294dc1ee1ee94fbff33", "author": {"user": {"login": "spericas", "name": "Santiago Pericasgeertsen"}}, "url": "https://github.com/oracle/helidon/commit/0b717818ed3d86e8f59c6294dc1ee1ee94fbff33", "committedDate": "2020-01-08T16:25:38Z", "message": "Some changes to the webserver engine to handle websocket connections.\n\nSigned-off-by: Santiago Pericas-Geertsen <santiago.pericasgeertsen@oracle.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "467059ecbbe5327bbb8fd6dc8e6cceec31457767", "author": {"user": {"login": "spericas", "name": "Santiago Pericasgeertsen"}}, "url": "https://github.com/oracle/helidon/commit/467059ecbbe5327bbb8fd6dc8e6cceec31457767", "committedDate": "2020-01-08T16:42:04Z", "message": "Fixed copyright and checkstyle.\n\nSigned-off-by: Santiago Pericas-Geertsen <santiago.pericasgeertsen@oracle.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c34dce5495edeb056850c8a08aaadaff0d61ddf4", "author": {"user": {"login": "spericas", "name": "Santiago Pericasgeertsen"}}, "url": "https://github.com/oracle/helidon/commit/c34dce5495edeb056850c8a08aaadaff0d61ddf4", "committedDate": "2020-01-08T17:50:14Z", "message": "A few more copyright fixes.\n\nSigned-off-by: Santiago Pericas-Geertsen <santiago.pericasgeertsen@oracle.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d19f47db73dbca03fcd96a04cb6c21a8a266d702", "author": {"user": {"login": "spericas", "name": "Santiago Pericasgeertsen"}}, "url": "https://github.com/oracle/helidon/commit/d19f47db73dbca03fcd96a04cb6c21a8a266d702", "committedDate": "2020-01-08T18:53:41Z", "message": "Spotbugs fix.\n\nSigned-off-by: Santiago Pericas-Geertsen <santiago.pericasgeertsen@oracle.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "37a0de214526c55c523146017afaa344da6b4fd6", "author": {"user": {"login": "spericas", "name": "Santiago Pericasgeertsen"}}, "url": "https://github.com/oracle/helidon/commit/37a0de214526c55c523146017afaa344da6b4fd6", "committedDate": "2020-01-08T20:22:07Z", "message": "Moving up to WebSockets API 1.1.2.\n\nSigned-off-by: Santiago Pericas-Geertsen <santiago.pericasgeertsen@oracle.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "938d6f8461c4bfb147eeb5edff9d3ce29fb61756", "author": {"user": {"login": "spericas", "name": "Santiago Pericasgeertsen"}}, "url": "https://github.com/oracle/helidon/commit/938d6f8461c4bfb147eeb5edff9d3ce29fb61756", "committedDate": "2020-01-09T16:56:19Z", "message": "Created base class for tests. Improved testing for EchoService.\n\nSigned-off-by: Santiago Pericas-Geertsen <santiago.pericasgeertsen@oracle.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "077141012649538f66e2a2f7d16adee443f3bfd7", "author": {"user": {"login": "spericas", "name": "Santiago Pericasgeertsen"}}, "url": "https://github.com/oracle/helidon/commit/077141012649538f66e2a2f7d16adee443f3bfd7", "committedDate": "2020-01-10T14:43:48Z", "message": "Basic support for WebSocket programmatic API. New and improved testing that includes verification of encoders and decoders.\n\nSigned-off-by: Santiago Pericas-Geertsen <santiago.pericasgeertsen@oracle.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7e0d81d4acab59263d18869b9821242f7749fdd3", "author": {"user": {"login": "spericas", "name": "Santiago Pericasgeertsen"}}, "url": "https://github.com/oracle/helidon/commit/7e0d81d4acab59263d18869b9821242f7749fdd3", "committedDate": "2020-01-10T19:46:31Z", "message": "New routing tests. Some additional changes to test framework.\n\nSigned-off-by: Santiago Pericas-Geertsen <santiago.pericasgeertsen@oracle.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7c5079435eaeca96117ab1ab1e127a68e94923d0", "author": {"user": {"login": "spericas", "name": "Santiago Pericasgeertsen"}}, "url": "https://github.com/oracle/helidon/commit/7c5079435eaeca96117ab1ab1e127a68e94923d0", "committedDate": "2020-01-13T14:18:45Z", "message": "Filter out any flush buffers in the count.\n\nSigned-off-by: Santiago Pericas-Geertsen <santiago.pericasgeertsen@oracle.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "30dcb6b338545d71a0046f908829a0d44a1e2093", "author": {"user": {"login": "spericas", "name": "Santiago Pericasgeertsen"}}, "url": "https://github.com/oracle/helidon/commit/30dcb6b338545d71a0046f908829a0d44a1e2093", "committedDate": "2020-01-14T15:12:26Z", "message": "Merging with master for PR 1259.\n\nSigned-off-by: Santiago Pericas-Geertsen <santiago.pericasgeertsen@oracle.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "989d88141882f9761531a6fd0046adc3e011646e", "author": {"user": {"login": "spericas", "name": "Santiago Pericasgeertsen"}}, "url": "https://github.com/oracle/helidon/commit/989d88141882f9761531a6fd0046adc3e011646e", "committedDate": "2020-01-17T21:07:31Z", "message": "Initial work to support WebSocket in Helidon MP.\n\nSigned-off-by: Santiago Pericas-Geertsen <santiago.pericasgeertsen@oracle.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ccbda1eb35cc155741251e253676f3535c606f18", "author": {"user": {"login": "spericas", "name": "Santiago Pericasgeertsen"}}, "url": "https://github.com/oracle/helidon/commit/ccbda1eb35cc155741251e253676f3535c606f18", "committedDate": "2020-01-22T16:45:59Z", "message": "Tyrus component provider to integrate with CDI. Changes to JerseySupport to ignore websocket handshakes. MP server test.\n\nSigned-off-by: Santiago Pericas-Geertsen <santiago.pericasgeertsen@oracle.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "507c2df2889ddc995c350621c75cee738f442b44", "author": {"user": {"login": "spericas", "name": "Santiago Pericasgeertsen"}}, "url": "https://github.com/oracle/helidon/commit/507c2df2889ddc995c350621c75cee738f442b44", "committedDate": "2020-01-23T16:03:08Z", "message": "Support for scanning programmatic endpoints and applications. Allow @ApplicationPath annotation on subclasses of ServerApplicationConfig. Some test changes."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "89c7f697e631c7e2a968c6bf463c265cd255d51b", "author": {"user": {"login": "spericas", "name": "Santiago Pericasgeertsen"}}, "url": "https://github.com/oracle/helidon/commit/89c7f697e631c7e2a968c6bf463c265cd255d51b", "committedDate": "2020-01-23T19:48:19Z", "message": "Testing websocket applications and programmatic endpoints."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7345fc9112aee02cede40c9b1890eb32537410f9", "author": {"user": {"login": "spericas", "name": "Santiago Pericasgeertsen"}}, "url": "https://github.com/oracle/helidon/commit/7345fc9112aee02cede40c9b1890eb32537410f9", "committedDate": "2020-01-23T20:31:25Z", "message": "Extended server builder to allow manually setting a websocket application. Updated corresponding test."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "af077c6255fad9746c1ed588be8f15ef231935bf", "author": {"user": {"login": "spericas", "name": "Santiago Pericasgeertsen"}}, "url": "https://github.com/oracle/helidon/commit/af077c6255fad9746c1ed588be8f15ef231935bf", "committedDate": "2020-01-24T18:41:29Z", "message": "New MP example that uses REST and WebSockets. Some other minor changes."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0f2693feb4f5583c2937b4ddba942d13acdcb924", "author": {"user": {"login": "spericas", "name": "Santiago Pericasgeertsen"}}, "url": "https://github.com/oracle/helidon/commit/0f2693feb4f5583c2937b4ddba942d13acdcb924", "committedDate": "2020-01-27T14:49:09Z", "message": "Fixed copyright problems."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f3d456af7a3a289a189774cddfe5c51d009dcbb4", "author": {"user": {"login": "spericas", "name": "Santiago Pericasgeertsen"}}, "url": "https://github.com/oracle/helidon/commit/f3d456af7a3a289a189774cddfe5c51d009dcbb4", "committedDate": "2020-01-27T19:15:05Z", "message": "Make @ServerEndpoint annotation a bean-defining annotation in CDI so that scanning discovers endpoints even if not annotated with a CDI scope. This is the same we currently do for @Path in JAX-RS. Simplified example a bit."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1e343ecbe8ceac340d02142ca53c27672fea76d4", "author": {"user": {"login": "spericas", "name": "Santiago Pericasgeertsen"}}, "url": "https://github.com/oracle/helidon/commit/1e343ecbe8ceac340d02142ca53c27672fea76d4", "committedDate": "2020-01-28T14:53:38Z", "message": "New Helidon SE example that uses the WebSocket programmatic API."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8c4a878216ca536d08c583653a02e8e28da33f3e", "author": {"user": {"login": "spericas", "name": "Santiago Pericasgeertsen"}}, "url": "https://github.com/oracle/helidon/commit/8c4a878216ca536d08c583653a02e8e28da33f3e", "committedDate": "2020-01-28T15:20:03Z", "message": "Merging with master.\n\nSigned-off-by: Santiago Pericas-Geertsen <santiago.pericasgeertsen@oracle.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4ea25ce005511f8488665dabf8f9ec28565372fe", "author": {"user": {"login": "spericas", "name": "Santiago Pericasgeertsen"}}, "url": "https://github.com/oracle/helidon/commit/4ea25ce005511f8488665dabf8f9ec28565372fe", "committedDate": "2020-01-29T16:59:47Z", "message": "Initial doc for websocket support in Helidon SE and MP.\n\nSigned-off-by: Santiago Pericas-Geertsen <santiago.pericasgeertsen@oracle.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d6e23e8273a9eee9dad35c1234350dcaeeedec8c", "author": {"user": {"login": "spericas", "name": "Santiago Pericasgeertsen"}}, "url": "https://github.com/oracle/helidon/commit/d6e23e8273a9eee9dad35c1234350dcaeeedec8c", "committedDate": "2020-01-29T18:26:19Z", "message": "Fixed copyright.\n\nSigned-off-by: Santiago Pericas-Geertsen <santiago.pericasgeertsen@oracle.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "22865ca8d7a4607769e9a42a1d34481fdbf2872f", "author": {"user": {"login": "spericas", "name": "Santiago Pericasgeertsen"}}, "url": "https://github.com/oracle/helidon/commit/22865ca8d7a4607769e9a42a1d34481fdbf2872f", "committedDate": "2020-01-30T16:22:15Z", "message": "Dropped support @ApplicationPath on websocket classes in favor of @RoutingPath/@RoutingName."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "71e4f442143fa8c954648dbef4521987052d6cc9", "author": {"user": {"login": "spericas", "name": "Santiago Pericasgeertsen"}}, "url": "https://github.com/oracle/helidon/commit/71e4f442143fa8c954648dbef4521987052d6cc9", "committedDate": "2020-01-30T22:34:36Z", "message": "Initial support for executor services in Helidon MP. In MP, websocket endpoint methods are no longer called using Netty threads."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "70e696eeca2dc8e76720ee9a17acfa6ac617b308", "author": {"user": {"login": "spericas", "name": "Santiago Pericasgeertsen"}}, "url": "https://github.com/oracle/helidon/commit/70e696eeca2dc8e76720ee9a17acfa6ac617b308", "committedDate": "2020-01-31T13:20:28Z", "message": "Updated tests to verify threads in which endpoint methods are called."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0d0e215cfb326c55d421d679515926ec947caa61", "author": {"user": {"login": "spericas", "name": "Santiago Pericasgeertsen"}}, "url": "https://github.com/oracle/helidon/commit/0d0e215cfb326c55d421d679515926ec947caa61", "committedDate": "2020-01-31T13:39:35Z", "message": "Updated docs explaining websocket threading model for SE and MP."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUyMTg3MjIw", "url": "https://github.com/oracle/helidon/pull/1280#pullrequestreview-352187220", "createdAt": "2020-02-03T11:28:10Z", "commit": {"oid": "0d0e215cfb326c55d421d679515926ec947caa61"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QxMToyODoxMVrOFkuTAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QxMTo0NjoxOVrOFkuvUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA1MTU4NQ==", "bodyText": "I do not think the .flavor() method is good. We do not control the time when the flavor is configured and this is not the intention (HelidonFeatures task is to list features of Helidon, not to handle the flavor of Helidon).\nAlso the approach for thread pools is to use one of the existing ThreadPoolSupplier classes, that already handle lazy initiialization.\nIf you do not need an executor in SE, than why is this method in this class? It should be in the CDI extension for WebSockets, and the TyrusSupport class should only provider features to handle the SE model (with capability to build the MP model on top of it).", "url": "https://github.com/oracle/helidon/pull/1280#discussion_r374051585", "createdAt": "2020-02-03T11:28:11Z", "author": {"login": "tomas-langer"}, "path": "webserver/tyrus/src/main/java/io/helidon/webserver/tyrus/TyrusSupport.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.webserver.tyrus;\n+\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.logging.Logger;\n+\n+import javax.websocket.DeploymentException;\n+import javax.websocket.server.HandshakeRequest;\n+import javax.websocket.server.ServerEndpointConfig;\n+\n+import io.helidon.common.HelidonFeatures;\n+import io.helidon.common.HelidonFlavor;\n+import io.helidon.common.configurable.ServerThreadPoolSupplier;\n+import io.helidon.common.context.Contexts;\n+import io.helidon.config.Config;\n+import io.helidon.webserver.Handler;\n+import io.helidon.webserver.Routing;\n+import io.helidon.webserver.ServerRequest;\n+import io.helidon.webserver.ServerResponse;\n+import io.helidon.webserver.Service;\n+\n+import org.eclipse.microprofile.config.ConfigProvider;\n+import org.glassfish.tyrus.core.RequestContext;\n+import org.glassfish.tyrus.core.TyrusUpgradeResponse;\n+import org.glassfish.tyrus.core.TyrusWebSocketEngine;\n+import org.glassfish.tyrus.server.TyrusServerContainer;\n+import org.glassfish.tyrus.spi.Connection;\n+import org.glassfish.tyrus.spi.WebSocketEngine;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+/**\n+ * Class TyrusSupport implemented as a Helidon service.\n+ */\n+public class TyrusSupport implements Service {\n+    private static final Logger LOGGER = Logger.getLogger(TyrusSupport.class.getName());\n+\n+    /**\n+     * A zero-length buffer indicates a connection flush to Helidon.\n+     */\n+    private static final ByteBuffer FLUSH_BUFFER = ByteBuffer.allocateDirect(0);\n+\n+    private static final AtomicReference<ExecutorService> DEFAULT_THREAD_POOL = new AtomicReference<>();\n+\n+    private final WebSocketEngine engine;\n+    private final TyrusHandler handler = new TyrusHandler();\n+    private Set<Class<?>> endpointClasses;\n+    private Set<ServerEndpointConfig> endpointConfigs;\n+    private ExecutorService executorService;\n+\n+    TyrusSupport(WebSocketEngine engine, Set<Class<?>> endpointClasses, Set<ServerEndpointConfig> endpointConfigs) {\n+        this.engine = engine;\n+        this.endpointClasses = endpointClasses;\n+        this.endpointConfigs = endpointConfigs;\n+        this.executorService = createExecutorService();\n+        if (this.executorService != null) {\n+            this.executorService = Contexts.wrap(this.executorService);\n+        }\n+    }\n+\n+    /**\n+     * Register our WebSocket handler for all routes. Once a request is received,\n+     * it will be forwarded to the next handler if not a protocol upgrade request.\n+     *\n+     * @param routingRules Routing rules to update.\n+     */\n+    @Override\n+    public void update(Routing.Rules routingRules) {\n+        LOGGER.info(\"Updating TyrusSupport routing routes\");\n+        routingRules.any(handler);\n+    }\n+\n+    /**\n+     * Access to endpoint classes.\n+     *\n+     * @return Immutable set of end endpoint classes.\n+     */\n+    public Set<Class<?>> endpointClasses() {\n+        return Collections.unmodifiableSet(endpointClasses);\n+    }\n+\n+    /**\n+     * Access to endpoint configs.\n+     *\n+     * @return Immutable set of end endpoint configs.\n+     */\n+    public Set<ServerEndpointConfig> endpointConfigs() {\n+        return Collections.unmodifiableSet(endpointConfigs);\n+    }\n+\n+    /**\n+     * Creates a builder for this class.\n+     *\n+     * @return A builder for this class.\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    /**\n+     * Builder for convenient way to create {@link TyrusSupport}.\n+     */\n+    public static final class Builder implements io.helidon.common.Builder<TyrusSupport> {\n+\n+        private Set<Class<?>> endpointClasses = new HashSet<>();\n+        private Set<ServerEndpointConfig> endpointConfigs = new HashSet<>();\n+\n+        private Builder() {\n+        }\n+\n+        /**\n+         * Register an endpoint class.\n+         *\n+         * @param endpointClass The class.\n+         * @return The builder.\n+         */\n+        public Builder register(Class<?> endpointClass) {\n+            endpointClasses.add(endpointClass);\n+            return this;\n+        }\n+\n+        /**\n+         * Register an endpoint config.\n+         *\n+         * @param endpointConfig The endpoint config.\n+         * @return The builder.\n+         */\n+        public Builder register(ServerEndpointConfig endpointConfig) {\n+            endpointConfigs.add(endpointConfig);\n+            return this;\n+        }\n+\n+        @Override\n+        public TyrusSupport build() {\n+            // Create container and WebSocket engine\n+            TyrusServerContainer serverContainer = new TyrusServerContainer(endpointClasses) {\n+                private final WebSocketEngine engine =\n+                        TyrusWebSocketEngine.builder(this).build();\n+\n+                @Override\n+                public void register(Class<?> endpointClass) {\n+                    throw new UnsupportedOperationException(\"Use TyrusWebSocketEngine for registration\");\n+                }\n+\n+                @Override\n+                public void register(ServerEndpointConfig serverEndpointConfig) {\n+                    throw new UnsupportedOperationException(\"Use TyrusWebSocketEngine for registration\");\n+                }\n+\n+                @Override\n+                public WebSocketEngine getWebSocketEngine() {\n+                    return engine;\n+                }\n+            };\n+\n+            // Register classes with context path \"/\"\n+            WebSocketEngine engine = serverContainer.getWebSocketEngine();\n+            endpointClasses.forEach(c -> {\n+                try {\n+                    // Context path handled by Helidon based on app's routes\n+                    engine.register(c, \"/\");\n+                } catch (DeploymentException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            });\n+            endpointConfigs.forEach(c -> {\n+                try {\n+                    // Context path handled by Helidon based on app's routes\n+                    engine.register(c, \"/\");\n+                } catch (DeploymentException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            });\n+\n+            // Create TyrusSupport using WebSocket engine\n+            return new TyrusSupport(serverContainer.getWebSocketEngine(), endpointClasses, endpointConfigs);\n+        }\n+    }\n+\n+    /**\n+     * Creates executor service for Websocket in MP. No executor for SE.\n+     *\n+     * @return Executor service or {@code null}.\n+     */\n+    private static ExecutorService createExecutorService() {\n+        if (HelidonFeatures.flavor() == HelidonFlavor.MP && DEFAULT_THREAD_POOL.get() == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d0e215cfb326c55d421d679515926ec947caa61"}, "originalPosition": 210}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA1MTk4MA==", "bodyText": "Please use Optional.isEmpty()", "url": "https://github.com/oracle/helidon/pull/1280#discussion_r374051980", "createdAt": "2020-02-03T11:29:08Z", "author": {"login": "tomas-langer"}, "path": "webserver/tyrus/src/main/java/io/helidon/webserver/tyrus/TyrusSupport.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.webserver.tyrus;\n+\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.logging.Logger;\n+\n+import javax.websocket.DeploymentException;\n+import javax.websocket.server.HandshakeRequest;\n+import javax.websocket.server.ServerEndpointConfig;\n+\n+import io.helidon.common.HelidonFeatures;\n+import io.helidon.common.HelidonFlavor;\n+import io.helidon.common.configurable.ServerThreadPoolSupplier;\n+import io.helidon.common.context.Contexts;\n+import io.helidon.config.Config;\n+import io.helidon.webserver.Handler;\n+import io.helidon.webserver.Routing;\n+import io.helidon.webserver.ServerRequest;\n+import io.helidon.webserver.ServerResponse;\n+import io.helidon.webserver.Service;\n+\n+import org.eclipse.microprofile.config.ConfigProvider;\n+import org.glassfish.tyrus.core.RequestContext;\n+import org.glassfish.tyrus.core.TyrusUpgradeResponse;\n+import org.glassfish.tyrus.core.TyrusWebSocketEngine;\n+import org.glassfish.tyrus.server.TyrusServerContainer;\n+import org.glassfish.tyrus.spi.Connection;\n+import org.glassfish.tyrus.spi.WebSocketEngine;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+/**\n+ * Class TyrusSupport implemented as a Helidon service.\n+ */\n+public class TyrusSupport implements Service {\n+    private static final Logger LOGGER = Logger.getLogger(TyrusSupport.class.getName());\n+\n+    /**\n+     * A zero-length buffer indicates a connection flush to Helidon.\n+     */\n+    private static final ByteBuffer FLUSH_BUFFER = ByteBuffer.allocateDirect(0);\n+\n+    private static final AtomicReference<ExecutorService> DEFAULT_THREAD_POOL = new AtomicReference<>();\n+\n+    private final WebSocketEngine engine;\n+    private final TyrusHandler handler = new TyrusHandler();\n+    private Set<Class<?>> endpointClasses;\n+    private Set<ServerEndpointConfig> endpointConfigs;\n+    private ExecutorService executorService;\n+\n+    TyrusSupport(WebSocketEngine engine, Set<Class<?>> endpointClasses, Set<ServerEndpointConfig> endpointConfigs) {\n+        this.engine = engine;\n+        this.endpointClasses = endpointClasses;\n+        this.endpointConfigs = endpointConfigs;\n+        this.executorService = createExecutorService();\n+        if (this.executorService != null) {\n+            this.executorService = Contexts.wrap(this.executorService);\n+        }\n+    }\n+\n+    /**\n+     * Register our WebSocket handler for all routes. Once a request is received,\n+     * it will be forwarded to the next handler if not a protocol upgrade request.\n+     *\n+     * @param routingRules Routing rules to update.\n+     */\n+    @Override\n+    public void update(Routing.Rules routingRules) {\n+        LOGGER.info(\"Updating TyrusSupport routing routes\");\n+        routingRules.any(handler);\n+    }\n+\n+    /**\n+     * Access to endpoint classes.\n+     *\n+     * @return Immutable set of end endpoint classes.\n+     */\n+    public Set<Class<?>> endpointClasses() {\n+        return Collections.unmodifiableSet(endpointClasses);\n+    }\n+\n+    /**\n+     * Access to endpoint configs.\n+     *\n+     * @return Immutable set of end endpoint configs.\n+     */\n+    public Set<ServerEndpointConfig> endpointConfigs() {\n+        return Collections.unmodifiableSet(endpointConfigs);\n+    }\n+\n+    /**\n+     * Creates a builder for this class.\n+     *\n+     * @return A builder for this class.\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    /**\n+     * Builder for convenient way to create {@link TyrusSupport}.\n+     */\n+    public static final class Builder implements io.helidon.common.Builder<TyrusSupport> {\n+\n+        private Set<Class<?>> endpointClasses = new HashSet<>();\n+        private Set<ServerEndpointConfig> endpointConfigs = new HashSet<>();\n+\n+        private Builder() {\n+        }\n+\n+        /**\n+         * Register an endpoint class.\n+         *\n+         * @param endpointClass The class.\n+         * @return The builder.\n+         */\n+        public Builder register(Class<?> endpointClass) {\n+            endpointClasses.add(endpointClass);\n+            return this;\n+        }\n+\n+        /**\n+         * Register an endpoint config.\n+         *\n+         * @param endpointConfig The endpoint config.\n+         * @return The builder.\n+         */\n+        public Builder register(ServerEndpointConfig endpointConfig) {\n+            endpointConfigs.add(endpointConfig);\n+            return this;\n+        }\n+\n+        @Override\n+        public TyrusSupport build() {\n+            // Create container and WebSocket engine\n+            TyrusServerContainer serverContainer = new TyrusServerContainer(endpointClasses) {\n+                private final WebSocketEngine engine =\n+                        TyrusWebSocketEngine.builder(this).build();\n+\n+                @Override\n+                public void register(Class<?> endpointClass) {\n+                    throw new UnsupportedOperationException(\"Use TyrusWebSocketEngine for registration\");\n+                }\n+\n+                @Override\n+                public void register(ServerEndpointConfig serverEndpointConfig) {\n+                    throw new UnsupportedOperationException(\"Use TyrusWebSocketEngine for registration\");\n+                }\n+\n+                @Override\n+                public WebSocketEngine getWebSocketEngine() {\n+                    return engine;\n+                }\n+            };\n+\n+            // Register classes with context path \"/\"\n+            WebSocketEngine engine = serverContainer.getWebSocketEngine();\n+            endpointClasses.forEach(c -> {\n+                try {\n+                    // Context path handled by Helidon based on app's routes\n+                    engine.register(c, \"/\");\n+                } catch (DeploymentException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            });\n+            endpointConfigs.forEach(c -> {\n+                try {\n+                    // Context path handled by Helidon based on app's routes\n+                    engine.register(c, \"/\");\n+                } catch (DeploymentException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            });\n+\n+            // Create TyrusSupport using WebSocket engine\n+            return new TyrusSupport(serverContainer.getWebSocketEngine(), endpointClasses, endpointConfigs);\n+        }\n+    }\n+\n+    /**\n+     * Creates executor service for Websocket in MP. No executor for SE.\n+     *\n+     * @return Executor service or {@code null}.\n+     */\n+    private static ExecutorService createExecutorService() {\n+        if (HelidonFeatures.flavor() == HelidonFlavor.MP && DEFAULT_THREAD_POOL.get() == null) {\n+            Config executorConfig = ((Config) ConfigProvider.getConfig())\n+                    .get(\"websocket.executor-service\");\n+\n+            DEFAULT_THREAD_POOL.set(ServerThreadPoolSupplier.builder()\n+                    .name(\"websocket\")\n+                    .config(executorConfig)\n+                    .build()\n+                    .get());\n+        }\n+        return DEFAULT_THREAD_POOL.get();\n+    }\n+\n+    /**\n+     * A Helidon handler that integrates with Tyrus and can process WebSocket\n+     * upgrade requests.\n+     */\n+    private class TyrusHandler implements Handler {\n+\n+        /**\n+         * Process a server request/response.\n+         *\n+         * @param req an HTTP server request.\n+         * @param res an HTTP server response.\n+         */\n+        @Override\n+        public void accept(ServerRequest req, ServerResponse res) {\n+            // Skip this handler if not an upgrade request\n+            Optional<String> secWebSocketKey = req.headers().value(HandshakeRequest.SEC_WEBSOCKET_KEY);\n+            if (!secWebSocketKey.isPresent()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d0e215cfb326c55d421d679515926ec947caa61"}, "originalPosition": 239}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA1MjM5NQ==", "bodyText": "use req.headers().toMap().forEach((key, value) -> ...)", "url": "https://github.com/oracle/helidon/pull/1280#discussion_r374052395", "createdAt": "2020-02-03T11:30:11Z", "author": {"login": "tomas-langer"}, "path": "webserver/tyrus/src/main/java/io/helidon/webserver/tyrus/TyrusSupport.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.webserver.tyrus;\n+\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.logging.Logger;\n+\n+import javax.websocket.DeploymentException;\n+import javax.websocket.server.HandshakeRequest;\n+import javax.websocket.server.ServerEndpointConfig;\n+\n+import io.helidon.common.HelidonFeatures;\n+import io.helidon.common.HelidonFlavor;\n+import io.helidon.common.configurable.ServerThreadPoolSupplier;\n+import io.helidon.common.context.Contexts;\n+import io.helidon.config.Config;\n+import io.helidon.webserver.Handler;\n+import io.helidon.webserver.Routing;\n+import io.helidon.webserver.ServerRequest;\n+import io.helidon.webserver.ServerResponse;\n+import io.helidon.webserver.Service;\n+\n+import org.eclipse.microprofile.config.ConfigProvider;\n+import org.glassfish.tyrus.core.RequestContext;\n+import org.glassfish.tyrus.core.TyrusUpgradeResponse;\n+import org.glassfish.tyrus.core.TyrusWebSocketEngine;\n+import org.glassfish.tyrus.server.TyrusServerContainer;\n+import org.glassfish.tyrus.spi.Connection;\n+import org.glassfish.tyrus.spi.WebSocketEngine;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+/**\n+ * Class TyrusSupport implemented as a Helidon service.\n+ */\n+public class TyrusSupport implements Service {\n+    private static final Logger LOGGER = Logger.getLogger(TyrusSupport.class.getName());\n+\n+    /**\n+     * A zero-length buffer indicates a connection flush to Helidon.\n+     */\n+    private static final ByteBuffer FLUSH_BUFFER = ByteBuffer.allocateDirect(0);\n+\n+    private static final AtomicReference<ExecutorService> DEFAULT_THREAD_POOL = new AtomicReference<>();\n+\n+    private final WebSocketEngine engine;\n+    private final TyrusHandler handler = new TyrusHandler();\n+    private Set<Class<?>> endpointClasses;\n+    private Set<ServerEndpointConfig> endpointConfigs;\n+    private ExecutorService executorService;\n+\n+    TyrusSupport(WebSocketEngine engine, Set<Class<?>> endpointClasses, Set<ServerEndpointConfig> endpointConfigs) {\n+        this.engine = engine;\n+        this.endpointClasses = endpointClasses;\n+        this.endpointConfigs = endpointConfigs;\n+        this.executorService = createExecutorService();\n+        if (this.executorService != null) {\n+            this.executorService = Contexts.wrap(this.executorService);\n+        }\n+    }\n+\n+    /**\n+     * Register our WebSocket handler for all routes. Once a request is received,\n+     * it will be forwarded to the next handler if not a protocol upgrade request.\n+     *\n+     * @param routingRules Routing rules to update.\n+     */\n+    @Override\n+    public void update(Routing.Rules routingRules) {\n+        LOGGER.info(\"Updating TyrusSupport routing routes\");\n+        routingRules.any(handler);\n+    }\n+\n+    /**\n+     * Access to endpoint classes.\n+     *\n+     * @return Immutable set of end endpoint classes.\n+     */\n+    public Set<Class<?>> endpointClasses() {\n+        return Collections.unmodifiableSet(endpointClasses);\n+    }\n+\n+    /**\n+     * Access to endpoint configs.\n+     *\n+     * @return Immutable set of end endpoint configs.\n+     */\n+    public Set<ServerEndpointConfig> endpointConfigs() {\n+        return Collections.unmodifiableSet(endpointConfigs);\n+    }\n+\n+    /**\n+     * Creates a builder for this class.\n+     *\n+     * @return A builder for this class.\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    /**\n+     * Builder for convenient way to create {@link TyrusSupport}.\n+     */\n+    public static final class Builder implements io.helidon.common.Builder<TyrusSupport> {\n+\n+        private Set<Class<?>> endpointClasses = new HashSet<>();\n+        private Set<ServerEndpointConfig> endpointConfigs = new HashSet<>();\n+\n+        private Builder() {\n+        }\n+\n+        /**\n+         * Register an endpoint class.\n+         *\n+         * @param endpointClass The class.\n+         * @return The builder.\n+         */\n+        public Builder register(Class<?> endpointClass) {\n+            endpointClasses.add(endpointClass);\n+            return this;\n+        }\n+\n+        /**\n+         * Register an endpoint config.\n+         *\n+         * @param endpointConfig The endpoint config.\n+         * @return The builder.\n+         */\n+        public Builder register(ServerEndpointConfig endpointConfig) {\n+            endpointConfigs.add(endpointConfig);\n+            return this;\n+        }\n+\n+        @Override\n+        public TyrusSupport build() {\n+            // Create container and WebSocket engine\n+            TyrusServerContainer serverContainer = new TyrusServerContainer(endpointClasses) {\n+                private final WebSocketEngine engine =\n+                        TyrusWebSocketEngine.builder(this).build();\n+\n+                @Override\n+                public void register(Class<?> endpointClass) {\n+                    throw new UnsupportedOperationException(\"Use TyrusWebSocketEngine for registration\");\n+                }\n+\n+                @Override\n+                public void register(ServerEndpointConfig serverEndpointConfig) {\n+                    throw new UnsupportedOperationException(\"Use TyrusWebSocketEngine for registration\");\n+                }\n+\n+                @Override\n+                public WebSocketEngine getWebSocketEngine() {\n+                    return engine;\n+                }\n+            };\n+\n+            // Register classes with context path \"/\"\n+            WebSocketEngine engine = serverContainer.getWebSocketEngine();\n+            endpointClasses.forEach(c -> {\n+                try {\n+                    // Context path handled by Helidon based on app's routes\n+                    engine.register(c, \"/\");\n+                } catch (DeploymentException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            });\n+            endpointConfigs.forEach(c -> {\n+                try {\n+                    // Context path handled by Helidon based on app's routes\n+                    engine.register(c, \"/\");\n+                } catch (DeploymentException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            });\n+\n+            // Create TyrusSupport using WebSocket engine\n+            return new TyrusSupport(serverContainer.getWebSocketEngine(), endpointClasses, endpointConfigs);\n+        }\n+    }\n+\n+    /**\n+     * Creates executor service for Websocket in MP. No executor for SE.\n+     *\n+     * @return Executor service or {@code null}.\n+     */\n+    private static ExecutorService createExecutorService() {\n+        if (HelidonFeatures.flavor() == HelidonFlavor.MP && DEFAULT_THREAD_POOL.get() == null) {\n+            Config executorConfig = ((Config) ConfigProvider.getConfig())\n+                    .get(\"websocket.executor-service\");\n+\n+            DEFAULT_THREAD_POOL.set(ServerThreadPoolSupplier.builder()\n+                    .name(\"websocket\")\n+                    .config(executorConfig)\n+                    .build()\n+                    .get());\n+        }\n+        return DEFAULT_THREAD_POOL.get();\n+    }\n+\n+    /**\n+     * A Helidon handler that integrates with Tyrus and can process WebSocket\n+     * upgrade requests.\n+     */\n+    private class TyrusHandler implements Handler {\n+\n+        /**\n+         * Process a server request/response.\n+         *\n+         * @param req an HTTP server request.\n+         * @param res an HTTP server response.\n+         */\n+        @Override\n+        public void accept(ServerRequest req, ServerResponse res) {\n+            // Skip this handler if not an upgrade request\n+            Optional<String> secWebSocketKey = req.headers().value(HandshakeRequest.SEC_WEBSOCKET_KEY);\n+            if (!secWebSocketKey.isPresent()) {\n+                req.next();\n+                return;\n+            }\n+\n+            LOGGER.fine(\"Initiating WebSocket handshake ...\");\n+\n+            // Create Tyrus request context and copy request headers\n+            RequestContext requestContext = RequestContext.Builder.create()\n+                    .requestURI(URI.create(req.path().toString()))      // excludes context path\n+                    .build();\n+            req.headers().toMap().entrySet().forEach(e ->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d0e215cfb326c55d421d679515926ec947caa61"}, "originalPosition": 250}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA1MzI3Ng==", "bodyText": "I am not sure I understand this - why do you use an executor service, when you call get on the result? You are blocking the current thread anyways, why not just call the statement directly?\nAlso this seems to be an issue for our WebServer, as you should never block", "url": "https://github.com/oracle/helidon/pull/1280#discussion_r374053276", "createdAt": "2020-02-03T11:32:25Z", "author": {"login": "tomas-langer"}, "path": "webserver/tyrus/src/main/java/io/helidon/webserver/tyrus/TyrusSupport.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.webserver.tyrus;\n+\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.logging.Logger;\n+\n+import javax.websocket.DeploymentException;\n+import javax.websocket.server.HandshakeRequest;\n+import javax.websocket.server.ServerEndpointConfig;\n+\n+import io.helidon.common.HelidonFeatures;\n+import io.helidon.common.HelidonFlavor;\n+import io.helidon.common.configurable.ServerThreadPoolSupplier;\n+import io.helidon.common.context.Contexts;\n+import io.helidon.config.Config;\n+import io.helidon.webserver.Handler;\n+import io.helidon.webserver.Routing;\n+import io.helidon.webserver.ServerRequest;\n+import io.helidon.webserver.ServerResponse;\n+import io.helidon.webserver.Service;\n+\n+import org.eclipse.microprofile.config.ConfigProvider;\n+import org.glassfish.tyrus.core.RequestContext;\n+import org.glassfish.tyrus.core.TyrusUpgradeResponse;\n+import org.glassfish.tyrus.core.TyrusWebSocketEngine;\n+import org.glassfish.tyrus.server.TyrusServerContainer;\n+import org.glassfish.tyrus.spi.Connection;\n+import org.glassfish.tyrus.spi.WebSocketEngine;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+/**\n+ * Class TyrusSupport implemented as a Helidon service.\n+ */\n+public class TyrusSupport implements Service {\n+    private static final Logger LOGGER = Logger.getLogger(TyrusSupport.class.getName());\n+\n+    /**\n+     * A zero-length buffer indicates a connection flush to Helidon.\n+     */\n+    private static final ByteBuffer FLUSH_BUFFER = ByteBuffer.allocateDirect(0);\n+\n+    private static final AtomicReference<ExecutorService> DEFAULT_THREAD_POOL = new AtomicReference<>();\n+\n+    private final WebSocketEngine engine;\n+    private final TyrusHandler handler = new TyrusHandler();\n+    private Set<Class<?>> endpointClasses;\n+    private Set<ServerEndpointConfig> endpointConfigs;\n+    private ExecutorService executorService;\n+\n+    TyrusSupport(WebSocketEngine engine, Set<Class<?>> endpointClasses, Set<ServerEndpointConfig> endpointConfigs) {\n+        this.engine = engine;\n+        this.endpointClasses = endpointClasses;\n+        this.endpointConfigs = endpointConfigs;\n+        this.executorService = createExecutorService();\n+        if (this.executorService != null) {\n+            this.executorService = Contexts.wrap(this.executorService);\n+        }\n+    }\n+\n+    /**\n+     * Register our WebSocket handler for all routes. Once a request is received,\n+     * it will be forwarded to the next handler if not a protocol upgrade request.\n+     *\n+     * @param routingRules Routing rules to update.\n+     */\n+    @Override\n+    public void update(Routing.Rules routingRules) {\n+        LOGGER.info(\"Updating TyrusSupport routing routes\");\n+        routingRules.any(handler);\n+    }\n+\n+    /**\n+     * Access to endpoint classes.\n+     *\n+     * @return Immutable set of end endpoint classes.\n+     */\n+    public Set<Class<?>> endpointClasses() {\n+        return Collections.unmodifiableSet(endpointClasses);\n+    }\n+\n+    /**\n+     * Access to endpoint configs.\n+     *\n+     * @return Immutable set of end endpoint configs.\n+     */\n+    public Set<ServerEndpointConfig> endpointConfigs() {\n+        return Collections.unmodifiableSet(endpointConfigs);\n+    }\n+\n+    /**\n+     * Creates a builder for this class.\n+     *\n+     * @return A builder for this class.\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    /**\n+     * Builder for convenient way to create {@link TyrusSupport}.\n+     */\n+    public static final class Builder implements io.helidon.common.Builder<TyrusSupport> {\n+\n+        private Set<Class<?>> endpointClasses = new HashSet<>();\n+        private Set<ServerEndpointConfig> endpointConfigs = new HashSet<>();\n+\n+        private Builder() {\n+        }\n+\n+        /**\n+         * Register an endpoint class.\n+         *\n+         * @param endpointClass The class.\n+         * @return The builder.\n+         */\n+        public Builder register(Class<?> endpointClass) {\n+            endpointClasses.add(endpointClass);\n+            return this;\n+        }\n+\n+        /**\n+         * Register an endpoint config.\n+         *\n+         * @param endpointConfig The endpoint config.\n+         * @return The builder.\n+         */\n+        public Builder register(ServerEndpointConfig endpointConfig) {\n+            endpointConfigs.add(endpointConfig);\n+            return this;\n+        }\n+\n+        @Override\n+        public TyrusSupport build() {\n+            // Create container and WebSocket engine\n+            TyrusServerContainer serverContainer = new TyrusServerContainer(endpointClasses) {\n+                private final WebSocketEngine engine =\n+                        TyrusWebSocketEngine.builder(this).build();\n+\n+                @Override\n+                public void register(Class<?> endpointClass) {\n+                    throw new UnsupportedOperationException(\"Use TyrusWebSocketEngine for registration\");\n+                }\n+\n+                @Override\n+                public void register(ServerEndpointConfig serverEndpointConfig) {\n+                    throw new UnsupportedOperationException(\"Use TyrusWebSocketEngine for registration\");\n+                }\n+\n+                @Override\n+                public WebSocketEngine getWebSocketEngine() {\n+                    return engine;\n+                }\n+            };\n+\n+            // Register classes with context path \"/\"\n+            WebSocketEngine engine = serverContainer.getWebSocketEngine();\n+            endpointClasses.forEach(c -> {\n+                try {\n+                    // Context path handled by Helidon based on app's routes\n+                    engine.register(c, \"/\");\n+                } catch (DeploymentException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            });\n+            endpointConfigs.forEach(c -> {\n+                try {\n+                    // Context path handled by Helidon based on app's routes\n+                    engine.register(c, \"/\");\n+                } catch (DeploymentException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            });\n+\n+            // Create TyrusSupport using WebSocket engine\n+            return new TyrusSupport(serverContainer.getWebSocketEngine(), endpointClasses, endpointConfigs);\n+        }\n+    }\n+\n+    /**\n+     * Creates executor service for Websocket in MP. No executor for SE.\n+     *\n+     * @return Executor service or {@code null}.\n+     */\n+    private static ExecutorService createExecutorService() {\n+        if (HelidonFeatures.flavor() == HelidonFlavor.MP && DEFAULT_THREAD_POOL.get() == null) {\n+            Config executorConfig = ((Config) ConfigProvider.getConfig())\n+                    .get(\"websocket.executor-service\");\n+\n+            DEFAULT_THREAD_POOL.set(ServerThreadPoolSupplier.builder()\n+                    .name(\"websocket\")\n+                    .config(executorConfig)\n+                    .build()\n+                    .get());\n+        }\n+        return DEFAULT_THREAD_POOL.get();\n+    }\n+\n+    /**\n+     * A Helidon handler that integrates with Tyrus and can process WebSocket\n+     * upgrade requests.\n+     */\n+    private class TyrusHandler implements Handler {\n+\n+        /**\n+         * Process a server request/response.\n+         *\n+         * @param req an HTTP server request.\n+         * @param res an HTTP server response.\n+         */\n+        @Override\n+        public void accept(ServerRequest req, ServerResponse res) {\n+            // Skip this handler if not an upgrade request\n+            Optional<String> secWebSocketKey = req.headers().value(HandshakeRequest.SEC_WEBSOCKET_KEY);\n+            if (!secWebSocketKey.isPresent()) {\n+                req.next();\n+                return;\n+            }\n+\n+            LOGGER.fine(\"Initiating WebSocket handshake ...\");\n+\n+            // Create Tyrus request context and copy request headers\n+            RequestContext requestContext = RequestContext.Builder.create()\n+                    .requestURI(URI.create(req.path().toString()))      // excludes context path\n+                    .build();\n+            req.headers().toMap().entrySet().forEach(e ->\n+                    requestContext.getHeaders().put(e.getKey(), e.getValue()));\n+\n+            // Use Tyrus to process a WebSocket upgrade request\n+            final TyrusUpgradeResponse upgradeResponse = new TyrusUpgradeResponse();\n+            final WebSocketEngine.UpgradeInfo upgradeInfo = engine.upgrade(requestContext, upgradeResponse);\n+\n+            // Respond to upgrade request using response from Tyrus\n+            res.status(upgradeResponse.getStatus());\n+            upgradeResponse.getHeaders().entrySet().forEach(e ->\n+                    res.headers().add(e.getKey(), e.getValue()));\n+            TyrusWriterPublisher publisherWriter = new TyrusWriterPublisher();\n+            res.send(publisherWriter);\n+\n+            // Write reason for failure if not successful\n+            if (upgradeInfo.getStatus() != WebSocketEngine.UpgradeStatus.SUCCESS) {\n+                String reason = upgradeResponse.getReasonPhrase();\n+                if (reason != null) {\n+                    publisherWriter.write(ByteBuffer.wrap(reason.getBytes(UTF_8)), null);\n+                }\n+            }\n+\n+            // Flush upgrade response\n+            publisherWriter.write(FLUSH_BUFFER, null);\n+\n+            // Setup the WebSocket connection and internally the ReaderHandler\n+            Connection connection;\n+            if (executorService != null) {\n+                try {\n+                    // Set up connection and call @onOpen\n+                    Future<Connection> future = executorService.submit(() ->\n+                            upgradeInfo.createConnection(publisherWriter,\n+                                    closeReason -> LOGGER.fine(() -> \"Connection closed: \" + closeReason)));\n+                    connection = future.get();      // Need to sync here", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d0e215cfb326c55d421d679515926ec947caa61"}, "originalPosition": 283}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA1NTUyMw==", "bodyText": "WebSocket support should not be part of Helidon MicroProfile server.\nThis adds an unwanted dependency on Tyrus for MP implementation.\nPlease extract WebSocket support into a separate module.", "url": "https://github.com/oracle/helidon/pull/1280#discussion_r374055523", "createdAt": "2020-02-03T11:38:05Z", "author": {"login": "tomas-langer"}, "path": "microprofile/server/src/main/java/io/helidon/microprofile/server/Server.java", "diffHunk": "@@ -69,6 +71,20 @@ static Server create(Class<? extends Application>... applicationClasses) throws\n         return builder.build();\n     }\n \n+    /**\n+     * Create a server instance using a Websocket application class.\n+     *\n+     * @param applicationClass websocket application class\n+     * @return server instance to be started\n+     * @throws MpException in case the server fails to be created\n+     * @see #builder()\n+     */\n+    static Server create(Class<? extends ServerApplicationConfig> applicationClass) throws MpException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d0e215cfb326c55d421d679515926ec947caa61"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA1NTY0OA==", "bodyText": "Remove from Server. WebSocket should be handled in a separate module.", "url": "https://github.com/oracle/helidon/pull/1280#discussion_r374055648", "createdAt": "2020-02-03T11:38:27Z", "author": {"login": "tomas-langer"}, "path": "microprofile/server/src/main/java/io/helidon/microprofile/server/Server.java", "diffHunk": "@@ -366,6 +383,20 @@ public Builder addApplication(Application application) {\n             return this;\n         }\n \n+        /**\n+         * Registers a WebSocket application in the server. At most one application can be registered.\n+         *\n+         * @param wsApplication websocket application\n+         * @return modified builder\n+         */\n+        public Builder websocketApplication(Class<? extends ServerApplicationConfig> wsApplication) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d0e215cfb326c55d421d679515926ec947caa61"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA1NTg3MQ==", "bodyText": "Extract into a separate module, use WebSocketCdiExtension in that module to setup everything", "url": "https://github.com/oracle/helidon/pull/1280#discussion_r374055871", "createdAt": "2020-02-03T11:39:01Z", "author": {"login": "tomas-langer"}, "path": "microprofile/server/src/main/java/io/helidon/microprofile/server/ServerCdiExtension.java", "diffHunk": "@@ -117,6 +126,9 @@ private void startServer(@Observes @Priority(PLATFORM_AFTER + 100) @Initialized(\n         // register static content if configured\n         registerStaticContent();\n \n+        // register websocket endpoints", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d0e215cfb326c55d421d679515926ec947caa61"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA1NjE4Nw==", "bodyText": "There should be no dependency on tyrus or websocket in Helidon MP Server.", "url": "https://github.com/oracle/helidon/pull/1280#discussion_r374056187", "createdAt": "2020-02-03T11:39:53Z", "author": {"login": "tomas-langer"}, "path": "microprofile/server/src/main/java/module-info.java", "diffHunk": "@@ -38,9 +36,15 @@\n     // there is now a hardcoded dependency on Weld, to configure additional bean defining annotation\n     requires java.management;\n \n+    requires io.helidon.microprofile.tyrus;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d0e215cfb326c55d421d679515926ec947caa61"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA1Njg2Ng==", "bodyText": "Do not use info level, unless it is an information needed for every user on every startup.\nThis seems to be debug information.\nYou can list Tyrus applications in info - but only when actually registering them (e.g. by the time we have the complete list).", "url": "https://github.com/oracle/helidon/pull/1280#discussion_r374056866", "createdAt": "2020-02-03T11:41:40Z", "author": {"login": "tomas-langer"}, "path": "microprofile/tyrus/src/main/java/io/helidon/microprofile/tyrus/WebSocketCdiExtension.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.microprofile.tyrus;\n+\n+import java.util.logging.Logger;\n+\n+import javax.enterprise.event.Observes;\n+import javax.enterprise.inject.spi.Extension;\n+import javax.enterprise.inject.spi.ProcessAnnotatedType;\n+import javax.enterprise.inject.spi.WithAnnotations;\n+import javax.websocket.Endpoint;\n+import javax.websocket.server.ServerApplicationConfig;\n+import javax.websocket.server.ServerEndpoint;\n+\n+import io.helidon.common.HelidonFeatures;\n+import io.helidon.common.HelidonFlavor;\n+\n+/**\n+ * Configure Tyrus related things.\n+ */\n+public class WebSocketCdiExtension implements Extension {\n+    private static final Logger LOGGER = Logger.getLogger(WebSocketCdiExtension.class.getName());\n+\n+    static {\n+        HelidonFeatures.register(HelidonFlavor.MP, \"WebSocket\");\n+    }\n+\n+    private WebSocketApplication.Builder appBuilder = WebSocketApplication.builder();\n+\n+    /**\n+     * Collect application class extending {@code ServerApplicationConfig}.\n+     *\n+     * @param applicationClass Application class.\n+     */\n+    private void applicationClass(@Observes ProcessAnnotatedType<? extends ServerApplicationConfig> applicationClass) {\n+        LOGGER.info(() -> \"Application class found \" + applicationClass.getAnnotatedType().getJavaClass());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d0e215cfb326c55d421d679515926ec947caa61"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA1Njk3Mw==", "bodyText": "see above - do not use info level", "url": "https://github.com/oracle/helidon/pull/1280#discussion_r374056973", "createdAt": "2020-02-03T11:41:54Z", "author": {"login": "tomas-langer"}, "path": "microprofile/tyrus/src/main/java/io/helidon/microprofile/tyrus/WebSocketCdiExtension.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.microprofile.tyrus;\n+\n+import java.util.logging.Logger;\n+\n+import javax.enterprise.event.Observes;\n+import javax.enterprise.inject.spi.Extension;\n+import javax.enterprise.inject.spi.ProcessAnnotatedType;\n+import javax.enterprise.inject.spi.WithAnnotations;\n+import javax.websocket.Endpoint;\n+import javax.websocket.server.ServerApplicationConfig;\n+import javax.websocket.server.ServerEndpoint;\n+\n+import io.helidon.common.HelidonFeatures;\n+import io.helidon.common.HelidonFlavor;\n+\n+/**\n+ * Configure Tyrus related things.\n+ */\n+public class WebSocketCdiExtension implements Extension {\n+    private static final Logger LOGGER = Logger.getLogger(WebSocketCdiExtension.class.getName());\n+\n+    static {\n+        HelidonFeatures.register(HelidonFlavor.MP, \"WebSocket\");\n+    }\n+\n+    private WebSocketApplication.Builder appBuilder = WebSocketApplication.builder();\n+\n+    /**\n+     * Collect application class extending {@code ServerApplicationConfig}.\n+     *\n+     * @param applicationClass Application class.\n+     */\n+    private void applicationClass(@Observes ProcessAnnotatedType<? extends ServerApplicationConfig> applicationClass) {\n+        LOGGER.info(() -> \"Application class found \" + applicationClass.getAnnotatedType().getJavaClass());\n+        appBuilder.applicationClass(applicationClass.getAnnotatedType().getJavaClass());\n+    }\n+\n+    /**\n+     * Overrides a websocket application class.\n+     *\n+     * @param applicationClass Application class.\n+     */\n+    public void applicationClass(Class<? extends ServerApplicationConfig> applicationClass) {\n+        LOGGER.info(() -> \"Using manually set application class  \" + applicationClass);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d0e215cfb326c55d421d679515926ec947caa61"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA1NzAxMw==", "bodyText": "see above - do not use info level", "url": "https://github.com/oracle/helidon/pull/1280#discussion_r374057013", "createdAt": "2020-02-03T11:41:59Z", "author": {"login": "tomas-langer"}, "path": "microprofile/tyrus/src/main/java/io/helidon/microprofile/tyrus/WebSocketCdiExtension.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.microprofile.tyrus;\n+\n+import java.util.logging.Logger;\n+\n+import javax.enterprise.event.Observes;\n+import javax.enterprise.inject.spi.Extension;\n+import javax.enterprise.inject.spi.ProcessAnnotatedType;\n+import javax.enterprise.inject.spi.WithAnnotations;\n+import javax.websocket.Endpoint;\n+import javax.websocket.server.ServerApplicationConfig;\n+import javax.websocket.server.ServerEndpoint;\n+\n+import io.helidon.common.HelidonFeatures;\n+import io.helidon.common.HelidonFlavor;\n+\n+/**\n+ * Configure Tyrus related things.\n+ */\n+public class WebSocketCdiExtension implements Extension {\n+    private static final Logger LOGGER = Logger.getLogger(WebSocketCdiExtension.class.getName());\n+\n+    static {\n+        HelidonFeatures.register(HelidonFlavor.MP, \"WebSocket\");\n+    }\n+\n+    private WebSocketApplication.Builder appBuilder = WebSocketApplication.builder();\n+\n+    /**\n+     * Collect application class extending {@code ServerApplicationConfig}.\n+     *\n+     * @param applicationClass Application class.\n+     */\n+    private void applicationClass(@Observes ProcessAnnotatedType<? extends ServerApplicationConfig> applicationClass) {\n+        LOGGER.info(() -> \"Application class found \" + applicationClass.getAnnotatedType().getJavaClass());\n+        appBuilder.applicationClass(applicationClass.getAnnotatedType().getJavaClass());\n+    }\n+\n+    /**\n+     * Overrides a websocket application class.\n+     *\n+     * @param applicationClass Application class.\n+     */\n+    public void applicationClass(Class<? extends ServerApplicationConfig> applicationClass) {\n+        LOGGER.info(() -> \"Using manually set application class  \" + applicationClass);\n+        appBuilder.updateApplicationClass(applicationClass);\n+    }\n+\n+    /**\n+     * Collect annotated endpoints.\n+     *\n+     * @param endpoint The endpoint.\n+     */\n+    private void endpointClasses(@Observes @WithAnnotations(ServerEndpoint.class) ProcessAnnotatedType<?> endpoint) {\n+        LOGGER.info(() -> \"Annotated endpoint found \" + endpoint.getAnnotatedType().getJavaClass());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d0e215cfb326c55d421d679515926ec947caa61"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA1NzA1NA==", "bodyText": "see above - do not use info level", "url": "https://github.com/oracle/helidon/pull/1280#discussion_r374057054", "createdAt": "2020-02-03T11:42:04Z", "author": {"login": "tomas-langer"}, "path": "microprofile/tyrus/src/main/java/io/helidon/microprofile/tyrus/WebSocketCdiExtension.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.microprofile.tyrus;\n+\n+import java.util.logging.Logger;\n+\n+import javax.enterprise.event.Observes;\n+import javax.enterprise.inject.spi.Extension;\n+import javax.enterprise.inject.spi.ProcessAnnotatedType;\n+import javax.enterprise.inject.spi.WithAnnotations;\n+import javax.websocket.Endpoint;\n+import javax.websocket.server.ServerApplicationConfig;\n+import javax.websocket.server.ServerEndpoint;\n+\n+import io.helidon.common.HelidonFeatures;\n+import io.helidon.common.HelidonFlavor;\n+\n+/**\n+ * Configure Tyrus related things.\n+ */\n+public class WebSocketCdiExtension implements Extension {\n+    private static final Logger LOGGER = Logger.getLogger(WebSocketCdiExtension.class.getName());\n+\n+    static {\n+        HelidonFeatures.register(HelidonFlavor.MP, \"WebSocket\");\n+    }\n+\n+    private WebSocketApplication.Builder appBuilder = WebSocketApplication.builder();\n+\n+    /**\n+     * Collect application class extending {@code ServerApplicationConfig}.\n+     *\n+     * @param applicationClass Application class.\n+     */\n+    private void applicationClass(@Observes ProcessAnnotatedType<? extends ServerApplicationConfig> applicationClass) {\n+        LOGGER.info(() -> \"Application class found \" + applicationClass.getAnnotatedType().getJavaClass());\n+        appBuilder.applicationClass(applicationClass.getAnnotatedType().getJavaClass());\n+    }\n+\n+    /**\n+     * Overrides a websocket application class.\n+     *\n+     * @param applicationClass Application class.\n+     */\n+    public void applicationClass(Class<? extends ServerApplicationConfig> applicationClass) {\n+        LOGGER.info(() -> \"Using manually set application class  \" + applicationClass);\n+        appBuilder.updateApplicationClass(applicationClass);\n+    }\n+\n+    /**\n+     * Collect annotated endpoints.\n+     *\n+     * @param endpoint The endpoint.\n+     */\n+    private void endpointClasses(@Observes @WithAnnotations(ServerEndpoint.class) ProcessAnnotatedType<?> endpoint) {\n+        LOGGER.info(() -> \"Annotated endpoint found \" + endpoint.getAnnotatedType().getJavaClass());\n+        appBuilder.annotatedEndpoint(endpoint.getAnnotatedType().getJavaClass());\n+    }\n+\n+    /**\n+     * Collects programmatic endpoints .\n+     *\n+     * @param endpoint The endpoint.\n+     */\n+    private void endpointConfig(@Observes ProcessAnnotatedType<? extends Endpoint> endpoint) {\n+        LOGGER.info(() -> \"Programmatic endpoint found \" + endpoint.getAnnotatedType().getJavaClass());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d0e215cfb326c55d421d679515926ec947caa61"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA1ODgzMg==", "bodyText": "This looks like a candidate for finest, not fine.\nAlso when constructing a message in log levels lower than info, please use lambda:\nLOGGER.finest(() -> \"...\"  + msg); to avoid string concatenation on every single byte buffer received", "url": "https://github.com/oracle/helidon/pull/1280#discussion_r374058832", "createdAt": "2020-02-03T11:46:19Z", "author": {"login": "tomas-langer"}, "path": "webserver/webserver/src/main/java/io/helidon/webserver/ForwardingHandler.java", "diffHunk": "@@ -178,14 +198,49 @@ protected void channelRead0(ChannelHandlerContext ctx, Object msg) {\n             }\n \n             if (msg instanceof LastHttpContent) {\n-                requestContext.publisher().complete();\n-                requestContext = null; // just to be sure that current http req/res session doesn't interfere with other ones\n+                if (!isWebSocketUpgrade) {\n+                    requestContext.publisher().complete();\n+                    requestContext = null; // just to be sure that current http req/res session doesn't interfere with other ones\n+                }\n             } else if (!content.isReadable()) {\n                 // this is here to handle the case when the content is not readable but we didn't\n                 // exceptionally complete the publisher and close the connection\n                 throw new IllegalStateException(\"It is not expected to not have readable content.\");\n             }\n         }\n+\n+        // We receive a raw bytebuf if connection was upgraded to WebSockets\n+        if (msg instanceof ByteBuf) {\n+            if (!isWebSocketUpgrade) {\n+                throw new IllegalStateException(\"Received ByteBuf without upgrading to WebSockets\");\n+            }\n+            // Simply forward raw bytebuf to Tyrus for processing\n+            LOGGER.fine(\"Received ByteBuf of WebSockets connection\" + msg);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d0e215cfb326c55d421d679515926ec947caa61"}, "originalPosition": 101}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3e2d7867d805a388237d46ddcb599bbd1151a65f", "author": {"user": {"login": "spericas", "name": "Santiago Pericasgeertsen"}}, "url": "https://github.com/oracle/helidon/commit/3e2d7867d805a388237d46ddcb599bbd1151a65f", "committedDate": "2020-02-04T14:22:39Z", "message": "Minor improvements and fixes to logging calls."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0f9a2f5df5d17400278e03affc5c1dc9a5bf24f6", "author": {"user": {"login": "spericas", "name": "Santiago Pericasgeertsen"}}, "url": "https://github.com/oracle/helidon/commit/0f9a2f5df5d17400278e03affc5c1dc9a5bf24f6", "committedDate": "2020-02-04T15:09:27Z", "message": "Ensure Netty's thread is not blocked when setting up a connection in MP."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "09534885d4a6b362a86dcb78b1fb298a57bdcf14", "author": {"user": {"login": "spericas", "name": "Santiago Pericasgeertsen"}}, "url": "https://github.com/oracle/helidon/commit/09534885d4a6b362a86dcb78b1fb298a57bdcf14", "committedDate": "2020-02-04T15:13:54Z", "message": "Fixed checkstyle.\n\nSigned-off-by: Santiago Pericas-Geertsen <santiago.pericasgeertsen@oracle.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "946db23e8bbcfa6b3acd4c812ec30e6942915d83", "author": {"user": {"login": "spericas", "name": "Santiago Pericasgeertsen"}}, "url": "https://github.com/oracle/helidon/commit/946db23e8bbcfa6b3acd4c812ec30e6942915d83", "committedDate": "2020-02-05T20:50:15Z", "message": "Re-shuffled code to remove dependency with websockets API and Tyrus in microprofile's server module. Use CDI events between modules for loose coupling."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "363e5b91d0bf94d209c8d129626adfa06d12b047", "author": {"user": {"login": "spericas", "name": "Santiago Pericasgeertsen"}}, "url": "https://github.com/oracle/helidon/commit/363e5b91d0bf94d209c8d129626adfa06d12b047", "committedDate": "2020-02-06T16:49:17Z", "message": "Dropped support for websockets in Server.Builder. Created subclass for TyrusSupport in MP. Fixed tests."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8f6051e8ed26f8c487fbb6c0d4dd0c2467b16d4e", "author": {"user": {"login": "spericas", "name": "Santiago Pericasgeertsen"}}, "url": "https://github.com/oracle/helidon/commit/8f6051e8ed26f8c487fbb6c0d4dd0c2467b16d4e", "committedDate": "2020-02-06T18:32:44Z", "message": "Fixed spotbugs error."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3d874d67744cdaa957d2cd02dd4171b610ec0c75", "author": {"user": {"login": "spericas", "name": "Santiago Pericasgeertsen"}}, "url": "https://github.com/oracle/helidon/commit/3d874d67744cdaa957d2cd02dd4171b610ec0c75", "committedDate": "2020-02-07T13:20:40Z", "message": "Removed unused method and updated docs."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9515f52ec7e283728774e0c7be692fb9195734f0", "author": {"user": {"login": "spericas", "name": "Santiago Pericasgeertsen"}}, "url": "https://github.com/oracle/helidon/commit/9515f52ec7e283728774e0c7be692fb9195734f0", "committedDate": "2020-02-07T13:28:25Z", "message": "Removed unused class."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1456226e7215eef56cf1926b2f0208ef74625472", "author": {"user": {"login": "spericas", "name": "Santiago Pericasgeertsen"}}, "url": "https://github.com/oracle/helidon/commit/1456226e7215eef56cf1926b2f0208ef74625472", "committedDate": "2020-02-13T14:41:56Z", "message": "Renamed module from tyrus to websocket. Restored transitive dependencies in MP server.\n\nSigned-off-by: Santiago Pericas-Geertsen <santiago.pericasgeertsen@oracle.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2c399f3abd869873024f13f8930d90456bf2c2ed", "author": {"user": {"login": "spericas", "name": "Santiago Pericasgeertsen"}}, "url": "https://github.com/oracle/helidon/commit/2c399f3abd869873024f13f8930d90456bf2c2ed", "committedDate": "2020-02-13T14:33:09Z", "message": "Renamed module from tyrus to websocket. Restored transitive dependencies in MP server.\n\nSigned-off-by: Santiago Pericas-Geertsen <santiago.pericasgeertsen@oracle.com>"}, "afterCommit": {"oid": "1456226e7215eef56cf1926b2f0208ef74625472", "author": {"user": {"login": "spericas", "name": "Santiago Pericasgeertsen"}}, "url": "https://github.com/oracle/helidon/commit/1456226e7215eef56cf1926b2f0208ef74625472", "committedDate": "2020-02-13T14:41:56Z", "message": "Renamed module from tyrus to websocket. Restored transitive dependencies in MP server.\n\nSigned-off-by: Santiago Pericas-Geertsen <santiago.pericasgeertsen@oracle.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4Mzc5NzI1", "url": "https://github.com/oracle/helidon/pull/1280#pullrequestreview-358379725", "createdAt": "2020-02-13T16:46:51Z", "commit": {"oid": "1456226e7215eef56cf1926b2f0208ef74625472"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4NTE4NTU0", "url": "https://github.com/oracle/helidon/pull/1280#pullrequestreview-358518554", "createdAt": "2020-02-13T20:12:13Z", "commit": {"oid": "1456226e7215eef56cf1926b2f0208ef74625472"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 875, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}