{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYwNTQ0MzU4", "number": 1280, "reviewThreads": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QxMToyODoxMVrODcmcAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QxMTo0NjoxOVrODcmuSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxMzE2NDgzOnYy", "diffSide": "RIGHT", "path": "webserver/tyrus/src/main/java/io/helidon/webserver/tyrus/TyrusSupport.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QxMToyODoxMVrOFkuTAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QxMToyODoxMVrOFkuTAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA1MTU4NQ==", "bodyText": "I do not think the .flavor() method is good. We do not control the time when the flavor is configured and this is not the intention (HelidonFeatures task is to list features of Helidon, not to handle the flavor of Helidon).\nAlso the approach for thread pools is to use one of the existing ThreadPoolSupplier classes, that already handle lazy initiialization.\nIf you do not need an executor in SE, than why is this method in this class? It should be in the CDI extension for WebSockets, and the TyrusSupport class should only provider features to handle the SE model (with capability to build the MP model on top of it).", "url": "https://github.com/oracle/helidon/pull/1280#discussion_r374051585", "createdAt": "2020-02-03T11:28:11Z", "author": {"login": "tomas-langer"}, "path": "webserver/tyrus/src/main/java/io/helidon/webserver/tyrus/TyrusSupport.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.webserver.tyrus;\n+\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.logging.Logger;\n+\n+import javax.websocket.DeploymentException;\n+import javax.websocket.server.HandshakeRequest;\n+import javax.websocket.server.ServerEndpointConfig;\n+\n+import io.helidon.common.HelidonFeatures;\n+import io.helidon.common.HelidonFlavor;\n+import io.helidon.common.configurable.ServerThreadPoolSupplier;\n+import io.helidon.common.context.Contexts;\n+import io.helidon.config.Config;\n+import io.helidon.webserver.Handler;\n+import io.helidon.webserver.Routing;\n+import io.helidon.webserver.ServerRequest;\n+import io.helidon.webserver.ServerResponse;\n+import io.helidon.webserver.Service;\n+\n+import org.eclipse.microprofile.config.ConfigProvider;\n+import org.glassfish.tyrus.core.RequestContext;\n+import org.glassfish.tyrus.core.TyrusUpgradeResponse;\n+import org.glassfish.tyrus.core.TyrusWebSocketEngine;\n+import org.glassfish.tyrus.server.TyrusServerContainer;\n+import org.glassfish.tyrus.spi.Connection;\n+import org.glassfish.tyrus.spi.WebSocketEngine;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+/**\n+ * Class TyrusSupport implemented as a Helidon service.\n+ */\n+public class TyrusSupport implements Service {\n+    private static final Logger LOGGER = Logger.getLogger(TyrusSupport.class.getName());\n+\n+    /**\n+     * A zero-length buffer indicates a connection flush to Helidon.\n+     */\n+    private static final ByteBuffer FLUSH_BUFFER = ByteBuffer.allocateDirect(0);\n+\n+    private static final AtomicReference<ExecutorService> DEFAULT_THREAD_POOL = new AtomicReference<>();\n+\n+    private final WebSocketEngine engine;\n+    private final TyrusHandler handler = new TyrusHandler();\n+    private Set<Class<?>> endpointClasses;\n+    private Set<ServerEndpointConfig> endpointConfigs;\n+    private ExecutorService executorService;\n+\n+    TyrusSupport(WebSocketEngine engine, Set<Class<?>> endpointClasses, Set<ServerEndpointConfig> endpointConfigs) {\n+        this.engine = engine;\n+        this.endpointClasses = endpointClasses;\n+        this.endpointConfigs = endpointConfigs;\n+        this.executorService = createExecutorService();\n+        if (this.executorService != null) {\n+            this.executorService = Contexts.wrap(this.executorService);\n+        }\n+    }\n+\n+    /**\n+     * Register our WebSocket handler for all routes. Once a request is received,\n+     * it will be forwarded to the next handler if not a protocol upgrade request.\n+     *\n+     * @param routingRules Routing rules to update.\n+     */\n+    @Override\n+    public void update(Routing.Rules routingRules) {\n+        LOGGER.info(\"Updating TyrusSupport routing routes\");\n+        routingRules.any(handler);\n+    }\n+\n+    /**\n+     * Access to endpoint classes.\n+     *\n+     * @return Immutable set of end endpoint classes.\n+     */\n+    public Set<Class<?>> endpointClasses() {\n+        return Collections.unmodifiableSet(endpointClasses);\n+    }\n+\n+    /**\n+     * Access to endpoint configs.\n+     *\n+     * @return Immutable set of end endpoint configs.\n+     */\n+    public Set<ServerEndpointConfig> endpointConfigs() {\n+        return Collections.unmodifiableSet(endpointConfigs);\n+    }\n+\n+    /**\n+     * Creates a builder for this class.\n+     *\n+     * @return A builder for this class.\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    /**\n+     * Builder for convenient way to create {@link TyrusSupport}.\n+     */\n+    public static final class Builder implements io.helidon.common.Builder<TyrusSupport> {\n+\n+        private Set<Class<?>> endpointClasses = new HashSet<>();\n+        private Set<ServerEndpointConfig> endpointConfigs = new HashSet<>();\n+\n+        private Builder() {\n+        }\n+\n+        /**\n+         * Register an endpoint class.\n+         *\n+         * @param endpointClass The class.\n+         * @return The builder.\n+         */\n+        public Builder register(Class<?> endpointClass) {\n+            endpointClasses.add(endpointClass);\n+            return this;\n+        }\n+\n+        /**\n+         * Register an endpoint config.\n+         *\n+         * @param endpointConfig The endpoint config.\n+         * @return The builder.\n+         */\n+        public Builder register(ServerEndpointConfig endpointConfig) {\n+            endpointConfigs.add(endpointConfig);\n+            return this;\n+        }\n+\n+        @Override\n+        public TyrusSupport build() {\n+            // Create container and WebSocket engine\n+            TyrusServerContainer serverContainer = new TyrusServerContainer(endpointClasses) {\n+                private final WebSocketEngine engine =\n+                        TyrusWebSocketEngine.builder(this).build();\n+\n+                @Override\n+                public void register(Class<?> endpointClass) {\n+                    throw new UnsupportedOperationException(\"Use TyrusWebSocketEngine for registration\");\n+                }\n+\n+                @Override\n+                public void register(ServerEndpointConfig serverEndpointConfig) {\n+                    throw new UnsupportedOperationException(\"Use TyrusWebSocketEngine for registration\");\n+                }\n+\n+                @Override\n+                public WebSocketEngine getWebSocketEngine() {\n+                    return engine;\n+                }\n+            };\n+\n+            // Register classes with context path \"/\"\n+            WebSocketEngine engine = serverContainer.getWebSocketEngine();\n+            endpointClasses.forEach(c -> {\n+                try {\n+                    // Context path handled by Helidon based on app's routes\n+                    engine.register(c, \"/\");\n+                } catch (DeploymentException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            });\n+            endpointConfigs.forEach(c -> {\n+                try {\n+                    // Context path handled by Helidon based on app's routes\n+                    engine.register(c, \"/\");\n+                } catch (DeploymentException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            });\n+\n+            // Create TyrusSupport using WebSocket engine\n+            return new TyrusSupport(serverContainer.getWebSocketEngine(), endpointClasses, endpointConfigs);\n+        }\n+    }\n+\n+    /**\n+     * Creates executor service for Websocket in MP. No executor for SE.\n+     *\n+     * @return Executor service or {@code null}.\n+     */\n+    private static ExecutorService createExecutorService() {\n+        if (HelidonFeatures.flavor() == HelidonFlavor.MP && DEFAULT_THREAD_POOL.get() == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d0e215cfb326c55d421d679515926ec947caa61"}, "originalPosition": 210}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxMzE2NzMwOnYy", "diffSide": "RIGHT", "path": "webserver/tyrus/src/main/java/io/helidon/webserver/tyrus/TyrusSupport.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QxMToyOTowOFrOFkuUjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QxMToyOTowOFrOFkuUjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA1MTk4MA==", "bodyText": "Please use Optional.isEmpty()", "url": "https://github.com/oracle/helidon/pull/1280#discussion_r374051980", "createdAt": "2020-02-03T11:29:08Z", "author": {"login": "tomas-langer"}, "path": "webserver/tyrus/src/main/java/io/helidon/webserver/tyrus/TyrusSupport.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.webserver.tyrus;\n+\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.logging.Logger;\n+\n+import javax.websocket.DeploymentException;\n+import javax.websocket.server.HandshakeRequest;\n+import javax.websocket.server.ServerEndpointConfig;\n+\n+import io.helidon.common.HelidonFeatures;\n+import io.helidon.common.HelidonFlavor;\n+import io.helidon.common.configurable.ServerThreadPoolSupplier;\n+import io.helidon.common.context.Contexts;\n+import io.helidon.config.Config;\n+import io.helidon.webserver.Handler;\n+import io.helidon.webserver.Routing;\n+import io.helidon.webserver.ServerRequest;\n+import io.helidon.webserver.ServerResponse;\n+import io.helidon.webserver.Service;\n+\n+import org.eclipse.microprofile.config.ConfigProvider;\n+import org.glassfish.tyrus.core.RequestContext;\n+import org.glassfish.tyrus.core.TyrusUpgradeResponse;\n+import org.glassfish.tyrus.core.TyrusWebSocketEngine;\n+import org.glassfish.tyrus.server.TyrusServerContainer;\n+import org.glassfish.tyrus.spi.Connection;\n+import org.glassfish.tyrus.spi.WebSocketEngine;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+/**\n+ * Class TyrusSupport implemented as a Helidon service.\n+ */\n+public class TyrusSupport implements Service {\n+    private static final Logger LOGGER = Logger.getLogger(TyrusSupport.class.getName());\n+\n+    /**\n+     * A zero-length buffer indicates a connection flush to Helidon.\n+     */\n+    private static final ByteBuffer FLUSH_BUFFER = ByteBuffer.allocateDirect(0);\n+\n+    private static final AtomicReference<ExecutorService> DEFAULT_THREAD_POOL = new AtomicReference<>();\n+\n+    private final WebSocketEngine engine;\n+    private final TyrusHandler handler = new TyrusHandler();\n+    private Set<Class<?>> endpointClasses;\n+    private Set<ServerEndpointConfig> endpointConfigs;\n+    private ExecutorService executorService;\n+\n+    TyrusSupport(WebSocketEngine engine, Set<Class<?>> endpointClasses, Set<ServerEndpointConfig> endpointConfigs) {\n+        this.engine = engine;\n+        this.endpointClasses = endpointClasses;\n+        this.endpointConfigs = endpointConfigs;\n+        this.executorService = createExecutorService();\n+        if (this.executorService != null) {\n+            this.executorService = Contexts.wrap(this.executorService);\n+        }\n+    }\n+\n+    /**\n+     * Register our WebSocket handler for all routes. Once a request is received,\n+     * it will be forwarded to the next handler if not a protocol upgrade request.\n+     *\n+     * @param routingRules Routing rules to update.\n+     */\n+    @Override\n+    public void update(Routing.Rules routingRules) {\n+        LOGGER.info(\"Updating TyrusSupport routing routes\");\n+        routingRules.any(handler);\n+    }\n+\n+    /**\n+     * Access to endpoint classes.\n+     *\n+     * @return Immutable set of end endpoint classes.\n+     */\n+    public Set<Class<?>> endpointClasses() {\n+        return Collections.unmodifiableSet(endpointClasses);\n+    }\n+\n+    /**\n+     * Access to endpoint configs.\n+     *\n+     * @return Immutable set of end endpoint configs.\n+     */\n+    public Set<ServerEndpointConfig> endpointConfigs() {\n+        return Collections.unmodifiableSet(endpointConfigs);\n+    }\n+\n+    /**\n+     * Creates a builder for this class.\n+     *\n+     * @return A builder for this class.\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    /**\n+     * Builder for convenient way to create {@link TyrusSupport}.\n+     */\n+    public static final class Builder implements io.helidon.common.Builder<TyrusSupport> {\n+\n+        private Set<Class<?>> endpointClasses = new HashSet<>();\n+        private Set<ServerEndpointConfig> endpointConfigs = new HashSet<>();\n+\n+        private Builder() {\n+        }\n+\n+        /**\n+         * Register an endpoint class.\n+         *\n+         * @param endpointClass The class.\n+         * @return The builder.\n+         */\n+        public Builder register(Class<?> endpointClass) {\n+            endpointClasses.add(endpointClass);\n+            return this;\n+        }\n+\n+        /**\n+         * Register an endpoint config.\n+         *\n+         * @param endpointConfig The endpoint config.\n+         * @return The builder.\n+         */\n+        public Builder register(ServerEndpointConfig endpointConfig) {\n+            endpointConfigs.add(endpointConfig);\n+            return this;\n+        }\n+\n+        @Override\n+        public TyrusSupport build() {\n+            // Create container and WebSocket engine\n+            TyrusServerContainer serverContainer = new TyrusServerContainer(endpointClasses) {\n+                private final WebSocketEngine engine =\n+                        TyrusWebSocketEngine.builder(this).build();\n+\n+                @Override\n+                public void register(Class<?> endpointClass) {\n+                    throw new UnsupportedOperationException(\"Use TyrusWebSocketEngine for registration\");\n+                }\n+\n+                @Override\n+                public void register(ServerEndpointConfig serverEndpointConfig) {\n+                    throw new UnsupportedOperationException(\"Use TyrusWebSocketEngine for registration\");\n+                }\n+\n+                @Override\n+                public WebSocketEngine getWebSocketEngine() {\n+                    return engine;\n+                }\n+            };\n+\n+            // Register classes with context path \"/\"\n+            WebSocketEngine engine = serverContainer.getWebSocketEngine();\n+            endpointClasses.forEach(c -> {\n+                try {\n+                    // Context path handled by Helidon based on app's routes\n+                    engine.register(c, \"/\");\n+                } catch (DeploymentException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            });\n+            endpointConfigs.forEach(c -> {\n+                try {\n+                    // Context path handled by Helidon based on app's routes\n+                    engine.register(c, \"/\");\n+                } catch (DeploymentException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            });\n+\n+            // Create TyrusSupport using WebSocket engine\n+            return new TyrusSupport(serverContainer.getWebSocketEngine(), endpointClasses, endpointConfigs);\n+        }\n+    }\n+\n+    /**\n+     * Creates executor service for Websocket in MP. No executor for SE.\n+     *\n+     * @return Executor service or {@code null}.\n+     */\n+    private static ExecutorService createExecutorService() {\n+        if (HelidonFeatures.flavor() == HelidonFlavor.MP && DEFAULT_THREAD_POOL.get() == null) {\n+            Config executorConfig = ((Config) ConfigProvider.getConfig())\n+                    .get(\"websocket.executor-service\");\n+\n+            DEFAULT_THREAD_POOL.set(ServerThreadPoolSupplier.builder()\n+                    .name(\"websocket\")\n+                    .config(executorConfig)\n+                    .build()\n+                    .get());\n+        }\n+        return DEFAULT_THREAD_POOL.get();\n+    }\n+\n+    /**\n+     * A Helidon handler that integrates with Tyrus and can process WebSocket\n+     * upgrade requests.\n+     */\n+    private class TyrusHandler implements Handler {\n+\n+        /**\n+         * Process a server request/response.\n+         *\n+         * @param req an HTTP server request.\n+         * @param res an HTTP server response.\n+         */\n+        @Override\n+        public void accept(ServerRequest req, ServerResponse res) {\n+            // Skip this handler if not an upgrade request\n+            Optional<String> secWebSocketKey = req.headers().value(HandshakeRequest.SEC_WEBSOCKET_KEY);\n+            if (!secWebSocketKey.isPresent()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d0e215cfb326c55d421d679515926ec947caa61"}, "originalPosition": 239}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxMzE2OTkxOnYy", "diffSide": "RIGHT", "path": "webserver/tyrus/src/main/java/io/helidon/webserver/tyrus/TyrusSupport.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QxMTozMDoxMVrOFkuWKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QxMTozMDoxMVrOFkuWKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA1MjM5NQ==", "bodyText": "use req.headers().toMap().forEach((key, value) -> ...)", "url": "https://github.com/oracle/helidon/pull/1280#discussion_r374052395", "createdAt": "2020-02-03T11:30:11Z", "author": {"login": "tomas-langer"}, "path": "webserver/tyrus/src/main/java/io/helidon/webserver/tyrus/TyrusSupport.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.webserver.tyrus;\n+\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.logging.Logger;\n+\n+import javax.websocket.DeploymentException;\n+import javax.websocket.server.HandshakeRequest;\n+import javax.websocket.server.ServerEndpointConfig;\n+\n+import io.helidon.common.HelidonFeatures;\n+import io.helidon.common.HelidonFlavor;\n+import io.helidon.common.configurable.ServerThreadPoolSupplier;\n+import io.helidon.common.context.Contexts;\n+import io.helidon.config.Config;\n+import io.helidon.webserver.Handler;\n+import io.helidon.webserver.Routing;\n+import io.helidon.webserver.ServerRequest;\n+import io.helidon.webserver.ServerResponse;\n+import io.helidon.webserver.Service;\n+\n+import org.eclipse.microprofile.config.ConfigProvider;\n+import org.glassfish.tyrus.core.RequestContext;\n+import org.glassfish.tyrus.core.TyrusUpgradeResponse;\n+import org.glassfish.tyrus.core.TyrusWebSocketEngine;\n+import org.glassfish.tyrus.server.TyrusServerContainer;\n+import org.glassfish.tyrus.spi.Connection;\n+import org.glassfish.tyrus.spi.WebSocketEngine;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+/**\n+ * Class TyrusSupport implemented as a Helidon service.\n+ */\n+public class TyrusSupport implements Service {\n+    private static final Logger LOGGER = Logger.getLogger(TyrusSupport.class.getName());\n+\n+    /**\n+     * A zero-length buffer indicates a connection flush to Helidon.\n+     */\n+    private static final ByteBuffer FLUSH_BUFFER = ByteBuffer.allocateDirect(0);\n+\n+    private static final AtomicReference<ExecutorService> DEFAULT_THREAD_POOL = new AtomicReference<>();\n+\n+    private final WebSocketEngine engine;\n+    private final TyrusHandler handler = new TyrusHandler();\n+    private Set<Class<?>> endpointClasses;\n+    private Set<ServerEndpointConfig> endpointConfigs;\n+    private ExecutorService executorService;\n+\n+    TyrusSupport(WebSocketEngine engine, Set<Class<?>> endpointClasses, Set<ServerEndpointConfig> endpointConfigs) {\n+        this.engine = engine;\n+        this.endpointClasses = endpointClasses;\n+        this.endpointConfigs = endpointConfigs;\n+        this.executorService = createExecutorService();\n+        if (this.executorService != null) {\n+            this.executorService = Contexts.wrap(this.executorService);\n+        }\n+    }\n+\n+    /**\n+     * Register our WebSocket handler for all routes. Once a request is received,\n+     * it will be forwarded to the next handler if not a protocol upgrade request.\n+     *\n+     * @param routingRules Routing rules to update.\n+     */\n+    @Override\n+    public void update(Routing.Rules routingRules) {\n+        LOGGER.info(\"Updating TyrusSupport routing routes\");\n+        routingRules.any(handler);\n+    }\n+\n+    /**\n+     * Access to endpoint classes.\n+     *\n+     * @return Immutable set of end endpoint classes.\n+     */\n+    public Set<Class<?>> endpointClasses() {\n+        return Collections.unmodifiableSet(endpointClasses);\n+    }\n+\n+    /**\n+     * Access to endpoint configs.\n+     *\n+     * @return Immutable set of end endpoint configs.\n+     */\n+    public Set<ServerEndpointConfig> endpointConfigs() {\n+        return Collections.unmodifiableSet(endpointConfigs);\n+    }\n+\n+    /**\n+     * Creates a builder for this class.\n+     *\n+     * @return A builder for this class.\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    /**\n+     * Builder for convenient way to create {@link TyrusSupport}.\n+     */\n+    public static final class Builder implements io.helidon.common.Builder<TyrusSupport> {\n+\n+        private Set<Class<?>> endpointClasses = new HashSet<>();\n+        private Set<ServerEndpointConfig> endpointConfigs = new HashSet<>();\n+\n+        private Builder() {\n+        }\n+\n+        /**\n+         * Register an endpoint class.\n+         *\n+         * @param endpointClass The class.\n+         * @return The builder.\n+         */\n+        public Builder register(Class<?> endpointClass) {\n+            endpointClasses.add(endpointClass);\n+            return this;\n+        }\n+\n+        /**\n+         * Register an endpoint config.\n+         *\n+         * @param endpointConfig The endpoint config.\n+         * @return The builder.\n+         */\n+        public Builder register(ServerEndpointConfig endpointConfig) {\n+            endpointConfigs.add(endpointConfig);\n+            return this;\n+        }\n+\n+        @Override\n+        public TyrusSupport build() {\n+            // Create container and WebSocket engine\n+            TyrusServerContainer serverContainer = new TyrusServerContainer(endpointClasses) {\n+                private final WebSocketEngine engine =\n+                        TyrusWebSocketEngine.builder(this).build();\n+\n+                @Override\n+                public void register(Class<?> endpointClass) {\n+                    throw new UnsupportedOperationException(\"Use TyrusWebSocketEngine for registration\");\n+                }\n+\n+                @Override\n+                public void register(ServerEndpointConfig serverEndpointConfig) {\n+                    throw new UnsupportedOperationException(\"Use TyrusWebSocketEngine for registration\");\n+                }\n+\n+                @Override\n+                public WebSocketEngine getWebSocketEngine() {\n+                    return engine;\n+                }\n+            };\n+\n+            // Register classes with context path \"/\"\n+            WebSocketEngine engine = serverContainer.getWebSocketEngine();\n+            endpointClasses.forEach(c -> {\n+                try {\n+                    // Context path handled by Helidon based on app's routes\n+                    engine.register(c, \"/\");\n+                } catch (DeploymentException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            });\n+            endpointConfigs.forEach(c -> {\n+                try {\n+                    // Context path handled by Helidon based on app's routes\n+                    engine.register(c, \"/\");\n+                } catch (DeploymentException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            });\n+\n+            // Create TyrusSupport using WebSocket engine\n+            return new TyrusSupport(serverContainer.getWebSocketEngine(), endpointClasses, endpointConfigs);\n+        }\n+    }\n+\n+    /**\n+     * Creates executor service for Websocket in MP. No executor for SE.\n+     *\n+     * @return Executor service or {@code null}.\n+     */\n+    private static ExecutorService createExecutorService() {\n+        if (HelidonFeatures.flavor() == HelidonFlavor.MP && DEFAULT_THREAD_POOL.get() == null) {\n+            Config executorConfig = ((Config) ConfigProvider.getConfig())\n+                    .get(\"websocket.executor-service\");\n+\n+            DEFAULT_THREAD_POOL.set(ServerThreadPoolSupplier.builder()\n+                    .name(\"websocket\")\n+                    .config(executorConfig)\n+                    .build()\n+                    .get());\n+        }\n+        return DEFAULT_THREAD_POOL.get();\n+    }\n+\n+    /**\n+     * A Helidon handler that integrates with Tyrus and can process WebSocket\n+     * upgrade requests.\n+     */\n+    private class TyrusHandler implements Handler {\n+\n+        /**\n+         * Process a server request/response.\n+         *\n+         * @param req an HTTP server request.\n+         * @param res an HTTP server response.\n+         */\n+        @Override\n+        public void accept(ServerRequest req, ServerResponse res) {\n+            // Skip this handler if not an upgrade request\n+            Optional<String> secWebSocketKey = req.headers().value(HandshakeRequest.SEC_WEBSOCKET_KEY);\n+            if (!secWebSocketKey.isPresent()) {\n+                req.next();\n+                return;\n+            }\n+\n+            LOGGER.fine(\"Initiating WebSocket handshake ...\");\n+\n+            // Create Tyrus request context and copy request headers\n+            RequestContext requestContext = RequestContext.Builder.create()\n+                    .requestURI(URI.create(req.path().toString()))      // excludes context path\n+                    .build();\n+            req.headers().toMap().entrySet().forEach(e ->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d0e215cfb326c55d421d679515926ec947caa61"}, "originalPosition": 250}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxMzE3NTUzOnYy", "diffSide": "RIGHT", "path": "webserver/tyrus/src/main/java/io/helidon/webserver/tyrus/TyrusSupport.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QxMTozMjoyNVrOFkuZnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QxMTozMjoyNVrOFkuZnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA1MzI3Ng==", "bodyText": "I am not sure I understand this - why do you use an executor service, when you call get on the result? You are blocking the current thread anyways, why not just call the statement directly?\nAlso this seems to be an issue for our WebServer, as you should never block", "url": "https://github.com/oracle/helidon/pull/1280#discussion_r374053276", "createdAt": "2020-02-03T11:32:25Z", "author": {"login": "tomas-langer"}, "path": "webserver/tyrus/src/main/java/io/helidon/webserver/tyrus/TyrusSupport.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.webserver.tyrus;\n+\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.logging.Logger;\n+\n+import javax.websocket.DeploymentException;\n+import javax.websocket.server.HandshakeRequest;\n+import javax.websocket.server.ServerEndpointConfig;\n+\n+import io.helidon.common.HelidonFeatures;\n+import io.helidon.common.HelidonFlavor;\n+import io.helidon.common.configurable.ServerThreadPoolSupplier;\n+import io.helidon.common.context.Contexts;\n+import io.helidon.config.Config;\n+import io.helidon.webserver.Handler;\n+import io.helidon.webserver.Routing;\n+import io.helidon.webserver.ServerRequest;\n+import io.helidon.webserver.ServerResponse;\n+import io.helidon.webserver.Service;\n+\n+import org.eclipse.microprofile.config.ConfigProvider;\n+import org.glassfish.tyrus.core.RequestContext;\n+import org.glassfish.tyrus.core.TyrusUpgradeResponse;\n+import org.glassfish.tyrus.core.TyrusWebSocketEngine;\n+import org.glassfish.tyrus.server.TyrusServerContainer;\n+import org.glassfish.tyrus.spi.Connection;\n+import org.glassfish.tyrus.spi.WebSocketEngine;\n+\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n+/**\n+ * Class TyrusSupport implemented as a Helidon service.\n+ */\n+public class TyrusSupport implements Service {\n+    private static final Logger LOGGER = Logger.getLogger(TyrusSupport.class.getName());\n+\n+    /**\n+     * A zero-length buffer indicates a connection flush to Helidon.\n+     */\n+    private static final ByteBuffer FLUSH_BUFFER = ByteBuffer.allocateDirect(0);\n+\n+    private static final AtomicReference<ExecutorService> DEFAULT_THREAD_POOL = new AtomicReference<>();\n+\n+    private final WebSocketEngine engine;\n+    private final TyrusHandler handler = new TyrusHandler();\n+    private Set<Class<?>> endpointClasses;\n+    private Set<ServerEndpointConfig> endpointConfigs;\n+    private ExecutorService executorService;\n+\n+    TyrusSupport(WebSocketEngine engine, Set<Class<?>> endpointClasses, Set<ServerEndpointConfig> endpointConfigs) {\n+        this.engine = engine;\n+        this.endpointClasses = endpointClasses;\n+        this.endpointConfigs = endpointConfigs;\n+        this.executorService = createExecutorService();\n+        if (this.executorService != null) {\n+            this.executorService = Contexts.wrap(this.executorService);\n+        }\n+    }\n+\n+    /**\n+     * Register our WebSocket handler for all routes. Once a request is received,\n+     * it will be forwarded to the next handler if not a protocol upgrade request.\n+     *\n+     * @param routingRules Routing rules to update.\n+     */\n+    @Override\n+    public void update(Routing.Rules routingRules) {\n+        LOGGER.info(\"Updating TyrusSupport routing routes\");\n+        routingRules.any(handler);\n+    }\n+\n+    /**\n+     * Access to endpoint classes.\n+     *\n+     * @return Immutable set of end endpoint classes.\n+     */\n+    public Set<Class<?>> endpointClasses() {\n+        return Collections.unmodifiableSet(endpointClasses);\n+    }\n+\n+    /**\n+     * Access to endpoint configs.\n+     *\n+     * @return Immutable set of end endpoint configs.\n+     */\n+    public Set<ServerEndpointConfig> endpointConfigs() {\n+        return Collections.unmodifiableSet(endpointConfigs);\n+    }\n+\n+    /**\n+     * Creates a builder for this class.\n+     *\n+     * @return A builder for this class.\n+     */\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    /**\n+     * Builder for convenient way to create {@link TyrusSupport}.\n+     */\n+    public static final class Builder implements io.helidon.common.Builder<TyrusSupport> {\n+\n+        private Set<Class<?>> endpointClasses = new HashSet<>();\n+        private Set<ServerEndpointConfig> endpointConfigs = new HashSet<>();\n+\n+        private Builder() {\n+        }\n+\n+        /**\n+         * Register an endpoint class.\n+         *\n+         * @param endpointClass The class.\n+         * @return The builder.\n+         */\n+        public Builder register(Class<?> endpointClass) {\n+            endpointClasses.add(endpointClass);\n+            return this;\n+        }\n+\n+        /**\n+         * Register an endpoint config.\n+         *\n+         * @param endpointConfig The endpoint config.\n+         * @return The builder.\n+         */\n+        public Builder register(ServerEndpointConfig endpointConfig) {\n+            endpointConfigs.add(endpointConfig);\n+            return this;\n+        }\n+\n+        @Override\n+        public TyrusSupport build() {\n+            // Create container and WebSocket engine\n+            TyrusServerContainer serverContainer = new TyrusServerContainer(endpointClasses) {\n+                private final WebSocketEngine engine =\n+                        TyrusWebSocketEngine.builder(this).build();\n+\n+                @Override\n+                public void register(Class<?> endpointClass) {\n+                    throw new UnsupportedOperationException(\"Use TyrusWebSocketEngine for registration\");\n+                }\n+\n+                @Override\n+                public void register(ServerEndpointConfig serverEndpointConfig) {\n+                    throw new UnsupportedOperationException(\"Use TyrusWebSocketEngine for registration\");\n+                }\n+\n+                @Override\n+                public WebSocketEngine getWebSocketEngine() {\n+                    return engine;\n+                }\n+            };\n+\n+            // Register classes with context path \"/\"\n+            WebSocketEngine engine = serverContainer.getWebSocketEngine();\n+            endpointClasses.forEach(c -> {\n+                try {\n+                    // Context path handled by Helidon based on app's routes\n+                    engine.register(c, \"/\");\n+                } catch (DeploymentException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            });\n+            endpointConfigs.forEach(c -> {\n+                try {\n+                    // Context path handled by Helidon based on app's routes\n+                    engine.register(c, \"/\");\n+                } catch (DeploymentException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            });\n+\n+            // Create TyrusSupport using WebSocket engine\n+            return new TyrusSupport(serverContainer.getWebSocketEngine(), endpointClasses, endpointConfigs);\n+        }\n+    }\n+\n+    /**\n+     * Creates executor service for Websocket in MP. No executor for SE.\n+     *\n+     * @return Executor service or {@code null}.\n+     */\n+    private static ExecutorService createExecutorService() {\n+        if (HelidonFeatures.flavor() == HelidonFlavor.MP && DEFAULT_THREAD_POOL.get() == null) {\n+            Config executorConfig = ((Config) ConfigProvider.getConfig())\n+                    .get(\"websocket.executor-service\");\n+\n+            DEFAULT_THREAD_POOL.set(ServerThreadPoolSupplier.builder()\n+                    .name(\"websocket\")\n+                    .config(executorConfig)\n+                    .build()\n+                    .get());\n+        }\n+        return DEFAULT_THREAD_POOL.get();\n+    }\n+\n+    /**\n+     * A Helidon handler that integrates with Tyrus and can process WebSocket\n+     * upgrade requests.\n+     */\n+    private class TyrusHandler implements Handler {\n+\n+        /**\n+         * Process a server request/response.\n+         *\n+         * @param req an HTTP server request.\n+         * @param res an HTTP server response.\n+         */\n+        @Override\n+        public void accept(ServerRequest req, ServerResponse res) {\n+            // Skip this handler if not an upgrade request\n+            Optional<String> secWebSocketKey = req.headers().value(HandshakeRequest.SEC_WEBSOCKET_KEY);\n+            if (!secWebSocketKey.isPresent()) {\n+                req.next();\n+                return;\n+            }\n+\n+            LOGGER.fine(\"Initiating WebSocket handshake ...\");\n+\n+            // Create Tyrus request context and copy request headers\n+            RequestContext requestContext = RequestContext.Builder.create()\n+                    .requestURI(URI.create(req.path().toString()))      // excludes context path\n+                    .build();\n+            req.headers().toMap().entrySet().forEach(e ->\n+                    requestContext.getHeaders().put(e.getKey(), e.getValue()));\n+\n+            // Use Tyrus to process a WebSocket upgrade request\n+            final TyrusUpgradeResponse upgradeResponse = new TyrusUpgradeResponse();\n+            final WebSocketEngine.UpgradeInfo upgradeInfo = engine.upgrade(requestContext, upgradeResponse);\n+\n+            // Respond to upgrade request using response from Tyrus\n+            res.status(upgradeResponse.getStatus());\n+            upgradeResponse.getHeaders().entrySet().forEach(e ->\n+                    res.headers().add(e.getKey(), e.getValue()));\n+            TyrusWriterPublisher publisherWriter = new TyrusWriterPublisher();\n+            res.send(publisherWriter);\n+\n+            // Write reason for failure if not successful\n+            if (upgradeInfo.getStatus() != WebSocketEngine.UpgradeStatus.SUCCESS) {\n+                String reason = upgradeResponse.getReasonPhrase();\n+                if (reason != null) {\n+                    publisherWriter.write(ByteBuffer.wrap(reason.getBytes(UTF_8)), null);\n+                }\n+            }\n+\n+            // Flush upgrade response\n+            publisherWriter.write(FLUSH_BUFFER, null);\n+\n+            // Setup the WebSocket connection and internally the ReaderHandler\n+            Connection connection;\n+            if (executorService != null) {\n+                try {\n+                    // Set up connection and call @onOpen\n+                    Future<Connection> future = executorService.submit(() ->\n+                            upgradeInfo.createConnection(publisherWriter,\n+                                    closeReason -> LOGGER.fine(() -> \"Connection closed: \" + closeReason)));\n+                    connection = future.get();      // Need to sync here", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d0e215cfb326c55d421d679515926ec947caa61"}, "originalPosition": 283}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxMzE4OTQ4OnYy", "diffSide": "RIGHT", "path": "microprofile/server/src/main/java/io/helidon/microprofile/server/Server.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QxMTozODowNVrOFkuiYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QxMTozODowNVrOFkuiYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA1NTUyMw==", "bodyText": "WebSocket support should not be part of Helidon MicroProfile server.\nThis adds an unwanted dependency on Tyrus for MP implementation.\nPlease extract WebSocket support into a separate module.", "url": "https://github.com/oracle/helidon/pull/1280#discussion_r374055523", "createdAt": "2020-02-03T11:38:05Z", "author": {"login": "tomas-langer"}, "path": "microprofile/server/src/main/java/io/helidon/microprofile/server/Server.java", "diffHunk": "@@ -69,6 +71,20 @@ static Server create(Class<? extends Application>... applicationClasses) throws\n         return builder.build();\n     }\n \n+    /**\n+     * Create a server instance using a Websocket application class.\n+     *\n+     * @param applicationClass websocket application class\n+     * @return server instance to be started\n+     * @throws MpException in case the server fails to be created\n+     * @see #builder()\n+     */\n+    static Server create(Class<? extends ServerApplicationConfig> applicationClass) throws MpException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d0e215cfb326c55d421d679515926ec947caa61"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxMzE5MDQxOnYy", "diffSide": "RIGHT", "path": "microprofile/server/src/main/java/io/helidon/microprofile/server/Server.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QxMTozODoyN1rOFkui4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QxMTozODoyN1rOFkui4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA1NTY0OA==", "bodyText": "Remove from Server. WebSocket should be handled in a separate module.", "url": "https://github.com/oracle/helidon/pull/1280#discussion_r374055648", "createdAt": "2020-02-03T11:38:27Z", "author": {"login": "tomas-langer"}, "path": "microprofile/server/src/main/java/io/helidon/microprofile/server/Server.java", "diffHunk": "@@ -366,6 +383,20 @@ public Builder addApplication(Application application) {\n             return this;\n         }\n \n+        /**\n+         * Registers a WebSocket application in the server. At most one application can be registered.\n+         *\n+         * @param wsApplication websocket application\n+         * @return modified builder\n+         */\n+        public Builder websocketApplication(Class<? extends ServerApplicationConfig> wsApplication) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d0e215cfb326c55d421d679515926ec947caa61"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxMzE5MTc3OnYy", "diffSide": "RIGHT", "path": "microprofile/server/src/main/java/io/helidon/microprofile/server/ServerCdiExtension.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QxMTozOTowMVrOFkujvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QxMTozOTowMVrOFkujvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA1NTg3MQ==", "bodyText": "Extract into a separate module, use WebSocketCdiExtension in that module to setup everything", "url": "https://github.com/oracle/helidon/pull/1280#discussion_r374055871", "createdAt": "2020-02-03T11:39:01Z", "author": {"login": "tomas-langer"}, "path": "microprofile/server/src/main/java/io/helidon/microprofile/server/ServerCdiExtension.java", "diffHunk": "@@ -117,6 +126,9 @@ private void startServer(@Observes @Priority(PLATFORM_AFTER + 100) @Initialized(\n         // register static content if configured\n         registerStaticContent();\n \n+        // register websocket endpoints", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d0e215cfb326c55d421d679515926ec947caa61"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxMzE5Mzc3OnYy", "diffSide": "RIGHT", "path": "microprofile/server/src/main/java/module-info.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QxMTozOTo1M1rOFkuk-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QxMTozOTo1M1rOFkuk-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA1NjE4Nw==", "bodyText": "There should be no dependency on tyrus or websocket in Helidon MP Server.", "url": "https://github.com/oracle/helidon/pull/1280#discussion_r374056187", "createdAt": "2020-02-03T11:39:53Z", "author": {"login": "tomas-langer"}, "path": "microprofile/server/src/main/java/module-info.java", "diffHunk": "@@ -38,9 +36,15 @@\n     // there is now a hardcoded dependency on Weld, to configure additional bean defining annotation\n     requires java.management;\n \n+    requires io.helidon.microprofile.tyrus;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d0e215cfb326c55d421d679515926ec947caa61"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxMzE5ODA4OnYy", "diffSide": "RIGHT", "path": "microprofile/tyrus/src/main/java/io/helidon/microprofile/tyrus/WebSocketCdiExtension.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QxMTo0MTo0MFrOFkunog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQxNDoxNzowNlrOFlVkfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA1Njg2Ng==", "bodyText": "Do not use info level, unless it is an information needed for every user on every startup.\nThis seems to be debug information.\nYou can list Tyrus applications in info - but only when actually registering them (e.g. by the time we have the complete list).", "url": "https://github.com/oracle/helidon/pull/1280#discussion_r374056866", "createdAt": "2020-02-03T11:41:40Z", "author": {"login": "tomas-langer"}, "path": "microprofile/tyrus/src/main/java/io/helidon/microprofile/tyrus/WebSocketCdiExtension.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.microprofile.tyrus;\n+\n+import java.util.logging.Logger;\n+\n+import javax.enterprise.event.Observes;\n+import javax.enterprise.inject.spi.Extension;\n+import javax.enterprise.inject.spi.ProcessAnnotatedType;\n+import javax.enterprise.inject.spi.WithAnnotations;\n+import javax.websocket.Endpoint;\n+import javax.websocket.server.ServerApplicationConfig;\n+import javax.websocket.server.ServerEndpoint;\n+\n+import io.helidon.common.HelidonFeatures;\n+import io.helidon.common.HelidonFlavor;\n+\n+/**\n+ * Configure Tyrus related things.\n+ */\n+public class WebSocketCdiExtension implements Extension {\n+    private static final Logger LOGGER = Logger.getLogger(WebSocketCdiExtension.class.getName());\n+\n+    static {\n+        HelidonFeatures.register(HelidonFlavor.MP, \"WebSocket\");\n+    }\n+\n+    private WebSocketApplication.Builder appBuilder = WebSocketApplication.builder();\n+\n+    /**\n+     * Collect application class extending {@code ServerApplicationConfig}.\n+     *\n+     * @param applicationClass Application class.\n+     */\n+    private void applicationClass(@Observes ProcessAnnotatedType<? extends ServerApplicationConfig> applicationClass) {\n+        LOGGER.info(() -> \"Application class found \" + applicationClass.getAnnotatedType().getJavaClass());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d0e215cfb326c55d421d679515926ec947caa61"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDY5NTAzNg==", "bodyText": "Yes, these were all misuses of logging for development.", "url": "https://github.com/oracle/helidon/pull/1280#discussion_r374695036", "createdAt": "2020-02-04T14:17:06Z", "author": {"login": "spericas"}, "path": "microprofile/tyrus/src/main/java/io/helidon/microprofile/tyrus/WebSocketCdiExtension.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.microprofile.tyrus;\n+\n+import java.util.logging.Logger;\n+\n+import javax.enterprise.event.Observes;\n+import javax.enterprise.inject.spi.Extension;\n+import javax.enterprise.inject.spi.ProcessAnnotatedType;\n+import javax.enterprise.inject.spi.WithAnnotations;\n+import javax.websocket.Endpoint;\n+import javax.websocket.server.ServerApplicationConfig;\n+import javax.websocket.server.ServerEndpoint;\n+\n+import io.helidon.common.HelidonFeatures;\n+import io.helidon.common.HelidonFlavor;\n+\n+/**\n+ * Configure Tyrus related things.\n+ */\n+public class WebSocketCdiExtension implements Extension {\n+    private static final Logger LOGGER = Logger.getLogger(WebSocketCdiExtension.class.getName());\n+\n+    static {\n+        HelidonFeatures.register(HelidonFlavor.MP, \"WebSocket\");\n+    }\n+\n+    private WebSocketApplication.Builder appBuilder = WebSocketApplication.builder();\n+\n+    /**\n+     * Collect application class extending {@code ServerApplicationConfig}.\n+     *\n+     * @param applicationClass Application class.\n+     */\n+    private void applicationClass(@Observes ProcessAnnotatedType<? extends ServerApplicationConfig> applicationClass) {\n+        LOGGER.info(() -> \"Application class found \" + applicationClass.getAnnotatedType().getJavaClass());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA1Njg2Ng=="}, "originalCommit": {"oid": "0d0e215cfb326c55d421d679515926ec947caa61"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxMzE5ODgyOnYy", "diffSide": "RIGHT", "path": "microprofile/tyrus/src/main/java/io/helidon/microprofile/tyrus/WebSocketCdiExtension.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QxMTo0MTo1NFrOFkuoDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QxMTo0MTo1NFrOFkuoDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA1Njk3Mw==", "bodyText": "see above - do not use info level", "url": "https://github.com/oracle/helidon/pull/1280#discussion_r374056973", "createdAt": "2020-02-03T11:41:54Z", "author": {"login": "tomas-langer"}, "path": "microprofile/tyrus/src/main/java/io/helidon/microprofile/tyrus/WebSocketCdiExtension.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.microprofile.tyrus;\n+\n+import java.util.logging.Logger;\n+\n+import javax.enterprise.event.Observes;\n+import javax.enterprise.inject.spi.Extension;\n+import javax.enterprise.inject.spi.ProcessAnnotatedType;\n+import javax.enterprise.inject.spi.WithAnnotations;\n+import javax.websocket.Endpoint;\n+import javax.websocket.server.ServerApplicationConfig;\n+import javax.websocket.server.ServerEndpoint;\n+\n+import io.helidon.common.HelidonFeatures;\n+import io.helidon.common.HelidonFlavor;\n+\n+/**\n+ * Configure Tyrus related things.\n+ */\n+public class WebSocketCdiExtension implements Extension {\n+    private static final Logger LOGGER = Logger.getLogger(WebSocketCdiExtension.class.getName());\n+\n+    static {\n+        HelidonFeatures.register(HelidonFlavor.MP, \"WebSocket\");\n+    }\n+\n+    private WebSocketApplication.Builder appBuilder = WebSocketApplication.builder();\n+\n+    /**\n+     * Collect application class extending {@code ServerApplicationConfig}.\n+     *\n+     * @param applicationClass Application class.\n+     */\n+    private void applicationClass(@Observes ProcessAnnotatedType<? extends ServerApplicationConfig> applicationClass) {\n+        LOGGER.info(() -> \"Application class found \" + applicationClass.getAnnotatedType().getJavaClass());\n+        appBuilder.applicationClass(applicationClass.getAnnotatedType().getJavaClass());\n+    }\n+\n+    /**\n+     * Overrides a websocket application class.\n+     *\n+     * @param applicationClass Application class.\n+     */\n+    public void applicationClass(Class<? extends ServerApplicationConfig> applicationClass) {\n+        LOGGER.info(() -> \"Using manually set application class  \" + applicationClass);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d0e215cfb326c55d421d679515926ec947caa61"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxMzE5OTA5OnYy", "diffSide": "RIGHT", "path": "microprofile/tyrus/src/main/java/io/helidon/microprofile/tyrus/WebSocketCdiExtension.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QxMTo0MTo1OVrOFkuoNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QxMTo0MTo1OVrOFkuoNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA1NzAxMw==", "bodyText": "see above - do not use info level", "url": "https://github.com/oracle/helidon/pull/1280#discussion_r374057013", "createdAt": "2020-02-03T11:41:59Z", "author": {"login": "tomas-langer"}, "path": "microprofile/tyrus/src/main/java/io/helidon/microprofile/tyrus/WebSocketCdiExtension.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.microprofile.tyrus;\n+\n+import java.util.logging.Logger;\n+\n+import javax.enterprise.event.Observes;\n+import javax.enterprise.inject.spi.Extension;\n+import javax.enterprise.inject.spi.ProcessAnnotatedType;\n+import javax.enterprise.inject.spi.WithAnnotations;\n+import javax.websocket.Endpoint;\n+import javax.websocket.server.ServerApplicationConfig;\n+import javax.websocket.server.ServerEndpoint;\n+\n+import io.helidon.common.HelidonFeatures;\n+import io.helidon.common.HelidonFlavor;\n+\n+/**\n+ * Configure Tyrus related things.\n+ */\n+public class WebSocketCdiExtension implements Extension {\n+    private static final Logger LOGGER = Logger.getLogger(WebSocketCdiExtension.class.getName());\n+\n+    static {\n+        HelidonFeatures.register(HelidonFlavor.MP, \"WebSocket\");\n+    }\n+\n+    private WebSocketApplication.Builder appBuilder = WebSocketApplication.builder();\n+\n+    /**\n+     * Collect application class extending {@code ServerApplicationConfig}.\n+     *\n+     * @param applicationClass Application class.\n+     */\n+    private void applicationClass(@Observes ProcessAnnotatedType<? extends ServerApplicationConfig> applicationClass) {\n+        LOGGER.info(() -> \"Application class found \" + applicationClass.getAnnotatedType().getJavaClass());\n+        appBuilder.applicationClass(applicationClass.getAnnotatedType().getJavaClass());\n+    }\n+\n+    /**\n+     * Overrides a websocket application class.\n+     *\n+     * @param applicationClass Application class.\n+     */\n+    public void applicationClass(Class<? extends ServerApplicationConfig> applicationClass) {\n+        LOGGER.info(() -> \"Using manually set application class  \" + applicationClass);\n+        appBuilder.updateApplicationClass(applicationClass);\n+    }\n+\n+    /**\n+     * Collect annotated endpoints.\n+     *\n+     * @param endpoint The endpoint.\n+     */\n+    private void endpointClasses(@Observes @WithAnnotations(ServerEndpoint.class) ProcessAnnotatedType<?> endpoint) {\n+        LOGGER.info(() -> \"Annotated endpoint found \" + endpoint.getAnnotatedType().getJavaClass());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d0e215cfb326c55d421d679515926ec947caa61"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxMzE5OTM5OnYy", "diffSide": "RIGHT", "path": "microprofile/tyrus/src/main/java/io/helidon/microprofile/tyrus/WebSocketCdiExtension.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QxMTo0MjowNFrOFkuoXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QxMTo0MjowNFrOFkuoXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA1NzA1NA==", "bodyText": "see above - do not use info level", "url": "https://github.com/oracle/helidon/pull/1280#discussion_r374057054", "createdAt": "2020-02-03T11:42:04Z", "author": {"login": "tomas-langer"}, "path": "microprofile/tyrus/src/main/java/io/helidon/microprofile/tyrus/WebSocketCdiExtension.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates. All rights reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.microprofile.tyrus;\n+\n+import java.util.logging.Logger;\n+\n+import javax.enterprise.event.Observes;\n+import javax.enterprise.inject.spi.Extension;\n+import javax.enterprise.inject.spi.ProcessAnnotatedType;\n+import javax.enterprise.inject.spi.WithAnnotations;\n+import javax.websocket.Endpoint;\n+import javax.websocket.server.ServerApplicationConfig;\n+import javax.websocket.server.ServerEndpoint;\n+\n+import io.helidon.common.HelidonFeatures;\n+import io.helidon.common.HelidonFlavor;\n+\n+/**\n+ * Configure Tyrus related things.\n+ */\n+public class WebSocketCdiExtension implements Extension {\n+    private static final Logger LOGGER = Logger.getLogger(WebSocketCdiExtension.class.getName());\n+\n+    static {\n+        HelidonFeatures.register(HelidonFlavor.MP, \"WebSocket\");\n+    }\n+\n+    private WebSocketApplication.Builder appBuilder = WebSocketApplication.builder();\n+\n+    /**\n+     * Collect application class extending {@code ServerApplicationConfig}.\n+     *\n+     * @param applicationClass Application class.\n+     */\n+    private void applicationClass(@Observes ProcessAnnotatedType<? extends ServerApplicationConfig> applicationClass) {\n+        LOGGER.info(() -> \"Application class found \" + applicationClass.getAnnotatedType().getJavaClass());\n+        appBuilder.applicationClass(applicationClass.getAnnotatedType().getJavaClass());\n+    }\n+\n+    /**\n+     * Overrides a websocket application class.\n+     *\n+     * @param applicationClass Application class.\n+     */\n+    public void applicationClass(Class<? extends ServerApplicationConfig> applicationClass) {\n+        LOGGER.info(() -> \"Using manually set application class  \" + applicationClass);\n+        appBuilder.updateApplicationClass(applicationClass);\n+    }\n+\n+    /**\n+     * Collect annotated endpoints.\n+     *\n+     * @param endpoint The endpoint.\n+     */\n+    private void endpointClasses(@Observes @WithAnnotations(ServerEndpoint.class) ProcessAnnotatedType<?> endpoint) {\n+        LOGGER.info(() -> \"Annotated endpoint found \" + endpoint.getAnnotatedType().getJavaClass());\n+        appBuilder.annotatedEndpoint(endpoint.getAnnotatedType().getJavaClass());\n+    }\n+\n+    /**\n+     * Collects programmatic endpoints .\n+     *\n+     * @param endpoint The endpoint.\n+     */\n+    private void endpointConfig(@Observes ProcessAnnotatedType<? extends Endpoint> endpoint) {\n+        LOGGER.info(() -> \"Programmatic endpoint found \" + endpoint.getAnnotatedType().getJavaClass());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d0e215cfb326c55d421d679515926ec947caa61"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxMzIxMTYxOnYy", "diffSide": "RIGHT", "path": "webserver/webserver/src/main/java/io/helidon/webserver/ForwardingHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QxMTo0NjoxOVrOFkuvUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QxMTo0NjoxOVrOFkuvUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA1ODgzMg==", "bodyText": "This looks like a candidate for finest, not fine.\nAlso when constructing a message in log levels lower than info, please use lambda:\nLOGGER.finest(() -> \"...\"  + msg); to avoid string concatenation on every single byte buffer received", "url": "https://github.com/oracle/helidon/pull/1280#discussion_r374058832", "createdAt": "2020-02-03T11:46:19Z", "author": {"login": "tomas-langer"}, "path": "webserver/webserver/src/main/java/io/helidon/webserver/ForwardingHandler.java", "diffHunk": "@@ -178,14 +198,49 @@ protected void channelRead0(ChannelHandlerContext ctx, Object msg) {\n             }\n \n             if (msg instanceof LastHttpContent) {\n-                requestContext.publisher().complete();\n-                requestContext = null; // just to be sure that current http req/res session doesn't interfere with other ones\n+                if (!isWebSocketUpgrade) {\n+                    requestContext.publisher().complete();\n+                    requestContext = null; // just to be sure that current http req/res session doesn't interfere with other ones\n+                }\n             } else if (!content.isReadable()) {\n                 // this is here to handle the case when the content is not readable but we didn't\n                 // exceptionally complete the publisher and close the connection\n                 throw new IllegalStateException(\"It is not expected to not have readable content.\");\n             }\n         }\n+\n+        // We receive a raw bytebuf if connection was upgraded to WebSockets\n+        if (msg instanceof ByteBuf) {\n+            if (!isWebSocketUpgrade) {\n+                throw new IllegalStateException(\"Received ByteBuf without upgrading to WebSockets\");\n+            }\n+            // Simply forward raw bytebuf to Tyrus for processing\n+            LOGGER.fine(\"Received ByteBuf of WebSockets connection\" + msg);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d0e215cfb326c55d421d679515926ec947caa61"}, "originalPosition": 101}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 290, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}