{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk4NjMwNTQz", "number": 2413, "title": "Multi discrepancies", "bodyText": "Signed-off-by: Daniel Kec daniel.kec@oracle.com", "createdAt": "2020-10-06T15:17:50Z", "url": "https://github.com/oracle/helidon/pull/2413", "merged": true, "mergeCommit": {"oid": "9aa8185441f79ac5de54f3a655d1da343c67ba48"}, "closed": true, "closedAt": "2020-10-07T16:28:22Z", "author": {"login": "danielkec"}, "timelineItems": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdP5-GVgH2gAyNDk4NjMwNTQzOmI5YzM0NmY5NWIzMGViMmQ5ZTZjMzM5NzE5OWE0YzYwNGNmNjRkYWU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdQOMjEAFqTUwMzk2NzIyMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "b9c346f95b30eb2d9e6c3397199a4c604cf64dae", "author": {"user": {"login": "danielkec", "name": "Daniel Kec"}}, "url": "https://github.com/oracle/helidon/commit/b9c346f95b30eb2d9e6c3397199a4c604cf64dae", "committedDate": "2020-10-06T15:18:31Z", "message": "Multi discrepancies\n\nSigned-off-by: Daniel Kec <daniel.kec@oracle.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAzMTA5MDcy", "url": "https://github.com/oracle/helidon/pull/2413#pullrequestreview-503109072", "createdAt": "2020-10-06T15:45:08Z", "commit": {"oid": "b9c346f95b30eb2d9e6c3397199a4c604cf64dae"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxNTo0NTowOFrOHdOT1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNlQxNTo1OTo0OFrOHdO9uw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQwNTIwNg==", "bodyText": "I am not sure why you added the masking of the value. getAndUpdate returns the value that existed before - so comparing to just REQUEST_ARRIVED in the POC was intentional.\na. in the case that we support masking makes no difference.\nb. if the method is abused, and does get called more than once, the POC would still deliver only one value, and masking will deliver more than one value, and break the spec by delivering onNext after onComplete.", "url": "https://github.com/oracle/helidon/pull/2413#discussion_r500405206", "createdAt": "2020-10-06T15:45:08Z", "author": {"login": "olotenko"}, "path": "common/reactive/src/main/java/io/helidon/common/reactive/DeferredScalarSubscription.java", "diffHunk": "@@ -31,91 +32,66 @@\n \n     private T value;\n \n-    static final int NO_VALUE_NO_REQUEST = 0;\n-    static final int NO_VALUE_HAS_REQUEST = 1;\n-    static final int HAS_VALUE_NO_REQUEST = 2;\n-    static final int HAS_VALUE_HAS_REQUEST = 3;\n-    static final int COMPLETE = 4;\n-    static final int CANCELED = 5;\n+    static final int REQUEST_ARRIVED = 1;\n+    static final int VALUE_ARRIVED = 2;\n+    static final int DONE = REQUEST_ARRIVED | VALUE_ARRIVED;\n+\n \n     DeferredScalarSubscription(Flow.Subscriber<? super T> downstream) {\n         this.downstream = downstream;\n     }\n \n     @Override\n     public void cancel() {\n-        if (getAndSet(CANCELED) != CANCELED) {\n+        if (getAndSet(DONE) != DONE) {\n             value = null;\n         }\n     }\n \n     @Override\n     public final void request(long n) {\n         if (n <= 0L) {\n-            if (getAndSet(CANCELED) != CANCELED) {\n+            if (getAndSet(DONE) != DONE) {\n+                value = null;\n                 downstream.onError(\n                         new IllegalArgumentException(\"Rule \u00a73.9 violated: non-positive requests are forbidden\"));\n             }\n-        } else {\n-            for (;;) {\n-                int state = get();\n-                if (state == HAS_VALUE_NO_REQUEST) {\n-                    T v = value;\n-                    value = null;\n-                    if (compareAndSet(HAS_VALUE_NO_REQUEST, HAS_VALUE_HAS_REQUEST)) {\n-                        downstream.onNext(v);\n-                        if (compareAndSet(HAS_VALUE_HAS_REQUEST, COMPLETE)) {\n-                            downstream.onComplete();\n-                        }\n-                        break;\n-                    }\n-                } else if (state == NO_VALUE_NO_REQUEST) {\n-                    if (compareAndSet(NO_VALUE_NO_REQUEST, NO_VALUE_HAS_REQUEST)) {\n-                        break;\n-                    }\n-                } else {\n-                    // state == COMPLETE\n-                    // state == HAS_VALUE_HAS_REQUEST\n-                    // state == NO_VALUE_HAS_REQUEST\n-                    // state == CANCELED\n-                    break;\n-                }\n-            }\n+            return;\n+        }\n+\n+        int state;\n+        T v;\n+        do {\n+            state = get();\n+            v = value;\n+        } while (!compareAndSet(state, state | REQUEST_ARRIVED));\n+\n+        if (state == VALUE_ARRIVED) {\n+            value = null;\n+            downstream.onNext(v);\n+            downstream.onComplete();\n         }\n     }\n \n     /**\n      * Signal the only item if possible or save it for later when there\n      * is a request for it.\n      * <p>\n-     *     This method should be called at most once and from only one thread.\n+     * This method should be called at most once and from only one thread.\n      * </p>\n+     *\n      * @param item the item to signal and then complete the downstream\n      */\n     public final void complete(T item) {\n-        for (;;) {\n-            int state = get();\n-            if (state == NO_VALUE_HAS_REQUEST) {\n-                if (compareAndSet(NO_VALUE_HAS_REQUEST, HAS_VALUE_HAS_REQUEST)) {\n-                    downstream.onNext(item);\n-                    if (compareAndSet(HAS_VALUE_HAS_REQUEST, COMPLETE)) {\n-                        downstream.onComplete();\n-                    }\n-                    break;\n-                }\n-            } else if (state == NO_VALUE_NO_REQUEST) {\n-                value = item;\n-                if (compareAndSet(NO_VALUE_NO_REQUEST, HAS_VALUE_NO_REQUEST)) {\n-                    break;\n-                }\n-                value = null;\n-            } else {\n-                // state == COMPLETE\n-                // state == HAS_VALUE_NO_REQUEST\n-                // state == HAS_VALUE_HAS_REQUEST\n-                // state == CANCELED\n-                break;\n-            }\n+        value = item; // assert: even if the race occurs, we will deliver one of the items with which complete()\n+        //         has been invoked - we support only the case with a single invocation of complete()\n+        int state = getAndUpdate(n -> n | VALUE_ARRIVED);\n+        if ((state & REQUEST_ARRIVED) == REQUEST_ARRIVED) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b9c346f95b30eb2d9e6c3397199a4c604cf64dae"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDQxNTkzMQ==", "bodyText": "This is not sufficient for the problem that has been discovered. We'll have to address it better.", "url": "https://github.com/oracle/helidon/pull/2413#discussion_r500415931", "createdAt": "2020-10-06T15:59:48Z", "author": {"login": "olotenko"}, "path": "common/reactive/src/main/java/io/helidon/common/reactive/MultiConcatArray.java", "diffHunk": "@@ -98,6 +98,7 @@ public void nextSource() {\n         @Override\n         public void request(long n) {\n             if (n <= 0) {\n+                cancel();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b9c346f95b30eb2d9e6c3397199a4c604cf64dae"}, "originalPosition": 13}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "693ad0157948f60b90673e609cd9b51108973ecc", "author": {"user": {"login": "danielkec", "name": "Daniel Kec"}}, "url": "https://github.com/oracle/helidon/commit/693ad0157948f60b90673e609cd9b51108973ecc", "committedDate": "2020-10-06T20:23:15Z", "message": "Review issues\n\nSigned-off-by: Daniel Kec <daniel.kec@oracle.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAzMzc1MTg1", "url": "https://github.com/oracle/helidon/pull/2413#pullrequestreview-503375185", "createdAt": "2020-10-06T21:32:56Z", "commit": {"oid": "693ad0157948f60b90673e609cd9b51108973ecc"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d3cb64cb1b6cdbe72554d152eb89679d0d8f1f9c", "author": {"user": {"login": "danielkec", "name": "Daniel Kec"}}, "url": "https://github.com/oracle/helidon/commit/d3cb64cb1b6cdbe72554d152eb89679d0d8f1f9c", "committedDate": "2020-10-07T06:23:45Z", "message": "Revert concat array changes\n\nSigned-off-by: Daniel Kec <daniel.kec@oracle.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAzOTY3MjIx", "url": "https://github.com/oracle/helidon/pull/2413#pullrequestreview-503967221", "createdAt": "2020-10-07T14:52:24Z", "commit": {"oid": "b9c346f95b30eb2d9e6c3397199a4c604cf64dae"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 478, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}