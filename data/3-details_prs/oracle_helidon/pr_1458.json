{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgyNDg5MDI0", "number": 1458, "title": "Remove dependency on Jackson via SmallRye -2.x", "bodyText": "Not ready for approval yet -- need to update the helidon-build-tools version in the top-level Helidon pom once we have a new helidon-build-tools release.\nOverview - removing our dependency on Jackson\n(fixes #1109)\nOur OpenAPI implementation layers on SmallRye\u2019s OpenAPI module, which on its own uses Jackson to parse the OpenAPI JSON or YAML and to parse the JSON in OpenAPI @Extension annotations. The SmallRye API has for some time allowed the calling code to \u2014 and Helidon now does \u2014 completely bypass the main parsing (doing so itself before invoking SmallRye), and a recent SmallRye enhancement allows the caller to provide its own way to do the @Extension parsing.\nRemoving the Jackson dependency involves three main areas of change:\n\ncreating the helidon-build-tools SnakeYAML plug-in, (merged separately)\nchanging the Helidon OpenAPI pom to drive that plug-in, and\nchanging the Helidon OpenAPI code to\nenhance the SnakeYAML-created object model for OpenAPI in important ways,\nto parse YAML and JSON using SnakeYAML (rather than leaving that to SmallRye), and\ndriving the SmallRye API slightly differently to accomplish the above.\n\nThe plug-in\nSnakeYAML does a good job identifying properties from the MicroProfile OpenAPI interfaces, but SnakeYAML cannot (nor can any tool that looks only at compiled byte code) build a complete map between the JSON/YAML serialization and the object model. The SnakeYAML API allows callers to provide this additional information.\nThe plug-in analyzes the MP OpenAPI interfaces and the SmallRye implementation classes and generates a class that includes this helper logic for SnakeYAML.\nThe Helidon OpenAPI module component pom.xml\nThe pom:\n\nenhances the dependency on SmallRye to exclude Jackson,\ninvokes the dependency plug-in to extract the source code for the MicroProfile OpenAPI interfaces and the SmallRye implementations, and\ninvokes the new helidon-build-tools SnakeYAML plug-in to generate the helper class.\n\nThe Helidon OpenAPI changes\nThe new plug-in is independent of OpenAPI, yet there are some aspects of the OpenAPI interfaces and the SmallRye implementations that need special attention to correctly map between JSON/YAML and the object model. These adjustments to the model occur in the OpenAPISupport#adjustTypeDescriptions method.\nIn MP OpenAPI 1.1.2, several interfaces extend Map<X, Y>. This \u201cconfuses\u201d SnakeYAML slightly, in that when deserializing a document it instantiates an Object for the children instead of the actual implementation class for the interface Y. MP OpenAPI seems to be abandoning this approach in 2.0, but we still need to deal with it now. That happens in CustomConstructor.\nThe SnakeYAML API relies heavily on the TypeDescription class for conveying non-default information about mapping between documents and the object model. In OpenAPI several interfaces have the same unusual needs, and those are collected in the Helidon OpenAPI-specific ExpandedTypeDescription class. (The class which the plug-in generates takes a type parameter which extends TypeDescription and a factory function for creating new instances of the desired type.)\nFor parsing the OpenAPI @Extension annotation (always JSON), SmallRye accepts an AnnotationScannerExtension which, among other things, supports the parseExtension method. The Helidon version of this is based heavily on the source from SmallRye, the key difference being in how the JSON is parsed and handled. There might be ways of doing this with less code but patterning closely after the (working) SmallRye implementation that uses Jackson seemed wise.\nOru custom Serializer class mostly sets SnakeYAML formatting configuration before invoking SnakeYAML\u2019s Yaml#dump method to serialize the object model. We need to tailor some of the processing beyond what the config settings support, hence the CustomRepresenter and TagSuppressingWriter inner classes. Note that one of those customizations is to work around a bug in the MP OpenAPI TCK (see the comments in the code).", "createdAt": "2020-03-02T16:43:12Z", "url": "https://github.com/oracle/helidon/pull/1458", "merged": true, "mergeCommit": {"oid": "75d5343f293e7d7cab544634342028d837a471df"}, "closed": true, "closedAt": "2020-03-09T15:47:09Z", "author": {"login": "tjquinno"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcIp2XdAH2gAyMzgyNDg5MDI0OmMxZDkwM2FiOGNmOWMwYzBhY2RiZGI2MWVhMWU2Y2Y4OWE5Zjg3YzA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcL_54_AFqTM3MTI5OTI2OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "c1d903ab8cf9c0c0acdbdb61ea1e6cf89a9f87c0", "author": {"user": {"login": "tjquinno", "name": "Tim Quinn"}}, "url": "https://github.com/oracle/helidon/commit/c1d903ab8cf9c0c0acdbdb61ea1e6cf89a9f87c0", "committedDate": "2020-02-28T06:22:58Z", "message": "Remove transitive dep. on jackson from SmallRye OpenAPI implementation"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY3NDk0NzM0", "url": "https://github.com/oracle/helidon/pull/1458#pullrequestreview-367494734", "createdAt": "2020-03-02T20:13:28Z", "commit": {"oid": "c1d903ab8cf9c0c0acdbdb61ea1e6cf89a9f87c0"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 22, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQyMDoxMzoyOFrOFwtsHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQyMDozNzo0MFrOFwuZqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYyNDU0MA==", "bodyText": "Just a quick check to make sure you have to do this, and/or it's the right thing to do.  It struck me as surprising (as a layman reviewer) that the Property superclass wouldn't default to this value.", "url": "https://github.com/oracle/helidon/pull/1458#discussion_r386624540", "createdAt": "2020-03-02T20:13:28Z", "author": {"login": "ljnelson"}, "path": "openapi/src/main/java/io/helidon/openapi/ExpandedTypeDescription.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/*\n+ * Copyright (c) 2019-2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+package io.helidon.openapi;\n+\n+import java.beans.IntrospectionException;\n+import java.beans.PropertyDescriptor;\n+import java.lang.annotation.Annotation;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.microprofile.openapi.models.Extensible;\n+import org.eclipse.microprofile.openapi.models.media.Schema;\n+import org.yaml.snakeyaml.TypeDescription;\n+import org.yaml.snakeyaml.error.YAMLException;\n+import org.yaml.snakeyaml.introspector.MethodProperty;\n+import org.yaml.snakeyaml.introspector.Property;\n+import org.yaml.snakeyaml.introspector.PropertySubstitute;\n+import org.yaml.snakeyaml.introspector.PropertyUtils;\n+import org.yaml.snakeyaml.nodes.Node;\n+import org.yaml.snakeyaml.nodes.ScalarNode;\n+\n+/**\n+ * Extension of {@link TypeDescription} that handles:\n+ * <ul>\n+ *     <li>nested enums,</li>\n+ *     <li>extensible types, and</li>\n+ *     <li>references.</li>\n+ * </ul>\n+ * <p>\n+ *     The OpenAPI document format uses lower-case enum names and values, while the SmallRye\n+ *     definitions use upper-case. This class simplifies adding the special handling for enums\n+ *     declared within a particular class.\n+ * </p>\n+ * <p>\n+ *     Some of the MP OpenAPI items are extensible, meaning they accept sub-item keys with the\n+ *     \"x-\" prefix. This class supports extensions. For scalars it delegates to the normal\n+ *     SnakeYAML processing to correctly type and parse the scalar. For sequences it\n+ *     creates {@code List}s. For mappings it creates {@code Map}s. The subnodes of the lists and\n+ *     maps are handled by the normal SnakeYAML parsing, so the resulting elements in lists and\n+ *     maps are of the SnakeYAML-inferred types.\n+ * </p>\n+ * <p>\n+ *     A subnode {@code $ref} maps to the {@code ref} property on the MP OpenAPI types. This type\n+ *     description simplifies defining the {@code $ref} property to those types that support it.\n+ * </p>\n+ * <p>\n+ *     We use this expanded version of {@code TypeDescription} with the generated SnakeYAMLParserHelper class.\n+ * </p>\n+ */\n+class ExpandedTypeDescription extends TypeDescription {\n+\n+    private static final String EXTENSION_PROPERTY_PREFIX = \"x-\";\n+\n+    private static final PropertyUtils PROPERTY_UTILS = new PropertyUtils();\n+\n+    private Class<?> impl;\n+\n+    /**\n+     * Factory method for ease of chaining other method invocations.\n+     *\n+     * @param clazz interface type to describe\n+     * @param impl implementation class for the interface\n+     * @return resulting TypeDescription\n+     */\n+    static ExpandedTypeDescription create(Class<? extends Object> clazz, Class<?> impl) {\n+\n+        ExpandedTypeDescription result = clazz.equals(Schema.class)\n+                ? new SchemaTypeDescription(clazz, impl) : new ExpandedTypeDescription(clazz, impl);\n+        result.setPropertyUtils(PROPERTY_UTILS);\n+        return result;\n+    }\n+\n+    private ExpandedTypeDescription(Class<? extends Object> clazz, Class<?> impl) {\n+        super(clazz, null, impl);\n+        this.impl = impl;\n+    }\n+\n+    /**\n+     * Adds property handling for a {@code $ref} reference.\n+     *\n+     * @return this type description\n+     */\n+    ExpandedTypeDescription addRef() {\n+        PropertySubstitute sub = new PropertySubstitute(\"$ref\", String.class, \"getRef\", \"setRef\");\n+        sub.setTargetType(impl);\n+        substituteProperty(sub);\n+        return this;\n+    }\n+\n+    /**\n+     * Adds property handling for extensions.\n+     *\n+     * @return this type description\n+     */\n+    ExpandedTypeDescription addExtensions() {\n+        PropertySubstitute sub = new PropertySubstitute(\"extensions\", Map.class, \"getExtensions\", \"setExtensions\");\n+        sub.setTargetType(impl);\n+        substituteProperty(sub);\n+        return this;\n+    }\n+\n+    @Override\n+    public Property getProperty(String name) {\n+        return isExtension(name) ? new ExtensionProperty(name) : super.getProperty(name);\n+    }\n+\n+    Property getPropertyNoEx(String name) {\n+        try {\n+            Property p = getProperty(\"defaultValue\");\n+            return p;\n+        } catch (YAMLException ex) {\n+            if (ex.getMessage().startsWith(\"Unable to find property\")) {\n+                return null;\n+            }\n+            throw ex;\n+        }\n+    }\n+\n+    @Override\n+    public Object newInstance(String propertyName, Node node) {\n+        Property p = getProperty(propertyName);\n+        if (p.getType().isEnum()) {\n+            @SuppressWarnings(\"unchecked\")\n+            Class<Enum> eClass = (Class<Enum>) p.getType();\n+            String valueText = ScalarNode.class.cast(node).getValue();\n+            for (Enum e : eClass.getEnumConstants()) {\n+                if (e.toString().equals(valueText)) {\n+                    return e;\n+                }\n+            }\n+        }\n+        return super.newInstance(propertyName, node);\n+    }\n+\n+    @Override\n+    public boolean setupPropertyType(String key, Node valueNode) {\n+        return setupExtensionType(key, valueNode) || super.setupPropertyType(key, valueNode);\n+    }\n+\n+    void addExcludes(String... propNames) {\n+        if (excludes == Collections.<String>emptySet()) {\n+            excludes = new HashSet<String>();\n+        }\n+        for (String propName : propNames) {\n+            excludes.add(propName);\n+        }\n+    }\n+\n+    /**\n+     * Returns the implementation class associated with this type descr.\n+     *\n+     * @return implementation class\n+     */\n+    Class<?> impl() {\n+        return impl;\n+    }\n+\n+    boolean hasDefaultProperty() {\n+        return getPropertyNoEx(\"defaultValue\") != null;\n+    }\n+\n+    private boolean setupExtensionType(String key, Node valueNode) {\n+        if (isExtension(key)) {\n+            switch (valueNode.getNodeId()) {\n+                case sequence:\n+                    valueNode.setType(List.class);\n+                    return true;\n+\n+                case anchor:\n+                    break;\n+\n+                case mapping:\n+                    valueNode.setType(Map.class);\n+                    return true;\n+\n+                case scalar:\n+                    break;\n+\n+                default:\n+\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean isExtension(String name) {\n+        return name.startsWith(EXTENSION_PROPERTY_PREFIX);\n+    }\n+\n+    /**\n+     * Specific type description for {@code Schema}.\n+     * <p>\n+     *     The {@code Schema} node allows the {@code additionalProperties} subnode to be either\n+     *     {@code Boolean} or another {@code Schema}. This type description provides a customized\n+     *     property description for {@code additionalProperties} that infers which variant a\n+     *     specific node in the document actually uses and then processes it accordingly.\n+     * </p>\n+     */\n+    static class SchemaTypeDescription extends ExpandedTypeDescription {\n+\n+        private static final PropertyDescriptor ADDL_PROPS_PROP_DESCRIPTOR = preparePropertyDescriptor();\n+\n+        private static final Property ADDL_PROPS_PROPERTY =\n+                new MethodProperty(ADDL_PROPS_PROP_DESCRIPTOR) {\n+\n+                    @Override\n+                    public void set(Object object, Object value) throws Exception {\n+                        Schema s = Schema.class.cast(object);\n+                        if (value instanceof Schema) {\n+                            s.setAdditionalPropertiesSchema((Schema) value);\n+                        } else {\n+                            s.setAdditionalPropertiesBoolean((Boolean) value);\n+                        }\n+                    }\n+\n+                    @Override\n+                    public Object get(Object object) {\n+                        Schema s = Schema.class.cast(object);\n+                        Boolean b = s.getAdditionalPropertiesBoolean();\n+                        return b != null ? b : s.getAdditionalPropertiesSchema();\n+                    }\n+                };\n+\n+        private static PropertyDescriptor preparePropertyDescriptor() {\n+            try {\n+                return new PropertyDescriptor(\"additionalProperties\",\n+                        Schema.class.getMethod(\"getAdditionalPropertiesSchema\"),\n+                        Schema.class.getMethod(\"setAdditionalPropertiesSchema\", Schema.class));\n+            } catch (IntrospectionException | NoSuchMethodException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        private SchemaTypeDescription(Class<? extends Object> clazz, Class<?> impl) {\n+            super(clazz, impl);\n+        }\n+\n+        @Override\n+        public Property getProperty(String name) {\n+            return name.equals(\"additionalProperties\") ? ADDL_PROPS_PROPERTY : super.getProperty(name);\n+        }\n+    }\n+\n+    /**\n+     * Property description for an extension subnode.\n+     */\n+    static class ExtensionProperty extends Property {\n+\n+        ExtensionProperty(String name) {\n+            super(name, Object.class);\n+        }\n+\n+        @Override\n+        public Class<?>[] getActualTypeArguments() {\n+            return new Class[0];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1d903ab8cf9c0c0acdbdb61ea1e6cf89a9f87c0"}, "originalPosition": 271}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYyNDcxMg==", "bodyText": "Consider making static", "url": "https://github.com/oracle/helidon/pull/1458#discussion_r386624712", "createdAt": "2020-03-02T20:13:48Z", "author": {"login": "ljnelson"}, "path": "openapi/src/main/java/io/helidon/openapi/ExpandedTypeDescription.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/*\n+ * Copyright (c) 2019-2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+package io.helidon.openapi;\n+\n+import java.beans.IntrospectionException;\n+import java.beans.PropertyDescriptor;\n+import java.lang.annotation.Annotation;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.microprofile.openapi.models.Extensible;\n+import org.eclipse.microprofile.openapi.models.media.Schema;\n+import org.yaml.snakeyaml.TypeDescription;\n+import org.yaml.snakeyaml.error.YAMLException;\n+import org.yaml.snakeyaml.introspector.MethodProperty;\n+import org.yaml.snakeyaml.introspector.Property;\n+import org.yaml.snakeyaml.introspector.PropertySubstitute;\n+import org.yaml.snakeyaml.introspector.PropertyUtils;\n+import org.yaml.snakeyaml.nodes.Node;\n+import org.yaml.snakeyaml.nodes.ScalarNode;\n+\n+/**\n+ * Extension of {@link TypeDescription} that handles:\n+ * <ul>\n+ *     <li>nested enums,</li>\n+ *     <li>extensible types, and</li>\n+ *     <li>references.</li>\n+ * </ul>\n+ * <p>\n+ *     The OpenAPI document format uses lower-case enum names and values, while the SmallRye\n+ *     definitions use upper-case. This class simplifies adding the special handling for enums\n+ *     declared within a particular class.\n+ * </p>\n+ * <p>\n+ *     Some of the MP OpenAPI items are extensible, meaning they accept sub-item keys with the\n+ *     \"x-\" prefix. This class supports extensions. For scalars it delegates to the normal\n+ *     SnakeYAML processing to correctly type and parse the scalar. For sequences it\n+ *     creates {@code List}s. For mappings it creates {@code Map}s. The subnodes of the lists and\n+ *     maps are handled by the normal SnakeYAML parsing, so the resulting elements in lists and\n+ *     maps are of the SnakeYAML-inferred types.\n+ * </p>\n+ * <p>\n+ *     A subnode {@code $ref} maps to the {@code ref} property on the MP OpenAPI types. This type\n+ *     description simplifies defining the {@code $ref} property to those types that support it.\n+ * </p>\n+ * <p>\n+ *     We use this expanded version of {@code TypeDescription} with the generated SnakeYAMLParserHelper class.\n+ * </p>\n+ */\n+class ExpandedTypeDescription extends TypeDescription {\n+\n+    private static final String EXTENSION_PROPERTY_PREFIX = \"x-\";\n+\n+    private static final PropertyUtils PROPERTY_UTILS = new PropertyUtils();\n+\n+    private Class<?> impl;\n+\n+    /**\n+     * Factory method for ease of chaining other method invocations.\n+     *\n+     * @param clazz interface type to describe\n+     * @param impl implementation class for the interface\n+     * @return resulting TypeDescription\n+     */\n+    static ExpandedTypeDescription create(Class<? extends Object> clazz, Class<?> impl) {\n+\n+        ExpandedTypeDescription result = clazz.equals(Schema.class)\n+                ? new SchemaTypeDescription(clazz, impl) : new ExpandedTypeDescription(clazz, impl);\n+        result.setPropertyUtils(PROPERTY_UTILS);\n+        return result;\n+    }\n+\n+    private ExpandedTypeDescription(Class<? extends Object> clazz, Class<?> impl) {\n+        super(clazz, null, impl);\n+        this.impl = impl;\n+    }\n+\n+    /**\n+     * Adds property handling for a {@code $ref} reference.\n+     *\n+     * @return this type description\n+     */\n+    ExpandedTypeDescription addRef() {\n+        PropertySubstitute sub = new PropertySubstitute(\"$ref\", String.class, \"getRef\", \"setRef\");\n+        sub.setTargetType(impl);\n+        substituteProperty(sub);\n+        return this;\n+    }\n+\n+    /**\n+     * Adds property handling for extensions.\n+     *\n+     * @return this type description\n+     */\n+    ExpandedTypeDescription addExtensions() {\n+        PropertySubstitute sub = new PropertySubstitute(\"extensions\", Map.class, \"getExtensions\", \"setExtensions\");\n+        sub.setTargetType(impl);\n+        substituteProperty(sub);\n+        return this;\n+    }\n+\n+    @Override\n+    public Property getProperty(String name) {\n+        return isExtension(name) ? new ExtensionProperty(name) : super.getProperty(name);\n+    }\n+\n+    Property getPropertyNoEx(String name) {\n+        try {\n+            Property p = getProperty(\"defaultValue\");\n+            return p;\n+        } catch (YAMLException ex) {\n+            if (ex.getMessage().startsWith(\"Unable to find property\")) {\n+                return null;\n+            }\n+            throw ex;\n+        }\n+    }\n+\n+    @Override\n+    public Object newInstance(String propertyName, Node node) {\n+        Property p = getProperty(propertyName);\n+        if (p.getType().isEnum()) {\n+            @SuppressWarnings(\"unchecked\")\n+            Class<Enum> eClass = (Class<Enum>) p.getType();\n+            String valueText = ScalarNode.class.cast(node).getValue();\n+            for (Enum e : eClass.getEnumConstants()) {\n+                if (e.toString().equals(valueText)) {\n+                    return e;\n+                }\n+            }\n+        }\n+        return super.newInstance(propertyName, node);\n+    }\n+\n+    @Override\n+    public boolean setupPropertyType(String key, Node valueNode) {\n+        return setupExtensionType(key, valueNode) || super.setupPropertyType(key, valueNode);\n+    }\n+\n+    void addExcludes(String... propNames) {\n+        if (excludes == Collections.<String>emptySet()) {\n+            excludes = new HashSet<String>();\n+        }\n+        for (String propName : propNames) {\n+            excludes.add(propName);\n+        }\n+    }\n+\n+    /**\n+     * Returns the implementation class associated with this type descr.\n+     *\n+     * @return implementation class\n+     */\n+    Class<?> impl() {\n+        return impl;\n+    }\n+\n+    boolean hasDefaultProperty() {\n+        return getPropertyNoEx(\"defaultValue\") != null;\n+    }\n+\n+    private boolean setupExtensionType(String key, Node valueNode) {\n+        if (isExtension(key)) {\n+            switch (valueNode.getNodeId()) {\n+                case sequence:\n+                    valueNode.setType(List.class);\n+                    return true;\n+\n+                case anchor:\n+                    break;\n+\n+                case mapping:\n+                    valueNode.setType(Map.class);\n+                    return true;\n+\n+                case scalar:\n+                    break;\n+\n+                default:\n+\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean isExtension(String name) {\n+        return name.startsWith(EXTENSION_PROPERTY_PREFIX);\n+    }\n+\n+    /**\n+     * Specific type description for {@code Schema}.\n+     * <p>\n+     *     The {@code Schema} node allows the {@code additionalProperties} subnode to be either\n+     *     {@code Boolean} or another {@code Schema}. This type description provides a customized\n+     *     property description for {@code additionalProperties} that infers which variant a\n+     *     specific node in the document actually uses and then processes it accordingly.\n+     * </p>\n+     */\n+    static class SchemaTypeDescription extends ExpandedTypeDescription {\n+\n+        private static final PropertyDescriptor ADDL_PROPS_PROP_DESCRIPTOR = preparePropertyDescriptor();\n+\n+        private static final Property ADDL_PROPS_PROPERTY =\n+                new MethodProperty(ADDL_PROPS_PROP_DESCRIPTOR) {\n+\n+                    @Override\n+                    public void set(Object object, Object value) throws Exception {\n+                        Schema s = Schema.class.cast(object);\n+                        if (value instanceof Schema) {\n+                            s.setAdditionalPropertiesSchema((Schema) value);\n+                        } else {\n+                            s.setAdditionalPropertiesBoolean((Boolean) value);\n+                        }\n+                    }\n+\n+                    @Override\n+                    public Object get(Object object) {\n+                        Schema s = Schema.class.cast(object);\n+                        Boolean b = s.getAdditionalPropertiesBoolean();\n+                        return b != null ? b : s.getAdditionalPropertiesSchema();\n+                    }\n+                };\n+\n+        private static PropertyDescriptor preparePropertyDescriptor() {\n+            try {\n+                return new PropertyDescriptor(\"additionalProperties\",\n+                        Schema.class.getMethod(\"getAdditionalPropertiesSchema\"),\n+                        Schema.class.getMethod(\"setAdditionalPropertiesSchema\", Schema.class));\n+            } catch (IntrospectionException | NoSuchMethodException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        private SchemaTypeDescription(Class<? extends Object> clazz, Class<?> impl) {\n+            super(clazz, impl);\n+        }\n+\n+        @Override\n+        public Property getProperty(String name) {\n+            return name.equals(\"additionalProperties\") ? ADDL_PROPS_PROPERTY : super.getProperty(name);\n+        }\n+    }\n+\n+    /**\n+     * Property description for an extension subnode.\n+     */\n+    static class ExtensionProperty extends Property {\n+\n+        ExtensionProperty(String name) {\n+            super(name, Object.class);\n+        }\n+\n+        @Override\n+        public Class<?>[] getActualTypeArguments() {\n+            return new Class[0];\n+        }\n+\n+        @Override\n+        public void set(Object object, Object value) throws Exception {\n+            asExt(object).addExtension(getName(), value);\n+        }\n+\n+        @Override\n+        public Object get(Object object) {\n+            return asExt(object).getExtensions().get(getName());\n+        }\n+\n+        @Override\n+        public List<Annotation> getAnnotations() {\n+            return null;\n+        }\n+\n+        @Override\n+        public <A extends Annotation> A getAnnotation(Class<A> annotationType) {\n+            return null;\n+        }\n+\n+        private Extensible<?> asExt(Object object) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1d903ab8cf9c0c0acdbdb61ea1e6cf89a9f87c0"}, "originalPosition": 294}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYyNjAwMw==", "bodyText": "These case values surprised me; where are they coming from?  Obviously everything compiles so it's fine but maybe a quick one-liner comment somewhere explaining their provenance.", "url": "https://github.com/oracle/helidon/pull/1458#discussion_r386626003", "createdAt": "2020-03-02T20:16:30Z", "author": {"login": "ljnelson"}, "path": "openapi/src/main/java/io/helidon/openapi/ExpandedTypeDescription.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/*\n+ * Copyright (c) 2019-2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+package io.helidon.openapi;\n+\n+import java.beans.IntrospectionException;\n+import java.beans.PropertyDescriptor;\n+import java.lang.annotation.Annotation;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.microprofile.openapi.models.Extensible;\n+import org.eclipse.microprofile.openapi.models.media.Schema;\n+import org.yaml.snakeyaml.TypeDescription;\n+import org.yaml.snakeyaml.error.YAMLException;\n+import org.yaml.snakeyaml.introspector.MethodProperty;\n+import org.yaml.snakeyaml.introspector.Property;\n+import org.yaml.snakeyaml.introspector.PropertySubstitute;\n+import org.yaml.snakeyaml.introspector.PropertyUtils;\n+import org.yaml.snakeyaml.nodes.Node;\n+import org.yaml.snakeyaml.nodes.ScalarNode;\n+\n+/**\n+ * Extension of {@link TypeDescription} that handles:\n+ * <ul>\n+ *     <li>nested enums,</li>\n+ *     <li>extensible types, and</li>\n+ *     <li>references.</li>\n+ * </ul>\n+ * <p>\n+ *     The OpenAPI document format uses lower-case enum names and values, while the SmallRye\n+ *     definitions use upper-case. This class simplifies adding the special handling for enums\n+ *     declared within a particular class.\n+ * </p>\n+ * <p>\n+ *     Some of the MP OpenAPI items are extensible, meaning they accept sub-item keys with the\n+ *     \"x-\" prefix. This class supports extensions. For scalars it delegates to the normal\n+ *     SnakeYAML processing to correctly type and parse the scalar. For sequences it\n+ *     creates {@code List}s. For mappings it creates {@code Map}s. The subnodes of the lists and\n+ *     maps are handled by the normal SnakeYAML parsing, so the resulting elements in lists and\n+ *     maps are of the SnakeYAML-inferred types.\n+ * </p>\n+ * <p>\n+ *     A subnode {@code $ref} maps to the {@code ref} property on the MP OpenAPI types. This type\n+ *     description simplifies defining the {@code $ref} property to those types that support it.\n+ * </p>\n+ * <p>\n+ *     We use this expanded version of {@code TypeDescription} with the generated SnakeYAMLParserHelper class.\n+ * </p>\n+ */\n+class ExpandedTypeDescription extends TypeDescription {\n+\n+    private static final String EXTENSION_PROPERTY_PREFIX = \"x-\";\n+\n+    private static final PropertyUtils PROPERTY_UTILS = new PropertyUtils();\n+\n+    private Class<?> impl;\n+\n+    /**\n+     * Factory method for ease of chaining other method invocations.\n+     *\n+     * @param clazz interface type to describe\n+     * @param impl implementation class for the interface\n+     * @return resulting TypeDescription\n+     */\n+    static ExpandedTypeDescription create(Class<? extends Object> clazz, Class<?> impl) {\n+\n+        ExpandedTypeDescription result = clazz.equals(Schema.class)\n+                ? new SchemaTypeDescription(clazz, impl) : new ExpandedTypeDescription(clazz, impl);\n+        result.setPropertyUtils(PROPERTY_UTILS);\n+        return result;\n+    }\n+\n+    private ExpandedTypeDescription(Class<? extends Object> clazz, Class<?> impl) {\n+        super(clazz, null, impl);\n+        this.impl = impl;\n+    }\n+\n+    /**\n+     * Adds property handling for a {@code $ref} reference.\n+     *\n+     * @return this type description\n+     */\n+    ExpandedTypeDescription addRef() {\n+        PropertySubstitute sub = new PropertySubstitute(\"$ref\", String.class, \"getRef\", \"setRef\");\n+        sub.setTargetType(impl);\n+        substituteProperty(sub);\n+        return this;\n+    }\n+\n+    /**\n+     * Adds property handling for extensions.\n+     *\n+     * @return this type description\n+     */\n+    ExpandedTypeDescription addExtensions() {\n+        PropertySubstitute sub = new PropertySubstitute(\"extensions\", Map.class, \"getExtensions\", \"setExtensions\");\n+        sub.setTargetType(impl);\n+        substituteProperty(sub);\n+        return this;\n+    }\n+\n+    @Override\n+    public Property getProperty(String name) {\n+        return isExtension(name) ? new ExtensionProperty(name) : super.getProperty(name);\n+    }\n+\n+    Property getPropertyNoEx(String name) {\n+        try {\n+            Property p = getProperty(\"defaultValue\");\n+            return p;\n+        } catch (YAMLException ex) {\n+            if (ex.getMessage().startsWith(\"Unable to find property\")) {\n+                return null;\n+            }\n+            throw ex;\n+        }\n+    }\n+\n+    @Override\n+    public Object newInstance(String propertyName, Node node) {\n+        Property p = getProperty(propertyName);\n+        if (p.getType().isEnum()) {\n+            @SuppressWarnings(\"unchecked\")\n+            Class<Enum> eClass = (Class<Enum>) p.getType();\n+            String valueText = ScalarNode.class.cast(node).getValue();\n+            for (Enum e : eClass.getEnumConstants()) {\n+                if (e.toString().equals(valueText)) {\n+                    return e;\n+                }\n+            }\n+        }\n+        return super.newInstance(propertyName, node);\n+    }\n+\n+    @Override\n+    public boolean setupPropertyType(String key, Node valueNode) {\n+        return setupExtensionType(key, valueNode) || super.setupPropertyType(key, valueNode);\n+    }\n+\n+    void addExcludes(String... propNames) {\n+        if (excludes == Collections.<String>emptySet()) {\n+            excludes = new HashSet<String>();\n+        }\n+        for (String propName : propNames) {\n+            excludes.add(propName);\n+        }\n+    }\n+\n+    /**\n+     * Returns the implementation class associated with this type descr.\n+     *\n+     * @return implementation class\n+     */\n+    Class<?> impl() {\n+        return impl;\n+    }\n+\n+    boolean hasDefaultProperty() {\n+        return getPropertyNoEx(\"defaultValue\") != null;\n+    }\n+\n+    private boolean setupExtensionType(String key, Node valueNode) {\n+        if (isExtension(key)) {\n+            switch (valueNode.getNodeId()) {\n+                case sequence:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1d903ab8cf9c0c0acdbdb61ea1e6cf89a9f87c0"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYyNjQyMQ==", "bodyText": "OK to return null, or should it be Collections.emptyList()?  Don't know the innards of SnakeYAML to know whether one is different from the other.  Obviously avoiding any object allocations is good if possible.", "url": "https://github.com/oracle/helidon/pull/1458#discussion_r386626421", "createdAt": "2020-03-02T20:17:26Z", "author": {"login": "ljnelson"}, "path": "openapi/src/main/java/io/helidon/openapi/ExpandedTypeDescription.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/*\n+ * Copyright (c) 2019-2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+package io.helidon.openapi;\n+\n+import java.beans.IntrospectionException;\n+import java.beans.PropertyDescriptor;\n+import java.lang.annotation.Annotation;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.microprofile.openapi.models.Extensible;\n+import org.eclipse.microprofile.openapi.models.media.Schema;\n+import org.yaml.snakeyaml.TypeDescription;\n+import org.yaml.snakeyaml.error.YAMLException;\n+import org.yaml.snakeyaml.introspector.MethodProperty;\n+import org.yaml.snakeyaml.introspector.Property;\n+import org.yaml.snakeyaml.introspector.PropertySubstitute;\n+import org.yaml.snakeyaml.introspector.PropertyUtils;\n+import org.yaml.snakeyaml.nodes.Node;\n+import org.yaml.snakeyaml.nodes.ScalarNode;\n+\n+/**\n+ * Extension of {@link TypeDescription} that handles:\n+ * <ul>\n+ *     <li>nested enums,</li>\n+ *     <li>extensible types, and</li>\n+ *     <li>references.</li>\n+ * </ul>\n+ * <p>\n+ *     The OpenAPI document format uses lower-case enum names and values, while the SmallRye\n+ *     definitions use upper-case. This class simplifies adding the special handling for enums\n+ *     declared within a particular class.\n+ * </p>\n+ * <p>\n+ *     Some of the MP OpenAPI items are extensible, meaning they accept sub-item keys with the\n+ *     \"x-\" prefix. This class supports extensions. For scalars it delegates to the normal\n+ *     SnakeYAML processing to correctly type and parse the scalar. For sequences it\n+ *     creates {@code List}s. For mappings it creates {@code Map}s. The subnodes of the lists and\n+ *     maps are handled by the normal SnakeYAML parsing, so the resulting elements in lists and\n+ *     maps are of the SnakeYAML-inferred types.\n+ * </p>\n+ * <p>\n+ *     A subnode {@code $ref} maps to the {@code ref} property on the MP OpenAPI types. This type\n+ *     description simplifies defining the {@code $ref} property to those types that support it.\n+ * </p>\n+ * <p>\n+ *     We use this expanded version of {@code TypeDescription} with the generated SnakeYAMLParserHelper class.\n+ * </p>\n+ */\n+class ExpandedTypeDescription extends TypeDescription {\n+\n+    private static final String EXTENSION_PROPERTY_PREFIX = \"x-\";\n+\n+    private static final PropertyUtils PROPERTY_UTILS = new PropertyUtils();\n+\n+    private Class<?> impl;\n+\n+    /**\n+     * Factory method for ease of chaining other method invocations.\n+     *\n+     * @param clazz interface type to describe\n+     * @param impl implementation class for the interface\n+     * @return resulting TypeDescription\n+     */\n+    static ExpandedTypeDescription create(Class<? extends Object> clazz, Class<?> impl) {\n+\n+        ExpandedTypeDescription result = clazz.equals(Schema.class)\n+                ? new SchemaTypeDescription(clazz, impl) : new ExpandedTypeDescription(clazz, impl);\n+        result.setPropertyUtils(PROPERTY_UTILS);\n+        return result;\n+    }\n+\n+    private ExpandedTypeDescription(Class<? extends Object> clazz, Class<?> impl) {\n+        super(clazz, null, impl);\n+        this.impl = impl;\n+    }\n+\n+    /**\n+     * Adds property handling for a {@code $ref} reference.\n+     *\n+     * @return this type description\n+     */\n+    ExpandedTypeDescription addRef() {\n+        PropertySubstitute sub = new PropertySubstitute(\"$ref\", String.class, \"getRef\", \"setRef\");\n+        sub.setTargetType(impl);\n+        substituteProperty(sub);\n+        return this;\n+    }\n+\n+    /**\n+     * Adds property handling for extensions.\n+     *\n+     * @return this type description\n+     */\n+    ExpandedTypeDescription addExtensions() {\n+        PropertySubstitute sub = new PropertySubstitute(\"extensions\", Map.class, \"getExtensions\", \"setExtensions\");\n+        sub.setTargetType(impl);\n+        substituteProperty(sub);\n+        return this;\n+    }\n+\n+    @Override\n+    public Property getProperty(String name) {\n+        return isExtension(name) ? new ExtensionProperty(name) : super.getProperty(name);\n+    }\n+\n+    Property getPropertyNoEx(String name) {\n+        try {\n+            Property p = getProperty(\"defaultValue\");\n+            return p;\n+        } catch (YAMLException ex) {\n+            if (ex.getMessage().startsWith(\"Unable to find property\")) {\n+                return null;\n+            }\n+            throw ex;\n+        }\n+    }\n+\n+    @Override\n+    public Object newInstance(String propertyName, Node node) {\n+        Property p = getProperty(propertyName);\n+        if (p.getType().isEnum()) {\n+            @SuppressWarnings(\"unchecked\")\n+            Class<Enum> eClass = (Class<Enum>) p.getType();\n+            String valueText = ScalarNode.class.cast(node).getValue();\n+            for (Enum e : eClass.getEnumConstants()) {\n+                if (e.toString().equals(valueText)) {\n+                    return e;\n+                }\n+            }\n+        }\n+        return super.newInstance(propertyName, node);\n+    }\n+\n+    @Override\n+    public boolean setupPropertyType(String key, Node valueNode) {\n+        return setupExtensionType(key, valueNode) || super.setupPropertyType(key, valueNode);\n+    }\n+\n+    void addExcludes(String... propNames) {\n+        if (excludes == Collections.<String>emptySet()) {\n+            excludes = new HashSet<String>();\n+        }\n+        for (String propName : propNames) {\n+            excludes.add(propName);\n+        }\n+    }\n+\n+    /**\n+     * Returns the implementation class associated with this type descr.\n+     *\n+     * @return implementation class\n+     */\n+    Class<?> impl() {\n+        return impl;\n+    }\n+\n+    boolean hasDefaultProperty() {\n+        return getPropertyNoEx(\"defaultValue\") != null;\n+    }\n+\n+    private boolean setupExtensionType(String key, Node valueNode) {\n+        if (isExtension(key)) {\n+            switch (valueNode.getNodeId()) {\n+                case sequence:\n+                    valueNode.setType(List.class);\n+                    return true;\n+\n+                case anchor:\n+                    break;\n+\n+                case mapping:\n+                    valueNode.setType(Map.class);\n+                    return true;\n+\n+                case scalar:\n+                    break;\n+\n+                default:\n+\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean isExtension(String name) {\n+        return name.startsWith(EXTENSION_PROPERTY_PREFIX);\n+    }\n+\n+    /**\n+     * Specific type description for {@code Schema}.\n+     * <p>\n+     *     The {@code Schema} node allows the {@code additionalProperties} subnode to be either\n+     *     {@code Boolean} or another {@code Schema}. This type description provides a customized\n+     *     property description for {@code additionalProperties} that infers which variant a\n+     *     specific node in the document actually uses and then processes it accordingly.\n+     * </p>\n+     */\n+    static class SchemaTypeDescription extends ExpandedTypeDescription {\n+\n+        private static final PropertyDescriptor ADDL_PROPS_PROP_DESCRIPTOR = preparePropertyDescriptor();\n+\n+        private static final Property ADDL_PROPS_PROPERTY =\n+                new MethodProperty(ADDL_PROPS_PROP_DESCRIPTOR) {\n+\n+                    @Override\n+                    public void set(Object object, Object value) throws Exception {\n+                        Schema s = Schema.class.cast(object);\n+                        if (value instanceof Schema) {\n+                            s.setAdditionalPropertiesSchema((Schema) value);\n+                        } else {\n+                            s.setAdditionalPropertiesBoolean((Boolean) value);\n+                        }\n+                    }\n+\n+                    @Override\n+                    public Object get(Object object) {\n+                        Schema s = Schema.class.cast(object);\n+                        Boolean b = s.getAdditionalPropertiesBoolean();\n+                        return b != null ? b : s.getAdditionalPropertiesSchema();\n+                    }\n+                };\n+\n+        private static PropertyDescriptor preparePropertyDescriptor() {\n+            try {\n+                return new PropertyDescriptor(\"additionalProperties\",\n+                        Schema.class.getMethod(\"getAdditionalPropertiesSchema\"),\n+                        Schema.class.getMethod(\"setAdditionalPropertiesSchema\", Schema.class));\n+            } catch (IntrospectionException | NoSuchMethodException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        private SchemaTypeDescription(Class<? extends Object> clazz, Class<?> impl) {\n+            super(clazz, impl);\n+        }\n+\n+        @Override\n+        public Property getProperty(String name) {\n+            return name.equals(\"additionalProperties\") ? ADDL_PROPS_PROPERTY : super.getProperty(name);\n+        }\n+    }\n+\n+    /**\n+     * Property description for an extension subnode.\n+     */\n+    static class ExtensionProperty extends Property {\n+\n+        ExtensionProperty(String name) {\n+            super(name, Object.class);\n+        }\n+\n+        @Override\n+        public Class<?>[] getActualTypeArguments() {\n+            return new Class[0];\n+        }\n+\n+        @Override\n+        public void set(Object object, Object value) throws Exception {\n+            asExt(object).addExtension(getName(), value);\n+        }\n+\n+        @Override\n+        public Object get(Object object) {\n+            return asExt(object).getExtensions().get(getName());\n+        }\n+\n+        @Override\n+        public List<Annotation> getAnnotations() {\n+            return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1d903ab8cf9c0c0acdbdb61ea1e6cf89a9f87c0"}, "originalPosition": 286}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYyNjY0OQ==", "bodyText": "Layman reviewer note: surprised me to see Impl as a prefix; was expecting a suffix here.  This is true even when I read your class comment.  I'm not sure what would be a better name.  Maybe DelegatingTypeDescription?", "url": "https://github.com/oracle/helidon/pull/1458#discussion_r386626649", "createdAt": "2020-03-02T20:17:57Z", "author": {"login": "ljnelson"}, "path": "openapi/src/main/java/io/helidon/openapi/ImplTypeDescription.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+package io.helidon.openapi;\n+\n+import java.util.Set;\n+\n+import org.yaml.snakeyaml.TypeDescription;\n+import org.yaml.snakeyaml.introspector.Property;\n+import org.yaml.snakeyaml.introspector.PropertySubstitute;\n+import org.yaml.snakeyaml.introspector.PropertyUtils;\n+import org.yaml.snakeyaml.nodes.Node;\n+import org.yaml.snakeyaml.nodes.Tag;\n+\n+/**\n+ * Version of {@code TypeDescription} used for implementation classes (rather than the corresponding interfaces) which delegate\n+ * most method invocations to the {@code TypeDescription} for the related interface.\n+ */\n+class ImplTypeDescription extends TypeDescription {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1d903ab8cf9c0c0acdbdb61ea1e6cf89a9f87c0"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYyNzMyNg==", "bodyText": "Could this be final?", "url": "https://github.com/oracle/helidon/pull/1458#discussion_r386627326", "createdAt": "2020-03-02T20:19:23Z", "author": {"login": "ljnelson"}, "path": "openapi/src/main/java/io/helidon/openapi/OpenAPIParser.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+package io.helidon.openapi;\n+\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+\n+import org.eclipse.microprofile.openapi.models.OpenAPI;\n+import org.yaml.snakeyaml.TypeDescription;\n+import org.yaml.snakeyaml.Yaml;\n+import org.yaml.snakeyaml.constructor.Constructor;\n+\n+/**\n+ * Abstraction for SnakeYAML parsing of JSON and YAML.\n+ */\n+class OpenAPIParser {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1d903ab8cf9c0c0acdbdb61ea1e6cf89a9f87c0"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYyNzg3Ng==", "bodyText": "Do we know if the Reader is closed?  I assume Yaml does in fact consume the whole thing and closes it afterwards (a pet peeve of mine, but I digress).  A quick comment noting this would be good here.", "url": "https://github.com/oracle/helidon/pull/1458#discussion_r386627876", "createdAt": "2020-03-02T20:20:34Z", "author": {"login": "ljnelson"}, "path": "openapi/src/main/java/io/helidon/openapi/OpenAPIParser.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+package io.helidon.openapi;\n+\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.Reader;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+\n+import org.eclipse.microprofile.openapi.models.OpenAPI;\n+import org.yaml.snakeyaml.TypeDescription;\n+import org.yaml.snakeyaml.Yaml;\n+import org.yaml.snakeyaml.constructor.Constructor;\n+\n+/**\n+ * Abstraction for SnakeYAML parsing of JSON and YAML.\n+ */\n+class OpenAPIParser {\n+\n+    private OpenAPIParser() {\n+    }\n+\n+    static OpenAPI parse(Map<Class<?>, ExpandedTypeDescription> types, InputStream inputStream,\n+            OpenAPISupport.OpenAPIMediaType openAPIMediaType) {\n+        Reader reader = new InputStreamReader(inputStream, StandardCharsets.UTF_8);\n+        return parse(types, reader, openAPIMediaType);\n+    }\n+\n+    static OpenAPI parse(Map<Class<?>, ExpandedTypeDescription> types, Reader reader,\n+            OpenAPISupport.OpenAPIMediaType openAPIMediaType) {\n+        TypeDescription openAPITD = types.get(OpenAPI.class);\n+        Constructor topConstructor = new CustomConstructor(openAPITD);\n+\n+        types.values()\n+                .forEach(topConstructor::addTypeDescription);\n+\n+        Yaml yaml = new Yaml(topConstructor);\n+        OpenAPI result = yaml.loadAs(reader, OpenAPI.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1d903ab8cf9c0c0acdbdb61ea1e6cf89a9f87c0"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYyODM1Nw==", "bodyText": "Nit: consider \"Specialized SnakeYAML Constructor\"", "url": "https://github.com/oracle/helidon/pull/1458#discussion_r386628357", "createdAt": "2020-03-02T20:21:34Z", "author": {"login": "ljnelson"}, "path": "openapi/src/main/java/io/helidon/openapi/CustomConstructor.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright (c) 2019-2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+package io.helidon.openapi;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.microprofile.openapi.models.PathItem;\n+import org.eclipse.microprofile.openapi.models.Paths;\n+import org.eclipse.microprofile.openapi.models.callbacks.Callback;\n+import org.eclipse.microprofile.openapi.models.media.Content;\n+import org.eclipse.microprofile.openapi.models.media.MediaType;\n+import org.eclipse.microprofile.openapi.models.responses.APIResponse;\n+import org.eclipse.microprofile.openapi.models.responses.APIResponses;\n+import org.eclipse.microprofile.openapi.models.security.Scopes;\n+import org.eclipse.microprofile.openapi.models.security.SecurityRequirement;\n+import org.eclipse.microprofile.openapi.models.servers.ServerVariable;\n+import org.eclipse.microprofile.openapi.models.servers.ServerVariables;\n+import org.yaml.snakeyaml.TypeDescription;\n+import org.yaml.snakeyaml.constructor.Constructor;\n+import org.yaml.snakeyaml.nodes.MappingNode;\n+import org.yaml.snakeyaml.nodes.Node;\n+import org.yaml.snakeyaml.nodes.NodeId;\n+import org.yaml.snakeyaml.nodes.SequenceNode;\n+\n+/**\n+ * Specialized constructor for modifying {@code Node} objects for OpenAPI types that extend {@code Map} to adjust the type of", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1d903ab8cf9c0c0acdbdb61ea1e6cf89a9f87c0"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYyODkyNQ==", "bodyText": "Reading along, perhaps you effectively answer this later, perhaps not: can this be final?", "url": "https://github.com/oracle/helidon/pull/1458#discussion_r386628925", "createdAt": "2020-03-02T20:22:41Z", "author": {"login": "ljnelson"}, "path": "openapi/src/main/java/io/helidon/openapi/CustomConstructor.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright (c) 2019-2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+package io.helidon.openapi;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.microprofile.openapi.models.PathItem;\n+import org.eclipse.microprofile.openapi.models.Paths;\n+import org.eclipse.microprofile.openapi.models.callbacks.Callback;\n+import org.eclipse.microprofile.openapi.models.media.Content;\n+import org.eclipse.microprofile.openapi.models.media.MediaType;\n+import org.eclipse.microprofile.openapi.models.responses.APIResponse;\n+import org.eclipse.microprofile.openapi.models.responses.APIResponses;\n+import org.eclipse.microprofile.openapi.models.security.Scopes;\n+import org.eclipse.microprofile.openapi.models.security.SecurityRequirement;\n+import org.eclipse.microprofile.openapi.models.servers.ServerVariable;\n+import org.eclipse.microprofile.openapi.models.servers.ServerVariables;\n+import org.yaml.snakeyaml.TypeDescription;\n+import org.yaml.snakeyaml.constructor.Constructor;\n+import org.yaml.snakeyaml.nodes.MappingNode;\n+import org.yaml.snakeyaml.nodes.Node;\n+import org.yaml.snakeyaml.nodes.NodeId;\n+import org.yaml.snakeyaml.nodes.SequenceNode;\n+\n+/**\n+ * Specialized constructor for modifying {@code Node} objects for OpenAPI types that extend {@code Map} to adjust the type of\n+ * the child nodes of such nodes.\n+ * <p>\n+ * Several MicroProfile OpenAPI interfaces extend {@code Map}. For example, {@code Paths} extends {@code Map\n+ * <String, PathItem>} and {@code SecurityRequirement} extends {@code Map<String, List<String>>}. When SnakeYAML builds the node\n+ * corresponding to one of these types, it correctly creates each child node as a {@code MappingNode} but it assigns those\n+ * child nodes a type of {@code Object} instead of the mapped type -- {@code PathItem} in the example above.\n+ * </p>\n+ * <p>\n+ * This class customizes the preparation of the node tree in these situations by setting the types for the child nodes explicitly\n+ * to the corresponding child type. In OpenAPI 1.1.2 there are two situations, depending on whether the mapped-to type is a\n+ * {@code List} or not.\n+ * </p>\n+ * <p>\n+ * The MicroProfile OpenAPI 2.0 versions of the interfaces no longer use this construct of an interface extending {@code Map}, so\n+ * ideally we can remove this workaround when we adopt 2.0.\n+ * </p>\n+ */\n+class CustomConstructor extends Constructor {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1d903ab8cf9c0c0acdbdb61ea1e6cf89a9f87c0"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYyOTM3NQ==", "bodyText": "Can this be final?", "url": "https://github.com/oracle/helidon/pull/1458#discussion_r386629375", "createdAt": "2020-03-02T20:23:37Z", "author": {"login": "ljnelson"}, "path": "openapi/src/main/java/io/helidon/openapi/ExpandedTypeDescription.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/*\n+ * Copyright (c) 2019-2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+package io.helidon.openapi;\n+\n+import java.beans.IntrospectionException;\n+import java.beans.PropertyDescriptor;\n+import java.lang.annotation.Annotation;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.microprofile.openapi.models.Extensible;\n+import org.eclipse.microprofile.openapi.models.media.Schema;\n+import org.yaml.snakeyaml.TypeDescription;\n+import org.yaml.snakeyaml.error.YAMLException;\n+import org.yaml.snakeyaml.introspector.MethodProperty;\n+import org.yaml.snakeyaml.introspector.Property;\n+import org.yaml.snakeyaml.introspector.PropertySubstitute;\n+import org.yaml.snakeyaml.introspector.PropertyUtils;\n+import org.yaml.snakeyaml.nodes.Node;\n+import org.yaml.snakeyaml.nodes.ScalarNode;\n+\n+/**\n+ * Extension of {@link TypeDescription} that handles:\n+ * <ul>\n+ *     <li>nested enums,</li>\n+ *     <li>extensible types, and</li>\n+ *     <li>references.</li>\n+ * </ul>\n+ * <p>\n+ *     The OpenAPI document format uses lower-case enum names and values, while the SmallRye\n+ *     definitions use upper-case. This class simplifies adding the special handling for enums\n+ *     declared within a particular class.\n+ * </p>\n+ * <p>\n+ *     Some of the MP OpenAPI items are extensible, meaning they accept sub-item keys with the\n+ *     \"x-\" prefix. This class supports extensions. For scalars it delegates to the normal\n+ *     SnakeYAML processing to correctly type and parse the scalar. For sequences it\n+ *     creates {@code List}s. For mappings it creates {@code Map}s. The subnodes of the lists and\n+ *     maps are handled by the normal SnakeYAML parsing, so the resulting elements in lists and\n+ *     maps are of the SnakeYAML-inferred types.\n+ * </p>\n+ * <p>\n+ *     A subnode {@code $ref} maps to the {@code ref} property on the MP OpenAPI types. This type\n+ *     description simplifies defining the {@code $ref} property to those types that support it.\n+ * </p>\n+ * <p>\n+ *     We use this expanded version of {@code TypeDescription} with the generated SnakeYAMLParserHelper class.\n+ * </p>\n+ */\n+class ExpandedTypeDescription extends TypeDescription {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1d903ab8cf9c0c0acdbdb61ea1e6cf89a9f87c0"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYzMDMzOA==", "bodyText": "Consider wrapping this in Collections.unmodifiableMap().", "url": "https://github.com/oracle/helidon/pull/1458#discussion_r386630338", "createdAt": "2020-03-02T20:25:42Z", "author": {"login": "ljnelson"}, "path": "openapi/src/main/java/io/helidon/openapi/OpenAPISupport.java", "diffHunk": "@@ -116,6 +149,88 @@ public void configureEndpoint(Routing.Rules rules) {\n                 .get(webContext, this::prepareResponse);\n     }\n \n+    static synchronized SnakeYAMLParserHelper<ExpandedTypeDescription> helper() {\n+        if (helper == null) {\n+            helper = SnakeYAMLParserHelper.create(ExpandedTypeDescription::create);\n+            adjustTypeDescriptions(helper.types());\n+        }\n+        return helper;\n+    }\n+\n+    static Map<Class<?>, ExpandedTypeDescription> buildImplsToTypes(SnakeYAMLParserHelper<ExpandedTypeDescription> helper) {\n+        return helper.entrySet().stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1d903ab8cf9c0c0acdbdb61ea1e6cf89a9f87c0"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYzMDczMg==", "bodyText": "Just a note to say I appreciate the comments!!", "url": "https://github.com/oracle/helidon/pull/1458#discussion_r386630732", "createdAt": "2020-03-02T20:26:26Z", "author": {"login": "ljnelson"}, "path": "openapi/src/main/java/io/helidon/openapi/OpenAPISupport.java", "diffHunk": "@@ -116,6 +149,88 @@ public void configureEndpoint(Routing.Rules rules) {\n                 .get(webContext, this::prepareResponse);\n     }\n \n+    static synchronized SnakeYAMLParserHelper<ExpandedTypeDescription> helper() {\n+        if (helper == null) {\n+            helper = SnakeYAMLParserHelper.create(ExpandedTypeDescription::create);\n+            adjustTypeDescriptions(helper.types());\n+        }\n+        return helper;\n+    }\n+\n+    static Map<Class<?>, ExpandedTypeDescription> buildImplsToTypes(SnakeYAMLParserHelper<ExpandedTypeDescription> helper) {\n+        return helper.entrySet().stream()\n+                .map(Map.Entry::getValue)\n+                .collect(Collectors.toMap(ExpandedTypeDescription::impl, Function.identity()));\n+    }\n+\n+    private static void adjustTypeDescriptions(Map<Class<?>, ExpandedTypeDescription> types) {\n+        /*\n+         * We need to adjust the {@code TypeDescription} objects set up by the generated {@code SnakeYAMLParserHelper} class\n+         * because there are some OpenAPI-specific issues that the general-purpose helper generator cannot know about.\n+         */\n+\n+        /*\n+         * In the OpenAPI document, HTTP methods are expressed in lower-case. But the associated Java methods on the PathItem\n+         * class use the HTTP method names in upper-case. So for each HTTP method, \"add\" a property to PathItem's type\n+         * description using the lower-case name but upper-case Java methods and exclude the upper-case property that\n+         * SnakeYAML's automatic analysis of the class already created.\n+         */\n+        ExpandedTypeDescription pathItemTD = types.get(PathItem.class);\n+        for (PathItem.HttpMethod m : PathItem.HttpMethod.values()) {\n+            pathItemTD.substituteProperty(m.name().toLowerCase(), Operation.class, getter(m), setter(m));\n+            pathItemTD.addExcludes(m.name());\n+        }\n+\n+        /*\n+         * An OpenAPI document can contain a property named \"enum\" for Schema and ServerVariable, but the related Java methods\n+         * use \"enumeration\".\n+         */\n+        Set.<Class<?>>of(Schema.class, ServerVariable.class).forEach(c -> {\n+            ExpandedTypeDescription tdWithEnumeration = types.get(c);\n+            tdWithEnumeration.substituteProperty(\"enum\", List.class, \"getEnumeration\", \"setEnumeration\");\n+            tdWithEnumeration.addPropertyParameters(\"enum\", String.class);\n+            tdWithEnumeration.addExcludes(\"enumeration\");\n+        });\n+\n+        /*\n+         * SnakeYAML derives properties only from methods declared directly by each OpenAPI interface, not from methods defined\n+         *  on other interfaces which the original one extends. Those we have to handle explicitly.\n+         */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1d903ab8cf9c0c0acdbdb61ea1e6cf89a9f87c0"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYzMjE1MA==", "bodyText": "Whoops", "url": "https://github.com/oracle/helidon/pull/1458#discussion_r386632150", "createdAt": "2020-03-02T20:29:04Z", "author": {"login": "ljnelson"}, "path": "openapi/src/main/java/io/helidon/openapi/OpenAPISupport.java", "diffHunk": "@@ -132,8 +247,10 @@ private OpenAPI prepareModel(OpenApiConfig config, IndexView indexView, OpenApiS\n                 OpenApiDocument.INSTANCE.reset();\n                 OpenApiDocument.INSTANCE.config(config);\n                 OpenApiDocument.INSTANCE.modelFromReader(OpenApiProcessor.modelFromReader(config, getContextClassLoader()));\n-                OpenApiDocument.INSTANCE.modelFromStaticFile(OpenApiProcessor.modelFromStaticFile(staticFile));\n-                if (isAnnotationProcessingEnabled(config)) {\n+                if (staticFile != null) {\n+                    OpenApiDocument.INSTANCE.modelFromStaticFile(OpenAPIParser.parse(helper().types(), staticFile.getContent(),\n+                            OpenAPIMediaType.byFormat(staticFile.getFormat())));\n+                }if (isAnnotationProcessingEnabled(config)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1d903ab8cf9c0c0acdbdb61ea1e6cf89a9f87c0"}, "originalPosition": 184}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYzMjUwMw==", "bodyText": "The old version would let RuntimeExceptions be thrown here; not sure if you intended to catch them as well.", "url": "https://github.com/oracle/helidon/pull/1458#discussion_r386632503", "createdAt": "2020-03-02T20:29:48Z", "author": {"login": "ljnelson"}, "path": "openapi/src/main/java/io/helidon/openapi/OpenAPISupport.java", "diffHunk": "@@ -182,7 +305,7 @@ private void prepareResponse(ServerRequest req, ServerResponse resp) {\n             resp.status(Http.Status.OK_200);\n             resp.headers().add(Http.Header.CONTENT_TYPE, resultMediaType.toString());\n             resp.send(openAPIDocument);\n-        } catch (IOException ex) {\n+        } catch (Exception ex) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1d903ab8cf9c0c0acdbdb61ea1e6cf89a9f87c0"}, "originalPosition": 210}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYzMjkyMQ==", "bodyText": "Maybe equalsIgnoreCase()?", "url": "https://github.com/oracle/helidon/pull/1458#discussion_r386632921", "createdAt": "2020-03-02T20:30:45Z", "author": {"login": "ljnelson"}, "path": "openapi/src/main/java/io/helidon/openapi/OpenAPISupport.java", "diffHunk": "@@ -252,6 +375,92 @@ private MediaType chooseResponseMediaType(ServerRequest req) {\n         return resultMediaType;\n     }\n \n+    /**\n+     * Extension we want SmallRye's OpenAPI implementation to use for parsing the JSON content in Extension annotations.\n+     */\n+    private static class HelidonAnnotationScannerExtension implements AnnotationScannerExtension {\n+\n+        @Override\n+        public Object parseExtension(String key, String value) {\n+\n+            // Inspired by SmallRye's JsonUtil#parseValue method.\n+            if (value == null) {\n+                return null;\n+            }\n+\n+            value = value.trim();\n+\n+            if (\"true\".equals(value) || \"false\".equals(value)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1d903ab8cf9c0c0acdbdb61ea1e6cf89a9f87c0"}, "originalPosition": 284}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYzMzkwMA==", "bodyText": "Hazy old memories of making sure that SnakeYAML's SafeConstructor or something is in play; I'll try to dig for more details.", "url": "https://github.com/oracle/helidon/pull/1458#discussion_r386633900", "createdAt": "2020-03-02T20:32:52Z", "author": {"login": "ljnelson"}, "path": "openapi/src/main/java/io/helidon/openapi/Serializer.java", "diffHunk": "@@ -0,0 +1,349 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+package io.helidon.openapi;\n+\n+import java.io.PrintWriter;\n+import java.io.Writer;\n+import java.lang.annotation.Annotation;\n+import java.nio.CharBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.logging.Logger;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import io.smallrye.openapi.api.models.OpenAPIImpl;\n+import io.smallrye.openapi.runtime.io.OpenApiSerializer;\n+import org.eclipse.microprofile.openapi.models.Extensible;\n+import org.eclipse.microprofile.openapi.models.OpenAPI;\n+import org.eclipse.microprofile.openapi.models.parameters.Parameter;\n+import org.yaml.snakeyaml.DumperOptions;\n+import org.yaml.snakeyaml.Yaml;\n+import org.yaml.snakeyaml.introspector.Property;\n+import org.yaml.snakeyaml.nodes.MappingNode;\n+import org.yaml.snakeyaml.nodes.Node;\n+import org.yaml.snakeyaml.nodes.NodeId;\n+import org.yaml.snakeyaml.nodes.NodeTuple;\n+import org.yaml.snakeyaml.nodes.ScalarNode;\n+import org.yaml.snakeyaml.nodes.Tag;\n+import org.yaml.snakeyaml.representer.Representer;\n+\n+/**\n+ * Expresses an existing {@code OpenAPI} instance as an OpenAPI document. This implementation uses\n+ * SnakeYAML to write OpenAPI documents from the SmallRye MP OpenAPI model interfaces and classes\n+ * while suppressing tags that would indicate the SmallRye classes -- we don't want to\n+ * suggest that the output can only be read into the SmallRye implementation.\n+ */\n+class Serializer {\n+\n+    private static final DumperOptions YAML_DUMPER_OPTIONS = new DumperOptions();\n+    private static final DumperOptions JSON_DUMPER_OPTIONS = new DumperOptions();\n+\n+    private static final Logger LOGGER = Logger.getLogger(Serializer.class.getName());\n+\n+    private Serializer() {\n+    }\n+\n+    static {\n+        YAML_DUMPER_OPTIONS.setIndent(2);\n+        YAML_DUMPER_OPTIONS.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK);\n+\n+        JSON_DUMPER_OPTIONS.setDefaultFlowStyle(DumperOptions.FlowStyle.FLOW);\n+        JSON_DUMPER_OPTIONS.setPrettyFlow(true);\n+        JSON_DUMPER_OPTIONS.setDefaultScalarStyle(DumperOptions.ScalarStyle.DOUBLE_QUOTED);\n+        JSON_DUMPER_OPTIONS.setSplitLines(false);\n+    }\n+\n+    static void serialize(Map<Class<?>, ExpandedTypeDescription> types, Map<Class<?>, ExpandedTypeDescription> implsToTypes,\n+            OpenAPI openAPI, OpenApiSerializer.Format fmt,\n+            Writer writer) {\n+        if (fmt == OpenApiSerializer.Format.JSON) {\n+            serialize(types, implsToTypes, openAPI, writer, JSON_DUMPER_OPTIONS, DumperOptions.ScalarStyle.DOUBLE_QUOTED);\n+        } else {\n+            serialize(types, implsToTypes, openAPI, writer, YAML_DUMPER_OPTIONS, DumperOptions.ScalarStyle.PLAIN);\n+        }\n+    }\n+\n+    private static void serialize(Map<Class<?>, ExpandedTypeDescription> types,\n+            Map<Class<?>, ExpandedTypeDescription> implsToTypes, OpenAPI openAPI, Writer writer,\n+            DumperOptions dumperOptions,\n+            DumperOptions.ScalarStyle stringStyle) {\n+\n+        Yaml yaml = new Yaml(new CustomRepresenter(types, implsToTypes, dumperOptions, stringStyle), dumperOptions);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1d903ab8cf9c0c0acdbdb61ea1e6cf89a9f87c0"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYzNDQwMw==", "bodyText": "Maybe put in a finally block?", "url": "https://github.com/oracle/helidon/pull/1458#discussion_r386634403", "createdAt": "2020-03-02T20:33:55Z", "author": {"login": "ljnelson"}, "path": "openapi/src/main/java/io/helidon/openapi/Serializer.java", "diffHunk": "@@ -0,0 +1,349 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+package io.helidon.openapi;\n+\n+import java.io.PrintWriter;\n+import java.io.Writer;\n+import java.lang.annotation.Annotation;\n+import java.nio.CharBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.logging.Logger;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import io.smallrye.openapi.api.models.OpenAPIImpl;\n+import io.smallrye.openapi.runtime.io.OpenApiSerializer;\n+import org.eclipse.microprofile.openapi.models.Extensible;\n+import org.eclipse.microprofile.openapi.models.OpenAPI;\n+import org.eclipse.microprofile.openapi.models.parameters.Parameter;\n+import org.yaml.snakeyaml.DumperOptions;\n+import org.yaml.snakeyaml.Yaml;\n+import org.yaml.snakeyaml.introspector.Property;\n+import org.yaml.snakeyaml.nodes.MappingNode;\n+import org.yaml.snakeyaml.nodes.Node;\n+import org.yaml.snakeyaml.nodes.NodeId;\n+import org.yaml.snakeyaml.nodes.NodeTuple;\n+import org.yaml.snakeyaml.nodes.ScalarNode;\n+import org.yaml.snakeyaml.nodes.Tag;\n+import org.yaml.snakeyaml.representer.Representer;\n+\n+/**\n+ * Expresses an existing {@code OpenAPI} instance as an OpenAPI document. This implementation uses\n+ * SnakeYAML to write OpenAPI documents from the SmallRye MP OpenAPI model interfaces and classes\n+ * while suppressing tags that would indicate the SmallRye classes -- we don't want to\n+ * suggest that the output can only be read into the SmallRye implementation.\n+ */\n+class Serializer {\n+\n+    private static final DumperOptions YAML_DUMPER_OPTIONS = new DumperOptions();\n+    private static final DumperOptions JSON_DUMPER_OPTIONS = new DumperOptions();\n+\n+    private static final Logger LOGGER = Logger.getLogger(Serializer.class.getName());\n+\n+    private Serializer() {\n+    }\n+\n+    static {\n+        YAML_DUMPER_OPTIONS.setIndent(2);\n+        YAML_DUMPER_OPTIONS.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK);\n+\n+        JSON_DUMPER_OPTIONS.setDefaultFlowStyle(DumperOptions.FlowStyle.FLOW);\n+        JSON_DUMPER_OPTIONS.setPrettyFlow(true);\n+        JSON_DUMPER_OPTIONS.setDefaultScalarStyle(DumperOptions.ScalarStyle.DOUBLE_QUOTED);\n+        JSON_DUMPER_OPTIONS.setSplitLines(false);\n+    }\n+\n+    static void serialize(Map<Class<?>, ExpandedTypeDescription> types, Map<Class<?>, ExpandedTypeDescription> implsToTypes,\n+            OpenAPI openAPI, OpenApiSerializer.Format fmt,\n+            Writer writer) {\n+        if (fmt == OpenApiSerializer.Format.JSON) {\n+            serialize(types, implsToTypes, openAPI, writer, JSON_DUMPER_OPTIONS, DumperOptions.ScalarStyle.DOUBLE_QUOTED);\n+        } else {\n+            serialize(types, implsToTypes, openAPI, writer, YAML_DUMPER_OPTIONS, DumperOptions.ScalarStyle.PLAIN);\n+        }\n+    }\n+\n+    private static void serialize(Map<Class<?>, ExpandedTypeDescription> types,\n+            Map<Class<?>, ExpandedTypeDescription> implsToTypes, OpenAPI openAPI, Writer writer,\n+            DumperOptions dumperOptions,\n+            DumperOptions.ScalarStyle stringStyle) {\n+\n+        Yaml yaml = new Yaml(new CustomRepresenter(types, implsToTypes, dumperOptions, stringStyle), dumperOptions);\n+        yaml.dump(openAPI, new TagSuppressingWriter(writer));\n+    }\n+\n+    /**\n+     * Represents the nodes in the OpenAPI document output by:\n+     * <ul>\n+     *     <li>adjusting the output of enum names and values to conform to the OpenAPI spec\n+     *     (lower-case) rather than the SmallRye implementations (upper-case),</li>\n+     *     <li>promotes the children of the property \"extensions\" up one level in the output\n+     *     document as required by the OpenAPI spec, and</li>\n+     *     <li>format scalar string nodes with double-quotes for JSON but not for YAML.</li>\n+     * </ul>\n+     */\n+    static class CustomRepresenter extends Representer {\n+\n+        private static final String EXTENSIONS = \"extensions\";\n+\n+        private final DumperOptions dumperOptions;\n+        private final DumperOptions.ScalarStyle stringStyle;\n+\n+        private final Map<Class<?>, ExpandedTypeDescription> implsToTypes;\n+\n+        CustomRepresenter(Map<Class<?>, ExpandedTypeDescription> types,\n+                Map<Class<?>, ExpandedTypeDescription> implsToTypes, DumperOptions dumperOptions,\n+                DumperOptions.ScalarStyle stringStyle) {\n+            this.implsToTypes = implsToTypes;\n+            this.dumperOptions = dumperOptions;\n+            this.stringStyle = stringStyle;\n+            types.values().stream()\n+                    .map(ImplTypeDescription::new)\n+                    .forEach(this::addTypeDescription);\n+        }\n+\n+        @Override\n+        protected Node representScalar(Tag tag, String value, DumperOptions.ScalarStyle style) {\n+            return super.representScalar(tag, value, isExemptedFromQuotes(tag) ? DumperOptions.ScalarStyle.PLAIN : style);\n+        }\n+\n+        @Override\n+        protected Node representSequence(Tag tag, Iterable<?> sequence, DumperOptions.FlowStyle flowStyle) {\n+            Node result = super.representSequence(tag, sequence, flowStyle);\n+            representedObjects.clear();\n+            return result;\n+        }\n+\n+        private boolean isExemptedFromQuotes(Tag tag) {\n+            return tag.equals(Tag.BINARY) || tag.equals(Tag.BOOL) || tag.equals(Tag.FLOAT)\n+                    || tag.equals(Tag.INT);\n+        }\n+\n+        @Override\n+        protected NodeTuple representJavaBeanProperty(Object javaBean, Property property, Object propertyValue,\n+                Tag customTag) {\n+            if (propertyValue == null) {\n+                return null;\n+            }\n+\n+            Property p = property;\n+            Object v = adjustPropertyValue(propertyValue);\n+            Class<?> type = implsToTypes.get(javaBean.getClass()).getType();\n+            if (type.isEnum()) {\n+                p = new DelegatingProperty(property, property.toString());\n+            }\n+            if (propertyValue instanceof Enum) {\n+                Enum e = (Enum) propertyValue;\n+                v = e.toString();\n+            }\n+            NodeTuple result = okToProcess(javaBean, property)\n+                    ? super.representJavaBeanProperty(javaBean, p, v, customTag) : null;\n+            return result;\n+        }\n+\n+        private Object adjustPropertyValue(Object propertyValue) {\n+            /* Some MP OpenAPI TCK tests expect an integer-style format, even for BigDecimal types, if the\n+             * value is an integer. Because the formatting is done in SnakeYAML code based on the type of the value,\n+             * we need to replace a, for example BigDecimal that happen to be an integer value, with an Integer.\n+             * See https://github.com/eclipse/microprofile-open-api/issues/412\n+             */\n+            if (Number.class.isInstance(propertyValue) && !Boolean.getBoolean(\"io.helidon.openapi.skipTCKWorkaround\")) {\n+                Number n = (Number) propertyValue;\n+                float diff = n.floatValue() - n.intValue();\n+                if (diff == 0) {\n+                    propertyValue = Integer.valueOf(n.intValue());\n+                } else if (Math.abs(diff) < 0.1) {\n+                    LOGGER.warning(String.format(\"Integer approximation of %f did not match but the difference was only %e\",\n+                            n, diff));\n+                }\n+            }\n+            return propertyValue;\n+        }\n+\n+        @Override\n+        protected MappingNode representJavaBean(Set<Property> properties, Object javaBean) {\n+            MappingNode result = super.representJavaBean(properties, javaBean);\n+            processExtensions(result, javaBean);\n+            representedObjects.clear();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1d903ab8cf9c0c0acdbdb61ea1e6cf89a9f87c0"}, "originalPosition": 184}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYzNDg5Ng==", "bodyText": "Been a while since I've seen this operator.  Won't this always assign false to reject?  {Heads off to JLS page}", "url": "https://github.com/oracle/helidon/pull/1458#discussion_r386634896", "createdAt": "2020-03-02T20:34:59Z", "author": {"login": "ljnelson"}, "path": "openapi/src/main/java/io/helidon/openapi/Serializer.java", "diffHunk": "@@ -0,0 +1,349 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+package io.helidon.openapi;\n+\n+import java.io.PrintWriter;\n+import java.io.Writer;\n+import java.lang.annotation.Annotation;\n+import java.nio.CharBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.logging.Logger;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import io.smallrye.openapi.api.models.OpenAPIImpl;\n+import io.smallrye.openapi.runtime.io.OpenApiSerializer;\n+import org.eclipse.microprofile.openapi.models.Extensible;\n+import org.eclipse.microprofile.openapi.models.OpenAPI;\n+import org.eclipse.microprofile.openapi.models.parameters.Parameter;\n+import org.yaml.snakeyaml.DumperOptions;\n+import org.yaml.snakeyaml.Yaml;\n+import org.yaml.snakeyaml.introspector.Property;\n+import org.yaml.snakeyaml.nodes.MappingNode;\n+import org.yaml.snakeyaml.nodes.Node;\n+import org.yaml.snakeyaml.nodes.NodeId;\n+import org.yaml.snakeyaml.nodes.NodeTuple;\n+import org.yaml.snakeyaml.nodes.ScalarNode;\n+import org.yaml.snakeyaml.nodes.Tag;\n+import org.yaml.snakeyaml.representer.Representer;\n+\n+/**\n+ * Expresses an existing {@code OpenAPI} instance as an OpenAPI document. This implementation uses\n+ * SnakeYAML to write OpenAPI documents from the SmallRye MP OpenAPI model interfaces and classes\n+ * while suppressing tags that would indicate the SmallRye classes -- we don't want to\n+ * suggest that the output can only be read into the SmallRye implementation.\n+ */\n+class Serializer {\n+\n+    private static final DumperOptions YAML_DUMPER_OPTIONS = new DumperOptions();\n+    private static final DumperOptions JSON_DUMPER_OPTIONS = new DumperOptions();\n+\n+    private static final Logger LOGGER = Logger.getLogger(Serializer.class.getName());\n+\n+    private Serializer() {\n+    }\n+\n+    static {\n+        YAML_DUMPER_OPTIONS.setIndent(2);\n+        YAML_DUMPER_OPTIONS.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK);\n+\n+        JSON_DUMPER_OPTIONS.setDefaultFlowStyle(DumperOptions.FlowStyle.FLOW);\n+        JSON_DUMPER_OPTIONS.setPrettyFlow(true);\n+        JSON_DUMPER_OPTIONS.setDefaultScalarStyle(DumperOptions.ScalarStyle.DOUBLE_QUOTED);\n+        JSON_DUMPER_OPTIONS.setSplitLines(false);\n+    }\n+\n+    static void serialize(Map<Class<?>, ExpandedTypeDescription> types, Map<Class<?>, ExpandedTypeDescription> implsToTypes,\n+            OpenAPI openAPI, OpenApiSerializer.Format fmt,\n+            Writer writer) {\n+        if (fmt == OpenApiSerializer.Format.JSON) {\n+            serialize(types, implsToTypes, openAPI, writer, JSON_DUMPER_OPTIONS, DumperOptions.ScalarStyle.DOUBLE_QUOTED);\n+        } else {\n+            serialize(types, implsToTypes, openAPI, writer, YAML_DUMPER_OPTIONS, DumperOptions.ScalarStyle.PLAIN);\n+        }\n+    }\n+\n+    private static void serialize(Map<Class<?>, ExpandedTypeDescription> types,\n+            Map<Class<?>, ExpandedTypeDescription> implsToTypes, OpenAPI openAPI, Writer writer,\n+            DumperOptions dumperOptions,\n+            DumperOptions.ScalarStyle stringStyle) {\n+\n+        Yaml yaml = new Yaml(new CustomRepresenter(types, implsToTypes, dumperOptions, stringStyle), dumperOptions);\n+        yaml.dump(openAPI, new TagSuppressingWriter(writer));\n+    }\n+\n+    /**\n+     * Represents the nodes in the OpenAPI document output by:\n+     * <ul>\n+     *     <li>adjusting the output of enum names and values to conform to the OpenAPI spec\n+     *     (lower-case) rather than the SmallRye implementations (upper-case),</li>\n+     *     <li>promotes the children of the property \"extensions\" up one level in the output\n+     *     document as required by the OpenAPI spec, and</li>\n+     *     <li>format scalar string nodes with double-quotes for JSON but not for YAML.</li>\n+     * </ul>\n+     */\n+    static class CustomRepresenter extends Representer {\n+\n+        private static final String EXTENSIONS = \"extensions\";\n+\n+        private final DumperOptions dumperOptions;\n+        private final DumperOptions.ScalarStyle stringStyle;\n+\n+        private final Map<Class<?>, ExpandedTypeDescription> implsToTypes;\n+\n+        CustomRepresenter(Map<Class<?>, ExpandedTypeDescription> types,\n+                Map<Class<?>, ExpandedTypeDescription> implsToTypes, DumperOptions dumperOptions,\n+                DumperOptions.ScalarStyle stringStyle) {\n+            this.implsToTypes = implsToTypes;\n+            this.dumperOptions = dumperOptions;\n+            this.stringStyle = stringStyle;\n+            types.values().stream()\n+                    .map(ImplTypeDescription::new)\n+                    .forEach(this::addTypeDescription);\n+        }\n+\n+        @Override\n+        protected Node representScalar(Tag tag, String value, DumperOptions.ScalarStyle style) {\n+            return super.representScalar(tag, value, isExemptedFromQuotes(tag) ? DumperOptions.ScalarStyle.PLAIN : style);\n+        }\n+\n+        @Override\n+        protected Node representSequence(Tag tag, Iterable<?> sequence, DumperOptions.FlowStyle flowStyle) {\n+            Node result = super.representSequence(tag, sequence, flowStyle);\n+            representedObjects.clear();\n+            return result;\n+        }\n+\n+        private boolean isExemptedFromQuotes(Tag tag) {\n+            return tag.equals(Tag.BINARY) || tag.equals(Tag.BOOL) || tag.equals(Tag.FLOAT)\n+                    || tag.equals(Tag.INT);\n+        }\n+\n+        @Override\n+        protected NodeTuple representJavaBeanProperty(Object javaBean, Property property, Object propertyValue,\n+                Tag customTag) {\n+            if (propertyValue == null) {\n+                return null;\n+            }\n+\n+            Property p = property;\n+            Object v = adjustPropertyValue(propertyValue);\n+            Class<?> type = implsToTypes.get(javaBean.getClass()).getType();\n+            if (type.isEnum()) {\n+                p = new DelegatingProperty(property, property.toString());\n+            }\n+            if (propertyValue instanceof Enum) {\n+                Enum e = (Enum) propertyValue;\n+                v = e.toString();\n+            }\n+            NodeTuple result = okToProcess(javaBean, property)\n+                    ? super.representJavaBeanProperty(javaBean, p, v, customTag) : null;\n+            return result;\n+        }\n+\n+        private Object adjustPropertyValue(Object propertyValue) {\n+            /* Some MP OpenAPI TCK tests expect an integer-style format, even for BigDecimal types, if the\n+             * value is an integer. Because the formatting is done in SnakeYAML code based on the type of the value,\n+             * we need to replace a, for example BigDecimal that happen to be an integer value, with an Integer.\n+             * See https://github.com/eclipse/microprofile-open-api/issues/412\n+             */\n+            if (Number.class.isInstance(propertyValue) && !Boolean.getBoolean(\"io.helidon.openapi.skipTCKWorkaround\")) {\n+                Number n = (Number) propertyValue;\n+                float diff = n.floatValue() - n.intValue();\n+                if (diff == 0) {\n+                    propertyValue = Integer.valueOf(n.intValue());\n+                } else if (Math.abs(diff) < 0.1) {\n+                    LOGGER.warning(String.format(\"Integer approximation of %f did not match but the difference was only %e\",\n+                            n, diff));\n+                }\n+            }\n+            return propertyValue;\n+        }\n+\n+        @Override\n+        protected MappingNode representJavaBean(Set<Property> properties, Object javaBean) {\n+            MappingNode result = super.representJavaBean(properties, javaBean);\n+            processExtensions(result, javaBean);\n+            representedObjects.clear();\n+            return result;\n+        }\n+\n+        private void processExtensions(MappingNode node, Object javaBean) {\n+            if (!Extensible.class.isAssignableFrom(javaBean.getClass())) {\n+                return;\n+            }\n+\n+            List<NodeTuple> tuples = new ArrayList<>(node.getValue());\n+\n+            if (tuples.isEmpty()) {\n+                return;\n+            }\n+            List<NodeTuple> updatedTuples = new ArrayList<>();\n+\n+            tuples.forEach(tuple -> {\n+                Node keyNode = tuple.getKeyNode();\n+                if (keyNode.getTag().equals(Tag.STR)) {\n+                    String key = ((ScalarNode) keyNode).getValue();\n+                    if (key.equals(EXTENSIONS)) {\n+                        Node valueNode = tuple.getValueNode();\n+                        if (valueNode.getNodeId().equals(NodeId.mapping)) {\n+                            MappingNode extensions = MappingNode.class.cast(valueNode);\n+                            updatedTuples.addAll(extensions.getValue());\n+                        }\n+                    } else {\n+                        updatedTuples.add(tuple);\n+                    }\n+                } else {\n+                    updatedTuples.add(tuple);\n+                }\n+            });\n+            node.setValue(updatedTuples);\n+        }\n+\n+        /**\n+         * Some SmallRye implementation classes have properties not supported by the implemented interface, so ignore those or\n+         * the serialized YAML will contain SmallRye-only properties.\n+         *\n+         * @param javaBean the bean being serialized\n+         * @param property the property being serialized\n+         * @return true if the property should be processes; false otherwise\n+         */\n+        private boolean okToProcess(Object javaBean, Property property) {\n+            boolean reject = false;\n+            reject |= Parameter.class.isAssignableFrom(javaBean.getClass()) && property.getName().equals(\"hidden\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1d903ab8cf9c0c0acdbdb61ea1e6cf89a9f87c0"}, "originalPosition": 230}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYzNTIxOA==", "bodyText": "Nit: why reverse the order?", "url": "https://github.com/oracle/helidon/pull/1458#discussion_r386635218", "createdAt": "2020-03-02T20:35:38Z", "author": {"login": "ljnelson"}, "path": "openapi/src/main/java/io/helidon/openapi/Serializer.java", "diffHunk": "@@ -0,0 +1,349 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+package io.helidon.openapi;\n+\n+import java.io.PrintWriter;\n+import java.io.Writer;\n+import java.lang.annotation.Annotation;\n+import java.nio.CharBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.logging.Logger;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import io.smallrye.openapi.api.models.OpenAPIImpl;\n+import io.smallrye.openapi.runtime.io.OpenApiSerializer;\n+import org.eclipse.microprofile.openapi.models.Extensible;\n+import org.eclipse.microprofile.openapi.models.OpenAPI;\n+import org.eclipse.microprofile.openapi.models.parameters.Parameter;\n+import org.yaml.snakeyaml.DumperOptions;\n+import org.yaml.snakeyaml.Yaml;\n+import org.yaml.snakeyaml.introspector.Property;\n+import org.yaml.snakeyaml.nodes.MappingNode;\n+import org.yaml.snakeyaml.nodes.Node;\n+import org.yaml.snakeyaml.nodes.NodeId;\n+import org.yaml.snakeyaml.nodes.NodeTuple;\n+import org.yaml.snakeyaml.nodes.ScalarNode;\n+import org.yaml.snakeyaml.nodes.Tag;\n+import org.yaml.snakeyaml.representer.Representer;\n+\n+/**\n+ * Expresses an existing {@code OpenAPI} instance as an OpenAPI document. This implementation uses\n+ * SnakeYAML to write OpenAPI documents from the SmallRye MP OpenAPI model interfaces and classes\n+ * while suppressing tags that would indicate the SmallRye classes -- we don't want to\n+ * suggest that the output can only be read into the SmallRye implementation.\n+ */\n+class Serializer {\n+\n+    private static final DumperOptions YAML_DUMPER_OPTIONS = new DumperOptions();\n+    private static final DumperOptions JSON_DUMPER_OPTIONS = new DumperOptions();\n+\n+    private static final Logger LOGGER = Logger.getLogger(Serializer.class.getName());\n+\n+    private Serializer() {\n+    }\n+\n+    static {\n+        YAML_DUMPER_OPTIONS.setIndent(2);\n+        YAML_DUMPER_OPTIONS.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK);\n+\n+        JSON_DUMPER_OPTIONS.setDefaultFlowStyle(DumperOptions.FlowStyle.FLOW);\n+        JSON_DUMPER_OPTIONS.setPrettyFlow(true);\n+        JSON_DUMPER_OPTIONS.setDefaultScalarStyle(DumperOptions.ScalarStyle.DOUBLE_QUOTED);\n+        JSON_DUMPER_OPTIONS.setSplitLines(false);\n+    }\n+\n+    static void serialize(Map<Class<?>, ExpandedTypeDescription> types, Map<Class<?>, ExpandedTypeDescription> implsToTypes,\n+            OpenAPI openAPI, OpenApiSerializer.Format fmt,\n+            Writer writer) {\n+        if (fmt == OpenApiSerializer.Format.JSON) {\n+            serialize(types, implsToTypes, openAPI, writer, JSON_DUMPER_OPTIONS, DumperOptions.ScalarStyle.DOUBLE_QUOTED);\n+        } else {\n+            serialize(types, implsToTypes, openAPI, writer, YAML_DUMPER_OPTIONS, DumperOptions.ScalarStyle.PLAIN);\n+        }\n+    }\n+\n+    private static void serialize(Map<Class<?>, ExpandedTypeDescription> types,\n+            Map<Class<?>, ExpandedTypeDescription> implsToTypes, OpenAPI openAPI, Writer writer,\n+            DumperOptions dumperOptions,\n+            DumperOptions.ScalarStyle stringStyle) {\n+\n+        Yaml yaml = new Yaml(new CustomRepresenter(types, implsToTypes, dumperOptions, stringStyle), dumperOptions);\n+        yaml.dump(openAPI, new TagSuppressingWriter(writer));\n+    }\n+\n+    /**\n+     * Represents the nodes in the OpenAPI document output by:\n+     * <ul>\n+     *     <li>adjusting the output of enum names and values to conform to the OpenAPI spec\n+     *     (lower-case) rather than the SmallRye implementations (upper-case),</li>\n+     *     <li>promotes the children of the property \"extensions\" up one level in the output\n+     *     document as required by the OpenAPI spec, and</li>\n+     *     <li>format scalar string nodes with double-quotes for JSON but not for YAML.</li>\n+     * </ul>\n+     */\n+    static class CustomRepresenter extends Representer {\n+\n+        private static final String EXTENSIONS = \"extensions\";\n+\n+        private final DumperOptions dumperOptions;\n+        private final DumperOptions.ScalarStyle stringStyle;\n+\n+        private final Map<Class<?>, ExpandedTypeDescription> implsToTypes;\n+\n+        CustomRepresenter(Map<Class<?>, ExpandedTypeDescription> types,\n+                Map<Class<?>, ExpandedTypeDescription> implsToTypes, DumperOptions dumperOptions,\n+                DumperOptions.ScalarStyle stringStyle) {\n+            this.implsToTypes = implsToTypes;\n+            this.dumperOptions = dumperOptions;\n+            this.stringStyle = stringStyle;\n+            types.values().stream()\n+                    .map(ImplTypeDescription::new)\n+                    .forEach(this::addTypeDescription);\n+        }\n+\n+        @Override\n+        protected Node representScalar(Tag tag, String value, DumperOptions.ScalarStyle style) {\n+            return super.representScalar(tag, value, isExemptedFromQuotes(tag) ? DumperOptions.ScalarStyle.PLAIN : style);\n+        }\n+\n+        @Override\n+        protected Node representSequence(Tag tag, Iterable<?> sequence, DumperOptions.FlowStyle flowStyle) {\n+            Node result = super.representSequence(tag, sequence, flowStyle);\n+            representedObjects.clear();\n+            return result;\n+        }\n+\n+        private boolean isExemptedFromQuotes(Tag tag) {\n+            return tag.equals(Tag.BINARY) || tag.equals(Tag.BOOL) || tag.equals(Tag.FLOAT)\n+                    || tag.equals(Tag.INT);\n+        }\n+\n+        @Override\n+        protected NodeTuple representJavaBeanProperty(Object javaBean, Property property, Object propertyValue,\n+                Tag customTag) {\n+            if (propertyValue == null) {\n+                return null;\n+            }\n+\n+            Property p = property;\n+            Object v = adjustPropertyValue(propertyValue);\n+            Class<?> type = implsToTypes.get(javaBean.getClass()).getType();\n+            if (type.isEnum()) {\n+                p = new DelegatingProperty(property, property.toString());\n+            }\n+            if (propertyValue instanceof Enum) {\n+                Enum e = (Enum) propertyValue;\n+                v = e.toString();\n+            }\n+            NodeTuple result = okToProcess(javaBean, property)\n+                    ? super.representJavaBeanProperty(javaBean, p, v, customTag) : null;\n+            return result;\n+        }\n+\n+        private Object adjustPropertyValue(Object propertyValue) {\n+            /* Some MP OpenAPI TCK tests expect an integer-style format, even for BigDecimal types, if the\n+             * value is an integer. Because the formatting is done in SnakeYAML code based on the type of the value,\n+             * we need to replace a, for example BigDecimal that happen to be an integer value, with an Integer.\n+             * See https://github.com/eclipse/microprofile-open-api/issues/412\n+             */\n+            if (Number.class.isInstance(propertyValue) && !Boolean.getBoolean(\"io.helidon.openapi.skipTCKWorkaround\")) {\n+                Number n = (Number) propertyValue;\n+                float diff = n.floatValue() - n.intValue();\n+                if (diff == 0) {\n+                    propertyValue = Integer.valueOf(n.intValue());\n+                } else if (Math.abs(diff) < 0.1) {\n+                    LOGGER.warning(String.format(\"Integer approximation of %f did not match but the difference was only %e\",\n+                            n, diff));\n+                }\n+            }\n+            return propertyValue;\n+        }\n+\n+        @Override\n+        protected MappingNode representJavaBean(Set<Property> properties, Object javaBean) {\n+            MappingNode result = super.representJavaBean(properties, javaBean);\n+            processExtensions(result, javaBean);\n+            representedObjects.clear();\n+            return result;\n+        }\n+\n+        private void processExtensions(MappingNode node, Object javaBean) {\n+            if (!Extensible.class.isAssignableFrom(javaBean.getClass())) {\n+                return;\n+            }\n+\n+            List<NodeTuple> tuples = new ArrayList<>(node.getValue());\n+\n+            if (tuples.isEmpty()) {\n+                return;\n+            }\n+            List<NodeTuple> updatedTuples = new ArrayList<>();\n+\n+            tuples.forEach(tuple -> {\n+                Node keyNode = tuple.getKeyNode();\n+                if (keyNode.getTag().equals(Tag.STR)) {\n+                    String key = ((ScalarNode) keyNode).getValue();\n+                    if (key.equals(EXTENSIONS)) {\n+                        Node valueNode = tuple.getValueNode();\n+                        if (valueNode.getNodeId().equals(NodeId.mapping)) {\n+                            MappingNode extensions = MappingNode.class.cast(valueNode);\n+                            updatedTuples.addAll(extensions.getValue());\n+                        }\n+                    } else {\n+                        updatedTuples.add(tuple);\n+                    }\n+                } else {\n+                    updatedTuples.add(tuple);\n+                }\n+            });\n+            node.setValue(updatedTuples);\n+        }\n+\n+        /**\n+         * Some SmallRye implementation classes have properties not supported by the implemented interface, so ignore those or\n+         * the serialized YAML will contain SmallRye-only properties.\n+         *\n+         * @param javaBean the bean being serialized\n+         * @param property the property being serialized\n+         * @return true if the property should be processes; false otherwise\n+         */\n+        private boolean okToProcess(Object javaBean, Property property) {\n+            boolean reject = false;\n+            reject |= Parameter.class.isAssignableFrom(javaBean.getClass()) && property.getName().equals(\"hidden\");\n+            return !reject;\n+        }\n+    }\n+\n+    /**\n+     * Suppress the tag output for SmallRye implementation classes so the resulting document can be read into any MP OpenAPI\n+     * implementation, not just SmallRye's.\n+     */\n+    static class TagSuppressingWriter extends PrintWriter {\n+\n+        private static final Pattern SMALLRYE_IMPL_TAG_PATTERN =\n+                Pattern.compile(\"!!\" + Pattern.quote(OpenAPIImpl.class.getPackage().getName()) + \".+$\");\n+\n+        TagSuppressingWriter(Writer out) {\n+            super(out);\n+        }\n+\n+        @Override\n+        public void write(char[] cbuf, int off, int len) {\n+            int effLen = detag(CharBuffer.wrap(cbuf), off, len);\n+            if (effLen > 0) {\n+                super.write(cbuf, off, effLen);\n+            }\n+        }\n+\n+        @Override\n+        public void write(String s, int off, int len) {\n+            int effLen = detag(s, off, len);\n+            if (effLen > 0) {\n+                super.write(s, off, effLen);\n+            }\n+        }\n+\n+        private int detag(CharSequence cs, int off, int len) {\n+            int result = len;\n+            Matcher m = SMALLRYE_IMPL_TAG_PATTERN.matcher(cs.subSequence(off, off + len));\n+            if (m.matches()) {\n+                result = len - (m.end() - m.start());\n+            }\n+\n+            return result;\n+        }\n+    }\n+\n+    private static class DelegatingProperty extends Property {\n+\n+        private final Property delegate;\n+\n+        private DelegatingProperty(Property delegate, String name) {\n+            super(name, delegate.getType());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1d903ab8cf9c0c0acdbdb61ea1e6cf89a9f87c0"}, "originalPosition": 280}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYzNTUzMw==", "bodyText": "Surprise: was expecting delegate.  Don't know if that's on purpose or not.", "url": "https://github.com/oracle/helidon/pull/1458#discussion_r386635533", "createdAt": "2020-03-02T20:36:14Z", "author": {"login": "ljnelson"}, "path": "openapi/src/main/java/io/helidon/openapi/Serializer.java", "diffHunk": "@@ -0,0 +1,349 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+package io.helidon.openapi;\n+\n+import java.io.PrintWriter;\n+import java.io.Writer;\n+import java.lang.annotation.Annotation;\n+import java.nio.CharBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.logging.Logger;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import io.smallrye.openapi.api.models.OpenAPIImpl;\n+import io.smallrye.openapi.runtime.io.OpenApiSerializer;\n+import org.eclipse.microprofile.openapi.models.Extensible;\n+import org.eclipse.microprofile.openapi.models.OpenAPI;\n+import org.eclipse.microprofile.openapi.models.parameters.Parameter;\n+import org.yaml.snakeyaml.DumperOptions;\n+import org.yaml.snakeyaml.Yaml;\n+import org.yaml.snakeyaml.introspector.Property;\n+import org.yaml.snakeyaml.nodes.MappingNode;\n+import org.yaml.snakeyaml.nodes.Node;\n+import org.yaml.snakeyaml.nodes.NodeId;\n+import org.yaml.snakeyaml.nodes.NodeTuple;\n+import org.yaml.snakeyaml.nodes.ScalarNode;\n+import org.yaml.snakeyaml.nodes.Tag;\n+import org.yaml.snakeyaml.representer.Representer;\n+\n+/**\n+ * Expresses an existing {@code OpenAPI} instance as an OpenAPI document. This implementation uses\n+ * SnakeYAML to write OpenAPI documents from the SmallRye MP OpenAPI model interfaces and classes\n+ * while suppressing tags that would indicate the SmallRye classes -- we don't want to\n+ * suggest that the output can only be read into the SmallRye implementation.\n+ */\n+class Serializer {\n+\n+    private static final DumperOptions YAML_DUMPER_OPTIONS = new DumperOptions();\n+    private static final DumperOptions JSON_DUMPER_OPTIONS = new DumperOptions();\n+\n+    private static final Logger LOGGER = Logger.getLogger(Serializer.class.getName());\n+\n+    private Serializer() {\n+    }\n+\n+    static {\n+        YAML_DUMPER_OPTIONS.setIndent(2);\n+        YAML_DUMPER_OPTIONS.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK);\n+\n+        JSON_DUMPER_OPTIONS.setDefaultFlowStyle(DumperOptions.FlowStyle.FLOW);\n+        JSON_DUMPER_OPTIONS.setPrettyFlow(true);\n+        JSON_DUMPER_OPTIONS.setDefaultScalarStyle(DumperOptions.ScalarStyle.DOUBLE_QUOTED);\n+        JSON_DUMPER_OPTIONS.setSplitLines(false);\n+    }\n+\n+    static void serialize(Map<Class<?>, ExpandedTypeDescription> types, Map<Class<?>, ExpandedTypeDescription> implsToTypes,\n+            OpenAPI openAPI, OpenApiSerializer.Format fmt,\n+            Writer writer) {\n+        if (fmt == OpenApiSerializer.Format.JSON) {\n+            serialize(types, implsToTypes, openAPI, writer, JSON_DUMPER_OPTIONS, DumperOptions.ScalarStyle.DOUBLE_QUOTED);\n+        } else {\n+            serialize(types, implsToTypes, openAPI, writer, YAML_DUMPER_OPTIONS, DumperOptions.ScalarStyle.PLAIN);\n+        }\n+    }\n+\n+    private static void serialize(Map<Class<?>, ExpandedTypeDescription> types,\n+            Map<Class<?>, ExpandedTypeDescription> implsToTypes, OpenAPI openAPI, Writer writer,\n+            DumperOptions dumperOptions,\n+            DumperOptions.ScalarStyle stringStyle) {\n+\n+        Yaml yaml = new Yaml(new CustomRepresenter(types, implsToTypes, dumperOptions, stringStyle), dumperOptions);\n+        yaml.dump(openAPI, new TagSuppressingWriter(writer));\n+    }\n+\n+    /**\n+     * Represents the nodes in the OpenAPI document output by:\n+     * <ul>\n+     *     <li>adjusting the output of enum names and values to conform to the OpenAPI spec\n+     *     (lower-case) rather than the SmallRye implementations (upper-case),</li>\n+     *     <li>promotes the children of the property \"extensions\" up one level in the output\n+     *     document as required by the OpenAPI spec, and</li>\n+     *     <li>format scalar string nodes with double-quotes for JSON but not for YAML.</li>\n+     * </ul>\n+     */\n+    static class CustomRepresenter extends Representer {\n+\n+        private static final String EXTENSIONS = \"extensions\";\n+\n+        private final DumperOptions dumperOptions;\n+        private final DumperOptions.ScalarStyle stringStyle;\n+\n+        private final Map<Class<?>, ExpandedTypeDescription> implsToTypes;\n+\n+        CustomRepresenter(Map<Class<?>, ExpandedTypeDescription> types,\n+                Map<Class<?>, ExpandedTypeDescription> implsToTypes, DumperOptions dumperOptions,\n+                DumperOptions.ScalarStyle stringStyle) {\n+            this.implsToTypes = implsToTypes;\n+            this.dumperOptions = dumperOptions;\n+            this.stringStyle = stringStyle;\n+            types.values().stream()\n+                    .map(ImplTypeDescription::new)\n+                    .forEach(this::addTypeDescription);\n+        }\n+\n+        @Override\n+        protected Node representScalar(Tag tag, String value, DumperOptions.ScalarStyle style) {\n+            return super.representScalar(tag, value, isExemptedFromQuotes(tag) ? DumperOptions.ScalarStyle.PLAIN : style);\n+        }\n+\n+        @Override\n+        protected Node representSequence(Tag tag, Iterable<?> sequence, DumperOptions.FlowStyle flowStyle) {\n+            Node result = super.representSequence(tag, sequence, flowStyle);\n+            representedObjects.clear();\n+            return result;\n+        }\n+\n+        private boolean isExemptedFromQuotes(Tag tag) {\n+            return tag.equals(Tag.BINARY) || tag.equals(Tag.BOOL) || tag.equals(Tag.FLOAT)\n+                    || tag.equals(Tag.INT);\n+        }\n+\n+        @Override\n+        protected NodeTuple representJavaBeanProperty(Object javaBean, Property property, Object propertyValue,\n+                Tag customTag) {\n+            if (propertyValue == null) {\n+                return null;\n+            }\n+\n+            Property p = property;\n+            Object v = adjustPropertyValue(propertyValue);\n+            Class<?> type = implsToTypes.get(javaBean.getClass()).getType();\n+            if (type.isEnum()) {\n+                p = new DelegatingProperty(property, property.toString());\n+            }\n+            if (propertyValue instanceof Enum) {\n+                Enum e = (Enum) propertyValue;\n+                v = e.toString();\n+            }\n+            NodeTuple result = okToProcess(javaBean, property)\n+                    ? super.representJavaBeanProperty(javaBean, p, v, customTag) : null;\n+            return result;\n+        }\n+\n+        private Object adjustPropertyValue(Object propertyValue) {\n+            /* Some MP OpenAPI TCK tests expect an integer-style format, even for BigDecimal types, if the\n+             * value is an integer. Because the formatting is done in SnakeYAML code based on the type of the value,\n+             * we need to replace a, for example BigDecimal that happen to be an integer value, with an Integer.\n+             * See https://github.com/eclipse/microprofile-open-api/issues/412\n+             */\n+            if (Number.class.isInstance(propertyValue) && !Boolean.getBoolean(\"io.helidon.openapi.skipTCKWorkaround\")) {\n+                Number n = (Number) propertyValue;\n+                float diff = n.floatValue() - n.intValue();\n+                if (diff == 0) {\n+                    propertyValue = Integer.valueOf(n.intValue());\n+                } else if (Math.abs(diff) < 0.1) {\n+                    LOGGER.warning(String.format(\"Integer approximation of %f did not match but the difference was only %e\",\n+                            n, diff));\n+                }\n+            }\n+            return propertyValue;\n+        }\n+\n+        @Override\n+        protected MappingNode representJavaBean(Set<Property> properties, Object javaBean) {\n+            MappingNode result = super.representJavaBean(properties, javaBean);\n+            processExtensions(result, javaBean);\n+            representedObjects.clear();\n+            return result;\n+        }\n+\n+        private void processExtensions(MappingNode node, Object javaBean) {\n+            if (!Extensible.class.isAssignableFrom(javaBean.getClass())) {\n+                return;\n+            }\n+\n+            List<NodeTuple> tuples = new ArrayList<>(node.getValue());\n+\n+            if (tuples.isEmpty()) {\n+                return;\n+            }\n+            List<NodeTuple> updatedTuples = new ArrayList<>();\n+\n+            tuples.forEach(tuple -> {\n+                Node keyNode = tuple.getKeyNode();\n+                if (keyNode.getTag().equals(Tag.STR)) {\n+                    String key = ((ScalarNode) keyNode).getValue();\n+                    if (key.equals(EXTENSIONS)) {\n+                        Node valueNode = tuple.getValueNode();\n+                        if (valueNode.getNodeId().equals(NodeId.mapping)) {\n+                            MappingNode extensions = MappingNode.class.cast(valueNode);\n+                            updatedTuples.addAll(extensions.getValue());\n+                        }\n+                    } else {\n+                        updatedTuples.add(tuple);\n+                    }\n+                } else {\n+                    updatedTuples.add(tuple);\n+                }\n+            });\n+            node.setValue(updatedTuples);\n+        }\n+\n+        /**\n+         * Some SmallRye implementation classes have properties not supported by the implemented interface, so ignore those or\n+         * the serialized YAML will contain SmallRye-only properties.\n+         *\n+         * @param javaBean the bean being serialized\n+         * @param property the property being serialized\n+         * @return true if the property should be processes; false otherwise\n+         */\n+        private boolean okToProcess(Object javaBean, Property property) {\n+            boolean reject = false;\n+            reject |= Parameter.class.isAssignableFrom(javaBean.getClass()) && property.getName().equals(\"hidden\");\n+            return !reject;\n+        }\n+    }\n+\n+    /**\n+     * Suppress the tag output for SmallRye implementation classes so the resulting document can be read into any MP OpenAPI\n+     * implementation, not just SmallRye's.\n+     */\n+    static class TagSuppressingWriter extends PrintWriter {\n+\n+        private static final Pattern SMALLRYE_IMPL_TAG_PATTERN =\n+                Pattern.compile(\"!!\" + Pattern.quote(OpenAPIImpl.class.getPackage().getName()) + \".+$\");\n+\n+        TagSuppressingWriter(Writer out) {\n+            super(out);\n+        }\n+\n+        @Override\n+        public void write(char[] cbuf, int off, int len) {\n+            int effLen = detag(CharBuffer.wrap(cbuf), off, len);\n+            if (effLen > 0) {\n+                super.write(cbuf, off, effLen);\n+            }\n+        }\n+\n+        @Override\n+        public void write(String s, int off, int len) {\n+            int effLen = detag(s, off, len);\n+            if (effLen > 0) {\n+                super.write(s, off, effLen);\n+            }\n+        }\n+\n+        private int detag(CharSequence cs, int off, int len) {\n+            int result = len;\n+            Matcher m = SMALLRYE_IMPL_TAG_PATTERN.matcher(cs.subSequence(off, off + len));\n+            if (m.matches()) {\n+                result = len - (m.end() - m.start());\n+            }\n+\n+            return result;\n+        }\n+    }\n+\n+    private static class DelegatingProperty extends Property {\n+\n+        private final Property delegate;\n+\n+        private DelegatingProperty(Property delegate, String name) {\n+            super(name, delegate.getType());\n+            this.delegate = delegate;\n+        }\n+\n+        @Override\n+        public Class<?> getType() {\n+            return delegate.getType();\n+        }\n+\n+        @Override\n+        public Class<?>[] getActualTypeArguments() {\n+            return delegate.getActualTypeArguments();\n+        }\n+\n+        @Override\n+        public String getName() {\n+            return super.getName();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1d903ab8cf9c0c0acdbdb61ea1e6cf89a9f87c0"}, "originalPosition": 296}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYzNTc2NA==", "bodyText": "Nit: java.beans, yes?", "url": "https://github.com/oracle/helidon/pull/1458#discussion_r386635764", "createdAt": "2020-03-02T20:36:42Z", "author": {"login": "ljnelson"}, "path": "openapi/src/main/java/module-info.java", "diffHunk": "@@ -27,6 +27,9 @@\n     requires jandex;\n \n     requires smallrye.open.api;\n+    requires java.json;\n+    requires java.desktop; // for java.bean package", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1d903ab8cf9c0c0acdbdb61ea1e6cf89a9f87c0"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYzNjIwMw==", "bodyText": "Nit: any kind of close operation that needs to be performed here?", "url": "https://github.com/oracle/helidon/pull/1458#discussion_r386636203", "createdAt": "2020-03-02T20:37:40Z", "author": {"login": "ljnelson"}, "path": "openapi/src/test/java/io/helidon/openapi/TestUtil.java", "diffHunk": "@@ -221,6 +222,12 @@ public static JsonStructure jsonFromResponse(HttpURLConnection cnx) throws IOExc\n         return result;\n     }\n \n+    static JsonStructure jsonFromReader(Reader reader) {\n+        JsonReader jsonReader = JSON_READER_FACTORY.createReader(reader);\n+        JsonStructure result = jsonReader.read();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c1d903ab8cf9c0c0acdbdb61ea1e6cf89a9f87c0"}, "originalPosition": 21}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "29c648df31bcbfdbd917d384347a7a6e82a69ee1", "author": {"user": {"login": "tjquinno", "name": "Tim Quinn"}}, "url": "https://github.com/oracle/helidon/commit/29c648df31bcbfdbd917d384347a7a6e82a69ee1", "committedDate": "2020-03-03T11:34:30Z", "message": "Respond to review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e9b79e8db3a05f860502508a6ceb2fc5aa32a832", "author": {"user": {"login": "tjquinno", "name": "Tim Quinn"}}, "url": "https://github.com/oracle/helidon/commit/e9b79e8db3a05f860502508a6ceb2fc5aa32a832", "committedDate": "2020-03-04T15:53:30Z", "message": "Review comment adjustments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7b4cab195a1969dd959bcecf854f7a99e8c8ea30", "author": {"user": {"login": "tjquinno", "name": "Tim Quinn"}}, "url": "https://github.com/oracle/helidon/commit/7b4cab195a1969dd959bcecf854f7a99e8c8ea30", "committedDate": "2020-03-04T17:33:09Z", "message": "A few other changes inspired by review comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5MTAyNDA5", "url": "https://github.com/oracle/helidon/pull/1458#pullrequestreview-369102409", "createdAt": "2020-03-04T20:34:46Z", "commit": {"oid": "7b4cab195a1969dd959bcecf854f7a99e8c8ea30"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5MTE4NjI1", "url": "https://github.com/oracle/helidon/pull/1458#pullrequestreview-369118625", "createdAt": "2020-03-04T21:00:30Z", "commit": {"oid": "7b4cab195a1969dd959bcecf854f7a99e8c8ea30"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c93cdee40e726932cbc5ea4529e270de198b9a3a", "author": {"user": {"login": "tjquinno", "name": "Tim Quinn"}}, "url": "https://github.com/oracle/helidon/commit/c93cdee40e726932cbc5ea4529e270de198b9a3a", "committedDate": "2020-03-04T21:39:03Z", "message": "Trivial change to trigger pipeline"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5MTYwMTUw", "url": "https://github.com/oracle/helidon/pull/1458#pullrequestreview-369160150", "createdAt": "2020-03-04T22:08:20Z", "commit": {"oid": "7b4cab195a1969dd959bcecf854f7a99e8c8ea30"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5798e0268a92d83df654872fa22c0b9a142d6de4", "author": {"user": {"login": "tjquinno", "name": "Tim Quinn"}}, "url": "https://github.com/oracle/helidon/commit/5798e0268a92d83df654872fa22c0b9a142d6de4", "committedDate": "2020-03-08T23:48:03Z", "message": "Concurrent changes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "445993b7d5c5d5dd23baa0688d9b2ef81b6ff713", "author": {"user": {"login": "tjquinno", "name": "Tim Quinn"}}, "url": "https://github.com/oracle/helidon/commit/445993b7d5c5d5dd23baa0688d9b2ef81b6ff713", "committedDate": "2020-03-08T23:49:47Z", "message": "Exclude JSON-B via jakarta (as well as existing exclusion)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "88ce4740885f00d2b67e838cc0ab00d98f893a4a", "author": {"user": {"login": "tjquinno", "name": "Tim Quinn"}}, "url": "https://github.com/oracle/helidon/commit/88ce4740885f00d2b67e838cc0ab00d98f893a4a", "committedDate": "2020-03-09T04:42:09Z", "message": "Fix missing quote marks around numeric key in example openapi yaml file"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f12d92359ecc018537a04ad3d78ddaa9b533ebb2", "author": {"user": {"login": "tjquinno", "name": "Tim Quinn"}}, "url": "https://github.com/oracle/helidon/commit/f12d92359ecc018537a04ad3d78ddaa9b533ebb2", "committedDate": "2020-03-09T04:49:11Z", "message": "Fix copyright error"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4b8f8ecdd6f1a836e9fa0c6b4a21191566d0562c", "author": {"user": {"login": "tjquinno", "name": "Tim Quinn"}}, "url": "https://github.com/oracle/helidon/commit/4b8f8ecdd6f1a836e9fa0c6b4a21191566d0562c", "committedDate": "2020-03-09T12:35:21Z", "message": "Old exclusion no longer needed; just the one for jakarta.json.bind-api now"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ed54720e28666124efeab0c718000b25b91b2d87", "author": {"user": {"login": "tjquinno", "name": "Tim Quinn"}}, "url": "https://github.com/oracle/helidon/commit/ed54720e28666124efeab0c718000b25b91b2d87", "committedDate": "2020-03-09T14:48:59Z", "message": "Concurrent changes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxMjk5MjY4", "url": "https://github.com/oracle/helidon/pull/1458#pullrequestreview-371299268", "createdAt": "2020-03-09T15:45:24Z", "commit": {"oid": "ed54720e28666124efeab0c718000b25b91b2d87"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNTo0NToyNVrOFzuMaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNTo0NToyNVrOFzuMaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc3ODUzNw==", "bodyText": "Just a dumb comment: comment says Jackson, artifact is JSON-B, yes?", "url": "https://github.com/oracle/helidon/pull/1458#discussion_r389778537", "createdAt": "2020-03-09T15:45:25Z", "author": {"login": "ljnelson"}, "path": "microprofile/tests/tck/tck-rest-client/pom.xml", "diffHunk": "@@ -37,8 +37,8 @@\n             <exclusions>\n                 <exclusion>\n                     <!-- TCK requires Jackson, not JSON-B -->\n-                    <groupId>org.glassfish.jersey.media</groupId>\n-                    <artifactId>jersey-media-json-binding</artifactId>\n+                    <groupId>jakarta.json.bind</groupId>\n+                    <artifactId>jakarta.json.bind-api</artifactId>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed54720e28666124efeab0c718000b25b91b2d87"}, "originalPosition": 7}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 839, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}