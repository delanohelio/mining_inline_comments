{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA2MDU0NjAx", "number": 2467, "title": "Micronaut integration", "bodyText": "Resolves #2386\nProvides integration with Micronaut as follows:\n\nMicronaut Singleton beans can be injected into CDI beans\nMicronaut interceptors can be used in CDI, as long as proper annotation processor is defined\nSupport for Micronaut Data - tested with JDBC repository (both as an interface and abstract class)\nSupport for Micronaut Bean Validation\nsee example (examples/integrations/micronaut/data)\nNative image support\n\nFollow ups (TODO):\n\nDocumentation pages", "createdAt": "2020-10-19T15:02:01Z", "url": "https://github.com/oracle/helidon/pull/2467", "merged": true, "mergeCommit": {"oid": "fa59ea94b197c2c5afaae8665c93c6b53fae9693"}, "closed": true, "closedAt": "2020-12-01T21:28:24Z", "author": {"login": "tomas-langer"}, "timelineItems": {"totalCount": 30, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdUVQn2gBqjM4OTc2MDE3ODU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdh72B6gFqTU0MjAyODQxOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "85a1eaadd9eef4637046b8735b26912485925287", "author": {"user": {"login": "tomas-langer", "name": "Tomas Langer"}}, "url": "https://github.com/oracle/helidon/commit/85a1eaadd9eef4637046b8735b26912485925287", "committedDate": "2020-10-19T20:32:48Z", "message": "Checkstyle fixes.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>"}, "afterCommit": {"oid": "1033461366e5b9149967a61eb19b14ed8d696847", "author": {"user": {"login": "tomas-langer", "name": "Tomas Langer"}}, "url": "https://github.com/oracle/helidon/commit/1033461366e5b9149967a61eb19b14ed8d696847", "committedDate": "2020-10-20T09:21:37Z", "message": "Rebase and pom version fix.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1033461366e5b9149967a61eb19b14ed8d696847", "author": {"user": {"login": "tomas-langer", "name": "Tomas Langer"}}, "url": "https://github.com/oracle/helidon/commit/1033461366e5b9149967a61eb19b14ed8d696847", "committedDate": "2020-10-20T09:21:37Z", "message": "Rebase and pom version fix.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>"}, "afterCommit": {"oid": "3bc55e1d8f5145f6fcf97679fe56bfafb64e6593", "author": {"user": {"login": "tomas-langer", "name": "Tomas Langer"}}, "url": "https://github.com/oracle/helidon/commit/3bc55e1d8f5145f6fcf97679fe56bfafb64e6593", "committedDate": "2020-10-20T09:39:42Z", "message": "Rebase and pom version fix.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0NjIyMzU2", "url": "https://github.com/oracle/helidon/pull/2467#pullrequestreview-514622356", "createdAt": "2020-10-22T11:25:53Z", "commit": {"oid": "e306d7bd3114abf57856621d196869c60c8f357b"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxMToyNTo1M1rOHmdD_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxMTo0NDo1OVrOHmdsZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDA4NDA5Mw==", "bodyText": "Does this need to take into account parameterized types?", "url": "https://github.com/oracle/helidon/pull/2467#discussion_r510084093", "createdAt": "2020-10-22T11:25:53Z", "author": {"login": "graemerocher"}, "path": "integrations/micronaut/cdi/src/main/java/io/helidon/integrations/micronaut/cdi/CdiExecutableMethod.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.integrations.micronaut.cdi;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.annotation.Documented;\n+import java.lang.annotation.Repeatable;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.Target;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.lang.reflect.Parameter;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.enterprise.inject.spi.Annotated;\n+import javax.enterprise.inject.spi.AnnotatedMethod;\n+import javax.enterprise.inject.spi.AnnotatedParameter;\n+\n+import io.micronaut.context.AbstractExecutableMethod;\n+import io.micronaut.core.annotation.AnnotationMetadata;\n+import io.micronaut.core.annotation.AnnotationValue;\n+import io.micronaut.core.type.Argument;\n+import io.micronaut.core.type.DefaultArgument;\n+import io.micronaut.inject.ExecutableMethod;\n+import io.micronaut.inject.annotation.DefaultAnnotationMetadata;\n+\n+// Executable method used to invoke Micronaut interceptor when we need to merge CDI and Micronaut\n+// annotation metadata, or when we do not have Micronaut annotation metadata\n+@SuppressWarnings(\"rawtypes\")\n+final class CdiExecutableMethod extends AbstractExecutableMethod {\n+    private final AnnotationMetadata annotationMetadata;\n+\n+    private CdiExecutableMethod(AnnotationMetadata methodAnnotationMetadata,\n+                                Class<?> declaringType,\n+                                String methodName,\n+                                Argument<?> genericReturnType,\n+                                Argument... arguments) {\n+        super(declaringType, methodName, genericReturnType, arguments);\n+        this.annotationMetadata = methodAnnotationMetadata;\n+    }\n+\n+    /**\n+     * Create from CDI method and Micronaut executable method.\n+     * Merges together annotations from both worlds.\n+     *\n+     * @param cdiMethod CDI annotated method\n+     * @param micronautMethod Micronaut executable method\n+     * @return a new combined executable method\n+     */\n+    static ExecutableMethod<?, ?> create(AnnotatedMethod<?> cdiMethod, ExecutableMethod<?, ?> micronautMethod) {\n+        return create(cdiMethod,\n+                      annotationMetadata(cdiMethod, micronautMethod.getAnnotationMetadata()),\n+                      arguments(cdiMethod.getParameters(), micronautMethod.getArguments()));\n+    }\n+\n+    /**\n+     * Create from CDI method.\n+     *\n+     * @param cdiMethod CDI annotated method\n+     * @return Micronaut executable method\n+     */\n+    static ExecutableMethod<?, ?> create(AnnotatedMethod<?> cdiMethod) {\n+        return create(cdiMethod,\n+                      annotationMetadata(cdiMethod),\n+                      arguments(cdiMethod.getParameters()));\n+    }\n+\n+    private static ExecutableMethod<?, ?> create(AnnotatedMethod<?> cdiMethod,\n+                                                 AnnotationMetadata annotationMetadata,\n+                                                 Argument... arguments) {\n+        Class<?> declaringType = cdiMethod.getDeclaringType().getJavaClass();\n+        Argument<?> returnType = Argument.of(cdiMethod.getJavaMember().getReturnType());\n+\n+        return new CdiExecutableMethod(annotationMetadata,\n+                                       declaringType,\n+                                       cdiMethod.getJavaMember().getName(),\n+                                       returnType,\n+                                       arguments);\n+    }\n+\n+    @Override\n+    protected AnnotationMetadata resolveAnnotationMetadata() {\n+        return annotationMetadata;\n+    }\n+\n+    @Override\n+    protected Object invokeInternal(Object instance, Object[] arguments) {\n+        throw new MicronautCdiException(\"invokeInternal should not be called in interceptor\");\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static Argument[] arguments(List<? extends AnnotatedParameter<?>> parameters, Argument[] miParameters) {\n+        Argument[] result = new Argument[parameters.size()];\n+\n+        for (int i = 0; i < parameters.size(); i++) {\n+            AnnotatedParameter<?> parameter = parameters.get(i);\n+            result[i] = toArgument(parameter, miParameters[i]);\n+        }\n+\n+        return result;\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static Argument[] arguments(List<? extends AnnotatedParameter<?>> parameters) {\n+        Argument[] result = new Argument[parameters.size()];\n+\n+        for (int i = 0; i < parameters.size(); i++) {\n+            AnnotatedParameter<?> parameter = parameters.get(i);\n+            result[i] = toArgument(parameter);\n+        }\n+\n+        return result;\n+    }\n+\n+    private static Argument<?> toArgument(AnnotatedParameter<?> parameter, Argument argument) {\n+        Parameter javaParameter = parameter.getJavaParameter();\n+        return new DefaultArgument(javaParameter.getType(),\n+                                   javaParameter.getName(),\n+                                   annotationMetadata(parameter, argument.getAnnotationMetadata()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e306d7bd3114abf57856621d196869c60c8f357b"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDA4ODkzNg==", "bodyText": "I think you can probably create the io.micronaut.context.Qualifier[] in the same loop with Qualifiers.byAnnotation(annotationMetadata, qualifiers.get(i))", "url": "https://github.com/oracle/helidon/pull/2467#discussion_r510088936", "createdAt": "2020-10-22T11:34:55Z", "author": {"login": "graemerocher"}, "path": "integrations/micronaut/cdi/src/main/java/io/helidon/integrations/micronaut/cdi/MicronautCdiExtension.java", "diffHunk": "@@ -0,0 +1,405 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.helidon.integrations.micronaut.cdi;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.Priority;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.context.BeforeDestroyed;\n+import javax.enterprise.context.Dependent;\n+import javax.enterprise.context.Initialized;\n+import javax.enterprise.event.Observes;\n+import javax.enterprise.inject.spi.AfterBeanDiscovery;\n+import javax.enterprise.inject.spi.BeforeBeanDiscovery;\n+import javax.enterprise.inject.spi.Extension;\n+import javax.enterprise.inject.spi.ProcessAnnotatedType;\n+import javax.enterprise.inject.spi.configurator.BeanConfigurator;\n+import javax.inject.Qualifier;\n+\n+import io.micronaut.aop.Around;\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.context.ApplicationContext;\n+import io.micronaut.context.annotation.Type;\n+import io.micronaut.context.env.PropertySource;\n+import io.micronaut.core.annotation.AnnotationMetadata;\n+import io.micronaut.core.io.service.ServiceDefinition;\n+import io.micronaut.core.io.service.SoftServiceLoader;\n+import io.micronaut.inject.BeanDefinition;\n+import io.micronaut.inject.BeanDefinitionReference;\n+import io.micronaut.inject.ExecutableMethod;\n+import io.micronaut.inject.qualifiers.Qualifiers;\n+import org.eclipse.microprofile.config.Config;\n+\n+import static javax.interceptor.Interceptor.Priority.PLATFORM_AFTER;\n+import static javax.interceptor.Interceptor.Priority.PLATFORM_BEFORE;\n+\n+/**\n+ * Extension integrating CDI with Micronaut.\n+ * This extensions adds Micronaut beans to be injectable into CDI beans (limited to {@link javax.inject.Singleton}\n+ * scope), adn adds support for invoking Micronaut interceptors.\n+ */\n+public class MicronautCdiExtension implements Extension {\n+    private final AtomicReference<ApplicationContext> micronautContext = new AtomicReference<>();\n+    private final Map<Method, ExecutableMethod<?, ?>> executableMethodCache = new HashMap<>();\n+    private final Map<Method, MethodInterceptorMetadata> methods = new HashMap<>();\n+    // all bean definitions as seen by Micronaut\n+    private final List<MicronautBean> beanDefinitions = new LinkedList<>();\n+    // map of an actual class (user's source code) mapping to Micronaut bean definition\n+    private final Map<Class<?>, List<MicronautBean>> mBeanToDefRef = new HashMap<>();\n+    // Micronaut beans not yet processed by CDI\n+    private final Map<Class<?>, List<MicronautBean>> unprocessedBeans = new HashMap<>();\n+\n+    /**\n+     * Get the application context of Micronaut.\n+     * This method can only be invoked once the server is started.\n+     *\n+     * @return Micronaut application context\n+     * @throws java.lang.IllegalStateException when invoked when server (and hence the context) is not started\n+     */\n+    public ApplicationContext context() {\n+        ApplicationContext ctx = micronautContext.get();\n+        if (ctx == null) {\n+            throw new IllegalStateException(\n+                    \"Micronaut application context can only be obtained after the ApplicationScoped is initialized\");\n+        }\n+        return ctx;\n+    }\n+\n+    MethodInterceptorMetadata getInterceptionMetadata(Method javaMethod) {\n+        return methods.get(javaMethod);\n+    }\n+\n+    /**\n+     * Load all Micronaut bean definitions and register our interceptor binding, so we can\n+     * execute Micronaut interceptors using a CDI interceptor.\n+     *\n+     * @param event CDI event\n+     */\n+    void beforeBeanDiscovery(@Priority(PLATFORM_BEFORE) @Observes BeforeBeanDiscovery event) {\n+        loadMicronautBeanDefinitions();\n+\n+        event.addAnnotatedType(MicronautInterceptor.class, \"mcdi-MicronautInterceptor\");\n+        event.addInterceptorBinding(MicronautIntercepted.class);\n+    }\n+\n+    /**\n+     * Construct a list of Micronaut interceptors to execute on each CDI method.\n+     * In case a Micronaut bean definition is available for the CDI bean (which should be for application, as\n+     * the CDI annotation processor should be used, and it adds CDI beans as Micronaut beans), the information\n+     * is combined from Micronaut and CDI bean definitions.\n+     *\n+     * @param event CDI event\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    void processTypes(@Priority(PLATFORM_AFTER) @Observes ProcessAnnotatedType<?> event) {\n+        Set<Class<?>> classInterceptors = new HashSet<>();\n+        Map<Method, Set<Class<?>>> allMethodInterceptors = new HashMap<>();\n+\n+        List<MicronautBean> miBeans = unprocessedBeans.remove(event.getAnnotatedType().getJavaClass());\n+\n+        if (miBeans != null && miBeans.size() > 0) {\n+            BeanDefinitionReference<?> miBean = findMicronautBeanDefinition(miBeans);\n+            // add all interceptors that are seen based on Micronaut\n+            findMicronautInterceptors(classInterceptors, allMethodInterceptors, miBean);\n+        }\n+\n+        // find all annotations that have meta annotation Around and collect their Type list to add as interceptors\n+        addMicronautInterceptors(classInterceptors, event.getAnnotatedType().getAnnotations());\n+\n+        // for each method, find the same (Around, collect Type), and add the interceptor binding for Micronaut interceptors\n+        // CDI interceptors will be automatic\n+        event.configureAnnotatedType()\n+                .methods()\n+                .forEach(method -> {\n+                    Method javaMethod = method.getAnnotated().getJavaMember();\n+\n+                    Set<Class<?>> methodInterceptors = allMethodInterceptors.computeIfAbsent(javaMethod, it -> new HashSet<>());\n+                    methodInterceptors.addAll(classInterceptors);\n+\n+                    addMicronautInterceptors(methodInterceptors, method.getAnnotated().getAnnotations());\n+\n+                    if (!methodInterceptors.isEmpty()) {\n+                        // now I have a set of micronaut interceptors that are needed for this method\n+                        method.add(MicronautIntercepted.Literal.INSTANCE);\n+\n+                        Set<Class<? extends MethodInterceptor<?, ?>>> interceptors = new HashSet<>();\n+                        methodInterceptors.forEach(it -> interceptors.add((Class<? extends MethodInterceptor<?, ?>>) it));\n+\n+                        methods.computeIfAbsent(javaMethod,\n+                                                theMethod -> MethodInterceptorMetadata.create(\n+                                                        method.getAnnotated(),\n+                                                        executableMethodCache.get(theMethod)))\n+                                .addInterceptors(interceptors);\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Add all (not yet added) Micronaut beans for injection as long as they are singletons.\n+     *\n+     * @param event CDI event\n+     */\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    void afterBeanDiscovery(@Priority(PLATFORM_BEFORE) @Observes AfterBeanDiscovery event) {\n+        event.addBean()\n+                .addType(ApplicationContext.class)\n+                .id(\"micronaut-context\")\n+                .scope(ApplicationScoped.class)\n+                .produceWith(instance -> micronautContext.get());\n+\n+        // add the remaining Micronaut beans\n+        for (var entry : unprocessedBeans.entrySet()) {\n+            Class<?> beanType = entry.getKey();\n+            List<MicronautBean> beans = entry.getValue();\n+\n+            List<? extends BeanDefinitionReference<?>> refs = List.of();\n+            if (beans.size() > 1) {\n+                // first make sure these are singletons; if not, ignore\n+                refs = beans.stream()\n+                        .map(MicronautBean::definitionRef)\n+                        .filter(it -> !it.getBeanType().getName().endsWith(\"$Intercepted\"))\n+                        .filter(BeanDefinitionReference::isSingleton)\n+                        .collect(Collectors.toList());\n+            }\n+\n+            // primary\n+            event.addBean()\n+                    .addType(beanType)\n+                    .id(\"micronaut-\" + beanType.getName())\n+                    // inject using dependent - manage scope by micronaut context\n+                    .scope(Dependent.class)\n+                    .produceWith(instance -> micronautContext.get().getBean(beanType));\n+\n+            if (refs.size() > 1) {\n+                // we must care about qualifiers\n+                for (var ref : refs) {\n+                    AnnotationMetadata annotationMetadata = ref.getAnnotationMetadata();\n+                    List<Class<? extends Annotation>> qualifiers = annotationMetadata\n+                            .getAnnotationTypesByStereotype(Qualifier.class);\n+\n+                    Annotation[] synthesized = new Annotation[qualifiers.size()];\n+                    for (int i = 0; i < qualifiers.size(); i++) {\n+                        synthesized[i] = annotationMetadata.synthesize(qualifiers.get(i));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e306d7bd3114abf57856621d196869c60c8f357b"}, "originalPosition": 210}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDA5MDEwOQ==", "bodyText": "Minor, but this would preform better with parallelStream() and then collect() then adding all the beans to beanDefinitions", "url": "https://github.com/oracle/helidon/pull/2467#discussion_r510090109", "createdAt": "2020-10-22T11:37:04Z", "author": {"login": "graemerocher"}, "path": "integrations/micronaut/cdi/src/main/java/io/helidon/integrations/micronaut/cdi/MicronautCdiExtension.java", "diffHunk": "@@ -0,0 +1,405 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.helidon.integrations.micronaut.cdi;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.Priority;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.context.BeforeDestroyed;\n+import javax.enterprise.context.Dependent;\n+import javax.enterprise.context.Initialized;\n+import javax.enterprise.event.Observes;\n+import javax.enterprise.inject.spi.AfterBeanDiscovery;\n+import javax.enterprise.inject.spi.BeforeBeanDiscovery;\n+import javax.enterprise.inject.spi.Extension;\n+import javax.enterprise.inject.spi.ProcessAnnotatedType;\n+import javax.enterprise.inject.spi.configurator.BeanConfigurator;\n+import javax.inject.Qualifier;\n+\n+import io.micronaut.aop.Around;\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.context.ApplicationContext;\n+import io.micronaut.context.annotation.Type;\n+import io.micronaut.context.env.PropertySource;\n+import io.micronaut.core.annotation.AnnotationMetadata;\n+import io.micronaut.core.io.service.ServiceDefinition;\n+import io.micronaut.core.io.service.SoftServiceLoader;\n+import io.micronaut.inject.BeanDefinition;\n+import io.micronaut.inject.BeanDefinitionReference;\n+import io.micronaut.inject.ExecutableMethod;\n+import io.micronaut.inject.qualifiers.Qualifiers;\n+import org.eclipse.microprofile.config.Config;\n+\n+import static javax.interceptor.Interceptor.Priority.PLATFORM_AFTER;\n+import static javax.interceptor.Interceptor.Priority.PLATFORM_BEFORE;\n+\n+/**\n+ * Extension integrating CDI with Micronaut.\n+ * This extensions adds Micronaut beans to be injectable into CDI beans (limited to {@link javax.inject.Singleton}\n+ * scope), adn adds support for invoking Micronaut interceptors.\n+ */\n+public class MicronautCdiExtension implements Extension {\n+    private final AtomicReference<ApplicationContext> micronautContext = new AtomicReference<>();\n+    private final Map<Method, ExecutableMethod<?, ?>> executableMethodCache = new HashMap<>();\n+    private final Map<Method, MethodInterceptorMetadata> methods = new HashMap<>();\n+    // all bean definitions as seen by Micronaut\n+    private final List<MicronautBean> beanDefinitions = new LinkedList<>();\n+    // map of an actual class (user's source code) mapping to Micronaut bean definition\n+    private final Map<Class<?>, List<MicronautBean>> mBeanToDefRef = new HashMap<>();\n+    // Micronaut beans not yet processed by CDI\n+    private final Map<Class<?>, List<MicronautBean>> unprocessedBeans = new HashMap<>();\n+\n+    /**\n+     * Get the application context of Micronaut.\n+     * This method can only be invoked once the server is started.\n+     *\n+     * @return Micronaut application context\n+     * @throws java.lang.IllegalStateException when invoked when server (and hence the context) is not started\n+     */\n+    public ApplicationContext context() {\n+        ApplicationContext ctx = micronautContext.get();\n+        if (ctx == null) {\n+            throw new IllegalStateException(\n+                    \"Micronaut application context can only be obtained after the ApplicationScoped is initialized\");\n+        }\n+        return ctx;\n+    }\n+\n+    MethodInterceptorMetadata getInterceptionMetadata(Method javaMethod) {\n+        return methods.get(javaMethod);\n+    }\n+\n+    /**\n+     * Load all Micronaut bean definitions and register our interceptor binding, so we can\n+     * execute Micronaut interceptors using a CDI interceptor.\n+     *\n+     * @param event CDI event\n+     */\n+    void beforeBeanDiscovery(@Priority(PLATFORM_BEFORE) @Observes BeforeBeanDiscovery event) {\n+        loadMicronautBeanDefinitions();\n+\n+        event.addAnnotatedType(MicronautInterceptor.class, \"mcdi-MicronautInterceptor\");\n+        event.addInterceptorBinding(MicronautIntercepted.class);\n+    }\n+\n+    /**\n+     * Construct a list of Micronaut interceptors to execute on each CDI method.\n+     * In case a Micronaut bean definition is available for the CDI bean (which should be for application, as\n+     * the CDI annotation processor should be used, and it adds CDI beans as Micronaut beans), the information\n+     * is combined from Micronaut and CDI bean definitions.\n+     *\n+     * @param event CDI event\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    void processTypes(@Priority(PLATFORM_AFTER) @Observes ProcessAnnotatedType<?> event) {\n+        Set<Class<?>> classInterceptors = new HashSet<>();\n+        Map<Method, Set<Class<?>>> allMethodInterceptors = new HashMap<>();\n+\n+        List<MicronautBean> miBeans = unprocessedBeans.remove(event.getAnnotatedType().getJavaClass());\n+\n+        if (miBeans != null && miBeans.size() > 0) {\n+            BeanDefinitionReference<?> miBean = findMicronautBeanDefinition(miBeans);\n+            // add all interceptors that are seen based on Micronaut\n+            findMicronautInterceptors(classInterceptors, allMethodInterceptors, miBean);\n+        }\n+\n+        // find all annotations that have meta annotation Around and collect their Type list to add as interceptors\n+        addMicronautInterceptors(classInterceptors, event.getAnnotatedType().getAnnotations());\n+\n+        // for each method, find the same (Around, collect Type), and add the interceptor binding for Micronaut interceptors\n+        // CDI interceptors will be automatic\n+        event.configureAnnotatedType()\n+                .methods()\n+                .forEach(method -> {\n+                    Method javaMethod = method.getAnnotated().getJavaMember();\n+\n+                    Set<Class<?>> methodInterceptors = allMethodInterceptors.computeIfAbsent(javaMethod, it -> new HashSet<>());\n+                    methodInterceptors.addAll(classInterceptors);\n+\n+                    addMicronautInterceptors(methodInterceptors, method.getAnnotated().getAnnotations());\n+\n+                    if (!methodInterceptors.isEmpty()) {\n+                        // now I have a set of micronaut interceptors that are needed for this method\n+                        method.add(MicronautIntercepted.Literal.INSTANCE);\n+\n+                        Set<Class<? extends MethodInterceptor<?, ?>>> interceptors = new HashSet<>();\n+                        methodInterceptors.forEach(it -> interceptors.add((Class<? extends MethodInterceptor<?, ?>>) it));\n+\n+                        methods.computeIfAbsent(javaMethod,\n+                                                theMethod -> MethodInterceptorMetadata.create(\n+                                                        method.getAnnotated(),\n+                                                        executableMethodCache.get(theMethod)))\n+                                .addInterceptors(interceptors);\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Add all (not yet added) Micronaut beans for injection as long as they are singletons.\n+     *\n+     * @param event CDI event\n+     */\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    void afterBeanDiscovery(@Priority(PLATFORM_BEFORE) @Observes AfterBeanDiscovery event) {\n+        event.addBean()\n+                .addType(ApplicationContext.class)\n+                .id(\"micronaut-context\")\n+                .scope(ApplicationScoped.class)\n+                .produceWith(instance -> micronautContext.get());\n+\n+        // add the remaining Micronaut beans\n+        for (var entry : unprocessedBeans.entrySet()) {\n+            Class<?> beanType = entry.getKey();\n+            List<MicronautBean> beans = entry.getValue();\n+\n+            List<? extends BeanDefinitionReference<?>> refs = List.of();\n+            if (beans.size() > 1) {\n+                // first make sure these are singletons; if not, ignore\n+                refs = beans.stream()\n+                        .map(MicronautBean::definitionRef)\n+                        .filter(it -> !it.getBeanType().getName().endsWith(\"$Intercepted\"))\n+                        .filter(BeanDefinitionReference::isSingleton)\n+                        .collect(Collectors.toList());\n+            }\n+\n+            // primary\n+            event.addBean()\n+                    .addType(beanType)\n+                    .id(\"micronaut-\" + beanType.getName())\n+                    // inject using dependent - manage scope by micronaut context\n+                    .scope(Dependent.class)\n+                    .produceWith(instance -> micronautContext.get().getBean(beanType));\n+\n+            if (refs.size() > 1) {\n+                // we must care about qualifiers\n+                for (var ref : refs) {\n+                    AnnotationMetadata annotationMetadata = ref.getAnnotationMetadata();\n+                    List<Class<? extends Annotation>> qualifiers = annotationMetadata\n+                            .getAnnotationTypesByStereotype(Qualifier.class);\n+\n+                    Annotation[] synthesized = new Annotation[qualifiers.size()];\n+                    for (int i = 0; i < qualifiers.size(); i++) {\n+                        synthesized[i] = annotationMetadata.synthesize(qualifiers.get(i));\n+                    }\n+\n+                    io.micronaut.context.Qualifier[] mq = new io.micronaut.context.Qualifier[qualifiers.size()];\n+\n+                    for (int i = 0; i < qualifiers.size(); i++) {\n+                        if (synthesized[i] != null) {\n+                            mq[i] = Qualifiers.byAnnotation(synthesized[i]);\n+                        }\n+                    }\n+\n+                    io.micronaut.context.Qualifier composite = Qualifiers.byQualifiers(mq);\n+\n+                    BeanConfigurator<Object> newBean = event.addBean()\n+                            .addType(beanType)\n+                            .id(\"micronaut-\" + ref.getBeanDefinitionName())\n+                            .scope(Dependent.class)\n+                            .produceWith(instance -> micronautContext.get().getBean(beanType, composite));\n+\n+                    for (Annotation annotation : synthesized) {\n+                        newBean.addQualifier(annotation);\n+                    }\n+\n+                }\n+            }\n+        }\n+        unprocessedBeans.clear();\n+    }\n+\n+    /**\n+     * Start Micronaut application context and make it available for other extensions.\n+     *\n+     * @param event CDI event\n+     */\n+    void startContext(@Observes @Priority(PLATFORM_BEFORE) @Initialized(ApplicationScoped.class) Object event) {\n+        ApplicationContext context = ApplicationContext.builder()\n+                .propertySources(createMicronautPropertySource())\n+                .build();\n+\n+        context.start();\n+\n+        micronautContext.set(context);\n+    }\n+\n+    /**\n+     * Stop Micronaut application context.\n+     * @param event CDI event\n+     */\n+    void stopContext(@Observes @Priority(PLATFORM_AFTER) @BeforeDestroyed(ApplicationScoped.class) Object event) {\n+        ApplicationContext context = micronautContext.get();\n+        // if startup failed, context is null\n+        if (context != null) {\n+            context.close();\n+        }\n+    }\n+\n+    /**\n+     * Use MicroProfile Config as a config source for Micronaut.\n+     *\n+     * @return Micronaut property source from MP Config\n+     */\n+    private PropertySource createMicronautPropertySource() {\n+        Config config = org.eclipse.microprofile.config.ConfigProvider.getConfig();\n+\n+        return new PropertySource() {\n+            @Override\n+            public String getName() {\n+                return \"MicroProfile-Config\";\n+            }\n+\n+            @Override\n+            public Object get(String key) {\n+                return config.getOptionalValue(key, String.class).orElse(null);\n+            }\n+\n+            @Override\n+            public Iterator<String> iterator() {\n+                List<String> names = new LinkedList<>();\n+                config.getPropertyNames()\n+                        .forEach(names::add);\n+\n+                return names.iterator();\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Load Micronaut bean definition using service loader, to have full knowledge of the landscape.\n+     */\n+    @SuppressWarnings(\"rawtypes\")\n+    private void loadMicronautBeanDefinitions() {\n+        // we now need to load all Micronaut beans so other extensions can inject them\n+        List<ServiceDefinition<BeanDefinitionReference>> list = new ArrayList<>(200);\n+\n+        SoftServiceLoader.load(BeanDefinitionReference.class)\n+                .forEach(list::add);\n+\n+        list.stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e306d7bd3114abf57856621d196869c60c8f357b"}, "originalPosition": 307}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDA5MjQxNw==", "bodyText": "Would probably try cache all of this lookup logic in getInterceptionMetadata otherwise it probably adds quite some overhead to invocation", "url": "https://github.com/oracle/helidon/pull/2467#discussion_r510092417", "createdAt": "2020-10-22T11:41:25Z", "author": {"login": "graemerocher"}, "path": "integrations/micronaut/cdi/src/main/java/io/helidon/integrations/micronaut/cdi/MicronautInterceptor.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.integrations.micronaut.cdi;\n+\n+import java.lang.reflect.Method;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.logging.Logger;\n+\n+import javax.annotation.Priority;\n+import javax.inject.Inject;\n+import javax.interceptor.AroundInvoke;\n+import javax.interceptor.Interceptor;\n+import javax.interceptor.InvocationContext;\n+\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.context.ApplicationContext;\n+import io.micronaut.core.annotation.Internal;\n+import io.micronaut.inject.ExecutableMethod;\n+\n+/**\n+ * A CDI interceptor that invokes all Micronaut interceptors.\n+ * DO NOT USE DIRECTLY. Usage is computed by this CDI extension.\n+ */\n+// interceptor binding is defined in code of extension, not on annotation\n+@MicronautIntercepted\n+@Interceptor\n+@Priority(Interceptor.Priority.LIBRARY_BEFORE)\n+@Internal\n+public class MicronautInterceptor {\n+    private static final Logger LOGGER = Logger.getLogger(MicronautInterceptor.class.getName());\n+\n+    private final ApplicationContext context;\n+    private final MicronautCdiExtension extension;\n+\n+    @Inject\n+    MicronautInterceptor(ApplicationContext context, MicronautCdiExtension extension) {\n+        this.context = context;\n+        this.extension = extension;\n+    }\n+\n+    /**\n+     * Interceptor method that call Micronaut interceptors for a CDI bean.\n+     *\n+     * @param cdiCtx invocation context\n+     * @return response of the method\n+     */\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    @AroundInvoke\n+    public Object invoke(InvocationContext cdiCtx) {\n+\n+        Method javaMethod = cdiCtx.getMethod();\n+        MethodInterceptorMetadata meta = extension.getInterceptionMetadata(javaMethod);\n+\n+        Set<Class<? extends MethodInterceptor<?, ?>>> interceptorClasses = meta.interceptors();\n+        Set<MethodInterceptor<?, ?>> interceptors = new TreeSet<>(Comparator.comparingInt(MethodInterceptor::getOrder));\n+\n+        for (Class<? extends MethodInterceptor> aClass : interceptorClasses) {\n+            interceptors.add(context.findBean(aClass)\n+                                     .orElseThrow(() -> new MicronautCdiException(\"Cannot create bean class for interceptor \"\n+                                                                                          + aClass.getName())));\n+        }\n+\n+        ExecutableMethod<?, ?> executableMethod = meta.executableMethod();\n+        Iterator<MethodInterceptor<?, ?>> remaining = interceptors.iterator();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e306d7bd3114abf57856621d196869c60c8f357b"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDA5MzA0NA==", "bodyText": "In Micronaut core we construct the attributes and mutable arguments lazily since they may not be used which reduces overhead", "url": "https://github.com/oracle/helidon/pull/2467#discussion_r510093044", "createdAt": "2020-10-22T11:42:33Z", "author": {"login": "graemerocher"}, "path": "integrations/micronaut/cdi/src/main/java/io/helidon/integrations/micronaut/cdi/MicronautMethodInvocationContext.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.integrations.micronaut.cdi;\n+\n+import java.lang.reflect.Method;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.logging.Logger;\n+\n+import javax.interceptor.InvocationContext;\n+\n+import io.micronaut.aop.Interceptor;\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.aop.MethodInvocationContext;\n+import io.micronaut.core.convert.ConversionService;\n+import io.micronaut.core.convert.value.MutableConvertibleMultiValuesMap;\n+import io.micronaut.core.convert.value.MutableConvertibleValues;\n+import io.micronaut.core.type.Argument;\n+import io.micronaut.core.type.ArgumentValue;\n+import io.micronaut.core.type.MutableArgumentValue;\n+import io.micronaut.core.type.ReturnType;\n+import io.micronaut.inject.ExecutableMethod;\n+\n+/**\n+ * Invocation context for Micronaut interceptors.\n+ */\n+@SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+class MicronautMethodInvocationContext implements MethodInvocationContext {\n+    private static final Logger LOGGER = Logger.getLogger(MicronautMethodInvocationContext.class.getName());\n+\n+    private final InvocationContext cdiContext;\n+    private final ExecutableMethod executableMethod;\n+    private final Set<MethodInterceptor<?, ?>> allInterceptors;\n+    private final MutableConvertibleValues attributes;\n+    private final Map<String, MutableArgumentValue<?>> mutableArguments;\n+\n+    private Iterator<MethodInterceptor<?, ?>> remaining;\n+\n+    private MicronautMethodInvocationContext(InvocationContext cdiContext,\n+                                             ExecutableMethod executableMethod,\n+                                             Set<MethodInterceptor<?, ?>> allInterceptors,\n+                                             Iterator<MethodInterceptor<?, ?>> remaining) {\n+        this.cdiContext = cdiContext;\n+        this.executableMethod = executableMethod;\n+        this.allInterceptors = allInterceptors;\n+        this.remaining = remaining;\n+\n+        this.attributes = new MutableConvertibleMultiValuesMap();\n+        this.mutableArguments = new LinkedHashMap<>();\n+        Object[] parameters = cdiContext.getParameters();\n+        Argument[] argumentNames = executableMethod.getArguments();\n+\n+        for (int i = 0; i < argumentNames.length; i++) {\n+            Argument argument = argumentNames[i];\n+            Object parameterValue = parameters[i];\n+            mutableArguments.put(argument.getName(),\n+                                 new MutableArgument<Object>(argument, parameterValue));\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e306d7bd3114abf57856621d196869c60c8f357b"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDA5NDQzOQ==", "bodyText": "Again in Micronaut core we tend to have an implementation whereby MutableArgumentValue.setValue(..) will set the value into the Object[] to avoid this copying", "url": "https://github.com/oracle/helidon/pull/2467#discussion_r510094439", "createdAt": "2020-10-22T11:44:59Z", "author": {"login": "graemerocher"}, "path": "integrations/micronaut/cdi/src/main/java/io/helidon/integrations/micronaut/cdi/MicronautMethodInvocationContext.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.integrations.micronaut.cdi;\n+\n+import java.lang.reflect.Method;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.logging.Logger;\n+\n+import javax.interceptor.InvocationContext;\n+\n+import io.micronaut.aop.Interceptor;\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.aop.MethodInvocationContext;\n+import io.micronaut.core.convert.ConversionService;\n+import io.micronaut.core.convert.value.MutableConvertibleMultiValuesMap;\n+import io.micronaut.core.convert.value.MutableConvertibleValues;\n+import io.micronaut.core.type.Argument;\n+import io.micronaut.core.type.ArgumentValue;\n+import io.micronaut.core.type.MutableArgumentValue;\n+import io.micronaut.core.type.ReturnType;\n+import io.micronaut.inject.ExecutableMethod;\n+\n+/**\n+ * Invocation context for Micronaut interceptors.\n+ */\n+@SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+class MicronautMethodInvocationContext implements MethodInvocationContext {\n+    private static final Logger LOGGER = Logger.getLogger(MicronautMethodInvocationContext.class.getName());\n+\n+    private final InvocationContext cdiContext;\n+    private final ExecutableMethod executableMethod;\n+    private final Set<MethodInterceptor<?, ?>> allInterceptors;\n+    private final MutableConvertibleValues attributes;\n+    private final Map<String, MutableArgumentValue<?>> mutableArguments;\n+\n+    private Iterator<MethodInterceptor<?, ?>> remaining;\n+\n+    private MicronautMethodInvocationContext(InvocationContext cdiContext,\n+                                             ExecutableMethod executableMethod,\n+                                             Set<MethodInterceptor<?, ?>> allInterceptors,\n+                                             Iterator<MethodInterceptor<?, ?>> remaining) {\n+        this.cdiContext = cdiContext;\n+        this.executableMethod = executableMethod;\n+        this.allInterceptors = allInterceptors;\n+        this.remaining = remaining;\n+\n+        this.attributes = new MutableConvertibleMultiValuesMap();\n+        this.mutableArguments = new LinkedHashMap<>();\n+        Object[] parameters = cdiContext.getParameters();\n+        Argument[] argumentNames = executableMethod.getArguments();\n+\n+        for (int i = 0; i < argumentNames.length; i++) {\n+            Argument argument = argumentNames[i];\n+            Object parameterValue = parameters[i];\n+            mutableArguments.put(argument.getName(),\n+                                 new MutableArgument<Object>(argument, parameterValue));\n+        }\n+    }\n+\n+    static MethodInvocationContext create(InvocationContext cdiCtx,\n+                                          ExecutableMethod<?, ?> executableMethod,\n+                                          Set<MethodInterceptor<?, ?>> allInterceptors,\n+                                          Iterator<MethodInterceptor<?, ?>> remaining) {\n+        return new MicronautMethodInvocationContext(cdiCtx,\n+                                                    executableMethod,\n+                                                    allInterceptors,\n+                                                    remaining);\n+    }\n+\n+    @Override\n+    public ExecutableMethod getExecutableMethod() {\n+        return executableMethod;\n+    }\n+\n+    @Override\n+    public Map<String, MutableArgumentValue<?>> getParameters() {\n+        return mutableArguments;\n+    }\n+\n+    @Override\n+    public Object getTarget() {\n+        return cdiContext.getTarget();\n+    }\n+\n+    @Override\n+    public Object proceed() throws RuntimeException {\n+        if (remaining.hasNext()) {\n+            MethodInterceptor<?, ?> next = remaining.next();\n+            LOGGER.finest(() -> \"Micronaut interceptor: \" + next.getClass().getName());\n+            return next.intercept(this);\n+        }\n+        try {\n+            Object[] arguments = mutableArguments.values()\n+                    .stream()\n+                    .map(ArgumentValue::getValue)\n+                    .toArray(Object[]::new);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e306d7bd3114abf57856621d196869c60c8f357b"}, "originalPosition": 113}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1MDM5MjY1", "url": "https://github.com/oracle/helidon/pull/2467#pullrequestreview-515039265", "createdAt": "2020-10-22T19:11:09Z", "commit": {"oid": "e306d7bd3114abf57856621d196869c60c8f357b"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e306d7bd3114abf57856621d196869c60c8f357b", "author": {"user": {"login": "tomas-langer", "name": "Tomas Langer"}}, "url": "https://github.com/oracle/helidon/commit/e306d7bd3114abf57856621d196869c60c8f357b", "committedDate": "2020-10-21T15:49:51Z", "message": "Using the correct Micronaut scope for Dependent.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>"}, "afterCommit": {"oid": "02a423c18cee7eca3c800f596998d36b31ccdaf4", "author": {"user": {"login": "tomas-langer", "name": "Tomas Langer"}}, "url": "https://github.com/oracle/helidon/commit/02a423c18cee7eca3c800f596998d36b31ccdaf4", "committedDate": "2020-11-09T15:54:10Z", "message": "Review fixes.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMwMTkzNTg0", "url": "https://github.com/oracle/helidon/pull/2467#pullrequestreview-530193584", "createdAt": "2020-11-13T16:10:40Z", "commit": {"oid": "02a423c18cee7eca3c800f596998d36b31ccdaf4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxNjoxMDo0MFrOHy0dsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xM1QxNjoxMDo0MFrOHy0dsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA1MDQxOA==", "bodyText": ".flatMap(Arrays::stream) may save few instructions", "url": "https://github.com/oracle/helidon/pull/2467#discussion_r523050418", "createdAt": "2020-11-13T16:10:40Z", "author": {"login": "danielkec"}, "path": "integrations/micronaut/cdi/src/main/java/io/helidon/integrations/micronaut/cdi/MicronautCdiExtension.java", "diffHunk": "@@ -0,0 +1,406 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.helidon.integrations.micronaut.cdi;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.Priority;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.context.BeforeDestroyed;\n+import javax.enterprise.context.Dependent;\n+import javax.enterprise.context.Initialized;\n+import javax.enterprise.event.Observes;\n+import javax.enterprise.inject.spi.AfterBeanDiscovery;\n+import javax.enterprise.inject.spi.BeforeBeanDiscovery;\n+import javax.enterprise.inject.spi.Extension;\n+import javax.enterprise.inject.spi.ProcessAnnotatedType;\n+import javax.enterprise.inject.spi.configurator.BeanConfigurator;\n+import javax.inject.Qualifier;\n+\n+import io.micronaut.aop.Around;\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.context.ApplicationContext;\n+import io.micronaut.context.annotation.Type;\n+import io.micronaut.context.env.PropertySource;\n+import io.micronaut.core.annotation.AnnotationMetadata;\n+import io.micronaut.core.io.service.ServiceDefinition;\n+import io.micronaut.core.io.service.SoftServiceLoader;\n+import io.micronaut.inject.BeanDefinition;\n+import io.micronaut.inject.BeanDefinitionReference;\n+import io.micronaut.inject.ExecutableMethod;\n+import io.micronaut.inject.qualifiers.Qualifiers;\n+import org.eclipse.microprofile.config.Config;\n+\n+import static javax.interceptor.Interceptor.Priority.PLATFORM_AFTER;\n+import static javax.interceptor.Interceptor.Priority.PLATFORM_BEFORE;\n+\n+/**\n+ * Extension integrating CDI with Micronaut.\n+ * This extensions adds Micronaut beans to be injectable into CDI beans (limited to {@link javax.inject.Singleton}\n+ * scope), adn adds support for invoking Micronaut interceptors.\n+ */\n+public class MicronautCdiExtension implements Extension {\n+    private final AtomicReference<ApplicationContext> micronautContext = new AtomicReference<>();\n+    private final Map<Method, ExecutableMethod<?, ?>> executableMethodCache = new HashMap<>();\n+    private final Map<Method, MethodInterceptorMetadata> methods = new HashMap<>();\n+    // all bean definitions as seen by Micronaut\n+    private List<MicronautBean> beanDefinitions = new LinkedList<>();\n+    // map of an actual class (user's source code) mapping to Micronaut bean definition\n+    private final Map<Class<?>, List<MicronautBean>> mBeanToDefRef = new HashMap<>();\n+    // Micronaut beans not yet processed by CDI\n+    private final Map<Class<?>, List<MicronautBean>> unprocessedBeans = new HashMap<>();\n+\n+    /**\n+     * Get the application context of Micronaut.\n+     * This method can only be invoked once the server is started.\n+     *\n+     * @return Micronaut application context\n+     * @throws java.lang.IllegalStateException when invoked when server (and hence the context) is not started\n+     */\n+    public ApplicationContext context() {\n+        ApplicationContext ctx = micronautContext.get();\n+        if (ctx == null) {\n+            throw new IllegalStateException(\n+                    \"Micronaut application context can only be obtained after the ApplicationScoped is initialized\");\n+        }\n+        return ctx;\n+    }\n+\n+    MethodInterceptorMetadata getInterceptionMetadata(Method javaMethod) {\n+        return methods.get(javaMethod);\n+    }\n+\n+    /**\n+     * Load all Micronaut bean definitions and register our interceptor binding, so we can\n+     * execute Micronaut interceptors using a CDI interceptor.\n+     *\n+     * @param event CDI event\n+     */\n+    void beforeBeanDiscovery(@Priority(PLATFORM_BEFORE) @Observes BeforeBeanDiscovery event) {\n+        loadMicronautBeanDefinitions();\n+\n+        event.addAnnotatedType(MicronautInterceptor.class, \"mcdi-MicronautInterceptor\");\n+        event.addInterceptorBinding(MicronautIntercepted.class);\n+    }\n+\n+    /**\n+     * Construct a list of Micronaut interceptors to execute on each CDI method.\n+     * In case a Micronaut bean definition is available for the CDI bean (which should be for application, as\n+     * the CDI annotation processor should be used, and it adds CDI beans as Micronaut beans), the information\n+     * is combined from Micronaut and CDI bean definitions.\n+     *\n+     * @param event CDI event\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    void processTypes(@Priority(PLATFORM_AFTER) @Observes ProcessAnnotatedType<?> event) {\n+        Set<Class<?>> classInterceptors = new HashSet<>();\n+        Map<Method, Set<Class<?>>> allMethodInterceptors = new HashMap<>();\n+\n+        List<MicronautBean> miBeans = unprocessedBeans.remove(event.getAnnotatedType().getJavaClass());\n+\n+        if (miBeans != null && miBeans.size() > 0) {\n+            BeanDefinitionReference<?> miBean = findMicronautBeanDefinition(miBeans);\n+            // add all interceptors that are seen based on Micronaut\n+            findMicronautInterceptors(classInterceptors, allMethodInterceptors, miBean);\n+        }\n+\n+        // find all annotations that have meta annotation Around and collect their Type list to add as interceptors\n+        addMicronautInterceptors(classInterceptors, event.getAnnotatedType().getAnnotations());\n+\n+        // for each method, find the same (Around, collect Type), and add the interceptor binding for Micronaut interceptors\n+        // CDI interceptors will be automatic\n+        event.configureAnnotatedType()\n+                .methods()\n+                .forEach(method -> {\n+                    Method javaMethod = method.getAnnotated().getJavaMember();\n+\n+                    Set<Class<?>> methodInterceptors = allMethodInterceptors.computeIfAbsent(javaMethod, it -> new HashSet<>());\n+                    methodInterceptors.addAll(classInterceptors);\n+\n+                    addMicronautInterceptors(methodInterceptors, method.getAnnotated().getAnnotations());\n+\n+                    if (!methodInterceptors.isEmpty()) {\n+                        // now I have a set of micronaut interceptors that are needed for this method\n+                        method.add(MicronautIntercepted.Literal.INSTANCE);\n+\n+                        Set<Class<? extends MethodInterceptor<?, ?>>> interceptors = new HashSet<>();\n+                        methodInterceptors.forEach(it -> interceptors.add((Class<? extends MethodInterceptor<?, ?>>) it));\n+\n+                        methods.computeIfAbsent(javaMethod,\n+                                                theMethod -> MethodInterceptorMetadata.create(\n+                                                        method.getAnnotated(),\n+                                                        executableMethodCache.get(theMethod)))\n+                                .addInterceptors(interceptors);\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Add all (not yet added) Micronaut beans for injection as long as they are singletons.\n+     *\n+     * @param event CDI event\n+     */\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    void afterBeanDiscovery(@Priority(PLATFORM_BEFORE) @Observes AfterBeanDiscovery event) {\n+        event.addBean()\n+                .addType(ApplicationContext.class)\n+                .id(\"micronaut-context\")\n+                .scope(ApplicationScoped.class)\n+                .produceWith(instance -> micronautContext.get());\n+\n+        // add the remaining Micronaut beans\n+        for (var entry : unprocessedBeans.entrySet()) {\n+            Class<?> beanType = entry.getKey();\n+            List<MicronautBean> beans = entry.getValue();\n+\n+            List<? extends BeanDefinitionReference<?>> refs = List.of();\n+            if (beans.size() > 1) {\n+                // first make sure these are singletons; if not, ignore\n+                refs = beans.stream()\n+                        .map(MicronautBean::definitionRef)\n+                        .filter(it -> !it.getBeanType().getName().endsWith(\"$Intercepted\"))\n+                        .filter(BeanDefinitionReference::isSingleton)\n+                        .collect(Collectors.toList());\n+            }\n+\n+            // primary\n+            event.addBean()\n+                    .addType(beanType)\n+                    .id(\"micronaut-\" + beanType.getName())\n+                    // inject using dependent - manage scope by micronaut context\n+                    .scope(Dependent.class)\n+                    .produceWith(instance -> micronautContext.get().getBean(beanType));\n+\n+            if (refs.size() > 1) {\n+                // we must care about qualifiers\n+                for (var ref : refs) {\n+                    AnnotationMetadata annotationMetadata = ref.getAnnotationMetadata();\n+                    List<Class<? extends Annotation>> qualifiers = annotationMetadata\n+                            .getAnnotationTypesByStereotype(Qualifier.class);\n+\n+                    Annotation[] synthesized = new Annotation[qualifiers.size()];\n+                    io.micronaut.context.Qualifier[] mq = new io.micronaut.context.Qualifier[qualifiers.size()];\n+\n+                    for (int i = 0; i < qualifiers.size(); i++) {\n+                        Annotation annotation = annotationMetadata.synthesize(qualifiers.get(i));\n+                        synthesized[i] = annotation;\n+                        if (annotation != null) {\n+                            mq[i] = Qualifiers.byAnnotation(annotation);\n+                        }\n+                    }\n+\n+                    io.micronaut.context.Qualifier composite = Qualifiers.byQualifiers(mq);\n+\n+                    BeanConfigurator<Object> newBean = event.addBean()\n+                            .addType(beanType)\n+                            .id(\"micronaut-\" + ref.getBeanDefinitionName())\n+                            .scope(Dependent.class)\n+                            .produceWith(instance -> micronautContext.get().getBean(beanType, composite));\n+\n+                    for (Annotation annotation : synthesized) {\n+                        newBean.addQualifier(annotation);\n+                    }\n+\n+                }\n+            }\n+        }\n+        unprocessedBeans.clear();\n+    }\n+\n+    /**\n+     * Start Micronaut application context and make it available for other extensions.\n+     *\n+     * @param event CDI event\n+     */\n+    void startContext(@Observes @Priority(PLATFORM_BEFORE) @Initialized(ApplicationScoped.class) Object event) {\n+        ApplicationContext context = ApplicationContext.builder()\n+                .propertySources(createMicronautPropertySource())\n+                .build();\n+\n+        context.start();\n+\n+        micronautContext.set(context);\n+    }\n+\n+    /**\n+     * Stop Micronaut application context.\n+     * @param event CDI event\n+     */\n+    void stopContext(@Observes @Priority(PLATFORM_AFTER) @BeforeDestroyed(ApplicationScoped.class) Object event) {\n+        ApplicationContext context = micronautContext.get();\n+        // if startup failed, context is null\n+        if (context != null) {\n+            context.close();\n+        }\n+    }\n+\n+    /**\n+     * Use MicroProfile Config as a config source for Micronaut.\n+     *\n+     * @return Micronaut property source from MP Config\n+     */\n+    private PropertySource createMicronautPropertySource() {\n+        Config config = org.eclipse.microprofile.config.ConfigProvider.getConfig();\n+\n+        return new PropertySource() {\n+            @Override\n+            public String getName() {\n+                return \"MicroProfile-Config\";\n+            }\n+\n+            @Override\n+            public Object get(String key) {\n+                return config.getOptionalValue(key, String.class).orElse(null);\n+            }\n+\n+            @Override\n+            public Iterator<String> iterator() {\n+                List<String> names = new LinkedList<>();\n+                config.getPropertyNames()\n+                        .forEach(names::add);\n+\n+                return names.iterator();\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Load Micronaut bean definition using service loader, to have full knowledge of the landscape.\n+     */\n+    @SuppressWarnings(\"rawtypes\")\n+    private void loadMicronautBeanDefinitions() {\n+        // we now need to load all Micronaut beans so other extensions can inject them\n+        List<ServiceDefinition<BeanDefinitionReference>> list = new ArrayList<>(200);\n+\n+        SoftServiceLoader.load(BeanDefinitionReference.class)\n+                .forEach(list::add);\n+\n+        List<MicronautBean> beans = list.parallelStream()\n+                .filter(ServiceDefinition::isPresent)\n+                .map(ServiceDefinition::load)\n+                .filter(BeanDefinitionReference::isPresent)\n+                .map(ref -> {\n+                    Class<?> beanType = ref.getBeanType();\n+\n+                    String className = ref.getBeanType().getName();\n+                    if (className.endsWith(\"$Intercepted\")) {\n+                        // either superclass is the one we want, or first implemented interface\n+                        if (Object.class.equals(beanType.getSuperclass())) {\n+                            Class<?>[] interfaces = beanType.getInterfaces();\n+                            if (interfaces.length > 0) {\n+                                beanType = interfaces[0];\n+                            }\n+                        } else {\n+                            beanType = beanType.getSuperclass();\n+                        }\n+                    }\n+\n+                    return new MicronautBean(beanType, ref);\n+                })\n+                .collect(Collectors.toList());\n+\n+        // using my own collection, so the field is final\n+        beanDefinitions.addAll(beans);\n+\n+        for (MicronautBean defRef : beanDefinitions) {\n+            mBeanToDefRef.computeIfAbsent(defRef.beanType(), it -> new LinkedList<>())\n+                    .add(defRef);\n+        }\n+\n+        unprocessedBeans.putAll(mBeanToDefRef);\n+    }\n+\n+    /**\n+     * Find Micronaut interceptor annotations and locate interceptor classes to be used.\n+     *\n+     * @param interceptors set of interceptors to add new interceptors to\n+     * @param annotations set of annotations on the processed element\n+     */\n+    private void addMicronautInterceptors(Set<Class<?>> interceptors, Set<Annotation> annotations) {\n+        annotations.stream()\n+                .map(Annotation::annotationType)\n+                .filter(type -> type.getAnnotation(Around.class) != null)\n+                .map(type -> type.getAnnotation(Type.class))\n+                .map(Type::value)\n+                .map(Set::of)\n+                .flatMap(Set::stream)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02a423c18cee7eca3c800f596998d36b31ccdaf4"}, "originalPosition": 353}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM0NTc2MTY3", "url": "https://github.com/oracle/helidon/pull/2467#pullrequestreview-534576167", "createdAt": "2020-11-19T15:40:24Z", "commit": {"oid": "3e73e69d4360b5c93a0ed7afa6138176519cc1fc"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNTo0MDoyNFrOH2ksIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNTo0MDoyNFrOH2ksIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjk4NjI3Mg==", "bodyText": "argumentNames[0].getName() seems weird, var name arguments would sound better", "url": "https://github.com/oracle/helidon/pull/2467#discussion_r526986272", "createdAt": "2020-11-19T15:40:24Z", "author": {"login": "danielkec"}, "path": "integrations/micronaut/cdi/src/main/java/io/helidon/integrations/micronaut/cdi/MicronautMethodInvocationContext.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.integrations.micronaut.cdi;\n+\n+import java.lang.reflect.Method;\n+import java.util.Iterator;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.logging.Logger;\n+\n+import javax.interceptor.InvocationContext;\n+\n+import io.helidon.common.LazyValue;\n+\n+import io.micronaut.aop.Interceptor;\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.aop.MethodInvocationContext;\n+import io.micronaut.core.convert.ConversionService;\n+import io.micronaut.core.convert.value.MutableConvertibleMultiValuesMap;\n+import io.micronaut.core.convert.value.MutableConvertibleValues;\n+import io.micronaut.core.type.Argument;\n+import io.micronaut.core.type.ArgumentValue;\n+import io.micronaut.core.type.MutableArgumentValue;\n+import io.micronaut.core.type.ReturnType;\n+import io.micronaut.inject.ExecutableMethod;\n+\n+/**\n+ * Invocation context for Micronaut interceptors.\n+ */\n+@SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+class MicronautMethodInvocationContext implements MethodInvocationContext {\n+    private static final Logger LOGGER = Logger.getLogger(MicronautMethodInvocationContext.class.getName());\n+\n+    private final InvocationContext cdiContext;\n+    private final ExecutableMethod executableMethod;\n+    private final Set<MethodInterceptor<?, ?>> allInterceptors;\n+    private final LazyValue<MutableConvertibleMultiValuesMap> attributes;\n+    private final LazyValue<Map<String, MutableArgumentValue<?>>> mutableArguments;\n+\n+    private Iterator<MethodInterceptor<?, ?>> remaining;\n+\n+    private MicronautMethodInvocationContext(InvocationContext cdiContext,\n+                                             ExecutableMethod executableMethod,\n+                                             Set<MethodInterceptor<?, ?>> allInterceptors,\n+                                             Iterator<MethodInterceptor<?, ?>> remaining) {\n+        this.cdiContext = cdiContext;\n+        this.executableMethod = executableMethod;\n+        this.allInterceptors = allInterceptors;\n+        this.remaining = remaining;\n+\n+        this.attributes = LazyValue.create(MutableConvertibleMultiValuesMap::new);\n+        this.mutableArguments = LazyValue.create(() -> {\n+            Map<String, MutableArgumentValue<?>> args = new LinkedHashMap<>();\n+            Object[] parameters = cdiContext.getParameters();\n+            Argument[] argumentNames = executableMethod.getArguments();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e73e69d4360b5c93a0ed7afa6138176519cc1fc"}, "originalPosition": 70}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM0NTgzODQ1", "url": "https://github.com/oracle/helidon/pull/2467#pullrequestreview-534583845", "createdAt": "2020-11-19T15:47:44Z", "commit": {"oid": "3e73e69d4360b5c93a0ed7afa6138176519cc1fc"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNTo0Nzo0NFrOH2lC-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNTo0Nzo0NFrOH2lC-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjk5MjEyMA==", "bodyText": "Is it possible that no interceptor classes are found and NPE is thrown?", "url": "https://github.com/oracle/helidon/pull/2467#discussion_r526992120", "createdAt": "2020-11-19T15:47:44Z", "author": {"login": "danielkec"}, "path": "integrations/micronaut/cdi/src/main/java/io/helidon/integrations/micronaut/cdi/MicronautInterceptor.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.integrations.micronaut.cdi;\n+\n+import java.lang.reflect.Method;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.logging.Logger;\n+\n+import javax.annotation.Priority;\n+import javax.inject.Inject;\n+import javax.interceptor.AroundInvoke;\n+import javax.interceptor.Interceptor;\n+import javax.interceptor.InvocationContext;\n+\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.context.ApplicationContext;\n+import io.micronaut.core.annotation.Internal;\n+import io.micronaut.inject.ExecutableMethod;\n+\n+/**\n+ * A CDI interceptor that invokes all Micronaut interceptors.\n+ * DO NOT USE DIRECTLY. Usage is computed by this CDI extension.\n+ */\n+// interceptor binding is defined in code of extension, not on annotation\n+@MicronautIntercepted\n+@Interceptor\n+@Priority(Interceptor.Priority.LIBRARY_BEFORE)\n+@Internal\n+public class MicronautInterceptor {\n+    private static final Logger LOGGER = Logger.getLogger(MicronautInterceptor.class.getName());\n+\n+    private final ApplicationContext context;\n+    private final MicronautCdiExtension extension;\n+\n+    @Inject\n+    MicronautInterceptor(ApplicationContext context, MicronautCdiExtension extension) {\n+        this.context = context;\n+        this.extension = extension;\n+    }\n+\n+    /**\n+     * Interceptor method that call Micronaut interceptors for a CDI bean.\n+     *\n+     * @param cdiCtx invocation context\n+     * @return response of the method\n+     */\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    @AroundInvoke\n+    public Object invoke(InvocationContext cdiCtx) {\n+\n+        Method javaMethod = cdiCtx.getMethod();\n+        MethodInterceptorMetadata meta = extension.getInterceptionMetadata(javaMethod);\n+\n+        Set<Class<? extends MethodInterceptor<?, ?>>> interceptorClasses = meta.interceptors();\n+        Set<MethodInterceptor<?, ?>> interceptors = new TreeSet<>(Comparator.comparingInt(MethodInterceptor::getOrder));\n+\n+        for (Class<? extends MethodInterceptor> aClass : interceptorClasses) {\n+            // we need to find the bean for each invocation, as this may be a prototype bean\n+            interceptors.add(context.findBean(aClass)\n+                                     .orElseThrow(() -> new MicronautCdiException(\"Cannot create bean class for interceptor \"\n+                                                                                          + aClass.getName())));\n+        }\n+\n+        ExecutableMethod<?, ?> executableMethod = meta.executableMethod();\n+        Iterator<MethodInterceptor<?, ?>> remaining = interceptors.iterator();\n+        io.micronaut.aop.MethodInvocationContext context = MicronautMethodInvocationContext\n+                .create(cdiCtx, executableMethod, interceptors, remaining);\n+\n+        MethodInterceptor<?, ?> next = remaining.next();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e73e69d4360b5c93a0ed7afa6138176519cc1fc"}, "originalPosition": 86}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM0NTg3NTA3", "url": "https://github.com/oracle/helidon/pull/2467#pullrequestreview-534587507", "createdAt": "2020-11-19T15:51:17Z", "commit": {"oid": "3e73e69d4360b5c93a0ed7afa6138176519cc1fc"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxNTo1MToxN1rOH2lOAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxODoxNDo1M1rOH2rinw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjk5NDk0Nw==", "bodyText": "Not needed anymore? \ud83d\udc7b", "url": "https://github.com/oracle/helidon/pull/2467#discussion_r526994947", "createdAt": "2020-11-19T15:51:17Z", "author": {"login": "danielkec"}, "path": "integrations/micronaut/cdi/src/main/java/io/helidon/integrations/micronaut/cdi/MicronautCdiExtension.java", "diffHunk": "@@ -0,0 +1,406 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.helidon.integrations.micronaut.cdi;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.Priority;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.context.BeforeDestroyed;\n+import javax.enterprise.context.Dependent;\n+import javax.enterprise.context.Initialized;\n+import javax.enterprise.event.Observes;\n+import javax.enterprise.inject.spi.AfterBeanDiscovery;\n+import javax.enterprise.inject.spi.BeforeBeanDiscovery;\n+import javax.enterprise.inject.spi.Extension;\n+import javax.enterprise.inject.spi.ProcessAnnotatedType;\n+import javax.enterprise.inject.spi.configurator.BeanConfigurator;\n+import javax.inject.Qualifier;\n+\n+import io.micronaut.aop.Around;\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.context.ApplicationContext;\n+import io.micronaut.context.annotation.Type;\n+import io.micronaut.context.env.PropertySource;\n+import io.micronaut.core.annotation.AnnotationMetadata;\n+import io.micronaut.core.io.service.ServiceDefinition;\n+import io.micronaut.core.io.service.SoftServiceLoader;\n+import io.micronaut.inject.BeanDefinition;\n+import io.micronaut.inject.BeanDefinitionReference;\n+import io.micronaut.inject.ExecutableMethod;\n+import io.micronaut.inject.qualifiers.Qualifiers;\n+import org.eclipse.microprofile.config.Config;\n+\n+import static javax.interceptor.Interceptor.Priority.PLATFORM_AFTER;\n+import static javax.interceptor.Interceptor.Priority.PLATFORM_BEFORE;\n+\n+/**\n+ * Extension integrating CDI with Micronaut.\n+ * This extensions adds Micronaut beans to be injectable into CDI beans (limited to {@link javax.inject.Singleton}\n+ * scope), adn adds support for invoking Micronaut interceptors.\n+ */\n+public class MicronautCdiExtension implements Extension {\n+    private final AtomicReference<ApplicationContext> micronautContext = new AtomicReference<>();\n+    private final Map<Method, ExecutableMethod<?, ?>> executableMethodCache = new HashMap<>();\n+    private final Map<Method, MethodInterceptorMetadata> methods = new HashMap<>();\n+    // all bean definitions as seen by Micronaut\n+    private List<MicronautBean> beanDefinitions = new LinkedList<>();\n+    // map of an actual class (user's source code) mapping to Micronaut bean definition\n+    private final Map<Class<?>, List<MicronautBean>> mBeanToDefRef = new HashMap<>();\n+    // Micronaut beans not yet processed by CDI\n+    private final Map<Class<?>, List<MicronautBean>> unprocessedBeans = new HashMap<>();\n+\n+    /**\n+     * Get the application context of Micronaut.\n+     * This method can only be invoked once the server is started.\n+     *\n+     * @return Micronaut application context\n+     * @throws java.lang.IllegalStateException when invoked when server (and hence the context) is not started\n+     */\n+    public ApplicationContext context() {\n+        ApplicationContext ctx = micronautContext.get();\n+        if (ctx == null) {\n+            throw new IllegalStateException(\n+                    \"Micronaut application context can only be obtained after the ApplicationScoped is initialized\");\n+        }\n+        return ctx;\n+    }\n+\n+    MethodInterceptorMetadata getInterceptionMetadata(Method javaMethod) {\n+        return methods.get(javaMethod);\n+    }\n+\n+    /**\n+     * Load all Micronaut bean definitions and register our interceptor binding, so we can\n+     * execute Micronaut interceptors using a CDI interceptor.\n+     *\n+     * @param event CDI event\n+     */\n+    void beforeBeanDiscovery(@Priority(PLATFORM_BEFORE) @Observes BeforeBeanDiscovery event) {\n+        loadMicronautBeanDefinitions();\n+\n+        event.addAnnotatedType(MicronautInterceptor.class, \"mcdi-MicronautInterceptor\");\n+        event.addInterceptorBinding(MicronautIntercepted.class);\n+    }\n+\n+    /**\n+     * Construct a list of Micronaut interceptors to execute on each CDI method.\n+     * In case a Micronaut bean definition is available for the CDI bean (which should be for application, as\n+     * the CDI annotation processor should be used, and it adds CDI beans as Micronaut beans), the information\n+     * is combined from Micronaut and CDI bean definitions.\n+     *\n+     * @param event CDI event\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    void processTypes(@Priority(PLATFORM_AFTER) @Observes ProcessAnnotatedType<?> event) {\n+        Set<Class<?>> classInterceptors = new HashSet<>();\n+        Map<Method, Set<Class<?>>> allMethodInterceptors = new HashMap<>();\n+\n+        List<MicronautBean> miBeans = unprocessedBeans.remove(event.getAnnotatedType().getJavaClass());\n+\n+        if (miBeans != null && miBeans.size() > 0) {\n+            BeanDefinitionReference<?> miBean = findMicronautBeanDefinition(miBeans);\n+            // add all interceptors that are seen based on Micronaut\n+            findMicronautInterceptors(classInterceptors, allMethodInterceptors, miBean);\n+        }\n+\n+        // find all annotations that have meta annotation Around and collect their Type list to add as interceptors\n+        addMicronautInterceptors(classInterceptors, event.getAnnotatedType().getAnnotations());\n+\n+        // for each method, find the same (Around, collect Type), and add the interceptor binding for Micronaut interceptors\n+        // CDI interceptors will be automatic\n+        event.configureAnnotatedType()\n+                .methods()\n+                .forEach(method -> {\n+                    Method javaMethod = method.getAnnotated().getJavaMember();\n+\n+                    Set<Class<?>> methodInterceptors = allMethodInterceptors.computeIfAbsent(javaMethod, it -> new HashSet<>());\n+                    methodInterceptors.addAll(classInterceptors);\n+\n+                    addMicronautInterceptors(methodInterceptors, method.getAnnotated().getAnnotations());\n+\n+                    if (!methodInterceptors.isEmpty()) {\n+                        // now I have a set of micronaut interceptors that are needed for this method\n+                        method.add(MicronautIntercepted.Literal.INSTANCE);\n+\n+                        Set<Class<? extends MethodInterceptor<?, ?>>> interceptors = new HashSet<>();\n+                        methodInterceptors.forEach(it -> interceptors.add((Class<? extends MethodInterceptor<?, ?>>) it));\n+\n+                        methods.computeIfAbsent(javaMethod,\n+                                                theMethod -> MethodInterceptorMetadata.create(\n+                                                        method.getAnnotated(),\n+                                                        executableMethodCache.get(theMethod)))\n+                                .addInterceptors(interceptors);\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Add all (not yet added) Micronaut beans for injection as long as they are singletons.\n+     *\n+     * @param event CDI event\n+     */\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    void afterBeanDiscovery(@Priority(PLATFORM_BEFORE) @Observes AfterBeanDiscovery event) {\n+        event.addBean()\n+                .addType(ApplicationContext.class)\n+                .id(\"micronaut-context\")\n+                .scope(ApplicationScoped.class)\n+                .produceWith(instance -> micronautContext.get());\n+\n+        // add the remaining Micronaut beans\n+        for (var entry : unprocessedBeans.entrySet()) {\n+            Class<?> beanType = entry.getKey();\n+            List<MicronautBean> beans = entry.getValue();\n+\n+            List<? extends BeanDefinitionReference<?>> refs = List.of();\n+            if (beans.size() > 1) {\n+                // first make sure these are singletons; if not, ignore\n+                refs = beans.stream()\n+                        .map(MicronautBean::definitionRef)\n+                        .filter(it -> !it.getBeanType().getName().endsWith(\"$Intercepted\"))\n+                        .filter(BeanDefinitionReference::isSingleton)\n+                        .collect(Collectors.toList());\n+            }\n+\n+            // primary\n+            event.addBean()\n+                    .addType(beanType)\n+                    .id(\"micronaut-\" + beanType.getName())\n+                    // inject using dependent - manage scope by micronaut context\n+                    .scope(Dependent.class)\n+                    .produceWith(instance -> micronautContext.get().getBean(beanType));\n+\n+            if (refs.size() > 1) {\n+                // we must care about qualifiers\n+                for (var ref : refs) {\n+                    AnnotationMetadata annotationMetadata = ref.getAnnotationMetadata();\n+                    List<Class<? extends Annotation>> qualifiers = annotationMetadata\n+                            .getAnnotationTypesByStereotype(Qualifier.class);\n+\n+                    Annotation[] synthesized = new Annotation[qualifiers.size()];\n+                    io.micronaut.context.Qualifier[] mq = new io.micronaut.context.Qualifier[qualifiers.size()];\n+\n+                    for (int i = 0; i < qualifiers.size(); i++) {\n+                        Annotation annotation = annotationMetadata.synthesize(qualifiers.get(i));\n+                        synthesized[i] = annotation;\n+                        if (annotation != null) {\n+                            mq[i] = Qualifiers.byAnnotation(annotation);\n+                        }\n+                    }\n+\n+                    io.micronaut.context.Qualifier composite = Qualifiers.byQualifiers(mq);\n+\n+                    BeanConfigurator<Object> newBean = event.addBean()\n+                            .addType(beanType)\n+                            .id(\"micronaut-\" + ref.getBeanDefinitionName())\n+                            .scope(Dependent.class)\n+                            .produceWith(instance -> micronautContext.get().getBean(beanType, composite));\n+\n+                    for (Annotation annotation : synthesized) {\n+                        newBean.addQualifier(annotation);\n+                    }\n+\n+                }\n+            }\n+        }\n+        unprocessedBeans.clear();\n+    }\n+\n+    /**\n+     * Start Micronaut application context and make it available for other extensions.\n+     *\n+     * @param event CDI event\n+     */\n+    void startContext(@Observes @Priority(PLATFORM_BEFORE) @Initialized(ApplicationScoped.class) Object event) {\n+        ApplicationContext context = ApplicationContext.builder()\n+                .propertySources(createMicronautPropertySource())\n+                .build();\n+\n+        context.start();\n+\n+        micronautContext.set(context);\n+    }\n+\n+    /**\n+     * Stop Micronaut application context.\n+     * @param event CDI event\n+     */\n+    void stopContext(@Observes @Priority(PLATFORM_AFTER) @BeforeDestroyed(ApplicationScoped.class) Object event) {\n+        ApplicationContext context = micronautContext.get();\n+        // if startup failed, context is null\n+        if (context != null) {\n+            context.close();\n+        }\n+    }\n+\n+    /**\n+     * Use MicroProfile Config as a config source for Micronaut.\n+     *\n+     * @return Micronaut property source from MP Config\n+     */\n+    private PropertySource createMicronautPropertySource() {\n+        Config config = org.eclipse.microprofile.config.ConfigProvider.getConfig();\n+\n+        return new PropertySource() {\n+            @Override\n+            public String getName() {\n+                return \"MicroProfile-Config\";\n+            }\n+\n+            @Override\n+            public Object get(String key) {\n+                return config.getOptionalValue(key, String.class).orElse(null);\n+            }\n+\n+            @Override\n+            public Iterator<String> iterator() {\n+                List<String> names = new LinkedList<>();\n+                config.getPropertyNames()\n+                        .forEach(names::add);\n+\n+                return names.iterator();\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Load Micronaut bean definition using service loader, to have full knowledge of the landscape.\n+     */\n+    @SuppressWarnings(\"rawtypes\")\n+    private void loadMicronautBeanDefinitions() {\n+        // we now need to load all Micronaut beans so other extensions can inject them\n+        List<ServiceDefinition<BeanDefinitionReference>> list = new ArrayList<>(200);\n+\n+        SoftServiceLoader.load(BeanDefinitionReference.class)\n+                .forEach(list::add);\n+\n+        List<MicronautBean> beans = list.parallelStream()\n+                .filter(ServiceDefinition::isPresent)\n+                .map(ServiceDefinition::load)\n+                .filter(BeanDefinitionReference::isPresent)\n+                .map(ref -> {\n+                    Class<?> beanType = ref.getBeanType();\n+\n+                    String className = ref.getBeanType().getName();\n+                    if (className.endsWith(\"$Intercepted\")) {\n+                        // either superclass is the one we want, or first implemented interface\n+                        if (Object.class.equals(beanType.getSuperclass())) {\n+                            Class<?>[] interfaces = beanType.getInterfaces();\n+                            if (interfaces.length > 0) {\n+                                beanType = interfaces[0];\n+                            }\n+                        } else {\n+                            beanType = beanType.getSuperclass();\n+                        }\n+                    }\n+\n+                    return new MicronautBean(beanType, ref);\n+                })\n+                .collect(Collectors.toList());\n+\n+        // using my own collection, so the field is final\n+        beanDefinitions.addAll(beans);\n+\n+        for (MicronautBean defRef : beanDefinitions) {\n+            mBeanToDefRef.computeIfAbsent(defRef.beanType(), it -> new LinkedList<>())\n+                    .add(defRef);\n+        }\n+\n+        unprocessedBeans.putAll(mBeanToDefRef);\n+    }\n+\n+    /**\n+     * Find Micronaut interceptor annotations and locate interceptor classes to be used.\n+     *\n+     * @param interceptors set of interceptors to add new interceptors to\n+     * @param annotations set of annotations on the processed element\n+     */\n+    private void addMicronautInterceptors(Set<Class<?>> interceptors, Set<Annotation> annotations) {\n+        annotations.stream()\n+                .map(Annotation::annotationType)\n+                .filter(type -> type.getAnnotation(Around.class) != null)\n+                .map(type -> type.getAnnotation(Type.class))\n+                .map(Type::value)\n+                .map(Set::of)\n+                .flatMap(Set::stream)\n+                .forEach(interceptors::add);\n+    }\n+\n+    private void findMicronautInterceptors(Set<Class<?>> classInterceptors,\n+                                           Map<Method, Set<Class<?>>> allMethodInterceptors,\n+                                           BeanDefinitionReference<?> miBean) {\n+        // find all annotations with Around stereotype and find its Type annotation to add interceptors\n+        miBean.getAnnotationMetadata()\n+                .getAnnotationTypesByStereotype(Around.class)\n+                .stream()\n+                .map(it -> it.getAnnotation(Type.class))\n+                .filter(Objects::nonNull)\n+                .map(Type::value)\n+                .flatMap(Stream::of)\n+                .forEach(classInterceptors::add);\n+\n+        BeanDefinition<?> beanDef = miBean.load();\n+\n+        Collection<? extends ExecutableMethod<?, ?>> executableMethods = beanDef.getExecutableMethods();\n+        for (ExecutableMethod<?, ?> executableMethod : executableMethods) {\n+            Set<Class<?>> methodInterceptors = new HashSet<>();\n+\n+            executableMethod\n+                    .getAnnotationTypesByStereotype(Around.class)\n+                    .stream()\n+                    .map(it -> it.getAnnotation(Type.class))\n+                    .filter(Objects::nonNull)\n+                    .map(Type::value)\n+                    .flatMap(Stream::of)\n+                    .forEach(methodInterceptors::add);\n+\n+            this.executableMethodCache.putIfAbsent(executableMethod.getTargetMethod(), executableMethod);\n+\n+            allMethodInterceptors.computeIfAbsent(executableMethod.getTargetMethod(), it -> new HashSet<>())\n+                    .addAll(methodInterceptors);\n+        }\n+    }\n+\n+    private BeanDefinitionReference<?> findMicronautBeanDefinition(List<MicronautBean> mBeans) {\n+        for (MicronautBean mBean : mBeans) {\n+            BeanDefinitionReference<?> ref = mBean.definitionRef();\n+            //            if (ref instanceof AdvisedBeanType) {\n+            //                continue;\n+            //            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e73e69d4360b5c93a0ed7afa6138176519cc1fc"}, "originalPosition": 397}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjk5OTgxOA==", "bodyText": "Could be little prettier\nfindMicronautBeanDefinition(miBeans)\n    .ifPresent(miBean -> findMicronautInterceptors(classInterceptors, allMethodInterceptors, miBean))", "url": "https://github.com/oracle/helidon/pull/2467#discussion_r526999818", "createdAt": "2020-11-19T15:57:13Z", "author": {"login": "danielkec"}, "path": "integrations/micronaut/cdi/src/main/java/io/helidon/integrations/micronaut/cdi/MicronautCdiExtension.java", "diffHunk": "@@ -0,0 +1,406 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.helidon.integrations.micronaut.cdi;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.Priority;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.context.BeforeDestroyed;\n+import javax.enterprise.context.Dependent;\n+import javax.enterprise.context.Initialized;\n+import javax.enterprise.event.Observes;\n+import javax.enterprise.inject.spi.AfterBeanDiscovery;\n+import javax.enterprise.inject.spi.BeforeBeanDiscovery;\n+import javax.enterprise.inject.spi.Extension;\n+import javax.enterprise.inject.spi.ProcessAnnotatedType;\n+import javax.enterprise.inject.spi.configurator.BeanConfigurator;\n+import javax.inject.Qualifier;\n+\n+import io.micronaut.aop.Around;\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.context.ApplicationContext;\n+import io.micronaut.context.annotation.Type;\n+import io.micronaut.context.env.PropertySource;\n+import io.micronaut.core.annotation.AnnotationMetadata;\n+import io.micronaut.core.io.service.ServiceDefinition;\n+import io.micronaut.core.io.service.SoftServiceLoader;\n+import io.micronaut.inject.BeanDefinition;\n+import io.micronaut.inject.BeanDefinitionReference;\n+import io.micronaut.inject.ExecutableMethod;\n+import io.micronaut.inject.qualifiers.Qualifiers;\n+import org.eclipse.microprofile.config.Config;\n+\n+import static javax.interceptor.Interceptor.Priority.PLATFORM_AFTER;\n+import static javax.interceptor.Interceptor.Priority.PLATFORM_BEFORE;\n+\n+/**\n+ * Extension integrating CDI with Micronaut.\n+ * This extensions adds Micronaut beans to be injectable into CDI beans (limited to {@link javax.inject.Singleton}\n+ * scope), adn adds support for invoking Micronaut interceptors.\n+ */\n+public class MicronautCdiExtension implements Extension {\n+    private final AtomicReference<ApplicationContext> micronautContext = new AtomicReference<>();\n+    private final Map<Method, ExecutableMethod<?, ?>> executableMethodCache = new HashMap<>();\n+    private final Map<Method, MethodInterceptorMetadata> methods = new HashMap<>();\n+    // all bean definitions as seen by Micronaut\n+    private List<MicronautBean> beanDefinitions = new LinkedList<>();\n+    // map of an actual class (user's source code) mapping to Micronaut bean definition\n+    private final Map<Class<?>, List<MicronautBean>> mBeanToDefRef = new HashMap<>();\n+    // Micronaut beans not yet processed by CDI\n+    private final Map<Class<?>, List<MicronautBean>> unprocessedBeans = new HashMap<>();\n+\n+    /**\n+     * Get the application context of Micronaut.\n+     * This method can only be invoked once the server is started.\n+     *\n+     * @return Micronaut application context\n+     * @throws java.lang.IllegalStateException when invoked when server (and hence the context) is not started\n+     */\n+    public ApplicationContext context() {\n+        ApplicationContext ctx = micronautContext.get();\n+        if (ctx == null) {\n+            throw new IllegalStateException(\n+                    \"Micronaut application context can only be obtained after the ApplicationScoped is initialized\");\n+        }\n+        return ctx;\n+    }\n+\n+    MethodInterceptorMetadata getInterceptionMetadata(Method javaMethod) {\n+        return methods.get(javaMethod);\n+    }\n+\n+    /**\n+     * Load all Micronaut bean definitions and register our interceptor binding, so we can\n+     * execute Micronaut interceptors using a CDI interceptor.\n+     *\n+     * @param event CDI event\n+     */\n+    void beforeBeanDiscovery(@Priority(PLATFORM_BEFORE) @Observes BeforeBeanDiscovery event) {\n+        loadMicronautBeanDefinitions();\n+\n+        event.addAnnotatedType(MicronautInterceptor.class, \"mcdi-MicronautInterceptor\");\n+        event.addInterceptorBinding(MicronautIntercepted.class);\n+    }\n+\n+    /**\n+     * Construct a list of Micronaut interceptors to execute on each CDI method.\n+     * In case a Micronaut bean definition is available for the CDI bean (which should be for application, as\n+     * the CDI annotation processor should be used, and it adds CDI beans as Micronaut beans), the information\n+     * is combined from Micronaut and CDI bean definitions.\n+     *\n+     * @param event CDI event\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    void processTypes(@Priority(PLATFORM_AFTER) @Observes ProcessAnnotatedType<?> event) {\n+        Set<Class<?>> classInterceptors = new HashSet<>();\n+        Map<Method, Set<Class<?>>> allMethodInterceptors = new HashMap<>();\n+\n+        List<MicronautBean> miBeans = unprocessedBeans.remove(event.getAnnotatedType().getJavaClass());\n+\n+        if (miBeans != null && miBeans.size() > 0) {\n+            BeanDefinitionReference<?> miBean = findMicronautBeanDefinition(miBeans);\n+            // add all interceptors that are seen based on Micronaut\n+            findMicronautInterceptors(classInterceptors, allMethodInterceptors, miBean);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e73e69d4360b5c93a0ed7afa6138176519cc1fc"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAwOTkxMA==", "bodyText": "Code duplication alert with line 362-368", "url": "https://github.com/oracle/helidon/pull/2467#discussion_r527009910", "createdAt": "2020-11-19T16:10:07Z", "author": {"login": "danielkec"}, "path": "integrations/micronaut/cdi/src/main/java/io/helidon/integrations/micronaut/cdi/MicronautCdiExtension.java", "diffHunk": "@@ -0,0 +1,406 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.helidon.integrations.micronaut.cdi;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.Priority;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.context.BeforeDestroyed;\n+import javax.enterprise.context.Dependent;\n+import javax.enterprise.context.Initialized;\n+import javax.enterprise.event.Observes;\n+import javax.enterprise.inject.spi.AfterBeanDiscovery;\n+import javax.enterprise.inject.spi.BeforeBeanDiscovery;\n+import javax.enterprise.inject.spi.Extension;\n+import javax.enterprise.inject.spi.ProcessAnnotatedType;\n+import javax.enterprise.inject.spi.configurator.BeanConfigurator;\n+import javax.inject.Qualifier;\n+\n+import io.micronaut.aop.Around;\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.context.ApplicationContext;\n+import io.micronaut.context.annotation.Type;\n+import io.micronaut.context.env.PropertySource;\n+import io.micronaut.core.annotation.AnnotationMetadata;\n+import io.micronaut.core.io.service.ServiceDefinition;\n+import io.micronaut.core.io.service.SoftServiceLoader;\n+import io.micronaut.inject.BeanDefinition;\n+import io.micronaut.inject.BeanDefinitionReference;\n+import io.micronaut.inject.ExecutableMethod;\n+import io.micronaut.inject.qualifiers.Qualifiers;\n+import org.eclipse.microprofile.config.Config;\n+\n+import static javax.interceptor.Interceptor.Priority.PLATFORM_AFTER;\n+import static javax.interceptor.Interceptor.Priority.PLATFORM_BEFORE;\n+\n+/**\n+ * Extension integrating CDI with Micronaut.\n+ * This extensions adds Micronaut beans to be injectable into CDI beans (limited to {@link javax.inject.Singleton}\n+ * scope), adn adds support for invoking Micronaut interceptors.\n+ */\n+public class MicronautCdiExtension implements Extension {\n+    private final AtomicReference<ApplicationContext> micronautContext = new AtomicReference<>();\n+    private final Map<Method, ExecutableMethod<?, ?>> executableMethodCache = new HashMap<>();\n+    private final Map<Method, MethodInterceptorMetadata> methods = new HashMap<>();\n+    // all bean definitions as seen by Micronaut\n+    private List<MicronautBean> beanDefinitions = new LinkedList<>();\n+    // map of an actual class (user's source code) mapping to Micronaut bean definition\n+    private final Map<Class<?>, List<MicronautBean>> mBeanToDefRef = new HashMap<>();\n+    // Micronaut beans not yet processed by CDI\n+    private final Map<Class<?>, List<MicronautBean>> unprocessedBeans = new HashMap<>();\n+\n+    /**\n+     * Get the application context of Micronaut.\n+     * This method can only be invoked once the server is started.\n+     *\n+     * @return Micronaut application context\n+     * @throws java.lang.IllegalStateException when invoked when server (and hence the context) is not started\n+     */\n+    public ApplicationContext context() {\n+        ApplicationContext ctx = micronautContext.get();\n+        if (ctx == null) {\n+            throw new IllegalStateException(\n+                    \"Micronaut application context can only be obtained after the ApplicationScoped is initialized\");\n+        }\n+        return ctx;\n+    }\n+\n+    MethodInterceptorMetadata getInterceptionMetadata(Method javaMethod) {\n+        return methods.get(javaMethod);\n+    }\n+\n+    /**\n+     * Load all Micronaut bean definitions and register our interceptor binding, so we can\n+     * execute Micronaut interceptors using a CDI interceptor.\n+     *\n+     * @param event CDI event\n+     */\n+    void beforeBeanDiscovery(@Priority(PLATFORM_BEFORE) @Observes BeforeBeanDiscovery event) {\n+        loadMicronautBeanDefinitions();\n+\n+        event.addAnnotatedType(MicronautInterceptor.class, \"mcdi-MicronautInterceptor\");\n+        event.addInterceptorBinding(MicronautIntercepted.class);\n+    }\n+\n+    /**\n+     * Construct a list of Micronaut interceptors to execute on each CDI method.\n+     * In case a Micronaut bean definition is available for the CDI bean (which should be for application, as\n+     * the CDI annotation processor should be used, and it adds CDI beans as Micronaut beans), the information\n+     * is combined from Micronaut and CDI bean definitions.\n+     *\n+     * @param event CDI event\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    void processTypes(@Priority(PLATFORM_AFTER) @Observes ProcessAnnotatedType<?> event) {\n+        Set<Class<?>> classInterceptors = new HashSet<>();\n+        Map<Method, Set<Class<?>>> allMethodInterceptors = new HashMap<>();\n+\n+        List<MicronautBean> miBeans = unprocessedBeans.remove(event.getAnnotatedType().getJavaClass());\n+\n+        if (miBeans != null && miBeans.size() > 0) {\n+            BeanDefinitionReference<?> miBean = findMicronautBeanDefinition(miBeans);\n+            // add all interceptors that are seen based on Micronaut\n+            findMicronautInterceptors(classInterceptors, allMethodInterceptors, miBean);\n+        }\n+\n+        // find all annotations that have meta annotation Around and collect their Type list to add as interceptors\n+        addMicronautInterceptors(classInterceptors, event.getAnnotatedType().getAnnotations());\n+\n+        // for each method, find the same (Around, collect Type), and add the interceptor binding for Micronaut interceptors\n+        // CDI interceptors will be automatic\n+        event.configureAnnotatedType()\n+                .methods()\n+                .forEach(method -> {\n+                    Method javaMethod = method.getAnnotated().getJavaMember();\n+\n+                    Set<Class<?>> methodInterceptors = allMethodInterceptors.computeIfAbsent(javaMethod, it -> new HashSet<>());\n+                    methodInterceptors.addAll(classInterceptors);\n+\n+                    addMicronautInterceptors(methodInterceptors, method.getAnnotated().getAnnotations());\n+\n+                    if (!methodInterceptors.isEmpty()) {\n+                        // now I have a set of micronaut interceptors that are needed for this method\n+                        method.add(MicronautIntercepted.Literal.INSTANCE);\n+\n+                        Set<Class<? extends MethodInterceptor<?, ?>>> interceptors = new HashSet<>();\n+                        methodInterceptors.forEach(it -> interceptors.add((Class<? extends MethodInterceptor<?, ?>>) it));\n+\n+                        methods.computeIfAbsent(javaMethod,\n+                                                theMethod -> MethodInterceptorMetadata.create(\n+                                                        method.getAnnotated(),\n+                                                        executableMethodCache.get(theMethod)))\n+                                .addInterceptors(interceptors);\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Add all (not yet added) Micronaut beans for injection as long as they are singletons.\n+     *\n+     * @param event CDI event\n+     */\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    void afterBeanDiscovery(@Priority(PLATFORM_BEFORE) @Observes AfterBeanDiscovery event) {\n+        event.addBean()\n+                .addType(ApplicationContext.class)\n+                .id(\"micronaut-context\")\n+                .scope(ApplicationScoped.class)\n+                .produceWith(instance -> micronautContext.get());\n+\n+        // add the remaining Micronaut beans\n+        for (var entry : unprocessedBeans.entrySet()) {\n+            Class<?> beanType = entry.getKey();\n+            List<MicronautBean> beans = entry.getValue();\n+\n+            List<? extends BeanDefinitionReference<?>> refs = List.of();\n+            if (beans.size() > 1) {\n+                // first make sure these are singletons; if not, ignore\n+                refs = beans.stream()\n+                        .map(MicronautBean::definitionRef)\n+                        .filter(it -> !it.getBeanType().getName().endsWith(\"$Intercepted\"))\n+                        .filter(BeanDefinitionReference::isSingleton)\n+                        .collect(Collectors.toList());\n+            }\n+\n+            // primary\n+            event.addBean()\n+                    .addType(beanType)\n+                    .id(\"micronaut-\" + beanType.getName())\n+                    // inject using dependent - manage scope by micronaut context\n+                    .scope(Dependent.class)\n+                    .produceWith(instance -> micronautContext.get().getBean(beanType));\n+\n+            if (refs.size() > 1) {\n+                // we must care about qualifiers\n+                for (var ref : refs) {\n+                    AnnotationMetadata annotationMetadata = ref.getAnnotationMetadata();\n+                    List<Class<? extends Annotation>> qualifiers = annotationMetadata\n+                            .getAnnotationTypesByStereotype(Qualifier.class);\n+\n+                    Annotation[] synthesized = new Annotation[qualifiers.size()];\n+                    io.micronaut.context.Qualifier[] mq = new io.micronaut.context.Qualifier[qualifiers.size()];\n+\n+                    for (int i = 0; i < qualifiers.size(); i++) {\n+                        Annotation annotation = annotationMetadata.synthesize(qualifiers.get(i));\n+                        synthesized[i] = annotation;\n+                        if (annotation != null) {\n+                            mq[i] = Qualifiers.byAnnotation(annotation);\n+                        }\n+                    }\n+\n+                    io.micronaut.context.Qualifier composite = Qualifiers.byQualifiers(mq);\n+\n+                    BeanConfigurator<Object> newBean = event.addBean()\n+                            .addType(beanType)\n+                            .id(\"micronaut-\" + ref.getBeanDefinitionName())\n+                            .scope(Dependent.class)\n+                            .produceWith(instance -> micronautContext.get().getBean(beanType, composite));\n+\n+                    for (Annotation annotation : synthesized) {\n+                        newBean.addQualifier(annotation);\n+                    }\n+\n+                }\n+            }\n+        }\n+        unprocessedBeans.clear();\n+    }\n+\n+    /**\n+     * Start Micronaut application context and make it available for other extensions.\n+     *\n+     * @param event CDI event\n+     */\n+    void startContext(@Observes @Priority(PLATFORM_BEFORE) @Initialized(ApplicationScoped.class) Object event) {\n+        ApplicationContext context = ApplicationContext.builder()\n+                .propertySources(createMicronautPropertySource())\n+                .build();\n+\n+        context.start();\n+\n+        micronautContext.set(context);\n+    }\n+\n+    /**\n+     * Stop Micronaut application context.\n+     * @param event CDI event\n+     */\n+    void stopContext(@Observes @Priority(PLATFORM_AFTER) @BeforeDestroyed(ApplicationScoped.class) Object event) {\n+        ApplicationContext context = micronautContext.get();\n+        // if startup failed, context is null\n+        if (context != null) {\n+            context.close();\n+        }\n+    }\n+\n+    /**\n+     * Use MicroProfile Config as a config source for Micronaut.\n+     *\n+     * @return Micronaut property source from MP Config\n+     */\n+    private PropertySource createMicronautPropertySource() {\n+        Config config = org.eclipse.microprofile.config.ConfigProvider.getConfig();\n+\n+        return new PropertySource() {\n+            @Override\n+            public String getName() {\n+                return \"MicroProfile-Config\";\n+            }\n+\n+            @Override\n+            public Object get(String key) {\n+                return config.getOptionalValue(key, String.class).orElse(null);\n+            }\n+\n+            @Override\n+            public Iterator<String> iterator() {\n+                List<String> names = new LinkedList<>();\n+                config.getPropertyNames()\n+                        .forEach(names::add);\n+\n+                return names.iterator();\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Load Micronaut bean definition using service loader, to have full knowledge of the landscape.\n+     */\n+    @SuppressWarnings(\"rawtypes\")\n+    private void loadMicronautBeanDefinitions() {\n+        // we now need to load all Micronaut beans so other extensions can inject them\n+        List<ServiceDefinition<BeanDefinitionReference>> list = new ArrayList<>(200);\n+\n+        SoftServiceLoader.load(BeanDefinitionReference.class)\n+                .forEach(list::add);\n+\n+        List<MicronautBean> beans = list.parallelStream()\n+                .filter(ServiceDefinition::isPresent)\n+                .map(ServiceDefinition::load)\n+                .filter(BeanDefinitionReference::isPresent)\n+                .map(ref -> {\n+                    Class<?> beanType = ref.getBeanType();\n+\n+                    String className = ref.getBeanType().getName();\n+                    if (className.endsWith(\"$Intercepted\")) {\n+                        // either superclass is the one we want, or first implemented interface\n+                        if (Object.class.equals(beanType.getSuperclass())) {\n+                            Class<?>[] interfaces = beanType.getInterfaces();\n+                            if (interfaces.length > 0) {\n+                                beanType = interfaces[0];\n+                            }\n+                        } else {\n+                            beanType = beanType.getSuperclass();\n+                        }\n+                    }\n+\n+                    return new MicronautBean(beanType, ref);\n+                })\n+                .collect(Collectors.toList());\n+\n+        // using my own collection, so the field is final\n+        beanDefinitions.addAll(beans);\n+\n+        for (MicronautBean defRef : beanDefinitions) {\n+            mBeanToDefRef.computeIfAbsent(defRef.beanType(), it -> new LinkedList<>())\n+                    .add(defRef);\n+        }\n+\n+        unprocessedBeans.putAll(mBeanToDefRef);\n+    }\n+\n+    /**\n+     * Find Micronaut interceptor annotations and locate interceptor classes to be used.\n+     *\n+     * @param interceptors set of interceptors to add new interceptors to\n+     * @param annotations set of annotations on the processed element\n+     */\n+    private void addMicronautInterceptors(Set<Class<?>> interceptors, Set<Annotation> annotations) {\n+        annotations.stream()\n+                .map(Annotation::annotationType)\n+                .filter(type -> type.getAnnotation(Around.class) != null)\n+                .map(type -> type.getAnnotation(Type.class))\n+                .map(Type::value)\n+                .map(Set::of)\n+                .flatMap(Set::stream)\n+                .forEach(interceptors::add);\n+    }\n+\n+    private void findMicronautInterceptors(Set<Class<?>> classInterceptors,\n+                                           Map<Method, Set<Class<?>>> allMethodInterceptors,\n+                                           BeanDefinitionReference<?> miBean) {\n+        // find all annotations with Around stereotype and find its Type annotation to add interceptors\n+        miBean.getAnnotationMetadata()\n+                .getAnnotationTypesByStereotype(Around.class)\n+                .stream()\n+                .map(it -> it.getAnnotation(Type.class))\n+                .filter(Objects::nonNull)\n+                .map(Type::value)\n+                .flatMap(Stream::of)\n+                .forEach(classInterceptors::add);\n+\n+        BeanDefinition<?> beanDef = miBean.load();\n+\n+        Collection<? extends ExecutableMethod<?, ?>> executableMethods = beanDef.getExecutableMethods();\n+        for (ExecutableMethod<?, ?> executableMethod : executableMethods) {\n+            Set<Class<?>> methodInterceptors = new HashSet<>();\n+\n+            executableMethod\n+                    .getAnnotationTypesByStereotype(Around.class)\n+                    .stream()\n+                    .map(it -> it.getAnnotation(Type.class))\n+                    .filter(Objects::nonNull)\n+                    .map(Type::value)\n+                    .flatMap(Stream::of)\n+                    .forEach(methodInterceptors::add);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e73e69d4360b5c93a0ed7afa6138176519cc1fc"}, "originalPosition": 383}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAxODcxMg==", "bodyText": "Bean id prefix used 4 times would deserve a constant", "url": "https://github.com/oracle/helidon/pull/2467#discussion_r527018712", "createdAt": "2020-11-19T16:21:56Z", "author": {"login": "danielkec"}, "path": "integrations/micronaut/cdi/src/main/java/io/helidon/integrations/micronaut/cdi/MicronautCdiExtension.java", "diffHunk": "@@ -0,0 +1,406 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.helidon.integrations.micronaut.cdi;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.Priority;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.context.BeforeDestroyed;\n+import javax.enterprise.context.Dependent;\n+import javax.enterprise.context.Initialized;\n+import javax.enterprise.event.Observes;\n+import javax.enterprise.inject.spi.AfterBeanDiscovery;\n+import javax.enterprise.inject.spi.BeforeBeanDiscovery;\n+import javax.enterprise.inject.spi.Extension;\n+import javax.enterprise.inject.spi.ProcessAnnotatedType;\n+import javax.enterprise.inject.spi.configurator.BeanConfigurator;\n+import javax.inject.Qualifier;\n+\n+import io.micronaut.aop.Around;\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.context.ApplicationContext;\n+import io.micronaut.context.annotation.Type;\n+import io.micronaut.context.env.PropertySource;\n+import io.micronaut.core.annotation.AnnotationMetadata;\n+import io.micronaut.core.io.service.ServiceDefinition;\n+import io.micronaut.core.io.service.SoftServiceLoader;\n+import io.micronaut.inject.BeanDefinition;\n+import io.micronaut.inject.BeanDefinitionReference;\n+import io.micronaut.inject.ExecutableMethod;\n+import io.micronaut.inject.qualifiers.Qualifiers;\n+import org.eclipse.microprofile.config.Config;\n+\n+import static javax.interceptor.Interceptor.Priority.PLATFORM_AFTER;\n+import static javax.interceptor.Interceptor.Priority.PLATFORM_BEFORE;\n+\n+/**\n+ * Extension integrating CDI with Micronaut.\n+ * This extensions adds Micronaut beans to be injectable into CDI beans (limited to {@link javax.inject.Singleton}\n+ * scope), adn adds support for invoking Micronaut interceptors.\n+ */\n+public class MicronautCdiExtension implements Extension {\n+    private final AtomicReference<ApplicationContext> micronautContext = new AtomicReference<>();\n+    private final Map<Method, ExecutableMethod<?, ?>> executableMethodCache = new HashMap<>();\n+    private final Map<Method, MethodInterceptorMetadata> methods = new HashMap<>();\n+    // all bean definitions as seen by Micronaut\n+    private List<MicronautBean> beanDefinitions = new LinkedList<>();\n+    // map of an actual class (user's source code) mapping to Micronaut bean definition\n+    private final Map<Class<?>, List<MicronautBean>> mBeanToDefRef = new HashMap<>();\n+    // Micronaut beans not yet processed by CDI\n+    private final Map<Class<?>, List<MicronautBean>> unprocessedBeans = new HashMap<>();\n+\n+    /**\n+     * Get the application context of Micronaut.\n+     * This method can only be invoked once the server is started.\n+     *\n+     * @return Micronaut application context\n+     * @throws java.lang.IllegalStateException when invoked when server (and hence the context) is not started\n+     */\n+    public ApplicationContext context() {\n+        ApplicationContext ctx = micronautContext.get();\n+        if (ctx == null) {\n+            throw new IllegalStateException(\n+                    \"Micronaut application context can only be obtained after the ApplicationScoped is initialized\");\n+        }\n+        return ctx;\n+    }\n+\n+    MethodInterceptorMetadata getInterceptionMetadata(Method javaMethod) {\n+        return methods.get(javaMethod);\n+    }\n+\n+    /**\n+     * Load all Micronaut bean definitions and register our interceptor binding, so we can\n+     * execute Micronaut interceptors using a CDI interceptor.\n+     *\n+     * @param event CDI event\n+     */\n+    void beforeBeanDiscovery(@Priority(PLATFORM_BEFORE) @Observes BeforeBeanDiscovery event) {\n+        loadMicronautBeanDefinitions();\n+\n+        event.addAnnotatedType(MicronautInterceptor.class, \"mcdi-MicronautInterceptor\");\n+        event.addInterceptorBinding(MicronautIntercepted.class);\n+    }\n+\n+    /**\n+     * Construct a list of Micronaut interceptors to execute on each CDI method.\n+     * In case a Micronaut bean definition is available for the CDI bean (which should be for application, as\n+     * the CDI annotation processor should be used, and it adds CDI beans as Micronaut beans), the information\n+     * is combined from Micronaut and CDI bean definitions.\n+     *\n+     * @param event CDI event\n+     */\n+    @SuppressWarnings(\"unchecked\")\n+    void processTypes(@Priority(PLATFORM_AFTER) @Observes ProcessAnnotatedType<?> event) {\n+        Set<Class<?>> classInterceptors = new HashSet<>();\n+        Map<Method, Set<Class<?>>> allMethodInterceptors = new HashMap<>();\n+\n+        List<MicronautBean> miBeans = unprocessedBeans.remove(event.getAnnotatedType().getJavaClass());\n+\n+        if (miBeans != null && miBeans.size() > 0) {\n+            BeanDefinitionReference<?> miBean = findMicronautBeanDefinition(miBeans);\n+            // add all interceptors that are seen based on Micronaut\n+            findMicronautInterceptors(classInterceptors, allMethodInterceptors, miBean);\n+        }\n+\n+        // find all annotations that have meta annotation Around and collect their Type list to add as interceptors\n+        addMicronautInterceptors(classInterceptors, event.getAnnotatedType().getAnnotations());\n+\n+        // for each method, find the same (Around, collect Type), and add the interceptor binding for Micronaut interceptors\n+        // CDI interceptors will be automatic\n+        event.configureAnnotatedType()\n+                .methods()\n+                .forEach(method -> {\n+                    Method javaMethod = method.getAnnotated().getJavaMember();\n+\n+                    Set<Class<?>> methodInterceptors = allMethodInterceptors.computeIfAbsent(javaMethod, it -> new HashSet<>());\n+                    methodInterceptors.addAll(classInterceptors);\n+\n+                    addMicronautInterceptors(methodInterceptors, method.getAnnotated().getAnnotations());\n+\n+                    if (!methodInterceptors.isEmpty()) {\n+                        // now I have a set of micronaut interceptors that are needed for this method\n+                        method.add(MicronautIntercepted.Literal.INSTANCE);\n+\n+                        Set<Class<? extends MethodInterceptor<?, ?>>> interceptors = new HashSet<>();\n+                        methodInterceptors.forEach(it -> interceptors.add((Class<? extends MethodInterceptor<?, ?>>) it));\n+\n+                        methods.computeIfAbsent(javaMethod,\n+                                                theMethod -> MethodInterceptorMetadata.create(\n+                                                        method.getAnnotated(),\n+                                                        executableMethodCache.get(theMethod)))\n+                                .addInterceptors(interceptors);\n+                    }\n+                });\n+    }\n+\n+    /**\n+     * Add all (not yet added) Micronaut beans for injection as long as they are singletons.\n+     *\n+     * @param event CDI event\n+     */\n+    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+    void afterBeanDiscovery(@Priority(PLATFORM_BEFORE) @Observes AfterBeanDiscovery event) {\n+        event.addBean()\n+                .addType(ApplicationContext.class)\n+                .id(\"micronaut-context\")\n+                .scope(ApplicationScoped.class)\n+                .produceWith(instance -> micronautContext.get());\n+\n+        // add the remaining Micronaut beans\n+        for (var entry : unprocessedBeans.entrySet()) {\n+            Class<?> beanType = entry.getKey();\n+            List<MicronautBean> beans = entry.getValue();\n+\n+            List<? extends BeanDefinitionReference<?>> refs = List.of();\n+            if (beans.size() > 1) {\n+                // first make sure these are singletons; if not, ignore\n+                refs = beans.stream()\n+                        .map(MicronautBean::definitionRef)\n+                        .filter(it -> !it.getBeanType().getName().endsWith(\"$Intercepted\"))\n+                        .filter(BeanDefinitionReference::isSingleton)\n+                        .collect(Collectors.toList());\n+            }\n+\n+            // primary\n+            event.addBean()\n+                    .addType(beanType)\n+                    .id(\"micronaut-\" + beanType.getName())\n+                    // inject using dependent - manage scope by micronaut context\n+                    .scope(Dependent.class)\n+                    .produceWith(instance -> micronautContext.get().getBean(beanType));\n+\n+            if (refs.size() > 1) {\n+                // we must care about qualifiers\n+                for (var ref : refs) {\n+                    AnnotationMetadata annotationMetadata = ref.getAnnotationMetadata();\n+                    List<Class<? extends Annotation>> qualifiers = annotationMetadata\n+                            .getAnnotationTypesByStereotype(Qualifier.class);\n+\n+                    Annotation[] synthesized = new Annotation[qualifiers.size()];\n+                    io.micronaut.context.Qualifier[] mq = new io.micronaut.context.Qualifier[qualifiers.size()];\n+\n+                    for (int i = 0; i < qualifiers.size(); i++) {\n+                        Annotation annotation = annotationMetadata.synthesize(qualifiers.get(i));\n+                        synthesized[i] = annotation;\n+                        if (annotation != null) {\n+                            mq[i] = Qualifiers.byAnnotation(annotation);\n+                        }\n+                    }\n+\n+                    io.micronaut.context.Qualifier composite = Qualifiers.byQualifiers(mq);\n+\n+                    BeanConfigurator<Object> newBean = event.addBean()\n+                            .addType(beanType)\n+                            .id(\"micronaut-\" + ref.getBeanDefinitionName())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e73e69d4360b5c93a0ed7afa6138176519cc1fc"}, "originalPosition": 223}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAyMzE1Nw==", "bodyText": "adn", "url": "https://github.com/oracle/helidon/pull/2467#discussion_r527023157", "createdAt": "2020-11-19T16:27:46Z", "author": {"login": "danielkec"}, "path": "integrations/micronaut/cdi/src/main/java/io/helidon/integrations/micronaut/cdi/MicronautCdiExtension.java", "diffHunk": "@@ -0,0 +1,406 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.helidon.integrations.micronaut.cdi;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.Priority;\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.enterprise.context.BeforeDestroyed;\n+import javax.enterprise.context.Dependent;\n+import javax.enterprise.context.Initialized;\n+import javax.enterprise.event.Observes;\n+import javax.enterprise.inject.spi.AfterBeanDiscovery;\n+import javax.enterprise.inject.spi.BeforeBeanDiscovery;\n+import javax.enterprise.inject.spi.Extension;\n+import javax.enterprise.inject.spi.ProcessAnnotatedType;\n+import javax.enterprise.inject.spi.configurator.BeanConfigurator;\n+import javax.inject.Qualifier;\n+\n+import io.micronaut.aop.Around;\n+import io.micronaut.aop.MethodInterceptor;\n+import io.micronaut.context.ApplicationContext;\n+import io.micronaut.context.annotation.Type;\n+import io.micronaut.context.env.PropertySource;\n+import io.micronaut.core.annotation.AnnotationMetadata;\n+import io.micronaut.core.io.service.ServiceDefinition;\n+import io.micronaut.core.io.service.SoftServiceLoader;\n+import io.micronaut.inject.BeanDefinition;\n+import io.micronaut.inject.BeanDefinitionReference;\n+import io.micronaut.inject.ExecutableMethod;\n+import io.micronaut.inject.qualifiers.Qualifiers;\n+import org.eclipse.microprofile.config.Config;\n+\n+import static javax.interceptor.Interceptor.Priority.PLATFORM_AFTER;\n+import static javax.interceptor.Interceptor.Priority.PLATFORM_BEFORE;\n+\n+/**\n+ * Extension integrating CDI with Micronaut.\n+ * This extensions adds Micronaut beans to be injectable into CDI beans (limited to {@link javax.inject.Singleton}\n+ * scope), adn adds support for invoking Micronaut interceptors.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e73e69d4360b5c93a0ed7afa6138176519cc1fc"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzA3Nzg5NQ==", "bodyText": "teh", "url": "https://github.com/oracle/helidon/pull/2467#discussion_r527077895", "createdAt": "2020-11-19T17:43:04Z", "author": {"login": "danielkec"}, "path": "integrations/micronaut/cdi/src/main/java/io/helidon/integrations/micronaut/cdi/CdiExecutableMethod.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.integrations.micronaut.cdi;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.annotation.Documented;\n+import java.lang.annotation.Repeatable;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.Target;\n+import java.lang.reflect.Array;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.lang.reflect.Parameter;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.enterprise.inject.spi.Annotated;\n+import javax.enterprise.inject.spi.AnnotatedMethod;\n+import javax.enterprise.inject.spi.AnnotatedParameter;\n+\n+import io.micronaut.context.AbstractExecutableMethod;\n+import io.micronaut.core.annotation.AnnotationMetadata;\n+import io.micronaut.core.annotation.AnnotationValue;\n+import io.micronaut.core.type.Argument;\n+import io.micronaut.core.type.DefaultArgument;\n+import io.micronaut.inject.ExecutableMethod;\n+import io.micronaut.inject.annotation.DefaultAnnotationMetadata;\n+\n+// Executable method used to invoke Micronaut interceptor when we need to merge CDI and Micronaut\n+// annotation metadata, or when we do not have Micronaut annotation metadata\n+@SuppressWarnings(\"rawtypes\")\n+final class CdiExecutableMethod extends AbstractExecutableMethod {\n+    private final AnnotationMetadata annotationMetadata;\n+\n+    private CdiExecutableMethod(AnnotationMetadata methodAnnotationMetadata,\n+                                Class<?> declaringType,\n+                                String methodName,\n+                                Argument<?> genericReturnType,\n+                                Argument... arguments) {\n+        super(declaringType, methodName, genericReturnType, arguments);\n+        this.annotationMetadata = methodAnnotationMetadata;\n+    }\n+\n+    /**\n+     * Create from CDI method and Micronaut executable method.\n+     * Merges together annotations from both worlds.\n+     *\n+     * @param cdiMethod CDI annotated method\n+     * @param micronautMethod Micronaut executable method\n+     * @return a new combined executable method\n+     */\n+    static ExecutableMethod<?, ?> create(AnnotatedMethod<?> cdiMethod, ExecutableMethod<?, ?> micronautMethod) {\n+        return create(cdiMethod,\n+                      annotationMetadata(cdiMethod, micronautMethod.getAnnotationMetadata()),\n+                      arguments(cdiMethod.getParameters(), micronautMethod.getArguments()));\n+    }\n+\n+    /**\n+     * Create from CDI method.\n+     *\n+     * @param cdiMethod CDI annotated method\n+     * @return Micronaut executable method\n+     */\n+    static ExecutableMethod<?, ?> create(AnnotatedMethod<?> cdiMethod) {\n+        return create(cdiMethod,\n+                      annotationMetadata(cdiMethod),\n+                      arguments(cdiMethod.getParameters()));\n+    }\n+\n+    private static ExecutableMethod<?, ?> create(AnnotatedMethod<?> cdiMethod,\n+                                                 AnnotationMetadata annotationMetadata,\n+                                                 Argument... arguments) {\n+        Class<?> declaringType = cdiMethod.getDeclaringType().getJavaClass();\n+        Argument<?> returnType = Argument.of(cdiMethod.getJavaMember().getReturnType());\n+\n+        return new CdiExecutableMethod(annotationMetadata,\n+                                       declaringType,\n+                                       cdiMethod.getJavaMember().getName(),\n+                                       returnType,\n+                                       arguments);\n+    }\n+\n+    @Override\n+    protected AnnotationMetadata resolveAnnotationMetadata() {\n+        return annotationMetadata;\n+    }\n+\n+    @Override\n+    protected Object invokeInternal(Object instance, Object[] arguments) {\n+        throw new MicronautCdiException(\"invokeInternal should not be called in interceptor\");\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static Argument[] arguments(List<? extends AnnotatedParameter<?>> parameters, Argument[] miParameters) {\n+        Argument[] result = new Argument[parameters.size()];\n+\n+        for (int i = 0; i < parameters.size(); i++) {\n+            AnnotatedParameter<?> parameter = parameters.get(i);\n+            result[i] = toArgument(parameter, miParameters[i]);\n+        }\n+\n+        return result;\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    private static Argument[] arguments(List<? extends AnnotatedParameter<?>> parameters) {\n+        Argument[] result = new Argument[parameters.size()];\n+\n+        for (int i = 0; i < parameters.size(); i++) {\n+            AnnotatedParameter<?> parameter = parameters.get(i);\n+            result[i] = toArgument(parameter);\n+        }\n+\n+        return result;\n+    }\n+\n+    private static Argument<?> toArgument(AnnotatedParameter<?> parameter, Argument argument) {\n+        Parameter javaParameter = parameter.getJavaParameter();\n+        return new DefaultArgument(javaParameter.getParameterizedType(),\n+                                   javaParameter.getName(),\n+                                   annotationMetadata(parameter, argument.getAnnotationMetadata()));\n+    }\n+\n+    private static Argument<?> toArgument(AnnotatedParameter<?> parameter) {\n+        Parameter javaParameter = parameter.getJavaParameter();\n+        return new DefaultArgument(javaParameter.getType(),\n+                                   javaParameter.getName(),\n+                                   annotationMetadata(parameter));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static AnnotationMetadata annotationMetadata(Annotated annotated, AnnotationMetadata miAnnotated) {\n+        Map<Class<? extends Annotation>, Annotation> annotations = new HashMap<>();\n+        Set<String> miAnnotationNames = miAnnotated.getAnnotationNames();\n+        // add micronaut annotations\n+        for (String miAnnotationName : miAnnotationNames) {\n+            try {\n+                Annotation annotation = miAnnotated.synthesize((Class<? extends Annotation>) Class.forName(miAnnotationName));\n+                annotations.put(annotation.annotationType(), annotation);\n+            } catch (Throwable ignored) {\n+                // this annotation is not on the classpath, we can ignore it\n+            }\n+        }\n+\n+        // then overwrite with CDI annotations (more significant for us)\n+        annotated.getAnnotations()\n+                .forEach(it -> annotations.put(it.annotationType(), it));\n+\n+        return annotationMetadata(annotations);\n+    }\n+\n+    private static AnnotationMetadata annotationMetadata(Annotated annotated) {\n+        Map<Class<? extends Annotation>, Annotation> annotations = new HashMap<>();\n+        annotated.getAnnotations()\n+                .forEach(it -> annotations.put(it.annotationType(), it));\n+\n+        return annotationMetadata(annotations);\n+    }\n+\n+    private static AnnotationMetadata annotationMetadata(Map<Class<? extends Annotation>, Annotation> annotations) {\n+        Map<Class<? extends Annotation>, Annotation> stereotypes = new HashMap<>();\n+        Map<String, Set<String>> byStereotype = new HashMap<>();\n+        Map<String, Map<CharSequence, Object>> miAnnotations = new HashMap<>();\n+\n+        processAnnotations(annotations,\n+                           miAnnotations,\n+                           stereotypes,\n+                           byStereotype);\n+\n+        Map<String, Map<CharSequence, Object>> miStereotypes = new HashMap<>();\n+        for (var entry : stereotypes.entrySet()) {\n+            miStereotypes.put(entry.getKey().getName(), annotationValues(entry.getValue()));\n+        }\n+\n+        Map<String, List<String>> byStereotypeWithList = new HashMap<>();\n+        byStereotype\n+                .forEach((stereotype, set) -> byStereotypeWithList.put(stereotype, new ArrayList<>(set)));\n+\n+        return new DefaultAnnotationMetadata(miAnnotations,\n+                                             miStereotypes,\n+                                             miStereotypes,\n+                                             miAnnotations,\n+                                             byStereotypeWithList);\n+    }\n+\n+    private static void processAnnotations(Map<Class<? extends Annotation>, Annotation> declaredAnnotations,\n+                                           Map<String, Map<CharSequence, Object>> miAnnotations,\n+                                           Map<Class<? extends Annotation>, Annotation> stereotypeMap,\n+                                           Map<String, Set<String>> annotationsByStereotype) {\n+        for (var entry : declaredAnnotations.entrySet()) {\n+            if (stereotypeMap.containsKey(Repeatable.class)) {\n+                // I need to ignore this (used only when there is just one repetition)\n+                // this gets processed as part of teh Repeatable container", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e73e69d4360b5c93a0ed7afa6138176519cc1fc"}, "originalPosition": 211}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzA4MzE2OA==", "bodyText": "Something is missing here \ud83d\udc40", "url": "https://github.com/oracle/helidon/pull/2467#discussion_r527083168", "createdAt": "2020-11-19T17:51:00Z", "author": {"login": "danielkec"}, "path": "integrations/micronaut/cdi/README.md", "diffHunk": "@@ -0,0 +1,30 @@\n+CDI integration with Micronaut\n+---\n+\n+#Introduction\n+\n+Goals of this integration:\n+\n+- Allow invocation of Micronaut interceptors on CDI beans\n+- Allow injection of Micronaut beans into CDI beans\n+\n+Non-goals:\n+\n+- Injection of CDI beans into Micronaut beans\n+- No support for request scope in Micronaut\n+\n+#Design\n+\n+What I need to do\n+ - find all interceptors handled by micronaut\n+ - find all beans handled by micronaut\n+ - add interceptor bindings to the CDI bean\n+ - prepare all execution metadata for that interceptor (executable method)\n+ - add producers for Micronaut based beans\n+\n+#Usage\n+\n+The following must be done to use this integration:\n+\n+- The dependency `` must be on classpath for annotation processing\n+- ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e73e69d4360b5c93a0ed7afa6138176519cc1fc"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzA5ODUyNw==", "bodyText": "this formating change seems weird", "url": "https://github.com/oracle/helidon/pull/2467#discussion_r527098527", "createdAt": "2020-11-19T18:14:53Z", "author": {"login": "danielkec"}, "path": "dependencies/pom.xml", "diffHunk": "@@ -920,10 +923,10 @@\n                 <artifactId>jboss-transaction-spi</artifactId>\n                 <version>${version.lib.jboss.transaction-spi}</version>\n                 <exclusions>\n-                  <exclusion>\n-                      <groupId>org.jboss.spec.javax.resource</groupId>\n-                      <artifactId>jboss-connector-api_1.7_spec</artifactId>\n-                  </exclusion>\n+                    <exclusion>\n+                        <groupId>org.jboss.spec.javax.resource</groupId>\n+                        <artifactId>jboss-connector-api_1.7_spec</artifactId>\n+                    </exclusion>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e73e69d4360b5c93a0ed7afa6138176519cc1fc"}, "originalPosition": 34}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "260a855b0045b7df255a10facb3fcfecac78bb77", "author": {"user": {"login": "tomas-langer", "name": "Tomas Langer"}}, "url": "https://github.com/oracle/helidon/commit/260a855b0045b7df255a10facb3fcfecac78bb77", "committedDate": "2020-11-20T12:46:00Z", "message": "squashable\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9d7465cc5c662bee734ba3c461bd8a81029980fe", "author": {"user": {"login": "tomas-langer", "name": "Tomas Langer"}}, "url": "https://github.com/oracle/helidon/commit/9d7465cc5c662bee734ba3c461bd8a81029980fe", "committedDate": "2020-11-20T12:46:00Z", "message": "squashable\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3d39f339a398d8c9c22b658cd34e9bfa5a42cb30", "author": {"user": {"login": "tomas-langer", "name": "Tomas Langer"}}, "url": "https://github.com/oracle/helidon/commit/3d39f339a398d8c9c22b658cd34e9bfa5a42cb30", "committedDate": "2020-11-20T12:46:00Z", "message": "squashable\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "14e2888f23f0577066934c0b0e1d120ea2a05e53", "author": {"user": {"login": "tomas-langer", "name": "Tomas Langer"}}, "url": "https://github.com/oracle/helidon/commit/14e2888f23f0577066934c0b0e1d120ea2a05e53", "committedDate": "2020-11-20T12:46:00Z", "message": "Using snapshot for fixed feature\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3a41570984973b4463db92bd1af9a49d6ae55081", "author": {"user": {"login": "tomas-langer", "name": "Tomas Langer"}}, "url": "https://github.com/oracle/helidon/commit/3a41570984973b4463db92bd1af9a49d6ae55081", "committedDate": "2020-11-20T12:46:01Z", "message": "squashable\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b9e1e99765177c6aac742c238d102130f821893f", "author": {"user": {"login": "tomas-langer", "name": "Tomas Langer"}}, "url": "https://github.com/oracle/helidon/commit/b9e1e99765177c6aac742c238d102130f821893f", "committedDate": "2020-11-20T12:46:01Z", "message": "squashable\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "43bfcf2e6bf134c8f07369621dd6bcfe3cc5cbd4", "author": {"user": {"login": "tomas-langer", "name": "Tomas Langer"}}, "url": "https://github.com/oracle/helidon/commit/43bfcf2e6bf134c8f07369621dd6bcfe3cc5cbd4", "committedDate": "2020-11-20T12:46:01Z", "message": "Squashable\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5a1e21ec7f0d41632de1670e7bb60715d047eac7", "author": {"user": {"login": "tomas-langer", "name": "Tomas Langer"}}, "url": "https://github.com/oracle/helidon/commit/5a1e21ec7f0d41632de1670e7bb60715d047eac7", "committedDate": "2020-11-20T12:46:01Z", "message": "Micronaut integration, with Micronaut Data support.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a22ac3e81abc1d3882d428b33416aea9779d02f0", "author": {"user": {"login": "tomas-langer", "name": "Tomas Langer"}}, "url": "https://github.com/oracle/helidon/commit/a22ac3e81abc1d3882d428b33416aea9779d02f0", "committedDate": "2020-11-20T12:46:01Z", "message": "Checkstyle fixes.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5fa440f3fa68d1241db235adb2985ad33f42c98e", "author": {"user": {"login": "tomas-langer", "name": "Tomas Langer"}}, "url": "https://github.com/oracle/helidon/commit/5fa440f3fa68d1241db235adb2985ad33f42c98e", "committedDate": "2020-11-20T12:46:01Z", "message": "Rebase and pom version fix.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8ec2689fbd2db9cf880b54f1b15e380bd031ea40", "author": {"user": {"login": "tomas-langer", "name": "Tomas Langer"}}, "url": "https://github.com/oracle/helidon/commit/8ec2689fbd2db9cf880b54f1b15e380bd031ea40", "committedDate": "2020-11-20T12:46:01Z", "message": "- module info\n- native image support\n- test for example\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f64311997abeb0257103dceb02963c3f7f3db21e", "author": {"user": {"login": "tomas-langer", "name": "Tomas Langer"}}, "url": "https://github.com/oracle/helidon/commit/f64311997abeb0257103dceb02963c3f7f3db21e", "committedDate": "2020-11-20T12:46:01Z", "message": "Fix javadoc issue.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "77594cb1cfc14322b1868e967a95bf57105ec3bc", "author": {"user": {"login": "tomas-langer", "name": "Tomas Langer"}}, "url": "https://github.com/oracle/helidon/commit/77594cb1cfc14322b1868e967a95bf57105ec3bc", "committedDate": "2020-11-20T12:46:01Z", "message": "Using the correct Micronaut scope for Dependent.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "36f650a9f402514e72719c0b2691ef0581d50d10", "author": {"user": {"login": "tomas-langer", "name": "Tomas Langer"}}, "url": "https://github.com/oracle/helidon/commit/36f650a9f402514e72719c0b2691ef0581d50d10", "committedDate": "2020-11-20T12:46:01Z", "message": "Support for parameterized types\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a2422b68d4bb523c5b5ae4da6ef6527fbe28d223", "author": {"user": {"login": "tomas-langer", "name": "Tomas Langer"}}, "url": "https://github.com/oracle/helidon/commit/a2422b68d4bb523c5b5ae4da6ef6527fbe28d223", "committedDate": "2020-11-20T12:46:01Z", "message": "Review fixes.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ef91e01b1d3a7fd860b7c98f9302f2ff9a592af1", "author": {"user": {"login": "tomas-langer", "name": "Tomas Langer"}}, "url": "https://github.com/oracle/helidon/commit/ef91e01b1d3a7fd860b7c98f9302f2ff9a592af1", "committedDate": "2020-11-20T12:46:01Z", "message": "Review comment fixes.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f40e241615e95da81bade0e22da7252362b2f12e", "author": {"user": {"login": "tomas-langer", "name": "Tomas Langer"}}, "url": "https://github.com/oracle/helidon/commit/f40e241615e95da81bade0e22da7252362b2f12e", "committedDate": "2020-11-20T13:59:35Z", "message": "Upgrade to latest Micronaut release.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3e73e69d4360b5c93a0ed7afa6138176519cc1fc", "author": {"user": {"login": "tomas-langer", "name": "Tomas Langer"}}, "url": "https://github.com/oracle/helidon/commit/3e73e69d4360b5c93a0ed7afa6138176519cc1fc", "committedDate": "2020-11-16T17:25:52Z", "message": "Update pom.xml\n\nFixed wrong merge"}, "afterCommit": {"oid": "f40e241615e95da81bade0e22da7252362b2f12e", "author": {"user": {"login": "tomas-langer", "name": "Tomas Langer"}}, "url": "https://github.com/oracle/helidon/commit/f40e241615e95da81bade0e22da7252362b2f12e", "committedDate": "2020-11-20T13:59:35Z", "message": "Upgrade to latest Micronaut release.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM1NDg3Njc1", "url": "https://github.com/oracle/helidon/pull/2467#pullrequestreview-535487675", "createdAt": "2020-11-20T14:44:01Z", "commit": {"oid": "f40e241615e95da81bade0e22da7252362b2f12e"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4ecda43ea559eba0c59685c575f990abd1bd7b71", "author": {"user": {"login": "tomas-langer", "name": "Tomas Langer"}}, "url": "https://github.com/oracle/helidon/commit/4ecda43ea559eba0c59685c575f990abd1bd7b71", "committedDate": "2020-11-25T11:18:11Z", "message": "Merge branch 'master' into 2386-micronaut-integration"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQyMDI4NDE4", "url": "https://github.com/oracle/helidon/pull/2467#pullrequestreview-542028418", "createdAt": "2020-12-01T15:40:09Z", "commit": {"oid": "4ecda43ea559eba0c59685c575f990abd1bd7b71"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 493, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}