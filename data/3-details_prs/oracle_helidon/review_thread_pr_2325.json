{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc5MDcxNjQ1", "number": 2325, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QyMzowMTo0NVrOEgLt3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QyMzowMTo0NVrOEgLt3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyMTgxODU0OnYy", "diffSide": "RIGHT", "path": "microprofile/openapi/src/main/java/io/helidon/microprofile/openapi/MPOpenAPIBuilder.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QyMzowMTo0NVrOHM6IHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxNTo1MTowOFrOHNTOHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzI5NzMwOQ==", "bodyText": "Since disposal will do nothing, this is probably OK, but it looks weird.  I wonder if you can move this Unmanaged stuff elsewhere, like where you call something like getClasses() on the Application instance, and do the disposal afterwards.  Like up around line 123 or so for example.", "url": "https://github.com/oracle/helidon/pull/2325#discussion_r483297309", "createdAt": "2020-09-03T23:01:45Z", "author": {"login": "ljnelson"}, "path": "microprofile/openapi/src/main/java/io/helidon/microprofile/openapi/MPOpenAPIBuilder.java", "diffHunk": "@@ -172,14 +172,11 @@ MPOpenAPIBuilder config(Config mpConfig) {\n     }\n \n     private static Optional<? extends Application> instantiate(Class<? extends Application> appClass) {\n-        try {\n-            return Optional.of(appClass.getConstructor().newInstance());\n-        } catch (InstantiationException | IllegalAccessException | InvocationTargetException e) {\n-            throw new RuntimeException(e);\n-        } catch (NoSuchMethodException e) {\n-            // Wrapper app does not have a no-args constructor so we canont instantiate it.\n-            return Optional.empty();\n-        }\n+        Unmanaged<? extends Application> unmanagedApp = new Unmanaged<>(appClass);\n+        Unmanaged.UnmanagedInstance<? extends Application> unmanagedInstance = unmanagedApp.newInstance();\n+        Application app = unmanagedInstance.produce().inject().postConstruct().get();\n+        unmanagedInstance.preDestroy().dispose();\n+        return Optional.of(app);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "08a4c740f7ccb74a8bbda44c884343753317ebd0"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzMxMjIxNw==", "bodyText": "It sounds as if your concern is that the use of the instance (the app) outlives the unmanagedInstance that gave rise to it.\nI see how that does look a bit odd. But the app instance also outlives the code around line 123 and in fact is used not only in the same MPOpenAPIBuilder but also in a separate class OpenApiCdiExtension.\nI'll take a look at refactoring things to address that admittedly odd-looking code without altering too much the way the consuming code operates. Thanks for the catch.", "url": "https://github.com/oracle/helidon/pull/2325#discussion_r483312217", "createdAt": "2020-09-03T23:53:37Z", "author": {"login": "tjquinno"}, "path": "microprofile/openapi/src/main/java/io/helidon/microprofile/openapi/MPOpenAPIBuilder.java", "diffHunk": "@@ -172,14 +172,11 @@ MPOpenAPIBuilder config(Config mpConfig) {\n     }\n \n     private static Optional<? extends Application> instantiate(Class<? extends Application> appClass) {\n-        try {\n-            return Optional.of(appClass.getConstructor().newInstance());\n-        } catch (InstantiationException | IllegalAccessException | InvocationTargetException e) {\n-            throw new RuntimeException(e);\n-        } catch (NoSuchMethodException e) {\n-            // Wrapper app does not have a no-args constructor so we canont instantiate it.\n-            return Optional.empty();\n-        }\n+        Unmanaged<? extends Application> unmanagedApp = new Unmanaged<>(appClass);\n+        Unmanaged.UnmanagedInstance<? extends Application> unmanagedInstance = unmanagedApp.newInstance();\n+        Application app = unmanagedInstance.produce().inject().postConstruct().get();\n+        unmanagedInstance.preDestroy().dispose();\n+        return Optional.of(app);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzI5NzMwOQ=="}, "originalCommit": {"oid": "08a4c740f7ccb74a8bbda44c884343753317ebd0"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzMxMjg4Nw==", "bodyText": "Yeah, the main problem is that dependent objects that may get injected into the Application instance (and of course it's user-supplied so you don't have any control over it) may get flushed/released/disposed when that dispose() call is made.  So you don't want them to go away obviously while the Application instance is in use somewhere.", "url": "https://github.com/oracle/helidon/pull/2325#discussion_r483312887", "createdAt": "2020-09-03T23:55:57Z", "author": {"login": "ljnelson"}, "path": "microprofile/openapi/src/main/java/io/helidon/microprofile/openapi/MPOpenAPIBuilder.java", "diffHunk": "@@ -172,14 +172,11 @@ MPOpenAPIBuilder config(Config mpConfig) {\n     }\n \n     private static Optional<? extends Application> instantiate(Class<? extends Application> appClass) {\n-        try {\n-            return Optional.of(appClass.getConstructor().newInstance());\n-        } catch (InstantiationException | IllegalAccessException | InvocationTargetException e) {\n-            throw new RuntimeException(e);\n-        } catch (NoSuchMethodException e) {\n-            // Wrapper app does not have a no-args constructor so we canont instantiate it.\n-            return Optional.empty();\n-        }\n+        Unmanaged<? extends Application> unmanagedApp = new Unmanaged<>(appClass);\n+        Unmanaged.UnmanagedInstance<? extends Application> unmanagedInstance = unmanagedApp.newInstance();\n+        Application app = unmanagedInstance.produce().inject().postConstruct().get();\n+        unmanagedInstance.preDestroy().dispose();\n+        return Optional.of(app);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzI5NzMwOQ=="}, "originalCommit": {"oid": "08a4c740f7ccb74a8bbda44c884343753317ebd0"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcwODQ0Ng==", "bodyText": "The latest push rearranges the code so it uses any unmanaged instance as much as needed, and only then disposes of it.", "url": "https://github.com/oracle/helidon/pull/2325#discussion_r483708446", "createdAt": "2020-09-04T15:51:08Z", "author": {"login": "tjquinno"}, "path": "microprofile/openapi/src/main/java/io/helidon/microprofile/openapi/MPOpenAPIBuilder.java", "diffHunk": "@@ -172,14 +172,11 @@ MPOpenAPIBuilder config(Config mpConfig) {\n     }\n \n     private static Optional<? extends Application> instantiate(Class<? extends Application> appClass) {\n-        try {\n-            return Optional.of(appClass.getConstructor().newInstance());\n-        } catch (InstantiationException | IllegalAccessException | InvocationTargetException e) {\n-            throw new RuntimeException(e);\n-        } catch (NoSuchMethodException e) {\n-            // Wrapper app does not have a no-args constructor so we canont instantiate it.\n-            return Optional.empty();\n-        }\n+        Unmanaged<? extends Application> unmanagedApp = new Unmanaged<>(appClass);\n+        Unmanaged.UnmanagedInstance<? extends Application> unmanagedInstance = unmanagedApp.newInstance();\n+        Application app = unmanagedInstance.produce().inject().postConstruct().get();\n+        unmanagedInstance.preDestroy().dispose();\n+        return Optional.of(app);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzI5NzMwOQ=="}, "originalCommit": {"oid": "08a4c740f7ccb74a8bbda44c884343753317ebd0"}, "originalPosition": 32}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 397, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}