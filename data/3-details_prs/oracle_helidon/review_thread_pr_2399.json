{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk0ODcwNTEw", "number": 2399, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNDozODoxMFrOEolU3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxODoxNzozMVrOEor_uA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwOTkwMDQ2OnYy", "diffSide": "RIGHT", "path": "docs/se/faulttolerance/01_faulttolerance.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNDozODoxMFrOHZwj5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNDozODoxMFrOHZwj5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc3MjA3MA==", "bodyText": "the value it produces is printed by the consumer and passed to 'thenAccept'.", "url": "https://github.com/oracle/helidon/pull/2399#discussion_r496772070", "createdAt": "2020-09-29T14:38:10Z", "author": {"login": "ljamen"}, "path": "docs/se/faulttolerance/01_faulttolerance.adoc", "diffHunk": "@@ -0,0 +1,338 @@\n+///////////////////////////////////////////////////////////////////////////////\n+\n+    Copyright (c) 2020 Oracle and/or its affiliates.\n+\n+    Licensed under the Apache License, Version 2.0 (the \"License\");\n+    you may not use this file except in compliance with the License.\n+    You may obtain a copy of the License at\n+\n+        http://www.apache.org/licenses/LICENSE-2.0\n+\n+    Unless required by applicable law or agreed to in writing, software\n+    distributed under the License is distributed on an \"AS IS\" BASIS,\n+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+    See the License for the specific language governing permissions and\n+    limitations under the License.\n+\n+///////////////////////////////////////////////////////////////////////////////\n+\n+= Fault Tolerance in Helidon SE\n+:toc:\n+:toc-placement: preamble\n+:h1Prefix: SE\n+:pagename: fault-tolerance\n+:description: Fault Tolerance in Helidon SE\n+:keywords: helidon, java, fault, tolerance, fault tolerance, se\n+:helidon-tag: https://github.com/oracle/helidon/tree/{helidon-version}\n+:quickstart-example: {helidon-tag}/examples/quickstarts/helidon-quickshelidon/webserver/cors\n+:javadoc-base-url-webserver: {javadoc-base-url}io.helidon.webserver/io/helidon/webserver\n+:helidon-variant: SE\n+:common-page-prefix-inc: ../../shared/cors/common_shared.adoc\n+:mp-microprofile: https://download.eclipse.org/microprofile/microprofile-fault-tolerance-2.1.1/microprofile-fault-tolerance-spec.html\n+\n+\n+== Introduction\n+\n+Helidon SE Fault Tolerance support is inspired by link:{mp-microprofile}[MicroProfile Fault Tolerance].\n+The API defines the notion of a _fault handler_ that can be combined with other handlers to\n+improve application robustness. Handlers are created to manage error conditions (faults)\n+that may occur in real-world application environments. Examples include service restarts,\n+network delays, temporal infrastructure instabilities, etc.\n+\n+The interaction of multiple microservices bring some new challenges from distributed systems\n+that require careful planning. Faults in distributed systems should be compartmentalized\n+to avoid unnecessary service interruptions. For example, if comparable information can\n+be obtained from multiples sources, a user request _should not_ be denied when a subset\n+of these sources is unreachable or offline. Similarly, if a non-essential source has been\n+flagged as unreachable, an application should avoid continuous access to that source\n+as that would result in much higher response times.\n+\n+In order to combat the most common types of application faults, the Helidon SE Fault Tolerance API\n+provides support for circuit breakers, retries, timeouts, bulkheads and fallbacks.\n+In addition, the API makes it very easy to create and monitor asynchronous tasks that\n+do not require explicit creation and management of threads/executors.\n+\n+=== Updating your POM\n+\n+The following POM dependency is necessary to use the Fault Tolerance SE API in a\n+Helidon application.\n+\n+[source,xml]\n+.Fault Tolerance SE Dependency in `pom.xml`\n+----\n+<dependency>\n+    <groupId>io.helidon.fault-tolerance</groupId>\n+    <artifactId>helidon-fault-tolerance</artifactId>\n+    <version>{helidon-version}</version>\n+</dependency>\n+----\n+\n+=== Single<T> and Multi<T>\n+\n+In what follows we shall assume the reader is familiar with the two core Helidon types\n+`Single<T>` and `Multi<T>` from the `io.helidon.common.reactive` package. Most simply,\n+a `Single<T>` is a promise to produce zero or one value of type `T` or signal an error;\n+while a `Multi<T>` is a promise to produce zero or more values of type `T` or signal an error.\n+More generally, these two types can be regarded as _producers_ of zero or more values of type\n+`T`.\n+\n+NOTE: Note also that `Single<T>`, like `CompletableFuture<T>`, extends `CompletionStage<T>`\n+ so conversion among these types is straightforward.\n+\n+We shall use all these types in connection with Fault Tolerance handlers in the next few\n+sections.\n+\n+=== Asynchronous\n+\n+Asynchronous tasks can be created or forked by using an `Async` instance. A supplier of type\n+`T` is provided as the argument when invoking this handler. For example:\n+\n+[source,java]\n+----\n+Single<Thread> s = Async.create().invoke(() -> Thread.currentThread()));\n+s.thenAccept(t -> System.out.println(\"Async task executed in thread \" + t));\n+----\n+\n+The supplier `() -> Thread.currentThread()` is executed in a new thread and\n+the value it produces printed by the consumer passed to `thenAccept`.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6081d533be384a75bfac9d3f78f2af0aece784f"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwOTkyMjg1OnYy", "diffSide": "RIGHT", "path": "docs/se/faulttolerance/01_faulttolerance.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNDo0MjozMVrOHZwx1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNDo0MjozMVrOHZwx1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc3NTYzNg==", "bodyText": "A fallback to a known result can ...\nfallback is the noun form and fall back is the action", "url": "https://github.com/oracle/helidon/pull/2399#discussion_r496775636", "createdAt": "2020-09-29T14:42:31Z", "author": {"login": "ljamen"}, "path": "docs/se/faulttolerance/01_faulttolerance.adoc", "diffHunk": "@@ -0,0 +1,338 @@\n+///////////////////////////////////////////////////////////////////////////////\n+\n+    Copyright (c) 2020 Oracle and/or its affiliates.\n+\n+    Licensed under the Apache License, Version 2.0 (the \"License\");\n+    you may not use this file except in compliance with the License.\n+    You may obtain a copy of the License at\n+\n+        http://www.apache.org/licenses/LICENSE-2.0\n+\n+    Unless required by applicable law or agreed to in writing, software\n+    distributed under the License is distributed on an \"AS IS\" BASIS,\n+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+    See the License for the specific language governing permissions and\n+    limitations under the License.\n+\n+///////////////////////////////////////////////////////////////////////////////\n+\n+= Fault Tolerance in Helidon SE\n+:toc:\n+:toc-placement: preamble\n+:h1Prefix: SE\n+:pagename: fault-tolerance\n+:description: Fault Tolerance in Helidon SE\n+:keywords: helidon, java, fault, tolerance, fault tolerance, se\n+:helidon-tag: https://github.com/oracle/helidon/tree/{helidon-version}\n+:quickstart-example: {helidon-tag}/examples/quickstarts/helidon-quickshelidon/webserver/cors\n+:javadoc-base-url-webserver: {javadoc-base-url}io.helidon.webserver/io/helidon/webserver\n+:helidon-variant: SE\n+:common-page-prefix-inc: ../../shared/cors/common_shared.adoc\n+:mp-microprofile: https://download.eclipse.org/microprofile/microprofile-fault-tolerance-2.1.1/microprofile-fault-tolerance-spec.html\n+\n+\n+== Introduction\n+\n+Helidon SE Fault Tolerance support is inspired by link:{mp-microprofile}[MicroProfile Fault Tolerance].\n+The API defines the notion of a _fault handler_ that can be combined with other handlers to\n+improve application robustness. Handlers are created to manage error conditions (faults)\n+that may occur in real-world application environments. Examples include service restarts,\n+network delays, temporal infrastructure instabilities, etc.\n+\n+The interaction of multiple microservices bring some new challenges from distributed systems\n+that require careful planning. Faults in distributed systems should be compartmentalized\n+to avoid unnecessary service interruptions. For example, if comparable information can\n+be obtained from multiples sources, a user request _should not_ be denied when a subset\n+of these sources is unreachable or offline. Similarly, if a non-essential source has been\n+flagged as unreachable, an application should avoid continuous access to that source\n+as that would result in much higher response times.\n+\n+In order to combat the most common types of application faults, the Helidon SE Fault Tolerance API\n+provides support for circuit breakers, retries, timeouts, bulkheads and fallbacks.\n+In addition, the API makes it very easy to create and monitor asynchronous tasks that\n+do not require explicit creation and management of threads/executors.\n+\n+=== Updating your POM\n+\n+The following POM dependency is necessary to use the Fault Tolerance SE API in a\n+Helidon application.\n+\n+[source,xml]\n+.Fault Tolerance SE Dependency in `pom.xml`\n+----\n+<dependency>\n+    <groupId>io.helidon.fault-tolerance</groupId>\n+    <artifactId>helidon-fault-tolerance</artifactId>\n+    <version>{helidon-version}</version>\n+</dependency>\n+----\n+\n+=== Single<T> and Multi<T>\n+\n+In what follows we shall assume the reader is familiar with the two core Helidon types\n+`Single<T>` and `Multi<T>` from the `io.helidon.common.reactive` package. Most simply,\n+a `Single<T>` is a promise to produce zero or one value of type `T` or signal an error;\n+while a `Multi<T>` is a promise to produce zero or more values of type `T` or signal an error.\n+More generally, these two types can be regarded as _producers_ of zero or more values of type\n+`T`.\n+\n+NOTE: Note also that `Single<T>`, like `CompletableFuture<T>`, extends `CompletionStage<T>`\n+ so conversion among these types is straightforward.\n+\n+We shall use all these types in connection with Fault Tolerance handlers in the next few\n+sections.\n+\n+=== Asynchronous\n+\n+Asynchronous tasks can be created or forked by using an `Async` instance. A supplier of type\n+`T` is provided as the argument when invoking this handler. For example:\n+\n+[source,java]\n+----\n+Single<Thread> s = Async.create().invoke(() -> Thread.currentThread()));\n+s.thenAccept(t -> System.out.println(\"Async task executed in thread \" + t));\n+----\n+\n+The supplier `() -> Thread.currentThread()` is executed in a new thread and\n+the value it produces printed by the consumer passed to `thenAccept`.\n+\n+NOTE: The method reference `Thread::currentThread` is a simplified way of\n+providing a supplier in the example above.\n+\n+Asynchronous tasks are executed in a thread pool managed by the Helidon SE\n+Fault Tolerance module. Thread pools are created during the initialization\n+phase of class `io.helidon.faulttolerance.FaultTolerance` and can be\n+configured for your application.\n+\n+=== Retries\n+\n+Temporal networking problems can sometimes be mitigated by simply retrying\n+a certain task. A `Retry` handler is created using a `RetryPolicy` that\n+indicates the number of retries, delay between retries, etc.\n+\n+[source,java]\n+----\n+Retry retry = Retry.builder()\n+                   .retryPolicy(Retry.JitterRetryPolicy.builder()\n+                                     .calls(3)\n+                                     .delay(Duration.ofMillis(100))\n+                                     .build())\n+                   .build();\n+retry.invoke(this::retryOnFailure);\n+----\n+\n+The sample code above will retry calls to the supplier `this::retryOnFailure`\n+for up to 3 times with a 100 millisecond delay between them.\n+\n+NOTE: The return type of method `retryOnFailure` in the example above must\n+be `CompletionStage<T>` and the parameter to the retry handler's `invoke`\n+method `Supplier<? extends CompletionStage<T>>`.\n+\n+If the `CompletionStage<T>` returned by the method completes exceptionally,\n+the call will be treated as a failure and retried until the maximum number\n+of attempts is reached; finer control is\n+possible by creating a retry policy and using methods such as\n+`applyOn(Class<? extends Throwable>... classes)` and\n+`skipOn(Class<? extends Throwable>... classes)` to control those exceptions\n+on which to act and those that can be ignored.\n+\n+=== Timeouts\n+\n+A request to a service that is inaccessible or simply unavailable should be bounded\n+to ensure a certain quality of service and response time. Timeouts can be configured\n+to avoid excessive waiting times. In addition, a fallback action can be defined\n+if a timeout expires as we shall cover in the next section.\n+\n+The following is an example of using `Timeout`:\n+[source,java]\n+----\n+Single<T> s = Timeout.create(Duration.ofMillis(10)).invoke(this::mayTakeVeryLong);\n+s.handle((t, e) -> {\n+    if (e instanceof TimeoutException) {\n+        // Invocation has timed out!\n+    }\n+    ...\n+});\n+----\n+\n+The example above monitors the call to method `mayTakeVeryLong` and reports a\n+`TimeoutException` if the execution takes more than 10 milliseconds to complete.\n+\n+=== Fallbacks\n+\n+A fall back to a _known_ result can sometimes be an alternative to", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6081d533be384a75bfac9d3f78f2af0aece784f"}, "originalPosition": 163}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwOTk0NzE5OnYy", "diffSide": "RIGHT", "path": "docs/se/faulttolerance/01_faulttolerance.adoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNDo0NzoxNlrOHZxBEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNDo0NzoxNlrOHZxBEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc3OTUzNg==", "bodyText": "from eagerly transition states without considering...\nfrom transitioning states without considering", "url": "https://github.com/oracle/helidon/pull/2399#discussion_r496779536", "createdAt": "2020-09-29T14:47:16Z", "author": {"login": "ljamen"}, "path": "docs/se/faulttolerance/01_faulttolerance.adoc", "diffHunk": "@@ -0,0 +1,338 @@\n+///////////////////////////////////////////////////////////////////////////////\n+\n+    Copyright (c) 2020 Oracle and/or its affiliates.\n+\n+    Licensed under the Apache License, Version 2.0 (the \"License\");\n+    you may not use this file except in compliance with the License.\n+    You may obtain a copy of the License at\n+\n+        http://www.apache.org/licenses/LICENSE-2.0\n+\n+    Unless required by applicable law or agreed to in writing, software\n+    distributed under the License is distributed on an \"AS IS\" BASIS,\n+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+    See the License for the specific language governing permissions and\n+    limitations under the License.\n+\n+///////////////////////////////////////////////////////////////////////////////\n+\n+= Fault Tolerance in Helidon SE\n+:toc:\n+:toc-placement: preamble\n+:h1Prefix: SE\n+:pagename: fault-tolerance\n+:description: Fault Tolerance in Helidon SE\n+:keywords: helidon, java, fault, tolerance, fault tolerance, se\n+:helidon-tag: https://github.com/oracle/helidon/tree/{helidon-version}\n+:quickstart-example: {helidon-tag}/examples/quickstarts/helidon-quickshelidon/webserver/cors\n+:javadoc-base-url-webserver: {javadoc-base-url}io.helidon.webserver/io/helidon/webserver\n+:helidon-variant: SE\n+:common-page-prefix-inc: ../../shared/cors/common_shared.adoc\n+:mp-microprofile: https://download.eclipse.org/microprofile/microprofile-fault-tolerance-2.1.1/microprofile-fault-tolerance-spec.html\n+\n+\n+== Introduction\n+\n+Helidon SE Fault Tolerance support is inspired by link:{mp-microprofile}[MicroProfile Fault Tolerance].\n+The API defines the notion of a _fault handler_ that can be combined with other handlers to\n+improve application robustness. Handlers are created to manage error conditions (faults)\n+that may occur in real-world application environments. Examples include service restarts,\n+network delays, temporal infrastructure instabilities, etc.\n+\n+The interaction of multiple microservices bring some new challenges from distributed systems\n+that require careful planning. Faults in distributed systems should be compartmentalized\n+to avoid unnecessary service interruptions. For example, if comparable information can\n+be obtained from multiples sources, a user request _should not_ be denied when a subset\n+of these sources is unreachable or offline. Similarly, if a non-essential source has been\n+flagged as unreachable, an application should avoid continuous access to that source\n+as that would result in much higher response times.\n+\n+In order to combat the most common types of application faults, the Helidon SE Fault Tolerance API\n+provides support for circuit breakers, retries, timeouts, bulkheads and fallbacks.\n+In addition, the API makes it very easy to create and monitor asynchronous tasks that\n+do not require explicit creation and management of threads/executors.\n+\n+=== Updating your POM\n+\n+The following POM dependency is necessary to use the Fault Tolerance SE API in a\n+Helidon application.\n+\n+[source,xml]\n+.Fault Tolerance SE Dependency in `pom.xml`\n+----\n+<dependency>\n+    <groupId>io.helidon.fault-tolerance</groupId>\n+    <artifactId>helidon-fault-tolerance</artifactId>\n+    <version>{helidon-version}</version>\n+</dependency>\n+----\n+\n+=== Single<T> and Multi<T>\n+\n+In what follows we shall assume the reader is familiar with the two core Helidon types\n+`Single<T>` and `Multi<T>` from the `io.helidon.common.reactive` package. Most simply,\n+a `Single<T>` is a promise to produce zero or one value of type `T` or signal an error;\n+while a `Multi<T>` is a promise to produce zero or more values of type `T` or signal an error.\n+More generally, these two types can be regarded as _producers_ of zero or more values of type\n+`T`.\n+\n+NOTE: Note also that `Single<T>`, like `CompletableFuture<T>`, extends `CompletionStage<T>`\n+ so conversion among these types is straightforward.\n+\n+We shall use all these types in connection with Fault Tolerance handlers in the next few\n+sections.\n+\n+=== Asynchronous\n+\n+Asynchronous tasks can be created or forked by using an `Async` instance. A supplier of type\n+`T` is provided as the argument when invoking this handler. For example:\n+\n+[source,java]\n+----\n+Single<Thread> s = Async.create().invoke(() -> Thread.currentThread()));\n+s.thenAccept(t -> System.out.println(\"Async task executed in thread \" + t));\n+----\n+\n+The supplier `() -> Thread.currentThread()` is executed in a new thread and\n+the value it produces printed by the consumer passed to `thenAccept`.\n+\n+NOTE: The method reference `Thread::currentThread` is a simplified way of\n+providing a supplier in the example above.\n+\n+Asynchronous tasks are executed in a thread pool managed by the Helidon SE\n+Fault Tolerance module. Thread pools are created during the initialization\n+phase of class `io.helidon.faulttolerance.FaultTolerance` and can be\n+configured for your application.\n+\n+=== Retries\n+\n+Temporal networking problems can sometimes be mitigated by simply retrying\n+a certain task. A `Retry` handler is created using a `RetryPolicy` that\n+indicates the number of retries, delay between retries, etc.\n+\n+[source,java]\n+----\n+Retry retry = Retry.builder()\n+                   .retryPolicy(Retry.JitterRetryPolicy.builder()\n+                                     .calls(3)\n+                                     .delay(Duration.ofMillis(100))\n+                                     .build())\n+                   .build();\n+retry.invoke(this::retryOnFailure);\n+----\n+\n+The sample code above will retry calls to the supplier `this::retryOnFailure`\n+for up to 3 times with a 100 millisecond delay between them.\n+\n+NOTE: The return type of method `retryOnFailure` in the example above must\n+be `CompletionStage<T>` and the parameter to the retry handler's `invoke`\n+method `Supplier<? extends CompletionStage<T>>`.\n+\n+If the `CompletionStage<T>` returned by the method completes exceptionally,\n+the call will be treated as a failure and retried until the maximum number\n+of attempts is reached; finer control is\n+possible by creating a retry policy and using methods such as\n+`applyOn(Class<? extends Throwable>... classes)` and\n+`skipOn(Class<? extends Throwable>... classes)` to control those exceptions\n+on which to act and those that can be ignored.\n+\n+=== Timeouts\n+\n+A request to a service that is inaccessible or simply unavailable should be bounded\n+to ensure a certain quality of service and response time. Timeouts can be configured\n+to avoid excessive waiting times. In addition, a fallback action can be defined\n+if a timeout expires as we shall cover in the next section.\n+\n+The following is an example of using `Timeout`:\n+[source,java]\n+----\n+Single<T> s = Timeout.create(Duration.ofMillis(10)).invoke(this::mayTakeVeryLong);\n+s.handle((t, e) -> {\n+    if (e instanceof TimeoutException) {\n+        // Invocation has timed out!\n+    }\n+    ...\n+});\n+----\n+\n+The example above monitors the call to method `mayTakeVeryLong` and reports a\n+`TimeoutException` if the execution takes more than 10 milliseconds to complete.\n+\n+=== Fallbacks\n+\n+A fall back to a _known_ result can sometimes be an alternative to\n+reporting an error. For example, if we are unable to access a service\n+we may fall back to the last result obtained from that service.\n+\n+A `Fallback` instance is created by providing a function that takes a `Throwable`\n+and produces a `CompletionStage<T>` as shown next:\n+\n+[source,java]\n+----\n+Single<T> single = Fallback.create(\n+    throwable -> Single.just(lastKnownValue).invoke(this::mayFail);\n+single.thenAccept(t -> ...);\n+----\n+\n+In this example, we register a function that can produce a `Single<T>` (which implements\n+`CompletionStage<T>`) if the call to `this::mayFail` completes exceptionally.\n+\n+=== Circuit Breakers\n+\n+Failing to execute a certain task or call another service repeatedly can have a direct\n+impact on application performance. It is often preferred to avoid calls to non-essential\n+services by simply preventing that logic to execute altogether. A circuit breaker can be\n+configured to monitor such calls and block attempts that are likely to fail, thus improving\n+overall performance.\n+\n+Circuit breakers start in a _closed_ state, letting calls to proceed normally; after\n+detecting a certain number of errors during a pre-defined processing window, they can _open_ to\n+prevent additional failures. After a circuit has been opened, it can transition\n+first to a _half-open_ state before finally transitioning back to a closed state.\n+The use of an intermediate state (half-open)\n+makes transitions from open to close more progressive, and prevents a circuit breaker\n+from eagerly transition states without considering \"sufficient\" observations.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6081d533be384a75bfac9d3f78f2af0aece784f"}, "originalPosition": 194}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwOTk3MTQ1OnYy", "diffSide": "RIGHT", "path": "docs/se/faulttolerance/01_faulttolerance.adoc", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNDo1MTo1OFrOHZxQVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxNzoyNToyOFrOHZ5KGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc4MzQ0Nw==", "bodyText": "does the em dash render correctly?", "url": "https://github.com/oracle/helidon/pull/2399#discussion_r496783447", "createdAt": "2020-09-29T14:51:58Z", "author": {"login": "ljamen"}, "path": "docs/se/faulttolerance/01_faulttolerance.adoc", "diffHunk": "@@ -0,0 +1,338 @@\n+///////////////////////////////////////////////////////////////////////////////\n+\n+    Copyright (c) 2020 Oracle and/or its affiliates.\n+\n+    Licensed under the Apache License, Version 2.0 (the \"License\");\n+    you may not use this file except in compliance with the License.\n+    You may obtain a copy of the License at\n+\n+        http://www.apache.org/licenses/LICENSE-2.0\n+\n+    Unless required by applicable law or agreed to in writing, software\n+    distributed under the License is distributed on an \"AS IS\" BASIS,\n+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+    See the License for the specific language governing permissions and\n+    limitations under the License.\n+\n+///////////////////////////////////////////////////////////////////////////////\n+\n+= Fault Tolerance in Helidon SE\n+:toc:\n+:toc-placement: preamble\n+:h1Prefix: SE\n+:pagename: fault-tolerance\n+:description: Fault Tolerance in Helidon SE\n+:keywords: helidon, java, fault, tolerance, fault tolerance, se\n+:helidon-tag: https://github.com/oracle/helidon/tree/{helidon-version}\n+:quickstart-example: {helidon-tag}/examples/quickstarts/helidon-quickshelidon/webserver/cors\n+:javadoc-base-url-webserver: {javadoc-base-url}io.helidon.webserver/io/helidon/webserver\n+:helidon-variant: SE\n+:common-page-prefix-inc: ../../shared/cors/common_shared.adoc\n+:mp-microprofile: https://download.eclipse.org/microprofile/microprofile-fault-tolerance-2.1.1/microprofile-fault-tolerance-spec.html\n+\n+\n+== Introduction\n+\n+Helidon SE Fault Tolerance support is inspired by link:{mp-microprofile}[MicroProfile Fault Tolerance].\n+The API defines the notion of a _fault handler_ that can be combined with other handlers to\n+improve application robustness. Handlers are created to manage error conditions (faults)\n+that may occur in real-world application environments. Examples include service restarts,\n+network delays, temporal infrastructure instabilities, etc.\n+\n+The interaction of multiple microservices bring some new challenges from distributed systems\n+that require careful planning. Faults in distributed systems should be compartmentalized\n+to avoid unnecessary service interruptions. For example, if comparable information can\n+be obtained from multiples sources, a user request _should not_ be denied when a subset\n+of these sources is unreachable or offline. Similarly, if a non-essential source has been\n+flagged as unreachable, an application should avoid continuous access to that source\n+as that would result in much higher response times.\n+\n+In order to combat the most common types of application faults, the Helidon SE Fault Tolerance API\n+provides support for circuit breakers, retries, timeouts, bulkheads and fallbacks.\n+In addition, the API makes it very easy to create and monitor asynchronous tasks that\n+do not require explicit creation and management of threads/executors.\n+\n+=== Updating your POM\n+\n+The following POM dependency is necessary to use the Fault Tolerance SE API in a\n+Helidon application.\n+\n+[source,xml]\n+.Fault Tolerance SE Dependency in `pom.xml`\n+----\n+<dependency>\n+    <groupId>io.helidon.fault-tolerance</groupId>\n+    <artifactId>helidon-fault-tolerance</artifactId>\n+    <version>{helidon-version}</version>\n+</dependency>\n+----\n+\n+=== Single<T> and Multi<T>\n+\n+In what follows we shall assume the reader is familiar with the two core Helidon types\n+`Single<T>` and `Multi<T>` from the `io.helidon.common.reactive` package. Most simply,\n+a `Single<T>` is a promise to produce zero or one value of type `T` or signal an error;\n+while a `Multi<T>` is a promise to produce zero or more values of type `T` or signal an error.\n+More generally, these two types can be regarded as _producers_ of zero or more values of type\n+`T`.\n+\n+NOTE: Note also that `Single<T>`, like `CompletableFuture<T>`, extends `CompletionStage<T>`\n+ so conversion among these types is straightforward.\n+\n+We shall use all these types in connection with Fault Tolerance handlers in the next few\n+sections.\n+\n+=== Asynchronous\n+\n+Asynchronous tasks can be created or forked by using an `Async` instance. A supplier of type\n+`T` is provided as the argument when invoking this handler. For example:\n+\n+[source,java]\n+----\n+Single<Thread> s = Async.create().invoke(() -> Thread.currentThread()));\n+s.thenAccept(t -> System.out.println(\"Async task executed in thread \" + t));\n+----\n+\n+The supplier `() -> Thread.currentThread()` is executed in a new thread and\n+the value it produces printed by the consumer passed to `thenAccept`.\n+\n+NOTE: The method reference `Thread::currentThread` is a simplified way of\n+providing a supplier in the example above.\n+\n+Asynchronous tasks are executed in a thread pool managed by the Helidon SE\n+Fault Tolerance module. Thread pools are created during the initialization\n+phase of class `io.helidon.faulttolerance.FaultTolerance` and can be\n+configured for your application.\n+\n+=== Retries\n+\n+Temporal networking problems can sometimes be mitigated by simply retrying\n+a certain task. A `Retry` handler is created using a `RetryPolicy` that\n+indicates the number of retries, delay between retries, etc.\n+\n+[source,java]\n+----\n+Retry retry = Retry.builder()\n+                   .retryPolicy(Retry.JitterRetryPolicy.builder()\n+                                     .calls(3)\n+                                     .delay(Duration.ofMillis(100))\n+                                     .build())\n+                   .build();\n+retry.invoke(this::retryOnFailure);\n+----\n+\n+The sample code above will retry calls to the supplier `this::retryOnFailure`\n+for up to 3 times with a 100 millisecond delay between them.\n+\n+NOTE: The return type of method `retryOnFailure` in the example above must\n+be `CompletionStage<T>` and the parameter to the retry handler's `invoke`\n+method `Supplier<? extends CompletionStage<T>>`.\n+\n+If the `CompletionStage<T>` returned by the method completes exceptionally,\n+the call will be treated as a failure and retried until the maximum number\n+of attempts is reached; finer control is\n+possible by creating a retry policy and using methods such as\n+`applyOn(Class<? extends Throwable>... classes)` and\n+`skipOn(Class<? extends Throwable>... classes)` to control those exceptions\n+on which to act and those that can be ignored.\n+\n+=== Timeouts\n+\n+A request to a service that is inaccessible or simply unavailable should be bounded\n+to ensure a certain quality of service and response time. Timeouts can be configured\n+to avoid excessive waiting times. In addition, a fallback action can be defined\n+if a timeout expires as we shall cover in the next section.\n+\n+The following is an example of using `Timeout`:\n+[source,java]\n+----\n+Single<T> s = Timeout.create(Duration.ofMillis(10)).invoke(this::mayTakeVeryLong);\n+s.handle((t, e) -> {\n+    if (e instanceof TimeoutException) {\n+        // Invocation has timed out!\n+    }\n+    ...\n+});\n+----\n+\n+The example above monitors the call to method `mayTakeVeryLong` and reports a\n+`TimeoutException` if the execution takes more than 10 milliseconds to complete.\n+\n+=== Fallbacks\n+\n+A fall back to a _known_ result can sometimes be an alternative to\n+reporting an error. For example, if we are unable to access a service\n+we may fall back to the last result obtained from that service.\n+\n+A `Fallback` instance is created by providing a function that takes a `Throwable`\n+and produces a `CompletionStage<T>` as shown next:\n+\n+[source,java]\n+----\n+Single<T> single = Fallback.create(\n+    throwable -> Single.just(lastKnownValue).invoke(this::mayFail);\n+single.thenAccept(t -> ...);\n+----\n+\n+In this example, we register a function that can produce a `Single<T>` (which implements\n+`CompletionStage<T>`) if the call to `this::mayFail` completes exceptionally.\n+\n+=== Circuit Breakers\n+\n+Failing to execute a certain task or call another service repeatedly can have a direct\n+impact on application performance. It is often preferred to avoid calls to non-essential\n+services by simply preventing that logic to execute altogether. A circuit breaker can be\n+configured to monitor such calls and block attempts that are likely to fail, thus improving\n+overall performance.\n+\n+Circuit breakers start in a _closed_ state, letting calls to proceed normally; after\n+detecting a certain number of errors during a pre-defined processing window, they can _open_ to\n+prevent additional failures. After a circuit has been opened, it can transition\n+first to a _half-open_ state before finally transitioning back to a closed state.\n+The use of an intermediate state (half-open)\n+makes transitions from open to close more progressive, and prevents a circuit breaker\n+from eagerly transition states without considering \"sufficient\" observations.\n+\n+NOTE: Any failure while a circuit breaker is in half-open state will immediately\n+cause it to transition back to an open state.\n+\n+Consider the following example in which `this::mayFail` is monitored by a\n+circuit breaker:\n+[source,java]\n+----\n+CircuitBreaker breaker = CircuitBreaker.builder()\n+                                       .volume(10)\n+                                       .errorRatio(30)\n+                                       .delay(Duration.ofMillis(200))\n+                                       .successThreshold(2)\n+                                       .build();\n+Single<T> result = breaker.invoke(this::mayFail);\n+----\n+\n+The circuit breaker in this example defines a processing window of size 10, an error\n+ratio of 30%, a duration to transition to half-open state of 200 milliseconds, and\n+a success threshold to transition from half-open to closed state of 2 observations.\n+It follows that,\n+\n+* After completing the processing window, if at least 3 errors were detected, the\n+circuit breaker will transition to the open state, thus blocking the execution\n+of any subsequent calls.\n+\n+* After 200 millis, the circuit breaker will transition back to half-open and\n+enable calls to proceed again.\n+\n+* If the next two calls after transitioning to half-open are successful, the\n+circuit breaker will transition to closed state; otherwise, it will\n+transition back to open state, waiting for another 200 milliseconds\n+before attempting to transition to half-open again.\n+\n+A circuit breaker will throw a\n+`io.helidon.faulttolerance.CircuitBreakerOpenException`\n+if an attempt to make an invocation takes place while it is in open state.\n+\n+=== Bulkheads\n+\n+Concurrent access to certain components may need to be limited to avoid\n+excessive use of resources. For example, if an invocation that opens\n+a network connection is allowed to execute concurrently without\n+any restriction, and if the service on the other end is slow responding,\n+it is possible for the rate at which network connections are opened\n+to exceed the maximum number of connections allowed. Faults of this\n+type can be prevented by guarding these invocations using a bulkhead.\n+\n+NOTE: The origin of the name _bulkhead_ comes from the partitions that\n+comprise a ship's hull. If some partition is somehow compromised\n+(e.g., filled with water) it can be isolated in a manner not to\n+affect the rest of the hull.\n+\n+A waiting queue can be associated with a bulkhead to handle tasks\n+that are submitted when the bulkhead is already full capacity.\n+\n+[source,java]\n+----\n+Bulkhead bulkhead = Bulkhead.builder()\n+                            .limit(3)\n+                            .queueLength(5)\n+                            .build();\n+Single<T> single = bulkhead.invoke(this::usesResources);\n+----\n+\n+This example creates a bulkhead that limits concurrent execution\n+to `this:usesResources` to at most 3, and with a queue of size 5. The\n+bulkhead will report a `io.helidon.faulttolerance.BulkheadException` if unable to invoke\n+the call: either due to the limit being reached or, if defined,\n+when the queue is already at maximum capacity.\n+\n+=== Handler Composition\n+\n+Method invocations can be guarded by a combination of the handlers\n+presented above. For example, an invocation that\n+times out can be retried a few times before resorting to a fallback &mdash;assuming\n+it never succeeds. Here is how this example would be written using the\n+Fault Tolerance API:\n+\n+[source,java]\n+----\n+// Create supplier for timeout\n+Supplier<? extends CompletionStage<T>> supplierTimeout =\n+    () -> Timeout.create(Duration.ofMillis(10)).invoke(this::mayTakeVeryLong);\n+\n+// Create supplier for retry using timeout's\n+Retry retry = Retry.builder()\n+                   .retryPolicy(Retry.JitterRetryPolicy.builder()\n+                                     .calls(3)\n+                                     .delay(Duration.ofMillis(100))\n+                                     .build())\n+                   .build();\n+Supplier<? extends CompletionStage<T>> supplierRetry = () -> retry.invoke(supplierTimeout);\n+\n+// Finally invoke this::mayTakeVeryLong wrapping supplier for retry using fallback\n+Single<T> single = Fallback.create(\n+    throwable -> Single.just(lastKnownValue)).invoke(supplierRetry);\n+----\n+\n+The exact manner in which handlers are combined depends on the use case,\n+but generally the order starting from innermost to outermost should be: bulkhead,\n+timeout, circuit breaker, retry and fallback. That is, bulkhead is the first\n+handler executed and fallback the last one.\n+\n+NOTE: This is the ordering used by the MicroProfile Fault Tolerance implementation\n+in Helidon when a method is decorated with multiple annotations.\n+\n+=== Revisiting Multi's\n+\n+All the examples presented so far have focused on invocations returning\n+a single value of type `Single<T>`. If the invocation in question can return\n+more than one value (i.e., a `Multi<T>`) then all that is needed is to use\n+the method `invokeMulti` instead of `invoke`. The supplier passed to this\n+method must return a `Flow.Publisher<T>` instead of a `CompletionStage<T>`.\n+\n+A `Flow.Publisher<T>` is a generalization of a `Single<T>` that can\n+produce zero or more values. Note that a `Flow.Publisher<T>`, unlike a\n+`Single<T>`, can report an error after\n+producing one or more values, introducing additional challenges if all\n+values must be processed transactionally, that is, in an all or nothing\n+manner.\n+\n+The following example creates an instance of `Retry` and invokes\n+the `invokeMulti` method, it then registers a subscriber to process\n+the results:\n+\n+[source,java]\n+----\n+Retry retry = Retry.builder()\n+                   .retryPolicy(Retry.JitterRetryPolicy.builder()\n+                                     .calls(2)\n+                                     .build())\n+                   .build();\n+Multi<Integer> multi = retry.invokeMulti(() -> Multi.just(0, 1, 2));\n+\n+IntSubscriber ts = new IntSubscriber();\n+multi.subscribe(ts);\n+ts.request(Integer.MAX_VALUE);\n+----\n+\n+The call to `Multi.just(0, 1, 2)` simply returns a multi that produces\n+the integers 0, 1 and 2. If an error was generated during this process,\n+the policy will retry the call one more time &mdash;for a total of 2", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6081d533be384a75bfac9d3f78f2af0aece784f"}, "originalPosition": 337}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc5MDgwNQ==", "bodyText": "It does in my viewer, I think it should. Do you have a way to test it?", "url": "https://github.com/oracle/helidon/pull/2399#discussion_r496790805", "createdAt": "2020-09-29T15:00:49Z", "author": {"login": "spericas"}, "path": "docs/se/faulttolerance/01_faulttolerance.adoc", "diffHunk": "@@ -0,0 +1,338 @@\n+///////////////////////////////////////////////////////////////////////////////\n+\n+    Copyright (c) 2020 Oracle and/or its affiliates.\n+\n+    Licensed under the Apache License, Version 2.0 (the \"License\");\n+    you may not use this file except in compliance with the License.\n+    You may obtain a copy of the License at\n+\n+        http://www.apache.org/licenses/LICENSE-2.0\n+\n+    Unless required by applicable law or agreed to in writing, software\n+    distributed under the License is distributed on an \"AS IS\" BASIS,\n+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+    See the License for the specific language governing permissions and\n+    limitations under the License.\n+\n+///////////////////////////////////////////////////////////////////////////////\n+\n+= Fault Tolerance in Helidon SE\n+:toc:\n+:toc-placement: preamble\n+:h1Prefix: SE\n+:pagename: fault-tolerance\n+:description: Fault Tolerance in Helidon SE\n+:keywords: helidon, java, fault, tolerance, fault tolerance, se\n+:helidon-tag: https://github.com/oracle/helidon/tree/{helidon-version}\n+:quickstart-example: {helidon-tag}/examples/quickstarts/helidon-quickshelidon/webserver/cors\n+:javadoc-base-url-webserver: {javadoc-base-url}io.helidon.webserver/io/helidon/webserver\n+:helidon-variant: SE\n+:common-page-prefix-inc: ../../shared/cors/common_shared.adoc\n+:mp-microprofile: https://download.eclipse.org/microprofile/microprofile-fault-tolerance-2.1.1/microprofile-fault-tolerance-spec.html\n+\n+\n+== Introduction\n+\n+Helidon SE Fault Tolerance support is inspired by link:{mp-microprofile}[MicroProfile Fault Tolerance].\n+The API defines the notion of a _fault handler_ that can be combined with other handlers to\n+improve application robustness. Handlers are created to manage error conditions (faults)\n+that may occur in real-world application environments. Examples include service restarts,\n+network delays, temporal infrastructure instabilities, etc.\n+\n+The interaction of multiple microservices bring some new challenges from distributed systems\n+that require careful planning. Faults in distributed systems should be compartmentalized\n+to avoid unnecessary service interruptions. For example, if comparable information can\n+be obtained from multiples sources, a user request _should not_ be denied when a subset\n+of these sources is unreachable or offline. Similarly, if a non-essential source has been\n+flagged as unreachable, an application should avoid continuous access to that source\n+as that would result in much higher response times.\n+\n+In order to combat the most common types of application faults, the Helidon SE Fault Tolerance API\n+provides support for circuit breakers, retries, timeouts, bulkheads and fallbacks.\n+In addition, the API makes it very easy to create and monitor asynchronous tasks that\n+do not require explicit creation and management of threads/executors.\n+\n+=== Updating your POM\n+\n+The following POM dependency is necessary to use the Fault Tolerance SE API in a\n+Helidon application.\n+\n+[source,xml]\n+.Fault Tolerance SE Dependency in `pom.xml`\n+----\n+<dependency>\n+    <groupId>io.helidon.fault-tolerance</groupId>\n+    <artifactId>helidon-fault-tolerance</artifactId>\n+    <version>{helidon-version}</version>\n+</dependency>\n+----\n+\n+=== Single<T> and Multi<T>\n+\n+In what follows we shall assume the reader is familiar with the two core Helidon types\n+`Single<T>` and `Multi<T>` from the `io.helidon.common.reactive` package. Most simply,\n+a `Single<T>` is a promise to produce zero or one value of type `T` or signal an error;\n+while a `Multi<T>` is a promise to produce zero or more values of type `T` or signal an error.\n+More generally, these two types can be regarded as _producers_ of zero or more values of type\n+`T`.\n+\n+NOTE: Note also that `Single<T>`, like `CompletableFuture<T>`, extends `CompletionStage<T>`\n+ so conversion among these types is straightforward.\n+\n+We shall use all these types in connection with Fault Tolerance handlers in the next few\n+sections.\n+\n+=== Asynchronous\n+\n+Asynchronous tasks can be created or forked by using an `Async` instance. A supplier of type\n+`T` is provided as the argument when invoking this handler. For example:\n+\n+[source,java]\n+----\n+Single<Thread> s = Async.create().invoke(() -> Thread.currentThread()));\n+s.thenAccept(t -> System.out.println(\"Async task executed in thread \" + t));\n+----\n+\n+The supplier `() -> Thread.currentThread()` is executed in a new thread and\n+the value it produces printed by the consumer passed to `thenAccept`.\n+\n+NOTE: The method reference `Thread::currentThread` is a simplified way of\n+providing a supplier in the example above.\n+\n+Asynchronous tasks are executed in a thread pool managed by the Helidon SE\n+Fault Tolerance module. Thread pools are created during the initialization\n+phase of class `io.helidon.faulttolerance.FaultTolerance` and can be\n+configured for your application.\n+\n+=== Retries\n+\n+Temporal networking problems can sometimes be mitigated by simply retrying\n+a certain task. A `Retry` handler is created using a `RetryPolicy` that\n+indicates the number of retries, delay between retries, etc.\n+\n+[source,java]\n+----\n+Retry retry = Retry.builder()\n+                   .retryPolicy(Retry.JitterRetryPolicy.builder()\n+                                     .calls(3)\n+                                     .delay(Duration.ofMillis(100))\n+                                     .build())\n+                   .build();\n+retry.invoke(this::retryOnFailure);\n+----\n+\n+The sample code above will retry calls to the supplier `this::retryOnFailure`\n+for up to 3 times with a 100 millisecond delay between them.\n+\n+NOTE: The return type of method `retryOnFailure` in the example above must\n+be `CompletionStage<T>` and the parameter to the retry handler's `invoke`\n+method `Supplier<? extends CompletionStage<T>>`.\n+\n+If the `CompletionStage<T>` returned by the method completes exceptionally,\n+the call will be treated as a failure and retried until the maximum number\n+of attempts is reached; finer control is\n+possible by creating a retry policy and using methods such as\n+`applyOn(Class<? extends Throwable>... classes)` and\n+`skipOn(Class<? extends Throwable>... classes)` to control those exceptions\n+on which to act and those that can be ignored.\n+\n+=== Timeouts\n+\n+A request to a service that is inaccessible or simply unavailable should be bounded\n+to ensure a certain quality of service and response time. Timeouts can be configured\n+to avoid excessive waiting times. In addition, a fallback action can be defined\n+if a timeout expires as we shall cover in the next section.\n+\n+The following is an example of using `Timeout`:\n+[source,java]\n+----\n+Single<T> s = Timeout.create(Duration.ofMillis(10)).invoke(this::mayTakeVeryLong);\n+s.handle((t, e) -> {\n+    if (e instanceof TimeoutException) {\n+        // Invocation has timed out!\n+    }\n+    ...\n+});\n+----\n+\n+The example above monitors the call to method `mayTakeVeryLong` and reports a\n+`TimeoutException` if the execution takes more than 10 milliseconds to complete.\n+\n+=== Fallbacks\n+\n+A fall back to a _known_ result can sometimes be an alternative to\n+reporting an error. For example, if we are unable to access a service\n+we may fall back to the last result obtained from that service.\n+\n+A `Fallback` instance is created by providing a function that takes a `Throwable`\n+and produces a `CompletionStage<T>` as shown next:\n+\n+[source,java]\n+----\n+Single<T> single = Fallback.create(\n+    throwable -> Single.just(lastKnownValue).invoke(this::mayFail);\n+single.thenAccept(t -> ...);\n+----\n+\n+In this example, we register a function that can produce a `Single<T>` (which implements\n+`CompletionStage<T>`) if the call to `this::mayFail` completes exceptionally.\n+\n+=== Circuit Breakers\n+\n+Failing to execute a certain task or call another service repeatedly can have a direct\n+impact on application performance. It is often preferred to avoid calls to non-essential\n+services by simply preventing that logic to execute altogether. A circuit breaker can be\n+configured to monitor such calls and block attempts that are likely to fail, thus improving\n+overall performance.\n+\n+Circuit breakers start in a _closed_ state, letting calls to proceed normally; after\n+detecting a certain number of errors during a pre-defined processing window, they can _open_ to\n+prevent additional failures. After a circuit has been opened, it can transition\n+first to a _half-open_ state before finally transitioning back to a closed state.\n+The use of an intermediate state (half-open)\n+makes transitions from open to close more progressive, and prevents a circuit breaker\n+from eagerly transition states without considering \"sufficient\" observations.\n+\n+NOTE: Any failure while a circuit breaker is in half-open state will immediately\n+cause it to transition back to an open state.\n+\n+Consider the following example in which `this::mayFail` is monitored by a\n+circuit breaker:\n+[source,java]\n+----\n+CircuitBreaker breaker = CircuitBreaker.builder()\n+                                       .volume(10)\n+                                       .errorRatio(30)\n+                                       .delay(Duration.ofMillis(200))\n+                                       .successThreshold(2)\n+                                       .build();\n+Single<T> result = breaker.invoke(this::mayFail);\n+----\n+\n+The circuit breaker in this example defines a processing window of size 10, an error\n+ratio of 30%, a duration to transition to half-open state of 200 milliseconds, and\n+a success threshold to transition from half-open to closed state of 2 observations.\n+It follows that,\n+\n+* After completing the processing window, if at least 3 errors were detected, the\n+circuit breaker will transition to the open state, thus blocking the execution\n+of any subsequent calls.\n+\n+* After 200 millis, the circuit breaker will transition back to half-open and\n+enable calls to proceed again.\n+\n+* If the next two calls after transitioning to half-open are successful, the\n+circuit breaker will transition to closed state; otherwise, it will\n+transition back to open state, waiting for another 200 milliseconds\n+before attempting to transition to half-open again.\n+\n+A circuit breaker will throw a\n+`io.helidon.faulttolerance.CircuitBreakerOpenException`\n+if an attempt to make an invocation takes place while it is in open state.\n+\n+=== Bulkheads\n+\n+Concurrent access to certain components may need to be limited to avoid\n+excessive use of resources. For example, if an invocation that opens\n+a network connection is allowed to execute concurrently without\n+any restriction, and if the service on the other end is slow responding,\n+it is possible for the rate at which network connections are opened\n+to exceed the maximum number of connections allowed. Faults of this\n+type can be prevented by guarding these invocations using a bulkhead.\n+\n+NOTE: The origin of the name _bulkhead_ comes from the partitions that\n+comprise a ship's hull. If some partition is somehow compromised\n+(e.g., filled with water) it can be isolated in a manner not to\n+affect the rest of the hull.\n+\n+A waiting queue can be associated with a bulkhead to handle tasks\n+that are submitted when the bulkhead is already full capacity.\n+\n+[source,java]\n+----\n+Bulkhead bulkhead = Bulkhead.builder()\n+                            .limit(3)\n+                            .queueLength(5)\n+                            .build();\n+Single<T> single = bulkhead.invoke(this::usesResources);\n+----\n+\n+This example creates a bulkhead that limits concurrent execution\n+to `this:usesResources` to at most 3, and with a queue of size 5. The\n+bulkhead will report a `io.helidon.faulttolerance.BulkheadException` if unable to invoke\n+the call: either due to the limit being reached or, if defined,\n+when the queue is already at maximum capacity.\n+\n+=== Handler Composition\n+\n+Method invocations can be guarded by a combination of the handlers\n+presented above. For example, an invocation that\n+times out can be retried a few times before resorting to a fallback &mdash;assuming\n+it never succeeds. Here is how this example would be written using the\n+Fault Tolerance API:\n+\n+[source,java]\n+----\n+// Create supplier for timeout\n+Supplier<? extends CompletionStage<T>> supplierTimeout =\n+    () -> Timeout.create(Duration.ofMillis(10)).invoke(this::mayTakeVeryLong);\n+\n+// Create supplier for retry using timeout's\n+Retry retry = Retry.builder()\n+                   .retryPolicy(Retry.JitterRetryPolicy.builder()\n+                                     .calls(3)\n+                                     .delay(Duration.ofMillis(100))\n+                                     .build())\n+                   .build();\n+Supplier<? extends CompletionStage<T>> supplierRetry = () -> retry.invoke(supplierTimeout);\n+\n+// Finally invoke this::mayTakeVeryLong wrapping supplier for retry using fallback\n+Single<T> single = Fallback.create(\n+    throwable -> Single.just(lastKnownValue)).invoke(supplierRetry);\n+----\n+\n+The exact manner in which handlers are combined depends on the use case,\n+but generally the order starting from innermost to outermost should be: bulkhead,\n+timeout, circuit breaker, retry and fallback. That is, bulkhead is the first\n+handler executed and fallback the last one.\n+\n+NOTE: This is the ordering used by the MicroProfile Fault Tolerance implementation\n+in Helidon when a method is decorated with multiple annotations.\n+\n+=== Revisiting Multi's\n+\n+All the examples presented so far have focused on invocations returning\n+a single value of type `Single<T>`. If the invocation in question can return\n+more than one value (i.e., a `Multi<T>`) then all that is needed is to use\n+the method `invokeMulti` instead of `invoke`. The supplier passed to this\n+method must return a `Flow.Publisher<T>` instead of a `CompletionStage<T>`.\n+\n+A `Flow.Publisher<T>` is a generalization of a `Single<T>` that can\n+produce zero or more values. Note that a `Flow.Publisher<T>`, unlike a\n+`Single<T>`, can report an error after\n+producing one or more values, introducing additional challenges if all\n+values must be processed transactionally, that is, in an all or nothing\n+manner.\n+\n+The following example creates an instance of `Retry` and invokes\n+the `invokeMulti` method, it then registers a subscriber to process\n+the results:\n+\n+[source,java]\n+----\n+Retry retry = Retry.builder()\n+                   .retryPolicy(Retry.JitterRetryPolicy.builder()\n+                                     .calls(2)\n+                                     .build())\n+                   .build();\n+Multi<Integer> multi = retry.invokeMulti(() -> Multi.just(0, 1, 2));\n+\n+IntSubscriber ts = new IntSubscriber();\n+multi.subscribe(ts);\n+ts.request(Integer.MAX_VALUE);\n+----\n+\n+The call to `Multi.just(0, 1, 2)` simply returns a multi that produces\n+the integers 0, 1 and 2. If an error was generated during this process,\n+the policy will retry the call one more time &mdash;for a total of 2", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc4MzQ0Nw=="}, "originalCommit": {"oid": "c6081d533be384a75bfac9d3f78f2af0aece784f"}, "originalPosition": 337}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkxMjkyMA==", "bodyText": "Actually, using the view option here on Github, it renders fine.", "url": "https://github.com/oracle/helidon/pull/2399#discussion_r496912920", "createdAt": "2020-09-29T17:25:28Z", "author": {"login": "spericas"}, "path": "docs/se/faulttolerance/01_faulttolerance.adoc", "diffHunk": "@@ -0,0 +1,338 @@\n+///////////////////////////////////////////////////////////////////////////////\n+\n+    Copyright (c) 2020 Oracle and/or its affiliates.\n+\n+    Licensed under the Apache License, Version 2.0 (the \"License\");\n+    you may not use this file except in compliance with the License.\n+    You may obtain a copy of the License at\n+\n+        http://www.apache.org/licenses/LICENSE-2.0\n+\n+    Unless required by applicable law or agreed to in writing, software\n+    distributed under the License is distributed on an \"AS IS\" BASIS,\n+    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+    See the License for the specific language governing permissions and\n+    limitations under the License.\n+\n+///////////////////////////////////////////////////////////////////////////////\n+\n+= Fault Tolerance in Helidon SE\n+:toc:\n+:toc-placement: preamble\n+:h1Prefix: SE\n+:pagename: fault-tolerance\n+:description: Fault Tolerance in Helidon SE\n+:keywords: helidon, java, fault, tolerance, fault tolerance, se\n+:helidon-tag: https://github.com/oracle/helidon/tree/{helidon-version}\n+:quickstart-example: {helidon-tag}/examples/quickstarts/helidon-quickshelidon/webserver/cors\n+:javadoc-base-url-webserver: {javadoc-base-url}io.helidon.webserver/io/helidon/webserver\n+:helidon-variant: SE\n+:common-page-prefix-inc: ../../shared/cors/common_shared.adoc\n+:mp-microprofile: https://download.eclipse.org/microprofile/microprofile-fault-tolerance-2.1.1/microprofile-fault-tolerance-spec.html\n+\n+\n+== Introduction\n+\n+Helidon SE Fault Tolerance support is inspired by link:{mp-microprofile}[MicroProfile Fault Tolerance].\n+The API defines the notion of a _fault handler_ that can be combined with other handlers to\n+improve application robustness. Handlers are created to manage error conditions (faults)\n+that may occur in real-world application environments. Examples include service restarts,\n+network delays, temporal infrastructure instabilities, etc.\n+\n+The interaction of multiple microservices bring some new challenges from distributed systems\n+that require careful planning. Faults in distributed systems should be compartmentalized\n+to avoid unnecessary service interruptions. For example, if comparable information can\n+be obtained from multiples sources, a user request _should not_ be denied when a subset\n+of these sources is unreachable or offline. Similarly, if a non-essential source has been\n+flagged as unreachable, an application should avoid continuous access to that source\n+as that would result in much higher response times.\n+\n+In order to combat the most common types of application faults, the Helidon SE Fault Tolerance API\n+provides support for circuit breakers, retries, timeouts, bulkheads and fallbacks.\n+In addition, the API makes it very easy to create and monitor asynchronous tasks that\n+do not require explicit creation and management of threads/executors.\n+\n+=== Updating your POM\n+\n+The following POM dependency is necessary to use the Fault Tolerance SE API in a\n+Helidon application.\n+\n+[source,xml]\n+.Fault Tolerance SE Dependency in `pom.xml`\n+----\n+<dependency>\n+    <groupId>io.helidon.fault-tolerance</groupId>\n+    <artifactId>helidon-fault-tolerance</artifactId>\n+    <version>{helidon-version}</version>\n+</dependency>\n+----\n+\n+=== Single<T> and Multi<T>\n+\n+In what follows we shall assume the reader is familiar with the two core Helidon types\n+`Single<T>` and `Multi<T>` from the `io.helidon.common.reactive` package. Most simply,\n+a `Single<T>` is a promise to produce zero or one value of type `T` or signal an error;\n+while a `Multi<T>` is a promise to produce zero or more values of type `T` or signal an error.\n+More generally, these two types can be regarded as _producers_ of zero or more values of type\n+`T`.\n+\n+NOTE: Note also that `Single<T>`, like `CompletableFuture<T>`, extends `CompletionStage<T>`\n+ so conversion among these types is straightforward.\n+\n+We shall use all these types in connection with Fault Tolerance handlers in the next few\n+sections.\n+\n+=== Asynchronous\n+\n+Asynchronous tasks can be created or forked by using an `Async` instance. A supplier of type\n+`T` is provided as the argument when invoking this handler. For example:\n+\n+[source,java]\n+----\n+Single<Thread> s = Async.create().invoke(() -> Thread.currentThread()));\n+s.thenAccept(t -> System.out.println(\"Async task executed in thread \" + t));\n+----\n+\n+The supplier `() -> Thread.currentThread()` is executed in a new thread and\n+the value it produces printed by the consumer passed to `thenAccept`.\n+\n+NOTE: The method reference `Thread::currentThread` is a simplified way of\n+providing a supplier in the example above.\n+\n+Asynchronous tasks are executed in a thread pool managed by the Helidon SE\n+Fault Tolerance module. Thread pools are created during the initialization\n+phase of class `io.helidon.faulttolerance.FaultTolerance` and can be\n+configured for your application.\n+\n+=== Retries\n+\n+Temporal networking problems can sometimes be mitigated by simply retrying\n+a certain task. A `Retry` handler is created using a `RetryPolicy` that\n+indicates the number of retries, delay between retries, etc.\n+\n+[source,java]\n+----\n+Retry retry = Retry.builder()\n+                   .retryPolicy(Retry.JitterRetryPolicy.builder()\n+                                     .calls(3)\n+                                     .delay(Duration.ofMillis(100))\n+                                     .build())\n+                   .build();\n+retry.invoke(this::retryOnFailure);\n+----\n+\n+The sample code above will retry calls to the supplier `this::retryOnFailure`\n+for up to 3 times with a 100 millisecond delay between them.\n+\n+NOTE: The return type of method `retryOnFailure` in the example above must\n+be `CompletionStage<T>` and the parameter to the retry handler's `invoke`\n+method `Supplier<? extends CompletionStage<T>>`.\n+\n+If the `CompletionStage<T>` returned by the method completes exceptionally,\n+the call will be treated as a failure and retried until the maximum number\n+of attempts is reached; finer control is\n+possible by creating a retry policy and using methods such as\n+`applyOn(Class<? extends Throwable>... classes)` and\n+`skipOn(Class<? extends Throwable>... classes)` to control those exceptions\n+on which to act and those that can be ignored.\n+\n+=== Timeouts\n+\n+A request to a service that is inaccessible or simply unavailable should be bounded\n+to ensure a certain quality of service and response time. Timeouts can be configured\n+to avoid excessive waiting times. In addition, a fallback action can be defined\n+if a timeout expires as we shall cover in the next section.\n+\n+The following is an example of using `Timeout`:\n+[source,java]\n+----\n+Single<T> s = Timeout.create(Duration.ofMillis(10)).invoke(this::mayTakeVeryLong);\n+s.handle((t, e) -> {\n+    if (e instanceof TimeoutException) {\n+        // Invocation has timed out!\n+    }\n+    ...\n+});\n+----\n+\n+The example above monitors the call to method `mayTakeVeryLong` and reports a\n+`TimeoutException` if the execution takes more than 10 milliseconds to complete.\n+\n+=== Fallbacks\n+\n+A fall back to a _known_ result can sometimes be an alternative to\n+reporting an error. For example, if we are unable to access a service\n+we may fall back to the last result obtained from that service.\n+\n+A `Fallback` instance is created by providing a function that takes a `Throwable`\n+and produces a `CompletionStage<T>` as shown next:\n+\n+[source,java]\n+----\n+Single<T> single = Fallback.create(\n+    throwable -> Single.just(lastKnownValue).invoke(this::mayFail);\n+single.thenAccept(t -> ...);\n+----\n+\n+In this example, we register a function that can produce a `Single<T>` (which implements\n+`CompletionStage<T>`) if the call to `this::mayFail` completes exceptionally.\n+\n+=== Circuit Breakers\n+\n+Failing to execute a certain task or call another service repeatedly can have a direct\n+impact on application performance. It is often preferred to avoid calls to non-essential\n+services by simply preventing that logic to execute altogether. A circuit breaker can be\n+configured to monitor such calls and block attempts that are likely to fail, thus improving\n+overall performance.\n+\n+Circuit breakers start in a _closed_ state, letting calls to proceed normally; after\n+detecting a certain number of errors during a pre-defined processing window, they can _open_ to\n+prevent additional failures. After a circuit has been opened, it can transition\n+first to a _half-open_ state before finally transitioning back to a closed state.\n+The use of an intermediate state (half-open)\n+makes transitions from open to close more progressive, and prevents a circuit breaker\n+from eagerly transition states without considering \"sufficient\" observations.\n+\n+NOTE: Any failure while a circuit breaker is in half-open state will immediately\n+cause it to transition back to an open state.\n+\n+Consider the following example in which `this::mayFail` is monitored by a\n+circuit breaker:\n+[source,java]\n+----\n+CircuitBreaker breaker = CircuitBreaker.builder()\n+                                       .volume(10)\n+                                       .errorRatio(30)\n+                                       .delay(Duration.ofMillis(200))\n+                                       .successThreshold(2)\n+                                       .build();\n+Single<T> result = breaker.invoke(this::mayFail);\n+----\n+\n+The circuit breaker in this example defines a processing window of size 10, an error\n+ratio of 30%, a duration to transition to half-open state of 200 milliseconds, and\n+a success threshold to transition from half-open to closed state of 2 observations.\n+It follows that,\n+\n+* After completing the processing window, if at least 3 errors were detected, the\n+circuit breaker will transition to the open state, thus blocking the execution\n+of any subsequent calls.\n+\n+* After 200 millis, the circuit breaker will transition back to half-open and\n+enable calls to proceed again.\n+\n+* If the next two calls after transitioning to half-open are successful, the\n+circuit breaker will transition to closed state; otherwise, it will\n+transition back to open state, waiting for another 200 milliseconds\n+before attempting to transition to half-open again.\n+\n+A circuit breaker will throw a\n+`io.helidon.faulttolerance.CircuitBreakerOpenException`\n+if an attempt to make an invocation takes place while it is in open state.\n+\n+=== Bulkheads\n+\n+Concurrent access to certain components may need to be limited to avoid\n+excessive use of resources. For example, if an invocation that opens\n+a network connection is allowed to execute concurrently without\n+any restriction, and if the service on the other end is slow responding,\n+it is possible for the rate at which network connections are opened\n+to exceed the maximum number of connections allowed. Faults of this\n+type can be prevented by guarding these invocations using a bulkhead.\n+\n+NOTE: The origin of the name _bulkhead_ comes from the partitions that\n+comprise a ship's hull. If some partition is somehow compromised\n+(e.g., filled with water) it can be isolated in a manner not to\n+affect the rest of the hull.\n+\n+A waiting queue can be associated with a bulkhead to handle tasks\n+that are submitted when the bulkhead is already full capacity.\n+\n+[source,java]\n+----\n+Bulkhead bulkhead = Bulkhead.builder()\n+                            .limit(3)\n+                            .queueLength(5)\n+                            .build();\n+Single<T> single = bulkhead.invoke(this::usesResources);\n+----\n+\n+This example creates a bulkhead that limits concurrent execution\n+to `this:usesResources` to at most 3, and with a queue of size 5. The\n+bulkhead will report a `io.helidon.faulttolerance.BulkheadException` if unable to invoke\n+the call: either due to the limit being reached or, if defined,\n+when the queue is already at maximum capacity.\n+\n+=== Handler Composition\n+\n+Method invocations can be guarded by a combination of the handlers\n+presented above. For example, an invocation that\n+times out can be retried a few times before resorting to a fallback &mdash;assuming\n+it never succeeds. Here is how this example would be written using the\n+Fault Tolerance API:\n+\n+[source,java]\n+----\n+// Create supplier for timeout\n+Supplier<? extends CompletionStage<T>> supplierTimeout =\n+    () -> Timeout.create(Duration.ofMillis(10)).invoke(this::mayTakeVeryLong);\n+\n+// Create supplier for retry using timeout's\n+Retry retry = Retry.builder()\n+                   .retryPolicy(Retry.JitterRetryPolicy.builder()\n+                                     .calls(3)\n+                                     .delay(Duration.ofMillis(100))\n+                                     .build())\n+                   .build();\n+Supplier<? extends CompletionStage<T>> supplierRetry = () -> retry.invoke(supplierTimeout);\n+\n+// Finally invoke this::mayTakeVeryLong wrapping supplier for retry using fallback\n+Single<T> single = Fallback.create(\n+    throwable -> Single.just(lastKnownValue)).invoke(supplierRetry);\n+----\n+\n+The exact manner in which handlers are combined depends on the use case,\n+but generally the order starting from innermost to outermost should be: bulkhead,\n+timeout, circuit breaker, retry and fallback. That is, bulkhead is the first\n+handler executed and fallback the last one.\n+\n+NOTE: This is the ordering used by the MicroProfile Fault Tolerance implementation\n+in Helidon when a method is decorated with multiple annotations.\n+\n+=== Revisiting Multi's\n+\n+All the examples presented so far have focused on invocations returning\n+a single value of type `Single<T>`. If the invocation in question can return\n+more than one value (i.e., a `Multi<T>`) then all that is needed is to use\n+the method `invokeMulti` instead of `invoke`. The supplier passed to this\n+method must return a `Flow.Publisher<T>` instead of a `CompletionStage<T>`.\n+\n+A `Flow.Publisher<T>` is a generalization of a `Single<T>` that can\n+produce zero or more values. Note that a `Flow.Publisher<T>`, unlike a\n+`Single<T>`, can report an error after\n+producing one or more values, introducing additional challenges if all\n+values must be processed transactionally, that is, in an all or nothing\n+manner.\n+\n+The following example creates an instance of `Retry` and invokes\n+the `invokeMulti` method, it then registers a subscriber to process\n+the results:\n+\n+[source,java]\n+----\n+Retry retry = Retry.builder()\n+                   .retryPolicy(Retry.JitterRetryPolicy.builder()\n+                                     .calls(2)\n+                                     .build())\n+                   .build();\n+Multi<Integer> multi = retry.invokeMulti(() -> Multi.just(0, 1, 2));\n+\n+IntSubscriber ts = new IntSubscriber();\n+multi.subscribe(ts);\n+ts.request(Integer.MAX_VALUE);\n+----\n+\n+The call to `Multi.just(0, 1, 2)` simply returns a multi that produces\n+the integers 0, 1 and 2. If an error was generated during this process,\n+the policy will retry the call one more time &mdash;for a total of 2", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc4MzQ0Nw=="}, "originalCommit": {"oid": "c6081d533be384a75bfac9d3f78f2af0aece784f"}, "originalPosition": 337}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExMDk5MzIwOnYy", "diffSide": "RIGHT", "path": "docs/sitegen.yaml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxODoxNzozMVrOHZ7FYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOVQxODo1ODoxNFrOHZ8gGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk0NDQ4Mw==", "bodyText": "Is this meant to be MP here?", "url": "https://github.com/oracle/helidon/pull/2399#discussion_r496944483", "createdAt": "2020-09-29T18:17:31Z", "author": {"login": "ljamen"}, "path": "docs/sitegen.yaml", "diffHunk": "@@ -208,6 +208,14 @@ backend:\n               items:\n                 - includes:\n                     - \"se/aot/*.adoc\"\n+            - title: \"Fault Tolerance\"\n+              pathprefix: \"/se/faulttolerance\"\n+              glyph:\n+                type: \"icon\"\n+                value: \"warning\"\n+              items:\n+                - includes:\n+                    - \"se/faulttolerance/*.adoc\"\n         - title: \"Helidon MP\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "90480bdea12ab6d064d57562ba76c3a3ba29e5d7"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk2NzcwNw==", "bodyText": "Fault Tolerance SE should be the last entry for SE. The next line is where MP starts as I understand it.", "url": "https://github.com/oracle/helidon/pull/2399#discussion_r496967707", "createdAt": "2020-09-29T18:58:14Z", "author": {"login": "spericas"}, "path": "docs/sitegen.yaml", "diffHunk": "@@ -208,6 +208,14 @@ backend:\n               items:\n                 - includes:\n                     - \"se/aot/*.adoc\"\n+            - title: \"Fault Tolerance\"\n+              pathprefix: \"/se/faulttolerance\"\n+              glyph:\n+                type: \"icon\"\n+                value: \"warning\"\n+              items:\n+                - includes:\n+                    - \"se/faulttolerance/*.adoc\"\n         - title: \"Helidon MP\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njk0NDQ4Mw=="}, "originalCommit": {"oid": "90480bdea12ab6d064d57562ba76c3a3ba29e5d7"}, "originalPosition": 12}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 424, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}