{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIwMzIwOTcz", "number": 1830, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwOToxNTozMlrOD-h9DQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQyMToxMjoxNlrOD-wIUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2ODk0NjA1OnYy", "diffSide": "RIGHT", "path": "common/reactive/src/main/java/io/helidon/common/reactive/BiConsumerChain.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwOToxNTozMlrOGYr9-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxNToxMjo0OFrOGY23zA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODUzOTM4Nw==", "bodyText": "Do not use public methods in package local classes", "url": "https://github.com/oracle/helidon/pull/1830#discussion_r428539387", "createdAt": "2020-05-21T09:15:32Z", "author": {"login": "tomas-langer"}, "path": "common/reactive/src/main/java/io/helidon/common/reactive/BiConsumerChain.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Copyright (c)  2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.common.reactive;\n+\n+import java.util.ArrayList;\n+import java.util.function.BiConsumer;\n+\n+class BiConsumerChain<T, S>\n+        extends ArrayList<BiConsumer<? super T, ? super S>>\n+        implements BiConsumer<T, S> {\n+\n+    @Override\n+    public void accept(T t, S s) {\n+        for (BiConsumer<? super T, ? super S> inner : this) {\n+            inner.accept(t, s);\n+        }\n+    }\n+\n+    public BiConsumerChain<T, S> combineWith(BiConsumer<? super T, ? super S> another) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1f2f2991c57ec107e7d1e8280d7577f0daa4c70"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODcxODAyOA==", "bodyText": "fixed", "url": "https://github.com/oracle/helidon/pull/1830#discussion_r428718028", "createdAt": "2020-05-21T15:12:48Z", "author": {"login": "danielkec"}, "path": "common/reactive/src/main/java/io/helidon/common/reactive/BiConsumerChain.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Copyright (c)  2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.common.reactive;\n+\n+import java.util.ArrayList;\n+import java.util.function.BiConsumer;\n+\n+class BiConsumerChain<T, S>\n+        extends ArrayList<BiConsumer<? super T, ? super S>>\n+        implements BiConsumer<T, S> {\n+\n+    @Override\n+    public void accept(T t, S s) {\n+        for (BiConsumer<? super T, ? super S> inner : this) {\n+            inner.accept(t, s);\n+        }\n+    }\n+\n+    public BiConsumerChain<T, S> combineWith(BiConsumer<? super T, ? super S> another) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODUzOTM4Nw=="}, "originalCommit": {"oid": "a1f2f2991c57ec107e7d1e8280d7577f0daa4c70"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2ODk2MzMxOnYy", "diffSide": "RIGHT", "path": "common/reactive/src/main/java/io/helidon/common/reactive/RunnableChain.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwOToyMTozNlrOGYsJIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxNToxMjo1NlrOGY24HQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODU0MjI0MQ==", "bodyText": "Please remove public modifier from methods in package local classes", "url": "https://github.com/oracle/helidon/pull/1830#discussion_r428542241", "createdAt": "2020-05-21T09:21:36Z", "author": {"login": "tomas-langer"}, "path": "common/reactive/src/main/java/io/helidon/common/reactive/RunnableChain.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/*\n+ * Copyright (c)  2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.common.reactive;\n+\n+import java.util.ArrayList;\n+\n+/**\n+ * Holds a list of {@link Runnable}s to flatten out a call chain of them.\n+ */\n+class RunnableChain extends ArrayList<Runnable> implements Runnable {\n+    @Override\n+    public void run() {\n+        for (Runnable inner : this) {\n+            inner.run();\n+        }\n+    }\n+\n+    public RunnableChain combineWith(Runnable another) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a1f2f2991c57ec107e7d1e8280d7577f0daa4c70"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODcxODEwOQ==", "bodyText": "fixed", "url": "https://github.com/oracle/helidon/pull/1830#discussion_r428718109", "createdAt": "2020-05-21T15:12:56Z", "author": {"login": "danielkec"}, "path": "common/reactive/src/main/java/io/helidon/common/reactive/RunnableChain.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/*\n+ * Copyright (c)  2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.common.reactive;\n+\n+import java.util.ArrayList;\n+\n+/**\n+ * Holds a list of {@link Runnable}s to flatten out a call chain of them.\n+ */\n+class RunnableChain extends ArrayList<Runnable> implements Runnable {\n+    @Override\n+    public void run() {\n+        for (Runnable inner : this) {\n+            inner.run();\n+        }\n+    }\n+\n+    public RunnableChain combineWith(Runnable another) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODU0MjI0MQ=="}, "originalCommit": {"oid": "a1f2f2991c57ec107e7d1e8280d7577f0daa4c70"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MTI2MjA2OnYy", "diffSide": "RIGHT", "path": "common/reactive/src/main/java/io/helidon/common/reactive/BufferedEmittingPublisher.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQyMTowOTo1OVrOGZC-FA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNjoxOToxNlrOGZcrww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkxNjI0NA==", "bodyText": "How about having support for onEmit callbacks ?", "url": "https://github.com/oracle/helidon/pull/1830#discussion_r428916244", "createdAt": "2020-05-21T21:09:59Z", "author": {"login": "romain-grecourt"}, "path": "common/reactive/src/main/java/io/helidon/common/reactive/BufferedEmittingPublisher.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * Copyright (c)  2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.common.reactive;\n+\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.Flow;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n+\n+/**\n+ * Emitting publisher for manual publishing with built-in buffer for handling backpressure.\n+ *\n+ * <p>\n+ * <strong>This publisher allows only a single subscriber</strong>.\n+ * </p>\n+ *\n+ * @param <T> type of emitted item\n+ */\n+public class BufferedEmittingPublisher<T> implements Flow.Publisher<T> {\n+\n+    private final AtomicReference<State> state = new AtomicReference<>(State.READY_TO_EMIT);\n+    private final ConcurrentLinkedQueue<T> buffer = new ConcurrentLinkedQueue<>();\n+    private final EmittingPublisher<T> emitter = new EmittingPublisher<>();\n+    private final AtomicBoolean draining = new AtomicBoolean(false);\n+    private final AtomicBoolean emitting = new AtomicBoolean(false);\n+    private final AtomicReference<Throwable> error = new AtomicReference<>();\n+    private BiConsumer<Long, Long> requestCallback = (n, r) -> {};\n+\n+    protected BufferedEmittingPublisher() {\n+    }\n+\n+    /**\n+     * Create new {@link BufferedEmittingPublisher}.\n+     *\n+     * @param <T> type of emitted item\n+     * @return new instance of BufferedEmittingPublisher\n+     */\n+    public static <T> BufferedEmittingPublisher<T> create() {\n+        return new BufferedEmittingPublisher<T>();\n+    }\n+\n+    @Override\n+    public void subscribe(final Flow.Subscriber<? super T> subscriber) {\n+        emitter.onSubscribe(() -> state.get().drain(this));\n+        emitter.onRequest((n, cnt) -> {\n+            requestCallback.accept(n, cnt);\n+            state.get().drain(this);\n+        });\n+        emitter.onCancel(() -> state.compareAndSet(State.READY_TO_EMIT, State.CANCELLED));\n+        emitter.subscribe(subscriber);\n+    }\n+\n+    /**\n+     * Callback executed when request signal from downstream arrive.\n+     * <ul>\n+     * <li><b>param</b> {@code n} the requested count.</li>\n+     * <li><b>param</b> {@code result} the current total cumulative requested count, ranges between [0, {@link Long#MAX_VALUE}]\n+     * where the max indicates that this publisher is unbounded.</li>\n+     * </ul>\n+     *\n+     * @param requestCallback to be executed\n+     */\n+    public void onRequest(BiConsumer<Long, Long> requestCallback) {\n+        this.requestCallback = BiConsumerChain.combine(this.requestCallback, requestCallback);\n+    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea9da46dceef61a25bd55e31fd13d41a6cff6cbe"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTIwNzE4OQ==", "bodyText": "Would be sufficient to invoke such callback right after emit invocation? To keep request counting isolated in EmittingPublisher the BufferedEmittingPublisher never know in advance if emit will be successful", "url": "https://github.com/oracle/helidon/pull/1830#discussion_r429207189", "createdAt": "2020-05-22T12:04:28Z", "author": {"login": "danielkec"}, "path": "common/reactive/src/main/java/io/helidon/common/reactive/BufferedEmittingPublisher.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * Copyright (c)  2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.common.reactive;\n+\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.Flow;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n+\n+/**\n+ * Emitting publisher for manual publishing with built-in buffer for handling backpressure.\n+ *\n+ * <p>\n+ * <strong>This publisher allows only a single subscriber</strong>.\n+ * </p>\n+ *\n+ * @param <T> type of emitted item\n+ */\n+public class BufferedEmittingPublisher<T> implements Flow.Publisher<T> {\n+\n+    private final AtomicReference<State> state = new AtomicReference<>(State.READY_TO_EMIT);\n+    private final ConcurrentLinkedQueue<T> buffer = new ConcurrentLinkedQueue<>();\n+    private final EmittingPublisher<T> emitter = new EmittingPublisher<>();\n+    private final AtomicBoolean draining = new AtomicBoolean(false);\n+    private final AtomicBoolean emitting = new AtomicBoolean(false);\n+    private final AtomicReference<Throwable> error = new AtomicReference<>();\n+    private BiConsumer<Long, Long> requestCallback = (n, r) -> {};\n+\n+    protected BufferedEmittingPublisher() {\n+    }\n+\n+    /**\n+     * Create new {@link BufferedEmittingPublisher}.\n+     *\n+     * @param <T> type of emitted item\n+     * @return new instance of BufferedEmittingPublisher\n+     */\n+    public static <T> BufferedEmittingPublisher<T> create() {\n+        return new BufferedEmittingPublisher<T>();\n+    }\n+\n+    @Override\n+    public void subscribe(final Flow.Subscriber<? super T> subscriber) {\n+        emitter.onSubscribe(() -> state.get().drain(this));\n+        emitter.onRequest((n, cnt) -> {\n+            requestCallback.accept(n, cnt);\n+            state.get().drain(this);\n+        });\n+        emitter.onCancel(() -> state.compareAndSet(State.READY_TO_EMIT, State.CANCELLED));\n+        emitter.subscribe(subscriber);\n+    }\n+\n+    /**\n+     * Callback executed when request signal from downstream arrive.\n+     * <ul>\n+     * <li><b>param</b> {@code n} the requested count.</li>\n+     * <li><b>param</b> {@code result} the current total cumulative requested count, ranges between [0, {@link Long#MAX_VALUE}]\n+     * where the max indicates that this publisher is unbounded.</li>\n+     * </ul>\n+     *\n+     * @param requestCallback to be executed\n+     */\n+    public void onRequest(BiConsumer<Long, Long> requestCallback) {\n+        this.requestCallback = BiConsumerChain.combine(this.requestCallback, requestCallback);\n+    }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkxNjI0NA=="}, "originalCommit": {"oid": "ea9da46dceef61a25bd55e31fd13d41a6cff6cbe"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMzNzUzOQ==", "bodyText": "What you did seems sufficient to me.", "url": "https://github.com/oracle/helidon/pull/1830#discussion_r429337539", "createdAt": "2020-05-22T16:19:16Z", "author": {"login": "romain-grecourt"}, "path": "common/reactive/src/main/java/io/helidon/common/reactive/BufferedEmittingPublisher.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * Copyright (c)  2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.common.reactive;\n+\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.Flow;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BiConsumer;\n+import java.util.function.Consumer;\n+\n+/**\n+ * Emitting publisher for manual publishing with built-in buffer for handling backpressure.\n+ *\n+ * <p>\n+ * <strong>This publisher allows only a single subscriber</strong>.\n+ * </p>\n+ *\n+ * @param <T> type of emitted item\n+ */\n+public class BufferedEmittingPublisher<T> implements Flow.Publisher<T> {\n+\n+    private final AtomicReference<State> state = new AtomicReference<>(State.READY_TO_EMIT);\n+    private final ConcurrentLinkedQueue<T> buffer = new ConcurrentLinkedQueue<>();\n+    private final EmittingPublisher<T> emitter = new EmittingPublisher<>();\n+    private final AtomicBoolean draining = new AtomicBoolean(false);\n+    private final AtomicBoolean emitting = new AtomicBoolean(false);\n+    private final AtomicReference<Throwable> error = new AtomicReference<>();\n+    private BiConsumer<Long, Long> requestCallback = (n, r) -> {};\n+\n+    protected BufferedEmittingPublisher() {\n+    }\n+\n+    /**\n+     * Create new {@link BufferedEmittingPublisher}.\n+     *\n+     * @param <T> type of emitted item\n+     * @return new instance of BufferedEmittingPublisher\n+     */\n+    public static <T> BufferedEmittingPublisher<T> create() {\n+        return new BufferedEmittingPublisher<T>();\n+    }\n+\n+    @Override\n+    public void subscribe(final Flow.Subscriber<? super T> subscriber) {\n+        emitter.onSubscribe(() -> state.get().drain(this));\n+        emitter.onRequest((n, cnt) -> {\n+            requestCallback.accept(n, cnt);\n+            state.get().drain(this);\n+        });\n+        emitter.onCancel(() -> state.compareAndSet(State.READY_TO_EMIT, State.CANCELLED));\n+        emitter.subscribe(subscriber);\n+    }\n+\n+    /**\n+     * Callback executed when request signal from downstream arrive.\n+     * <ul>\n+     * <li><b>param</b> {@code n} the requested count.</li>\n+     * <li><b>param</b> {@code result} the current total cumulative requested count, ranges between [0, {@link Long#MAX_VALUE}]\n+     * where the max indicates that this publisher is unbounded.</li>\n+     * </ul>\n+     *\n+     * @param requestCallback to be executed\n+     */\n+    public void onRequest(BiConsumer<Long, Long> requestCallback) {\n+        this.requestCallback = BiConsumerChain.combine(this.requestCallback, requestCallback);\n+    }\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkxNjI0NA=="}, "originalCommit": {"oid": "ea9da46dceef61a25bd55e31fd13d41a6cff6cbe"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MTI2ODY0OnYy", "diffSide": "RIGHT", "path": "common/reactive/src/main/java/io/helidon/common/reactive/EmittingPublisher.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQyMToxMjoxNlrOGZDCLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxMTo1NDo1NFrOGZUfcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkxNzI5NA==", "bodyText": "The subscriber reference is not released when completed.\nOne way of fixing it would be to add EmittingPublisher.this.subscriber = null; here", "url": "https://github.com/oracle/helidon/pull/1830#discussion_r428917294", "createdAt": "2020-05-21T21:12:16Z", "author": {"login": "romain-grecourt"}, "path": "common/reactive/src/main/java/io/helidon/common/reactive/EmittingPublisher.java", "diffHunk": "@@ -0,0 +1,334 @@\n+/*\n+ * Copyright (c)  2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package io.helidon.common.reactive;\n+\n+import java.util.Objects;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Flow;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BiConsumer;\n+\n+/**\n+ * Emitting publisher for manual publishing on the same thread.\n+ * {@link EmittingPublisher} doesn't have any buffering capability and propagates backpressure\n+ * directly by returning {@code false} from {@link EmittingPublisher#emit(Object)} in case there\n+ * is no demand, or {@code cancel} signal has been received.\n+ * <p>\n+ *     For publishing with buffering in case of backpressure use {@link BufferedEmittingPublisher}.\n+ * </p>\n+ *\n+ * <p>\n+ * <strong>This publisher allows only a single subscriber</strong>.\n+ * </p>\n+ *\n+ * @param <T> type of emitted item\n+ */\n+public class EmittingPublisher<T> implements Flow.Publisher<T> {\n+    private Flow.Subscriber<? super T> subscriber;\n+    private final AtomicReference<State> state = new AtomicReference<>(State.NOT_REQUESTED_YET);\n+    private final AtomicLong requested = new AtomicLong();\n+    private final AtomicBoolean emitting = new AtomicBoolean(false);\n+    private final AtomicBoolean subscribed = new AtomicBoolean(false);\n+    private final CompletableFuture<Void> deferredComplete = new CompletableFuture<>();\n+    private BiConsumer<Long, Long> requestCallback = (n, r) -> {};\n+    private Runnable onSubscribeCallback = () -> {};\n+    private Runnable cancelCallback = () -> {};\n+\n+    EmittingPublisher() {\n+    }\n+\n+    /**\n+     * Create new {@code EmittingPublisher}.\n+     *\n+     * @param <T> type of emitted item\n+     * @return brand new {@code EmittingPublisher}\n+     */\n+    public static <T> EmittingPublisher<T> create() {\n+        return new EmittingPublisher<>();\n+    }\n+\n+    @Override\n+    public void subscribe(final Flow.Subscriber<? super T> subscriber) {\n+        Objects.requireNonNull(subscriber, \"subscriber is null\");\n+\n+        if (!subscribed.compareAndSet(false, true)) {\n+            subscriber.onSubscribe(SubscriptionHelper.CANCELED);\n+            subscriber.onError(new IllegalStateException(\"Only single subscriber is allowed!\"));\n+            return;\n+        }\n+\n+        this.subscriber = subscriber;\n+\n+        onSubscribeCallback.run();\n+        subscriber.onSubscribe(new Flow.Subscription() {\n+            @Override\n+            public void request(final long n) {\n+                if (state.get() == State.CANCELLED) {\n+                    return;\n+                }\n+                if (n < 1) {\n+                    fail(new IllegalArgumentException(\"Rule \u00a73.9 violated: non-positive request amount is forbidden\"));\n+                    return;\n+                }\n+                requested.updateAndGet(r -> Long.MAX_VALUE - r > n ? n + r : Long.MAX_VALUE);\n+                state.compareAndSet(State.NOT_REQUESTED_YET, State.READY_TO_EMIT);\n+                requestCallback.accept(n, requested.get());\n+            }\n+\n+            @Override\n+            public void cancel() {\n+                if (state.compareAndSet(State.NOT_REQUESTED_YET, State.CANCELLED)\n+                        || state.compareAndSet(State.READY_TO_EMIT, State.CANCELLED)) {\n+                    cancelCallback.run();\n+                    EmittingPublisher.this.subscriber = null;\n+                }\n+            }\n+\n+        });\n+        deferredComplete.complete(null);\n+    }\n+\n+    /**\n+     * Properly fail the stream, set publisher to cancelled state and send {@code onError} signal downstream.\n+     * Signal {@code onError} is sent only once, any other call to this method is no-op.\n+     *\n+     * @param throwable Sent as {@code onError} signal\n+     */\n+    public void fail(Throwable throwable) {\n+        if (deferredComplete.isDone()) {\n+            signalOnError(throwable);\n+        } else {\n+            deferredComplete.thenRun(() -> signalOnError(throwable));\n+        }\n+    }\n+\n+    /**\n+     * Properly complete the stream, set publisher to completed state and send {@code onComplete} signal downstream.\n+     * Signal {@code onComplete} is sent only once, any other call to this method is no-op.\n+     */\n+    public void complete() {\n+        deferredComplete.thenRun(this::signalOnComplete);\n+    }\n+\n+    private void signalOnError(Throwable throwable) {\n+        if (state.compareAndSet(State.NOT_REQUESTED_YET, State.FAILED)\n+                || state.compareAndSet(State.READY_TO_EMIT, State.FAILED)) {\n+            for (;;) {\n+                try {\n+                    if (emitting.getAndSet(true)) {\n+                        continue;\n+                    }\n+                    this.subscriber.onError(throwable);\n+                    return;\n+                } catch (Throwable t) {\n+                    throw new IllegalStateException(\"On error threw an exception!\", t);\n+                } finally {\n+                    emitting.set(false);\n+                }\n+            }\n+        }\n+    }\n+\n+    private void signalOnComplete() {\n+        if (state.compareAndSet(State.NOT_REQUESTED_YET, State.COMPLETED)\n+                || state.compareAndSet(State.READY_TO_EMIT, State.COMPLETED)) {\n+            for (;;) {\n+                try {\n+                    if (emitting.getAndSet(true)) {\n+                        continue;\n+                    }\n+                    this.subscriber.onComplete();\n+                    return;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea9da46dceef61a25bd55e31fd13d41a6cff6cbe"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTIwMzMxMw==", "bodyText": "Uf thx for that, there was also possible NPE if emit started right before READY_TO_EMIT -> CANCELLED state transition, but invoked onNext after reference release", "url": "https://github.com/oracle/helidon/pull/1830#discussion_r429203313", "createdAt": "2020-05-22T11:54:54Z", "author": {"login": "danielkec"}, "path": "common/reactive/src/main/java/io/helidon/common/reactive/EmittingPublisher.java", "diffHunk": "@@ -0,0 +1,334 @@\n+/*\n+ * Copyright (c)  2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package io.helidon.common.reactive;\n+\n+import java.util.Objects;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.Flow;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BiConsumer;\n+\n+/**\n+ * Emitting publisher for manual publishing on the same thread.\n+ * {@link EmittingPublisher} doesn't have any buffering capability and propagates backpressure\n+ * directly by returning {@code false} from {@link EmittingPublisher#emit(Object)} in case there\n+ * is no demand, or {@code cancel} signal has been received.\n+ * <p>\n+ *     For publishing with buffering in case of backpressure use {@link BufferedEmittingPublisher}.\n+ * </p>\n+ *\n+ * <p>\n+ * <strong>This publisher allows only a single subscriber</strong>.\n+ * </p>\n+ *\n+ * @param <T> type of emitted item\n+ */\n+public class EmittingPublisher<T> implements Flow.Publisher<T> {\n+    private Flow.Subscriber<? super T> subscriber;\n+    private final AtomicReference<State> state = new AtomicReference<>(State.NOT_REQUESTED_YET);\n+    private final AtomicLong requested = new AtomicLong();\n+    private final AtomicBoolean emitting = new AtomicBoolean(false);\n+    private final AtomicBoolean subscribed = new AtomicBoolean(false);\n+    private final CompletableFuture<Void> deferredComplete = new CompletableFuture<>();\n+    private BiConsumer<Long, Long> requestCallback = (n, r) -> {};\n+    private Runnable onSubscribeCallback = () -> {};\n+    private Runnable cancelCallback = () -> {};\n+\n+    EmittingPublisher() {\n+    }\n+\n+    /**\n+     * Create new {@code EmittingPublisher}.\n+     *\n+     * @param <T> type of emitted item\n+     * @return brand new {@code EmittingPublisher}\n+     */\n+    public static <T> EmittingPublisher<T> create() {\n+        return new EmittingPublisher<>();\n+    }\n+\n+    @Override\n+    public void subscribe(final Flow.Subscriber<? super T> subscriber) {\n+        Objects.requireNonNull(subscriber, \"subscriber is null\");\n+\n+        if (!subscribed.compareAndSet(false, true)) {\n+            subscriber.onSubscribe(SubscriptionHelper.CANCELED);\n+            subscriber.onError(new IllegalStateException(\"Only single subscriber is allowed!\"));\n+            return;\n+        }\n+\n+        this.subscriber = subscriber;\n+\n+        onSubscribeCallback.run();\n+        subscriber.onSubscribe(new Flow.Subscription() {\n+            @Override\n+            public void request(final long n) {\n+                if (state.get() == State.CANCELLED) {\n+                    return;\n+                }\n+                if (n < 1) {\n+                    fail(new IllegalArgumentException(\"Rule \u00a73.9 violated: non-positive request amount is forbidden\"));\n+                    return;\n+                }\n+                requested.updateAndGet(r -> Long.MAX_VALUE - r > n ? n + r : Long.MAX_VALUE);\n+                state.compareAndSet(State.NOT_REQUESTED_YET, State.READY_TO_EMIT);\n+                requestCallback.accept(n, requested.get());\n+            }\n+\n+            @Override\n+            public void cancel() {\n+                if (state.compareAndSet(State.NOT_REQUESTED_YET, State.CANCELLED)\n+                        || state.compareAndSet(State.READY_TO_EMIT, State.CANCELLED)) {\n+                    cancelCallback.run();\n+                    EmittingPublisher.this.subscriber = null;\n+                }\n+            }\n+\n+        });\n+        deferredComplete.complete(null);\n+    }\n+\n+    /**\n+     * Properly fail the stream, set publisher to cancelled state and send {@code onError} signal downstream.\n+     * Signal {@code onError} is sent only once, any other call to this method is no-op.\n+     *\n+     * @param throwable Sent as {@code onError} signal\n+     */\n+    public void fail(Throwable throwable) {\n+        if (deferredComplete.isDone()) {\n+            signalOnError(throwable);\n+        } else {\n+            deferredComplete.thenRun(() -> signalOnError(throwable));\n+        }\n+    }\n+\n+    /**\n+     * Properly complete the stream, set publisher to completed state and send {@code onComplete} signal downstream.\n+     * Signal {@code onComplete} is sent only once, any other call to this method is no-op.\n+     */\n+    public void complete() {\n+        deferredComplete.thenRun(this::signalOnComplete);\n+    }\n+\n+    private void signalOnError(Throwable throwable) {\n+        if (state.compareAndSet(State.NOT_REQUESTED_YET, State.FAILED)\n+                || state.compareAndSet(State.READY_TO_EMIT, State.FAILED)) {\n+            for (;;) {\n+                try {\n+                    if (emitting.getAndSet(true)) {\n+                        continue;\n+                    }\n+                    this.subscriber.onError(throwable);\n+                    return;\n+                } catch (Throwable t) {\n+                    throw new IllegalStateException(\"On error threw an exception!\", t);\n+                } finally {\n+                    emitting.set(false);\n+                }\n+            }\n+        }\n+    }\n+\n+    private void signalOnComplete() {\n+        if (state.compareAndSet(State.NOT_REQUESTED_YET, State.COMPLETED)\n+                || state.compareAndSet(State.READY_TO_EMIT, State.COMPLETED)) {\n+            for (;;) {\n+                try {\n+                    if (emitting.getAndSet(true)) {\n+                        continue;\n+                    }\n+                    this.subscriber.onComplete();\n+                    return;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkxNzI5NA=="}, "originalCommit": {"oid": "ea9da46dceef61a25bd55e31fd13d41a6cff6cbe"}, "originalPosition": 158}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 567, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}