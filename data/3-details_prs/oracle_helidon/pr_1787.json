{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE3NzE5NTU1", "number": 1787, "title": "Multipart", "bodyText": "Fixes #189\nFixes #102", "createdAt": "2020-05-14T02:56:44Z", "url": "https://github.com/oracle/helidon/pull/1787", "merged": true, "mergeCommit": {"oid": "ab23ce10cb55043e5e4beea1037a65bb8968354b"}, "closed": true, "closedAt": "2020-05-26T20:00:02Z", "author": {"login": "romain-grecourt"}, "timelineItems": {"totalCount": 57, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcgtri6gH2gAyNDE3NzE5NTU1OmUzMjE0OTVhZWQ1NDk3OTJjNzZiOTc2ZDU5MmM1ZGI5MDBlZGU0NTg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABclI3EMAFqTQxODU2MDcwMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "e321495aed549792c76b976d592c5db900ede458", "author": {"user": {"login": "romain-grecourt", "name": "Romain Grecourt"}}, "url": "https://github.com/oracle/helidon/commit/e321495aed549792c76b976d592c5db900ede458", "committedDate": "2020-05-13T00:24:57Z", "message": "Multipart (#2)\n\nInitial implementation of multipart media support."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c354d736e5c76ed6284f5d957edc36ab96e7e5f8", "author": {"user": {"login": "romain-grecourt", "name": "Romain Grecourt"}}, "url": "https://github.com/oracle/helidon/commit/c354d736e5c76ed6284f5d957edc36ab96e7e5f8", "committedDate": "2020-05-13T02:24:39Z", "message": "Update multipart example"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aaf944b6e13e15c4b6349ac619e9958856bc0486", "author": {"user": {"login": "romain-grecourt", "name": "Romain Grecourt"}}, "url": "https://github.com/oracle/helidon/commit/aaf944b6e13e15c4b6349ac619e9958856bc0486", "committedDate": "2020-05-13T02:25:10Z", "message": "update BodyPartTest to get rid of UncompletablePublisher"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6ef0f9771abcf28337e9e764cef389a9c1ec9e03", "author": {"user": {"login": "romain-grecourt", "name": "Romain Grecourt"}}, "url": "https://github.com/oracle/helidon/commit/6ef0f9771abcf28337e9e764cef389a9c1ec9e03", "committedDate": "2020-05-13T02:29:22Z", "message": "fix signature of MutliPart.fields"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ee33bb2719bdab8457543820fc8bb122cdf3e7d3", "author": {"user": {"login": "romain-grecourt", "name": "Romain Grecourt"}}, "url": "https://github.com/oracle/helidon/commit/ee33bb2719bdab8457543820fc8bb122cdf3e7d3", "committedDate": "2020-05-13T02:29:37Z", "message": "fix imports in MultiPartEncoderTest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7c2902ecfdfe7cae3612fcc4b8be01c975695e62", "author": {"user": {"login": "romain-grecourt", "name": "Romain Grecourt"}}, "url": "https://github.com/oracle/helidon/commit/7c2902ecfdfe7cae3612fcc4b8be01c975695e62", "committedDate": "2020-05-14T02:39:49Z", "message": "fix buffering"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "07bc03937780992459c7238ec40298c47371a1d5", "author": {"user": {"login": "romain-grecourt", "name": "Romain Grecourt"}}, "url": "https://github.com/oracle/helidon/commit/07bc03937780992459c7238ec40298c47371a1d5", "committedDate": "2020-05-14T02:50:52Z", "message": "Update multipart example to be a mini file upload webapp"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dbcbb81891f3b926ce45717adf8be21439b37535", "author": {"user": {"login": "romain-grecourt", "name": "Romain Grecourt"}}, "url": "https://github.com/oracle/helidon/commit/dbcbb81891f3b926ce45717adf8be21439b37535", "committedDate": "2020-05-14T03:16:15Z", "message": "fix checkstyle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1e9d1a876a27e52a81c6921cffe786d5d5a1208d", "author": {"user": {"login": "romain-grecourt", "name": "Romain Grecourt"}}, "url": "https://github.com/oracle/helidon/commit/1e9d1a876a27e52a81c6921cffe786d5d5a1208d", "committedDate": "2020-05-14T05:22:20Z", "message": "fix checkstyle"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExNzAxMzc0", "url": "https://github.com/oracle/helidon/pull/1787#pullrequestreview-411701374", "createdAt": "2020-05-14T11:13:02Z", "commit": {"oid": "1e9d1a876a27e52a81c6921cffe786d5d5a1208d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxMToxMzowMlrOGVXddA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxMToxMzowMlrOGVXddA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA1NzY1Mg==", "bodyText": "We have nice tooling for that, no need to misuse OriginThreadPublisher here\nMultiPartDecoder_not_extending_OTPub.patch.txt", "url": "https://github.com/oracle/helidon/pull/1787#discussion_r425057652", "createdAt": "2020-05-14T11:13:02Z", "author": {"login": "danielkec"}, "path": "media/multipart/common/src/main/java/io/helidon/media/multipart/common/MultiPartDecoder.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.helidon.media.multipart.common;\n+\n+import java.util.LinkedList;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Queue;\n+import java.util.concurrent.Flow.Processor;\n+import java.util.concurrent.Flow.Subscriber;\n+import java.util.concurrent.Flow.Subscription;\n+import java.util.logging.Logger;\n+\n+import io.helidon.common.http.DataChunk;\n+import io.helidon.common.reactive.OriginThreadPublisher;\n+import io.helidon.media.common.MessageBodyReadableContent;\n+import io.helidon.media.common.MessageBodyReaderContext;\n+\n+/**\n+ * Reactive processor that decodes HTTP payload as a stream of {@link BodyPart}.\n+ * This processor is a single use publisher that supports a single subscriber,\n+ * it is not resumable.\n+ */\n+public final class MultiPartDecoder implements Processor<DataChunk, ReadableBodyPart> {\n+\n+    /**\n+     * Logger.\n+     */\n+    private static final Logger LOGGER = Logger.getLogger(MultiPartDecoder.class.getName());\n+\n+    /**\n+     * Indicate that the chunks subscription is complete.\n+     */\n+    private boolean complete;\n+\n+    /**\n+     * The upstream subscription.\n+     */\n+    private Subscription chunksSubscription;\n+\n+    /**\n+     * The builder for the current {@link BodyPart}.\n+     */\n+    private ReadableBodyPart.Builder bodyPartBuilder;\n+\n+    /**\n+     * The builder for the current {@link ReadableBodyPartHeaders}.\n+     */\n+    private ReadableBodyPartHeaders.Builder bodyPartHeaderBuilder;\n+\n+    /**\n+     * The publisher for the current part.\n+     */\n+    private BodyPartContentPublisher contentPublisher;\n+\n+    /**\n+     * The parent chunk for the published body part chunks.\n+     */\n+    private BodyPartChunk.Parent chunkParent;\n+\n+    /**\n+     * The MIME parser.\n+     */\n+    private final MIMEParser parser;\n+\n+    /**\n+     * The parser event processor.\n+     */\n+    private final ParserEventProcessor parserEventProcessor;\n+\n+    /**\n+     * The bodyParts processed during each {@code onNext}.\n+     */\n+    private final Queue<ReadableBodyPart> bodyParts;\n+\n+    /**\n+     * The reader context.\n+     */\n+    private final MessageBodyReaderContext context;\n+\n+    /**\n+     * The downstream publisher.\n+     */\n+    private final BodyPartPublisher downstream;\n+\n+    /**\n+     * Create a new instance.\n+     *\n+     * @param boundary mime message boundary\n+     * @param context reader context\n+     */\n+    private MultiPartDecoder(String boundary, MessageBodyReaderContext context) {\n+        Objects.requireNonNull(boundary, \"boundary cannot be null!\");\n+        Objects.requireNonNull(context, \"context cannot be null!\");\n+        this.context = context;\n+        parserEventProcessor = new ParserEventProcessor();\n+        parser = new MIMEParser(boundary, parserEventProcessor);\n+        downstream = new BodyPartPublisher();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e9d1a876a27e52a81c6921cffe786d5d5a1208d"}, "originalPosition": 111}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExNzA0Mzcw", "url": "https://github.com/oracle/helidon/pull/1787#pullrequestreview-411704370", "createdAt": "2020-05-14T11:17:30Z", "commit": {"oid": "1e9d1a876a27e52a81c6921cffe786d5d5a1208d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxMToxNzozMVrOGVXm2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxMToxNzozMVrOGVXm2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA2MDA1OA==", "bodyText": "We definitely need Multi.just(...).via(Flow.Processor).subscribe(Flow.Subscriber) like MPRS have", "url": "https://github.com/oracle/helidon/pull/1787#discussion_r425060058", "createdAt": "2020-05-14T11:17:31Z", "author": {"login": "danielkec"}, "path": "media/multipart/common/src/test/java/io/helidon/media/multipart/common/MultiPartDecoderTest.java", "diffHunk": "@@ -0,0 +1,571 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.helidon.media.multipart.common;\n+\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Flow.Publisher;\n+import java.util.concurrent.Flow.Subscriber;\n+import java.util.concurrent.Flow.Subscription;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import io.helidon.common.http.DataChunk;\n+import io.helidon.common.reactive.Multi;\n+\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.CoreMatchers.hasItems;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.CoreMatchers.nullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static io.helidon.media.multipart.common.BodyPartTest.MEDIA_CONTEXT;\n+\n+/**\n+ * Tests {@link MultiPartDecoder}.\n+ */\n+public class MultiPartDecoderTest {\n+\n+    private static final Logger LOGGER = Logger.getLogger(MultiPartDecoder.class.getName());\n+\n+    @BeforeAll\n+    public static void before() {\n+        LOGGER.setLevel(Level.ALL);\n+    }\n+\n+    @AfterAll\n+    public static void after() {\n+        LOGGER.setLevel(Level.INFO);\n+    }\n+\n+    @Test\n+    public void testOnePartInOneChunk() {\n+        String boundary = \"boundary\";\n+        final byte[] chunk1 = (\"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part1\\n\"\n+                + \"\\n\"\n+                + \"body 1\\n\"\n+                + \"--\" + boundary + \"--\").getBytes();\n+\n+        final CountDownLatch latch = new CountDownLatch(2);\n+        Consumer<BodyPart> consumer = (part) -> {\n+            latch.countDown();\n+            assertThat(part.headers().values(\"Content-Id\"),\n+                    hasItems(\"part1\"));\n+            DataChunkSubscriber subscriber = new DataChunkSubscriber();\n+            part.content().subscribe(subscriber);\n+            subscriber.content().thenAccept(body -> {\n+                latch.countDown();\n+                assertThat(body, is(equalTo(\"body 1\")));\n+            });\n+        };\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(\n+                SUBSCRIBER_TYPE.INFINITE, consumer);\n+        partsPublisher(boundary, chunk1).subscribe(testSubscriber);\n+        waitOnLatch(latch);\n+        assertThat(testSubscriber.error, is(nullValue()));\n+        assertThat(testSubscriber.complete, is(equalTo(true)));\n+    }\n+\n+    @Test\n+    public void testTwoPartsInOneChunk() {\n+        String boundary = \"boundary\";\n+        final byte[] chunk1 = (\"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part1\\n\"\n+                + \"\\n\"\n+                + \"body 1\\n\"\n+                + \"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part2\\n\"\n+                + \"\\n\"\n+                + \"body 2\\n\"\n+                + \"--\" + boundary + \"--\").getBytes();\n+\n+        final CountDownLatch latch = new CountDownLatch(4);\n+        Consumer<BodyPart> consumer = (part) -> {\n+            latch.countDown();\n+            if (latch.getCount() == 3) {\n+                assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part1\"));\n+                DataChunkSubscriber subscriber = new DataChunkSubscriber();\n+                part.content().subscribe(subscriber);\n+                subscriber.content().thenAccept(body -> {\n+                    latch.countDown();\n+                    assertThat(body, is(equalTo(\"body 1\")));\n+                });\n+            } else {\n+                assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part2\"));\n+                DataChunkSubscriber subscriber = new DataChunkSubscriber();\n+                part.content().subscribe(subscriber);\n+                subscriber.content().thenAccept(body -> {\n+                    latch.countDown();\n+                    assertThat(body, is(equalTo(\"body 2\")));\n+                });\n+            }\n+        };\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(SUBSCRIBER_TYPE.INFINITE, consumer);\n+        partsPublisher(boundary, chunk1).subscribe(testSubscriber);\n+        waitOnLatch(latch);\n+        assertThat(testSubscriber.error, is(nullValue()));\n+        assertThat(testSubscriber.complete, is(equalTo(true)));\n+    }\n+\n+    @Test\n+    public void testContentAcrossChunks() {\n+        String boundary = \"boundary\";\n+        final byte[] chunk1 = (\"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part1\\n\"\n+                + \"\\n\"\n+                + \"this-is-the-1st-slice-of-the-body\\n\").getBytes();\n+        final byte[] chunk2 = (\"this-is-the-2nd-slice-of-the-body\\n\"\n+                + \"--\" + boundary + \"--\").getBytes();\n+\n+        final CountDownLatch latch = new CountDownLatch(2);\n+        Consumer<BodyPart> consumer = (part) -> {\n+            latch.countDown();\n+            assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part1\"));\n+            DataChunkSubscriber subscriber = new DataChunkSubscriber();\n+            part.content().subscribe(subscriber);\n+            subscriber.content().thenAccept(body -> {\n+                latch.countDown();\n+                assertThat(body, is(equalTo(\n+                        \"this-is-the-1st-slice-of-the-body\\n\"\n+                        + \"this-is-the-2nd-slice-of-the-body\")));\n+            });\n+        };\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(SUBSCRIBER_TYPE.INFINITE, consumer);\n+        partsPublisher(boundary, chunk1, chunk2).subscribe(testSubscriber);\n+        waitOnLatch(latch);\n+        assertThat(testSubscriber.error, is(nullValue()));\n+        assertThat(testSubscriber.complete, is(equalTo(true)));\n+    }\n+\n+    @Test\n+    public void testMultipleChunksBeforeContent() {\n+        String boundary = \"boundary\";\n+        final byte[] chunk1 = (\"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part1\\n\").getBytes();\n+        final byte[] chunk2 = \"Content-Type: text/plain\\n\".getBytes();\n+        final byte[] chunk3 = \"Set-Cookie: bob=alice\\n\".getBytes();\n+        final byte[] chunk4 = \"Set-Cookie: foo=bar\\n\".getBytes();\n+        final byte[] chunk5 = (\"\\n\"\n+                + \"body 1\\n\"\n+                + \"--\" + boundary + \"--\").getBytes();\n+\n+        final CountDownLatch latch = new CountDownLatch(2);\n+        Consumer<BodyPart> consumer = (part) -> {\n+            latch.countDown();\n+            assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part1\"));\n+            assertThat(part.headers().values(\"Content-Type\"), hasItems(\"text/plain\"));\n+            assertThat(part.headers().values(\"Set-Cookie\"), hasItems(\"bob=alice\", \"foo=bar\"));\n+            DataChunkSubscriber subscriber = new DataChunkSubscriber();\n+            part.content().subscribe(subscriber);\n+            subscriber.content().thenAccept(body -> {\n+                latch.countDown();\n+                assertThat(body, is(equalTo(\"body 1\")));\n+            });\n+        };\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(SUBSCRIBER_TYPE.INFINITE, consumer);\n+        partsPublisher(boundary, chunk1, chunk2, chunk3, chunk4, chunk5).subscribe(testSubscriber);\n+        waitOnLatch(latch);\n+        assertThat(testSubscriber.error, is(nullValue()));\n+        assertThat(testSubscriber.complete, is(equalTo(true)));\n+    }\n+\n+    @Test\n+    public void testMulitiplePartsWithOneByOneSubscriber() {\n+        String boundary = \"boundary\";\n+        final byte[] chunk1 = (\"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part1\\n\"\n+                + \"\\n\"\n+                + \"body 1\\n\"\n+                + \"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part2\\n\"\n+                + \"\\n\"\n+                + \"body 2\\n\"\n+                + \"--\" + boundary + \"--\").getBytes();\n+\n+        final CountDownLatch latch = new CountDownLatch(4);\n+        Consumer<BodyPart> consumer = (part) -> {\n+            latch.countDown();\n+            if (latch.getCount()== 3) {\n+                assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part1\"));\n+                DataChunkSubscriber subscriber = new DataChunkSubscriber();\n+                part.content().subscribe(subscriber);\n+                subscriber.content().thenAccept(body -> {\n+                    latch.countDown();\n+                    assertThat(body, is(equalTo(\"body 1\")));\n+                });\n+            } else {\n+                assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part2\"));\n+                DataChunkSubscriber subscriber = new DataChunkSubscriber();\n+                part.content().subscribe(subscriber);\n+                subscriber.content().thenAccept(body -> {\n+                    latch.countDown();\n+                    assertThat(body, is(equalTo(\"body 2\")));\n+                });\n+            }\n+        };\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(SUBSCRIBER_TYPE.ONE_BY_ONE, consumer);\n+        partsPublisher(boundary, chunk1).subscribe(testSubscriber);\n+        waitOnLatch(latch);\n+        assertThat(testSubscriber.error, is(nullValue()));\n+        assertThat(testSubscriber.complete, is(equalTo(true)));\n+    }\n+\n+    @Test\n+    public void testSubscriberCancelAfterOnePart() {\n+        String boundary = \"boundary\";\n+        final byte[] chunk1 = (\"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part1\\n\"\n+                + \"\\n\"\n+                + \"body 1\\n\"\n+                + \"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part2\\n\"\n+                + \"\\n\"\n+                + \"body 2\\n\"\n+                + \"--\" + boundary + \"--\").getBytes();\n+\n+        final CountDownLatch latch = new CountDownLatch(2);\n+        Consumer<BodyPart> consumer = (part) -> {\n+            latch.countDown();\n+            if (latch.getCount()== 1) {\n+                assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part1\"));\n+                DataChunkSubscriber subscriber1 = new DataChunkSubscriber();\n+                part.content().subscribe(subscriber1);\n+                subscriber1.content().thenAccept(body -> {\n+                    latch.countDown();\n+                    assertThat(body, is(equalTo(\"body 1\")));\n+                });\n+            }\n+        };\n+\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(SUBSCRIBER_TYPE.CANCEL_AFTER_ONE, consumer);\n+        partsPublisher(boundary, chunk1).subscribe(testSubscriber);\n+        waitOnLatch(latch);\n+        assertThat(testSubscriber.error, is(nullValue()));\n+        assertThat(testSubscriber.complete, is(equalTo(false)));\n+    }\n+\n+    @Test\n+    public void testNoClosingBoundary(){\n+        String boundary = \"boundary\";\n+        final byte[] chunk1 = (\"--\" + boundary + \"\\n\"\n+                + \"Content-Type: text/xml; charset=UTF-8\\n\"\n+                + \"Content-Id: part1\\n\"\n+                + \"\\n\"\n+                + \"<foo>bar</foo>\\n\").getBytes();\n+\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(SUBSCRIBER_TYPE.CANCEL_AFTER_ONE, null);\n+        partsPublisher(boundary, chunk1).subscribe(testSubscriber);\n+        assertThat(testSubscriber.complete, is(equalTo(false)));\n+        assertThat(testSubscriber.error, is(notNullValue()));\n+        assertThat(testSubscriber.error.getClass(), is(equalTo(MIMEParser.ParsingException.class)));\n+        assertThat(testSubscriber.error.getMessage(), is(equalTo(\"No closing MIME boundary\")));\n+    }\n+\n+    @Test\n+    public void testCanceledPartSubscription() {\n+        String boundary = \"boundary\";\n+        final byte[] chunk1 = (\"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part1\\n\"\n+                + \"\\n\"\n+                + \"body 1.aaaa\\n\").getBytes();\n+        final byte[] chunk2 = \"body 1.bbbb\\n\".getBytes();\n+        final byte[] chunk3 = (\"body 1.cccc\\n\"\n+                + \"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part2\\n\"\n+                + \"\\n\"\n+                + \"This is the 2nd\").getBytes();\n+        final byte[] chunk4 = (\"body.\\n\"\n+                + \"--\" + boundary + \"--\").getBytes();\n+\n+        final CountDownLatch latch = new CountDownLatch(4);\n+        Consumer<BodyPart> consumer = (part) -> {\n+            latch.countDown();\n+            if (latch.getCount() == 3) {\n+                assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part1\"));\n+                part.content().subscribe(new Subscriber<DataChunk>() {\n+                    Subscription subscription;\n+\n+                    @Override\n+                    public void onSubscribe(Subscription subscription) {\n+                        this.subscription = subscription;\n+                        subscription.request(Long.MAX_VALUE);\n+                    }\n+\n+                    @Override\n+                    public void onNext(DataChunk item) {\n+                        latch.countDown();\n+                        subscription.cancel();\n+                    }\n+\n+                    @Override\n+                    public void onError(Throwable throwable) {\n+                    }\n+\n+                    @Override\n+                    public void onComplete() {\n+                    }\n+                });\n+            } else {\n+                assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part2\"));\n+                DataChunkSubscriber subscriber = new DataChunkSubscriber();\n+                part.content().subscribe(subscriber);\n+                subscriber.content().thenAccept(body -> {\n+                    latch.countDown();\n+                    assertThat(body, is(equalTo(\"This is the 2nd body.\")));\n+                });\n+            }\n+        };\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(SUBSCRIBER_TYPE.ONE_BY_ONE, consumer);\n+        partsPublisher(boundary, chunk1, chunk2, chunk3, chunk4).subscribe(testSubscriber);\n+        waitOnLatch(latch);\n+        assertThat(testSubscriber.error, is(nullValue()));\n+        assertThat(testSubscriber.complete, is(equalTo(true)));\n+    }\n+\n+    @Test\n+    public void testPartContentSubscriberThrottling() {\n+        String boundary = \"boundary\";\n+        final byte[] chunk1 = (\"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part1\\n\"\n+                + \"\\n\"\n+                + \"body 1.aaaa\\n\").getBytes();\n+        final byte[] chunk2 = \"body 1.bbbb\\n\".getBytes();\n+        final byte[] chunk3 = (\"body 1.cccc\\n\"\n+                + \"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part2\\n\"\n+                + \"\\n\"\n+                + \"This is the 2nd\").getBytes();\n+        final byte[] chunk4 = (\"body.\\n\"\n+                + \"--\" + boundary + \"--\").getBytes();\n+\n+        final CountDownLatch latch = new CountDownLatch(3);\n+        Consumer<BodyPart> consumer = (part) -> {\n+            latch.countDown();\n+            if (latch.getCount() == 2) {\n+                assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part1\"));\n+            }\n+            part.content().subscribe(new Subscriber<DataChunk>() {\n+\n+                @Override\n+                public void onSubscribe(Subscription subscription) {\n+                    subscription.request(1);\n+                }\n+\n+                @Override\n+                public void onNext(DataChunk item) {\n+                    latch.countDown();\n+                }\n+\n+                @Override\n+                public void onError(Throwable throwable) {\n+                }\n+\n+                @Override\n+                public void onComplete() {\n+                }\n+            });\n+        };\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(SUBSCRIBER_TYPE.ONE_BY_ONE, consumer);\n+        partsPublisher(boundary, chunk1, chunk2, chunk3, chunk4).subscribe(testSubscriber);\n+        waitOnLatchNegative(latch, \"the 2nd part should not be processed\");\n+        assertThat(latch.getCount(), is(equalTo(1L)));\n+        assertThat(testSubscriber.error, is(nullValue()));\n+        assertThat(testSubscriber.complete, is(equalTo(false)));\n+    }\n+\n+    @Test\n+    public void testUpstreamError() {\n+        MultiPartDecoder decoder = MultiPartDecoder.create(\"boundary\", MEDIA_CONTEXT.readerContext());\n+        new Publisher<DataChunk>(){\n+            @Override\n+            public void subscribe(Subscriber<? super DataChunk> subscriber) {\n+                subscriber.onError(new IllegalStateException(\"oops\"));\n+            }\n+        }.subscribe(decoder);\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(SUBSCRIBER_TYPE.INFINITE, null);\n+        decoder.subscribe(testSubscriber);\n+        assertThat(testSubscriber.complete, is(equalTo(false)));\n+        assertThat(testSubscriber.error, is(notNullValue()));\n+        assertThat(testSubscriber.error.getMessage(), is(equalTo(\"oops\")));\n+    }\n+\n+    @Test\n+    public void testSubcribingMoreThanOnce() {\n+        MultiPartDecoder decoder = MultiPartDecoder.create(\"boundary\", MEDIA_CONTEXT.readerContext());\n+        chunksPublisher(\"foo\".getBytes()).subscribe(decoder);\n+        try {\n+            chunksPublisher(\"bar\".getBytes()).subscribe(decoder);\n+            fail(\"exception should be thrown\");\n+        } catch(IllegalStateException ex) {\n+            assertThat(ex.getMessage(), is(equalTo(\"Input subscription already set\")));\n+        }\n+    }\n+\n+    /**\n+     * Types of test subscribers.\n+     */\n+    enum SUBSCRIBER_TYPE {\n+        INFINITE,\n+        ONE_BY_ONE,\n+        CANCEL_AFTER_ONE,\n+    }\n+\n+    /**\n+     * A part test subscriber.\n+     */\n+    static class BodyPartSubscriber implements Subscriber<BodyPart>{\n+\n+        private final SUBSCRIBER_TYPE subscriberType;\n+        private final Consumer<BodyPart> consumer;\n+        private Subscription subcription;\n+        private Throwable error;\n+        private boolean complete;\n+\n+        BodyPartSubscriber(SUBSCRIBER_TYPE subscriberType, Consumer<BodyPart> consumer) {\n+            this.subscriberType = subscriberType;\n+            this.consumer = consumer;\n+        }\n+\n+        @Override\n+        public void onSubscribe(Subscription subscription) {\n+            this.subcription = subscription;\n+            if (subscriberType == SUBSCRIBER_TYPE.INFINITE) {\n+                subscription.request(Long.MAX_VALUE);\n+            } else {\n+                subscription.request(1);\n+            }\n+        }\n+\n+        @Override\n+        public void onNext(BodyPart item) {\n+            if (consumer == null){\n+                return;\n+            }\n+            consumer.accept(item);\n+            if (subscriberType == SUBSCRIBER_TYPE.ONE_BY_ONE) {\n+                subcription.request(1);\n+            } else if (subscriberType == SUBSCRIBER_TYPE.CANCEL_AFTER_ONE) {\n+                subcription.cancel();\n+            }\n+        }\n+\n+        @Override\n+        public void onError(Throwable ex) {\n+            error = ex;\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            complete = true;\n+        }\n+    }\n+\n+    /**\n+     * Create the parts publisher for the specified boundary and request\n+     * chunks.\n+     * @param boundary multipart boundary string\n+     * @param chunks request chunks\n+     * @return publisher of body parts\n+     */\n+    static Publisher<? extends BodyPart> partsPublisher(String boundary, byte[]... chunks) {\n+        MultiPartDecoder decoder = MultiPartDecoder.create(boundary, MEDIA_CONTEXT.readerContext());\n+        chunksPublisher(chunks).subscribe(decoder);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e9d1a876a27e52a81c6921cffe786d5d5a1208d"}, "originalPosition": 494}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExNzA2Njg5", "url": "https://github.com/oracle/helidon/pull/1787#pullrequestreview-411706689", "createdAt": "2020-05-14T11:21:05Z", "commit": {"oid": "1e9d1a876a27e52a81c6921cffe786d5d5a1208d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxMToyMTowNVrOGVXuDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxMToyMTowNVrOGVXuDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA2MTkwMg==", "bodyText": "Its not required by spec, is there business reason for this check?", "url": "https://github.com/oracle/helidon/pull/1787#discussion_r425061902", "createdAt": "2020-05-14T11:21:05Z", "author": {"login": "danielkec"}, "path": "media/multipart/common/src/test/java/io/helidon/media/multipart/common/MultiPartDecoderTest.java", "diffHunk": "@@ -0,0 +1,571 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.helidon.media.multipart.common;\n+\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Flow.Publisher;\n+import java.util.concurrent.Flow.Subscriber;\n+import java.util.concurrent.Flow.Subscription;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import io.helidon.common.http.DataChunk;\n+import io.helidon.common.reactive.Multi;\n+\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.CoreMatchers.hasItems;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.CoreMatchers.nullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static io.helidon.media.multipart.common.BodyPartTest.MEDIA_CONTEXT;\n+\n+/**\n+ * Tests {@link MultiPartDecoder}.\n+ */\n+public class MultiPartDecoderTest {\n+\n+    private static final Logger LOGGER = Logger.getLogger(MultiPartDecoder.class.getName());\n+\n+    @BeforeAll\n+    public static void before() {\n+        LOGGER.setLevel(Level.ALL);\n+    }\n+\n+    @AfterAll\n+    public static void after() {\n+        LOGGER.setLevel(Level.INFO);\n+    }\n+\n+    @Test\n+    public void testOnePartInOneChunk() {\n+        String boundary = \"boundary\";\n+        final byte[] chunk1 = (\"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part1\\n\"\n+                + \"\\n\"\n+                + \"body 1\\n\"\n+                + \"--\" + boundary + \"--\").getBytes();\n+\n+        final CountDownLatch latch = new CountDownLatch(2);\n+        Consumer<BodyPart> consumer = (part) -> {\n+            latch.countDown();\n+            assertThat(part.headers().values(\"Content-Id\"),\n+                    hasItems(\"part1\"));\n+            DataChunkSubscriber subscriber = new DataChunkSubscriber();\n+            part.content().subscribe(subscriber);\n+            subscriber.content().thenAccept(body -> {\n+                latch.countDown();\n+                assertThat(body, is(equalTo(\"body 1\")));\n+            });\n+        };\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(\n+                SUBSCRIBER_TYPE.INFINITE, consumer);\n+        partsPublisher(boundary, chunk1).subscribe(testSubscriber);\n+        waitOnLatch(latch);\n+        assertThat(testSubscriber.error, is(nullValue()));\n+        assertThat(testSubscriber.complete, is(equalTo(true)));\n+    }\n+\n+    @Test\n+    public void testTwoPartsInOneChunk() {\n+        String boundary = \"boundary\";\n+        final byte[] chunk1 = (\"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part1\\n\"\n+                + \"\\n\"\n+                + \"body 1\\n\"\n+                + \"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part2\\n\"\n+                + \"\\n\"\n+                + \"body 2\\n\"\n+                + \"--\" + boundary + \"--\").getBytes();\n+\n+        final CountDownLatch latch = new CountDownLatch(4);\n+        Consumer<BodyPart> consumer = (part) -> {\n+            latch.countDown();\n+            if (latch.getCount() == 3) {\n+                assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part1\"));\n+                DataChunkSubscriber subscriber = new DataChunkSubscriber();\n+                part.content().subscribe(subscriber);\n+                subscriber.content().thenAccept(body -> {\n+                    latch.countDown();\n+                    assertThat(body, is(equalTo(\"body 1\")));\n+                });\n+            } else {\n+                assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part2\"));\n+                DataChunkSubscriber subscriber = new DataChunkSubscriber();\n+                part.content().subscribe(subscriber);\n+                subscriber.content().thenAccept(body -> {\n+                    latch.countDown();\n+                    assertThat(body, is(equalTo(\"body 2\")));\n+                });\n+            }\n+        };\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(SUBSCRIBER_TYPE.INFINITE, consumer);\n+        partsPublisher(boundary, chunk1).subscribe(testSubscriber);\n+        waitOnLatch(latch);\n+        assertThat(testSubscriber.error, is(nullValue()));\n+        assertThat(testSubscriber.complete, is(equalTo(true)));\n+    }\n+\n+    @Test\n+    public void testContentAcrossChunks() {\n+        String boundary = \"boundary\";\n+        final byte[] chunk1 = (\"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part1\\n\"\n+                + \"\\n\"\n+                + \"this-is-the-1st-slice-of-the-body\\n\").getBytes();\n+        final byte[] chunk2 = (\"this-is-the-2nd-slice-of-the-body\\n\"\n+                + \"--\" + boundary + \"--\").getBytes();\n+\n+        final CountDownLatch latch = new CountDownLatch(2);\n+        Consumer<BodyPart> consumer = (part) -> {\n+            latch.countDown();\n+            assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part1\"));\n+            DataChunkSubscriber subscriber = new DataChunkSubscriber();\n+            part.content().subscribe(subscriber);\n+            subscriber.content().thenAccept(body -> {\n+                latch.countDown();\n+                assertThat(body, is(equalTo(\n+                        \"this-is-the-1st-slice-of-the-body\\n\"\n+                        + \"this-is-the-2nd-slice-of-the-body\")));\n+            });\n+        };\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(SUBSCRIBER_TYPE.INFINITE, consumer);\n+        partsPublisher(boundary, chunk1, chunk2).subscribe(testSubscriber);\n+        waitOnLatch(latch);\n+        assertThat(testSubscriber.error, is(nullValue()));\n+        assertThat(testSubscriber.complete, is(equalTo(true)));\n+    }\n+\n+    @Test\n+    public void testMultipleChunksBeforeContent() {\n+        String boundary = \"boundary\";\n+        final byte[] chunk1 = (\"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part1\\n\").getBytes();\n+        final byte[] chunk2 = \"Content-Type: text/plain\\n\".getBytes();\n+        final byte[] chunk3 = \"Set-Cookie: bob=alice\\n\".getBytes();\n+        final byte[] chunk4 = \"Set-Cookie: foo=bar\\n\".getBytes();\n+        final byte[] chunk5 = (\"\\n\"\n+                + \"body 1\\n\"\n+                + \"--\" + boundary + \"--\").getBytes();\n+\n+        final CountDownLatch latch = new CountDownLatch(2);\n+        Consumer<BodyPart> consumer = (part) -> {\n+            latch.countDown();\n+            assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part1\"));\n+            assertThat(part.headers().values(\"Content-Type\"), hasItems(\"text/plain\"));\n+            assertThat(part.headers().values(\"Set-Cookie\"), hasItems(\"bob=alice\", \"foo=bar\"));\n+            DataChunkSubscriber subscriber = new DataChunkSubscriber();\n+            part.content().subscribe(subscriber);\n+            subscriber.content().thenAccept(body -> {\n+                latch.countDown();\n+                assertThat(body, is(equalTo(\"body 1\")));\n+            });\n+        };\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(SUBSCRIBER_TYPE.INFINITE, consumer);\n+        partsPublisher(boundary, chunk1, chunk2, chunk3, chunk4, chunk5).subscribe(testSubscriber);\n+        waitOnLatch(latch);\n+        assertThat(testSubscriber.error, is(nullValue()));\n+        assertThat(testSubscriber.complete, is(equalTo(true)));\n+    }\n+\n+    @Test\n+    public void testMulitiplePartsWithOneByOneSubscriber() {\n+        String boundary = \"boundary\";\n+        final byte[] chunk1 = (\"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part1\\n\"\n+                + \"\\n\"\n+                + \"body 1\\n\"\n+                + \"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part2\\n\"\n+                + \"\\n\"\n+                + \"body 2\\n\"\n+                + \"--\" + boundary + \"--\").getBytes();\n+\n+        final CountDownLatch latch = new CountDownLatch(4);\n+        Consumer<BodyPart> consumer = (part) -> {\n+            latch.countDown();\n+            if (latch.getCount()== 3) {\n+                assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part1\"));\n+                DataChunkSubscriber subscriber = new DataChunkSubscriber();\n+                part.content().subscribe(subscriber);\n+                subscriber.content().thenAccept(body -> {\n+                    latch.countDown();\n+                    assertThat(body, is(equalTo(\"body 1\")));\n+                });\n+            } else {\n+                assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part2\"));\n+                DataChunkSubscriber subscriber = new DataChunkSubscriber();\n+                part.content().subscribe(subscriber);\n+                subscriber.content().thenAccept(body -> {\n+                    latch.countDown();\n+                    assertThat(body, is(equalTo(\"body 2\")));\n+                });\n+            }\n+        };\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(SUBSCRIBER_TYPE.ONE_BY_ONE, consumer);\n+        partsPublisher(boundary, chunk1).subscribe(testSubscriber);\n+        waitOnLatch(latch);\n+        assertThat(testSubscriber.error, is(nullValue()));\n+        assertThat(testSubscriber.complete, is(equalTo(true)));\n+    }\n+\n+    @Test\n+    public void testSubscriberCancelAfterOnePart() {\n+        String boundary = \"boundary\";\n+        final byte[] chunk1 = (\"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part1\\n\"\n+                + \"\\n\"\n+                + \"body 1\\n\"\n+                + \"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part2\\n\"\n+                + \"\\n\"\n+                + \"body 2\\n\"\n+                + \"--\" + boundary + \"--\").getBytes();\n+\n+        final CountDownLatch latch = new CountDownLatch(2);\n+        Consumer<BodyPart> consumer = (part) -> {\n+            latch.countDown();\n+            if (latch.getCount()== 1) {\n+                assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part1\"));\n+                DataChunkSubscriber subscriber1 = new DataChunkSubscriber();\n+                part.content().subscribe(subscriber1);\n+                subscriber1.content().thenAccept(body -> {\n+                    latch.countDown();\n+                    assertThat(body, is(equalTo(\"body 1\")));\n+                });\n+            }\n+        };\n+\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(SUBSCRIBER_TYPE.CANCEL_AFTER_ONE, consumer);\n+        partsPublisher(boundary, chunk1).subscribe(testSubscriber);\n+        waitOnLatch(latch);\n+        assertThat(testSubscriber.error, is(nullValue()));\n+        assertThat(testSubscriber.complete, is(equalTo(false)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e9d1a876a27e52a81c6921cffe786d5d5a1208d"}, "originalPosition": 266}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExODA0OTQ4", "url": "https://github.com/oracle/helidon/pull/1787#pullrequestreview-411804948", "createdAt": "2020-05-14T13:30:26Z", "commit": {"oid": "1e9d1a876a27e52a81c6921cffe786d5d5a1208d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxMzozMDoyNlrOGVcVEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxMzozMDoyNlrOGVcVEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTEzNzQyNg==", "bodyText": "Decoder looks basically as a flatmap, I may be wrong but it should be possible to leave all the queuing in decoder to flatMap operator and simplify it considerably, so if this works:\n        Multi.from(chunksPublisher(chunk1))\n                .flatMap(chunk -> {\n                    var decoder = MultiPartDecoder.create(boundary, MEDIA_CONTEXT.readerContext());\n                    Single.just(chunk).subscribe(decoder);\n                    return decoder;\n                }).subscribe(testSubscriber);\nSomething like this should be possible:\n        var parser = new MIMEParser(boundary){\n            List<ReadableBodyPart> parse(DataChunk chunk){\n                ...\n            }\n        };\n        Multi.from(chunksPublisher(chunk1))\n                .flatMapIterable(parser::parse)\n                }).subscribe(testSubscriber);", "url": "https://github.com/oracle/helidon/pull/1787#discussion_r425137426", "createdAt": "2020-05-14T13:30:26Z", "author": {"login": "danielkec"}, "path": "media/multipart/common/src/test/java/io/helidon/media/multipart/common/MultiPartDecoderTest.java", "diffHunk": "@@ -0,0 +1,571 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.helidon.media.multipart.common;\n+\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Flow.Publisher;\n+import java.util.concurrent.Flow.Subscriber;\n+import java.util.concurrent.Flow.Subscription;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import io.helidon.common.http.DataChunk;\n+import io.helidon.common.reactive.Multi;\n+\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.CoreMatchers.hasItems;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.CoreMatchers.nullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static io.helidon.media.multipart.common.BodyPartTest.MEDIA_CONTEXT;\n+\n+/**\n+ * Tests {@link MultiPartDecoder}.\n+ */\n+public class MultiPartDecoderTest {\n+\n+    private static final Logger LOGGER = Logger.getLogger(MultiPartDecoder.class.getName());\n+\n+    @BeforeAll\n+    public static void before() {\n+        LOGGER.setLevel(Level.ALL);\n+    }\n+\n+    @AfterAll\n+    public static void after() {\n+        LOGGER.setLevel(Level.INFO);\n+    }\n+\n+    @Test\n+    public void testOnePartInOneChunk() {\n+        String boundary = \"boundary\";\n+        final byte[] chunk1 = (\"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part1\\n\"\n+                + \"\\n\"\n+                + \"body 1\\n\"\n+                + \"--\" + boundary + \"--\").getBytes();\n+\n+        final CountDownLatch latch = new CountDownLatch(2);\n+        Consumer<BodyPart> consumer = (part) -> {\n+            latch.countDown();\n+            assertThat(part.headers().values(\"Content-Id\"),\n+                    hasItems(\"part1\"));\n+            DataChunkSubscriber subscriber = new DataChunkSubscriber();\n+            part.content().subscribe(subscriber);\n+            subscriber.content().thenAccept(body -> {\n+                latch.countDown();\n+                assertThat(body, is(equalTo(\"body 1\")));\n+            });\n+        };\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(\n+                SUBSCRIBER_TYPE.INFINITE, consumer);\n+        partsPublisher(boundary, chunk1).subscribe(testSubscriber);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e9d1a876a27e52a81c6921cffe786d5d5a1208d"}, "originalPosition": 85}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExOTEzOTU2", "url": "https://github.com/oracle/helidon/pull/1787#pullrequestreview-411913956", "createdAt": "2020-05-14T15:20:19Z", "commit": {"oid": "1e9d1a876a27e52a81c6921cffe786d5d5a1208d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxNToyMDoxOVrOGVhY-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxNToyMDoxOVrOGVhY-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTIyMDM0NA==", "bodyText": "required_spec213_blackbox_onSubscribe_mustThrowNullPointerExceptionWhenParametersAreNull\nrequired_spec205_blackbox_mustCallSubscriptionCancelIfItAlreadyHasAnSubscriptionAndReceivesAnotherOnSubscribeSignal", "url": "https://github.com/oracle/helidon/pull/1787#discussion_r425220344", "createdAt": "2020-05-14T15:20:19Z", "author": {"login": "danielkec"}, "path": "media/multipart/common/src/main/java/io/helidon/media/multipart/common/MultiPartEncoder.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.helidon.media.multipart.common;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.Flow.Processor;\n+import java.util.concurrent.Flow.Subscriber;\n+import java.util.concurrent.Flow.Subscription;\n+\n+import io.helidon.common.http.DataChunk;\n+import io.helidon.common.reactive.OriginThreadPublisher;\n+import io.helidon.media.common.MessageBodyWriterContext;\n+\n+/**\n+ * Reactive processor that encodes a stream of {@link BodyPart} into an HTTP\n+ * payload. This processor is a single use publisher that supports a single\n+ * subscriber, it is not resumable.\n+ */\n+public final class MultiPartEncoder implements Processor<WriteableBodyPart, DataChunk> {\n+\n+    private Subscription partsSubscription;\n+    private BodyPartContentSubscriber contentSubscriber;\n+\n+    /**\n+     * The writer context.\n+     */\n+    private final MessageBodyWriterContext context;\n+\n+    /**\n+     * The boundary used for the generated multi-part message.\n+     */\n+    private final String boundary;\n+\n+    /**\n+     * Complete flag.\n+     */\n+    private volatile boolean complete;\n+\n+    /**\n+     * The downstream publisher.\n+     */\n+    private final MultiPartChunksPublisher downstream;\n+\n+    /**\n+     * Create a new multipart encoder.\n+     * @param boundary boundary string\n+     * @param context writer context\n+     */\n+    private MultiPartEncoder(String boundary, MessageBodyWriterContext context) {\n+        Objects.requireNonNull(boundary, \"boundary cannot be null!\");\n+        Objects.requireNonNull(context, \"context cannot be null!\");\n+        this.context = context;\n+        this.boundary = boundary;\n+        this.downstream = new MultiPartChunksPublisher();\n+        this.complete = false;\n+    }\n+\n+    /**\n+     * Create a new encoder instance.\n+     * @param boundary multipart boundary delimiter\n+     * @param context writer context\n+     * @return MultiPartEncoder\n+     */\n+    public static MultiPartEncoder create(String boundary, MessageBodyWriterContext context) {\n+        return new MultiPartEncoder(boundary, context);\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super DataChunk> subscriber) {\n+        downstream.subscribe(subscriber);\n+    }\n+\n+    @Override\n+    public void onSubscribe(Subscription subscription) {\n+        if (partsSubscription != null) {\n+            throw new IllegalStateException(\"Input subscription already set\");\n+        }\n+        partsSubscription = subscription;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e9d1a876a27e52a81c6921cffe786d5d5a1208d"}, "originalPosition": 96}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDExOTI5MTMy", "url": "https://github.com/oracle/helidon/pull/1787#pullrequestreview-411929132", "createdAt": "2020-05-14T15:35:27Z", "commit": {"oid": "1e9d1a876a27e52a81c6921cffe786d5d5a1208d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxNTozNToyOFrOGViG7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxNTozNToyOFrOGViG7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTIzMjEwOA==", "bodyText": "required_spec213_blackbox_onError_mustThrowNullPointerExceptionWhenParametersAreNull", "url": "https://github.com/oracle/helidon/pull/1787#discussion_r425232108", "createdAt": "2020-05-14T15:35:28Z", "author": {"login": "danielkec"}, "path": "media/multipart/common/src/main/java/io/helidon/media/multipart/common/MultiPartEncoder.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.helidon.media.multipart.common;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.Flow.Processor;\n+import java.util.concurrent.Flow.Subscriber;\n+import java.util.concurrent.Flow.Subscription;\n+\n+import io.helidon.common.http.DataChunk;\n+import io.helidon.common.reactive.OriginThreadPublisher;\n+import io.helidon.media.common.MessageBodyWriterContext;\n+\n+/**\n+ * Reactive processor that encodes a stream of {@link BodyPart} into an HTTP\n+ * payload. This processor is a single use publisher that supports a single\n+ * subscriber, it is not resumable.\n+ */\n+public final class MultiPartEncoder implements Processor<WriteableBodyPart, DataChunk> {\n+\n+    private Subscription partsSubscription;\n+    private BodyPartContentSubscriber contentSubscriber;\n+\n+    /**\n+     * The writer context.\n+     */\n+    private final MessageBodyWriterContext context;\n+\n+    /**\n+     * The boundary used for the generated multi-part message.\n+     */\n+    private final String boundary;\n+\n+    /**\n+     * Complete flag.\n+     */\n+    private volatile boolean complete;\n+\n+    /**\n+     * The downstream publisher.\n+     */\n+    private final MultiPartChunksPublisher downstream;\n+\n+    /**\n+     * Create a new multipart encoder.\n+     * @param boundary boundary string\n+     * @param context writer context\n+     */\n+    private MultiPartEncoder(String boundary, MessageBodyWriterContext context) {\n+        Objects.requireNonNull(boundary, \"boundary cannot be null!\");\n+        Objects.requireNonNull(context, \"context cannot be null!\");\n+        this.context = context;\n+        this.boundary = boundary;\n+        this.downstream = new MultiPartChunksPublisher();\n+        this.complete = false;\n+    }\n+\n+    /**\n+     * Create a new encoder instance.\n+     * @param boundary multipart boundary delimiter\n+     * @param context writer context\n+     * @return MultiPartEncoder\n+     */\n+    public static MultiPartEncoder create(String boundary, MessageBodyWriterContext context) {\n+        return new MultiPartEncoder(boundary, context);\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super DataChunk> subscriber) {\n+        downstream.subscribe(subscriber);\n+    }\n+\n+    @Override\n+    public void onSubscribe(Subscription subscription) {\n+        if (partsSubscription != null) {\n+            throw new IllegalStateException(\"Input subscription already set\");\n+        }\n+        partsSubscription = subscription;\n+    }\n+\n+    @Override\n+    public void onNext(WriteableBodyPart bodyPart) {\n+        Map<String, List<String>> headers = bodyPart.headers().toMap();\n+        StringBuilder sb = new StringBuilder();\n+\n+        // start boundary\n+        sb.append(\"--\").append(boundary).append(\"\\r\\n\");\n+\n+        // headers lines\n+        for (Map.Entry<String, List<String>> headerEntry : headers.entrySet()) {\n+\n+            String headerName = headerEntry.getKey();\n+            for (String headerValue : headerEntry.getValue()) {\n+                sb.append(headerName)\n+                        .append(\":\")\n+                        .append(headerValue)\n+                        .append(\"\\r\\n\");\n+            }\n+        }\n+\n+        // end of headers empty line\n+        sb.append(\"\\r\\n\");\n+        downstream.submit(sb.toString());\n+        contentSubscriber = new BodyPartContentSubscriber();\n+        bodyPart.content()\n+                .toPublisher(context)\n+                .subscribe(contentSubscriber);\n+    }\n+\n+    @Override\n+    public void onError(Throwable error) {\n+        downstream.error(error);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e9d1a876a27e52a81c6921cffe786d5d5a1208d"}, "originalPosition": 130}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEyODU2ODA1", "url": "https://github.com/oracle/helidon/pull/1787#pullrequestreview-412856805", "createdAt": "2020-05-15T18:00:01Z", "commit": {"oid": "1e9d1a876a27e52a81c6921cffe786d5d5a1208d"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxODowMDowMVrOGWOrNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxODowMDowMVrOGWOrNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk2MjI5Mg==", "bodyText": "Can you please rename to MimeParser? We adopt this in our APIs - even for cases when the original abbreviation is all capitals (such as MpConfig).", "url": "https://github.com/oracle/helidon/pull/1787#discussion_r425962292", "createdAt": "2020-05-15T18:00:01Z", "author": {"login": "tomas-langer"}, "path": "media/multipart/common/src/main/java/io/helidon/media/multipart/common/MIMEParser.java", "diffHunk": "@@ -0,0 +1,953 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.helidon.media.multipart.common;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.Charset;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+/**\n+ * Parser for multipart MIME message.\n+ */\n+final class MIMEParser {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e9d1a876a27e52a81c6921cffe786d5d5a1208d"}, "originalPosition": 29}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7f1d0a55ce1269619a3beb64906530266c9a7911", "author": {"user": {"login": "romain-grecourt", "name": "Romain Grecourt"}}, "url": "https://github.com/oracle/helidon/commit/7f1d0a55ce1269619a3beb64906530266c9a7911", "committedDate": "2020-05-16T03:21:59Z", "message": "Polish FileService, remove silly wrap methods\nRework body part release\nOptimize VirtualBuffer.getByte(int), use arrays instead of LinkedList\n\nrename MIMEParser to MimeParser\n\nuse SubscriptionHelper\n\nfix use of Optional\n\nreset all fields in VirtualBuffer.clear\n\nFix unit tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEzMDQzMTM0", "url": "https://github.com/oracle/helidon/pull/1787#pullrequestreview-413043134", "createdAt": "2020-05-16T03:29:04Z", "commit": {"oid": "7f1d0a55ce1269619a3beb64906530266c9a7911"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQwMzoyOTowNVrOGWX4qA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQwMzoyOTowNVrOGWX4qA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjExMzE5Mg==", "bodyText": "TODO move media/multipart/common to media/mutlipart", "url": "https://github.com/oracle/helidon/pull/1787#discussion_r426113192", "createdAt": "2020-05-16T03:29:05Z", "author": {"login": "romain-grecourt"}, "path": "media/multipart/common/pom.xml", "diffHunk": "@@ -0,0 +1,63 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f1d0a55ce1269619a3beb64906530266c9a7911"}, "originalPosition": 1}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f1e9607e9c521b59861059ab576389dbeaef41ec", "author": {"user": {"login": "romain-grecourt", "name": "Romain Grecourt"}}, "url": "https://github.com/oracle/helidon/commit/f1e9607e9c521b59861059ab576389dbeaef41ec", "committedDate": "2020-05-16T03:38:21Z", "message": "fix checkstyle errors"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4471a5fc8b2943cd737f2cd0abcf38175069d906", "author": {"user": {"login": "romain-grecourt", "name": "Romain Grecourt"}}, "url": "https://github.com/oracle/helidon/commit/4471a5fc8b2943cd737f2cd0abcf38175069d906", "committedDate": "2020-05-16T04:04:17Z", "message": "Rename MIMEParserTest to MimeParserTest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "293612c040551111d5f95d94694791fef9f7c32f", "author": {"user": {"login": "romain-grecourt", "name": "Romain Grecourt"}}, "url": "https://github.com/oracle/helidon/commit/293612c040551111d5f95d94694791fef9f7c32f", "committedDate": "2020-05-18T18:25:42Z", "message": "Merge remote-tracking branch 'origin/master' into multipart"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5dedfc9df13f1f51e9b13d8ece7d3f53903e956b", "author": {"user": {"login": "danielkec", "name": "Daniel Kec"}}, "url": "https://github.com/oracle/helidon/commit/5dedfc9df13f1f51e9b13d8ece7d3f53903e956b", "committedDate": "2020-05-19T00:07:24Z", "message": "Encoder with emitter (#3)\n\nSigned-off-by: Daniel Kec <daniel.kec@oracle.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6bc1b4f8f4b50321eca5075e034576a7f376964f", "author": {"user": {"login": "romain-grecourt", "name": "Romain Grecourt"}}, "url": "https://github.com/oracle/helidon/commit/6bc1b4f8f4b50321eca5075e034576a7f376964f", "committedDate": "2020-05-19T18:58:26Z", "message": "Update multipart reactive code to get rid of OriginThreadPublisher and use EmittingPublisher instead."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d77b9f54cbde461935a0093071b284c6a84c9671", "author": {"user": {"login": "danielkec", "name": "Daniel Kec"}}, "url": "https://github.com/oracle/helidon/commit/d77b9f54cbde461935a0093071b284c6a84c9671", "committedDate": "2020-05-19T19:30:04Z", "message": "BufferedEmittingPublisher as replacement for OriginThreadPublisher\n\nSigned-off-by: Daniel Kec <daniel.kec@oracle.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6ea60c7a0b2e11e949e89ccd9bae51b57f3e7be1", "author": {"user": {"login": "romain-grecourt", "name": "Romain Grecourt"}}, "url": "https://github.com/oracle/helidon/commit/6ea60c7a0b2e11e949e89ccd9bae51b57f3e7be1", "committedDate": "2020-05-20T02:00:28Z", "message": "Merge branch 'multipart' of github.com:romain-grecourt/helidon into multipart"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "881fff3382e410ef80a3ad5a689ff811244f93dd", "author": {"user": {"login": "romain-grecourt", "name": "Romain Grecourt"}}, "url": "https://github.com/oracle/helidon/commit/881fff3382e410ef80a3ad5a689ff811244f93dd", "committedDate": "2020-05-20T02:15:33Z", "message": "fix checkstyle and update style"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8876724810d8ed78679eb431b62027917d53a161", "author": {"user": {"login": "romain-grecourt", "name": "Romain Grecourt"}}, "url": "https://github.com/oracle/helidon/commit/8876724810d8ed78679eb431b62027917d53a161", "committedDate": "2020-05-20T02:33:15Z", "message": "add newline at the end of file"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bed4825c9bc61839264064a76cfb626b21b913ce", "author": {"user": {"login": "danielkec", "name": "Daniel Kec"}}, "url": "https://github.com/oracle/helidon/commit/bed4825c9bc61839264064a76cfb626b21b913ce", "committedDate": "2020-05-20T09:45:24Z", "message": "Cleanup\n\nSigned-off-by: Daniel Kec <daniel.kec@oracle.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "49c2177dc8d367276dbe0d21e9c99b4e597a1567", "author": {"user": {"login": "danielkec", "name": "Daniel Kec"}}, "url": "https://github.com/oracle/helidon/commit/49c2177dc8d367276dbe0d21e9c99b4e597a1567", "committedDate": "2020-05-20T11:21:33Z", "message": "Align with OTP use-cases\n\nSigned-off-by: Daniel Kec <daniel.kec@oracle.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "035083a9d295ed912535270ef5a925089cb409cb", "author": {"user": {"login": "danielkec", "name": "Daniel Kec"}}, "url": "https://github.com/oracle/helidon/commit/035083a9d295ed912535270ef5a925089cb409cb", "committedDate": "2020-05-20T11:27:53Z", "message": "Switch webclient to new OTP replacement\n\nSigned-off-by: Daniel Kec <daniel.kec@oracle.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a298a01fbef2b850852b86e218c6785c67207814", "author": {"user": {"login": "danielkec", "name": "Daniel Kec"}}, "url": "https://github.com/oracle/helidon/commit/a298a01fbef2b850852b86e218c6785c67207814", "committedDate": "2020-05-20T12:28:31Z", "message": "Noop emit for webclient workaround\n\nSigned-off-by: Daniel Kec <daniel.kec@oracle.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aac0d2c443b422e152d1c6daf609c9e0dff5d75a", "author": {"user": {"login": "danielkec", "name": "Daniel Kec"}}, "url": "https://github.com/oracle/helidon/commit/aac0d2c443b422e152d1c6daf609c9e0dff5d75a", "committedDate": "2020-05-20T12:30:13Z", "message": "Javadoc fix\n\nSigned-off-by: Daniel Kec <daniel.kec@oracle.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "30fcc8ee232c709756c51753fd415329a9247c15", "author": {"user": {"login": "danielkec", "name": "Daniel Kec"}}, "url": "https://github.com/oracle/helidon/commit/30fcc8ee232c709756c51753fd415329a9247c15", "committedDate": "2020-05-20T12:30:27Z", "message": "Noop emit for webclient workaround\n\nSigned-off-by: Daniel Kec <daniel.kec@oracle.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f5f17a18dbff54de25ab2d7d4de562832f469920", "author": {"user": {"login": "danielkec", "name": "Daniel Kec"}}, "url": "https://github.com/oracle/helidon/commit/f5f17a18dbff54de25ab2d7d4de562832f469920", "committedDate": "2020-05-20T12:58:23Z", "message": "Javadoc fix\n\nSigned-off-by: Daniel Kec <daniel.kec@oracle.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "34260917e90928a05ade689f0d69fa96943aebea", "author": {"user": {"login": "danielkec", "name": "Daniel Kec"}}, "url": "https://github.com/oracle/helidon/commit/34260917e90928a05ade689f0d69fa96943aebea", "committedDate": "2020-05-20T15:07:10Z", "message": "Switch webserver to new OTP replacement\n\nSigned-off-by: Daniel Kec <daniel.kec@oracle.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8bf8560559e98633de583722b6a6407557973201", "author": {"user": {"login": "danielkec", "name": "Daniel Kec"}}, "url": "https://github.com/oracle/helidon/commit/8bf8560559e98633de583722b6a6407557973201", "committedDate": "2020-05-20T18:33:40Z", "message": "OTP in webserver Jersey test fix\n\nSigned-off-by: Daniel Kec <daniel.kec@oracle.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "183fe7387df9f7ca30927661400adf1a0ceb903a", "author": {"user": {"login": "danielkec", "name": "Daniel Kec"}}, "url": "https://github.com/oracle/helidon/commit/183fe7387df9f7ca30927661400adf1a0ceb903a", "committedDate": "2020-05-20T20:44:51Z", "message": "Performance boost for unbounded use-cases\n\nSigned-off-by: Daniel Kec <daniel.kec@oracle.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e247007dc69dae440398437f2db0373da9041b1d", "author": {"user": {"login": "romain-grecourt", "name": "Romain Grecourt"}}, "url": "https://github.com/oracle/helidon/commit/e247007dc69dae440398437f2db0373da9041b1d", "committedDate": "2020-05-21T00:14:54Z", "message": "TCK passing for both encoder and decoder"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e1c8643472a621247688e148f9dda9e6ceec7a12", "author": {"user": {"login": "romain-grecourt", "name": "Romain Grecourt"}}, "url": "https://github.com/oracle/helidon/commit/e1c8643472a621247688e148f9dda9e6ceec7a12", "committedDate": "2020-05-21T00:25:52Z", "message": "update example to compile after the refactoring from io.helidon.media.multipart.common to io.helidon.media.multipart"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cef832fdd7ce7f3ee4582fcf70c612b9184e5b75", "author": {"user": {"login": "romain-grecourt", "name": "Romain Grecourt"}}, "url": "https://github.com/oracle/helidon/commit/cef832fdd7ce7f3ee4582fcf70c612b9184e5b75", "committedDate": "2020-05-21T00:29:54Z", "message": "Merge remote-tracking branch 'danielkec/emitter' into multipart"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "21469fd10947a7fbffed0d898794df1445c161ec", "author": {"user": {"login": "romain-grecourt", "name": "Romain Grecourt"}}, "url": "https://github.com/oracle/helidon/commit/21469fd10947a7fbffed0d898794df1445c161ec", "committedDate": "2020-05-21T03:38:05Z", "message": "rebase multipart on top of the buffered emitter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7543139d2aba4cebac344647578979f20824b722", "author": {"user": {"login": "romain-grecourt", "name": "Romain Grecourt"}}, "url": "https://github.com/oracle/helidon/commit/7543139d2aba4cebac344647578979f20824b722", "committedDate": "2020-05-21T04:07:24Z", "message": "update javadocs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1029093bf21acf318aaeaab8f9844749e7176829", "author": {"user": {"login": "romain-grecourt", "name": "Romain Grecourt"}}, "url": "https://github.com/oracle/helidon/commit/1029093bf21acf318aaeaab8f9844749e7176829", "committedDate": "2020-05-21T04:14:52Z", "message": "remove javadoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6ff433b3f18c4a4917df6b82b25235a7d27a31cd", "author": {"user": {"login": "romain-grecourt", "name": "Romain Grecourt"}}, "url": "https://github.com/oracle/helidon/commit/6ff433b3f18c4a4917df6b82b25235a7d27a31cd", "committedDate": "2020-05-21T04:18:11Z", "message": "fix checkstyle"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f8a33c5070d95746804b215c457cf256ae526335", "author": {"user": {"login": "romain-grecourt", "name": "Romain Grecourt"}}, "url": "https://github.com/oracle/helidon/commit/f8a33c5070d95746804b215c457cf256ae526335", "committedDate": "2020-05-21T06:56:27Z", "message": "fix EmittingPublisherTest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a1f2f2991c57ec107e7d1e8280d7577f0daa4c70", "author": {"user": {"login": "danielkec", "name": "Daniel Kec"}}, "url": "https://github.com/oracle/helidon/commit/a1f2f2991c57ec107e7d1e8280d7577f0daa4c70", "committedDate": "2020-05-21T08:34:32Z", "message": "Another performance boost\n\nSigned-off-by: Daniel Kec <daniel.kec@oracle.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9eeab8c2d43739e4f1eef97feb5ff83fe4f8187d", "author": {"user": {"login": "danielkec", "name": "Daniel Kec"}}, "url": "https://github.com/oracle/helidon/commit/9eeab8c2d43739e4f1eef97feb5ff83fe4f8187d", "committedDate": "2020-05-21T15:11:11Z", "message": "Cleanup and review issues\n\nSigned-off-by: Daniel Kec <daniel.kec@oracle.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ea9da46dceef61a25bd55e31fd13d41a6cff6cbe", "author": {"user": {"login": "danielkec", "name": "Daniel Kec"}}, "url": "https://github.com/oracle/helidon/commit/ea9da46dceef61a25bd55e31fd13d41a6cff6cbe", "committedDate": "2020-05-21T16:28:17Z", "message": "Kafka connector with new emitter\n\nSigned-off-by: Daniel Kec <daniel.kec@oracle.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6251d7781d79a73a48e2ba14e9b1ac0ba1ae7d01", "author": {"user": {"login": "romain-grecourt", "name": "Romain Grecourt"}}, "url": "https://github.com/oracle/helidon/commit/6251d7781d79a73a48e2ba14e9b1ac0ba1ae7d01", "committedDate": "2020-05-21T18:22:11Z", "message": "Merge remote-tracking branch 'danielkec/emitter' into multipart"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a7d538f285eee454f55f303414da01e3df4e2f4d", "author": {"user": {"login": "romain-grecourt", "name": "Romain Grecourt"}}, "url": "https://github.com/oracle/helidon/commit/a7d538f285eee454f55f303414da01e3df4e2f4d", "committedDate": "2020-05-21T21:30:38Z", "message": "Remove MessageBodyWriteableContent and fallback variants of MessageBodyWriterContext.marshall\nReplace MessageBodyWriteableContent with WriteableBodyPartContent that does support a writer context (i.e registerWriter methods)\nSimplified WriteableBodyPart.Builder by implementing 3 variants of WriteableBodyPartContent for the 3 types of data sources (raw publisher, entity, entity stream)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "54e30229f2fb8066064dd036da847bb260715de2", "author": {"user": {"login": "romain-grecourt", "name": "Romain Grecourt"}}, "url": "https://github.com/oracle/helidon/commit/54e30229f2fb8066064dd036da847bb260715de2", "committedDate": "2020-05-21T22:37:00Z", "message": "fix checkstyle errors"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e10feda18f20354801c8ba71e45a8fc4eac01971", "author": {"user": {"login": "romain-grecourt", "name": "Romain Grecourt"}}, "url": "https://github.com/oracle/helidon/commit/e10feda18f20354801c8ba71e45a8fc4eac01971", "committedDate": "2020-05-21T23:22:31Z", "message": "fix leftover usage of marshallStream with fallback"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3MDY4Njc5", "url": "https://github.com/oracle/helidon/pull/1787#pullrequestreview-417068679", "createdAt": "2020-05-22T17:16:49Z", "commit": {"oid": "e10feda18f20354801c8ba71e45a8fc4eac01971"}, "state": "DISMISSED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e2238bf0c3c7b50037855334b14aae462e59a223", "author": {"user": {"login": "romain-grecourt", "name": "Romain Grecourt"}}, "url": "https://github.com/oracle/helidon/commit/e2238bf0c3c7b50037855334b14aae462e59a223", "committedDate": "2020-05-22T23:44:02Z", "message": "Merge remote-tracking branch 'origin/master' into multipart"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "119c508fd84172a5449ec8fec12112e17947a7f2", "author": {"user": {"login": "romain-grecourt", "name": "Romain Grecourt"}}, "url": "https://github.com/oracle/helidon/commit/119c508fd84172a5449ec8fec12112e17947a7f2", "committedDate": "2020-05-23T00:32:23Z", "message": "comment-out onCancel for now"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE4NTMxODM3", "url": "https://github.com/oracle/helidon/pull/1787#pullrequestreview-418531837", "createdAt": "2020-05-26T17:43:26Z", "commit": {"oid": "119c508fd84172a5449ec8fec12112e17947a7f2"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE4NTYwNzAz", "url": "https://github.com/oracle/helidon/pull/1787#pullrequestreview-418560703", "createdAt": "2020-05-26T18:20:40Z", "commit": {"oid": "119c508fd84172a5449ec8fec12112e17947a7f2"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 784, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}