{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM1Mjg5MTc3", "number": 2591, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxODoxOToxMlrOFDEaBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQyMDoxNjoyMlrOFDqf_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NzYyMjQ0OnYy", "diffSide": "RIGHT", "path": "webserver/webserver/src/main/java/io/helidon/webserver/BareResponseImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxODoxOToxMlrOICi11w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxODozNToyOVrOICjiEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTUzODkwMw==", "bodyText": "Readability nit: prev should probably be something like previousRequestFuture to \"look like\", e.g., responseFuture, headersFuture, etc.", "url": "https://github.com/oracle/helidon/pull/2591#discussion_r539538903", "createdAt": "2020-12-09T18:19:12Z", "author": {"login": "ljnelson"}, "path": "webserver/webserver/src/main/java/io/helidon/webserver/BareResponseImpl.java", "diffHunk": "@@ -79,27 +78,28 @@\n     private volatile DefaultHttpResponse response;\n     private volatile boolean lengthOptimization;\n     private volatile boolean isWebSocketUpgrade = false;\n+    private CompletableFuture<?> prev;\n \n     /**\n      * @param ctx the channel handler context\n      * @param request the request\n      * @param requestContentConsumed whether the request content is consumed\n-     * @param thread the outbound event loop thread which will be used to write the response\n+     * @param prev Future that represents previous request completion for HTTP pipelining\n      * @param requestId the correlation ID that is added to the log statements\n      */\n     BareResponseImpl(ChannelHandlerContext ctx,\n                      HttpRequest request,\n                      BooleanSupplier requestContentConsumed,\n-                     Thread thread,\n+                     CompletableFuture<?> prev,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45963f04d7432f5a76ffd445b305c188df67396a"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU1MDIyNw==", "bodyText": "Good point", "url": "https://github.com/oracle/helidon/pull/2591#discussion_r539550227", "createdAt": "2020-12-09T18:35:29Z", "author": {"login": "spericas"}, "path": "webserver/webserver/src/main/java/io/helidon/webserver/BareResponseImpl.java", "diffHunk": "@@ -79,27 +78,28 @@\n     private volatile DefaultHttpResponse response;\n     private volatile boolean lengthOptimization;\n     private volatile boolean isWebSocketUpgrade = false;\n+    private CompletableFuture<?> prev;\n \n     /**\n      * @param ctx the channel handler context\n      * @param request the request\n      * @param requestContentConsumed whether the request content is consumed\n-     * @param thread the outbound event loop thread which will be used to write the response\n+     * @param prev Future that represents previous request completion for HTTP pipelining\n      * @param requestId the correlation ID that is added to the log statements\n      */\n     BareResponseImpl(ChannelHandlerContext ctx,\n                      HttpRequest request,\n                      BooleanSupplier requestContentConsumed,\n-                     Thread thread,\n+                     CompletableFuture<?> prev,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTUzODkwMw=="}, "originalCommit": {"oid": "45963f04d7432f5a76ffd445b305c188df67396a"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NzY0MDk4OnYy", "diffSide": "RIGHT", "path": "webserver/webserver/src/test/java/io/helidon/webserver/HttpPipelineTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxODoyMzoxM1rOICjA7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxODozNjoyNlrOICjkgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU0MTc0MA==", "bodyText": "await(10, TimeUnit.SECONDS)", "url": "https://github.com/oracle/helidon/pull/2591#discussion_r539541740", "createdAt": "2020-12-09T18:23:13Z", "author": {"login": "danielkec"}, "path": "webserver/webserver/src/test/java/io/helidon/webserver/HttpPipelineTest.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.webserver;\n+\n+import javax.net.ssl.X509TrustManager;\n+import java.io.IOException;\n+import java.net.URL;\n+import java.security.cert.X509Certificate;\n+import java.util.Collections;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.logging.Logger;\n+\n+import io.helidon.common.http.Http;\n+import io.helidon.webserver.utils.SocketHttpClient;\n+\n+import okhttp3.Call;\n+import okhttp3.Callback;\n+import okhttp3.Interceptor;\n+import okhttp3.MediaType;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Protocol;\n+import okhttp3.Request;\n+import okhttp3.RequestBody;\n+import okhttp3.Response;\n+\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.CoreMatchers.containsString;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+\n+/**\n+ * Test support for HTTP 1.1 pipelining.\n+ */\n+public class HttpPipelineTest {\n+    private static final Logger LOGGER = Logger.getLogger(HttpPipelineTest.class.getName());\n+\n+    private static WebServer webServer;\n+    private static AtomicInteger counter = new AtomicInteger(0);\n+    private static ScheduledExecutorService executor = new ScheduledThreadPoolExecutor(1);\n+    private static OkHttpClient client;\n+\n+    private static class LoggingInterceptor implements Interceptor {\n+        @Override\n+        public okhttp3.Response intercept(Interceptor.Chain chain) throws IOException {\n+            Request request = chain.request();\n+\n+            long t1 = System.nanoTime();\n+            System.out.println(String.format(\"Sending request %s on %s%n%s\",\n+                    request.url(), chain.connection(), request.headers()));\n+\n+            Response response = chain.proceed(request);\n+\n+            long t2 = System.nanoTime();\n+            System.out.println(String.format(\"Received response for %s in %.1fms%nProtocol is %s%n%s\",\n+                    response.request().url(), (t2 - t1) / 1e6d, response.protocol(), response.headers()));\n+\n+            return response;\n+        }\n+    }\n+\n+    @BeforeAll\n+    public static void startServer() throws Exception {\n+        startServer(0);\n+    }\n+\n+    @AfterAll\n+    public static void close() throws Exception {\n+        if (webServer != null) {\n+            webServer.shutdown()\n+                    .toCompletableFuture()\n+                    .get(10, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private static void startServer(int port) throws Exception {\n+        webServer = WebServer.builder()\n+                .experimental(ExperimentalConfiguration.builder().http2(\n+                        Http2Configuration.builder().enable(true).build()).build())\n+                .port(port)\n+                .routing(Routing.builder()\n+                        .put(\"/\", (req, res) -> {\n+                            counter.set(0);\n+                            res.send();\n+                        })\n+                        .get(\"/\", (req, res) -> {\n+                            int n = counter.getAndIncrement();\n+                            int delay = (n % 2 == 0) ? 1000 : 0;    // alternate delay 1 second and no delay\n+                            executor.schedule(() -> res.status(Http.Status.OK_200).send(\"Response \" + n + \"\\n\"),\n+                                    delay, TimeUnit.MILLISECONDS);\n+                        })\n+                        .build())\n+                .build()\n+                .start()\n+                .toCompletableFuture()\n+                .get(10, TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45963f04d7432f5a76ffd445b305c188df67396a"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU1MDg1MA==", "bodyText": "Copy/paste, yes too long.", "url": "https://github.com/oracle/helidon/pull/2591#discussion_r539550850", "createdAt": "2020-12-09T18:36:26Z", "author": {"login": "spericas"}, "path": "webserver/webserver/src/test/java/io/helidon/webserver/HttpPipelineTest.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.webserver;\n+\n+import javax.net.ssl.X509TrustManager;\n+import java.io.IOException;\n+import java.net.URL;\n+import java.security.cert.X509Certificate;\n+import java.util.Collections;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.logging.Logger;\n+\n+import io.helidon.common.http.Http;\n+import io.helidon.webserver.utils.SocketHttpClient;\n+\n+import okhttp3.Call;\n+import okhttp3.Callback;\n+import okhttp3.Interceptor;\n+import okhttp3.MediaType;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Protocol;\n+import okhttp3.Request;\n+import okhttp3.RequestBody;\n+import okhttp3.Response;\n+\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.CoreMatchers.containsString;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+\n+/**\n+ * Test support for HTTP 1.1 pipelining.\n+ */\n+public class HttpPipelineTest {\n+    private static final Logger LOGGER = Logger.getLogger(HttpPipelineTest.class.getName());\n+\n+    private static WebServer webServer;\n+    private static AtomicInteger counter = new AtomicInteger(0);\n+    private static ScheduledExecutorService executor = new ScheduledThreadPoolExecutor(1);\n+    private static OkHttpClient client;\n+\n+    private static class LoggingInterceptor implements Interceptor {\n+        @Override\n+        public okhttp3.Response intercept(Interceptor.Chain chain) throws IOException {\n+            Request request = chain.request();\n+\n+            long t1 = System.nanoTime();\n+            System.out.println(String.format(\"Sending request %s on %s%n%s\",\n+                    request.url(), chain.connection(), request.headers()));\n+\n+            Response response = chain.proceed(request);\n+\n+            long t2 = System.nanoTime();\n+            System.out.println(String.format(\"Received response for %s in %.1fms%nProtocol is %s%n%s\",\n+                    response.request().url(), (t2 - t1) / 1e6d, response.protocol(), response.headers()));\n+\n+            return response;\n+        }\n+    }\n+\n+    @BeforeAll\n+    public static void startServer() throws Exception {\n+        startServer(0);\n+    }\n+\n+    @AfterAll\n+    public static void close() throws Exception {\n+        if (webServer != null) {\n+            webServer.shutdown()\n+                    .toCompletableFuture()\n+                    .get(10, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private static void startServer(int port) throws Exception {\n+        webServer = WebServer.builder()\n+                .experimental(ExperimentalConfiguration.builder().http2(\n+                        Http2Configuration.builder().enable(true).build()).build())\n+                .port(port)\n+                .routing(Routing.builder()\n+                        .put(\"/\", (req, res) -> {\n+                            counter.set(0);\n+                            res.send();\n+                        })\n+                        .get(\"/\", (req, res) -> {\n+                            int n = counter.getAndIncrement();\n+                            int delay = (n % 2 == 0) ? 1000 : 0;    // alternate delay 1 second and no delay\n+                            executor.schedule(() -> res.status(Http.Status.OK_200).send(\"Response \" + n + \"\\n\"),\n+                                    delay, TimeUnit.MILLISECONDS);\n+                        })\n+                        .build())\n+                .build()\n+                .start()\n+                .toCompletableFuture()\n+                .get(10, TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU0MTc0MA=="}, "originalCommit": {"oid": "45963f04d7432f5a76ffd445b305c188df67396a"}, "originalPosition": 118}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NzY2MTc1OnYy", "diffSide": "RIGHT", "path": "webserver/webserver/src/test/java/io/helidon/webserver/HttpPipelineTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxODoyNzo0NFrOICjNMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxODozNzozM1rOICjnmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU0NDg4Mw==", "bodyText": "Will be the assertion error thrown on correct thread?", "url": "https://github.com/oracle/helidon/pull/2591#discussion_r539544883", "createdAt": "2020-12-09T18:27:44Z", "author": {"login": "danielkec"}, "path": "webserver/webserver/src/test/java/io/helidon/webserver/HttpPipelineTest.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.webserver;\n+\n+import javax.net.ssl.X509TrustManager;\n+import java.io.IOException;\n+import java.net.URL;\n+import java.security.cert.X509Certificate;\n+import java.util.Collections;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.logging.Logger;\n+\n+import io.helidon.common.http.Http;\n+import io.helidon.webserver.utils.SocketHttpClient;\n+\n+import okhttp3.Call;\n+import okhttp3.Callback;\n+import okhttp3.Interceptor;\n+import okhttp3.MediaType;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Protocol;\n+import okhttp3.Request;\n+import okhttp3.RequestBody;\n+import okhttp3.Response;\n+\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.CoreMatchers.containsString;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+\n+/**\n+ * Test support for HTTP 1.1 pipelining.\n+ */\n+public class HttpPipelineTest {\n+    private static final Logger LOGGER = Logger.getLogger(HttpPipelineTest.class.getName());\n+\n+    private static WebServer webServer;\n+    private static AtomicInteger counter = new AtomicInteger(0);\n+    private static ScheduledExecutorService executor = new ScheduledThreadPoolExecutor(1);\n+    private static OkHttpClient client;\n+\n+    private static class LoggingInterceptor implements Interceptor {\n+        @Override\n+        public okhttp3.Response intercept(Interceptor.Chain chain) throws IOException {\n+            Request request = chain.request();\n+\n+            long t1 = System.nanoTime();\n+            System.out.println(String.format(\"Sending request %s on %s%n%s\",\n+                    request.url(), chain.connection(), request.headers()));\n+\n+            Response response = chain.proceed(request);\n+\n+            long t2 = System.nanoTime();\n+            System.out.println(String.format(\"Received response for %s in %.1fms%nProtocol is %s%n%s\",\n+                    response.request().url(), (t2 - t1) / 1e6d, response.protocol(), response.headers()));\n+\n+            return response;\n+        }\n+    }\n+\n+    @BeforeAll\n+    public static void startServer() throws Exception {\n+        startServer(0);\n+    }\n+\n+    @AfterAll\n+    public static void close() throws Exception {\n+        if (webServer != null) {\n+            webServer.shutdown()\n+                    .toCompletableFuture()\n+                    .get(10, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private static void startServer(int port) throws Exception {\n+        webServer = WebServer.builder()\n+                .experimental(ExperimentalConfiguration.builder().http2(\n+                        Http2Configuration.builder().enable(true).build()).build())\n+                .port(port)\n+                .routing(Routing.builder()\n+                        .put(\"/\", (req, res) -> {\n+                            counter.set(0);\n+                            res.send();\n+                        })\n+                        .get(\"/\", (req, res) -> {\n+                            int n = counter.getAndIncrement();\n+                            int delay = (n % 2 == 0) ? 1000 : 0;    // alternate delay 1 second and no delay\n+                            executor.schedule(() -> res.status(Http.Status.OK_200).send(\"Response \" + n + \"\\n\"),\n+                                    delay, TimeUnit.MILLISECONDS);\n+                        })\n+                        .build())\n+                .build()\n+                .start()\n+                .toCompletableFuture()\n+                .get(10, TimeUnit.SECONDS);\n+\n+        OkHttpClient.Builder clientBuilder = new OkHttpClient.Builder()\n+                .addNetworkInterceptor(new LoggingInterceptor())\n+                .protocols(Collections.singletonList(Protocol.H2_PRIOR_KNOWLEDGE));\n+        client = clientBuilder.build();\n+\n+        LOGGER.info(\"Started server at: https://localhost:\" + webServer.port());\n+    }\n+\n+    /**\n+     * Pipelines request_0 and request_1 and makes sure responses are returned in the\n+     * correct order. Note that the server will delay the response for request_0 to\n+     * make sure they are properly synchronized.\n+     *\n+     * @throws Exception If there are connection problems.\n+     */\n+    @Test\n+    public void testPipelining() throws Exception {\n+        try (SocketHttpClient s = new SocketHttpClient(webServer)) {\n+            s.request(Http.Method.PUT, \"/\");        // reset server\n+            s.request(Http.Method.GET, \"/\");        // request_0\n+            s.request(Http.Method.GET, \"/\");        // request_1\n+            String put = s.receive();\n+            assertThat(put, notNullValue());\n+            String get0 = s.receive();\n+            assertThat(get0, containsString(\"Response 0\"));\n+            String get1 = s.receive();\n+            assertThat(get1, containsString(\"Response 1\"));\n+        }\n+    }\n+\n+    /**\n+     * Same as previous test but using HTTP/2 and OkHttp as async client.\n+     */\n+    @Test\n+    public void testPipeliningHttp2() throws Exception {\n+        MediaType mt = MediaType.get(\"text/plain\");\n+        URL url = new URL(\"http://localhost:\" + webServer.port() + \"/\");\n+        Request put = new Request.Builder().url(url).put(RequestBody.create(mt, \"\")).build();\n+        client.newCall(put).execute();\n+\n+        Request get = new Request.Builder().url(url).build();\n+        CompletableFuture<?> cf0 = new CompletableFuture<>();\n+        CompletableFuture<?> cf1 = new CompletableFuture<>();\n+\n+        client.newCall(get).enqueue(new Callback() {\n+            @Override\n+            public void onFailure(Call call, IOException e) {\n+                cf0.completeExceptionally(e);\n+            }\n+\n+            @Override\n+            public void onResponse(Call call, Response r0) throws IOException {\n+                LOGGER.info(\"Received r0\");\n+                if (cf1.isDone()) {\n+                    LOGGER.info(\"Expected r0 before r1\");\n+                    cf0.completeExceptionally(new RuntimeException(\"Expected r0 before r1\"));\n+                } else {\n+                    assertThat(r0.body().string(), containsString(\"Response 0\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45963f04d7432f5a76ffd445b305c188df67396a"}, "originalPosition": 177}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU1MTY0Mg==", "bodyText": "No, will fix this.", "url": "https://github.com/oracle/helidon/pull/2591#discussion_r539551642", "createdAt": "2020-12-09T18:37:33Z", "author": {"login": "spericas"}, "path": "webserver/webserver/src/test/java/io/helidon/webserver/HttpPipelineTest.java", "diffHunk": "@@ -0,0 +1,204 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.webserver;\n+\n+import javax.net.ssl.X509TrustManager;\n+import java.io.IOException;\n+import java.net.URL;\n+import java.security.cert.X509Certificate;\n+import java.util.Collections;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.logging.Logger;\n+\n+import io.helidon.common.http.Http;\n+import io.helidon.webserver.utils.SocketHttpClient;\n+\n+import okhttp3.Call;\n+import okhttp3.Callback;\n+import okhttp3.Interceptor;\n+import okhttp3.MediaType;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Protocol;\n+import okhttp3.Request;\n+import okhttp3.RequestBody;\n+import okhttp3.Response;\n+\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.CoreMatchers.containsString;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+\n+/**\n+ * Test support for HTTP 1.1 pipelining.\n+ */\n+public class HttpPipelineTest {\n+    private static final Logger LOGGER = Logger.getLogger(HttpPipelineTest.class.getName());\n+\n+    private static WebServer webServer;\n+    private static AtomicInteger counter = new AtomicInteger(0);\n+    private static ScheduledExecutorService executor = new ScheduledThreadPoolExecutor(1);\n+    private static OkHttpClient client;\n+\n+    private static class LoggingInterceptor implements Interceptor {\n+        @Override\n+        public okhttp3.Response intercept(Interceptor.Chain chain) throws IOException {\n+            Request request = chain.request();\n+\n+            long t1 = System.nanoTime();\n+            System.out.println(String.format(\"Sending request %s on %s%n%s\",\n+                    request.url(), chain.connection(), request.headers()));\n+\n+            Response response = chain.proceed(request);\n+\n+            long t2 = System.nanoTime();\n+            System.out.println(String.format(\"Received response for %s in %.1fms%nProtocol is %s%n%s\",\n+                    response.request().url(), (t2 - t1) / 1e6d, response.protocol(), response.headers()));\n+\n+            return response;\n+        }\n+    }\n+\n+    @BeforeAll\n+    public static void startServer() throws Exception {\n+        startServer(0);\n+    }\n+\n+    @AfterAll\n+    public static void close() throws Exception {\n+        if (webServer != null) {\n+            webServer.shutdown()\n+                    .toCompletableFuture()\n+                    .get(10, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private static void startServer(int port) throws Exception {\n+        webServer = WebServer.builder()\n+                .experimental(ExperimentalConfiguration.builder().http2(\n+                        Http2Configuration.builder().enable(true).build()).build())\n+                .port(port)\n+                .routing(Routing.builder()\n+                        .put(\"/\", (req, res) -> {\n+                            counter.set(0);\n+                            res.send();\n+                        })\n+                        .get(\"/\", (req, res) -> {\n+                            int n = counter.getAndIncrement();\n+                            int delay = (n % 2 == 0) ? 1000 : 0;    // alternate delay 1 second and no delay\n+                            executor.schedule(() -> res.status(Http.Status.OK_200).send(\"Response \" + n + \"\\n\"),\n+                                    delay, TimeUnit.MILLISECONDS);\n+                        })\n+                        .build())\n+                .build()\n+                .start()\n+                .toCompletableFuture()\n+                .get(10, TimeUnit.SECONDS);\n+\n+        OkHttpClient.Builder clientBuilder = new OkHttpClient.Builder()\n+                .addNetworkInterceptor(new LoggingInterceptor())\n+                .protocols(Collections.singletonList(Protocol.H2_PRIOR_KNOWLEDGE));\n+        client = clientBuilder.build();\n+\n+        LOGGER.info(\"Started server at: https://localhost:\" + webServer.port());\n+    }\n+\n+    /**\n+     * Pipelines request_0 and request_1 and makes sure responses are returned in the\n+     * correct order. Note that the server will delay the response for request_0 to\n+     * make sure they are properly synchronized.\n+     *\n+     * @throws Exception If there are connection problems.\n+     */\n+    @Test\n+    public void testPipelining() throws Exception {\n+        try (SocketHttpClient s = new SocketHttpClient(webServer)) {\n+            s.request(Http.Method.PUT, \"/\");        // reset server\n+            s.request(Http.Method.GET, \"/\");        // request_0\n+            s.request(Http.Method.GET, \"/\");        // request_1\n+            String put = s.receive();\n+            assertThat(put, notNullValue());\n+            String get0 = s.receive();\n+            assertThat(get0, containsString(\"Response 0\"));\n+            String get1 = s.receive();\n+            assertThat(get1, containsString(\"Response 1\"));\n+        }\n+    }\n+\n+    /**\n+     * Same as previous test but using HTTP/2 and OkHttp as async client.\n+     */\n+    @Test\n+    public void testPipeliningHttp2() throws Exception {\n+        MediaType mt = MediaType.get(\"text/plain\");\n+        URL url = new URL(\"http://localhost:\" + webServer.port() + \"/\");\n+        Request put = new Request.Builder().url(url).put(RequestBody.create(mt, \"\")).build();\n+        client.newCall(put).execute();\n+\n+        Request get = new Request.Builder().url(url).build();\n+        CompletableFuture<?> cf0 = new CompletableFuture<>();\n+        CompletableFuture<?> cf1 = new CompletableFuture<>();\n+\n+        client.newCall(get).enqueue(new Callback() {\n+            @Override\n+            public void onFailure(Call call, IOException e) {\n+                cf0.completeExceptionally(e);\n+            }\n+\n+            @Override\n+            public void onResponse(Call call, Response r0) throws IOException {\n+                LOGGER.info(\"Received r0\");\n+                if (cf1.isDone()) {\n+                    LOGGER.info(\"Expected r0 before r1\");\n+                    cf0.completeExceptionally(new RuntimeException(\"Expected r0 before r1\"));\n+                } else {\n+                    assertThat(r0.body().string(), containsString(\"Response 0\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU0NDg4Mw=="}, "originalCommit": {"oid": "45963f04d7432f5a76ffd445b305c188df67396a"}, "originalPosition": 177}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NzY5ODU1OnYy", "diffSide": "RIGHT", "path": "webserver/webserver/pom.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxODozNTo0OVrOICjjCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxODozOToxMlrOICjr_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU1MDQ3Mw==", "bodyText": "Why do you have to specify the version, isn't that managed by the helidon-project parent pom ?", "url": "https://github.com/oracle/helidon/pull/2591#discussion_r539550473", "createdAt": "2020-12-09T18:35:49Z", "author": {"login": "romain-grecourt"}, "path": "webserver/webserver/pom.xml", "diffHunk": "@@ -161,5 +161,11 @@\n             <artifactId>helidon-config-testing</artifactId>\n             <scope>test</scope>\n         </dependency>\n+        <dependency>\n+            <groupId>com.squareup.okhttp3</groupId>\n+            <artifactId>okhttp</artifactId>\n+            <version>${version.lib.okhttp3}</version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "45963f04d7432f5a76ffd445b305c188df67396a"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU1Mjc2Ng==", "bodyText": "Will drop version.", "url": "https://github.com/oracle/helidon/pull/2591#discussion_r539552766", "createdAt": "2020-12-09T18:39:12Z", "author": {"login": "spericas"}, "path": "webserver/webserver/pom.xml", "diffHunk": "@@ -161,5 +161,11 @@\n             <artifactId>helidon-config-testing</artifactId>\n             <scope>test</scope>\n         </dependency>\n+        <dependency>\n+            <groupId>com.squareup.okhttp3</groupId>\n+            <artifactId>okhttp</artifactId>\n+            <version>${version.lib.okhttp3}</version>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU1MDQ3Mw=="}, "originalCommit": {"oid": "45963f04d7432f5a76ffd445b305c188df67396a"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4Nzc2Njk3OnYy", "diffSide": "RIGHT", "path": "webserver/webserver/src/main/java/io/helidon/webserver/BareResponseImpl.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQxODo1MDo0NlrOICkLCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQyMToyNTo1OFrOICqNVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU2MDcxMg==", "bodyText": "I am unsure of the threading implications of who can modify this field, but I see it being modified in several places.  Does it need to be volatile?", "url": "https://github.com/oracle/helidon/pull/2591#discussion_r539560712", "createdAt": "2020-12-09T18:50:46Z", "author": {"login": "ljnelson"}, "path": "webserver/webserver/src/main/java/io/helidon/webserver/BareResponseImpl.java", "diffHunk": "@@ -78,19 +78,19 @@\n     private volatile DefaultHttpResponse response;\n     private volatile boolean lengthOptimization;\n     private volatile boolean isWebSocketUpgrade = false;\n-    private CompletableFuture<?> previousRequestFuture;\n+    private CompletableFuture<?> prevRequestFuture;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3e33bab7b1bfbaf7eeef509008314663713fa3a"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU2OTQ4Mw==", "bodyText": "Reading and writing this variable as a volatile as we do in onNext is odd and typically flagged as a problem (non-atomic update). Method onNext cannot be called in parallel, but it can be called sequentially in different threads. Perhaps this should be an AtomicReference instead.", "url": "https://github.com/oracle/helidon/pull/2591#discussion_r539569483", "createdAt": "2020-12-09T19:04:11Z", "author": {"login": "spericas"}, "path": "webserver/webserver/src/main/java/io/helidon/webserver/BareResponseImpl.java", "diffHunk": "@@ -78,19 +78,19 @@\n     private volatile DefaultHttpResponse response;\n     private volatile boolean lengthOptimization;\n     private volatile boolean isWebSocketUpgrade = false;\n-    private CompletableFuture<?> previousRequestFuture;\n+    private CompletableFuture<?> prevRequestFuture;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU2MDcxMg=="}, "originalCommit": {"oid": "c3e33bab7b1bfbaf7eeef509008314663713fa3a"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU3MTMyNA==", "bodyText": "\u2026although AtomicReference is really just volatile memory semantics on steroids, right?  Up to you; just saw it being assigned in various places and wanted to double-check.", "url": "https://github.com/oracle/helidon/pull/2591#discussion_r539571324", "createdAt": "2020-12-09T19:06:59Z", "author": {"login": "ljnelson"}, "path": "webserver/webserver/src/main/java/io/helidon/webserver/BareResponseImpl.java", "diffHunk": "@@ -78,19 +78,19 @@\n     private volatile DefaultHttpResponse response;\n     private volatile boolean lengthOptimization;\n     private volatile boolean isWebSocketUpgrade = false;\n-    private CompletableFuture<?> previousRequestFuture;\n+    private CompletableFuture<?> prevRequestFuture;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU2MDcxMg=="}, "originalCommit": {"oid": "c3e33bab7b1bfbaf7eeef509008314663713fa3a"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY1OTYwNQ==", "bodyText": "onNext/onComplete from which these are invoked are totally ordered. The inter-thread semantics are ensured by the Publisher that calls these.\nOn the other hand, if you have a non-compliant Publisher that may issue onNext concurrently, the chaining logic is going to be broken even if prev is volatile.", "url": "https://github.com/oracle/helidon/pull/2591#discussion_r539659605", "createdAt": "2020-12-09T21:25:58Z", "author": {"login": "olotenko"}, "path": "webserver/webserver/src/main/java/io/helidon/webserver/BareResponseImpl.java", "diffHunk": "@@ -78,19 +78,19 @@\n     private volatile DefaultHttpResponse response;\n     private volatile boolean lengthOptimization;\n     private volatile boolean isWebSocketUpgrade = false;\n-    private CompletableFuture<?> previousRequestFuture;\n+    private CompletableFuture<?> prevRequestFuture;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU2MDcxMg=="}, "originalCommit": {"oid": "c3e33bab7b1bfbaf7eeef509008314663713fa3a"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4ODQ0MDgzOnYy", "diffSide": "RIGHT", "path": "webserver/webserver/src/main/java/io/helidon/webserver/BareResponseImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQyMToyODozM1rOICqTXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQyMToyODozM1rOICqTXw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTY2MTE1MQ==", "bodyText": "Since we are into renaming, I'd like to make sure the meaning is documented to be not only previous request, but really any chunk.\n(N.B.: onNext may push several content chunks for the same request, so prev would reference the future for those chunks)", "url": "https://github.com/oracle/helidon/pull/2591#discussion_r539661151", "createdAt": "2020-12-09T21:28:33Z", "author": {"login": "olotenko"}, "path": "webserver/webserver/src/main/java/io/helidon/webserver/BareResponseImpl.java", "diffHunk": "@@ -78,19 +78,19 @@\n     private volatile DefaultHttpResponse response;\n     private volatile boolean lengthOptimization;\n     private volatile boolean isWebSocketUpgrade = false;\n-    private CompletableFuture<?> prev;\n+    private CompletableFuture<?> previousRequestFuture;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47de1a64f25fa7f1c60a30c513f5c6af35042705"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5Mzg2MzY3OnYy", "diffSide": "RIGHT", "path": "webserver/webserver/src/main/java/io/helidon/webserver/ForwardingHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQyMDoxNjoyMlrOIDbhHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQyMDoyNDozMVrOIDb0Cg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ2NzQ4Nw==", "bodyText": "Why declare local var?", "url": "https://github.com/oracle/helidon/pull/2591#discussion_r540467487", "createdAt": "2020-12-10T20:16:22Z", "author": {"login": "danielkec"}, "path": "webserver/webserver/src/main/java/io/helidon/webserver/ForwardingHandler.java", "diffHunk": "@@ -144,7 +156,9 @@ protected void channelRead0(ChannelHandlerContext ctx, Object msg) {\n             // Queue, context and publisher creation\n             ReferenceHoldingQueue<DataChunk> queue = new ReferenceHoldingQueue<>();\n             queues.add(queue);\n-            requestContext = new RequestContext(new HttpRequestScopedPublisher(ctx, queue), request);\n+            RequestContext requestContext = new RequestContext(new HttpRequestScopedPublisher(ctx, queue), request);\n+            this.requestContext = requestContext;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ba7d4347fca194a54307b3f34bcf3badbec882de"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ3MjMzMA==", "bodyText": "aha makes sense", "url": "https://github.com/oracle/helidon/pull/2591#discussion_r540472330", "createdAt": "2020-12-10T20:24:31Z", "author": {"login": "danielkec"}, "path": "webserver/webserver/src/main/java/io/helidon/webserver/ForwardingHandler.java", "diffHunk": "@@ -144,7 +156,9 @@ protected void channelRead0(ChannelHandlerContext ctx, Object msg) {\n             // Queue, context and publisher creation\n             ReferenceHoldingQueue<DataChunk> queue = new ReferenceHoldingQueue<>();\n             queues.add(queue);\n-            requestContext = new RequestContext(new HttpRequestScopedPublisher(ctx, queue), request);\n+            RequestContext requestContext = new RequestContext(new HttpRequestScopedPublisher(ctx, queue), request);\n+            this.requestContext = requestContext;\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDQ2NzQ4Nw=="}, "originalCommit": {"oid": "ba7d4347fca194a54307b3f34bcf3badbec882de"}, "originalPosition": 47}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 374, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}