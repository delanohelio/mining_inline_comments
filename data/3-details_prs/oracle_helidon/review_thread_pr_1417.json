{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc3ODY4NTgz", "number": 1417, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNDoxODoxOVrODj0_EQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNToxNToyNFrODj2Nyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4ODk0ODY1OnYy", "diffSide": "RIGHT", "path": "config/config/src/main/java/io/helidon/config/ListNodeBuilderImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNDoxODoxOVrOFv2bZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMjo1MDoxNFrOFySR4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTcxOTE0MA==", "bodyText": "Could it be avoided by adding another from method?\n    static ListNodeBuilderImpl from(ListNode elements, Function<String, String> resolveTokenFunction) {\n        ListNodeBuilderImpl builder = new ListNodeBuilderImpl(resolveTokenFunction);\n        elements.forEach(builder::addNode);\n        elements.value().ifPresent(builder::value);\n        return builder;\n    }", "url": "https://github.com/oracle/helidon/pull/1417#discussion_r385719140", "createdAt": "2020-02-28T14:18:19Z", "author": {"login": "danielkec"}, "path": "config/config/src/main/java/io/helidon/config/ListNodeBuilderImpl.java", "diffHunk": "@@ -97,6 +97,13 @@ public ListNodeBuilderImpl value(String value) {\n         return this;\n     }\n \n+    // this is a shortcut method to keep current fluent code\n+    // even though value is now optional\n+    ListNodeBuilderImpl value(Optional<String> value) {\n+        value.ifPresent(this::value);\n+        return this;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23e8d221d71445f12913435739fef10eb8cc4617"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI3MjYwOA==", "bodyText": "This method is called as fluent from multiple places that have different methods called.", "url": "https://github.com/oracle/helidon/pull/1417#discussion_r388272608", "createdAt": "2020-03-05T12:50:14Z", "author": {"login": "tomas-langer"}, "path": "config/config/src/main/java/io/helidon/config/ListNodeBuilderImpl.java", "diffHunk": "@@ -97,6 +97,13 @@ public ListNodeBuilderImpl value(String value) {\n         return this;\n     }\n \n+    // this is a shortcut method to keep current fluent code\n+    // even though value is now optional\n+    ListNodeBuilderImpl value(Optional<String> value) {\n+        value.ifPresent(this::value);\n+        return this;\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTcxOTE0MA=="}, "originalCommit": {"oid": "23e8d221d71445f12913435739fef10eb8cc4617"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4OTEyODk1OnYy", "diffSide": "RIGHT", "path": "config/config/src/main/java/io/helidon/config/ConfigSourcesRuntime.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNTowOTozNVrOFv4KLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNTowOTozNVrOFv4KLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc0NzUwMQ==", "bodyText": "List<ObjectNode> objectNodes = loadedData.stream()\n                .map(RuntimeWithData::data)\n                .flatMap(Optional::stream)\n                .collect(Collectors.toList());", "url": "https://github.com/oracle/helidon/pull/1417#discussion_r385747501", "createdAt": "2020-02-28T15:09:35Z", "author": {"login": "danielkec"}, "path": "config/config/src/main/java/io/helidon/config/ConfigSourcesRuntime.java", "diffHunk": "@@ -0,0 +1,223 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.config;\n+\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import io.helidon.config.spi.ConfigNode;\n+import io.helidon.config.spi.ConfigNode.ObjectNode;\n+import io.helidon.config.spi.MergingStrategy;\n+\n+/**\n+ * Runtime of all configured configuration sources.\n+ */\n+final class ConfigSourcesRuntime {\n+    private final List<RuntimeWithData> loadedData = new LinkedList<>();\n+\n+    private List<ConfigSourceRuntimeBase> allSources;\n+    private MergingStrategy mergingStrategy;\n+    private Consumer<Optional<ObjectNode>> changeListener;\n+\n+    ConfigSourcesRuntime(List<ConfigSourceRuntimeBase> allSources,\n+                         MergingStrategy mergingStrategy) {\n+        this.allSources = allSources;\n+        this.mergingStrategy = mergingStrategy;\n+    }\n+\n+    // for the purpose of tests\n+    static ConfigSourcesRuntime empty() {\n+        return new ConfigSourcesRuntime(List.of(new ConfigSourceRuntimeImpl(null, ConfigSources.empty())),\n+                                        MergingStrategy.fallback());\n+    }\n+\n+    List<ConfigSourceRuntimeBase> allSources() {\n+        return allSources;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        ConfigSourcesRuntime that = (ConfigSourcesRuntime) o;\n+        return allSources.equals(that.allSources);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(allSources);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return allSources.toString();\n+    }\n+\n+    void changeListener(Consumer<Optional<ObjectNode>> changeListener) {\n+        this.changeListener = changeListener;\n+    }\n+\n+    void startChanges() {\n+        loadedData.stream()\n+                .filter(loaded -> loaded.runtime().changesSupported())\n+                .forEach(loaded -> loaded.runtime()\n+                        .onChange((key, configNode) -> {\n+                            loaded.data(processChange(loaded.data, key, configNode));\n+                            changeListener.accept(latest());\n+                        }));\n+    }\n+\n+    private Optional<ObjectNode> processChange(Optional<ObjectNode> oldData, String changedKey, ConfigNode changeNode) {\n+        ConfigKeyImpl key = ConfigKeyImpl.of(changedKey);\n+        ObjectNode changeObjectNode = toObjectNode(changeNode);\n+\n+        if (key.isRoot()) {\n+            // we have a root, no merging with original data, just return it\n+            return Optional.of(changeObjectNode);\n+        }\n+\n+        ObjectNode newRootNode = ObjectNode.builder().addObject(changedKey, changeObjectNode).build();\n+\n+        // old data was empty, this is the only data we have\n+        if (oldData.isEmpty()) {\n+            return Optional.of(newRootNode);\n+        }\n+\n+        // we had data, now we have new data (not on root), let's merge\n+        return Optional.of(mergingStrategy.merge(List.of(newRootNode, oldData.get())));\n+    }\n+\n+    private ObjectNode toObjectNode(ConfigNode changeNode) {\n+        switch (changeNode.nodeType()) {\n+        case OBJECT:\n+            return (ObjectNode) changeNode;\n+        case LIST:\n+            return ObjectNode.builder().addList(\"\", (ConfigNode.ListNode) changeNode).build();\n+        case VALUE:\n+            return ObjectNode.builder().value(((ConfigNode.ValueNode) changeNode).get()).build();\n+        default:\n+            throw new IllegalArgumentException(\"Unsupported node type: \" + changeNode.nodeType());\n+        }\n+    }\n+\n+    synchronized Optional<ObjectNode> latest() {\n+        List<ObjectNode> objectNodes = loadedData.stream()\n+                .map(RuntimeWithData::data)\n+                .filter(Optional::isPresent)\n+                .map(Optional::get)\n+                .collect(Collectors.toList());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23e8d221d71445f12913435739fef10eb8cc4617"}, "originalPosition": 134}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4OTE0ODAyOnYy", "diffSide": "RIGHT", "path": "config/config/src/main/java/io/helidon/config/ConfigSourcesRuntime.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNToxNDo0N1rOFv4V3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMjo1MToyM1rOFyST8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc1MDQ5NA==", "bodyText": "Optional is such ... \ud83d\ude1e\n.flatMap(Optional::stream)\n.flatMap(this::streamKeys)", "url": "https://github.com/oracle/helidon/pull/1417#discussion_r385750494", "createdAt": "2020-02-28T15:14:47Z", "author": {"login": "danielkec"}, "path": "config/config/src/main/java/io/helidon/config/ConfigSourcesRuntime.java", "diffHunk": "@@ -0,0 +1,223 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.config;\n+\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import io.helidon.config.spi.ConfigNode;\n+import io.helidon.config.spi.ConfigNode.ObjectNode;\n+import io.helidon.config.spi.MergingStrategy;\n+\n+/**\n+ * Runtime of all configured configuration sources.\n+ */\n+final class ConfigSourcesRuntime {\n+    private final List<RuntimeWithData> loadedData = new LinkedList<>();\n+\n+    private List<ConfigSourceRuntimeBase> allSources;\n+    private MergingStrategy mergingStrategy;\n+    private Consumer<Optional<ObjectNode>> changeListener;\n+\n+    ConfigSourcesRuntime(List<ConfigSourceRuntimeBase> allSources,\n+                         MergingStrategy mergingStrategy) {\n+        this.allSources = allSources;\n+        this.mergingStrategy = mergingStrategy;\n+    }\n+\n+    // for the purpose of tests\n+    static ConfigSourcesRuntime empty() {\n+        return new ConfigSourcesRuntime(List.of(new ConfigSourceRuntimeImpl(null, ConfigSources.empty())),\n+                                        MergingStrategy.fallback());\n+    }\n+\n+    List<ConfigSourceRuntimeBase> allSources() {\n+        return allSources;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        ConfigSourcesRuntime that = (ConfigSourcesRuntime) o;\n+        return allSources.equals(that.allSources);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(allSources);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return allSources.toString();\n+    }\n+\n+    void changeListener(Consumer<Optional<ObjectNode>> changeListener) {\n+        this.changeListener = changeListener;\n+    }\n+\n+    void startChanges() {\n+        loadedData.stream()\n+                .filter(loaded -> loaded.runtime().changesSupported())\n+                .forEach(loaded -> loaded.runtime()\n+                        .onChange((key, configNode) -> {\n+                            loaded.data(processChange(loaded.data, key, configNode));\n+                            changeListener.accept(latest());\n+                        }));\n+    }\n+\n+    private Optional<ObjectNode> processChange(Optional<ObjectNode> oldData, String changedKey, ConfigNode changeNode) {\n+        ConfigKeyImpl key = ConfigKeyImpl.of(changedKey);\n+        ObjectNode changeObjectNode = toObjectNode(changeNode);\n+\n+        if (key.isRoot()) {\n+            // we have a root, no merging with original data, just return it\n+            return Optional.of(changeObjectNode);\n+        }\n+\n+        ObjectNode newRootNode = ObjectNode.builder().addObject(changedKey, changeObjectNode).build();\n+\n+        // old data was empty, this is the only data we have\n+        if (oldData.isEmpty()) {\n+            return Optional.of(newRootNode);\n+        }\n+\n+        // we had data, now we have new data (not on root), let's merge\n+        return Optional.of(mergingStrategy.merge(List.of(newRootNode, oldData.get())));\n+    }\n+\n+    private ObjectNode toObjectNode(ConfigNode changeNode) {\n+        switch (changeNode.nodeType()) {\n+        case OBJECT:\n+            return (ObjectNode) changeNode;\n+        case LIST:\n+            return ObjectNode.builder().addList(\"\", (ConfigNode.ListNode) changeNode).build();\n+        case VALUE:\n+            return ObjectNode.builder().value(((ConfigNode.ValueNode) changeNode).get()).build();\n+        default:\n+            throw new IllegalArgumentException(\"Unsupported node type: \" + changeNode.nodeType());\n+        }\n+    }\n+\n+    synchronized Optional<ObjectNode> latest() {\n+        List<ObjectNode> objectNodes = loadedData.stream()\n+                .map(RuntimeWithData::data)\n+                .filter(Optional::isPresent)\n+                .map(Optional::get)\n+                .collect(Collectors.toList());\n+\n+        return Optional.of(mergingStrategy.merge(objectNodes));\n+    }\n+\n+    synchronized Optional<ObjectNode> load() {\n+\n+        for (ConfigSourceRuntimeBase source : allSources) {\n+            if (source.isLazy()) {\n+                loadedData.add(new RuntimeWithData(source, Optional.empty()));\n+            } else {\n+                loadedData.add(new RuntimeWithData(source, source.load()\n+                        .map(ObjectNodeImpl::wrap)\n+                        .map(objectNode -> objectNode.initDescription(source.description()))));\n+            }\n+        }\n+\n+        Set<String> allKeys = loadedData.stream()\n+                .map(RuntimeWithData::data)\n+                .filter(Optional::isPresent)\n+                .map(Optional::get)\n+                .flatMap(this::streamKeys)\n+                .collect(Collectors.toSet());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23e8d221d71445f12913435739fef10eb8cc4617"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI3MzEzOQ==", "bodyText": "Fixing.", "url": "https://github.com/oracle/helidon/pull/1417#discussion_r388273139", "createdAt": "2020-03-05T12:51:23Z", "author": {"login": "tomas-langer"}, "path": "config/config/src/main/java/io/helidon/config/ConfigSourcesRuntime.java", "diffHunk": "@@ -0,0 +1,223 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.config;\n+\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import io.helidon.config.spi.ConfigNode;\n+import io.helidon.config.spi.ConfigNode.ObjectNode;\n+import io.helidon.config.spi.MergingStrategy;\n+\n+/**\n+ * Runtime of all configured configuration sources.\n+ */\n+final class ConfigSourcesRuntime {\n+    private final List<RuntimeWithData> loadedData = new LinkedList<>();\n+\n+    private List<ConfigSourceRuntimeBase> allSources;\n+    private MergingStrategy mergingStrategy;\n+    private Consumer<Optional<ObjectNode>> changeListener;\n+\n+    ConfigSourcesRuntime(List<ConfigSourceRuntimeBase> allSources,\n+                         MergingStrategy mergingStrategy) {\n+        this.allSources = allSources;\n+        this.mergingStrategy = mergingStrategy;\n+    }\n+\n+    // for the purpose of tests\n+    static ConfigSourcesRuntime empty() {\n+        return new ConfigSourcesRuntime(List.of(new ConfigSourceRuntimeImpl(null, ConfigSources.empty())),\n+                                        MergingStrategy.fallback());\n+    }\n+\n+    List<ConfigSourceRuntimeBase> allSources() {\n+        return allSources;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        ConfigSourcesRuntime that = (ConfigSourcesRuntime) o;\n+        return allSources.equals(that.allSources);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(allSources);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return allSources.toString();\n+    }\n+\n+    void changeListener(Consumer<Optional<ObjectNode>> changeListener) {\n+        this.changeListener = changeListener;\n+    }\n+\n+    void startChanges() {\n+        loadedData.stream()\n+                .filter(loaded -> loaded.runtime().changesSupported())\n+                .forEach(loaded -> loaded.runtime()\n+                        .onChange((key, configNode) -> {\n+                            loaded.data(processChange(loaded.data, key, configNode));\n+                            changeListener.accept(latest());\n+                        }));\n+    }\n+\n+    private Optional<ObjectNode> processChange(Optional<ObjectNode> oldData, String changedKey, ConfigNode changeNode) {\n+        ConfigKeyImpl key = ConfigKeyImpl.of(changedKey);\n+        ObjectNode changeObjectNode = toObjectNode(changeNode);\n+\n+        if (key.isRoot()) {\n+            // we have a root, no merging with original data, just return it\n+            return Optional.of(changeObjectNode);\n+        }\n+\n+        ObjectNode newRootNode = ObjectNode.builder().addObject(changedKey, changeObjectNode).build();\n+\n+        // old data was empty, this is the only data we have\n+        if (oldData.isEmpty()) {\n+            return Optional.of(newRootNode);\n+        }\n+\n+        // we had data, now we have new data (not on root), let's merge\n+        return Optional.of(mergingStrategy.merge(List.of(newRootNode, oldData.get())));\n+    }\n+\n+    private ObjectNode toObjectNode(ConfigNode changeNode) {\n+        switch (changeNode.nodeType()) {\n+        case OBJECT:\n+            return (ObjectNode) changeNode;\n+        case LIST:\n+            return ObjectNode.builder().addList(\"\", (ConfigNode.ListNode) changeNode).build();\n+        case VALUE:\n+            return ObjectNode.builder().value(((ConfigNode.ValueNode) changeNode).get()).build();\n+        default:\n+            throw new IllegalArgumentException(\"Unsupported node type: \" + changeNode.nodeType());\n+        }\n+    }\n+\n+    synchronized Optional<ObjectNode> latest() {\n+        List<ObjectNode> objectNodes = loadedData.stream()\n+                .map(RuntimeWithData::data)\n+                .filter(Optional::isPresent)\n+                .map(Optional::get)\n+                .collect(Collectors.toList());\n+\n+        return Optional.of(mergingStrategy.merge(objectNodes));\n+    }\n+\n+    synchronized Optional<ObjectNode> load() {\n+\n+        for (ConfigSourceRuntimeBase source : allSources) {\n+            if (source.isLazy()) {\n+                loadedData.add(new RuntimeWithData(source, Optional.empty()));\n+            } else {\n+                loadedData.add(new RuntimeWithData(source, source.load()\n+                        .map(ObjectNodeImpl::wrap)\n+                        .map(objectNode -> objectNode.initDescription(source.description()))));\n+            }\n+        }\n+\n+        Set<String> allKeys = loadedData.stream()\n+                .map(RuntimeWithData::data)\n+                .filter(Optional::isPresent)\n+                .map(Optional::get)\n+                .flatMap(this::streamKeys)\n+                .collect(Collectors.toSet());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc1MDQ5NA=="}, "originalCommit": {"oid": "23e8d221d71445f12913435739fef10eb8cc4617"}, "originalPosition": 156}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4OTE1MDE5OnYy", "diffSide": "RIGHT", "path": "config/config/src/main/java/io/helidon/config/ConfigSourcesRuntime.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxNToxNToyNFrOFv4XQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMjo1NDowNFrOFySZBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc1MDg1MA==", "bodyText": "same", "url": "https://github.com/oracle/helidon/pull/1417#discussion_r385750850", "createdAt": "2020-02-28T15:15:24Z", "author": {"login": "danielkec"}, "path": "config/config/src/main/java/io/helidon/config/ConfigSourcesRuntime.java", "diffHunk": "@@ -0,0 +1,223 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.config;\n+\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import io.helidon.config.spi.ConfigNode;\n+import io.helidon.config.spi.ConfigNode.ObjectNode;\n+import io.helidon.config.spi.MergingStrategy;\n+\n+/**\n+ * Runtime of all configured configuration sources.\n+ */\n+final class ConfigSourcesRuntime {\n+    private final List<RuntimeWithData> loadedData = new LinkedList<>();\n+\n+    private List<ConfigSourceRuntimeBase> allSources;\n+    private MergingStrategy mergingStrategy;\n+    private Consumer<Optional<ObjectNode>> changeListener;\n+\n+    ConfigSourcesRuntime(List<ConfigSourceRuntimeBase> allSources,\n+                         MergingStrategy mergingStrategy) {\n+        this.allSources = allSources;\n+        this.mergingStrategy = mergingStrategy;\n+    }\n+\n+    // for the purpose of tests\n+    static ConfigSourcesRuntime empty() {\n+        return new ConfigSourcesRuntime(List.of(new ConfigSourceRuntimeImpl(null, ConfigSources.empty())),\n+                                        MergingStrategy.fallback());\n+    }\n+\n+    List<ConfigSourceRuntimeBase> allSources() {\n+        return allSources;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        ConfigSourcesRuntime that = (ConfigSourcesRuntime) o;\n+        return allSources.equals(that.allSources);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(allSources);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return allSources.toString();\n+    }\n+\n+    void changeListener(Consumer<Optional<ObjectNode>> changeListener) {\n+        this.changeListener = changeListener;\n+    }\n+\n+    void startChanges() {\n+        loadedData.stream()\n+                .filter(loaded -> loaded.runtime().changesSupported())\n+                .forEach(loaded -> loaded.runtime()\n+                        .onChange((key, configNode) -> {\n+                            loaded.data(processChange(loaded.data, key, configNode));\n+                            changeListener.accept(latest());\n+                        }));\n+    }\n+\n+    private Optional<ObjectNode> processChange(Optional<ObjectNode> oldData, String changedKey, ConfigNode changeNode) {\n+        ConfigKeyImpl key = ConfigKeyImpl.of(changedKey);\n+        ObjectNode changeObjectNode = toObjectNode(changeNode);\n+\n+        if (key.isRoot()) {\n+            // we have a root, no merging with original data, just return it\n+            return Optional.of(changeObjectNode);\n+        }\n+\n+        ObjectNode newRootNode = ObjectNode.builder().addObject(changedKey, changeObjectNode).build();\n+\n+        // old data was empty, this is the only data we have\n+        if (oldData.isEmpty()) {\n+            return Optional.of(newRootNode);\n+        }\n+\n+        // we had data, now we have new data (not on root), let's merge\n+        return Optional.of(mergingStrategy.merge(List.of(newRootNode, oldData.get())));\n+    }\n+\n+    private ObjectNode toObjectNode(ConfigNode changeNode) {\n+        switch (changeNode.nodeType()) {\n+        case OBJECT:\n+            return (ObjectNode) changeNode;\n+        case LIST:\n+            return ObjectNode.builder().addList(\"\", (ConfigNode.ListNode) changeNode).build();\n+        case VALUE:\n+            return ObjectNode.builder().value(((ConfigNode.ValueNode) changeNode).get()).build();\n+        default:\n+            throw new IllegalArgumentException(\"Unsupported node type: \" + changeNode.nodeType());\n+        }\n+    }\n+\n+    synchronized Optional<ObjectNode> latest() {\n+        List<ObjectNode> objectNodes = loadedData.stream()\n+                .map(RuntimeWithData::data)\n+                .filter(Optional::isPresent)\n+                .map(Optional::get)\n+                .collect(Collectors.toList());\n+\n+        return Optional.of(mergingStrategy.merge(objectNodes));\n+    }\n+\n+    synchronized Optional<ObjectNode> load() {\n+\n+        for (ConfigSourceRuntimeBase source : allSources) {\n+            if (source.isLazy()) {\n+                loadedData.add(new RuntimeWithData(source, Optional.empty()));\n+            } else {\n+                loadedData.add(new RuntimeWithData(source, source.load()\n+                        .map(ObjectNodeImpl::wrap)\n+                        .map(objectNode -> objectNode.initDescription(source.description()))));\n+            }\n+        }\n+\n+        Set<String> allKeys = loadedData.stream()\n+                .map(RuntimeWithData::data)\n+                .filter(Optional::isPresent)\n+                .map(Optional::get)\n+                .flatMap(this::streamKeys)\n+                .collect(Collectors.toSet());\n+\n+        if (allKeys.isEmpty()) {\n+            return Optional.empty();\n+        }\n+\n+        // now we have all the keys, let's load them from the lazy sources\n+        for (RuntimeWithData data : loadedData) {\n+            if (data.runtime().isLazy()) {\n+                data.data(loadLazy(data.runtime(), allKeys));\n+            }\n+        }\n+\n+        List<ObjectNode> objectNodes = loadedData.stream()\n+                .map(RuntimeWithData::data)\n+                .filter(Optional::isPresent)\n+                .map(Optional::get)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "23e8d221d71445f12913435739fef10eb8cc4617"}, "originalPosition": 172}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI3MzM3Mw==", "bodyText": "Fixing", "url": "https://github.com/oracle/helidon/pull/1417#discussion_r388273373", "createdAt": "2020-03-05T12:51:52Z", "author": {"login": "tomas-langer"}, "path": "config/config/src/main/java/io/helidon/config/ConfigSourcesRuntime.java", "diffHunk": "@@ -0,0 +1,223 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.config;\n+\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import io.helidon.config.spi.ConfigNode;\n+import io.helidon.config.spi.ConfigNode.ObjectNode;\n+import io.helidon.config.spi.MergingStrategy;\n+\n+/**\n+ * Runtime of all configured configuration sources.\n+ */\n+final class ConfigSourcesRuntime {\n+    private final List<RuntimeWithData> loadedData = new LinkedList<>();\n+\n+    private List<ConfigSourceRuntimeBase> allSources;\n+    private MergingStrategy mergingStrategy;\n+    private Consumer<Optional<ObjectNode>> changeListener;\n+\n+    ConfigSourcesRuntime(List<ConfigSourceRuntimeBase> allSources,\n+                         MergingStrategy mergingStrategy) {\n+        this.allSources = allSources;\n+        this.mergingStrategy = mergingStrategy;\n+    }\n+\n+    // for the purpose of tests\n+    static ConfigSourcesRuntime empty() {\n+        return new ConfigSourcesRuntime(List.of(new ConfigSourceRuntimeImpl(null, ConfigSources.empty())),\n+                                        MergingStrategy.fallback());\n+    }\n+\n+    List<ConfigSourceRuntimeBase> allSources() {\n+        return allSources;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        ConfigSourcesRuntime that = (ConfigSourcesRuntime) o;\n+        return allSources.equals(that.allSources);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(allSources);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return allSources.toString();\n+    }\n+\n+    void changeListener(Consumer<Optional<ObjectNode>> changeListener) {\n+        this.changeListener = changeListener;\n+    }\n+\n+    void startChanges() {\n+        loadedData.stream()\n+                .filter(loaded -> loaded.runtime().changesSupported())\n+                .forEach(loaded -> loaded.runtime()\n+                        .onChange((key, configNode) -> {\n+                            loaded.data(processChange(loaded.data, key, configNode));\n+                            changeListener.accept(latest());\n+                        }));\n+    }\n+\n+    private Optional<ObjectNode> processChange(Optional<ObjectNode> oldData, String changedKey, ConfigNode changeNode) {\n+        ConfigKeyImpl key = ConfigKeyImpl.of(changedKey);\n+        ObjectNode changeObjectNode = toObjectNode(changeNode);\n+\n+        if (key.isRoot()) {\n+            // we have a root, no merging with original data, just return it\n+            return Optional.of(changeObjectNode);\n+        }\n+\n+        ObjectNode newRootNode = ObjectNode.builder().addObject(changedKey, changeObjectNode).build();\n+\n+        // old data was empty, this is the only data we have\n+        if (oldData.isEmpty()) {\n+            return Optional.of(newRootNode);\n+        }\n+\n+        // we had data, now we have new data (not on root), let's merge\n+        return Optional.of(mergingStrategy.merge(List.of(newRootNode, oldData.get())));\n+    }\n+\n+    private ObjectNode toObjectNode(ConfigNode changeNode) {\n+        switch (changeNode.nodeType()) {\n+        case OBJECT:\n+            return (ObjectNode) changeNode;\n+        case LIST:\n+            return ObjectNode.builder().addList(\"\", (ConfigNode.ListNode) changeNode).build();\n+        case VALUE:\n+            return ObjectNode.builder().value(((ConfigNode.ValueNode) changeNode).get()).build();\n+        default:\n+            throw new IllegalArgumentException(\"Unsupported node type: \" + changeNode.nodeType());\n+        }\n+    }\n+\n+    synchronized Optional<ObjectNode> latest() {\n+        List<ObjectNode> objectNodes = loadedData.stream()\n+                .map(RuntimeWithData::data)\n+                .filter(Optional::isPresent)\n+                .map(Optional::get)\n+                .collect(Collectors.toList());\n+\n+        return Optional.of(mergingStrategy.merge(objectNodes));\n+    }\n+\n+    synchronized Optional<ObjectNode> load() {\n+\n+        for (ConfigSourceRuntimeBase source : allSources) {\n+            if (source.isLazy()) {\n+                loadedData.add(new RuntimeWithData(source, Optional.empty()));\n+            } else {\n+                loadedData.add(new RuntimeWithData(source, source.load()\n+                        .map(ObjectNodeImpl::wrap)\n+                        .map(objectNode -> objectNode.initDescription(source.description()))));\n+            }\n+        }\n+\n+        Set<String> allKeys = loadedData.stream()\n+                .map(RuntimeWithData::data)\n+                .filter(Optional::isPresent)\n+                .map(Optional::get)\n+                .flatMap(this::streamKeys)\n+                .collect(Collectors.toSet());\n+\n+        if (allKeys.isEmpty()) {\n+            return Optional.empty();\n+        }\n+\n+        // now we have all the keys, let's load them from the lazy sources\n+        for (RuntimeWithData data : loadedData) {\n+            if (data.runtime().isLazy()) {\n+                data.data(loadLazy(data.runtime(), allKeys));\n+            }\n+        }\n+\n+        List<ObjectNode> objectNodes = loadedData.stream()\n+                .map(RuntimeWithData::data)\n+                .filter(Optional::isPresent)\n+                .map(Optional::get)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc1MDg1MA=="}, "originalCommit": {"oid": "23e8d221d71445f12913435739fef10eb8cc4617"}, "originalPosition": 172}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI3NDQzNg==", "bodyText": "Also fixing in all other classes this was used.", "url": "https://github.com/oracle/helidon/pull/1417#discussion_r388274436", "createdAt": "2020-03-05T12:54:04Z", "author": {"login": "tomas-langer"}, "path": "config/config/src/main/java/io/helidon/config/ConfigSourcesRuntime.java", "diffHunk": "@@ -0,0 +1,223 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.config;\n+\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import io.helidon.config.spi.ConfigNode;\n+import io.helidon.config.spi.ConfigNode.ObjectNode;\n+import io.helidon.config.spi.MergingStrategy;\n+\n+/**\n+ * Runtime of all configured configuration sources.\n+ */\n+final class ConfigSourcesRuntime {\n+    private final List<RuntimeWithData> loadedData = new LinkedList<>();\n+\n+    private List<ConfigSourceRuntimeBase> allSources;\n+    private MergingStrategy mergingStrategy;\n+    private Consumer<Optional<ObjectNode>> changeListener;\n+\n+    ConfigSourcesRuntime(List<ConfigSourceRuntimeBase> allSources,\n+                         MergingStrategy mergingStrategy) {\n+        this.allSources = allSources;\n+        this.mergingStrategy = mergingStrategy;\n+    }\n+\n+    // for the purpose of tests\n+    static ConfigSourcesRuntime empty() {\n+        return new ConfigSourcesRuntime(List.of(new ConfigSourceRuntimeImpl(null, ConfigSources.empty())),\n+                                        MergingStrategy.fallback());\n+    }\n+\n+    List<ConfigSourceRuntimeBase> allSources() {\n+        return allSources;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        ConfigSourcesRuntime that = (ConfigSourcesRuntime) o;\n+        return allSources.equals(that.allSources);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(allSources);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return allSources.toString();\n+    }\n+\n+    void changeListener(Consumer<Optional<ObjectNode>> changeListener) {\n+        this.changeListener = changeListener;\n+    }\n+\n+    void startChanges() {\n+        loadedData.stream()\n+                .filter(loaded -> loaded.runtime().changesSupported())\n+                .forEach(loaded -> loaded.runtime()\n+                        .onChange((key, configNode) -> {\n+                            loaded.data(processChange(loaded.data, key, configNode));\n+                            changeListener.accept(latest());\n+                        }));\n+    }\n+\n+    private Optional<ObjectNode> processChange(Optional<ObjectNode> oldData, String changedKey, ConfigNode changeNode) {\n+        ConfigKeyImpl key = ConfigKeyImpl.of(changedKey);\n+        ObjectNode changeObjectNode = toObjectNode(changeNode);\n+\n+        if (key.isRoot()) {\n+            // we have a root, no merging with original data, just return it\n+            return Optional.of(changeObjectNode);\n+        }\n+\n+        ObjectNode newRootNode = ObjectNode.builder().addObject(changedKey, changeObjectNode).build();\n+\n+        // old data was empty, this is the only data we have\n+        if (oldData.isEmpty()) {\n+            return Optional.of(newRootNode);\n+        }\n+\n+        // we had data, now we have new data (not on root), let's merge\n+        return Optional.of(mergingStrategy.merge(List.of(newRootNode, oldData.get())));\n+    }\n+\n+    private ObjectNode toObjectNode(ConfigNode changeNode) {\n+        switch (changeNode.nodeType()) {\n+        case OBJECT:\n+            return (ObjectNode) changeNode;\n+        case LIST:\n+            return ObjectNode.builder().addList(\"\", (ConfigNode.ListNode) changeNode).build();\n+        case VALUE:\n+            return ObjectNode.builder().value(((ConfigNode.ValueNode) changeNode).get()).build();\n+        default:\n+            throw new IllegalArgumentException(\"Unsupported node type: \" + changeNode.nodeType());\n+        }\n+    }\n+\n+    synchronized Optional<ObjectNode> latest() {\n+        List<ObjectNode> objectNodes = loadedData.stream()\n+                .map(RuntimeWithData::data)\n+                .filter(Optional::isPresent)\n+                .map(Optional::get)\n+                .collect(Collectors.toList());\n+\n+        return Optional.of(mergingStrategy.merge(objectNodes));\n+    }\n+\n+    synchronized Optional<ObjectNode> load() {\n+\n+        for (ConfigSourceRuntimeBase source : allSources) {\n+            if (source.isLazy()) {\n+                loadedData.add(new RuntimeWithData(source, Optional.empty()));\n+            } else {\n+                loadedData.add(new RuntimeWithData(source, source.load()\n+                        .map(ObjectNodeImpl::wrap)\n+                        .map(objectNode -> objectNode.initDescription(source.description()))));\n+            }\n+        }\n+\n+        Set<String> allKeys = loadedData.stream()\n+                .map(RuntimeWithData::data)\n+                .filter(Optional::isPresent)\n+                .map(Optional::get)\n+                .flatMap(this::streamKeys)\n+                .collect(Collectors.toSet());\n+\n+        if (allKeys.isEmpty()) {\n+            return Optional.empty();\n+        }\n+\n+        // now we have all the keys, let's load them from the lazy sources\n+        for (RuntimeWithData data : loadedData) {\n+            if (data.runtime().isLazy()) {\n+                data.data(loadLazy(data.runtime(), allKeys));\n+            }\n+        }\n+\n+        List<ObjectNode> objectNodes = loadedData.stream()\n+                .map(RuntimeWithData::data)\n+                .filter(Optional::isPresent)\n+                .map(Optional::get)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTc1MDg1MA=="}, "originalCommit": {"oid": "23e8d221d71445f12913435739fef10eb8cc4617"}, "originalPosition": 172}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 242, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}