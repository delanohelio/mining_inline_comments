{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEzOTk0NzIy", "number": 1732, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwNjowMzo1MFrOD6GiEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwNjowMzo1MFrOD6GiEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyMjUxMDI0OnYy", "diffSide": "RIGHT", "path": "common/reactive/src/main/java/io/helidon/common/reactive/OutputStreamPublisher.java", "isResolved": false, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwNjowMzo1MFrOGRvlpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwOTo0NTowN1rOGR22rg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI1ODY2MQ==", "bodyText": "Lock doesn't help to prevent rule \u00a71.7 violation, we can remove synchronization logic from publisher and wrap subscriber in io.helidon.common.reactive.SequentialSubscriber", "url": "https://github.com/oracle/helidon/pull/1732#discussion_r421258661", "createdAt": "2020-05-07T06:03:50Z", "author": {"login": "danielkec"}, "path": "common/reactive/src/main/java/io/helidon/common/reactive/OutputStreamPublisher.java", "diffHunk": "@@ -163,6 +195,7 @@ private void complete(Throwable t) {\n         subscriber.close(sub -> {\n             synchronized (invocationLock) {\n                 sub.onError(t);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86e1aec7056d3fcbd928056c2a40838d57d67add"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI1OTAxOA==", "bodyText": "Not a blocker for this PR, just noticing", "url": "https://github.com/oracle/helidon/pull/1732#discussion_r421259018", "createdAt": "2020-05-07T06:04:47Z", "author": {"login": "danielkec"}, "path": "common/reactive/src/main/java/io/helidon/common/reactive/OutputStreamPublisher.java", "diffHunk": "@@ -163,6 +195,7 @@ private void complete(Throwable t) {\n         subscriber.close(sub -> {\n             synchronized (invocationLock) {\n                 sub.onError(t);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI1ODY2MQ=="}, "originalCommit": {"oid": "86e1aec7056d3fcbd928056c2a40838d57d67add"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI2NDAyOA==", "bodyText": "1.7 violation can be seen to not be reachable in this instance.", "url": "https://github.com/oracle/helidon/pull/1732#discussion_r421264028", "createdAt": "2020-05-07T06:19:02Z", "author": {"login": "olotenko"}, "path": "common/reactive/src/main/java/io/helidon/common/reactive/OutputStreamPublisher.java", "diffHunk": "@@ -163,6 +195,7 @@ private void complete(Throwable t) {\n         subscriber.close(sub -> {\n             synchronized (invocationLock) {\n                 sub.onError(t);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI1ODY2MQ=="}, "originalCommit": {"oid": "86e1aec7056d3fcbd928056c2a40838d57d67add"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI2NzAzNQ==", "bodyText": "I'm thinking about not very probable use-case of request(-1) vs. exception in publish method", "url": "https://github.com/oracle/helidon/pull/1732#discussion_r421267035", "createdAt": "2020-05-07T06:26:58Z", "author": {"login": "danielkec"}, "path": "common/reactive/src/main/java/io/helidon/common/reactive/OutputStreamPublisher.java", "diffHunk": "@@ -163,6 +195,7 @@ private void complete(Throwable t) {\n         subscriber.close(sub -> {\n             synchronized (invocationLock) {\n                 sub.onError(t);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI1ODY2MQ=="}, "originalCommit": {"oid": "86e1aec7056d3fcbd928056c2a40838d57d67add"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI3MDIxNA==", "bodyText": "You can see subscriber.close ensures completion signals will be signalled once and only once, as long as they always go through complete which calls subscriber.close.", "url": "https://github.com/oracle/helidon/pull/1732#discussion_r421270214", "createdAt": "2020-05-07T06:35:29Z", "author": {"login": "olotenko"}, "path": "common/reactive/src/main/java/io/helidon/common/reactive/OutputStreamPublisher.java", "diffHunk": "@@ -163,6 +195,7 @@ private void complete(Throwable t) {\n         subscriber.close(sub -> {\n             synchronized (invocationLock) {\n                 sub.onError(t);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI1ODY2MQ=="}, "originalCommit": {"oid": "86e1aec7056d3fcbd928056c2a40838d57d67add"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMwNTI2NQ==", "bodyText": "Missed that, thanks for clarification", "url": "https://github.com/oracle/helidon/pull/1732#discussion_r421305265", "createdAt": "2020-05-07T07:46:50Z", "author": {"login": "danielkec"}, "path": "common/reactive/src/main/java/io/helidon/common/reactive/OutputStreamPublisher.java", "diffHunk": "@@ -163,6 +195,7 @@ private void complete(Throwable t) {\n         subscriber.close(sub -> {\n             synchronized (invocationLock) {\n                 sub.onError(t);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI1ODY2MQ=="}, "originalCommit": {"oid": "86e1aec7056d3fcbd928056c2a40838d57d67add"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM3NzcxMA==", "bodyText": "Pro tip: when designing routines with CPS, ensure a continuation is invoked always. (Not necessarily the same continuation for all outcomes, not necessarily immediately, but you've got to design routines with a guarantee that the continuation is invoked always) You want to not call any continuation only in very rare circumstances.\nThe problem with the current design of SingleSubscriberHolder is that it can omit calling the continuation, and the caller is not told that that is the case. It is the same behaviour as non-termination. The outcome is that signalCloseComplete is not guaranteed to be reachable, and the completionResult.get can wait indefinitely. The (rather long) timeout then only eventually reclaims the thread.", "url": "https://github.com/oracle/helidon/pull/1732#discussion_r421377710", "createdAt": "2020-05-07T09:45:07Z", "author": {"login": "olotenko"}, "path": "common/reactive/src/main/java/io/helidon/common/reactive/OutputStreamPublisher.java", "diffHunk": "@@ -163,6 +195,7 @@ private void complete(Throwable t) {\n         subscriber.close(sub -> {\n             synchronized (invocationLock) {\n                 sub.onError(t);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTI1ODY2MQ=="}, "originalCommit": {"oid": "86e1aec7056d3fcbd928056c2a40838d57d67add"}, "originalPosition": 117}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 669, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}