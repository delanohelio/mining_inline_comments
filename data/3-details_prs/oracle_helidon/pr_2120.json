{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQzMDYzMTUz", "number": 2120, "title": "Fault tolerance for SE", "bodyText": "Fault tolerance handlers supporting Single and Multi.\nResolves #2110\nUsing ServerResponse.send(Throwable) now resolves error handlers and gets the cause of CompletionException to support CompletionStage.exceptionally", "createdAt": "2020-07-01T23:29:17Z", "url": "https://github.com/oracle/helidon/pull/2120", "merged": true, "mergeCommit": {"oid": "9e18020ff1ea2214750762bfae5895c96b7e90b5"}, "closed": true, "closedAt": "2020-07-06T12:47:45Z", "author": {"login": "tomas-langer"}, "timelineItems": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcwzAzcgH2gAyNDQzMDYzMTUzOjA2ZDFjNjdmMDBkMDVhNmUxZjdhNjZhOWU1ZTQyMzUzOTYxODA0NWU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcyQqfJgFqTQ0MzA0MjY2OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "06d1c67f00d05a6e1f7a66a9e5e423539618045e", "author": {"user": {"login": "tomas-langer", "name": "Tomas Langer"}}, "url": "https://github.com/oracle/helidon/commit/06d1c67f00d05a6e1f7a66a9e5e423539618045e", "committedDate": "2020-07-01T23:40:29Z", "message": "FaultTolerance for SE.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3b300214d0bd5680ea1f9b27240e26a99e437788", "author": {"user": {"login": "tomas-langer", "name": "Tomas Langer"}}, "url": "https://github.com/oracle/helidon/commit/3b300214d0bd5680ea1f9b27240e26a99e437788", "committedDate": "2020-07-01T23:40:29Z", "message": "Update to support multi.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1c8304cf812ce6231060443b6e012b7a401a8db2", "author": {"user": {"login": "tomas-langer", "name": "Tomas Langer"}}, "url": "https://github.com/oracle/helidon/commit/1c8304cf812ce6231060443b6e012b7a401a8db2", "committedDate": "2020-07-01T23:40:29Z", "message": "Javadoc and finished all handlers.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "addc87e85972b5cf482b270fa3de8b06a5d2e0f2", "author": {"user": {"login": "tomas-langer", "name": "Tomas Langer"}}, "url": "https://github.com/oracle/helidon/commit/addc87e85972b5cf482b270fa3de8b06a5d2e0f2", "committedDate": "2020-07-01T23:40:29Z", "message": "Checkstyle fixes.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9021d111e73aa552062f5c33d6843e8c11e2e6e9", "author": {"user": {"login": "tomas-langer", "name": "Tomas Langer"}}, "url": "https://github.com/oracle/helidon/commit/9021d111e73aa552062f5c33d6843e8c11e2e6e9", "committedDate": "2020-07-01T23:40:29Z", "message": "Sending an error now resolves error handlers.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8ca08a867b3b68f36c4c1bbcc87c1e35519e43d4", "author": {"user": {"login": "tomas-langer", "name": "Tomas Langer"}}, "url": "https://github.com/oracle/helidon/commit/8ca08a867b3b68f36c4c1bbcc87c1e35519e43d4", "committedDate": "2020-07-01T23:40:29Z", "message": "Example for FT with webserver.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "72accbbb0bff3984df0d2d2b5215345556901309", "author": {"user": {"login": "tomas-langer", "name": "Tomas Langer"}}, "url": "https://github.com/oracle/helidon/commit/72accbbb0bff3984df0d2d2b5215345556901309", "committedDate": "2020-07-01T23:41:30Z", "message": "Rebase and fix version.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8e393f54ad317cb3faf9d0fecbaee44939d70e10", "author": {"user": {"login": "tomas-langer", "name": "Tomas Langer"}}, "url": "https://github.com/oracle/helidon/commit/8e393f54ad317cb3faf9d0fecbaee44939d70e10", "committedDate": "2020-07-01T23:28:20Z", "message": "Example for FT with webserver.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>"}, "afterCommit": {"oid": "72accbbb0bff3984df0d2d2b5215345556901309", "author": {"user": {"login": "tomas-langer", "name": "Tomas Langer"}}, "url": "https://github.com/oracle/helidon/commit/72accbbb0bff3984df0d2d2b5215345556901309", "committedDate": "2020-07-01T23:41:30Z", "message": "Rebase and fix version.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f557c589a94399c1a2169e5d0f4af2a0e06f7b5e", "author": {"user": {"login": "tomas-langer", "name": "Tomas Langer"}}, "url": "https://github.com/oracle/helidon/commit/f557c589a94399c1a2169e5d0f4af2a0e06f7b5e", "committedDate": "2020-07-02T10:02:57Z", "message": "Fixed javadoc\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0220ec94c2fa14c445c1ee9e0500ad64c9784993", "author": {"user": {"login": "tomas-langer", "name": "Tomas Langer"}}, "url": "https://github.com/oracle/helidon/commit/0220ec94c2fa14c445c1ee9e0500ad64c9784993", "committedDate": "2020-07-02T12:03:37Z", "message": "Scope fix for test dependency.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxNzA5MjAy", "url": "https://github.com/oracle/helidon/pull/2120#pullrequestreview-441709202", "createdAt": "2020-07-02T14:02:57Z", "commit": {"oid": "0220ec94c2fa14c445c1ee9e0500ad64c9784993"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNDowMjo1OFrOGsOUSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNDowMjo1OFrOGsOUSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTAyNTA5OA==", "bodyText": "Need it?", "url": "https://github.com/oracle/helidon/pull/2120#discussion_r449025098", "createdAt": "2020-07-02T14:02:58Z", "author": {"login": "spericas"}, "path": "fault-tolerance/src/test/java/io/helidon/faulttolerance/RetryTest.java", "diffHunk": "@@ -0,0 +1,327 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.faulttolerance;\n+\n+import java.time.Duration;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Flow;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import io.helidon.common.reactive.Multi;\n+import io.helidon.common.reactive.Single;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.CoreMatchers.instanceOf;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.contains;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+class RetryTest {\n+    @Test\n+    void testRetry() {\n+        Retry retry = Retry.builder()\n+                .retryPolicy(Retry.JitterRetryPolicy.builder()\n+                                     .calls(3)\n+                                     .delay(Duration.ofMillis(50))\n+                                     .jitter(Duration.ofMillis(50))\n+                                     .build())\n+                .overallTimeout(Duration.ofMillis(500))\n+                .build();\n+\n+        Request req = new Request(3, new TerminalException(), new RetryException());\n+        Single<Integer> result = retry.invoke(req::invoke);\n+        FaultToleranceTest.completionException(result, TerminalException.class);\n+        assertThat(req.call.get(), is(3));\n+\n+        req = new Request(2, new TerminalException(), new RetryException());\n+        result = retry.invoke(req::invoke);\n+        int count = result.await(1, TimeUnit.SECONDS);\n+        assertThat(count, is(3));\n+    }\n+\n+    @Test\n+    void testRetryOn() {\n+        Retry retry = Retry.builder()\n+                .retryPolicy(Retry.JitterRetryPolicy.builder()\n+                                     .calls(3)\n+                                     .delay(Duration.ofMillis(100))\n+                                     .jitter(Duration.ofMillis(50))\n+                                     .build())\n+                .overallTimeout(Duration.ofMillis(500))\n+                .addApplyOn(RetryException.class)\n+                .build();\n+\n+        Request req = new Request(3, new RetryException(), new RetryException());\n+        Single<Integer> result = retry.invoke(req::invoke);\n+        FaultToleranceTest.completionException(result, RetryException.class);\n+        assertThat(req.call.get(), is(3));\n+\n+        req = new Request(2, new RetryException(), new TerminalException());\n+        result = retry.invoke(req::invoke);\n+        FaultToleranceTest.completionException(result, TerminalException.class);\n+        assertThat(req.call.get(), is(2));\n+\n+        req = new Request(2, new RetryException(), new RetryException());\n+        result = retry.invoke(req::invoke);\n+        int count = result.await(1, TimeUnit.SECONDS);\n+        assertThat(count, is(3));\n+    }\n+\n+    @Test\n+    void testAbortOn() {\n+        Retry retry = Retry.builder()\n+                .retryPolicy(Retry.JitterRetryPolicy.builder()\n+                                     .calls(3)\n+                                     .delay(Duration.ofMillis(100))\n+                                     .jitter(Duration.ofMillis(50))\n+                                     .build())\n+                .overallTimeout(Duration.ofMillis(50000))\n+                .addSkipOn(TerminalException.class)\n+                .build();\n+\n+        Request req = new Request(3, new RetryException(), new RetryException());\n+        Single<Integer> result = retry.invoke(req::invoke);\n+        FaultToleranceTest.completionException(result, RetryException.class);\n+        assertThat(req.call.get(), is(3));\n+\n+        req = new Request(2, new RetryException(), new TerminalException());\n+        result = retry.invoke(req::invoke);\n+        FaultToleranceTest.completionException(result, TerminalException.class);\n+        assertThat(req.call.get(), is(2));\n+\n+        req = new Request(2, new RetryException(), new RetryException());\n+        result = retry.invoke(req::invoke);\n+        int count = result.await(1, TimeUnit.SECONDS);\n+        assertThat(count, is(3));\n+    }\n+\n+    @Test\n+    void testTimeout() {\n+        Retry retry = Retry.builder()\n+                .retryPolicy(Retry.JitterRetryPolicy.builder()\n+                                     .calls(3)\n+                                     .delay(Duration.ofMillis(100))\n+                                     .jitter(Duration.ZERO)\n+                                     .build())\n+                .overallTimeout(Duration.ofMillis(50))\n+                .build();\n+\n+        Request req = new Request(3, new RetryException(), new RetryException());\n+        Single<Integer> result = retry.invoke(req::invoke);\n+        FaultToleranceTest.completionException(result, TimeoutException.class);\n+        // first time: immediate call\n+        // second time: delayed invocation\n+        // third attempt to retry fails on timeout\n+        assertThat(\"Should have been called twice\", req.call.get(), is(2));\n+    }\n+\n+    @Test\n+    void testBadConfiguration() {\n+        Retry.Builder builder = Retry.builder()\n+                .applyOn(RetryException.class)\n+                .skipOn(TerminalException.class);\n+\n+        assertThrows(IllegalArgumentException.class, builder::build);\n+    }\n+\n+    @Test\n+    void testMultiRetriesNoFailure() throws InterruptedException {\n+        Retry retry = Retry.builder()\n+                .retryPolicy(Retry.DelayingRetryPolicy.noDelay(3))\n+                .build();\n+\n+        Multi<Integer> multi = retry.invokeMulti(() -> Multi.just(0, 1, 2));\n+\n+        TestSubscriber ts = new TestSubscriber();\n+        multi.subscribe(ts);\n+        ts.request(100);\n+\n+        ts.cdl.await(1, TimeUnit.SECONDS);\n+\n+        assertThat(\"Should be completed\", ts.completed.get(), is(true));\n+        assertThat(\"Should not be failed\", ts.failed.get(), is(false));\n+        assertThat(ts.values, contains(0, 1, 2));\n+    }\n+\n+    @Test\n+    void testMultiRetries() throws InterruptedException {\n+        Retry retry = Retry.builder()\n+                .retryPolicy(Retry.DelayingRetryPolicy.noDelay(3))\n+                .build();\n+\n+        AtomicInteger count = new AtomicInteger();\n+\n+        Multi<Integer> multi = retry.invokeMulti(() -> {\n+            if (count.getAndIncrement() < 2) {\n+                return Multi.error(new RetryException());\n+            } else {\n+                return Multi.just(0, 1, 2);\n+            }\n+        });\n+\n+        TestSubscriber ts = new TestSubscriber();\n+        multi.subscribe(ts);\n+        ts.request(100);\n+\n+        ts.cdl.await(1, TimeUnit.SECONDS);\n+\n+        assertThat(\"Should be completed\", ts.completed.get(), is(true));\n+        assertThat(\"Should not be failed\", ts.failed.get(), is(false));\n+        assertThat(ts.values, contains(0, 1, 2));\n+    }\n+\n+    @Test\n+    void testMultiRetriesRead() throws InterruptedException {\n+        Retry retry = Retry.builder()\n+                .retryPolicy(Retry.DelayingRetryPolicy.noDelay(3))\n+                .build();\n+\n+        AtomicInteger count = new AtomicInteger();\n+\n+        TestSubscriber ts = new TestSubscriber();\n+\n+        Multi<Integer> multi = retry.invokeMulti(() -> {\n+            if (count.getAndIncrement() == 0) {\n+                //return new PartialPublisher();\n+                return Multi.concat(Multi.just(0), Multi.error(new RetryException()));\n+            } else {\n+                TestSubscriber it = ts;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0220ec94c2fa14c445c1ee9e0500ad64c9784993"}, "originalPosition": 211}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxNzEwMDQx", "url": "https://github.com/oracle/helidon/pull/2120#pullrequestreview-441710041", "createdAt": "2020-07-02T14:03:50Z", "commit": {"oid": "0220ec94c2fa14c445c1ee9e0500ad64c9784993"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNDowMzo1MVrOGsOWjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNDowMzo1MVrOGsOWjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTAyNTY3OQ==", "bodyText": "Variable inProgressResult not used", "url": "https://github.com/oracle/helidon/pull/2120#discussion_r449025679", "createdAt": "2020-07-02T14:03:51Z", "author": {"login": "spericas"}, "path": "fault-tolerance/src/test/java/io/helidon/faulttolerance/BulkheadTest.java", "diffHunk": "@@ -0,0 +1,230 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.faulttolerance;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Flow;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.IntStream;\n+\n+import io.helidon.common.LogConfig;\n+import io.helidon.common.reactive.Multi;\n+import io.helidon.common.reactive.Single;\n+\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.contains;\n+import static org.hamcrest.Matchers.instanceOf;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.notNullValue;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+class BulkheadTest {\n+    @BeforeAll\n+    static void setupTest() {\n+        LogConfig.configureRuntime();\n+    }\n+\n+    @Test\n+    void testBulkheadQueue() throws InterruptedException {\n+        Bulkhead bulkhead = Bulkhead.builder()\n+                .limit(1)\n+                .queueLength(1000)\n+                .build();\n+\n+        Request inProgress = new Request(0);\n+        Single<Integer> inProgressResult = bulkhead.invoke(inProgress::invoke);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0220ec94c2fa14c445c1ee9e0500ad64c9784993"}, "originalPosition": 57}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxNzEyNjI3", "url": "https://github.com/oracle/helidon/pull/2120#pullrequestreview-441712627", "createdAt": "2020-07-02T14:06:33Z", "commit": {"oid": "0220ec94c2fa14c445c1ee9e0500ad64c9784993"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNDowNjozM1rOGsOeHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNDowNjozM1rOGsOeHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTAyNzYxNQ==", "bodyText": "Minor: can be static", "url": "https://github.com/oracle/helidon/pull/2120#discussion_r449027615", "createdAt": "2020-07-02T14:06:33Z", "author": {"login": "spericas"}, "path": "fault-tolerance/src/test/java/io/helidon/faulttolerance/FaultToleranceTest.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.faulttolerance;\n+\n+import java.time.Duration;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import io.helidon.common.reactive.Single;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.CoreMatchers.instanceOf;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+public class FaultToleranceTest {\n+\n+    @Test\n+    void testCustomCombination() {\n+        CircuitBreaker breaker = CircuitBreaker.builder()\n+                .build();\n+\n+        Bulkhead bulkhead = Bulkhead.builder()\n+                .limit(1)\n+                .queueLength(0)\n+                .build();\n+\n+        FtHandlerTyped<String> faultTolerance = FaultTolerance.builder()\n+                .addBreaker(breaker)\n+                .addBulkhead(bulkhead)\n+                .addTimeout(Timeout.builder().timeout(Duration.ofMillis(100)).build())\n+                .addFallback(Fallback.<String>builder()\n+                                     .fallback(this::fallback)\n+                                     .build())\n+                .build();\n+\n+        Single<String> result = faultTolerance.invoke(this::primary);\n+        assertThat(result.await(1, TimeUnit.SECONDS), is(MyException.class.getName()));\n+\n+        breaker.state(CircuitBreaker.State.OPEN);\n+        result = faultTolerance.invoke(this::primary);\n+        assertThat(result.await(1, TimeUnit.SECONDS), is(CircuitBreakerOpenException.class.getName()));\n+\n+        breaker.state(CircuitBreaker.State.CLOSED);\n+\n+        Manual m = new Manual();\n+        Single<String> manualResult = bulkhead.invoke(m::call);\n+\n+        result = faultTolerance.invoke(this::primary);\n+        assertThat(result.await(1, TimeUnit.SECONDS), is(BulkheadException.class.getName()));\n+\n+        m.future.complete(\"result\");\n+        manualResult.await(1, TimeUnit.SECONDS);\n+\n+        m = new Manual();\n+        result = faultTolerance.invoke(m::call);\n+        assertThat(result.await(1, TimeUnit.SECONDS), is(TimeoutException.class.getName()));\n+\n+        m.future.complete(\"hu\");\n+    }\n+\n+    private Single<String> primary() {\n+        return Single.error(new MyException());\n+    }\n+\n+    private Single<String> fallback(Throwable throwable) {\n+        return Single.just(throwable.getClass().getName());\n+    }\n+\n+    static <T extends Throwable> T completionException(Single<?> result, Class<T> expected) {\n+        CompletionException completionException = assertThrows(CompletionException.class,\n+                                                               () -> result.await(1, TimeUnit.SECONDS));\n+        Throwable cause = completionException.getCause();\n+        assertThat(cause, notNullValue());\n+        assertThat(cause, instanceOf(expected));\n+\n+        return expected.cast(cause);\n+    }\n+\n+    private class Manual {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0220ec94c2fa14c445c1ee9e0500ad64c9784993"}, "originalPosition": 100}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxNzI5ODM0", "url": "https://github.com/oracle/helidon/pull/2120#pullrequestreview-441729834", "createdAt": "2020-07-02T14:25:04Z", "commit": {"oid": "0220ec94c2fa14c445c1ee9e0500ad64c9784993"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNDoyNTowNFrOGsPQtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNDoyNTowNFrOGsPQtg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA0MDU2Ng==", "bodyText": "May be a bit more readable if methods had a suffix like \"M\", a bit difficult to read when named same as variables", "url": "https://github.com/oracle/helidon/pull/2120#discussion_r449040566", "createdAt": "2020-07-02T14:25:04Z", "author": {"login": "spericas"}, "path": "examples/webserver/fault-tolerance/src/main/java/io/helidon/webserver/examples/faulttolerance/FtService.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.webserver.examples.faulttolerance;\n+\n+import java.time.Duration;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import io.helidon.common.reactive.Single;\n+import io.helidon.faulttolerance.Async;\n+import io.helidon.faulttolerance.Bulkhead;\n+import io.helidon.faulttolerance.CircuitBreaker;\n+import io.helidon.faulttolerance.Fallback;\n+import io.helidon.faulttolerance.Retry;\n+import io.helidon.faulttolerance.Timeout;\n+import io.helidon.webserver.Routing;\n+import io.helidon.webserver.ServerRequest;\n+import io.helidon.webserver.ServerResponse;\n+import io.helidon.webserver.Service;\n+\n+/**\n+ * Simple service to demonstrate fault tolerance.\n+ */\n+public class FtService implements Service {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0220ec94c2fa14c445c1ee9e0500ad64c9784993"}, "originalPosition": 37}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxNzgyODkw", "url": "https://github.com/oracle/helidon/pull/2120#pullrequestreview-441782890", "createdAt": "2020-07-02T15:16:03Z", "commit": {"oid": "0220ec94c2fa14c445c1ee9e0500ad64c9784993"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNToxNjowM1rOGsRY4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNToxNjowM1rOGsRY4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA3NTQyNQ==", "bodyText": "Unused", "url": "https://github.com/oracle/helidon/pull/2120#discussion_r449075425", "createdAt": "2020-07-02T15:16:03Z", "author": {"login": "spericas"}, "path": "fault-tolerance/src/test/java/io/helidon/faulttolerance/AsyncTest.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.faulttolerance;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import io.helidon.common.reactive.Single;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.CoreMatchers.instanceOf;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.not;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+class AsyncTest {\n+    private final AtomicInteger syncCounter = new AtomicInteger();\n+\n+    @BeforeEach\n+    void reset() {\n+        syncCounter.set(0);\n+    }\n+\n+    @Test\n+    void testAsync() {\n+        Thread result = Async.create()\n+                .invoke(this::sync)\n+                .await(1, TimeUnit.SECONDS);\n+\n+        assertThat(result, is(not(Thread.currentThread())));\n+        assertThat(syncCounter.get(), is(1));\n+    }\n+\n+    @Test\n+    void testAsyncError() {\n+        Single<String> result = Async.create()\n+                .invoke(this::syncError);\n+\n+        CompletionException exception = assertThrows(CompletionException.class, () -> result.await(1, TimeUnit.SECONDS));\n+\n+        Throwable cause = exception.getCause();\n+\n+        assertThat(cause, notNullValue());\n+        assertThat(cause, instanceOf(MyException.class));\n+    }\n+\n+    private List<String> syncList() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0220ec94c2fa14c445c1ee9e0500ad64c9784993"}, "originalPosition": 67}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQxODA1NzE4", "url": "https://github.com/oracle/helidon/pull/2120#pullrequestreview-441805718", "createdAt": "2020-07-02T15:33:48Z", "commit": {"oid": "0220ec94c2fa14c445c1ee9e0500ad64c9784993"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNTozMzo0OFrOGsSX8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNTozMzo0OFrOGsSX8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA5MTU2OQ==", "bodyText": "Isn't this better?\n    final static class AtomicCycle {\n        private final AtomicInteger atomicInteger = new AtomicInteger(-1);\n        private final int maxIndex;\n\n        AtomicCycle(int maxIndex) {\n            this.maxIndex = maxIndex + 1;\n        }\n\n        int incrementAndGet() {\n            return atomicInteger.accumulateAndGet(maxIndex, (current, max) -> (current + 1) % max);\n        }\n    }", "url": "https://github.com/oracle/helidon/pull/2120#discussion_r449091569", "createdAt": "2020-07-02T15:33:48Z", "author": {"login": "spericas"}, "path": "fault-tolerance/src/main/java/io/helidon/faulttolerance/AtomicCycle.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.faulttolerance;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+final class AtomicCycle {\n+    private final AtomicInteger atomicInteger = new AtomicInteger(-1);\n+    private final int maxIndex;\n+\n+    AtomicCycle(int maxIndex) {\n+        this.maxIndex = maxIndex;\n+    }\n+\n+    int incrementAndGet() {\n+        int currentIndex;\n+        int nextIndex;\n+        do {\n+            currentIndex = atomicInteger.get();\n+            nextIndex = (currentIndex == maxIndex) ? 0 : currentIndex + 1;\n+        } while (!atomicInteger.compareAndSet(currentIndex, nextIndex));\n+\n+        return nextIndex;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0220ec94c2fa14c445c1ee9e0500ad64c9784993"}, "originalPosition": 38}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7908b57af9119a22bcb1ec0fca87157b583e377f", "author": {"user": {"login": "tomas-langer", "name": "Tomas Langer"}}, "url": "https://github.com/oracle/helidon/commit/7908b57af9119a22bcb1ec0fca87157b583e377f", "committedDate": "2020-07-02T21:29:09Z", "message": "Incorporated review changes.\n\nSigned-off-by: Tomas Langer <tomas.langer@oracle.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzMDQyNjY4", "url": "https://github.com/oracle/helidon/pull/2120#pullrequestreview-443042668", "createdAt": "2020-07-06T12:47:11Z", "commit": {"oid": "7908b57af9119a22bcb1ec0fca87157b583e377f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 499, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}