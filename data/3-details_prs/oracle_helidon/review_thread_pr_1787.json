{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE3NzE5NTU1", "number": 1787, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxMToxMzowMlrOD8bqSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQwMzoyOTowNVrOD9Dtww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0Njk0MzQ3OnYy", "diffSide": "RIGHT", "path": "media/multipart/common/src/main/java/io/helidon/media/multipart/common/MultiPartDecoder.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxMToxMzowMlrOGVXddA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQwMzowNDo0NFrOGWXyMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA1NzY1Mg==", "bodyText": "We have nice tooling for that, no need to misuse OriginThreadPublisher here\nMultiPartDecoder_not_extending_OTPub.patch.txt", "url": "https://github.com/oracle/helidon/pull/1787#discussion_r425057652", "createdAt": "2020-05-14T11:13:02Z", "author": {"login": "danielkec"}, "path": "media/multipart/common/src/main/java/io/helidon/media/multipart/common/MultiPartDecoder.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.helidon.media.multipart.common;\n+\n+import java.util.LinkedList;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Queue;\n+import java.util.concurrent.Flow.Processor;\n+import java.util.concurrent.Flow.Subscriber;\n+import java.util.concurrent.Flow.Subscription;\n+import java.util.logging.Logger;\n+\n+import io.helidon.common.http.DataChunk;\n+import io.helidon.common.reactive.OriginThreadPublisher;\n+import io.helidon.media.common.MessageBodyReadableContent;\n+import io.helidon.media.common.MessageBodyReaderContext;\n+\n+/**\n+ * Reactive processor that decodes HTTP payload as a stream of {@link BodyPart}.\n+ * This processor is a single use publisher that supports a single subscriber,\n+ * it is not resumable.\n+ */\n+public final class MultiPartDecoder implements Processor<DataChunk, ReadableBodyPart> {\n+\n+    /**\n+     * Logger.\n+     */\n+    private static final Logger LOGGER = Logger.getLogger(MultiPartDecoder.class.getName());\n+\n+    /**\n+     * Indicate that the chunks subscription is complete.\n+     */\n+    private boolean complete;\n+\n+    /**\n+     * The upstream subscription.\n+     */\n+    private Subscription chunksSubscription;\n+\n+    /**\n+     * The builder for the current {@link BodyPart}.\n+     */\n+    private ReadableBodyPart.Builder bodyPartBuilder;\n+\n+    /**\n+     * The builder for the current {@link ReadableBodyPartHeaders}.\n+     */\n+    private ReadableBodyPartHeaders.Builder bodyPartHeaderBuilder;\n+\n+    /**\n+     * The publisher for the current part.\n+     */\n+    private BodyPartContentPublisher contentPublisher;\n+\n+    /**\n+     * The parent chunk for the published body part chunks.\n+     */\n+    private BodyPartChunk.Parent chunkParent;\n+\n+    /**\n+     * The MIME parser.\n+     */\n+    private final MIMEParser parser;\n+\n+    /**\n+     * The parser event processor.\n+     */\n+    private final ParserEventProcessor parserEventProcessor;\n+\n+    /**\n+     * The bodyParts processed during each {@code onNext}.\n+     */\n+    private final Queue<ReadableBodyPart> bodyParts;\n+\n+    /**\n+     * The reader context.\n+     */\n+    private final MessageBodyReaderContext context;\n+\n+    /**\n+     * The downstream publisher.\n+     */\n+    private final BodyPartPublisher downstream;\n+\n+    /**\n+     * Create a new instance.\n+     *\n+     * @param boundary mime message boundary\n+     * @param context reader context\n+     */\n+    private MultiPartDecoder(String boundary, MessageBodyReaderContext context) {\n+        Objects.requireNonNull(boundary, \"boundary cannot be null!\");\n+        Objects.requireNonNull(context, \"context cannot be null!\");\n+        this.context = context;\n+        parserEventProcessor = new ParserEventProcessor();\n+        parser = new MIMEParser(boundary, parserEventProcessor);\n+        downstream = new BodyPartPublisher();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e9d1a876a27e52a81c6921cffe786d5d5a1208d"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI1NzAzMQ==", "bodyText": "I wrote most of this code prior to all of the new Multi stuff ; which is why it is using OTP. I'll take a look at your patch.", "url": "https://github.com/oracle/helidon/pull/1787#discussion_r425257031", "createdAt": "2020-05-14T16:09:35Z", "author": {"login": "romain-grecourt"}, "path": "media/multipart/common/src/main/java/io/helidon/media/multipart/common/MultiPartDecoder.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.helidon.media.multipart.common;\n+\n+import java.util.LinkedList;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Queue;\n+import java.util.concurrent.Flow.Processor;\n+import java.util.concurrent.Flow.Subscriber;\n+import java.util.concurrent.Flow.Subscription;\n+import java.util.logging.Logger;\n+\n+import io.helidon.common.http.DataChunk;\n+import io.helidon.common.reactive.OriginThreadPublisher;\n+import io.helidon.media.common.MessageBodyReadableContent;\n+import io.helidon.media.common.MessageBodyReaderContext;\n+\n+/**\n+ * Reactive processor that decodes HTTP payload as a stream of {@link BodyPart}.\n+ * This processor is a single use publisher that supports a single subscriber,\n+ * it is not resumable.\n+ */\n+public final class MultiPartDecoder implements Processor<DataChunk, ReadableBodyPart> {\n+\n+    /**\n+     * Logger.\n+     */\n+    private static final Logger LOGGER = Logger.getLogger(MultiPartDecoder.class.getName());\n+\n+    /**\n+     * Indicate that the chunks subscription is complete.\n+     */\n+    private boolean complete;\n+\n+    /**\n+     * The upstream subscription.\n+     */\n+    private Subscription chunksSubscription;\n+\n+    /**\n+     * The builder for the current {@link BodyPart}.\n+     */\n+    private ReadableBodyPart.Builder bodyPartBuilder;\n+\n+    /**\n+     * The builder for the current {@link ReadableBodyPartHeaders}.\n+     */\n+    private ReadableBodyPartHeaders.Builder bodyPartHeaderBuilder;\n+\n+    /**\n+     * The publisher for the current part.\n+     */\n+    private BodyPartContentPublisher contentPublisher;\n+\n+    /**\n+     * The parent chunk for the published body part chunks.\n+     */\n+    private BodyPartChunk.Parent chunkParent;\n+\n+    /**\n+     * The MIME parser.\n+     */\n+    private final MIMEParser parser;\n+\n+    /**\n+     * The parser event processor.\n+     */\n+    private final ParserEventProcessor parserEventProcessor;\n+\n+    /**\n+     * The bodyParts processed during each {@code onNext}.\n+     */\n+    private final Queue<ReadableBodyPart> bodyParts;\n+\n+    /**\n+     * The reader context.\n+     */\n+    private final MessageBodyReaderContext context;\n+\n+    /**\n+     * The downstream publisher.\n+     */\n+    private final BodyPartPublisher downstream;\n+\n+    /**\n+     * Create a new instance.\n+     *\n+     * @param boundary mime message boundary\n+     * @param context reader context\n+     */\n+    private MultiPartDecoder(String boundary, MessageBodyReaderContext context) {\n+        Objects.requireNonNull(boundary, \"boundary cannot be null!\");\n+        Objects.requireNonNull(context, \"context cannot be null!\");\n+        this.context = context;\n+        parserEventProcessor = new ParserEventProcessor();\n+        parser = new MIMEParser(boundary, parserEventProcessor);\n+        downstream = new BodyPartPublisher();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA1NzY1Mg=="}, "originalCommit": {"oid": "1e9d1a876a27e52a81c6921cffe786d5d5a1208d"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjExMTUzNg==", "bodyText": "Looking at your diff, there seems to be a part that's missing. Let's schedule something next week to go over your suggestions.", "url": "https://github.com/oracle/helidon/pull/1787#discussion_r426111536", "createdAt": "2020-05-16T03:04:44Z", "author": {"login": "romain-grecourt"}, "path": "media/multipart/common/src/main/java/io/helidon/media/multipart/common/MultiPartDecoder.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.helidon.media.multipart.common;\n+\n+import java.util.LinkedList;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Queue;\n+import java.util.concurrent.Flow.Processor;\n+import java.util.concurrent.Flow.Subscriber;\n+import java.util.concurrent.Flow.Subscription;\n+import java.util.logging.Logger;\n+\n+import io.helidon.common.http.DataChunk;\n+import io.helidon.common.reactive.OriginThreadPublisher;\n+import io.helidon.media.common.MessageBodyReadableContent;\n+import io.helidon.media.common.MessageBodyReaderContext;\n+\n+/**\n+ * Reactive processor that decodes HTTP payload as a stream of {@link BodyPart}.\n+ * This processor is a single use publisher that supports a single subscriber,\n+ * it is not resumable.\n+ */\n+public final class MultiPartDecoder implements Processor<DataChunk, ReadableBodyPart> {\n+\n+    /**\n+     * Logger.\n+     */\n+    private static final Logger LOGGER = Logger.getLogger(MultiPartDecoder.class.getName());\n+\n+    /**\n+     * Indicate that the chunks subscription is complete.\n+     */\n+    private boolean complete;\n+\n+    /**\n+     * The upstream subscription.\n+     */\n+    private Subscription chunksSubscription;\n+\n+    /**\n+     * The builder for the current {@link BodyPart}.\n+     */\n+    private ReadableBodyPart.Builder bodyPartBuilder;\n+\n+    /**\n+     * The builder for the current {@link ReadableBodyPartHeaders}.\n+     */\n+    private ReadableBodyPartHeaders.Builder bodyPartHeaderBuilder;\n+\n+    /**\n+     * The publisher for the current part.\n+     */\n+    private BodyPartContentPublisher contentPublisher;\n+\n+    /**\n+     * The parent chunk for the published body part chunks.\n+     */\n+    private BodyPartChunk.Parent chunkParent;\n+\n+    /**\n+     * The MIME parser.\n+     */\n+    private final MIMEParser parser;\n+\n+    /**\n+     * The parser event processor.\n+     */\n+    private final ParserEventProcessor parserEventProcessor;\n+\n+    /**\n+     * The bodyParts processed during each {@code onNext}.\n+     */\n+    private final Queue<ReadableBodyPart> bodyParts;\n+\n+    /**\n+     * The reader context.\n+     */\n+    private final MessageBodyReaderContext context;\n+\n+    /**\n+     * The downstream publisher.\n+     */\n+    private final BodyPartPublisher downstream;\n+\n+    /**\n+     * Create a new instance.\n+     *\n+     * @param boundary mime message boundary\n+     * @param context reader context\n+     */\n+    private MultiPartDecoder(String boundary, MessageBodyReaderContext context) {\n+        Objects.requireNonNull(boundary, \"boundary cannot be null!\");\n+        Objects.requireNonNull(context, \"context cannot be null!\");\n+        this.context = context;\n+        parserEventProcessor = new ParserEventProcessor();\n+        parser = new MIMEParser(boundary, parserEventProcessor);\n+        downstream = new BodyPartPublisher();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA1NzY1Mg=="}, "originalCommit": {"oid": "1e9d1a876a27e52a81c6921cffe786d5d5a1208d"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0Njk1ODQ1OnYy", "diffSide": "RIGHT", "path": "media/multipart/common/src/test/java/io/helidon/media/multipart/common/MultiPartDecoderTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxMToxNzozMVrOGVXm2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxNjoyNDoyMlrOGVkTNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA2MDA1OA==", "bodyText": "We definitely need Multi.just(...).via(Flow.Processor).subscribe(Flow.Subscriber) like MPRS have", "url": "https://github.com/oracle/helidon/pull/1787#discussion_r425060058", "createdAt": "2020-05-14T11:17:31Z", "author": {"login": "danielkec"}, "path": "media/multipart/common/src/test/java/io/helidon/media/multipart/common/MultiPartDecoderTest.java", "diffHunk": "@@ -0,0 +1,571 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.helidon.media.multipart.common;\n+\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Flow.Publisher;\n+import java.util.concurrent.Flow.Subscriber;\n+import java.util.concurrent.Flow.Subscription;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import io.helidon.common.http.DataChunk;\n+import io.helidon.common.reactive.Multi;\n+\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.CoreMatchers.hasItems;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.CoreMatchers.nullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static io.helidon.media.multipart.common.BodyPartTest.MEDIA_CONTEXT;\n+\n+/**\n+ * Tests {@link MultiPartDecoder}.\n+ */\n+public class MultiPartDecoderTest {\n+\n+    private static final Logger LOGGER = Logger.getLogger(MultiPartDecoder.class.getName());\n+\n+    @BeforeAll\n+    public static void before() {\n+        LOGGER.setLevel(Level.ALL);\n+    }\n+\n+    @AfterAll\n+    public static void after() {\n+        LOGGER.setLevel(Level.INFO);\n+    }\n+\n+    @Test\n+    public void testOnePartInOneChunk() {\n+        String boundary = \"boundary\";\n+        final byte[] chunk1 = (\"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part1\\n\"\n+                + \"\\n\"\n+                + \"body 1\\n\"\n+                + \"--\" + boundary + \"--\").getBytes();\n+\n+        final CountDownLatch latch = new CountDownLatch(2);\n+        Consumer<BodyPart> consumer = (part) -> {\n+            latch.countDown();\n+            assertThat(part.headers().values(\"Content-Id\"),\n+                    hasItems(\"part1\"));\n+            DataChunkSubscriber subscriber = new DataChunkSubscriber();\n+            part.content().subscribe(subscriber);\n+            subscriber.content().thenAccept(body -> {\n+                latch.countDown();\n+                assertThat(body, is(equalTo(\"body 1\")));\n+            });\n+        };\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(\n+                SUBSCRIBER_TYPE.INFINITE, consumer);\n+        partsPublisher(boundary, chunk1).subscribe(testSubscriber);\n+        waitOnLatch(latch);\n+        assertThat(testSubscriber.error, is(nullValue()));\n+        assertThat(testSubscriber.complete, is(equalTo(true)));\n+    }\n+\n+    @Test\n+    public void testTwoPartsInOneChunk() {\n+        String boundary = \"boundary\";\n+        final byte[] chunk1 = (\"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part1\\n\"\n+                + \"\\n\"\n+                + \"body 1\\n\"\n+                + \"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part2\\n\"\n+                + \"\\n\"\n+                + \"body 2\\n\"\n+                + \"--\" + boundary + \"--\").getBytes();\n+\n+        final CountDownLatch latch = new CountDownLatch(4);\n+        Consumer<BodyPart> consumer = (part) -> {\n+            latch.countDown();\n+            if (latch.getCount() == 3) {\n+                assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part1\"));\n+                DataChunkSubscriber subscriber = new DataChunkSubscriber();\n+                part.content().subscribe(subscriber);\n+                subscriber.content().thenAccept(body -> {\n+                    latch.countDown();\n+                    assertThat(body, is(equalTo(\"body 1\")));\n+                });\n+            } else {\n+                assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part2\"));\n+                DataChunkSubscriber subscriber = new DataChunkSubscriber();\n+                part.content().subscribe(subscriber);\n+                subscriber.content().thenAccept(body -> {\n+                    latch.countDown();\n+                    assertThat(body, is(equalTo(\"body 2\")));\n+                });\n+            }\n+        };\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(SUBSCRIBER_TYPE.INFINITE, consumer);\n+        partsPublisher(boundary, chunk1).subscribe(testSubscriber);\n+        waitOnLatch(latch);\n+        assertThat(testSubscriber.error, is(nullValue()));\n+        assertThat(testSubscriber.complete, is(equalTo(true)));\n+    }\n+\n+    @Test\n+    public void testContentAcrossChunks() {\n+        String boundary = \"boundary\";\n+        final byte[] chunk1 = (\"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part1\\n\"\n+                + \"\\n\"\n+                + \"this-is-the-1st-slice-of-the-body\\n\").getBytes();\n+        final byte[] chunk2 = (\"this-is-the-2nd-slice-of-the-body\\n\"\n+                + \"--\" + boundary + \"--\").getBytes();\n+\n+        final CountDownLatch latch = new CountDownLatch(2);\n+        Consumer<BodyPart> consumer = (part) -> {\n+            latch.countDown();\n+            assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part1\"));\n+            DataChunkSubscriber subscriber = new DataChunkSubscriber();\n+            part.content().subscribe(subscriber);\n+            subscriber.content().thenAccept(body -> {\n+                latch.countDown();\n+                assertThat(body, is(equalTo(\n+                        \"this-is-the-1st-slice-of-the-body\\n\"\n+                        + \"this-is-the-2nd-slice-of-the-body\")));\n+            });\n+        };\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(SUBSCRIBER_TYPE.INFINITE, consumer);\n+        partsPublisher(boundary, chunk1, chunk2).subscribe(testSubscriber);\n+        waitOnLatch(latch);\n+        assertThat(testSubscriber.error, is(nullValue()));\n+        assertThat(testSubscriber.complete, is(equalTo(true)));\n+    }\n+\n+    @Test\n+    public void testMultipleChunksBeforeContent() {\n+        String boundary = \"boundary\";\n+        final byte[] chunk1 = (\"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part1\\n\").getBytes();\n+        final byte[] chunk2 = \"Content-Type: text/plain\\n\".getBytes();\n+        final byte[] chunk3 = \"Set-Cookie: bob=alice\\n\".getBytes();\n+        final byte[] chunk4 = \"Set-Cookie: foo=bar\\n\".getBytes();\n+        final byte[] chunk5 = (\"\\n\"\n+                + \"body 1\\n\"\n+                + \"--\" + boundary + \"--\").getBytes();\n+\n+        final CountDownLatch latch = new CountDownLatch(2);\n+        Consumer<BodyPart> consumer = (part) -> {\n+            latch.countDown();\n+            assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part1\"));\n+            assertThat(part.headers().values(\"Content-Type\"), hasItems(\"text/plain\"));\n+            assertThat(part.headers().values(\"Set-Cookie\"), hasItems(\"bob=alice\", \"foo=bar\"));\n+            DataChunkSubscriber subscriber = new DataChunkSubscriber();\n+            part.content().subscribe(subscriber);\n+            subscriber.content().thenAccept(body -> {\n+                latch.countDown();\n+                assertThat(body, is(equalTo(\"body 1\")));\n+            });\n+        };\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(SUBSCRIBER_TYPE.INFINITE, consumer);\n+        partsPublisher(boundary, chunk1, chunk2, chunk3, chunk4, chunk5).subscribe(testSubscriber);\n+        waitOnLatch(latch);\n+        assertThat(testSubscriber.error, is(nullValue()));\n+        assertThat(testSubscriber.complete, is(equalTo(true)));\n+    }\n+\n+    @Test\n+    public void testMulitiplePartsWithOneByOneSubscriber() {\n+        String boundary = \"boundary\";\n+        final byte[] chunk1 = (\"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part1\\n\"\n+                + \"\\n\"\n+                + \"body 1\\n\"\n+                + \"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part2\\n\"\n+                + \"\\n\"\n+                + \"body 2\\n\"\n+                + \"--\" + boundary + \"--\").getBytes();\n+\n+        final CountDownLatch latch = new CountDownLatch(4);\n+        Consumer<BodyPart> consumer = (part) -> {\n+            latch.countDown();\n+            if (latch.getCount()== 3) {\n+                assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part1\"));\n+                DataChunkSubscriber subscriber = new DataChunkSubscriber();\n+                part.content().subscribe(subscriber);\n+                subscriber.content().thenAccept(body -> {\n+                    latch.countDown();\n+                    assertThat(body, is(equalTo(\"body 1\")));\n+                });\n+            } else {\n+                assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part2\"));\n+                DataChunkSubscriber subscriber = new DataChunkSubscriber();\n+                part.content().subscribe(subscriber);\n+                subscriber.content().thenAccept(body -> {\n+                    latch.countDown();\n+                    assertThat(body, is(equalTo(\"body 2\")));\n+                });\n+            }\n+        };\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(SUBSCRIBER_TYPE.ONE_BY_ONE, consumer);\n+        partsPublisher(boundary, chunk1).subscribe(testSubscriber);\n+        waitOnLatch(latch);\n+        assertThat(testSubscriber.error, is(nullValue()));\n+        assertThat(testSubscriber.complete, is(equalTo(true)));\n+    }\n+\n+    @Test\n+    public void testSubscriberCancelAfterOnePart() {\n+        String boundary = \"boundary\";\n+        final byte[] chunk1 = (\"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part1\\n\"\n+                + \"\\n\"\n+                + \"body 1\\n\"\n+                + \"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part2\\n\"\n+                + \"\\n\"\n+                + \"body 2\\n\"\n+                + \"--\" + boundary + \"--\").getBytes();\n+\n+        final CountDownLatch latch = new CountDownLatch(2);\n+        Consumer<BodyPart> consumer = (part) -> {\n+            latch.countDown();\n+            if (latch.getCount()== 1) {\n+                assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part1\"));\n+                DataChunkSubscriber subscriber1 = new DataChunkSubscriber();\n+                part.content().subscribe(subscriber1);\n+                subscriber1.content().thenAccept(body -> {\n+                    latch.countDown();\n+                    assertThat(body, is(equalTo(\"body 1\")));\n+                });\n+            }\n+        };\n+\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(SUBSCRIBER_TYPE.CANCEL_AFTER_ONE, consumer);\n+        partsPublisher(boundary, chunk1).subscribe(testSubscriber);\n+        waitOnLatch(latch);\n+        assertThat(testSubscriber.error, is(nullValue()));\n+        assertThat(testSubscriber.complete, is(equalTo(false)));\n+    }\n+\n+    @Test\n+    public void testNoClosingBoundary(){\n+        String boundary = \"boundary\";\n+        final byte[] chunk1 = (\"--\" + boundary + \"\\n\"\n+                + \"Content-Type: text/xml; charset=UTF-8\\n\"\n+                + \"Content-Id: part1\\n\"\n+                + \"\\n\"\n+                + \"<foo>bar</foo>\\n\").getBytes();\n+\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(SUBSCRIBER_TYPE.CANCEL_AFTER_ONE, null);\n+        partsPublisher(boundary, chunk1).subscribe(testSubscriber);\n+        assertThat(testSubscriber.complete, is(equalTo(false)));\n+        assertThat(testSubscriber.error, is(notNullValue()));\n+        assertThat(testSubscriber.error.getClass(), is(equalTo(MIMEParser.ParsingException.class)));\n+        assertThat(testSubscriber.error.getMessage(), is(equalTo(\"No closing MIME boundary\")));\n+    }\n+\n+    @Test\n+    public void testCanceledPartSubscription() {\n+        String boundary = \"boundary\";\n+        final byte[] chunk1 = (\"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part1\\n\"\n+                + \"\\n\"\n+                + \"body 1.aaaa\\n\").getBytes();\n+        final byte[] chunk2 = \"body 1.bbbb\\n\".getBytes();\n+        final byte[] chunk3 = (\"body 1.cccc\\n\"\n+                + \"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part2\\n\"\n+                + \"\\n\"\n+                + \"This is the 2nd\").getBytes();\n+        final byte[] chunk4 = (\"body.\\n\"\n+                + \"--\" + boundary + \"--\").getBytes();\n+\n+        final CountDownLatch latch = new CountDownLatch(4);\n+        Consumer<BodyPart> consumer = (part) -> {\n+            latch.countDown();\n+            if (latch.getCount() == 3) {\n+                assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part1\"));\n+                part.content().subscribe(new Subscriber<DataChunk>() {\n+                    Subscription subscription;\n+\n+                    @Override\n+                    public void onSubscribe(Subscription subscription) {\n+                        this.subscription = subscription;\n+                        subscription.request(Long.MAX_VALUE);\n+                    }\n+\n+                    @Override\n+                    public void onNext(DataChunk item) {\n+                        latch.countDown();\n+                        subscription.cancel();\n+                    }\n+\n+                    @Override\n+                    public void onError(Throwable throwable) {\n+                    }\n+\n+                    @Override\n+                    public void onComplete() {\n+                    }\n+                });\n+            } else {\n+                assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part2\"));\n+                DataChunkSubscriber subscriber = new DataChunkSubscriber();\n+                part.content().subscribe(subscriber);\n+                subscriber.content().thenAccept(body -> {\n+                    latch.countDown();\n+                    assertThat(body, is(equalTo(\"This is the 2nd body.\")));\n+                });\n+            }\n+        };\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(SUBSCRIBER_TYPE.ONE_BY_ONE, consumer);\n+        partsPublisher(boundary, chunk1, chunk2, chunk3, chunk4).subscribe(testSubscriber);\n+        waitOnLatch(latch);\n+        assertThat(testSubscriber.error, is(nullValue()));\n+        assertThat(testSubscriber.complete, is(equalTo(true)));\n+    }\n+\n+    @Test\n+    public void testPartContentSubscriberThrottling() {\n+        String boundary = \"boundary\";\n+        final byte[] chunk1 = (\"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part1\\n\"\n+                + \"\\n\"\n+                + \"body 1.aaaa\\n\").getBytes();\n+        final byte[] chunk2 = \"body 1.bbbb\\n\".getBytes();\n+        final byte[] chunk3 = (\"body 1.cccc\\n\"\n+                + \"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part2\\n\"\n+                + \"\\n\"\n+                + \"This is the 2nd\").getBytes();\n+        final byte[] chunk4 = (\"body.\\n\"\n+                + \"--\" + boundary + \"--\").getBytes();\n+\n+        final CountDownLatch latch = new CountDownLatch(3);\n+        Consumer<BodyPart> consumer = (part) -> {\n+            latch.countDown();\n+            if (latch.getCount() == 2) {\n+                assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part1\"));\n+            }\n+            part.content().subscribe(new Subscriber<DataChunk>() {\n+\n+                @Override\n+                public void onSubscribe(Subscription subscription) {\n+                    subscription.request(1);\n+                }\n+\n+                @Override\n+                public void onNext(DataChunk item) {\n+                    latch.countDown();\n+                }\n+\n+                @Override\n+                public void onError(Throwable throwable) {\n+                }\n+\n+                @Override\n+                public void onComplete() {\n+                }\n+            });\n+        };\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(SUBSCRIBER_TYPE.ONE_BY_ONE, consumer);\n+        partsPublisher(boundary, chunk1, chunk2, chunk3, chunk4).subscribe(testSubscriber);\n+        waitOnLatchNegative(latch, \"the 2nd part should not be processed\");\n+        assertThat(latch.getCount(), is(equalTo(1L)));\n+        assertThat(testSubscriber.error, is(nullValue()));\n+        assertThat(testSubscriber.complete, is(equalTo(false)));\n+    }\n+\n+    @Test\n+    public void testUpstreamError() {\n+        MultiPartDecoder decoder = MultiPartDecoder.create(\"boundary\", MEDIA_CONTEXT.readerContext());\n+        new Publisher<DataChunk>(){\n+            @Override\n+            public void subscribe(Subscriber<? super DataChunk> subscriber) {\n+                subscriber.onError(new IllegalStateException(\"oops\"));\n+            }\n+        }.subscribe(decoder);\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(SUBSCRIBER_TYPE.INFINITE, null);\n+        decoder.subscribe(testSubscriber);\n+        assertThat(testSubscriber.complete, is(equalTo(false)));\n+        assertThat(testSubscriber.error, is(notNullValue()));\n+        assertThat(testSubscriber.error.getMessage(), is(equalTo(\"oops\")));\n+    }\n+\n+    @Test\n+    public void testSubcribingMoreThanOnce() {\n+        MultiPartDecoder decoder = MultiPartDecoder.create(\"boundary\", MEDIA_CONTEXT.readerContext());\n+        chunksPublisher(\"foo\".getBytes()).subscribe(decoder);\n+        try {\n+            chunksPublisher(\"bar\".getBytes()).subscribe(decoder);\n+            fail(\"exception should be thrown\");\n+        } catch(IllegalStateException ex) {\n+            assertThat(ex.getMessage(), is(equalTo(\"Input subscription already set\")));\n+        }\n+    }\n+\n+    /**\n+     * Types of test subscribers.\n+     */\n+    enum SUBSCRIBER_TYPE {\n+        INFINITE,\n+        ONE_BY_ONE,\n+        CANCEL_AFTER_ONE,\n+    }\n+\n+    /**\n+     * A part test subscriber.\n+     */\n+    static class BodyPartSubscriber implements Subscriber<BodyPart>{\n+\n+        private final SUBSCRIBER_TYPE subscriberType;\n+        private final Consumer<BodyPart> consumer;\n+        private Subscription subcription;\n+        private Throwable error;\n+        private boolean complete;\n+\n+        BodyPartSubscriber(SUBSCRIBER_TYPE subscriberType, Consumer<BodyPart> consumer) {\n+            this.subscriberType = subscriberType;\n+            this.consumer = consumer;\n+        }\n+\n+        @Override\n+        public void onSubscribe(Subscription subscription) {\n+            this.subcription = subscription;\n+            if (subscriberType == SUBSCRIBER_TYPE.INFINITE) {\n+                subscription.request(Long.MAX_VALUE);\n+            } else {\n+                subscription.request(1);\n+            }\n+        }\n+\n+        @Override\n+        public void onNext(BodyPart item) {\n+            if (consumer == null){\n+                return;\n+            }\n+            consumer.accept(item);\n+            if (subscriberType == SUBSCRIBER_TYPE.ONE_BY_ONE) {\n+                subcription.request(1);\n+            } else if (subscriberType == SUBSCRIBER_TYPE.CANCEL_AFTER_ONE) {\n+                subcription.cancel();\n+            }\n+        }\n+\n+        @Override\n+        public void onError(Throwable ex) {\n+            error = ex;\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            complete = true;\n+        }\n+    }\n+\n+    /**\n+     * Create the parts publisher for the specified boundary and request\n+     * chunks.\n+     * @param boundary multipart boundary string\n+     * @param chunks request chunks\n+     * @return publisher of body parts\n+     */\n+    static Publisher<? extends BodyPart> partsPublisher(String boundary, byte[]... chunks) {\n+        MultiPartDecoder decoder = MultiPartDecoder.create(boundary, MEDIA_CONTEXT.readerContext());\n+        chunksPublisher(chunks).subscribe(decoder);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e9d1a876a27e52a81c6921cffe786d5d5a1208d"}, "originalPosition": 494}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI2ODAyMQ==", "bodyText": "Yes, this would simplify using processors.", "url": "https://github.com/oracle/helidon/pull/1787#discussion_r425268021", "createdAt": "2020-05-14T16:24:22Z", "author": {"login": "romain-grecourt"}, "path": "media/multipart/common/src/test/java/io/helidon/media/multipart/common/MultiPartDecoderTest.java", "diffHunk": "@@ -0,0 +1,571 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.helidon.media.multipart.common;\n+\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Flow.Publisher;\n+import java.util.concurrent.Flow.Subscriber;\n+import java.util.concurrent.Flow.Subscription;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import io.helidon.common.http.DataChunk;\n+import io.helidon.common.reactive.Multi;\n+\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.CoreMatchers.hasItems;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.CoreMatchers.nullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static io.helidon.media.multipart.common.BodyPartTest.MEDIA_CONTEXT;\n+\n+/**\n+ * Tests {@link MultiPartDecoder}.\n+ */\n+public class MultiPartDecoderTest {\n+\n+    private static final Logger LOGGER = Logger.getLogger(MultiPartDecoder.class.getName());\n+\n+    @BeforeAll\n+    public static void before() {\n+        LOGGER.setLevel(Level.ALL);\n+    }\n+\n+    @AfterAll\n+    public static void after() {\n+        LOGGER.setLevel(Level.INFO);\n+    }\n+\n+    @Test\n+    public void testOnePartInOneChunk() {\n+        String boundary = \"boundary\";\n+        final byte[] chunk1 = (\"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part1\\n\"\n+                + \"\\n\"\n+                + \"body 1\\n\"\n+                + \"--\" + boundary + \"--\").getBytes();\n+\n+        final CountDownLatch latch = new CountDownLatch(2);\n+        Consumer<BodyPart> consumer = (part) -> {\n+            latch.countDown();\n+            assertThat(part.headers().values(\"Content-Id\"),\n+                    hasItems(\"part1\"));\n+            DataChunkSubscriber subscriber = new DataChunkSubscriber();\n+            part.content().subscribe(subscriber);\n+            subscriber.content().thenAccept(body -> {\n+                latch.countDown();\n+                assertThat(body, is(equalTo(\"body 1\")));\n+            });\n+        };\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(\n+                SUBSCRIBER_TYPE.INFINITE, consumer);\n+        partsPublisher(boundary, chunk1).subscribe(testSubscriber);\n+        waitOnLatch(latch);\n+        assertThat(testSubscriber.error, is(nullValue()));\n+        assertThat(testSubscriber.complete, is(equalTo(true)));\n+    }\n+\n+    @Test\n+    public void testTwoPartsInOneChunk() {\n+        String boundary = \"boundary\";\n+        final byte[] chunk1 = (\"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part1\\n\"\n+                + \"\\n\"\n+                + \"body 1\\n\"\n+                + \"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part2\\n\"\n+                + \"\\n\"\n+                + \"body 2\\n\"\n+                + \"--\" + boundary + \"--\").getBytes();\n+\n+        final CountDownLatch latch = new CountDownLatch(4);\n+        Consumer<BodyPart> consumer = (part) -> {\n+            latch.countDown();\n+            if (latch.getCount() == 3) {\n+                assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part1\"));\n+                DataChunkSubscriber subscriber = new DataChunkSubscriber();\n+                part.content().subscribe(subscriber);\n+                subscriber.content().thenAccept(body -> {\n+                    latch.countDown();\n+                    assertThat(body, is(equalTo(\"body 1\")));\n+                });\n+            } else {\n+                assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part2\"));\n+                DataChunkSubscriber subscriber = new DataChunkSubscriber();\n+                part.content().subscribe(subscriber);\n+                subscriber.content().thenAccept(body -> {\n+                    latch.countDown();\n+                    assertThat(body, is(equalTo(\"body 2\")));\n+                });\n+            }\n+        };\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(SUBSCRIBER_TYPE.INFINITE, consumer);\n+        partsPublisher(boundary, chunk1).subscribe(testSubscriber);\n+        waitOnLatch(latch);\n+        assertThat(testSubscriber.error, is(nullValue()));\n+        assertThat(testSubscriber.complete, is(equalTo(true)));\n+    }\n+\n+    @Test\n+    public void testContentAcrossChunks() {\n+        String boundary = \"boundary\";\n+        final byte[] chunk1 = (\"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part1\\n\"\n+                + \"\\n\"\n+                + \"this-is-the-1st-slice-of-the-body\\n\").getBytes();\n+        final byte[] chunk2 = (\"this-is-the-2nd-slice-of-the-body\\n\"\n+                + \"--\" + boundary + \"--\").getBytes();\n+\n+        final CountDownLatch latch = new CountDownLatch(2);\n+        Consumer<BodyPart> consumer = (part) -> {\n+            latch.countDown();\n+            assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part1\"));\n+            DataChunkSubscriber subscriber = new DataChunkSubscriber();\n+            part.content().subscribe(subscriber);\n+            subscriber.content().thenAccept(body -> {\n+                latch.countDown();\n+                assertThat(body, is(equalTo(\n+                        \"this-is-the-1st-slice-of-the-body\\n\"\n+                        + \"this-is-the-2nd-slice-of-the-body\")));\n+            });\n+        };\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(SUBSCRIBER_TYPE.INFINITE, consumer);\n+        partsPublisher(boundary, chunk1, chunk2).subscribe(testSubscriber);\n+        waitOnLatch(latch);\n+        assertThat(testSubscriber.error, is(nullValue()));\n+        assertThat(testSubscriber.complete, is(equalTo(true)));\n+    }\n+\n+    @Test\n+    public void testMultipleChunksBeforeContent() {\n+        String boundary = \"boundary\";\n+        final byte[] chunk1 = (\"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part1\\n\").getBytes();\n+        final byte[] chunk2 = \"Content-Type: text/plain\\n\".getBytes();\n+        final byte[] chunk3 = \"Set-Cookie: bob=alice\\n\".getBytes();\n+        final byte[] chunk4 = \"Set-Cookie: foo=bar\\n\".getBytes();\n+        final byte[] chunk5 = (\"\\n\"\n+                + \"body 1\\n\"\n+                + \"--\" + boundary + \"--\").getBytes();\n+\n+        final CountDownLatch latch = new CountDownLatch(2);\n+        Consumer<BodyPart> consumer = (part) -> {\n+            latch.countDown();\n+            assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part1\"));\n+            assertThat(part.headers().values(\"Content-Type\"), hasItems(\"text/plain\"));\n+            assertThat(part.headers().values(\"Set-Cookie\"), hasItems(\"bob=alice\", \"foo=bar\"));\n+            DataChunkSubscriber subscriber = new DataChunkSubscriber();\n+            part.content().subscribe(subscriber);\n+            subscriber.content().thenAccept(body -> {\n+                latch.countDown();\n+                assertThat(body, is(equalTo(\"body 1\")));\n+            });\n+        };\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(SUBSCRIBER_TYPE.INFINITE, consumer);\n+        partsPublisher(boundary, chunk1, chunk2, chunk3, chunk4, chunk5).subscribe(testSubscriber);\n+        waitOnLatch(latch);\n+        assertThat(testSubscriber.error, is(nullValue()));\n+        assertThat(testSubscriber.complete, is(equalTo(true)));\n+    }\n+\n+    @Test\n+    public void testMulitiplePartsWithOneByOneSubscriber() {\n+        String boundary = \"boundary\";\n+        final byte[] chunk1 = (\"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part1\\n\"\n+                + \"\\n\"\n+                + \"body 1\\n\"\n+                + \"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part2\\n\"\n+                + \"\\n\"\n+                + \"body 2\\n\"\n+                + \"--\" + boundary + \"--\").getBytes();\n+\n+        final CountDownLatch latch = new CountDownLatch(4);\n+        Consumer<BodyPart> consumer = (part) -> {\n+            latch.countDown();\n+            if (latch.getCount()== 3) {\n+                assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part1\"));\n+                DataChunkSubscriber subscriber = new DataChunkSubscriber();\n+                part.content().subscribe(subscriber);\n+                subscriber.content().thenAccept(body -> {\n+                    latch.countDown();\n+                    assertThat(body, is(equalTo(\"body 1\")));\n+                });\n+            } else {\n+                assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part2\"));\n+                DataChunkSubscriber subscriber = new DataChunkSubscriber();\n+                part.content().subscribe(subscriber);\n+                subscriber.content().thenAccept(body -> {\n+                    latch.countDown();\n+                    assertThat(body, is(equalTo(\"body 2\")));\n+                });\n+            }\n+        };\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(SUBSCRIBER_TYPE.ONE_BY_ONE, consumer);\n+        partsPublisher(boundary, chunk1).subscribe(testSubscriber);\n+        waitOnLatch(latch);\n+        assertThat(testSubscriber.error, is(nullValue()));\n+        assertThat(testSubscriber.complete, is(equalTo(true)));\n+    }\n+\n+    @Test\n+    public void testSubscriberCancelAfterOnePart() {\n+        String boundary = \"boundary\";\n+        final byte[] chunk1 = (\"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part1\\n\"\n+                + \"\\n\"\n+                + \"body 1\\n\"\n+                + \"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part2\\n\"\n+                + \"\\n\"\n+                + \"body 2\\n\"\n+                + \"--\" + boundary + \"--\").getBytes();\n+\n+        final CountDownLatch latch = new CountDownLatch(2);\n+        Consumer<BodyPart> consumer = (part) -> {\n+            latch.countDown();\n+            if (latch.getCount()== 1) {\n+                assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part1\"));\n+                DataChunkSubscriber subscriber1 = new DataChunkSubscriber();\n+                part.content().subscribe(subscriber1);\n+                subscriber1.content().thenAccept(body -> {\n+                    latch.countDown();\n+                    assertThat(body, is(equalTo(\"body 1\")));\n+                });\n+            }\n+        };\n+\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(SUBSCRIBER_TYPE.CANCEL_AFTER_ONE, consumer);\n+        partsPublisher(boundary, chunk1).subscribe(testSubscriber);\n+        waitOnLatch(latch);\n+        assertThat(testSubscriber.error, is(nullValue()));\n+        assertThat(testSubscriber.complete, is(equalTo(false)));\n+    }\n+\n+    @Test\n+    public void testNoClosingBoundary(){\n+        String boundary = \"boundary\";\n+        final byte[] chunk1 = (\"--\" + boundary + \"\\n\"\n+                + \"Content-Type: text/xml; charset=UTF-8\\n\"\n+                + \"Content-Id: part1\\n\"\n+                + \"\\n\"\n+                + \"<foo>bar</foo>\\n\").getBytes();\n+\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(SUBSCRIBER_TYPE.CANCEL_AFTER_ONE, null);\n+        partsPublisher(boundary, chunk1).subscribe(testSubscriber);\n+        assertThat(testSubscriber.complete, is(equalTo(false)));\n+        assertThat(testSubscriber.error, is(notNullValue()));\n+        assertThat(testSubscriber.error.getClass(), is(equalTo(MIMEParser.ParsingException.class)));\n+        assertThat(testSubscriber.error.getMessage(), is(equalTo(\"No closing MIME boundary\")));\n+    }\n+\n+    @Test\n+    public void testCanceledPartSubscription() {\n+        String boundary = \"boundary\";\n+        final byte[] chunk1 = (\"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part1\\n\"\n+                + \"\\n\"\n+                + \"body 1.aaaa\\n\").getBytes();\n+        final byte[] chunk2 = \"body 1.bbbb\\n\".getBytes();\n+        final byte[] chunk3 = (\"body 1.cccc\\n\"\n+                + \"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part2\\n\"\n+                + \"\\n\"\n+                + \"This is the 2nd\").getBytes();\n+        final byte[] chunk4 = (\"body.\\n\"\n+                + \"--\" + boundary + \"--\").getBytes();\n+\n+        final CountDownLatch latch = new CountDownLatch(4);\n+        Consumer<BodyPart> consumer = (part) -> {\n+            latch.countDown();\n+            if (latch.getCount() == 3) {\n+                assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part1\"));\n+                part.content().subscribe(new Subscriber<DataChunk>() {\n+                    Subscription subscription;\n+\n+                    @Override\n+                    public void onSubscribe(Subscription subscription) {\n+                        this.subscription = subscription;\n+                        subscription.request(Long.MAX_VALUE);\n+                    }\n+\n+                    @Override\n+                    public void onNext(DataChunk item) {\n+                        latch.countDown();\n+                        subscription.cancel();\n+                    }\n+\n+                    @Override\n+                    public void onError(Throwable throwable) {\n+                    }\n+\n+                    @Override\n+                    public void onComplete() {\n+                    }\n+                });\n+            } else {\n+                assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part2\"));\n+                DataChunkSubscriber subscriber = new DataChunkSubscriber();\n+                part.content().subscribe(subscriber);\n+                subscriber.content().thenAccept(body -> {\n+                    latch.countDown();\n+                    assertThat(body, is(equalTo(\"This is the 2nd body.\")));\n+                });\n+            }\n+        };\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(SUBSCRIBER_TYPE.ONE_BY_ONE, consumer);\n+        partsPublisher(boundary, chunk1, chunk2, chunk3, chunk4).subscribe(testSubscriber);\n+        waitOnLatch(latch);\n+        assertThat(testSubscriber.error, is(nullValue()));\n+        assertThat(testSubscriber.complete, is(equalTo(true)));\n+    }\n+\n+    @Test\n+    public void testPartContentSubscriberThrottling() {\n+        String boundary = \"boundary\";\n+        final byte[] chunk1 = (\"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part1\\n\"\n+                + \"\\n\"\n+                + \"body 1.aaaa\\n\").getBytes();\n+        final byte[] chunk2 = \"body 1.bbbb\\n\".getBytes();\n+        final byte[] chunk3 = (\"body 1.cccc\\n\"\n+                + \"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part2\\n\"\n+                + \"\\n\"\n+                + \"This is the 2nd\").getBytes();\n+        final byte[] chunk4 = (\"body.\\n\"\n+                + \"--\" + boundary + \"--\").getBytes();\n+\n+        final CountDownLatch latch = new CountDownLatch(3);\n+        Consumer<BodyPart> consumer = (part) -> {\n+            latch.countDown();\n+            if (latch.getCount() == 2) {\n+                assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part1\"));\n+            }\n+            part.content().subscribe(new Subscriber<DataChunk>() {\n+\n+                @Override\n+                public void onSubscribe(Subscription subscription) {\n+                    subscription.request(1);\n+                }\n+\n+                @Override\n+                public void onNext(DataChunk item) {\n+                    latch.countDown();\n+                }\n+\n+                @Override\n+                public void onError(Throwable throwable) {\n+                }\n+\n+                @Override\n+                public void onComplete() {\n+                }\n+            });\n+        };\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(SUBSCRIBER_TYPE.ONE_BY_ONE, consumer);\n+        partsPublisher(boundary, chunk1, chunk2, chunk3, chunk4).subscribe(testSubscriber);\n+        waitOnLatchNegative(latch, \"the 2nd part should not be processed\");\n+        assertThat(latch.getCount(), is(equalTo(1L)));\n+        assertThat(testSubscriber.error, is(nullValue()));\n+        assertThat(testSubscriber.complete, is(equalTo(false)));\n+    }\n+\n+    @Test\n+    public void testUpstreamError() {\n+        MultiPartDecoder decoder = MultiPartDecoder.create(\"boundary\", MEDIA_CONTEXT.readerContext());\n+        new Publisher<DataChunk>(){\n+            @Override\n+            public void subscribe(Subscriber<? super DataChunk> subscriber) {\n+                subscriber.onError(new IllegalStateException(\"oops\"));\n+            }\n+        }.subscribe(decoder);\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(SUBSCRIBER_TYPE.INFINITE, null);\n+        decoder.subscribe(testSubscriber);\n+        assertThat(testSubscriber.complete, is(equalTo(false)));\n+        assertThat(testSubscriber.error, is(notNullValue()));\n+        assertThat(testSubscriber.error.getMessage(), is(equalTo(\"oops\")));\n+    }\n+\n+    @Test\n+    public void testSubcribingMoreThanOnce() {\n+        MultiPartDecoder decoder = MultiPartDecoder.create(\"boundary\", MEDIA_CONTEXT.readerContext());\n+        chunksPublisher(\"foo\".getBytes()).subscribe(decoder);\n+        try {\n+            chunksPublisher(\"bar\".getBytes()).subscribe(decoder);\n+            fail(\"exception should be thrown\");\n+        } catch(IllegalStateException ex) {\n+            assertThat(ex.getMessage(), is(equalTo(\"Input subscription already set\")));\n+        }\n+    }\n+\n+    /**\n+     * Types of test subscribers.\n+     */\n+    enum SUBSCRIBER_TYPE {\n+        INFINITE,\n+        ONE_BY_ONE,\n+        CANCEL_AFTER_ONE,\n+    }\n+\n+    /**\n+     * A part test subscriber.\n+     */\n+    static class BodyPartSubscriber implements Subscriber<BodyPart>{\n+\n+        private final SUBSCRIBER_TYPE subscriberType;\n+        private final Consumer<BodyPart> consumer;\n+        private Subscription subcription;\n+        private Throwable error;\n+        private boolean complete;\n+\n+        BodyPartSubscriber(SUBSCRIBER_TYPE subscriberType, Consumer<BodyPart> consumer) {\n+            this.subscriberType = subscriberType;\n+            this.consumer = consumer;\n+        }\n+\n+        @Override\n+        public void onSubscribe(Subscription subscription) {\n+            this.subcription = subscription;\n+            if (subscriberType == SUBSCRIBER_TYPE.INFINITE) {\n+                subscription.request(Long.MAX_VALUE);\n+            } else {\n+                subscription.request(1);\n+            }\n+        }\n+\n+        @Override\n+        public void onNext(BodyPart item) {\n+            if (consumer == null){\n+                return;\n+            }\n+            consumer.accept(item);\n+            if (subscriberType == SUBSCRIBER_TYPE.ONE_BY_ONE) {\n+                subcription.request(1);\n+            } else if (subscriberType == SUBSCRIBER_TYPE.CANCEL_AFTER_ONE) {\n+                subcription.cancel();\n+            }\n+        }\n+\n+        @Override\n+        public void onError(Throwable ex) {\n+            error = ex;\n+        }\n+\n+        @Override\n+        public void onComplete() {\n+            complete = true;\n+        }\n+    }\n+\n+    /**\n+     * Create the parts publisher for the specified boundary and request\n+     * chunks.\n+     * @param boundary multipart boundary string\n+     * @param chunks request chunks\n+     * @return publisher of body parts\n+     */\n+    static Publisher<? extends BodyPart> partsPublisher(String boundary, byte[]... chunks) {\n+        MultiPartDecoder decoder = MultiPartDecoder.create(boundary, MEDIA_CONTEXT.readerContext());\n+        chunksPublisher(chunks).subscribe(decoder);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA2MDA1OA=="}, "originalCommit": {"oid": "1e9d1a876a27e52a81c6921cffe786d5d5a1208d"}, "originalPosition": 494}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0Njk2OTg5OnYy", "diffSide": "RIGHT", "path": "media/multipart/common/src/test/java/io/helidon/media/multipart/common/MultiPartDecoderTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxMToyMTowNVrOGVXuDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQwMjo1NDo1MVrOGWXvdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA2MTkwMg==", "bodyText": "Its not required by spec, is there business reason for this check?", "url": "https://github.com/oracle/helidon/pull/1787#discussion_r425061902", "createdAt": "2020-05-14T11:21:05Z", "author": {"login": "danielkec"}, "path": "media/multipart/common/src/test/java/io/helidon/media/multipart/common/MultiPartDecoderTest.java", "diffHunk": "@@ -0,0 +1,571 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.helidon.media.multipart.common;\n+\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Flow.Publisher;\n+import java.util.concurrent.Flow.Subscriber;\n+import java.util.concurrent.Flow.Subscription;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import io.helidon.common.http.DataChunk;\n+import io.helidon.common.reactive.Multi;\n+\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.CoreMatchers.hasItems;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.CoreMatchers.nullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static io.helidon.media.multipart.common.BodyPartTest.MEDIA_CONTEXT;\n+\n+/**\n+ * Tests {@link MultiPartDecoder}.\n+ */\n+public class MultiPartDecoderTest {\n+\n+    private static final Logger LOGGER = Logger.getLogger(MultiPartDecoder.class.getName());\n+\n+    @BeforeAll\n+    public static void before() {\n+        LOGGER.setLevel(Level.ALL);\n+    }\n+\n+    @AfterAll\n+    public static void after() {\n+        LOGGER.setLevel(Level.INFO);\n+    }\n+\n+    @Test\n+    public void testOnePartInOneChunk() {\n+        String boundary = \"boundary\";\n+        final byte[] chunk1 = (\"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part1\\n\"\n+                + \"\\n\"\n+                + \"body 1\\n\"\n+                + \"--\" + boundary + \"--\").getBytes();\n+\n+        final CountDownLatch latch = new CountDownLatch(2);\n+        Consumer<BodyPart> consumer = (part) -> {\n+            latch.countDown();\n+            assertThat(part.headers().values(\"Content-Id\"),\n+                    hasItems(\"part1\"));\n+            DataChunkSubscriber subscriber = new DataChunkSubscriber();\n+            part.content().subscribe(subscriber);\n+            subscriber.content().thenAccept(body -> {\n+                latch.countDown();\n+                assertThat(body, is(equalTo(\"body 1\")));\n+            });\n+        };\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(\n+                SUBSCRIBER_TYPE.INFINITE, consumer);\n+        partsPublisher(boundary, chunk1).subscribe(testSubscriber);\n+        waitOnLatch(latch);\n+        assertThat(testSubscriber.error, is(nullValue()));\n+        assertThat(testSubscriber.complete, is(equalTo(true)));\n+    }\n+\n+    @Test\n+    public void testTwoPartsInOneChunk() {\n+        String boundary = \"boundary\";\n+        final byte[] chunk1 = (\"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part1\\n\"\n+                + \"\\n\"\n+                + \"body 1\\n\"\n+                + \"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part2\\n\"\n+                + \"\\n\"\n+                + \"body 2\\n\"\n+                + \"--\" + boundary + \"--\").getBytes();\n+\n+        final CountDownLatch latch = new CountDownLatch(4);\n+        Consumer<BodyPart> consumer = (part) -> {\n+            latch.countDown();\n+            if (latch.getCount() == 3) {\n+                assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part1\"));\n+                DataChunkSubscriber subscriber = new DataChunkSubscriber();\n+                part.content().subscribe(subscriber);\n+                subscriber.content().thenAccept(body -> {\n+                    latch.countDown();\n+                    assertThat(body, is(equalTo(\"body 1\")));\n+                });\n+            } else {\n+                assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part2\"));\n+                DataChunkSubscriber subscriber = new DataChunkSubscriber();\n+                part.content().subscribe(subscriber);\n+                subscriber.content().thenAccept(body -> {\n+                    latch.countDown();\n+                    assertThat(body, is(equalTo(\"body 2\")));\n+                });\n+            }\n+        };\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(SUBSCRIBER_TYPE.INFINITE, consumer);\n+        partsPublisher(boundary, chunk1).subscribe(testSubscriber);\n+        waitOnLatch(latch);\n+        assertThat(testSubscriber.error, is(nullValue()));\n+        assertThat(testSubscriber.complete, is(equalTo(true)));\n+    }\n+\n+    @Test\n+    public void testContentAcrossChunks() {\n+        String boundary = \"boundary\";\n+        final byte[] chunk1 = (\"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part1\\n\"\n+                + \"\\n\"\n+                + \"this-is-the-1st-slice-of-the-body\\n\").getBytes();\n+        final byte[] chunk2 = (\"this-is-the-2nd-slice-of-the-body\\n\"\n+                + \"--\" + boundary + \"--\").getBytes();\n+\n+        final CountDownLatch latch = new CountDownLatch(2);\n+        Consumer<BodyPart> consumer = (part) -> {\n+            latch.countDown();\n+            assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part1\"));\n+            DataChunkSubscriber subscriber = new DataChunkSubscriber();\n+            part.content().subscribe(subscriber);\n+            subscriber.content().thenAccept(body -> {\n+                latch.countDown();\n+                assertThat(body, is(equalTo(\n+                        \"this-is-the-1st-slice-of-the-body\\n\"\n+                        + \"this-is-the-2nd-slice-of-the-body\")));\n+            });\n+        };\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(SUBSCRIBER_TYPE.INFINITE, consumer);\n+        partsPublisher(boundary, chunk1, chunk2).subscribe(testSubscriber);\n+        waitOnLatch(latch);\n+        assertThat(testSubscriber.error, is(nullValue()));\n+        assertThat(testSubscriber.complete, is(equalTo(true)));\n+    }\n+\n+    @Test\n+    public void testMultipleChunksBeforeContent() {\n+        String boundary = \"boundary\";\n+        final byte[] chunk1 = (\"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part1\\n\").getBytes();\n+        final byte[] chunk2 = \"Content-Type: text/plain\\n\".getBytes();\n+        final byte[] chunk3 = \"Set-Cookie: bob=alice\\n\".getBytes();\n+        final byte[] chunk4 = \"Set-Cookie: foo=bar\\n\".getBytes();\n+        final byte[] chunk5 = (\"\\n\"\n+                + \"body 1\\n\"\n+                + \"--\" + boundary + \"--\").getBytes();\n+\n+        final CountDownLatch latch = new CountDownLatch(2);\n+        Consumer<BodyPart> consumer = (part) -> {\n+            latch.countDown();\n+            assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part1\"));\n+            assertThat(part.headers().values(\"Content-Type\"), hasItems(\"text/plain\"));\n+            assertThat(part.headers().values(\"Set-Cookie\"), hasItems(\"bob=alice\", \"foo=bar\"));\n+            DataChunkSubscriber subscriber = new DataChunkSubscriber();\n+            part.content().subscribe(subscriber);\n+            subscriber.content().thenAccept(body -> {\n+                latch.countDown();\n+                assertThat(body, is(equalTo(\"body 1\")));\n+            });\n+        };\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(SUBSCRIBER_TYPE.INFINITE, consumer);\n+        partsPublisher(boundary, chunk1, chunk2, chunk3, chunk4, chunk5).subscribe(testSubscriber);\n+        waitOnLatch(latch);\n+        assertThat(testSubscriber.error, is(nullValue()));\n+        assertThat(testSubscriber.complete, is(equalTo(true)));\n+    }\n+\n+    @Test\n+    public void testMulitiplePartsWithOneByOneSubscriber() {\n+        String boundary = \"boundary\";\n+        final byte[] chunk1 = (\"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part1\\n\"\n+                + \"\\n\"\n+                + \"body 1\\n\"\n+                + \"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part2\\n\"\n+                + \"\\n\"\n+                + \"body 2\\n\"\n+                + \"--\" + boundary + \"--\").getBytes();\n+\n+        final CountDownLatch latch = new CountDownLatch(4);\n+        Consumer<BodyPart> consumer = (part) -> {\n+            latch.countDown();\n+            if (latch.getCount()== 3) {\n+                assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part1\"));\n+                DataChunkSubscriber subscriber = new DataChunkSubscriber();\n+                part.content().subscribe(subscriber);\n+                subscriber.content().thenAccept(body -> {\n+                    latch.countDown();\n+                    assertThat(body, is(equalTo(\"body 1\")));\n+                });\n+            } else {\n+                assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part2\"));\n+                DataChunkSubscriber subscriber = new DataChunkSubscriber();\n+                part.content().subscribe(subscriber);\n+                subscriber.content().thenAccept(body -> {\n+                    latch.countDown();\n+                    assertThat(body, is(equalTo(\"body 2\")));\n+                });\n+            }\n+        };\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(SUBSCRIBER_TYPE.ONE_BY_ONE, consumer);\n+        partsPublisher(boundary, chunk1).subscribe(testSubscriber);\n+        waitOnLatch(latch);\n+        assertThat(testSubscriber.error, is(nullValue()));\n+        assertThat(testSubscriber.complete, is(equalTo(true)));\n+    }\n+\n+    @Test\n+    public void testSubscriberCancelAfterOnePart() {\n+        String boundary = \"boundary\";\n+        final byte[] chunk1 = (\"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part1\\n\"\n+                + \"\\n\"\n+                + \"body 1\\n\"\n+                + \"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part2\\n\"\n+                + \"\\n\"\n+                + \"body 2\\n\"\n+                + \"--\" + boundary + \"--\").getBytes();\n+\n+        final CountDownLatch latch = new CountDownLatch(2);\n+        Consumer<BodyPart> consumer = (part) -> {\n+            latch.countDown();\n+            if (latch.getCount()== 1) {\n+                assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part1\"));\n+                DataChunkSubscriber subscriber1 = new DataChunkSubscriber();\n+                part.content().subscribe(subscriber1);\n+                subscriber1.content().thenAccept(body -> {\n+                    latch.countDown();\n+                    assertThat(body, is(equalTo(\"body 1\")));\n+                });\n+            }\n+        };\n+\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(SUBSCRIBER_TYPE.CANCEL_AFTER_ONE, consumer);\n+        partsPublisher(boundary, chunk1).subscribe(testSubscriber);\n+        waitOnLatch(latch);\n+        assertThat(testSubscriber.error, is(nullValue()));\n+        assertThat(testSubscriber.complete, is(equalTo(false)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e9d1a876a27e52a81c6921cffe786d5d5a1208d"}, "originalPosition": 266}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI2NzIxMg==", "bodyText": "Probably not, I wasn't looking at making these spec compliant at the time. Thanks for pointing this out, I will remove these.", "url": "https://github.com/oracle/helidon/pull/1787#discussion_r425267212", "createdAt": "2020-05-14T16:23:37Z", "author": {"login": "romain-grecourt"}, "path": "media/multipart/common/src/test/java/io/helidon/media/multipart/common/MultiPartDecoderTest.java", "diffHunk": "@@ -0,0 +1,571 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.helidon.media.multipart.common;\n+\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Flow.Publisher;\n+import java.util.concurrent.Flow.Subscriber;\n+import java.util.concurrent.Flow.Subscription;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import io.helidon.common.http.DataChunk;\n+import io.helidon.common.reactive.Multi;\n+\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.CoreMatchers.hasItems;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.CoreMatchers.nullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static io.helidon.media.multipart.common.BodyPartTest.MEDIA_CONTEXT;\n+\n+/**\n+ * Tests {@link MultiPartDecoder}.\n+ */\n+public class MultiPartDecoderTest {\n+\n+    private static final Logger LOGGER = Logger.getLogger(MultiPartDecoder.class.getName());\n+\n+    @BeforeAll\n+    public static void before() {\n+        LOGGER.setLevel(Level.ALL);\n+    }\n+\n+    @AfterAll\n+    public static void after() {\n+        LOGGER.setLevel(Level.INFO);\n+    }\n+\n+    @Test\n+    public void testOnePartInOneChunk() {\n+        String boundary = \"boundary\";\n+        final byte[] chunk1 = (\"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part1\\n\"\n+                + \"\\n\"\n+                + \"body 1\\n\"\n+                + \"--\" + boundary + \"--\").getBytes();\n+\n+        final CountDownLatch latch = new CountDownLatch(2);\n+        Consumer<BodyPart> consumer = (part) -> {\n+            latch.countDown();\n+            assertThat(part.headers().values(\"Content-Id\"),\n+                    hasItems(\"part1\"));\n+            DataChunkSubscriber subscriber = new DataChunkSubscriber();\n+            part.content().subscribe(subscriber);\n+            subscriber.content().thenAccept(body -> {\n+                latch.countDown();\n+                assertThat(body, is(equalTo(\"body 1\")));\n+            });\n+        };\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(\n+                SUBSCRIBER_TYPE.INFINITE, consumer);\n+        partsPublisher(boundary, chunk1).subscribe(testSubscriber);\n+        waitOnLatch(latch);\n+        assertThat(testSubscriber.error, is(nullValue()));\n+        assertThat(testSubscriber.complete, is(equalTo(true)));\n+    }\n+\n+    @Test\n+    public void testTwoPartsInOneChunk() {\n+        String boundary = \"boundary\";\n+        final byte[] chunk1 = (\"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part1\\n\"\n+                + \"\\n\"\n+                + \"body 1\\n\"\n+                + \"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part2\\n\"\n+                + \"\\n\"\n+                + \"body 2\\n\"\n+                + \"--\" + boundary + \"--\").getBytes();\n+\n+        final CountDownLatch latch = new CountDownLatch(4);\n+        Consumer<BodyPart> consumer = (part) -> {\n+            latch.countDown();\n+            if (latch.getCount() == 3) {\n+                assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part1\"));\n+                DataChunkSubscriber subscriber = new DataChunkSubscriber();\n+                part.content().subscribe(subscriber);\n+                subscriber.content().thenAccept(body -> {\n+                    latch.countDown();\n+                    assertThat(body, is(equalTo(\"body 1\")));\n+                });\n+            } else {\n+                assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part2\"));\n+                DataChunkSubscriber subscriber = new DataChunkSubscriber();\n+                part.content().subscribe(subscriber);\n+                subscriber.content().thenAccept(body -> {\n+                    latch.countDown();\n+                    assertThat(body, is(equalTo(\"body 2\")));\n+                });\n+            }\n+        };\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(SUBSCRIBER_TYPE.INFINITE, consumer);\n+        partsPublisher(boundary, chunk1).subscribe(testSubscriber);\n+        waitOnLatch(latch);\n+        assertThat(testSubscriber.error, is(nullValue()));\n+        assertThat(testSubscriber.complete, is(equalTo(true)));\n+    }\n+\n+    @Test\n+    public void testContentAcrossChunks() {\n+        String boundary = \"boundary\";\n+        final byte[] chunk1 = (\"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part1\\n\"\n+                + \"\\n\"\n+                + \"this-is-the-1st-slice-of-the-body\\n\").getBytes();\n+        final byte[] chunk2 = (\"this-is-the-2nd-slice-of-the-body\\n\"\n+                + \"--\" + boundary + \"--\").getBytes();\n+\n+        final CountDownLatch latch = new CountDownLatch(2);\n+        Consumer<BodyPart> consumer = (part) -> {\n+            latch.countDown();\n+            assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part1\"));\n+            DataChunkSubscriber subscriber = new DataChunkSubscriber();\n+            part.content().subscribe(subscriber);\n+            subscriber.content().thenAccept(body -> {\n+                latch.countDown();\n+                assertThat(body, is(equalTo(\n+                        \"this-is-the-1st-slice-of-the-body\\n\"\n+                        + \"this-is-the-2nd-slice-of-the-body\")));\n+            });\n+        };\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(SUBSCRIBER_TYPE.INFINITE, consumer);\n+        partsPublisher(boundary, chunk1, chunk2).subscribe(testSubscriber);\n+        waitOnLatch(latch);\n+        assertThat(testSubscriber.error, is(nullValue()));\n+        assertThat(testSubscriber.complete, is(equalTo(true)));\n+    }\n+\n+    @Test\n+    public void testMultipleChunksBeforeContent() {\n+        String boundary = \"boundary\";\n+        final byte[] chunk1 = (\"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part1\\n\").getBytes();\n+        final byte[] chunk2 = \"Content-Type: text/plain\\n\".getBytes();\n+        final byte[] chunk3 = \"Set-Cookie: bob=alice\\n\".getBytes();\n+        final byte[] chunk4 = \"Set-Cookie: foo=bar\\n\".getBytes();\n+        final byte[] chunk5 = (\"\\n\"\n+                + \"body 1\\n\"\n+                + \"--\" + boundary + \"--\").getBytes();\n+\n+        final CountDownLatch latch = new CountDownLatch(2);\n+        Consumer<BodyPart> consumer = (part) -> {\n+            latch.countDown();\n+            assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part1\"));\n+            assertThat(part.headers().values(\"Content-Type\"), hasItems(\"text/plain\"));\n+            assertThat(part.headers().values(\"Set-Cookie\"), hasItems(\"bob=alice\", \"foo=bar\"));\n+            DataChunkSubscriber subscriber = new DataChunkSubscriber();\n+            part.content().subscribe(subscriber);\n+            subscriber.content().thenAccept(body -> {\n+                latch.countDown();\n+                assertThat(body, is(equalTo(\"body 1\")));\n+            });\n+        };\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(SUBSCRIBER_TYPE.INFINITE, consumer);\n+        partsPublisher(boundary, chunk1, chunk2, chunk3, chunk4, chunk5).subscribe(testSubscriber);\n+        waitOnLatch(latch);\n+        assertThat(testSubscriber.error, is(nullValue()));\n+        assertThat(testSubscriber.complete, is(equalTo(true)));\n+    }\n+\n+    @Test\n+    public void testMulitiplePartsWithOneByOneSubscriber() {\n+        String boundary = \"boundary\";\n+        final byte[] chunk1 = (\"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part1\\n\"\n+                + \"\\n\"\n+                + \"body 1\\n\"\n+                + \"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part2\\n\"\n+                + \"\\n\"\n+                + \"body 2\\n\"\n+                + \"--\" + boundary + \"--\").getBytes();\n+\n+        final CountDownLatch latch = new CountDownLatch(4);\n+        Consumer<BodyPart> consumer = (part) -> {\n+            latch.countDown();\n+            if (latch.getCount()== 3) {\n+                assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part1\"));\n+                DataChunkSubscriber subscriber = new DataChunkSubscriber();\n+                part.content().subscribe(subscriber);\n+                subscriber.content().thenAccept(body -> {\n+                    latch.countDown();\n+                    assertThat(body, is(equalTo(\"body 1\")));\n+                });\n+            } else {\n+                assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part2\"));\n+                DataChunkSubscriber subscriber = new DataChunkSubscriber();\n+                part.content().subscribe(subscriber);\n+                subscriber.content().thenAccept(body -> {\n+                    latch.countDown();\n+                    assertThat(body, is(equalTo(\"body 2\")));\n+                });\n+            }\n+        };\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(SUBSCRIBER_TYPE.ONE_BY_ONE, consumer);\n+        partsPublisher(boundary, chunk1).subscribe(testSubscriber);\n+        waitOnLatch(latch);\n+        assertThat(testSubscriber.error, is(nullValue()));\n+        assertThat(testSubscriber.complete, is(equalTo(true)));\n+    }\n+\n+    @Test\n+    public void testSubscriberCancelAfterOnePart() {\n+        String boundary = \"boundary\";\n+        final byte[] chunk1 = (\"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part1\\n\"\n+                + \"\\n\"\n+                + \"body 1\\n\"\n+                + \"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part2\\n\"\n+                + \"\\n\"\n+                + \"body 2\\n\"\n+                + \"--\" + boundary + \"--\").getBytes();\n+\n+        final CountDownLatch latch = new CountDownLatch(2);\n+        Consumer<BodyPart> consumer = (part) -> {\n+            latch.countDown();\n+            if (latch.getCount()== 1) {\n+                assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part1\"));\n+                DataChunkSubscriber subscriber1 = new DataChunkSubscriber();\n+                part.content().subscribe(subscriber1);\n+                subscriber1.content().thenAccept(body -> {\n+                    latch.countDown();\n+                    assertThat(body, is(equalTo(\"body 1\")));\n+                });\n+            }\n+        };\n+\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(SUBSCRIBER_TYPE.CANCEL_AFTER_ONE, consumer);\n+        partsPublisher(boundary, chunk1).subscribe(testSubscriber);\n+        waitOnLatch(latch);\n+        assertThat(testSubscriber.error, is(nullValue()));\n+        assertThat(testSubscriber.complete, is(equalTo(false)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA2MTkwMg=="}, "originalCommit": {"oid": "1e9d1a876a27e52a81c6921cffe786d5d5a1208d"}, "originalPosition": 266}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjExMDgzNg==", "bodyText": "This test is doing a cancel after receiving the first item ; the assertions tests none of onError() and onComplete() were called.\nDo you mean that it is legal for a subscriber to received either of these signals after the subscription has been canceled ?\nThe code that implements onError and onComplete checks for canceled subscription, that's the only reason for these 2 assertions.", "url": "https://github.com/oracle/helidon/pull/1787#discussion_r426110836", "createdAt": "2020-05-16T02:54:51Z", "author": {"login": "romain-grecourt"}, "path": "media/multipart/common/src/test/java/io/helidon/media/multipart/common/MultiPartDecoderTest.java", "diffHunk": "@@ -0,0 +1,571 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.helidon.media.multipart.common;\n+\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Flow.Publisher;\n+import java.util.concurrent.Flow.Subscriber;\n+import java.util.concurrent.Flow.Subscription;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import io.helidon.common.http.DataChunk;\n+import io.helidon.common.reactive.Multi;\n+\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.CoreMatchers.hasItems;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.CoreMatchers.nullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static io.helidon.media.multipart.common.BodyPartTest.MEDIA_CONTEXT;\n+\n+/**\n+ * Tests {@link MultiPartDecoder}.\n+ */\n+public class MultiPartDecoderTest {\n+\n+    private static final Logger LOGGER = Logger.getLogger(MultiPartDecoder.class.getName());\n+\n+    @BeforeAll\n+    public static void before() {\n+        LOGGER.setLevel(Level.ALL);\n+    }\n+\n+    @AfterAll\n+    public static void after() {\n+        LOGGER.setLevel(Level.INFO);\n+    }\n+\n+    @Test\n+    public void testOnePartInOneChunk() {\n+        String boundary = \"boundary\";\n+        final byte[] chunk1 = (\"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part1\\n\"\n+                + \"\\n\"\n+                + \"body 1\\n\"\n+                + \"--\" + boundary + \"--\").getBytes();\n+\n+        final CountDownLatch latch = new CountDownLatch(2);\n+        Consumer<BodyPart> consumer = (part) -> {\n+            latch.countDown();\n+            assertThat(part.headers().values(\"Content-Id\"),\n+                    hasItems(\"part1\"));\n+            DataChunkSubscriber subscriber = new DataChunkSubscriber();\n+            part.content().subscribe(subscriber);\n+            subscriber.content().thenAccept(body -> {\n+                latch.countDown();\n+                assertThat(body, is(equalTo(\"body 1\")));\n+            });\n+        };\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(\n+                SUBSCRIBER_TYPE.INFINITE, consumer);\n+        partsPublisher(boundary, chunk1).subscribe(testSubscriber);\n+        waitOnLatch(latch);\n+        assertThat(testSubscriber.error, is(nullValue()));\n+        assertThat(testSubscriber.complete, is(equalTo(true)));\n+    }\n+\n+    @Test\n+    public void testTwoPartsInOneChunk() {\n+        String boundary = \"boundary\";\n+        final byte[] chunk1 = (\"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part1\\n\"\n+                + \"\\n\"\n+                + \"body 1\\n\"\n+                + \"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part2\\n\"\n+                + \"\\n\"\n+                + \"body 2\\n\"\n+                + \"--\" + boundary + \"--\").getBytes();\n+\n+        final CountDownLatch latch = new CountDownLatch(4);\n+        Consumer<BodyPart> consumer = (part) -> {\n+            latch.countDown();\n+            if (latch.getCount() == 3) {\n+                assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part1\"));\n+                DataChunkSubscriber subscriber = new DataChunkSubscriber();\n+                part.content().subscribe(subscriber);\n+                subscriber.content().thenAccept(body -> {\n+                    latch.countDown();\n+                    assertThat(body, is(equalTo(\"body 1\")));\n+                });\n+            } else {\n+                assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part2\"));\n+                DataChunkSubscriber subscriber = new DataChunkSubscriber();\n+                part.content().subscribe(subscriber);\n+                subscriber.content().thenAccept(body -> {\n+                    latch.countDown();\n+                    assertThat(body, is(equalTo(\"body 2\")));\n+                });\n+            }\n+        };\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(SUBSCRIBER_TYPE.INFINITE, consumer);\n+        partsPublisher(boundary, chunk1).subscribe(testSubscriber);\n+        waitOnLatch(latch);\n+        assertThat(testSubscriber.error, is(nullValue()));\n+        assertThat(testSubscriber.complete, is(equalTo(true)));\n+    }\n+\n+    @Test\n+    public void testContentAcrossChunks() {\n+        String boundary = \"boundary\";\n+        final byte[] chunk1 = (\"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part1\\n\"\n+                + \"\\n\"\n+                + \"this-is-the-1st-slice-of-the-body\\n\").getBytes();\n+        final byte[] chunk2 = (\"this-is-the-2nd-slice-of-the-body\\n\"\n+                + \"--\" + boundary + \"--\").getBytes();\n+\n+        final CountDownLatch latch = new CountDownLatch(2);\n+        Consumer<BodyPart> consumer = (part) -> {\n+            latch.countDown();\n+            assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part1\"));\n+            DataChunkSubscriber subscriber = new DataChunkSubscriber();\n+            part.content().subscribe(subscriber);\n+            subscriber.content().thenAccept(body -> {\n+                latch.countDown();\n+                assertThat(body, is(equalTo(\n+                        \"this-is-the-1st-slice-of-the-body\\n\"\n+                        + \"this-is-the-2nd-slice-of-the-body\")));\n+            });\n+        };\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(SUBSCRIBER_TYPE.INFINITE, consumer);\n+        partsPublisher(boundary, chunk1, chunk2).subscribe(testSubscriber);\n+        waitOnLatch(latch);\n+        assertThat(testSubscriber.error, is(nullValue()));\n+        assertThat(testSubscriber.complete, is(equalTo(true)));\n+    }\n+\n+    @Test\n+    public void testMultipleChunksBeforeContent() {\n+        String boundary = \"boundary\";\n+        final byte[] chunk1 = (\"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part1\\n\").getBytes();\n+        final byte[] chunk2 = \"Content-Type: text/plain\\n\".getBytes();\n+        final byte[] chunk3 = \"Set-Cookie: bob=alice\\n\".getBytes();\n+        final byte[] chunk4 = \"Set-Cookie: foo=bar\\n\".getBytes();\n+        final byte[] chunk5 = (\"\\n\"\n+                + \"body 1\\n\"\n+                + \"--\" + boundary + \"--\").getBytes();\n+\n+        final CountDownLatch latch = new CountDownLatch(2);\n+        Consumer<BodyPart> consumer = (part) -> {\n+            latch.countDown();\n+            assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part1\"));\n+            assertThat(part.headers().values(\"Content-Type\"), hasItems(\"text/plain\"));\n+            assertThat(part.headers().values(\"Set-Cookie\"), hasItems(\"bob=alice\", \"foo=bar\"));\n+            DataChunkSubscriber subscriber = new DataChunkSubscriber();\n+            part.content().subscribe(subscriber);\n+            subscriber.content().thenAccept(body -> {\n+                latch.countDown();\n+                assertThat(body, is(equalTo(\"body 1\")));\n+            });\n+        };\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(SUBSCRIBER_TYPE.INFINITE, consumer);\n+        partsPublisher(boundary, chunk1, chunk2, chunk3, chunk4, chunk5).subscribe(testSubscriber);\n+        waitOnLatch(latch);\n+        assertThat(testSubscriber.error, is(nullValue()));\n+        assertThat(testSubscriber.complete, is(equalTo(true)));\n+    }\n+\n+    @Test\n+    public void testMulitiplePartsWithOneByOneSubscriber() {\n+        String boundary = \"boundary\";\n+        final byte[] chunk1 = (\"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part1\\n\"\n+                + \"\\n\"\n+                + \"body 1\\n\"\n+                + \"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part2\\n\"\n+                + \"\\n\"\n+                + \"body 2\\n\"\n+                + \"--\" + boundary + \"--\").getBytes();\n+\n+        final CountDownLatch latch = new CountDownLatch(4);\n+        Consumer<BodyPart> consumer = (part) -> {\n+            latch.countDown();\n+            if (latch.getCount()== 3) {\n+                assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part1\"));\n+                DataChunkSubscriber subscriber = new DataChunkSubscriber();\n+                part.content().subscribe(subscriber);\n+                subscriber.content().thenAccept(body -> {\n+                    latch.countDown();\n+                    assertThat(body, is(equalTo(\"body 1\")));\n+                });\n+            } else {\n+                assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part2\"));\n+                DataChunkSubscriber subscriber = new DataChunkSubscriber();\n+                part.content().subscribe(subscriber);\n+                subscriber.content().thenAccept(body -> {\n+                    latch.countDown();\n+                    assertThat(body, is(equalTo(\"body 2\")));\n+                });\n+            }\n+        };\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(SUBSCRIBER_TYPE.ONE_BY_ONE, consumer);\n+        partsPublisher(boundary, chunk1).subscribe(testSubscriber);\n+        waitOnLatch(latch);\n+        assertThat(testSubscriber.error, is(nullValue()));\n+        assertThat(testSubscriber.complete, is(equalTo(true)));\n+    }\n+\n+    @Test\n+    public void testSubscriberCancelAfterOnePart() {\n+        String boundary = \"boundary\";\n+        final byte[] chunk1 = (\"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part1\\n\"\n+                + \"\\n\"\n+                + \"body 1\\n\"\n+                + \"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part2\\n\"\n+                + \"\\n\"\n+                + \"body 2\\n\"\n+                + \"--\" + boundary + \"--\").getBytes();\n+\n+        final CountDownLatch latch = new CountDownLatch(2);\n+        Consumer<BodyPart> consumer = (part) -> {\n+            latch.countDown();\n+            if (latch.getCount()== 1) {\n+                assertThat(part.headers().values(\"Content-Id\"), hasItems(\"part1\"));\n+                DataChunkSubscriber subscriber1 = new DataChunkSubscriber();\n+                part.content().subscribe(subscriber1);\n+                subscriber1.content().thenAccept(body -> {\n+                    latch.countDown();\n+                    assertThat(body, is(equalTo(\"body 1\")));\n+                });\n+            }\n+        };\n+\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(SUBSCRIBER_TYPE.CANCEL_AFTER_ONE, consumer);\n+        partsPublisher(boundary, chunk1).subscribe(testSubscriber);\n+        waitOnLatch(latch);\n+        assertThat(testSubscriber.error, is(nullValue()));\n+        assertThat(testSubscriber.complete, is(equalTo(false)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA2MTkwMg=="}, "originalCommit": {"oid": "1e9d1a876a27e52a81c6921cffe786d5d5a1208d"}, "originalPosition": 266}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0NzQzNjkzOnYy", "diffSide": "RIGHT", "path": "media/multipart/common/src/test/java/io/helidon/media/multipart/common/MultiPartDecoderTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxMzozMDoyNlrOGVcVEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxNDo1NTozNlrOGVgQbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTEzNzQyNg==", "bodyText": "Decoder looks basically as a flatmap, I may be wrong but it should be possible to leave all the queuing in decoder to flatMap operator and simplify it considerably, so if this works:\n        Multi.from(chunksPublisher(chunk1))\n                .flatMap(chunk -> {\n                    var decoder = MultiPartDecoder.create(boundary, MEDIA_CONTEXT.readerContext());\n                    Single.just(chunk).subscribe(decoder);\n                    return decoder;\n                }).subscribe(testSubscriber);\nSomething like this should be possible:\n        var parser = new MIMEParser(boundary){\n            List<ReadableBodyPart> parse(DataChunk chunk){\n                ...\n            }\n        };\n        Multi.from(chunksPublisher(chunk1))\n                .flatMapIterable(parser::parse)\n                }).subscribe(testSubscriber);", "url": "https://github.com/oracle/helidon/pull/1787#discussion_r425137426", "createdAt": "2020-05-14T13:30:26Z", "author": {"login": "danielkec"}, "path": "media/multipart/common/src/test/java/io/helidon/media/multipart/common/MultiPartDecoderTest.java", "diffHunk": "@@ -0,0 +1,571 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.helidon.media.multipart.common;\n+\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Flow.Publisher;\n+import java.util.concurrent.Flow.Subscriber;\n+import java.util.concurrent.Flow.Subscription;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import io.helidon.common.http.DataChunk;\n+import io.helidon.common.reactive.Multi;\n+\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.CoreMatchers.hasItems;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.CoreMatchers.nullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static io.helidon.media.multipart.common.BodyPartTest.MEDIA_CONTEXT;\n+\n+/**\n+ * Tests {@link MultiPartDecoder}.\n+ */\n+public class MultiPartDecoderTest {\n+\n+    private static final Logger LOGGER = Logger.getLogger(MultiPartDecoder.class.getName());\n+\n+    @BeforeAll\n+    public static void before() {\n+        LOGGER.setLevel(Level.ALL);\n+    }\n+\n+    @AfterAll\n+    public static void after() {\n+        LOGGER.setLevel(Level.INFO);\n+    }\n+\n+    @Test\n+    public void testOnePartInOneChunk() {\n+        String boundary = \"boundary\";\n+        final byte[] chunk1 = (\"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part1\\n\"\n+                + \"\\n\"\n+                + \"body 1\\n\"\n+                + \"--\" + boundary + \"--\").getBytes();\n+\n+        final CountDownLatch latch = new CountDownLatch(2);\n+        Consumer<BodyPart> consumer = (part) -> {\n+            latch.countDown();\n+            assertThat(part.headers().values(\"Content-Id\"),\n+                    hasItems(\"part1\"));\n+            DataChunkSubscriber subscriber = new DataChunkSubscriber();\n+            part.content().subscribe(subscriber);\n+            subscriber.content().thenAccept(body -> {\n+                latch.countDown();\n+                assertThat(body, is(equalTo(\"body 1\")));\n+            });\n+        };\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(\n+                SUBSCRIBER_TYPE.INFINITE, consumer);\n+        partsPublisher(boundary, chunk1).subscribe(testSubscriber);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e9d1a876a27e52a81c6921cffe786d5d5a1208d"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTIwMTc3Mw==", "bodyText": "Sorry I got Decoder/Encoder vertigo, I meant Encoder, to look like re-implemented flatmap:\n    private static String encodeParts(String boundary, WriteableBodyPart... parts) throws Exception {\n        Multi<DataChunk> pub = Multi.just(parts)\n                .flatMap(part -> {\n                    var enc = MultiPartEncoder.create(boundary, MEDIA_CONTEXT.writerContext());\n                    Single.just(part).subscribe(enc);\n                    return enc;\n                });\n        return ContentReaders.readString(pub, StandardCharsets.UTF_8).get(10, TimeUnit.SECONDS);\n    }", "url": "https://github.com/oracle/helidon/pull/1787#discussion_r425201773", "createdAt": "2020-05-14T14:55:36Z", "author": {"login": "danielkec"}, "path": "media/multipart/common/src/test/java/io/helidon/media/multipart/common/MultiPartDecoderTest.java", "diffHunk": "@@ -0,0 +1,571 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.helidon.media.multipart.common;\n+\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Flow.Publisher;\n+import java.util.concurrent.Flow.Subscriber;\n+import java.util.concurrent.Flow.Subscription;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import io.helidon.common.http.DataChunk;\n+import io.helidon.common.reactive.Multi;\n+\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.CoreMatchers.hasItems;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.CoreMatchers.nullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.junit.jupiter.api.Assertions.fail;\n+import static io.helidon.media.multipart.common.BodyPartTest.MEDIA_CONTEXT;\n+\n+/**\n+ * Tests {@link MultiPartDecoder}.\n+ */\n+public class MultiPartDecoderTest {\n+\n+    private static final Logger LOGGER = Logger.getLogger(MultiPartDecoder.class.getName());\n+\n+    @BeforeAll\n+    public static void before() {\n+        LOGGER.setLevel(Level.ALL);\n+    }\n+\n+    @AfterAll\n+    public static void after() {\n+        LOGGER.setLevel(Level.INFO);\n+    }\n+\n+    @Test\n+    public void testOnePartInOneChunk() {\n+        String boundary = \"boundary\";\n+        final byte[] chunk1 = (\"--\" + boundary + \"\\n\"\n+                + \"Content-Id: part1\\n\"\n+                + \"\\n\"\n+                + \"body 1\\n\"\n+                + \"--\" + boundary + \"--\").getBytes();\n+\n+        final CountDownLatch latch = new CountDownLatch(2);\n+        Consumer<BodyPart> consumer = (part) -> {\n+            latch.countDown();\n+            assertThat(part.headers().values(\"Content-Id\"),\n+                    hasItems(\"part1\"));\n+            DataChunkSubscriber subscriber = new DataChunkSubscriber();\n+            part.content().subscribe(subscriber);\n+            subscriber.content().thenAccept(body -> {\n+                latch.countDown();\n+                assertThat(body, is(equalTo(\"body 1\")));\n+            });\n+        };\n+        BodyPartSubscriber testSubscriber = new BodyPartSubscriber(\n+                SUBSCRIBER_TYPE.INFINITE, consumer);\n+        partsPublisher(boundary, chunk1).subscribe(testSubscriber);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTEzNzQyNg=="}, "originalCommit": {"oid": "1e9d1a876a27e52a81c6921cffe786d5d5a1208d"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0Nzk0MDM2OnYy", "diffSide": "RIGHT", "path": "media/multipart/common/src/main/java/io/helidon/media/multipart/common/MultiPartEncoder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxNToyMDoxOVrOGVhY-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxNToyMDoxOVrOGVhY-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTIyMDM0NA==", "bodyText": "required_spec213_blackbox_onSubscribe_mustThrowNullPointerExceptionWhenParametersAreNull\nrequired_spec205_blackbox_mustCallSubscriptionCancelIfItAlreadyHasAnSubscriptionAndReceivesAnotherOnSubscribeSignal", "url": "https://github.com/oracle/helidon/pull/1787#discussion_r425220344", "createdAt": "2020-05-14T15:20:19Z", "author": {"login": "danielkec"}, "path": "media/multipart/common/src/main/java/io/helidon/media/multipart/common/MultiPartEncoder.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.helidon.media.multipart.common;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.Flow.Processor;\n+import java.util.concurrent.Flow.Subscriber;\n+import java.util.concurrent.Flow.Subscription;\n+\n+import io.helidon.common.http.DataChunk;\n+import io.helidon.common.reactive.OriginThreadPublisher;\n+import io.helidon.media.common.MessageBodyWriterContext;\n+\n+/**\n+ * Reactive processor that encodes a stream of {@link BodyPart} into an HTTP\n+ * payload. This processor is a single use publisher that supports a single\n+ * subscriber, it is not resumable.\n+ */\n+public final class MultiPartEncoder implements Processor<WriteableBodyPart, DataChunk> {\n+\n+    private Subscription partsSubscription;\n+    private BodyPartContentSubscriber contentSubscriber;\n+\n+    /**\n+     * The writer context.\n+     */\n+    private final MessageBodyWriterContext context;\n+\n+    /**\n+     * The boundary used for the generated multi-part message.\n+     */\n+    private final String boundary;\n+\n+    /**\n+     * Complete flag.\n+     */\n+    private volatile boolean complete;\n+\n+    /**\n+     * The downstream publisher.\n+     */\n+    private final MultiPartChunksPublisher downstream;\n+\n+    /**\n+     * Create a new multipart encoder.\n+     * @param boundary boundary string\n+     * @param context writer context\n+     */\n+    private MultiPartEncoder(String boundary, MessageBodyWriterContext context) {\n+        Objects.requireNonNull(boundary, \"boundary cannot be null!\");\n+        Objects.requireNonNull(context, \"context cannot be null!\");\n+        this.context = context;\n+        this.boundary = boundary;\n+        this.downstream = new MultiPartChunksPublisher();\n+        this.complete = false;\n+    }\n+\n+    /**\n+     * Create a new encoder instance.\n+     * @param boundary multipart boundary delimiter\n+     * @param context writer context\n+     * @return MultiPartEncoder\n+     */\n+    public static MultiPartEncoder create(String boundary, MessageBodyWriterContext context) {\n+        return new MultiPartEncoder(boundary, context);\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super DataChunk> subscriber) {\n+        downstream.subscribe(subscriber);\n+    }\n+\n+    @Override\n+    public void onSubscribe(Subscription subscription) {\n+        if (partsSubscription != null) {\n+            throw new IllegalStateException(\"Input subscription already set\");\n+        }\n+        partsSubscription = subscription;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e9d1a876a27e52a81c6921cffe786d5d5a1208d"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0ODAxMjQ0OnYy", "diffSide": "RIGHT", "path": "media/multipart/common/src/main/java/io/helidon/media/multipart/common/MultiPartEncoder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxNTozNToyOFrOGViG7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNFQxNTozNToyOFrOGViG7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTIzMjEwOA==", "bodyText": "required_spec213_blackbox_onError_mustThrowNullPointerExceptionWhenParametersAreNull", "url": "https://github.com/oracle/helidon/pull/1787#discussion_r425232108", "createdAt": "2020-05-14T15:35:28Z", "author": {"login": "danielkec"}, "path": "media/multipart/common/src/main/java/io/helidon/media/multipart/common/MultiPartEncoder.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.helidon.media.multipart.common;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.Flow.Processor;\n+import java.util.concurrent.Flow.Subscriber;\n+import java.util.concurrent.Flow.Subscription;\n+\n+import io.helidon.common.http.DataChunk;\n+import io.helidon.common.reactive.OriginThreadPublisher;\n+import io.helidon.media.common.MessageBodyWriterContext;\n+\n+/**\n+ * Reactive processor that encodes a stream of {@link BodyPart} into an HTTP\n+ * payload. This processor is a single use publisher that supports a single\n+ * subscriber, it is not resumable.\n+ */\n+public final class MultiPartEncoder implements Processor<WriteableBodyPart, DataChunk> {\n+\n+    private Subscription partsSubscription;\n+    private BodyPartContentSubscriber contentSubscriber;\n+\n+    /**\n+     * The writer context.\n+     */\n+    private final MessageBodyWriterContext context;\n+\n+    /**\n+     * The boundary used for the generated multi-part message.\n+     */\n+    private final String boundary;\n+\n+    /**\n+     * Complete flag.\n+     */\n+    private volatile boolean complete;\n+\n+    /**\n+     * The downstream publisher.\n+     */\n+    private final MultiPartChunksPublisher downstream;\n+\n+    /**\n+     * Create a new multipart encoder.\n+     * @param boundary boundary string\n+     * @param context writer context\n+     */\n+    private MultiPartEncoder(String boundary, MessageBodyWriterContext context) {\n+        Objects.requireNonNull(boundary, \"boundary cannot be null!\");\n+        Objects.requireNonNull(context, \"context cannot be null!\");\n+        this.context = context;\n+        this.boundary = boundary;\n+        this.downstream = new MultiPartChunksPublisher();\n+        this.complete = false;\n+    }\n+\n+    /**\n+     * Create a new encoder instance.\n+     * @param boundary multipart boundary delimiter\n+     * @param context writer context\n+     * @return MultiPartEncoder\n+     */\n+    public static MultiPartEncoder create(String boundary, MessageBodyWriterContext context) {\n+        return new MultiPartEncoder(boundary, context);\n+    }\n+\n+    @Override\n+    public void subscribe(Subscriber<? super DataChunk> subscriber) {\n+        downstream.subscribe(subscriber);\n+    }\n+\n+    @Override\n+    public void onSubscribe(Subscription subscription) {\n+        if (partsSubscription != null) {\n+            throw new IllegalStateException(\"Input subscription already set\");\n+        }\n+        partsSubscription = subscription;\n+    }\n+\n+    @Override\n+    public void onNext(WriteableBodyPart bodyPart) {\n+        Map<String, List<String>> headers = bodyPart.headers().toMap();\n+        StringBuilder sb = new StringBuilder();\n+\n+        // start boundary\n+        sb.append(\"--\").append(boundary).append(\"\\r\\n\");\n+\n+        // headers lines\n+        for (Map.Entry<String, List<String>> headerEntry : headers.entrySet()) {\n+\n+            String headerName = headerEntry.getKey();\n+            for (String headerValue : headerEntry.getValue()) {\n+                sb.append(headerName)\n+                        .append(\":\")\n+                        .append(headerValue)\n+                        .append(\"\\r\\n\");\n+            }\n+        }\n+\n+        // end of headers empty line\n+        sb.append(\"\\r\\n\");\n+        downstream.submit(sb.toString());\n+        contentSubscriber = new BodyPartContentSubscriber();\n+        bodyPart.content()\n+                .toPublisher(context)\n+                .subscribe(contentSubscriber);\n+    }\n+\n+    @Override\n+    public void onError(Throwable error) {\n+        downstream.error(error);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e9d1a876a27e52a81c6921cffe786d5d5a1208d"}, "originalPosition": 130}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MjUzNjk1OnYy", "diffSide": "RIGHT", "path": "media/multipart/common/src/main/java/io/helidon/media/multipart/common/MIMEParser.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNVQxODowMDowMVrOGWOrNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwNDoxOToyMVrOGYlr8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk2MjI5Mg==", "bodyText": "Can you please rename to MimeParser? We adopt this in our APIs - even for cases when the original abbreviation is all capitals (such as MpConfig).", "url": "https://github.com/oracle/helidon/pull/1787#discussion_r425962292", "createdAt": "2020-05-15T18:00:01Z", "author": {"login": "tomas-langer"}, "path": "media/multipart/common/src/main/java/io/helidon/media/multipart/common/MIMEParser.java", "diffHunk": "@@ -0,0 +1,953 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.helidon.media.multipart.common;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.Charset;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+/**\n+ * Parser for multipart MIME message.\n+ */\n+final class MIMEParser {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e9d1a876a27e52a81c6921cffe786d5d5a1208d"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQzNjQ2Ng==", "bodyText": "Fixed.", "url": "https://github.com/oracle/helidon/pull/1787#discussion_r428436466", "createdAt": "2020-05-21T04:19:21Z", "author": {"login": "romain-grecourt"}, "path": "media/multipart/common/src/main/java/io/helidon/media/multipart/common/MIMEParser.java", "diffHunk": "@@ -0,0 +1,953 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.helidon.media.multipart.common;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.Charset;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+/**\n+ * Parser for multipart MIME message.\n+ */\n+final class MIMEParser {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk2MjI5Mg=="}, "originalCommit": {"oid": "1e9d1a876a27e52a81c6921cffe786d5d5a1208d"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY1MzUwNTk1OnYy", "diffSide": "RIGHT", "path": "media/multipart/common/pom.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQwMzoyOTowNVrOGWX4qA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xNlQwMzoyOTowNVrOGWX4qA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjExMzE5Mg==", "bodyText": "TODO move media/multipart/common to media/mutlipart", "url": "https://github.com/oracle/helidon/pull/1787#discussion_r426113192", "createdAt": "2020-05-16T03:29:05Z", "author": {"login": "romain-grecourt"}, "path": "media/multipart/common/pom.xml", "diffHunk": "@@ -0,0 +1,63 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f1d0a55ce1269619a3beb64906530266c9a7911"}, "originalPosition": 1}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 688, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}