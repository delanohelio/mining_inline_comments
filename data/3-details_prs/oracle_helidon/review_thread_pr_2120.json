{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQzMDYzMTUz", "number": 2120, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNDowMjo1OFrOEK6RtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNTozMzo0OFrOEK8wKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5ODc2MDIwOnYy", "diffSide": "RIGHT", "path": "fault-tolerance/src/test/java/io/helidon/faulttolerance/RetryTest.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNDowMjo1OFrOGsOUSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQyMTozMDowMVrOGsdjMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTAyNTA5OA==", "bodyText": "Need it?", "url": "https://github.com/oracle/helidon/pull/2120#discussion_r449025098", "createdAt": "2020-07-02T14:02:58Z", "author": {"login": "spericas"}, "path": "fault-tolerance/src/test/java/io/helidon/faulttolerance/RetryTest.java", "diffHunk": "@@ -0,0 +1,327 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.faulttolerance;\n+\n+import java.time.Duration;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Flow;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import io.helidon.common.reactive.Multi;\n+import io.helidon.common.reactive.Single;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.CoreMatchers.instanceOf;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.contains;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+class RetryTest {\n+    @Test\n+    void testRetry() {\n+        Retry retry = Retry.builder()\n+                .retryPolicy(Retry.JitterRetryPolicy.builder()\n+                                     .calls(3)\n+                                     .delay(Duration.ofMillis(50))\n+                                     .jitter(Duration.ofMillis(50))\n+                                     .build())\n+                .overallTimeout(Duration.ofMillis(500))\n+                .build();\n+\n+        Request req = new Request(3, new TerminalException(), new RetryException());\n+        Single<Integer> result = retry.invoke(req::invoke);\n+        FaultToleranceTest.completionException(result, TerminalException.class);\n+        assertThat(req.call.get(), is(3));\n+\n+        req = new Request(2, new TerminalException(), new RetryException());\n+        result = retry.invoke(req::invoke);\n+        int count = result.await(1, TimeUnit.SECONDS);\n+        assertThat(count, is(3));\n+    }\n+\n+    @Test\n+    void testRetryOn() {\n+        Retry retry = Retry.builder()\n+                .retryPolicy(Retry.JitterRetryPolicy.builder()\n+                                     .calls(3)\n+                                     .delay(Duration.ofMillis(100))\n+                                     .jitter(Duration.ofMillis(50))\n+                                     .build())\n+                .overallTimeout(Duration.ofMillis(500))\n+                .addApplyOn(RetryException.class)\n+                .build();\n+\n+        Request req = new Request(3, new RetryException(), new RetryException());\n+        Single<Integer> result = retry.invoke(req::invoke);\n+        FaultToleranceTest.completionException(result, RetryException.class);\n+        assertThat(req.call.get(), is(3));\n+\n+        req = new Request(2, new RetryException(), new TerminalException());\n+        result = retry.invoke(req::invoke);\n+        FaultToleranceTest.completionException(result, TerminalException.class);\n+        assertThat(req.call.get(), is(2));\n+\n+        req = new Request(2, new RetryException(), new RetryException());\n+        result = retry.invoke(req::invoke);\n+        int count = result.await(1, TimeUnit.SECONDS);\n+        assertThat(count, is(3));\n+    }\n+\n+    @Test\n+    void testAbortOn() {\n+        Retry retry = Retry.builder()\n+                .retryPolicy(Retry.JitterRetryPolicy.builder()\n+                                     .calls(3)\n+                                     .delay(Duration.ofMillis(100))\n+                                     .jitter(Duration.ofMillis(50))\n+                                     .build())\n+                .overallTimeout(Duration.ofMillis(50000))\n+                .addSkipOn(TerminalException.class)\n+                .build();\n+\n+        Request req = new Request(3, new RetryException(), new RetryException());\n+        Single<Integer> result = retry.invoke(req::invoke);\n+        FaultToleranceTest.completionException(result, RetryException.class);\n+        assertThat(req.call.get(), is(3));\n+\n+        req = new Request(2, new RetryException(), new TerminalException());\n+        result = retry.invoke(req::invoke);\n+        FaultToleranceTest.completionException(result, TerminalException.class);\n+        assertThat(req.call.get(), is(2));\n+\n+        req = new Request(2, new RetryException(), new RetryException());\n+        result = retry.invoke(req::invoke);\n+        int count = result.await(1, TimeUnit.SECONDS);\n+        assertThat(count, is(3));\n+    }\n+\n+    @Test\n+    void testTimeout() {\n+        Retry retry = Retry.builder()\n+                .retryPolicy(Retry.JitterRetryPolicy.builder()\n+                                     .calls(3)\n+                                     .delay(Duration.ofMillis(100))\n+                                     .jitter(Duration.ZERO)\n+                                     .build())\n+                .overallTimeout(Duration.ofMillis(50))\n+                .build();\n+\n+        Request req = new Request(3, new RetryException(), new RetryException());\n+        Single<Integer> result = retry.invoke(req::invoke);\n+        FaultToleranceTest.completionException(result, TimeoutException.class);\n+        // first time: immediate call\n+        // second time: delayed invocation\n+        // third attempt to retry fails on timeout\n+        assertThat(\"Should have been called twice\", req.call.get(), is(2));\n+    }\n+\n+    @Test\n+    void testBadConfiguration() {\n+        Retry.Builder builder = Retry.builder()\n+                .applyOn(RetryException.class)\n+                .skipOn(TerminalException.class);\n+\n+        assertThrows(IllegalArgumentException.class, builder::build);\n+    }\n+\n+    @Test\n+    void testMultiRetriesNoFailure() throws InterruptedException {\n+        Retry retry = Retry.builder()\n+                .retryPolicy(Retry.DelayingRetryPolicy.noDelay(3))\n+                .build();\n+\n+        Multi<Integer> multi = retry.invokeMulti(() -> Multi.just(0, 1, 2));\n+\n+        TestSubscriber ts = new TestSubscriber();\n+        multi.subscribe(ts);\n+        ts.request(100);\n+\n+        ts.cdl.await(1, TimeUnit.SECONDS);\n+\n+        assertThat(\"Should be completed\", ts.completed.get(), is(true));\n+        assertThat(\"Should not be failed\", ts.failed.get(), is(false));\n+        assertThat(ts.values, contains(0, 1, 2));\n+    }\n+\n+    @Test\n+    void testMultiRetries() throws InterruptedException {\n+        Retry retry = Retry.builder()\n+                .retryPolicy(Retry.DelayingRetryPolicy.noDelay(3))\n+                .build();\n+\n+        AtomicInteger count = new AtomicInteger();\n+\n+        Multi<Integer> multi = retry.invokeMulti(() -> {\n+            if (count.getAndIncrement() < 2) {\n+                return Multi.error(new RetryException());\n+            } else {\n+                return Multi.just(0, 1, 2);\n+            }\n+        });\n+\n+        TestSubscriber ts = new TestSubscriber();\n+        multi.subscribe(ts);\n+        ts.request(100);\n+\n+        ts.cdl.await(1, TimeUnit.SECONDS);\n+\n+        assertThat(\"Should be completed\", ts.completed.get(), is(true));\n+        assertThat(\"Should not be failed\", ts.failed.get(), is(false));\n+        assertThat(ts.values, contains(0, 1, 2));\n+    }\n+\n+    @Test\n+    void testMultiRetriesRead() throws InterruptedException {\n+        Retry retry = Retry.builder()\n+                .retryPolicy(Retry.DelayingRetryPolicy.noDelay(3))\n+                .build();\n+\n+        AtomicInteger count = new AtomicInteger();\n+\n+        TestSubscriber ts = new TestSubscriber();\n+\n+        Multi<Integer> multi = retry.invokeMulti(() -> {\n+            if (count.getAndIncrement() == 0) {\n+                //return new PartialPublisher();\n+                return Multi.concat(Multi.just(0), Multi.error(new RetryException()));\n+            } else {\n+                TestSubscriber it = ts;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0220ec94c2fa14c445c1ee9e0500ad64c9784993"}, "originalPosition": 211}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTExNjkyMg==", "bodyText": "Need what? Sorry I do not see it", "url": "https://github.com/oracle/helidon/pull/2120#discussion_r449116922", "createdAt": "2020-07-02T15:58:21Z", "author": {"login": "tomas-langer"}, "path": "fault-tolerance/src/test/java/io/helidon/faulttolerance/RetryTest.java", "diffHunk": "@@ -0,0 +1,327 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.faulttolerance;\n+\n+import java.time.Duration;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Flow;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import io.helidon.common.reactive.Multi;\n+import io.helidon.common.reactive.Single;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.CoreMatchers.instanceOf;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.contains;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+class RetryTest {\n+    @Test\n+    void testRetry() {\n+        Retry retry = Retry.builder()\n+                .retryPolicy(Retry.JitterRetryPolicy.builder()\n+                                     .calls(3)\n+                                     .delay(Duration.ofMillis(50))\n+                                     .jitter(Duration.ofMillis(50))\n+                                     .build())\n+                .overallTimeout(Duration.ofMillis(500))\n+                .build();\n+\n+        Request req = new Request(3, new TerminalException(), new RetryException());\n+        Single<Integer> result = retry.invoke(req::invoke);\n+        FaultToleranceTest.completionException(result, TerminalException.class);\n+        assertThat(req.call.get(), is(3));\n+\n+        req = new Request(2, new TerminalException(), new RetryException());\n+        result = retry.invoke(req::invoke);\n+        int count = result.await(1, TimeUnit.SECONDS);\n+        assertThat(count, is(3));\n+    }\n+\n+    @Test\n+    void testRetryOn() {\n+        Retry retry = Retry.builder()\n+                .retryPolicy(Retry.JitterRetryPolicy.builder()\n+                                     .calls(3)\n+                                     .delay(Duration.ofMillis(100))\n+                                     .jitter(Duration.ofMillis(50))\n+                                     .build())\n+                .overallTimeout(Duration.ofMillis(500))\n+                .addApplyOn(RetryException.class)\n+                .build();\n+\n+        Request req = new Request(3, new RetryException(), new RetryException());\n+        Single<Integer> result = retry.invoke(req::invoke);\n+        FaultToleranceTest.completionException(result, RetryException.class);\n+        assertThat(req.call.get(), is(3));\n+\n+        req = new Request(2, new RetryException(), new TerminalException());\n+        result = retry.invoke(req::invoke);\n+        FaultToleranceTest.completionException(result, TerminalException.class);\n+        assertThat(req.call.get(), is(2));\n+\n+        req = new Request(2, new RetryException(), new RetryException());\n+        result = retry.invoke(req::invoke);\n+        int count = result.await(1, TimeUnit.SECONDS);\n+        assertThat(count, is(3));\n+    }\n+\n+    @Test\n+    void testAbortOn() {\n+        Retry retry = Retry.builder()\n+                .retryPolicy(Retry.JitterRetryPolicy.builder()\n+                                     .calls(3)\n+                                     .delay(Duration.ofMillis(100))\n+                                     .jitter(Duration.ofMillis(50))\n+                                     .build())\n+                .overallTimeout(Duration.ofMillis(50000))\n+                .addSkipOn(TerminalException.class)\n+                .build();\n+\n+        Request req = new Request(3, new RetryException(), new RetryException());\n+        Single<Integer> result = retry.invoke(req::invoke);\n+        FaultToleranceTest.completionException(result, RetryException.class);\n+        assertThat(req.call.get(), is(3));\n+\n+        req = new Request(2, new RetryException(), new TerminalException());\n+        result = retry.invoke(req::invoke);\n+        FaultToleranceTest.completionException(result, TerminalException.class);\n+        assertThat(req.call.get(), is(2));\n+\n+        req = new Request(2, new RetryException(), new RetryException());\n+        result = retry.invoke(req::invoke);\n+        int count = result.await(1, TimeUnit.SECONDS);\n+        assertThat(count, is(3));\n+    }\n+\n+    @Test\n+    void testTimeout() {\n+        Retry retry = Retry.builder()\n+                .retryPolicy(Retry.JitterRetryPolicy.builder()\n+                                     .calls(3)\n+                                     .delay(Duration.ofMillis(100))\n+                                     .jitter(Duration.ZERO)\n+                                     .build())\n+                .overallTimeout(Duration.ofMillis(50))\n+                .build();\n+\n+        Request req = new Request(3, new RetryException(), new RetryException());\n+        Single<Integer> result = retry.invoke(req::invoke);\n+        FaultToleranceTest.completionException(result, TimeoutException.class);\n+        // first time: immediate call\n+        // second time: delayed invocation\n+        // third attempt to retry fails on timeout\n+        assertThat(\"Should have been called twice\", req.call.get(), is(2));\n+    }\n+\n+    @Test\n+    void testBadConfiguration() {\n+        Retry.Builder builder = Retry.builder()\n+                .applyOn(RetryException.class)\n+                .skipOn(TerminalException.class);\n+\n+        assertThrows(IllegalArgumentException.class, builder::build);\n+    }\n+\n+    @Test\n+    void testMultiRetriesNoFailure() throws InterruptedException {\n+        Retry retry = Retry.builder()\n+                .retryPolicy(Retry.DelayingRetryPolicy.noDelay(3))\n+                .build();\n+\n+        Multi<Integer> multi = retry.invokeMulti(() -> Multi.just(0, 1, 2));\n+\n+        TestSubscriber ts = new TestSubscriber();\n+        multi.subscribe(ts);\n+        ts.request(100);\n+\n+        ts.cdl.await(1, TimeUnit.SECONDS);\n+\n+        assertThat(\"Should be completed\", ts.completed.get(), is(true));\n+        assertThat(\"Should not be failed\", ts.failed.get(), is(false));\n+        assertThat(ts.values, contains(0, 1, 2));\n+    }\n+\n+    @Test\n+    void testMultiRetries() throws InterruptedException {\n+        Retry retry = Retry.builder()\n+                .retryPolicy(Retry.DelayingRetryPolicy.noDelay(3))\n+                .build();\n+\n+        AtomicInteger count = new AtomicInteger();\n+\n+        Multi<Integer> multi = retry.invokeMulti(() -> {\n+            if (count.getAndIncrement() < 2) {\n+                return Multi.error(new RetryException());\n+            } else {\n+                return Multi.just(0, 1, 2);\n+            }\n+        });\n+\n+        TestSubscriber ts = new TestSubscriber();\n+        multi.subscribe(ts);\n+        ts.request(100);\n+\n+        ts.cdl.await(1, TimeUnit.SECONDS);\n+\n+        assertThat(\"Should be completed\", ts.completed.get(), is(true));\n+        assertThat(\"Should not be failed\", ts.failed.get(), is(false));\n+        assertThat(ts.values, contains(0, 1, 2));\n+    }\n+\n+    @Test\n+    void testMultiRetriesRead() throws InterruptedException {\n+        Retry retry = Retry.builder()\n+                .retryPolicy(Retry.DelayingRetryPolicy.noDelay(3))\n+                .build();\n+\n+        AtomicInteger count = new AtomicInteger();\n+\n+        TestSubscriber ts = new TestSubscriber();\n+\n+        Multi<Integer> multi = retry.invokeMulti(() -> {\n+            if (count.getAndIncrement() == 0) {\n+                //return new PartialPublisher();\n+                return Multi.concat(Multi.just(0), Multi.error(new RetryException()));\n+            } else {\n+                TestSubscriber it = ts;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTAyNTA5OA=="}, "originalCommit": {"oid": "0220ec94c2fa14c445c1ee9e0500ad64c9784993"}, "originalPosition": 211}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEzMjUzMA==", "bodyText": ":) Meant if we need the variable it", "url": "https://github.com/oracle/helidon/pull/2120#discussion_r449132530", "createdAt": "2020-07-02T16:23:56Z", "author": {"login": "spericas"}, "path": "fault-tolerance/src/test/java/io/helidon/faulttolerance/RetryTest.java", "diffHunk": "@@ -0,0 +1,327 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.faulttolerance;\n+\n+import java.time.Duration;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Flow;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import io.helidon.common.reactive.Multi;\n+import io.helidon.common.reactive.Single;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.CoreMatchers.instanceOf;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.contains;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+class RetryTest {\n+    @Test\n+    void testRetry() {\n+        Retry retry = Retry.builder()\n+                .retryPolicy(Retry.JitterRetryPolicy.builder()\n+                                     .calls(3)\n+                                     .delay(Duration.ofMillis(50))\n+                                     .jitter(Duration.ofMillis(50))\n+                                     .build())\n+                .overallTimeout(Duration.ofMillis(500))\n+                .build();\n+\n+        Request req = new Request(3, new TerminalException(), new RetryException());\n+        Single<Integer> result = retry.invoke(req::invoke);\n+        FaultToleranceTest.completionException(result, TerminalException.class);\n+        assertThat(req.call.get(), is(3));\n+\n+        req = new Request(2, new TerminalException(), new RetryException());\n+        result = retry.invoke(req::invoke);\n+        int count = result.await(1, TimeUnit.SECONDS);\n+        assertThat(count, is(3));\n+    }\n+\n+    @Test\n+    void testRetryOn() {\n+        Retry retry = Retry.builder()\n+                .retryPolicy(Retry.JitterRetryPolicy.builder()\n+                                     .calls(3)\n+                                     .delay(Duration.ofMillis(100))\n+                                     .jitter(Duration.ofMillis(50))\n+                                     .build())\n+                .overallTimeout(Duration.ofMillis(500))\n+                .addApplyOn(RetryException.class)\n+                .build();\n+\n+        Request req = new Request(3, new RetryException(), new RetryException());\n+        Single<Integer> result = retry.invoke(req::invoke);\n+        FaultToleranceTest.completionException(result, RetryException.class);\n+        assertThat(req.call.get(), is(3));\n+\n+        req = new Request(2, new RetryException(), new TerminalException());\n+        result = retry.invoke(req::invoke);\n+        FaultToleranceTest.completionException(result, TerminalException.class);\n+        assertThat(req.call.get(), is(2));\n+\n+        req = new Request(2, new RetryException(), new RetryException());\n+        result = retry.invoke(req::invoke);\n+        int count = result.await(1, TimeUnit.SECONDS);\n+        assertThat(count, is(3));\n+    }\n+\n+    @Test\n+    void testAbortOn() {\n+        Retry retry = Retry.builder()\n+                .retryPolicy(Retry.JitterRetryPolicy.builder()\n+                                     .calls(3)\n+                                     .delay(Duration.ofMillis(100))\n+                                     .jitter(Duration.ofMillis(50))\n+                                     .build())\n+                .overallTimeout(Duration.ofMillis(50000))\n+                .addSkipOn(TerminalException.class)\n+                .build();\n+\n+        Request req = new Request(3, new RetryException(), new RetryException());\n+        Single<Integer> result = retry.invoke(req::invoke);\n+        FaultToleranceTest.completionException(result, RetryException.class);\n+        assertThat(req.call.get(), is(3));\n+\n+        req = new Request(2, new RetryException(), new TerminalException());\n+        result = retry.invoke(req::invoke);\n+        FaultToleranceTest.completionException(result, TerminalException.class);\n+        assertThat(req.call.get(), is(2));\n+\n+        req = new Request(2, new RetryException(), new RetryException());\n+        result = retry.invoke(req::invoke);\n+        int count = result.await(1, TimeUnit.SECONDS);\n+        assertThat(count, is(3));\n+    }\n+\n+    @Test\n+    void testTimeout() {\n+        Retry retry = Retry.builder()\n+                .retryPolicy(Retry.JitterRetryPolicy.builder()\n+                                     .calls(3)\n+                                     .delay(Duration.ofMillis(100))\n+                                     .jitter(Duration.ZERO)\n+                                     .build())\n+                .overallTimeout(Duration.ofMillis(50))\n+                .build();\n+\n+        Request req = new Request(3, new RetryException(), new RetryException());\n+        Single<Integer> result = retry.invoke(req::invoke);\n+        FaultToleranceTest.completionException(result, TimeoutException.class);\n+        // first time: immediate call\n+        // second time: delayed invocation\n+        // third attempt to retry fails on timeout\n+        assertThat(\"Should have been called twice\", req.call.get(), is(2));\n+    }\n+\n+    @Test\n+    void testBadConfiguration() {\n+        Retry.Builder builder = Retry.builder()\n+                .applyOn(RetryException.class)\n+                .skipOn(TerminalException.class);\n+\n+        assertThrows(IllegalArgumentException.class, builder::build);\n+    }\n+\n+    @Test\n+    void testMultiRetriesNoFailure() throws InterruptedException {\n+        Retry retry = Retry.builder()\n+                .retryPolicy(Retry.DelayingRetryPolicy.noDelay(3))\n+                .build();\n+\n+        Multi<Integer> multi = retry.invokeMulti(() -> Multi.just(0, 1, 2));\n+\n+        TestSubscriber ts = new TestSubscriber();\n+        multi.subscribe(ts);\n+        ts.request(100);\n+\n+        ts.cdl.await(1, TimeUnit.SECONDS);\n+\n+        assertThat(\"Should be completed\", ts.completed.get(), is(true));\n+        assertThat(\"Should not be failed\", ts.failed.get(), is(false));\n+        assertThat(ts.values, contains(0, 1, 2));\n+    }\n+\n+    @Test\n+    void testMultiRetries() throws InterruptedException {\n+        Retry retry = Retry.builder()\n+                .retryPolicy(Retry.DelayingRetryPolicy.noDelay(3))\n+                .build();\n+\n+        AtomicInteger count = new AtomicInteger();\n+\n+        Multi<Integer> multi = retry.invokeMulti(() -> {\n+            if (count.getAndIncrement() < 2) {\n+                return Multi.error(new RetryException());\n+            } else {\n+                return Multi.just(0, 1, 2);\n+            }\n+        });\n+\n+        TestSubscriber ts = new TestSubscriber();\n+        multi.subscribe(ts);\n+        ts.request(100);\n+\n+        ts.cdl.await(1, TimeUnit.SECONDS);\n+\n+        assertThat(\"Should be completed\", ts.completed.get(), is(true));\n+        assertThat(\"Should not be failed\", ts.failed.get(), is(false));\n+        assertThat(ts.values, contains(0, 1, 2));\n+    }\n+\n+    @Test\n+    void testMultiRetriesRead() throws InterruptedException {\n+        Retry retry = Retry.builder()\n+                .retryPolicy(Retry.DelayingRetryPolicy.noDelay(3))\n+                .build();\n+\n+        AtomicInteger count = new AtomicInteger();\n+\n+        TestSubscriber ts = new TestSubscriber();\n+\n+        Multi<Integer> multi = retry.invokeMulti(() -> {\n+            if (count.getAndIncrement() == 0) {\n+                //return new PartialPublisher();\n+                return Multi.concat(Multi.just(0), Multi.error(new RetryException()));\n+            } else {\n+                TestSubscriber it = ts;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTAyNTA5OA=="}, "originalCommit": {"oid": "0220ec94c2fa14c445c1ee9e0500ad64c9784993"}, "originalPosition": 211}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI2NjA3MA==", "bodyText": "No :)", "url": "https://github.com/oracle/helidon/pull/2120#discussion_r449266070", "createdAt": "2020-07-02T21:06:53Z", "author": {"login": "tomas-langer"}, "path": "fault-tolerance/src/test/java/io/helidon/faulttolerance/RetryTest.java", "diffHunk": "@@ -0,0 +1,327 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.faulttolerance;\n+\n+import java.time.Duration;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Flow;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import io.helidon.common.reactive.Multi;\n+import io.helidon.common.reactive.Single;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.CoreMatchers.instanceOf;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.contains;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+class RetryTest {\n+    @Test\n+    void testRetry() {\n+        Retry retry = Retry.builder()\n+                .retryPolicy(Retry.JitterRetryPolicy.builder()\n+                                     .calls(3)\n+                                     .delay(Duration.ofMillis(50))\n+                                     .jitter(Duration.ofMillis(50))\n+                                     .build())\n+                .overallTimeout(Duration.ofMillis(500))\n+                .build();\n+\n+        Request req = new Request(3, new TerminalException(), new RetryException());\n+        Single<Integer> result = retry.invoke(req::invoke);\n+        FaultToleranceTest.completionException(result, TerminalException.class);\n+        assertThat(req.call.get(), is(3));\n+\n+        req = new Request(2, new TerminalException(), new RetryException());\n+        result = retry.invoke(req::invoke);\n+        int count = result.await(1, TimeUnit.SECONDS);\n+        assertThat(count, is(3));\n+    }\n+\n+    @Test\n+    void testRetryOn() {\n+        Retry retry = Retry.builder()\n+                .retryPolicy(Retry.JitterRetryPolicy.builder()\n+                                     .calls(3)\n+                                     .delay(Duration.ofMillis(100))\n+                                     .jitter(Duration.ofMillis(50))\n+                                     .build())\n+                .overallTimeout(Duration.ofMillis(500))\n+                .addApplyOn(RetryException.class)\n+                .build();\n+\n+        Request req = new Request(3, new RetryException(), new RetryException());\n+        Single<Integer> result = retry.invoke(req::invoke);\n+        FaultToleranceTest.completionException(result, RetryException.class);\n+        assertThat(req.call.get(), is(3));\n+\n+        req = new Request(2, new RetryException(), new TerminalException());\n+        result = retry.invoke(req::invoke);\n+        FaultToleranceTest.completionException(result, TerminalException.class);\n+        assertThat(req.call.get(), is(2));\n+\n+        req = new Request(2, new RetryException(), new RetryException());\n+        result = retry.invoke(req::invoke);\n+        int count = result.await(1, TimeUnit.SECONDS);\n+        assertThat(count, is(3));\n+    }\n+\n+    @Test\n+    void testAbortOn() {\n+        Retry retry = Retry.builder()\n+                .retryPolicy(Retry.JitterRetryPolicy.builder()\n+                                     .calls(3)\n+                                     .delay(Duration.ofMillis(100))\n+                                     .jitter(Duration.ofMillis(50))\n+                                     .build())\n+                .overallTimeout(Duration.ofMillis(50000))\n+                .addSkipOn(TerminalException.class)\n+                .build();\n+\n+        Request req = new Request(3, new RetryException(), new RetryException());\n+        Single<Integer> result = retry.invoke(req::invoke);\n+        FaultToleranceTest.completionException(result, RetryException.class);\n+        assertThat(req.call.get(), is(3));\n+\n+        req = new Request(2, new RetryException(), new TerminalException());\n+        result = retry.invoke(req::invoke);\n+        FaultToleranceTest.completionException(result, TerminalException.class);\n+        assertThat(req.call.get(), is(2));\n+\n+        req = new Request(2, new RetryException(), new RetryException());\n+        result = retry.invoke(req::invoke);\n+        int count = result.await(1, TimeUnit.SECONDS);\n+        assertThat(count, is(3));\n+    }\n+\n+    @Test\n+    void testTimeout() {\n+        Retry retry = Retry.builder()\n+                .retryPolicy(Retry.JitterRetryPolicy.builder()\n+                                     .calls(3)\n+                                     .delay(Duration.ofMillis(100))\n+                                     .jitter(Duration.ZERO)\n+                                     .build())\n+                .overallTimeout(Duration.ofMillis(50))\n+                .build();\n+\n+        Request req = new Request(3, new RetryException(), new RetryException());\n+        Single<Integer> result = retry.invoke(req::invoke);\n+        FaultToleranceTest.completionException(result, TimeoutException.class);\n+        // first time: immediate call\n+        // second time: delayed invocation\n+        // third attempt to retry fails on timeout\n+        assertThat(\"Should have been called twice\", req.call.get(), is(2));\n+    }\n+\n+    @Test\n+    void testBadConfiguration() {\n+        Retry.Builder builder = Retry.builder()\n+                .applyOn(RetryException.class)\n+                .skipOn(TerminalException.class);\n+\n+        assertThrows(IllegalArgumentException.class, builder::build);\n+    }\n+\n+    @Test\n+    void testMultiRetriesNoFailure() throws InterruptedException {\n+        Retry retry = Retry.builder()\n+                .retryPolicy(Retry.DelayingRetryPolicy.noDelay(3))\n+                .build();\n+\n+        Multi<Integer> multi = retry.invokeMulti(() -> Multi.just(0, 1, 2));\n+\n+        TestSubscriber ts = new TestSubscriber();\n+        multi.subscribe(ts);\n+        ts.request(100);\n+\n+        ts.cdl.await(1, TimeUnit.SECONDS);\n+\n+        assertThat(\"Should be completed\", ts.completed.get(), is(true));\n+        assertThat(\"Should not be failed\", ts.failed.get(), is(false));\n+        assertThat(ts.values, contains(0, 1, 2));\n+    }\n+\n+    @Test\n+    void testMultiRetries() throws InterruptedException {\n+        Retry retry = Retry.builder()\n+                .retryPolicy(Retry.DelayingRetryPolicy.noDelay(3))\n+                .build();\n+\n+        AtomicInteger count = new AtomicInteger();\n+\n+        Multi<Integer> multi = retry.invokeMulti(() -> {\n+            if (count.getAndIncrement() < 2) {\n+                return Multi.error(new RetryException());\n+            } else {\n+                return Multi.just(0, 1, 2);\n+            }\n+        });\n+\n+        TestSubscriber ts = new TestSubscriber();\n+        multi.subscribe(ts);\n+        ts.request(100);\n+\n+        ts.cdl.await(1, TimeUnit.SECONDS);\n+\n+        assertThat(\"Should be completed\", ts.completed.get(), is(true));\n+        assertThat(\"Should not be failed\", ts.failed.get(), is(false));\n+        assertThat(ts.values, contains(0, 1, 2));\n+    }\n+\n+    @Test\n+    void testMultiRetriesRead() throws InterruptedException {\n+        Retry retry = Retry.builder()\n+                .retryPolicy(Retry.DelayingRetryPolicy.noDelay(3))\n+                .build();\n+\n+        AtomicInteger count = new AtomicInteger();\n+\n+        TestSubscriber ts = new TestSubscriber();\n+\n+        Multi<Integer> multi = retry.invokeMulti(() -> {\n+            if (count.getAndIncrement() == 0) {\n+                //return new PartialPublisher();\n+                return Multi.concat(Multi.just(0), Multi.error(new RetryException()));\n+            } else {\n+                TestSubscriber it = ts;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTAyNTA5OA=="}, "originalCommit": {"oid": "0220ec94c2fa14c445c1ee9e0500ad64c9784993"}, "originalPosition": 211}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI3NDY3Mw==", "bodyText": "it not there anymore", "url": "https://github.com/oracle/helidon/pull/2120#discussion_r449274673", "createdAt": "2020-07-02T21:30:01Z", "author": {"login": "tomas-langer"}, "path": "fault-tolerance/src/test/java/io/helidon/faulttolerance/RetryTest.java", "diffHunk": "@@ -0,0 +1,327 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.faulttolerance;\n+\n+import java.time.Duration;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Flow;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import io.helidon.common.reactive.Multi;\n+import io.helidon.common.reactive.Single;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.CoreMatchers.instanceOf;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.contains;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+class RetryTest {\n+    @Test\n+    void testRetry() {\n+        Retry retry = Retry.builder()\n+                .retryPolicy(Retry.JitterRetryPolicy.builder()\n+                                     .calls(3)\n+                                     .delay(Duration.ofMillis(50))\n+                                     .jitter(Duration.ofMillis(50))\n+                                     .build())\n+                .overallTimeout(Duration.ofMillis(500))\n+                .build();\n+\n+        Request req = new Request(3, new TerminalException(), new RetryException());\n+        Single<Integer> result = retry.invoke(req::invoke);\n+        FaultToleranceTest.completionException(result, TerminalException.class);\n+        assertThat(req.call.get(), is(3));\n+\n+        req = new Request(2, new TerminalException(), new RetryException());\n+        result = retry.invoke(req::invoke);\n+        int count = result.await(1, TimeUnit.SECONDS);\n+        assertThat(count, is(3));\n+    }\n+\n+    @Test\n+    void testRetryOn() {\n+        Retry retry = Retry.builder()\n+                .retryPolicy(Retry.JitterRetryPolicy.builder()\n+                                     .calls(3)\n+                                     .delay(Duration.ofMillis(100))\n+                                     .jitter(Duration.ofMillis(50))\n+                                     .build())\n+                .overallTimeout(Duration.ofMillis(500))\n+                .addApplyOn(RetryException.class)\n+                .build();\n+\n+        Request req = new Request(3, new RetryException(), new RetryException());\n+        Single<Integer> result = retry.invoke(req::invoke);\n+        FaultToleranceTest.completionException(result, RetryException.class);\n+        assertThat(req.call.get(), is(3));\n+\n+        req = new Request(2, new RetryException(), new TerminalException());\n+        result = retry.invoke(req::invoke);\n+        FaultToleranceTest.completionException(result, TerminalException.class);\n+        assertThat(req.call.get(), is(2));\n+\n+        req = new Request(2, new RetryException(), new RetryException());\n+        result = retry.invoke(req::invoke);\n+        int count = result.await(1, TimeUnit.SECONDS);\n+        assertThat(count, is(3));\n+    }\n+\n+    @Test\n+    void testAbortOn() {\n+        Retry retry = Retry.builder()\n+                .retryPolicy(Retry.JitterRetryPolicy.builder()\n+                                     .calls(3)\n+                                     .delay(Duration.ofMillis(100))\n+                                     .jitter(Duration.ofMillis(50))\n+                                     .build())\n+                .overallTimeout(Duration.ofMillis(50000))\n+                .addSkipOn(TerminalException.class)\n+                .build();\n+\n+        Request req = new Request(3, new RetryException(), new RetryException());\n+        Single<Integer> result = retry.invoke(req::invoke);\n+        FaultToleranceTest.completionException(result, RetryException.class);\n+        assertThat(req.call.get(), is(3));\n+\n+        req = new Request(2, new RetryException(), new TerminalException());\n+        result = retry.invoke(req::invoke);\n+        FaultToleranceTest.completionException(result, TerminalException.class);\n+        assertThat(req.call.get(), is(2));\n+\n+        req = new Request(2, new RetryException(), new RetryException());\n+        result = retry.invoke(req::invoke);\n+        int count = result.await(1, TimeUnit.SECONDS);\n+        assertThat(count, is(3));\n+    }\n+\n+    @Test\n+    void testTimeout() {\n+        Retry retry = Retry.builder()\n+                .retryPolicy(Retry.JitterRetryPolicy.builder()\n+                                     .calls(3)\n+                                     .delay(Duration.ofMillis(100))\n+                                     .jitter(Duration.ZERO)\n+                                     .build())\n+                .overallTimeout(Duration.ofMillis(50))\n+                .build();\n+\n+        Request req = new Request(3, new RetryException(), new RetryException());\n+        Single<Integer> result = retry.invoke(req::invoke);\n+        FaultToleranceTest.completionException(result, TimeoutException.class);\n+        // first time: immediate call\n+        // second time: delayed invocation\n+        // third attempt to retry fails on timeout\n+        assertThat(\"Should have been called twice\", req.call.get(), is(2));\n+    }\n+\n+    @Test\n+    void testBadConfiguration() {\n+        Retry.Builder builder = Retry.builder()\n+                .applyOn(RetryException.class)\n+                .skipOn(TerminalException.class);\n+\n+        assertThrows(IllegalArgumentException.class, builder::build);\n+    }\n+\n+    @Test\n+    void testMultiRetriesNoFailure() throws InterruptedException {\n+        Retry retry = Retry.builder()\n+                .retryPolicy(Retry.DelayingRetryPolicy.noDelay(3))\n+                .build();\n+\n+        Multi<Integer> multi = retry.invokeMulti(() -> Multi.just(0, 1, 2));\n+\n+        TestSubscriber ts = new TestSubscriber();\n+        multi.subscribe(ts);\n+        ts.request(100);\n+\n+        ts.cdl.await(1, TimeUnit.SECONDS);\n+\n+        assertThat(\"Should be completed\", ts.completed.get(), is(true));\n+        assertThat(\"Should not be failed\", ts.failed.get(), is(false));\n+        assertThat(ts.values, contains(0, 1, 2));\n+    }\n+\n+    @Test\n+    void testMultiRetries() throws InterruptedException {\n+        Retry retry = Retry.builder()\n+                .retryPolicy(Retry.DelayingRetryPolicy.noDelay(3))\n+                .build();\n+\n+        AtomicInteger count = new AtomicInteger();\n+\n+        Multi<Integer> multi = retry.invokeMulti(() -> {\n+            if (count.getAndIncrement() < 2) {\n+                return Multi.error(new RetryException());\n+            } else {\n+                return Multi.just(0, 1, 2);\n+            }\n+        });\n+\n+        TestSubscriber ts = new TestSubscriber();\n+        multi.subscribe(ts);\n+        ts.request(100);\n+\n+        ts.cdl.await(1, TimeUnit.SECONDS);\n+\n+        assertThat(\"Should be completed\", ts.completed.get(), is(true));\n+        assertThat(\"Should not be failed\", ts.failed.get(), is(false));\n+        assertThat(ts.values, contains(0, 1, 2));\n+    }\n+\n+    @Test\n+    void testMultiRetriesRead() throws InterruptedException {\n+        Retry retry = Retry.builder()\n+                .retryPolicy(Retry.DelayingRetryPolicy.noDelay(3))\n+                .build();\n+\n+        AtomicInteger count = new AtomicInteger();\n+\n+        TestSubscriber ts = new TestSubscriber();\n+\n+        Multi<Integer> multi = retry.invokeMulti(() -> {\n+            if (count.getAndIncrement() == 0) {\n+                //return new PartialPublisher();\n+                return Multi.concat(Multi.just(0), Multi.error(new RetryException()));\n+            } else {\n+                TestSubscriber it = ts;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTAyNTA5OA=="}, "originalCommit": {"oid": "0220ec94c2fa14c445c1ee9e0500ad64c9784993"}, "originalPosition": 211}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5ODc2MzU5OnYy", "diffSide": "RIGHT", "path": "fault-tolerance/src/test/java/io/helidon/faulttolerance/BulkheadTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNDowMzo1MVrOGsOWjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQyMToyOTo1MFrOGsdi-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTAyNTY3OQ==", "bodyText": "Variable inProgressResult not used", "url": "https://github.com/oracle/helidon/pull/2120#discussion_r449025679", "createdAt": "2020-07-02T14:03:51Z", "author": {"login": "spericas"}, "path": "fault-tolerance/src/test/java/io/helidon/faulttolerance/BulkheadTest.java", "diffHunk": "@@ -0,0 +1,230 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.faulttolerance;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Flow;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.IntStream;\n+\n+import io.helidon.common.LogConfig;\n+import io.helidon.common.reactive.Multi;\n+import io.helidon.common.reactive.Single;\n+\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.contains;\n+import static org.hamcrest.Matchers.instanceOf;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.notNullValue;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+class BulkheadTest {\n+    @BeforeAll\n+    static void setupTest() {\n+        LogConfig.configureRuntime();\n+    }\n+\n+    @Test\n+    void testBulkheadQueue() throws InterruptedException {\n+        Bulkhead bulkhead = Bulkhead.builder()\n+                .limit(1)\n+                .queueLength(1000)\n+                .build();\n+\n+        Request inProgress = new Request(0);\n+        Single<Integer> inProgressResult = bulkhead.invoke(inProgress::invoke);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0220ec94c2fa14c445c1ee9e0500ad64c9784993"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI3NDYxNw==", "bodyText": "Removed", "url": "https://github.com/oracle/helidon/pull/2120#discussion_r449274617", "createdAt": "2020-07-02T21:29:50Z", "author": {"login": "tomas-langer"}, "path": "fault-tolerance/src/test/java/io/helidon/faulttolerance/BulkheadTest.java", "diffHunk": "@@ -0,0 +1,230 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.faulttolerance;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Flow;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.IntStream;\n+\n+import io.helidon.common.LogConfig;\n+import io.helidon.common.reactive.Multi;\n+import io.helidon.common.reactive.Single;\n+\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.contains;\n+import static org.hamcrest.Matchers.instanceOf;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.notNullValue;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+class BulkheadTest {\n+    @BeforeAll\n+    static void setupTest() {\n+        LogConfig.configureRuntime();\n+    }\n+\n+    @Test\n+    void testBulkheadQueue() throws InterruptedException {\n+        Bulkhead bulkhead = Bulkhead.builder()\n+                .limit(1)\n+                .queueLength(1000)\n+                .build();\n+\n+        Request inProgress = new Request(0);\n+        Single<Integer> inProgressResult = bulkhead.invoke(inProgress::invoke);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTAyNTY3OQ=="}, "originalCommit": {"oid": "0220ec94c2fa14c445c1ee9e0500ad64c9784993"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5ODc3NTYyOnYy", "diffSide": "RIGHT", "path": "fault-tolerance/src/test/java/io/helidon/faulttolerance/FaultToleranceTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNDowNjozM1rOGsOeHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQyMToyOTo0NFrOGsdizw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTAyNzYxNQ==", "bodyText": "Minor: can be static", "url": "https://github.com/oracle/helidon/pull/2120#discussion_r449027615", "createdAt": "2020-07-02T14:06:33Z", "author": {"login": "spericas"}, "path": "fault-tolerance/src/test/java/io/helidon/faulttolerance/FaultToleranceTest.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.faulttolerance;\n+\n+import java.time.Duration;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import io.helidon.common.reactive.Single;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.CoreMatchers.instanceOf;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+public class FaultToleranceTest {\n+\n+    @Test\n+    void testCustomCombination() {\n+        CircuitBreaker breaker = CircuitBreaker.builder()\n+                .build();\n+\n+        Bulkhead bulkhead = Bulkhead.builder()\n+                .limit(1)\n+                .queueLength(0)\n+                .build();\n+\n+        FtHandlerTyped<String> faultTolerance = FaultTolerance.builder()\n+                .addBreaker(breaker)\n+                .addBulkhead(bulkhead)\n+                .addTimeout(Timeout.builder().timeout(Duration.ofMillis(100)).build())\n+                .addFallback(Fallback.<String>builder()\n+                                     .fallback(this::fallback)\n+                                     .build())\n+                .build();\n+\n+        Single<String> result = faultTolerance.invoke(this::primary);\n+        assertThat(result.await(1, TimeUnit.SECONDS), is(MyException.class.getName()));\n+\n+        breaker.state(CircuitBreaker.State.OPEN);\n+        result = faultTolerance.invoke(this::primary);\n+        assertThat(result.await(1, TimeUnit.SECONDS), is(CircuitBreakerOpenException.class.getName()));\n+\n+        breaker.state(CircuitBreaker.State.CLOSED);\n+\n+        Manual m = new Manual();\n+        Single<String> manualResult = bulkhead.invoke(m::call);\n+\n+        result = faultTolerance.invoke(this::primary);\n+        assertThat(result.await(1, TimeUnit.SECONDS), is(BulkheadException.class.getName()));\n+\n+        m.future.complete(\"result\");\n+        manualResult.await(1, TimeUnit.SECONDS);\n+\n+        m = new Manual();\n+        result = faultTolerance.invoke(m::call);\n+        assertThat(result.await(1, TimeUnit.SECONDS), is(TimeoutException.class.getName()));\n+\n+        m.future.complete(\"hu\");\n+    }\n+\n+    private Single<String> primary() {\n+        return Single.error(new MyException());\n+    }\n+\n+    private Single<String> fallback(Throwable throwable) {\n+        return Single.just(throwable.getClass().getName());\n+    }\n+\n+    static <T extends Throwable> T completionException(Single<?> result, Class<T> expected) {\n+        CompletionException completionException = assertThrows(CompletionException.class,\n+                                                               () -> result.await(1, TimeUnit.SECONDS));\n+        Throwable cause = completionException.getCause();\n+        assertThat(cause, notNullValue());\n+        assertThat(cause, instanceOf(expected));\n+\n+        return expected.cast(cause);\n+    }\n+\n+    private class Manual {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0220ec94c2fa14c445c1ee9e0500ad64c9784993"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI3NDU3NQ==", "bodyText": "Static", "url": "https://github.com/oracle/helidon/pull/2120#discussion_r449274575", "createdAt": "2020-07-02T21:29:44Z", "author": {"login": "tomas-langer"}, "path": "fault-tolerance/src/test/java/io/helidon/faulttolerance/FaultToleranceTest.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.faulttolerance;\n+\n+import java.time.Duration;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import io.helidon.common.reactive.Single;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.CoreMatchers.instanceOf;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+public class FaultToleranceTest {\n+\n+    @Test\n+    void testCustomCombination() {\n+        CircuitBreaker breaker = CircuitBreaker.builder()\n+                .build();\n+\n+        Bulkhead bulkhead = Bulkhead.builder()\n+                .limit(1)\n+                .queueLength(0)\n+                .build();\n+\n+        FtHandlerTyped<String> faultTolerance = FaultTolerance.builder()\n+                .addBreaker(breaker)\n+                .addBulkhead(bulkhead)\n+                .addTimeout(Timeout.builder().timeout(Duration.ofMillis(100)).build())\n+                .addFallback(Fallback.<String>builder()\n+                                     .fallback(this::fallback)\n+                                     .build())\n+                .build();\n+\n+        Single<String> result = faultTolerance.invoke(this::primary);\n+        assertThat(result.await(1, TimeUnit.SECONDS), is(MyException.class.getName()));\n+\n+        breaker.state(CircuitBreaker.State.OPEN);\n+        result = faultTolerance.invoke(this::primary);\n+        assertThat(result.await(1, TimeUnit.SECONDS), is(CircuitBreakerOpenException.class.getName()));\n+\n+        breaker.state(CircuitBreaker.State.CLOSED);\n+\n+        Manual m = new Manual();\n+        Single<String> manualResult = bulkhead.invoke(m::call);\n+\n+        result = faultTolerance.invoke(this::primary);\n+        assertThat(result.await(1, TimeUnit.SECONDS), is(BulkheadException.class.getName()));\n+\n+        m.future.complete(\"result\");\n+        manualResult.await(1, TimeUnit.SECONDS);\n+\n+        m = new Manual();\n+        result = faultTolerance.invoke(m::call);\n+        assertThat(result.await(1, TimeUnit.SECONDS), is(TimeoutException.class.getName()));\n+\n+        m.future.complete(\"hu\");\n+    }\n+\n+    private Single<String> primary() {\n+        return Single.error(new MyException());\n+    }\n+\n+    private Single<String> fallback(Throwable throwable) {\n+        return Single.just(throwable.getClass().getName());\n+    }\n+\n+    static <T extends Throwable> T completionException(Single<?> result, Class<T> expected) {\n+        CompletionException completionException = assertThrows(CompletionException.class,\n+                                                               () -> result.await(1, TimeUnit.SECONDS));\n+        Throwable cause = completionException.getCause();\n+        assertThat(cause, notNullValue());\n+        assertThat(cause, instanceOf(expected));\n+\n+        return expected.cast(cause);\n+    }\n+\n+    private class Manual {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTAyNzYxNQ=="}, "originalCommit": {"oid": "0220ec94c2fa14c445c1ee9e0500ad64c9784993"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5ODg1NTk5OnYy", "diffSide": "RIGHT", "path": "examples/webserver/fault-tolerance/src/main/java/io/helidon/webserver/examples/faulttolerance/FtService.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNDoyNTowNFrOGsPQtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQyMTowOTowOFrOGsdE8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA0MDU2Ng==", "bodyText": "May be a bit more readable if methods had a suffix like \"M\", a bit difficult to read when named same as variables", "url": "https://github.com/oracle/helidon/pull/2120#discussion_r449040566", "createdAt": "2020-07-02T14:25:04Z", "author": {"login": "spericas"}, "path": "examples/webserver/fault-tolerance/src/main/java/io/helidon/webserver/examples/faulttolerance/FtService.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.webserver.examples.faulttolerance;\n+\n+import java.time.Duration;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import io.helidon.common.reactive.Single;\n+import io.helidon.faulttolerance.Async;\n+import io.helidon.faulttolerance.Bulkhead;\n+import io.helidon.faulttolerance.CircuitBreaker;\n+import io.helidon.faulttolerance.Fallback;\n+import io.helidon.faulttolerance.Retry;\n+import io.helidon.faulttolerance.Timeout;\n+import io.helidon.webserver.Routing;\n+import io.helidon.webserver.ServerRequest;\n+import io.helidon.webserver.ServerResponse;\n+import io.helidon.webserver.Service;\n+\n+/**\n+ * Simple service to demonstrate fault tolerance.\n+ */\n+public class FtService implements Service {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0220ec94c2fa14c445c1ee9e0500ad64c9784993"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTExNzYwNA==", "bodyText": "Will make it clear", "url": "https://github.com/oracle/helidon/pull/2120#discussion_r449117604", "createdAt": "2020-07-02T15:59:20Z", "author": {"login": "tomas-langer"}, "path": "examples/webserver/fault-tolerance/src/main/java/io/helidon/webserver/examples/faulttolerance/FtService.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.webserver.examples.faulttolerance;\n+\n+import java.time.Duration;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import io.helidon.common.reactive.Single;\n+import io.helidon.faulttolerance.Async;\n+import io.helidon.faulttolerance.Bulkhead;\n+import io.helidon.faulttolerance.CircuitBreaker;\n+import io.helidon.faulttolerance.Fallback;\n+import io.helidon.faulttolerance.Retry;\n+import io.helidon.faulttolerance.Timeout;\n+import io.helidon.webserver.Routing;\n+import io.helidon.webserver.ServerRequest;\n+import io.helidon.webserver.ServerResponse;\n+import io.helidon.webserver.Service;\n+\n+/**\n+ * Simple service to demonstrate fault tolerance.\n+ */\n+public class FtService implements Service {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA0MDU2Ng=="}, "originalCommit": {"oid": "0220ec94c2fa14c445c1ee9e0500ad64c9784993"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI2NjkyOQ==", "bodyText": "Changed method names to *Handler", "url": "https://github.com/oracle/helidon/pull/2120#discussion_r449266929", "createdAt": "2020-07-02T21:09:08Z", "author": {"login": "tomas-langer"}, "path": "examples/webserver/fault-tolerance/src/main/java/io/helidon/webserver/examples/faulttolerance/FtService.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.webserver.examples.faulttolerance;\n+\n+import java.time.Duration;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import io.helidon.common.reactive.Single;\n+import io.helidon.faulttolerance.Async;\n+import io.helidon.faulttolerance.Bulkhead;\n+import io.helidon.faulttolerance.CircuitBreaker;\n+import io.helidon.faulttolerance.Fallback;\n+import io.helidon.faulttolerance.Retry;\n+import io.helidon.faulttolerance.Timeout;\n+import io.helidon.webserver.Routing;\n+import io.helidon.webserver.ServerRequest;\n+import io.helidon.webserver.ServerResponse;\n+import io.helidon.webserver.Service;\n+\n+/**\n+ * Simple service to demonstrate fault tolerance.\n+ */\n+public class FtService implements Service {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA0MDU2Ng=="}, "originalCommit": {"oid": "0220ec94c2fa14c445c1ee9e0500ad64c9784993"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5OTA3MTYxOnYy", "diffSide": "RIGHT", "path": "fault-tolerance/src/test/java/io/helidon/faulttolerance/AsyncTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNToxNjowM1rOGsRY4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQyMToyOTozM1rOGsdihg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA3NTQyNQ==", "bodyText": "Unused", "url": "https://github.com/oracle/helidon/pull/2120#discussion_r449075425", "createdAt": "2020-07-02T15:16:03Z", "author": {"login": "spericas"}, "path": "fault-tolerance/src/test/java/io/helidon/faulttolerance/AsyncTest.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.faulttolerance;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import io.helidon.common.reactive.Single;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.CoreMatchers.instanceOf;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.not;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+class AsyncTest {\n+    private final AtomicInteger syncCounter = new AtomicInteger();\n+\n+    @BeforeEach\n+    void reset() {\n+        syncCounter.set(0);\n+    }\n+\n+    @Test\n+    void testAsync() {\n+        Thread result = Async.create()\n+                .invoke(this::sync)\n+                .await(1, TimeUnit.SECONDS);\n+\n+        assertThat(result, is(not(Thread.currentThread())));\n+        assertThat(syncCounter.get(), is(1));\n+    }\n+\n+    @Test\n+    void testAsyncError() {\n+        Single<String> result = Async.create()\n+                .invoke(this::syncError);\n+\n+        CompletionException exception = assertThrows(CompletionException.class, () -> result.await(1, TimeUnit.SECONDS));\n+\n+        Throwable cause = exception.getCause();\n+\n+        assertThat(cause, notNullValue());\n+        assertThat(cause, instanceOf(MyException.class));\n+    }\n+\n+    private List<String> syncList() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0220ec94c2fa14c445c1ee9e0500ad64c9784993"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI3NDUwMg==", "bodyText": "Removed", "url": "https://github.com/oracle/helidon/pull/2120#discussion_r449274502", "createdAt": "2020-07-02T21:29:33Z", "author": {"login": "tomas-langer"}, "path": "fault-tolerance/src/test/java/io/helidon/faulttolerance/AsyncTest.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.faulttolerance;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import io.helidon.common.reactive.Single;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import static org.hamcrest.CoreMatchers.instanceOf;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.notNullValue;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.not;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+class AsyncTest {\n+    private final AtomicInteger syncCounter = new AtomicInteger();\n+\n+    @BeforeEach\n+    void reset() {\n+        syncCounter.set(0);\n+    }\n+\n+    @Test\n+    void testAsync() {\n+        Thread result = Async.create()\n+                .invoke(this::sync)\n+                .await(1, TimeUnit.SECONDS);\n+\n+        assertThat(result, is(not(Thread.currentThread())));\n+        assertThat(syncCounter.get(), is(1));\n+    }\n+\n+    @Test\n+    void testAsyncError() {\n+        Single<String> result = Async.create()\n+                .invoke(this::syncError);\n+\n+        CompletionException exception = assertThrows(CompletionException.class, () -> result.await(1, TimeUnit.SECONDS));\n+\n+        Throwable cause = exception.getCause();\n+\n+        assertThat(cause, notNullValue());\n+        assertThat(cause, instanceOf(MyException.class));\n+    }\n+\n+    private List<String> syncList() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA3NTQyNQ=="}, "originalCommit": {"oid": "0220ec94c2fa14c445c1ee9e0500ad64c9784993"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5OTE2NTg3OnYy", "diffSide": "RIGHT", "path": "fault-tolerance/src/main/java/io/helidon/faulttolerance/AtomicCycle.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNTozMzo0OFrOGsSX8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQyMToyOToyMlrOGsdiSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA5MTU2OQ==", "bodyText": "Isn't this better?\n    final static class AtomicCycle {\n        private final AtomicInteger atomicInteger = new AtomicInteger(-1);\n        private final int maxIndex;\n\n        AtomicCycle(int maxIndex) {\n            this.maxIndex = maxIndex + 1;\n        }\n\n        int incrementAndGet() {\n            return atomicInteger.accumulateAndGet(maxIndex, (current, max) -> (current + 1) % max);\n        }\n    }", "url": "https://github.com/oracle/helidon/pull/2120#discussion_r449091569", "createdAt": "2020-07-02T15:33:48Z", "author": {"login": "spericas"}, "path": "fault-tolerance/src/main/java/io/helidon/faulttolerance/AtomicCycle.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.faulttolerance;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+final class AtomicCycle {\n+    private final AtomicInteger atomicInteger = new AtomicInteger(-1);\n+    private final int maxIndex;\n+\n+    AtomicCycle(int maxIndex) {\n+        this.maxIndex = maxIndex;\n+    }\n+\n+    int incrementAndGet() {\n+        int currentIndex;\n+        int nextIndex;\n+        do {\n+            currentIndex = atomicInteger.get();\n+            nextIndex = (currentIndex == maxIndex) ? 0 : currentIndex + 1;\n+        } while (!atomicInteger.compareAndSet(currentIndex, nextIndex));\n+\n+        return nextIndex;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0220ec94c2fa14c445c1ee9e0500ad64c9784993"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI3NDQ0Mg==", "bodyText": "Yes, fixed.", "url": "https://github.com/oracle/helidon/pull/2120#discussion_r449274442", "createdAt": "2020-07-02T21:29:22Z", "author": {"login": "tomas-langer"}, "path": "fault-tolerance/src/main/java/io/helidon/faulttolerance/AtomicCycle.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Copyright (c) 2020 Oracle and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.helidon.faulttolerance;\n+\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+final class AtomicCycle {\n+    private final AtomicInteger atomicInteger = new AtomicInteger(-1);\n+    private final int maxIndex;\n+\n+    AtomicCycle(int maxIndex) {\n+        this.maxIndex = maxIndex;\n+    }\n+\n+    int incrementAndGet() {\n+        int currentIndex;\n+        int nextIndex;\n+        do {\n+            currentIndex = atomicInteger.get();\n+            nextIndex = (currentIndex == maxIndex) ? 0 : currentIndex + 1;\n+        } while (!atomicInteger.compareAndSet(currentIndex, nextIndex));\n+\n+        return nextIndex;\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA5MTU2OQ=="}, "originalCommit": {"oid": "0220ec94c2fa14c445c1ee9e0500ad64c9784993"}, "originalPosition": 38}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 448, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}