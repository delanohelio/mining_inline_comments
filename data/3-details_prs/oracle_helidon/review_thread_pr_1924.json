{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI2Njc2OTI1", "number": 1924, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNTowODo0N1rOECmzvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNTowODo0N1rOECmzvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMTY4NDQ3OnYy", "diffSide": "RIGHT", "path": "common/reactive/src/main/java/io/helidon/common/reactive/IoMulti.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNTowODo0N1rOGfKoPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNTo1NzozNVrOGfM4_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTMzMzE4MQ==", "bodyText": "{@link ReadableByteChannel}", "url": "https://github.com/oracle/helidon/pull/1924#discussion_r435333181", "createdAt": "2020-06-04T15:08:47Z", "author": {"login": "danielkec"}, "path": "common/reactive/src/main/java/io/helidon/common/reactive/IoMulti.java", "diffHunk": "@@ -67,23 +103,175 @@ static OutputStreamMultiBuilder builderOutputStream() {\n      * @param inputStream the Stream to publish\n      * @return Multi\n      * @throws NullPointerException if {@code stream} is {@code null}\n+     * @deprecated please use {@link #multiFromStream(java.io.InputStream)}\n      */\n+    @Deprecated(since = \"2.0.0\", forRemoval = true)\n     static Multi<ByteBuffer> createInputStream(final InputStream inputStream) {\n         return IoMulti.builderInputStream(inputStream)\n                 .build();\n     }\n \n+    /**\n+     * Create a {@link Multi} instance that publishes {@link ByteBuffer}s from\n+     * the given {@link InputStream}.\n+     * <p>\n+     * {@link InputStream} is trusted not to block on read operations, in case\n+     * it can't be assured use builder to specify executor for asynchronous waiting\n+     * for blocking reads. {@code IoMulti.builder(is).executor(executorService).build()}.\n+     *\n+     * @param inputStream the Stream to publish\n+     * @return Multi\n+     */\n+    static Multi<ByteBuffer> multiFromStream(final InputStream inputStream) {\n+        return IoMulti.builderInputStream(inputStream)\n+                .build();\n+    }\n+\n     /**\n      * Creates a builder of the {@link Multi} from supplied {@link java.io.InputStream}.\n      *\n      * @param inputStream the Stream to publish\n      * @return the builder\n+     * @deprecated Please use {@link #multiFromStreamBuilder(java.io.InputStream)}\n      */\n+    @Deprecated(since = \"2.0.0\", forRemoval = true)\n     static MultiFromInputStreamBuilder builderInputStream(final InputStream inputStream) {\n         Objects.requireNonNull(inputStream);\n         return new MultiFromInputStreamBuilder(inputStream);\n     }\n \n+    /**\n+     * Creates a builder of the {@link Multi} from supplied {@link java.io.InputStream}.\n+     *\n+     * @param inputStream the Stream to publish\n+     * @return the builder\n+     */\n+    static MultiFromInputStreamBuilder multiFromStreamBuilder(final InputStream inputStream) {\n+        Objects.requireNonNull(inputStream);\n+        return new MultiFromInputStreamBuilder(inputStream);\n+    }\n+\n+    /**\n+     * Creates a multi that reads data from the provided byte channel.\n+     * The multi uses an executor service to process asynchronous reads.\n+     * You can provide a custom executor service using\n+     * {@link #multiFromByteChannelBuilder(java.nio.channels.ReadableByteChannel)}.\n+     *\n+     * @param byteChannel readable byte channel with data\n+     * @return publisher of data from the provided channel\n+     */\n+    static Multi<ByteBuffer> multiFromByteChannel(ReadableByteChannel byteChannel) {\n+        return multiFromByteChannelBuilder(byteChannel).build();\n+    }\n+\n+    /**\n+     * Creates a builder of {@link Multi} from provided {@link java.nio.channels.ReadableByteChannel}.\n+     *\n+     * @param byteChannel readable byte channel with data\n+     * @return fluent API builder to configure additional details\n+     */\n+    static MultiFromByteChannelBuilder multiFromByteChannelBuilder(ReadableByteChannel byteChannel) {\n+        return new MultiFromByteChannelBuilder(Objects.requireNonNull(byteChannel));\n+    }\n+\n+    /**\n+     * Fluent API builder for creating a {@link io.helidon.common.reactive.Multi} from an\n+     * {@link java.io.InputStream}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "459f5956cf5ce789da7d1deeeab1dc51f2beb6a4"}, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM0ODE3Mg==", "bodyText": "Not sure I understand the comment?\nIn general it is preferable to use fully qualified class names in Javadoc, so you do not import a class only referenced in Javadoc", "url": "https://github.com/oracle/helidon/pull/1924#discussion_r435348172", "createdAt": "2020-06-04T15:29:06Z", "author": {"login": "tomas-langer"}, "path": "common/reactive/src/main/java/io/helidon/common/reactive/IoMulti.java", "diffHunk": "@@ -67,23 +103,175 @@ static OutputStreamMultiBuilder builderOutputStream() {\n      * @param inputStream the Stream to publish\n      * @return Multi\n      * @throws NullPointerException if {@code stream} is {@code null}\n+     * @deprecated please use {@link #multiFromStream(java.io.InputStream)}\n      */\n+    @Deprecated(since = \"2.0.0\", forRemoval = true)\n     static Multi<ByteBuffer> createInputStream(final InputStream inputStream) {\n         return IoMulti.builderInputStream(inputStream)\n                 .build();\n     }\n \n+    /**\n+     * Create a {@link Multi} instance that publishes {@link ByteBuffer}s from\n+     * the given {@link InputStream}.\n+     * <p>\n+     * {@link InputStream} is trusted not to block on read operations, in case\n+     * it can't be assured use builder to specify executor for asynchronous waiting\n+     * for blocking reads. {@code IoMulti.builder(is).executor(executorService).build()}.\n+     *\n+     * @param inputStream the Stream to publish\n+     * @return Multi\n+     */\n+    static Multi<ByteBuffer> multiFromStream(final InputStream inputStream) {\n+        return IoMulti.builderInputStream(inputStream)\n+                .build();\n+    }\n+\n     /**\n      * Creates a builder of the {@link Multi} from supplied {@link java.io.InputStream}.\n      *\n      * @param inputStream the Stream to publish\n      * @return the builder\n+     * @deprecated Please use {@link #multiFromStreamBuilder(java.io.InputStream)}\n      */\n+    @Deprecated(since = \"2.0.0\", forRemoval = true)\n     static MultiFromInputStreamBuilder builderInputStream(final InputStream inputStream) {\n         Objects.requireNonNull(inputStream);\n         return new MultiFromInputStreamBuilder(inputStream);\n     }\n \n+    /**\n+     * Creates a builder of the {@link Multi} from supplied {@link java.io.InputStream}.\n+     *\n+     * @param inputStream the Stream to publish\n+     * @return the builder\n+     */\n+    static MultiFromInputStreamBuilder multiFromStreamBuilder(final InputStream inputStream) {\n+        Objects.requireNonNull(inputStream);\n+        return new MultiFromInputStreamBuilder(inputStream);\n+    }\n+\n+    /**\n+     * Creates a multi that reads data from the provided byte channel.\n+     * The multi uses an executor service to process asynchronous reads.\n+     * You can provide a custom executor service using\n+     * {@link #multiFromByteChannelBuilder(java.nio.channels.ReadableByteChannel)}.\n+     *\n+     * @param byteChannel readable byte channel with data\n+     * @return publisher of data from the provided channel\n+     */\n+    static Multi<ByteBuffer> multiFromByteChannel(ReadableByteChannel byteChannel) {\n+        return multiFromByteChannelBuilder(byteChannel).build();\n+    }\n+\n+    /**\n+     * Creates a builder of {@link Multi} from provided {@link java.nio.channels.ReadableByteChannel}.\n+     *\n+     * @param byteChannel readable byte channel with data\n+     * @return fluent API builder to configure additional details\n+     */\n+    static MultiFromByteChannelBuilder multiFromByteChannelBuilder(ReadableByteChannel byteChannel) {\n+        return new MultiFromByteChannelBuilder(Objects.requireNonNull(byteChannel));\n+    }\n+\n+    /**\n+     * Fluent API builder for creating a {@link io.helidon.common.reactive.Multi} from an\n+     * {@link java.io.InputStream}.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTMzMzE4MQ=="}, "originalCommit": {"oid": "459f5956cf5ce789da7d1deeeab1dc51f2beb6a4"}, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM2ODk1Mg==", "bodyText": "Its just its on MultiFromByteChannelBuilder so it should be from ReadableByteChannel not from InputStream", "url": "https://github.com/oracle/helidon/pull/1924#discussion_r435368952", "createdAt": "2020-06-04T15:55:49Z", "author": {"login": "danielkec"}, "path": "common/reactive/src/main/java/io/helidon/common/reactive/IoMulti.java", "diffHunk": "@@ -67,23 +103,175 @@ static OutputStreamMultiBuilder builderOutputStream() {\n      * @param inputStream the Stream to publish\n      * @return Multi\n      * @throws NullPointerException if {@code stream} is {@code null}\n+     * @deprecated please use {@link #multiFromStream(java.io.InputStream)}\n      */\n+    @Deprecated(since = \"2.0.0\", forRemoval = true)\n     static Multi<ByteBuffer> createInputStream(final InputStream inputStream) {\n         return IoMulti.builderInputStream(inputStream)\n                 .build();\n     }\n \n+    /**\n+     * Create a {@link Multi} instance that publishes {@link ByteBuffer}s from\n+     * the given {@link InputStream}.\n+     * <p>\n+     * {@link InputStream} is trusted not to block on read operations, in case\n+     * it can't be assured use builder to specify executor for asynchronous waiting\n+     * for blocking reads. {@code IoMulti.builder(is).executor(executorService).build()}.\n+     *\n+     * @param inputStream the Stream to publish\n+     * @return Multi\n+     */\n+    static Multi<ByteBuffer> multiFromStream(final InputStream inputStream) {\n+        return IoMulti.builderInputStream(inputStream)\n+                .build();\n+    }\n+\n     /**\n      * Creates a builder of the {@link Multi} from supplied {@link java.io.InputStream}.\n      *\n      * @param inputStream the Stream to publish\n      * @return the builder\n+     * @deprecated Please use {@link #multiFromStreamBuilder(java.io.InputStream)}\n      */\n+    @Deprecated(since = \"2.0.0\", forRemoval = true)\n     static MultiFromInputStreamBuilder builderInputStream(final InputStream inputStream) {\n         Objects.requireNonNull(inputStream);\n         return new MultiFromInputStreamBuilder(inputStream);\n     }\n \n+    /**\n+     * Creates a builder of the {@link Multi} from supplied {@link java.io.InputStream}.\n+     *\n+     * @param inputStream the Stream to publish\n+     * @return the builder\n+     */\n+    static MultiFromInputStreamBuilder multiFromStreamBuilder(final InputStream inputStream) {\n+        Objects.requireNonNull(inputStream);\n+        return new MultiFromInputStreamBuilder(inputStream);\n+    }\n+\n+    /**\n+     * Creates a multi that reads data from the provided byte channel.\n+     * The multi uses an executor service to process asynchronous reads.\n+     * You can provide a custom executor service using\n+     * {@link #multiFromByteChannelBuilder(java.nio.channels.ReadableByteChannel)}.\n+     *\n+     * @param byteChannel readable byte channel with data\n+     * @return publisher of data from the provided channel\n+     */\n+    static Multi<ByteBuffer> multiFromByteChannel(ReadableByteChannel byteChannel) {\n+        return multiFromByteChannelBuilder(byteChannel).build();\n+    }\n+\n+    /**\n+     * Creates a builder of {@link Multi} from provided {@link java.nio.channels.ReadableByteChannel}.\n+     *\n+     * @param byteChannel readable byte channel with data\n+     * @return fluent API builder to configure additional details\n+     */\n+    static MultiFromByteChannelBuilder multiFromByteChannelBuilder(ReadableByteChannel byteChannel) {\n+        return new MultiFromByteChannelBuilder(Objects.requireNonNull(byteChannel));\n+    }\n+\n+    /**\n+     * Fluent API builder for creating a {@link io.helidon.common.reactive.Multi} from an\n+     * {@link java.io.InputStream}.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTMzMzE4MQ=="}, "originalCommit": {"oid": "459f5956cf5ce789da7d1deeeab1dc51f2beb6a4"}, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM3MDIzNg==", "bodyText": "Fixed.", "url": "https://github.com/oracle/helidon/pull/1924#discussion_r435370236", "createdAt": "2020-06-04T15:57:35Z", "author": {"login": "tomas-langer"}, "path": "common/reactive/src/main/java/io/helidon/common/reactive/IoMulti.java", "diffHunk": "@@ -67,23 +103,175 @@ static OutputStreamMultiBuilder builderOutputStream() {\n      * @param inputStream the Stream to publish\n      * @return Multi\n      * @throws NullPointerException if {@code stream} is {@code null}\n+     * @deprecated please use {@link #multiFromStream(java.io.InputStream)}\n      */\n+    @Deprecated(since = \"2.0.0\", forRemoval = true)\n     static Multi<ByteBuffer> createInputStream(final InputStream inputStream) {\n         return IoMulti.builderInputStream(inputStream)\n                 .build();\n     }\n \n+    /**\n+     * Create a {@link Multi} instance that publishes {@link ByteBuffer}s from\n+     * the given {@link InputStream}.\n+     * <p>\n+     * {@link InputStream} is trusted not to block on read operations, in case\n+     * it can't be assured use builder to specify executor for asynchronous waiting\n+     * for blocking reads. {@code IoMulti.builder(is).executor(executorService).build()}.\n+     *\n+     * @param inputStream the Stream to publish\n+     * @return Multi\n+     */\n+    static Multi<ByteBuffer> multiFromStream(final InputStream inputStream) {\n+        return IoMulti.builderInputStream(inputStream)\n+                .build();\n+    }\n+\n     /**\n      * Creates a builder of the {@link Multi} from supplied {@link java.io.InputStream}.\n      *\n      * @param inputStream the Stream to publish\n      * @return the builder\n+     * @deprecated Please use {@link #multiFromStreamBuilder(java.io.InputStream)}\n      */\n+    @Deprecated(since = \"2.0.0\", forRemoval = true)\n     static MultiFromInputStreamBuilder builderInputStream(final InputStream inputStream) {\n         Objects.requireNonNull(inputStream);\n         return new MultiFromInputStreamBuilder(inputStream);\n     }\n \n+    /**\n+     * Creates a builder of the {@link Multi} from supplied {@link java.io.InputStream}.\n+     *\n+     * @param inputStream the Stream to publish\n+     * @return the builder\n+     */\n+    static MultiFromInputStreamBuilder multiFromStreamBuilder(final InputStream inputStream) {\n+        Objects.requireNonNull(inputStream);\n+        return new MultiFromInputStreamBuilder(inputStream);\n+    }\n+\n+    /**\n+     * Creates a multi that reads data from the provided byte channel.\n+     * The multi uses an executor service to process asynchronous reads.\n+     * You can provide a custom executor service using\n+     * {@link #multiFromByteChannelBuilder(java.nio.channels.ReadableByteChannel)}.\n+     *\n+     * @param byteChannel readable byte channel with data\n+     * @return publisher of data from the provided channel\n+     */\n+    static Multi<ByteBuffer> multiFromByteChannel(ReadableByteChannel byteChannel) {\n+        return multiFromByteChannelBuilder(byteChannel).build();\n+    }\n+\n+    /**\n+     * Creates a builder of {@link Multi} from provided {@link java.nio.channels.ReadableByteChannel}.\n+     *\n+     * @param byteChannel readable byte channel with data\n+     * @return fluent API builder to configure additional details\n+     */\n+    static MultiFromByteChannelBuilder multiFromByteChannelBuilder(ReadableByteChannel byteChannel) {\n+        return new MultiFromByteChannelBuilder(Objects.requireNonNull(byteChannel));\n+    }\n+\n+    /**\n+     * Fluent API builder for creating a {@link io.helidon.common.reactive.Multi} from an\n+     * {@link java.io.InputStream}.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTMzMzE4MQ=="}, "originalCommit": {"oid": "459f5956cf5ce789da7d1deeeab1dc51f2beb6a4"}, "originalPosition": 162}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 602, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}