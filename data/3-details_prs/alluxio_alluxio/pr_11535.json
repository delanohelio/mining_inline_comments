{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMyMTAyNjQy", "number": 11535, "title": "Implement interrupt based locking protocol over state-lock", "bodyText": "This PR, in general, introduces a new locking framework over state-lock. Changes can be summarized as:\n\n\nBackups take the lock exclusive with an initial grace-cycle. Grace-cycle is defined as tryLock-sleep cycles until the lock is held. 3 graceful locking strategies have been implemented (TIMEOUT, FORCED)\n\n\nImmediate shared holders/waiters of state-lock may now be interrupted as part of interrupt-cycle task, which is activated before or after taking the lock.\n\n\nShell/daily backups can now be configured for all grace modes via master config change. (Defaults for Shell: TIMEOUT, Daily: FORCED)\n\n\nA new maintenance duration( exclusive-only phase) is defined for masters, during which only exclusive locking will be allowed. This duration is effective after the first time masters are started, after reading the journals.", "createdAt": "2020-06-09T22:41:59Z", "url": "https://github.com/Alluxio/alluxio/pull/11535", "merged": true, "mergeCommit": {"oid": "86767c7206ec898a62b6b10c898eab8f1c0393bb"}, "closed": true, "closedAt": "2020-06-17T17:42:05Z", "author": {"login": "ggezer"}, "timelineItems": {"totalCount": 21, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcptGHTgFqTQyNzU5NzY3MQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcr9Em2AFqTQzMTkzODMxMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI3NTk3Njcx", "url": "https://github.com/Alluxio/alluxio/pull/11535#pullrequestreview-427597671", "createdAt": "2020-06-09T22:49:22Z", "commit": {"oid": "d5b75bfc788ecfaa6d8cbf059542924b0738821c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQyMjo0OToyM1rOGhfBAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQyMjo0OToyM1rOGhfBAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc2NDM1NQ==", "bodyText": "@gpang if you pass the last argument of StateLockOptions as 0 (which disables the interrupt-waiters cycle), then the repro will fail as before.", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r437764355", "createdAt": "2020-06-09T22:49:23Z", "author": {"login": "ggezer"}, "path": "tests/src/test/java/alluxio/client/cli/fsadmin/BackupCommandIntegrationTest.java", "diffHunk": "@@ -87,4 +101,54 @@ public void timeout() throws Exception {\n       assertNotEquals(0, errCode);\n     }\n   }\n+\n+  @Test\n+  public void workersLostRepro() throws Exception {\n+    // Grab the master state-change lock via reflection.\n+    MasterProcess masterProcess =\n+        Whitebox.getInternalState(mLocalAlluxioCluster.getLocalAlluxioMaster(), \"mMasterProcess\");\n+    MasterContext masterCtx = Whitebox.getInternalState(masterProcess, \"mContext\");\n+    StateLockManager stateLockManager = masterCtx.getStateLockManager();\n+\n+    BlockMaster blockMaster = masterProcess.getMaster(BlockMaster.class);\n+    Whitebox.setInternalState(blockMaster, \"mMasterContext\", masterCtx);\n+\n+    FileSystemMaster fsMaster = masterProcess.getMaster(FileSystemMaster.class);\n+    Whitebox.setInternalState(fsMaster, \"mMasterContext\", masterCtx);\n+\n+    FileSystem fs = mLocalAlluxioCluster.getClient();\n+    FileOutStream fsOutStr = fs.createFile(new AlluxioURI(\"/test\"));\n+    fsOutStr.write(\"bogus\".getBytes());\n+    // Lock the state-change lock on the master.\n+    LockResource lr =\n+        stateLockManager.lockExclusive(new StateLockOptions(false, false, true, 0, 0, 0, 100));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5b75bfc788ecfaa6d8cbf059542924b0738821c"}, "originalPosition": 70}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI3NjI2NDEw", "url": "https://github.com/Alluxio/alluxio/pull/11535#pullrequestreview-427626410", "createdAt": "2020-06-10T00:07:00Z", "commit": {"oid": "69ff6f65f4e88e80951149f0a3d3899da5d8cfff"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwMDowNzowMFrOGhgf_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxNjozNTo1OFrOGh9VZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc4ODY3MQ==", "bodyText": "Mark the runnable as @Nullable", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r437788671", "createdAt": "2020-06-10T00:07:00Z", "author": {"login": "gpang"}, "path": "core/common/src/main/java/alluxio/resource/LockResource.java", "diffHunk": "@@ -59,7 +56,25 @@ public LockResource(Lock lock) {\n    * @param useTryLock whether or not use to {@link Lock#tryLock()}\n    */\n   public LockResource(Lock lock, boolean acquireLock, boolean useTryLock) {\n+    this(lock, acquireLock, useTryLock, null);\n+  }\n+\n+  /**\n+   * Creates a new instance of {@link LockResource} using the given lock.\n+   *\n+   * This method may use the {@link Lock#tryLock()} method to gain ownership of the locks. The\n+   * reason one might want to use this is to avoid the fairness heuristics within the\n+   * {@link java.util.concurrent.locks.ReentrantReadWriteLock}'s NonFairSync which may block reader\n+   * threads if a writer if the first in the queue.\n+   *\n+   * @param lock the lock to acquire\n+   * @param acquireLock whether to lock the lock\n+   * @param useTryLock whether or not use to {@link Lock#tryLock()}\n+   * @param closeAction the closeable that will be closed along with this lock\n+   */\n+  public LockResource(Lock lock, boolean acquireLock, boolean useTryLock, Runnable closeAction) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69ff6f65f4e88e80951149f0a3d3899da5d8cfff"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI0NjA0MA==", "bodyText": "Does this mean backup is in progress? Should we say more in the message?", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r438246040", "createdAt": "2020-06-10T16:12:33Z", "author": {"login": "gpang"}, "path": "core/server/common/src/main/java/alluxio/master/AbstractMaster.java", "diffHunk": "@@ -135,8 +136,14 @@ protected ExecutorService getExecutorService() {\n   public JournalContext createJournalContext() throws UnavailableException {\n     // Use the state change lock for the journal context, since all modifications to journaled\n     // state must happen inside of a journal context.\n-    return new StateChangeJournalContext(mJournal.createJournalContext(),\n-        mMasterContext.stateChangeLock());\n+    LockResource sharedLockResource;\n+    try {\n+      sharedLockResource = mMasterContext.getStateLockManager().lockShared();\n+    } catch (InterruptedException e) {\n+      throw new UnavailableException(\"Failed to acquire state-lock in shared mode.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e248a260c674452ccdc7bfad1c202df47033c27"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI0ODcwNg==", "bodyText": "If these were in a previous release, removal is not backwards compatible.", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r438248706", "createdAt": "2020-06-10T16:16:38Z", "author": {"login": "gpang"}, "path": "core/transport/src/main/proto/grpc/meta_master.proto", "diffHunk": "@@ -119,9 +119,6 @@ message BackupPOptions {\n     optional bool localFileSystem = 1;\n     optional bool runAsync = 2;\n     optional bool allowLeader = 3;\n-    optional int64 stateLockTryDurationMs = 4;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e248a260c674452ccdc7bfad1c202df47033c27"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI0ODkyNw==", "bodyText": "are the changes in this file necessary?", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r438248927", "createdAt": "2020-06-10T16:16:59Z", "author": {"login": "gpang"}, "path": "pom.xml", "diffHunk": "@@ -158,7 +158,7 @@\n     <surefire.rerunFailingTestsCount>1</surefire.rerunFailingTestsCount>\n     <test.output.redirect>true</test.output.redirect>\n     <update.check.enabled>false</update.check.enabled>\n-    <findbugs.skip>false</findbugs.skip>\n+    <findbugs.skip>true</findbugs.skip>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e248a260c674452ccdc7bfad1c202df47033c27"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI0OTIyMQ==", "bodyText": "why are these all set to IGNORE?", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r438249221", "createdAt": "2020-06-10T16:17:27Z", "author": {"login": "gpang"}, "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "diffHunk": "@@ -1296,6 +1296,13 @@ public String toString() {\n           .setConsistencyCheckLevel(ConsistencyCheckLevel.IGNORE)\n           .setScope(Scope.MASTER)\n           .build();\n+  public static final PropertyKey MASTER_BACKUP_STATE_LOCK_SAFE_MODE =\n+      new Builder(Name.MASTER_BACKUP_STATE_LOCK_SAFE_MODE)\n+          .setDefaultValue(false)\n+          .setDescription(\"Ignores client state-lock requests for backup to always take the lock.\")\n+          .setConsistencyCheckLevel(ConsistencyCheckLevel.IGNORE)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e248a260c674452ccdc7bfad1c202df47033c27"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI0OTk4OQ==", "bodyText": "Can you add what this implies? Like, all new rpcs could block for this long?", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r438249989", "createdAt": "2020-06-10T16:18:33Z", "author": {"login": "gpang"}, "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "diffHunk": "@@ -1323,11 +1330,24 @@ public String toString() {\n           .setConsistencyCheckLevel(ConsistencyCheckLevel.ENFORCE)\n           .setScope(Scope.MASTER)\n           .build();\n-  public static final PropertyKey MASTER_BACKUP_STATE_LOCK_TIMEOUT =\n-      new Builder(Name.MASTER_BACKUP_STATE_LOCK_TIMEOUT)\n+  public static final PropertyKey MASTER_SHELL_BACKUP_STATE_LOCK_TIMEOUT =\n+      new Builder(Name.MASTER_SHELL_BACKUP_STATE_LOCK_TIMEOUT)\n           .setDefaultValue(\"1m\")\n-          .setDescription(\n-              \"The max duration to try acquiring the state lock for taking backups via shell.\")\n+          .setDescription(\"The max duration to try acquiring the state lock for taking backups .\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e248a260c674452ccdc7bfad1c202df47033c27"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI1MDUzNA==", "bodyText": "I don't think grace period is defined anywhere, so this description is not obvious what it means.", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r438250534", "createdAt": "2020-06-10T16:19:17Z", "author": {"login": "gpang"}, "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "diffHunk": "@@ -1323,11 +1330,24 @@ public String toString() {\n           .setConsistencyCheckLevel(ConsistencyCheckLevel.ENFORCE)\n           .setScope(Scope.MASTER)\n           .build();\n-  public static final PropertyKey MASTER_BACKUP_STATE_LOCK_TIMEOUT =\n-      new Builder(Name.MASTER_BACKUP_STATE_LOCK_TIMEOUT)\n+  public static final PropertyKey MASTER_SHELL_BACKUP_STATE_LOCK_TIMEOUT =\n+      new Builder(Name.MASTER_SHELL_BACKUP_STATE_LOCK_TIMEOUT)\n           .setDefaultValue(\"1m\")\n-          .setDescription(\n-              \"The max duration to try acquiring the state lock for taking backups via shell.\")\n+          .setDescription(\"The max duration to try acquiring the state lock for taking backups .\")\n+          .setConsistencyCheckLevel(ConsistencyCheckLevel.IGNORE)\n+          .setScope(Scope.MASTER)\n+          .build();\n+  public static final PropertyKey MASTER_SHELL_BACKUP_STATE_LOCK_INTERRUPT_HOLDERS_AFTER_GRACE =\n+      new Builder(Name.MASTER_SHELL_BACKUP_STATE_LOCK_INTERRUPT_HOLDERS_AFTER_GRACE)\n+          .setDefaultValue(false)\n+          .setDescription(\"Whether to interrupt state-lock holders after grace period.\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e248a260c674452ccdc7bfad1c202df47033c27"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI1MDg5OA==", "bodyText": "I don't think grace period is defined anywhere, so this description is not obvious what it means. Also, it is not clear how it is different from MASTER_SHELL_BACKUP_STATE_LOCK_INTERRUPT_HOLDERS_AFTER_GRACE. Interrupting sounds forceful, so would this parameter be different?", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r438250898", "createdAt": "2020-06-10T16:19:58Z", "author": {"login": "gpang"}, "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "diffHunk": "@@ -1323,11 +1330,24 @@ public String toString() {\n           .setConsistencyCheckLevel(ConsistencyCheckLevel.ENFORCE)\n           .setScope(Scope.MASTER)\n           .build();\n-  public static final PropertyKey MASTER_BACKUP_STATE_LOCK_TIMEOUT =\n-      new Builder(Name.MASTER_BACKUP_STATE_LOCK_TIMEOUT)\n+  public static final PropertyKey MASTER_SHELL_BACKUP_STATE_LOCK_TIMEOUT =\n+      new Builder(Name.MASTER_SHELL_BACKUP_STATE_LOCK_TIMEOUT)\n           .setDefaultValue(\"1m\")\n-          .setDescription(\n-              \"The max duration to try acquiring the state lock for taking backups via shell.\")\n+          .setDescription(\"The max duration to try acquiring the state lock for taking backups .\")\n+          .setConsistencyCheckLevel(ConsistencyCheckLevel.IGNORE)\n+          .setScope(Scope.MASTER)\n+          .build();\n+  public static final PropertyKey MASTER_SHELL_BACKUP_STATE_LOCK_INTERRUPT_HOLDERS_AFTER_GRACE =\n+      new Builder(Name.MASTER_SHELL_BACKUP_STATE_LOCK_INTERRUPT_HOLDERS_AFTER_GRACE)\n+          .setDefaultValue(false)\n+          .setDescription(\"Whether to interrupt state-lock holders after grace period.\")\n+          .setConsistencyCheckLevel(ConsistencyCheckLevel.IGNORE)\n+          .setScope(Scope.MASTER)\n+          .build();\n+  public static final PropertyKey MASTER_SHELL_BACKUP_STATE_LOCK_TAKE_AFTER_GRACE =\n+      new Builder(Name.MASTER_SHELL_BACKUP_STATE_LOCK_TAKE_AFTER_GRACE)\n+          .setDefaultValue(false)\n+          .setDescription(\"Whether to take the lock forcefully after grace period.\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e248a260c674452ccdc7bfad1c202df47033c27"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI1MTM1NA==", "bodyText": "I have the same questions as the shell ones.", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r438251354", "createdAt": "2020-06-10T16:20:39Z", "author": {"login": "gpang"}, "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "diffHunk": "@@ -1352,6 +1372,20 @@ public String toString() {\n           .setConsistencyCheckLevel(ConsistencyCheckLevel.IGNORE)\n           .setScope(Scope.MASTER)\n           .build();\n+  public static final PropertyKey MASTER_DAILY_BACKUP_STATE_LOCK_INTERRUPT_HOLDERS_AFTER_GRACE =\n+      new Builder(Name.MASTER_DAILY_BACKUP_STATE_LOCK_INTERRUPT_HOLDERS_AFTER_GRACE)\n+          .setDefaultValue(true)\n+          .setDescription(\"Whether to interrupt state-lock holders after grace period.\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e248a260c674452ccdc7bfad1c202df47033c27"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI1MzU1NQ==", "bodyText": "what does safe mode mean? I think it would be helpful if there was more documentation on this class as to what various terms mean, and workflow or state transitions.", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r438253555", "createdAt": "2020-06-10T16:23:59Z", "author": {"login": "gpang"}, "path": "core/server/common/src/main/java/alluxio/master/StateLockManager.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master;\n+\n+import alluxio.collections.ConcurrentHashSet;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.exception.ExceptionMessage;\n+import alluxio.resource.LockResource;\n+import alluxio.util.ThreadFactoryUtils;\n+\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+/**\n+ * Provides graceful and interruptable locking protocol for taking the state lock.\n+ *\n+ * {@link #lockShared()} will be used by user RPCs and may throw {@link InterruptedException}\n+ * based on options passed to {@link #lockExclusive(StateLockOptions)}.\n+ *\n+ * {@link #lockExclusive(StateLockOptions)} will be used by metadata backups in order to\n+ * guarantee paused state during critical tasks.\n+ */\n+public class StateLockManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(StateLockManager.class);\n+\n+  /** The state-lock */\n+  private ReadWriteLock mStateLock = new ReentrantReadWriteLock(true);\n+\n+  /** The set of threads that are waiting for state-lock in shared mode. */\n+  private Set<Thread> mSharedWaiters;\n+  /** The set of threads that are holding the state-lock in shared mode. */\n+  private Set<Thread> mSharedHolders;\n+\n+  /** Scheduler that is used for interrupt-cycle. */\n+  private ScheduledExecutorService mScheduler;\n+  /** The future for the active interrupt cycle */\n+  private ScheduledFuture<?> mInterrupterFuture;\n+\n+  /** Whether state-lock manager is in safe-mode. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e248a260c674452ccdc7bfad1c202df47033c27"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI1NTAxOQ==", "bodyText": "Will this message be propagated to clients? If so, can this be more actionable, and/or informative?", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r438255019", "createdAt": "2020-06-10T16:26:17Z", "author": {"login": "gpang"}, "path": "core/server/common/src/main/java/alluxio/master/StateLockManager.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master;\n+\n+import alluxio.collections.ConcurrentHashSet;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.exception.ExceptionMessage;\n+import alluxio.resource.LockResource;\n+import alluxio.util.ThreadFactoryUtils;\n+\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+/**\n+ * Provides graceful and interruptable locking protocol for taking the state lock.\n+ *\n+ * {@link #lockShared()} will be used by user RPCs and may throw {@link InterruptedException}\n+ * based on options passed to {@link #lockExclusive(StateLockOptions)}.\n+ *\n+ * {@link #lockExclusive(StateLockOptions)} will be used by metadata backups in order to\n+ * guarantee paused state during critical tasks.\n+ */\n+public class StateLockManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(StateLockManager.class);\n+\n+  /** The state-lock */\n+  private ReadWriteLock mStateLock = new ReentrantReadWriteLock(true);\n+\n+  /** The set of threads that are waiting for state-lock in shared mode. */\n+  private Set<Thread> mSharedWaiters;\n+  /** The set of threads that are holding the state-lock in shared mode. */\n+  private Set<Thread> mSharedHolders;\n+\n+  /** Scheduler that is used for interrupt-cycle. */\n+  private ScheduledExecutorService mScheduler;\n+  /** The future for the active interrupt cycle */\n+  private ScheduledFuture<?> mInterrupterFuture;\n+\n+  /** Whether state-lock manager is in safe-mode. */\n+  private boolean mSafeMode;\n+\n+  /**\n+   * Creates a new state-lock manager.\n+   */\n+  public StateLockManager() {\n+    mSharedWaiters = new ConcurrentHashSet<>();\n+    mSharedHolders = new ConcurrentHashSet<>();\n+\n+    mScheduler = Executors\n+        .newSingleThreadScheduledExecutor(ThreadFactoryUtils.build(\"state-lock-manager-%d\", true));\n+\n+    mSafeMode = ServerConfiguration.getBoolean(PropertyKey.MASTER_BACKUP_STATE_LOCK_SAFE_MODE);\n+  }\n+\n+  /**\n+   * Locks the state shared.\n+   *\n+   * @return the lock resource\n+   * @throws InterruptedException\n+   */\n+  public LockResource lockShared() throws InterruptedException {\n+    // Do not allow taking shared lock during safe-mode.\n+    if (mSafeMode) {\n+      throw new IllegalStateException(\"Cannot acquire lock shared during safe-mode.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e248a260c674452ccdc7bfad1c202df47033c27"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI1NzEzMw==", "bodyText": "What is the contract for all the threads this set? Clearly we cannot track this perfectly, so will that be a problem? Some threads in the set will not be waiting for the lock yet.", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r438257133", "createdAt": "2020-06-10T16:29:41Z", "author": {"login": "gpang"}, "path": "core/server/common/src/main/java/alluxio/master/StateLockManager.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master;\n+\n+import alluxio.collections.ConcurrentHashSet;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.exception.ExceptionMessage;\n+import alluxio.resource.LockResource;\n+import alluxio.util.ThreadFactoryUtils;\n+\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+/**\n+ * Provides graceful and interruptable locking protocol for taking the state lock.\n+ *\n+ * {@link #lockShared()} will be used by user RPCs and may throw {@link InterruptedException}\n+ * based on options passed to {@link #lockExclusive(StateLockOptions)}.\n+ *\n+ * {@link #lockExclusive(StateLockOptions)} will be used by metadata backups in order to\n+ * guarantee paused state during critical tasks.\n+ */\n+public class StateLockManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(StateLockManager.class);\n+\n+  /** The state-lock */\n+  private ReadWriteLock mStateLock = new ReentrantReadWriteLock(true);\n+\n+  /** The set of threads that are waiting for state-lock in shared mode. */\n+  private Set<Thread> mSharedWaiters;\n+  /** The set of threads that are holding the state-lock in shared mode. */\n+  private Set<Thread> mSharedHolders;\n+\n+  /** Scheduler that is used for interrupt-cycle. */\n+  private ScheduledExecutorService mScheduler;\n+  /** The future for the active interrupt cycle */\n+  private ScheduledFuture<?> mInterrupterFuture;\n+\n+  /** Whether state-lock manager is in safe-mode. */\n+  private boolean mSafeMode;\n+\n+  /**\n+   * Creates a new state-lock manager.\n+   */\n+  public StateLockManager() {\n+    mSharedWaiters = new ConcurrentHashSet<>();\n+    mSharedHolders = new ConcurrentHashSet<>();\n+\n+    mScheduler = Executors\n+        .newSingleThreadScheduledExecutor(ThreadFactoryUtils.build(\"state-lock-manager-%d\", true));\n+\n+    mSafeMode = ServerConfiguration.getBoolean(PropertyKey.MASTER_BACKUP_STATE_LOCK_SAFE_MODE);\n+  }\n+\n+  /**\n+   * Locks the state shared.\n+   *\n+   * @return the lock resource\n+   * @throws InterruptedException\n+   */\n+  public LockResource lockShared() throws InterruptedException {\n+    // Do not allow taking shared lock during safe-mode.\n+    if (mSafeMode) {\n+      throw new IllegalStateException(\"Cannot acquire lock shared during safe-mode.\");\n+    }\n+    try {\n+      // Register as waiter.\n+      mSharedWaiters.add(Thread.currentThread());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e248a260c674452ccdc7bfad1c202df47033c27"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI1NzYyMQ==", "bodyText": "What is the contract for all the threads this set? Clearly we cannot track this perfectly, so will that be a problem? Some actual lock holders will not be in the holder set yet.\nAlso, there is a point in time that a thread is not in either set. What are the implications of that?\nBasically, since we cannot track the lock holders and waiters in a perfectly consistent way, which inconsistencies are we able to handle?", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r438257621", "createdAt": "2020-06-10T16:30:29Z", "author": {"login": "gpang"}, "path": "core/server/common/src/main/java/alluxio/master/StateLockManager.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master;\n+\n+import alluxio.collections.ConcurrentHashSet;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.exception.ExceptionMessage;\n+import alluxio.resource.LockResource;\n+import alluxio.util.ThreadFactoryUtils;\n+\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+/**\n+ * Provides graceful and interruptable locking protocol for taking the state lock.\n+ *\n+ * {@link #lockShared()} will be used by user RPCs and may throw {@link InterruptedException}\n+ * based on options passed to {@link #lockExclusive(StateLockOptions)}.\n+ *\n+ * {@link #lockExclusive(StateLockOptions)} will be used by metadata backups in order to\n+ * guarantee paused state during critical tasks.\n+ */\n+public class StateLockManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(StateLockManager.class);\n+\n+  /** The state-lock */\n+  private ReadWriteLock mStateLock = new ReentrantReadWriteLock(true);\n+\n+  /** The set of threads that are waiting for state-lock in shared mode. */\n+  private Set<Thread> mSharedWaiters;\n+  /** The set of threads that are holding the state-lock in shared mode. */\n+  private Set<Thread> mSharedHolders;\n+\n+  /** Scheduler that is used for interrupt-cycle. */\n+  private ScheduledExecutorService mScheduler;\n+  /** The future for the active interrupt cycle */\n+  private ScheduledFuture<?> mInterrupterFuture;\n+\n+  /** Whether state-lock manager is in safe-mode. */\n+  private boolean mSafeMode;\n+\n+  /**\n+   * Creates a new state-lock manager.\n+   */\n+  public StateLockManager() {\n+    mSharedWaiters = new ConcurrentHashSet<>();\n+    mSharedHolders = new ConcurrentHashSet<>();\n+\n+    mScheduler = Executors\n+        .newSingleThreadScheduledExecutor(ThreadFactoryUtils.build(\"state-lock-manager-%d\", true));\n+\n+    mSafeMode = ServerConfiguration.getBoolean(PropertyKey.MASTER_BACKUP_STATE_LOCK_SAFE_MODE);\n+  }\n+\n+  /**\n+   * Locks the state shared.\n+   *\n+   * @return the lock resource\n+   * @throws InterruptedException\n+   */\n+  public LockResource lockShared() throws InterruptedException {\n+    // Do not allow taking shared lock during safe-mode.\n+    if (mSafeMode) {\n+      throw new IllegalStateException(\"Cannot acquire lock shared during safe-mode.\");\n+    }\n+    try {\n+      // Register as waiter.\n+      mSharedWaiters.add(Thread.currentThread());\n+      // Grab the lock interruptibly.\n+      mStateLock.readLock().lockInterruptibly();\n+    } finally {\n+      // Remove itself from waiters.\n+      mSharedWaiters.remove(Thread.currentThread());\n+    }\n+    // Register as holder.\n+    mSharedHolders.add(Thread.currentThread());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e248a260c674452ccdc7bfad1c202df47033c27"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI2MDI4Mg==", "bodyText": "Is this supposed to be shell?", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r438260282", "createdAt": "2020-06-10T16:34:43Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/master/backup/BackupLeaderRole.java", "diffHunk": "@@ -98,10 +100,10 @@\n   public BackupLeaderRole(CoreMasterContext masterContext) {\n     super(masterContext);\n     LOG.info(\"Creating backup-leader role.\");\n-    // Store state lock for pausing state change when necessary.\n-    mStatePauseLock = masterContext.pauseStateLock();\n+    // Store state lock manager pausing state change when necessary.\n+    mStateLockManager = masterContext.getStateLockManager();\n     // Read properties.\n-    mStateLockTimeout = ServerConfiguration.getMs(PropertyKey.MASTER_BACKUP_STATE_LOCK_TIMEOUT);\n+    mStateLockTimeout = ServerConfiguration.getMs(PropertyKey.MASTER_SHELL_BACKUP_STATE_LOCK_TIMEOUT);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e248a260c674452ccdc7bfad1c202df47033c27"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI2MTA5NA==", "bodyText": "Can we have more information in this message?", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r438261094", "createdAt": "2020-06-10T16:35:58Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/master/meta/DefaultMetaMaster.java", "diffHunk": "@@ -382,11 +370,14 @@ public BackupStatus getBackupStatus(BackupStatusPRequest statusPRequest) throws\n \n   @Override\n   public String checkpoint() throws IOException {\n-    try (LockResource lr = new LockResource(mMasterContext.pauseStateLock())) {\n+    try (LockResource lr =\n+        mMasterContext.getStateLockManager().lockExclusive(StateLockOptions.defaults())) {\n       mJournalSystem.checkpoint();\n+      return NetworkAddressUtils.getConnectHost(NetworkAddressUtils.ServiceType.MASTER_RPC,\n+          ServerConfiguration.global());\n+    } catch (Exception e) {\n+      throw new IOException(\"Failed to take a checkpoint\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e248a260c674452ccdc7bfad1c202df47033c27"}, "originalPosition": 45}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI4NDk0MDU2", "url": "https://github.com/Alluxio/alluxio/pull/11535#pullrequestreview-428494056", "createdAt": "2020-06-10T23:24:40Z", "commit": {"oid": "f1448e8416bad07da0b959a416f08a31f6fe2fd4"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMzoyNDo0MFrOGiJfTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMzozNDozNVrOGiJqxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ2MDIzNw==", "bodyText": "does safemode never get reset? That means the master can ONLY take a backup and never service clients, even when it is primary?", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r438460237", "createdAt": "2020-06-10T23:24:40Z", "author": {"login": "gpang"}, "path": "core/server/common/src/main/java/alluxio/master/StateLockManager.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master;\n+\n+import alluxio.collections.ConcurrentHashSet;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.exception.ExceptionMessage;\n+import alluxio.resource.LockResource;\n+import alluxio.util.ThreadFactoryUtils;\n+\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+/**\n+ * Provides graceful and interruptable locking protocol for taking the state lock.\n+ *\n+ * {@link #lockShared()} will be used by user RPCs and may throw {@link InterruptedException}\n+ * based on options passed to {@link #lockExclusive(StateLockOptions)}.\n+ *\n+ * {@link #lockExclusive(StateLockOptions)} will be used by metadata backups in order to\n+ * guarantee paused state during critical tasks.\n+ */\n+public class StateLockManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(StateLockManager.class);\n+\n+  /** The state-lock */\n+  private ReadWriteLock mStateLock = new ReentrantReadWriteLock(true);\n+\n+  /** The set of threads that are waiting for state-lock in shared mode. */\n+  private Set<Thread> mSharedWaiters;\n+  /** The set of threads that are holding the state-lock in shared mode. */\n+  private Set<Thread> mSharedHolders;\n+\n+  /** Scheduler that is used for interrupt-cycle. */\n+  private ScheduledExecutorService mScheduler;\n+  /** The future for the active interrupt cycle */\n+  private ScheduledFuture<?> mInterrupterFuture;\n+\n+  /** Whether state-lock manager is in safe-mode. */\n+  private boolean mSafeMode;\n+\n+  /**\n+   * Creates a new state-lock manager.\n+   */\n+  public StateLockManager() {\n+    mSharedWaiters = new ConcurrentHashSet<>();\n+    mSharedHolders = new ConcurrentHashSet<>();\n+\n+    mScheduler = Executors\n+        .newSingleThreadScheduledExecutor(ThreadFactoryUtils.build(\"state-lock-manager-%d\", true));\n+\n+    mSafeMode = ServerConfiguration.getBoolean(PropertyKey.MASTER_BACKUP_STATE_LOCK_SAFE_MODE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1448e8416bad07da0b959a416f08a31f6fe2fd4"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ2MzE3NQ==", "bodyText": "hrmmm, this seems tricky and hard to guarantee correct behavior...", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r438463175", "createdAt": "2020-06-10T23:34:35Z", "author": {"login": "gpang"}, "path": "core/server/common/src/main/java/alluxio/master/StateLockManager.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master;\n+\n+import alluxio.collections.ConcurrentHashSet;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.exception.ExceptionMessage;\n+import alluxio.resource.LockResource;\n+import alluxio.util.ThreadFactoryUtils;\n+\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+/**\n+ * Provides graceful and interruptable locking protocol for taking the state lock.\n+ *\n+ * {@link #lockShared()} will be used by user RPCs and may throw {@link InterruptedException}\n+ * based on options passed to {@link #lockExclusive(StateLockOptions)}.\n+ *\n+ * {@link #lockExclusive(StateLockOptions)} will be used by metadata backups in order to\n+ * guarantee paused state during critical tasks.\n+ */\n+public class StateLockManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(StateLockManager.class);\n+\n+  /** The state-lock */\n+  private ReadWriteLock mStateLock = new ReentrantReadWriteLock(true);\n+\n+  /** The set of threads that are waiting for state-lock in shared mode. */\n+  private Set<Thread> mSharedWaiters;\n+  /** The set of threads that are holding the state-lock in shared mode. */\n+  private Set<Thread> mSharedHolders;\n+\n+  /** Scheduler that is used for interrupt-cycle. */\n+  private ScheduledExecutorService mScheduler;\n+  /** The future for the active interrupt cycle */\n+  private ScheduledFuture<?> mInterrupterFuture;\n+\n+  /** Whether state-lock manager is in safe-mode. */\n+  private boolean mSafeMode;\n+\n+  /**\n+   * Creates a new state-lock manager.\n+   */\n+  public StateLockManager() {\n+    mSharedWaiters = new ConcurrentHashSet<>();\n+    mSharedHolders = new ConcurrentHashSet<>();\n+\n+    mScheduler = Executors\n+        .newSingleThreadScheduledExecutor(ThreadFactoryUtils.build(\"state-lock-manager-%d\", true));\n+\n+    mSafeMode = ServerConfiguration.getBoolean(PropertyKey.MASTER_BACKUP_STATE_LOCK_SAFE_MODE);\n+  }\n+\n+  /**\n+   * Locks the state shared.\n+   *\n+   * @return the lock resource\n+   * @throws InterruptedException\n+   */\n+  public LockResource lockShared() throws InterruptedException {\n+    // Do not allow taking shared lock during safe-mode.\n+    if (mSafeMode) {\n+      throw new IllegalStateException(\"Cannot acquire lock shared during safe-mode.\");\n+    }\n+    try {\n+      // Register as waiter.\n+      mSharedWaiters.add(Thread.currentThread());\n+      // Grab the lock interruptibly.\n+      mStateLock.readLock().lockInterruptibly();\n+    } finally {\n+      // Remove itself from waiters.\n+      mSharedWaiters.remove(Thread.currentThread());\n+    }\n+    // Register as holder.\n+    mSharedHolders.add(Thread.currentThread());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI1NzYyMQ=="}, "originalCommit": {"oid": "5e248a260c674452ccdc7bfad1c202df47033c27"}, "originalPosition": 96}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI5MzQ0NTQx", "url": "https://github.com/Alluxio/alluxio/pull/11535#pullrequestreview-429344541", "createdAt": "2020-06-11T22:48:57Z", "commit": {"oid": "b0550f44dfad36238ad1210eee202232e1c02396"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQyMjo0ODo1N1rOGixS0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQyMjo1MTozNlrOGixWHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTExMjQwMQ==", "bodyText": "This could block for a long time, and thus block other RPCs (including heartbeats) for a long time?", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r439112401", "createdAt": "2020-06-11T22:48:57Z", "author": {"login": "gpang"}, "path": "core/server/common/src/main/java/alluxio/master/StateLockManager.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master;\n+\n+import alluxio.collections.ConcurrentHashSet;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.exception.ExceptionMessage;\n+import alluxio.resource.LockResource;\n+import alluxio.util.ThreadFactoryUtils;\n+\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+/**\n+ * Provides graceful and interruptable locking protocol for taking the state lock.\n+ *\n+ * {@link #lockShared()} will be used by user RPCs and may throw {@link InterruptedException}\n+ * based on options passed to {@link #lockExclusive(StateLockOptions)}.\n+ *\n+ * {@link #lockExclusive(StateLockOptions)} will be used by metadata backups in order to\n+ * guarantee paused state during critical tasks.\n+ */\n+public class StateLockManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(StateLockManager.class);\n+\n+  /** The state-lock */\n+  private ReadWriteLock mStateLock = new ReentrantReadWriteLock(true);\n+\n+  /** The set of threads that are waiting for or holding the state-lock in shared mode. */\n+  private Set<Thread> mSharedWaitersAndHolders;\n+\n+  /** Scheduler that is used for interrupt-cycle. */\n+  private ScheduledExecutorService mScheduler;\n+  /** The future for the active interrupt cycle */\n+  private ScheduledFuture<?> mInterrupterFuture;\n+\n+  /** Whether state-lock manager is in safe-mode. */\n+  private boolean mSafeMode;\n+\n+  /**\n+   * Creates a new state-lock manager.\n+   */\n+  public StateLockManager() {\n+    mSharedWaitersAndHolders = new ConcurrentHashSet<>();\n+\n+    mScheduler = Executors\n+        .newSingleThreadScheduledExecutor(ThreadFactoryUtils.build(\"state-lock-manager-%d\", true));\n+\n+    mSafeMode = ServerConfiguration.getBoolean(PropertyKey.MASTER_BACKUP_STATE_LOCK_SAFE_MODE);\n+  }\n+\n+  /**\n+   * Locks the state shared.\n+   *\n+   * Calling thread might be interrupted by this manager,\n+   * if it found to be waiting for the shared lock under when:\n+   *  - backup is exiting grace-cycle and entering the lock permanently\n+   *  - backup is in progress\n+   *\n+   * @return the lock resource\n+   * @throws InterruptedException\n+   */\n+  public LockResource lockShared() throws InterruptedException {\n+    // Do not allow taking shared lock during safe-mode.\n+    if (mSafeMode) {\n+      String safeModeMsg = String.format(\n+          \"Cannot acquire lock shared during backup safe-mode. \"\n+              + \"Please configure %s as 'false' in order to disable the backup safe-mode.\",\n+          PropertyKey.Name.MASTER_BACKUP_STATE_LOCK_SAFE_MODE);\n+      throw new IllegalStateException(safeModeMsg);\n+    }\n+    // Register thread for interrupt cycle.\n+    mSharedWaitersAndHolders.add(Thread.currentThread());\n+    // Grab the lock interruptibly.\n+    mStateLock.readLock().lockInterruptibly();\n+    // Return the resource.\n+    // Register an action to remove the thread from holders registry before releasing the lock.\n+    return new LockResource(mStateLock.readLock(), false, false, () -> {\n+      mSharedWaitersAndHolders.remove(Thread.currentThread());\n+    });\n+  }\n+\n+  /**\n+   * Locks the state exclusively.\n+   *\n+   * @param lockOptions exclusive lock options\n+   * @return the lock resource\n+   * @throws TimeoutException if locking times out\n+   * @throws InterruptedException if interrupting during locking\n+   */\n+  public LockResource lockExclusive(StateLockOptions lockOptions)\n+      throws TimeoutException, InterruptedException {\n+    // Run the grace cycle.\n+    boolean lockAcquired = false;\n+    if (lockOptions.waitGraceCycle()) {\n+      long deadlineMs = System.currentTimeMillis() + lockOptions.getGraceCycleTimeoutMs();\n+      while (System.currentTimeMillis() < deadlineMs) {\n+        if (mStateLock.writeLock().tryLock(lockOptions.getGraceCycleTryMs(), TimeUnit.MILLISECONDS)) {\n+          lockAcquired = true;\n+          break;\n+        } else {\n+          long remainingWaitMs = deadlineMs - System.currentTimeMillis();\n+          if (remainingWaitMs > 0) {\n+            Thread.sleep(Math.min(lockOptions.getGraceCycleSleepMs(), remainingWaitMs));\n+          }\n+        }\n+      }\n+    }\n+    if (lockAcquired) { // Lock was acquired within grace-cycle.\n+      scheduleInterruptCycle(lockOptions.getInterruptWaitersInternalMs());\n+    } else { // Lock couldn't be acquired by grace-cycle.\n+      if (!lockOptions.lockAfterGraceCycle()) {\n+        throw new TimeoutException(\n+                ExceptionMessage.STATE_LOCK_TIMED_OUT.getMessage(lockOptions.getGraceCycleTimeoutMs()));\n+      }\n+      if (lockOptions.interruptCycleAfterGraceCycle()) {\n+        // Schedule interrupt cycle before entering the lock because it might wait in the queue.\n+        scheduleInterruptCycle(lockOptions.getInterruptWaitersInternalMs());\n+      }\n+      // Own the lock.\n+      mStateLock.writeLock().lock();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0550f44dfad36238ad1210eee202232e1c02396"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTExMjk4OQ==", "bodyText": "Is there any danger that this mInterrupterFuture points to a different future than the one that was started?", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r439112989", "createdAt": "2020-06-11T22:50:45Z", "author": {"login": "gpang"}, "path": "core/server/common/src/main/java/alluxio/master/StateLockManager.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master;\n+\n+import alluxio.collections.ConcurrentHashSet;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.exception.ExceptionMessage;\n+import alluxio.resource.LockResource;\n+import alluxio.util.ThreadFactoryUtils;\n+\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+/**\n+ * Provides graceful and interruptable locking protocol for taking the state lock.\n+ *\n+ * {@link #lockShared()} will be used by user RPCs and may throw {@link InterruptedException}\n+ * based on options passed to {@link #lockExclusive(StateLockOptions)}.\n+ *\n+ * {@link #lockExclusive(StateLockOptions)} will be used by metadata backups in order to\n+ * guarantee paused state during critical tasks.\n+ */\n+public class StateLockManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(StateLockManager.class);\n+\n+  /** The state-lock */\n+  private ReadWriteLock mStateLock = new ReentrantReadWriteLock(true);\n+\n+  /** The set of threads that are waiting for or holding the state-lock in shared mode. */\n+  private Set<Thread> mSharedWaitersAndHolders;\n+\n+  /** Scheduler that is used for interrupt-cycle. */\n+  private ScheduledExecutorService mScheduler;\n+  /** The future for the active interrupt cycle */\n+  private ScheduledFuture<?> mInterrupterFuture;\n+\n+  /** Whether state-lock manager is in safe-mode. */\n+  private boolean mSafeMode;\n+\n+  /**\n+   * Creates a new state-lock manager.\n+   */\n+  public StateLockManager() {\n+    mSharedWaitersAndHolders = new ConcurrentHashSet<>();\n+\n+    mScheduler = Executors\n+        .newSingleThreadScheduledExecutor(ThreadFactoryUtils.build(\"state-lock-manager-%d\", true));\n+\n+    mSafeMode = ServerConfiguration.getBoolean(PropertyKey.MASTER_BACKUP_STATE_LOCK_SAFE_MODE);\n+  }\n+\n+  /**\n+   * Locks the state shared.\n+   *\n+   * Calling thread might be interrupted by this manager,\n+   * if it found to be waiting for the shared lock under when:\n+   *  - backup is exiting grace-cycle and entering the lock permanently\n+   *  - backup is in progress\n+   *\n+   * @return the lock resource\n+   * @throws InterruptedException\n+   */\n+  public LockResource lockShared() throws InterruptedException {\n+    // Do not allow taking shared lock during safe-mode.\n+    if (mSafeMode) {\n+      String safeModeMsg = String.format(\n+          \"Cannot acquire lock shared during backup safe-mode. \"\n+              + \"Please configure %s as 'false' in order to disable the backup safe-mode.\",\n+          PropertyKey.Name.MASTER_BACKUP_STATE_LOCK_SAFE_MODE);\n+      throw new IllegalStateException(safeModeMsg);\n+    }\n+    // Register thread for interrupt cycle.\n+    mSharedWaitersAndHolders.add(Thread.currentThread());\n+    // Grab the lock interruptibly.\n+    mStateLock.readLock().lockInterruptibly();\n+    // Return the resource.\n+    // Register an action to remove the thread from holders registry before releasing the lock.\n+    return new LockResource(mStateLock.readLock(), false, false, () -> {\n+      mSharedWaitersAndHolders.remove(Thread.currentThread());\n+    });\n+  }\n+\n+  /**\n+   * Locks the state exclusively.\n+   *\n+   * @param lockOptions exclusive lock options\n+   * @return the lock resource\n+   * @throws TimeoutException if locking times out\n+   * @throws InterruptedException if interrupting during locking\n+   */\n+  public LockResource lockExclusive(StateLockOptions lockOptions)\n+      throws TimeoutException, InterruptedException {\n+    // Run the grace cycle.\n+    boolean lockAcquired = false;\n+    if (lockOptions.waitGraceCycle()) {\n+      long deadlineMs = System.currentTimeMillis() + lockOptions.getGraceCycleTimeoutMs();\n+      while (System.currentTimeMillis() < deadlineMs) {\n+        if (mStateLock.writeLock().tryLock(lockOptions.getGraceCycleTryMs(), TimeUnit.MILLISECONDS)) {\n+          lockAcquired = true;\n+          break;\n+        } else {\n+          long remainingWaitMs = deadlineMs - System.currentTimeMillis();\n+          if (remainingWaitMs > 0) {\n+            Thread.sleep(Math.min(lockOptions.getGraceCycleSleepMs(), remainingWaitMs));\n+          }\n+        }\n+      }\n+    }\n+    if (lockAcquired) { // Lock was acquired within grace-cycle.\n+      scheduleInterruptCycle(lockOptions.getInterruptWaitersInternalMs());\n+    } else { // Lock couldn't be acquired by grace-cycle.\n+      if (!lockOptions.lockAfterGraceCycle()) {\n+        throw new TimeoutException(\n+                ExceptionMessage.STATE_LOCK_TIMED_OUT.getMessage(lockOptions.getGraceCycleTimeoutMs()));\n+      }\n+      if (lockOptions.interruptCycleAfterGraceCycle()) {\n+        // Schedule interrupt cycle before entering the lock because it might wait in the queue.\n+        scheduleInterruptCycle(lockOptions.getInterruptWaitersInternalMs());\n+      }\n+      // Own the lock.\n+      mStateLock.writeLock().lock();\n+    }\n+\n+    // We have the lock, wrap it and return.\n+    // Register an action for cancelling the interrupt cycle before releasing the lock.\n+    return new LockResource(mStateLock.writeLock(), false, false, () -> {\n+      // Before releasing the write-lock, deactivate interrupter if active.\n+      if (mInterrupterFuture != null && !mInterrupterFuture.isDone()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0550f44dfad36238ad1210eee202232e1c02396"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTExMzI0Ng==", "bodyText": "I don't know how this should be used by users.", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r439113246", "createdAt": "2020-06-11T22:51:36Z", "author": {"login": "gpang"}, "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "diffHunk": "@@ -1296,6 +1296,13 @@ public String toString() {\n           .setConsistencyCheckLevel(ConsistencyCheckLevel.IGNORE)\n           .setScope(Scope.MASTER)\n           .build();\n+  public static final PropertyKey MASTER_BACKUP_STATE_LOCK_SAFE_MODE =\n+      new Builder(Name.MASTER_BACKUP_STATE_LOCK_SAFE_MODE)\n+          .setDefaultValue(false)\n+          .setDescription(\"Ignores client state-lock requests for backup to always take the lock.\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0550f44dfad36238ad1210eee202232e1c02396"}, "originalPosition": 7}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b0550f44dfad36238ad1210eee202232e1c02396", "author": {"user": {"login": "ggezer", "name": "G\u00f6kt\u00fcrk Gezer"}}, "url": "https://github.com/Alluxio/alluxio/commit/b0550f44dfad36238ad1210eee202232e1c02396", "committedDate": "2020-06-11T07:41:52Z", "message": "Property refactor"}, "afterCommit": {"oid": "f7bb22b60722c34eddc983adb69c52dbef8ced8c", "author": {"user": {"login": "ggezer", "name": "G\u00f6kt\u00fcrk Gezer"}}, "url": "https://github.com/Alluxio/alluxio/commit/f7bb22b60722c34eddc983adb69c52dbef8ced8c", "committedDate": "2020-06-12T18:43:29Z", "message": "Implement interrupt based locking protocol over state-lock"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "aa6b0362b333c11a921bbafb2b245a09ee6fa062", "author": {"user": {"login": "ggezer", "name": "G\u00f6kt\u00fcrk Gezer"}}, "url": "https://github.com/Alluxio/alluxio/commit/aa6b0362b333c11a921bbafb2b245a09ee6fa062", "committedDate": "2020-06-12T21:30:28Z", "message": "Make safe-mode self resetting"}, "afterCommit": {"oid": "6c5f9387aa07165072123451c226a506636b3701", "author": {"user": {"login": "ggezer", "name": "G\u00f6kt\u00fcrk Gezer"}}, "url": "https://github.com/Alluxio/alluxio/commit/6c5f9387aa07165072123451c226a506636b3701", "committedDate": "2020-06-12T22:00:17Z", "message": "Implement interrupt based locking protocol over state-lock"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6c5f9387aa07165072123451c226a506636b3701", "author": {"user": {"login": "ggezer", "name": "G\u00f6kt\u00fcrk Gezer"}}, "url": "https://github.com/Alluxio/alluxio/commit/6c5f9387aa07165072123451c226a506636b3701", "committedDate": "2020-06-12T22:00:17Z", "message": "Implement interrupt based locking protocol over state-lock"}, "afterCommit": {"oid": "02b7f612ff46a4e250127a9ebf1efeb334ec6465", "author": {"user": {"login": "ggezer", "name": "G\u00f6kt\u00fcrk Gezer"}}, "url": "https://github.com/Alluxio/alluxio/commit/02b7f612ff46a4e250127a9ebf1efeb334ec6465", "committedDate": "2020-06-12T22:06:41Z", "message": "Implement interrupt based locking protocol over state-lock"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "942701b545fbda91810654b814e7436b40172ff3", "author": {"user": {"login": "ggezer", "name": "G\u00f6kt\u00fcrk Gezer"}}, "url": "https://github.com/Alluxio/alluxio/commit/942701b545fbda91810654b814e7436b40172ff3", "committedDate": "2020-06-12T22:52:56Z", "message": "Implement interrupt based locking protocol over state-lock"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "02b7f612ff46a4e250127a9ebf1efeb334ec6465", "author": {"user": {"login": "ggezer", "name": "G\u00f6kt\u00fcrk Gezer"}}, "url": "https://github.com/Alluxio/alluxio/commit/02b7f612ff46a4e250127a9ebf1efeb334ec6465", "committedDate": "2020-06-12T22:06:41Z", "message": "Implement interrupt based locking protocol over state-lock"}, "afterCommit": {"oid": "942701b545fbda91810654b814e7436b40172ff3", "author": {"user": {"login": "ggezer", "name": "G\u00f6kt\u00fcrk Gezer"}}, "url": "https://github.com/Alluxio/alluxio/commit/942701b545fbda91810654b814e7436b40172ff3", "committedDate": "2020-06-12T22:52:56Z", "message": "Implement interrupt based locking protocol over state-lock"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9a6517d86e54ddb6d3aea12e86429dc26cab3e2b", "author": {"user": {"login": "ggezer", "name": "G\u00f6kt\u00fcrk Gezer"}}, "url": "https://github.com/Alluxio/alluxio/commit/9a6517d86e54ddb6d3aea12e86429dc26cab3e2b", "committedDate": "2020-06-15T20:22:00Z", "message": "Reduce grace modes to TIMEOUT/FORCED"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2f1276491e39a7fdd110881a8d3f8407355b921d", "author": {"user": {"login": "ggezer", "name": "G\u00f6kt\u00fcrk Gezer"}}, "url": "https://github.com/Alluxio/alluxio/commit/2f1276491e39a7fdd110881a8d3f8407355b921d", "committedDate": "2020-06-15T20:27:45Z", "message": "Make guaranteed mode bound to life-cycle of master"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9203ceab6a25f945fbfccf87a107784003aba9eb", "author": {"user": {"login": "ggezer", "name": "G\u00f6kt\u00fcrk Gezer"}}, "url": "https://github.com/Alluxio/alluxio/commit/9203ceab6a25f945fbfccf87a107784003aba9eb", "committedDate": "2020-06-15T20:31:41Z", "message": "Test fixes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxMDEyMjEz", "url": "https://github.com/Alluxio/alluxio/pull/11535#pullrequestreview-431012213", "createdAt": "2020-06-15T21:38:48Z", "commit": {"oid": "9203ceab6a25f945fbfccf87a107784003aba9eb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQyMTozODo0OVrOGkDqYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQyMTozODo0OVrOGkDqYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ2MTkyMQ==", "bodyText": "Will it be easy to search for log message, where will this be logged?", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r440461921", "createdAt": "2020-06-15T21:38:49Z", "author": {"login": "calvinjia"}, "path": "core/server/common/src/main/java/alluxio/master/StateLockManager.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master;\n+\n+import alluxio.collections.ConcurrentHashSet;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.exception.ExceptionMessage;\n+import alluxio.resource.LockResource;\n+import alluxio.util.ThreadFactoryUtils;\n+\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+/**\n+ * Provides graceful and interruptable locking protocol for taking the state lock.\n+ *\n+ * {@link #lockShared()} will be used by user RPCs and may throw {@link InterruptedException}\n+ * based on options passed to {@link #lockExclusive(StateLockOptions)}.\n+ *\n+ * {@link #lockExclusive(StateLockOptions)} will be used by metadata backups in order to\n+ * guarantee paused state during critical tasks.\n+ */\n+public class StateLockManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(StateLockManager.class);\n+\n+  /** The state-lock. */\n+  private ReadWriteLock mStateLock = new ReentrantReadWriteLock(true);\n+\n+  /** The set of threads that are waiting for or holding the state-lock in shared mode. */\n+  private Set<Thread> mSharedWaitersAndHolders;\n+  /** Scheduler that is used for interrupt-cycle. */\n+  private ScheduledExecutorService mScheduler;\n+\n+  /** Whether exclusive locking will trigger interrupt-cycle. */\n+  private boolean mInterruptCycleEnabled;\n+  /** Interval at which threads around shared-lock will be interrupted during interrupt-cycle. */\n+  private long mInterruptCycleInterval;\n+  /** Used to synchronize execution/termination of interrupt-cycle. */\n+  private Lock mInterruptCycleLock = new ReentrantLock(true);\n+  /** How many active exclusive locking attempts. */\n+  private volatile long mInterruptCycleRefCount = 0;\n+  /** The future for the active interrupt cycle. */\n+  private ScheduledFuture<?> mInterrupterFuture;\n+\n+  /** This is the deadline for forcing the lock. */\n+  private long mForcedDurationMs;\n+\n+  // TODO(ggezer): Make it bound to a process start/stop cycle.\n+  /** Shared locking requests will fail until this time. */\n+  private long mExclusiveOnlyDeadlineMs = -1;\n+\n+  /**\n+   * Creates a new state-lock manager.\n+   */\n+  public StateLockManager() {\n+    mSharedWaitersAndHolders = new ConcurrentHashSet<>();\n+    // Init members.\n+    mScheduler = Executors\n+        .newSingleThreadScheduledExecutor(ThreadFactoryUtils.build(\"state-lock-manager-%d\", true));\n+    // Read properties.\n+    mInterruptCycleEnabled = ServerConfiguration\n+        .getBoolean(PropertyKey.MASTER_BACKUP_STATE_LOCK_INTERRUPT_CYCLE_ENABLED);\n+    mInterruptCycleInterval =\n+        ServerConfiguration.getMs(PropertyKey.MASTER_BACKUP_STATE_LOCK_INTERRUPT_CYCLE_INTERVAL);\n+    mForcedDurationMs =\n+        ServerConfiguration.getMs(PropertyKey.MASTER_BACKUP_STATE_LOCK_FORCED_DURATION);\n+    // Validate properties.\n+    Preconditions.checkArgument(mInterruptCycleInterval > 0,\n+        \"Interrupt-cycle interval should be greater than 0.\");\n+  }\n+\n+  /**\n+   * This is called by owning process in order to signal that\n+   * the state is read completely and masters are started.\n+   *\n+   * This triggers the beginning of exclusive-only maintenance mode for the state-lock.\n+   * Note: Calling it multiple times does not reset the maintenance window.\n+   */\n+  public void mastersStartedCallback() {\n+    if (mExclusiveOnlyDeadlineMs == -1) {\n+      mExclusiveOnlyDeadlineMs = System.currentTimeMillis()\n+          + ServerConfiguration.getMs(PropertyKey.MASTER_BACKUP_STATE_LOCK_EXCLUSIVE_DURATION);\n+    }\n+  }\n+\n+  /**\n+   * Locks the state shared.\n+   *\n+   * Calling thread might be interrupted by this manager,\n+   * if it found to be waiting for the shared lock under when:\n+   *  - backup is exiting grace-cycle and entering the lock permanently\n+   *  - backup is in progress\n+   *\n+   * @return the lock resource\n+   * @throws InterruptedException\n+   */\n+  public LockResource lockShared() throws InterruptedException {\n+    // Do not allow taking shared lock during safe-mode.\n+    if (System.currentTimeMillis() < mExclusiveOnlyDeadlineMs) {\n+      String safeModeMsg = String.format(\n+          \"Master still in exclusive-only phase for the state-lock.\"\n+              + \"Please see documentation for %s.\",\n+          PropertyKey.Name.MASTER_BACKUP_STATE_LOCK_EXCLUSIVE_DURATION);\n+      throw new IllegalStateException(safeModeMsg);\n+    }\n+    // Register thread for interrupt cycle.\n+    mSharedWaitersAndHolders.add(Thread.currentThread());\n+    // Grab the lock interruptibly.\n+    mStateLock.readLock().lockInterruptibly();\n+    // Return the resource.\n+    // Register an action to remove the thread from holders registry before releasing the lock.\n+    return new LockResource(mStateLock.readLock(), false, false, () -> {\n+      mSharedWaitersAndHolders.remove(Thread.currentThread());\n+    });\n+  }\n+\n+  /**\n+   * Locks the state exclusively.\n+   *\n+   * @param lockOptions exclusive lock options\n+   * @return the lock resource\n+   * @throws TimeoutException if locking times out\n+   * @throws InterruptedException if interrupting during locking\n+   */\n+  public LockResource lockExclusive(StateLockOptions lockOptions)\n+      throws TimeoutException, InterruptedException {\n+    // Run the grace cycle.\n+    StateLockOptions.GraceMode graceMode = lockOptions.getGraceMode();\n+    boolean lockAcquired = false;\n+    long deadlineMs = System.currentTimeMillis() + lockOptions.getGraceCycleTimeoutMs();\n+    while (System.currentTimeMillis() < deadlineMs) {\n+      if (mStateLock.writeLock().tryLock(lockOptions.getGraceCycleTryMs(), TimeUnit.MILLISECONDS)) {\n+        lockAcquired = true;\n+        break;\n+      } else {\n+        long remainingWaitMs = deadlineMs - System.currentTimeMillis();\n+        if (remainingWaitMs > 0) {\n+          Thread.sleep(Math.min(lockOptions.getGraceCycleSleepMs(), remainingWaitMs));\n+        }\n+      }\n+    }\n+    if (lockAcquired) { // Lock was acquired within grace-cycle.\n+      activateInterruptCycle();\n+    } else { // Lock couldn't be acquired by grace-cycle.\n+      if (graceMode == StateLockOptions.GraceMode.TIMEOUT) {\n+        throw new TimeoutException(\n+            ExceptionMessage.STATE_LOCK_TIMED_OUT.getMessage(lockOptions.getGraceCycleTimeoutMs()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9203ceab6a25f945fbfccf87a107784003aba9eb"}, "originalPosition": 169}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxMDEzMjY3", "url": "https://github.com/Alluxio/alluxio/pull/11535#pullrequestreview-431013267", "createdAt": "2020-06-15T21:40:49Z", "commit": {"oid": "9203ceab6a25f945fbfccf87a107784003aba9eb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQyMTo0MDo0OVrOGkDtxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQyMTo0MDo0OVrOGkDtxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ2Mjc4OQ==", "bodyText": "Would be helpful to state how much longer the deadline is", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r440462789", "createdAt": "2020-06-15T21:40:49Z", "author": {"login": "calvinjia"}, "path": "core/server/common/src/main/java/alluxio/master/StateLockManager.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master;\n+\n+import alluxio.collections.ConcurrentHashSet;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.exception.ExceptionMessage;\n+import alluxio.resource.LockResource;\n+import alluxio.util.ThreadFactoryUtils;\n+\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+/**\n+ * Provides graceful and interruptable locking protocol for taking the state lock.\n+ *\n+ * {@link #lockShared()} will be used by user RPCs and may throw {@link InterruptedException}\n+ * based on options passed to {@link #lockExclusive(StateLockOptions)}.\n+ *\n+ * {@link #lockExclusive(StateLockOptions)} will be used by metadata backups in order to\n+ * guarantee paused state during critical tasks.\n+ */\n+public class StateLockManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(StateLockManager.class);\n+\n+  /** The state-lock. */\n+  private ReadWriteLock mStateLock = new ReentrantReadWriteLock(true);\n+\n+  /** The set of threads that are waiting for or holding the state-lock in shared mode. */\n+  private Set<Thread> mSharedWaitersAndHolders;\n+  /** Scheduler that is used for interrupt-cycle. */\n+  private ScheduledExecutorService mScheduler;\n+\n+  /** Whether exclusive locking will trigger interrupt-cycle. */\n+  private boolean mInterruptCycleEnabled;\n+  /** Interval at which threads around shared-lock will be interrupted during interrupt-cycle. */\n+  private long mInterruptCycleInterval;\n+  /** Used to synchronize execution/termination of interrupt-cycle. */\n+  private Lock mInterruptCycleLock = new ReentrantLock(true);\n+  /** How many active exclusive locking attempts. */\n+  private volatile long mInterruptCycleRefCount = 0;\n+  /** The future for the active interrupt cycle. */\n+  private ScheduledFuture<?> mInterrupterFuture;\n+\n+  /** This is the deadline for forcing the lock. */\n+  private long mForcedDurationMs;\n+\n+  // TODO(ggezer): Make it bound to a process start/stop cycle.\n+  /** Shared locking requests will fail until this time. */\n+  private long mExclusiveOnlyDeadlineMs = -1;\n+\n+  /**\n+   * Creates a new state-lock manager.\n+   */\n+  public StateLockManager() {\n+    mSharedWaitersAndHolders = new ConcurrentHashSet<>();\n+    // Init members.\n+    mScheduler = Executors\n+        .newSingleThreadScheduledExecutor(ThreadFactoryUtils.build(\"state-lock-manager-%d\", true));\n+    // Read properties.\n+    mInterruptCycleEnabled = ServerConfiguration\n+        .getBoolean(PropertyKey.MASTER_BACKUP_STATE_LOCK_INTERRUPT_CYCLE_ENABLED);\n+    mInterruptCycleInterval =\n+        ServerConfiguration.getMs(PropertyKey.MASTER_BACKUP_STATE_LOCK_INTERRUPT_CYCLE_INTERVAL);\n+    mForcedDurationMs =\n+        ServerConfiguration.getMs(PropertyKey.MASTER_BACKUP_STATE_LOCK_FORCED_DURATION);\n+    // Validate properties.\n+    Preconditions.checkArgument(mInterruptCycleInterval > 0,\n+        \"Interrupt-cycle interval should be greater than 0.\");\n+  }\n+\n+  /**\n+   * This is called by owning process in order to signal that\n+   * the state is read completely and masters are started.\n+   *\n+   * This triggers the beginning of exclusive-only maintenance mode for the state-lock.\n+   * Note: Calling it multiple times does not reset the maintenance window.\n+   */\n+  public void mastersStartedCallback() {\n+    if (mExclusiveOnlyDeadlineMs == -1) {\n+      mExclusiveOnlyDeadlineMs = System.currentTimeMillis()\n+          + ServerConfiguration.getMs(PropertyKey.MASTER_BACKUP_STATE_LOCK_EXCLUSIVE_DURATION);\n+    }\n+  }\n+\n+  /**\n+   * Locks the state shared.\n+   *\n+   * Calling thread might be interrupted by this manager,\n+   * if it found to be waiting for the shared lock under when:\n+   *  - backup is exiting grace-cycle and entering the lock permanently\n+   *  - backup is in progress\n+   *\n+   * @return the lock resource\n+   * @throws InterruptedException\n+   */\n+  public LockResource lockShared() throws InterruptedException {\n+    // Do not allow taking shared lock during safe-mode.\n+    if (System.currentTimeMillis() < mExclusiveOnlyDeadlineMs) {\n+      String safeModeMsg = String.format(\n+          \"Master still in exclusive-only phase for the state-lock.\"\n+              + \"Please see documentation for %s.\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9203ceab6a25f945fbfccf87a107784003aba9eb"}, "originalPosition": 124}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxMDI2Nzgy", "url": "https://github.com/Alluxio/alluxio/pull/11535#pullrequestreview-431026782", "createdAt": "2020-06-15T22:07:09Z", "commit": {"oid": "9203ceab6a25f945fbfccf87a107784003aba9eb"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b8724736bbe4463dadc8920db951ab867fb3cd4f", "author": {"user": {"login": "ggezer", "name": "G\u00f6kt\u00fcrk Gezer"}}, "url": "https://github.com/Alluxio/alluxio/commit/b8724736bbe4463dadc8920db951ab867fb3cd4f", "committedDate": "2020-06-16T17:58:29Z", "message": "Add more traces for exclusive-only mode"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ffcb98861454fb7435673273bbf3b109dc8917d2", "author": {"user": {"login": "ggezer", "name": "G\u00f6kt\u00fcrk Gezer"}}, "url": "https://github.com/Alluxio/alluxio/commit/ffcb98861454fb7435673273bbf3b109dc8917d2", "committedDate": "2020-06-16T18:25:49Z", "message": "Add UT for exclusive-only phase"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxODA3MTQ4", "url": "https://github.com/Alluxio/alluxio/pull/11535#pullrequestreview-431807148", "createdAt": "2020-06-16T19:00:43Z", "commit": {"oid": "ffcb98861454fb7435673273bbf3b109dc8917d2"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxOTowMDo0M1rOGkpK7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxOToyOToyNFrOGkqHGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA3NjQ2MQ==", "bodyText": "I think this is stale, since we are still using tryLock.", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r441076461", "createdAt": "2020-06-16T19:00:43Z", "author": {"login": "gpang"}, "path": "core/server/common/src/main/java/alluxio/master/StateLockOptions.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master;\n+\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+\n+import java.util.concurrent.locks.Lock;\n+\n+/**\n+ * Used to define state-lock options for taking it exclusively.\n+ * A typical framework for obtaining the state-lock exclusively is:\n+ *  1- Run a grace-cycle:\n+ *      cycle of {@link Lock#tryLock()} - {@link Thread#sleep(long)} calls.\n+ *  2- Interrupt state-lock holders if grace-cycle fails.\n+ *  3- Take the lock using {@link Lock#lock()}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ffcb98861454fb7435673273bbf3b109dc8917d2"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA3NjczNA==", "bodyText": "This is actually something like \"continually interrupt state-lock holders and waiters\", right?", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r441076734", "createdAt": "2020-06-16T19:01:13Z", "author": {"login": "gpang"}, "path": "core/server/common/src/main/java/alluxio/master/StateLockOptions.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master;\n+\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+\n+import java.util.concurrent.locks.Lock;\n+\n+/**\n+ * Used to define state-lock options for taking it exclusively.\n+ * A typical framework for obtaining the state-lock exclusively is:\n+ *  1- Run a grace-cycle:\n+ *      cycle of {@link Lock#tryLock()} - {@link Thread#sleep(long)} calls.\n+ *  2- Interrupt state-lock holders if grace-cycle fails.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ffcb98861454fb7435673273bbf3b109dc8917d2"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA5MTg2NA==", "bodyText": "I think we should be more explicit here. This will reject all RPCs which need to take the state-lock, which is most client RPCs.\nShould we also mention that this can be useful to guarantee a window on restart to initiate a backup?", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r441091864", "createdAt": "2020-06-16T19:29:24Z", "author": {"login": "gpang"}, "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "diffHunk": "@@ -1301,6 +1301,39 @@ public String toString() {\n           .setConsistencyCheckLevel(ConsistencyCheckLevel.IGNORE)\n           .setScope(Scope.MASTER)\n           .build();\n+  public static final PropertyKey MASTER_BACKUP_STATE_LOCK_EXCLUSIVE_DURATION =\n+      new Builder(Name.MASTER_BACKUP_STATE_LOCK_EXCLUSIVE_DURATION)\n+          .setDefaultValue(\"0ms\")\n+          .setDescription(\"Alluxio master will allow only exclusive locking of \"\n+              + \"the state-lock for this duration. This duration starts after masters \"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ffcb98861454fb7435673273bbf3b109dc8917d2"}, "originalPosition": 8}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "713cd794fbfe4bce27de455ff8d1b2bed062f8ea", "author": {"user": {"login": "ggezer", "name": "G\u00f6kt\u00fcrk Gezer"}}, "url": "https://github.com/Alluxio/alluxio/commit/713cd794fbfe4bce27de455ff8d1b2bed062f8ea", "committedDate": "2020-06-16T20:11:43Z", "message": "PR feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b5329c0ccd3f30344719fe1316c391be9a576650", "author": {"user": {"login": "ggezer", "name": "G\u00f6kt\u00fcrk Gezer"}}, "url": "https://github.com/Alluxio/alluxio/commit/b5329c0ccd3f30344719fe1316c391be9a576650", "committedDate": "2020-06-16T20:12:02Z", "message": "Add integration test for exclusive-only phase"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxOTM4MzEw", "url": "https://github.com/Alluxio/alluxio/pull/11535#pullrequestreview-431938310", "createdAt": "2020-06-16T22:34:04Z", "commit": {"oid": "b5329c0ccd3f30344719fe1316c391be9a576650"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4484, "cost": 1, "resetAt": "2021-10-29T17:30:11Z"}}}