{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkzMDk0MTI0", "number": 11204, "title": "Improve metadata sync operations", "bodyText": "This PR improves the \"syncMetadata\" operation used throughout the DefaultFileSystemMaster.\nThis approach incrementally locks and syncs the paths in the tree instead of taking a write lock on the root of the tree. The \"loadMetadata\" step of syncing  is now contained within the \"syncInodeMetadata\" function.\nIt is implemented with a BFS. The previous implementation used DFS which could have been prone to stack overflows if a user created a deep enough file hierarchy.\nAdditionally, this implementation makes the minimum amount of RPC calls required to the UFS. UfsStatuses are re-used as much as possible, and discarded once they are no longer required.", "createdAt": "2020-03-24T16:14:14Z", "url": "https://github.com/Alluxio/alluxio/pull/11204", "merged": true, "mergeCommit": {"oid": "6907d3b0bae32b8189990c0532e59545fd9647e4"}, "closed": true, "closedAt": "2020-05-12T07:55:45Z", "author": {"login": "ZacBlanco"}, "timelineItems": {"totalCount": 53, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcQ1bkUgBqjMxNjA0NzczOTI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcgY7e0gFqTQwOTYxNTU4OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c1e3c235ae49de9ba239f5e062d8378f8289dc68", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/c1e3c235ae49de9ba239f5e062d8378f8289dc68", "committedDate": "2020-03-24T08:21:34Z", "message": "temp commit"}, "afterCommit": {"oid": "0d77a3a975661bce5c480abcdb6a14b5fdb1b3da", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/0d77a3a975661bce5c480abcdb6a14b5fdb1b3da", "committedDate": "2020-03-24T16:23:41Z", "message": "temp commit"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0d77a3a975661bce5c480abcdb6a14b5fdb1b3da", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/0d77a3a975661bce5c480abcdb6a14b5fdb1b3da", "committedDate": "2020-03-24T16:23:41Z", "message": "temp commit"}, "afterCommit": {"oid": "b4796b83c2c17ca7469c0448e88004b884cb66b3", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/b4796b83c2c17ca7469c0448e88004b884cb66b3", "committedDate": "2020-03-24T16:45:50Z", "message": "temp commit"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "195a8a4cc8da9028ee33fe40f1d4a685d0be1fd9", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/195a8a4cc8da9028ee33fe40f1d4a685d0be1fd9", "committedDate": "2020-03-25T08:10:04Z", "message": "Fixed FSMasterRestartIT, UfsSyncIT, PinIT, ReadOnlyMountIT"}, "afterCommit": {"oid": "bc4d33422a0a5979c01b6c400c2b5035ca69b2d0", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/bc4d33422a0a5979c01b6c400c2b5035ca69b2d0", "committedDate": "2020-03-25T08:34:53Z", "message": "Fixed FSMasterRestartIT, UfsSyncIT, PinIT, ReadOnlyMountIT"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "bc4d33422a0a5979c01b6c400c2b5035ca69b2d0", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/bc4d33422a0a5979c01b6c400c2b5035ca69b2d0", "committedDate": "2020-03-25T08:34:53Z", "message": "Fixed FSMasterRestartIT, UfsSyncIT, PinIT, ReadOnlyMountIT"}, "afterCommit": {"oid": "8fb4cabb89411d23c5538a5fbb524b31570ac6ce", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/8fb4cabb89411d23c5538a5fbb524b31570ac6ce", "committedDate": "2020-03-25T09:28:28Z", "message": "Fixed FSMasterRestartIT, UfsSyncIT, PinIT, ReadOnlyMountIT"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8fb4cabb89411d23c5538a5fbb524b31570ac6ce", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/8fb4cabb89411d23c5538a5fbb524b31570ac6ce", "committedDate": "2020-03-25T09:28:28Z", "message": "Fixed FSMasterRestartIT, UfsSyncIT, PinIT, ReadOnlyMountIT"}, "afterCommit": {"oid": "2270cb22c90e1078930570abf0256783f65695cd", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/2270cb22c90e1078930570abf0256783f65695cd", "committedDate": "2020-03-26T00:15:29Z", "message": "Add UfsStatus Prefetch mechanism"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2270cb22c90e1078930570abf0256783f65695cd", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/2270cb22c90e1078930570abf0256783f65695cd", "committedDate": "2020-03-26T00:15:29Z", "message": "Add UfsStatus Prefetch mechanism"}, "afterCommit": {"oid": "ee07539a8dc549542162cdf87931d05621d807ae", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/ee07539a8dc549542162cdf87931d05621d807ae", "committedDate": "2020-03-26T15:52:37Z", "message": "Add UfsStatus Prefetch mechanism"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "be36b88dae4d4d63777a91a85156f5abf1362830", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/be36b88dae4d4d63777a91a85156f5abf1362830", "committedDate": "2020-03-27T02:59:30Z", "message": "Re-architect syncing primitive in FileSystemMaster"}, "afterCommit": {"oid": "52b9f426ffbc0b0edf70f63d335e96225069aeb9", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/52b9f426ffbc0b0edf70f63d335e96225069aeb9", "committedDate": "2020-03-27T15:15:14Z", "message": "Re-architect syncing primitive in FileSystemMaster"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "74f2897598ae0e5f5ac9f436b20017540a6994bd", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/74f2897598ae0e5f5ac9f436b20017540a6994bd", "committedDate": "2020-04-03T16:49:30Z", "message": "Appease findbugs and make parallelism configurable"}, "afterCommit": {"oid": "66ee306530d4ad3c6837bbb1e81d181cc565738b", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/66ee306530d4ad3c6837bbb1e81d181cc565738b", "committedDate": "2020-04-03T17:29:57Z", "message": "Appease findbugs and make parallelism configurable"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "bd226e04db312bc0230e01438ef8c169b986394f", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/bd226e04db312bc0230e01438ef8c169b986394f", "committedDate": "2020-04-05T23:41:58Z", "message": "Split sync executor size from sync concurrency\n\nThis can help limit the impact of a single sync job on the\nperformance of Alluxio as a whole. This is especially\nimportant if more than one path is being synced at a time.\nIt allows for a limited level of concurrency but still lets\nus share a single thread pool for executing sync tasks."}, "afterCommit": {"oid": "d0800a320ddfd09aa0db26ec3e23b188de2c248a", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/d0800a320ddfd09aa0db26ec3e23b188de2c248a", "committedDate": "2020-04-06T04:48:03Z", "message": "Split sync executor size from sync concurrency\n\nThis can help limit the impact of a single sync job on the\nperformance of Alluxio as a whole. This is especially\nimportant if more than one path is being synced at a time.\nIt allows for a limited level of concurrency but still lets\nus share a single thread pool for executing sync tasks."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "19273041357d2066d069b72327c9c938d450418a", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/19273041357d2066d069b72327c9c938d450418a", "committedDate": "2020-04-06T06:50:43Z", "message": "Remove unnecessary logs"}, "afterCommit": {"oid": "4922a6e6daa7f55b8f6c5151a8c14f36f30a08a3", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/4922a6e6daa7f55b8f6c5151a8c14f36f30a08a3", "committedDate": "2020-04-23T19:22:05Z", "message": "Remove unnecessary logs"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d0f0ac10f520d8be29a5be4431aec5f1697e2a4f", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/d0f0ac10f520d8be29a5be4431aec5f1697e2a4f", "committedDate": "2020-04-23T19:28:40Z", "message": "Fix build after rebase"}, "afterCommit": {"oid": "6b7d52bc3f226f8e2c7ffb0e65b2df90f496343e", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/6b7d52bc3f226f8e2c7ffb0e65b2df90f496343e", "committedDate": "2020-04-28T19:59:44Z", "message": "Fix FSMSyncMetadataTest"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAzMTE2NDc5", "url": "https://github.com/Alluxio/alluxio/pull/11204#pullrequestreview-403116479", "createdAt": "2020-04-29T23:50:32Z", "commit": {"oid": "6b7d52bc3f226f8e2c7ffb0e65b2df90f496343e"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQyMzo1MDozMlrOGOVAxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQwMDoxMDozMFrOGOVZdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY3NzUxMA==", "bodyText": "is this change related to this PR?", "url": "https://github.com/Alluxio/alluxio/pull/11204#discussion_r417677510", "createdAt": "2020-04-29T23:50:32Z", "author": {"login": "gpang"}, "path": "core/client/fs/src/test/java/alluxio/client/metrics/MetricsHeartbeatContextTest.java", "diffHunk": "@@ -41,8 +41,8 @@\n \n   @Test\n   public void testExecutorInitialized() {\n-\n     InstancedConfiguration conf = ConfigurationTestUtils.defaults();\n+    conf.set(PropertyKey.MASTER_HOSTNAME, \"localhost\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b7d52bc3f226f8e2c7ffb0e65b2df90f496343e"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY3ODAwNw==", "bodyText": "finish these params", "url": "https://github.com/Alluxio/alluxio/pull/11204#discussion_r417678007", "createdAt": "2020-04-29T23:51:58Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/master/file/meta/LockingScheme.java", "diffHunk": "@@ -38,6 +41,26 @@ public LockingScheme(AlluxioURI path, LockPattern desiredLockPattern, boolean sh\n     mShouldSync = shouldSync;\n   }\n \n+  /**\n+   * Create a new {@link LockingScheme}.\n+   *\n+   * @param path a", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b7d52bc3f226f8e2c7ffb0e65b2df90f496343e"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY4MTkzNQ==", "bodyText": "Should this be a parameter? Also, do we want to loop indefinitely, or throw some sort of exception when it was looping for too long? I'd imagine throwing an exception would prevent possible deadlocks or long delays, but failures would be less-user friendly. What do you think?", "url": "https://github.com/Alluxio/alluxio/pull/11204#discussion_r417681935", "createdAt": "2020-04-30T00:04:29Z", "author": {"login": "gpang"}, "path": "core/common/src/main/java/alluxio/resource/LockResource.java", "diffHunk": "@@ -35,24 +39,39 @@\n    * @param lock the lock to acquire\n    */\n   public LockResource(Lock lock) {\n-    this(lock, true);\n+    this(lock, true, false);\n   }\n \n   /**\n    * Creates a new instance of {@link LockResource} using the given lock.\n    *\n+   * This method may use the {@link Lock#tryLock()} method to gain ownership of the locks. The\n+   * reason one might want to use this is to avoid the fairness heuristics within the\n+   * {@link java.util.concurrent.locks.ReentrantReadWriteLock}'s NonFairSync which may block reader\n+   * threads if a writer if the first in the queue.\n+   *\n    * @param lock the lock to acquire\n    * @param acquireLock whether to lock the lock\n+   * @param useTryLock whether or not use to {@link Lock#tryLock()}\n    */\n-  public LockResource(Lock lock, boolean acquireLock) {\n+  public LockResource(Lock lock, boolean acquireLock, boolean useTryLock) {\n     mLock = lock;\n     if (acquireLock) {\n-      mLock.lock();\n+      if (useTryLock) {\n+        while (!mLock.tryLock()) { // returns immediately\n+          // The reason we don't use #tryLock(int, TimeUnit) here is because we found there is a bug\n+          // somewhere in the internal accounting of the ReentrantRWLock that, even though all\n+          // threads had released the lock, that a final thread would never be able to acquire it.\n+          LockSupport.parkNanos(10000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aea2599ba2565e052e3871653282b3f22a325203"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY4MjcyNg==", "bodyText": "How does this relate to the other parameters, MASTER_METADATA_SYNC_EXECUTOR_POOL_SIZE and MASTER_METADATA_SYNC_UFS_PREFETCH_POOL_SIZE? Also, it would be helpful to state what the potential tradeoffs are for a higher vs lower value (for the other parameters as well).", "url": "https://github.com/Alluxio/alluxio/pull/11204#discussion_r417682726", "createdAt": "2020-04-30T00:06:45Z", "author": {"login": "gpang"}, "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "diffHunk": "@@ -2132,6 +2132,30 @@ public String toString() {\n           .setConsistencyCheckLevel(ConsistencyCheckLevel.WARN)\n           .setScope(Scope.MASTER)\n           .build();\n+  public static final PropertyKey MASTER_METADATA_SYNC_CONCURRENCY_LEVEL =\n+      new Builder(Name.MASTER_METADATA_SYNC_CONCURRENCY_LEVEL)\n+          .setDefaultValue(6)\n+          .setDescription(\"The maximum number of concurrent sync tasks running for a given sync \"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aea2599ba2565e052e3871653282b3f22a325203"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY4MzgyOQ==", "bodyText": "Is this test useful anymore, if it is not validating how the load is happening?", "url": "https://github.com/Alluxio/alluxio/pull/11204#discussion_r417683829", "createdAt": "2020-04-30T00:10:30Z", "author": {"login": "gpang"}, "path": "tests/src/test/java/alluxio/client/fs/LoadMetadataIntegrationTest.java", "diffHunk": "@@ -219,15 +219,9 @@ public void loadRecursive() throws Exception {\n         fileWriter.close();\n       }\n     }\n-    long startMs = CommonUtils.getCurrentMs();\n     List<URIStatus> list = mFileSystem.listStatus(new AlluxioURI(\"/mnt\"), options);\n-    long durationMs = CommonUtils.getCurrentMs() - startMs;\n     // 25 files, 25 level 2 dirs, 5 level 1 dirs, 1 file and 1 dir created in before\n     Assert.assertEquals(25 * 2 + 5 + 2, list.size());\n-\n-    // Should load metadata once, in one recursive call", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aea2599ba2565e052e3871653282b3f22a325203"}, "originalPosition": 10}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAzODQ1NTQ3", "url": "https://github.com/Alluxio/alluxio/pull/11204#pullrequestreview-403845547", "createdAt": "2020-04-30T20:16:02Z", "commit": {"oid": "aea2599ba2565e052e3871653282b3f22a325203"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQyMDoxNjowMlrOGO4wkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQyMTozNDo0OFrOGO7KPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI2MzE4Ng==", "bodyText": "NIT\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  throw new IOException(\"Failed to await evictor termination\", e);\n          \n          \n            \n                  throw new IOException(\"Failed to await LockPool evictor termination\", e);", "url": "https://github.com/Alluxio/alluxio/pull/11204#discussion_r418263186", "createdAt": "2020-04-30T20:16:02Z", "author": {"login": "gpang"}, "path": "core/common/src/main/java/alluxio/collections/LockPool.java", "diffHunk": "@@ -77,8 +82,20 @@ public LockPool(Function<? super K, ? extends ReentrantReadWriteLock> defaultLoa\n     mHighWatermark = highWatermark;\n     mPool = new ConcurrentHashMap<>(initialSize, DEFAULT_LOAD_FACTOR, concurrencyLevel);\n     mEvictor = Executors.newSingleThreadExecutor(\n-        ThreadFactoryUtils.build(EVICTOR_THREAD_NAME, true));\n-    mEvictor.submit(new Evictor());\n+        ThreadFactoryUtils.build(String.format(\"%s-%s\", EVICTOR_THREAD_NAME, toString()), true));\n+    mEvictorTask = mEvictor.submit(new Evictor());\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    mEvictorTask.cancel(true);\n+    mEvictor.shutdownNow(); // immediately halt the evictor thread.\n+    try {\n+      mEvictor.awaitTermination(2, TimeUnit.SECONDS);\n+    } catch (InterruptedException e) {\n+      Thread.currentThread().interrupt();\n+      throw new IOException(\"Failed to await evictor termination\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aea2599ba2565e052e3871653282b3f22a325203"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI2NTAwMg==", "bodyText": "The param is nullable, what does that mean? Can you update this line?", "url": "https://github.com/Alluxio/alluxio/pull/11204#discussion_r418265002", "createdAt": "2020-04-30T20:19:27Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/underfs/UfsStatusCache.java", "diffHunk": "@@ -0,0 +1,275 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.underfs;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.collections.ConcurrentHashSet;\n+import alluxio.exception.InvalidPathException;\n+import alluxio.master.file.meta.MountTable;\n+import alluxio.resource.CloseableResource;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nullable;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.RejectedExecutionException;\n+\n+/**\n+ * This class is a cache from an Alluxio namespace URI ({@link AlluxioURI}, i.e. /path/to/inode) to\n+ * UFS statuses.\n+ *\n+ * It also allows associating a path with child inodes, so that the statuses for a specific path can\n+ * be searched for later.\n+ */\n+public class UfsStatusCache {\n+  private static final Logger LOG = LoggerFactory.getLogger(UfsStatusCache.class);\n+\n+  private final ConcurrentHashMap<AlluxioURI, UfsStatus> mStatuses;\n+  private final ConcurrentHashMap<AlluxioURI, Future<Collection<UfsStatus>>> mActivePrefetchJobs;\n+  private final ConcurrentHashMap<AlluxioURI, Collection<UfsStatus>> mChildren;\n+  private final ExecutorService mPrefetchExecutor;\n+\n+  /**\n+   * Create a new instance of {@link UfsStatusCache}.\n+   *\n+   * @param prefetchExecutor the executor service used to prefetch statuses", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aea2599ba2565e052e3871653282b3f22a325203"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI2NzUxMQ==", "bodyText": "what is prev for, and if it was already there, what should we do?", "url": "https://github.com/Alluxio/alluxio/pull/11204#discussion_r418267511", "createdAt": "2020-04-30T20:24:32Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/underfs/UfsStatusCache.java", "diffHunk": "@@ -0,0 +1,275 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.underfs;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.collections.ConcurrentHashSet;\n+import alluxio.exception.InvalidPathException;\n+import alluxio.master.file.meta.MountTable;\n+import alluxio.resource.CloseableResource;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nullable;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.RejectedExecutionException;\n+\n+/**\n+ * This class is a cache from an Alluxio namespace URI ({@link AlluxioURI}, i.e. /path/to/inode) to\n+ * UFS statuses.\n+ *\n+ * It also allows associating a path with child inodes, so that the statuses for a specific path can\n+ * be searched for later.\n+ */\n+public class UfsStatusCache {\n+  private static final Logger LOG = LoggerFactory.getLogger(UfsStatusCache.class);\n+\n+  private final ConcurrentHashMap<AlluxioURI, UfsStatus> mStatuses;\n+  private final ConcurrentHashMap<AlluxioURI, Future<Collection<UfsStatus>>> mActivePrefetchJobs;\n+  private final ConcurrentHashMap<AlluxioURI, Collection<UfsStatus>> mChildren;\n+  private final ExecutorService mPrefetchExecutor;\n+\n+  /**\n+   * Create a new instance of {@link UfsStatusCache}.\n+   *\n+   * @param prefetchExecutor the executor service used to prefetch statuses\n+   */\n+  public UfsStatusCache(@Nullable ExecutorService prefetchExecutor) {\n+    mStatuses = new ConcurrentHashMap<>();\n+    mChildren = new ConcurrentHashMap<>();\n+    mActivePrefetchJobs = new ConcurrentHashMap<>();\n+    mPrefetchExecutor = prefetchExecutor;\n+  }\n+\n+  /**\n+   * Add a new status to the cache.\n+   *\n+   * The last component of the path in the {@link AlluxioURI} must match the result of\n+   * {@link UfsStatus#getName()}. This method overrides any status currently cached for the same\n+   * URI.\n+   *\n+   * @param path the Alluxio path to key on\n+   * @param status the ufs status to store\n+   * @throws IllegalArgumentException if the status name doesn't match the final URI path component\n+   */\n+  public void addStatus(AlluxioURI path, UfsStatus status) {\n+    UfsStatus prev = mStatuses.putIfAbsent(path, status);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aea2599ba2565e052e3871653282b3f22a325203"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI2Nzc3NA==", "bodyText": "why is this check done after it was inserted?", "url": "https://github.com/Alluxio/alluxio/pull/11204#discussion_r418267774", "createdAt": "2020-04-30T20:25:00Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/underfs/UfsStatusCache.java", "diffHunk": "@@ -0,0 +1,275 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.underfs;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.collections.ConcurrentHashSet;\n+import alluxio.exception.InvalidPathException;\n+import alluxio.master.file.meta.MountTable;\n+import alluxio.resource.CloseableResource;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nullable;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.RejectedExecutionException;\n+\n+/**\n+ * This class is a cache from an Alluxio namespace URI ({@link AlluxioURI}, i.e. /path/to/inode) to\n+ * UFS statuses.\n+ *\n+ * It also allows associating a path with child inodes, so that the statuses for a specific path can\n+ * be searched for later.\n+ */\n+public class UfsStatusCache {\n+  private static final Logger LOG = LoggerFactory.getLogger(UfsStatusCache.class);\n+\n+  private final ConcurrentHashMap<AlluxioURI, UfsStatus> mStatuses;\n+  private final ConcurrentHashMap<AlluxioURI, Future<Collection<UfsStatus>>> mActivePrefetchJobs;\n+  private final ConcurrentHashMap<AlluxioURI, Collection<UfsStatus>> mChildren;\n+  private final ExecutorService mPrefetchExecutor;\n+\n+  /**\n+   * Create a new instance of {@link UfsStatusCache}.\n+   *\n+   * @param prefetchExecutor the executor service used to prefetch statuses\n+   */\n+  public UfsStatusCache(@Nullable ExecutorService prefetchExecutor) {\n+    mStatuses = new ConcurrentHashMap<>();\n+    mChildren = new ConcurrentHashMap<>();\n+    mActivePrefetchJobs = new ConcurrentHashMap<>();\n+    mPrefetchExecutor = prefetchExecutor;\n+  }\n+\n+  /**\n+   * Add a new status to the cache.\n+   *\n+   * The last component of the path in the {@link AlluxioURI} must match the result of\n+   * {@link UfsStatus#getName()}. This method overrides any status currently cached for the same\n+   * URI.\n+   *\n+   * @param path the Alluxio path to key on\n+   * @param status the ufs status to store\n+   * @throws IllegalArgumentException if the status name doesn't match the final URI path component\n+   */\n+  public void addStatus(AlluxioURI path, UfsStatus status) {\n+    UfsStatus prev = mStatuses.putIfAbsent(path, status);\n+    if (!path.getName().equals(status.getName())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aea2599ba2565e052e3871653282b3f22a325203"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI5MzE1Mg==", "bodyText": "When is this parent-child relationship used?", "url": "https://github.com/Alluxio/alluxio/pull/11204#discussion_r418293152", "createdAt": "2020-04-30T21:14:39Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/underfs/UfsStatusCache.java", "diffHunk": "@@ -0,0 +1,275 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.underfs;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.collections.ConcurrentHashSet;\n+import alluxio.exception.InvalidPathException;\n+import alluxio.master.file.meta.MountTable;\n+import alluxio.resource.CloseableResource;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nullable;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.RejectedExecutionException;\n+\n+/**\n+ * This class is a cache from an Alluxio namespace URI ({@link AlluxioURI}, i.e. /path/to/inode) to\n+ * UFS statuses.\n+ *\n+ * It also allows associating a path with child inodes, so that the statuses for a specific path can\n+ * be searched for later.\n+ */\n+public class UfsStatusCache {\n+  private static final Logger LOG = LoggerFactory.getLogger(UfsStatusCache.class);\n+\n+  private final ConcurrentHashMap<AlluxioURI, UfsStatus> mStatuses;\n+  private final ConcurrentHashMap<AlluxioURI, Future<Collection<UfsStatus>>> mActivePrefetchJobs;\n+  private final ConcurrentHashMap<AlluxioURI, Collection<UfsStatus>> mChildren;\n+  private final ExecutorService mPrefetchExecutor;\n+\n+  /**\n+   * Create a new instance of {@link UfsStatusCache}.\n+   *\n+   * @param prefetchExecutor the executor service used to prefetch statuses\n+   */\n+  public UfsStatusCache(@Nullable ExecutorService prefetchExecutor) {\n+    mStatuses = new ConcurrentHashMap<>();\n+    mChildren = new ConcurrentHashMap<>();\n+    mActivePrefetchJobs = new ConcurrentHashMap<>();\n+    mPrefetchExecutor = prefetchExecutor;\n+  }\n+\n+  /**\n+   * Add a new status to the cache.\n+   *\n+   * The last component of the path in the {@link AlluxioURI} must match the result of\n+   * {@link UfsStatus#getName()}. This method overrides any status currently cached for the same\n+   * URI.\n+   *\n+   * @param path the Alluxio path to key on\n+   * @param status the ufs status to store\n+   * @throws IllegalArgumentException if the status name doesn't match the final URI path component\n+   */\n+  public void addStatus(AlluxioURI path, UfsStatus status) {\n+    UfsStatus prev = mStatuses.putIfAbsent(path, status);\n+    if (!path.getName().equals(status.getName())) {\n+      throw new IllegalArgumentException(\n+          String.format(\"path name %s does not match ufs status name %s\",\n+              path.getName(), status.getName()));\n+    }\n+  }\n+\n+  /**\n+   * Add a parent-child mapping to the status cache.\n+   *\n+   * All child statuses added via this method will be available via {@link #getStatus(AlluxioURI)}.\n+   *\n+   * @param path the directory inode path which contains the children\n+   * @param children the children of the {@code path}\n+   * @throws IllegalArgumentException when {@code path} already exists or if any child already\n+   *                                  exists\n+   */\n+  public void addChildren(AlluxioURI path, Collection<UfsStatus> children) {\n+    UfsStatus status = mStatuses.get(path);\n+    // If this path doesn't yet exist, we can't keep track of the parent-child relationship", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aea2599ba2565e052e3871653282b3f22a325203"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI5NDgwNQ==", "bodyText": "Why can't we add this parent->children listing cache even if the parent status is not in the other map?", "url": "https://github.com/Alluxio/alluxio/pull/11204#discussion_r418294805", "createdAt": "2020-04-30T21:18:06Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/underfs/UfsStatusCache.java", "diffHunk": "@@ -0,0 +1,275 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.underfs;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.collections.ConcurrentHashSet;\n+import alluxio.exception.InvalidPathException;\n+import alluxio.master.file.meta.MountTable;\n+import alluxio.resource.CloseableResource;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nullable;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.RejectedExecutionException;\n+\n+/**\n+ * This class is a cache from an Alluxio namespace URI ({@link AlluxioURI}, i.e. /path/to/inode) to\n+ * UFS statuses.\n+ *\n+ * It also allows associating a path with child inodes, so that the statuses for a specific path can\n+ * be searched for later.\n+ */\n+public class UfsStatusCache {\n+  private static final Logger LOG = LoggerFactory.getLogger(UfsStatusCache.class);\n+\n+  private final ConcurrentHashMap<AlluxioURI, UfsStatus> mStatuses;\n+  private final ConcurrentHashMap<AlluxioURI, Future<Collection<UfsStatus>>> mActivePrefetchJobs;\n+  private final ConcurrentHashMap<AlluxioURI, Collection<UfsStatus>> mChildren;\n+  private final ExecutorService mPrefetchExecutor;\n+\n+  /**\n+   * Create a new instance of {@link UfsStatusCache}.\n+   *\n+   * @param prefetchExecutor the executor service used to prefetch statuses\n+   */\n+  public UfsStatusCache(@Nullable ExecutorService prefetchExecutor) {\n+    mStatuses = new ConcurrentHashMap<>();\n+    mChildren = new ConcurrentHashMap<>();\n+    mActivePrefetchJobs = new ConcurrentHashMap<>();\n+    mPrefetchExecutor = prefetchExecutor;\n+  }\n+\n+  /**\n+   * Add a new status to the cache.\n+   *\n+   * The last component of the path in the {@link AlluxioURI} must match the result of\n+   * {@link UfsStatus#getName()}. This method overrides any status currently cached for the same\n+   * URI.\n+   *\n+   * @param path the Alluxio path to key on\n+   * @param status the ufs status to store\n+   * @throws IllegalArgumentException if the status name doesn't match the final URI path component\n+   */\n+  public void addStatus(AlluxioURI path, UfsStatus status) {\n+    UfsStatus prev = mStatuses.putIfAbsent(path, status);\n+    if (!path.getName().equals(status.getName())) {\n+      throw new IllegalArgumentException(\n+          String.format(\"path name %s does not match ufs status name %s\",\n+              path.getName(), status.getName()));\n+    }\n+  }\n+\n+  /**\n+   * Add a parent-child mapping to the status cache.\n+   *\n+   * All child statuses added via this method will be available via {@link #getStatus(AlluxioURI)}.\n+   *\n+   * @param path the directory inode path which contains the children\n+   * @param children the children of the {@code path}\n+   * @throws IllegalArgumentException when {@code path} already exists or if any child already\n+   *                                  exists\n+   */\n+  public void addChildren(AlluxioURI path, Collection<UfsStatus> children) {\n+    UfsStatus status = mStatuses.get(path);\n+    // If this path doesn't yet exist, we can't keep track of the parent-child relationship\n+    // We can still add statuses to the cache regardless\n+    if (status != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aea2599ba2565e052e3871653282b3f22a325203"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI5NTQ3Mw==", "bodyText": "Is the contract that if the status DNE, then the children list DNE for that path? It is unclear what the relationship is between the 2 maps.", "url": "https://github.com/Alluxio/alluxio/pull/11204#discussion_r418295473", "createdAt": "2020-04-30T21:19:27Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/underfs/UfsStatusCache.java", "diffHunk": "@@ -0,0 +1,275 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.underfs;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.collections.ConcurrentHashSet;\n+import alluxio.exception.InvalidPathException;\n+import alluxio.master.file.meta.MountTable;\n+import alluxio.resource.CloseableResource;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nullable;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.RejectedExecutionException;\n+\n+/**\n+ * This class is a cache from an Alluxio namespace URI ({@link AlluxioURI}, i.e. /path/to/inode) to\n+ * UFS statuses.\n+ *\n+ * It also allows associating a path with child inodes, so that the statuses for a specific path can\n+ * be searched for later.\n+ */\n+public class UfsStatusCache {\n+  private static final Logger LOG = LoggerFactory.getLogger(UfsStatusCache.class);\n+\n+  private final ConcurrentHashMap<AlluxioURI, UfsStatus> mStatuses;\n+  private final ConcurrentHashMap<AlluxioURI, Future<Collection<UfsStatus>>> mActivePrefetchJobs;\n+  private final ConcurrentHashMap<AlluxioURI, Collection<UfsStatus>> mChildren;\n+  private final ExecutorService mPrefetchExecutor;\n+\n+  /**\n+   * Create a new instance of {@link UfsStatusCache}.\n+   *\n+   * @param prefetchExecutor the executor service used to prefetch statuses\n+   */\n+  public UfsStatusCache(@Nullable ExecutorService prefetchExecutor) {\n+    mStatuses = new ConcurrentHashMap<>();\n+    mChildren = new ConcurrentHashMap<>();\n+    mActivePrefetchJobs = new ConcurrentHashMap<>();\n+    mPrefetchExecutor = prefetchExecutor;\n+  }\n+\n+  /**\n+   * Add a new status to the cache.\n+   *\n+   * The last component of the path in the {@link AlluxioURI} must match the result of\n+   * {@link UfsStatus#getName()}. This method overrides any status currently cached for the same\n+   * URI.\n+   *\n+   * @param path the Alluxio path to key on\n+   * @param status the ufs status to store\n+   * @throws IllegalArgumentException if the status name doesn't match the final URI path component\n+   */\n+  public void addStatus(AlluxioURI path, UfsStatus status) {\n+    UfsStatus prev = mStatuses.putIfAbsent(path, status);\n+    if (!path.getName().equals(status.getName())) {\n+      throw new IllegalArgumentException(\n+          String.format(\"path name %s does not match ufs status name %s\",\n+              path.getName(), status.getName()));\n+    }\n+  }\n+\n+  /**\n+   * Add a parent-child mapping to the status cache.\n+   *\n+   * All child statuses added via this method will be available via {@link #getStatus(AlluxioURI)}.\n+   *\n+   * @param path the directory inode path which contains the children\n+   * @param children the children of the {@code path}\n+   * @throws IllegalArgumentException when {@code path} already exists or if any child already\n+   *                                  exists\n+   */\n+  public void addChildren(AlluxioURI path, Collection<UfsStatus> children) {\n+    UfsStatus status = mStatuses.get(path);\n+    // If this path doesn't yet exist, we can't keep track of the parent-child relationship\n+    // We can still add statuses to the cache regardless\n+    if (status != null) {\n+      mChildren.computeIfAbsent(path, ufsStatus -> new ConcurrentHashSet<>()).addAll(children);\n+    }\n+    children.forEach(child -> {\n+      AlluxioURI childPath = path.joinUnsafe(child.getName());\n+      addStatus(childPath, child);\n+    });\n+  }\n+\n+  /**\n+   * Remove a status from the cache.\n+   *\n+   *  Any children added to this status will remain in the cache.\n+   *\n+   * @param path the path corresponding to the {@link UfsStatus} to remove\n+   * @return the removed UfsStatus\n+   */\n+  public UfsStatus remove(AlluxioURI path) {\n+    UfsStatus removed = mStatuses.remove(path);\n+    if (removed == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aea2599ba2565e052e3871653282b3f22a325203"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI5NTg1Ng==", "bodyText": "What if it was already cached? The children cache would be stale?", "url": "https://github.com/Alluxio/alluxio/pull/11204#discussion_r418295856", "createdAt": "2020-04-30T21:20:13Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/underfs/UfsStatusCache.java", "diffHunk": "@@ -0,0 +1,275 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.underfs;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.collections.ConcurrentHashSet;\n+import alluxio.exception.InvalidPathException;\n+import alluxio.master.file.meta.MountTable;\n+import alluxio.resource.CloseableResource;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nullable;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.RejectedExecutionException;\n+\n+/**\n+ * This class is a cache from an Alluxio namespace URI ({@link AlluxioURI}, i.e. /path/to/inode) to\n+ * UFS statuses.\n+ *\n+ * It also allows associating a path with child inodes, so that the statuses for a specific path can\n+ * be searched for later.\n+ */\n+public class UfsStatusCache {\n+  private static final Logger LOG = LoggerFactory.getLogger(UfsStatusCache.class);\n+\n+  private final ConcurrentHashMap<AlluxioURI, UfsStatus> mStatuses;\n+  private final ConcurrentHashMap<AlluxioURI, Future<Collection<UfsStatus>>> mActivePrefetchJobs;\n+  private final ConcurrentHashMap<AlluxioURI, Collection<UfsStatus>> mChildren;\n+  private final ExecutorService mPrefetchExecutor;\n+\n+  /**\n+   * Create a new instance of {@link UfsStatusCache}.\n+   *\n+   * @param prefetchExecutor the executor service used to prefetch statuses\n+   */\n+  public UfsStatusCache(@Nullable ExecutorService prefetchExecutor) {\n+    mStatuses = new ConcurrentHashMap<>();\n+    mChildren = new ConcurrentHashMap<>();\n+    mActivePrefetchJobs = new ConcurrentHashMap<>();\n+    mPrefetchExecutor = prefetchExecutor;\n+  }\n+\n+  /**\n+   * Add a new status to the cache.\n+   *\n+   * The last component of the path in the {@link AlluxioURI} must match the result of\n+   * {@link UfsStatus#getName()}. This method overrides any status currently cached for the same\n+   * URI.\n+   *\n+   * @param path the Alluxio path to key on\n+   * @param status the ufs status to store\n+   * @throws IllegalArgumentException if the status name doesn't match the final URI path component\n+   */\n+  public void addStatus(AlluxioURI path, UfsStatus status) {\n+    UfsStatus prev = mStatuses.putIfAbsent(path, status);\n+    if (!path.getName().equals(status.getName())) {\n+      throw new IllegalArgumentException(\n+          String.format(\"path name %s does not match ufs status name %s\",\n+              path.getName(), status.getName()));\n+    }\n+  }\n+\n+  /**\n+   * Add a parent-child mapping to the status cache.\n+   *\n+   * All child statuses added via this method will be available via {@link #getStatus(AlluxioURI)}.\n+   *\n+   * @param path the directory inode path which contains the children\n+   * @param children the children of the {@code path}\n+   * @throws IllegalArgumentException when {@code path} already exists or if any child already\n+   *                                  exists\n+   */\n+  public void addChildren(AlluxioURI path, Collection<UfsStatus> children) {\n+    UfsStatus status = mStatuses.get(path);\n+    // If this path doesn't yet exist, we can't keep track of the parent-child relationship\n+    // We can still add statuses to the cache regardless\n+    if (status != null) {\n+      mChildren.computeIfAbsent(path, ufsStatus -> new ConcurrentHashSet<>()).addAll(children);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aea2599ba2565e052e3871653282b3f22a325203"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI5ODY5Mw==", "bodyText": "What happens if there is no scheduled prefetch job? Is that what (3) is?", "url": "https://github.com/Alluxio/alluxio/pull/11204#discussion_r418298693", "createdAt": "2020-04-30T21:26:27Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/underfs/UfsStatusCache.java", "diffHunk": "@@ -0,0 +1,275 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.underfs;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.collections.ConcurrentHashSet;\n+import alluxio.exception.InvalidPathException;\n+import alluxio.master.file.meta.MountTable;\n+import alluxio.resource.CloseableResource;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nullable;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.RejectedExecutionException;\n+\n+/**\n+ * This class is a cache from an Alluxio namespace URI ({@link AlluxioURI}, i.e. /path/to/inode) to\n+ * UFS statuses.\n+ *\n+ * It also allows associating a path with child inodes, so that the statuses for a specific path can\n+ * be searched for later.\n+ */\n+public class UfsStatusCache {\n+  private static final Logger LOG = LoggerFactory.getLogger(UfsStatusCache.class);\n+\n+  private final ConcurrentHashMap<AlluxioURI, UfsStatus> mStatuses;\n+  private final ConcurrentHashMap<AlluxioURI, Future<Collection<UfsStatus>>> mActivePrefetchJobs;\n+  private final ConcurrentHashMap<AlluxioURI, Collection<UfsStatus>> mChildren;\n+  private final ExecutorService mPrefetchExecutor;\n+\n+  /**\n+   * Create a new instance of {@link UfsStatusCache}.\n+   *\n+   * @param prefetchExecutor the executor service used to prefetch statuses\n+   */\n+  public UfsStatusCache(@Nullable ExecutorService prefetchExecutor) {\n+    mStatuses = new ConcurrentHashMap<>();\n+    mChildren = new ConcurrentHashMap<>();\n+    mActivePrefetchJobs = new ConcurrentHashMap<>();\n+    mPrefetchExecutor = prefetchExecutor;\n+  }\n+\n+  /**\n+   * Add a new status to the cache.\n+   *\n+   * The last component of the path in the {@link AlluxioURI} must match the result of\n+   * {@link UfsStatus#getName()}. This method overrides any status currently cached for the same\n+   * URI.\n+   *\n+   * @param path the Alluxio path to key on\n+   * @param status the ufs status to store\n+   * @throws IllegalArgumentException if the status name doesn't match the final URI path component\n+   */\n+  public void addStatus(AlluxioURI path, UfsStatus status) {\n+    UfsStatus prev = mStatuses.putIfAbsent(path, status);\n+    if (!path.getName().equals(status.getName())) {\n+      throw new IllegalArgumentException(\n+          String.format(\"path name %s does not match ufs status name %s\",\n+              path.getName(), status.getName()));\n+    }\n+  }\n+\n+  /**\n+   * Add a parent-child mapping to the status cache.\n+   *\n+   * All child statuses added via this method will be available via {@link #getStatus(AlluxioURI)}.\n+   *\n+   * @param path the directory inode path which contains the children\n+   * @param children the children of the {@code path}\n+   * @throws IllegalArgumentException when {@code path} already exists or if any child already\n+   *                                  exists\n+   */\n+  public void addChildren(AlluxioURI path, Collection<UfsStatus> children) {\n+    UfsStatus status = mStatuses.get(path);\n+    // If this path doesn't yet exist, we can't keep track of the parent-child relationship\n+    // We can still add statuses to the cache regardless\n+    if (status != null) {\n+      mChildren.computeIfAbsent(path, ufsStatus -> new ConcurrentHashSet<>()).addAll(children);\n+    }\n+    children.forEach(child -> {\n+      AlluxioURI childPath = path.joinUnsafe(child.getName());\n+      addStatus(childPath, child);\n+    });\n+  }\n+\n+  /**\n+   * Remove a status from the cache.\n+   *\n+   *  Any children added to this status will remain in the cache.\n+   *\n+   * @param path the path corresponding to the {@link UfsStatus} to remove\n+   * @return the removed UfsStatus\n+   */\n+  public UfsStatus remove(AlluxioURI path) {\n+    UfsStatus removed = mStatuses.remove(path);\n+    if (removed == null) {\n+      return null;\n+    }\n+\n+    mChildren.remove(path); // ok if there aren't any children\n+    return removed;\n+  }\n+\n+  /**\n+   * Get the UfsStatus from a given AlluxioURI.\n+   *\n+   * @param path the path the retrieve\n+   * @return The corresponding {@link UfsStatus} or {@code null} if there is none stored\n+   */\n+  public UfsStatus getStatus(AlluxioURI path) {\n+    return mStatuses.get(path);\n+  }\n+\n+  /**\n+   * Fetches children of a given alluxio path, stores them in the cache, then returns them.\n+   *\n+   * Children can be returned in a few ways\n+   * 1. Children already exist in the internal index. We simply return them\n+   * 2. If children did not already exist in the index, then check if there was a scheduled\n+   * prefetch job running for this path. If so, wait for the job to finish and return the result.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aea2599ba2565e052e3871653282b3f22a325203"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMwMDE5Mw==", "bodyText": "Removing it means other callers which call this same method would think there are no prefetch jobs? Is that intended?", "url": "https://github.com/Alluxio/alluxio/pull/11204#discussion_r418300193", "createdAt": "2020-04-30T21:29:43Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/underfs/UfsStatusCache.java", "diffHunk": "@@ -0,0 +1,275 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.underfs;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.collections.ConcurrentHashSet;\n+import alluxio.exception.InvalidPathException;\n+import alluxio.master.file.meta.MountTable;\n+import alluxio.resource.CloseableResource;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nullable;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.RejectedExecutionException;\n+\n+/**\n+ * This class is a cache from an Alluxio namespace URI ({@link AlluxioURI}, i.e. /path/to/inode) to\n+ * UFS statuses.\n+ *\n+ * It also allows associating a path with child inodes, so that the statuses for a specific path can\n+ * be searched for later.\n+ */\n+public class UfsStatusCache {\n+  private static final Logger LOG = LoggerFactory.getLogger(UfsStatusCache.class);\n+\n+  private final ConcurrentHashMap<AlluxioURI, UfsStatus> mStatuses;\n+  private final ConcurrentHashMap<AlluxioURI, Future<Collection<UfsStatus>>> mActivePrefetchJobs;\n+  private final ConcurrentHashMap<AlluxioURI, Collection<UfsStatus>> mChildren;\n+  private final ExecutorService mPrefetchExecutor;\n+\n+  /**\n+   * Create a new instance of {@link UfsStatusCache}.\n+   *\n+   * @param prefetchExecutor the executor service used to prefetch statuses\n+   */\n+  public UfsStatusCache(@Nullable ExecutorService prefetchExecutor) {\n+    mStatuses = new ConcurrentHashMap<>();\n+    mChildren = new ConcurrentHashMap<>();\n+    mActivePrefetchJobs = new ConcurrentHashMap<>();\n+    mPrefetchExecutor = prefetchExecutor;\n+  }\n+\n+  /**\n+   * Add a new status to the cache.\n+   *\n+   * The last component of the path in the {@link AlluxioURI} must match the result of\n+   * {@link UfsStatus#getName()}. This method overrides any status currently cached for the same\n+   * URI.\n+   *\n+   * @param path the Alluxio path to key on\n+   * @param status the ufs status to store\n+   * @throws IllegalArgumentException if the status name doesn't match the final URI path component\n+   */\n+  public void addStatus(AlluxioURI path, UfsStatus status) {\n+    UfsStatus prev = mStatuses.putIfAbsent(path, status);\n+    if (!path.getName().equals(status.getName())) {\n+      throw new IllegalArgumentException(\n+          String.format(\"path name %s does not match ufs status name %s\",\n+              path.getName(), status.getName()));\n+    }\n+  }\n+\n+  /**\n+   * Add a parent-child mapping to the status cache.\n+   *\n+   * All child statuses added via this method will be available via {@link #getStatus(AlluxioURI)}.\n+   *\n+   * @param path the directory inode path which contains the children\n+   * @param children the children of the {@code path}\n+   * @throws IllegalArgumentException when {@code path} already exists or if any child already\n+   *                                  exists\n+   */\n+  public void addChildren(AlluxioURI path, Collection<UfsStatus> children) {\n+    UfsStatus status = mStatuses.get(path);\n+    // If this path doesn't yet exist, we can't keep track of the parent-child relationship\n+    // We can still add statuses to the cache regardless\n+    if (status != null) {\n+      mChildren.computeIfAbsent(path, ufsStatus -> new ConcurrentHashSet<>()).addAll(children);\n+    }\n+    children.forEach(child -> {\n+      AlluxioURI childPath = path.joinUnsafe(child.getName());\n+      addStatus(childPath, child);\n+    });\n+  }\n+\n+  /**\n+   * Remove a status from the cache.\n+   *\n+   *  Any children added to this status will remain in the cache.\n+   *\n+   * @param path the path corresponding to the {@link UfsStatus} to remove\n+   * @return the removed UfsStatus\n+   */\n+  public UfsStatus remove(AlluxioURI path) {\n+    UfsStatus removed = mStatuses.remove(path);\n+    if (removed == null) {\n+      return null;\n+    }\n+\n+    mChildren.remove(path); // ok if there aren't any children\n+    return removed;\n+  }\n+\n+  /**\n+   * Get the UfsStatus from a given AlluxioURI.\n+   *\n+   * @param path the path the retrieve\n+   * @return The corresponding {@link UfsStatus} or {@code null} if there is none stored\n+   */\n+  public UfsStatus getStatus(AlluxioURI path) {\n+    return mStatuses.get(path);\n+  }\n+\n+  /**\n+   * Fetches children of a given alluxio path, stores them in the cache, then returns them.\n+   *\n+   * Children can be returned in a few ways\n+   * 1. Children already exist in the internal index. We simply return them\n+   * 2. If children did not already exist in the index, then check if there was a scheduled\n+   * prefetch job running for this path. If so, wait for the job to finish and return the result.\n+   * 3. If no prefetch job, and children don't yet exist in the cache, then if the fallback\n+   * parameter is true, fetch them from the UFS and store them in the cache. Otherwise, simply\n+   * return null.\n+   *\n+   * @param path the Alluxio path to get the children of\n+   * @param mountTable the Alluxio mount table\n+   * @param useFallback whether or not to fall back to calling the UFS\n+   * @return child UFS statuses of the alluxio path, or null if no prefetch job and fallback\n+   *         specified as false\n+   * @throws InvalidPathException if the alluxio path can't be resolved to a UFS mount\n+   */\n+  @Nullable\n+  public Collection<UfsStatus> fetchChildrenIfAbsent(AlluxioURI path, MountTable mountTable,\n+      boolean useFallback)\n+      throws IOException, InvalidPathException {\n+    Collection<UfsStatus> children = getChildren(path);\n+    if (children != null) {\n+      return children;\n+    }\n+    Future<Collection<UfsStatus>> prefetchJob = mActivePrefetchJobs.remove(path);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aea2599ba2565e052e3871653282b3f22a325203"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMwMDM4MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    LOG.warn(\"Failed waiting to fetch children at {}\", path);\n          \n          \n            \n                    LOG.warn(\"Failed waiting to prefetch children at {}\", path);", "url": "https://github.com/Alluxio/alluxio/pull/11204#discussion_r418300381", "createdAt": "2020-04-30T21:30:09Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/underfs/UfsStatusCache.java", "diffHunk": "@@ -0,0 +1,275 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.underfs;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.collections.ConcurrentHashSet;\n+import alluxio.exception.InvalidPathException;\n+import alluxio.master.file.meta.MountTable;\n+import alluxio.resource.CloseableResource;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nullable;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.RejectedExecutionException;\n+\n+/**\n+ * This class is a cache from an Alluxio namespace URI ({@link AlluxioURI}, i.e. /path/to/inode) to\n+ * UFS statuses.\n+ *\n+ * It also allows associating a path with child inodes, so that the statuses for a specific path can\n+ * be searched for later.\n+ */\n+public class UfsStatusCache {\n+  private static final Logger LOG = LoggerFactory.getLogger(UfsStatusCache.class);\n+\n+  private final ConcurrentHashMap<AlluxioURI, UfsStatus> mStatuses;\n+  private final ConcurrentHashMap<AlluxioURI, Future<Collection<UfsStatus>>> mActivePrefetchJobs;\n+  private final ConcurrentHashMap<AlluxioURI, Collection<UfsStatus>> mChildren;\n+  private final ExecutorService mPrefetchExecutor;\n+\n+  /**\n+   * Create a new instance of {@link UfsStatusCache}.\n+   *\n+   * @param prefetchExecutor the executor service used to prefetch statuses\n+   */\n+  public UfsStatusCache(@Nullable ExecutorService prefetchExecutor) {\n+    mStatuses = new ConcurrentHashMap<>();\n+    mChildren = new ConcurrentHashMap<>();\n+    mActivePrefetchJobs = new ConcurrentHashMap<>();\n+    mPrefetchExecutor = prefetchExecutor;\n+  }\n+\n+  /**\n+   * Add a new status to the cache.\n+   *\n+   * The last component of the path in the {@link AlluxioURI} must match the result of\n+   * {@link UfsStatus#getName()}. This method overrides any status currently cached for the same\n+   * URI.\n+   *\n+   * @param path the Alluxio path to key on\n+   * @param status the ufs status to store\n+   * @throws IllegalArgumentException if the status name doesn't match the final URI path component\n+   */\n+  public void addStatus(AlluxioURI path, UfsStatus status) {\n+    UfsStatus prev = mStatuses.putIfAbsent(path, status);\n+    if (!path.getName().equals(status.getName())) {\n+      throw new IllegalArgumentException(\n+          String.format(\"path name %s does not match ufs status name %s\",\n+              path.getName(), status.getName()));\n+    }\n+  }\n+\n+  /**\n+   * Add a parent-child mapping to the status cache.\n+   *\n+   * All child statuses added via this method will be available via {@link #getStatus(AlluxioURI)}.\n+   *\n+   * @param path the directory inode path which contains the children\n+   * @param children the children of the {@code path}\n+   * @throws IllegalArgumentException when {@code path} already exists or if any child already\n+   *                                  exists\n+   */\n+  public void addChildren(AlluxioURI path, Collection<UfsStatus> children) {\n+    UfsStatus status = mStatuses.get(path);\n+    // If this path doesn't yet exist, we can't keep track of the parent-child relationship\n+    // We can still add statuses to the cache regardless\n+    if (status != null) {\n+      mChildren.computeIfAbsent(path, ufsStatus -> new ConcurrentHashSet<>()).addAll(children);\n+    }\n+    children.forEach(child -> {\n+      AlluxioURI childPath = path.joinUnsafe(child.getName());\n+      addStatus(childPath, child);\n+    });\n+  }\n+\n+  /**\n+   * Remove a status from the cache.\n+   *\n+   *  Any children added to this status will remain in the cache.\n+   *\n+   * @param path the path corresponding to the {@link UfsStatus} to remove\n+   * @return the removed UfsStatus\n+   */\n+  public UfsStatus remove(AlluxioURI path) {\n+    UfsStatus removed = mStatuses.remove(path);\n+    if (removed == null) {\n+      return null;\n+    }\n+\n+    mChildren.remove(path); // ok if there aren't any children\n+    return removed;\n+  }\n+\n+  /**\n+   * Get the UfsStatus from a given AlluxioURI.\n+   *\n+   * @param path the path the retrieve\n+   * @return The corresponding {@link UfsStatus} or {@code null} if there is none stored\n+   */\n+  public UfsStatus getStatus(AlluxioURI path) {\n+    return mStatuses.get(path);\n+  }\n+\n+  /**\n+   * Fetches children of a given alluxio path, stores them in the cache, then returns them.\n+   *\n+   * Children can be returned in a few ways\n+   * 1. Children already exist in the internal index. We simply return them\n+   * 2. If children did not already exist in the index, then check if there was a scheduled\n+   * prefetch job running for this path. If so, wait for the job to finish and return the result.\n+   * 3. If no prefetch job, and children don't yet exist in the cache, then if the fallback\n+   * parameter is true, fetch them from the UFS and store them in the cache. Otherwise, simply\n+   * return null.\n+   *\n+   * @param path the Alluxio path to get the children of\n+   * @param mountTable the Alluxio mount table\n+   * @param useFallback whether or not to fall back to calling the UFS\n+   * @return child UFS statuses of the alluxio path, or null if no prefetch job and fallback\n+   *         specified as false\n+   * @throws InvalidPathException if the alluxio path can't be resolved to a UFS mount\n+   */\n+  @Nullable\n+  public Collection<UfsStatus> fetchChildrenIfAbsent(AlluxioURI path, MountTable mountTable,\n+      boolean useFallback)\n+      throws IOException, InvalidPathException {\n+    Collection<UfsStatus> children = getChildren(path);\n+    if (children != null) {\n+      return children;\n+    }\n+    Future<Collection<UfsStatus>> prefetchJob = mActivePrefetchJobs.remove(path);\n+    if (prefetchJob != null) {\n+      try {\n+        return prefetchJob.get();\n+      } catch (InterruptedException | ExecutionException e) {\n+        LOG.warn(\"Failed waiting to fetch children at {}\", path);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aea2599ba2565e052e3871653282b3f22a325203"}, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMwMDQzMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (e instanceof  InterruptedException) {\n          \n          \n            \n                    if (e instanceof InterruptedException) {", "url": "https://github.com/Alluxio/alluxio/pull/11204#discussion_r418300433", "createdAt": "2020-04-30T21:30:18Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/underfs/UfsStatusCache.java", "diffHunk": "@@ -0,0 +1,275 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.underfs;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.collections.ConcurrentHashSet;\n+import alluxio.exception.InvalidPathException;\n+import alluxio.master.file.meta.MountTable;\n+import alluxio.resource.CloseableResource;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nullable;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.RejectedExecutionException;\n+\n+/**\n+ * This class is a cache from an Alluxio namespace URI ({@link AlluxioURI}, i.e. /path/to/inode) to\n+ * UFS statuses.\n+ *\n+ * It also allows associating a path with child inodes, so that the statuses for a specific path can\n+ * be searched for later.\n+ */\n+public class UfsStatusCache {\n+  private static final Logger LOG = LoggerFactory.getLogger(UfsStatusCache.class);\n+\n+  private final ConcurrentHashMap<AlluxioURI, UfsStatus> mStatuses;\n+  private final ConcurrentHashMap<AlluxioURI, Future<Collection<UfsStatus>>> mActivePrefetchJobs;\n+  private final ConcurrentHashMap<AlluxioURI, Collection<UfsStatus>> mChildren;\n+  private final ExecutorService mPrefetchExecutor;\n+\n+  /**\n+   * Create a new instance of {@link UfsStatusCache}.\n+   *\n+   * @param prefetchExecutor the executor service used to prefetch statuses\n+   */\n+  public UfsStatusCache(@Nullable ExecutorService prefetchExecutor) {\n+    mStatuses = new ConcurrentHashMap<>();\n+    mChildren = new ConcurrentHashMap<>();\n+    mActivePrefetchJobs = new ConcurrentHashMap<>();\n+    mPrefetchExecutor = prefetchExecutor;\n+  }\n+\n+  /**\n+   * Add a new status to the cache.\n+   *\n+   * The last component of the path in the {@link AlluxioURI} must match the result of\n+   * {@link UfsStatus#getName()}. This method overrides any status currently cached for the same\n+   * URI.\n+   *\n+   * @param path the Alluxio path to key on\n+   * @param status the ufs status to store\n+   * @throws IllegalArgumentException if the status name doesn't match the final URI path component\n+   */\n+  public void addStatus(AlluxioURI path, UfsStatus status) {\n+    UfsStatus prev = mStatuses.putIfAbsent(path, status);\n+    if (!path.getName().equals(status.getName())) {\n+      throw new IllegalArgumentException(\n+          String.format(\"path name %s does not match ufs status name %s\",\n+              path.getName(), status.getName()));\n+    }\n+  }\n+\n+  /**\n+   * Add a parent-child mapping to the status cache.\n+   *\n+   * All child statuses added via this method will be available via {@link #getStatus(AlluxioURI)}.\n+   *\n+   * @param path the directory inode path which contains the children\n+   * @param children the children of the {@code path}\n+   * @throws IllegalArgumentException when {@code path} already exists or if any child already\n+   *                                  exists\n+   */\n+  public void addChildren(AlluxioURI path, Collection<UfsStatus> children) {\n+    UfsStatus status = mStatuses.get(path);\n+    // If this path doesn't yet exist, we can't keep track of the parent-child relationship\n+    // We can still add statuses to the cache regardless\n+    if (status != null) {\n+      mChildren.computeIfAbsent(path, ufsStatus -> new ConcurrentHashSet<>()).addAll(children);\n+    }\n+    children.forEach(child -> {\n+      AlluxioURI childPath = path.joinUnsafe(child.getName());\n+      addStatus(childPath, child);\n+    });\n+  }\n+\n+  /**\n+   * Remove a status from the cache.\n+   *\n+   *  Any children added to this status will remain in the cache.\n+   *\n+   * @param path the path corresponding to the {@link UfsStatus} to remove\n+   * @return the removed UfsStatus\n+   */\n+  public UfsStatus remove(AlluxioURI path) {\n+    UfsStatus removed = mStatuses.remove(path);\n+    if (removed == null) {\n+      return null;\n+    }\n+\n+    mChildren.remove(path); // ok if there aren't any children\n+    return removed;\n+  }\n+\n+  /**\n+   * Get the UfsStatus from a given AlluxioURI.\n+   *\n+   * @param path the path the retrieve\n+   * @return The corresponding {@link UfsStatus} or {@code null} if there is none stored\n+   */\n+  public UfsStatus getStatus(AlluxioURI path) {\n+    return mStatuses.get(path);\n+  }\n+\n+  /**\n+   * Fetches children of a given alluxio path, stores them in the cache, then returns them.\n+   *\n+   * Children can be returned in a few ways\n+   * 1. Children already exist in the internal index. We simply return them\n+   * 2. If children did not already exist in the index, then check if there was a scheduled\n+   * prefetch job running for this path. If so, wait for the job to finish and return the result.\n+   * 3. If no prefetch job, and children don't yet exist in the cache, then if the fallback\n+   * parameter is true, fetch them from the UFS and store them in the cache. Otherwise, simply\n+   * return null.\n+   *\n+   * @param path the Alluxio path to get the children of\n+   * @param mountTable the Alluxio mount table\n+   * @param useFallback whether or not to fall back to calling the UFS\n+   * @return child UFS statuses of the alluxio path, or null if no prefetch job and fallback\n+   *         specified as false\n+   * @throws InvalidPathException if the alluxio path can't be resolved to a UFS mount\n+   */\n+  @Nullable\n+  public Collection<UfsStatus> fetchChildrenIfAbsent(AlluxioURI path, MountTable mountTable,\n+      boolean useFallback)\n+      throws IOException, InvalidPathException {\n+    Collection<UfsStatus> children = getChildren(path);\n+    if (children != null) {\n+      return children;\n+    }\n+    Future<Collection<UfsStatus>> prefetchJob = mActivePrefetchJobs.remove(path);\n+    if (prefetchJob != null) {\n+      try {\n+        return prefetchJob.get();\n+      } catch (InterruptedException | ExecutionException e) {\n+        LOG.warn(\"Failed waiting to fetch children at {}\", path);\n+        if (e instanceof  InterruptedException) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aea2599ba2565e052e3871653282b3f22a325203"}, "originalPosition": 163}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMwMjA2Mw==", "bodyText": "hrmmm, is fute a real term? I am not familiar with it...", "url": "https://github.com/Alluxio/alluxio/pull/11204#discussion_r418302063", "createdAt": "2020-04-30T21:33:53Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/underfs/UfsStatusCache.java", "diffHunk": "@@ -0,0 +1,275 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.underfs;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.collections.ConcurrentHashSet;\n+import alluxio.exception.InvalidPathException;\n+import alluxio.master.file.meta.MountTable;\n+import alluxio.resource.CloseableResource;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nullable;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.RejectedExecutionException;\n+\n+/**\n+ * This class is a cache from an Alluxio namespace URI ({@link AlluxioURI}, i.e. /path/to/inode) to\n+ * UFS statuses.\n+ *\n+ * It also allows associating a path with child inodes, so that the statuses for a specific path can\n+ * be searched for later.\n+ */\n+public class UfsStatusCache {\n+  private static final Logger LOG = LoggerFactory.getLogger(UfsStatusCache.class);\n+\n+  private final ConcurrentHashMap<AlluxioURI, UfsStatus> mStatuses;\n+  private final ConcurrentHashMap<AlluxioURI, Future<Collection<UfsStatus>>> mActivePrefetchJobs;\n+  private final ConcurrentHashMap<AlluxioURI, Collection<UfsStatus>> mChildren;\n+  private final ExecutorService mPrefetchExecutor;\n+\n+  /**\n+   * Create a new instance of {@link UfsStatusCache}.\n+   *\n+   * @param prefetchExecutor the executor service used to prefetch statuses\n+   */\n+  public UfsStatusCache(@Nullable ExecutorService prefetchExecutor) {\n+    mStatuses = new ConcurrentHashMap<>();\n+    mChildren = new ConcurrentHashMap<>();\n+    mActivePrefetchJobs = new ConcurrentHashMap<>();\n+    mPrefetchExecutor = prefetchExecutor;\n+  }\n+\n+  /**\n+   * Add a new status to the cache.\n+   *\n+   * The last component of the path in the {@link AlluxioURI} must match the result of\n+   * {@link UfsStatus#getName()}. This method overrides any status currently cached for the same\n+   * URI.\n+   *\n+   * @param path the Alluxio path to key on\n+   * @param status the ufs status to store\n+   * @throws IllegalArgumentException if the status name doesn't match the final URI path component\n+   */\n+  public void addStatus(AlluxioURI path, UfsStatus status) {\n+    UfsStatus prev = mStatuses.putIfAbsent(path, status);\n+    if (!path.getName().equals(status.getName())) {\n+      throw new IllegalArgumentException(\n+          String.format(\"path name %s does not match ufs status name %s\",\n+              path.getName(), status.getName()));\n+    }\n+  }\n+\n+  /**\n+   * Add a parent-child mapping to the status cache.\n+   *\n+   * All child statuses added via this method will be available via {@link #getStatus(AlluxioURI)}.\n+   *\n+   * @param path the directory inode path which contains the children\n+   * @param children the children of the {@code path}\n+   * @throws IllegalArgumentException when {@code path} already exists or if any child already\n+   *                                  exists\n+   */\n+  public void addChildren(AlluxioURI path, Collection<UfsStatus> children) {\n+    UfsStatus status = mStatuses.get(path);\n+    // If this path doesn't yet exist, we can't keep track of the parent-child relationship\n+    // We can still add statuses to the cache regardless\n+    if (status != null) {\n+      mChildren.computeIfAbsent(path, ufsStatus -> new ConcurrentHashSet<>()).addAll(children);\n+    }\n+    children.forEach(child -> {\n+      AlluxioURI childPath = path.joinUnsafe(child.getName());\n+      addStatus(childPath, child);\n+    });\n+  }\n+\n+  /**\n+   * Remove a status from the cache.\n+   *\n+   *  Any children added to this status will remain in the cache.\n+   *\n+   * @param path the path corresponding to the {@link UfsStatus} to remove\n+   * @return the removed UfsStatus\n+   */\n+  public UfsStatus remove(AlluxioURI path) {\n+    UfsStatus removed = mStatuses.remove(path);\n+    if (removed == null) {\n+      return null;\n+    }\n+\n+    mChildren.remove(path); // ok if there aren't any children\n+    return removed;\n+  }\n+\n+  /**\n+   * Get the UfsStatus from a given AlluxioURI.\n+   *\n+   * @param path the path the retrieve\n+   * @return The corresponding {@link UfsStatus} or {@code null} if there is none stored\n+   */\n+  public UfsStatus getStatus(AlluxioURI path) {\n+    return mStatuses.get(path);\n+  }\n+\n+  /**\n+   * Fetches children of a given alluxio path, stores them in the cache, then returns them.\n+   *\n+   * Children can be returned in a few ways\n+   * 1. Children already exist in the internal index. We simply return them\n+   * 2. If children did not already exist in the index, then check if there was a scheduled\n+   * prefetch job running for this path. If so, wait for the job to finish and return the result.\n+   * 3. If no prefetch job, and children don't yet exist in the cache, then if the fallback\n+   * parameter is true, fetch them from the UFS and store them in the cache. Otherwise, simply\n+   * return null.\n+   *\n+   * @param path the Alluxio path to get the children of\n+   * @param mountTable the Alluxio mount table\n+   * @param useFallback whether or not to fall back to calling the UFS\n+   * @return child UFS statuses of the alluxio path, or null if no prefetch job and fallback\n+   *         specified as false\n+   * @throws InvalidPathException if the alluxio path can't be resolved to a UFS mount\n+   */\n+  @Nullable\n+  public Collection<UfsStatus> fetchChildrenIfAbsent(AlluxioURI path, MountTable mountTable,\n+      boolean useFallback)\n+      throws IOException, InvalidPathException {\n+    Collection<UfsStatus> children = getChildren(path);\n+    if (children != null) {\n+      return children;\n+    }\n+    Future<Collection<UfsStatus>> prefetchJob = mActivePrefetchJobs.remove(path);\n+    if (prefetchJob != null) {\n+      try {\n+        return prefetchJob.get();\n+      } catch (InterruptedException | ExecutionException e) {\n+        LOG.warn(\"Failed waiting to fetch children at {}\", path);\n+        if (e instanceof  InterruptedException) {\n+          Thread.currentThread().interrupt();\n+        }\n+        throw new IOException(e);\n+      }\n+    }\n+    if (useFallback) {\n+      return getChildrenIfAbsent(path, mountTable);\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * Fetches children of a given alluxio path stores them in the cache, then returns them.\n+   *\n+   * Will always return statuses from the UFS whether or not they exist in the cache, and whether\n+   * a prefetch job was scheduled or not.\n+   *\n+   * @param path the Alluxio path\n+   * @param mountTable the Alluxio mount table\n+   * @return child UFS statuses of the alluxio path\n+   * @throws InvalidPathException if the alluxio path can't be resolved to a UFS mount\n+   * @see {@link #fetchChildrenIfAbsent(AlluxioURI, MountTable, boolean)}\n+   */\n+  public Collection<UfsStatus> fetchChildrenIfAbsent(AlluxioURI path, MountTable mountTable)\n+      throws IOException, InvalidPathException {\n+    return fetchChildrenIfAbsent(path, mountTable, true);\n+  }\n+\n+  /**\n+   * Retrieves the child UFS statuses for a given path and stores them in the cache.\n+   *\n+   * This method first checks if the children have already been retrieved, and if not, then\n+   * retrieves them.\n+\n+   * @param path the path to get the children for\n+   * @param mountTable the Alluxio mount table\n+   * @return the child statuses that were stored in the cache, or null if the UFS couldn't list the\n+   *         statuses\n+   * @throws InvalidPathException when the table can't resolve the mount for the given URI\n+   */\n+  @Nullable\n+  private Collection<UfsStatus> getChildrenIfAbsent(AlluxioURI path, MountTable mountTable)\n+      throws InvalidPathException {\n+    Collection<UfsStatus> children = getChildren(path);\n+    if (children != null) {\n+      return children;\n+    }\n+    MountTable.Resolution resolution = mountTable.resolve(path);\n+    AlluxioURI ufsUri = resolution.getUri();\n+    try (CloseableResource<UnderFileSystem> ufsResource = resolution.acquireUfsResource()) {\n+      UnderFileSystem ufs = ufsResource.get();\n+      UfsStatus[] statuses = ufs.listStatus(ufsUri.toString());\n+      if (statuses == null) {\n+        return null;\n+      }\n+      children = Arrays.asList(statuses);\n+      addChildren(path, children);\n+    } catch (IllegalArgumentException | IOException e) {\n+      LOG.debug(\"Failed to add status to cache\", e);\n+    }\n+    return children;\n+  }\n+\n+  /**\n+   * Get the child {@link UfsStatus}es from a given {@link AlluxioURI}.\n+   *\n+   * @param path the path the retrieve\n+   * @return The corresponding {@link UfsStatus} or {@code null} if there is none stored\n+   */\n+  @Nullable\n+  public Collection<UfsStatus> getChildren(AlluxioURI path) {\n+    return mChildren.get(path);\n+  }\n+\n+  /**\n+   * Submit a request to asynchronously fetch the statuses corresponding to a given directory.\n+   *\n+   * Retrieve any fetched statuses by calling {@link #fetchChildrenIfAbsent(AlluxioURI, MountTable)}\n+   * with the same Alluxio path.\n+   *\n+   * If no {@link ExecutorService} was provided to this object before instantiation, this method is\n+   * a no-op.\n+   *\n+   * @param path the path to prefetch\n+   * @param mountTable the Alluxio mount table\n+   */\n+  public void prefetchChildren(AlluxioURI path, MountTable mountTable) {\n+    if (mPrefetchExecutor == null) {\n+      return;\n+    }\n+    try {\n+      Future<Collection<UfsStatus>> fute =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aea2599ba2565e052e3871653282b3f22a325203"}, "originalPosition": 255}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMwMjUyNg==", "bodyText": "Why cancel the old one? Could this cause an endless cycle of constantly cancelled tasks?", "url": "https://github.com/Alluxio/alluxio/pull/11204#discussion_r418302526", "createdAt": "2020-04-30T21:34:48Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/underfs/UfsStatusCache.java", "diffHunk": "@@ -0,0 +1,275 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.underfs;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.collections.ConcurrentHashSet;\n+import alluxio.exception.InvalidPathException;\n+import alluxio.master.file.meta.MountTable;\n+import alluxio.resource.CloseableResource;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nullable;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.RejectedExecutionException;\n+\n+/**\n+ * This class is a cache from an Alluxio namespace URI ({@link AlluxioURI}, i.e. /path/to/inode) to\n+ * UFS statuses.\n+ *\n+ * It also allows associating a path with child inodes, so that the statuses for a specific path can\n+ * be searched for later.\n+ */\n+public class UfsStatusCache {\n+  private static final Logger LOG = LoggerFactory.getLogger(UfsStatusCache.class);\n+\n+  private final ConcurrentHashMap<AlluxioURI, UfsStatus> mStatuses;\n+  private final ConcurrentHashMap<AlluxioURI, Future<Collection<UfsStatus>>> mActivePrefetchJobs;\n+  private final ConcurrentHashMap<AlluxioURI, Collection<UfsStatus>> mChildren;\n+  private final ExecutorService mPrefetchExecutor;\n+\n+  /**\n+   * Create a new instance of {@link UfsStatusCache}.\n+   *\n+   * @param prefetchExecutor the executor service used to prefetch statuses\n+   */\n+  public UfsStatusCache(@Nullable ExecutorService prefetchExecutor) {\n+    mStatuses = new ConcurrentHashMap<>();\n+    mChildren = new ConcurrentHashMap<>();\n+    mActivePrefetchJobs = new ConcurrentHashMap<>();\n+    mPrefetchExecutor = prefetchExecutor;\n+  }\n+\n+  /**\n+   * Add a new status to the cache.\n+   *\n+   * The last component of the path in the {@link AlluxioURI} must match the result of\n+   * {@link UfsStatus#getName()}. This method overrides any status currently cached for the same\n+   * URI.\n+   *\n+   * @param path the Alluxio path to key on\n+   * @param status the ufs status to store\n+   * @throws IllegalArgumentException if the status name doesn't match the final URI path component\n+   */\n+  public void addStatus(AlluxioURI path, UfsStatus status) {\n+    UfsStatus prev = mStatuses.putIfAbsent(path, status);\n+    if (!path.getName().equals(status.getName())) {\n+      throw new IllegalArgumentException(\n+          String.format(\"path name %s does not match ufs status name %s\",\n+              path.getName(), status.getName()));\n+    }\n+  }\n+\n+  /**\n+   * Add a parent-child mapping to the status cache.\n+   *\n+   * All child statuses added via this method will be available via {@link #getStatus(AlluxioURI)}.\n+   *\n+   * @param path the directory inode path which contains the children\n+   * @param children the children of the {@code path}\n+   * @throws IllegalArgumentException when {@code path} already exists or if any child already\n+   *                                  exists\n+   */\n+  public void addChildren(AlluxioURI path, Collection<UfsStatus> children) {\n+    UfsStatus status = mStatuses.get(path);\n+    // If this path doesn't yet exist, we can't keep track of the parent-child relationship\n+    // We can still add statuses to the cache regardless\n+    if (status != null) {\n+      mChildren.computeIfAbsent(path, ufsStatus -> new ConcurrentHashSet<>()).addAll(children);\n+    }\n+    children.forEach(child -> {\n+      AlluxioURI childPath = path.joinUnsafe(child.getName());\n+      addStatus(childPath, child);\n+    });\n+  }\n+\n+  /**\n+   * Remove a status from the cache.\n+   *\n+   *  Any children added to this status will remain in the cache.\n+   *\n+   * @param path the path corresponding to the {@link UfsStatus} to remove\n+   * @return the removed UfsStatus\n+   */\n+  public UfsStatus remove(AlluxioURI path) {\n+    UfsStatus removed = mStatuses.remove(path);\n+    if (removed == null) {\n+      return null;\n+    }\n+\n+    mChildren.remove(path); // ok if there aren't any children\n+    return removed;\n+  }\n+\n+  /**\n+   * Get the UfsStatus from a given AlluxioURI.\n+   *\n+   * @param path the path the retrieve\n+   * @return The corresponding {@link UfsStatus} or {@code null} if there is none stored\n+   */\n+  public UfsStatus getStatus(AlluxioURI path) {\n+    return mStatuses.get(path);\n+  }\n+\n+  /**\n+   * Fetches children of a given alluxio path, stores them in the cache, then returns them.\n+   *\n+   * Children can be returned in a few ways\n+   * 1. Children already exist in the internal index. We simply return them\n+   * 2. If children did not already exist in the index, then check if there was a scheduled\n+   * prefetch job running for this path. If so, wait for the job to finish and return the result.\n+   * 3. If no prefetch job, and children don't yet exist in the cache, then if the fallback\n+   * parameter is true, fetch them from the UFS and store them in the cache. Otherwise, simply\n+   * return null.\n+   *\n+   * @param path the Alluxio path to get the children of\n+   * @param mountTable the Alluxio mount table\n+   * @param useFallback whether or not to fall back to calling the UFS\n+   * @return child UFS statuses of the alluxio path, or null if no prefetch job and fallback\n+   *         specified as false\n+   * @throws InvalidPathException if the alluxio path can't be resolved to a UFS mount\n+   */\n+  @Nullable\n+  public Collection<UfsStatus> fetchChildrenIfAbsent(AlluxioURI path, MountTable mountTable,\n+      boolean useFallback)\n+      throws IOException, InvalidPathException {\n+    Collection<UfsStatus> children = getChildren(path);\n+    if (children != null) {\n+      return children;\n+    }\n+    Future<Collection<UfsStatus>> prefetchJob = mActivePrefetchJobs.remove(path);\n+    if (prefetchJob != null) {\n+      try {\n+        return prefetchJob.get();\n+      } catch (InterruptedException | ExecutionException e) {\n+        LOG.warn(\"Failed waiting to fetch children at {}\", path);\n+        if (e instanceof  InterruptedException) {\n+          Thread.currentThread().interrupt();\n+        }\n+        throw new IOException(e);\n+      }\n+    }\n+    if (useFallback) {\n+      return getChildrenIfAbsent(path, mountTable);\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * Fetches children of a given alluxio path stores them in the cache, then returns them.\n+   *\n+   * Will always return statuses from the UFS whether or not they exist in the cache, and whether\n+   * a prefetch job was scheduled or not.\n+   *\n+   * @param path the Alluxio path\n+   * @param mountTable the Alluxio mount table\n+   * @return child UFS statuses of the alluxio path\n+   * @throws InvalidPathException if the alluxio path can't be resolved to a UFS mount\n+   * @see {@link #fetchChildrenIfAbsent(AlluxioURI, MountTable, boolean)}\n+   */\n+  public Collection<UfsStatus> fetchChildrenIfAbsent(AlluxioURI path, MountTable mountTable)\n+      throws IOException, InvalidPathException {\n+    return fetchChildrenIfAbsent(path, mountTable, true);\n+  }\n+\n+  /**\n+   * Retrieves the child UFS statuses for a given path and stores them in the cache.\n+   *\n+   * This method first checks if the children have already been retrieved, and if not, then\n+   * retrieves them.\n+\n+   * @param path the path to get the children for\n+   * @param mountTable the Alluxio mount table\n+   * @return the child statuses that were stored in the cache, or null if the UFS couldn't list the\n+   *         statuses\n+   * @throws InvalidPathException when the table can't resolve the mount for the given URI\n+   */\n+  @Nullable\n+  private Collection<UfsStatus> getChildrenIfAbsent(AlluxioURI path, MountTable mountTable)\n+      throws InvalidPathException {\n+    Collection<UfsStatus> children = getChildren(path);\n+    if (children != null) {\n+      return children;\n+    }\n+    MountTable.Resolution resolution = mountTable.resolve(path);\n+    AlluxioURI ufsUri = resolution.getUri();\n+    try (CloseableResource<UnderFileSystem> ufsResource = resolution.acquireUfsResource()) {\n+      UnderFileSystem ufs = ufsResource.get();\n+      UfsStatus[] statuses = ufs.listStatus(ufsUri.toString());\n+      if (statuses == null) {\n+        return null;\n+      }\n+      children = Arrays.asList(statuses);\n+      addChildren(path, children);\n+    } catch (IllegalArgumentException | IOException e) {\n+      LOG.debug(\"Failed to add status to cache\", e);\n+    }\n+    return children;\n+  }\n+\n+  /**\n+   * Get the child {@link UfsStatus}es from a given {@link AlluxioURI}.\n+   *\n+   * @param path the path the retrieve\n+   * @return The corresponding {@link UfsStatus} or {@code null} if there is none stored\n+   */\n+  @Nullable\n+  public Collection<UfsStatus> getChildren(AlluxioURI path) {\n+    return mChildren.get(path);\n+  }\n+\n+  /**\n+   * Submit a request to asynchronously fetch the statuses corresponding to a given directory.\n+   *\n+   * Retrieve any fetched statuses by calling {@link #fetchChildrenIfAbsent(AlluxioURI, MountTable)}\n+   * with the same Alluxio path.\n+   *\n+   * If no {@link ExecutorService} was provided to this object before instantiation, this method is\n+   * a no-op.\n+   *\n+   * @param path the path to prefetch\n+   * @param mountTable the Alluxio mount table\n+   */\n+  public void prefetchChildren(AlluxioURI path, MountTable mountTable) {\n+    if (mPrefetchExecutor == null) {\n+      return;\n+    }\n+    try {\n+      Future<Collection<UfsStatus>> fute =\n+          mPrefetchExecutor.submit(() -> getChildrenIfAbsent(path, mountTable));\n+      Future<Collection<UfsStatus>> prev = mActivePrefetchJobs.put(path, fute);\n+      if (prev != null) {\n+        prev.cancel(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aea2599ba2565e052e3871653282b3f22a325203"}, "originalPosition": 259}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAzODk3MjA3", "url": "https://github.com/Alluxio/alluxio/pull/11204#pullrequestreview-403897207", "createdAt": "2020-04-30T21:40:38Z", "commit": {"oid": "aea2599ba2565e052e3871653282b3f22a325203"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQyMTo0MDozOFrOGO7UOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQyMjoxMToxNVrOGO8GwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMwNTA4Mw==", "bodyText": "call this forceSync?", "url": "https://github.com/Alluxio/alluxio/pull/11204#discussion_r418305083", "createdAt": "2020-04-30T21:40:38Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/master/file/InodeSyncStream.java", "diffHunk": "@@ -0,0 +1,810 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master.file;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.client.WriteType;\n+import alluxio.collections.Pair;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.exception.AccessControlException;\n+import alluxio.exception.BlockInfoException;\n+import alluxio.exception.DirectoryNotEmptyException;\n+import alluxio.exception.FileAlreadyCompletedException;\n+import alluxio.exception.FileAlreadyExistsException;\n+import alluxio.exception.FileDoesNotExistException;\n+import alluxio.exception.InvalidFileSizeException;\n+import alluxio.exception.InvalidPathException;\n+import alluxio.file.options.DescendantType;\n+import alluxio.grpc.CompleteFilePOptions;\n+import alluxio.grpc.DeletePOptions;\n+import alluxio.grpc.FileSystemMasterCommonPOptions;\n+import alluxio.grpc.GrpcUtils;\n+import alluxio.grpc.LoadDescendantPType;\n+import alluxio.grpc.LoadMetadataPOptions;\n+import alluxio.grpc.SetAttributePOptions;\n+import alluxio.master.file.contexts.CompleteFileContext;\n+import alluxio.master.file.contexts.CreateDirectoryContext;\n+import alluxio.master.file.contexts.CreateFileContext;\n+import alluxio.master.file.contexts.DeleteContext;\n+import alluxio.master.file.contexts.GetStatusContext;\n+import alluxio.master.file.contexts.LoadMetadataContext;\n+import alluxio.master.file.contexts.SetAttributeContext;\n+import alluxio.master.file.meta.Inode;\n+import alluxio.master.file.meta.InodeFile;\n+import alluxio.master.file.meta.InodeLockManager;\n+import alluxio.master.file.meta.InodeTree;\n+import alluxio.master.file.meta.InodeTree.LockPattern;\n+import alluxio.master.file.meta.LockedInodePath;\n+import alluxio.master.file.meta.LockingScheme;\n+import alluxio.master.file.meta.MountTable;\n+import alluxio.master.file.meta.UfsSyncPathCache;\n+import alluxio.master.file.meta.UfsSyncUtils;\n+import alluxio.master.metastore.ReadOnlyInodeStore;\n+import alluxio.resource.CloseableResource;\n+import alluxio.security.authorization.AccessControlList;\n+import alluxio.security.authorization.DefaultAccessControlList;\n+import alluxio.security.authorization.Mode;\n+import alluxio.underfs.Fingerprint;\n+import alluxio.underfs.UfsFileStatus;\n+import alluxio.underfs.UfsStatus;\n+import alluxio.underfs.UfsStatusCache;\n+import alluxio.underfs.UnderFileSystem;\n+import alluxio.util.interfaces.Scoped;\n+import alluxio.util.io.PathUtils;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+\n+/**\n+ * This class is responsible for maintaining the logic which surrounds syncing metadata between\n+ * Alluxio and its UFSes.\n+ *\n+ * This implementation uses a BFS-based approach to crawl the inode tree. In order to speed up\n+ * the sync process we use an {@link ExecutorService} which we submit inode paths to using\n+ * {@link #processSyncPath(AlluxioURI)}. The processing of inode paths will discover new paths to\n+ * sync depending on the {@link #mDescendantType}. Syncing is finished when all submitted tasks\n+ * are completed and there are no new inodes left in the queue.\n+ *\n+ * Syncing inode metadata requires making calls to the UFS. This implementation will schedule UFS\n+ * RPCs with the {@link UfsStatusCache#prefetchChildren(AlluxioURI, MountTable)}. Then, once the\n+ * inode begins processing, it can retrieve the results. After processing, it can then remove its\n+ * {@link UfsStatus} from the cache. This strategy helps reduce memory pressure on the master\n+ * while performing a sync for a large tree. Additionally, by using a prefetch mechanism we can\n+ * concurrently process other inodes while waiting for UFS RPCs to complete.\n+ *\n+ * With regards to locking, this class expects to be able to take a write lock on any inode, and\n+ * then subsequently downgrades or unlocks after the sync is finished. Even though we use\n+ * {@link java.util.concurrent.locks.ReentrantReadWriteLock}, because we concurrently process\n+ * inodes on separate threads, we cannot utilize the reetrnant behavior. The implications of\n+ * that mean the caller of this class must not hold a write while calling {@link #sync()}.\n+ *\n+ * A user of this class is expected to create a new instance for each path that they would like\n+ * to process. This is because the Lock on the {@link #mRootPath} may be changed after calling\n+ * {@link #sync()}.\n+ *\n+ */\n+public class InodeSyncStream {\n+  private static final Logger LOG = LoggerFactory.getLogger(InodeSyncStream.class);\n+\n+  /** The root path. Should be locked with a write lock. */\n+  private final LockedInodePath mRootPath;\n+\n+  /** A {@link UfsSyncPathCache} maintained from the {@link DefaultFileSystemMaster}. */\n+  private final UfsSyncPathCache mUfsSyncPathCache;\n+\n+  /** Object holding the {@link UfsStatus}es which may be required for syncing. */\n+  private final UfsStatusCache mStatusCache;\n+\n+  /** Inode tree to lock new paths. */\n+  private final InodeTree mInodeTree;\n+\n+  /** Determines how deep in the tree we need to load. */\n+  private final DescendantType mDescendantType;\n+\n+  /** The {@link RpcContext} from the caller. */\n+  private final RpcContext mRpcContext;\n+\n+  /** The inode store to look up children. */\n+  private final ReadOnlyInodeStore mInodeStore;\n+\n+  /** The mount table for looking up the proper UFS client based on the Alluxio path. */\n+  private final MountTable mMountTable;\n+\n+  /** The lock manager used to try acquiring the persisting lock. */\n+  private final InodeLockManager mInodeLockManager;\n+\n+  /** The FS master creating this object. */\n+  private final DefaultFileSystemMaster mFsMaster;\n+\n+  /** Set this to true to force a sync regardless of the UfsPathCache. */\n+  private final boolean mShouldSync;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aea2599ba2565e052e3871653282b3f22a325203"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMwNTg3Ng==", "bodyText": "Would pendingPaths is more descriptive?", "url": "https://github.com/Alluxio/alluxio/pull/11204#discussion_r418305876", "createdAt": "2020-04-30T21:42:30Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/master/file/InodeSyncStream.java", "diffHunk": "@@ -0,0 +1,810 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master.file;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.client.WriteType;\n+import alluxio.collections.Pair;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.exception.AccessControlException;\n+import alluxio.exception.BlockInfoException;\n+import alluxio.exception.DirectoryNotEmptyException;\n+import alluxio.exception.FileAlreadyCompletedException;\n+import alluxio.exception.FileAlreadyExistsException;\n+import alluxio.exception.FileDoesNotExistException;\n+import alluxio.exception.InvalidFileSizeException;\n+import alluxio.exception.InvalidPathException;\n+import alluxio.file.options.DescendantType;\n+import alluxio.grpc.CompleteFilePOptions;\n+import alluxio.grpc.DeletePOptions;\n+import alluxio.grpc.FileSystemMasterCommonPOptions;\n+import alluxio.grpc.GrpcUtils;\n+import alluxio.grpc.LoadDescendantPType;\n+import alluxio.grpc.LoadMetadataPOptions;\n+import alluxio.grpc.SetAttributePOptions;\n+import alluxio.master.file.contexts.CompleteFileContext;\n+import alluxio.master.file.contexts.CreateDirectoryContext;\n+import alluxio.master.file.contexts.CreateFileContext;\n+import alluxio.master.file.contexts.DeleteContext;\n+import alluxio.master.file.contexts.GetStatusContext;\n+import alluxio.master.file.contexts.LoadMetadataContext;\n+import alluxio.master.file.contexts.SetAttributeContext;\n+import alluxio.master.file.meta.Inode;\n+import alluxio.master.file.meta.InodeFile;\n+import alluxio.master.file.meta.InodeLockManager;\n+import alluxio.master.file.meta.InodeTree;\n+import alluxio.master.file.meta.InodeTree.LockPattern;\n+import alluxio.master.file.meta.LockedInodePath;\n+import alluxio.master.file.meta.LockingScheme;\n+import alluxio.master.file.meta.MountTable;\n+import alluxio.master.file.meta.UfsSyncPathCache;\n+import alluxio.master.file.meta.UfsSyncUtils;\n+import alluxio.master.metastore.ReadOnlyInodeStore;\n+import alluxio.resource.CloseableResource;\n+import alluxio.security.authorization.AccessControlList;\n+import alluxio.security.authorization.DefaultAccessControlList;\n+import alluxio.security.authorization.Mode;\n+import alluxio.underfs.Fingerprint;\n+import alluxio.underfs.UfsFileStatus;\n+import alluxio.underfs.UfsStatus;\n+import alluxio.underfs.UfsStatusCache;\n+import alluxio.underfs.UnderFileSystem;\n+import alluxio.util.interfaces.Scoped;\n+import alluxio.util.io.PathUtils;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+\n+/**\n+ * This class is responsible for maintaining the logic which surrounds syncing metadata between\n+ * Alluxio and its UFSes.\n+ *\n+ * This implementation uses a BFS-based approach to crawl the inode tree. In order to speed up\n+ * the sync process we use an {@link ExecutorService} which we submit inode paths to using\n+ * {@link #processSyncPath(AlluxioURI)}. The processing of inode paths will discover new paths to\n+ * sync depending on the {@link #mDescendantType}. Syncing is finished when all submitted tasks\n+ * are completed and there are no new inodes left in the queue.\n+ *\n+ * Syncing inode metadata requires making calls to the UFS. This implementation will schedule UFS\n+ * RPCs with the {@link UfsStatusCache#prefetchChildren(AlluxioURI, MountTable)}. Then, once the\n+ * inode begins processing, it can retrieve the results. After processing, it can then remove its\n+ * {@link UfsStatus} from the cache. This strategy helps reduce memory pressure on the master\n+ * while performing a sync for a large tree. Additionally, by using a prefetch mechanism we can\n+ * concurrently process other inodes while waiting for UFS RPCs to complete.\n+ *\n+ * With regards to locking, this class expects to be able to take a write lock on any inode, and\n+ * then subsequently downgrades or unlocks after the sync is finished. Even though we use\n+ * {@link java.util.concurrent.locks.ReentrantReadWriteLock}, because we concurrently process\n+ * inodes on separate threads, we cannot utilize the reetrnant behavior. The implications of\n+ * that mean the caller of this class must not hold a write while calling {@link #sync()}.\n+ *\n+ * A user of this class is expected to create a new instance for each path that they would like\n+ * to process. This is because the Lock on the {@link #mRootPath} may be changed after calling\n+ * {@link #sync()}.\n+ *\n+ */\n+public class InodeSyncStream {\n+  private static final Logger LOG = LoggerFactory.getLogger(InodeSyncStream.class);\n+\n+  /** The root path. Should be locked with a write lock. */\n+  private final LockedInodePath mRootPath;\n+\n+  /** A {@link UfsSyncPathCache} maintained from the {@link DefaultFileSystemMaster}. */\n+  private final UfsSyncPathCache mUfsSyncPathCache;\n+\n+  /** Object holding the {@link UfsStatus}es which may be required for syncing. */\n+  private final UfsStatusCache mStatusCache;\n+\n+  /** Inode tree to lock new paths. */\n+  private final InodeTree mInodeTree;\n+\n+  /** Determines how deep in the tree we need to load. */\n+  private final DescendantType mDescendantType;\n+\n+  /** The {@link RpcContext} from the caller. */\n+  private final RpcContext mRpcContext;\n+\n+  /** The inode store to look up children. */\n+  private final ReadOnlyInodeStore mInodeStore;\n+\n+  /** The mount table for looking up the proper UFS client based on the Alluxio path. */\n+  private final MountTable mMountTable;\n+\n+  /** The lock manager used to try acquiring the persisting lock. */\n+  private final InodeLockManager mInodeLockManager;\n+\n+  /** The FS master creating this object. */\n+  private final DefaultFileSystemMaster mFsMaster;\n+\n+  /** Set this to true to force a sync regardless of the UfsPathCache. */\n+  private final boolean mShouldSync;\n+\n+  /** The sync options on the RPC.  */\n+  private final FileSystemMasterCommonPOptions mSyncOptions;\n+\n+  /**\n+   * Whether the caller is {@link FileSystemMaster#getFileInfo(AlluxioURI, GetStatusContext)}.\n+   * This is used for the {@link #mUfsSyncPathCache}.\n+   */\n+  private final boolean mIsGetFileInfo;\n+\n+  /** Whether to only read+create metadata from the UFS, or to update metadata as well. */\n+  private final boolean mLoadOnly;\n+\n+  /** Queue used to keep track of paths that still need to be synced. */\n+  private final ConcurrentLinkedQueue<AlluxioURI> mSyncMetadataQ;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aea2599ba2565e052e3871653282b3f22a325203"}, "originalPosition": 158}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMxNTUwOA==", "bodyText": "Does this have to be all caps?", "url": "https://github.com/Alluxio/alluxio/pull/11204#discussion_r418315508", "createdAt": "2020-04-30T22:05:05Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/master/file/InodeSyncStream.java", "diffHunk": "@@ -0,0 +1,810 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master.file;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.client.WriteType;\n+import alluxio.collections.Pair;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.exception.AccessControlException;\n+import alluxio.exception.BlockInfoException;\n+import alluxio.exception.DirectoryNotEmptyException;\n+import alluxio.exception.FileAlreadyCompletedException;\n+import alluxio.exception.FileAlreadyExistsException;\n+import alluxio.exception.FileDoesNotExistException;\n+import alluxio.exception.InvalidFileSizeException;\n+import alluxio.exception.InvalidPathException;\n+import alluxio.file.options.DescendantType;\n+import alluxio.grpc.CompleteFilePOptions;\n+import alluxio.grpc.DeletePOptions;\n+import alluxio.grpc.FileSystemMasterCommonPOptions;\n+import alluxio.grpc.GrpcUtils;\n+import alluxio.grpc.LoadDescendantPType;\n+import alluxio.grpc.LoadMetadataPOptions;\n+import alluxio.grpc.SetAttributePOptions;\n+import alluxio.master.file.contexts.CompleteFileContext;\n+import alluxio.master.file.contexts.CreateDirectoryContext;\n+import alluxio.master.file.contexts.CreateFileContext;\n+import alluxio.master.file.contexts.DeleteContext;\n+import alluxio.master.file.contexts.GetStatusContext;\n+import alluxio.master.file.contexts.LoadMetadataContext;\n+import alluxio.master.file.contexts.SetAttributeContext;\n+import alluxio.master.file.meta.Inode;\n+import alluxio.master.file.meta.InodeFile;\n+import alluxio.master.file.meta.InodeLockManager;\n+import alluxio.master.file.meta.InodeTree;\n+import alluxio.master.file.meta.InodeTree.LockPattern;\n+import alluxio.master.file.meta.LockedInodePath;\n+import alluxio.master.file.meta.LockingScheme;\n+import alluxio.master.file.meta.MountTable;\n+import alluxio.master.file.meta.UfsSyncPathCache;\n+import alluxio.master.file.meta.UfsSyncUtils;\n+import alluxio.master.metastore.ReadOnlyInodeStore;\n+import alluxio.resource.CloseableResource;\n+import alluxio.security.authorization.AccessControlList;\n+import alluxio.security.authorization.DefaultAccessControlList;\n+import alluxio.security.authorization.Mode;\n+import alluxio.underfs.Fingerprint;\n+import alluxio.underfs.UfsFileStatus;\n+import alluxio.underfs.UfsStatus;\n+import alluxio.underfs.UfsStatusCache;\n+import alluxio.underfs.UnderFileSystem;\n+import alluxio.util.interfaces.Scoped;\n+import alluxio.util.io.PathUtils;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+\n+/**\n+ * This class is responsible for maintaining the logic which surrounds syncing metadata between\n+ * Alluxio and its UFSes.\n+ *\n+ * This implementation uses a BFS-based approach to crawl the inode tree. In order to speed up\n+ * the sync process we use an {@link ExecutorService} which we submit inode paths to using\n+ * {@link #processSyncPath(AlluxioURI)}. The processing of inode paths will discover new paths to\n+ * sync depending on the {@link #mDescendantType}. Syncing is finished when all submitted tasks\n+ * are completed and there are no new inodes left in the queue.\n+ *\n+ * Syncing inode metadata requires making calls to the UFS. This implementation will schedule UFS\n+ * RPCs with the {@link UfsStatusCache#prefetchChildren(AlluxioURI, MountTable)}. Then, once the\n+ * inode begins processing, it can retrieve the results. After processing, it can then remove its\n+ * {@link UfsStatus} from the cache. This strategy helps reduce memory pressure on the master\n+ * while performing a sync for a large tree. Additionally, by using a prefetch mechanism we can\n+ * concurrently process other inodes while waiting for UFS RPCs to complete.\n+ *\n+ * With regards to locking, this class expects to be able to take a write lock on any inode, and\n+ * then subsequently downgrades or unlocks after the sync is finished. Even though we use\n+ * {@link java.util.concurrent.locks.ReentrantReadWriteLock}, because we concurrently process\n+ * inodes on separate threads, we cannot utilize the reetrnant behavior. The implications of\n+ * that mean the caller of this class must not hold a write while calling {@link #sync()}.\n+ *\n+ * A user of this class is expected to create a new instance for each path that they would like\n+ * to process. This is because the Lock on the {@link #mRootPath} may be changed after calling\n+ * {@link #sync()}.\n+ *\n+ */\n+public class InodeSyncStream {\n+  private static final Logger LOG = LoggerFactory.getLogger(InodeSyncStream.class);\n+\n+  /** The root path. Should be locked with a write lock. */\n+  private final LockedInodePath mRootPath;\n+\n+  /** A {@link UfsSyncPathCache} maintained from the {@link DefaultFileSystemMaster}. */\n+  private final UfsSyncPathCache mUfsSyncPathCache;\n+\n+  /** Object holding the {@link UfsStatus}es which may be required for syncing. */\n+  private final UfsStatusCache mStatusCache;\n+\n+  /** Inode tree to lock new paths. */\n+  private final InodeTree mInodeTree;\n+\n+  /** Determines how deep in the tree we need to load. */\n+  private final DescendantType mDescendantType;\n+\n+  /** The {@link RpcContext} from the caller. */\n+  private final RpcContext mRpcContext;\n+\n+  /** The inode store to look up children. */\n+  private final ReadOnlyInodeStore mInodeStore;\n+\n+  /** The mount table for looking up the proper UFS client based on the Alluxio path. */\n+  private final MountTable mMountTable;\n+\n+  /** The lock manager used to try acquiring the persisting lock. */\n+  private final InodeLockManager mInodeLockManager;\n+\n+  /** The FS master creating this object. */\n+  private final DefaultFileSystemMaster mFsMaster;\n+\n+  /** Set this to true to force a sync regardless of the UfsPathCache. */\n+  private final boolean mShouldSync;\n+\n+  /** The sync options on the RPC.  */\n+  private final FileSystemMasterCommonPOptions mSyncOptions;\n+\n+  /**\n+   * Whether the caller is {@link FileSystemMaster#getFileInfo(AlluxioURI, GetStatusContext)}.\n+   * This is used for the {@link #mUfsSyncPathCache}.\n+   */\n+  private final boolean mIsGetFileInfo;\n+\n+  /** Whether to only read+create metadata from the UFS, or to update metadata as well. */\n+  private final boolean mLoadOnly;\n+\n+  /** Queue used to keep track of paths that still need to be synced. */\n+  private final ConcurrentLinkedQueue<AlluxioURI> mSyncMetadataQ;\n+\n+  /** Queue of paths that have been submitted to the executor. */\n+  private final Queue<Future<Boolean>> mSyncPathJobs;\n+\n+  /** The executor enabling concurrent processing. */\n+  private final ExecutorService mMetadataSyncService;\n+\n+  /** The maximum number of concurrent paths that can be syncing at any moment. */\n+  private final int mConcurrencyLevel =\n+      ServerConfiguration.getInt(PropertyKey.MASTER_METADATA_SYNC_CONCURRENCY_LEVEL);\n+\n+  /**\n+   * Create a new instance of {@link InodeSyncStream}.\n+   *\n+   * The root path should be already locked with {@link LockPattern#WRITE_EDGE} unless the user is\n+   * only planning on loading metadata. The desired pattern should always be\n+   * {@link LockPattern#READ}.\n+   *\n+   * It is an error to initiate sync without a WRITE_EDGE lock when loadOnly is {@code false}.\n+   * If loadOnly is set to {@code true}, then the the root path may have a read lock.\n+   *\n+   * @param rootPath The root path to begin syncing\n+   * @param concurrencyService executor used to process paths concurrently\n+   * @param fsMaster the {@link FileSystemMaster} calling this method\n+   * @param inodeTree the {@link InodeTree}\n+   * @param inodeStore the {@link alluxio.master.metastore.InodeStore}\n+   * @param inodeLockManager the {@link InodeLockManager}\n+   * @param mountTable the master's {@link MountTable}\n+   * @param rpcContext the caller's {@link RpcContext}\n+   * @param descendantType determines the number of descendant inodes to sync\n+   * @param ufsSyncPathCache the sync path cache to determine when inodes should be synced\n+   * @param options the RPC's {@link FileSystemMasterCommonPOptions}\n+   * @param isGetFileInfo whether the caller is {@link FileSystemMaster#getFileInfo}\n+   * @param forceSync whether to sync inode metadata no matter what\n+   * @param loadOnly whether to only load new metadata, rather than update existing metadata\n+   */\n+  public InodeSyncStream(LockedInodePath rootPath, ExecutorService concurrencyService,\n+      DefaultFileSystemMaster fsMaster, InodeTree inodeTree, ReadOnlyInodeStore inodeStore,\n+      InodeLockManager inodeLockManager, MountTable mountTable, RpcContext rpcContext,\n+      DescendantType descendantType, UfsSyncPathCache ufsSyncPathCache,\n+      FileSystemMasterCommonPOptions options, boolean isGetFileInfo, boolean forceSync,\n+      boolean loadOnly) {\n+    mDescendantType = descendantType;\n+    mFsMaster = fsMaster;\n+    mSyncMetadataQ = new ConcurrentLinkedQueue<>();\n+    mInodeLockManager = inodeLockManager;\n+    mInodeStore = inodeStore;\n+    mInodeTree = inodeTree;\n+    mMountTable = mountTable;\n+    mRpcContext = rpcContext;\n+    mStatusCache = new UfsStatusCache(fsMaster.mSyncPrefetchExecutor);\n+    mUfsSyncPathCache = ufsSyncPathCache;\n+    mShouldSync = forceSync;\n+    mRootPath = rootPath;\n+    mSyncOptions = options;\n+    mIsGetFileInfo = isGetFileInfo;\n+    mLoadOnly = loadOnly;\n+    mSyncPathJobs = new LinkedList<>();\n+    mMetadataSyncService = concurrencyService;\n+  }\n+\n+  /**\n+   * Sync the metadata according the the root path the stream was created with.\n+   *\n+   * @return true if at least one path was synced\n+   */\n+  public boolean sync() {\n+    // The high-level process for the syncing is:\n+    // 1. Given an Alluxio path, determine if it is not consistent with the corresponding UFS path.\n+    //     this means the UFS path does not exist, or has metadata which differs from Alluxio\n+    // 2. If only the metadata changed, update the inode with the new metadata\n+    // 3. If the path does not exist in the UFS, delete the inode in Alluxio\n+    // 4. If not deleted, load metadata from the UFS\n+    // 5. If a recursive sync, add children inodes to sync queue\n+    int syncPathCount = 0;\n+    int stopNum = -1; // stop syncing when we've processed this many paths. -1 for infinite\n+\n+    try {\n+      syncInodeMetadata(mRootPath);\n+      syncPathCount++;\n+      if (mDescendantType == DescendantType.ONE) {\n+        // If descendantType is ONE, then we shouldn't process any more paths except for those\n+        // currently in the queue\n+        stopNum = mSyncMetadataQ.size();\n+      }\n+\n+      // process the sync result for the original path\n+      try {\n+        mRootPath.traverse();\n+      } catch (InvalidPathException e) {\n+        throw new RuntimeException(e);\n+      }\n+    } catch (AccessControlException | BlockInfoException | FileAlreadyCompletedException\n+        | FileDoesNotExistException | InvalidFileSizeException | InvalidPathException\n+        | IOException e) {\n+      LOG.warn(\"FAILED TO SYNC METADATA: {}\", e.getMessage(), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aea2599ba2565e052e3871653282b3f22a325203"}, "originalPosition": 254}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMxNTgzMQ==", "bodyText": "why remove the status?", "url": "https://github.com/Alluxio/alluxio/pull/11204#discussion_r418315831", "createdAt": "2020-04-30T22:05:56Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/master/file/InodeSyncStream.java", "diffHunk": "@@ -0,0 +1,810 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master.file;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.client.WriteType;\n+import alluxio.collections.Pair;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.exception.AccessControlException;\n+import alluxio.exception.BlockInfoException;\n+import alluxio.exception.DirectoryNotEmptyException;\n+import alluxio.exception.FileAlreadyCompletedException;\n+import alluxio.exception.FileAlreadyExistsException;\n+import alluxio.exception.FileDoesNotExistException;\n+import alluxio.exception.InvalidFileSizeException;\n+import alluxio.exception.InvalidPathException;\n+import alluxio.file.options.DescendantType;\n+import alluxio.grpc.CompleteFilePOptions;\n+import alluxio.grpc.DeletePOptions;\n+import alluxio.grpc.FileSystemMasterCommonPOptions;\n+import alluxio.grpc.GrpcUtils;\n+import alluxio.grpc.LoadDescendantPType;\n+import alluxio.grpc.LoadMetadataPOptions;\n+import alluxio.grpc.SetAttributePOptions;\n+import alluxio.master.file.contexts.CompleteFileContext;\n+import alluxio.master.file.contexts.CreateDirectoryContext;\n+import alluxio.master.file.contexts.CreateFileContext;\n+import alluxio.master.file.contexts.DeleteContext;\n+import alluxio.master.file.contexts.GetStatusContext;\n+import alluxio.master.file.contexts.LoadMetadataContext;\n+import alluxio.master.file.contexts.SetAttributeContext;\n+import alluxio.master.file.meta.Inode;\n+import alluxio.master.file.meta.InodeFile;\n+import alluxio.master.file.meta.InodeLockManager;\n+import alluxio.master.file.meta.InodeTree;\n+import alluxio.master.file.meta.InodeTree.LockPattern;\n+import alluxio.master.file.meta.LockedInodePath;\n+import alluxio.master.file.meta.LockingScheme;\n+import alluxio.master.file.meta.MountTable;\n+import alluxio.master.file.meta.UfsSyncPathCache;\n+import alluxio.master.file.meta.UfsSyncUtils;\n+import alluxio.master.metastore.ReadOnlyInodeStore;\n+import alluxio.resource.CloseableResource;\n+import alluxio.security.authorization.AccessControlList;\n+import alluxio.security.authorization.DefaultAccessControlList;\n+import alluxio.security.authorization.Mode;\n+import alluxio.underfs.Fingerprint;\n+import alluxio.underfs.UfsFileStatus;\n+import alluxio.underfs.UfsStatus;\n+import alluxio.underfs.UfsStatusCache;\n+import alluxio.underfs.UnderFileSystem;\n+import alluxio.util.interfaces.Scoped;\n+import alluxio.util.io.PathUtils;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+\n+/**\n+ * This class is responsible for maintaining the logic which surrounds syncing metadata between\n+ * Alluxio and its UFSes.\n+ *\n+ * This implementation uses a BFS-based approach to crawl the inode tree. In order to speed up\n+ * the sync process we use an {@link ExecutorService} which we submit inode paths to using\n+ * {@link #processSyncPath(AlluxioURI)}. The processing of inode paths will discover new paths to\n+ * sync depending on the {@link #mDescendantType}. Syncing is finished when all submitted tasks\n+ * are completed and there are no new inodes left in the queue.\n+ *\n+ * Syncing inode metadata requires making calls to the UFS. This implementation will schedule UFS\n+ * RPCs with the {@link UfsStatusCache#prefetchChildren(AlluxioURI, MountTable)}. Then, once the\n+ * inode begins processing, it can retrieve the results. After processing, it can then remove its\n+ * {@link UfsStatus} from the cache. This strategy helps reduce memory pressure on the master\n+ * while performing a sync for a large tree. Additionally, by using a prefetch mechanism we can\n+ * concurrently process other inodes while waiting for UFS RPCs to complete.\n+ *\n+ * With regards to locking, this class expects to be able to take a write lock on any inode, and\n+ * then subsequently downgrades or unlocks after the sync is finished. Even though we use\n+ * {@link java.util.concurrent.locks.ReentrantReadWriteLock}, because we concurrently process\n+ * inodes on separate threads, we cannot utilize the reetrnant behavior. The implications of\n+ * that mean the caller of this class must not hold a write while calling {@link #sync()}.\n+ *\n+ * A user of this class is expected to create a new instance for each path that they would like\n+ * to process. This is because the Lock on the {@link #mRootPath} may be changed after calling\n+ * {@link #sync()}.\n+ *\n+ */\n+public class InodeSyncStream {\n+  private static final Logger LOG = LoggerFactory.getLogger(InodeSyncStream.class);\n+\n+  /** The root path. Should be locked with a write lock. */\n+  private final LockedInodePath mRootPath;\n+\n+  /** A {@link UfsSyncPathCache} maintained from the {@link DefaultFileSystemMaster}. */\n+  private final UfsSyncPathCache mUfsSyncPathCache;\n+\n+  /** Object holding the {@link UfsStatus}es which may be required for syncing. */\n+  private final UfsStatusCache mStatusCache;\n+\n+  /** Inode tree to lock new paths. */\n+  private final InodeTree mInodeTree;\n+\n+  /** Determines how deep in the tree we need to load. */\n+  private final DescendantType mDescendantType;\n+\n+  /** The {@link RpcContext} from the caller. */\n+  private final RpcContext mRpcContext;\n+\n+  /** The inode store to look up children. */\n+  private final ReadOnlyInodeStore mInodeStore;\n+\n+  /** The mount table for looking up the proper UFS client based on the Alluxio path. */\n+  private final MountTable mMountTable;\n+\n+  /** The lock manager used to try acquiring the persisting lock. */\n+  private final InodeLockManager mInodeLockManager;\n+\n+  /** The FS master creating this object. */\n+  private final DefaultFileSystemMaster mFsMaster;\n+\n+  /** Set this to true to force a sync regardless of the UfsPathCache. */\n+  private final boolean mShouldSync;\n+\n+  /** The sync options on the RPC.  */\n+  private final FileSystemMasterCommonPOptions mSyncOptions;\n+\n+  /**\n+   * Whether the caller is {@link FileSystemMaster#getFileInfo(AlluxioURI, GetStatusContext)}.\n+   * This is used for the {@link #mUfsSyncPathCache}.\n+   */\n+  private final boolean mIsGetFileInfo;\n+\n+  /** Whether to only read+create metadata from the UFS, or to update metadata as well. */\n+  private final boolean mLoadOnly;\n+\n+  /** Queue used to keep track of paths that still need to be synced. */\n+  private final ConcurrentLinkedQueue<AlluxioURI> mSyncMetadataQ;\n+\n+  /** Queue of paths that have been submitted to the executor. */\n+  private final Queue<Future<Boolean>> mSyncPathJobs;\n+\n+  /** The executor enabling concurrent processing. */\n+  private final ExecutorService mMetadataSyncService;\n+\n+  /** The maximum number of concurrent paths that can be syncing at any moment. */\n+  private final int mConcurrencyLevel =\n+      ServerConfiguration.getInt(PropertyKey.MASTER_METADATA_SYNC_CONCURRENCY_LEVEL);\n+\n+  /**\n+   * Create a new instance of {@link InodeSyncStream}.\n+   *\n+   * The root path should be already locked with {@link LockPattern#WRITE_EDGE} unless the user is\n+   * only planning on loading metadata. The desired pattern should always be\n+   * {@link LockPattern#READ}.\n+   *\n+   * It is an error to initiate sync without a WRITE_EDGE lock when loadOnly is {@code false}.\n+   * If loadOnly is set to {@code true}, then the the root path may have a read lock.\n+   *\n+   * @param rootPath The root path to begin syncing\n+   * @param concurrencyService executor used to process paths concurrently\n+   * @param fsMaster the {@link FileSystemMaster} calling this method\n+   * @param inodeTree the {@link InodeTree}\n+   * @param inodeStore the {@link alluxio.master.metastore.InodeStore}\n+   * @param inodeLockManager the {@link InodeLockManager}\n+   * @param mountTable the master's {@link MountTable}\n+   * @param rpcContext the caller's {@link RpcContext}\n+   * @param descendantType determines the number of descendant inodes to sync\n+   * @param ufsSyncPathCache the sync path cache to determine when inodes should be synced\n+   * @param options the RPC's {@link FileSystemMasterCommonPOptions}\n+   * @param isGetFileInfo whether the caller is {@link FileSystemMaster#getFileInfo}\n+   * @param forceSync whether to sync inode metadata no matter what\n+   * @param loadOnly whether to only load new metadata, rather than update existing metadata\n+   */\n+  public InodeSyncStream(LockedInodePath rootPath, ExecutorService concurrencyService,\n+      DefaultFileSystemMaster fsMaster, InodeTree inodeTree, ReadOnlyInodeStore inodeStore,\n+      InodeLockManager inodeLockManager, MountTable mountTable, RpcContext rpcContext,\n+      DescendantType descendantType, UfsSyncPathCache ufsSyncPathCache,\n+      FileSystemMasterCommonPOptions options, boolean isGetFileInfo, boolean forceSync,\n+      boolean loadOnly) {\n+    mDescendantType = descendantType;\n+    mFsMaster = fsMaster;\n+    mSyncMetadataQ = new ConcurrentLinkedQueue<>();\n+    mInodeLockManager = inodeLockManager;\n+    mInodeStore = inodeStore;\n+    mInodeTree = inodeTree;\n+    mMountTable = mountTable;\n+    mRpcContext = rpcContext;\n+    mStatusCache = new UfsStatusCache(fsMaster.mSyncPrefetchExecutor);\n+    mUfsSyncPathCache = ufsSyncPathCache;\n+    mShouldSync = forceSync;\n+    mRootPath = rootPath;\n+    mSyncOptions = options;\n+    mIsGetFileInfo = isGetFileInfo;\n+    mLoadOnly = loadOnly;\n+    mSyncPathJobs = new LinkedList<>();\n+    mMetadataSyncService = concurrencyService;\n+  }\n+\n+  /**\n+   * Sync the metadata according the the root path the stream was created with.\n+   *\n+   * @return true if at least one path was synced\n+   */\n+  public boolean sync() {\n+    // The high-level process for the syncing is:\n+    // 1. Given an Alluxio path, determine if it is not consistent with the corresponding UFS path.\n+    //     this means the UFS path does not exist, or has metadata which differs from Alluxio\n+    // 2. If only the metadata changed, update the inode with the new metadata\n+    // 3. If the path does not exist in the UFS, delete the inode in Alluxio\n+    // 4. If not deleted, load metadata from the UFS\n+    // 5. If a recursive sync, add children inodes to sync queue\n+    int syncPathCount = 0;\n+    int stopNum = -1; // stop syncing when we've processed this many paths. -1 for infinite\n+\n+    try {\n+      syncInodeMetadata(mRootPath);\n+      syncPathCount++;\n+      if (mDescendantType == DescendantType.ONE) {\n+        // If descendantType is ONE, then we shouldn't process any more paths except for those\n+        // currently in the queue\n+        stopNum = mSyncMetadataQ.size();\n+      }\n+\n+      // process the sync result for the original path\n+      try {\n+        mRootPath.traverse();\n+      } catch (InvalidPathException e) {\n+        throw new RuntimeException(e);\n+      }\n+    } catch (AccessControlException | BlockInfoException | FileAlreadyCompletedException\n+        | FileDoesNotExistException | InvalidFileSizeException | InvalidPathException\n+        | IOException e) {\n+      LOG.warn(\"FAILED TO SYNC METADATA: {}\", e.getMessage(), e);\n+    } finally {\n+      // regardless of the outcome, remove the UfsStatus for this path from the cache\n+      mStatusCache.remove(mRootPath.getUri());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aea2599ba2565e052e3871653282b3f22a325203"}, "originalPosition": 257}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMxNjEwMQ==", "bodyText": "Please add the root path to message", "url": "https://github.com/Alluxio/alluxio/pull/11204#discussion_r418316101", "createdAt": "2020-04-30T22:06:33Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/master/file/InodeSyncStream.java", "diffHunk": "@@ -0,0 +1,810 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master.file;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.client.WriteType;\n+import alluxio.collections.Pair;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.exception.AccessControlException;\n+import alluxio.exception.BlockInfoException;\n+import alluxio.exception.DirectoryNotEmptyException;\n+import alluxio.exception.FileAlreadyCompletedException;\n+import alluxio.exception.FileAlreadyExistsException;\n+import alluxio.exception.FileDoesNotExistException;\n+import alluxio.exception.InvalidFileSizeException;\n+import alluxio.exception.InvalidPathException;\n+import alluxio.file.options.DescendantType;\n+import alluxio.grpc.CompleteFilePOptions;\n+import alluxio.grpc.DeletePOptions;\n+import alluxio.grpc.FileSystemMasterCommonPOptions;\n+import alluxio.grpc.GrpcUtils;\n+import alluxio.grpc.LoadDescendantPType;\n+import alluxio.grpc.LoadMetadataPOptions;\n+import alluxio.grpc.SetAttributePOptions;\n+import alluxio.master.file.contexts.CompleteFileContext;\n+import alluxio.master.file.contexts.CreateDirectoryContext;\n+import alluxio.master.file.contexts.CreateFileContext;\n+import alluxio.master.file.contexts.DeleteContext;\n+import alluxio.master.file.contexts.GetStatusContext;\n+import alluxio.master.file.contexts.LoadMetadataContext;\n+import alluxio.master.file.contexts.SetAttributeContext;\n+import alluxio.master.file.meta.Inode;\n+import alluxio.master.file.meta.InodeFile;\n+import alluxio.master.file.meta.InodeLockManager;\n+import alluxio.master.file.meta.InodeTree;\n+import alluxio.master.file.meta.InodeTree.LockPattern;\n+import alluxio.master.file.meta.LockedInodePath;\n+import alluxio.master.file.meta.LockingScheme;\n+import alluxio.master.file.meta.MountTable;\n+import alluxio.master.file.meta.UfsSyncPathCache;\n+import alluxio.master.file.meta.UfsSyncUtils;\n+import alluxio.master.metastore.ReadOnlyInodeStore;\n+import alluxio.resource.CloseableResource;\n+import alluxio.security.authorization.AccessControlList;\n+import alluxio.security.authorization.DefaultAccessControlList;\n+import alluxio.security.authorization.Mode;\n+import alluxio.underfs.Fingerprint;\n+import alluxio.underfs.UfsFileStatus;\n+import alluxio.underfs.UfsStatus;\n+import alluxio.underfs.UfsStatusCache;\n+import alluxio.underfs.UnderFileSystem;\n+import alluxio.util.interfaces.Scoped;\n+import alluxio.util.io.PathUtils;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+\n+/**\n+ * This class is responsible for maintaining the logic which surrounds syncing metadata between\n+ * Alluxio and its UFSes.\n+ *\n+ * This implementation uses a BFS-based approach to crawl the inode tree. In order to speed up\n+ * the sync process we use an {@link ExecutorService} which we submit inode paths to using\n+ * {@link #processSyncPath(AlluxioURI)}. The processing of inode paths will discover new paths to\n+ * sync depending on the {@link #mDescendantType}. Syncing is finished when all submitted tasks\n+ * are completed and there are no new inodes left in the queue.\n+ *\n+ * Syncing inode metadata requires making calls to the UFS. This implementation will schedule UFS\n+ * RPCs with the {@link UfsStatusCache#prefetchChildren(AlluxioURI, MountTable)}. Then, once the\n+ * inode begins processing, it can retrieve the results. After processing, it can then remove its\n+ * {@link UfsStatus} from the cache. This strategy helps reduce memory pressure on the master\n+ * while performing a sync for a large tree. Additionally, by using a prefetch mechanism we can\n+ * concurrently process other inodes while waiting for UFS RPCs to complete.\n+ *\n+ * With regards to locking, this class expects to be able to take a write lock on any inode, and\n+ * then subsequently downgrades or unlocks after the sync is finished. Even though we use\n+ * {@link java.util.concurrent.locks.ReentrantReadWriteLock}, because we concurrently process\n+ * inodes on separate threads, we cannot utilize the reetrnant behavior. The implications of\n+ * that mean the caller of this class must not hold a write while calling {@link #sync()}.\n+ *\n+ * A user of this class is expected to create a new instance for each path that they would like\n+ * to process. This is because the Lock on the {@link #mRootPath} may be changed after calling\n+ * {@link #sync()}.\n+ *\n+ */\n+public class InodeSyncStream {\n+  private static final Logger LOG = LoggerFactory.getLogger(InodeSyncStream.class);\n+\n+  /** The root path. Should be locked with a write lock. */\n+  private final LockedInodePath mRootPath;\n+\n+  /** A {@link UfsSyncPathCache} maintained from the {@link DefaultFileSystemMaster}. */\n+  private final UfsSyncPathCache mUfsSyncPathCache;\n+\n+  /** Object holding the {@link UfsStatus}es which may be required for syncing. */\n+  private final UfsStatusCache mStatusCache;\n+\n+  /** Inode tree to lock new paths. */\n+  private final InodeTree mInodeTree;\n+\n+  /** Determines how deep in the tree we need to load. */\n+  private final DescendantType mDescendantType;\n+\n+  /** The {@link RpcContext} from the caller. */\n+  private final RpcContext mRpcContext;\n+\n+  /** The inode store to look up children. */\n+  private final ReadOnlyInodeStore mInodeStore;\n+\n+  /** The mount table for looking up the proper UFS client based on the Alluxio path. */\n+  private final MountTable mMountTable;\n+\n+  /** The lock manager used to try acquiring the persisting lock. */\n+  private final InodeLockManager mInodeLockManager;\n+\n+  /** The FS master creating this object. */\n+  private final DefaultFileSystemMaster mFsMaster;\n+\n+  /** Set this to true to force a sync regardless of the UfsPathCache. */\n+  private final boolean mShouldSync;\n+\n+  /** The sync options on the RPC.  */\n+  private final FileSystemMasterCommonPOptions mSyncOptions;\n+\n+  /**\n+   * Whether the caller is {@link FileSystemMaster#getFileInfo(AlluxioURI, GetStatusContext)}.\n+   * This is used for the {@link #mUfsSyncPathCache}.\n+   */\n+  private final boolean mIsGetFileInfo;\n+\n+  /** Whether to only read+create metadata from the UFS, or to update metadata as well. */\n+  private final boolean mLoadOnly;\n+\n+  /** Queue used to keep track of paths that still need to be synced. */\n+  private final ConcurrentLinkedQueue<AlluxioURI> mSyncMetadataQ;\n+\n+  /** Queue of paths that have been submitted to the executor. */\n+  private final Queue<Future<Boolean>> mSyncPathJobs;\n+\n+  /** The executor enabling concurrent processing. */\n+  private final ExecutorService mMetadataSyncService;\n+\n+  /** The maximum number of concurrent paths that can be syncing at any moment. */\n+  private final int mConcurrencyLevel =\n+      ServerConfiguration.getInt(PropertyKey.MASTER_METADATA_SYNC_CONCURRENCY_LEVEL);\n+\n+  /**\n+   * Create a new instance of {@link InodeSyncStream}.\n+   *\n+   * The root path should be already locked with {@link LockPattern#WRITE_EDGE} unless the user is\n+   * only planning on loading metadata. The desired pattern should always be\n+   * {@link LockPattern#READ}.\n+   *\n+   * It is an error to initiate sync without a WRITE_EDGE lock when loadOnly is {@code false}.\n+   * If loadOnly is set to {@code true}, then the the root path may have a read lock.\n+   *\n+   * @param rootPath The root path to begin syncing\n+   * @param concurrencyService executor used to process paths concurrently\n+   * @param fsMaster the {@link FileSystemMaster} calling this method\n+   * @param inodeTree the {@link InodeTree}\n+   * @param inodeStore the {@link alluxio.master.metastore.InodeStore}\n+   * @param inodeLockManager the {@link InodeLockManager}\n+   * @param mountTable the master's {@link MountTable}\n+   * @param rpcContext the caller's {@link RpcContext}\n+   * @param descendantType determines the number of descendant inodes to sync\n+   * @param ufsSyncPathCache the sync path cache to determine when inodes should be synced\n+   * @param options the RPC's {@link FileSystemMasterCommonPOptions}\n+   * @param isGetFileInfo whether the caller is {@link FileSystemMaster#getFileInfo}\n+   * @param forceSync whether to sync inode metadata no matter what\n+   * @param loadOnly whether to only load new metadata, rather than update existing metadata\n+   */\n+  public InodeSyncStream(LockedInodePath rootPath, ExecutorService concurrencyService,\n+      DefaultFileSystemMaster fsMaster, InodeTree inodeTree, ReadOnlyInodeStore inodeStore,\n+      InodeLockManager inodeLockManager, MountTable mountTable, RpcContext rpcContext,\n+      DescendantType descendantType, UfsSyncPathCache ufsSyncPathCache,\n+      FileSystemMasterCommonPOptions options, boolean isGetFileInfo, boolean forceSync,\n+      boolean loadOnly) {\n+    mDescendantType = descendantType;\n+    mFsMaster = fsMaster;\n+    mSyncMetadataQ = new ConcurrentLinkedQueue<>();\n+    mInodeLockManager = inodeLockManager;\n+    mInodeStore = inodeStore;\n+    mInodeTree = inodeTree;\n+    mMountTable = mountTable;\n+    mRpcContext = rpcContext;\n+    mStatusCache = new UfsStatusCache(fsMaster.mSyncPrefetchExecutor);\n+    mUfsSyncPathCache = ufsSyncPathCache;\n+    mShouldSync = forceSync;\n+    mRootPath = rootPath;\n+    mSyncOptions = options;\n+    mIsGetFileInfo = isGetFileInfo;\n+    mLoadOnly = loadOnly;\n+    mSyncPathJobs = new LinkedList<>();\n+    mMetadataSyncService = concurrencyService;\n+  }\n+\n+  /**\n+   * Sync the metadata according the the root path the stream was created with.\n+   *\n+   * @return true if at least one path was synced\n+   */\n+  public boolean sync() {\n+    // The high-level process for the syncing is:\n+    // 1. Given an Alluxio path, determine if it is not consistent with the corresponding UFS path.\n+    //     this means the UFS path does not exist, or has metadata which differs from Alluxio\n+    // 2. If only the metadata changed, update the inode with the new metadata\n+    // 3. If the path does not exist in the UFS, delete the inode in Alluxio\n+    // 4. If not deleted, load metadata from the UFS\n+    // 5. If a recursive sync, add children inodes to sync queue\n+    int syncPathCount = 0;\n+    int stopNum = -1; // stop syncing when we've processed this many paths. -1 for infinite\n+\n+    try {\n+      syncInodeMetadata(mRootPath);\n+      syncPathCount++;\n+      if (mDescendantType == DescendantType.ONE) {\n+        // If descendantType is ONE, then we shouldn't process any more paths except for those\n+        // currently in the queue\n+        stopNum = mSyncMetadataQ.size();\n+      }\n+\n+      // process the sync result for the original path\n+      try {\n+        mRootPath.traverse();\n+      } catch (InvalidPathException e) {\n+        throw new RuntimeException(e);\n+      }\n+    } catch (AccessControlException | BlockInfoException | FileAlreadyCompletedException\n+        | FileDoesNotExistException | InvalidFileSizeException | InvalidPathException\n+        | IOException e) {\n+      LOG.warn(\"FAILED TO SYNC METADATA: {}\", e.getMessage(), e);\n+    } finally {\n+      // regardless of the outcome, remove the UfsStatus for this path from the cache\n+      mStatusCache.remove(mRootPath.getUri());\n+      // downgrade so that if operations are parallelized, the lock on the root doesn't restrict\n+      // concurrent operations\n+      mRootPath.downgradeToPattern(LockPattern.READ);\n+    }\n+\n+    // Process any children after the root.\n+    while (!mSyncMetadataQ.isEmpty() || !mSyncPathJobs.isEmpty()) {\n+      if (Thread.currentThread().isInterrupted()) {\n+        LOG.warn(\"Metadata syncing was interrupted before completion\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aea2599ba2565e052e3871653282b3f22a325203"}, "originalPosition": 266}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMxNjUxNQ==", "bodyText": "Please add root path to message", "url": "https://github.com/Alluxio/alluxio/pull/11204#discussion_r418316515", "createdAt": "2020-04-30T22:07:32Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/master/file/InodeSyncStream.java", "diffHunk": "@@ -0,0 +1,810 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master.file;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.client.WriteType;\n+import alluxio.collections.Pair;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.exception.AccessControlException;\n+import alluxio.exception.BlockInfoException;\n+import alluxio.exception.DirectoryNotEmptyException;\n+import alluxio.exception.FileAlreadyCompletedException;\n+import alluxio.exception.FileAlreadyExistsException;\n+import alluxio.exception.FileDoesNotExistException;\n+import alluxio.exception.InvalidFileSizeException;\n+import alluxio.exception.InvalidPathException;\n+import alluxio.file.options.DescendantType;\n+import alluxio.grpc.CompleteFilePOptions;\n+import alluxio.grpc.DeletePOptions;\n+import alluxio.grpc.FileSystemMasterCommonPOptions;\n+import alluxio.grpc.GrpcUtils;\n+import alluxio.grpc.LoadDescendantPType;\n+import alluxio.grpc.LoadMetadataPOptions;\n+import alluxio.grpc.SetAttributePOptions;\n+import alluxio.master.file.contexts.CompleteFileContext;\n+import alluxio.master.file.contexts.CreateDirectoryContext;\n+import alluxio.master.file.contexts.CreateFileContext;\n+import alluxio.master.file.contexts.DeleteContext;\n+import alluxio.master.file.contexts.GetStatusContext;\n+import alluxio.master.file.contexts.LoadMetadataContext;\n+import alluxio.master.file.contexts.SetAttributeContext;\n+import alluxio.master.file.meta.Inode;\n+import alluxio.master.file.meta.InodeFile;\n+import alluxio.master.file.meta.InodeLockManager;\n+import alluxio.master.file.meta.InodeTree;\n+import alluxio.master.file.meta.InodeTree.LockPattern;\n+import alluxio.master.file.meta.LockedInodePath;\n+import alluxio.master.file.meta.LockingScheme;\n+import alluxio.master.file.meta.MountTable;\n+import alluxio.master.file.meta.UfsSyncPathCache;\n+import alluxio.master.file.meta.UfsSyncUtils;\n+import alluxio.master.metastore.ReadOnlyInodeStore;\n+import alluxio.resource.CloseableResource;\n+import alluxio.security.authorization.AccessControlList;\n+import alluxio.security.authorization.DefaultAccessControlList;\n+import alluxio.security.authorization.Mode;\n+import alluxio.underfs.Fingerprint;\n+import alluxio.underfs.UfsFileStatus;\n+import alluxio.underfs.UfsStatus;\n+import alluxio.underfs.UfsStatusCache;\n+import alluxio.underfs.UnderFileSystem;\n+import alluxio.util.interfaces.Scoped;\n+import alluxio.util.io.PathUtils;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+\n+/**\n+ * This class is responsible for maintaining the logic which surrounds syncing metadata between\n+ * Alluxio and its UFSes.\n+ *\n+ * This implementation uses a BFS-based approach to crawl the inode tree. In order to speed up\n+ * the sync process we use an {@link ExecutorService} which we submit inode paths to using\n+ * {@link #processSyncPath(AlluxioURI)}. The processing of inode paths will discover new paths to\n+ * sync depending on the {@link #mDescendantType}. Syncing is finished when all submitted tasks\n+ * are completed and there are no new inodes left in the queue.\n+ *\n+ * Syncing inode metadata requires making calls to the UFS. This implementation will schedule UFS\n+ * RPCs with the {@link UfsStatusCache#prefetchChildren(AlluxioURI, MountTable)}. Then, once the\n+ * inode begins processing, it can retrieve the results. After processing, it can then remove its\n+ * {@link UfsStatus} from the cache. This strategy helps reduce memory pressure on the master\n+ * while performing a sync for a large tree. Additionally, by using a prefetch mechanism we can\n+ * concurrently process other inodes while waiting for UFS RPCs to complete.\n+ *\n+ * With regards to locking, this class expects to be able to take a write lock on any inode, and\n+ * then subsequently downgrades or unlocks after the sync is finished. Even though we use\n+ * {@link java.util.concurrent.locks.ReentrantReadWriteLock}, because we concurrently process\n+ * inodes on separate threads, we cannot utilize the reetrnant behavior. The implications of\n+ * that mean the caller of this class must not hold a write while calling {@link #sync()}.\n+ *\n+ * A user of this class is expected to create a new instance for each path that they would like\n+ * to process. This is because the Lock on the {@link #mRootPath} may be changed after calling\n+ * {@link #sync()}.\n+ *\n+ */\n+public class InodeSyncStream {\n+  private static final Logger LOG = LoggerFactory.getLogger(InodeSyncStream.class);\n+\n+  /** The root path. Should be locked with a write lock. */\n+  private final LockedInodePath mRootPath;\n+\n+  /** A {@link UfsSyncPathCache} maintained from the {@link DefaultFileSystemMaster}. */\n+  private final UfsSyncPathCache mUfsSyncPathCache;\n+\n+  /** Object holding the {@link UfsStatus}es which may be required for syncing. */\n+  private final UfsStatusCache mStatusCache;\n+\n+  /** Inode tree to lock new paths. */\n+  private final InodeTree mInodeTree;\n+\n+  /** Determines how deep in the tree we need to load. */\n+  private final DescendantType mDescendantType;\n+\n+  /** The {@link RpcContext} from the caller. */\n+  private final RpcContext mRpcContext;\n+\n+  /** The inode store to look up children. */\n+  private final ReadOnlyInodeStore mInodeStore;\n+\n+  /** The mount table for looking up the proper UFS client based on the Alluxio path. */\n+  private final MountTable mMountTable;\n+\n+  /** The lock manager used to try acquiring the persisting lock. */\n+  private final InodeLockManager mInodeLockManager;\n+\n+  /** The FS master creating this object. */\n+  private final DefaultFileSystemMaster mFsMaster;\n+\n+  /** Set this to true to force a sync regardless of the UfsPathCache. */\n+  private final boolean mShouldSync;\n+\n+  /** The sync options on the RPC.  */\n+  private final FileSystemMasterCommonPOptions mSyncOptions;\n+\n+  /**\n+   * Whether the caller is {@link FileSystemMaster#getFileInfo(AlluxioURI, GetStatusContext)}.\n+   * This is used for the {@link #mUfsSyncPathCache}.\n+   */\n+  private final boolean mIsGetFileInfo;\n+\n+  /** Whether to only read+create metadata from the UFS, or to update metadata as well. */\n+  private final boolean mLoadOnly;\n+\n+  /** Queue used to keep track of paths that still need to be synced. */\n+  private final ConcurrentLinkedQueue<AlluxioURI> mSyncMetadataQ;\n+\n+  /** Queue of paths that have been submitted to the executor. */\n+  private final Queue<Future<Boolean>> mSyncPathJobs;\n+\n+  /** The executor enabling concurrent processing. */\n+  private final ExecutorService mMetadataSyncService;\n+\n+  /** The maximum number of concurrent paths that can be syncing at any moment. */\n+  private final int mConcurrencyLevel =\n+      ServerConfiguration.getInt(PropertyKey.MASTER_METADATA_SYNC_CONCURRENCY_LEVEL);\n+\n+  /**\n+   * Create a new instance of {@link InodeSyncStream}.\n+   *\n+   * The root path should be already locked with {@link LockPattern#WRITE_EDGE} unless the user is\n+   * only planning on loading metadata. The desired pattern should always be\n+   * {@link LockPattern#READ}.\n+   *\n+   * It is an error to initiate sync without a WRITE_EDGE lock when loadOnly is {@code false}.\n+   * If loadOnly is set to {@code true}, then the the root path may have a read lock.\n+   *\n+   * @param rootPath The root path to begin syncing\n+   * @param concurrencyService executor used to process paths concurrently\n+   * @param fsMaster the {@link FileSystemMaster} calling this method\n+   * @param inodeTree the {@link InodeTree}\n+   * @param inodeStore the {@link alluxio.master.metastore.InodeStore}\n+   * @param inodeLockManager the {@link InodeLockManager}\n+   * @param mountTable the master's {@link MountTable}\n+   * @param rpcContext the caller's {@link RpcContext}\n+   * @param descendantType determines the number of descendant inodes to sync\n+   * @param ufsSyncPathCache the sync path cache to determine when inodes should be synced\n+   * @param options the RPC's {@link FileSystemMasterCommonPOptions}\n+   * @param isGetFileInfo whether the caller is {@link FileSystemMaster#getFileInfo}\n+   * @param forceSync whether to sync inode metadata no matter what\n+   * @param loadOnly whether to only load new metadata, rather than update existing metadata\n+   */\n+  public InodeSyncStream(LockedInodePath rootPath, ExecutorService concurrencyService,\n+      DefaultFileSystemMaster fsMaster, InodeTree inodeTree, ReadOnlyInodeStore inodeStore,\n+      InodeLockManager inodeLockManager, MountTable mountTable, RpcContext rpcContext,\n+      DescendantType descendantType, UfsSyncPathCache ufsSyncPathCache,\n+      FileSystemMasterCommonPOptions options, boolean isGetFileInfo, boolean forceSync,\n+      boolean loadOnly) {\n+    mDescendantType = descendantType;\n+    mFsMaster = fsMaster;\n+    mSyncMetadataQ = new ConcurrentLinkedQueue<>();\n+    mInodeLockManager = inodeLockManager;\n+    mInodeStore = inodeStore;\n+    mInodeTree = inodeTree;\n+    mMountTable = mountTable;\n+    mRpcContext = rpcContext;\n+    mStatusCache = new UfsStatusCache(fsMaster.mSyncPrefetchExecutor);\n+    mUfsSyncPathCache = ufsSyncPathCache;\n+    mShouldSync = forceSync;\n+    mRootPath = rootPath;\n+    mSyncOptions = options;\n+    mIsGetFileInfo = isGetFileInfo;\n+    mLoadOnly = loadOnly;\n+    mSyncPathJobs = new LinkedList<>();\n+    mMetadataSyncService = concurrencyService;\n+  }\n+\n+  /**\n+   * Sync the metadata according the the root path the stream was created with.\n+   *\n+   * @return true if at least one path was synced\n+   */\n+  public boolean sync() {\n+    // The high-level process for the syncing is:\n+    // 1. Given an Alluxio path, determine if it is not consistent with the corresponding UFS path.\n+    //     this means the UFS path does not exist, or has metadata which differs from Alluxio\n+    // 2. If only the metadata changed, update the inode with the new metadata\n+    // 3. If the path does not exist in the UFS, delete the inode in Alluxio\n+    // 4. If not deleted, load metadata from the UFS\n+    // 5. If a recursive sync, add children inodes to sync queue\n+    int syncPathCount = 0;\n+    int stopNum = -1; // stop syncing when we've processed this many paths. -1 for infinite\n+\n+    try {\n+      syncInodeMetadata(mRootPath);\n+      syncPathCount++;\n+      if (mDescendantType == DescendantType.ONE) {\n+        // If descendantType is ONE, then we shouldn't process any more paths except for those\n+        // currently in the queue\n+        stopNum = mSyncMetadataQ.size();\n+      }\n+\n+      // process the sync result for the original path\n+      try {\n+        mRootPath.traverse();\n+      } catch (InvalidPathException e) {\n+        throw new RuntimeException(e);\n+      }\n+    } catch (AccessControlException | BlockInfoException | FileAlreadyCompletedException\n+        | FileDoesNotExistException | InvalidFileSizeException | InvalidPathException\n+        | IOException e) {\n+      LOG.warn(\"FAILED TO SYNC METADATA: {}\", e.getMessage(), e);\n+    } finally {\n+      // regardless of the outcome, remove the UfsStatus for this path from the cache\n+      mStatusCache.remove(mRootPath.getUri());\n+      // downgrade so that if operations are parallelized, the lock on the root doesn't restrict\n+      // concurrent operations\n+      mRootPath.downgradeToPattern(LockPattern.READ);\n+    }\n+\n+    // Process any children after the root.\n+    while (!mSyncMetadataQ.isEmpty() || !mSyncPathJobs.isEmpty()) {\n+      if (Thread.currentThread().isInterrupted()) {\n+        LOG.warn(\"Metadata syncing was interrupted before completion\");\n+        break;\n+      }\n+      // There are still paths to process\n+      // First, remove any futures which have completed. Add to the sync path count if they sync'd\n+      // successfully\n+      while (true) {\n+        Future<Boolean> job = mSyncPathJobs.peek();\n+        if (job == null || !job.isDone()) {\n+          break;\n+        }\n+        // remove the job because we know it is done.\n+        if (mSyncPathJobs.poll() != job) {\n+          throw new IllegalStateException(\"Last node to be de-queued was not equal to the expected\"\n+              + \"head of queue\");\n+        }\n+        try {\n+          // we synced the path successfully\n+          if (job.get()) {\n+            syncPathCount++;\n+          }\n+        } catch (InterruptedException | ExecutionException e) {\n+          if (e instanceof  InterruptedException) {\n+            Thread.currentThread().interrupt();\n+          }\n+          LOG.warn(\"metadata sync job was interrupted while waiting for completion\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aea2599ba2565e052e3871653282b3f22a325203"}, "originalPosition": 291}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMxNjY3Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      if (e instanceof  InterruptedException) {\n          \n          \n            \n                      if (e instanceof InterruptedException) {", "url": "https://github.com/Alluxio/alluxio/pull/11204#discussion_r418316672", "createdAt": "2020-04-30T22:07:56Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/master/file/InodeSyncStream.java", "diffHunk": "@@ -0,0 +1,810 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master.file;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.client.WriteType;\n+import alluxio.collections.Pair;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.exception.AccessControlException;\n+import alluxio.exception.BlockInfoException;\n+import alluxio.exception.DirectoryNotEmptyException;\n+import alluxio.exception.FileAlreadyCompletedException;\n+import alluxio.exception.FileAlreadyExistsException;\n+import alluxio.exception.FileDoesNotExistException;\n+import alluxio.exception.InvalidFileSizeException;\n+import alluxio.exception.InvalidPathException;\n+import alluxio.file.options.DescendantType;\n+import alluxio.grpc.CompleteFilePOptions;\n+import alluxio.grpc.DeletePOptions;\n+import alluxio.grpc.FileSystemMasterCommonPOptions;\n+import alluxio.grpc.GrpcUtils;\n+import alluxio.grpc.LoadDescendantPType;\n+import alluxio.grpc.LoadMetadataPOptions;\n+import alluxio.grpc.SetAttributePOptions;\n+import alluxio.master.file.contexts.CompleteFileContext;\n+import alluxio.master.file.contexts.CreateDirectoryContext;\n+import alluxio.master.file.contexts.CreateFileContext;\n+import alluxio.master.file.contexts.DeleteContext;\n+import alluxio.master.file.contexts.GetStatusContext;\n+import alluxio.master.file.contexts.LoadMetadataContext;\n+import alluxio.master.file.contexts.SetAttributeContext;\n+import alluxio.master.file.meta.Inode;\n+import alluxio.master.file.meta.InodeFile;\n+import alluxio.master.file.meta.InodeLockManager;\n+import alluxio.master.file.meta.InodeTree;\n+import alluxio.master.file.meta.InodeTree.LockPattern;\n+import alluxio.master.file.meta.LockedInodePath;\n+import alluxio.master.file.meta.LockingScheme;\n+import alluxio.master.file.meta.MountTable;\n+import alluxio.master.file.meta.UfsSyncPathCache;\n+import alluxio.master.file.meta.UfsSyncUtils;\n+import alluxio.master.metastore.ReadOnlyInodeStore;\n+import alluxio.resource.CloseableResource;\n+import alluxio.security.authorization.AccessControlList;\n+import alluxio.security.authorization.DefaultAccessControlList;\n+import alluxio.security.authorization.Mode;\n+import alluxio.underfs.Fingerprint;\n+import alluxio.underfs.UfsFileStatus;\n+import alluxio.underfs.UfsStatus;\n+import alluxio.underfs.UfsStatusCache;\n+import alluxio.underfs.UnderFileSystem;\n+import alluxio.util.interfaces.Scoped;\n+import alluxio.util.io.PathUtils;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+\n+/**\n+ * This class is responsible for maintaining the logic which surrounds syncing metadata between\n+ * Alluxio and its UFSes.\n+ *\n+ * This implementation uses a BFS-based approach to crawl the inode tree. In order to speed up\n+ * the sync process we use an {@link ExecutorService} which we submit inode paths to using\n+ * {@link #processSyncPath(AlluxioURI)}. The processing of inode paths will discover new paths to\n+ * sync depending on the {@link #mDescendantType}. Syncing is finished when all submitted tasks\n+ * are completed and there are no new inodes left in the queue.\n+ *\n+ * Syncing inode metadata requires making calls to the UFS. This implementation will schedule UFS\n+ * RPCs with the {@link UfsStatusCache#prefetchChildren(AlluxioURI, MountTable)}. Then, once the\n+ * inode begins processing, it can retrieve the results. After processing, it can then remove its\n+ * {@link UfsStatus} from the cache. This strategy helps reduce memory pressure on the master\n+ * while performing a sync for a large tree. Additionally, by using a prefetch mechanism we can\n+ * concurrently process other inodes while waiting for UFS RPCs to complete.\n+ *\n+ * With regards to locking, this class expects to be able to take a write lock on any inode, and\n+ * then subsequently downgrades or unlocks after the sync is finished. Even though we use\n+ * {@link java.util.concurrent.locks.ReentrantReadWriteLock}, because we concurrently process\n+ * inodes on separate threads, we cannot utilize the reetrnant behavior. The implications of\n+ * that mean the caller of this class must not hold a write while calling {@link #sync()}.\n+ *\n+ * A user of this class is expected to create a new instance for each path that they would like\n+ * to process. This is because the Lock on the {@link #mRootPath} may be changed after calling\n+ * {@link #sync()}.\n+ *\n+ */\n+public class InodeSyncStream {\n+  private static final Logger LOG = LoggerFactory.getLogger(InodeSyncStream.class);\n+\n+  /** The root path. Should be locked with a write lock. */\n+  private final LockedInodePath mRootPath;\n+\n+  /** A {@link UfsSyncPathCache} maintained from the {@link DefaultFileSystemMaster}. */\n+  private final UfsSyncPathCache mUfsSyncPathCache;\n+\n+  /** Object holding the {@link UfsStatus}es which may be required for syncing. */\n+  private final UfsStatusCache mStatusCache;\n+\n+  /** Inode tree to lock new paths. */\n+  private final InodeTree mInodeTree;\n+\n+  /** Determines how deep in the tree we need to load. */\n+  private final DescendantType mDescendantType;\n+\n+  /** The {@link RpcContext} from the caller. */\n+  private final RpcContext mRpcContext;\n+\n+  /** The inode store to look up children. */\n+  private final ReadOnlyInodeStore mInodeStore;\n+\n+  /** The mount table for looking up the proper UFS client based on the Alluxio path. */\n+  private final MountTable mMountTable;\n+\n+  /** The lock manager used to try acquiring the persisting lock. */\n+  private final InodeLockManager mInodeLockManager;\n+\n+  /** The FS master creating this object. */\n+  private final DefaultFileSystemMaster mFsMaster;\n+\n+  /** Set this to true to force a sync regardless of the UfsPathCache. */\n+  private final boolean mShouldSync;\n+\n+  /** The sync options on the RPC.  */\n+  private final FileSystemMasterCommonPOptions mSyncOptions;\n+\n+  /**\n+   * Whether the caller is {@link FileSystemMaster#getFileInfo(AlluxioURI, GetStatusContext)}.\n+   * This is used for the {@link #mUfsSyncPathCache}.\n+   */\n+  private final boolean mIsGetFileInfo;\n+\n+  /** Whether to only read+create metadata from the UFS, or to update metadata as well. */\n+  private final boolean mLoadOnly;\n+\n+  /** Queue used to keep track of paths that still need to be synced. */\n+  private final ConcurrentLinkedQueue<AlluxioURI> mSyncMetadataQ;\n+\n+  /** Queue of paths that have been submitted to the executor. */\n+  private final Queue<Future<Boolean>> mSyncPathJobs;\n+\n+  /** The executor enabling concurrent processing. */\n+  private final ExecutorService mMetadataSyncService;\n+\n+  /** The maximum number of concurrent paths that can be syncing at any moment. */\n+  private final int mConcurrencyLevel =\n+      ServerConfiguration.getInt(PropertyKey.MASTER_METADATA_SYNC_CONCURRENCY_LEVEL);\n+\n+  /**\n+   * Create a new instance of {@link InodeSyncStream}.\n+   *\n+   * The root path should be already locked with {@link LockPattern#WRITE_EDGE} unless the user is\n+   * only planning on loading metadata. The desired pattern should always be\n+   * {@link LockPattern#READ}.\n+   *\n+   * It is an error to initiate sync without a WRITE_EDGE lock when loadOnly is {@code false}.\n+   * If loadOnly is set to {@code true}, then the the root path may have a read lock.\n+   *\n+   * @param rootPath The root path to begin syncing\n+   * @param concurrencyService executor used to process paths concurrently\n+   * @param fsMaster the {@link FileSystemMaster} calling this method\n+   * @param inodeTree the {@link InodeTree}\n+   * @param inodeStore the {@link alluxio.master.metastore.InodeStore}\n+   * @param inodeLockManager the {@link InodeLockManager}\n+   * @param mountTable the master's {@link MountTable}\n+   * @param rpcContext the caller's {@link RpcContext}\n+   * @param descendantType determines the number of descendant inodes to sync\n+   * @param ufsSyncPathCache the sync path cache to determine when inodes should be synced\n+   * @param options the RPC's {@link FileSystemMasterCommonPOptions}\n+   * @param isGetFileInfo whether the caller is {@link FileSystemMaster#getFileInfo}\n+   * @param forceSync whether to sync inode metadata no matter what\n+   * @param loadOnly whether to only load new metadata, rather than update existing metadata\n+   */\n+  public InodeSyncStream(LockedInodePath rootPath, ExecutorService concurrencyService,\n+      DefaultFileSystemMaster fsMaster, InodeTree inodeTree, ReadOnlyInodeStore inodeStore,\n+      InodeLockManager inodeLockManager, MountTable mountTable, RpcContext rpcContext,\n+      DescendantType descendantType, UfsSyncPathCache ufsSyncPathCache,\n+      FileSystemMasterCommonPOptions options, boolean isGetFileInfo, boolean forceSync,\n+      boolean loadOnly) {\n+    mDescendantType = descendantType;\n+    mFsMaster = fsMaster;\n+    mSyncMetadataQ = new ConcurrentLinkedQueue<>();\n+    mInodeLockManager = inodeLockManager;\n+    mInodeStore = inodeStore;\n+    mInodeTree = inodeTree;\n+    mMountTable = mountTable;\n+    mRpcContext = rpcContext;\n+    mStatusCache = new UfsStatusCache(fsMaster.mSyncPrefetchExecutor);\n+    mUfsSyncPathCache = ufsSyncPathCache;\n+    mShouldSync = forceSync;\n+    mRootPath = rootPath;\n+    mSyncOptions = options;\n+    mIsGetFileInfo = isGetFileInfo;\n+    mLoadOnly = loadOnly;\n+    mSyncPathJobs = new LinkedList<>();\n+    mMetadataSyncService = concurrencyService;\n+  }\n+\n+  /**\n+   * Sync the metadata according the the root path the stream was created with.\n+   *\n+   * @return true if at least one path was synced\n+   */\n+  public boolean sync() {\n+    // The high-level process for the syncing is:\n+    // 1. Given an Alluxio path, determine if it is not consistent with the corresponding UFS path.\n+    //     this means the UFS path does not exist, or has metadata which differs from Alluxio\n+    // 2. If only the metadata changed, update the inode with the new metadata\n+    // 3. If the path does not exist in the UFS, delete the inode in Alluxio\n+    // 4. If not deleted, load metadata from the UFS\n+    // 5. If a recursive sync, add children inodes to sync queue\n+    int syncPathCount = 0;\n+    int stopNum = -1; // stop syncing when we've processed this many paths. -1 for infinite\n+\n+    try {\n+      syncInodeMetadata(mRootPath);\n+      syncPathCount++;\n+      if (mDescendantType == DescendantType.ONE) {\n+        // If descendantType is ONE, then we shouldn't process any more paths except for those\n+        // currently in the queue\n+        stopNum = mSyncMetadataQ.size();\n+      }\n+\n+      // process the sync result for the original path\n+      try {\n+        mRootPath.traverse();\n+      } catch (InvalidPathException e) {\n+        throw new RuntimeException(e);\n+      }\n+    } catch (AccessControlException | BlockInfoException | FileAlreadyCompletedException\n+        | FileDoesNotExistException | InvalidFileSizeException | InvalidPathException\n+        | IOException e) {\n+      LOG.warn(\"FAILED TO SYNC METADATA: {}\", e.getMessage(), e);\n+    } finally {\n+      // regardless of the outcome, remove the UfsStatus for this path from the cache\n+      mStatusCache.remove(mRootPath.getUri());\n+      // downgrade so that if operations are parallelized, the lock on the root doesn't restrict\n+      // concurrent operations\n+      mRootPath.downgradeToPattern(LockPattern.READ);\n+    }\n+\n+    // Process any children after the root.\n+    while (!mSyncMetadataQ.isEmpty() || !mSyncPathJobs.isEmpty()) {\n+      if (Thread.currentThread().isInterrupted()) {\n+        LOG.warn(\"Metadata syncing was interrupted before completion\");\n+        break;\n+      }\n+      // There are still paths to process\n+      // First, remove any futures which have completed. Add to the sync path count if they sync'd\n+      // successfully\n+      while (true) {\n+        Future<Boolean> job = mSyncPathJobs.peek();\n+        if (job == null || !job.isDone()) {\n+          break;\n+        }\n+        // remove the job because we know it is done.\n+        if (mSyncPathJobs.poll() != job) {\n+          throw new IllegalStateException(\"Last node to be de-queued was not equal to the expected\"\n+              + \"head of queue\");\n+        }\n+        try {\n+          // we synced the path successfully\n+          if (job.get()) {\n+            syncPathCount++;\n+          }\n+        } catch (InterruptedException | ExecutionException e) {\n+          if (e instanceof  InterruptedException) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aea2599ba2565e052e3871653282b3f22a325203"}, "originalPosition": 288}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMxNzA1OQ==", "bodyText": "if some of the tasks failed for some reason, will the count accounting still work? If I want to load a directory with 10 children, but 1 failed, will it still stop after all 10 finished (fail or succeed)?", "url": "https://github.com/Alluxio/alluxio/pull/11204#discussion_r418317059", "createdAt": "2020-04-30T22:08:54Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/master/file/InodeSyncStream.java", "diffHunk": "@@ -0,0 +1,810 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master.file;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.client.WriteType;\n+import alluxio.collections.Pair;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.exception.AccessControlException;\n+import alluxio.exception.BlockInfoException;\n+import alluxio.exception.DirectoryNotEmptyException;\n+import alluxio.exception.FileAlreadyCompletedException;\n+import alluxio.exception.FileAlreadyExistsException;\n+import alluxio.exception.FileDoesNotExistException;\n+import alluxio.exception.InvalidFileSizeException;\n+import alluxio.exception.InvalidPathException;\n+import alluxio.file.options.DescendantType;\n+import alluxio.grpc.CompleteFilePOptions;\n+import alluxio.grpc.DeletePOptions;\n+import alluxio.grpc.FileSystemMasterCommonPOptions;\n+import alluxio.grpc.GrpcUtils;\n+import alluxio.grpc.LoadDescendantPType;\n+import alluxio.grpc.LoadMetadataPOptions;\n+import alluxio.grpc.SetAttributePOptions;\n+import alluxio.master.file.contexts.CompleteFileContext;\n+import alluxio.master.file.contexts.CreateDirectoryContext;\n+import alluxio.master.file.contexts.CreateFileContext;\n+import alluxio.master.file.contexts.DeleteContext;\n+import alluxio.master.file.contexts.GetStatusContext;\n+import alluxio.master.file.contexts.LoadMetadataContext;\n+import alluxio.master.file.contexts.SetAttributeContext;\n+import alluxio.master.file.meta.Inode;\n+import alluxio.master.file.meta.InodeFile;\n+import alluxio.master.file.meta.InodeLockManager;\n+import alluxio.master.file.meta.InodeTree;\n+import alluxio.master.file.meta.InodeTree.LockPattern;\n+import alluxio.master.file.meta.LockedInodePath;\n+import alluxio.master.file.meta.LockingScheme;\n+import alluxio.master.file.meta.MountTable;\n+import alluxio.master.file.meta.UfsSyncPathCache;\n+import alluxio.master.file.meta.UfsSyncUtils;\n+import alluxio.master.metastore.ReadOnlyInodeStore;\n+import alluxio.resource.CloseableResource;\n+import alluxio.security.authorization.AccessControlList;\n+import alluxio.security.authorization.DefaultAccessControlList;\n+import alluxio.security.authorization.Mode;\n+import alluxio.underfs.Fingerprint;\n+import alluxio.underfs.UfsFileStatus;\n+import alluxio.underfs.UfsStatus;\n+import alluxio.underfs.UfsStatusCache;\n+import alluxio.underfs.UnderFileSystem;\n+import alluxio.util.interfaces.Scoped;\n+import alluxio.util.io.PathUtils;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+\n+/**\n+ * This class is responsible for maintaining the logic which surrounds syncing metadata between\n+ * Alluxio and its UFSes.\n+ *\n+ * This implementation uses a BFS-based approach to crawl the inode tree. In order to speed up\n+ * the sync process we use an {@link ExecutorService} which we submit inode paths to using\n+ * {@link #processSyncPath(AlluxioURI)}. The processing of inode paths will discover new paths to\n+ * sync depending on the {@link #mDescendantType}. Syncing is finished when all submitted tasks\n+ * are completed and there are no new inodes left in the queue.\n+ *\n+ * Syncing inode metadata requires making calls to the UFS. This implementation will schedule UFS\n+ * RPCs with the {@link UfsStatusCache#prefetchChildren(AlluxioURI, MountTable)}. Then, once the\n+ * inode begins processing, it can retrieve the results. After processing, it can then remove its\n+ * {@link UfsStatus} from the cache. This strategy helps reduce memory pressure on the master\n+ * while performing a sync for a large tree. Additionally, by using a prefetch mechanism we can\n+ * concurrently process other inodes while waiting for UFS RPCs to complete.\n+ *\n+ * With regards to locking, this class expects to be able to take a write lock on any inode, and\n+ * then subsequently downgrades or unlocks after the sync is finished. Even though we use\n+ * {@link java.util.concurrent.locks.ReentrantReadWriteLock}, because we concurrently process\n+ * inodes on separate threads, we cannot utilize the reetrnant behavior. The implications of\n+ * that mean the caller of this class must not hold a write while calling {@link #sync()}.\n+ *\n+ * A user of this class is expected to create a new instance for each path that they would like\n+ * to process. This is because the Lock on the {@link #mRootPath} may be changed after calling\n+ * {@link #sync()}.\n+ *\n+ */\n+public class InodeSyncStream {\n+  private static final Logger LOG = LoggerFactory.getLogger(InodeSyncStream.class);\n+\n+  /** The root path. Should be locked with a write lock. */\n+  private final LockedInodePath mRootPath;\n+\n+  /** A {@link UfsSyncPathCache} maintained from the {@link DefaultFileSystemMaster}. */\n+  private final UfsSyncPathCache mUfsSyncPathCache;\n+\n+  /** Object holding the {@link UfsStatus}es which may be required for syncing. */\n+  private final UfsStatusCache mStatusCache;\n+\n+  /** Inode tree to lock new paths. */\n+  private final InodeTree mInodeTree;\n+\n+  /** Determines how deep in the tree we need to load. */\n+  private final DescendantType mDescendantType;\n+\n+  /** The {@link RpcContext} from the caller. */\n+  private final RpcContext mRpcContext;\n+\n+  /** The inode store to look up children. */\n+  private final ReadOnlyInodeStore mInodeStore;\n+\n+  /** The mount table for looking up the proper UFS client based on the Alluxio path. */\n+  private final MountTable mMountTable;\n+\n+  /** The lock manager used to try acquiring the persisting lock. */\n+  private final InodeLockManager mInodeLockManager;\n+\n+  /** The FS master creating this object. */\n+  private final DefaultFileSystemMaster mFsMaster;\n+\n+  /** Set this to true to force a sync regardless of the UfsPathCache. */\n+  private final boolean mShouldSync;\n+\n+  /** The sync options on the RPC.  */\n+  private final FileSystemMasterCommonPOptions mSyncOptions;\n+\n+  /**\n+   * Whether the caller is {@link FileSystemMaster#getFileInfo(AlluxioURI, GetStatusContext)}.\n+   * This is used for the {@link #mUfsSyncPathCache}.\n+   */\n+  private final boolean mIsGetFileInfo;\n+\n+  /** Whether to only read+create metadata from the UFS, or to update metadata as well. */\n+  private final boolean mLoadOnly;\n+\n+  /** Queue used to keep track of paths that still need to be synced. */\n+  private final ConcurrentLinkedQueue<AlluxioURI> mSyncMetadataQ;\n+\n+  /** Queue of paths that have been submitted to the executor. */\n+  private final Queue<Future<Boolean>> mSyncPathJobs;\n+\n+  /** The executor enabling concurrent processing. */\n+  private final ExecutorService mMetadataSyncService;\n+\n+  /** The maximum number of concurrent paths that can be syncing at any moment. */\n+  private final int mConcurrencyLevel =\n+      ServerConfiguration.getInt(PropertyKey.MASTER_METADATA_SYNC_CONCURRENCY_LEVEL);\n+\n+  /**\n+   * Create a new instance of {@link InodeSyncStream}.\n+   *\n+   * The root path should be already locked with {@link LockPattern#WRITE_EDGE} unless the user is\n+   * only planning on loading metadata. The desired pattern should always be\n+   * {@link LockPattern#READ}.\n+   *\n+   * It is an error to initiate sync without a WRITE_EDGE lock when loadOnly is {@code false}.\n+   * If loadOnly is set to {@code true}, then the the root path may have a read lock.\n+   *\n+   * @param rootPath The root path to begin syncing\n+   * @param concurrencyService executor used to process paths concurrently\n+   * @param fsMaster the {@link FileSystemMaster} calling this method\n+   * @param inodeTree the {@link InodeTree}\n+   * @param inodeStore the {@link alluxio.master.metastore.InodeStore}\n+   * @param inodeLockManager the {@link InodeLockManager}\n+   * @param mountTable the master's {@link MountTable}\n+   * @param rpcContext the caller's {@link RpcContext}\n+   * @param descendantType determines the number of descendant inodes to sync\n+   * @param ufsSyncPathCache the sync path cache to determine when inodes should be synced\n+   * @param options the RPC's {@link FileSystemMasterCommonPOptions}\n+   * @param isGetFileInfo whether the caller is {@link FileSystemMaster#getFileInfo}\n+   * @param forceSync whether to sync inode metadata no matter what\n+   * @param loadOnly whether to only load new metadata, rather than update existing metadata\n+   */\n+  public InodeSyncStream(LockedInodePath rootPath, ExecutorService concurrencyService,\n+      DefaultFileSystemMaster fsMaster, InodeTree inodeTree, ReadOnlyInodeStore inodeStore,\n+      InodeLockManager inodeLockManager, MountTable mountTable, RpcContext rpcContext,\n+      DescendantType descendantType, UfsSyncPathCache ufsSyncPathCache,\n+      FileSystemMasterCommonPOptions options, boolean isGetFileInfo, boolean forceSync,\n+      boolean loadOnly) {\n+    mDescendantType = descendantType;\n+    mFsMaster = fsMaster;\n+    mSyncMetadataQ = new ConcurrentLinkedQueue<>();\n+    mInodeLockManager = inodeLockManager;\n+    mInodeStore = inodeStore;\n+    mInodeTree = inodeTree;\n+    mMountTable = mountTable;\n+    mRpcContext = rpcContext;\n+    mStatusCache = new UfsStatusCache(fsMaster.mSyncPrefetchExecutor);\n+    mUfsSyncPathCache = ufsSyncPathCache;\n+    mShouldSync = forceSync;\n+    mRootPath = rootPath;\n+    mSyncOptions = options;\n+    mIsGetFileInfo = isGetFileInfo;\n+    mLoadOnly = loadOnly;\n+    mSyncPathJobs = new LinkedList<>();\n+    mMetadataSyncService = concurrencyService;\n+  }\n+\n+  /**\n+   * Sync the metadata according the the root path the stream was created with.\n+   *\n+   * @return true if at least one path was synced\n+   */\n+  public boolean sync() {\n+    // The high-level process for the syncing is:\n+    // 1. Given an Alluxio path, determine if it is not consistent with the corresponding UFS path.\n+    //     this means the UFS path does not exist, or has metadata which differs from Alluxio\n+    // 2. If only the metadata changed, update the inode with the new metadata\n+    // 3. If the path does not exist in the UFS, delete the inode in Alluxio\n+    // 4. If not deleted, load metadata from the UFS\n+    // 5. If a recursive sync, add children inodes to sync queue\n+    int syncPathCount = 0;\n+    int stopNum = -1; // stop syncing when we've processed this many paths. -1 for infinite\n+\n+    try {\n+      syncInodeMetadata(mRootPath);\n+      syncPathCount++;\n+      if (mDescendantType == DescendantType.ONE) {\n+        // If descendantType is ONE, then we shouldn't process any more paths except for those\n+        // currently in the queue\n+        stopNum = mSyncMetadataQ.size();\n+      }\n+\n+      // process the sync result for the original path\n+      try {\n+        mRootPath.traverse();\n+      } catch (InvalidPathException e) {\n+        throw new RuntimeException(e);\n+      }\n+    } catch (AccessControlException | BlockInfoException | FileAlreadyCompletedException\n+        | FileDoesNotExistException | InvalidFileSizeException | InvalidPathException\n+        | IOException e) {\n+      LOG.warn(\"FAILED TO SYNC METADATA: {}\", e.getMessage(), e);\n+    } finally {\n+      // regardless of the outcome, remove the UfsStatus for this path from the cache\n+      mStatusCache.remove(mRootPath.getUri());\n+      // downgrade so that if operations are parallelized, the lock on the root doesn't restrict\n+      // concurrent operations\n+      mRootPath.downgradeToPattern(LockPattern.READ);\n+    }\n+\n+    // Process any children after the root.\n+    while (!mSyncMetadataQ.isEmpty() || !mSyncPathJobs.isEmpty()) {\n+      if (Thread.currentThread().isInterrupted()) {\n+        LOG.warn(\"Metadata syncing was interrupted before completion\");\n+        break;\n+      }\n+      // There are still paths to process\n+      // First, remove any futures which have completed. Add to the sync path count if they sync'd\n+      // successfully\n+      while (true) {\n+        Future<Boolean> job = mSyncPathJobs.peek();\n+        if (job == null || !job.isDone()) {\n+          break;\n+        }\n+        // remove the job because we know it is done.\n+        if (mSyncPathJobs.poll() != job) {\n+          throw new IllegalStateException(\"Last node to be de-queued was not equal to the expected\"\n+              + \"head of queue\");\n+        }\n+        try {\n+          // we synced the path successfully\n+          if (job.get()) {\n+            syncPathCount++;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aea2599ba2565e052e3871653282b3f22a325203"}, "originalPosition": 285}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMxNzQ1MQ==", "bodyText": "debug logging?", "url": "https://github.com/Alluxio/alluxio/pull/11204#discussion_r418317451", "createdAt": "2020-04-30T22:09:50Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/master/file/InodeSyncStream.java", "diffHunk": "@@ -0,0 +1,810 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master.file;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.client.WriteType;\n+import alluxio.collections.Pair;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.exception.AccessControlException;\n+import alluxio.exception.BlockInfoException;\n+import alluxio.exception.DirectoryNotEmptyException;\n+import alluxio.exception.FileAlreadyCompletedException;\n+import alluxio.exception.FileAlreadyExistsException;\n+import alluxio.exception.FileDoesNotExistException;\n+import alluxio.exception.InvalidFileSizeException;\n+import alluxio.exception.InvalidPathException;\n+import alluxio.file.options.DescendantType;\n+import alluxio.grpc.CompleteFilePOptions;\n+import alluxio.grpc.DeletePOptions;\n+import alluxio.grpc.FileSystemMasterCommonPOptions;\n+import alluxio.grpc.GrpcUtils;\n+import alluxio.grpc.LoadDescendantPType;\n+import alluxio.grpc.LoadMetadataPOptions;\n+import alluxio.grpc.SetAttributePOptions;\n+import alluxio.master.file.contexts.CompleteFileContext;\n+import alluxio.master.file.contexts.CreateDirectoryContext;\n+import alluxio.master.file.contexts.CreateFileContext;\n+import alluxio.master.file.contexts.DeleteContext;\n+import alluxio.master.file.contexts.GetStatusContext;\n+import alluxio.master.file.contexts.LoadMetadataContext;\n+import alluxio.master.file.contexts.SetAttributeContext;\n+import alluxio.master.file.meta.Inode;\n+import alluxio.master.file.meta.InodeFile;\n+import alluxio.master.file.meta.InodeLockManager;\n+import alluxio.master.file.meta.InodeTree;\n+import alluxio.master.file.meta.InodeTree.LockPattern;\n+import alluxio.master.file.meta.LockedInodePath;\n+import alluxio.master.file.meta.LockingScheme;\n+import alluxio.master.file.meta.MountTable;\n+import alluxio.master.file.meta.UfsSyncPathCache;\n+import alluxio.master.file.meta.UfsSyncUtils;\n+import alluxio.master.metastore.ReadOnlyInodeStore;\n+import alluxio.resource.CloseableResource;\n+import alluxio.security.authorization.AccessControlList;\n+import alluxio.security.authorization.DefaultAccessControlList;\n+import alluxio.security.authorization.Mode;\n+import alluxio.underfs.Fingerprint;\n+import alluxio.underfs.UfsFileStatus;\n+import alluxio.underfs.UfsStatus;\n+import alluxio.underfs.UfsStatusCache;\n+import alluxio.underfs.UnderFileSystem;\n+import alluxio.util.interfaces.Scoped;\n+import alluxio.util.io.PathUtils;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+\n+/**\n+ * This class is responsible for maintaining the logic which surrounds syncing metadata between\n+ * Alluxio and its UFSes.\n+ *\n+ * This implementation uses a BFS-based approach to crawl the inode tree. In order to speed up\n+ * the sync process we use an {@link ExecutorService} which we submit inode paths to using\n+ * {@link #processSyncPath(AlluxioURI)}. The processing of inode paths will discover new paths to\n+ * sync depending on the {@link #mDescendantType}. Syncing is finished when all submitted tasks\n+ * are completed and there are no new inodes left in the queue.\n+ *\n+ * Syncing inode metadata requires making calls to the UFS. This implementation will schedule UFS\n+ * RPCs with the {@link UfsStatusCache#prefetchChildren(AlluxioURI, MountTable)}. Then, once the\n+ * inode begins processing, it can retrieve the results. After processing, it can then remove its\n+ * {@link UfsStatus} from the cache. This strategy helps reduce memory pressure on the master\n+ * while performing a sync for a large tree. Additionally, by using a prefetch mechanism we can\n+ * concurrently process other inodes while waiting for UFS RPCs to complete.\n+ *\n+ * With regards to locking, this class expects to be able to take a write lock on any inode, and\n+ * then subsequently downgrades or unlocks after the sync is finished. Even though we use\n+ * {@link java.util.concurrent.locks.ReentrantReadWriteLock}, because we concurrently process\n+ * inodes on separate threads, we cannot utilize the reetrnant behavior. The implications of\n+ * that mean the caller of this class must not hold a write while calling {@link #sync()}.\n+ *\n+ * A user of this class is expected to create a new instance for each path that they would like\n+ * to process. This is because the Lock on the {@link #mRootPath} may be changed after calling\n+ * {@link #sync()}.\n+ *\n+ */\n+public class InodeSyncStream {\n+  private static final Logger LOG = LoggerFactory.getLogger(InodeSyncStream.class);\n+\n+  /** The root path. Should be locked with a write lock. */\n+  private final LockedInodePath mRootPath;\n+\n+  /** A {@link UfsSyncPathCache} maintained from the {@link DefaultFileSystemMaster}. */\n+  private final UfsSyncPathCache mUfsSyncPathCache;\n+\n+  /** Object holding the {@link UfsStatus}es which may be required for syncing. */\n+  private final UfsStatusCache mStatusCache;\n+\n+  /** Inode tree to lock new paths. */\n+  private final InodeTree mInodeTree;\n+\n+  /** Determines how deep in the tree we need to load. */\n+  private final DescendantType mDescendantType;\n+\n+  /** The {@link RpcContext} from the caller. */\n+  private final RpcContext mRpcContext;\n+\n+  /** The inode store to look up children. */\n+  private final ReadOnlyInodeStore mInodeStore;\n+\n+  /** The mount table for looking up the proper UFS client based on the Alluxio path. */\n+  private final MountTable mMountTable;\n+\n+  /** The lock manager used to try acquiring the persisting lock. */\n+  private final InodeLockManager mInodeLockManager;\n+\n+  /** The FS master creating this object. */\n+  private final DefaultFileSystemMaster mFsMaster;\n+\n+  /** Set this to true to force a sync regardless of the UfsPathCache. */\n+  private final boolean mShouldSync;\n+\n+  /** The sync options on the RPC.  */\n+  private final FileSystemMasterCommonPOptions mSyncOptions;\n+\n+  /**\n+   * Whether the caller is {@link FileSystemMaster#getFileInfo(AlluxioURI, GetStatusContext)}.\n+   * This is used for the {@link #mUfsSyncPathCache}.\n+   */\n+  private final boolean mIsGetFileInfo;\n+\n+  /** Whether to only read+create metadata from the UFS, or to update metadata as well. */\n+  private final boolean mLoadOnly;\n+\n+  /** Queue used to keep track of paths that still need to be synced. */\n+  private final ConcurrentLinkedQueue<AlluxioURI> mSyncMetadataQ;\n+\n+  /** Queue of paths that have been submitted to the executor. */\n+  private final Queue<Future<Boolean>> mSyncPathJobs;\n+\n+  /** The executor enabling concurrent processing. */\n+  private final ExecutorService mMetadataSyncService;\n+\n+  /** The maximum number of concurrent paths that can be syncing at any moment. */\n+  private final int mConcurrencyLevel =\n+      ServerConfiguration.getInt(PropertyKey.MASTER_METADATA_SYNC_CONCURRENCY_LEVEL);\n+\n+  /**\n+   * Create a new instance of {@link InodeSyncStream}.\n+   *\n+   * The root path should be already locked with {@link LockPattern#WRITE_EDGE} unless the user is\n+   * only planning on loading metadata. The desired pattern should always be\n+   * {@link LockPattern#READ}.\n+   *\n+   * It is an error to initiate sync without a WRITE_EDGE lock when loadOnly is {@code false}.\n+   * If loadOnly is set to {@code true}, then the the root path may have a read lock.\n+   *\n+   * @param rootPath The root path to begin syncing\n+   * @param concurrencyService executor used to process paths concurrently\n+   * @param fsMaster the {@link FileSystemMaster} calling this method\n+   * @param inodeTree the {@link InodeTree}\n+   * @param inodeStore the {@link alluxio.master.metastore.InodeStore}\n+   * @param inodeLockManager the {@link InodeLockManager}\n+   * @param mountTable the master's {@link MountTable}\n+   * @param rpcContext the caller's {@link RpcContext}\n+   * @param descendantType determines the number of descendant inodes to sync\n+   * @param ufsSyncPathCache the sync path cache to determine when inodes should be synced\n+   * @param options the RPC's {@link FileSystemMasterCommonPOptions}\n+   * @param isGetFileInfo whether the caller is {@link FileSystemMaster#getFileInfo}\n+   * @param forceSync whether to sync inode metadata no matter what\n+   * @param loadOnly whether to only load new metadata, rather than update existing metadata\n+   */\n+  public InodeSyncStream(LockedInodePath rootPath, ExecutorService concurrencyService,\n+      DefaultFileSystemMaster fsMaster, InodeTree inodeTree, ReadOnlyInodeStore inodeStore,\n+      InodeLockManager inodeLockManager, MountTable mountTable, RpcContext rpcContext,\n+      DescendantType descendantType, UfsSyncPathCache ufsSyncPathCache,\n+      FileSystemMasterCommonPOptions options, boolean isGetFileInfo, boolean forceSync,\n+      boolean loadOnly) {\n+    mDescendantType = descendantType;\n+    mFsMaster = fsMaster;\n+    mSyncMetadataQ = new ConcurrentLinkedQueue<>();\n+    mInodeLockManager = inodeLockManager;\n+    mInodeStore = inodeStore;\n+    mInodeTree = inodeTree;\n+    mMountTable = mountTable;\n+    mRpcContext = rpcContext;\n+    mStatusCache = new UfsStatusCache(fsMaster.mSyncPrefetchExecutor);\n+    mUfsSyncPathCache = ufsSyncPathCache;\n+    mShouldSync = forceSync;\n+    mRootPath = rootPath;\n+    mSyncOptions = options;\n+    mIsGetFileInfo = isGetFileInfo;\n+    mLoadOnly = loadOnly;\n+    mSyncPathJobs = new LinkedList<>();\n+    mMetadataSyncService = concurrencyService;\n+  }\n+\n+  /**\n+   * Sync the metadata according the the root path the stream was created with.\n+   *\n+   * @return true if at least one path was synced\n+   */\n+  public boolean sync() {\n+    // The high-level process for the syncing is:\n+    // 1. Given an Alluxio path, determine if it is not consistent with the corresponding UFS path.\n+    //     this means the UFS path does not exist, or has metadata which differs from Alluxio\n+    // 2. If only the metadata changed, update the inode with the new metadata\n+    // 3. If the path does not exist in the UFS, delete the inode in Alluxio\n+    // 4. If not deleted, load metadata from the UFS\n+    // 5. If a recursive sync, add children inodes to sync queue\n+    int syncPathCount = 0;\n+    int stopNum = -1; // stop syncing when we've processed this many paths. -1 for infinite\n+\n+    try {\n+      syncInodeMetadata(mRootPath);\n+      syncPathCount++;\n+      if (mDescendantType == DescendantType.ONE) {\n+        // If descendantType is ONE, then we shouldn't process any more paths except for those\n+        // currently in the queue\n+        stopNum = mSyncMetadataQ.size();\n+      }\n+\n+      // process the sync result for the original path\n+      try {\n+        mRootPath.traverse();\n+      } catch (InvalidPathException e) {\n+        throw new RuntimeException(e);\n+      }\n+    } catch (AccessControlException | BlockInfoException | FileAlreadyCompletedException\n+        | FileDoesNotExistException | InvalidFileSizeException | InvalidPathException\n+        | IOException e) {\n+      LOG.warn(\"FAILED TO SYNC METADATA: {}\", e.getMessage(), e);\n+    } finally {\n+      // regardless of the outcome, remove the UfsStatus for this path from the cache\n+      mStatusCache.remove(mRootPath.getUri());\n+      // downgrade so that if operations are parallelized, the lock on the root doesn't restrict\n+      // concurrent operations\n+      mRootPath.downgradeToPattern(LockPattern.READ);\n+    }\n+\n+    // Process any children after the root.\n+    while (!mSyncMetadataQ.isEmpty() || !mSyncPathJobs.isEmpty()) {\n+      if (Thread.currentThread().isInterrupted()) {\n+        LOG.warn(\"Metadata syncing was interrupted before completion\");\n+        break;\n+      }\n+      // There are still paths to process\n+      // First, remove any futures which have completed. Add to the sync path count if they sync'd\n+      // successfully\n+      while (true) {\n+        Future<Boolean> job = mSyncPathJobs.peek();\n+        if (job == null || !job.isDone()) {\n+          break;\n+        }\n+        // remove the job because we know it is done.\n+        if (mSyncPathJobs.poll() != job) {\n+          throw new IllegalStateException(\"Last node to be de-queued was not equal to the expected\"\n+              + \"head of queue\");\n+        }\n+        try {\n+          // we synced the path successfully\n+          if (job.get()) {\n+            syncPathCount++;\n+          }\n+        } catch (InterruptedException | ExecutionException e) {\n+          if (e instanceof  InterruptedException) {\n+            Thread.currentThread().interrupt();\n+          }\n+          LOG.warn(\"metadata sync job was interrupted while waiting for completion\");\n+        }\n+      }\n+\n+      // When using descendant type of ONE, we need to stop prematurely.\n+      if (stopNum != -1 && syncPathCount > stopNum) {\n+        break;\n+      }\n+\n+      // We can submit up to ( max_concurrency - <jobs queue size>) jobs back into the queue\n+      int submissions = mConcurrencyLevel - mSyncPathJobs.size();\n+      for (int i = 0; i < submissions; i++) {\n+        AlluxioURI path = mSyncMetadataQ.poll();\n+        if (path == null) {\n+          // no paths left to sync\n+          break;\n+        }\n+        Future<Boolean> job = mMetadataSyncService.submit(() -> processSyncPath(path));\n+        mSyncPathJobs.offer(job);\n+      }\n+      // After submitting all jobs wait for the job at the head of the queue to finish.\n+      Future<Boolean> oldestJob = mSyncPathJobs.peek();\n+      if (oldestJob == null) { // There might not be any jobs, restart the loop.\n+        continue;\n+      }\n+      try {\n+        oldestJob.get(); // block until the oldest job finished.\n+      } catch (InterruptedException | ExecutionException e) {\n+        if (e instanceof InterruptedException) {\n+          Thread.currentThread().interrupt();\n+        }\n+        LOG.warn(\"Interrupted while waiting for metadata sync job to finish\", e);\n+      }\n+    }\n+    LOG.info(\"TRACING - Synced {} paths\", syncPathCount);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aea2599ba2565e052e3871653282b3f22a325203"}, "originalPosition": 325}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMxNzY5NQ==", "bodyText": "Does it matter if the oldest job finishes first or last? How would that affect behavior?", "url": "https://github.com/Alluxio/alluxio/pull/11204#discussion_r418317695", "createdAt": "2020-04-30T22:10:25Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/master/file/InodeSyncStream.java", "diffHunk": "@@ -0,0 +1,810 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master.file;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.client.WriteType;\n+import alluxio.collections.Pair;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.exception.AccessControlException;\n+import alluxio.exception.BlockInfoException;\n+import alluxio.exception.DirectoryNotEmptyException;\n+import alluxio.exception.FileAlreadyCompletedException;\n+import alluxio.exception.FileAlreadyExistsException;\n+import alluxio.exception.FileDoesNotExistException;\n+import alluxio.exception.InvalidFileSizeException;\n+import alluxio.exception.InvalidPathException;\n+import alluxio.file.options.DescendantType;\n+import alluxio.grpc.CompleteFilePOptions;\n+import alluxio.grpc.DeletePOptions;\n+import alluxio.grpc.FileSystemMasterCommonPOptions;\n+import alluxio.grpc.GrpcUtils;\n+import alluxio.grpc.LoadDescendantPType;\n+import alluxio.grpc.LoadMetadataPOptions;\n+import alluxio.grpc.SetAttributePOptions;\n+import alluxio.master.file.contexts.CompleteFileContext;\n+import alluxio.master.file.contexts.CreateDirectoryContext;\n+import alluxio.master.file.contexts.CreateFileContext;\n+import alluxio.master.file.contexts.DeleteContext;\n+import alluxio.master.file.contexts.GetStatusContext;\n+import alluxio.master.file.contexts.LoadMetadataContext;\n+import alluxio.master.file.contexts.SetAttributeContext;\n+import alluxio.master.file.meta.Inode;\n+import alluxio.master.file.meta.InodeFile;\n+import alluxio.master.file.meta.InodeLockManager;\n+import alluxio.master.file.meta.InodeTree;\n+import alluxio.master.file.meta.InodeTree.LockPattern;\n+import alluxio.master.file.meta.LockedInodePath;\n+import alluxio.master.file.meta.LockingScheme;\n+import alluxio.master.file.meta.MountTable;\n+import alluxio.master.file.meta.UfsSyncPathCache;\n+import alluxio.master.file.meta.UfsSyncUtils;\n+import alluxio.master.metastore.ReadOnlyInodeStore;\n+import alluxio.resource.CloseableResource;\n+import alluxio.security.authorization.AccessControlList;\n+import alluxio.security.authorization.DefaultAccessControlList;\n+import alluxio.security.authorization.Mode;\n+import alluxio.underfs.Fingerprint;\n+import alluxio.underfs.UfsFileStatus;\n+import alluxio.underfs.UfsStatus;\n+import alluxio.underfs.UfsStatusCache;\n+import alluxio.underfs.UnderFileSystem;\n+import alluxio.util.interfaces.Scoped;\n+import alluxio.util.io.PathUtils;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+\n+/**\n+ * This class is responsible for maintaining the logic which surrounds syncing metadata between\n+ * Alluxio and its UFSes.\n+ *\n+ * This implementation uses a BFS-based approach to crawl the inode tree. In order to speed up\n+ * the sync process we use an {@link ExecutorService} which we submit inode paths to using\n+ * {@link #processSyncPath(AlluxioURI)}. The processing of inode paths will discover new paths to\n+ * sync depending on the {@link #mDescendantType}. Syncing is finished when all submitted tasks\n+ * are completed and there are no new inodes left in the queue.\n+ *\n+ * Syncing inode metadata requires making calls to the UFS. This implementation will schedule UFS\n+ * RPCs with the {@link UfsStatusCache#prefetchChildren(AlluxioURI, MountTable)}. Then, once the\n+ * inode begins processing, it can retrieve the results. After processing, it can then remove its\n+ * {@link UfsStatus} from the cache. This strategy helps reduce memory pressure on the master\n+ * while performing a sync for a large tree. Additionally, by using a prefetch mechanism we can\n+ * concurrently process other inodes while waiting for UFS RPCs to complete.\n+ *\n+ * With regards to locking, this class expects to be able to take a write lock on any inode, and\n+ * then subsequently downgrades or unlocks after the sync is finished. Even though we use\n+ * {@link java.util.concurrent.locks.ReentrantReadWriteLock}, because we concurrently process\n+ * inodes on separate threads, we cannot utilize the reetrnant behavior. The implications of\n+ * that mean the caller of this class must not hold a write while calling {@link #sync()}.\n+ *\n+ * A user of this class is expected to create a new instance for each path that they would like\n+ * to process. This is because the Lock on the {@link #mRootPath} may be changed after calling\n+ * {@link #sync()}.\n+ *\n+ */\n+public class InodeSyncStream {\n+  private static final Logger LOG = LoggerFactory.getLogger(InodeSyncStream.class);\n+\n+  /** The root path. Should be locked with a write lock. */\n+  private final LockedInodePath mRootPath;\n+\n+  /** A {@link UfsSyncPathCache} maintained from the {@link DefaultFileSystemMaster}. */\n+  private final UfsSyncPathCache mUfsSyncPathCache;\n+\n+  /** Object holding the {@link UfsStatus}es which may be required for syncing. */\n+  private final UfsStatusCache mStatusCache;\n+\n+  /** Inode tree to lock new paths. */\n+  private final InodeTree mInodeTree;\n+\n+  /** Determines how deep in the tree we need to load. */\n+  private final DescendantType mDescendantType;\n+\n+  /** The {@link RpcContext} from the caller. */\n+  private final RpcContext mRpcContext;\n+\n+  /** The inode store to look up children. */\n+  private final ReadOnlyInodeStore mInodeStore;\n+\n+  /** The mount table for looking up the proper UFS client based on the Alluxio path. */\n+  private final MountTable mMountTable;\n+\n+  /** The lock manager used to try acquiring the persisting lock. */\n+  private final InodeLockManager mInodeLockManager;\n+\n+  /** The FS master creating this object. */\n+  private final DefaultFileSystemMaster mFsMaster;\n+\n+  /** Set this to true to force a sync regardless of the UfsPathCache. */\n+  private final boolean mShouldSync;\n+\n+  /** The sync options on the RPC.  */\n+  private final FileSystemMasterCommonPOptions mSyncOptions;\n+\n+  /**\n+   * Whether the caller is {@link FileSystemMaster#getFileInfo(AlluxioURI, GetStatusContext)}.\n+   * This is used for the {@link #mUfsSyncPathCache}.\n+   */\n+  private final boolean mIsGetFileInfo;\n+\n+  /** Whether to only read+create metadata from the UFS, or to update metadata as well. */\n+  private final boolean mLoadOnly;\n+\n+  /** Queue used to keep track of paths that still need to be synced. */\n+  private final ConcurrentLinkedQueue<AlluxioURI> mSyncMetadataQ;\n+\n+  /** Queue of paths that have been submitted to the executor. */\n+  private final Queue<Future<Boolean>> mSyncPathJobs;\n+\n+  /** The executor enabling concurrent processing. */\n+  private final ExecutorService mMetadataSyncService;\n+\n+  /** The maximum number of concurrent paths that can be syncing at any moment. */\n+  private final int mConcurrencyLevel =\n+      ServerConfiguration.getInt(PropertyKey.MASTER_METADATA_SYNC_CONCURRENCY_LEVEL);\n+\n+  /**\n+   * Create a new instance of {@link InodeSyncStream}.\n+   *\n+   * The root path should be already locked with {@link LockPattern#WRITE_EDGE} unless the user is\n+   * only planning on loading metadata. The desired pattern should always be\n+   * {@link LockPattern#READ}.\n+   *\n+   * It is an error to initiate sync without a WRITE_EDGE lock when loadOnly is {@code false}.\n+   * If loadOnly is set to {@code true}, then the the root path may have a read lock.\n+   *\n+   * @param rootPath The root path to begin syncing\n+   * @param concurrencyService executor used to process paths concurrently\n+   * @param fsMaster the {@link FileSystemMaster} calling this method\n+   * @param inodeTree the {@link InodeTree}\n+   * @param inodeStore the {@link alluxio.master.metastore.InodeStore}\n+   * @param inodeLockManager the {@link InodeLockManager}\n+   * @param mountTable the master's {@link MountTable}\n+   * @param rpcContext the caller's {@link RpcContext}\n+   * @param descendantType determines the number of descendant inodes to sync\n+   * @param ufsSyncPathCache the sync path cache to determine when inodes should be synced\n+   * @param options the RPC's {@link FileSystemMasterCommonPOptions}\n+   * @param isGetFileInfo whether the caller is {@link FileSystemMaster#getFileInfo}\n+   * @param forceSync whether to sync inode metadata no matter what\n+   * @param loadOnly whether to only load new metadata, rather than update existing metadata\n+   */\n+  public InodeSyncStream(LockedInodePath rootPath, ExecutorService concurrencyService,\n+      DefaultFileSystemMaster fsMaster, InodeTree inodeTree, ReadOnlyInodeStore inodeStore,\n+      InodeLockManager inodeLockManager, MountTable mountTable, RpcContext rpcContext,\n+      DescendantType descendantType, UfsSyncPathCache ufsSyncPathCache,\n+      FileSystemMasterCommonPOptions options, boolean isGetFileInfo, boolean forceSync,\n+      boolean loadOnly) {\n+    mDescendantType = descendantType;\n+    mFsMaster = fsMaster;\n+    mSyncMetadataQ = new ConcurrentLinkedQueue<>();\n+    mInodeLockManager = inodeLockManager;\n+    mInodeStore = inodeStore;\n+    mInodeTree = inodeTree;\n+    mMountTable = mountTable;\n+    mRpcContext = rpcContext;\n+    mStatusCache = new UfsStatusCache(fsMaster.mSyncPrefetchExecutor);\n+    mUfsSyncPathCache = ufsSyncPathCache;\n+    mShouldSync = forceSync;\n+    mRootPath = rootPath;\n+    mSyncOptions = options;\n+    mIsGetFileInfo = isGetFileInfo;\n+    mLoadOnly = loadOnly;\n+    mSyncPathJobs = new LinkedList<>();\n+    mMetadataSyncService = concurrencyService;\n+  }\n+\n+  /**\n+   * Sync the metadata according the the root path the stream was created with.\n+   *\n+   * @return true if at least one path was synced\n+   */\n+  public boolean sync() {\n+    // The high-level process for the syncing is:\n+    // 1. Given an Alluxio path, determine if it is not consistent with the corresponding UFS path.\n+    //     this means the UFS path does not exist, or has metadata which differs from Alluxio\n+    // 2. If only the metadata changed, update the inode with the new metadata\n+    // 3. If the path does not exist in the UFS, delete the inode in Alluxio\n+    // 4. If not deleted, load metadata from the UFS\n+    // 5. If a recursive sync, add children inodes to sync queue\n+    int syncPathCount = 0;\n+    int stopNum = -1; // stop syncing when we've processed this many paths. -1 for infinite\n+\n+    try {\n+      syncInodeMetadata(mRootPath);\n+      syncPathCount++;\n+      if (mDescendantType == DescendantType.ONE) {\n+        // If descendantType is ONE, then we shouldn't process any more paths except for those\n+        // currently in the queue\n+        stopNum = mSyncMetadataQ.size();\n+      }\n+\n+      // process the sync result for the original path\n+      try {\n+        mRootPath.traverse();\n+      } catch (InvalidPathException e) {\n+        throw new RuntimeException(e);\n+      }\n+    } catch (AccessControlException | BlockInfoException | FileAlreadyCompletedException\n+        | FileDoesNotExistException | InvalidFileSizeException | InvalidPathException\n+        | IOException e) {\n+      LOG.warn(\"FAILED TO SYNC METADATA: {}\", e.getMessage(), e);\n+    } finally {\n+      // regardless of the outcome, remove the UfsStatus for this path from the cache\n+      mStatusCache.remove(mRootPath.getUri());\n+      // downgrade so that if operations are parallelized, the lock on the root doesn't restrict\n+      // concurrent operations\n+      mRootPath.downgradeToPattern(LockPattern.READ);\n+    }\n+\n+    // Process any children after the root.\n+    while (!mSyncMetadataQ.isEmpty() || !mSyncPathJobs.isEmpty()) {\n+      if (Thread.currentThread().isInterrupted()) {\n+        LOG.warn(\"Metadata syncing was interrupted before completion\");\n+        break;\n+      }\n+      // There are still paths to process\n+      // First, remove any futures which have completed. Add to the sync path count if they sync'd\n+      // successfully\n+      while (true) {\n+        Future<Boolean> job = mSyncPathJobs.peek();\n+        if (job == null || !job.isDone()) {\n+          break;\n+        }\n+        // remove the job because we know it is done.\n+        if (mSyncPathJobs.poll() != job) {\n+          throw new IllegalStateException(\"Last node to be de-queued was not equal to the expected\"\n+              + \"head of queue\");\n+        }\n+        try {\n+          // we synced the path successfully\n+          if (job.get()) {\n+            syncPathCount++;\n+          }\n+        } catch (InterruptedException | ExecutionException e) {\n+          if (e instanceof  InterruptedException) {\n+            Thread.currentThread().interrupt();\n+          }\n+          LOG.warn(\"metadata sync job was interrupted while waiting for completion\");\n+        }\n+      }\n+\n+      // When using descendant type of ONE, we need to stop prematurely.\n+      if (stopNum != -1 && syncPathCount > stopNum) {\n+        break;\n+      }\n+\n+      // We can submit up to ( max_concurrency - <jobs queue size>) jobs back into the queue\n+      int submissions = mConcurrencyLevel - mSyncPathJobs.size();\n+      for (int i = 0; i < submissions; i++) {\n+        AlluxioURI path = mSyncMetadataQ.poll();\n+        if (path == null) {\n+          // no paths left to sync\n+          break;\n+        }\n+        Future<Boolean> job = mMetadataSyncService.submit(() -> processSyncPath(path));\n+        mSyncPathJobs.offer(job);\n+      }\n+      // After submitting all jobs wait for the job at the head of the queue to finish.\n+      Future<Boolean> oldestJob = mSyncPathJobs.peek();\n+      if (oldestJob == null) { // There might not be any jobs, restart the loop.\n+        continue;\n+      }\n+      try {\n+        oldestJob.get(); // block until the oldest job finished.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aea2599ba2565e052e3871653282b3f22a325203"}, "originalPosition": 317}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMxNzczNw==", "bodyText": "add root path to message", "url": "https://github.com/Alluxio/alluxio/pull/11204#discussion_r418317737", "createdAt": "2020-04-30T22:10:32Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/master/file/InodeSyncStream.java", "diffHunk": "@@ -0,0 +1,810 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master.file;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.client.WriteType;\n+import alluxio.collections.Pair;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.exception.AccessControlException;\n+import alluxio.exception.BlockInfoException;\n+import alluxio.exception.DirectoryNotEmptyException;\n+import alluxio.exception.FileAlreadyCompletedException;\n+import alluxio.exception.FileAlreadyExistsException;\n+import alluxio.exception.FileDoesNotExistException;\n+import alluxio.exception.InvalidFileSizeException;\n+import alluxio.exception.InvalidPathException;\n+import alluxio.file.options.DescendantType;\n+import alluxio.grpc.CompleteFilePOptions;\n+import alluxio.grpc.DeletePOptions;\n+import alluxio.grpc.FileSystemMasterCommonPOptions;\n+import alluxio.grpc.GrpcUtils;\n+import alluxio.grpc.LoadDescendantPType;\n+import alluxio.grpc.LoadMetadataPOptions;\n+import alluxio.grpc.SetAttributePOptions;\n+import alluxio.master.file.contexts.CompleteFileContext;\n+import alluxio.master.file.contexts.CreateDirectoryContext;\n+import alluxio.master.file.contexts.CreateFileContext;\n+import alluxio.master.file.contexts.DeleteContext;\n+import alluxio.master.file.contexts.GetStatusContext;\n+import alluxio.master.file.contexts.LoadMetadataContext;\n+import alluxio.master.file.contexts.SetAttributeContext;\n+import alluxio.master.file.meta.Inode;\n+import alluxio.master.file.meta.InodeFile;\n+import alluxio.master.file.meta.InodeLockManager;\n+import alluxio.master.file.meta.InodeTree;\n+import alluxio.master.file.meta.InodeTree.LockPattern;\n+import alluxio.master.file.meta.LockedInodePath;\n+import alluxio.master.file.meta.LockingScheme;\n+import alluxio.master.file.meta.MountTable;\n+import alluxio.master.file.meta.UfsSyncPathCache;\n+import alluxio.master.file.meta.UfsSyncUtils;\n+import alluxio.master.metastore.ReadOnlyInodeStore;\n+import alluxio.resource.CloseableResource;\n+import alluxio.security.authorization.AccessControlList;\n+import alluxio.security.authorization.DefaultAccessControlList;\n+import alluxio.security.authorization.Mode;\n+import alluxio.underfs.Fingerprint;\n+import alluxio.underfs.UfsFileStatus;\n+import alluxio.underfs.UfsStatus;\n+import alluxio.underfs.UfsStatusCache;\n+import alluxio.underfs.UnderFileSystem;\n+import alluxio.util.interfaces.Scoped;\n+import alluxio.util.io.PathUtils;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+\n+/**\n+ * This class is responsible for maintaining the logic which surrounds syncing metadata between\n+ * Alluxio and its UFSes.\n+ *\n+ * This implementation uses a BFS-based approach to crawl the inode tree. In order to speed up\n+ * the sync process we use an {@link ExecutorService} which we submit inode paths to using\n+ * {@link #processSyncPath(AlluxioURI)}. The processing of inode paths will discover new paths to\n+ * sync depending on the {@link #mDescendantType}. Syncing is finished when all submitted tasks\n+ * are completed and there are no new inodes left in the queue.\n+ *\n+ * Syncing inode metadata requires making calls to the UFS. This implementation will schedule UFS\n+ * RPCs with the {@link UfsStatusCache#prefetchChildren(AlluxioURI, MountTable)}. Then, once the\n+ * inode begins processing, it can retrieve the results. After processing, it can then remove its\n+ * {@link UfsStatus} from the cache. This strategy helps reduce memory pressure on the master\n+ * while performing a sync for a large tree. Additionally, by using a prefetch mechanism we can\n+ * concurrently process other inodes while waiting for UFS RPCs to complete.\n+ *\n+ * With regards to locking, this class expects to be able to take a write lock on any inode, and\n+ * then subsequently downgrades or unlocks after the sync is finished. Even though we use\n+ * {@link java.util.concurrent.locks.ReentrantReadWriteLock}, because we concurrently process\n+ * inodes on separate threads, we cannot utilize the reetrnant behavior. The implications of\n+ * that mean the caller of this class must not hold a write while calling {@link #sync()}.\n+ *\n+ * A user of this class is expected to create a new instance for each path that they would like\n+ * to process. This is because the Lock on the {@link #mRootPath} may be changed after calling\n+ * {@link #sync()}.\n+ *\n+ */\n+public class InodeSyncStream {\n+  private static final Logger LOG = LoggerFactory.getLogger(InodeSyncStream.class);\n+\n+  /** The root path. Should be locked with a write lock. */\n+  private final LockedInodePath mRootPath;\n+\n+  /** A {@link UfsSyncPathCache} maintained from the {@link DefaultFileSystemMaster}. */\n+  private final UfsSyncPathCache mUfsSyncPathCache;\n+\n+  /** Object holding the {@link UfsStatus}es which may be required for syncing. */\n+  private final UfsStatusCache mStatusCache;\n+\n+  /** Inode tree to lock new paths. */\n+  private final InodeTree mInodeTree;\n+\n+  /** Determines how deep in the tree we need to load. */\n+  private final DescendantType mDescendantType;\n+\n+  /** The {@link RpcContext} from the caller. */\n+  private final RpcContext mRpcContext;\n+\n+  /** The inode store to look up children. */\n+  private final ReadOnlyInodeStore mInodeStore;\n+\n+  /** The mount table for looking up the proper UFS client based on the Alluxio path. */\n+  private final MountTable mMountTable;\n+\n+  /** The lock manager used to try acquiring the persisting lock. */\n+  private final InodeLockManager mInodeLockManager;\n+\n+  /** The FS master creating this object. */\n+  private final DefaultFileSystemMaster mFsMaster;\n+\n+  /** Set this to true to force a sync regardless of the UfsPathCache. */\n+  private final boolean mShouldSync;\n+\n+  /** The sync options on the RPC.  */\n+  private final FileSystemMasterCommonPOptions mSyncOptions;\n+\n+  /**\n+   * Whether the caller is {@link FileSystemMaster#getFileInfo(AlluxioURI, GetStatusContext)}.\n+   * This is used for the {@link #mUfsSyncPathCache}.\n+   */\n+  private final boolean mIsGetFileInfo;\n+\n+  /** Whether to only read+create metadata from the UFS, or to update metadata as well. */\n+  private final boolean mLoadOnly;\n+\n+  /** Queue used to keep track of paths that still need to be synced. */\n+  private final ConcurrentLinkedQueue<AlluxioURI> mSyncMetadataQ;\n+\n+  /** Queue of paths that have been submitted to the executor. */\n+  private final Queue<Future<Boolean>> mSyncPathJobs;\n+\n+  /** The executor enabling concurrent processing. */\n+  private final ExecutorService mMetadataSyncService;\n+\n+  /** The maximum number of concurrent paths that can be syncing at any moment. */\n+  private final int mConcurrencyLevel =\n+      ServerConfiguration.getInt(PropertyKey.MASTER_METADATA_SYNC_CONCURRENCY_LEVEL);\n+\n+  /**\n+   * Create a new instance of {@link InodeSyncStream}.\n+   *\n+   * The root path should be already locked with {@link LockPattern#WRITE_EDGE} unless the user is\n+   * only planning on loading metadata. The desired pattern should always be\n+   * {@link LockPattern#READ}.\n+   *\n+   * It is an error to initiate sync without a WRITE_EDGE lock when loadOnly is {@code false}.\n+   * If loadOnly is set to {@code true}, then the the root path may have a read lock.\n+   *\n+   * @param rootPath The root path to begin syncing\n+   * @param concurrencyService executor used to process paths concurrently\n+   * @param fsMaster the {@link FileSystemMaster} calling this method\n+   * @param inodeTree the {@link InodeTree}\n+   * @param inodeStore the {@link alluxio.master.metastore.InodeStore}\n+   * @param inodeLockManager the {@link InodeLockManager}\n+   * @param mountTable the master's {@link MountTable}\n+   * @param rpcContext the caller's {@link RpcContext}\n+   * @param descendantType determines the number of descendant inodes to sync\n+   * @param ufsSyncPathCache the sync path cache to determine when inodes should be synced\n+   * @param options the RPC's {@link FileSystemMasterCommonPOptions}\n+   * @param isGetFileInfo whether the caller is {@link FileSystemMaster#getFileInfo}\n+   * @param forceSync whether to sync inode metadata no matter what\n+   * @param loadOnly whether to only load new metadata, rather than update existing metadata\n+   */\n+  public InodeSyncStream(LockedInodePath rootPath, ExecutorService concurrencyService,\n+      DefaultFileSystemMaster fsMaster, InodeTree inodeTree, ReadOnlyInodeStore inodeStore,\n+      InodeLockManager inodeLockManager, MountTable mountTable, RpcContext rpcContext,\n+      DescendantType descendantType, UfsSyncPathCache ufsSyncPathCache,\n+      FileSystemMasterCommonPOptions options, boolean isGetFileInfo, boolean forceSync,\n+      boolean loadOnly) {\n+    mDescendantType = descendantType;\n+    mFsMaster = fsMaster;\n+    mSyncMetadataQ = new ConcurrentLinkedQueue<>();\n+    mInodeLockManager = inodeLockManager;\n+    mInodeStore = inodeStore;\n+    mInodeTree = inodeTree;\n+    mMountTable = mountTable;\n+    mRpcContext = rpcContext;\n+    mStatusCache = new UfsStatusCache(fsMaster.mSyncPrefetchExecutor);\n+    mUfsSyncPathCache = ufsSyncPathCache;\n+    mShouldSync = forceSync;\n+    mRootPath = rootPath;\n+    mSyncOptions = options;\n+    mIsGetFileInfo = isGetFileInfo;\n+    mLoadOnly = loadOnly;\n+    mSyncPathJobs = new LinkedList<>();\n+    mMetadataSyncService = concurrencyService;\n+  }\n+\n+  /**\n+   * Sync the metadata according the the root path the stream was created with.\n+   *\n+   * @return true if at least one path was synced\n+   */\n+  public boolean sync() {\n+    // The high-level process for the syncing is:\n+    // 1. Given an Alluxio path, determine if it is not consistent with the corresponding UFS path.\n+    //     this means the UFS path does not exist, or has metadata which differs from Alluxio\n+    // 2. If only the metadata changed, update the inode with the new metadata\n+    // 3. If the path does not exist in the UFS, delete the inode in Alluxio\n+    // 4. If not deleted, load metadata from the UFS\n+    // 5. If a recursive sync, add children inodes to sync queue\n+    int syncPathCount = 0;\n+    int stopNum = -1; // stop syncing when we've processed this many paths. -1 for infinite\n+\n+    try {\n+      syncInodeMetadata(mRootPath);\n+      syncPathCount++;\n+      if (mDescendantType == DescendantType.ONE) {\n+        // If descendantType is ONE, then we shouldn't process any more paths except for those\n+        // currently in the queue\n+        stopNum = mSyncMetadataQ.size();\n+      }\n+\n+      // process the sync result for the original path\n+      try {\n+        mRootPath.traverse();\n+      } catch (InvalidPathException e) {\n+        throw new RuntimeException(e);\n+      }\n+    } catch (AccessControlException | BlockInfoException | FileAlreadyCompletedException\n+        | FileDoesNotExistException | InvalidFileSizeException | InvalidPathException\n+        | IOException e) {\n+      LOG.warn(\"FAILED TO SYNC METADATA: {}\", e.getMessage(), e);\n+    } finally {\n+      // regardless of the outcome, remove the UfsStatus for this path from the cache\n+      mStatusCache.remove(mRootPath.getUri());\n+      // downgrade so that if operations are parallelized, the lock on the root doesn't restrict\n+      // concurrent operations\n+      mRootPath.downgradeToPattern(LockPattern.READ);\n+    }\n+\n+    // Process any children after the root.\n+    while (!mSyncMetadataQ.isEmpty() || !mSyncPathJobs.isEmpty()) {\n+      if (Thread.currentThread().isInterrupted()) {\n+        LOG.warn(\"Metadata syncing was interrupted before completion\");\n+        break;\n+      }\n+      // There are still paths to process\n+      // First, remove any futures which have completed. Add to the sync path count if they sync'd\n+      // successfully\n+      while (true) {\n+        Future<Boolean> job = mSyncPathJobs.peek();\n+        if (job == null || !job.isDone()) {\n+          break;\n+        }\n+        // remove the job because we know it is done.\n+        if (mSyncPathJobs.poll() != job) {\n+          throw new IllegalStateException(\"Last node to be de-queued was not equal to the expected\"\n+              + \"head of queue\");\n+        }\n+        try {\n+          // we synced the path successfully\n+          if (job.get()) {\n+            syncPathCount++;\n+          }\n+        } catch (InterruptedException | ExecutionException e) {\n+          if (e instanceof  InterruptedException) {\n+            Thread.currentThread().interrupt();\n+          }\n+          LOG.warn(\"metadata sync job was interrupted while waiting for completion\");\n+        }\n+      }\n+\n+      // When using descendant type of ONE, we need to stop prematurely.\n+      if (stopNum != -1 && syncPathCount > stopNum) {\n+        break;\n+      }\n+\n+      // We can submit up to ( max_concurrency - <jobs queue size>) jobs back into the queue\n+      int submissions = mConcurrencyLevel - mSyncPathJobs.size();\n+      for (int i = 0; i < submissions; i++) {\n+        AlluxioURI path = mSyncMetadataQ.poll();\n+        if (path == null) {\n+          // no paths left to sync\n+          break;\n+        }\n+        Future<Boolean> job = mMetadataSyncService.submit(() -> processSyncPath(path));\n+        mSyncPathJobs.offer(job);\n+      }\n+      // After submitting all jobs wait for the job at the head of the queue to finish.\n+      Future<Boolean> oldestJob = mSyncPathJobs.peek();\n+      if (oldestJob == null) { // There might not be any jobs, restart the loop.\n+        continue;\n+      }\n+      try {\n+        oldestJob.get(); // block until the oldest job finished.\n+      } catch (InterruptedException | ExecutionException e) {\n+        if (e instanceof InterruptedException) {\n+          Thread.currentThread().interrupt();\n+        }\n+        LOG.warn(\"Interrupted while waiting for metadata sync job to finish\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aea2599ba2565e052e3871653282b3f22a325203"}, "originalPosition": 322}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMxODAxNw==", "bodyText": "all caps?", "url": "https://github.com/Alluxio/alluxio/pull/11204#discussion_r418318017", "createdAt": "2020-04-30T22:11:15Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/master/file/InodeSyncStream.java", "diffHunk": "@@ -0,0 +1,810 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master.file;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.client.WriteType;\n+import alluxio.collections.Pair;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.exception.AccessControlException;\n+import alluxio.exception.BlockInfoException;\n+import alluxio.exception.DirectoryNotEmptyException;\n+import alluxio.exception.FileAlreadyCompletedException;\n+import alluxio.exception.FileAlreadyExistsException;\n+import alluxio.exception.FileDoesNotExistException;\n+import alluxio.exception.InvalidFileSizeException;\n+import alluxio.exception.InvalidPathException;\n+import alluxio.file.options.DescendantType;\n+import alluxio.grpc.CompleteFilePOptions;\n+import alluxio.grpc.DeletePOptions;\n+import alluxio.grpc.FileSystemMasterCommonPOptions;\n+import alluxio.grpc.GrpcUtils;\n+import alluxio.grpc.LoadDescendantPType;\n+import alluxio.grpc.LoadMetadataPOptions;\n+import alluxio.grpc.SetAttributePOptions;\n+import alluxio.master.file.contexts.CompleteFileContext;\n+import alluxio.master.file.contexts.CreateDirectoryContext;\n+import alluxio.master.file.contexts.CreateFileContext;\n+import alluxio.master.file.contexts.DeleteContext;\n+import alluxio.master.file.contexts.GetStatusContext;\n+import alluxio.master.file.contexts.LoadMetadataContext;\n+import alluxio.master.file.contexts.SetAttributeContext;\n+import alluxio.master.file.meta.Inode;\n+import alluxio.master.file.meta.InodeFile;\n+import alluxio.master.file.meta.InodeLockManager;\n+import alluxio.master.file.meta.InodeTree;\n+import alluxio.master.file.meta.InodeTree.LockPattern;\n+import alluxio.master.file.meta.LockedInodePath;\n+import alluxio.master.file.meta.LockingScheme;\n+import alluxio.master.file.meta.MountTable;\n+import alluxio.master.file.meta.UfsSyncPathCache;\n+import alluxio.master.file.meta.UfsSyncUtils;\n+import alluxio.master.metastore.ReadOnlyInodeStore;\n+import alluxio.resource.CloseableResource;\n+import alluxio.security.authorization.AccessControlList;\n+import alluxio.security.authorization.DefaultAccessControlList;\n+import alluxio.security.authorization.Mode;\n+import alluxio.underfs.Fingerprint;\n+import alluxio.underfs.UfsFileStatus;\n+import alluxio.underfs.UfsStatus;\n+import alluxio.underfs.UfsStatusCache;\n+import alluxio.underfs.UnderFileSystem;\n+import alluxio.util.interfaces.Scoped;\n+import alluxio.util.io.PathUtils;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+\n+/**\n+ * This class is responsible for maintaining the logic which surrounds syncing metadata between\n+ * Alluxio and its UFSes.\n+ *\n+ * This implementation uses a BFS-based approach to crawl the inode tree. In order to speed up\n+ * the sync process we use an {@link ExecutorService} which we submit inode paths to using\n+ * {@link #processSyncPath(AlluxioURI)}. The processing of inode paths will discover new paths to\n+ * sync depending on the {@link #mDescendantType}. Syncing is finished when all submitted tasks\n+ * are completed and there are no new inodes left in the queue.\n+ *\n+ * Syncing inode metadata requires making calls to the UFS. This implementation will schedule UFS\n+ * RPCs with the {@link UfsStatusCache#prefetchChildren(AlluxioURI, MountTable)}. Then, once the\n+ * inode begins processing, it can retrieve the results. After processing, it can then remove its\n+ * {@link UfsStatus} from the cache. This strategy helps reduce memory pressure on the master\n+ * while performing a sync for a large tree. Additionally, by using a prefetch mechanism we can\n+ * concurrently process other inodes while waiting for UFS RPCs to complete.\n+ *\n+ * With regards to locking, this class expects to be able to take a write lock on any inode, and\n+ * then subsequently downgrades or unlocks after the sync is finished. Even though we use\n+ * {@link java.util.concurrent.locks.ReentrantReadWriteLock}, because we concurrently process\n+ * inodes on separate threads, we cannot utilize the reetrnant behavior. The implications of\n+ * that mean the caller of this class must not hold a write while calling {@link #sync()}.\n+ *\n+ * A user of this class is expected to create a new instance for each path that they would like\n+ * to process. This is because the Lock on the {@link #mRootPath} may be changed after calling\n+ * {@link #sync()}.\n+ *\n+ */\n+public class InodeSyncStream {\n+  private static final Logger LOG = LoggerFactory.getLogger(InodeSyncStream.class);\n+\n+  /** The root path. Should be locked with a write lock. */\n+  private final LockedInodePath mRootPath;\n+\n+  /** A {@link UfsSyncPathCache} maintained from the {@link DefaultFileSystemMaster}. */\n+  private final UfsSyncPathCache mUfsSyncPathCache;\n+\n+  /** Object holding the {@link UfsStatus}es which may be required for syncing. */\n+  private final UfsStatusCache mStatusCache;\n+\n+  /** Inode tree to lock new paths. */\n+  private final InodeTree mInodeTree;\n+\n+  /** Determines how deep in the tree we need to load. */\n+  private final DescendantType mDescendantType;\n+\n+  /** The {@link RpcContext} from the caller. */\n+  private final RpcContext mRpcContext;\n+\n+  /** The inode store to look up children. */\n+  private final ReadOnlyInodeStore mInodeStore;\n+\n+  /** The mount table for looking up the proper UFS client based on the Alluxio path. */\n+  private final MountTable mMountTable;\n+\n+  /** The lock manager used to try acquiring the persisting lock. */\n+  private final InodeLockManager mInodeLockManager;\n+\n+  /** The FS master creating this object. */\n+  private final DefaultFileSystemMaster mFsMaster;\n+\n+  /** Set this to true to force a sync regardless of the UfsPathCache. */\n+  private final boolean mShouldSync;\n+\n+  /** The sync options on the RPC.  */\n+  private final FileSystemMasterCommonPOptions mSyncOptions;\n+\n+  /**\n+   * Whether the caller is {@link FileSystemMaster#getFileInfo(AlluxioURI, GetStatusContext)}.\n+   * This is used for the {@link #mUfsSyncPathCache}.\n+   */\n+  private final boolean mIsGetFileInfo;\n+\n+  /** Whether to only read+create metadata from the UFS, or to update metadata as well. */\n+  private final boolean mLoadOnly;\n+\n+  /** Queue used to keep track of paths that still need to be synced. */\n+  private final ConcurrentLinkedQueue<AlluxioURI> mSyncMetadataQ;\n+\n+  /** Queue of paths that have been submitted to the executor. */\n+  private final Queue<Future<Boolean>> mSyncPathJobs;\n+\n+  /** The executor enabling concurrent processing. */\n+  private final ExecutorService mMetadataSyncService;\n+\n+  /** The maximum number of concurrent paths that can be syncing at any moment. */\n+  private final int mConcurrencyLevel =\n+      ServerConfiguration.getInt(PropertyKey.MASTER_METADATA_SYNC_CONCURRENCY_LEVEL);\n+\n+  /**\n+   * Create a new instance of {@link InodeSyncStream}.\n+   *\n+   * The root path should be already locked with {@link LockPattern#WRITE_EDGE} unless the user is\n+   * only planning on loading metadata. The desired pattern should always be\n+   * {@link LockPattern#READ}.\n+   *\n+   * It is an error to initiate sync without a WRITE_EDGE lock when loadOnly is {@code false}.\n+   * If loadOnly is set to {@code true}, then the the root path may have a read lock.\n+   *\n+   * @param rootPath The root path to begin syncing\n+   * @param concurrencyService executor used to process paths concurrently\n+   * @param fsMaster the {@link FileSystemMaster} calling this method\n+   * @param inodeTree the {@link InodeTree}\n+   * @param inodeStore the {@link alluxio.master.metastore.InodeStore}\n+   * @param inodeLockManager the {@link InodeLockManager}\n+   * @param mountTable the master's {@link MountTable}\n+   * @param rpcContext the caller's {@link RpcContext}\n+   * @param descendantType determines the number of descendant inodes to sync\n+   * @param ufsSyncPathCache the sync path cache to determine when inodes should be synced\n+   * @param options the RPC's {@link FileSystemMasterCommonPOptions}\n+   * @param isGetFileInfo whether the caller is {@link FileSystemMaster#getFileInfo}\n+   * @param forceSync whether to sync inode metadata no matter what\n+   * @param loadOnly whether to only load new metadata, rather than update existing metadata\n+   */\n+  public InodeSyncStream(LockedInodePath rootPath, ExecutorService concurrencyService,\n+      DefaultFileSystemMaster fsMaster, InodeTree inodeTree, ReadOnlyInodeStore inodeStore,\n+      InodeLockManager inodeLockManager, MountTable mountTable, RpcContext rpcContext,\n+      DescendantType descendantType, UfsSyncPathCache ufsSyncPathCache,\n+      FileSystemMasterCommonPOptions options, boolean isGetFileInfo, boolean forceSync,\n+      boolean loadOnly) {\n+    mDescendantType = descendantType;\n+    mFsMaster = fsMaster;\n+    mSyncMetadataQ = new ConcurrentLinkedQueue<>();\n+    mInodeLockManager = inodeLockManager;\n+    mInodeStore = inodeStore;\n+    mInodeTree = inodeTree;\n+    mMountTable = mountTable;\n+    mRpcContext = rpcContext;\n+    mStatusCache = new UfsStatusCache(fsMaster.mSyncPrefetchExecutor);\n+    mUfsSyncPathCache = ufsSyncPathCache;\n+    mShouldSync = forceSync;\n+    mRootPath = rootPath;\n+    mSyncOptions = options;\n+    mIsGetFileInfo = isGetFileInfo;\n+    mLoadOnly = loadOnly;\n+    mSyncPathJobs = new LinkedList<>();\n+    mMetadataSyncService = concurrencyService;\n+  }\n+\n+  /**\n+   * Sync the metadata according the the root path the stream was created with.\n+   *\n+   * @return true if at least one path was synced\n+   */\n+  public boolean sync() {\n+    // The high-level process for the syncing is:\n+    // 1. Given an Alluxio path, determine if it is not consistent with the corresponding UFS path.\n+    //     this means the UFS path does not exist, or has metadata which differs from Alluxio\n+    // 2. If only the metadata changed, update the inode with the new metadata\n+    // 3. If the path does not exist in the UFS, delete the inode in Alluxio\n+    // 4. If not deleted, load metadata from the UFS\n+    // 5. If a recursive sync, add children inodes to sync queue\n+    int syncPathCount = 0;\n+    int stopNum = -1; // stop syncing when we've processed this many paths. -1 for infinite\n+\n+    try {\n+      syncInodeMetadata(mRootPath);\n+      syncPathCount++;\n+      if (mDescendantType == DescendantType.ONE) {\n+        // If descendantType is ONE, then we shouldn't process any more paths except for those\n+        // currently in the queue\n+        stopNum = mSyncMetadataQ.size();\n+      }\n+\n+      // process the sync result for the original path\n+      try {\n+        mRootPath.traverse();\n+      } catch (InvalidPathException e) {\n+        throw new RuntimeException(e);\n+      }\n+    } catch (AccessControlException | BlockInfoException | FileAlreadyCompletedException\n+        | FileDoesNotExistException | InvalidFileSizeException | InvalidPathException\n+        | IOException e) {\n+      LOG.warn(\"FAILED TO SYNC METADATA: {}\", e.getMessage(), e);\n+    } finally {\n+      // regardless of the outcome, remove the UfsStatus for this path from the cache\n+      mStatusCache.remove(mRootPath.getUri());\n+      // downgrade so that if operations are parallelized, the lock on the root doesn't restrict\n+      // concurrent operations\n+      mRootPath.downgradeToPattern(LockPattern.READ);\n+    }\n+\n+    // Process any children after the root.\n+    while (!mSyncMetadataQ.isEmpty() || !mSyncPathJobs.isEmpty()) {\n+      if (Thread.currentThread().isInterrupted()) {\n+        LOG.warn(\"Metadata syncing was interrupted before completion\");\n+        break;\n+      }\n+      // There are still paths to process\n+      // First, remove any futures which have completed. Add to the sync path count if they sync'd\n+      // successfully\n+      while (true) {\n+        Future<Boolean> job = mSyncPathJobs.peek();\n+        if (job == null || !job.isDone()) {\n+          break;\n+        }\n+        // remove the job because we know it is done.\n+        if (mSyncPathJobs.poll() != job) {\n+          throw new IllegalStateException(\"Last node to be de-queued was not equal to the expected\"\n+              + \"head of queue\");\n+        }\n+        try {\n+          // we synced the path successfully\n+          if (job.get()) {\n+            syncPathCount++;\n+          }\n+        } catch (InterruptedException | ExecutionException e) {\n+          if (e instanceof  InterruptedException) {\n+            Thread.currentThread().interrupt();\n+          }\n+          LOG.warn(\"metadata sync job was interrupted while waiting for completion\");\n+        }\n+      }\n+\n+      // When using descendant type of ONE, we need to stop prematurely.\n+      if (stopNum != -1 && syncPathCount > stopNum) {\n+        break;\n+      }\n+\n+      // We can submit up to ( max_concurrency - <jobs queue size>) jobs back into the queue\n+      int submissions = mConcurrencyLevel - mSyncPathJobs.size();\n+      for (int i = 0; i < submissions; i++) {\n+        AlluxioURI path = mSyncMetadataQ.poll();\n+        if (path == null) {\n+          // no paths left to sync\n+          break;\n+        }\n+        Future<Boolean> job = mMetadataSyncService.submit(() -> processSyncPath(path));\n+        mSyncPathJobs.offer(job);\n+      }\n+      // After submitting all jobs wait for the job at the head of the queue to finish.\n+      Future<Boolean> oldestJob = mSyncPathJobs.peek();\n+      if (oldestJob == null) { // There might not be any jobs, restart the loop.\n+        continue;\n+      }\n+      try {\n+        oldestJob.get(); // block until the oldest job finished.\n+      } catch (InterruptedException | ExecutionException e) {\n+        if (e instanceof InterruptedException) {\n+          Thread.currentThread().interrupt();\n+        }\n+        LOG.warn(\"Interrupted while waiting for metadata sync job to finish\", e);\n+      }\n+    }\n+    LOG.info(\"TRACING - Synced {} paths\", syncPathCount);\n+    mStatusCache.cancelAllPrefetch();\n+    mSyncPathJobs.forEach(f -> f.cancel(true));\n+    return syncPathCount > 0;\n+  }\n+\n+  /**\n+   * Process a path to sync.\n+   *\n+   * This can update metadata for the inode, delete the inode, and/or queue any children that should\n+   * be synced as well.\n+   *\n+   * @param path The path to sync\n+   * @return true if this path was synced\n+   */\n+  private boolean processSyncPath(AlluxioURI path) {\n+    if (path == null) {\n+      return false;\n+    }\n+    LockingScheme scheme;\n+    if (mShouldSync) {\n+      scheme = new LockingScheme(path, LockPattern.READ, true);\n+    } else {\n+      scheme = new LockingScheme(path, LockPattern.READ, mSyncOptions,\n+          mUfsSyncPathCache, mIsGetFileInfo);\n+    }\n+\n+    if (!scheme.shouldSync() && !mShouldSync) {\n+      return false;\n+    }\n+    try (LockedInodePath inodePath = mInodeTree.tryLockInodePath(scheme)) {\n+      if (Thread.currentThread().isInterrupted()) {\n+        LOG.warn(\"Thread syncing {} was interrupted before completion\", inodePath.getUri());\n+        return false;\n+      }\n+      syncInodeMetadata(inodePath);\n+      return true;\n+    } catch (AccessControlException | BlockInfoException | FileAlreadyCompletedException\n+        | FileDoesNotExistException | InvalidFileSizeException | InvalidPathException\n+        | IOException e) {\n+      LOG.warn(\"FAILED TO SYNC METADATA: {}\", e.getMessage(), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aea2599ba2565e052e3871653282b3f22a325203"}, "originalPosition": 365}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1MTY1NTMy", "url": "https://github.com/Alluxio/alluxio/pull/11204#pullrequestreview-405165532", "createdAt": "2020-05-04T16:49:05Z", "commit": {"oid": "ff8a137d843dabc6cb4b38fb5ae7a324cae6fec4"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNjo0OTowNVrOGQI-7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQxNzoxNDoxOFrOGQJ-pQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU3NzU4Mg==", "bodyText": "Well, if we keep calling prefetchChildren, it will never terminate if we keep taking the latest request (and canceling the previous one), right?", "url": "https://github.com/Alluxio/alluxio/pull/11204#discussion_r419577582", "createdAt": "2020-05-04T16:49:05Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/underfs/UfsStatusCache.java", "diffHunk": "@@ -0,0 +1,275 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.underfs;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.collections.ConcurrentHashSet;\n+import alluxio.exception.InvalidPathException;\n+import alluxio.master.file.meta.MountTable;\n+import alluxio.resource.CloseableResource;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nullable;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.RejectedExecutionException;\n+\n+/**\n+ * This class is a cache from an Alluxio namespace URI ({@link AlluxioURI}, i.e. /path/to/inode) to\n+ * UFS statuses.\n+ *\n+ * It also allows associating a path with child inodes, so that the statuses for a specific path can\n+ * be searched for later.\n+ */\n+public class UfsStatusCache {\n+  private static final Logger LOG = LoggerFactory.getLogger(UfsStatusCache.class);\n+\n+  private final ConcurrentHashMap<AlluxioURI, UfsStatus> mStatuses;\n+  private final ConcurrentHashMap<AlluxioURI, Future<Collection<UfsStatus>>> mActivePrefetchJobs;\n+  private final ConcurrentHashMap<AlluxioURI, Collection<UfsStatus>> mChildren;\n+  private final ExecutorService mPrefetchExecutor;\n+\n+  /**\n+   * Create a new instance of {@link UfsStatusCache}.\n+   *\n+   * @param prefetchExecutor the executor service used to prefetch statuses\n+   */\n+  public UfsStatusCache(@Nullable ExecutorService prefetchExecutor) {\n+    mStatuses = new ConcurrentHashMap<>();\n+    mChildren = new ConcurrentHashMap<>();\n+    mActivePrefetchJobs = new ConcurrentHashMap<>();\n+    mPrefetchExecutor = prefetchExecutor;\n+  }\n+\n+  /**\n+   * Add a new status to the cache.\n+   *\n+   * The last component of the path in the {@link AlluxioURI} must match the result of\n+   * {@link UfsStatus#getName()}. This method overrides any status currently cached for the same\n+   * URI.\n+   *\n+   * @param path the Alluxio path to key on\n+   * @param status the ufs status to store\n+   * @throws IllegalArgumentException if the status name doesn't match the final URI path component\n+   */\n+  public void addStatus(AlluxioURI path, UfsStatus status) {\n+    UfsStatus prev = mStatuses.putIfAbsent(path, status);\n+    if (!path.getName().equals(status.getName())) {\n+      throw new IllegalArgumentException(\n+          String.format(\"path name %s does not match ufs status name %s\",\n+              path.getName(), status.getName()));\n+    }\n+  }\n+\n+  /**\n+   * Add a parent-child mapping to the status cache.\n+   *\n+   * All child statuses added via this method will be available via {@link #getStatus(AlluxioURI)}.\n+   *\n+   * @param path the directory inode path which contains the children\n+   * @param children the children of the {@code path}\n+   * @throws IllegalArgumentException when {@code path} already exists or if any child already\n+   *                                  exists\n+   */\n+  public void addChildren(AlluxioURI path, Collection<UfsStatus> children) {\n+    UfsStatus status = mStatuses.get(path);\n+    // If this path doesn't yet exist, we can't keep track of the parent-child relationship\n+    // We can still add statuses to the cache regardless\n+    if (status != null) {\n+      mChildren.computeIfAbsent(path, ufsStatus -> new ConcurrentHashSet<>()).addAll(children);\n+    }\n+    children.forEach(child -> {\n+      AlluxioURI childPath = path.joinUnsafe(child.getName());\n+      addStatus(childPath, child);\n+    });\n+  }\n+\n+  /**\n+   * Remove a status from the cache.\n+   *\n+   *  Any children added to this status will remain in the cache.\n+   *\n+   * @param path the path corresponding to the {@link UfsStatus} to remove\n+   * @return the removed UfsStatus\n+   */\n+  public UfsStatus remove(AlluxioURI path) {\n+    UfsStatus removed = mStatuses.remove(path);\n+    if (removed == null) {\n+      return null;\n+    }\n+\n+    mChildren.remove(path); // ok if there aren't any children\n+    return removed;\n+  }\n+\n+  /**\n+   * Get the UfsStatus from a given AlluxioURI.\n+   *\n+   * @param path the path the retrieve\n+   * @return The corresponding {@link UfsStatus} or {@code null} if there is none stored\n+   */\n+  public UfsStatus getStatus(AlluxioURI path) {\n+    return mStatuses.get(path);\n+  }\n+\n+  /**\n+   * Fetches children of a given alluxio path, stores them in the cache, then returns them.\n+   *\n+   * Children can be returned in a few ways\n+   * 1. Children already exist in the internal index. We simply return them\n+   * 2. If children did not already exist in the index, then check if there was a scheduled\n+   * prefetch job running for this path. If so, wait for the job to finish and return the result.\n+   * 3. If no prefetch job, and children don't yet exist in the cache, then if the fallback\n+   * parameter is true, fetch them from the UFS and store them in the cache. Otherwise, simply\n+   * return null.\n+   *\n+   * @param path the Alluxio path to get the children of\n+   * @param mountTable the Alluxio mount table\n+   * @param useFallback whether or not to fall back to calling the UFS\n+   * @return child UFS statuses of the alluxio path, or null if no prefetch job and fallback\n+   *         specified as false\n+   * @throws InvalidPathException if the alluxio path can't be resolved to a UFS mount\n+   */\n+  @Nullable\n+  public Collection<UfsStatus> fetchChildrenIfAbsent(AlluxioURI path, MountTable mountTable,\n+      boolean useFallback)\n+      throws IOException, InvalidPathException {\n+    Collection<UfsStatus> children = getChildren(path);\n+    if (children != null) {\n+      return children;\n+    }\n+    Future<Collection<UfsStatus>> prefetchJob = mActivePrefetchJobs.remove(path);\n+    if (prefetchJob != null) {\n+      try {\n+        return prefetchJob.get();\n+      } catch (InterruptedException | ExecutionException e) {\n+        LOG.warn(\"Failed waiting to fetch children at {}\", path);\n+        if (e instanceof  InterruptedException) {\n+          Thread.currentThread().interrupt();\n+        }\n+        throw new IOException(e);\n+      }\n+    }\n+    if (useFallback) {\n+      return getChildrenIfAbsent(path, mountTable);\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * Fetches children of a given alluxio path stores them in the cache, then returns them.\n+   *\n+   * Will always return statuses from the UFS whether or not they exist in the cache, and whether\n+   * a prefetch job was scheduled or not.\n+   *\n+   * @param path the Alluxio path\n+   * @param mountTable the Alluxio mount table\n+   * @return child UFS statuses of the alluxio path\n+   * @throws InvalidPathException if the alluxio path can't be resolved to a UFS mount\n+   * @see {@link #fetchChildrenIfAbsent(AlluxioURI, MountTable, boolean)}\n+   */\n+  public Collection<UfsStatus> fetchChildrenIfAbsent(AlluxioURI path, MountTable mountTable)\n+      throws IOException, InvalidPathException {\n+    return fetchChildrenIfAbsent(path, mountTable, true);\n+  }\n+\n+  /**\n+   * Retrieves the child UFS statuses for a given path and stores them in the cache.\n+   *\n+   * This method first checks if the children have already been retrieved, and if not, then\n+   * retrieves them.\n+\n+   * @param path the path to get the children for\n+   * @param mountTable the Alluxio mount table\n+   * @return the child statuses that were stored in the cache, or null if the UFS couldn't list the\n+   *         statuses\n+   * @throws InvalidPathException when the table can't resolve the mount for the given URI\n+   */\n+  @Nullable\n+  private Collection<UfsStatus> getChildrenIfAbsent(AlluxioURI path, MountTable mountTable)\n+      throws InvalidPathException {\n+    Collection<UfsStatus> children = getChildren(path);\n+    if (children != null) {\n+      return children;\n+    }\n+    MountTable.Resolution resolution = mountTable.resolve(path);\n+    AlluxioURI ufsUri = resolution.getUri();\n+    try (CloseableResource<UnderFileSystem> ufsResource = resolution.acquireUfsResource()) {\n+      UnderFileSystem ufs = ufsResource.get();\n+      UfsStatus[] statuses = ufs.listStatus(ufsUri.toString());\n+      if (statuses == null) {\n+        return null;\n+      }\n+      children = Arrays.asList(statuses);\n+      addChildren(path, children);\n+    } catch (IllegalArgumentException | IOException e) {\n+      LOG.debug(\"Failed to add status to cache\", e);\n+    }\n+    return children;\n+  }\n+\n+  /**\n+   * Get the child {@link UfsStatus}es from a given {@link AlluxioURI}.\n+   *\n+   * @param path the path the retrieve\n+   * @return The corresponding {@link UfsStatus} or {@code null} if there is none stored\n+   */\n+  @Nullable\n+  public Collection<UfsStatus> getChildren(AlluxioURI path) {\n+    return mChildren.get(path);\n+  }\n+\n+  /**\n+   * Submit a request to asynchronously fetch the statuses corresponding to a given directory.\n+   *\n+   * Retrieve any fetched statuses by calling {@link #fetchChildrenIfAbsent(AlluxioURI, MountTable)}\n+   * with the same Alluxio path.\n+   *\n+   * If no {@link ExecutorService} was provided to this object before instantiation, this method is\n+   * a no-op.\n+   *\n+   * @param path the path to prefetch\n+   * @param mountTable the Alluxio mount table\n+   */\n+  public void prefetchChildren(AlluxioURI path, MountTable mountTable) {\n+    if (mPrefetchExecutor == null) {\n+      return;\n+    }\n+    try {\n+      Future<Collection<UfsStatus>> fute =\n+          mPrefetchExecutor.submit(() -> getChildrenIfAbsent(path, mountTable));\n+      Future<Collection<UfsStatus>> prev = mActivePrefetchJobs.put(path, fute);\n+      if (prev != null) {\n+        prev.cancel(true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMwMjUyNg=="}, "originalCommit": {"oid": "aea2599ba2565e052e3871653282b3f22a325203"}, "originalPosition": 259}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU4MDI3Mg==", "bodyText": "Ok, so if the structure is /parent/child and /parent is removed, it looks like the child listing is removed for /parent, but the status may still remain for /parent/child?\nIs this status cache supposed to be thread safe?", "url": "https://github.com/Alluxio/alluxio/pull/11204#discussion_r419580272", "createdAt": "2020-05-04T16:53:06Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/underfs/UfsStatusCache.java", "diffHunk": "@@ -0,0 +1,275 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.underfs;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.collections.ConcurrentHashSet;\n+import alluxio.exception.InvalidPathException;\n+import alluxio.master.file.meta.MountTable;\n+import alluxio.resource.CloseableResource;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nullable;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.RejectedExecutionException;\n+\n+/**\n+ * This class is a cache from an Alluxio namespace URI ({@link AlluxioURI}, i.e. /path/to/inode) to\n+ * UFS statuses.\n+ *\n+ * It also allows associating a path with child inodes, so that the statuses for a specific path can\n+ * be searched for later.\n+ */\n+public class UfsStatusCache {\n+  private static final Logger LOG = LoggerFactory.getLogger(UfsStatusCache.class);\n+\n+  private final ConcurrentHashMap<AlluxioURI, UfsStatus> mStatuses;\n+  private final ConcurrentHashMap<AlluxioURI, Future<Collection<UfsStatus>>> mActivePrefetchJobs;\n+  private final ConcurrentHashMap<AlluxioURI, Collection<UfsStatus>> mChildren;\n+  private final ExecutorService mPrefetchExecutor;\n+\n+  /**\n+   * Create a new instance of {@link UfsStatusCache}.\n+   *\n+   * @param prefetchExecutor the executor service used to prefetch statuses\n+   */\n+  public UfsStatusCache(@Nullable ExecutorService prefetchExecutor) {\n+    mStatuses = new ConcurrentHashMap<>();\n+    mChildren = new ConcurrentHashMap<>();\n+    mActivePrefetchJobs = new ConcurrentHashMap<>();\n+    mPrefetchExecutor = prefetchExecutor;\n+  }\n+\n+  /**\n+   * Add a new status to the cache.\n+   *\n+   * The last component of the path in the {@link AlluxioURI} must match the result of\n+   * {@link UfsStatus#getName()}. This method overrides any status currently cached for the same\n+   * URI.\n+   *\n+   * @param path the Alluxio path to key on\n+   * @param status the ufs status to store\n+   * @throws IllegalArgumentException if the status name doesn't match the final URI path component\n+   */\n+  public void addStatus(AlluxioURI path, UfsStatus status) {\n+    UfsStatus prev = mStatuses.putIfAbsent(path, status);\n+    if (!path.getName().equals(status.getName())) {\n+      throw new IllegalArgumentException(\n+          String.format(\"path name %s does not match ufs status name %s\",\n+              path.getName(), status.getName()));\n+    }\n+  }\n+\n+  /**\n+   * Add a parent-child mapping to the status cache.\n+   *\n+   * All child statuses added via this method will be available via {@link #getStatus(AlluxioURI)}.\n+   *\n+   * @param path the directory inode path which contains the children\n+   * @param children the children of the {@code path}\n+   * @throws IllegalArgumentException when {@code path} already exists or if any child already\n+   *                                  exists\n+   */\n+  public void addChildren(AlluxioURI path, Collection<UfsStatus> children) {\n+    UfsStatus status = mStatuses.get(path);\n+    // If this path doesn't yet exist, we can't keep track of the parent-child relationship\n+    // We can still add statuses to the cache regardless\n+    if (status != null) {\n+      mChildren.computeIfAbsent(path, ufsStatus -> new ConcurrentHashSet<>()).addAll(children);\n+    }\n+    children.forEach(child -> {\n+      AlluxioURI childPath = path.joinUnsafe(child.getName());\n+      addStatus(childPath, child);\n+    });\n+  }\n+\n+  /**\n+   * Remove a status from the cache.\n+   *\n+   *  Any children added to this status will remain in the cache.\n+   *\n+   * @param path the path corresponding to the {@link UfsStatus} to remove\n+   * @return the removed UfsStatus\n+   */\n+  public UfsStatus remove(AlluxioURI path) {\n+    UfsStatus removed = mStatuses.remove(path);\n+    if (removed == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI5NTQ3Mw=="}, "originalCommit": {"oid": "aea2599ba2565e052e3871653282b3f22a325203"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU4NTgxNg==", "bodyText": "add path to message", "url": "https://github.com/Alluxio/alluxio/pull/11204#discussion_r419585816", "createdAt": "2020-05-04T17:01:36Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/underfs/UfsStatusCache.java", "diffHunk": "@@ -0,0 +1,279 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.underfs;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.collections.ConcurrentHashSet;\n+import alluxio.exception.InvalidPathException;\n+import alluxio.master.file.meta.MountTable;\n+import alluxio.resource.CloseableResource;\n+import alluxio.util.LogUtils;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nullable;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.RejectedExecutionException;\n+\n+/**\n+ * This class is a cache from an Alluxio namespace URI ({@link AlluxioURI}, i.e. /path/to/inode) to\n+ * UFS statuses.\n+ *\n+ * It also allows associating a path with child inodes, so that the statuses for a specific path can\n+ * be searched for later.\n+ */\n+public class UfsStatusCache {\n+  private static final Logger LOG = LoggerFactory.getLogger(UfsStatusCache.class);\n+\n+  private final ConcurrentHashMap<AlluxioURI, UfsStatus> mStatuses;\n+  private final ConcurrentHashMap<AlluxioURI, Future<Collection<UfsStatus>>> mActivePrefetchJobs;\n+  private final ConcurrentHashMap<AlluxioURI, Collection<UfsStatus>> mChildren;\n+  private final ExecutorService mPrefetchExecutor;\n+\n+  /**\n+   * Create a new instance of {@link UfsStatusCache}.\n+   *\n+   * @param prefetchExecutor the executor service used to prefetch statuses. If set to null, then\n+   *                         calls to {@link #prefetchChildren(AlluxioURI, MountTable)} will not\n+   *                         schedule any tasks.\n+   */\n+  public UfsStatusCache(@Nullable ExecutorService prefetchExecutor) {\n+    mStatuses = new ConcurrentHashMap<>();\n+    mChildren = new ConcurrentHashMap<>();\n+    mActivePrefetchJobs = new ConcurrentHashMap<>();\n+    mPrefetchExecutor = prefetchExecutor;\n+  }\n+\n+  /**\n+   * Add a new status to the cache.\n+   *\n+   * The last component of the path in the {@link AlluxioURI} must match the result of\n+   * {@link UfsStatus#getName()}. This method overrides any status currently cached for the same\n+   * URI.\n+   *\n+   * @param path the Alluxio path to key on\n+   * @param status the ufs status to store\n+   * @return the previous status for the path if it existed, null otherwise\n+   * @throws IllegalArgumentException if the status name doesn't match the final URI path component\n+   */\n+  @Nullable\n+  public UfsStatus addStatus(AlluxioURI path, UfsStatus status) {\n+    if (!path.getName().equals(status.getName())) {\n+      throw new IllegalArgumentException(\n+          String.format(\"path name %s does not match ufs status name %s\",\n+              path.getName(), status.getName()));\n+    }\n+    return mStatuses.put(path, status);\n+  }\n+\n+  /**\n+   * Add a parent-child mapping to the status cache.\n+   *\n+   * All child statuses added via this method will be available via {@link #getStatus(AlluxioURI)}.\n+   *\n+   * @param path the directory inode path which contains the children\n+   * @param children the children of the {@code path}\n+   * @return the previous set of children if the mapping existed, null otherwise\n+   */\n+  @Nullable\n+  public Collection<UfsStatus> addChildren(AlluxioURI path, Collection<UfsStatus> children) {\n+    ConcurrentHashSet<UfsStatus> set = new ConcurrentHashSet<>();\n+    children.forEach(child -> {\n+      AlluxioURI childPath = path.joinUnsafe(child.getName());\n+      addStatus(childPath, child);\n+      set.add(child);\n+    });\n+    return mChildren.put(path, set);\n+  }\n+\n+  /**\n+   * Remove a status from the cache.\n+   *\n+   *  Any children added to this status will remain in the cache.\n+   *\n+   * @param path the path corresponding to the {@link UfsStatus} to remove\n+   * @return the removed UfsStatus\n+   */\n+  public UfsStatus remove(AlluxioURI path) {\n+    UfsStatus removed = mStatuses.remove(path);\n+    if (removed == null) {\n+      return null;\n+    }\n+\n+    mChildren.remove(path); // ok if there aren't any children\n+    return removed;\n+  }\n+\n+  /**\n+   * Get the UfsStatus from a given AlluxioURI.\n+   *\n+   * @param path the path the retrieve\n+   * @return The corresponding {@link UfsStatus} or {@code null} if there is none stored\n+   */\n+  public UfsStatus getStatus(AlluxioURI path) {\n+    return mStatuses.get(path);\n+  }\n+\n+  /**\n+   * Fetches children of a given alluxio path, stores them in the cache, then returns them.\n+   *\n+   * Children can be returned in a few ways\n+   * 1. Children already exist in the internal index. We simply return them\n+   * 2. If children did not already exist in the index, then check if there was a scheduled\n+   * prefetch job running for this path. If so, wait for the job to finish and return the result.\n+   * 3. If no prefetch job, and children don't yet exist in the cache, then if the fallback\n+   * parameter is true, fetch them from the UFS and store them in the cache. Otherwise, simply\n+   * return null.\n+   *\n+   * @param path the Alluxio path to get the children of\n+   * @param mountTable the Alluxio mount table\n+   * @param useFallback whether or not to fall back to calling the UFS\n+   * @return child UFS statuses of the alluxio path, or null if no prefetch job and fallback\n+   *         specified as false\n+   * @throws InvalidPathException if the alluxio path can't be resolved to a UFS mount\n+   */\n+  @Nullable\n+  public Collection<UfsStatus> fetchChildrenIfAbsent(AlluxioURI path, MountTable mountTable,\n+      boolean useFallback)\n+      throws IOException, InvalidPathException {\n+    Collection<UfsStatus> children = getChildren(path);\n+    if (children != null) {\n+      return children;\n+    }\n+    Future<Collection<UfsStatus>> prefetchJob = mActivePrefetchJobs.get(path);\n+    if (prefetchJob != null) {\n+      try {\n+        return prefetchJob.get();\n+      } catch (InterruptedException | ExecutionException e) {\n+        LogUtils.warnWithException(LOG, \"Failed to get result for prefetch job on alluxio path {}\",\n+            path, e);\n+        if (e instanceof InterruptedException) {\n+          Thread.currentThread().interrupt();\n+        }\n+        throw new IOException(e);\n+      } finally {\n+        mActivePrefetchJobs.remove(path);\n+      }\n+    }\n+    if (useFallback) {\n+      return getChildrenIfAbsent(path, mountTable);\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * Fetches children of a given alluxio path stores them in the cache, then returns them.\n+   *\n+   * Will always return statuses from the UFS whether or not they exist in the cache, and whether\n+   * a prefetch job was scheduled or not.\n+   *\n+   * @param path the Alluxio path\n+   * @param mountTable the Alluxio mount table\n+   * @return child UFS statuses of the alluxio path\n+   * @throws InvalidPathException if the alluxio path can't be resolved to a UFS mount\n+   */\n+  public Collection<UfsStatus> fetchChildrenIfAbsent(AlluxioURI path, MountTable mountTable)\n+      throws IOException, InvalidPathException {\n+    return fetchChildrenIfAbsent(path, mountTable, true);\n+  }\n+\n+  /**\n+   * Retrieves the child UFS statuses for a given path and stores them in the cache.\n+   *\n+   * This method first checks if the children have already been retrieved, and if not, then\n+   * retrieves them.\n+\n+   * @param path the path to get the children for\n+   * @param mountTable the Alluxio mount table\n+   * @return the child statuses that were stored in the cache, or null if the UFS couldn't list the\n+   *         statuses\n+   * @throws InvalidPathException when the table can't resolve the mount for the given URI\n+   */\n+  @Nullable\n+  private Collection<UfsStatus> getChildrenIfAbsent(AlluxioURI path, MountTable mountTable)\n+      throws InvalidPathException {\n+    Collection<UfsStatus> children = getChildren(path);\n+    if (children != null) {\n+      return children;\n+    }\n+    MountTable.Resolution resolution = mountTable.resolve(path);\n+    AlluxioURI ufsUri = resolution.getUri();\n+    try (CloseableResource<UnderFileSystem> ufsResource = resolution.acquireUfsResource()) {\n+      UnderFileSystem ufs = ufsResource.get();\n+      UfsStatus[] statuses = ufs.listStatus(ufsUri.toString());\n+      if (statuses == null) {\n+        return null;\n+      }\n+      children = Arrays.asList(statuses);\n+      addChildren(path, children);\n+    } catch (IllegalArgumentException | IOException e) {\n+      LOG.debug(\"Failed to add status to cache\", e);\n+    }\n+    return children;\n+  }\n+\n+  /**\n+   * Get the child {@link UfsStatus}es from a given {@link AlluxioURI}.\n+   *\n+   * @param path the path the retrieve\n+   * @return The corresponding {@link UfsStatus} or {@code null} if there is none stored\n+   */\n+  @Nullable\n+  public Collection<UfsStatus> getChildren(AlluxioURI path) {\n+    return mChildren.get(path);\n+  }\n+\n+  /**\n+   * Submit a request to asynchronously fetch the statuses corresponding to a given directory.\n+   *\n+   * Retrieve any fetched statuses by calling {@link #fetchChildrenIfAbsent(AlluxioURI, MountTable)}\n+   * with the same Alluxio path.\n+   *\n+   * If no {@link ExecutorService} was provided to this object before instantiation, this method is\n+   * a no-op.\n+   *\n+   * @param path the path to prefetch\n+   * @param mountTable the Alluxio mount table\n+   */\n+  public void prefetchChildren(AlluxioURI path, MountTable mountTable) {\n+    if (mPrefetchExecutor == null) {\n+      return;\n+    }\n+    try {\n+      Future<Collection<UfsStatus>> job =\n+          mPrefetchExecutor.submit(() -> getChildrenIfAbsent(path, mountTable));\n+      Future<Collection<UfsStatus>> prev = mActivePrefetchJobs.put(path, job);\n+      if (prev != null) {\n+        prev.cancel(true);\n+      }\n+    } catch (RejectedExecutionException e) {\n+      LOG.debug(\"Failed to submit prefetch job\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff8a137d843dabc6cb4b38fb5ae7a324cae6fec4"}, "originalPosition": 266}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU4NjA2MA==", "bodyText": "add path to message", "url": "https://github.com/Alluxio/alluxio/pull/11204#discussion_r419586060", "createdAt": "2020-05-04T17:01:59Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/underfs/UfsStatusCache.java", "diffHunk": "@@ -0,0 +1,279 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.underfs;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.collections.ConcurrentHashSet;\n+import alluxio.exception.InvalidPathException;\n+import alluxio.master.file.meta.MountTable;\n+import alluxio.resource.CloseableResource;\n+import alluxio.util.LogUtils;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nullable;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.RejectedExecutionException;\n+\n+/**\n+ * This class is a cache from an Alluxio namespace URI ({@link AlluxioURI}, i.e. /path/to/inode) to\n+ * UFS statuses.\n+ *\n+ * It also allows associating a path with child inodes, so that the statuses for a specific path can\n+ * be searched for later.\n+ */\n+public class UfsStatusCache {\n+  private static final Logger LOG = LoggerFactory.getLogger(UfsStatusCache.class);\n+\n+  private final ConcurrentHashMap<AlluxioURI, UfsStatus> mStatuses;\n+  private final ConcurrentHashMap<AlluxioURI, Future<Collection<UfsStatus>>> mActivePrefetchJobs;\n+  private final ConcurrentHashMap<AlluxioURI, Collection<UfsStatus>> mChildren;\n+  private final ExecutorService mPrefetchExecutor;\n+\n+  /**\n+   * Create a new instance of {@link UfsStatusCache}.\n+   *\n+   * @param prefetchExecutor the executor service used to prefetch statuses. If set to null, then\n+   *                         calls to {@link #prefetchChildren(AlluxioURI, MountTable)} will not\n+   *                         schedule any tasks.\n+   */\n+  public UfsStatusCache(@Nullable ExecutorService prefetchExecutor) {\n+    mStatuses = new ConcurrentHashMap<>();\n+    mChildren = new ConcurrentHashMap<>();\n+    mActivePrefetchJobs = new ConcurrentHashMap<>();\n+    mPrefetchExecutor = prefetchExecutor;\n+  }\n+\n+  /**\n+   * Add a new status to the cache.\n+   *\n+   * The last component of the path in the {@link AlluxioURI} must match the result of\n+   * {@link UfsStatus#getName()}. This method overrides any status currently cached for the same\n+   * URI.\n+   *\n+   * @param path the Alluxio path to key on\n+   * @param status the ufs status to store\n+   * @return the previous status for the path if it existed, null otherwise\n+   * @throws IllegalArgumentException if the status name doesn't match the final URI path component\n+   */\n+  @Nullable\n+  public UfsStatus addStatus(AlluxioURI path, UfsStatus status) {\n+    if (!path.getName().equals(status.getName())) {\n+      throw new IllegalArgumentException(\n+          String.format(\"path name %s does not match ufs status name %s\",\n+              path.getName(), status.getName()));\n+    }\n+    return mStatuses.put(path, status);\n+  }\n+\n+  /**\n+   * Add a parent-child mapping to the status cache.\n+   *\n+   * All child statuses added via this method will be available via {@link #getStatus(AlluxioURI)}.\n+   *\n+   * @param path the directory inode path which contains the children\n+   * @param children the children of the {@code path}\n+   * @return the previous set of children if the mapping existed, null otherwise\n+   */\n+  @Nullable\n+  public Collection<UfsStatus> addChildren(AlluxioURI path, Collection<UfsStatus> children) {\n+    ConcurrentHashSet<UfsStatus> set = new ConcurrentHashSet<>();\n+    children.forEach(child -> {\n+      AlluxioURI childPath = path.joinUnsafe(child.getName());\n+      addStatus(childPath, child);\n+      set.add(child);\n+    });\n+    return mChildren.put(path, set);\n+  }\n+\n+  /**\n+   * Remove a status from the cache.\n+   *\n+   *  Any children added to this status will remain in the cache.\n+   *\n+   * @param path the path corresponding to the {@link UfsStatus} to remove\n+   * @return the removed UfsStatus\n+   */\n+  public UfsStatus remove(AlluxioURI path) {\n+    UfsStatus removed = mStatuses.remove(path);\n+    if (removed == null) {\n+      return null;\n+    }\n+\n+    mChildren.remove(path); // ok if there aren't any children\n+    return removed;\n+  }\n+\n+  /**\n+   * Get the UfsStatus from a given AlluxioURI.\n+   *\n+   * @param path the path the retrieve\n+   * @return The corresponding {@link UfsStatus} or {@code null} if there is none stored\n+   */\n+  public UfsStatus getStatus(AlluxioURI path) {\n+    return mStatuses.get(path);\n+  }\n+\n+  /**\n+   * Fetches children of a given alluxio path, stores them in the cache, then returns them.\n+   *\n+   * Children can be returned in a few ways\n+   * 1. Children already exist in the internal index. We simply return them\n+   * 2. If children did not already exist in the index, then check if there was a scheduled\n+   * prefetch job running for this path. If so, wait for the job to finish and return the result.\n+   * 3. If no prefetch job, and children don't yet exist in the cache, then if the fallback\n+   * parameter is true, fetch them from the UFS and store them in the cache. Otherwise, simply\n+   * return null.\n+   *\n+   * @param path the Alluxio path to get the children of\n+   * @param mountTable the Alluxio mount table\n+   * @param useFallback whether or not to fall back to calling the UFS\n+   * @return child UFS statuses of the alluxio path, or null if no prefetch job and fallback\n+   *         specified as false\n+   * @throws InvalidPathException if the alluxio path can't be resolved to a UFS mount\n+   */\n+  @Nullable\n+  public Collection<UfsStatus> fetchChildrenIfAbsent(AlluxioURI path, MountTable mountTable,\n+      boolean useFallback)\n+      throws IOException, InvalidPathException {\n+    Collection<UfsStatus> children = getChildren(path);\n+    if (children != null) {\n+      return children;\n+    }\n+    Future<Collection<UfsStatus>> prefetchJob = mActivePrefetchJobs.get(path);\n+    if (prefetchJob != null) {\n+      try {\n+        return prefetchJob.get();\n+      } catch (InterruptedException | ExecutionException e) {\n+        LogUtils.warnWithException(LOG, \"Failed to get result for prefetch job on alluxio path {}\",\n+            path, e);\n+        if (e instanceof InterruptedException) {\n+          Thread.currentThread().interrupt();\n+        }\n+        throw new IOException(e);\n+      } finally {\n+        mActivePrefetchJobs.remove(path);\n+      }\n+    }\n+    if (useFallback) {\n+      return getChildrenIfAbsent(path, mountTable);\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * Fetches children of a given alluxio path stores them in the cache, then returns them.\n+   *\n+   * Will always return statuses from the UFS whether or not they exist in the cache, and whether\n+   * a prefetch job was scheduled or not.\n+   *\n+   * @param path the Alluxio path\n+   * @param mountTable the Alluxio mount table\n+   * @return child UFS statuses of the alluxio path\n+   * @throws InvalidPathException if the alluxio path can't be resolved to a UFS mount\n+   */\n+  public Collection<UfsStatus> fetchChildrenIfAbsent(AlluxioURI path, MountTable mountTable)\n+      throws IOException, InvalidPathException {\n+    return fetchChildrenIfAbsent(path, mountTable, true);\n+  }\n+\n+  /**\n+   * Retrieves the child UFS statuses for a given path and stores them in the cache.\n+   *\n+   * This method first checks if the children have already been retrieved, and if not, then\n+   * retrieves them.\n+\n+   * @param path the path to get the children for\n+   * @param mountTable the Alluxio mount table\n+   * @return the child statuses that were stored in the cache, or null if the UFS couldn't list the\n+   *         statuses\n+   * @throws InvalidPathException when the table can't resolve the mount for the given URI\n+   */\n+  @Nullable\n+  private Collection<UfsStatus> getChildrenIfAbsent(AlluxioURI path, MountTable mountTable)\n+      throws InvalidPathException {\n+    Collection<UfsStatus> children = getChildren(path);\n+    if (children != null) {\n+      return children;\n+    }\n+    MountTable.Resolution resolution = mountTable.resolve(path);\n+    AlluxioURI ufsUri = resolution.getUri();\n+    try (CloseableResource<UnderFileSystem> ufsResource = resolution.acquireUfsResource()) {\n+      UnderFileSystem ufs = ufsResource.get();\n+      UfsStatus[] statuses = ufs.listStatus(ufsUri.toString());\n+      if (statuses == null) {\n+        return null;\n+      }\n+      children = Arrays.asList(statuses);\n+      addChildren(path, children);\n+    } catch (IllegalArgumentException | IOException e) {\n+      LOG.debug(\"Failed to add status to cache\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff8a137d843dabc6cb4b38fb5ae7a324cae6fec4"}, "originalPosition": 226}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU4ODQ5Mw==", "bodyText": "Won't this print out the entire stack trace of the exception?", "url": "https://github.com/Alluxio/alluxio/pull/11204#discussion_r419588493", "createdAt": "2020-05-04T17:05:44Z", "author": {"login": "gpang"}, "path": "core/common/src/main/java/alluxio/util/LogUtils.java", "diffHunk": "@@ -127,7 +127,7 @@ public static void warnWithException(Logger logger, String message, Object ...ar\n       logger.debug(message, args);\n     } else {\n       if (args.length > 0 && args[args.length - 1] instanceof Throwable) {\n-        args[args.length - 1] = ((Throwable) args[args.length - 1]).getMessage();\n+        args[args.length - 1] = (args[args.length - 1]).toString();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff8a137d843dabc6cb4b38fb5ae7a324cae6fec4"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU5MzE0Ng==", "bodyText": "Is the general approach for RPCs to have a sync phase first, then the actual execution of the RPC? (Before it did the sync within the same contexts of the RPC execution).", "url": "https://github.com/Alluxio/alluxio/pull/11204#discussion_r419593146", "createdAt": "2020-05-04T17:13:07Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/master/file/DefaultFileSystemMaster.java", "diffHunk": "@@ -726,45 +744,53 @@ public FileInfo getFileInfo(AlluxioURI path, GetStatusContext context)\n       throws FileDoesNotExistException, InvalidPathException, AccessControlException, IOException {\n     Metrics.GET_FILE_INFO_OPS.inc();\n     long opTimeMs = System.currentTimeMillis();\n-    LockingScheme lockingScheme =\n-        createLockingScheme(path, context.getOptions().getCommonOptions(), LockPattern.READ, true);\n     try (RpcContext rpcContext = createRpcContext();\n-         LockedInodePath inodePath = mInodeTree\n-             .lockInodePath(lockingScheme.getPath(), lockingScheme.getPattern());\n-         FileSystemMasterAuditContext auditContext =\n-             createAuditContext(\"getFileInfo\", path, null, inodePath.getInodeOrNull())) {\n-      try {\n-        mPermissionChecker.checkPermission(Mode.Bits.READ, inodePath);\n-      } catch (AccessControlException e) {\n-        auditContext.setAllowed(false);\n-        throw e;\n-      }\n-      // Possible ufs sync.\n-      if (syncMetadata(rpcContext, inodePath, lockingScheme, DescendantType.ONE)) {\n+        FileSystemMasterAuditContext auditContext =\n+            createAuditContext(\"getFileInfo\", path, null, null)) {\n+\n+      if (syncMetadata(rpcContext,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff8a137d843dabc6cb4b38fb5ae7a324cae6fec4"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU5Mzg5Mw==", "bodyText": "Can the new syncMetadata also take care of loadMetadata? I think the full sync is a superset of load metadata, so can't we just do the sync, which can optionally take care of loading metadata only if requested? I think load metadata only happens on getFileInfo and listStatus.", "url": "https://github.com/Alluxio/alluxio/pull/11204#discussion_r419593893", "createdAt": "2020-05-04T17:14:18Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/master/file/DefaultFileSystemMaster.java", "diffHunk": "@@ -815,73 +841,81 @@ public void listStatus(AlluxioURI path, ListStatusContext context,\n       ResultStream<FileInfo> resultStream)\n       throws AccessControlException, FileDoesNotExistException, InvalidPathException, IOException {\n     Metrics.GET_FILE_INFO_OPS.inc();\n-    LockingScheme lockingScheme =\n-        createLockingScheme(path, context.getOptions().getCommonOptions(), LockPattern.READ);\n     try (RpcContext rpcContext = createRpcContext();\n-         LockedInodePath inodePath = mInodeTree\n-             .lockInodePath(lockingScheme.getPath(), lockingScheme.getPattern());\n-         FileSystemMasterAuditContext auditContext =\n-             createAuditContext(\"listStatus\", path, null, inodePath.getInodeOrNull())) {\n-      try {\n-        mPermissionChecker.checkPermission(Mode.Bits.READ, inodePath);\n-      } catch (AccessControlException e) {\n-        auditContext.setAllowed(false);\n-        throw e;\n-      }\n-\n-      DescendantType descendantType = context.getOptions().getRecursive() ? DescendantType.ALL\n-          : DescendantType.ONE;\n-      // Possible ufs sync.\n-      if (syncMetadata(rpcContext, inodePath, lockingScheme, descendantType)) {\n+        FileSystemMasterAuditContext auditContext =\n+            createAuditContext(\"listStatus\", path, null, null)) {\n+\n+      DescendantType descendantType =\n+          context.getOptions().getRecursive() ? DescendantType.ALL : DescendantType.ONE;\n+      if (syncMetadata(rpcContext,\n+          path,\n+          context.getOptions().getCommonOptions(),\n+          descendantType,\n+          auditContext,\n+          LockedInodePath::getInodeOrNull,\n+          (inodePath, permChecker) -> permChecker.checkPermission(Mode.Bits.READ, inodePath))) {\n         // If synced, do not load metadata.\n         context.getOptions().setLoadMetadataType(LoadMetadataPType.NEVER);\n       }\n \n-      DescendantType loadDescendantType;\n-      if (context.getOptions().getLoadMetadataType() == LoadMetadataPType.NEVER) {\n-        loadDescendantType = DescendantType.NONE;\n-      } else if (context.getOptions().getRecursive()) {\n-        loadDescendantType = DescendantType.ALL;\n-      } else {\n-        loadDescendantType = DescendantType.ONE;\n-      }\n-      // load metadata for 1 level of descendants, or all descendants if recursive\n-      LoadMetadataContext loadMetadataContext =\n-          LoadMetadataContext.mergeFrom(LoadMetadataPOptions.newBuilder().setCreateAncestors(true)\n-              .setLoadDescendantType(GrpcUtils.toProto(loadDescendantType))\n-              .setCommonOptions(FileSystemMasterCommonPOptions.newBuilder()\n-                  .setTtl(context.getOptions().getCommonOptions().getTtl())\n-                  .setTtlAction(context.getOptions().getCommonOptions().getTtlAction())));\n-      Inode inode;\n-      if (inodePath.fullPathExists()) {\n-        inode = inodePath.getInode();\n-        if (inode.isDirectory()\n-            && context.getOptions().getLoadMetadataType() != LoadMetadataPType.ALWAYS) {\n-          InodeDirectory inodeDirectory = inode.asDirectory();\n+      // We just synced; the new lock pattern should not sync.\n+      LockingScheme lockingScheme = new LockingScheme(path, LockPattern.READ, false);\n+      try (LockedInodePath inodePath = mInodeTree.lockInodePath(lockingScheme)) {\n+        auditContext.setSrcInode(inodePath.getInodeOrNull());\n+        try {\n+          mPermissionChecker.checkPermission(Mode.Bits.READ, inodePath);\n+        } catch (AccessControlException e) {\n+          auditContext.setAllowed(false);\n+          throw e;\n+        }\n \n-          boolean isLoaded = inodeDirectory.isDirectChildrenLoaded();\n-          if (context.getOptions().getRecursive()) {\n-            isLoaded = areDescendantsLoaded(inodeDirectory);\n-          }\n-          if (isLoaded) {\n-            // no need to load again.\n-            loadMetadataContext.getOptions().setLoadDescendantType(LoadDescendantPType.NONE);\n+        DescendantType loadDescendantType;\n+        if (context.getOptions().getLoadMetadataType() == LoadMetadataPType.NEVER) {\n+          loadDescendantType = DescendantType.NONE;\n+        } else if (context.getOptions().getRecursive()) {\n+          loadDescendantType = DescendantType.ALL;\n+        } else {\n+          loadDescendantType = DescendantType.ONE;\n+        }\n+        // load metadata for 1 level of descendants, or all descendants if recursive\n+        LoadMetadataContext loadMetadataContext = LoadMetadataContext.mergeFrom(\n+            LoadMetadataPOptions.newBuilder()\n+                .setCreateAncestors(true)\n+                .setLoadDescendantType(GrpcUtils.toProto(loadDescendantType))\n+                .setCommonOptions(FileSystemMasterCommonPOptions.newBuilder()\n+                    .setTtl(context.getOptions().getCommonOptions().getTtl())\n+                    .setTtlAction(context.getOptions().getCommonOptions().getTtlAction())));\n+        Inode inode;\n+        if (inodePath.fullPathExists()) {\n+          inode = inodePath.getInode();\n+          if (inode.isDirectory()\n+              && context.getOptions().getLoadMetadataType() != LoadMetadataPType.ALWAYS) {\n+            InodeDirectory inodeDirectory = inode.asDirectory();\n+\n+            boolean isLoaded = inodeDirectory.isDirectChildrenLoaded();\n+            if (context.getOptions().getRecursive()) {\n+              isLoaded = areDescendantsLoaded(inodeDirectory);\n+            }\n+            if (isLoaded) {\n+              // no need to load again.\n+              loadMetadataContext.getOptions().setLoadDescendantType(LoadDescendantPType.NONE);\n+            }\n           }\n+        } else {\n+          checkLoadMetadataOptions(context.getOptions().getLoadMetadataType(), inodePath.getUri());\n         }\n-      } else {\n-        checkLoadMetadataOptions(context.getOptions().getLoadMetadataType(), inodePath.getUri());\n-      }\n \n-      loadMetadataIfNotExist(rpcContext, inodePath, loadMetadataContext);\n-      ensureFullPathAndUpdateCache(inodePath);\n-      inode = inodePath.getInode();\n-      auditContext.setSrcInode(inode);\n-      DescendantType descendantTypeForListStatus =\n-          (context.getOptions().getRecursive()) ? DescendantType.ALL : DescendantType.ONE;\n-      listStatusInternal(context, rpcContext, inodePath, auditContext, descendantTypeForListStatus,\n-          resultStream, 0);\n-      auditContext.setSucceeded(true);\n-      Metrics.FILE_INFOS_GOT.inc();\n+        loadMetadataIfNotExist(rpcContext, inodePath, loadMetadataContext, false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ff8a137d843dabc6cb4b38fb5ae7a324cae6fec4"}, "originalPosition": 352}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2Nzc5NTU5", "url": "https://github.com/Alluxio/alluxio/pull/11204#pullrequestreview-406779559", "createdAt": "2020-05-06T16:22:55Z", "commit": {"oid": "d7b701e8535c863ae9c395a75668c6f2f9f88c38"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxNjoyMjo1NVrOGRbDZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxNjozMjo0N1rOGRbd9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDkyMjIxMg==", "bodyText": "In fetchChildrenIfAbsent, it is supposed to wait for the prefetch job. If the prefetch job is always getting canceled and re-created, I'd imagine the prefetch job would never finish, and that i where the \"cycle\" would happen.\nBut it sounds like you are saying prefetchChildren is only called once per path per instance of this class?", "url": "https://github.com/Alluxio/alluxio/pull/11204#discussion_r420922212", "createdAt": "2020-05-06T16:22:55Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/underfs/UfsStatusCache.java", "diffHunk": "@@ -0,0 +1,275 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.underfs;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.collections.ConcurrentHashSet;\n+import alluxio.exception.InvalidPathException;\n+import alluxio.master.file.meta.MountTable;\n+import alluxio.resource.CloseableResource;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nullable;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.RejectedExecutionException;\n+\n+/**\n+ * This class is a cache from an Alluxio namespace URI ({@link AlluxioURI}, i.e. /path/to/inode) to\n+ * UFS statuses.\n+ *\n+ * It also allows associating a path with child inodes, so that the statuses for a specific path can\n+ * be searched for later.\n+ */\n+public class UfsStatusCache {\n+  private static final Logger LOG = LoggerFactory.getLogger(UfsStatusCache.class);\n+\n+  private final ConcurrentHashMap<AlluxioURI, UfsStatus> mStatuses;\n+  private final ConcurrentHashMap<AlluxioURI, Future<Collection<UfsStatus>>> mActivePrefetchJobs;\n+  private final ConcurrentHashMap<AlluxioURI, Collection<UfsStatus>> mChildren;\n+  private final ExecutorService mPrefetchExecutor;\n+\n+  /**\n+   * Create a new instance of {@link UfsStatusCache}.\n+   *\n+   * @param prefetchExecutor the executor service used to prefetch statuses\n+   */\n+  public UfsStatusCache(@Nullable ExecutorService prefetchExecutor) {\n+    mStatuses = new ConcurrentHashMap<>();\n+    mChildren = new ConcurrentHashMap<>();\n+    mActivePrefetchJobs = new ConcurrentHashMap<>();\n+    mPrefetchExecutor = prefetchExecutor;\n+  }\n+\n+  /**\n+   * Add a new status to the cache.\n+   *\n+   * The last component of the path in the {@link AlluxioURI} must match the result of\n+   * {@link UfsStatus#getName()}. This method overrides any status currently cached for the same\n+   * URI.\n+   *\n+   * @param path the Alluxio path to key on\n+   * @param status the ufs status to store\n+   * @throws IllegalArgumentException if the status name doesn't match the final URI path component\n+   */\n+  public void addStatus(AlluxioURI path, UfsStatus status) {\n+    UfsStatus prev = mStatuses.putIfAbsent(path, status);\n+    if (!path.getName().equals(status.getName())) {\n+      throw new IllegalArgumentException(\n+          String.format(\"path name %s does not match ufs status name %s\",\n+              path.getName(), status.getName()));\n+    }\n+  }\n+\n+  /**\n+   * Add a parent-child mapping to the status cache.\n+   *\n+   * All child statuses added via this method will be available via {@link #getStatus(AlluxioURI)}.\n+   *\n+   * @param path the directory inode path which contains the children\n+   * @param children the children of the {@code path}\n+   * @throws IllegalArgumentException when {@code path} already exists or if any child already\n+   *                                  exists\n+   */\n+  public void addChildren(AlluxioURI path, Collection<UfsStatus> children) {\n+    UfsStatus status = mStatuses.get(path);\n+    // If this path doesn't yet exist, we can't keep track of the parent-child relationship\n+    // We can still add statuses to the cache regardless\n+    if (status != null) {\n+      mChildren.computeIfAbsent(path, ufsStatus -> new ConcurrentHashSet<>()).addAll(children);\n+    }\n+    children.forEach(child -> {\n+      AlluxioURI childPath = path.joinUnsafe(child.getName());\n+      addStatus(childPath, child);\n+    });\n+  }\n+\n+  /**\n+   * Remove a status from the cache.\n+   *\n+   *  Any children added to this status will remain in the cache.\n+   *\n+   * @param path the path corresponding to the {@link UfsStatus} to remove\n+   * @return the removed UfsStatus\n+   */\n+  public UfsStatus remove(AlluxioURI path) {\n+    UfsStatus removed = mStatuses.remove(path);\n+    if (removed == null) {\n+      return null;\n+    }\n+\n+    mChildren.remove(path); // ok if there aren't any children\n+    return removed;\n+  }\n+\n+  /**\n+   * Get the UfsStatus from a given AlluxioURI.\n+   *\n+   * @param path the path the retrieve\n+   * @return The corresponding {@link UfsStatus} or {@code null} if there is none stored\n+   */\n+  public UfsStatus getStatus(AlluxioURI path) {\n+    return mStatuses.get(path);\n+  }\n+\n+  /**\n+   * Fetches children of a given alluxio path, stores them in the cache, then returns them.\n+   *\n+   * Children can be returned in a few ways\n+   * 1. Children already exist in the internal index. We simply return them\n+   * 2. If children did not already exist in the index, then check if there was a scheduled\n+   * prefetch job running for this path. If so, wait for the job to finish and return the result.\n+   * 3. If no prefetch job, and children don't yet exist in the cache, then if the fallback\n+   * parameter is true, fetch them from the UFS and store them in the cache. Otherwise, simply\n+   * return null.\n+   *\n+   * @param path the Alluxio path to get the children of\n+   * @param mountTable the Alluxio mount table\n+   * @param useFallback whether or not to fall back to calling the UFS\n+   * @return child UFS statuses of the alluxio path, or null if no prefetch job and fallback\n+   *         specified as false\n+   * @throws InvalidPathException if the alluxio path can't be resolved to a UFS mount\n+   */\n+  @Nullable\n+  public Collection<UfsStatus> fetchChildrenIfAbsent(AlluxioURI path, MountTable mountTable,\n+      boolean useFallback)\n+      throws IOException, InvalidPathException {\n+    Collection<UfsStatus> children = getChildren(path);\n+    if (children != null) {\n+      return children;\n+    }\n+    Future<Collection<UfsStatus>> prefetchJob = mActivePrefetchJobs.remove(path);\n+    if (prefetchJob != null) {\n+      try {\n+        return prefetchJob.get();\n+      } catch (InterruptedException | ExecutionException e) {\n+        LOG.warn(\"Failed waiting to fetch children at {}\", path);\n+        if (e instanceof  InterruptedException) {\n+          Thread.currentThread().interrupt();\n+        }\n+        throw new IOException(e);\n+      }\n+    }\n+    if (useFallback) {\n+      return getChildrenIfAbsent(path, mountTable);\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * Fetches children of a given alluxio path stores them in the cache, then returns them.\n+   *\n+   * Will always return statuses from the UFS whether or not they exist in the cache, and whether\n+   * a prefetch job was scheduled or not.\n+   *\n+   * @param path the Alluxio path\n+   * @param mountTable the Alluxio mount table\n+   * @return child UFS statuses of the alluxio path\n+   * @throws InvalidPathException if the alluxio path can't be resolved to a UFS mount\n+   * @see {@link #fetchChildrenIfAbsent(AlluxioURI, MountTable, boolean)}\n+   */\n+  public Collection<UfsStatus> fetchChildrenIfAbsent(AlluxioURI path, MountTable mountTable)\n+      throws IOException, InvalidPathException {\n+    return fetchChildrenIfAbsent(path, mountTable, true);\n+  }\n+\n+  /**\n+   * Retrieves the child UFS statuses for a given path and stores them in the cache.\n+   *\n+   * This method first checks if the children have already been retrieved, and if not, then\n+   * retrieves them.\n+\n+   * @param path the path to get the children for\n+   * @param mountTable the Alluxio mount table\n+   * @return the child statuses that were stored in the cache, or null if the UFS couldn't list the\n+   *         statuses\n+   * @throws InvalidPathException when the table can't resolve the mount for the given URI\n+   */\n+  @Nullable\n+  private Collection<UfsStatus> getChildrenIfAbsent(AlluxioURI path, MountTable mountTable)\n+      throws InvalidPathException {\n+    Collection<UfsStatus> children = getChildren(path);\n+    if (children != null) {\n+      return children;\n+    }\n+    MountTable.Resolution resolution = mountTable.resolve(path);\n+    AlluxioURI ufsUri = resolution.getUri();\n+    try (CloseableResource<UnderFileSystem> ufsResource = resolution.acquireUfsResource()) {\n+      UnderFileSystem ufs = ufsResource.get();\n+      UfsStatus[] statuses = ufs.listStatus(ufsUri.toString());\n+      if (statuses == null) {\n+        return null;\n+      }\n+      children = Arrays.asList(statuses);\n+      addChildren(path, children);\n+    } catch (IllegalArgumentException | IOException e) {\n+      LOG.debug(\"Failed to add status to cache\", e);\n+    }\n+    return children;\n+  }\n+\n+  /**\n+   * Get the child {@link UfsStatus}es from a given {@link AlluxioURI}.\n+   *\n+   * @param path the path the retrieve\n+   * @return The corresponding {@link UfsStatus} or {@code null} if there is none stored\n+   */\n+  @Nullable\n+  public Collection<UfsStatus> getChildren(AlluxioURI path) {\n+    return mChildren.get(path);\n+  }\n+\n+  /**\n+   * Submit a request to asynchronously fetch the statuses corresponding to a given directory.\n+   *\n+   * Retrieve any fetched statuses by calling {@link #fetchChildrenIfAbsent(AlluxioURI, MountTable)}\n+   * with the same Alluxio path.\n+   *\n+   * If no {@link ExecutorService} was provided to this object before instantiation, this method is\n+   * a no-op.\n+   *\n+   * @param path the path to prefetch\n+   * @param mountTable the Alluxio mount table\n+   */\n+  public void prefetchChildren(AlluxioURI path, MountTable mountTable) {\n+    if (mPrefetchExecutor == null) {\n+      return;\n+    }\n+    try {\n+      Future<Collection<UfsStatus>> fute =\n+          mPrefetchExecutor.submit(() -> getChildrenIfAbsent(path, mountTable));\n+      Future<Collection<UfsStatus>> prev = mActivePrefetchJobs.put(path, fute);\n+      if (prev != null) {\n+        prev.cancel(true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODMwMjUyNg=="}, "originalCommit": {"oid": "aea2599ba2565e052e3871653282b3f22a325203"}, "originalPosition": 259}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDkyMzIxNA==", "bodyText": "If the prefetch job is canceled, this will throw an error, right? Does something external retry this?", "url": "https://github.com/Alluxio/alluxio/pull/11204#discussion_r420923214", "createdAt": "2020-05-06T16:24:17Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/underfs/UfsStatusCache.java", "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.underfs;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.collections.ConcurrentHashSet;\n+import alluxio.exception.InvalidPathException;\n+import alluxio.master.file.meta.MountTable;\n+import alluxio.resource.CloseableResource;\n+import alluxio.util.LogUtils;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.ThreadSafe;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.RejectedExecutionException;\n+\n+/**\n+ * This class is a cache from an Alluxio namespace URI ({@link AlluxioURI}, i.e. /path/to/inode) to\n+ * UFS statuses.\n+ *\n+ * It also allows associating a path with child inodes, so that the statuses for a specific path can\n+ * be searched for later.\n+ */\n+@ThreadSafe\n+public class UfsStatusCache {\n+  private static final Logger LOG = LoggerFactory.getLogger(UfsStatusCache.class);\n+\n+  private final ConcurrentHashMap<AlluxioURI, UfsStatus> mStatuses;\n+  private final ConcurrentHashMap<AlluxioURI, Future<Collection<UfsStatus>>> mActivePrefetchJobs;\n+  private final ConcurrentHashMap<AlluxioURI, Collection<UfsStatus>> mChildren;\n+  private final ExecutorService mPrefetchExecutor;\n+\n+  /**\n+   * Create a new instance of {@link UfsStatusCache}.\n+   *\n+   * @param prefetchExecutor the executor service used to prefetch statuses. If set to null, then\n+   *                         calls to {@link #prefetchChildren(AlluxioURI, MountTable)} will not\n+   *                         schedule any tasks.\n+   */\n+  public UfsStatusCache(@Nullable ExecutorService prefetchExecutor) {\n+    mStatuses = new ConcurrentHashMap<>();\n+    mChildren = new ConcurrentHashMap<>();\n+    mActivePrefetchJobs = new ConcurrentHashMap<>();\n+    mPrefetchExecutor = prefetchExecutor;\n+  }\n+\n+  /**\n+   * Add a new status to the cache.\n+   *\n+   * The last component of the path in the {@link AlluxioURI} must match the result of\n+   * {@link UfsStatus#getName()}. This method overrides any status currently cached for the same\n+   * URI.\n+   *\n+   * @param path the Alluxio path to key on\n+   * @param status the ufs status to store\n+   * @return the previous status for the path if it existed, null otherwise\n+   * @throws IllegalArgumentException if the status name doesn't match the final URI path component\n+   */\n+  @Nullable\n+  public UfsStatus addStatus(AlluxioURI path, UfsStatus status) {\n+    if (!path.getName().equals(status.getName())) {\n+      throw new IllegalArgumentException(\n+          String.format(\"path name %s does not match ufs status name %s\",\n+              path.getName(), status.getName()));\n+    }\n+    return mStatuses.put(path, status);\n+  }\n+\n+  /**\n+   * Add a parent-child mapping to the status cache.\n+   *\n+   * All child statuses added via this method will be available via {@link #getStatus(AlluxioURI)}.\n+   *\n+   * @param path the directory inode path which contains the children\n+   * @param children the children of the {@code path}\n+   * @return the previous set of children if the mapping existed, null otherwise\n+   */\n+  @Nullable\n+  public Collection<UfsStatus> addChildren(AlluxioURI path, Collection<UfsStatus> children) {\n+    ConcurrentHashSet<UfsStatus> set = new ConcurrentHashSet<>();\n+    children.forEach(child -> {\n+      AlluxioURI childPath = path.joinUnsafe(child.getName());\n+      addStatus(childPath, child);\n+      set.add(child);\n+    });\n+    return mChildren.put(path, set);\n+  }\n+\n+  /**\n+   * Remove a status from the cache.\n+   *\n+   *  Any children added to this status will remain in the cache.\n+   *\n+   * @param path the path corresponding to the {@link UfsStatus} to remove\n+   * @return the removed UfsStatus\n+   */\n+  public UfsStatus remove(AlluxioURI path) {\n+    UfsStatus removed = mStatuses.remove(path);\n+    if (removed == null) {\n+      return null;\n+    }\n+\n+    mChildren.remove(path); // ok if there aren't any children\n+    return removed;\n+  }\n+\n+  /**\n+   * Get the UfsStatus from a given AlluxioURI.\n+   *\n+   * @param path the path the retrieve\n+   * @return The corresponding {@link UfsStatus} or {@code null} if there is none stored\n+   */\n+  public UfsStatus getStatus(AlluxioURI path) {\n+    return mStatuses.get(path);\n+  }\n+\n+  /**\n+   * Fetches children of a given alluxio path, stores them in the cache, then returns them.\n+   *\n+   * Children can be returned in a few ways\n+   * 1. Children already exist in the internal index. We simply return them\n+   * 2. If children did not already exist in the index, then check if there was a scheduled\n+   * prefetch job running for this path. If so, wait for the job to finish and return the result.\n+   * 3. If no prefetch job, and children don't yet exist in the cache, then if the fallback\n+   * parameter is true, fetch them from the UFS and store them in the cache. Otherwise, simply\n+   * return null.\n+   *\n+   * @param path the Alluxio path to get the children of\n+   * @param mountTable the Alluxio mount table\n+   * @param useFallback whether or not to fall back to calling the UFS\n+   * @return child UFS statuses of the alluxio path, or null if no prefetch job and fallback\n+   *         specified as false\n+   * @throws InvalidPathException if the alluxio path can't be resolved to a UFS mount\n+   */\n+  @Nullable\n+  public Collection<UfsStatus> fetchChildrenIfAbsent(AlluxioURI path, MountTable mountTable,\n+      boolean useFallback)\n+      throws IOException, InvalidPathException {\n+    Future<Collection<UfsStatus>> prefetchJob = mActivePrefetchJobs.get(path);\n+    if (prefetchJob != null) {\n+      try {\n+        return prefetchJob.get();\n+      } catch (InterruptedException | ExecutionException e) {\n+        LogUtils.warnWithException(LOG, \"Failed to get result for prefetch job on alluxio path {}\",\n+            path, e);\n+        if (e instanceof InterruptedException) {\n+          Thread.currentThread().interrupt();\n+        }\n+        throw new IOException(e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d7b701e8535c863ae9c395a75668c6f2f9f88c38"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDkyOTAxMg==", "bodyText": "Should we make the force sync option a static constant, and reuse it here and below?", "url": "https://github.com/Alluxio/alluxio/pull/11204#discussion_r420929012", "createdAt": "2020-05-06T16:32:47Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/master/file/DefaultFileSystemMaster.java", "diffHunk": "@@ -3235,28 +3096,33 @@ public void activeSyncMetadata(AlluxioURI path, Collection<AlluxioURI> changedFi\n     try (RpcContext rpcContext = createRpcContext()) {\n       if (changedFiles == null) {\n         // full sync\n-        LockingScheme lockingScheme = new LockingScheme(path, LockPattern.READ, true);\n-        try (LockedInodePath inodePath =\n-            mInodeTree.lockInodePath(lockingScheme.getPath(), lockingScheme.getPattern())) {\n-          syncMetadataInternal(rpcContext, inodePath, lockingScheme, DescendantType.ALL,\n-              populateStatusCache(path, DescendantType.ALL));\n+        long start = System.currentTimeMillis();\n+\n+        // Set sync interval to 0 to force a sync.\n+        FileSystemMasterCommonPOptions options =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d7b701e8535c863ae9c395a75668c6f2f9f88c38"}, "originalPosition": 1329}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2d1a8fcb7a445a1ec8753b5e7a1f2d8d6abc8b4a", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/2d1a8fcb7a445a1ec8753b5e7a1f2d8d6abc8b4a", "committedDate": "2020-05-08T19:09:12Z", "message": "Initial parallelized implementation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b38097f7de977e75377b871077266cae9cca2015", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/b38097f7de977e75377b871077266cae9cca2015", "committedDate": "2020-05-08T19:09:12Z", "message": "Stop deadlock when caller already has a write lock"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2bccad4f2c4f4c8580581da325a34cfecf61b6c0", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/2bccad4f2c4f4c8580581da325a34cfecf61b6c0", "committedDate": "2020-05-08T19:09:12Z", "message": "Remove parallelization from loadMetadataInternal"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "46a3f5b69e87ebc08f03a0288cc25598dc5e305d", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/46a3f5b69e87ebc08f03a0288cc25598dc5e305d", "committedDate": "2020-05-08T19:09:12Z", "message": "Re-architect syncing primitive in FileSystemMaster"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "95f823f19d30ec61c5e7d422d9f53f7135fef268", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/95f823f19d30ec61c5e7d422d9f53f7135fef268", "committedDate": "2020-05-08T19:09:12Z", "message": "Remove duplicate code from DFSM"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "27521e30dde045d35199d2e8c32c6d4c334b951d", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/27521e30dde045d35199d2e8c32c6d4c334b951d", "committedDate": "2020-05-08T19:09:12Z", "message": "Fix complete for loadMetadataIfNotExist"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0757fc583a0dc9ad00b8c46e61f96e2b3e9dfc96", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/0757fc583a0dc9ad00b8c46e61f96e2b3e9dfc96", "committedDate": "2020-05-08T19:09:12Z", "message": "Remove and replace old UfsStatusCache"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1eed29033c7a2bf68c3a8423c7ebc2164400c90b", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/1eed29033c7a2bf68c3a8423c7ebc2164400c90b", "committedDate": "2020-05-08T19:09:12Z", "message": "Fully concurrent path syncing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "29ec2eafa11d6eafd13aa0e730762905b89c35cf", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/29ec2eafa11d6eafd13aa0e730762905b89c35cf", "committedDate": "2020-05-08T19:09:12Z", "message": "Appease findbugs and make parallelism configurable"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0fae41a86cc0c2c8e7ec20e6849f2043477d3341", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/0fae41a86cc0c2c8e7ec20e6849f2043477d3341", "committedDate": "2020-05-08T19:09:12Z", "message": "Remove test assertion with runtime assumption"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4793f33f23862af675a672db0b569b19cf689ea0", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/4793f33f23862af675a672db0b569b19cf689ea0", "committedDate": "2020-05-08T19:09:12Z", "message": "Shut down lock pool evictor threads"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "966809048a1a189c3fd9c22ef49030ac78b2789b", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/966809048a1a189c3fd9c22ef49030ac78b2789b", "committedDate": "2020-05-08T19:09:12Z", "message": "Make metrics heartbeat test always use localhost\n\nOccasionally the JVM would pick up my computer's\nLAN name rather than localhost which would cause this test to fail"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d0074877d63bd6b5b8eb086437648dfcb1f44ac6", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/d0074877d63bd6b5b8eb086437648dfcb1f44ac6", "committedDate": "2020-05-08T19:09:12Z", "message": "Close FSMaster during tests\n\nThis prevents lots of un-closed resources from\naccumulating while the test runs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "08fe686de8355a75215e0970d7c3408d7bf7cfc9", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/08fe686de8355a75215e0970d7c3408d7bf7cfc9", "committedDate": "2020-05-08T19:09:12Z", "message": "Only use tryLock for sync stream"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "122c8fe58882ead3608e503622250fd7f5029898", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/122c8fe58882ead3608e503622250fd7f5029898", "committedDate": "2020-05-08T19:09:12Z", "message": "Fix LockPoolTest\n\nI'm not sure how this test didn't fail more consistently before.\n\nPreviously, the test would insert values [0,15] into the lock pool.\nThen, insert 16 in order to trigger an eviction. Next, it would finally\nattempt to insert [16,23]. Which should go up to the high watermark.\nHowever, sometimes the lock pool would evict entries [0, 8] (instead\nof [0,7]) leaving [9, 16], and attempting to insert [16, 23]. [9,23] is\nonly 15 total entries, when it expects 16. I make the test now insert\n[17,24]. It inserts the same amount of keys. It's just that the key\nrange is shifted, so that there is no key overlap.\n\nThe reason is because the evictor thread calculates numToEvict as\npool size - low watermark. After inserting the 17th item, the\nnumToEvict is 17 - 8 -> 9. For some reason before my changes,\nthis was being calculated as 8. As if the evictor was triggered prior\nto the key being added."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2492f81ebd357c28a3a5484313e9ac8b5a65dfcf", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/2492f81ebd357c28a3a5484313e9ac8b5a65dfcf", "committedDate": "2020-05-08T19:09:12Z", "message": "Split sync executor size from sync concurrency\n\nThis can help limit the impact of a single sync job on the\nperformance of Alluxio as a whole. This is especially\nimportant if more than one path is being synced at a time.\nIt allows for a limited level of concurrency but still lets\nus share a single thread pool for executing sync tasks."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "455e16e059fe485611be71f4dfa52633ddf1e254", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/455e16e059fe485611be71f4dfa52633ddf1e254", "committedDate": "2020-05-08T19:09:12Z", "message": "Remove unnecessary logs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e338eb0cac3727f041ecc8d74121e70b426ff197", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/e338eb0cac3727f041ecc8d74121e70b426ff197", "committedDate": "2020-05-08T19:09:12Z", "message": "Improve sync stream javadoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "57fe6801c3d3ef197ef7b5c90dccff53606a1a85", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/57fe6801c3d3ef197ef7b5c90dccff53606a1a85", "committedDate": "2020-05-08T19:09:12Z", "message": "Fix FSMSyncMetadataTest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "87ea39506454ef4195fe3634884b6593dc0c5895", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/87ea39506454ef4195fe3634884b6593dc0c5895", "committedDate": "2020-05-08T19:09:12Z", "message": "Use AlluxioURI for child index key\n\n- Using the UfsStatus presents a few problems because of the possibility\nof hash or equals collisions occurring because the UfsStatus object\ndoesn't compare the full path of the status, rather just the name\nof that index. We don't lose anything by indexing using the full path\nIt is also guaranteed to not have collisions. It is strictly better."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e7ffc1023ce8232b41bc0fe2ead8a1d3656041c8", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/e7ffc1023ce8232b41bc0fe2ead8a1d3656041c8", "committedDate": "2020-05-08T19:09:12Z", "message": "Address comments: UfsStatusCache"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b8dcf2dbc9c4d1dd097f5c952e18151b6ea4e8fe", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/b8dcf2dbc9c4d1dd097f5c952e18151b6ea4e8fe", "committedDate": "2020-05-08T19:09:12Z", "message": "Address comments: InodeSyncStream"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0b959cdfa525ba3af130652c4b174144e7f182ec", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/0b959cdfa525ba3af130652c4b174144e7f182ec", "committedDate": "2020-05-08T19:09:20Z", "message": "UfsSyncIntegrationTest passes\n\nFixed FSMasterRestartIT, UfsSyncIT, PinIT, ReadOnlyMountIT\n\nFix unit and integration tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ea2ade8c1f2cdf29df73c737177bcc6cac22e8f9", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/ea2ade8c1f2cdf29df73c737177bcc6cac22e8f9", "committedDate": "2020-05-08T19:09:12Z", "message": "Add UfsStatus Prefetch mechanism"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "785fcb28910ba907fb9c3a1c9932fcf59614707f", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/785fcb28910ba907fb9c3a1c9932fcf59614707f", "committedDate": "2020-05-08T18:40:57Z", "message": "Rethrow InterruptedException on status cache fetch"}, "afterCommit": {"oid": "c0e5d3bf2c90233a4ad4f76381423f15766e1617", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/c0e5d3bf2c90233a4ad4f76381423f15766e1617", "committedDate": "2020-05-08T19:09:12Z", "message": "Rethrow InterruptedException on status cache fetch"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c0e5d3bf2c90233a4ad4f76381423f15766e1617", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/c0e5d3bf2c90233a4ad4f76381423f15766e1617", "committedDate": "2020-05-08T19:09:12Z", "message": "Rethrow InterruptedException on status cache fetch"}, "afterCommit": {"oid": "26d6f0b37496604d66e68f19447cda6edbffd2e6", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/26d6f0b37496604d66e68f19447cda6edbffd2e6", "committedDate": "2020-05-08T21:13:18Z", "message": "Rethrow InterruptedException on status cache fetch"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "831e03cb111ae3191fdc52e82b131311e3038e59", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/831e03cb111ae3191fdc52e82b131311e3038e59", "committedDate": "2020-05-08T21:36:09Z", "message": "Improve logging for sync and profiling\n\nUtilized LogUtils.warnWithException to improve behavior of exception\nlogging."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b032ccff3d816515b344ee16380a4aecf51f1123", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/b032ccff3d816515b344ee16380a4aecf51f1123", "committedDate": "2020-05-08T21:36:09Z", "message": "Improve UfsStatusCache\n\n- We always check for a prefetch job first before calling getChildren,\nbecause a subsequent prefetch on the same path would then never get\nremoved.\n- Added paths to some error log messages\n- Increased test coverage on the class to 90%"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "26d6f0b37496604d66e68f19447cda6edbffd2e6", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/26d6f0b37496604d66e68f19447cda6edbffd2e6", "committedDate": "2020-05-08T21:13:18Z", "message": "Rethrow InterruptedException on status cache fetch"}, "afterCommit": {"oid": "44210c38347d506143a6322968513abf309802d4", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/44210c38347d506143a6322968513abf309802d4", "committedDate": "2020-05-08T21:36:09Z", "message": "Rethrow InterruptedException on status cache fetch"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "44210c38347d506143a6322968513abf309802d4", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/44210c38347d506143a6322968513abf309802d4", "committedDate": "2020-05-08T21:36:09Z", "message": "Rethrow InterruptedException on status cache fetch"}, "afterCommit": {"oid": "9ce6230d7814448bcda3d43142a84d0b26a6ff3c", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/9ce6230d7814448bcda3d43142a84d0b26a6ff3c", "committedDate": "2020-05-08T21:39:19Z", "message": "Rethrow InterruptedException on status cache fetch"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3NzE5NDky", "url": "https://github.com/Alluxio/alluxio/pull/11204#pullrequestreview-407719492", "createdAt": "2020-05-07T18:14:37Z", "commit": {"oid": "d7b701e8535c863ae9c395a75668c6f2f9f88c38"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxODoxNDozN1rOGSKgTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQwOToyNTowOVrOGTUG6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY5OTY2MQ==", "bodyText": "is there any value in reusing CacheBuilder from guava for this?", "url": "https://github.com/Alluxio/alluxio/pull/11204#discussion_r421699661", "createdAt": "2020-05-07T18:14:37Z", "author": {"login": "yuzhu"}, "path": "core/server/master/src/main/java/alluxio/underfs/UfsStatusCache.java", "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.underfs;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.collections.ConcurrentHashSet;\n+import alluxio.exception.InvalidPathException;\n+import alluxio.master.file.meta.MountTable;\n+import alluxio.resource.CloseableResource;\n+import alluxio.util.LogUtils;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.ThreadSafe;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.RejectedExecutionException;\n+\n+/**\n+ * This class is a cache from an Alluxio namespace URI ({@link AlluxioURI}, i.e. /path/to/inode) to\n+ * UFS statuses.\n+ *\n+ * It also allows associating a path with child inodes, so that the statuses for a specific path can\n+ * be searched for later.\n+ */\n+@ThreadSafe\n+public class UfsStatusCache {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d7b701e8535c863ae9c395a75668c6f2f9f88c38"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjg5Mjk4Mg==", "bodyText": "could we have some of these comments in the source code?  helps the next reader", "url": "https://github.com/Alluxio/alluxio/pull/11204#discussion_r422892982", "createdAt": "2020-05-11T09:04:20Z", "author": {"login": "yuzhu"}, "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "diffHunk": "@@ -2132,6 +2132,30 @@ public String toString() {\n           .setConsistencyCheckLevel(ConsistencyCheckLevel.WARN)\n           .setScope(Scope.MASTER)\n           .build();\n+  public static final PropertyKey MASTER_METADATA_SYNC_CONCURRENCY_LEVEL =\n+      new Builder(Name.MASTER_METADATA_SYNC_CONCURRENCY_LEVEL)\n+          .setDefaultValue(6)\n+          .setDescription(\"The maximum number of concurrent sync tasks running for a given sync \"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY4MjcyNg=="}, "originalCommit": {"oid": "aea2599ba2565e052e3871653282b3f22a325203"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjkwNDkzOA==", "bodyText": "in this case, are we ok with dangling cache entries? for a path /a/b/c, if /a is removed , /a/b -> {/a/b/c} is still in the cache, so is /a/b, do you think we should do cascading removal?", "url": "https://github.com/Alluxio/alluxio/pull/11204#discussion_r422904938", "createdAt": "2020-05-11T09:24:10Z", "author": {"login": "yuzhu"}, "path": "core/server/master/src/main/java/alluxio/underfs/UfsStatusCache.java", "diffHunk": "@@ -0,0 +1,275 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.underfs;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.collections.ConcurrentHashSet;\n+import alluxio.exception.InvalidPathException;\n+import alluxio.master.file.meta.MountTable;\n+import alluxio.resource.CloseableResource;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nullable;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.RejectedExecutionException;\n+\n+/**\n+ * This class is a cache from an Alluxio namespace URI ({@link AlluxioURI}, i.e. /path/to/inode) to\n+ * UFS statuses.\n+ *\n+ * It also allows associating a path with child inodes, so that the statuses for a specific path can\n+ * be searched for later.\n+ */\n+public class UfsStatusCache {\n+  private static final Logger LOG = LoggerFactory.getLogger(UfsStatusCache.class);\n+\n+  private final ConcurrentHashMap<AlluxioURI, UfsStatus> mStatuses;\n+  private final ConcurrentHashMap<AlluxioURI, Future<Collection<UfsStatus>>> mActivePrefetchJobs;\n+  private final ConcurrentHashMap<AlluxioURI, Collection<UfsStatus>> mChildren;\n+  private final ExecutorService mPrefetchExecutor;\n+\n+  /**\n+   * Create a new instance of {@link UfsStatusCache}.\n+   *\n+   * @param prefetchExecutor the executor service used to prefetch statuses\n+   */\n+  public UfsStatusCache(@Nullable ExecutorService prefetchExecutor) {\n+    mStatuses = new ConcurrentHashMap<>();\n+    mChildren = new ConcurrentHashMap<>();\n+    mActivePrefetchJobs = new ConcurrentHashMap<>();\n+    mPrefetchExecutor = prefetchExecutor;\n+  }\n+\n+  /**\n+   * Add a new status to the cache.\n+   *\n+   * The last component of the path in the {@link AlluxioURI} must match the result of\n+   * {@link UfsStatus#getName()}. This method overrides any status currently cached for the same\n+   * URI.\n+   *\n+   * @param path the Alluxio path to key on\n+   * @param status the ufs status to store\n+   * @throws IllegalArgumentException if the status name doesn't match the final URI path component\n+   */\n+  public void addStatus(AlluxioURI path, UfsStatus status) {\n+    UfsStatus prev = mStatuses.putIfAbsent(path, status);\n+    if (!path.getName().equals(status.getName())) {\n+      throw new IllegalArgumentException(\n+          String.format(\"path name %s does not match ufs status name %s\",\n+              path.getName(), status.getName()));\n+    }\n+  }\n+\n+  /**\n+   * Add a parent-child mapping to the status cache.\n+   *\n+   * All child statuses added via this method will be available via {@link #getStatus(AlluxioURI)}.\n+   *\n+   * @param path the directory inode path which contains the children\n+   * @param children the children of the {@code path}\n+   * @throws IllegalArgumentException when {@code path} already exists or if any child already\n+   *                                  exists\n+   */\n+  public void addChildren(AlluxioURI path, Collection<UfsStatus> children) {\n+    UfsStatus status = mStatuses.get(path);\n+    // If this path doesn't yet exist, we can't keep track of the parent-child relationship\n+    // We can still add statuses to the cache regardless\n+    if (status != null) {\n+      mChildren.computeIfAbsent(path, ufsStatus -> new ConcurrentHashSet<>()).addAll(children);\n+    }\n+    children.forEach(child -> {\n+      AlluxioURI childPath = path.joinUnsafe(child.getName());\n+      addStatus(childPath, child);\n+    });\n+  }\n+\n+  /**\n+   * Remove a status from the cache.\n+   *\n+   *  Any children added to this status will remain in the cache.\n+   *\n+   * @param path the path corresponding to the {@link UfsStatus} to remove\n+   * @return the removed UfsStatus\n+   */\n+  public UfsStatus remove(AlluxioURI path) {\n+    UfsStatus removed = mStatuses.remove(path);\n+    if (removed == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI5NTQ3Mw=="}, "originalCommit": {"oid": "aea2599ba2565e052e3871653282b3f22a325203"}, "originalPosition": 113}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjkwNTU3Ng==", "bodyText": "let's say /a is removed and added later, it will suddenly get many entries from the past", "url": "https://github.com/Alluxio/alluxio/pull/11204#discussion_r422905576", "createdAt": "2020-05-11T09:25:09Z", "author": {"login": "yuzhu"}, "path": "core/server/master/src/main/java/alluxio/underfs/UfsStatusCache.java", "diffHunk": "@@ -0,0 +1,275 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.underfs;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.collections.ConcurrentHashSet;\n+import alluxio.exception.InvalidPathException;\n+import alluxio.master.file.meta.MountTable;\n+import alluxio.resource.CloseableResource;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nullable;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.RejectedExecutionException;\n+\n+/**\n+ * This class is a cache from an Alluxio namespace URI ({@link AlluxioURI}, i.e. /path/to/inode) to\n+ * UFS statuses.\n+ *\n+ * It also allows associating a path with child inodes, so that the statuses for a specific path can\n+ * be searched for later.\n+ */\n+public class UfsStatusCache {\n+  private static final Logger LOG = LoggerFactory.getLogger(UfsStatusCache.class);\n+\n+  private final ConcurrentHashMap<AlluxioURI, UfsStatus> mStatuses;\n+  private final ConcurrentHashMap<AlluxioURI, Future<Collection<UfsStatus>>> mActivePrefetchJobs;\n+  private final ConcurrentHashMap<AlluxioURI, Collection<UfsStatus>> mChildren;\n+  private final ExecutorService mPrefetchExecutor;\n+\n+  /**\n+   * Create a new instance of {@link UfsStatusCache}.\n+   *\n+   * @param prefetchExecutor the executor service used to prefetch statuses\n+   */\n+  public UfsStatusCache(@Nullable ExecutorService prefetchExecutor) {\n+    mStatuses = new ConcurrentHashMap<>();\n+    mChildren = new ConcurrentHashMap<>();\n+    mActivePrefetchJobs = new ConcurrentHashMap<>();\n+    mPrefetchExecutor = prefetchExecutor;\n+  }\n+\n+  /**\n+   * Add a new status to the cache.\n+   *\n+   * The last component of the path in the {@link AlluxioURI} must match the result of\n+   * {@link UfsStatus#getName()}. This method overrides any status currently cached for the same\n+   * URI.\n+   *\n+   * @param path the Alluxio path to key on\n+   * @param status the ufs status to store\n+   * @throws IllegalArgumentException if the status name doesn't match the final URI path component\n+   */\n+  public void addStatus(AlluxioURI path, UfsStatus status) {\n+    UfsStatus prev = mStatuses.putIfAbsent(path, status);\n+    if (!path.getName().equals(status.getName())) {\n+      throw new IllegalArgumentException(\n+          String.format(\"path name %s does not match ufs status name %s\",\n+              path.getName(), status.getName()));\n+    }\n+  }\n+\n+  /**\n+   * Add a parent-child mapping to the status cache.\n+   *\n+   * All child statuses added via this method will be available via {@link #getStatus(AlluxioURI)}.\n+   *\n+   * @param path the directory inode path which contains the children\n+   * @param children the children of the {@code path}\n+   * @throws IllegalArgumentException when {@code path} already exists or if any child already\n+   *                                  exists\n+   */\n+  public void addChildren(AlluxioURI path, Collection<UfsStatus> children) {\n+    UfsStatus status = mStatuses.get(path);\n+    // If this path doesn't yet exist, we can't keep track of the parent-child relationship\n+    // We can still add statuses to the cache regardless\n+    if (status != null) {\n+      mChildren.computeIfAbsent(path, ufsStatus -> new ConcurrentHashSet<>()).addAll(children);\n+    }\n+    children.forEach(child -> {\n+      AlluxioURI childPath = path.joinUnsafe(child.getName());\n+      addStatus(childPath, child);\n+    });\n+  }\n+\n+  /**\n+   * Remove a status from the cache.\n+   *\n+   *  Any children added to this status will remain in the cache.\n+   *\n+   * @param path the path corresponding to the {@link UfsStatus} to remove\n+   * @return the removed UfsStatus\n+   */\n+  public UfsStatus remove(AlluxioURI path) {\n+    UfsStatus removed = mStatuses.remove(path);\n+    if (removed == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI5NTQ3Mw=="}, "originalCommit": {"oid": "aea2599ba2565e052e3871653282b3f22a325203"}, "originalPosition": 113}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f5bf2dbaf1db2175a8ff8ca1506aa77555cd47e8", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/f5bf2dbaf1db2175a8ff8ca1506aa77555cd47e8", "committedDate": "2020-05-11T16:40:09Z", "message": "Rethrow InterruptedException on status cache fetch"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9ce6230d7814448bcda3d43142a84d0b26a6ff3c", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/9ce6230d7814448bcda3d43142a84d0b26a6ff3c", "committedDate": "2020-05-08T21:39:19Z", "message": "Rethrow InterruptedException on status cache fetch"}, "afterCommit": {"oid": "f5bf2dbaf1db2175a8ff8ca1506aa77555cd47e8", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/f5bf2dbaf1db2175a8ff8ca1506aa77555cd47e8", "committedDate": "2020-05-11T16:40:09Z", "message": "Rethrow InterruptedException on status cache fetch"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA5MzQ0MjAw", "url": "https://github.com/Alluxio/alluxio/pull/11204#pullrequestreview-409344200", "createdAt": "2020-05-11T16:42:22Z", "commit": {"oid": "9ce6230d7814448bcda3d43142a84d0b26a6ff3c"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNjo0MjoyMlrOGTkbrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNjo1Mjo1MVrOGTk1QA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE3MzAzNg==", "bodyText": "Yeah, I know loadMetadata call reuses sync. However, do you think it is possible for everything to be taken care of with the syncMetadata() at the beginning of this method? Basically, for listStatus and fileInfo they both have a concept of loading metadata, which is just the creating part of sync. I wonder if everything could be taken care of in the syncMetadata() call, so we don't even need the loadMetadata() method anymore.\n(This would not be part of this PR)", "url": "https://github.com/Alluxio/alluxio/pull/11204#discussion_r423173036", "createdAt": "2020-05-11T16:42:22Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/master/file/DefaultFileSystemMaster.java", "diffHunk": "@@ -815,73 +841,81 @@ public void listStatus(AlluxioURI path, ListStatusContext context,\n       ResultStream<FileInfo> resultStream)\n       throws AccessControlException, FileDoesNotExistException, InvalidPathException, IOException {\n     Metrics.GET_FILE_INFO_OPS.inc();\n-    LockingScheme lockingScheme =\n-        createLockingScheme(path, context.getOptions().getCommonOptions(), LockPattern.READ);\n     try (RpcContext rpcContext = createRpcContext();\n-         LockedInodePath inodePath = mInodeTree\n-             .lockInodePath(lockingScheme.getPath(), lockingScheme.getPattern());\n-         FileSystemMasterAuditContext auditContext =\n-             createAuditContext(\"listStatus\", path, null, inodePath.getInodeOrNull())) {\n-      try {\n-        mPermissionChecker.checkPermission(Mode.Bits.READ, inodePath);\n-      } catch (AccessControlException e) {\n-        auditContext.setAllowed(false);\n-        throw e;\n-      }\n-\n-      DescendantType descendantType = context.getOptions().getRecursive() ? DescendantType.ALL\n-          : DescendantType.ONE;\n-      // Possible ufs sync.\n-      if (syncMetadata(rpcContext, inodePath, lockingScheme, descendantType)) {\n+        FileSystemMasterAuditContext auditContext =\n+            createAuditContext(\"listStatus\", path, null, null)) {\n+\n+      DescendantType descendantType =\n+          context.getOptions().getRecursive() ? DescendantType.ALL : DescendantType.ONE;\n+      if (syncMetadata(rpcContext,\n+          path,\n+          context.getOptions().getCommonOptions(),\n+          descendantType,\n+          auditContext,\n+          LockedInodePath::getInodeOrNull,\n+          (inodePath, permChecker) -> permChecker.checkPermission(Mode.Bits.READ, inodePath))) {\n         // If synced, do not load metadata.\n         context.getOptions().setLoadMetadataType(LoadMetadataPType.NEVER);\n       }\n \n-      DescendantType loadDescendantType;\n-      if (context.getOptions().getLoadMetadataType() == LoadMetadataPType.NEVER) {\n-        loadDescendantType = DescendantType.NONE;\n-      } else if (context.getOptions().getRecursive()) {\n-        loadDescendantType = DescendantType.ALL;\n-      } else {\n-        loadDescendantType = DescendantType.ONE;\n-      }\n-      // load metadata for 1 level of descendants, or all descendants if recursive\n-      LoadMetadataContext loadMetadataContext =\n-          LoadMetadataContext.mergeFrom(LoadMetadataPOptions.newBuilder().setCreateAncestors(true)\n-              .setLoadDescendantType(GrpcUtils.toProto(loadDescendantType))\n-              .setCommonOptions(FileSystemMasterCommonPOptions.newBuilder()\n-                  .setTtl(context.getOptions().getCommonOptions().getTtl())\n-                  .setTtlAction(context.getOptions().getCommonOptions().getTtlAction())));\n-      Inode inode;\n-      if (inodePath.fullPathExists()) {\n-        inode = inodePath.getInode();\n-        if (inode.isDirectory()\n-            && context.getOptions().getLoadMetadataType() != LoadMetadataPType.ALWAYS) {\n-          InodeDirectory inodeDirectory = inode.asDirectory();\n+      // We just synced; the new lock pattern should not sync.\n+      LockingScheme lockingScheme = new LockingScheme(path, LockPattern.READ, false);\n+      try (LockedInodePath inodePath = mInodeTree.lockInodePath(lockingScheme)) {\n+        auditContext.setSrcInode(inodePath.getInodeOrNull());\n+        try {\n+          mPermissionChecker.checkPermission(Mode.Bits.READ, inodePath);\n+        } catch (AccessControlException e) {\n+          auditContext.setAllowed(false);\n+          throw e;\n+        }\n \n-          boolean isLoaded = inodeDirectory.isDirectChildrenLoaded();\n-          if (context.getOptions().getRecursive()) {\n-            isLoaded = areDescendantsLoaded(inodeDirectory);\n-          }\n-          if (isLoaded) {\n-            // no need to load again.\n-            loadMetadataContext.getOptions().setLoadDescendantType(LoadDescendantPType.NONE);\n+        DescendantType loadDescendantType;\n+        if (context.getOptions().getLoadMetadataType() == LoadMetadataPType.NEVER) {\n+          loadDescendantType = DescendantType.NONE;\n+        } else if (context.getOptions().getRecursive()) {\n+          loadDescendantType = DescendantType.ALL;\n+        } else {\n+          loadDescendantType = DescendantType.ONE;\n+        }\n+        // load metadata for 1 level of descendants, or all descendants if recursive\n+        LoadMetadataContext loadMetadataContext = LoadMetadataContext.mergeFrom(\n+            LoadMetadataPOptions.newBuilder()\n+                .setCreateAncestors(true)\n+                .setLoadDescendantType(GrpcUtils.toProto(loadDescendantType))\n+                .setCommonOptions(FileSystemMasterCommonPOptions.newBuilder()\n+                    .setTtl(context.getOptions().getCommonOptions().getTtl())\n+                    .setTtlAction(context.getOptions().getCommonOptions().getTtlAction())));\n+        Inode inode;\n+        if (inodePath.fullPathExists()) {\n+          inode = inodePath.getInode();\n+          if (inode.isDirectory()\n+              && context.getOptions().getLoadMetadataType() != LoadMetadataPType.ALWAYS) {\n+            InodeDirectory inodeDirectory = inode.asDirectory();\n+\n+            boolean isLoaded = inodeDirectory.isDirectChildrenLoaded();\n+            if (context.getOptions().getRecursive()) {\n+              isLoaded = areDescendantsLoaded(inodeDirectory);\n+            }\n+            if (isLoaded) {\n+              // no need to load again.\n+              loadMetadataContext.getOptions().setLoadDescendantType(LoadDescendantPType.NONE);\n+            }\n           }\n+        } else {\n+          checkLoadMetadataOptions(context.getOptions().getLoadMetadataType(), inodePath.getUri());\n         }\n-      } else {\n-        checkLoadMetadataOptions(context.getOptions().getLoadMetadataType(), inodePath.getUri());\n-      }\n \n-      loadMetadataIfNotExist(rpcContext, inodePath, loadMetadataContext);\n-      ensureFullPathAndUpdateCache(inodePath);\n-      inode = inodePath.getInode();\n-      auditContext.setSrcInode(inode);\n-      DescendantType descendantTypeForListStatus =\n-          (context.getOptions().getRecursive()) ? DescendantType.ALL : DescendantType.ONE;\n-      listStatusInternal(context, rpcContext, inodePath, auditContext, descendantTypeForListStatus,\n-          resultStream, 0);\n-      auditContext.setSucceeded(true);\n-      Metrics.FILE_INFOS_GOT.inc();\n+        loadMetadataIfNotExist(rpcContext, inodePath, loadMetadataContext, false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU5Mzg5Mw=="}, "originalCommit": {"oid": "ff8a137d843dabc6cb4b38fb5ae7a324cae6fec4"}, "originalPosition": 352}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE3OTU4NA==", "bodyText": "@ZacBlanco Is there any relationship between the listings cache, and the status cache? Meaning, if the listing cache has the mapping /parent/ -> [/parent/a, /parent/b, /parent/c], is the status cache guaranteed to have the status of /parent/a, /parent/b, and /parent/c?", "url": "https://github.com/Alluxio/alluxio/pull/11204#discussion_r423179584", "createdAt": "2020-05-11T16:52:51Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/underfs/UfsStatusCache.java", "diffHunk": "@@ -0,0 +1,275 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.underfs;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.collections.ConcurrentHashSet;\n+import alluxio.exception.InvalidPathException;\n+import alluxio.master.file.meta.MountTable;\n+import alluxio.resource.CloseableResource;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nullable;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.RejectedExecutionException;\n+\n+/**\n+ * This class is a cache from an Alluxio namespace URI ({@link AlluxioURI}, i.e. /path/to/inode) to\n+ * UFS statuses.\n+ *\n+ * It also allows associating a path with child inodes, so that the statuses for a specific path can\n+ * be searched for later.\n+ */\n+public class UfsStatusCache {\n+  private static final Logger LOG = LoggerFactory.getLogger(UfsStatusCache.class);\n+\n+  private final ConcurrentHashMap<AlluxioURI, UfsStatus> mStatuses;\n+  private final ConcurrentHashMap<AlluxioURI, Future<Collection<UfsStatus>>> mActivePrefetchJobs;\n+  private final ConcurrentHashMap<AlluxioURI, Collection<UfsStatus>> mChildren;\n+  private final ExecutorService mPrefetchExecutor;\n+\n+  /**\n+   * Create a new instance of {@link UfsStatusCache}.\n+   *\n+   * @param prefetchExecutor the executor service used to prefetch statuses\n+   */\n+  public UfsStatusCache(@Nullable ExecutorService prefetchExecutor) {\n+    mStatuses = new ConcurrentHashMap<>();\n+    mChildren = new ConcurrentHashMap<>();\n+    mActivePrefetchJobs = new ConcurrentHashMap<>();\n+    mPrefetchExecutor = prefetchExecutor;\n+  }\n+\n+  /**\n+   * Add a new status to the cache.\n+   *\n+   * The last component of the path in the {@link AlluxioURI} must match the result of\n+   * {@link UfsStatus#getName()}. This method overrides any status currently cached for the same\n+   * URI.\n+   *\n+   * @param path the Alluxio path to key on\n+   * @param status the ufs status to store\n+   * @throws IllegalArgumentException if the status name doesn't match the final URI path component\n+   */\n+  public void addStatus(AlluxioURI path, UfsStatus status) {\n+    UfsStatus prev = mStatuses.putIfAbsent(path, status);\n+    if (!path.getName().equals(status.getName())) {\n+      throw new IllegalArgumentException(\n+          String.format(\"path name %s does not match ufs status name %s\",\n+              path.getName(), status.getName()));\n+    }\n+  }\n+\n+  /**\n+   * Add a parent-child mapping to the status cache.\n+   *\n+   * All child statuses added via this method will be available via {@link #getStatus(AlluxioURI)}.\n+   *\n+   * @param path the directory inode path which contains the children\n+   * @param children the children of the {@code path}\n+   * @throws IllegalArgumentException when {@code path} already exists or if any child already\n+   *                                  exists\n+   */\n+  public void addChildren(AlluxioURI path, Collection<UfsStatus> children) {\n+    UfsStatus status = mStatuses.get(path);\n+    // If this path doesn't yet exist, we can't keep track of the parent-child relationship\n+    // We can still add statuses to the cache regardless\n+    if (status != null) {\n+      mChildren.computeIfAbsent(path, ufsStatus -> new ConcurrentHashSet<>()).addAll(children);\n+    }\n+    children.forEach(child -> {\n+      AlluxioURI childPath = path.joinUnsafe(child.getName());\n+      addStatus(childPath, child);\n+    });\n+  }\n+\n+  /**\n+   * Remove a status from the cache.\n+   *\n+   *  Any children added to this status will remain in the cache.\n+   *\n+   * @param path the path corresponding to the {@link UfsStatus} to remove\n+   * @return the removed UfsStatus\n+   */\n+  public UfsStatus remove(AlluxioURI path) {\n+    UfsStatus removed = mStatuses.remove(path);\n+    if (removed == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI5NTQ3Mw=="}, "originalCommit": {"oid": "aea2599ba2565e052e3871653282b3f22a325203"}, "originalPosition": 113}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "681f9317b17a1bbf457807d2b1a2f24526ea6829", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/681f9317b17a1bbf457807d2b1a2f24526ea6829", "committedDate": "2020-05-11T20:53:32Z", "message": "Fix UfsStatusCache removal, add tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA5NTY0MzU3", "url": "https://github.com/Alluxio/alluxio/pull/11204#pullrequestreview-409564357", "createdAt": "2020-05-11T22:05:09Z", "commit": {"oid": "681f9317b17a1bbf457807d2b1a2f24526ea6829"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA5NjE1NTg4", "url": "https://github.com/Alluxio/alluxio/pull/11204#pullrequestreview-409615588", "createdAt": "2020-05-12T00:14:21Z", "commit": {"oid": "681f9317b17a1bbf457807d2b1a2f24526ea6829"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4698, "cost": 1, "resetAt": "2021-10-29T17:30:11Z"}}}