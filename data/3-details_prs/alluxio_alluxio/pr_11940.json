{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY0OTM5Njkx", "number": 11940, "title": "Migrate state machine to ratis", "bodyText": "Initial changes for hooking up embedded journal state machine with ratis API.  Implemented leader election, journal application and taking snapshot on followers.", "createdAt": "2020-08-08T02:55:43Z", "url": "https://github.com/Alluxio/alluxio/pull/11940", "merged": true, "mergeCommit": {"oid": "2c7bfbec61f4958066c302a4b63c46582cb514fb"}, "closed": true, "closedAt": "2020-08-25T17:46:45Z", "author": {"login": "bf8086"}, "timelineItems": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc8vcAaAH2gAyNDY0OTM5NjkxOjViOGE4MGZkZjIzZmI3MTNkZDcxMGMwNDYzODEwYzNlNWMyMmI5Yjg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdCYxEUAFqTQ3NDU4NjI5MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "5b8a80fdf23fb713dd710c0463810c3e5c22b9b8", "author": {"user": {"login": "bf8086", "name": null}}, "url": "https://github.com/Alluxio/alluxio/commit/5b8a80fdf23fb713dd710c0463810c3e5c22b9b8", "committedDate": "2020-08-08T02:17:40Z", "message": "migrate state machine to ratis"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "93b957447387511b7619456098f30b1866cae103", "author": {"user": {"login": "bf8086", "name": null}}, "url": "https://github.com/Alluxio/alluxio/commit/93b957447387511b7619456098f30b1866cae103", "committedDate": "2020-08-13T18:43:45Z", "message": "Fix spotbug issues"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0f13afcb308e7e142ab95f07337bb634f9b33645", "author": {"user": {"login": "bf8086", "name": null}}, "url": "https://github.com/Alluxio/alluxio/commit/0f13afcb308e7e142ab95f07337bb634f9b33645", "committedDate": "2020-08-14T06:23:55Z", "message": "Fix unit test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9250d5b4373f086ec5da357acc86d3167c3cfbcb", "author": {"user": {"login": "bf8086", "name": null}}, "url": "https://github.com/Alluxio/alluxio/commit/9250d5b4373f086ec5da357acc86d3167c3cfbcb", "committedDate": "2020-08-14T07:15:49Z", "message": "Clean up comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "78e1bfffd8435db5525423ebf415d3785f61ba61", "author": {"user": {"login": "bf8086", "name": null}}, "url": "https://github.com/Alluxio/alluxio/commit/78e1bfffd8435db5525423ebf415d3785f61ba61", "committedDate": "2020-08-15T01:24:49Z", "message": "Update journal dumper and fix tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "04df2168f24846426848cced3a7462ae2b8571b3", "author": {"user": {"login": "bf8086", "name": null}}, "url": "https://github.com/Alluxio/alluxio/commit/04df2168f24846426848cced3a7462ae2b8571b3", "committedDate": "2020-08-17T17:54:33Z", "message": "Fix more tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "54853c807e70564964849901be803ffb949a5435", "author": {"user": {"login": "bf8086", "name": null}}, "url": "https://github.com/Alluxio/alluxio/commit/54853c807e70564964849901be803ffb949a5435", "committedDate": "2020-08-18T09:29:00Z", "message": "Clean up code"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "96131f5114210d2a09e1d955f53ee3296b97fb98", "author": {"user": {"login": "bf8086", "name": null}}, "url": "https://github.com/Alluxio/alluxio/commit/96131f5114210d2a09e1d955f53ee3296b97fb98", "committedDate": "2020-08-18T16:26:20Z", "message": "Fix snapshot bug"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxODIwNzU5", "url": "https://github.com/Alluxio/alluxio/pull/11940#pullrequestreview-471820759", "createdAt": "2020-08-20T17:09:24Z", "commit": {"oid": "96131f5114210d2a09e1d955f53ee3296b97fb98"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNzowOToyNFrOHELeUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMFQxNzo1NjoxNFrOHENDgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE0NDMzOQ==", "bodyText": "When can we get rid of these copycat dependencies?", "url": "https://github.com/Alluxio/alluxio/pull/11940#discussion_r474144339", "createdAt": "2020-08-20T17:09:24Z", "author": {"login": "gpang"}, "path": "core/server/common/pom.xml", "diffHunk": "@@ -42,6 +42,14 @@\n       <groupId>io.atomix.copycat.alluxio</groupId>\n       <artifactId>copycat-client</artifactId>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "96131f5114210d2a09e1d955f53ee3296b97fb98"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE0NDY3Ng==", "bodyText": "why does it take so long to register nodes?", "url": "https://github.com/Alluxio/alluxio/pull/11940#discussion_r474144676", "createdAt": "2020-08-20T17:09:59Z", "author": {"login": "gpang"}, "path": "tests/src/test/java/alluxio/server/ft/journal/TriggeredCheckpointTest.java", "diffHunk": "@@ -121,7 +121,7 @@ private void validateCheckpointInClusterRestart(MultiProcessCluster cluster)\n       throws Exception {\n     cluster.stopMasters();\n     cluster.startMasters();\n-    cluster.waitForAllNodesRegistered(20 * Constants.SECOND_MS);\n+    cluster.waitForAllNodesRegistered(30 * Constants.SECOND_MS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "96131f5114210d2a09e1d955f53ee3296b97fb98"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE0NjQ2NA==", "bodyText": "old calculation was wrong?", "url": "https://github.com/Alluxio/alluxio/pull/11940#discussion_r474146464", "createdAt": "2020-08-20T17:13:15Z", "author": {"login": "gpang"}, "path": "core/server/common/src/test/java/alluxio/master/journal/raft/RaftJournalTest.java", "diffHunk": "@@ -242,9 +242,10 @@ public void gainPrimacyAfterSuspend() throws Exception {\n     Assert.assertEquals(0, countingMaster.getApplyCount());\n     // Gain primacy in follower journal and validate it catches up.\n     mFollowerJournalSystem.gainPrimacy();\n-    CommonUtils.waitFor(\"full state acquired after resume\",\n-        () -> countingMaster.getApplyCount() == entryCount, mWaitOptions);\n-\n+    CommonUtils.waitFor(\n+        \"full state acquired after resume\", () -> mFollowerJournalSystem.getCurrentSequenceNumbers()\n+            .values().stream().distinct().collect(Collectors.toList()).get(0) == entryCount - 1,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "96131f5114210d2a09e1d955f53ee3296b97fb98"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE2MTczOA==", "bodyText": "Is there any identifier we can add to this message?", "url": "https://github.com/Alluxio/alluxio/pull/11940#discussion_r474161738", "createdAt": "2020-08-20T17:40:49Z", "author": {"login": "gpang"}, "path": "core/server/common/src/main/java/alluxio/master/journal/raft/JournalStateMachine.java", "diffHunk": "@@ -70,35 +88,164 @@\n   private volatile long mLastPrimaryStartSequenceNumber = 0;\n   private volatile long mNextSequenceNumberToRead = 0;\n   private volatile boolean mSnapshotting = false;\n+  private volatile boolean mIsLeader = false;\n+\n   // The start time of the most recent snapshot\n   private volatile long mLastSnapshotStartTime = 0;\n   /** Used to control applying to masters. */\n   private BufferedJournalApplier mJournalApplier;\n+  private final SimpleStateMachineStorage mStorage = new SimpleStateMachineStorage();\n+  private RaftGroupId mRaftGroupId;\n \n   /**\n-   * @param journals master journals; these journals are still owned by the caller, not by the\n-   *        journal state machine\n-   * @param journalSinks a supplier for journal sinks\n+   * @param journals     master journals; these journals are still owned by the caller, not by the\n+   *                     journal state machine\n+   * @param journalSystem the raft journal system\n    */\n-  public JournalStateMachine(Map<String, RaftJournal> journals,\n-      Supplier<Set<JournalSink>> journalSinks) {\n+  public JournalStateMachine(Map<String, RaftJournal> journals, RaftJournalSystem journalSystem) {\n     mJournals = journals;\n-    mJournalApplier = new BufferedJournalApplier(journals, journalSinks);\n+    mJournalApplier = new BufferedJournalApplier(journals,\n+        () -> journalSystem.getJournalSinks(null));\n     resetState();\n     LOG.info(\"Initialized new journal state machine\");\n+    mJournalSystem = journalSystem;\n+  }\n+\n+  private static <T> CompletableFuture<T> completeExceptionally(Exception e) {\n+    final CompletableFuture<T> future = new CompletableFuture<>();\n+    future.completeExceptionally(e);\n+    return future;\n+  }\n+\n+  @Override\n+  public void initialize(RaftServer server, RaftGroupId groupId,\n+      RaftStorage raftStorage) throws IOException {\n+    getLifeCycle().startAndTransition(() -> {\n+      super.initialize(server, groupId, raftStorage);\n+      mRaftGroupId = groupId;\n+      mStorage.init(raftStorage);\n+      loadSnapshot(mStorage.getLatestSnapshot());\n+    });\n+  }\n+\n+  @Override\n+  public void reinitialize() throws IOException {\n+    LOG.info(\"Reinitializing state machine.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "96131f5114210d2a09e1d955f53ee3296b97fb98"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE2MjEzOA==", "bodyText": "I'm curious. Why does reinitialize() and initialize() look completely different? I would have imagined that reinitialize would be quite similar to initialize, or would share some code?", "url": "https://github.com/Alluxio/alluxio/pull/11940#discussion_r474162138", "createdAt": "2020-08-20T17:41:32Z", "author": {"login": "gpang"}, "path": "core/server/common/src/main/java/alluxio/master/journal/raft/JournalStateMachine.java", "diffHunk": "@@ -70,35 +88,164 @@\n   private volatile long mLastPrimaryStartSequenceNumber = 0;\n   private volatile long mNextSequenceNumberToRead = 0;\n   private volatile boolean mSnapshotting = false;\n+  private volatile boolean mIsLeader = false;\n+\n   // The start time of the most recent snapshot\n   private volatile long mLastSnapshotStartTime = 0;\n   /** Used to control applying to masters. */\n   private BufferedJournalApplier mJournalApplier;\n+  private final SimpleStateMachineStorage mStorage = new SimpleStateMachineStorage();\n+  private RaftGroupId mRaftGroupId;\n \n   /**\n-   * @param journals master journals; these journals are still owned by the caller, not by the\n-   *        journal state machine\n-   * @param journalSinks a supplier for journal sinks\n+   * @param journals     master journals; these journals are still owned by the caller, not by the\n+   *                     journal state machine\n+   * @param journalSystem the raft journal system\n    */\n-  public JournalStateMachine(Map<String, RaftJournal> journals,\n-      Supplier<Set<JournalSink>> journalSinks) {\n+  public JournalStateMachine(Map<String, RaftJournal> journals, RaftJournalSystem journalSystem) {\n     mJournals = journals;\n-    mJournalApplier = new BufferedJournalApplier(journals, journalSinks);\n+    mJournalApplier = new BufferedJournalApplier(journals,\n+        () -> journalSystem.getJournalSinks(null));\n     resetState();\n     LOG.info(\"Initialized new journal state machine\");\n+    mJournalSystem = journalSystem;\n+  }\n+\n+  private static <T> CompletableFuture<T> completeExceptionally(Exception e) {\n+    final CompletableFuture<T> future = new CompletableFuture<>();\n+    future.completeExceptionally(e);\n+    return future;\n+  }\n+\n+  @Override\n+  public void initialize(RaftServer server, RaftGroupId groupId,\n+      RaftStorage raftStorage) throws IOException {\n+    getLifeCycle().startAndTransition(() -> {\n+      super.initialize(server, groupId, raftStorage);\n+      mRaftGroupId = groupId;\n+      mStorage.init(raftStorage);\n+      loadSnapshot(mStorage.getLatestSnapshot());\n+    });\n+  }\n+\n+  @Override\n+  public void reinitialize() throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "96131f5114210d2a09e1d955f53ee3296b97fb98"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE2MjY5Nw==", "bodyText": "Should be ERROR. Also, when does this happen? I don't know what this message is supposed to tell the user.\nWhy is this not throwing an exception instead?", "url": "https://github.com/Alluxio/alluxio/pull/11940#discussion_r474162697", "createdAt": "2020-08-20T17:42:36Z", "author": {"login": "gpang"}, "path": "core/server/common/src/main/java/alluxio/master/journal/raft/JournalStateMachine.java", "diffHunk": "@@ -70,35 +88,164 @@\n   private volatile long mLastPrimaryStartSequenceNumber = 0;\n   private volatile long mNextSequenceNumberToRead = 0;\n   private volatile boolean mSnapshotting = false;\n+  private volatile boolean mIsLeader = false;\n+\n   // The start time of the most recent snapshot\n   private volatile long mLastSnapshotStartTime = 0;\n   /** Used to control applying to masters. */\n   private BufferedJournalApplier mJournalApplier;\n+  private final SimpleStateMachineStorage mStorage = new SimpleStateMachineStorage();\n+  private RaftGroupId mRaftGroupId;\n \n   /**\n-   * @param journals master journals; these journals are still owned by the caller, not by the\n-   *        journal state machine\n-   * @param journalSinks a supplier for journal sinks\n+   * @param journals     master journals; these journals are still owned by the caller, not by the\n+   *                     journal state machine\n+   * @param journalSystem the raft journal system\n    */\n-  public JournalStateMachine(Map<String, RaftJournal> journals,\n-      Supplier<Set<JournalSink>> journalSinks) {\n+  public JournalStateMachine(Map<String, RaftJournal> journals, RaftJournalSystem journalSystem) {\n     mJournals = journals;\n-    mJournalApplier = new BufferedJournalApplier(journals, journalSinks);\n+    mJournalApplier = new BufferedJournalApplier(journals,\n+        () -> journalSystem.getJournalSinks(null));\n     resetState();\n     LOG.info(\"Initialized new journal state machine\");\n+    mJournalSystem = journalSystem;\n+  }\n+\n+  private static <T> CompletableFuture<T> completeExceptionally(Exception e) {\n+    final CompletableFuture<T> future = new CompletableFuture<>();\n+    future.completeExceptionally(e);\n+    return future;\n+  }\n+\n+  @Override\n+  public void initialize(RaftServer server, RaftGroupId groupId,\n+      RaftStorage raftStorage) throws IOException {\n+    getLifeCycle().startAndTransition(() -> {\n+      super.initialize(server, groupId, raftStorage);\n+      mRaftGroupId = groupId;\n+      mStorage.init(raftStorage);\n+      loadSnapshot(mStorage.getLatestSnapshot());\n+    });\n+  }\n+\n+  @Override\n+  public void reinitialize() throws IOException {\n+    LOG.info(\"Reinitializing state machine.\");\n+    mStorage.loadLatestSnapshot();\n+    loadSnapshot(mStorage.getLatestSnapshot());\n+    unpause();\n+  }\n+\n+  private void loadSnapshot(SingleFileSnapshotInfo snapshot) throws IOException {\n+    if (snapshot == null) {\n+      LOG.info(\"No snapshot to load\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "96131f5114210d2a09e1d955f53ee3296b97fb98"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE2MzAyMQ==", "bodyText": "Do we need to log and throw the same exception?", "url": "https://github.com/Alluxio/alluxio/pull/11940#discussion_r474163021", "createdAt": "2020-08-20T17:43:12Z", "author": {"login": "gpang"}, "path": "core/server/common/src/main/java/alluxio/master/journal/raft/JournalStateMachine.java", "diffHunk": "@@ -70,35 +88,164 @@\n   private volatile long mLastPrimaryStartSequenceNumber = 0;\n   private volatile long mNextSequenceNumberToRead = 0;\n   private volatile boolean mSnapshotting = false;\n+  private volatile boolean mIsLeader = false;\n+\n   // The start time of the most recent snapshot\n   private volatile long mLastSnapshotStartTime = 0;\n   /** Used to control applying to masters. */\n   private BufferedJournalApplier mJournalApplier;\n+  private final SimpleStateMachineStorage mStorage = new SimpleStateMachineStorage();\n+  private RaftGroupId mRaftGroupId;\n \n   /**\n-   * @param journals master journals; these journals are still owned by the caller, not by the\n-   *        journal state machine\n-   * @param journalSinks a supplier for journal sinks\n+   * @param journals     master journals; these journals are still owned by the caller, not by the\n+   *                     journal state machine\n+   * @param journalSystem the raft journal system\n    */\n-  public JournalStateMachine(Map<String, RaftJournal> journals,\n-      Supplier<Set<JournalSink>> journalSinks) {\n+  public JournalStateMachine(Map<String, RaftJournal> journals, RaftJournalSystem journalSystem) {\n     mJournals = journals;\n-    mJournalApplier = new BufferedJournalApplier(journals, journalSinks);\n+    mJournalApplier = new BufferedJournalApplier(journals,\n+        () -> journalSystem.getJournalSinks(null));\n     resetState();\n     LOG.info(\"Initialized new journal state machine\");\n+    mJournalSystem = journalSystem;\n+  }\n+\n+  private static <T> CompletableFuture<T> completeExceptionally(Exception e) {\n+    final CompletableFuture<T> future = new CompletableFuture<>();\n+    future.completeExceptionally(e);\n+    return future;\n+  }\n+\n+  @Override\n+  public void initialize(RaftServer server, RaftGroupId groupId,\n+      RaftStorage raftStorage) throws IOException {\n+    getLifeCycle().startAndTransition(() -> {\n+      super.initialize(server, groupId, raftStorage);\n+      mRaftGroupId = groupId;\n+      mStorage.init(raftStorage);\n+      loadSnapshot(mStorage.getLatestSnapshot());\n+    });\n+  }\n+\n+  @Override\n+  public void reinitialize() throws IOException {\n+    LOG.info(\"Reinitializing state machine.\");\n+    mStorage.loadLatestSnapshot();\n+    loadSnapshot(mStorage.getLatestSnapshot());\n+    unpause();\n+  }\n+\n+  private void loadSnapshot(SingleFileSnapshotInfo snapshot) throws IOException {\n+    if (snapshot == null) {\n+      LOG.info(\"No snapshot to load\");\n+      return;\n+    }\n+    LOG.info(\"Loading Snapshot {}\", snapshot);\n+    final File snapshotFile = snapshot.getFile().getPath().toFile();\n+    if (!snapshotFile.exists()) {\n+      LOG.error(\"The snapshot {} does not exist\", snapshot);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "96131f5114210d2a09e1d955f53ee3296b97fb98"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE2MzcxMQ==", "bodyText": "I think if you use the logging with {}, you cannot use the last argument as the exception. You have to use String.format() to pass in a single string, and then the exception.", "url": "https://github.com/Alluxio/alluxio/pull/11940#discussion_r474163711", "createdAt": "2020-08-20T17:44:34Z", "author": {"login": "gpang"}, "path": "core/server/common/src/main/java/alluxio/master/journal/raft/JournalStateMachine.java", "diffHunk": "@@ -70,35 +88,164 @@\n   private volatile long mLastPrimaryStartSequenceNumber = 0;\n   private volatile long mNextSequenceNumberToRead = 0;\n   private volatile boolean mSnapshotting = false;\n+  private volatile boolean mIsLeader = false;\n+\n   // The start time of the most recent snapshot\n   private volatile long mLastSnapshotStartTime = 0;\n   /** Used to control applying to masters. */\n   private BufferedJournalApplier mJournalApplier;\n+  private final SimpleStateMachineStorage mStorage = new SimpleStateMachineStorage();\n+  private RaftGroupId mRaftGroupId;\n \n   /**\n-   * @param journals master journals; these journals are still owned by the caller, not by the\n-   *        journal state machine\n-   * @param journalSinks a supplier for journal sinks\n+   * @param journals     master journals; these journals are still owned by the caller, not by the\n+   *                     journal state machine\n+   * @param journalSystem the raft journal system\n    */\n-  public JournalStateMachine(Map<String, RaftJournal> journals,\n-      Supplier<Set<JournalSink>> journalSinks) {\n+  public JournalStateMachine(Map<String, RaftJournal> journals, RaftJournalSystem journalSystem) {\n     mJournals = journals;\n-    mJournalApplier = new BufferedJournalApplier(journals, journalSinks);\n+    mJournalApplier = new BufferedJournalApplier(journals,\n+        () -> journalSystem.getJournalSinks(null));\n     resetState();\n     LOG.info(\"Initialized new journal state machine\");\n+    mJournalSystem = journalSystem;\n+  }\n+\n+  private static <T> CompletableFuture<T> completeExceptionally(Exception e) {\n+    final CompletableFuture<T> future = new CompletableFuture<>();\n+    future.completeExceptionally(e);\n+    return future;\n+  }\n+\n+  @Override\n+  public void initialize(RaftServer server, RaftGroupId groupId,\n+      RaftStorage raftStorage) throws IOException {\n+    getLifeCycle().startAndTransition(() -> {\n+      super.initialize(server, groupId, raftStorage);\n+      mRaftGroupId = groupId;\n+      mStorage.init(raftStorage);\n+      loadSnapshot(mStorage.getLatestSnapshot());\n+    });\n+  }\n+\n+  @Override\n+  public void reinitialize() throws IOException {\n+    LOG.info(\"Reinitializing state machine.\");\n+    mStorage.loadLatestSnapshot();\n+    loadSnapshot(mStorage.getLatestSnapshot());\n+    unpause();\n+  }\n+\n+  private void loadSnapshot(SingleFileSnapshotInfo snapshot) throws IOException {\n+    if (snapshot == null) {\n+      LOG.info(\"No snapshot to load\");\n+      return;\n+    }\n+    LOG.info(\"Loading Snapshot {}\", snapshot);\n+    final File snapshotFile = snapshot.getFile().getPath().toFile();\n+    if (!snapshotFile.exists()) {\n+      LOG.error(\"The snapshot {} does not exist\", snapshot);\n+      throw new FileNotFoundException(\n+          String.format(\"The snapshot file %s does not exist\", snapshotFile.getPath()));\n+    }\n+    try {\n+      resetState();\n+      setLastAppliedTermIndex(snapshot.getTermIndex());\n+      install(snapshotFile);\n+    } catch (Exception e) {\n+      LOG.error(\"Failed to load snapshot {}\", snapshot, e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "96131f5114210d2a09e1d955f53ee3296b97fb98"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE2Mzk3Mg==", "bodyText": "Should we throw a new exception with the message like above? Also, do we need to log and throw an exception?", "url": "https://github.com/Alluxio/alluxio/pull/11940#discussion_r474163972", "createdAt": "2020-08-20T17:45:00Z", "author": {"login": "gpang"}, "path": "core/server/common/src/main/java/alluxio/master/journal/raft/JournalStateMachine.java", "diffHunk": "@@ -70,35 +88,164 @@\n   private volatile long mLastPrimaryStartSequenceNumber = 0;\n   private volatile long mNextSequenceNumberToRead = 0;\n   private volatile boolean mSnapshotting = false;\n+  private volatile boolean mIsLeader = false;\n+\n   // The start time of the most recent snapshot\n   private volatile long mLastSnapshotStartTime = 0;\n   /** Used to control applying to masters. */\n   private BufferedJournalApplier mJournalApplier;\n+  private final SimpleStateMachineStorage mStorage = new SimpleStateMachineStorage();\n+  private RaftGroupId mRaftGroupId;\n \n   /**\n-   * @param journals master journals; these journals are still owned by the caller, not by the\n-   *        journal state machine\n-   * @param journalSinks a supplier for journal sinks\n+   * @param journals     master journals; these journals are still owned by the caller, not by the\n+   *                     journal state machine\n+   * @param journalSystem the raft journal system\n    */\n-  public JournalStateMachine(Map<String, RaftJournal> journals,\n-      Supplier<Set<JournalSink>> journalSinks) {\n+  public JournalStateMachine(Map<String, RaftJournal> journals, RaftJournalSystem journalSystem) {\n     mJournals = journals;\n-    mJournalApplier = new BufferedJournalApplier(journals, journalSinks);\n+    mJournalApplier = new BufferedJournalApplier(journals,\n+        () -> journalSystem.getJournalSinks(null));\n     resetState();\n     LOG.info(\"Initialized new journal state machine\");\n+    mJournalSystem = journalSystem;\n+  }\n+\n+  private static <T> CompletableFuture<T> completeExceptionally(Exception e) {\n+    final CompletableFuture<T> future = new CompletableFuture<>();\n+    future.completeExceptionally(e);\n+    return future;\n+  }\n+\n+  @Override\n+  public void initialize(RaftServer server, RaftGroupId groupId,\n+      RaftStorage raftStorage) throws IOException {\n+    getLifeCycle().startAndTransition(() -> {\n+      super.initialize(server, groupId, raftStorage);\n+      mRaftGroupId = groupId;\n+      mStorage.init(raftStorage);\n+      loadSnapshot(mStorage.getLatestSnapshot());\n+    });\n+  }\n+\n+  @Override\n+  public void reinitialize() throws IOException {\n+    LOG.info(\"Reinitializing state machine.\");\n+    mStorage.loadLatestSnapshot();\n+    loadSnapshot(mStorage.getLatestSnapshot());\n+    unpause();\n+  }\n+\n+  private void loadSnapshot(SingleFileSnapshotInfo snapshot) throws IOException {\n+    if (snapshot == null) {\n+      LOG.info(\"No snapshot to load\");\n+      return;\n+    }\n+    LOG.info(\"Loading Snapshot {}\", snapshot);\n+    final File snapshotFile = snapshot.getFile().getPath().toFile();\n+    if (!snapshotFile.exists()) {\n+      LOG.error(\"The snapshot {} does not exist\", snapshot);\n+      throw new FileNotFoundException(\n+          String.format(\"The snapshot file %s does not exist\", snapshotFile.getPath()));\n+    }\n+    try {\n+      resetState();\n+      setLastAppliedTermIndex(snapshot.getTermIndex());\n+      install(snapshotFile);\n+    } catch (Exception e) {\n+      LOG.error(\"Failed to load snapshot {}\", snapshot, e);\n+      throw e;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "96131f5114210d2a09e1d955f53ee3296b97fb98"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE2NDg0Nw==", "bodyText": "Do we need to throw and log? Can we have this message include the message above?", "url": "https://github.com/Alluxio/alluxio/pull/11940#discussion_r474164847", "createdAt": "2020-08-20T17:46:39Z", "author": {"login": "gpang"}, "path": "core/server/common/src/main/java/alluxio/master/journal/raft/JournalStateMachine.java", "diffHunk": "@@ -70,35 +88,164 @@\n   private volatile long mLastPrimaryStartSequenceNumber = 0;\n   private volatile long mNextSequenceNumberToRead = 0;\n   private volatile boolean mSnapshotting = false;\n+  private volatile boolean mIsLeader = false;\n+\n   // The start time of the most recent snapshot\n   private volatile long mLastSnapshotStartTime = 0;\n   /** Used to control applying to masters. */\n   private BufferedJournalApplier mJournalApplier;\n+  private final SimpleStateMachineStorage mStorage = new SimpleStateMachineStorage();\n+  private RaftGroupId mRaftGroupId;\n \n   /**\n-   * @param journals master journals; these journals are still owned by the caller, not by the\n-   *        journal state machine\n-   * @param journalSinks a supplier for journal sinks\n+   * @param journals     master journals; these journals are still owned by the caller, not by the\n+   *                     journal state machine\n+   * @param journalSystem the raft journal system\n    */\n-  public JournalStateMachine(Map<String, RaftJournal> journals,\n-      Supplier<Set<JournalSink>> journalSinks) {\n+  public JournalStateMachine(Map<String, RaftJournal> journals, RaftJournalSystem journalSystem) {\n     mJournals = journals;\n-    mJournalApplier = new BufferedJournalApplier(journals, journalSinks);\n+    mJournalApplier = new BufferedJournalApplier(journals,\n+        () -> journalSystem.getJournalSinks(null));\n     resetState();\n     LOG.info(\"Initialized new journal state machine\");\n+    mJournalSystem = journalSystem;\n+  }\n+\n+  private static <T> CompletableFuture<T> completeExceptionally(Exception e) {\n+    final CompletableFuture<T> future = new CompletableFuture<>();\n+    future.completeExceptionally(e);\n+    return future;\n+  }\n+\n+  @Override\n+  public void initialize(RaftServer server, RaftGroupId groupId,\n+      RaftStorage raftStorage) throws IOException {\n+    getLifeCycle().startAndTransition(() -> {\n+      super.initialize(server, groupId, raftStorage);\n+      mRaftGroupId = groupId;\n+      mStorage.init(raftStorage);\n+      loadSnapshot(mStorage.getLatestSnapshot());\n+    });\n+  }\n+\n+  @Override\n+  public void reinitialize() throws IOException {\n+    LOG.info(\"Reinitializing state machine.\");\n+    mStorage.loadLatestSnapshot();\n+    loadSnapshot(mStorage.getLatestSnapshot());\n+    unpause();\n+  }\n+\n+  private void loadSnapshot(SingleFileSnapshotInfo snapshot) throws IOException {\n+    if (snapshot == null) {\n+      LOG.info(\"No snapshot to load\");\n+      return;\n+    }\n+    LOG.info(\"Loading Snapshot {}\", snapshot);\n+    final File snapshotFile = snapshot.getFile().getPath().toFile();\n+    if (!snapshotFile.exists()) {\n+      LOG.error(\"The snapshot {} does not exist\", snapshot);\n+      throw new FileNotFoundException(\n+          String.format(\"The snapshot file %s does not exist\", snapshotFile.getPath()));\n+    }\n+    try {\n+      resetState();\n+      setLastAppliedTermIndex(snapshot.getTermIndex());\n+      install(snapshotFile);\n+    } catch (Exception e) {\n+      LOG.error(\"Failed to load snapshot {}\", snapshot, e);\n+      throw e;\n+    }\n+  }\n+\n+  @Override\n+  public long takeSnapshot() {\n+    if (mIsLeader) {\n+      // TODO(feng): if secondary master has a more recent snapshot, install it\n+      return RaftLog.INVALID_LOG_INDEX;\n+    } else {\n+      return takeLocalSnapshot();\n+    }\n+  }\n+\n+  @Override\n+  public SnapshotInfo getLatestSnapshot() {\n+    return mStorage.getLatestSnapshot();\n+  }\n+\n+  @Override\n+  public StateMachineStorage getStateMachineStorage() {\n+    return mStorage;\n+  }\n+\n+  @Override\n+  public CompletableFuture<Message> query(Message request) {\n+    LOG.info(\"Received query: {}\", request);\n+    return super.query(request);\n+  }\n+\n+  @Override\n+  public void close() {\n+    mClosed = true;\n+  }\n+\n+  @Override\n+  public CompletableFuture<Message> applyTransaction(TransactionContext trx) {\n+    try {\n+      applyJournalEntryCommand(trx);\n+      return super.applyTransaction(trx);\n+    } catch (Exception e) {\n+      return completeExceptionally(e);\n+    }\n+  }\n+\n+  @Override\n+  public void notifyNotLeader(Collection<TransactionContext> pendingEntries) {\n+    mIsLeader = false;\n+    mJournalSystem.notifyLeadershipStateChanged(false);\n+  }\n+\n+  @Override\n+  public void pause() {\n+    getLifeCycle().transition(LifeCycle.State.PAUSING);\n+    try {\n+      if (!mJournalApplier.isSuspended()) {\n+        suspend();\n+      }\n+    } catch (IOException e) {\n+      LOG.error(\"State machine pause failed\", e);\n+      throw new IllegalStateException(e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "96131f5114210d2a09e1d955f53ee3296b97fb98"}, "originalPosition": 207}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE2NTcyMA==", "bodyText": "Can you include the file name?", "url": "https://github.com/Alluxio/alluxio/pull/11940#discussion_r474165720", "createdAt": "2020-08-20T17:48:13Z", "author": {"login": "gpang"}, "path": "core/server/common/src/main/java/alluxio/master/journal/raft/JournalStateMachine.java", "diffHunk": "@@ -171,31 +317,77 @@ private void applySingleEntry(JournalEntry entry) {\n     }\n   }\n \n-  @Override\n-  public void snapshot(SnapshotWriter writer) {\n+  private File createTempSnapshotFile() throws IOException {\n+    File tempDir = new File(mStorage.getSmDir().getParentFile(), \"tmp\");\n+    if (!tempDir.isDirectory() && !tempDir.mkdir()) {\n+      throw new IOException(\n+          \"Cannot create temporary snapshot directory at \" + tempDir.getAbsolutePath());\n+    }\n+    return File.createTempFile(\"raft_snapshot_\" + System.currentTimeMillis() + \"_\",\n+        \".dat\", tempDir);\n+  }\n+\n+  /**\n+   * Takes a snapshot of local state machine.\n+   * @return the index of last included entry, or {@link RaftLog#INVALID_LOG_INDEX} if it fails\n+   */\n+  public long takeLocalSnapshot() {\n     // Snapshot format is [snapshotId, name1, bytes1, name2, bytes2, ...].\n     if (mClosed) {\n-      return;\n+      return RaftLog.INVALID_LOG_INDEX;\n     }\n     LOG.debug(\"Calling snapshot\");\n     Preconditions.checkState(!mSnapshotting, \"Cannot call snapshot multiple times concurrently\");\n     mSnapshotting = true;\n     mLastSnapshotStartTime = System.currentTimeMillis();\n     long snapshotId = mNextSequenceNumberToRead - 1;\n-    try (SnapshotWriterStream sws = new SnapshotWriterStream(writer)) {\n-      writer.writeLong(snapshotId);\n-      JournalUtils.writeToCheckpoint(sws, getStateMachines());\n+    TermIndex last = getLastAppliedTermIndex();\n+    File tempFile;\n+    try {\n+      tempFile = createTempSnapshotFile();\n+    } catch (IOException e) {\n+      LogUtils.warnWithException(LOG, \"Failed to create temp snapshot file\", e);\n+      return RaftLog.INVALID_LOG_INDEX;\n+    }\n+    LOG.info(\"Taking a snapshot to file {}\", tempFile);\n+    final File snapshotFile = mStorage.getSnapshotFile(last.getTerm(), last.getIndex());\n+    try (DataOutputStream outputStream = new DataOutputStream(new FileOutputStream(tempFile))) {\n+      outputStream.writeLong(snapshotId);\n+      JournalUtils.writeToCheckpoint(outputStream, getStateMachines());\n+    } catch (Exception e) {\n+      tempFile.delete();\n+      LogUtils.warnWithException(LOG, \"Failed to take snapshot: {}\", snapshotId, e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "96131f5114210d2a09e1d955f53ee3296b97fb98"}, "originalPosition": 318}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE2NjQ5Mw==", "bodyText": "Include filename? Also, this message is identical to the previous section. Can we distinguish them?", "url": "https://github.com/Alluxio/alluxio/pull/11940#discussion_r474166493", "createdAt": "2020-08-20T17:49:39Z", "author": {"login": "gpang"}, "path": "core/server/common/src/main/java/alluxio/master/journal/raft/JournalStateMachine.java", "diffHunk": "@@ -171,31 +317,77 @@ private void applySingleEntry(JournalEntry entry) {\n     }\n   }\n \n-  @Override\n-  public void snapshot(SnapshotWriter writer) {\n+  private File createTempSnapshotFile() throws IOException {\n+    File tempDir = new File(mStorage.getSmDir().getParentFile(), \"tmp\");\n+    if (!tempDir.isDirectory() && !tempDir.mkdir()) {\n+      throw new IOException(\n+          \"Cannot create temporary snapshot directory at \" + tempDir.getAbsolutePath());\n+    }\n+    return File.createTempFile(\"raft_snapshot_\" + System.currentTimeMillis() + \"_\",\n+        \".dat\", tempDir);\n+  }\n+\n+  /**\n+   * Takes a snapshot of local state machine.\n+   * @return the index of last included entry, or {@link RaftLog#INVALID_LOG_INDEX} if it fails\n+   */\n+  public long takeLocalSnapshot() {\n     // Snapshot format is [snapshotId, name1, bytes1, name2, bytes2, ...].\n     if (mClosed) {\n-      return;\n+      return RaftLog.INVALID_LOG_INDEX;\n     }\n     LOG.debug(\"Calling snapshot\");\n     Preconditions.checkState(!mSnapshotting, \"Cannot call snapshot multiple times concurrently\");\n     mSnapshotting = true;\n     mLastSnapshotStartTime = System.currentTimeMillis();\n     long snapshotId = mNextSequenceNumberToRead - 1;\n-    try (SnapshotWriterStream sws = new SnapshotWriterStream(writer)) {\n-      writer.writeLong(snapshotId);\n-      JournalUtils.writeToCheckpoint(sws, getStateMachines());\n+    TermIndex last = getLastAppliedTermIndex();\n+    File tempFile;\n+    try {\n+      tempFile = createTempSnapshotFile();\n+    } catch (IOException e) {\n+      LogUtils.warnWithException(LOG, \"Failed to create temp snapshot file\", e);\n+      return RaftLog.INVALID_LOG_INDEX;\n+    }\n+    LOG.info(\"Taking a snapshot to file {}\", tempFile);\n+    final File snapshotFile = mStorage.getSnapshotFile(last.getTerm(), last.getIndex());\n+    try (DataOutputStream outputStream = new DataOutputStream(new FileOutputStream(tempFile))) {\n+      outputStream.writeLong(snapshotId);\n+      JournalUtils.writeToCheckpoint(outputStream, getStateMachines());\n+    } catch (Exception e) {\n+      tempFile.delete();\n+      LogUtils.warnWithException(LOG, \"Failed to take snapshot: {}\", snapshotId, e);\n+      return RaftLog.INVALID_LOG_INDEX;\n+    }\n+    try {\n+      final MD5Hash digest = MD5FileUtil.computeMd5ForFile(tempFile);\n+      LOG.info(\"Saving digest for snapshot file {}\", snapshotFile);\n+      MD5FileUtil.saveMD5File(snapshotFile, digest);\n+      LOG.info(\"Renaming a snapshot file {} to {}\", tempFile, snapshotFile);\n+      if (!tempFile.renameTo(snapshotFile)) {\n+        tempFile.delete();\n+        LOG.warn(\"Failed to rename snapshot from {} to {}\", tempFile, snapshotFile);\n+        return RaftLog.INVALID_LOG_INDEX;\n+      }\n+      LOG.info(\"Completed snapshot up to SN {} in {}ms\", snapshotId,\n+          System.currentTimeMillis() - mLastSnapshotStartTime);\n     } catch (Exception e) {\n-      ProcessUtils.fatalError(LOG, e, \"Failed to take snapshot: %s\", snapshotId);\n-      throw new RuntimeException(e);\n+      tempFile.delete();\n+      LogUtils.warnWithException(LOG, \"Failed to take snapshot: {}\", snapshotId, e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "96131f5114210d2a09e1d955f53ee3296b97fb98"}, "originalPosition": 337}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE2Njk3NA==", "bodyText": "What about if this is not true? What would that happen, and do we want to log some sort of warning when that happens?", "url": "https://github.com/Alluxio/alluxio/pull/11940#discussion_r474166974", "createdAt": "2020-08-20T17:50:31Z", "author": {"login": "gpang"}, "path": "core/server/common/src/main/java/alluxio/master/journal/raft/JournalStateMachine.java", "diffHunk": "@@ -314,10 +506,11 @@ public boolean isSnapshotting() {\n     return mSnapshotting;\n   }\n \n-  /**\n-   * Closes the journal state machine, causing all further modification requests to be ignored.\n-   */\n-  public void close() {\n-    mClosed = true;\n+  @Override\n+  public void notifyLeaderChanged(RaftGroupMemberId groupMemberId, RaftPeerId raftPeerId) {\n+    if (mRaftGroupId == groupMemberId.getGroupId()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "96131f5114210d2a09e1d955f53ee3296b97fb98"}, "originalPosition": 383}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE2ODQzOQ==", "bodyText": "Can you update some of the comments in this file that still say copycat?", "url": "https://github.com/Alluxio/alluxio/pull/11940#discussion_r474168439", "createdAt": "2020-08-20T17:53:08Z", "author": {"login": "gpang"}, "path": "core/server/common/src/main/java/alluxio/master/journal/raft/RaftPrimarySelector.java", "diffHunk": "@@ -29,33 +23,13 @@\n  */\n @ThreadSafe\n public class RaftPrimarySelector extends AbstractPrimarySelector {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "96131f5114210d2a09e1d955f53ee3296b97fb98"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE3MDI0MA==", "bodyText": "If you want to use the exception as the last argument, you will have to use String.format() to print parameters.", "url": "https://github.com/Alluxio/alluxio/pull/11940#discussion_r474170240", "createdAt": "2020-08-20T17:56:14Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/master/journal/tool/RaftJournalDumper.java", "diffHunk": "@@ -81,74 +75,69 @@ void dumpJournal() throws Throwable {\n    * way may be stale, but it can still be useful for debugging while the cluster is offline.\n    */\n   private void readFromDir() throws Throwable {\n-    Serializer serializer = RaftJournalSystem.createSerializer();\n-    serializer.resolve(new ClientRequestTypeResolver());\n-    serializer.resolve(new ClientResponseTypeResolver());\n-    serializer.resolve(new ProtocolSerialization());\n-    serializer.resolve(new ServerSerialization());\n-    serializer.resolve(new StorageSerialization());\n-\n-    SingleThreadContext context = new SingleThreadContext(\"readJournal\", serializer);\n-\n-    try {\n-      // Read through the whole journal content, starting from snapshot.\n-      context.execute(this::readCopycatSnapshotFromDir).get();\n-      context.execute(this::readCopycatLogFromDir).get();\n-    } catch (InterruptedException e) {\n-      Thread.currentThread().interrupt();\n-      throw e;\n-    } catch (ExecutionException e) {\n-      throw e.getCause();\n-    } finally {\n-      context.close();\n-    }\n+    // Read through the whole journal content, starting from snapshot.\n+    readRatisSnapshotFromDir();\n+    readRatisLogFromDir();\n   }\n \n-  private void readCopycatLogFromDir() {\n+  private void readRatisLogFromDir() {\n     try (\n         PrintStream out =\n             new PrintStream(new BufferedOutputStream(new FileOutputStream(mJournalEntryFile)));\n-        Log log = Storage.builder().withDirectory(mInputDir).build().openLog(\"copycat\")) {\n-      for (long i = log.firstIndex(); i < log.lastIndex(); i++) {\n-        io.atomix.copycat.server.storage.entry.Entry entry = log.get(i);\n-        if (entry instanceof CommandEntry) {\n-          Command command = ((CommandEntry) entry).getCommand();\n-          if (command instanceof JournalEntryCommand) {\n-            byte[] entryBytes = ((JournalEntryCommand) command).getSerializedJournalEntry();\n-            try {\n-              writeSelected(out, Journal.JournalEntry.parseFrom(entryBytes));\n-            } catch (Exception e) {\n-              throw new RuntimeException(e);\n-            }\n-          }\n-        }\n+        RaftStorage storage = new RaftStorage(getJournalDir(),\n+            RaftServerConstants.StartupOption.REGULAR)) {\n+      List<RaftStorageDirectory.LogPathAndIndex> paths =\n+          storage.getStorageDir().getLogSegmentFiles();\n+      for (RaftStorageDirectory.LogPathAndIndex path : paths) {\n+        final int entryCount = LogSegment.readSegmentFile(path.getPath().toFile(),\n+            path.getStartIndex(), path.getEndIndex(), path.isOpen(),\n+            RaftServerConfigKeys.Log.CorruptionPolicy.EXCEPTION, null, (proto) -> {\n+              if (proto.hasStateMachineLogEntry()) {\n+                try {\n+                  Journal.JournalEntry entry = Journal.JournalEntry.parseFrom(\n+                      proto.getStateMachineLogEntry().getLogData().asReadOnlyByteBuffer());\n+                  writeSelected(out, entry);\n+                } catch (Exception e) {\n+                  throw new RuntimeException(e);\n+                }\n+              }\n+            });\n+        LOG.info(\"Read {} entries from log {}.\", entryCount, path.getPath());\n       }\n     } catch (Exception e) {\n       LOG.error(\"Failed to read logs from journal.\", e);\n     }\n   }\n \n-  private void readCopycatSnapshotFromDir() {\n-    Storage journalStorage = Storage.builder().withDirectory(mInputDir).build();\n-    Snapshot currentSnapshot;\n-    try (final SnapshotStore copycat = journalStorage.openSnapshotStore(\"copycat\")) {\n-      if (copycat.snapshots().isEmpty()) {\n-        LOG.debug(\"No snapshot found.\");\n+  private File getJournalDir() {\n+    return new File(mInputDir, RaftJournalSystem.RAFT_GROUP_ID.toString());\n+  }\n+\n+  private void readRatisSnapshotFromDir() throws IOException {\n+    try (RaftStorage storage = new RaftStorage(getJournalDir(),\n+        RaftServerConstants.StartupOption.REGULAR)) {\n+      SimpleStateMachineStorage stateMachineStorage = new SimpleStateMachineStorage();\n+      stateMachineStorage.init(storage);\n+      SingleFileSnapshotInfo currentSnapshot = stateMachineStorage.getLatestSnapshot();\n+      if (currentSnapshot == null) {\n+        LOG.debug(\"No snapshot found\");\n         return;\n       }\n-      currentSnapshot = copycat.currentSnapshot();\n-    }\n-\n-    SnapshotReader snapshotReader = currentSnapshot.reader();\n-    String checkpointPath = String.format(\"%s-%s-%s\", mCheckpointsDir, currentSnapshot.index(),\n-        currentSnapshot.timestamp());\n-\n-    LOG.debug(\"Reading snapshot-Id: {}\", snapshotReader.readLong());\n-    try (CheckpointInputStream checkpointStream =\n-        new CheckpointInputStream(new SnapshotReaderStream(snapshotReader))) {\n-      readCheckpoint(checkpointStream, Paths.get(checkpointPath));\n-    } catch (Exception e) {\n-      LOG.error(\"Failed to read snapshot from journal.\", e);\n+      final File snapshotFile = currentSnapshot.getFile().getPath().toFile();\n+      String checkpointPath = String.format(\"%s-%s-%s\", mCheckpointsDir, currentSnapshot.getIndex(),\n+          snapshotFile.lastModified());\n+\n+      try (DataInputStream inputStream = new DataInputStream(new FileInputStream(snapshotFile))) {\n+        LOG.debug(\"Reading snapshot-Id: {}\", inputStream.readLong());\n+        try (CheckpointInputStream checkpointStream = new CheckpointInputStream(inputStream)) {\n+          readCheckpoint(checkpointStream, Paths.get(checkpointPath));\n+        } catch (Exception e) {\n+          LOG.error(\"Failed to read snapshot from journal.\", e);\n+        }\n+      } catch (Exception e) {\n+        LOG.error(\"Failed to load snapshot {}\", snapshotFile, e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "96131f5114210d2a09e1d955f53ee3296b97fb98"}, "originalPosition": 168}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a465214cd1df8477f60f84be4bf45caabe4571c5", "author": {"user": {"login": "bf8086", "name": null}}, "url": "https://github.com/Alluxio/alluxio/commit/a465214cd1df8477f60f84be4bf45caabe4571c5", "committedDate": "2020-08-20T22:32:11Z", "message": "Address comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "170c1eb177f2275b3273521408ba9cef33f75e2a", "author": {"user": {"login": "bf8086", "name": null}}, "url": "https://github.com/Alluxio/alluxio/commit/170c1eb177f2275b3273521408ba9cef33f75e2a", "committedDate": "2020-08-21T18:43:28Z", "message": "Improve snapshot error handling"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "597403e77e3b6c17806b32645079a5839a7147b2", "author": {"user": {"login": "bf8086", "name": null}}, "url": "https://github.com/Alluxio/alluxio/commit/597403e77e3b6c17806b32645079a5839a7147b2", "committedDate": "2020-08-22T05:42:44Z", "message": "improve leader election timing"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczNjU5MTE3", "url": "https://github.com/Alluxio/alluxio/pull/11940#pullrequestreview-473659117", "createdAt": "2020-08-24T16:24:28Z", "commit": {"oid": "597403e77e3b6c17806b32645079a5839a7147b2"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNjoyNDoyOFrOHFsrEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxNjozOToyOVrOHFtY8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTczNjg0OQ==", "bodyText": "Ok. Is there a local path where the files will be initialized?", "url": "https://github.com/Alluxio/alluxio/pull/11940#discussion_r475736849", "createdAt": "2020-08-24T16:24:28Z", "author": {"login": "gpang"}, "path": "core/server/common/src/main/java/alluxio/master/journal/raft/JournalStateMachine.java", "diffHunk": "@@ -70,35 +88,164 @@\n   private volatile long mLastPrimaryStartSequenceNumber = 0;\n   private volatile long mNextSequenceNumberToRead = 0;\n   private volatile boolean mSnapshotting = false;\n+  private volatile boolean mIsLeader = false;\n+\n   // The start time of the most recent snapshot\n   private volatile long mLastSnapshotStartTime = 0;\n   /** Used to control applying to masters. */\n   private BufferedJournalApplier mJournalApplier;\n+  private final SimpleStateMachineStorage mStorage = new SimpleStateMachineStorage();\n+  private RaftGroupId mRaftGroupId;\n \n   /**\n-   * @param journals master journals; these journals are still owned by the caller, not by the\n-   *        journal state machine\n-   * @param journalSinks a supplier for journal sinks\n+   * @param journals     master journals; these journals are still owned by the caller, not by the\n+   *                     journal state machine\n+   * @param journalSystem the raft journal system\n    */\n-  public JournalStateMachine(Map<String, RaftJournal> journals,\n-      Supplier<Set<JournalSink>> journalSinks) {\n+  public JournalStateMachine(Map<String, RaftJournal> journals, RaftJournalSystem journalSystem) {\n     mJournals = journals;\n-    mJournalApplier = new BufferedJournalApplier(journals, journalSinks);\n+    mJournalApplier = new BufferedJournalApplier(journals,\n+        () -> journalSystem.getJournalSinks(null));\n     resetState();\n     LOG.info(\"Initialized new journal state machine\");\n+    mJournalSystem = journalSystem;\n+  }\n+\n+  private static <T> CompletableFuture<T> completeExceptionally(Exception e) {\n+    final CompletableFuture<T> future = new CompletableFuture<>();\n+    future.completeExceptionally(e);\n+    return future;\n+  }\n+\n+  @Override\n+  public void initialize(RaftServer server, RaftGroupId groupId,\n+      RaftStorage raftStorage) throws IOException {\n+    getLifeCycle().startAndTransition(() -> {\n+      super.initialize(server, groupId, raftStorage);\n+      mRaftGroupId = groupId;\n+      mStorage.init(raftStorage);\n+      loadSnapshot(mStorage.getLatestSnapshot());\n+    });\n+  }\n+\n+  @Override\n+  public void reinitialize() throws IOException {\n+    LOG.info(\"Reinitializing state machine.\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE2MTczOA=="}, "originalCommit": {"oid": "96131f5114210d2a09e1d955f53ee3296b97fb98"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc0MjI3NQ==", "bodyText": "hrmmm, that is strange. I remember our logging messages would ignore the throwable, if we were using the string parameters...", "url": "https://github.com/Alluxio/alluxio/pull/11940#discussion_r475742275", "createdAt": "2020-08-24T16:33:15Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/master/journal/tool/RaftJournalDumper.java", "diffHunk": "@@ -81,74 +75,69 @@ void dumpJournal() throws Throwable {\n    * way may be stale, but it can still be useful for debugging while the cluster is offline.\n    */\n   private void readFromDir() throws Throwable {\n-    Serializer serializer = RaftJournalSystem.createSerializer();\n-    serializer.resolve(new ClientRequestTypeResolver());\n-    serializer.resolve(new ClientResponseTypeResolver());\n-    serializer.resolve(new ProtocolSerialization());\n-    serializer.resolve(new ServerSerialization());\n-    serializer.resolve(new StorageSerialization());\n-\n-    SingleThreadContext context = new SingleThreadContext(\"readJournal\", serializer);\n-\n-    try {\n-      // Read through the whole journal content, starting from snapshot.\n-      context.execute(this::readCopycatSnapshotFromDir).get();\n-      context.execute(this::readCopycatLogFromDir).get();\n-    } catch (InterruptedException e) {\n-      Thread.currentThread().interrupt();\n-      throw e;\n-    } catch (ExecutionException e) {\n-      throw e.getCause();\n-    } finally {\n-      context.close();\n-    }\n+    // Read through the whole journal content, starting from snapshot.\n+    readRatisSnapshotFromDir();\n+    readRatisLogFromDir();\n   }\n \n-  private void readCopycatLogFromDir() {\n+  private void readRatisLogFromDir() {\n     try (\n         PrintStream out =\n             new PrintStream(new BufferedOutputStream(new FileOutputStream(mJournalEntryFile)));\n-        Log log = Storage.builder().withDirectory(mInputDir).build().openLog(\"copycat\")) {\n-      for (long i = log.firstIndex(); i < log.lastIndex(); i++) {\n-        io.atomix.copycat.server.storage.entry.Entry entry = log.get(i);\n-        if (entry instanceof CommandEntry) {\n-          Command command = ((CommandEntry) entry).getCommand();\n-          if (command instanceof JournalEntryCommand) {\n-            byte[] entryBytes = ((JournalEntryCommand) command).getSerializedJournalEntry();\n-            try {\n-              writeSelected(out, Journal.JournalEntry.parseFrom(entryBytes));\n-            } catch (Exception e) {\n-              throw new RuntimeException(e);\n-            }\n-          }\n-        }\n+        RaftStorage storage = new RaftStorage(getJournalDir(),\n+            RaftServerConstants.StartupOption.REGULAR)) {\n+      List<RaftStorageDirectory.LogPathAndIndex> paths =\n+          storage.getStorageDir().getLogSegmentFiles();\n+      for (RaftStorageDirectory.LogPathAndIndex path : paths) {\n+        final int entryCount = LogSegment.readSegmentFile(path.getPath().toFile(),\n+            path.getStartIndex(), path.getEndIndex(), path.isOpen(),\n+            RaftServerConfigKeys.Log.CorruptionPolicy.EXCEPTION, null, (proto) -> {\n+              if (proto.hasStateMachineLogEntry()) {\n+                try {\n+                  Journal.JournalEntry entry = Journal.JournalEntry.parseFrom(\n+                      proto.getStateMachineLogEntry().getLogData().asReadOnlyByteBuffer());\n+                  writeSelected(out, entry);\n+                } catch (Exception e) {\n+                  throw new RuntimeException(e);\n+                }\n+              }\n+            });\n+        LOG.info(\"Read {} entries from log {}.\", entryCount, path.getPath());\n       }\n     } catch (Exception e) {\n       LOG.error(\"Failed to read logs from journal.\", e);\n     }\n   }\n \n-  private void readCopycatSnapshotFromDir() {\n-    Storage journalStorage = Storage.builder().withDirectory(mInputDir).build();\n-    Snapshot currentSnapshot;\n-    try (final SnapshotStore copycat = journalStorage.openSnapshotStore(\"copycat\")) {\n-      if (copycat.snapshots().isEmpty()) {\n-        LOG.debug(\"No snapshot found.\");\n+  private File getJournalDir() {\n+    return new File(mInputDir, RaftJournalSystem.RAFT_GROUP_ID.toString());\n+  }\n+\n+  private void readRatisSnapshotFromDir() throws IOException {\n+    try (RaftStorage storage = new RaftStorage(getJournalDir(),\n+        RaftServerConstants.StartupOption.REGULAR)) {\n+      SimpleStateMachineStorage stateMachineStorage = new SimpleStateMachineStorage();\n+      stateMachineStorage.init(storage);\n+      SingleFileSnapshotInfo currentSnapshot = stateMachineStorage.getLatestSnapshot();\n+      if (currentSnapshot == null) {\n+        LOG.debug(\"No snapshot found\");\n         return;\n       }\n-      currentSnapshot = copycat.currentSnapshot();\n-    }\n-\n-    SnapshotReader snapshotReader = currentSnapshot.reader();\n-    String checkpointPath = String.format(\"%s-%s-%s\", mCheckpointsDir, currentSnapshot.index(),\n-        currentSnapshot.timestamp());\n-\n-    LOG.debug(\"Reading snapshot-Id: {}\", snapshotReader.readLong());\n-    try (CheckpointInputStream checkpointStream =\n-        new CheckpointInputStream(new SnapshotReaderStream(snapshotReader))) {\n-      readCheckpoint(checkpointStream, Paths.get(checkpointPath));\n-    } catch (Exception e) {\n-      LOG.error(\"Failed to read snapshot from journal.\", e);\n+      final File snapshotFile = currentSnapshot.getFile().getPath().toFile();\n+      String checkpointPath = String.format(\"%s-%s-%s\", mCheckpointsDir, currentSnapshot.getIndex(),\n+          snapshotFile.lastModified());\n+\n+      try (DataInputStream inputStream = new DataInputStream(new FileInputStream(snapshotFile))) {\n+        LOG.debug(\"Reading snapshot-Id: {}\", inputStream.readLong());\n+        try (CheckpointInputStream checkpointStream = new CheckpointInputStream(inputStream)) {\n+          readCheckpoint(checkpointStream, Paths.get(checkpointPath));\n+        } catch (Exception e) {\n+          LOG.error(\"Failed to read snapshot from journal.\", e);\n+        }\n+      } catch (Exception e) {\n+        LOG.error(\"Failed to load snapshot {}\", snapshotFile, e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE3MDI0MA=="}, "originalCommit": {"oid": "96131f5114210d2a09e1d955f53ee3296b97fb98"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTc0ODU5NA==", "bodyText": "replace copycat in the comment", "url": "https://github.com/Alluxio/alluxio/pull/11940#discussion_r475748594", "createdAt": "2020-08-24T16:39:29Z", "author": {"login": "gpang"}, "path": "core/server/common/src/main/java/alluxio/master/journal/raft/RaftJournalSystem.java", "diffHunk": "@@ -333,7 +375,7 @@ public synchronized void gainPrimacy() {\n \n   @Override\n   public synchronized void losePrimacy() {\n-    if (!mServer.isRunning()) {\n+    if (mServer.getLifeCycleState() != LifeCycle.State.RUNNING) {\n       // Avoid duplicate shut down copycat server", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "597403e77e3b6c17806b32645079a5839a7147b2"}, "originalPosition": 384}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyOTU5OTIx", "url": "https://github.com/Alluxio/alluxio/pull/11940#pullrequestreview-472959921", "createdAt": "2020-08-22T20:18:51Z", "commit": {"oid": "597403e77e3b6c17806b32645079a5839a7147b2"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMDoxODo1MVrOHFH67Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQyMDoxOTozMlrOHFH7Kw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEzNDcwMQ==", "bodyText": "Why using a fixed group id?", "url": "https://github.com/Alluxio/alluxio/pull/11940#discussion_r475134701", "createdAt": "2020-08-22T20:18:51Z", "author": {"login": "LuQQiu"}, "path": "core/server/common/src/main/java/alluxio/master/journal/raft/RaftJournalSystem.java", "diffHunk": "@@ -124,19 +139,18 @@\n  */\n @ThreadSafe\n public final class RaftJournalSystem extends AbstractJournalSystem {\n+  public static final UUID RAFT_GROUP_ID = UUID.fromString(\"02511d47-d67c-49a3-9011-abb3109a44c1\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "597403e77e3b6c17806b32645079a5839a7147b2"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTEzNDc2Mw==", "bodyText": "Change the comment as well?", "url": "https://github.com/Alluxio/alluxio/pull/11940#discussion_r475134763", "createdAt": "2020-08-22T20:19:32Z", "author": {"login": "LuQQiu"}, "path": "core/server/common/src/main/java/alluxio/master/journal/raft/RaftJournalSystem.java", "diffHunk": "@@ -159,7 +173,7 @@\n   /**\n    * Copycat server.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "597403e77e3b6c17806b32645079a5839a7147b2"}, "originalPosition": 145}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e4edb2773978627aaea14f54d22d47395e534aba", "author": {"user": {"login": "bf8086", "name": null}}, "url": "https://github.com/Alluxio/alluxio/commit/e4edb2773978627aaea14f54d22d47395e534aba", "committedDate": "2020-08-24T18:06:33Z", "message": "Update comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczNzY1OTA4", "url": "https://github.com/Alluxio/alluxio/pull/11940#pullrequestreview-473765908", "createdAt": "2020-08-24T18:45:38Z", "commit": {"oid": "e4edb2773978627aaea14f54d22d47395e534aba"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxODo0NTozOFrOHFx31g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNFQxODo0NTozOFrOHFx31g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTgyMjAzOA==", "bodyText": "I saw the examples of loading snapshots in initialize and reinitialize, but not sure why.\nAre there guaranteed that all journal entries are included in the latest snapshot? will some journal entries after latest snapshot lost?", "url": "https://github.com/Alluxio/alluxio/pull/11940#discussion_r475822038", "createdAt": "2020-08-24T18:45:38Z", "author": {"login": "LuQQiu"}, "path": "core/server/common/src/main/java/alluxio/master/journal/raft/JournalStateMachine.java", "diffHunk": "@@ -70,35 +88,158 @@\n   private volatile long mLastPrimaryStartSequenceNumber = 0;\n   private volatile long mNextSequenceNumberToRead = 0;\n   private volatile boolean mSnapshotting = false;\n+  private volatile boolean mIsLeader = false;\n+\n   // The start time of the most recent snapshot\n   private volatile long mLastSnapshotStartTime = 0;\n   /** Used to control applying to masters. */\n   private BufferedJournalApplier mJournalApplier;\n+  private final SimpleStateMachineStorage mStorage = new SimpleStateMachineStorage();\n+  private RaftGroupId mRaftGroupId;\n \n   /**\n-   * @param journals master journals; these journals are still owned by the caller, not by the\n-   *        journal state machine\n-   * @param journalSinks a supplier for journal sinks\n+   * @param journals     master journals; these journals are still owned by the caller, not by the\n+   *                     journal state machine\n+   * @param journalSystem the raft journal system\n    */\n-  public JournalStateMachine(Map<String, RaftJournal> journals,\n-      Supplier<Set<JournalSink>> journalSinks) {\n+  public JournalStateMachine(Map<String, RaftJournal> journals, RaftJournalSystem journalSystem) {\n     mJournals = journals;\n-    mJournalApplier = new BufferedJournalApplier(journals, journalSinks);\n+    mJournalApplier = new BufferedJournalApplier(journals,\n+        () -> journalSystem.getJournalSinks(null));\n     resetState();\n     LOG.info(\"Initialized new journal state machine\");\n+    mJournalSystem = journalSystem;\n+  }\n+\n+  private static <T> CompletableFuture<T> completeExceptionally(Exception e) {\n+    final CompletableFuture<T> future = new CompletableFuture<>();\n+    future.completeExceptionally(e);\n+    return future;\n+  }\n+\n+  @Override\n+  public void initialize(RaftServer server, RaftGroupId groupId,\n+      RaftStorage raftStorage) throws IOException {\n+    getLifeCycle().startAndTransition(() -> {\n+      super.initialize(server, groupId, raftStorage);\n+      mRaftGroupId = groupId;\n+      mStorage.init(raftStorage);\n+      loadSnapshot(mStorage.getLatestSnapshot());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4edb2773978627aaea14f54d22d47395e534aba"}, "originalPosition": 128}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczOTcyNjgw", "url": "https://github.com/Alluxio/alluxio/pull/11940#pullrequestreview-473972680", "createdAt": "2020-08-24T22:57:55Z", "commit": {"oid": "e4edb2773978627aaea14f54d22d47395e534aba"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc0NTg2Mjkw", "url": "https://github.com/Alluxio/alluxio/pull/11940#pullrequestreview-474586290", "createdAt": "2020-08-25T15:16:24Z", "commit": {"oid": "e4edb2773978627aaea14f54d22d47395e534aba"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4088, "cost": 1, "resetAt": "2021-10-29T17:30:11Z"}}}