{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE2ODM0ODAw", "number": 11422, "reviewThreads": {"totalCount": 31, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QwMTowOTo1NFrOD_GZZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNjoxNjowM1rOECoqVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NDkxNjg0OnYy", "diffSide": "RIGHT", "path": "core/common/src/main/java/alluxio/util/CommonUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QwMTowOTo1NFrOGZmocA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QwMTowOTo1NFrOGZmocA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUwMDUyOA==", "bodyText": "never used?", "url": "https://github.com/Alluxio/alluxio/pull/11422#discussion_r429500528", "createdAt": "2020-05-23T01:09:54Z", "author": {"login": "madanadit"}, "path": "core/common/src/main/java/alluxio/util/CommonUtils.java", "diffHunk": "@@ -191,6 +191,16 @@ public static String getWorkerDataDirectory(String storageDir, AlluxioConfigurat\n     return src.toArray(ret);\n   }\n \n+  /**\n+   * Generates a random integer with the given bound.\n+   *\n+   * @param bound the upper bound\n+   * @return a random int\n+   */\n+  public static int randomInt(int bound) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ded15217e52f154ab8d35409041773d361beda73"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NDkxOTcxOnYy", "diffSide": "RIGHT", "path": "job/server/src/main/java/alluxio/job/plan/io/IODefinition.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QwMToxNDozN1rOGZmp8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QwMToxNDozN1rOGZmp8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUwMDkxNQ==", "bodyText": "why is this in a separate line and what is the value?", "url": "https://github.com/Alluxio/alluxio/pull/11422#discussion_r429500915", "createdAt": "2020-05-23T01:14:37Z", "author": {"login": "madanadit"}, "path": "job/server/src/main/java/alluxio/job/plan/io/IODefinition.java", "diffHunk": "@@ -0,0 +1,123 @@\n+package alluxio.job.plan.io;\n+\n+import alluxio.collections.Pair;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.job.RunTaskContext;\n+import alluxio.job.SelectExecutorsContext;\n+import alluxio.job.plan.PlanDefinition;\n+import alluxio.stress.BaseParameters;\n+import alluxio.stress.JsonSerializable;\n+import alluxio.stress.job.IOConfig;\n+import alluxio.stress.worker.IOTaskResult;\n+import alluxio.util.ShellUtils;\n+import alluxio.wire.WorkerInfo;\n+import com.google.common.collect.Sets;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The definition for the UFS I/O throughput job, which generates concurrent streams to the UFS.\n+ *\n+ * {@link IOConfig} is the configuration class, each task takes a List<String> as a list of\n+ * command-line arguments to the benchmark command, and each task returns the string output.\n+ * The output will be serialized and deserialized using JSON, collected and merged.\n+ */\n+public class IODefinition implements PlanDefinition<IOConfig, ArrayList<String>, String> {\n+  private static final Logger LOG = LoggerFactory.getLogger(IODefinition.class);\n+\n+  @Override\n+  public Class<IOConfig> getJobConfigClass() {\n+    return IOConfig.class;\n+  }\n+\n+  @Override\n+  public String join(IOConfig config, Map<WorkerInfo, String> taskResults) throws Exception {\n+    if (taskResults.isEmpty()) {\n+      throw new IOException(\"No results from any workers.\");\n+    }\n+    LOG.info(\"join()\");\n+    for(Map.Entry<WorkerInfo, String> entry : taskResults.entrySet()) {\n+      LOG.info(\"worker={}\", entry.getKey());\n+      LOG.info(\"{}\", entry.getValue());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ded15217e52f154ab8d35409041773d361beda73"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NDkyMjI1OnYy", "diffSide": "RIGHT", "path": "job/server/src/main/java/alluxio/job/plan/io/IODefinition.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QwMToxODozM1rOGZmrOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QwMToxODozM1rOGZmrOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUwMTI0Mw==", "bodyText": "this seems to be almost the same as StressBenchDefinition, can we remove the redundancy?", "url": "https://github.com/Alluxio/alluxio/pull/11422#discussion_r429501243", "createdAt": "2020-05-23T01:18:33Z", "author": {"login": "madanadit"}, "path": "job/server/src/main/java/alluxio/job/plan/io/IODefinition.java", "diffHunk": "@@ -0,0 +1,123 @@\n+package alluxio.job.plan.io;\n+\n+import alluxio.collections.Pair;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.job.RunTaskContext;\n+import alluxio.job.SelectExecutorsContext;\n+import alluxio.job.plan.PlanDefinition;\n+import alluxio.stress.BaseParameters;\n+import alluxio.stress.JsonSerializable;\n+import alluxio.stress.job.IOConfig;\n+import alluxio.stress.worker.IOTaskResult;\n+import alluxio.util.ShellUtils;\n+import alluxio.wire.WorkerInfo;\n+import com.google.common.collect.Sets;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The definition for the UFS I/O throughput job, which generates concurrent streams to the UFS.\n+ *\n+ * {@link IOConfig} is the configuration class, each task takes a List<String> as a list of\n+ * command-line arguments to the benchmark command, and each task returns the string output.\n+ * The output will be serialized and deserialized using JSON, collected and merged.\n+ */\n+public class IODefinition implements PlanDefinition<IOConfig, ArrayList<String>, String> {\n+  private static final Logger LOG = LoggerFactory.getLogger(IODefinition.class);\n+\n+  @Override\n+  public Class<IOConfig> getJobConfigClass() {\n+    return IOConfig.class;\n+  }\n+\n+  @Override\n+  public String join(IOConfig config, Map<WorkerInfo, String> taskResults) throws Exception {\n+    if (taskResults.isEmpty()) {\n+      throw new IOException(\"No results from any workers.\");\n+    }\n+    LOG.info(\"join()\");\n+    for(Map.Entry<WorkerInfo, String> entry : taskResults.entrySet()) {\n+      LOG.info(\"worker={}\", entry.getKey());\n+      LOG.info(\"{}\", entry.getValue());\n+    }\n+\n+    AtomicReference<IOException> error = new AtomicReference<>(null);\n+    List<IOTaskResult> results = taskResults.entrySet().stream().map(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ded15217e52f154ab8d35409041773d361beda73"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NDkyMzMxOnYy", "diffSide": "RIGHT", "path": "job/server/src/main/java/alluxio/job/plan/io/IODefinition.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QwMToyMDozMVrOGZmr4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QwMToyMDozMVrOGZmr4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUwMTQxMQ==", "bodyText": "nit: combine in the if above as if (cnt-- <= 0)", "url": "https://github.com/Alluxio/alluxio/pull/11422#discussion_r429501411", "createdAt": "2020-05-23T01:20:31Z", "author": {"login": "madanadit"}, "path": "job/server/src/main/java/alluxio/job/plan/io/IODefinition.java", "diffHunk": "@@ -0,0 +1,123 @@\n+package alluxio.job.plan.io;\n+\n+import alluxio.collections.Pair;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.job.RunTaskContext;\n+import alluxio.job.SelectExecutorsContext;\n+import alluxio.job.plan.PlanDefinition;\n+import alluxio.stress.BaseParameters;\n+import alluxio.stress.JsonSerializable;\n+import alluxio.stress.job.IOConfig;\n+import alluxio.stress.worker.IOTaskResult;\n+import alluxio.util.ShellUtils;\n+import alluxio.wire.WorkerInfo;\n+import com.google.common.collect.Sets;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The definition for the UFS I/O throughput job, which generates concurrent streams to the UFS.\n+ *\n+ * {@link IOConfig} is the configuration class, each task takes a List<String> as a list of\n+ * command-line arguments to the benchmark command, and each task returns the string output.\n+ * The output will be serialized and deserialized using JSON, collected and merged.\n+ */\n+public class IODefinition implements PlanDefinition<IOConfig, ArrayList<String>, String> {\n+  private static final Logger LOG = LoggerFactory.getLogger(IODefinition.class);\n+\n+  @Override\n+  public Class<IOConfig> getJobConfigClass() {\n+    return IOConfig.class;\n+  }\n+\n+  @Override\n+  public String join(IOConfig config, Map<WorkerInfo, String> taskResults) throws Exception {\n+    if (taskResults.isEmpty()) {\n+      throw new IOException(\"No results from any workers.\");\n+    }\n+    LOG.info(\"join()\");\n+    for(Map.Entry<WorkerInfo, String> entry : taskResults.entrySet()) {\n+      LOG.info(\"worker={}\", entry.getKey());\n+      LOG.info(\"{}\", entry.getValue());\n+    }\n+\n+    AtomicReference<IOException> error = new AtomicReference<>(null);\n+    List<IOTaskResult> results = taskResults.entrySet().stream().map(\n+            entry -> {\n+              try {\n+                return JsonSerializable.fromJson(entry.getValue().trim(), new IOTaskResult[0]);\n+              } catch (IOException | ClassNotFoundException e) {\n+                error.set(new IOException(String\n+                        .format(\"Failed to parse task output from %s into result class\",\n+                                entry.getKey().getAddress().getHost()), e));\n+              }\n+              return null;\n+            }).collect(Collectors.toList());\n+\n+    if (error.get() != null) {\n+      throw error.get();\n+    }\n+\n+    return results.get(0).aggregator().aggregate(results).toJson();\n+  }\n+\n+  @Override\n+  public Set<Pair<WorkerInfo, ArrayList<String>>> selectExecutors(\n+          IOConfig config, List<WorkerInfo> jobWorkerInfoList,\n+          SelectExecutorsContext selectExecutorsContext) throws Exception {\n+    Set<Pair<WorkerInfo, ArrayList<String>>> result = Sets.newHashSet();\n+\n+    // Randomly select N workers\n+    Collections.shuffle(jobWorkerInfoList);\n+    int cnt = config.getWorkerNum();\n+    for (WorkerInfo worker : jobWorkerInfoList) {\n+      if (cnt <= 0) {\n+        break;\n+      }\n+      ArrayList<String> args = new ArrayList<>(2);\n+      // Add the worker hostname + worker id as the unique task id for each distributed task.\n+      // The worker id is used since there may be multiple workers on a single host.\n+      args.add(BaseParameters.ID_FLAG);\n+      args.add(worker.getAddress().getHost() + \"-\" + worker.getId());\n+      result.add(new Pair<>(worker, args));\n+      cnt--;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ded15217e52f154ab8d35409041773d361beda73"}, "originalPosition": 94}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NDkyMzg2OnYy", "diffSide": "RIGHT", "path": "job/server/src/main/java/alluxio/job/plan/io/IODefinition.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QwMToyMToyMlrOGZmsLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QwMToyMToyMlrOGZmsLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUwMTQ4Nw==", "bodyText": "this is redundant again, a utility function?", "url": "https://github.com/Alluxio/alluxio/pull/11422#discussion_r429501487", "createdAt": "2020-05-23T01:21:22Z", "author": {"login": "madanadit"}, "path": "job/server/src/main/java/alluxio/job/plan/io/IODefinition.java", "diffHunk": "@@ -0,0 +1,123 @@\n+package alluxio.job.plan.io;\n+\n+import alluxio.collections.Pair;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.job.RunTaskContext;\n+import alluxio.job.SelectExecutorsContext;\n+import alluxio.job.plan.PlanDefinition;\n+import alluxio.stress.BaseParameters;\n+import alluxio.stress.JsonSerializable;\n+import alluxio.stress.job.IOConfig;\n+import alluxio.stress.worker.IOTaskResult;\n+import alluxio.util.ShellUtils;\n+import alluxio.wire.WorkerInfo;\n+import com.google.common.collect.Sets;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The definition for the UFS I/O throughput job, which generates concurrent streams to the UFS.\n+ *\n+ * {@link IOConfig} is the configuration class, each task takes a List<String> as a list of\n+ * command-line arguments to the benchmark command, and each task returns the string output.\n+ * The output will be serialized and deserialized using JSON, collected and merged.\n+ */\n+public class IODefinition implements PlanDefinition<IOConfig, ArrayList<String>, String> {\n+  private static final Logger LOG = LoggerFactory.getLogger(IODefinition.class);\n+\n+  @Override\n+  public Class<IOConfig> getJobConfigClass() {\n+    return IOConfig.class;\n+  }\n+\n+  @Override\n+  public String join(IOConfig config, Map<WorkerInfo, String> taskResults) throws Exception {\n+    if (taskResults.isEmpty()) {\n+      throw new IOException(\"No results from any workers.\");\n+    }\n+    LOG.info(\"join()\");\n+    for(Map.Entry<WorkerInfo, String> entry : taskResults.entrySet()) {\n+      LOG.info(\"worker={}\", entry.getKey());\n+      LOG.info(\"{}\", entry.getValue());\n+    }\n+\n+    AtomicReference<IOException> error = new AtomicReference<>(null);\n+    List<IOTaskResult> results = taskResults.entrySet().stream().map(\n+            entry -> {\n+              try {\n+                return JsonSerializable.fromJson(entry.getValue().trim(), new IOTaskResult[0]);\n+              } catch (IOException | ClassNotFoundException e) {\n+                error.set(new IOException(String\n+                        .format(\"Failed to parse task output from %s into result class\",\n+                                entry.getKey().getAddress().getHost()), e));\n+              }\n+              return null;\n+            }).collect(Collectors.toList());\n+\n+    if (error.get() != null) {\n+      throw error.get();\n+    }\n+\n+    return results.get(0).aggregator().aggregate(results).toJson();\n+  }\n+\n+  @Override\n+  public Set<Pair<WorkerInfo, ArrayList<String>>> selectExecutors(\n+          IOConfig config, List<WorkerInfo> jobWorkerInfoList,\n+          SelectExecutorsContext selectExecutorsContext) throws Exception {\n+    Set<Pair<WorkerInfo, ArrayList<String>>> result = Sets.newHashSet();\n+\n+    // Randomly select N workers\n+    Collections.shuffle(jobWorkerInfoList);\n+    int cnt = config.getWorkerNum();\n+    for (WorkerInfo worker : jobWorkerInfoList) {\n+      if (cnt <= 0) {\n+        break;\n+      }\n+      ArrayList<String> args = new ArrayList<>(2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ded15217e52f154ab8d35409041773d361beda73"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NDkyNDQxOnYy", "diffSide": "RIGHT", "path": "job/server/src/main/java/alluxio/job/plan/io/IODefinition.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QwMToyMjoxNlrOGZmshA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwODo0ODo1MVrOGcUOnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUwMTU3Mg==", "bodyText": "same redundancy here", "url": "https://github.com/Alluxio/alluxio/pull/11422#discussion_r429501572", "createdAt": "2020-05-23T01:22:16Z", "author": {"login": "madanadit"}, "path": "job/server/src/main/java/alluxio/job/plan/io/IODefinition.java", "diffHunk": "@@ -0,0 +1,123 @@\n+package alluxio.job.plan.io;\n+\n+import alluxio.collections.Pair;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.job.RunTaskContext;\n+import alluxio.job.SelectExecutorsContext;\n+import alluxio.job.plan.PlanDefinition;\n+import alluxio.stress.BaseParameters;\n+import alluxio.stress.JsonSerializable;\n+import alluxio.stress.job.IOConfig;\n+import alluxio.stress.worker.IOTaskResult;\n+import alluxio.util.ShellUtils;\n+import alluxio.wire.WorkerInfo;\n+import com.google.common.collect.Sets;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The definition for the UFS I/O throughput job, which generates concurrent streams to the UFS.\n+ *\n+ * {@link IOConfig} is the configuration class, each task takes a List<String> as a list of\n+ * command-line arguments to the benchmark command, and each task returns the string output.\n+ * The output will be serialized and deserialized using JSON, collected and merged.\n+ */\n+public class IODefinition implements PlanDefinition<IOConfig, ArrayList<String>, String> {\n+  private static final Logger LOG = LoggerFactory.getLogger(IODefinition.class);\n+\n+  @Override\n+  public Class<IOConfig> getJobConfigClass() {\n+    return IOConfig.class;\n+  }\n+\n+  @Override\n+  public String join(IOConfig config, Map<WorkerInfo, String> taskResults) throws Exception {\n+    if (taskResults.isEmpty()) {\n+      throw new IOException(\"No results from any workers.\");\n+    }\n+    LOG.info(\"join()\");\n+    for(Map.Entry<WorkerInfo, String> entry : taskResults.entrySet()) {\n+      LOG.info(\"worker={}\", entry.getKey());\n+      LOG.info(\"{}\", entry.getValue());\n+    }\n+\n+    AtomicReference<IOException> error = new AtomicReference<>(null);\n+    List<IOTaskResult> results = taskResults.entrySet().stream().map(\n+            entry -> {\n+              try {\n+                return JsonSerializable.fromJson(entry.getValue().trim(), new IOTaskResult[0]);\n+              } catch (IOException | ClassNotFoundException e) {\n+                error.set(new IOException(String\n+                        .format(\"Failed to parse task output from %s into result class\",\n+                                entry.getKey().getAddress().getHost()), e));\n+              }\n+              return null;\n+            }).collect(Collectors.toList());\n+\n+    if (error.get() != null) {\n+      throw error.get();\n+    }\n+\n+    return results.get(0).aggregator().aggregate(results).toJson();\n+  }\n+\n+  @Override\n+  public Set<Pair<WorkerInfo, ArrayList<String>>> selectExecutors(\n+          IOConfig config, List<WorkerInfo> jobWorkerInfoList,\n+          SelectExecutorsContext selectExecutorsContext) throws Exception {\n+    Set<Pair<WorkerInfo, ArrayList<String>>> result = Sets.newHashSet();\n+\n+    // Randomly select N workers\n+    Collections.shuffle(jobWorkerInfoList);\n+    int cnt = config.getWorkerNum();\n+    for (WorkerInfo worker : jobWorkerInfoList) {\n+      if (cnt <= 0) {\n+        break;\n+      }\n+      ArrayList<String> args = new ArrayList<>(2);\n+      // Add the worker hostname + worker id as the unique task id for each distributed task.\n+      // The worker id is used since there may be multiple workers on a single host.\n+      args.add(BaseParameters.ID_FLAG);\n+      args.add(worker.getAddress().getHost() + \"-\" + worker.getId());\n+      result.add(new Pair<>(worker, args));\n+      cnt--;\n+    }\n+    return result;\n+  }\n+\n+  @Override\n+  public String runTask(IOConfig config, ArrayList<String> args, RunTaskContext runTaskContext)\n+          throws Exception {\n+    LOG.info(\"args={}\", args);\n+\n+    List<String> command = new ArrayList<>(3 + config.getArgs().size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ded15217e52f154ab8d35409041773d361beda73"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM0NDczNQ==", "bodyText": "Updated this part to use the new runUfsIOTest class. Now it's different from IODefinition. (They do share a few lines but it's too specific to be a util method)", "url": "https://github.com/Alluxio/alluxio/pull/11422#discussion_r432344735", "createdAt": "2020-05-29T08:48:51Z", "author": {"login": "jiacheliu3"}, "path": "job/server/src/main/java/alluxio/job/plan/io/IODefinition.java", "diffHunk": "@@ -0,0 +1,123 @@\n+package alluxio.job.plan.io;\n+\n+import alluxio.collections.Pair;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.job.RunTaskContext;\n+import alluxio.job.SelectExecutorsContext;\n+import alluxio.job.plan.PlanDefinition;\n+import alluxio.stress.BaseParameters;\n+import alluxio.stress.JsonSerializable;\n+import alluxio.stress.job.IOConfig;\n+import alluxio.stress.worker.IOTaskResult;\n+import alluxio.util.ShellUtils;\n+import alluxio.wire.WorkerInfo;\n+import com.google.common.collect.Sets;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The definition for the UFS I/O throughput job, which generates concurrent streams to the UFS.\n+ *\n+ * {@link IOConfig} is the configuration class, each task takes a List<String> as a list of\n+ * command-line arguments to the benchmark command, and each task returns the string output.\n+ * The output will be serialized and deserialized using JSON, collected and merged.\n+ */\n+public class IODefinition implements PlanDefinition<IOConfig, ArrayList<String>, String> {\n+  private static final Logger LOG = LoggerFactory.getLogger(IODefinition.class);\n+\n+  @Override\n+  public Class<IOConfig> getJobConfigClass() {\n+    return IOConfig.class;\n+  }\n+\n+  @Override\n+  public String join(IOConfig config, Map<WorkerInfo, String> taskResults) throws Exception {\n+    if (taskResults.isEmpty()) {\n+      throw new IOException(\"No results from any workers.\");\n+    }\n+    LOG.info(\"join()\");\n+    for(Map.Entry<WorkerInfo, String> entry : taskResults.entrySet()) {\n+      LOG.info(\"worker={}\", entry.getKey());\n+      LOG.info(\"{}\", entry.getValue());\n+    }\n+\n+    AtomicReference<IOException> error = new AtomicReference<>(null);\n+    List<IOTaskResult> results = taskResults.entrySet().stream().map(\n+            entry -> {\n+              try {\n+                return JsonSerializable.fromJson(entry.getValue().trim(), new IOTaskResult[0]);\n+              } catch (IOException | ClassNotFoundException e) {\n+                error.set(new IOException(String\n+                        .format(\"Failed to parse task output from %s into result class\",\n+                                entry.getKey().getAddress().getHost()), e));\n+              }\n+              return null;\n+            }).collect(Collectors.toList());\n+\n+    if (error.get() != null) {\n+      throw error.get();\n+    }\n+\n+    return results.get(0).aggregator().aggregate(results).toJson();\n+  }\n+\n+  @Override\n+  public Set<Pair<WorkerInfo, ArrayList<String>>> selectExecutors(\n+          IOConfig config, List<WorkerInfo> jobWorkerInfoList,\n+          SelectExecutorsContext selectExecutorsContext) throws Exception {\n+    Set<Pair<WorkerInfo, ArrayList<String>>> result = Sets.newHashSet();\n+\n+    // Randomly select N workers\n+    Collections.shuffle(jobWorkerInfoList);\n+    int cnt = config.getWorkerNum();\n+    for (WorkerInfo worker : jobWorkerInfoList) {\n+      if (cnt <= 0) {\n+        break;\n+      }\n+      ArrayList<String> args = new ArrayList<>(2);\n+      // Add the worker hostname + worker id as the unique task id for each distributed task.\n+      // The worker id is used since there may be multiple workers on a single host.\n+      args.add(BaseParameters.ID_FLAG);\n+      args.add(worker.getAddress().getHost() + \"-\" + worker.getId());\n+      result.add(new Pair<>(worker, args));\n+      cnt--;\n+    }\n+    return result;\n+  }\n+\n+  @Override\n+  public String runTask(IOConfig config, ArrayList<String> args, RunTaskContext runTaskContext)\n+          throws Exception {\n+    LOG.info(\"args={}\", args);\n+\n+    List<String> command = new ArrayList<>(3 + config.getArgs().size());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUwMTU3Mg=="}, "originalCommit": {"oid": "ded15217e52f154ab8d35409041773d361beda73"}, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NDkyNTA4OnYy", "diffSide": "RIGHT", "path": "job/server/src/main/java/alluxio/job/plan/io/IODefinition.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QwMToyMzoxM1rOGZms0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwODo0NjozOFrOGcUKGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUwMTY0OQ==", "bodyText": "can we have a wrapper called alluxio runUfsIOTests over runClass+report?", "url": "https://github.com/Alluxio/alluxio/pull/11422#discussion_r429501649", "createdAt": "2020-05-23T01:23:13Z", "author": {"login": "madanadit"}, "path": "job/server/src/main/java/alluxio/job/plan/io/IODefinition.java", "diffHunk": "@@ -0,0 +1,123 @@\n+package alluxio.job.plan.io;\n+\n+import alluxio.collections.Pair;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.job.RunTaskContext;\n+import alluxio.job.SelectExecutorsContext;\n+import alluxio.job.plan.PlanDefinition;\n+import alluxio.stress.BaseParameters;\n+import alluxio.stress.JsonSerializable;\n+import alluxio.stress.job.IOConfig;\n+import alluxio.stress.worker.IOTaskResult;\n+import alluxio.util.ShellUtils;\n+import alluxio.wire.WorkerInfo;\n+import com.google.common.collect.Sets;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The definition for the UFS I/O throughput job, which generates concurrent streams to the UFS.\n+ *\n+ * {@link IOConfig} is the configuration class, each task takes a List<String> as a list of\n+ * command-line arguments to the benchmark command, and each task returns the string output.\n+ * The output will be serialized and deserialized using JSON, collected and merged.\n+ */\n+public class IODefinition implements PlanDefinition<IOConfig, ArrayList<String>, String> {\n+  private static final Logger LOG = LoggerFactory.getLogger(IODefinition.class);\n+\n+  @Override\n+  public Class<IOConfig> getJobConfigClass() {\n+    return IOConfig.class;\n+  }\n+\n+  @Override\n+  public String join(IOConfig config, Map<WorkerInfo, String> taskResults) throws Exception {\n+    if (taskResults.isEmpty()) {\n+      throw new IOException(\"No results from any workers.\");\n+    }\n+    LOG.info(\"join()\");\n+    for(Map.Entry<WorkerInfo, String> entry : taskResults.entrySet()) {\n+      LOG.info(\"worker={}\", entry.getKey());\n+      LOG.info(\"{}\", entry.getValue());\n+    }\n+\n+    AtomicReference<IOException> error = new AtomicReference<>(null);\n+    List<IOTaskResult> results = taskResults.entrySet().stream().map(\n+            entry -> {\n+              try {\n+                return JsonSerializable.fromJson(entry.getValue().trim(), new IOTaskResult[0]);\n+              } catch (IOException | ClassNotFoundException e) {\n+                error.set(new IOException(String\n+                        .format(\"Failed to parse task output from %s into result class\",\n+                                entry.getKey().getAddress().getHost()), e));\n+              }\n+              return null;\n+            }).collect(Collectors.toList());\n+\n+    if (error.get() != null) {\n+      throw error.get();\n+    }\n+\n+    return results.get(0).aggregator().aggregate(results).toJson();\n+  }\n+\n+  @Override\n+  public Set<Pair<WorkerInfo, ArrayList<String>>> selectExecutors(\n+          IOConfig config, List<WorkerInfo> jobWorkerInfoList,\n+          SelectExecutorsContext selectExecutorsContext) throws Exception {\n+    Set<Pair<WorkerInfo, ArrayList<String>>> result = Sets.newHashSet();\n+\n+    // Randomly select N workers\n+    Collections.shuffle(jobWorkerInfoList);\n+    int cnt = config.getWorkerNum();\n+    for (WorkerInfo worker : jobWorkerInfoList) {\n+      if (cnt <= 0) {\n+        break;\n+      }\n+      ArrayList<String> args = new ArrayList<>(2);\n+      // Add the worker hostname + worker id as the unique task id for each distributed task.\n+      // The worker id is used since there may be multiple workers on a single host.\n+      args.add(BaseParameters.ID_FLAG);\n+      args.add(worker.getAddress().getHost() + \"-\" + worker.getId());\n+      result.add(new Pair<>(worker, args));\n+      cnt--;\n+    }\n+    return result;\n+  }\n+\n+  @Override\n+  public String runTask(IOConfig config, ArrayList<String> args, RunTaskContext runTaskContext)\n+          throws Exception {\n+    LOG.info(\"args={}\", args);\n+\n+    List<String> command = new ArrayList<>(3 + config.getArgs().size());\n+    command.add(ServerConfiguration.get(PropertyKey.HOME) + \"/bin/alluxio\");\n+    command.add(\"runClass\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ded15217e52f154ab8d35409041773d361beda73"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM0MzU3Nw==", "bodyText": "I think the report step should be separate as we can combine multiple results to one graph like\n$ bin/alluxio runClass alluxio.stress.cli.report.GenerateReport --input io_4threads.json --input io_8threads.json --input io_16threads.json  --output-dir ./\n\nThe bar graphs will be next to each other providing a better illustration like below", "url": "https://github.com/Alluxio/alluxio/pull/11422#discussion_r432343577", "createdAt": "2020-05-29T08:46:38Z", "author": {"login": "jiacheliu3"}, "path": "job/server/src/main/java/alluxio/job/plan/io/IODefinition.java", "diffHunk": "@@ -0,0 +1,123 @@\n+package alluxio.job.plan.io;\n+\n+import alluxio.collections.Pair;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.job.RunTaskContext;\n+import alluxio.job.SelectExecutorsContext;\n+import alluxio.job.plan.PlanDefinition;\n+import alluxio.stress.BaseParameters;\n+import alluxio.stress.JsonSerializable;\n+import alluxio.stress.job.IOConfig;\n+import alluxio.stress.worker.IOTaskResult;\n+import alluxio.util.ShellUtils;\n+import alluxio.wire.WorkerInfo;\n+import com.google.common.collect.Sets;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The definition for the UFS I/O throughput job, which generates concurrent streams to the UFS.\n+ *\n+ * {@link IOConfig} is the configuration class, each task takes a List<String> as a list of\n+ * command-line arguments to the benchmark command, and each task returns the string output.\n+ * The output will be serialized and deserialized using JSON, collected and merged.\n+ */\n+public class IODefinition implements PlanDefinition<IOConfig, ArrayList<String>, String> {\n+  private static final Logger LOG = LoggerFactory.getLogger(IODefinition.class);\n+\n+  @Override\n+  public Class<IOConfig> getJobConfigClass() {\n+    return IOConfig.class;\n+  }\n+\n+  @Override\n+  public String join(IOConfig config, Map<WorkerInfo, String> taskResults) throws Exception {\n+    if (taskResults.isEmpty()) {\n+      throw new IOException(\"No results from any workers.\");\n+    }\n+    LOG.info(\"join()\");\n+    for(Map.Entry<WorkerInfo, String> entry : taskResults.entrySet()) {\n+      LOG.info(\"worker={}\", entry.getKey());\n+      LOG.info(\"{}\", entry.getValue());\n+    }\n+\n+    AtomicReference<IOException> error = new AtomicReference<>(null);\n+    List<IOTaskResult> results = taskResults.entrySet().stream().map(\n+            entry -> {\n+              try {\n+                return JsonSerializable.fromJson(entry.getValue().trim(), new IOTaskResult[0]);\n+              } catch (IOException | ClassNotFoundException e) {\n+                error.set(new IOException(String\n+                        .format(\"Failed to parse task output from %s into result class\",\n+                                entry.getKey().getAddress().getHost()), e));\n+              }\n+              return null;\n+            }).collect(Collectors.toList());\n+\n+    if (error.get() != null) {\n+      throw error.get();\n+    }\n+\n+    return results.get(0).aggregator().aggregate(results).toJson();\n+  }\n+\n+  @Override\n+  public Set<Pair<WorkerInfo, ArrayList<String>>> selectExecutors(\n+          IOConfig config, List<WorkerInfo> jobWorkerInfoList,\n+          SelectExecutorsContext selectExecutorsContext) throws Exception {\n+    Set<Pair<WorkerInfo, ArrayList<String>>> result = Sets.newHashSet();\n+\n+    // Randomly select N workers\n+    Collections.shuffle(jobWorkerInfoList);\n+    int cnt = config.getWorkerNum();\n+    for (WorkerInfo worker : jobWorkerInfoList) {\n+      if (cnt <= 0) {\n+        break;\n+      }\n+      ArrayList<String> args = new ArrayList<>(2);\n+      // Add the worker hostname + worker id as the unique task id for each distributed task.\n+      // The worker id is used since there may be multiple workers on a single host.\n+      args.add(BaseParameters.ID_FLAG);\n+      args.add(worker.getAddress().getHost() + \"-\" + worker.getId());\n+      result.add(new Pair<>(worker, args));\n+      cnt--;\n+    }\n+    return result;\n+  }\n+\n+  @Override\n+  public String runTask(IOConfig config, ArrayList<String> args, RunTaskContext runTaskContext)\n+          throws Exception {\n+    LOG.info(\"args={}\", args);\n+\n+    List<String> command = new ArrayList<>(3 + config.getArgs().size());\n+    command.add(ServerConfiguration.get(PropertyKey.HOME) + \"/bin/alluxio\");\n+    command.add(\"runClass\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUwMTY0OQ=="}, "originalCommit": {"oid": "ded15217e52f154ab8d35409041773d361beda73"}, "originalPosition": 105}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NDkyNTUyOnYy", "diffSide": "RIGHT", "path": "job/server/src/main/java/alluxio/job/plan/stress/StressBenchDefinition.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QwMToyNDowNVrOGZmtGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QwMToyNDowNVrOGZmtGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUwMTcyMA==", "bodyText": "nit: debug? the same for the other new logs in this file", "url": "https://github.com/Alluxio/alluxio/pull/11422#discussion_r429501720", "createdAt": "2020-05-23T01:24:05Z", "author": {"login": "madanadit"}, "path": "job/server/src/main/java/alluxio/job/plan/stress/StressBenchDefinition.java", "diffHunk": "@@ -68,13 +68,17 @@ public StressBenchDefinition() {\n       args.add(BaseParameters.ID_FLAG);\n       args.add(worker.getAddress().getHost() + \"-\" + worker.getId());\n       result.add(new Pair<>(worker, args));\n+      LOG.info(\"selectExecutors() args={}\", args);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ded15217e52f154ab8d35409041773d361beda73"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NDkyNjAwOnYy", "diffSide": "RIGHT", "path": "job/server/src/main/java/alluxio/job/plan/stress/StressBenchDefinition.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QwMToyNTowN1rOGZmtXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QwMToyNTowN1rOGZmtXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUwMTc4OQ==", "bodyText": "remove this and following our.println?", "url": "https://github.com/Alluxio/alluxio/pull/11422#discussion_r429501789", "createdAt": "2020-05-23T01:25:07Z", "author": {"login": "madanadit"}, "path": "job/server/src/main/java/alluxio/job/plan/stress/StressBenchDefinition.java", "diffHunk": "@@ -68,13 +68,17 @@ public StressBenchDefinition() {\n       args.add(BaseParameters.ID_FLAG);\n       args.add(worker.getAddress().getHost() + \"-\" + worker.getId());\n       result.add(new Pair<>(worker, args));\n+      LOG.info(\"selectExecutors() args={}\", args);\n     }\n     return result;\n   }\n \n   @Override\n   public String runTask(StressBenchConfig config, ArrayList<String> args,\n       RunTaskContext runTaskContext) throws Exception {\n+    LOG.info(\"Args: {}\", args);\n+    System.out.println(\"Running here \"+ args);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ded15217e52f154ab8d35409041773d361beda73"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NDkyNjE1OnYy", "diffSide": "RIGHT", "path": "job/server/src/main/java/alluxio/master/job/JobMaster.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QwMToyNToyMlrOGZmtbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QwMToyNToyMlrOGZmtbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUwMTgwNw==", "bodyText": "debug?", "url": "https://github.com/Alluxio/alluxio/pull/11422#discussion_r429501807", "createdAt": "2020-05-23T01:25:22Z", "author": {"login": "madanadit"}, "path": "job/server/src/main/java/alluxio/master/job/JobMaster.java", "diffHunk": "@@ -241,6 +241,7 @@ public synchronized void run(JobConfig jobConfig, long jobId)\n     Context forkedCtx = Context.current().fork();\n     Context prevCtx = forkedCtx.attach();\n     try {\n+      LOG.info(\"jobConfig class {}\", jobConfig.getClass().getCanonicalName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ded15217e52f154ab8d35409041773d361beda73"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NDk0MjA5OnYy", "diffSide": "RIGHT", "path": "job/server/src/test/java/alluxio/job/plan/io/IODefinitionTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QwMTo1NToyOVrOGZm2SQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxMzoxNDoxMlrOGb0eXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUwNDA3Mw==", "bodyText": "?", "url": "https://github.com/Alluxio/alluxio/pull/11422#discussion_r429504073", "createdAt": "2020-05-23T01:55:29Z", "author": {"login": "madanadit"}, "path": "job/server/src/test/java/alluxio/job/plan/io/IODefinitionTest.java", "diffHunk": "@@ -0,0 +1,109 @@\n+package alluxio.job.plan.io;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.ClientContext;\n+import alluxio.client.block.AlluxioBlockStore;\n+import alluxio.client.file.FileSystem;\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.collections.Pair;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.job.JobServerContext;\n+import alluxio.job.SelectExecutorsContext;\n+import alluxio.job.plan.load.LoadDefinition;\n+import alluxio.stress.job.IOConfig;\n+import alluxio.stress.worker.WorkerBenchParameters;\n+import alluxio.underfs.UfsManager;\n+import alluxio.wire.WorkerInfo;\n+import alluxio.wire.WorkerNetAddress;\n+import com.google.common.collect.ImmutableList;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mockito;\n+import org.powermock.api.mockito.PowerMockito;\n+import org.powermock.core.classloader.annotations.PrepareForTest;\n+import org.powermock.modules.junit4.PowerMockRunner;\n+\n+import java.lang.reflect.Array;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.Matchers.any;\n+\n+@RunWith(PowerMockRunner.class)\n+@PrepareForTest({FileSystem.class, JobServerContext.class, FileSystemContext.class,\n+        AlluxioBlockStore.class})\n+public class IODefinitionTest {\n+    private static final List<WorkerInfo> JOB_WORKERS = new ImmutableList.Builder<WorkerInfo>()\n+            .add(new WorkerInfo().setId(0).setAddress(new WorkerNetAddress().setHost(\"host0\")))\n+            .add(new WorkerInfo().setId(1).setAddress(new WorkerNetAddress().setHost(\"host1\")))\n+            .add(new WorkerInfo().setId(2).setAddress(new WorkerNetAddress().setHost(\"host2\")))\n+            .add(new WorkerInfo().setId(3).setAddress(new WorkerNetAddress().setHost(\"host3\"))).build();\n+\n+    private JobServerContext mJobServerContext;\n+    private FileSystem mMockFileSystem;\n+    private AlluxioBlockStore mMockBlockStore;\n+    private FileSystemContext mMockFsContext;\n+\n+    @Before\n+    public void before() {\n+        mMockFileSystem = PowerMockito.mock(FileSystem.class);\n+        mMockBlockStore = PowerMockito.mock(AlluxioBlockStore.class);\n+        mMockFsContext = PowerMockito.mock(FileSystemContext.class);\n+        PowerMockito.mockStatic(AlluxioBlockStore.class);\n+        PowerMockito.when(AlluxioBlockStore.create(any(FileSystemContext.class)))\n+                .thenReturn(mMockBlockStore);\n+        PowerMockito.when(mMockFsContext.getClientContext())\n+                .thenReturn(ClientContext.create(ServerConfiguration.global()));\n+        // TODO(jiacheng): need to hijack this conf?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ded15217e52f154ab8d35409041773d361beda73"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTgyNDQ3OA==", "bodyText": "Please ignore all unit test related stuff here. I will make the tests more meaningful once we are more settled on the functionality.", "url": "https://github.com/Alluxio/alluxio/pull/11422#discussion_r431824478", "createdAt": "2020-05-28T13:14:12Z", "author": {"login": "jiacheliu3"}, "path": "job/server/src/test/java/alluxio/job/plan/io/IODefinitionTest.java", "diffHunk": "@@ -0,0 +1,109 @@\n+package alluxio.job.plan.io;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.ClientContext;\n+import alluxio.client.block.AlluxioBlockStore;\n+import alluxio.client.file.FileSystem;\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.collections.Pair;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.job.JobServerContext;\n+import alluxio.job.SelectExecutorsContext;\n+import alluxio.job.plan.load.LoadDefinition;\n+import alluxio.stress.job.IOConfig;\n+import alluxio.stress.worker.WorkerBenchParameters;\n+import alluxio.underfs.UfsManager;\n+import alluxio.wire.WorkerInfo;\n+import alluxio.wire.WorkerNetAddress;\n+import com.google.common.collect.ImmutableList;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mockito;\n+import org.powermock.api.mockito.PowerMockito;\n+import org.powermock.core.classloader.annotations.PrepareForTest;\n+import org.powermock.modules.junit4.PowerMockRunner;\n+\n+import java.lang.reflect.Array;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.Matchers.any;\n+\n+@RunWith(PowerMockRunner.class)\n+@PrepareForTest({FileSystem.class, JobServerContext.class, FileSystemContext.class,\n+        AlluxioBlockStore.class})\n+public class IODefinitionTest {\n+    private static final List<WorkerInfo> JOB_WORKERS = new ImmutableList.Builder<WorkerInfo>()\n+            .add(new WorkerInfo().setId(0).setAddress(new WorkerNetAddress().setHost(\"host0\")))\n+            .add(new WorkerInfo().setId(1).setAddress(new WorkerNetAddress().setHost(\"host1\")))\n+            .add(new WorkerInfo().setId(2).setAddress(new WorkerNetAddress().setHost(\"host2\")))\n+            .add(new WorkerInfo().setId(3).setAddress(new WorkerNetAddress().setHost(\"host3\"))).build();\n+\n+    private JobServerContext mJobServerContext;\n+    private FileSystem mMockFileSystem;\n+    private AlluxioBlockStore mMockBlockStore;\n+    private FileSystemContext mMockFsContext;\n+\n+    @Before\n+    public void before() {\n+        mMockFileSystem = PowerMockito.mock(FileSystem.class);\n+        mMockBlockStore = PowerMockito.mock(AlluxioBlockStore.class);\n+        mMockFsContext = PowerMockito.mock(FileSystemContext.class);\n+        PowerMockito.mockStatic(AlluxioBlockStore.class);\n+        PowerMockito.when(AlluxioBlockStore.create(any(FileSystemContext.class)))\n+                .thenReturn(mMockBlockStore);\n+        PowerMockito.when(mMockFsContext.getClientContext())\n+                .thenReturn(ClientContext.create(ServerConfiguration.global()));\n+        // TODO(jiacheng): need to hijack this conf?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUwNDA3Mw=="}, "originalCommit": {"oid": "ded15217e52f154ab8d35409041773d361beda73"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NDk0MjIxOnYy", "diffSide": "RIGHT", "path": "job/server/src/test/java/alluxio/job/plan/io/IODefinitionTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QwMTo1NTozNVrOGZm2Vg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QwMTo1NTozNVrOGZm2Vg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUwNDA4Ng==", "bodyText": "?", "url": "https://github.com/Alluxio/alluxio/pull/11422#discussion_r429504086", "createdAt": "2020-05-23T01:55:35Z", "author": {"login": "madanadit"}, "path": "job/server/src/test/java/alluxio/job/plan/io/IODefinitionTest.java", "diffHunk": "@@ -0,0 +1,109 @@\n+package alluxio.job.plan.io;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.ClientContext;\n+import alluxio.client.block.AlluxioBlockStore;\n+import alluxio.client.file.FileSystem;\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.collections.Pair;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.job.JobServerContext;\n+import alluxio.job.SelectExecutorsContext;\n+import alluxio.job.plan.load.LoadDefinition;\n+import alluxio.stress.job.IOConfig;\n+import alluxio.stress.worker.WorkerBenchParameters;\n+import alluxio.underfs.UfsManager;\n+import alluxio.wire.WorkerInfo;\n+import alluxio.wire.WorkerNetAddress;\n+import com.google.common.collect.ImmutableList;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mockito;\n+import org.powermock.api.mockito.PowerMockito;\n+import org.powermock.core.classloader.annotations.PrepareForTest;\n+import org.powermock.modules.junit4.PowerMockRunner;\n+\n+import java.lang.reflect.Array;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.Matchers.any;\n+\n+@RunWith(PowerMockRunner.class)\n+@PrepareForTest({FileSystem.class, JobServerContext.class, FileSystemContext.class,\n+        AlluxioBlockStore.class})\n+public class IODefinitionTest {\n+    private static final List<WorkerInfo> JOB_WORKERS = new ImmutableList.Builder<WorkerInfo>()\n+            .add(new WorkerInfo().setId(0).setAddress(new WorkerNetAddress().setHost(\"host0\")))\n+            .add(new WorkerInfo().setId(1).setAddress(new WorkerNetAddress().setHost(\"host1\")))\n+            .add(new WorkerInfo().setId(2).setAddress(new WorkerNetAddress().setHost(\"host2\")))\n+            .add(new WorkerInfo().setId(3).setAddress(new WorkerNetAddress().setHost(\"host3\"))).build();\n+\n+    private JobServerContext mJobServerContext;\n+    private FileSystem mMockFileSystem;\n+    private AlluxioBlockStore mMockBlockStore;\n+    private FileSystemContext mMockFsContext;\n+\n+    @Before\n+    public void before() {\n+        mMockFileSystem = PowerMockito.mock(FileSystem.class);\n+        mMockBlockStore = PowerMockito.mock(AlluxioBlockStore.class);\n+        mMockFsContext = PowerMockito.mock(FileSystemContext.class);\n+        PowerMockito.mockStatic(AlluxioBlockStore.class);\n+        PowerMockito.when(AlluxioBlockStore.create(any(FileSystemContext.class)))\n+                .thenReturn(mMockBlockStore);\n+        PowerMockito.when(mMockFsContext.getClientContext())\n+                .thenReturn(ClientContext.create(ServerConfiguration.global()));\n+        // TODO(jiacheng): need to hijack this conf?\n+        PowerMockito.when(mMockFsContext.getClusterConf()).thenReturn(ServerConfiguration.global());\n+        PowerMockito.when(mMockFsContext.getPathConf(any(AlluxioURI.class)))\n+                .thenReturn(ServerConfiguration.global());\n+        mJobServerContext = new JobServerContext(mMockFileSystem, mMockFsContext,\n+                Mockito.mock(UfsManager.class));\n+    }\n+\n+    @Test\n+    public void selectExecutor() throws Exception {\n+        Set<WorkerInfo> workerSet = new HashSet<>(JOB_WORKERS);\n+        IOConfig jobConfig = new IOConfig(IOConfig.class.getCanonicalName(),\n+                ImmutableList.of(),\n+                16,\n+                1024,\n+                1,\n+                \"hdfs://namenode:9000/alluxio\");\n+        Set<Pair<WorkerInfo, ArrayList<String>>> assignments =\n+                new IODefinition().selectExecutors(jobConfig,\n+                        new ArrayList<>(JOB_WORKERS),\n+                        new SelectExecutorsContext(1, mJobServerContext));\n+        System.out.println(assignments);\n+        assertEquals(assignments.size(), 1);\n+        for (Pair<WorkerInfo, ArrayList<String>> p : assignments) {\n+            WorkerInfo w = p.getFirst();\n+            assertTrue(workerSet.contains(w));\n+        }\n+    }\n+\n+    // Test join", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ded15217e52f154ab8d35409041773d361beda73"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NDk0MjUzOnYy", "diffSide": "RIGHT", "path": "job/server/src/test/java/alluxio/job/plan/io/IODefinitionTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QwMTo1NjowOVrOGZm2gQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QwMTo1NjowOVrOGZm2gQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUwNDEyOQ==", "bodyText": "i don't get the TODOs in this file", "url": "https://github.com/Alluxio/alluxio/pull/11422#discussion_r429504129", "createdAt": "2020-05-23T01:56:09Z", "author": {"login": "madanadit"}, "path": "job/server/src/test/java/alluxio/job/plan/io/IODefinitionTest.java", "diffHunk": "@@ -0,0 +1,109 @@\n+package alluxio.job.plan.io;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.ClientContext;\n+import alluxio.client.block.AlluxioBlockStore;\n+import alluxio.client.file.FileSystem;\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.collections.Pair;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.job.JobServerContext;\n+import alluxio.job.SelectExecutorsContext;\n+import alluxio.job.plan.load.LoadDefinition;\n+import alluxio.stress.job.IOConfig;\n+import alluxio.stress.worker.WorkerBenchParameters;\n+import alluxio.underfs.UfsManager;\n+import alluxio.wire.WorkerInfo;\n+import alluxio.wire.WorkerNetAddress;\n+import com.google.common.collect.ImmutableList;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mockito;\n+import org.powermock.api.mockito.PowerMockito;\n+import org.powermock.core.classloader.annotations.PrepareForTest;\n+import org.powermock.modules.junit4.PowerMockRunner;\n+\n+import java.lang.reflect.Array;\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.Matchers.any;\n+\n+@RunWith(PowerMockRunner.class)\n+@PrepareForTest({FileSystem.class, JobServerContext.class, FileSystemContext.class,\n+        AlluxioBlockStore.class})\n+public class IODefinitionTest {\n+    private static final List<WorkerInfo> JOB_WORKERS = new ImmutableList.Builder<WorkerInfo>()\n+            .add(new WorkerInfo().setId(0).setAddress(new WorkerNetAddress().setHost(\"host0\")))\n+            .add(new WorkerInfo().setId(1).setAddress(new WorkerNetAddress().setHost(\"host1\")))\n+            .add(new WorkerInfo().setId(2).setAddress(new WorkerNetAddress().setHost(\"host2\")))\n+            .add(new WorkerInfo().setId(3).setAddress(new WorkerNetAddress().setHost(\"host3\"))).build();\n+\n+    private JobServerContext mJobServerContext;\n+    private FileSystem mMockFileSystem;\n+    private AlluxioBlockStore mMockBlockStore;\n+    private FileSystemContext mMockFsContext;\n+\n+    @Before\n+    public void before() {\n+        mMockFileSystem = PowerMockito.mock(FileSystem.class);\n+        mMockBlockStore = PowerMockito.mock(AlluxioBlockStore.class);\n+        mMockFsContext = PowerMockito.mock(FileSystemContext.class);\n+        PowerMockito.mockStatic(AlluxioBlockStore.class);\n+        PowerMockito.when(AlluxioBlockStore.create(any(FileSystemContext.class)))\n+                .thenReturn(mMockBlockStore);\n+        PowerMockito.when(mMockFsContext.getClientContext())\n+                .thenReturn(ClientContext.create(ServerConfiguration.global()));\n+        // TODO(jiacheng): need to hijack this conf?\n+        PowerMockito.when(mMockFsContext.getClusterConf()).thenReturn(ServerConfiguration.global());\n+        PowerMockito.when(mMockFsContext.getPathConf(any(AlluxioURI.class)))\n+                .thenReturn(ServerConfiguration.global());\n+        mJobServerContext = new JobServerContext(mMockFileSystem, mMockFsContext,\n+                Mockito.mock(UfsManager.class));\n+    }\n+\n+    @Test\n+    public void selectExecutor() throws Exception {\n+        Set<WorkerInfo> workerSet = new HashSet<>(JOB_WORKERS);\n+        IOConfig jobConfig = new IOConfig(IOConfig.class.getCanonicalName(),\n+                ImmutableList.of(),\n+                16,\n+                1024,\n+                1,\n+                \"hdfs://namenode:9000/alluxio\");\n+        Set<Pair<WorkerInfo, ArrayList<String>>> assignments =\n+                new IODefinition().selectExecutors(jobConfig,\n+                        new ArrayList<>(JOB_WORKERS),\n+                        new SelectExecutorsContext(1, mJobServerContext));\n+        System.out.println(assignments);\n+        assertEquals(assignments.size(), 1);\n+        for (Pair<WorkerInfo, ArrayList<String>> p : assignments) {\n+            WorkerInfo w = p.getFirst();\n+            assertTrue(workerSet.contains(w));\n+        }\n+    }\n+\n+    // Test join\n+\n+    // Test exec command\n+    @Test\n+    public void execCommand() {\n+        Set<WorkerInfo> workerSet = new HashSet<>(JOB_WORKERS);\n+        IOConfig jobConfig = new IOConfig(IOConfig.class.getCanonicalName(),\n+                ImmutableList.of(),\n+                16,\n+                1024,\n+                1,\n+                \"hdfs://namenode:9000/alluxio\");\n+        IODefinition def = new IODefinition();\n+        // TODO(jiacheng): catch ShellUtils?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ded15217e52f154ab8d35409041773d361beda73"}, "originalPosition": 105}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NDk0Mjc4OnYy", "diffSide": "RIGHT", "path": "stress/common/src/main/java/alluxio/stress/job/IOConfig.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QwMTo1Njo0OVrOGZm2pQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QwMTo1Njo0OVrOGZm2pQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUwNDE2NQ==", "bodyText": "comment", "url": "https://github.com/Alluxio/alluxio/pull/11422#discussion_r429504165", "createdAt": "2020-05-23T01:56:49Z", "author": {"login": "madanadit"}, "path": "stress/common/src/main/java/alluxio/stress/job/IOConfig.java", "diffHunk": "@@ -0,0 +1,126 @@\n+package alluxio.stress.job;\n+\n+import alluxio.stress.worker.WorkerBenchParameters;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonTypeName;\n+import com.google.common.base.Objects;\n+\n+import java.util.List;\n+\n+/**\n+ * Configuration for the IO throughput test to the UFS.\n+ */\n+@JsonTypeName(IOConfig.NAME)\n+public class IOConfig extends StressBenchConfig {\n+  private static final long serialVersionUID = 7883915266950426998L;\n+  public static final String NAME = \"IO\";\n+  // The number of streams to write to the UFS concurrently\n+  private int mThreadNum;\n+  // Size of data to write in total\n+  // They will be read in the read performance test\n+  private int mDataSize;\n+  // Temp dir to generate test files in\n+  private String mPath;\n+  private int mWorkerNum;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ded15217e52f154ab8d35409041773d361beda73"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NDk0MzEyOnYy", "diffSide": "RIGHT", "path": "stress/common/src/main/java/alluxio/stress/job/IOConfig.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QwMTo1NzozNFrOGZm22w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QwMTo1NzozNFrOGZm22w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUwNDIxOQ==", "bodyText": "nit: combine w/ previous comment \"Size of data to write/read in total\"", "url": "https://github.com/Alluxio/alluxio/pull/11422#discussion_r429504219", "createdAt": "2020-05-23T01:57:34Z", "author": {"login": "madanadit"}, "path": "stress/common/src/main/java/alluxio/stress/job/IOConfig.java", "diffHunk": "@@ -0,0 +1,126 @@\n+package alluxio.stress.job;\n+\n+import alluxio.stress.worker.WorkerBenchParameters;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.annotation.JsonTypeName;\n+import com.google.common.base.Objects;\n+\n+import java.util.List;\n+\n+/**\n+ * Configuration for the IO throughput test to the UFS.\n+ */\n+@JsonTypeName(IOConfig.NAME)\n+public class IOConfig extends StressBenchConfig {\n+  private static final long serialVersionUID = 7883915266950426998L;\n+  public static final String NAME = \"IO\";\n+  // The number of streams to write to the UFS concurrently\n+  private int mThreadNum;\n+  // Size of data to write in total\n+  // They will be read in the read performance test", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ded15217e52f154ab8d35409041773d361beda73"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NDk0NDEyOnYy", "diffSide": "RIGHT", "path": "stress/common/src/test/java/alluxio/stress/job/IOConfigTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QwMTo1OToyNFrOGZm3Zw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QwMTo1OToyNFrOGZm3Zw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUwNDM1OQ==", "bodyText": "complete the implementation?", "url": "https://github.com/Alluxio/alluxio/pull/11422#discussion_r429504359", "createdAt": "2020-05-23T01:59:24Z", "author": {"login": "madanadit"}, "path": "stress/common/src/test/java/alluxio/stress/job/IOConfigTest.java", "diffHunk": "@@ -0,0 +1,26 @@\n+package alluxio.stress.job;\n+\n+import alluxio.job.plan.replicate.EvictConfig;\n+import alluxio.stress.worker.WorkerBenchParameters;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableList;\n+import org.junit.Test;\n+\n+public class IOConfigTest {\n+    @Test\n+    public void json() throws Exception {\n+        IOConfig config = new IOConfig(IOConfig.class.getCanonicalName(),\n+                ImmutableList.of(),\n+        16,\n+        1024,\n+        1,\n+        \"hdfs://namenode:9000/alluxio\");\n+        ObjectMapper mapper = new ObjectMapper();\n+        String json = mapper.writeValueAsString(config);\n+        System.out.println(json);\n+        IOConfig other = mapper.readValue(json, IOConfig.class);\n+        // TODO(jiacheng): check equality", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ded15217e52f154ab8d35409041773d361beda73"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NDk0NDM3OnYy", "diffSide": "RIGHT", "path": "stress/common/src/test/java/alluxio/stress/worker/IOTaskResultTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QwMTo1OTo1NVrOGZm3kg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QwMTo1OTo1NVrOGZm3kg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUwNDQwMg==", "bodyText": "?", "url": "https://github.com/Alluxio/alluxio/pull/11422#discussion_r429504402", "createdAt": "2020-05-23T01:59:55Z", "author": {"login": "madanadit"}, "path": "stress/common/src/test/java/alluxio/stress/worker/IOTaskResultTest.java", "diffHunk": "@@ -0,0 +1,43 @@\n+package alluxio.stress.worker;\n+\n+import alluxio.stress.job.IOConfig;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.google.common.collect.ImmutableList;\n+import org.junit.Test;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+public class IOTaskResultTest {\n+    @Test\n+    public void json() throws Exception {\n+        IOTaskResult result = new IOTaskResult();\n+        result.addPoint(new IOTaskResult.Point(IOConfig.IOMode.READ, 100L, 20));\n+        result.addPoint(new IOTaskResult.Point(IOConfig.IOMode.WRITE, 100L, 5));\n+        ObjectMapper mapper = new ObjectMapper();\n+        String json = mapper.writeValueAsString(result);\n+        System.out.println(json);\n+        IOTaskResult other = mapper.readValue(json, IOTaskResult.class);\n+        // TODO(jiacheng): check equality", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ded15217e52f154ab8d35409041773d361beda73"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NDk0NjU5OnYy", "diffSide": "RIGHT", "path": "stress/common/src/main/java/alluxio/stress/worker/IOTaskSummary.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QwMjowNDowNlrOGZm4xA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwODowMTo0MVrOGcSt6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUwNDcwOA==", "bodyText": "are these any new system requirements for plotting the graphs? or do we include everything we need in the server tarball", "url": "https://github.com/Alluxio/alluxio/pull/11422#discussion_r429504708", "createdAt": "2020-05-23T02:04:06Z", "author": {"login": "madanadit"}, "path": "stress/common/src/main/java/alluxio/stress/worker/IOTaskSummary.java", "diffHunk": "@@ -0,0 +1,360 @@\n+package alluxio.stress.worker;\n+\n+import alluxio.collections.Pair;\n+import alluxio.stress.BaseParameters;\n+import alluxio.stress.JsonSerializable;\n+import alluxio.stress.Parameters;\n+import alluxio.stress.Summary;\n+import alluxio.stress.graph.BarGraph;\n+import alluxio.stress.graph.Graph;\n+import alluxio.stress.job.IOConfig;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.fasterxml.jackson.databind.deser.std.StdDeserializer;\n+import com.fasterxml.jackson.databind.ser.std.StdSerializer;\n+import com.google.common.base.Splitter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The summary for the UFS I/O throughput test.\n+ */\n+public class IOTaskSummary implements Summary {\n+  private static final Logger LOG = LoggerFactory.getLogger(IOTaskSummary.class);\n+  private List<IOTaskResult.Point> mPoints;\n+  private List<String> mErrors;\n+  private BaseParameters mBaseParameters;\n+  private WorkerBenchParameters mParameters;\n+  private SpeedStat mReadSpeedStat;\n+  private SpeedStat mWriteSpeedStat;\n+\n+  /**\n+   * Used for deserialization.\n+   * */\n+  @JsonCreator\n+  public IOTaskSummary() {}\n+\n+  /**\n+   * @param result the {@link IOTaskResult} to summarize\n+   * */\n+  public IOTaskSummary(IOTaskResult result) {\n+    mPoints = new ArrayList<>(result.getPoints());\n+    mErrors = new ArrayList<>(result.getErrors());\n+    mBaseParameters = result.getBaseParameters();\n+    mParameters = result.getParameters();\n+    calculateStats();\n+  }\n+\n+  /**\n+   * @return the points recorded\n+   * */\n+  public List<IOTaskResult.Point> getPoints() {\n+    return mPoints;\n+  }\n+\n+  /**\n+   * @param points the data points\n+   * */\n+  public void setPoints(List<IOTaskResult.Point> points) {\n+    mPoints = points;\n+  }\n+\n+  /**\n+   * @return the errors recorded\n+   * */\n+  public List<String> getErrors() {\n+    return mErrors;\n+  }\n+\n+  /**\n+   * @param errors the errors\n+   * */\n+  public void setErrors(List<String> errors) {\n+    mErrors = errors;\n+  }\n+\n+  /**\n+   * @return the {@link BaseParameters}\n+   * */\n+  public BaseParameters getBaseParameters() {\n+    return mBaseParameters;\n+  }\n+\n+  /**\n+   * @param baseParameters the {@link BaseParameters}\n+   * */\n+  public void setBaseParameters(BaseParameters baseParameters) {\n+    mBaseParameters = baseParameters;\n+  }\n+\n+  /**\n+   * @return the task specific {@link WorkerBenchParameters}\n+   * */\n+  public WorkerBenchParameters getParameters() {\n+    return mParameters;\n+  }\n+\n+  /**\n+   * @param parameters the {@link WorkerBenchParameters}\n+   * */\n+  public void setParameters(WorkerBenchParameters parameters) {\n+    mParameters = parameters;\n+  }\n+\n+  /**\n+   * @return the {@link SpeedStat} for read speed\n+   * */\n+  public SpeedStat getReadSpeedStat() {\n+    return mReadSpeedStat;\n+  }\n+\n+  /**\n+   * @param stat the {@link SpeedStat} for read stats\n+   * */\n+  public void setReadSpeedStat(SpeedStat stat) {\n+    mReadSpeedStat = stat;\n+  }\n+\n+  /**\n+   * @return the {@link SpeedStat} for write speed\n+   * */\n+  public SpeedStat getWriteSpeedStat() {\n+    return mWriteSpeedStat;\n+  }\n+\n+  /**\n+   * @param stat the {@link SpeedStat} for write stats\n+   * */\n+  public void setWriteSpeedStat(SpeedStat stat) {\n+    mWriteSpeedStat = stat;\n+  }\n+\n+  /**\n+   * An object representation of all the statistics we need\n+   * from this I/O test.\n+   * */\n+  @JsonSerialize(using = StatSerializer.class)\n+  @JsonDeserialize(using = StatDeserializer.class)\n+  public static class SpeedStat implements JsonSerializable {\n+    public double mTotalDuration; // in second\n+    public int mTotalSize; // in MB\n+    public double mMaxSpeed; // in MB/s\n+    public double mMinSpeed; // in MB/s\n+    public double mAvgSpeed; // in MB/s\n+    public double mStdDev; // in MB/s\n+\n+    /**\n+     * An empty constructor.\n+     * */\n+    public SpeedStat() {}\n+\n+    @Override\n+    public String toString() {\n+      return String.format(\"{totalDuration=%ss, totalSize=%sMB, maxSpeed=%sMB/s, \"\n+                      + \"minSpeed=%sMB/s, \" + \"avgSpeed=%sMB/s, stdDev=%s}\",\n+              mTotalDuration, mTotalSize, mMaxSpeed, mMinSpeed, mAvgSpeed, mStdDev);\n+    }\n+  }\n+\n+  /**\n+   * A customized serializer for {@link SpeedStat}.\n+   * All the fields are attached with the unit.\n+   * */\n+  public static class StatSerializer extends StdSerializer<SpeedStat> {\n+    /**\n+     * An empty constructor.\n+     * */\n+    public StatSerializer() {\n+      super(SpeedStat.class);\n+    }\n+\n+    @Override\n+    public void serialize(SpeedStat value, JsonGenerator jgen, SerializerProvider provider)\n+            throws IOException {\n+      jgen.writeStartObject();\n+      jgen.writeStringField(\"totalDuration\", value.mTotalDuration + \"s\");\n+      jgen.writeStringField(\"totalSize\", value.mTotalSize + \"MB\");\n+      jgen.writeStringField(\"maxSpeed\", value.mMaxSpeed + \"MB/s\");\n+      jgen.writeStringField(\"minSpeed\", value.mMinSpeed + \"MB/s\");\n+      jgen.writeStringField(\"avgSpeed\", value.mAvgSpeed + \"MB/s\");\n+      jgen.writeNumberField(\"stdDev\", value.mStdDev);\n+      jgen.writeEndObject();\n+    }\n+  }\n+\n+  /**\n+   * A customized deserializer for {@link SpeedStat}.\n+   * */\n+  public static class StatDeserializer extends StdDeserializer<SpeedStat> {\n+    /**\n+     * An empty constructor.\n+     * */\n+    public StatDeserializer() {\n+      super(SpeedStat.class);\n+    }\n+\n+    private double speedToNumber(String speed) {\n+      return Double.parseDouble(speed.substring(0, speed.length() - \"MB/s\".length()));\n+    }\n+\n+    private double timeToNumber(String time) {\n+      return Double.parseDouble(time.substring(0, time.length() - \"s\".length()));\n+    }\n+\n+    private int sizeToNumber(String size) {\n+      return Integer.parseInt(size.substring(0, size.length() - \"MB\".length()));\n+    }\n+\n+    @Override\n+    public SpeedStat deserialize(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException {\n+      JsonNode node = jp.getCodec().readTree(jp);\n+      SpeedStat stat = new SpeedStat();\n+      stat.mTotalDuration = timeToNumber(node.get(\"totalDuration\").asText());\n+      stat.mTotalSize = sizeToNumber(node.get(\"totalSize\").asText());\n+      stat.mMaxSpeed = speedToNumber(node.get(\"maxSpeed\").asText());\n+      stat.mMinSpeed = speedToNumber(node.get(\"minSpeed\").asText());\n+      stat.mAvgSpeed = speedToNumber(node.get(\"avgSpeed\").asText());\n+      stat.mStdDev = node.get(\"stdDev\").asDouble();\n+\n+      return stat;\n+    }\n+  }\n+\n+  /**\n+   * The points must be valid (duration not equal to 0).\n+   */\n+  private static SpeedStat calculateStat(List<IOTaskResult.Point> points) {\n+    SpeedStat result = new SpeedStat();\n+    if (points.size() == 0) {\n+      return result;\n+    }\n+\n+    double totalDuration = 0.0;\n+    int totalSize = 0;\n+    double[] speeds = new double[points.size()];\n+    double maxSpeed = 0.0;\n+    double minSpeed = Double.MAX_VALUE;\n+    int i = 0;\n+    for (IOTaskResult.Point p : points) {\n+      totalDuration += p.mDuration;\n+      totalSize += p.mDataSizeMB;\n+      double speed = p.mDataSizeMB / p.mDuration;\n+      maxSpeed = Math.max(maxSpeed, speed);\n+      minSpeed = Math.min(minSpeed, speed);\n+      speeds[i++] = p.mDataSizeMB / p.mDuration;\n+    }\n+    double avgSpeed = totalSize / totalDuration;\n+    double var = 0;\n+    for (double s : speeds) {\n+      var += (s - avgSpeed) * (s - avgSpeed);\n+    }\n+\n+    result.mTotalDuration = totalDuration;\n+    result.mTotalSize = totalSize;\n+    result.mMaxSpeed = maxSpeed;\n+    result.mMinSpeed = Double.compare(minSpeed, Double.MAX_VALUE) == 0 ? 0.0 : minSpeed;\n+    result.mAvgSpeed = avgSpeed;\n+    result.mStdDev = Math.sqrt(var);\n+\n+    return result;\n+  }\n+\n+  private void calculateStats() {\n+    List<IOTaskResult.Point> readPoints = mPoints.stream().filter((p) ->\n+            p.mMode == IOConfig.IOMode.READ && p.mDuration > 0)\n+            .collect(Collectors.toList());\n+    mReadSpeedStat = calculateStat(readPoints);\n+\n+    List<IOTaskResult.Point> writePoints = mPoints.stream().filter((p) ->\n+            p.mMode == IOConfig.IOMode.WRITE && p.mDuration > 0)\n+            .collect(Collectors.toList());\n+    mWriteSpeedStat = calculateStat(writePoints);\n+  }\n+\n+  @Override\n+  public GraphGenerator graphGenerator() {\n+    return new GraphGenerator();\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return String.format(\"IOTaskSummary: {Points=%s, Errors=%s}%n\",\n+            mPoints, mErrors);\n+  }\n+\n+  /**\n+   * A graph generator for the statistics collected.\n+   * */\n+  public static final class GraphGenerator extends alluxio.stress.GraphGenerator {\n+    @Override\n+    public List<Graph> generate(List<? extends Summary> results) {\n+      List<Graph> graphs = new ArrayList<>();\n+      // only examine MaxThroughputSummary\n+      List<IOTaskSummary> summaries =\n+              results.stream().map(x -> (IOTaskSummary) x).collect(Collectors.toList());\n+\n+      if (summaries.isEmpty()) {\n+        LOG.info(\"No summaries\");\n+        return graphs;\n+      }\n+\n+      // TODO(jiacheng): how to include params in this?\n+      // first() is the list of common field names, second() is the list of unique field names\n+      Pair<List<String>, List<String>> fieldNames = Parameters.partitionFieldNames(\n+              summaries.stream().map(x -> x.mParameters).collect(Collectors.toList()));\n+      System.out.format(\"FieldNames: %s%n\", fieldNames);\n+\n+      // Split up common description into 100 character chunks, for the sub title\n+      List<String> subTitle = new ArrayList<>(Splitter.fixedLength(100).splitToList(\n+              summaries.get(0).mParameters.getDescription(fieldNames.getFirst())));\n+      System.out.format(\"subtitle: %s%n\", subTitle);\n+\n+      for (IOTaskSummary summary : summaries) {\n+        String series = summary.mParameters.getDescription(fieldNames.getSecond());\n+        subTitle.add(series);\n+      }\n+\n+      BarGraph speedGraph = new BarGraph(\"Read/Write speed\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ded15217e52f154ab8d35409041773d361beda73"}, "originalPosition": 330}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMxOTk3OQ==", "bodyText": "There's no new system requirements for plotting. The HTML generation in alluxio.stress.graph.LineGraph/BarGraph wraps its own JS libraries.", "url": "https://github.com/Alluxio/alluxio/pull/11422#discussion_r432319979", "createdAt": "2020-05-29T08:01:41Z", "author": {"login": "jiacheliu3"}, "path": "stress/common/src/main/java/alluxio/stress/worker/IOTaskSummary.java", "diffHunk": "@@ -0,0 +1,360 @@\n+package alluxio.stress.worker;\n+\n+import alluxio.collections.Pair;\n+import alluxio.stress.BaseParameters;\n+import alluxio.stress.JsonSerializable;\n+import alluxio.stress.Parameters;\n+import alluxio.stress.Summary;\n+import alluxio.stress.graph.BarGraph;\n+import alluxio.stress.graph.Graph;\n+import alluxio.stress.job.IOConfig;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.fasterxml.jackson.databind.deser.std.StdDeserializer;\n+import com.fasterxml.jackson.databind.ser.std.StdSerializer;\n+import com.google.common.base.Splitter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The summary for the UFS I/O throughput test.\n+ */\n+public class IOTaskSummary implements Summary {\n+  private static final Logger LOG = LoggerFactory.getLogger(IOTaskSummary.class);\n+  private List<IOTaskResult.Point> mPoints;\n+  private List<String> mErrors;\n+  private BaseParameters mBaseParameters;\n+  private WorkerBenchParameters mParameters;\n+  private SpeedStat mReadSpeedStat;\n+  private SpeedStat mWriteSpeedStat;\n+\n+  /**\n+   * Used for deserialization.\n+   * */\n+  @JsonCreator\n+  public IOTaskSummary() {}\n+\n+  /**\n+   * @param result the {@link IOTaskResult} to summarize\n+   * */\n+  public IOTaskSummary(IOTaskResult result) {\n+    mPoints = new ArrayList<>(result.getPoints());\n+    mErrors = new ArrayList<>(result.getErrors());\n+    mBaseParameters = result.getBaseParameters();\n+    mParameters = result.getParameters();\n+    calculateStats();\n+  }\n+\n+  /**\n+   * @return the points recorded\n+   * */\n+  public List<IOTaskResult.Point> getPoints() {\n+    return mPoints;\n+  }\n+\n+  /**\n+   * @param points the data points\n+   * */\n+  public void setPoints(List<IOTaskResult.Point> points) {\n+    mPoints = points;\n+  }\n+\n+  /**\n+   * @return the errors recorded\n+   * */\n+  public List<String> getErrors() {\n+    return mErrors;\n+  }\n+\n+  /**\n+   * @param errors the errors\n+   * */\n+  public void setErrors(List<String> errors) {\n+    mErrors = errors;\n+  }\n+\n+  /**\n+   * @return the {@link BaseParameters}\n+   * */\n+  public BaseParameters getBaseParameters() {\n+    return mBaseParameters;\n+  }\n+\n+  /**\n+   * @param baseParameters the {@link BaseParameters}\n+   * */\n+  public void setBaseParameters(BaseParameters baseParameters) {\n+    mBaseParameters = baseParameters;\n+  }\n+\n+  /**\n+   * @return the task specific {@link WorkerBenchParameters}\n+   * */\n+  public WorkerBenchParameters getParameters() {\n+    return mParameters;\n+  }\n+\n+  /**\n+   * @param parameters the {@link WorkerBenchParameters}\n+   * */\n+  public void setParameters(WorkerBenchParameters parameters) {\n+    mParameters = parameters;\n+  }\n+\n+  /**\n+   * @return the {@link SpeedStat} for read speed\n+   * */\n+  public SpeedStat getReadSpeedStat() {\n+    return mReadSpeedStat;\n+  }\n+\n+  /**\n+   * @param stat the {@link SpeedStat} for read stats\n+   * */\n+  public void setReadSpeedStat(SpeedStat stat) {\n+    mReadSpeedStat = stat;\n+  }\n+\n+  /**\n+   * @return the {@link SpeedStat} for write speed\n+   * */\n+  public SpeedStat getWriteSpeedStat() {\n+    return mWriteSpeedStat;\n+  }\n+\n+  /**\n+   * @param stat the {@link SpeedStat} for write stats\n+   * */\n+  public void setWriteSpeedStat(SpeedStat stat) {\n+    mWriteSpeedStat = stat;\n+  }\n+\n+  /**\n+   * An object representation of all the statistics we need\n+   * from this I/O test.\n+   * */\n+  @JsonSerialize(using = StatSerializer.class)\n+  @JsonDeserialize(using = StatDeserializer.class)\n+  public static class SpeedStat implements JsonSerializable {\n+    public double mTotalDuration; // in second\n+    public int mTotalSize; // in MB\n+    public double mMaxSpeed; // in MB/s\n+    public double mMinSpeed; // in MB/s\n+    public double mAvgSpeed; // in MB/s\n+    public double mStdDev; // in MB/s\n+\n+    /**\n+     * An empty constructor.\n+     * */\n+    public SpeedStat() {}\n+\n+    @Override\n+    public String toString() {\n+      return String.format(\"{totalDuration=%ss, totalSize=%sMB, maxSpeed=%sMB/s, \"\n+                      + \"minSpeed=%sMB/s, \" + \"avgSpeed=%sMB/s, stdDev=%s}\",\n+              mTotalDuration, mTotalSize, mMaxSpeed, mMinSpeed, mAvgSpeed, mStdDev);\n+    }\n+  }\n+\n+  /**\n+   * A customized serializer for {@link SpeedStat}.\n+   * All the fields are attached with the unit.\n+   * */\n+  public static class StatSerializer extends StdSerializer<SpeedStat> {\n+    /**\n+     * An empty constructor.\n+     * */\n+    public StatSerializer() {\n+      super(SpeedStat.class);\n+    }\n+\n+    @Override\n+    public void serialize(SpeedStat value, JsonGenerator jgen, SerializerProvider provider)\n+            throws IOException {\n+      jgen.writeStartObject();\n+      jgen.writeStringField(\"totalDuration\", value.mTotalDuration + \"s\");\n+      jgen.writeStringField(\"totalSize\", value.mTotalSize + \"MB\");\n+      jgen.writeStringField(\"maxSpeed\", value.mMaxSpeed + \"MB/s\");\n+      jgen.writeStringField(\"minSpeed\", value.mMinSpeed + \"MB/s\");\n+      jgen.writeStringField(\"avgSpeed\", value.mAvgSpeed + \"MB/s\");\n+      jgen.writeNumberField(\"stdDev\", value.mStdDev);\n+      jgen.writeEndObject();\n+    }\n+  }\n+\n+  /**\n+   * A customized deserializer for {@link SpeedStat}.\n+   * */\n+  public static class StatDeserializer extends StdDeserializer<SpeedStat> {\n+    /**\n+     * An empty constructor.\n+     * */\n+    public StatDeserializer() {\n+      super(SpeedStat.class);\n+    }\n+\n+    private double speedToNumber(String speed) {\n+      return Double.parseDouble(speed.substring(0, speed.length() - \"MB/s\".length()));\n+    }\n+\n+    private double timeToNumber(String time) {\n+      return Double.parseDouble(time.substring(0, time.length() - \"s\".length()));\n+    }\n+\n+    private int sizeToNumber(String size) {\n+      return Integer.parseInt(size.substring(0, size.length() - \"MB\".length()));\n+    }\n+\n+    @Override\n+    public SpeedStat deserialize(JsonParser jp, DeserializationContext ctxt)\n+            throws IOException {\n+      JsonNode node = jp.getCodec().readTree(jp);\n+      SpeedStat stat = new SpeedStat();\n+      stat.mTotalDuration = timeToNumber(node.get(\"totalDuration\").asText());\n+      stat.mTotalSize = sizeToNumber(node.get(\"totalSize\").asText());\n+      stat.mMaxSpeed = speedToNumber(node.get(\"maxSpeed\").asText());\n+      stat.mMinSpeed = speedToNumber(node.get(\"minSpeed\").asText());\n+      stat.mAvgSpeed = speedToNumber(node.get(\"avgSpeed\").asText());\n+      stat.mStdDev = node.get(\"stdDev\").asDouble();\n+\n+      return stat;\n+    }\n+  }\n+\n+  /**\n+   * The points must be valid (duration not equal to 0).\n+   */\n+  private static SpeedStat calculateStat(List<IOTaskResult.Point> points) {\n+    SpeedStat result = new SpeedStat();\n+    if (points.size() == 0) {\n+      return result;\n+    }\n+\n+    double totalDuration = 0.0;\n+    int totalSize = 0;\n+    double[] speeds = new double[points.size()];\n+    double maxSpeed = 0.0;\n+    double minSpeed = Double.MAX_VALUE;\n+    int i = 0;\n+    for (IOTaskResult.Point p : points) {\n+      totalDuration += p.mDuration;\n+      totalSize += p.mDataSizeMB;\n+      double speed = p.mDataSizeMB / p.mDuration;\n+      maxSpeed = Math.max(maxSpeed, speed);\n+      minSpeed = Math.min(minSpeed, speed);\n+      speeds[i++] = p.mDataSizeMB / p.mDuration;\n+    }\n+    double avgSpeed = totalSize / totalDuration;\n+    double var = 0;\n+    for (double s : speeds) {\n+      var += (s - avgSpeed) * (s - avgSpeed);\n+    }\n+\n+    result.mTotalDuration = totalDuration;\n+    result.mTotalSize = totalSize;\n+    result.mMaxSpeed = maxSpeed;\n+    result.mMinSpeed = Double.compare(minSpeed, Double.MAX_VALUE) == 0 ? 0.0 : minSpeed;\n+    result.mAvgSpeed = avgSpeed;\n+    result.mStdDev = Math.sqrt(var);\n+\n+    return result;\n+  }\n+\n+  private void calculateStats() {\n+    List<IOTaskResult.Point> readPoints = mPoints.stream().filter((p) ->\n+            p.mMode == IOConfig.IOMode.READ && p.mDuration > 0)\n+            .collect(Collectors.toList());\n+    mReadSpeedStat = calculateStat(readPoints);\n+\n+    List<IOTaskResult.Point> writePoints = mPoints.stream().filter((p) ->\n+            p.mMode == IOConfig.IOMode.WRITE && p.mDuration > 0)\n+            .collect(Collectors.toList());\n+    mWriteSpeedStat = calculateStat(writePoints);\n+  }\n+\n+  @Override\n+  public GraphGenerator graphGenerator() {\n+    return new GraphGenerator();\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return String.format(\"IOTaskSummary: {Points=%s, Errors=%s}%n\",\n+            mPoints, mErrors);\n+  }\n+\n+  /**\n+   * A graph generator for the statistics collected.\n+   * */\n+  public static final class GraphGenerator extends alluxio.stress.GraphGenerator {\n+    @Override\n+    public List<Graph> generate(List<? extends Summary> results) {\n+      List<Graph> graphs = new ArrayList<>();\n+      // only examine MaxThroughputSummary\n+      List<IOTaskSummary> summaries =\n+              results.stream().map(x -> (IOTaskSummary) x).collect(Collectors.toList());\n+\n+      if (summaries.isEmpty()) {\n+        LOG.info(\"No summaries\");\n+        return graphs;\n+      }\n+\n+      // TODO(jiacheng): how to include params in this?\n+      // first() is the list of common field names, second() is the list of unique field names\n+      Pair<List<String>, List<String>> fieldNames = Parameters.partitionFieldNames(\n+              summaries.stream().map(x -> x.mParameters).collect(Collectors.toList()));\n+      System.out.format(\"FieldNames: %s%n\", fieldNames);\n+\n+      // Split up common description into 100 character chunks, for the sub title\n+      List<String> subTitle = new ArrayList<>(Splitter.fixedLength(100).splitToList(\n+              summaries.get(0).mParameters.getDescription(fieldNames.getFirst())));\n+      System.out.format(\"subtitle: %s%n\", subTitle);\n+\n+      for (IOTaskSummary summary : summaries) {\n+        String series = summary.mParameters.getDescription(fieldNames.getSecond());\n+        subTitle.add(series);\n+      }\n+\n+      BarGraph speedGraph = new BarGraph(\"Read/Write speed\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUwNDcwOA=="}, "originalCommit": {"oid": "ded15217e52f154ab8d35409041773d361beda73"}, "originalPosition": 330}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MjkwMTk1OnYy", "diffSide": "RIGHT", "path": "bin/alluxio", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwOTowODozNlrOGcU4qg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwOTowODozNlrOGcU4qg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM1NTQ5OA==", "bodyText": "removed one extra space", "url": "https://github.com/Alluxio/alluxio/pull/11422#discussion_r432355498", "createdAt": "2020-05-29T09:08:36Z", "author": {"login": "jiacheliu3"}, "path": "bin/alluxio", "diffHunk": "@@ -32,7 +32,9 @@ function printUsage {\n   echo -e \"                \\t NOTE: This command will stop the existing server and creates a new one!\"\n   echo -e \"  runMesosTest  \\t Test the Alluxio integration with Mesos. Try 'alluxio mesosTest -help' for more help.\"\n   echo -e \"                \\t NOTE: This command requires Mesos to be running and will stop any Alluxio servers that are currently running.\"\n-  echo -e \"  runUfsTests    \\t Test the integration between Alluxio and the target under filesystem. Try 'alluxio runUfsTests -help' for more help.\"\n+  echo -e \"  runUfsIOTest  \\t Test the Alluxio throughput to the UFS path. Try 'alluxio runUfsIOTest -help' for more help.\"\n+  echo -e \"                \\t NOTE: This command requrires a valid ufs path to write temporary files into.\"\n+  echo -e \"  runUfsTests   \\t Test the integration between Alluxio and the target under filesystem. Try 'alluxio runUfsTests -help' for more help.\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bcc19580442c79da96a8aa7b9d7adab6efb11ecc"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MjkwNjY3OnYy", "diffSide": "RIGHT", "path": "stress/shell/src/main/java/alluxio/stress/cli/UfsIOBench.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwOToxMDoxMFrOGcU7ng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwOToxMDoxMFrOGcU7ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM1NjI1NA==", "bodyText": "Any HDFS conf that will affect the IO throughput and I should add it here?", "url": "https://github.com/Alluxio/alluxio/pull/11422#discussion_r432356254", "createdAt": "2020-05-29T09:10:10Z", "author": {"login": "jiacheliu3"}, "path": "stress/shell/src/main/java/alluxio/stress/cli/UfsIOBench.java", "diffHunk": "@@ -0,0 +1,262 @@\n+package alluxio.stress.cli;\n+\n+import alluxio.client.job.JobGrpcClientUtils;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.InstancedConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.exception.status.UnimplementedException;\n+import alluxio.job.plan.PlanConfig;\n+import alluxio.job.wire.JobInfo;\n+import alluxio.stress.BaseParameters;\n+import alluxio.stress.TaskResult;\n+import alluxio.stress.job.IOConfig;\n+import alluxio.stress.job.StressBenchConfig;\n+import alluxio.stress.master.MasterBenchParameters;\n+import alluxio.stress.master.MasterBenchTaskResult;\n+import alluxio.stress.worker.IOTaskResult;\n+import alluxio.stress.worker.WorkerBenchParameters;\n+import alluxio.underfs.UfsDirectoryStatus;\n+import alluxio.underfs.UnderFileSystem;\n+import alluxio.underfs.UnderFileSystemConfiguration;\n+import alluxio.util.CommonUtils;\n+import alluxio.util.ConfigurationUtils;\n+import alluxio.util.FormatUtils;\n+import alluxio.util.ShellUtils;\n+import alluxio.util.executor.ExecutorServiceFactories;\n+import com.beust.jcommander.JCommander;\n+import com.beust.jcommander.ParametersDelegate;\n+import com.google.common.util.concurrent.RateLimiter;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.FSDataInputStream;\n+import org.apache.hadoop.fs.FSDataOutputStream;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.util.Time;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.BufferedOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.nio.file.Paths;\n+import java.util.*;\n+import java.util.concurrent.*;\n+import java.util.stream.Collectors;\n+\n+public class UfsIOBench extends Benchmark<IOTaskResult> {\n+    private static final Logger LOG = LoggerFactory.getLogger(UfsIOBench.class);\n+    private static final int BUFFER_SIZE = 1024 * 1024;\n+\n+    @ParametersDelegate\n+    private WorkerBenchParameters mParameters = new WorkerBenchParameters();\n+\n+    private final InstancedConfiguration mConf = InstancedConfiguration.defaults();\n+    private final HashMap<String, String> mHdfsConf = new HashMap<>();\n+\n+    @Override\n+    public PlanConfig generateJobConfig(String[] args) {\n+        // remove the cluster flag\n+        List<String> commandArgs =\n+                Arrays.stream(args).filter((s) -> !BaseParameters.CLUSTER_FLAG.equals(s))\n+                        .filter((s) -> !s.isEmpty()).collect(Collectors.toList());\n+\n+        commandArgs.addAll(mBaseParameters.mJavaOpts);\n+        String className = this.getClass().getCanonicalName();\n+        return new IOConfig(className, commandArgs, mParameters);\n+    }\n+\n+    @Override\n+    public IOTaskResult runLocal() throws Exception {\n+        ExecutorService pool =\n+                ExecutorServiceFactories.fixedThreadPool(\"bench-io-thread\", mParameters.mThreads).create();\n+\n+        IOTaskResult result = runIOBench(pool);\n+\n+        pool.shutdownNow();\n+        pool.awaitTermination(30, TimeUnit.SECONDS);\n+\n+        // Aggregate the task results\n+        return result;\n+    }\n+\n+    @Override\n+    public void prepare() throws Exception {\n+        // TODO(jiacheng): any HDFS conf to add?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bcc19580442c79da96a8aa7b9d7adab6efb11ecc"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MjkwODczOnYy", "diffSide": "LEFT", "path": "stress/shell/src/main/java/alluxio/stress/cli/Benchmark.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwOToxMDo0OFrOGcU83w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQwOToxMDo0OFrOGcU83w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM1NjU3NQ==", "bodyText": "Moved into util method", "url": "https://github.com/Alluxio/alluxio/pull/11422#discussion_r432356575", "createdAt": "2020-05-29T09:10:48Z", "author": {"login": "jiacheliu3"}, "path": "stress/shell/src/main/java/alluxio/stress/cli/Benchmark.java", "diffHunk": "@@ -91,23 +99,16 @@ public String run(String[] args) throws Exception {\n \n     if (mBaseParameters.mCluster) {\n       // run on job service\n-\n-      // remove the cluster flag\n-      List<String> commandArgs =\n-          Arrays.stream(args).filter((s) -> !BaseParameters.CLUSTER_FLAG.equals(s))\n-              .filter((s) -> !s.isEmpty()).collect(Collectors.toList());\n-\n-      commandArgs.addAll(mBaseParameters.mJavaOpts);\n-\n-      long jobId = JobGrpcClientUtils\n-          .run(new StressBenchConfig(className, commandArgs, 10000, mBaseParameters.mClusterLimit),\n-              0, conf);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bcc19580442c79da96a8aa7b9d7adab6efb11ecc"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NDY5NjMxOnYy", "diffSide": "RIGHT", "path": "stress/common/src/main/java/alluxio/stress/worker/WorkerBenchParameters.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQxNzo1NzoxN1rOGcmu2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxOToyNTozM1rOGeqJsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY0Nzg5OA==", "bodyText": "consider making this a String and using FormatUtils to parse a byte instead. Then users can specify 1k, 4k, 10M, 10g, etc instead. I think it is more user friendly.", "url": "https://github.com/Alluxio/alluxio/pull/11422#discussion_r432647898", "createdAt": "2020-05-29T17:57:17Z", "author": {"login": "ZacBlanco"}, "path": "stress/common/src/main/java/alluxio/stress/worker/WorkerBenchParameters.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.stress.worker;\n+\n+import alluxio.stress.Parameters;\n+\n+import com.beust.jcommander.Parameter;\n+\n+/**\n+ * Parameters used in the UFS I/O throughput test.\n+ * */\n+public class WorkerBenchParameters extends Parameters {\n+  @Parameter(names = {\"--threads\"}, description = \"the number of threads to use\")\n+  public int mThreads = 16;\n+\n+  @Parameter(names = {\"--io-size\"},\n+          description = \"size of data to write or read in total, in MB\")\n+  public int mDataSize = 4096;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d6dae419ca2535dd678f2098d29de0f6272a0c34"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk4Mjk3MA==", "bodyText": "This is a cool idea. However I think using an integer in the unit of MB makes the most sense for this test. It doesn't really mean much running an I/O with KB and i think using int gets us away from annoying decimal sizes. I lean towards keeping it this way. What do you think?", "url": "https://github.com/Alluxio/alluxio/pull/11422#discussion_r433982970", "createdAt": "2020-06-02T15:50:31Z", "author": {"login": "jiacheliu3"}, "path": "stress/common/src/main/java/alluxio/stress/worker/WorkerBenchParameters.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.stress.worker;\n+\n+import alluxio.stress.Parameters;\n+\n+import com.beust.jcommander.Parameter;\n+\n+/**\n+ * Parameters used in the UFS I/O throughput test.\n+ * */\n+public class WorkerBenchParameters extends Parameters {\n+  @Parameter(names = {\"--threads\"}, description = \"the number of threads to use\")\n+  public int mThreads = 16;\n+\n+  @Parameter(names = {\"--io-size\"},\n+          description = \"size of data to write or read in total, in MB\")\n+  public int mDataSize = 4096;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY0Nzg5OA=="}, "originalCommit": {"oid": "d6dae419ca2535dd678f2098d29de0f6272a0c34"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI0NDIwNw==", "bodyText": "I think Zac was saying to make this a string value, we can we specify like 4m. In the code, we can convert it to an int with FormatUtils.parseSpaceSize like https://github.com/Alluxio/alluxio/blob/master/stress/shell/src/main/java/alluxio/stress/cli/client/StressClientIOBench.java#L239", "url": "https://github.com/Alluxio/alluxio/pull/11422#discussion_r434244207", "createdAt": "2020-06-03T00:24:04Z", "author": {"login": "gpang"}, "path": "stress/common/src/main/java/alluxio/stress/worker/WorkerBenchParameters.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.stress.worker;\n+\n+import alluxio.stress.Parameters;\n+\n+import com.beust.jcommander.Parameter;\n+\n+/**\n+ * Parameters used in the UFS I/O throughput test.\n+ * */\n+public class WorkerBenchParameters extends Parameters {\n+  @Parameter(names = {\"--threads\"}, description = \"the number of threads to use\")\n+  public int mThreads = 16;\n+\n+  @Parameter(names = {\"--io-size\"},\n+          description = \"size of data to write or read in total, in MB\")\n+  public int mDataSize = 4096;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY0Nzg5OA=="}, "originalCommit": {"oid": "d6dae419ca2535dd678f2098d29de0f6272a0c34"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDgwMTA3Mg==", "bodyText": "Updated using formatted String now instead of int.", "url": "https://github.com/Alluxio/alluxio/pull/11422#discussion_r434801072", "createdAt": "2020-06-03T19:25:33Z", "author": {"login": "jiacheliu3"}, "path": "stress/common/src/main/java/alluxio/stress/worker/WorkerBenchParameters.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.stress.worker;\n+\n+import alluxio.stress.Parameters;\n+\n+import com.beust.jcommander.Parameter;\n+\n+/**\n+ * Parameters used in the UFS I/O throughput test.\n+ * */\n+public class WorkerBenchParameters extends Parameters {\n+  @Parameter(names = {\"--threads\"}, description = \"the number of threads to use\")\n+  public int mThreads = 16;\n+\n+  @Parameter(names = {\"--io-size\"},\n+          description = \"size of data to write or read in total, in MB\")\n+  public int mDataSize = 4096;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY0Nzg5OA=="}, "originalCommit": {"oid": "d6dae419ca2535dd678f2098d29de0f6272a0c34"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NTE1NTYwOnYy", "diffSide": "LEFT", "path": "job/server/src/main/java/alluxio/job/plan/stress/StressBenchDefinition.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQyMDozNjoyNFrOGcrTpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQyMDozNjoyNFrOGcrTpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjcyMjg1Mg==", "bodyText": "was this intentional?", "url": "https://github.com/Alluxio/alluxio/pull/11422#discussion_r432722852", "createdAt": "2020-05-29T20:36:24Z", "author": {"login": "gpang"}, "path": "job/server/src/main/java/alluxio/job/plan/stress/StressBenchDefinition.java", "diffHunk": "@@ -103,37 +93,13 @@ public String runTask(StressBenchConfig config, ArrayList<String> args,\n     }\n \n     command.addAll(args);\n-\n-    LOG.info(\"running command: \" + String.join(\" \", command));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d6dae419ca2535dd678f2098d29de0f6272a0c34"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NTE2ODAwOnYy", "diffSide": "RIGHT", "path": "job/server/src/main/java/alluxio/job/plan/io/IODefinition.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQyMDo0MTowMlrOGcrbPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxNTozNjoyM1rOGd3cLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjcyNDc5OA==", "bodyText": "why can't this just reuse the stress definition? It looks similar?", "url": "https://github.com/Alluxio/alluxio/pull/11422#discussion_r432724798", "createdAt": "2020-05-29T20:41:02Z", "author": {"login": "gpang"}, "path": "job/server/src/main/java/alluxio/job/plan/io/IODefinition.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.job.plan.io;\n+\n+import alluxio.collections.Pair;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.job.RunTaskContext;\n+import alluxio.job.SelectExecutorsContext;\n+import alluxio.job.plan.PlanDefinition;\n+import alluxio.job.util.BenchmarkJobUtils;\n+import alluxio.stress.BaseParameters;\n+import alluxio.stress.job.IOConfig;\n+import alluxio.util.ShellUtils;\n+import alluxio.wire.WorkerInfo;\n+\n+import com.google.common.collect.Sets;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * The definition for the UFS I/O throughput job, which generates concurrent streams to the UFS.\n+ *\n+ * {@link IOConfig} is the configuration class, each task takes a List<String> as a list of\n+ * command-line arguments to the benchmark command, and each task returns the string output.\n+ * The output will be serialized and deserialized using JSON, collected and merged.\n+ */\n+public class IODefinition implements PlanDefinition<IOConfig, ArrayList<String>, String> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d6dae419ca2535dd678f2098d29de0f6272a0c34"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkwMzExMw==", "bodyText": "Now it does look very similar since the StressBenchDefinition#selectExecutors selects k workers with the mClusterLimit parameter....", "url": "https://github.com/Alluxio/alluxio/pull/11422#discussion_r433903113", "createdAt": "2020-06-02T14:05:25Z", "author": {"login": "jiacheliu3"}, "path": "job/server/src/main/java/alluxio/job/plan/io/IODefinition.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.job.plan.io;\n+\n+import alluxio.collections.Pair;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.job.RunTaskContext;\n+import alluxio.job.SelectExecutorsContext;\n+import alluxio.job.plan.PlanDefinition;\n+import alluxio.job.util.BenchmarkJobUtils;\n+import alluxio.stress.BaseParameters;\n+import alluxio.stress.job.IOConfig;\n+import alluxio.util.ShellUtils;\n+import alluxio.wire.WorkerInfo;\n+\n+import com.google.common.collect.Sets;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * The definition for the UFS I/O throughput job, which generates concurrent streams to the UFS.\n+ *\n+ * {@link IOConfig} is the configuration class, each task takes a List<String> as a list of\n+ * command-line arguments to the benchmark command, and each task returns the string output.\n+ * The output will be serialized and deserialized using JSON, collected and merged.\n+ */\n+public class IODefinition implements PlanDefinition<IOConfig, ArrayList<String>, String> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjcyNDc5OA=="}, "originalCommit": {"oid": "d6dae419ca2535dd678f2098d29de0f6272a0c34"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk3MDIyMA==", "bodyText": "IODefinition and IOConfig are now removed. I think I misunderstood how to use StressBenchDefinition and StressBenchConfig...", "url": "https://github.com/Alluxio/alluxio/pull/11422#discussion_r433970220", "createdAt": "2020-06-02T15:36:23Z", "author": {"login": "jiacheliu3"}, "path": "job/server/src/main/java/alluxio/job/plan/io/IODefinition.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.job.plan.io;\n+\n+import alluxio.collections.Pair;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.job.RunTaskContext;\n+import alluxio.job.SelectExecutorsContext;\n+import alluxio.job.plan.PlanDefinition;\n+import alluxio.job.util.BenchmarkJobUtils;\n+import alluxio.stress.BaseParameters;\n+import alluxio.stress.job.IOConfig;\n+import alluxio.util.ShellUtils;\n+import alluxio.wire.WorkerInfo;\n+\n+import com.google.common.collect.Sets;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * The definition for the UFS I/O throughput job, which generates concurrent streams to the UFS.\n+ *\n+ * {@link IOConfig} is the configuration class, each task takes a List<String> as a list of\n+ * command-line arguments to the benchmark command, and each task returns the string output.\n+ * The output will be serialized and deserialized using JSON, collected and merged.\n+ */\n+public class IODefinition implements PlanDefinition<IOConfig, ArrayList<String>, String> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjcyNDc5OA=="}, "originalCommit": {"oid": "d6dae419ca2535dd678f2098d29de0f6272a0c34"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NTE4ODE1OnYy", "diffSide": "RIGHT", "path": "stress/shell/src/main/java/alluxio/stress/cli/Benchmark.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQyMDo0ODozN1rOGcrnzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQyMDo0ODozN1rOGcrnzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjcyODAxMg==", "bodyText": "Why is this debug now?", "url": "https://github.com/Alluxio/alluxio/pull/11422#discussion_r432728012", "createdAt": "2020-05-29T20:48:37Z", "author": {"login": "gpang"}, "path": "stress/shell/src/main/java/alluxio/stress/cli/Benchmark.java", "diffHunk": "@@ -126,8 +142,7 @@ public String run(String[] args) throws Exception {\n       command.addAll(Arrays.asList(args));\n       command.add(BaseParameters.IN_PROCESS_FLAG);\n       command.addAll(mBaseParameters.mJavaOpts);\n-\n-      LOG.info(\"running command: \" + String.join(\" \", command));\n+      LOG.debug(\"running command: \" + String.join(\" \", command));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d6dae419ca2535dd678f2098d29de0f6272a0c34"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NTIwNDc4OnYy", "diffSide": "RIGHT", "path": "stress/shell/src/main/java/alluxio/stress/cli/UfsIOBench.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQyMDo1NToxOFrOGcryGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOVQyMDo1NToxOFrOGcryGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjczMDY0OA==", "bodyText": "this test couldn't re-use the existing definition? It someone defeats the purpose with only using a small portion of the existing stress benchmark?", "url": "https://github.com/Alluxio/alluxio/pull/11422#discussion_r432730648", "createdAt": "2020-05-29T20:55:18Z", "author": {"login": "gpang"}, "path": "stress/shell/src/main/java/alluxio/stress/cli/UfsIOBench.java", "diffHunk": "@@ -0,0 +1,258 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.stress.cli;\n+\n+import alluxio.conf.InstancedConfiguration;\n+import alluxio.job.plan.PlanConfig;\n+import alluxio.stress.BaseParameters;\n+import alluxio.stress.job.IOConfig;\n+import alluxio.stress.worker.IOTaskResult;\n+import alluxio.stress.worker.WorkerBenchParameters;\n+import alluxio.underfs.UnderFileSystem;\n+import alluxio.underfs.UnderFileSystemConfiguration;\n+import alluxio.util.CommonUtils;\n+import alluxio.util.executor.ExecutorServiceFactories;\n+\n+import com.beust.jcommander.ParametersDelegate;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.BufferedOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Arrays;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * A benchmark tool measuring the IO to UFS.\n+ * */\n+public class UfsIOBench extends Benchmark<IOTaskResult> {\n+  private static final Logger LOG = LoggerFactory.getLogger(UfsIOBench.class);\n+  private static final int BUFFER_SIZE = 1024 * 1024;\n+\n+  @ParametersDelegate\n+  private WorkerBenchParameters mParameters = new WorkerBenchParameters();\n+\n+  private final InstancedConfiguration mConf = InstancedConfiguration.defaults();\n+  private final HashMap<String, String> mHdfsConf = new HashMap<>();\n+\n+  @Override\n+  public PlanConfig generateJobConfig(String[] args) {\n+    // remove the cluster flag\n+    List<String> commandArgs =\n+            Arrays.stream(args).filter((s) -> !BaseParameters.CLUSTER_FLAG.equals(s))\n+                    .filter((s) -> !s.isEmpty()).collect(Collectors.toList());\n+\n+    commandArgs.addAll(mBaseParameters.mJavaOpts);\n+    String className = this.getClass().getCanonicalName();\n+    return new IOConfig(className, commandArgs, mParameters);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d6dae419ca2535dd678f2098d29de0f6272a0c34"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwMzM2OTc1OnYy", "diffSide": "LEFT", "path": "stress/common/src/main/java/alluxio/stress/client/ClientIOTaskResult.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxNjowMDozNlrOGd42QA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxNjowMDozNlrOGd42QA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk5MzI4MA==", "bodyText": "I think generics can help remove some boilerplate code here", "url": "https://github.com/Alluxio/alluxio/pull/11422#discussion_r433993280", "createdAt": "2020-06-02T16:00:36Z", "author": {"login": "jiacheliu3"}, "path": "stress/common/src/main/java/alluxio/stress/client/ClientIOTaskResult.java", "diffHunk": "@@ -132,22 +132,17 @@ private long computeLastEndMs() {\n     return new Aggregator();\n   }\n \n-  private static final class Aggregator implements TaskResult.Aggregator {\n+  private static final class Aggregator implements TaskResult.Aggregator<ClientIOTaskResult> {\n     @Override\n-    public ClientIOTaskResult aggregate(Iterable<TaskResult> results) throws Exception {\n-      Iterator<TaskResult> it = results.iterator();\n+    public ClientIOTaskResult aggregate(Iterable<ClientIOTaskResult> results) throws Exception {\n+      Iterator<ClientIOTaskResult> it = results.iterator();\n       if (it.hasNext()) {\n-        TaskResult taskResult = it.next();\n+        ClientIOTaskResult taskResult = it.next();\n         if (it.hasNext()) {\n           throw new IOException(\n               \"ClientIO is a single node test, so multiple task results cannot be aggregated.\");\n         }\n-        if (!(taskResult instanceof ClientIOTaskResult)) {\n-          throw new IOException(\n-              \"TaskResult is not of type ClientIOTaskResult. class: \" + taskResult.getClass()\n-                  .getName());\n-        }\n-        return (ClientIOTaskResult) taskResult;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b7c2e488c3b59081d92a4eba2ddf22f85290551b"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNDgzNjE3OnYy", "diffSide": "RIGHT", "path": "bin/alluxio", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQyMzozNDoyNFrOGeHWCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQyMzozNDoyNFrOGeHWCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDIzMDc5Mg==", "bodyText": "nit: typo \"requrires\"", "url": "https://github.com/Alluxio/alluxio/pull/11422#discussion_r434230792", "createdAt": "2020-06-02T23:34:24Z", "author": {"login": "madanadit"}, "path": "bin/alluxio", "diffHunk": "@@ -32,7 +32,9 @@ function printUsage {\n   echo -e \"                \\t NOTE: This command will stop the existing server and creates a new one!\"\n   echo -e \"  runMesosTest  \\t Test the Alluxio integration with Mesos. Try 'alluxio mesosTest -help' for more help.\"\n   echo -e \"                \\t NOTE: This command requires Mesos to be running and will stop any Alluxio servers that are currently running.\"\n-  echo -e \"  runUfsTests    \\t Test the integration between Alluxio and the target under filesystem. Try 'alluxio runUfsTests -help' for more help.\"\n+  echo -e \"  runUfsIOTest  \\t Test the Alluxio throughput to the UFS path. Try 'alluxio runUfsIOTest -help' for more help.\"\n+  echo -e \"                \\t NOTE: This command requrires a valid ufs path to write temporary files into.\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a62658ff9d4bf25734acf786753074b1b18415b5"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNDkyNTczOnYy", "diffSide": "RIGHT", "path": "stress/common/src/main/java/alluxio/stress/worker/WorkerBenchParameters.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwMDoyNTo0NFrOGeIMKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwMDoyNTo0NFrOGeIMKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI0NDY0OQ==", "bodyText": "I think this should be renamed to something like UfsIOParameters? The ony test that uses this class is a test called UfsIOBench.", "url": "https://github.com/Alluxio/alluxio/pull/11422#discussion_r434244649", "createdAt": "2020-06-03T00:25:44Z", "author": {"login": "gpang"}, "path": "stress/common/src/main/java/alluxio/stress/worker/WorkerBenchParameters.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.stress.worker;\n+\n+import alluxio.stress.Parameters;\n+\n+import com.beust.jcommander.Parameter;\n+\n+/**\n+ * Parameters used in the UFS I/O throughput test.\n+ * */\n+public class WorkerBenchParameters extends Parameters {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a62658ff9d4bf25734acf786753074b1b18415b5"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNDkyOTgwOnYy", "diffSide": "RIGHT", "path": "stress/shell/src/main/java/alluxio/stress/cli/UfsIOBench.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwMDoyODoyMVrOGeIOtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNzoyOTo0NVrOGemNzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI0NTMwMw==", "bodyText": "Can you not reuse the clusterLimit parameter already available in base parameters? Also, the wait time should be non-zero, and probably be at least 5 or 10 seconds, so the distributed task can start on time.\nI feel like this generateJobConfig method doesn't need to be overridden.", "url": "https://github.com/Alluxio/alluxio/pull/11422#discussion_r434245303", "createdAt": "2020-06-03T00:28:21Z", "author": {"login": "gpang"}, "path": "stress/shell/src/main/java/alluxio/stress/cli/UfsIOBench.java", "diffHunk": "@@ -0,0 +1,260 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.stress.cli;\n+\n+import alluxio.conf.InstancedConfiguration;\n+import alluxio.job.plan.PlanConfig;\n+import alluxio.stress.BaseParameters;\n+import alluxio.stress.job.StressBenchConfig;\n+import alluxio.stress.worker.IOTaskResult;\n+import alluxio.stress.worker.WorkerBenchParameters;\n+import alluxio.underfs.UnderFileSystem;\n+import alluxio.underfs.UnderFileSystemConfiguration;\n+import alluxio.util.CommonUtils;\n+import alluxio.util.executor.ExecutorServiceFactories;\n+\n+import com.beust.jcommander.ParametersDelegate;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.BufferedOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Arrays;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * A benchmark tool measuring the IO to UFS.\n+ * */\n+public class UfsIOBench extends Benchmark<IOTaskResult> {\n+  private static final Logger LOG = LoggerFactory.getLogger(UfsIOBench.class);\n+  private static final int BUFFER_SIZE = 1024 * 1024;\n+\n+  @ParametersDelegate\n+  private WorkerBenchParameters mParameters = new WorkerBenchParameters();\n+\n+  private final InstancedConfiguration mConf = InstancedConfiguration.defaults();\n+  private final HashMap<String, String> mHdfsConf = new HashMap<>();\n+\n+  @Override\n+  public PlanConfig generateJobConfig(String[] args) {\n+    // remove the cluster flag\n+    List<String> commandArgs =\n+            Arrays.stream(args).filter((s) -> !BaseParameters.CLUSTER_FLAG.equals(s))\n+                    .filter((s) -> !s.isEmpty()).collect(Collectors.toList());\n+\n+    commandArgs.addAll(mBaseParameters.mJavaOpts);\n+    String className = this.getClass().getCanonicalName();\n+    return new StressBenchConfig(className, commandArgs, 0, mParameters.mWorkerNum);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a62658ff9d4bf25734acf786753074b1b18415b5"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDczNjU4OQ==", "bodyText": "You are right. Keeping this override is an overlook. Removed.\nActually in my test I recorded the duration in each read/write operation so this start time is not used anywhere.", "url": "https://github.com/Alluxio/alluxio/pull/11422#discussion_r434736589", "createdAt": "2020-06-03T17:29:45Z", "author": {"login": "jiacheliu3"}, "path": "stress/shell/src/main/java/alluxio/stress/cli/UfsIOBench.java", "diffHunk": "@@ -0,0 +1,260 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.stress.cli;\n+\n+import alluxio.conf.InstancedConfiguration;\n+import alluxio.job.plan.PlanConfig;\n+import alluxio.stress.BaseParameters;\n+import alluxio.stress.job.StressBenchConfig;\n+import alluxio.stress.worker.IOTaskResult;\n+import alluxio.stress.worker.WorkerBenchParameters;\n+import alluxio.underfs.UnderFileSystem;\n+import alluxio.underfs.UnderFileSystemConfiguration;\n+import alluxio.util.CommonUtils;\n+import alluxio.util.executor.ExecutorServiceFactories;\n+\n+import com.beust.jcommander.ParametersDelegate;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.BufferedOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Arrays;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * A benchmark tool measuring the IO to UFS.\n+ * */\n+public class UfsIOBench extends Benchmark<IOTaskResult> {\n+  private static final Logger LOG = LoggerFactory.getLogger(UfsIOBench.class);\n+  private static final int BUFFER_SIZE = 1024 * 1024;\n+\n+  @ParametersDelegate\n+  private WorkerBenchParameters mParameters = new WorkerBenchParameters();\n+\n+  private final InstancedConfiguration mConf = InstancedConfiguration.defaults();\n+  private final HashMap<String, String> mHdfsConf = new HashMap<>();\n+\n+  @Override\n+  public PlanConfig generateJobConfig(String[] args) {\n+    // remove the cluster flag\n+    List<String> commandArgs =\n+            Arrays.stream(args).filter((s) -> !BaseParameters.CLUSTER_FLAG.equals(s))\n+                    .filter((s) -> !s.isEmpty()).collect(Collectors.toList());\n+\n+    commandArgs.addAll(mBaseParameters.mJavaOpts);\n+    String className = this.getClass().getCanonicalName();\n+    return new StressBenchConfig(className, commandArgs, 0, mParameters.mWorkerNum);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDI0NTMwMw=="}, "originalCommit": {"oid": "a62658ff9d4bf25734acf786753074b1b18415b5"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMTk4ODA1OnYy", "diffSide": "RIGHT", "path": "stress/common/src/main/java/alluxio/stress/worker/IOTaskSummary.java", "isResolved": true, "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQxNjoxNjowM1rOGfNovw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQxNjowNjozMFrOGf0iLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM4MjQ2Mw==", "bodyText": "Why do serializers and deserializers need to be used? Jackson can just ser/de the classes, with getters/setters, or with public fields, right? That is how all the other results and parameter classes work.", "url": "https://github.com/Alluxio/alluxio/pull/11422#discussion_r435382463", "createdAt": "2020-06-04T16:16:03Z", "author": {"login": "gpang"}, "path": "stress/common/src/main/java/alluxio/stress/worker/IOTaskSummary.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.stress.worker;\n+\n+import alluxio.collections.Pair;\n+import alluxio.stress.BaseParameters;\n+import alluxio.stress.JsonSerializable;\n+import alluxio.stress.Parameters;\n+import alluxio.stress.Summary;\n+import alluxio.stress.graph.BarGraph;\n+import alluxio.stress.graph.Graph;\n+import alluxio.util.FormatUtils;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.fasterxml.jackson.databind.deser.std.StdDeserializer;\n+import com.fasterxml.jackson.databind.ser.std.StdSerializer;\n+import com.google.common.base.Splitter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The summary for the UFS I/O throughput test.\n+ */\n+public class IOTaskSummary implements Summary {\n+  private static final Logger LOG = LoggerFactory.getLogger(IOTaskSummary.class);\n+  private List<IOTaskResult.Point> mPoints;\n+  private List<String> mErrors;\n+  private BaseParameters mBaseParameters;\n+  private UfsIOParameters mParameters;\n+  private SpeedStat mReadSpeedStat;\n+  private SpeedStat mWriteSpeedStat;\n+\n+  /**\n+   * Used for deserialization.\n+   * */\n+  @JsonCreator\n+  public IOTaskSummary() {}\n+\n+  /**\n+   * @param result the {@link IOTaskResult} to summarize\n+   * */\n+  public IOTaskSummary(IOTaskResult result) {\n+    mPoints = new ArrayList<>(result.getPoints());\n+    mErrors = new ArrayList<>(result.getErrors());\n+    mBaseParameters = result.getBaseParameters();\n+    mParameters = result.getParameters();\n+    calculateStats();\n+  }\n+\n+  /**\n+   * @return the points recorded\n+   * */\n+  public List<IOTaskResult.Point> getPoints() {\n+    return mPoints;\n+  }\n+\n+  /**\n+   * @param points the data points\n+   * */\n+  public void setPoints(List<IOTaskResult.Point> points) {\n+    mPoints = points;\n+  }\n+\n+  /**\n+   * @return the errors recorded\n+   * */\n+  public List<String> getErrors() {\n+    return mErrors;\n+  }\n+\n+  /**\n+   * @param errors the errors\n+   * */\n+  public void setErrors(List<String> errors) {\n+    mErrors = errors;\n+  }\n+\n+  /**\n+   * @return the {@link BaseParameters}\n+   * */\n+  public BaseParameters getBaseParameters() {\n+    return mBaseParameters;\n+  }\n+\n+  /**\n+   * @param baseParameters the {@link BaseParameters}\n+   * */\n+  public void setBaseParameters(BaseParameters baseParameters) {\n+    mBaseParameters = baseParameters;\n+  }\n+\n+  /**\n+   * @return the task specific {@link UfsIOParameters}\n+   * */\n+  public UfsIOParameters getParameters() {\n+    return mParameters;\n+  }\n+\n+  /**\n+   * @param parameters the {@link UfsIOParameters}\n+   * */\n+  public void setParameters(UfsIOParameters parameters) {\n+    mParameters = parameters;\n+  }\n+\n+  /**\n+   * @return the {@link SpeedStat} for read speed\n+   * */\n+  public SpeedStat getReadSpeedStat() {\n+    return mReadSpeedStat;\n+  }\n+\n+  /**\n+   * @param stat the {@link SpeedStat} for read stats\n+   * */\n+  public void setReadSpeedStat(SpeedStat stat) {\n+    mReadSpeedStat = stat;\n+  }\n+\n+  /**\n+   * @return the {@link SpeedStat} for write speed\n+   * */\n+  public SpeedStat getWriteSpeedStat() {\n+    return mWriteSpeedStat;\n+  }\n+\n+  /**\n+   * @param stat the {@link SpeedStat} for write stats\n+   * */\n+  public void setWriteSpeedStat(SpeedStat stat) {\n+    mWriteSpeedStat = stat;\n+  }\n+\n+  /**\n+   * An object representation of all the statistics we need\n+   * from this I/O test.\n+   * */\n+  @JsonSerialize(using = StatSerializer.class)\n+  @JsonDeserialize(using = StatDeserializer.class)\n+  public static class SpeedStat implements JsonSerializable {\n+    public double mTotalDuration; // in second\n+    public long mTotalSize; // in Bytes\n+    public double mMaxSpeed; // in MB/s\n+    public double mMinSpeed; // in MB/s\n+    public double mAvgSpeed; // in MB/s\n+    public double mStdDev; // in MB/s\n+\n+    /**\n+     * An empty constructor.\n+     * */\n+    public SpeedStat() {}\n+\n+    @Override\n+    public String toString() {\n+      return String.format(\"{totalDuration=%ss, totalSize=%s, maxSpeed=%sMB/s, \"\n+                      + \"minSpeed=%sMB/s, \" + \"avgSpeed=%sMB/s, stdDev=%s}\",\n+              mTotalDuration, FormatUtils.getSizeFromBytes(mTotalSize),\n+              mMaxSpeed, mMinSpeed, mAvgSpeed, mStdDev);\n+    }\n+  }\n+\n+  /**\n+   * A customized serializer for {@link SpeedStat}.\n+   * All the fields are attached with the unit.\n+   * */\n+  public static class StatSerializer extends StdSerializer<SpeedStat> {\n+    private static final long serialVersionUID = -5198319303173120740L;\n+\n+    /**\n+     * An empty constructor.\n+     * */\n+    public StatSerializer() {\n+      super(SpeedStat.class);\n+    }\n+\n+    @Override\n+    public void serialize(SpeedStat value, JsonGenerator jgen, SerializerProvider provider)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bbb80c3c1cd2e026d411830d0033e9d1b6f535d3"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYzNzM4MA==", "bodyText": "I provided customized ser/de because I need some better formatting on the field, so both the intermediate and final results are much more human readable.\nBefore formatting:\n{\"totalDuration\":\"2.0\",\"totalSize\":\"415236096\",\"maxSpeed\":\"200.0\",\"minSpeed\":\"196.0\",\"avgSpeed\":\"198.0\",\"stdDev\":2.8284271247461903}\n\nAfter  formatting:\n{\"totalDuration\":\"2.0s\",\"totalSize\":\"396.00MB\",\"maxSpeed\":\"200.0MB/s\",\"minSpeed\":\"196.0MB/s\",\"avgSpeed\":\"198.0MB/s\",\"stdDev\":2.8284271247461903}", "url": "https://github.com/Alluxio/alluxio/pull/11422#discussion_r435637380", "createdAt": "2020-06-05T01:07:45Z", "author": {"login": "jiacheliu3"}, "path": "stress/common/src/main/java/alluxio/stress/worker/IOTaskSummary.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.stress.worker;\n+\n+import alluxio.collections.Pair;\n+import alluxio.stress.BaseParameters;\n+import alluxio.stress.JsonSerializable;\n+import alluxio.stress.Parameters;\n+import alluxio.stress.Summary;\n+import alluxio.stress.graph.BarGraph;\n+import alluxio.stress.graph.Graph;\n+import alluxio.util.FormatUtils;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.fasterxml.jackson.databind.deser.std.StdDeserializer;\n+import com.fasterxml.jackson.databind.ser.std.StdSerializer;\n+import com.google.common.base.Splitter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The summary for the UFS I/O throughput test.\n+ */\n+public class IOTaskSummary implements Summary {\n+  private static final Logger LOG = LoggerFactory.getLogger(IOTaskSummary.class);\n+  private List<IOTaskResult.Point> mPoints;\n+  private List<String> mErrors;\n+  private BaseParameters mBaseParameters;\n+  private UfsIOParameters mParameters;\n+  private SpeedStat mReadSpeedStat;\n+  private SpeedStat mWriteSpeedStat;\n+\n+  /**\n+   * Used for deserialization.\n+   * */\n+  @JsonCreator\n+  public IOTaskSummary() {}\n+\n+  /**\n+   * @param result the {@link IOTaskResult} to summarize\n+   * */\n+  public IOTaskSummary(IOTaskResult result) {\n+    mPoints = new ArrayList<>(result.getPoints());\n+    mErrors = new ArrayList<>(result.getErrors());\n+    mBaseParameters = result.getBaseParameters();\n+    mParameters = result.getParameters();\n+    calculateStats();\n+  }\n+\n+  /**\n+   * @return the points recorded\n+   * */\n+  public List<IOTaskResult.Point> getPoints() {\n+    return mPoints;\n+  }\n+\n+  /**\n+   * @param points the data points\n+   * */\n+  public void setPoints(List<IOTaskResult.Point> points) {\n+    mPoints = points;\n+  }\n+\n+  /**\n+   * @return the errors recorded\n+   * */\n+  public List<String> getErrors() {\n+    return mErrors;\n+  }\n+\n+  /**\n+   * @param errors the errors\n+   * */\n+  public void setErrors(List<String> errors) {\n+    mErrors = errors;\n+  }\n+\n+  /**\n+   * @return the {@link BaseParameters}\n+   * */\n+  public BaseParameters getBaseParameters() {\n+    return mBaseParameters;\n+  }\n+\n+  /**\n+   * @param baseParameters the {@link BaseParameters}\n+   * */\n+  public void setBaseParameters(BaseParameters baseParameters) {\n+    mBaseParameters = baseParameters;\n+  }\n+\n+  /**\n+   * @return the task specific {@link UfsIOParameters}\n+   * */\n+  public UfsIOParameters getParameters() {\n+    return mParameters;\n+  }\n+\n+  /**\n+   * @param parameters the {@link UfsIOParameters}\n+   * */\n+  public void setParameters(UfsIOParameters parameters) {\n+    mParameters = parameters;\n+  }\n+\n+  /**\n+   * @return the {@link SpeedStat} for read speed\n+   * */\n+  public SpeedStat getReadSpeedStat() {\n+    return mReadSpeedStat;\n+  }\n+\n+  /**\n+   * @param stat the {@link SpeedStat} for read stats\n+   * */\n+  public void setReadSpeedStat(SpeedStat stat) {\n+    mReadSpeedStat = stat;\n+  }\n+\n+  /**\n+   * @return the {@link SpeedStat} for write speed\n+   * */\n+  public SpeedStat getWriteSpeedStat() {\n+    return mWriteSpeedStat;\n+  }\n+\n+  /**\n+   * @param stat the {@link SpeedStat} for write stats\n+   * */\n+  public void setWriteSpeedStat(SpeedStat stat) {\n+    mWriteSpeedStat = stat;\n+  }\n+\n+  /**\n+   * An object representation of all the statistics we need\n+   * from this I/O test.\n+   * */\n+  @JsonSerialize(using = StatSerializer.class)\n+  @JsonDeserialize(using = StatDeserializer.class)\n+  public static class SpeedStat implements JsonSerializable {\n+    public double mTotalDuration; // in second\n+    public long mTotalSize; // in Bytes\n+    public double mMaxSpeed; // in MB/s\n+    public double mMinSpeed; // in MB/s\n+    public double mAvgSpeed; // in MB/s\n+    public double mStdDev; // in MB/s\n+\n+    /**\n+     * An empty constructor.\n+     * */\n+    public SpeedStat() {}\n+\n+    @Override\n+    public String toString() {\n+      return String.format(\"{totalDuration=%ss, totalSize=%s, maxSpeed=%sMB/s, \"\n+                      + \"minSpeed=%sMB/s, \" + \"avgSpeed=%sMB/s, stdDev=%s}\",\n+              mTotalDuration, FormatUtils.getSizeFromBytes(mTotalSize),\n+              mMaxSpeed, mMinSpeed, mAvgSpeed, mStdDev);\n+    }\n+  }\n+\n+  /**\n+   * A customized serializer for {@link SpeedStat}.\n+   * All the fields are attached with the unit.\n+   * */\n+  public static class StatSerializer extends StdSerializer<SpeedStat> {\n+    private static final long serialVersionUID = -5198319303173120740L;\n+\n+    /**\n+     * An empty constructor.\n+     * */\n+    public StatSerializer() {\n+      super(SpeedStat.class);\n+    }\n+\n+    @Override\n+    public void serialize(SpeedStat value, JsonGenerator jgen, SerializerProvider provider)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM4MjQ2Mw=="}, "originalCommit": {"oid": "bbb80c3c1cd2e026d411830d0033e9d1b6f535d3"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYzOTU0MQ==", "bodyText": "I see, so is the json intended to be the final human-readable output? Typically, these json files are fed into generate, to get the human-readable output.", "url": "https://github.com/Alluxio/alluxio/pull/11422#discussion_r435639541", "createdAt": "2020-06-05T01:17:25Z", "author": {"login": "gpang"}, "path": "stress/common/src/main/java/alluxio/stress/worker/IOTaskSummary.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.stress.worker;\n+\n+import alluxio.collections.Pair;\n+import alluxio.stress.BaseParameters;\n+import alluxio.stress.JsonSerializable;\n+import alluxio.stress.Parameters;\n+import alluxio.stress.Summary;\n+import alluxio.stress.graph.BarGraph;\n+import alluxio.stress.graph.Graph;\n+import alluxio.util.FormatUtils;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.fasterxml.jackson.databind.deser.std.StdDeserializer;\n+import com.fasterxml.jackson.databind.ser.std.StdSerializer;\n+import com.google.common.base.Splitter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The summary for the UFS I/O throughput test.\n+ */\n+public class IOTaskSummary implements Summary {\n+  private static final Logger LOG = LoggerFactory.getLogger(IOTaskSummary.class);\n+  private List<IOTaskResult.Point> mPoints;\n+  private List<String> mErrors;\n+  private BaseParameters mBaseParameters;\n+  private UfsIOParameters mParameters;\n+  private SpeedStat mReadSpeedStat;\n+  private SpeedStat mWriteSpeedStat;\n+\n+  /**\n+   * Used for deserialization.\n+   * */\n+  @JsonCreator\n+  public IOTaskSummary() {}\n+\n+  /**\n+   * @param result the {@link IOTaskResult} to summarize\n+   * */\n+  public IOTaskSummary(IOTaskResult result) {\n+    mPoints = new ArrayList<>(result.getPoints());\n+    mErrors = new ArrayList<>(result.getErrors());\n+    mBaseParameters = result.getBaseParameters();\n+    mParameters = result.getParameters();\n+    calculateStats();\n+  }\n+\n+  /**\n+   * @return the points recorded\n+   * */\n+  public List<IOTaskResult.Point> getPoints() {\n+    return mPoints;\n+  }\n+\n+  /**\n+   * @param points the data points\n+   * */\n+  public void setPoints(List<IOTaskResult.Point> points) {\n+    mPoints = points;\n+  }\n+\n+  /**\n+   * @return the errors recorded\n+   * */\n+  public List<String> getErrors() {\n+    return mErrors;\n+  }\n+\n+  /**\n+   * @param errors the errors\n+   * */\n+  public void setErrors(List<String> errors) {\n+    mErrors = errors;\n+  }\n+\n+  /**\n+   * @return the {@link BaseParameters}\n+   * */\n+  public BaseParameters getBaseParameters() {\n+    return mBaseParameters;\n+  }\n+\n+  /**\n+   * @param baseParameters the {@link BaseParameters}\n+   * */\n+  public void setBaseParameters(BaseParameters baseParameters) {\n+    mBaseParameters = baseParameters;\n+  }\n+\n+  /**\n+   * @return the task specific {@link UfsIOParameters}\n+   * */\n+  public UfsIOParameters getParameters() {\n+    return mParameters;\n+  }\n+\n+  /**\n+   * @param parameters the {@link UfsIOParameters}\n+   * */\n+  public void setParameters(UfsIOParameters parameters) {\n+    mParameters = parameters;\n+  }\n+\n+  /**\n+   * @return the {@link SpeedStat} for read speed\n+   * */\n+  public SpeedStat getReadSpeedStat() {\n+    return mReadSpeedStat;\n+  }\n+\n+  /**\n+   * @param stat the {@link SpeedStat} for read stats\n+   * */\n+  public void setReadSpeedStat(SpeedStat stat) {\n+    mReadSpeedStat = stat;\n+  }\n+\n+  /**\n+   * @return the {@link SpeedStat} for write speed\n+   * */\n+  public SpeedStat getWriteSpeedStat() {\n+    return mWriteSpeedStat;\n+  }\n+\n+  /**\n+   * @param stat the {@link SpeedStat} for write stats\n+   * */\n+  public void setWriteSpeedStat(SpeedStat stat) {\n+    mWriteSpeedStat = stat;\n+  }\n+\n+  /**\n+   * An object representation of all the statistics we need\n+   * from this I/O test.\n+   * */\n+  @JsonSerialize(using = StatSerializer.class)\n+  @JsonDeserialize(using = StatDeserializer.class)\n+  public static class SpeedStat implements JsonSerializable {\n+    public double mTotalDuration; // in second\n+    public long mTotalSize; // in Bytes\n+    public double mMaxSpeed; // in MB/s\n+    public double mMinSpeed; // in MB/s\n+    public double mAvgSpeed; // in MB/s\n+    public double mStdDev; // in MB/s\n+\n+    /**\n+     * An empty constructor.\n+     * */\n+    public SpeedStat() {}\n+\n+    @Override\n+    public String toString() {\n+      return String.format(\"{totalDuration=%ss, totalSize=%s, maxSpeed=%sMB/s, \"\n+                      + \"minSpeed=%sMB/s, \" + \"avgSpeed=%sMB/s, stdDev=%s}\",\n+              mTotalDuration, FormatUtils.getSizeFromBytes(mTotalSize),\n+              mMaxSpeed, mMinSpeed, mAvgSpeed, mStdDev);\n+    }\n+  }\n+\n+  /**\n+   * A customized serializer for {@link SpeedStat}.\n+   * All the fields are attached with the unit.\n+   * */\n+  public static class StatSerializer extends StdSerializer<SpeedStat> {\n+    private static final long serialVersionUID = -5198319303173120740L;\n+\n+    /**\n+     * An empty constructor.\n+     * */\n+    public StatSerializer() {\n+      super(SpeedStat.class);\n+    }\n+\n+    @Override\n+    public void serialize(SpeedStat value, JsonGenerator jgen, SerializerProvider provider)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM4MjQ2Mw=="}, "originalCommit": {"oid": "bbb80c3c1cd2e026d411830d0033e9d1b6f535d3"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY0MjkyNQ==", "bodyText": "Well this json will primarily be read by jason's new UI, which will render a graph. So it doesn't need to be human readable; the cli interface is secondary to the web ui", "url": "https://github.com/Alluxio/alluxio/pull/11422#discussion_r435642925", "createdAt": "2020-06-05T01:32:02Z", "author": {"login": "madanadit"}, "path": "stress/common/src/main/java/alluxio/stress/worker/IOTaskSummary.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.stress.worker;\n+\n+import alluxio.collections.Pair;\n+import alluxio.stress.BaseParameters;\n+import alluxio.stress.JsonSerializable;\n+import alluxio.stress.Parameters;\n+import alluxio.stress.Summary;\n+import alluxio.stress.graph.BarGraph;\n+import alluxio.stress.graph.Graph;\n+import alluxio.util.FormatUtils;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.fasterxml.jackson.databind.deser.std.StdDeserializer;\n+import com.fasterxml.jackson.databind.ser.std.StdSerializer;\n+import com.google.common.base.Splitter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The summary for the UFS I/O throughput test.\n+ */\n+public class IOTaskSummary implements Summary {\n+  private static final Logger LOG = LoggerFactory.getLogger(IOTaskSummary.class);\n+  private List<IOTaskResult.Point> mPoints;\n+  private List<String> mErrors;\n+  private BaseParameters mBaseParameters;\n+  private UfsIOParameters mParameters;\n+  private SpeedStat mReadSpeedStat;\n+  private SpeedStat mWriteSpeedStat;\n+\n+  /**\n+   * Used for deserialization.\n+   * */\n+  @JsonCreator\n+  public IOTaskSummary() {}\n+\n+  /**\n+   * @param result the {@link IOTaskResult} to summarize\n+   * */\n+  public IOTaskSummary(IOTaskResult result) {\n+    mPoints = new ArrayList<>(result.getPoints());\n+    mErrors = new ArrayList<>(result.getErrors());\n+    mBaseParameters = result.getBaseParameters();\n+    mParameters = result.getParameters();\n+    calculateStats();\n+  }\n+\n+  /**\n+   * @return the points recorded\n+   * */\n+  public List<IOTaskResult.Point> getPoints() {\n+    return mPoints;\n+  }\n+\n+  /**\n+   * @param points the data points\n+   * */\n+  public void setPoints(List<IOTaskResult.Point> points) {\n+    mPoints = points;\n+  }\n+\n+  /**\n+   * @return the errors recorded\n+   * */\n+  public List<String> getErrors() {\n+    return mErrors;\n+  }\n+\n+  /**\n+   * @param errors the errors\n+   * */\n+  public void setErrors(List<String> errors) {\n+    mErrors = errors;\n+  }\n+\n+  /**\n+   * @return the {@link BaseParameters}\n+   * */\n+  public BaseParameters getBaseParameters() {\n+    return mBaseParameters;\n+  }\n+\n+  /**\n+   * @param baseParameters the {@link BaseParameters}\n+   * */\n+  public void setBaseParameters(BaseParameters baseParameters) {\n+    mBaseParameters = baseParameters;\n+  }\n+\n+  /**\n+   * @return the task specific {@link UfsIOParameters}\n+   * */\n+  public UfsIOParameters getParameters() {\n+    return mParameters;\n+  }\n+\n+  /**\n+   * @param parameters the {@link UfsIOParameters}\n+   * */\n+  public void setParameters(UfsIOParameters parameters) {\n+    mParameters = parameters;\n+  }\n+\n+  /**\n+   * @return the {@link SpeedStat} for read speed\n+   * */\n+  public SpeedStat getReadSpeedStat() {\n+    return mReadSpeedStat;\n+  }\n+\n+  /**\n+   * @param stat the {@link SpeedStat} for read stats\n+   * */\n+  public void setReadSpeedStat(SpeedStat stat) {\n+    mReadSpeedStat = stat;\n+  }\n+\n+  /**\n+   * @return the {@link SpeedStat} for write speed\n+   * */\n+  public SpeedStat getWriteSpeedStat() {\n+    return mWriteSpeedStat;\n+  }\n+\n+  /**\n+   * @param stat the {@link SpeedStat} for write stats\n+   * */\n+  public void setWriteSpeedStat(SpeedStat stat) {\n+    mWriteSpeedStat = stat;\n+  }\n+\n+  /**\n+   * An object representation of all the statistics we need\n+   * from this I/O test.\n+   * */\n+  @JsonSerialize(using = StatSerializer.class)\n+  @JsonDeserialize(using = StatDeserializer.class)\n+  public static class SpeedStat implements JsonSerializable {\n+    public double mTotalDuration; // in second\n+    public long mTotalSize; // in Bytes\n+    public double mMaxSpeed; // in MB/s\n+    public double mMinSpeed; // in MB/s\n+    public double mAvgSpeed; // in MB/s\n+    public double mStdDev; // in MB/s\n+\n+    /**\n+     * An empty constructor.\n+     * */\n+    public SpeedStat() {}\n+\n+    @Override\n+    public String toString() {\n+      return String.format(\"{totalDuration=%ss, totalSize=%s, maxSpeed=%sMB/s, \"\n+                      + \"minSpeed=%sMB/s, \" + \"avgSpeed=%sMB/s, stdDev=%s}\",\n+              mTotalDuration, FormatUtils.getSizeFromBytes(mTotalSize),\n+              mMaxSpeed, mMinSpeed, mAvgSpeed, mStdDev);\n+    }\n+  }\n+\n+  /**\n+   * A customized serializer for {@link SpeedStat}.\n+   * All the fields are attached with the unit.\n+   * */\n+  public static class StatSerializer extends StdSerializer<SpeedStat> {\n+    private static final long serialVersionUID = -5198319303173120740L;\n+\n+    /**\n+     * An empty constructor.\n+     * */\n+    public StatSerializer() {\n+      super(SpeedStat.class);\n+    }\n+\n+    @Override\n+    public void serialize(SpeedStat value, JsonGenerator jgen, SerializerProvider provider)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM4MjQ2Mw=="}, "originalCommit": {"oid": "bbb80c3c1cd2e026d411830d0033e9d1b6f535d3"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY0MzgzOA==", "bodyText": "Ah I see what you mean. Yes I intend to use this as the final output, as we are exploring the possibility to move the graph generation logic into out frontend. I think it also makes some sense if the user is reading the results before the GenerateReport step.", "url": "https://github.com/Alluxio/alluxio/pull/11422#discussion_r435643838", "createdAt": "2020-06-05T01:36:02Z", "author": {"login": "jiacheliu3"}, "path": "stress/common/src/main/java/alluxio/stress/worker/IOTaskSummary.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.stress.worker;\n+\n+import alluxio.collections.Pair;\n+import alluxio.stress.BaseParameters;\n+import alluxio.stress.JsonSerializable;\n+import alluxio.stress.Parameters;\n+import alluxio.stress.Summary;\n+import alluxio.stress.graph.BarGraph;\n+import alluxio.stress.graph.Graph;\n+import alluxio.util.FormatUtils;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.fasterxml.jackson.databind.deser.std.StdDeserializer;\n+import com.fasterxml.jackson.databind.ser.std.StdSerializer;\n+import com.google.common.base.Splitter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The summary for the UFS I/O throughput test.\n+ */\n+public class IOTaskSummary implements Summary {\n+  private static final Logger LOG = LoggerFactory.getLogger(IOTaskSummary.class);\n+  private List<IOTaskResult.Point> mPoints;\n+  private List<String> mErrors;\n+  private BaseParameters mBaseParameters;\n+  private UfsIOParameters mParameters;\n+  private SpeedStat mReadSpeedStat;\n+  private SpeedStat mWriteSpeedStat;\n+\n+  /**\n+   * Used for deserialization.\n+   * */\n+  @JsonCreator\n+  public IOTaskSummary() {}\n+\n+  /**\n+   * @param result the {@link IOTaskResult} to summarize\n+   * */\n+  public IOTaskSummary(IOTaskResult result) {\n+    mPoints = new ArrayList<>(result.getPoints());\n+    mErrors = new ArrayList<>(result.getErrors());\n+    mBaseParameters = result.getBaseParameters();\n+    mParameters = result.getParameters();\n+    calculateStats();\n+  }\n+\n+  /**\n+   * @return the points recorded\n+   * */\n+  public List<IOTaskResult.Point> getPoints() {\n+    return mPoints;\n+  }\n+\n+  /**\n+   * @param points the data points\n+   * */\n+  public void setPoints(List<IOTaskResult.Point> points) {\n+    mPoints = points;\n+  }\n+\n+  /**\n+   * @return the errors recorded\n+   * */\n+  public List<String> getErrors() {\n+    return mErrors;\n+  }\n+\n+  /**\n+   * @param errors the errors\n+   * */\n+  public void setErrors(List<String> errors) {\n+    mErrors = errors;\n+  }\n+\n+  /**\n+   * @return the {@link BaseParameters}\n+   * */\n+  public BaseParameters getBaseParameters() {\n+    return mBaseParameters;\n+  }\n+\n+  /**\n+   * @param baseParameters the {@link BaseParameters}\n+   * */\n+  public void setBaseParameters(BaseParameters baseParameters) {\n+    mBaseParameters = baseParameters;\n+  }\n+\n+  /**\n+   * @return the task specific {@link UfsIOParameters}\n+   * */\n+  public UfsIOParameters getParameters() {\n+    return mParameters;\n+  }\n+\n+  /**\n+   * @param parameters the {@link UfsIOParameters}\n+   * */\n+  public void setParameters(UfsIOParameters parameters) {\n+    mParameters = parameters;\n+  }\n+\n+  /**\n+   * @return the {@link SpeedStat} for read speed\n+   * */\n+  public SpeedStat getReadSpeedStat() {\n+    return mReadSpeedStat;\n+  }\n+\n+  /**\n+   * @param stat the {@link SpeedStat} for read stats\n+   * */\n+  public void setReadSpeedStat(SpeedStat stat) {\n+    mReadSpeedStat = stat;\n+  }\n+\n+  /**\n+   * @return the {@link SpeedStat} for write speed\n+   * */\n+  public SpeedStat getWriteSpeedStat() {\n+    return mWriteSpeedStat;\n+  }\n+\n+  /**\n+   * @param stat the {@link SpeedStat} for write stats\n+   * */\n+  public void setWriteSpeedStat(SpeedStat stat) {\n+    mWriteSpeedStat = stat;\n+  }\n+\n+  /**\n+   * An object representation of all the statistics we need\n+   * from this I/O test.\n+   * */\n+  @JsonSerialize(using = StatSerializer.class)\n+  @JsonDeserialize(using = StatDeserializer.class)\n+  public static class SpeedStat implements JsonSerializable {\n+    public double mTotalDuration; // in second\n+    public long mTotalSize; // in Bytes\n+    public double mMaxSpeed; // in MB/s\n+    public double mMinSpeed; // in MB/s\n+    public double mAvgSpeed; // in MB/s\n+    public double mStdDev; // in MB/s\n+\n+    /**\n+     * An empty constructor.\n+     * */\n+    public SpeedStat() {}\n+\n+    @Override\n+    public String toString() {\n+      return String.format(\"{totalDuration=%ss, totalSize=%s, maxSpeed=%sMB/s, \"\n+                      + \"minSpeed=%sMB/s, \" + \"avgSpeed=%sMB/s, stdDev=%s}\",\n+              mTotalDuration, FormatUtils.getSizeFromBytes(mTotalSize),\n+              mMaxSpeed, mMinSpeed, mAvgSpeed, mStdDev);\n+    }\n+  }\n+\n+  /**\n+   * A customized serializer for {@link SpeedStat}.\n+   * All the fields are attached with the unit.\n+   * */\n+  public static class StatSerializer extends StdSerializer<SpeedStat> {\n+    private static final long serialVersionUID = -5198319303173120740L;\n+\n+    /**\n+     * An empty constructor.\n+     * */\n+    public StatSerializer() {\n+      super(SpeedStat.class);\n+    }\n+\n+    @Override\n+    public void serialize(SpeedStat value, JsonGenerator jgen, SerializerProvider provider)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM4MjQ2Mw=="}, "originalCommit": {"oid": "bbb80c3c1cd2e026d411830d0033e9d1b6f535d3"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY0ODMzNw==", "bodyText": "Also I think it's slightly more maintainable if we pass data with units to the frontend, as it's a mixture of \"Bytes\", \"MB\", and \"MB/s\".", "url": "https://github.com/Alluxio/alluxio/pull/11422#discussion_r435648337", "createdAt": "2020-06-05T01:54:18Z", "author": {"login": "jiacheliu3"}, "path": "stress/common/src/main/java/alluxio/stress/worker/IOTaskSummary.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.stress.worker;\n+\n+import alluxio.collections.Pair;\n+import alluxio.stress.BaseParameters;\n+import alluxio.stress.JsonSerializable;\n+import alluxio.stress.Parameters;\n+import alluxio.stress.Summary;\n+import alluxio.stress.graph.BarGraph;\n+import alluxio.stress.graph.Graph;\n+import alluxio.util.FormatUtils;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.fasterxml.jackson.databind.deser.std.StdDeserializer;\n+import com.fasterxml.jackson.databind.ser.std.StdSerializer;\n+import com.google.common.base.Splitter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The summary for the UFS I/O throughput test.\n+ */\n+public class IOTaskSummary implements Summary {\n+  private static final Logger LOG = LoggerFactory.getLogger(IOTaskSummary.class);\n+  private List<IOTaskResult.Point> mPoints;\n+  private List<String> mErrors;\n+  private BaseParameters mBaseParameters;\n+  private UfsIOParameters mParameters;\n+  private SpeedStat mReadSpeedStat;\n+  private SpeedStat mWriteSpeedStat;\n+\n+  /**\n+   * Used for deserialization.\n+   * */\n+  @JsonCreator\n+  public IOTaskSummary() {}\n+\n+  /**\n+   * @param result the {@link IOTaskResult} to summarize\n+   * */\n+  public IOTaskSummary(IOTaskResult result) {\n+    mPoints = new ArrayList<>(result.getPoints());\n+    mErrors = new ArrayList<>(result.getErrors());\n+    mBaseParameters = result.getBaseParameters();\n+    mParameters = result.getParameters();\n+    calculateStats();\n+  }\n+\n+  /**\n+   * @return the points recorded\n+   * */\n+  public List<IOTaskResult.Point> getPoints() {\n+    return mPoints;\n+  }\n+\n+  /**\n+   * @param points the data points\n+   * */\n+  public void setPoints(List<IOTaskResult.Point> points) {\n+    mPoints = points;\n+  }\n+\n+  /**\n+   * @return the errors recorded\n+   * */\n+  public List<String> getErrors() {\n+    return mErrors;\n+  }\n+\n+  /**\n+   * @param errors the errors\n+   * */\n+  public void setErrors(List<String> errors) {\n+    mErrors = errors;\n+  }\n+\n+  /**\n+   * @return the {@link BaseParameters}\n+   * */\n+  public BaseParameters getBaseParameters() {\n+    return mBaseParameters;\n+  }\n+\n+  /**\n+   * @param baseParameters the {@link BaseParameters}\n+   * */\n+  public void setBaseParameters(BaseParameters baseParameters) {\n+    mBaseParameters = baseParameters;\n+  }\n+\n+  /**\n+   * @return the task specific {@link UfsIOParameters}\n+   * */\n+  public UfsIOParameters getParameters() {\n+    return mParameters;\n+  }\n+\n+  /**\n+   * @param parameters the {@link UfsIOParameters}\n+   * */\n+  public void setParameters(UfsIOParameters parameters) {\n+    mParameters = parameters;\n+  }\n+\n+  /**\n+   * @return the {@link SpeedStat} for read speed\n+   * */\n+  public SpeedStat getReadSpeedStat() {\n+    return mReadSpeedStat;\n+  }\n+\n+  /**\n+   * @param stat the {@link SpeedStat} for read stats\n+   * */\n+  public void setReadSpeedStat(SpeedStat stat) {\n+    mReadSpeedStat = stat;\n+  }\n+\n+  /**\n+   * @return the {@link SpeedStat} for write speed\n+   * */\n+  public SpeedStat getWriteSpeedStat() {\n+    return mWriteSpeedStat;\n+  }\n+\n+  /**\n+   * @param stat the {@link SpeedStat} for write stats\n+   * */\n+  public void setWriteSpeedStat(SpeedStat stat) {\n+    mWriteSpeedStat = stat;\n+  }\n+\n+  /**\n+   * An object representation of all the statistics we need\n+   * from this I/O test.\n+   * */\n+  @JsonSerialize(using = StatSerializer.class)\n+  @JsonDeserialize(using = StatDeserializer.class)\n+  public static class SpeedStat implements JsonSerializable {\n+    public double mTotalDuration; // in second\n+    public long mTotalSize; // in Bytes\n+    public double mMaxSpeed; // in MB/s\n+    public double mMinSpeed; // in MB/s\n+    public double mAvgSpeed; // in MB/s\n+    public double mStdDev; // in MB/s\n+\n+    /**\n+     * An empty constructor.\n+     * */\n+    public SpeedStat() {}\n+\n+    @Override\n+    public String toString() {\n+      return String.format(\"{totalDuration=%ss, totalSize=%s, maxSpeed=%sMB/s, \"\n+                      + \"minSpeed=%sMB/s, \" + \"avgSpeed=%sMB/s, stdDev=%s}\",\n+              mTotalDuration, FormatUtils.getSizeFromBytes(mTotalSize),\n+              mMaxSpeed, mMinSpeed, mAvgSpeed, mStdDev);\n+    }\n+  }\n+\n+  /**\n+   * A customized serializer for {@link SpeedStat}.\n+   * All the fields are attached with the unit.\n+   * */\n+  public static class StatSerializer extends StdSerializer<SpeedStat> {\n+    private static final long serialVersionUID = -5198319303173120740L;\n+\n+    /**\n+     * An empty constructor.\n+     * */\n+    public StatSerializer() {\n+      super(SpeedStat.class);\n+    }\n+\n+    @Override\n+    public void serialize(SpeedStat value, JsonGenerator jgen, SerializerProvider provider)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM4MjQ2Mw=="}, "originalCommit": {"oid": "bbb80c3c1cd2e026d411830d0033e9d1b6f535d3"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcyNDk4NA==", "bodyText": "I am a bit confused. If this json is the final human-readable output, then yes, these values can just be strings. But, if this json is supposed to be data (to be later graphed or displayed), then I think it would make sense for the value to be the scalar primitive.\nIf units are a concern, other results have the units in the name of the field, like \"durationMs\", or \"iompbs\".", "url": "https://github.com/Alluxio/alluxio/pull/11422#discussion_r435724984", "createdAt": "2020-06-05T06:57:43Z", "author": {"login": "gpang"}, "path": "stress/common/src/main/java/alluxio/stress/worker/IOTaskSummary.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.stress.worker;\n+\n+import alluxio.collections.Pair;\n+import alluxio.stress.BaseParameters;\n+import alluxio.stress.JsonSerializable;\n+import alluxio.stress.Parameters;\n+import alluxio.stress.Summary;\n+import alluxio.stress.graph.BarGraph;\n+import alluxio.stress.graph.Graph;\n+import alluxio.util.FormatUtils;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.fasterxml.jackson.databind.deser.std.StdDeserializer;\n+import com.fasterxml.jackson.databind.ser.std.StdSerializer;\n+import com.google.common.base.Splitter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The summary for the UFS I/O throughput test.\n+ */\n+public class IOTaskSummary implements Summary {\n+  private static final Logger LOG = LoggerFactory.getLogger(IOTaskSummary.class);\n+  private List<IOTaskResult.Point> mPoints;\n+  private List<String> mErrors;\n+  private BaseParameters mBaseParameters;\n+  private UfsIOParameters mParameters;\n+  private SpeedStat mReadSpeedStat;\n+  private SpeedStat mWriteSpeedStat;\n+\n+  /**\n+   * Used for deserialization.\n+   * */\n+  @JsonCreator\n+  public IOTaskSummary() {}\n+\n+  /**\n+   * @param result the {@link IOTaskResult} to summarize\n+   * */\n+  public IOTaskSummary(IOTaskResult result) {\n+    mPoints = new ArrayList<>(result.getPoints());\n+    mErrors = new ArrayList<>(result.getErrors());\n+    mBaseParameters = result.getBaseParameters();\n+    mParameters = result.getParameters();\n+    calculateStats();\n+  }\n+\n+  /**\n+   * @return the points recorded\n+   * */\n+  public List<IOTaskResult.Point> getPoints() {\n+    return mPoints;\n+  }\n+\n+  /**\n+   * @param points the data points\n+   * */\n+  public void setPoints(List<IOTaskResult.Point> points) {\n+    mPoints = points;\n+  }\n+\n+  /**\n+   * @return the errors recorded\n+   * */\n+  public List<String> getErrors() {\n+    return mErrors;\n+  }\n+\n+  /**\n+   * @param errors the errors\n+   * */\n+  public void setErrors(List<String> errors) {\n+    mErrors = errors;\n+  }\n+\n+  /**\n+   * @return the {@link BaseParameters}\n+   * */\n+  public BaseParameters getBaseParameters() {\n+    return mBaseParameters;\n+  }\n+\n+  /**\n+   * @param baseParameters the {@link BaseParameters}\n+   * */\n+  public void setBaseParameters(BaseParameters baseParameters) {\n+    mBaseParameters = baseParameters;\n+  }\n+\n+  /**\n+   * @return the task specific {@link UfsIOParameters}\n+   * */\n+  public UfsIOParameters getParameters() {\n+    return mParameters;\n+  }\n+\n+  /**\n+   * @param parameters the {@link UfsIOParameters}\n+   * */\n+  public void setParameters(UfsIOParameters parameters) {\n+    mParameters = parameters;\n+  }\n+\n+  /**\n+   * @return the {@link SpeedStat} for read speed\n+   * */\n+  public SpeedStat getReadSpeedStat() {\n+    return mReadSpeedStat;\n+  }\n+\n+  /**\n+   * @param stat the {@link SpeedStat} for read stats\n+   * */\n+  public void setReadSpeedStat(SpeedStat stat) {\n+    mReadSpeedStat = stat;\n+  }\n+\n+  /**\n+   * @return the {@link SpeedStat} for write speed\n+   * */\n+  public SpeedStat getWriteSpeedStat() {\n+    return mWriteSpeedStat;\n+  }\n+\n+  /**\n+   * @param stat the {@link SpeedStat} for write stats\n+   * */\n+  public void setWriteSpeedStat(SpeedStat stat) {\n+    mWriteSpeedStat = stat;\n+  }\n+\n+  /**\n+   * An object representation of all the statistics we need\n+   * from this I/O test.\n+   * */\n+  @JsonSerialize(using = StatSerializer.class)\n+  @JsonDeserialize(using = StatDeserializer.class)\n+  public static class SpeedStat implements JsonSerializable {\n+    public double mTotalDuration; // in second\n+    public long mTotalSize; // in Bytes\n+    public double mMaxSpeed; // in MB/s\n+    public double mMinSpeed; // in MB/s\n+    public double mAvgSpeed; // in MB/s\n+    public double mStdDev; // in MB/s\n+\n+    /**\n+     * An empty constructor.\n+     * */\n+    public SpeedStat() {}\n+\n+    @Override\n+    public String toString() {\n+      return String.format(\"{totalDuration=%ss, totalSize=%s, maxSpeed=%sMB/s, \"\n+                      + \"minSpeed=%sMB/s, \" + \"avgSpeed=%sMB/s, stdDev=%s}\",\n+              mTotalDuration, FormatUtils.getSizeFromBytes(mTotalSize),\n+              mMaxSpeed, mMinSpeed, mAvgSpeed, mStdDev);\n+    }\n+  }\n+\n+  /**\n+   * A customized serializer for {@link SpeedStat}.\n+   * All the fields are attached with the unit.\n+   * */\n+  public static class StatSerializer extends StdSerializer<SpeedStat> {\n+    private static final long serialVersionUID = -5198319303173120740L;\n+\n+    /**\n+     * An empty constructor.\n+     * */\n+    public StatSerializer() {\n+      super(SpeedStat.class);\n+    }\n+\n+    @Override\n+    public void serialize(SpeedStat value, JsonGenerator jgen, SerializerProvider provider)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM4MjQ2Mw=="}, "originalCommit": {"oid": "bbb80c3c1cd2e026d411830d0033e9d1b6f535d3"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjAxOTc1Nw==", "bodyText": "I like the idea of unit in field names. I'll update this.", "url": "https://github.com/Alluxio/alluxio/pull/11422#discussion_r436019757", "createdAt": "2020-06-05T16:06:30Z", "author": {"login": "jiacheliu3"}, "path": "stress/common/src/main/java/alluxio/stress/worker/IOTaskSummary.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.stress.worker;\n+\n+import alluxio.collections.Pair;\n+import alluxio.stress.BaseParameters;\n+import alluxio.stress.JsonSerializable;\n+import alluxio.stress.Parameters;\n+import alluxio.stress.Summary;\n+import alluxio.stress.graph.BarGraph;\n+import alluxio.stress.graph.Graph;\n+import alluxio.util.FormatUtils;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.SerializerProvider;\n+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;\n+import com.fasterxml.jackson.databind.annotation.JsonSerialize;\n+import com.fasterxml.jackson.databind.deser.std.StdDeserializer;\n+import com.fasterxml.jackson.databind.ser.std.StdSerializer;\n+import com.google.common.base.Splitter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The summary for the UFS I/O throughput test.\n+ */\n+public class IOTaskSummary implements Summary {\n+  private static final Logger LOG = LoggerFactory.getLogger(IOTaskSummary.class);\n+  private List<IOTaskResult.Point> mPoints;\n+  private List<String> mErrors;\n+  private BaseParameters mBaseParameters;\n+  private UfsIOParameters mParameters;\n+  private SpeedStat mReadSpeedStat;\n+  private SpeedStat mWriteSpeedStat;\n+\n+  /**\n+   * Used for deserialization.\n+   * */\n+  @JsonCreator\n+  public IOTaskSummary() {}\n+\n+  /**\n+   * @param result the {@link IOTaskResult} to summarize\n+   * */\n+  public IOTaskSummary(IOTaskResult result) {\n+    mPoints = new ArrayList<>(result.getPoints());\n+    mErrors = new ArrayList<>(result.getErrors());\n+    mBaseParameters = result.getBaseParameters();\n+    mParameters = result.getParameters();\n+    calculateStats();\n+  }\n+\n+  /**\n+   * @return the points recorded\n+   * */\n+  public List<IOTaskResult.Point> getPoints() {\n+    return mPoints;\n+  }\n+\n+  /**\n+   * @param points the data points\n+   * */\n+  public void setPoints(List<IOTaskResult.Point> points) {\n+    mPoints = points;\n+  }\n+\n+  /**\n+   * @return the errors recorded\n+   * */\n+  public List<String> getErrors() {\n+    return mErrors;\n+  }\n+\n+  /**\n+   * @param errors the errors\n+   * */\n+  public void setErrors(List<String> errors) {\n+    mErrors = errors;\n+  }\n+\n+  /**\n+   * @return the {@link BaseParameters}\n+   * */\n+  public BaseParameters getBaseParameters() {\n+    return mBaseParameters;\n+  }\n+\n+  /**\n+   * @param baseParameters the {@link BaseParameters}\n+   * */\n+  public void setBaseParameters(BaseParameters baseParameters) {\n+    mBaseParameters = baseParameters;\n+  }\n+\n+  /**\n+   * @return the task specific {@link UfsIOParameters}\n+   * */\n+  public UfsIOParameters getParameters() {\n+    return mParameters;\n+  }\n+\n+  /**\n+   * @param parameters the {@link UfsIOParameters}\n+   * */\n+  public void setParameters(UfsIOParameters parameters) {\n+    mParameters = parameters;\n+  }\n+\n+  /**\n+   * @return the {@link SpeedStat} for read speed\n+   * */\n+  public SpeedStat getReadSpeedStat() {\n+    return mReadSpeedStat;\n+  }\n+\n+  /**\n+   * @param stat the {@link SpeedStat} for read stats\n+   * */\n+  public void setReadSpeedStat(SpeedStat stat) {\n+    mReadSpeedStat = stat;\n+  }\n+\n+  /**\n+   * @return the {@link SpeedStat} for write speed\n+   * */\n+  public SpeedStat getWriteSpeedStat() {\n+    return mWriteSpeedStat;\n+  }\n+\n+  /**\n+   * @param stat the {@link SpeedStat} for write stats\n+   * */\n+  public void setWriteSpeedStat(SpeedStat stat) {\n+    mWriteSpeedStat = stat;\n+  }\n+\n+  /**\n+   * An object representation of all the statistics we need\n+   * from this I/O test.\n+   * */\n+  @JsonSerialize(using = StatSerializer.class)\n+  @JsonDeserialize(using = StatDeserializer.class)\n+  public static class SpeedStat implements JsonSerializable {\n+    public double mTotalDuration; // in second\n+    public long mTotalSize; // in Bytes\n+    public double mMaxSpeed; // in MB/s\n+    public double mMinSpeed; // in MB/s\n+    public double mAvgSpeed; // in MB/s\n+    public double mStdDev; // in MB/s\n+\n+    /**\n+     * An empty constructor.\n+     * */\n+    public SpeedStat() {}\n+\n+    @Override\n+    public String toString() {\n+      return String.format(\"{totalDuration=%ss, totalSize=%s, maxSpeed=%sMB/s, \"\n+                      + \"minSpeed=%sMB/s, \" + \"avgSpeed=%sMB/s, stdDev=%s}\",\n+              mTotalDuration, FormatUtils.getSizeFromBytes(mTotalSize),\n+              mMaxSpeed, mMinSpeed, mAvgSpeed, mStdDev);\n+    }\n+  }\n+\n+  /**\n+   * A customized serializer for {@link SpeedStat}.\n+   * All the fields are attached with the unit.\n+   * */\n+  public static class StatSerializer extends StdSerializer<SpeedStat> {\n+    private static final long serialVersionUID = -5198319303173120740L;\n+\n+    /**\n+     * An empty constructor.\n+     * */\n+    public StatSerializer() {\n+      super(SpeedStat.class);\n+    }\n+\n+    @Override\n+    public void serialize(SpeedStat value, JsonGenerator jgen, SerializerProvider provider)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM4MjQ2Mw=="}, "originalCommit": {"oid": "bbb80c3c1cd2e026d411830d0033e9d1b6f535d3"}, "originalPosition": 198}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1738, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}