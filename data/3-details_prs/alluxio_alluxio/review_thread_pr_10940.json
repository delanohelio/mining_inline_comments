{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc2OTE0NzQ1", "number": 10940, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMDo1ODo0MlrODhOD1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMToyMDozOFrODhOdqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2MTU5OTU4OnYy", "diffSide": "RIGHT", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMDo1ODo0MlrOFr3YLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMToxNzoxOFrOFr37aQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU0MDM5Ng==", "bodyText": "Add @Nullable", "url": "https://github.com/Alluxio/alluxio/pull/10940#discussion_r381540396", "createdAt": "2020-02-19T20:58:42Z", "author": {"login": "apc999"}, "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java", "diffHunk": "@@ -268,4 +261,65 @@ public void delete(PageId pageId) throws IOException, PageNotFoundException {\n   public void close() throws Exception {\n     mPageStore.close();\n   }\n+\n+  /**\n+   * Attempts to add a page to the page store. The page lock must be acquired before calling this\n+   * method. The metastore must be updated before calling this method.\n+   *\n+   * @param pageId page id\n+   * @param page page data\n+   * @return true if successful, false otherwise\n+   */\n+  private boolean addPage(PageId pageId, byte[] page) {\n+    try {\n+      mPageStore.put(pageId, page);\n+    } catch (IOException e) {\n+      LOG.error(\"Failed to add page {}: {}\", pageId, e);\n+      return false;\n+    }\n+    mEvictor.updateOnPut(pageId);\n+    Metrics.BYTES_WRITTEN_CACHE.inc(page.length);\n+    return true;\n+  }\n+\n+  /**\n+   * Attempts to delete a page from the page store. The page lock must be acquired before calling\n+   * this method. The metastore must be updated before calling this method.\n+   *\n+   * @param pageId page id\n+   * @param pageInfo page info\n+   * @return true if successful, false otherwise\n+   */\n+  private boolean deletePage(PageId pageId, PageInfo pageInfo) {\n+    try {\n+      mPageStore.delete(pageId, pageInfo.getPageSize());\n+    } catch (IOException | PageNotFoundException e) {\n+      LOG.error(\"Failed to delete page {}: {}\", pageId, e);\n+      return false;\n+    }\n+    mEvictor.updateOnDelete(pageId);\n+    Metrics.BYTES_EVICTED_CACHE.inc(pageInfo.getPageSize());\n+    return true;\n+  }\n+\n+  private ReadableByteChannel getPage(PageId pageId, int offset) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "700e72f9369ac030802754f94e974600bd9175c7"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU0OTQxNw==", "bodyText": "Updated, thanks.", "url": "https://github.com/Alluxio/alluxio/pull/10940#discussion_r381549417", "createdAt": "2020-02-19T21:17:18Z", "author": {"login": "calvinjia"}, "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java", "diffHunk": "@@ -268,4 +261,65 @@ public void delete(PageId pageId) throws IOException, PageNotFoundException {\n   public void close() throws Exception {\n     mPageStore.close();\n   }\n+\n+  /**\n+   * Attempts to add a page to the page store. The page lock must be acquired before calling this\n+   * method. The metastore must be updated before calling this method.\n+   *\n+   * @param pageId page id\n+   * @param page page data\n+   * @return true if successful, false otherwise\n+   */\n+  private boolean addPage(PageId pageId, byte[] page) {\n+    try {\n+      mPageStore.put(pageId, page);\n+    } catch (IOException e) {\n+      LOG.error(\"Failed to add page {}: {}\", pageId, e);\n+      return false;\n+    }\n+    mEvictor.updateOnPut(pageId);\n+    Metrics.BYTES_WRITTEN_CACHE.inc(page.length);\n+    return true;\n+  }\n+\n+  /**\n+   * Attempts to delete a page from the page store. The page lock must be acquired before calling\n+   * this method. The metastore must be updated before calling this method.\n+   *\n+   * @param pageId page id\n+   * @param pageInfo page info\n+   * @return true if successful, false otherwise\n+   */\n+  private boolean deletePage(PageId pageId, PageInfo pageInfo) {\n+    try {\n+      mPageStore.delete(pageId, pageInfo.getPageSize());\n+    } catch (IOException | PageNotFoundException e) {\n+      LOG.error(\"Failed to delete page {}: {}\", pageId, e);\n+      return false;\n+    }\n+    mEvictor.updateOnDelete(pageId);\n+    Metrics.BYTES_EVICTED_CACHE.inc(pageInfo.getPageSize());\n+    return true;\n+  }\n+\n+  private ReadableByteChannel getPage(PageId pageId, int offset) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU0MDM5Ng=="}, "originalCommit": {"oid": "700e72f9369ac030802754f94e974600bd9175c7"}, "originalPosition": 145}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2MTYxMzc3OnYy", "diffSide": "RIGHT", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMTowMjo1MVrOFr3gmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMTowMjo1MVrOFr3gmQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU0MjU1Mw==", "bodyText": "move this down to be protected by lock as discussed", "url": "https://github.com/Alluxio/alluxio/pull/10940#discussion_r381542553", "createdAt": "2020-02-19T21:02:51Z", "author": {"login": "apc999"}, "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java", "diffHunk": "@@ -164,13 +167,13 @@ public boolean put(PageId pageId, byte[] page) throws IOException {\n           victimPageInfo = mMetaStore.getPageInfo(victim);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "700e72f9369ac030802754f94e974600bd9175c7"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM2MTY2NTY5OnYy", "diffSide": "RIGHT", "path": "core/client/fs/src/main/java/alluxio/client/file/cache/CacheManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMToyMDozOFrOFr4Blw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOVQyMzoyMjozMFrOFr7Ung==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU1MDk5OQ==", "bodyText": "still leave IOE here o signature?", "url": "https://github.com/Alluxio/alluxio/pull/10940#discussion_r381550999", "createdAt": "2020-02-19T21:20:38Z", "author": {"login": "apc999"}, "path": "core/client/fs/src/main/java/alluxio/client/file/cache/CacheManager.java", "diffHunk": "@@ -33,45 +32,41 @@ static CacheManager create(AlluxioConfiguration conf) throws IOException {\n   }\n \n   /**\n-   * Writes a new page from a source channel with best effort. It is possible that this put\n-   * operation returns without page written due to transient behavior not due to failures writing\n-   * to disks.\n+   * Puts a page into the cache manager. This method is best effort. It is possible that this put\n+   * operation returns without page written.\n    *\n    * @param pageId page identifier\n    * @param page page data\n-   * @throws IOException if error happens when writing the page to disk\n-   * @return true on a successful put or false due to transient\n+   * @return true if the put was successful, false otherwise\n    */\n-  boolean put(PageId pageId, byte[] page) throws IOException;\n+  boolean put(PageId pageId, byte[] page);\n \n   /**\n-   * Wraps the page in a channel or null if the queried page is not found in the cache.\n+   * Wraps the page in a channel or null if the queried page is not found in the cache or otherwise\n+   * unable to be read from the cache.\n    *\n    * @param pageId page identifier\n    * @return a channel to read the page\n-   * @throws IOException if error happens when reading the page\n    */\n   @Nullable\n-  ReadableByteChannel get(PageId pageId) throws IOException;\n+  ReadableByteChannel get(PageId pageId);\n \n   /**\n-   * Wraps a part of the page in a channel or null if the queried page is not found\n-   * in the cache.\n+   * Wraps a part of the page in a channel or null if the queried page is not found in the cache or\n+   * otherwise unable to be read from the cache.\n    *\n    * @param pageId page identifier\n    * @param pageOffset offset into the page\n    * @return a channel to read the page\n-   * @throws IOException if error happens when reading the page\n    */\n   @Nullable\n-  ReadableByteChannel get(PageId pageId, int pageOffset)\n-      throws IOException;\n+  ReadableByteChannel get(PageId pageId, int pageOffset);\n \n   /**\n    * Deletes a page from the cache.\n    *\n    * @param pageId page identifier\n-   * @throws PageNotFoundException if page is not found in the store\n+   * @return true if the page is successfully deleted, false otherwise\n    */\n-  void delete(PageId pageId) throws IOException, PageNotFoundException;\n+  boolean delete(PageId pageId) throws IOException;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "53ed3116939eb48d0f1c1eaa98d2c0f0f2954a58"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTYwNTAyMg==", "bodyText": "Updated, thanks.", "url": "https://github.com/Alluxio/alluxio/pull/10940#discussion_r381605022", "createdAt": "2020-02-19T23:22:30Z", "author": {"login": "calvinjia"}, "path": "core/client/fs/src/main/java/alluxio/client/file/cache/CacheManager.java", "diffHunk": "@@ -33,45 +32,41 @@ static CacheManager create(AlluxioConfiguration conf) throws IOException {\n   }\n \n   /**\n-   * Writes a new page from a source channel with best effort. It is possible that this put\n-   * operation returns without page written due to transient behavior not due to failures writing\n-   * to disks.\n+   * Puts a page into the cache manager. This method is best effort. It is possible that this put\n+   * operation returns without page written.\n    *\n    * @param pageId page identifier\n    * @param page page data\n-   * @throws IOException if error happens when writing the page to disk\n-   * @return true on a successful put or false due to transient\n+   * @return true if the put was successful, false otherwise\n    */\n-  boolean put(PageId pageId, byte[] page) throws IOException;\n+  boolean put(PageId pageId, byte[] page);\n \n   /**\n-   * Wraps the page in a channel or null if the queried page is not found in the cache.\n+   * Wraps the page in a channel or null if the queried page is not found in the cache or otherwise\n+   * unable to be read from the cache.\n    *\n    * @param pageId page identifier\n    * @return a channel to read the page\n-   * @throws IOException if error happens when reading the page\n    */\n   @Nullable\n-  ReadableByteChannel get(PageId pageId) throws IOException;\n+  ReadableByteChannel get(PageId pageId);\n \n   /**\n-   * Wraps a part of the page in a channel or null if the queried page is not found\n-   * in the cache.\n+   * Wraps a part of the page in a channel or null if the queried page is not found in the cache or\n+   * otherwise unable to be read from the cache.\n    *\n    * @param pageId page identifier\n    * @param pageOffset offset into the page\n    * @return a channel to read the page\n-   * @throws IOException if error happens when reading the page\n    */\n   @Nullable\n-  ReadableByteChannel get(PageId pageId, int pageOffset)\n-      throws IOException;\n+  ReadableByteChannel get(PageId pageId, int pageOffset);\n \n   /**\n    * Deletes a page from the cache.\n    *\n    * @param pageId page identifier\n-   * @throws PageNotFoundException if page is not found in the store\n+   * @return true if the page is successfully deleted, false otherwise\n    */\n-  void delete(PageId pageId) throws IOException, PageNotFoundException;\n+  boolean delete(PageId pageId) throws IOException;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTU1MDk5OQ=="}, "originalCommit": {"oid": "53ed3116939eb48d0f1c1eaa98d2c0f0f2954a58"}, "originalPosition": 64}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1949, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}