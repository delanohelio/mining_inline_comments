{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQwODI2Njk1", "number": 11674, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQyMzo0NjoyNlrOEJSt_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMjoyMjoyOFrOEL3KQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MTc5MzI2OnYy", "diffSide": "RIGHT", "path": "core/server/master/src/main/java/alluxio/master/file/InodeSyncStream.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQyMzo0NjoyNlrOGpxYLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMToxNjoyNlrOGrOx1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ1MzgwNQ==", "bodyText": "I don't think this needs to be here.\nThe check in the main sync() method should be enough", "url": "https://github.com/Alluxio/alluxio/pull/11674#discussion_r446453805", "createdAt": "2020-06-26T23:46:26Z", "author": {"login": "ZacBlanco"}, "path": "core/server/master/src/main/java/alluxio/master/file/InodeSyncStream.java", "diffHunk": "@@ -632,6 +638,7 @@ private void loadMetadataForPath(LockedInodePath inodePath)\n   private void loadMetadata(LockedInodePath inodePath, LoadMetadataContext context)\n       throws AccessControlException, BlockInfoException, FileAlreadyCompletedException,\n       FileDoesNotExistException, InvalidFileSizeException, InvalidPathException, IOException {\n+    mRpcContext.throwIfCancelled();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "44a170431ad4e66fba553c6ca682056f7811c997"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU5NTU5OQ==", "bodyText": "Wouldn't this ever take a long time to execute?", "url": "https://github.com/Alluxio/alluxio/pull/11674#discussion_r446595599", "createdAt": "2020-06-28T03:39:45Z", "author": {"login": "ggezer"}, "path": "core/server/master/src/main/java/alluxio/master/file/InodeSyncStream.java", "diffHunk": "@@ -632,6 +638,7 @@ private void loadMetadataForPath(LockedInodePath inodePath)\n   private void loadMetadata(LockedInodePath inodePath, LoadMetadataContext context)\n       throws AccessControlException, BlockInfoException, FileAlreadyCompletedException,\n       FileDoesNotExistException, InvalidFileSizeException, InvalidPathException, IOException {\n+    mRpcContext.throwIfCancelled();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ1MzgwNQ=="}, "originalCommit": {"oid": "44a170431ad4e66fba553c6ca682056f7811c997"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Njc0MDY2Mg==", "bodyText": "loadMetadata only ever executes for a single inode. I think in absolute terms it is not a long amount of time, but relative to other RPCs it could be seen as having a higher cost. I just don't think it's necessary to interrupt the loading process once it has started since it's only for one inode", "url": "https://github.com/Alluxio/alluxio/pull/11674#discussion_r446740662", "createdAt": "2020-06-29T02:31:29Z", "author": {"login": "ZacBlanco"}, "path": "core/server/master/src/main/java/alluxio/master/file/InodeSyncStream.java", "diffHunk": "@@ -632,6 +638,7 @@ private void loadMetadataForPath(LockedInodePath inodePath)\n   private void loadMetadata(LockedInodePath inodePath, LoadMetadataContext context)\n       throws AccessControlException, BlockInfoException, FileAlreadyCompletedException,\n       FileDoesNotExistException, InvalidFileSizeException, InvalidPathException, IOException {\n+    mRpcContext.throwIfCancelled();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ1MzgwNQ=="}, "originalCommit": {"oid": "44a170431ad4e66fba553c6ca682056f7811c997"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk4NDA4Ng==", "bodyText": "Still don't think this is necessary", "url": "https://github.com/Alluxio/alluxio/pull/11674#discussion_r447984086", "createdAt": "2020-06-30T21:16:26Z", "author": {"login": "ZacBlanco"}, "path": "core/server/master/src/main/java/alluxio/master/file/InodeSyncStream.java", "diffHunk": "@@ -632,6 +638,7 @@ private void loadMetadataForPath(LockedInodePath inodePath)\n   private void loadMetadata(LockedInodePath inodePath, LoadMetadataContext context)\n       throws AccessControlException, BlockInfoException, FileAlreadyCompletedException,\n       FileDoesNotExistException, InvalidFileSizeException, InvalidPathException, IOException {\n+    mRpcContext.throwIfCancelled();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ1MzgwNQ=="}, "originalCommit": {"oid": "44a170431ad4e66fba553c6ca682056f7811c997"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MjExMDMzOnYy", "diffSide": "RIGHT", "path": "core/server/master/src/main/java/alluxio/master/file/DefaultFileSystemMaster.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QwNjo0NjowMlrOGpzzEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QwNjo0NjowMlrOGpzzEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ5MzQ1Ng==", "bodyText": "I can't comment on this part. @gpang you probably have more context?", "url": "https://github.com/Alluxio/alluxio/pull/11674#discussion_r446493456", "createdAt": "2020-06-27T06:46:02Z", "author": {"login": "ZacBlanco"}, "path": "core/server/master/src/main/java/alluxio/master/file/DefaultFileSystemMaster.java", "diffHunk": "@@ -440,7 +441,17 @@ public DefaultFileSystemMaster(BlockMaster blockMaster, CoreMasterContext master\n         ? ServerConfiguration.getList(PropertyKey.MASTER_PERSISTENCE_BLACKLIST, \",\")\n         : Collections.emptyList();\n \n-    mStateLockCallTracker = () -> masterContext.getStateLockManager().interruptCycleTicking();\n+    mStateLockCallTracker = new CallTracker() {\n+      @Override\n+      public boolean isCancelled() {\n+        return masterContext.getStateLockManager().interruptCycleTicking();\n+      }\n+\n+      @Override\n+      public Type getType() {\n+        return Type.STATE_LOCK_TRACKER;\n+      }\n+    };", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "20cc3348ec88f2237cf9606d9e3792f031e1b4b0"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MjExNDkwOnYy", "diffSide": "RIGHT", "path": "core/server/master/src/main/java/alluxio/master/file/InodeSyncStream.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QwNjo1Mjo0NFrOGpz1HA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QwNjo1Mjo0NFrOGpz1HA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ5Mzk4MA==", "bodyText": "this line break isn't necessary?", "url": "https://github.com/Alluxio/alluxio/pull/11674#discussion_r446493980", "createdAt": "2020-06-27T06:52:44Z", "author": {"login": "ZacBlanco"}, "path": "core/server/master/src/main/java/alluxio/master/file/InodeSyncStream.java", "diffHunk": "@@ -204,7 +204,8 @@\n    * @param loadOnly whether to only load new metadata, rather than update existing metadata\n    */\n   public InodeSyncStream(LockingScheme rootPath, DefaultFileSystemMaster fsMaster,\n-      RpcContext rpcContext, DescendantType descendantType, FileSystemMasterCommonPOptions options,\n+      RpcContext rpcContext, DescendantType descendantType,\n+      FileSystemMasterCommonPOptions options,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "20cc3348ec88f2237cf9606d9e3792f031e1b4b0"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MjExNTA4OnYy", "diffSide": "RIGHT", "path": "core/server/master/src/main/java/alluxio/master/file/InodeSyncStream.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QwNjo1Mjo1NFrOGpz1Lg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QwNjo1Mjo1NFrOGpz1Lg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ5Mzk5OA==", "bodyText": "I don't think anything changed here?", "url": "https://github.com/Alluxio/alluxio/pull/11674#discussion_r446493998", "createdAt": "2020-06-27T06:52:54Z", "author": {"login": "ZacBlanco"}, "path": "core/server/master/src/main/java/alluxio/master/file/InodeSyncStream.java", "diffHunk": "@@ -246,8 +247,8 @@ public InodeSyncStream(LockingScheme rootPath, DefaultFileSystemMaster fsMaster,\n   public InodeSyncStream(LockingScheme rootScheme, DefaultFileSystemMaster fsMaster,\n       RpcContext rpcContext, DescendantType descendantType, FileSystemMasterCommonPOptions options,\n       boolean isGetFileInfo, boolean forceSync, boolean loadOnly) {\n-    this(rootScheme, fsMaster, rpcContext, descendantType, options, null, null, null,\n-        isGetFileInfo, forceSync, loadOnly);\n+    this(rootScheme, fsMaster, rpcContext, descendantType, options, null, null, null, isGetFileInfo,\n+        forceSync, loadOnly);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "20cc3348ec88f2237cf9606d9e3792f031e1b4b0"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MjEyMDM1OnYy", "diffSide": "RIGHT", "path": "core/server/master/src/main/java/alluxio/master/file/FileSystemMasterClientServiceHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QwNzowMDoxM1rOGpz3ng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QwNzowMDoxM1rOGpz3ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ5NDYyMg==", "bodyText": "if withTracker returns the generic type of the OperationContext (C in your implementation), then is it necessary to include the cast to CreateDirectoryContext? It just doesn't seem clean.\nedit - I looked into it and figured out the issue. Poor use of generics. Change the class definition of CreatePathContext to remove the need to cast\nold:\npublic abstract class CreatePathContext<T extends GeneratedMessageV3.Builder<?>, K>\n    extends OperationContext<T, CreatePathContext> {\nnew:\npublic abstract class CreatePathContext<T extends GeneratedMessageV3.Builder<?>,\n    K extends OperationContext> extends OperationContext<T, K> {", "url": "https://github.com/Alluxio/alluxio/pull/11674#discussion_r446494622", "createdAt": "2020-06-27T07:00:13Z", "author": {"login": "ZacBlanco"}, "path": "core/server/master/src/main/java/alluxio/master/file/FileSystemMasterClientServiceHandler.java", "diffHunk": "@@ -148,8 +148,8 @@ public void createDirectory(CreateDirectoryPRequest request,\n     CreateDirectoryPOptions options = request.getOptions();\n     RpcUtils.call(LOG, () -> {\n       AlluxioURI pathUri = getAlluxioURI(request.getPath());\n-      mFileSystemMaster.createDirectory(pathUri,\n-          CreateDirectoryContext.create(options.toBuilder()));\n+      mFileSystemMaster.createDirectory(pathUri, (CreateDirectoryContext) CreateDirectoryContext\n+          .create(options.toBuilder()).withTracker(new GrpcCallTracker(responseObserver)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "20cc3348ec88f2237cf9606d9e3792f031e1b4b0"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MjEyMDk5OnYy", "diffSide": "RIGHT", "path": "core/server/master/src/main/java/alluxio/master/file/FileSystemMasterClientServiceHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QwNzowMToxNVrOGpz36A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QwNzowMToxNVrOGpz36A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ5NDY5Ng==", "bodyText": "See other comment.\nChange to the CreatePathContext class def removed the need for the extra cast", "url": "https://github.com/Alluxio/alluxio/pull/11674#discussion_r446494696", "createdAt": "2020-06-27T07:01:15Z", "author": {"login": "ZacBlanco"}, "path": "core/server/master/src/main/java/alluxio/master/file/FileSystemMasterClientServiceHandler.java", "diffHunk": "@@ -159,8 +159,10 @@ public void createFile(CreateFilePRequest request,\n       StreamObserver<CreateFilePResponse> responseObserver) {\n     RpcUtils.call(LOG, () -> {\n       AlluxioURI pathUri = getAlluxioURI(request.getPath());\n-      return CreateFilePResponse.newBuilder().setFileInfo(GrpcUtils.toProto(mFileSystemMaster\n-          .createFile(pathUri, CreateFileContext.create(request.getOptions().toBuilder()))))\n+      return CreateFilePResponse.newBuilder()\n+          .setFileInfo(GrpcUtils.toProto(mFileSystemMaster.createFile(pathUri,\n+              (CreateFileContext) CreateFileContext.create(request.getOptions().toBuilder())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "20cc3348ec88f2237cf9606d9e3792f031e1b4b0"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MjEyMjAwOnYy", "diffSide": "RIGHT", "path": "core/server/master/src/main/java/alluxio/master/file/contexts/OperationContext.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QwNzowMzowNFrOGpz4XQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOFQwMzozNjo0OVrOGp6BTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ5NDgxMw==", "bodyText": "The list of call trackers should always be small, correct? 1 most of the time?\nAre there any cases when we could have more than that?", "url": "https://github.com/Alluxio/alluxio/pull/11674#discussion_r446494813", "createdAt": "2020-06-27T07:03:04Z", "author": {"login": "ZacBlanco"}, "path": "core/server/master/src/main/java/alluxio/master/file/contexts/OperationContext.java", "diffHunk": "@@ -11,54 +11,89 @@\n \n package alluxio.master.file.contexts;\n \n+import com.google.protobuf.GeneratedMessageV3;\n+\n import javax.annotation.concurrent.NotThreadSafe;\n+import java.util.Collections;\n+import java.util.LinkedList;\n+import java.util.List;\n \n /**\n  * Used as a base class for wrapping context around proto messages.\n  *\n  * @param <T> Proto message type\n+ * @param <C> extended type\n  */\n @NotThreadSafe\n-public class OperationContext<T extends com.google.protobuf.GeneratedMessageV3.Builder<?>> {\n+public class OperationContext<T extends GeneratedMessageV3.Builder, C extends OperationContext> {\n   // Proto message that is being wrapped\n   private T mOptionsBuilder;\n   // Used to track client call status.\n-  private CallTracker mCallTracker;\n+  private List<CallTracker> mCallTrackers;\n \n   /**\n    * Creates an instance with given proto message.\n    *\n    * @param optionsBuilder Internal proto message builder instance\n    */\n   public OperationContext(T optionsBuilder) {\n-    this(optionsBuilder, null);\n     mOptionsBuilder = optionsBuilder;\n-    mCallTracker = CallTracker.NOOP_TRACKER;\n+    mCallTrackers = new LinkedList<>();\n   }\n \n   /**\n-   * Creates an instance with given proto message.\n+   * @return underlying proto message instance\n+   */\n+  public T getOptions() {\n+    return mOptionsBuilder;\n+  }\n+\n+  /**\n+   * Used to transfer trackers of a context to this instance.\n+   * This is required when creating internal contexts.\n    *\n-   * @param optionsBuilder Internal proto message builder instance\n-   * @param callTracker client call tracker, or {@code null} if no tracking is desired\n+   * @param context the source context\n+   * @return the updated instance\n    */\n-  public OperationContext(T optionsBuilder, CallTracker callTracker) {\n-    mOptionsBuilder = optionsBuilder;\n-    mCallTracker = callTracker;\n+  public C withTracker(OperationContext context) {\n+    mCallTrackers = context.mCallTrackers;\n+    return (C) this;\n   }\n \n   /**\n-   * @return underlying proto message instance\n+   * Updates this context with a new tracker.\n+   *\n+   * @param tracker the new call tracker\n+   * @return the updated instance\n    */\n-  public T getOptions() {\n-    return mOptionsBuilder;\n+  public C withTracker(CallTracker tracker) {\n+    mCallTrackers.add(tracker);\n+    return (C) this;\n   }\n \n   /**\n-   * TODO(ggezer): Make the call-tracker infra note the source of cancellation.\n-   * @return {@code true} if the call is cancelled by the client\n+   * @return the list of trackers that have cancelled this operation\n    */\n-  public boolean isCancelled() {\n-    return mCallTracker.isCancelled();\n+  public List<CallTracker> getCancelledTrackers() {\n+    boolean trackerCancelled = false;\n+    for (CallTracker tracker : mCallTrackers) {\n+      if (tracker.isCancelled()) {\n+        trackerCancelled = true;\n+        break;\n+      }\n+    }\n+\n+    if (!trackerCancelled) {\n+      return Collections.emptyList();\n+    }\n+\n+    List<CallTracker> cancelledTrackers = new LinkedList<>();\n+    for (CallTracker tracker : mCallTrackers) {\n+      if (tracker.isCancelled()) {\n+        cancelledTrackers.add(tracker);\n+      }\n+    }\n+\n+    return cancelledTrackers;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "20cc3348ec88f2237cf9606d9e3792f031e1b4b0"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU5NTQwNQ==", "bodyText": "Every context has a state-lock tracker. Some has an additional transport level tracker (GrpcCallTracker).\nEven for those, it's very unlikely to have more than 1 canceller. However, it's possible so I give out the list here. (We might also wanna add more trackers in the future...)", "url": "https://github.com/Alluxio/alluxio/pull/11674#discussion_r446595405", "createdAt": "2020-06-28T03:36:49Z", "author": {"login": "ggezer"}, "path": "core/server/master/src/main/java/alluxio/master/file/contexts/OperationContext.java", "diffHunk": "@@ -11,54 +11,89 @@\n \n package alluxio.master.file.contexts;\n \n+import com.google.protobuf.GeneratedMessageV3;\n+\n import javax.annotation.concurrent.NotThreadSafe;\n+import java.util.Collections;\n+import java.util.LinkedList;\n+import java.util.List;\n \n /**\n  * Used as a base class for wrapping context around proto messages.\n  *\n  * @param <T> Proto message type\n+ * @param <C> extended type\n  */\n @NotThreadSafe\n-public class OperationContext<T extends com.google.protobuf.GeneratedMessageV3.Builder<?>> {\n+public class OperationContext<T extends GeneratedMessageV3.Builder, C extends OperationContext> {\n   // Proto message that is being wrapped\n   private T mOptionsBuilder;\n   // Used to track client call status.\n-  private CallTracker mCallTracker;\n+  private List<CallTracker> mCallTrackers;\n \n   /**\n    * Creates an instance with given proto message.\n    *\n    * @param optionsBuilder Internal proto message builder instance\n    */\n   public OperationContext(T optionsBuilder) {\n-    this(optionsBuilder, null);\n     mOptionsBuilder = optionsBuilder;\n-    mCallTracker = CallTracker.NOOP_TRACKER;\n+    mCallTrackers = new LinkedList<>();\n   }\n \n   /**\n-   * Creates an instance with given proto message.\n+   * @return underlying proto message instance\n+   */\n+  public T getOptions() {\n+    return mOptionsBuilder;\n+  }\n+\n+  /**\n+   * Used to transfer trackers of a context to this instance.\n+   * This is required when creating internal contexts.\n    *\n-   * @param optionsBuilder Internal proto message builder instance\n-   * @param callTracker client call tracker, or {@code null} if no tracking is desired\n+   * @param context the source context\n+   * @return the updated instance\n    */\n-  public OperationContext(T optionsBuilder, CallTracker callTracker) {\n-    mOptionsBuilder = optionsBuilder;\n-    mCallTracker = callTracker;\n+  public C withTracker(OperationContext context) {\n+    mCallTrackers = context.mCallTrackers;\n+    return (C) this;\n   }\n \n   /**\n-   * @return underlying proto message instance\n+   * Updates this context with a new tracker.\n+   *\n+   * @param tracker the new call tracker\n+   * @return the updated instance\n    */\n-  public T getOptions() {\n-    return mOptionsBuilder;\n+  public C withTracker(CallTracker tracker) {\n+    mCallTrackers.add(tracker);\n+    return (C) this;\n   }\n \n   /**\n-   * TODO(ggezer): Make the call-tracker infra note the source of cancellation.\n-   * @return {@code true} if the call is cancelled by the client\n+   * @return the list of trackers that have cancelled this operation\n    */\n-  public boolean isCancelled() {\n-    return mCallTracker.isCancelled();\n+  public List<CallTracker> getCancelledTrackers() {\n+    boolean trackerCancelled = false;\n+    for (CallTracker tracker : mCallTrackers) {\n+      if (tracker.isCancelled()) {\n+        trackerCancelled = true;\n+        break;\n+      }\n+    }\n+\n+    if (!trackerCancelled) {\n+      return Collections.emptyList();\n+    }\n+\n+    List<CallTracker> cancelledTrackers = new LinkedList<>();\n+    for (CallTracker tracker : mCallTrackers) {\n+      if (tracker.isCancelled()) {\n+        cancelledTrackers.add(tracker);\n+      }\n+    }\n+\n+    return cancelledTrackers;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ5NDgxMw=="}, "originalCommit": {"oid": "20cc3348ec88f2237cf9606d9e3792f031e1b4b0"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MjEyMjU3OnYy", "diffSide": "RIGHT", "path": "core/server/master/src/test/java/alluxio/master/file/RpcContextTest.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yN1QwNzowMzo1NlrOGpz4nw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMjoxMjoxOVrOGtoutA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ5NDg3OQ==", "bodyText": "Would like to see some test coverage on throwing for cancelled trackers.", "url": "https://github.com/Alluxio/alluxio/pull/11674#discussion_r446494879", "createdAt": "2020-06-27T07:03:56Z", "author": {"login": "ZacBlanco"}, "path": "core/server/master/src/test/java/alluxio/master/file/RpcContextTest.java", "diffHunk": "@@ -34,11 +35,12 @@\n public final class RpcContextTest {\n   private BlockDeletionContext mMockBDC = mock(BlockDeletionContext.class);\n   private JournalContext mMockJC = mock(JournalContext.class);\n+  private OperationContext mMockOC = mock(OperationContext.class);\n   private RpcContext mRpcContext;\n \n   @Before\n   public void before() {\n-    mRpcContext = new RpcContext(mMockBDC, mMockJC);\n+    mRpcContext = new RpcContext(mMockBDC, mMockJC, mMockOC);\n   }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "20cc3348ec88f2237cf9606d9e3792f031e1b4b0"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU5NTU0Nw==", "bodyText": "I can't see a clear way to test cancellation while the rpc is in progress, aka the loop break logic. I'll try adding some validation for the rest.", "url": "https://github.com/Alluxio/alluxio/pull/11674#discussion_r446595547", "createdAt": "2020-06-28T03:39:00Z", "author": {"login": "ggezer"}, "path": "core/server/master/src/test/java/alluxio/master/file/RpcContextTest.java", "diffHunk": "@@ -34,11 +35,12 @@\n public final class RpcContextTest {\n   private BlockDeletionContext mMockBDC = mock(BlockDeletionContext.class);\n   private JournalContext mMockJC = mock(JournalContext.class);\n+  private OperationContext mMockOC = mock(OperationContext.class);\n   private RpcContext mRpcContext;\n \n   @Before\n   public void before() {\n-    mRpcContext = new RpcContext(mMockBDC, mMockJC);\n+    mRpcContext = new RpcContext(mMockBDC, mMockJC, mMockOC);\n   }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ5NDg3OQ=="}, "originalCommit": {"oid": "20cc3348ec88f2237cf9606d9e3792f031e1b4b0"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzI2NTIxOA==", "bodyText": "I think what I would do is use Mockito's Spy class and wrap in conjunction with some locks to allow for the control of entering/exiting methods. See the UfsStatusCacheTest for an example. I'll paste some code from one of the tests inline here so you can see what I mean.\ncreateUfsDirs(\"dir0/dir1\");\n    ExecutorService executor =\n        new ThreadPoolExecutor(1, 1, 1, TimeUnit.MINUTES, new SynchronousQueue<>());\n    mCache = new UfsStatusCache(executor);\n    mCache = Mockito.spy(mCache);\n    Lock l = new ReentrantLock();\n    l.lock();\n    doAnswer((invocation) -> {\n      try {\n        l.lock();\n        return invocation.callRealMethod();\n      } finally {\n        l.unlock();\n      }\n    }).when(mCache).getChildrenIfAbsent(any(AlluxioURI.class), any(MountTable.class));\n    assertNotNull(mCache.prefetchChildren(new AlluxioURI(\"/dir0\"), mMountTable));\n    assertNull(mCache.prefetchChildren(new AlluxioURI(\"/dir0\"), mMountTable)); // rejected\n    assertNull(mCache.prefetchChildren(new AlluxioURI(\"/dir0\"), mMountTable)); // rejected\n    assertNull(mCache.prefetchChildren(new AlluxioURI(\"/dir0\"), mMountTable)); // rejected\n    assertNull(mCache.prefetchChildren(new AlluxioURI(\"/dir0\"), mMountTable)); // rejected\n    l.unlock();\n    Collection<UfsStatus> statuses =\n        mCache.fetchChildrenIfAbsent(new AlluxioURI(\"/dir0\"), mMountTable, false);\n    assertEquals(1, statuses.size());\n    statuses.forEach(s -> assertEquals(\"dir1\", s.getName()));\nYou can also use the spys to verify that a method was/was not called (throwIfCancelled?)", "url": "https://github.com/Alluxio/alluxio/pull/11674#discussion_r447265218", "createdAt": "2020-06-29T21:29:29Z", "author": {"login": "ZacBlanco"}, "path": "core/server/master/src/test/java/alluxio/master/file/RpcContextTest.java", "diffHunk": "@@ -34,11 +35,12 @@\n public final class RpcContextTest {\n   private BlockDeletionContext mMockBDC = mock(BlockDeletionContext.class);\n   private JournalContext mMockJC = mock(JournalContext.class);\n+  private OperationContext mMockOC = mock(OperationContext.class);\n   private RpcContext mRpcContext;\n \n   @Before\n   public void before() {\n-    mRpcContext = new RpcContext(mMockBDC, mMockJC);\n+    mRpcContext = new RpcContext(mMockBDC, mMockJC, mMockOC);\n   }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ5NDg3OQ=="}, "originalCommit": {"oid": "20cc3348ec88f2237cf9606d9e3792f031e1b4b0"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDUwNjQyMA==", "bodyText": "I went for a simpler UT and think going beyond that will require an integration test with mocking which is not feasible.", "url": "https://github.com/Alluxio/alluxio/pull/11674#discussion_r450506420", "createdAt": "2020-07-06T22:12:19Z", "author": {"login": "ggezer"}, "path": "core/server/master/src/test/java/alluxio/master/file/RpcContextTest.java", "diffHunk": "@@ -34,11 +35,12 @@\n public final class RpcContextTest {\n   private BlockDeletionContext mMockBDC = mock(BlockDeletionContext.class);\n   private JournalContext mMockJC = mock(JournalContext.class);\n+  private OperationContext mMockOC = mock(OperationContext.class);\n   private RpcContext mRpcContext;\n \n   @Before\n   public void before() {\n-    mRpcContext = new RpcContext(mMockBDC, mMockJC);\n+    mRpcContext = new RpcContext(mMockBDC, mMockJC, mMockOC);\n   }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ5NDg3OQ=="}, "originalCommit": {"oid": "20cc3348ec88f2237cf9606d9e3792f031e1b4b0"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4NzQ1MTU1OnYy", "diffSide": "RIGHT", "path": "core/server/master/src/main/java/alluxio/master/file/contexts/OperationContext.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQyMToxMDoyMlrOGqiV4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQyMDozNToyN1rOGrNe-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzI1NjAzNA==", "bodyText": "I think it is strange to have an API called withTracker but the input parameter is not a tracker but a context? Why can't we just use the other implementation only?", "url": "https://github.com/Alluxio/alluxio/pull/11674#discussion_r447256034", "createdAt": "2020-06-29T21:10:22Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/master/file/contexts/OperationContext.java", "diffHunk": "@@ -11,54 +11,89 @@\n \n package alluxio.master.file.contexts;\n \n+import com.google.protobuf.GeneratedMessageV3;\n+\n import javax.annotation.concurrent.NotThreadSafe;\n+import java.util.Collections;\n+import java.util.LinkedList;\n+import java.util.List;\n \n /**\n  * Used as a base class for wrapping context around proto messages.\n  *\n  * @param <T> Proto message type\n+ * @param <C> extended type\n  */\n @NotThreadSafe\n-public class OperationContext<T extends com.google.protobuf.GeneratedMessageV3.Builder<?>> {\n+public class OperationContext<T extends GeneratedMessageV3.Builder, C extends OperationContext> {\n   // Proto message that is being wrapped\n   private T mOptionsBuilder;\n   // Used to track client call status.\n-  private CallTracker mCallTracker;\n+  private List<CallTracker> mCallTrackers;\n \n   /**\n    * Creates an instance with given proto message.\n    *\n    * @param optionsBuilder Internal proto message builder instance\n    */\n   public OperationContext(T optionsBuilder) {\n-    this(optionsBuilder, null);\n     mOptionsBuilder = optionsBuilder;\n-    mCallTracker = CallTracker.NOOP_TRACKER;\n+    mCallTrackers = new LinkedList<>();\n   }\n \n   /**\n-   * Creates an instance with given proto message.\n+   * @return underlying proto message instance\n+   */\n+  public T getOptions() {\n+    return mOptionsBuilder;\n+  }\n+\n+  /**\n+   * Used to transfer trackers of a context to this instance.\n+   * This is required when creating internal contexts.\n    *\n-   * @param optionsBuilder Internal proto message builder instance\n-   * @param callTracker client call tracker, or {@code null} if no tracking is desired\n+   * @param context the source context\n+   * @return the updated instance\n    */\n-  public OperationContext(T optionsBuilder, CallTracker callTracker) {\n-    mOptionsBuilder = optionsBuilder;\n-    mCallTracker = callTracker;\n+  public C withTracker(OperationContext context) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85725ebcdc9edbf4df2aa0edfef8991f31bb7e05"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk1ODkzNQ==", "bodyText": "I still have this question.", "url": "https://github.com/Alluxio/alluxio/pull/11674#discussion_r447958935", "createdAt": "2020-06-30T20:27:44Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/master/file/contexts/OperationContext.java", "diffHunk": "@@ -11,54 +11,89 @@\n \n package alluxio.master.file.contexts;\n \n+import com.google.protobuf.GeneratedMessageV3;\n+\n import javax.annotation.concurrent.NotThreadSafe;\n+import java.util.Collections;\n+import java.util.LinkedList;\n+import java.util.List;\n \n /**\n  * Used as a base class for wrapping context around proto messages.\n  *\n  * @param <T> Proto message type\n+ * @param <C> extended type\n  */\n @NotThreadSafe\n-public class OperationContext<T extends com.google.protobuf.GeneratedMessageV3.Builder<?>> {\n+public class OperationContext<T extends GeneratedMessageV3.Builder, C extends OperationContext> {\n   // Proto message that is being wrapped\n   private T mOptionsBuilder;\n   // Used to track client call status.\n-  private CallTracker mCallTracker;\n+  private List<CallTracker> mCallTrackers;\n \n   /**\n    * Creates an instance with given proto message.\n    *\n    * @param optionsBuilder Internal proto message builder instance\n    */\n   public OperationContext(T optionsBuilder) {\n-    this(optionsBuilder, null);\n     mOptionsBuilder = optionsBuilder;\n-    mCallTracker = CallTracker.NOOP_TRACKER;\n+    mCallTrackers = new LinkedList<>();\n   }\n \n   /**\n-   * Creates an instance with given proto message.\n+   * @return underlying proto message instance\n+   */\n+  public T getOptions() {\n+    return mOptionsBuilder;\n+  }\n+\n+  /**\n+   * Used to transfer trackers of a context to this instance.\n+   * This is required when creating internal contexts.\n    *\n-   * @param optionsBuilder Internal proto message builder instance\n-   * @param callTracker client call tracker, or {@code null} if no tracking is desired\n+   * @param context the source context\n+   * @return the updated instance\n    */\n-  public OperationContext(T optionsBuilder, CallTracker callTracker) {\n-    mOptionsBuilder = optionsBuilder;\n-    mCallTracker = callTracker;\n+  public C withTracker(OperationContext context) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzI1NjAzNA=="}, "originalCommit": {"oid": "85725ebcdc9edbf4df2aa0edfef8991f31bb7e05"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk2Mjg3Mw==", "bodyText": "turned out it was a dead method. removed.", "url": "https://github.com/Alluxio/alluxio/pull/11674#discussion_r447962873", "createdAt": "2020-06-30T20:35:27Z", "author": {"login": "ggezer"}, "path": "core/server/master/src/main/java/alluxio/master/file/contexts/OperationContext.java", "diffHunk": "@@ -11,54 +11,89 @@\n \n package alluxio.master.file.contexts;\n \n+import com.google.protobuf.GeneratedMessageV3;\n+\n import javax.annotation.concurrent.NotThreadSafe;\n+import java.util.Collections;\n+import java.util.LinkedList;\n+import java.util.List;\n \n /**\n  * Used as a base class for wrapping context around proto messages.\n  *\n  * @param <T> Proto message type\n+ * @param <C> extended type\n  */\n @NotThreadSafe\n-public class OperationContext<T extends com.google.protobuf.GeneratedMessageV3.Builder<?>> {\n+public class OperationContext<T extends GeneratedMessageV3.Builder, C extends OperationContext> {\n   // Proto message that is being wrapped\n   private T mOptionsBuilder;\n   // Used to track client call status.\n-  private CallTracker mCallTracker;\n+  private List<CallTracker> mCallTrackers;\n \n   /**\n    * Creates an instance with given proto message.\n    *\n    * @param optionsBuilder Internal proto message builder instance\n    */\n   public OperationContext(T optionsBuilder) {\n-    this(optionsBuilder, null);\n     mOptionsBuilder = optionsBuilder;\n-    mCallTracker = CallTracker.NOOP_TRACKER;\n+    mCallTrackers = new LinkedList<>();\n   }\n \n   /**\n-   * Creates an instance with given proto message.\n+   * @return underlying proto message instance\n+   */\n+  public T getOptions() {\n+    return mOptionsBuilder;\n+  }\n+\n+  /**\n+   * Used to transfer trackers of a context to this instance.\n+   * This is required when creating internal contexts.\n    *\n-   * @param optionsBuilder Internal proto message builder instance\n-   * @param callTracker client call tracker, or {@code null} if no tracking is desired\n+   * @param context the source context\n+   * @return the updated instance\n    */\n-  public OperationContext(T optionsBuilder, CallTracker callTracker) {\n-    mOptionsBuilder = optionsBuilder;\n-    mCallTracker = callTracker;\n+  public C withTracker(OperationContext context) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzI1NjAzNA=="}, "originalCommit": {"oid": "85725ebcdc9edbf4df2aa0edfef8991f31bb7e05"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4NzQ5ODg4OnYy", "diffSide": "RIGHT", "path": "core/server/master/src/main/java/alluxio/master/file/contexts/OperationContext.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQyMToyNTozNVrOGqiymw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOVQyMjozNTo1NlrOGqk5BQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzI2MzM4Nw==", "bodyText": "Is the only reason for this, to have a withTracker() call? It seems inconvenient to add the same class as a template class parameter. Instead, can't we just have a setTracker(), that updates the instance, and we just pass in the instance to the rpc call?", "url": "https://github.com/Alluxio/alluxio/pull/11674#discussion_r447263387", "createdAt": "2020-06-29T21:25:35Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/master/file/contexts/OperationContext.java", "diffHunk": "@@ -11,54 +11,89 @@\n \n package alluxio.master.file.contexts;\n \n+import com.google.protobuf.GeneratedMessageV3;\n+\n import javax.annotation.concurrent.NotThreadSafe;\n+import java.util.Collections;\n+import java.util.LinkedList;\n+import java.util.List;\n \n /**\n  * Used as a base class for wrapping context around proto messages.\n  *\n  * @param <T> Proto message type\n+ * @param <C> extended type", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "85725ebcdc9edbf4df2aa0edfef8991f31bb7e05"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzI5Nzc5Nw==", "bodyText": "I'm just trying to make service-handler clean by making the API pretty to use.", "url": "https://github.com/Alluxio/alluxio/pull/11674#discussion_r447297797", "createdAt": "2020-06-29T22:35:56Z", "author": {"login": "ggezer"}, "path": "core/server/master/src/main/java/alluxio/master/file/contexts/OperationContext.java", "diffHunk": "@@ -11,54 +11,89 @@\n \n package alluxio.master.file.contexts;\n \n+import com.google.protobuf.GeneratedMessageV3;\n+\n import javax.annotation.concurrent.NotThreadSafe;\n+import java.util.Collections;\n+import java.util.LinkedList;\n+import java.util.List;\n \n /**\n  * Used as a base class for wrapping context around proto messages.\n  *\n  * @param <T> Proto message type\n+ * @param <C> extended type", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzI2MzM4Nw=="}, "originalCommit": {"oid": "85725ebcdc9edbf4df2aa0edfef8991f31bb7e05"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgwODczNTM5OnYy", "diffSide": "RIGHT", "path": "core/server/master/src/test/java/alluxio/master/file/RpcContextTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMjoyMjoyOFrOGto8zQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQyMjoyMjoyOFrOGto8zQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDUxMDAyOQ==", "bodyText": "This is a good case for the ExpectedException rule since there aren't any assertions afterwards ;)", "url": "https://github.com/Alluxio/alluxio/pull/11674#discussion_r450510029", "createdAt": "2020-07-06T22:22:28Z", "author": {"login": "ZacBlanco"}, "path": "core/server/master/src/test/java/alluxio/master/file/RpcContextTest.java", "diffHunk": "@@ -105,6 +108,46 @@ public void journalContextThrows() throws Throwable {\n     checkClose(jcException);\n   }\n \n+  @Test\n+  public void testCallTrackers() throws Throwable {\n+    InternalOperationContext opCtx = new InternalOperationContext();\n+    // Add a call tracker that's always cancelled.\n+    opCtx = opCtx.withTracker(new CallTracker() {\n+      @Override\n+      public boolean isCancelled() {\n+        return true;\n+      }\n+\n+      @Override\n+      public Type getType() {\n+        return Type.GRPC_CLIENT_TRACKER;\n+      }\n+    });\n+    // Add a call tracker that's never cancelled.\n+    opCtx = opCtx.withTracker(new CallTracker() {\n+      @Override\n+      public boolean isCancelled() {\n+        return false;\n+      }\n+\n+      @Override\n+      public Type getType() {\n+        return Type.STATE_LOCK_TRACKER;\n+      }\n+    });\n+    // Create RPC context.\n+    RpcContext rpcCtx = new RpcContext(mMockBDC, mMockJC, opCtx);\n+    // Verify the RPC is cancelled due to tracker that's always cancelled.\n+    assertTrue(rpcCtx.isCancelled());\n+    try {\n+      // Verify cancellation throws.\n+      rpcCtx.throwIfCancelled();\n+      fail(\"Call should have been cancelled.\");\n+    } catch (RuntimeException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "189e4b8641253bafb1c0fc10cfaead84983fb39a"}, "originalPosition": 56}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1524, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}