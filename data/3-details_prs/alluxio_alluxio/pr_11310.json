{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA1MDU2MjI5", "number": 11310, "title": "Release resources properly within Worker ReadHandler", "bodyText": "Before this change, it was possible for workers to get into a state where all reader threads were starved because locks were taken for a certain block, but never released, so every time a new reader thread would attempt to acquire a lock on that block, it would hang the thread forever. Eventually all reads would fail.\nThis PR attempts to fix the issue by making some more guarantees about the serialized task executor, as well as cleaning up resources and sending a proper response back to the client whenever an error occurs. The main cause of the starved readers is due to RejectedExecutionException being thrown when the threadpool corresponding to alluxio.worker.network.block.reader.threads.max was at full capacity.\nFirst, we add a new threadpool to the GrpcExecutors class which backs the SerializedExecutors and is mainly responsible for sending the responses back to the client. We set the rejectedExecutionHandler to CallerRunsPolicy() so that if we do run out of threads, we fall back to the current thread running the task. Using this fallback policy is critical for the methods replyError, replyEof, and replyCancel, so the client does not get stuck waiting for a response. This now guarantees whenever these methods are called, we at least attempt to send the reply. Previously, submitting to the SerializingExecutor could fail, which means we never actually send the response to the client.\nThe 2nd major change is that when exceptions are thrown which should cause the stream to abort, we need to ensure that those messages are sent. The method handleStreamEndingException was added to ensure that when an exception is thrown, and we cannot continue the stream with the client, that we send a proper notification and then shut down the serializing executor and close any open blocks afterwards.\nFixes #11258", "createdAt": "2020-04-17T10:36:11Z", "url": "https://github.com/Alluxio/alluxio/pull/11310", "merged": true, "mergeCommit": {"oid": "55fbd6dd89393b5f69ada7141061ce2bfe7ad6c0"}, "closed": true, "closedAt": "2020-04-22T17:43:36Z", "author": {"login": "ZacBlanco"}, "timelineItems": {"totalCount": 23, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcYe0PwgH2gAyNDA1MDU2MjI5OjIyYjBlMjFhNGI5MDVmNWQ2NzFmYjJhNTNmZWNlZDllNTA0NTQ2OGY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABckVMq0AFqTQxNzMyOTY3Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "22b0e21a4b905f5d671fb2a53feced9e5045468f", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/22b0e21a4b905f5d671fb2a53feced9e5045468f", "committedDate": "2020-04-17T10:34:29Z", "message": "Clean resources properly within ReadHandler\n\nBy cleaning up the resources in the correct way, we avoid one major\nissue, which is forgetting to unlock a block when the call fails.\n\nFixes #11258"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "557484bf6cf6923dc55ca7bfe63297dab02300c7", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/557484bf6cf6923dc55ca7bfe63297dab02300c7", "committedDate": "2020-04-17T17:22:50Z", "message": "Add licenses, fix checkstyle"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1Njc4MzIw", "url": "https://github.com/Alluxio/alluxio/pull/11310#pullrequestreview-395678320", "createdAt": "2020-04-17T18:23:44Z", "commit": {"oid": "557484bf6cf6923dc55ca7bfe63297dab02300c7"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QxODoyMzo0NFrOGHYk1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xN1QyMDo1OTowMFrOGHc51w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM5NTg2MA==", "bodyText": "This isn't necessarily due to rejected execution since we catch exception on line 157?", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r410395860", "createdAt": "2020-04-17T18:23:44Z", "author": {"login": "calvinjia"}, "path": "core/server/worker/src/main/java/alluxio/worker/grpc/AbstractReadHandler.java", "diffHunk": "@@ -126,14 +152,36 @@ public void onNext(alluxio.grpc.ReadRequest request) {\n       mContext.setPosReceived(mContext.getRequest().getStart());\n       mDataReaderExecutor.submit(createDataReader(mContext, mResponseObserver));\n       mContext.setDataReaderActive(true);\n+    } catch (RejectedExecutionException e) {\n+      handleStreamEndingException(e, Status.RESOURCE_EXHAUSTED);\n     } catch (Exception e) {\n-      LogUtils.warnWithException(LOG, \"Exception occurred while processing read request {}.\",\n-          request, e);\n-      mSerializingExecutor.execute(() -> mResponseObserver\n-          .onError(AlluxioStatusException.fromCheckedException(e).toGrpcStatusException()));\n+      handleStreamEndingException(\n+          AlluxioStatusException.fromThrowable(e).toGrpcStatusException());\n     }\n   }\n \n+  private void handleStreamEndingException(StatusException e) {\n+    handleStreamEndingException(e, e.getStatus());\n+  }\n+\n+  // In this case, we hit an exception that does not allow us to proceed further\n+  private void handleStreamEndingException(Exception e, Status status) {\n+    // The executor is too busy to handle our requests. The stream should error.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "557484bf6cf6923dc55ca7bfe63297dab02300c7"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM5NjkzOQ==", "bodyText": "One line", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r410396939", "createdAt": "2020-04-17T18:25:51Z", "author": {"login": "calvinjia"}, "path": "core/server/worker/src/main/java/alluxio/worker/grpc/AbstractReadHandler.java", "diffHunk": "@@ -126,14 +152,36 @@ public void onNext(alluxio.grpc.ReadRequest request) {\n       mContext.setPosReceived(mContext.getRequest().getStart());\n       mDataReaderExecutor.submit(createDataReader(mContext, mResponseObserver));\n       mContext.setDataReaderActive(true);\n+    } catch (RejectedExecutionException e) {\n+      handleStreamEndingException(e, Status.RESOURCE_EXHAUSTED);\n     } catch (Exception e) {\n-      LogUtils.warnWithException(LOG, \"Exception occurred while processing read request {}.\",\n-          request, e);\n-      mSerializingExecutor.execute(() -> mResponseObserver\n-          .onError(AlluxioStatusException.fromCheckedException(e).toGrpcStatusException()));\n+      handleStreamEndingException(\n+          AlluxioStatusException.fromThrowable(e).toGrpcStatusException());\n     }\n   }\n \n+  private void handleStreamEndingException(StatusException e) {\n+    handleStreamEndingException(e, e.getStatus());\n+  }\n+\n+  // In this case, we hit an exception that does not allow us to proceed further\n+  private void handleStreamEndingException(Exception e, Status status) {\n+    // The executor is too busy to handle our requests. The stream should error.\n+    Long sessionId = mContext.getRequest() == null ? null : mContext.getRequest().getSessionId();\n+    LogUtils.warnWithException(LOG, \"handling RejectedExecutionException: sessionId: {}\",\n+        sessionId, e);\n+    AlluxioStatusException statusExc =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "557484bf6cf6923dc55ca7bfe63297dab02300c7"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ2NjA0OQ==", "bodyText": "Previously we do all the work in a separate thread ensuring abstract read handler methods execute fairly quickly. Will executing the data reader on this thread cause significant slowdowns?", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r410466049", "createdAt": "2020-04-17T20:57:23Z", "author": {"login": "calvinjia"}, "path": "core/server/worker/src/main/java/alluxio/worker/grpc/AbstractReadHandler.java", "diffHunk": "@@ -126,14 +152,36 @@ public void onNext(alluxio.grpc.ReadRequest request) {\n       mContext.setPosReceived(mContext.getRequest().getStart());\n       mDataReaderExecutor.submit(createDataReader(mContext, mResponseObserver));\n       mContext.setDataReaderActive(true);\n+    } catch (RejectedExecutionException e) {\n+      handleStreamEndingException(e, Status.RESOURCE_EXHAUSTED);\n     } catch (Exception e) {\n-      LogUtils.warnWithException(LOG, \"Exception occurred while processing read request {}.\",\n-          request, e);\n-      mSerializingExecutor.execute(() -> mResponseObserver\n-          .onError(AlluxioStatusException.fromCheckedException(e).toGrpcStatusException()));\n+      handleStreamEndingException(\n+          AlluxioStatusException.fromThrowable(e).toGrpcStatusException());\n     }\n   }\n \n+  private void handleStreamEndingException(StatusException e) {\n+    handleStreamEndingException(e, e.getStatus());\n+  }\n+\n+  // In this case, we hit an exception that does not allow us to proceed further\n+  private void handleStreamEndingException(Exception e, Status status) {\n+    // The executor is too busy to handle our requests. The stream should error.\n+    Long sessionId = mContext.getRequest() == null ? null : mContext.getRequest().getSessionId();\n+    LogUtils.warnWithException(LOG, \"handling RejectedExecutionException: sessionId: {}\",\n+        sessionId, e);\n+    AlluxioStatusException statusExc =\n+        new AlluxioStatusException(status);\n+    if (mContext == null) {\n+      mContext = createRequestContext(alluxio.grpc.ReadRequest.newBuilder().build());\n+    }\n+    setError(new Error(statusExc, true));\n+    // After calling setError, this will run the data reader to complete the request and close\n+    // any possibly opened blocks, then replies to the client with onError, and should eventually\n+    // shut down the serializing executor.\n+    createDataReader(mContext, mResponseObserver).run();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "557484bf6cf6923dc55ca7bfe63297dab02300c7"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDQ2Njc3NQ==", "bodyText": "Is there a functional change here, it seems like we lose the error message of failing to close the block reader?", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r410466775", "createdAt": "2020-04-17T20:59:00Z", "author": {"login": "calvinjia"}, "path": "core/server/worker/src/main/java/alluxio/worker/grpc/BlockReadHandler.java", "diffHunk": "@@ -82,27 +82,28 @@\n \n     @Override\n     protected void completeRequest(BlockReadRequestContext context) throws Exception {\n-      BlockReader reader = context.getBlockReader();\n-      if (reader != null) {\n-        try {\n+      BlockReader reader = null;\n+      try {\n+        reader = context.getBlockReader();\n+        if (reader != null) {\n           reader.close();\n-        } catch (Exception e) {\n-          LOG.warn(\"Failed to close block reader for block {} with error {}.\",\n-              context.getRequest().getId(), e.getMessage());\n         }\n-      }\n-      if (!mWorker.unlockBlock(context.getRequest().getSessionId(), context.getRequest().getId())) {\n-        if (reader != null) {\n-          mWorker.closeUfsBlock(context.getRequest().getSessionId(), context.getRequest().getId());\n-          context.setBlockReader(null);\n+      } finally {\n+        if (!mWorker.unlockBlock(context.getRequest().getSessionId(),\n+            context.getRequest().getId())) {\n+          if (reader != null) {\n+            mWorker.closeUfsBlock(context.getRequest().getSessionId(),\n+                context.getRequest().getId());\n+            context.setBlockReader(null);\n+          }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "557484bf6cf6923dc55ca7bfe63297dab02300c7"}, "originalPosition": 39}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "619592a5ec5676d691ceae2bffee28b0503cee41", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/619592a5ec5676d691ceae2bffee28b0503cee41", "committedDate": "2020-04-17T23:35:44Z", "message": "Address comments\n\n- Add back missed exception on BlockReadHandler\n- When handling stream ending exception, attempt to run the data reader in a\nseparate thread first."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1ODQ0NzE0", "url": "https://github.com/Alluxio/alluxio/pull/11310#pullrequestreview-395844714", "createdAt": "2020-04-18T00:58:16Z", "commit": {"oid": "619592a5ec5676d691ceae2bffee28b0503cee41"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQwMDo1ODoxNlrOGHgrog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOFQwMDo1ODoxNlrOGHgrog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyODY3NA==", "bodyText": "Throwable", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r410528674", "createdAt": "2020-04-18T00:58:16Z", "author": {"login": "witgo"}, "path": "core/common/src/main/java/alluxio/util/executor/SerializedTaskRunner.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.util.executor;\n+\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * This class can execute a series of tasks on a separate thread in the order they are submitted.\n+ * No guarantees can be made about the timing of how the tasks complete, or what the result of\n+ * the tasks are.\n+ *\n+ * All tasks in the queue are guaranteed to complete before {@link #shutdown(long, TimeUnit)} is\n+ * called so long as they complete within the provided timeout. At which time the task runner will\n+ * stop accepting new tasks (all calls to {@link #addTask(Runnable)} will return false).\n+ *\n+ */\n+public class SerializedTaskRunner implements Runnable {\n+  private static final Logger LOG = LoggerFactory.getLogger(SerializedTaskRunner.class);\n+\n+  private volatile boolean mRunning;\n+  private volatile boolean mIsShutdown;\n+  private final LinkedBlockingQueue<Runnable> mTasks;\n+  private volatile Thread mRunningThread;\n+\n+  /**\n+   * Create a new instance of {@link SerializedTaskRunner}.\n+   */\n+  public SerializedTaskRunner() {\n+    mTasks = new LinkedBlockingQueue<>();\n+    mRunning = true;\n+    mIsShutdown = false;\n+  }\n+\n+  /**\n+   * Add a new task to execute into the queue.\n+   *\n+   * @param r task to run\n+   *\n+   * @return true if the task was added to the queue successfully\n+   */\n+  public boolean addTask(Runnable r) {\n+    if (mIsShutdown) {\n+      return false;\n+    }\n+    return mTasks.add(r);\n+  }\n+\n+  @Override\n+  public void run() {\n+    mRunningThread = Thread.currentThread();\n+    while (mRunning) {\n+      try {\n+        Runnable task = mTasks.take();\n+        try {\n+          task.run();\n+        } catch (RuntimeException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "619592a5ec5676d691ceae2bffee28b0503cee41"}, "originalPosition": 71}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c0e8727224089821327a838559e58240f9698cab", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/c0e8727224089821327a838559e58240f9698cab", "committedDate": "2020-04-20T04:46:57Z", "message": "Catch throwable instead of RuntimeException"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2NjM3NDE0", "url": "https://github.com/Alluxio/alluxio/pull/11310#pullrequestreview-396637414", "createdAt": "2020-04-20T16:53:51Z", "commit": {"oid": "619592a5ec5676d691ceae2bffee28b0503cee41"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNjo1Mzo1MlrOGIeL3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQxNzoxMjo1MlrOGIe9HQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTUzNjM0OA==", "bodyText": "Why not all exceptions?", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r411536348", "createdAt": "2020-04-20T16:53:52Z", "author": {"login": "ggezer"}, "path": "core/server/worker/src/main/java/alluxio/worker/grpc/AbstractReadHandler.java", "diffHunk": "@@ -237,9 +301,13 @@ protected abstract DataReader createDataReader(T context,\n \n   public void onReady() {\n     try (LockResource lr = new LockResource(mLock)) {\n-      if (shouldRestartDataReader()) {\n-        mDataReaderExecutor.submit(createDataReader(mContext, mResponseObserver));\n-        mContext.setDataReaderActive(true);\n+      if (shouldRestartDataReader() && !mFinished.get()) {\n+        try {\n+          mDataReaderExecutor.submit(createDataReader(mContext, mResponseObserver));\n+          mContext.setDataReaderActive(true);\n+        } catch (RejectedExecutionException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "619592a5ec5676d691ceae2bffee28b0503cee41"}, "originalPosition": 207}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU0MTU4Mw==", "bodyText": "Why do we need this?", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r411541583", "createdAt": "2020-04-20T17:01:40Z", "author": {"login": "ggezer"}, "path": "core/common/src/main/java/alluxio/util/executor/SerializedTaskRunner.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.util.executor;\n+\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * This class can execute a series of tasks on a separate thread in the order they are submitted.\n+ * No guarantees can be made about the timing of how the tasks complete, or what the result of\n+ * the tasks are.\n+ *\n+ * All tasks in the queue are guaranteed to complete before {@link #shutdown(long, TimeUnit)} is\n+ * called so long as they complete within the provided timeout. At which time the task runner will\n+ * stop accepting new tasks (all calls to {@link #addTask(Runnable)} will return false).\n+ *\n+ */\n+public class SerializedTaskRunner implements Runnable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "619592a5ec5676d691ceae2bffee28b0503cee41"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU0NDMwMA==", "bodyText": "We shouldn't care.\nThread here is allocated from gRPC's internal no-limit pool, just to serve onNext() and terminate afterward.", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r411544300", "createdAt": "2020-04-20T17:05:49Z", "author": {"login": "ggezer"}, "path": "core/server/worker/src/main/java/alluxio/worker/grpc/AbstractReadHandler.java", "diffHunk": "@@ -126,11 +153,46 @@ public void onNext(alluxio.grpc.ReadRequest request) {\n       mContext.setPosReceived(mContext.getRequest().getStart());\n       mDataReaderExecutor.submit(createDataReader(mContext, mResponseObserver));\n       mContext.setDataReaderActive(true);\n+    } catch (RejectedExecutionException e) {\n+      handleStreamEndingException(e, Status.RESOURCE_EXHAUSTED);\n     } catch (Exception e) {\n-      LogUtils.warnWithException(LOG, \"Exception occurred while processing read request {}.\",\n-          request, e);\n-      mSerializingExecutor.execute(() -> mResponseObserver\n-          .onError(AlluxioStatusException.fromCheckedException(e).toGrpcStatusException()));\n+      handleStreamEndingException(\n+          AlluxioStatusException.fromThrowable(e).toGrpcStatusException());\n+    }\n+  }\n+\n+  private void handleStreamEndingException(StatusException e) {\n+    handleStreamEndingException(e, e.getStatus());\n+  }\n+\n+  /**\n+   * Handle any exception which should abort the client's read request.\n+   *\n+   * @param exception the exception thrown\n+   * @param status the type of {@link Status} exception which should be returned to the user\n+   */\n+  private void handleStreamEndingException(Exception exception, Status status) {\n+    Long sessionId = mContext.getRequest() == null ? null : mContext.getRequest().getSessionId();\n+    LogUtils.warnWithException(LOG, \"fatal error occurred while handling read. sessionId: {}\",\n+        sessionId, exception);\n+    AlluxioStatusException statusExc = new AlluxioStatusException(status);\n+    try (LockResource lr = new LockResource(mLock)) {\n+      if (mContext == null) {\n+        mContext = createRequestContext(alluxio.grpc.ReadRequest.newBuilder().build());\n+      }\n+      setError(new Error(statusExc, true));\n+    }\n+    // After calling setError, this will run the data reader to complete the request and close\n+    // any possibly opened blocks, then replies to the client with onError, and should eventually\n+    // shut down the serializing executor.\n+    // If possible, we should free up this thread immediately by running the data reader in a\n+    // separate thread because we want to avoid the possibility of blocking the `onNext` method", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "619592a5ec5676d691ceae2bffee28b0503cee41"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU0NjI3Mw==", "bodyText": "Why not send it in-line?", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r411546273", "createdAt": "2020-04-20T17:08:49Z", "author": {"login": "ggezer"}, "path": "core/server/worker/src/main/java/alluxio/worker/grpc/AbstractReadHandler.java", "diffHunk": "@@ -337,7 +408,7 @@ private void runInternal() {\n \n           if (chunk != null) {\n             DataBuffer finalChunk = chunk;\n-            mSerializingExecutor.execute(() -> {\n+            mSerializingExecutor.addTask(() -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "619592a5ec5676d691ceae2bffee28b0503cee41"}, "originalPosition": 230}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU0NjcwMw==", "bodyText": "Why not send it in-line?", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r411546703", "createdAt": "2020-04-20T17:09:27Z", "author": {"login": "ggezer"}, "path": "core/server/worker/src/main/java/alluxio/worker/grpc/AbstractReadHandler.java", "diffHunk": "@@ -409,18 +482,16 @@ private void runInternal() {\n      * configurable transfer type.\n      *\n      * @param context context of the request to complete\n-     * @param response the gRPC response observer\n      * @param len The length, in bytes, of the data to read from the block\n      * @return a {@link DataBuffer} representing the data\n      */\n-    protected abstract DataBuffer getDataBuffer(T context, StreamObserver<ReadResponse> response,\n-        long offset, int len) throws Exception;\n+    protected abstract DataBuffer getDataBuffer(T context, long offset, int len) throws Exception;\n \n     /**\n      * Writes an error read response to the channel and closes the channel after that.\n      */\n     private void replyError(Error error) {\n-      mSerializingExecutor.execute(() -> {\n+      mSerializingExecutor.addTask(() -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "619592a5ec5676d691ceae2bffee28b0503cee41"}, "originalPosition": 276}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU0ODQ4Mg==", "bodyText": "What does WORKER_NETWORK_BLOCK_READER_THREADS_MAX limit when used with this pool?", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r411548482", "createdAt": "2020-04-20T17:12:05Z", "author": {"login": "ggezer"}, "path": "core/server/worker/src/main/java/alluxio/worker/grpc/GrpcExecutors.java", "diffHunk": "@@ -48,6 +48,12 @@\n           THREAD_STOP_MS, TimeUnit.MILLISECONDS, new SynchronousQueue<>(),\n           ThreadFactoryUtils.build(\"BlockDataReaderExecutor-%d\", true)));\n \n+  public static final ExecutorService BLOCK_READER_SERIALIZED_RUNNER_EXECUTOR =\n+      new ImpersonateThreadPoolExecutor(new ThreadPoolExecutor(THREADS_MIN,\n+          ServerConfiguration.getInt(PropertyKey.WORKER_NETWORK_BLOCK_READER_THREADS_MAX),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "619592a5ec5676d691ceae2bffee28b0503cee41"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU0ODk1Nw==", "bodyText": "Does this mean every new SerializedTaskRunner will hold a thread off this pool?", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r411548957", "createdAt": "2020-04-20T17:12:52Z", "author": {"login": "ggezer"}, "path": "core/common/src/main/java/alluxio/util/executor/SerializedTaskRunner.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.util.executor;\n+\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * This class can execute a series of tasks on a separate thread in the order they are submitted.\n+ * No guarantees can be made about the timing of how the tasks complete, or what the result of\n+ * the tasks are.\n+ *\n+ * All tasks in the queue are guaranteed to complete before {@link #shutdown(long, TimeUnit)} is\n+ * called so long as they complete within the provided timeout. At which time the task runner will\n+ * stop accepting new tasks (all calls to {@link #addTask(Runnable)} will return false).\n+ *\n+ */\n+public class SerializedTaskRunner implements Runnable {\n+  private static final Logger LOG = LoggerFactory.getLogger(SerializedTaskRunner.class);\n+\n+  private volatile boolean mRunning;\n+  private volatile boolean mIsShutdown;\n+  private final LinkedBlockingQueue<Runnable> mTasks;\n+  private volatile Thread mRunningThread;\n+\n+  /**\n+   * Create a new instance of {@link SerializedTaskRunner}.\n+   */\n+  public SerializedTaskRunner() {\n+    mTasks = new LinkedBlockingQueue<>();\n+    mRunning = true;\n+    mIsShutdown = false;\n+  }\n+\n+  /**\n+   * Add a new task to execute into the queue.\n+   *\n+   * @param r task to run\n+   *\n+   * @return true if the task was added to the queue successfully\n+   */\n+  public boolean addTask(Runnable r) {\n+    if (mIsShutdown) {\n+      return false;\n+    }\n+    return mTasks.add(r);\n+  }\n+\n+  @Override\n+  public void run() {\n+    mRunningThread = Thread.currentThread();\n+    while (mRunning) {\n+      try {\n+        Runnable task = mTasks.take();\n+        try {\n+          task.run();\n+        } catch (RuntimeException e) {\n+          LOG.warn(\"Exception in serialized task runner: \", e);\n+        }\n+      } catch (InterruptedException e) {\n+        LOG.debug(\"Interrupted while waiting for task\");\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Shuts down the task runner.\n+   *\n+   * No new tasks are accepted after this method is called. Remaining tasks are attempted to all\n+   * be executed within the shutdown timeout. Otherwise, after the timeout the running thread\n+   * will exit, any remaining tasks will fail to ever be executed.\n+   *\n+   * @param time the time to spend before aborting any outstanding tasks\n+   * @param unit the {@link TimeUnit} corresponding to the time argument\n+   */\n+  public synchronized void shutdown(long time, TimeUnit unit) {\n+    Preconditions.checkNotNull(unit, \"time unit\");\n+    if (mIsShutdown) {\n+      return;\n+    }\n+    mIsShutdown = true;\n+    long totalTime = unit.toMillis(time);\n+    long curr;\n+    long start = curr = System.currentTimeMillis();\n+    while (mTasks.size() > 0 || curr - start > totalTime) {\n+      curr = System.currentTimeMillis();\n+      Thread.yield();\n+    }\n+    mRunning = false;\n+    mRunningThread.interrupt();\n+    mRunningThread = null;\n+  }\n+\n+  /**\n+   * A Factory which can spawn new {@link SerializedTaskRunner}s on separate threads using an\n+   * available {@link ExecutorService}.\n+   */\n+  public static class Factory {\n+    private final ExecutorService mService;\n+\n+    /**\n+     * Create a new instance of  {@link Factory}.\n+     *\n+     * @param svc the executor service backing this factory\n+     */\n+    public Factory(ExecutorService svc) {\n+      mService = svc;\n+    }\n+\n+    /**\n+     * Spawn a new task executor which can begin queueing new tasks.\n+     *\n+     * It is not guaranteed to immediately begin running tasks. It will depend on the underlying\n+     * executor's ability to allocate a thread to this task runner.\n+     *\n+     * @return a new {@link SerializedTaskRunner}\n+     */\n+    public SerializedTaskRunner create() {\n+      SerializedTaskRunner runner = new SerializedTaskRunner();\n+      mService.execute(runner);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "619592a5ec5676d691ceae2bffee28b0503cee41"}, "originalPosition": 134}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2OTEwMzYz", "url": "https://github.com/Alluxio/alluxio/pull/11310#pullrequestreview-396910363", "createdAt": "2020-04-21T00:34:41Z", "commit": {"oid": "c0e8727224089821327a838559e58240f9698cab"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwMDozNDo0MlrOGItTwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwMDo0ODoyMVrOGItlcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc4NDEyOA==", "bodyText": "It will not be very efficient to hold a thread for the entire life of a request. The client might not be actively processing data so a number of the threads in pool will be taken by idle runners, lower workers ability to process concurrent requests.", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r411784128", "createdAt": "2020-04-21T00:34:42Z", "author": {"login": "bf8086"}, "path": "core/common/src/main/java/alluxio/util/executor/SerializedTaskRunner.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.util.executor;\n+\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * This class can execute a series of tasks on a separate thread in the order they are submitted.\n+ * No guarantees can be made about the timing of how the tasks complete, or what the result of\n+ * the tasks are.\n+ *\n+ * All tasks in the queue are guaranteed to complete before {@link #shutdown(long, TimeUnit)} is\n+ * called so long as they complete within the provided timeout. At which time the task runner will\n+ * stop accepting new tasks (all calls to {@link #addTask(Runnable)} will return false).\n+ *\n+ */\n+public class SerializedTaskRunner implements Runnable {\n+  private static final Logger LOG = LoggerFactory.getLogger(SerializedTaskRunner.class);\n+\n+  private volatile boolean mRunning;\n+  private volatile boolean mIsShutdown;\n+  private final LinkedBlockingQueue<Runnable> mTasks;\n+  private volatile Thread mRunningThread;\n+\n+  /**\n+   * Create a new instance of {@link SerializedTaskRunner}.\n+   */\n+  public SerializedTaskRunner() {\n+    mTasks = new LinkedBlockingQueue<>();\n+    mRunning = true;\n+    mIsShutdown = false;\n+  }\n+\n+  /**\n+   * Add a new task to execute into the queue.\n+   *\n+   * @param r task to run\n+   *\n+   * @return true if the task was added to the queue successfully\n+   */\n+  public boolean addTask(Runnable r) {\n+    if (mIsShutdown) {\n+      return false;\n+    }\n+    return mTasks.add(r);\n+  }\n+\n+  @Override\n+  public void run() {\n+    mRunningThread = Thread.currentThread();\n+    while (mRunning) {\n+      try {\n+        Runnable task = mTasks.take();\n+        try {\n+          task.run();\n+        } catch (RuntimeException e) {\n+          LOG.warn(\"Exception in serialized task runner: \", e);\n+        }\n+      } catch (InterruptedException e) {\n+        LOG.debug(\"Interrupted while waiting for task\");\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Shuts down the task runner.\n+   *\n+   * No new tasks are accepted after this method is called. Remaining tasks are attempted to all\n+   * be executed within the shutdown timeout. Otherwise, after the timeout the running thread\n+   * will exit, any remaining tasks will fail to ever be executed.\n+   *\n+   * @param time the time to spend before aborting any outstanding tasks\n+   * @param unit the {@link TimeUnit} corresponding to the time argument\n+   */\n+  public synchronized void shutdown(long time, TimeUnit unit) {\n+    Preconditions.checkNotNull(unit, \"time unit\");\n+    if (mIsShutdown) {\n+      return;\n+    }\n+    mIsShutdown = true;\n+    long totalTime = unit.toMillis(time);\n+    long curr;\n+    long start = curr = System.currentTimeMillis();\n+    while (mTasks.size() > 0 || curr - start > totalTime) {\n+      curr = System.currentTimeMillis();\n+      Thread.yield();\n+    }\n+    mRunning = false;\n+    mRunningThread.interrupt();\n+    mRunningThread = null;\n+  }\n+\n+  /**\n+   * A Factory which can spawn new {@link SerializedTaskRunner}s on separate threads using an\n+   * available {@link ExecutorService}.\n+   */\n+  public static class Factory {\n+    private final ExecutorService mService;\n+\n+    /**\n+     * Create a new instance of  {@link Factory}.\n+     *\n+     * @param svc the executor service backing this factory\n+     */\n+    public Factory(ExecutorService svc) {\n+      mService = svc;\n+    }\n+\n+    /**\n+     * Spawn a new task executor which can begin queueing new tasks.\n+     *\n+     * It is not guaranteed to immediately begin running tasks. It will depend on the underlying\n+     * executor's ability to allocate a thread to this task runner.\n+     *\n+     * @return a new {@link SerializedTaskRunner}\n+     */\n+    public SerializedTaskRunner create() {\n+      SerializedTaskRunner runner = new SerializedTaskRunner();\n+      mService.execute(runner);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTU0ODk1Nw=="}, "originalCommit": {"oid": "619592a5ec5676d691ceae2bffee28b0503cee41"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTc4ODY1Ng==", "bodyText": "Shall we just bail out and respond error directly if the context is not even created?", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r411788656", "createdAt": "2020-04-21T00:48:21Z", "author": {"login": "bf8086"}, "path": "core/server/worker/src/main/java/alluxio/worker/grpc/AbstractReadHandler.java", "diffHunk": "@@ -126,11 +153,46 @@ public void onNext(alluxio.grpc.ReadRequest request) {\n       mContext.setPosReceived(mContext.getRequest().getStart());\n       mDataReaderExecutor.submit(createDataReader(mContext, mResponseObserver));\n       mContext.setDataReaderActive(true);\n+    } catch (RejectedExecutionException e) {\n+      handleStreamEndingException(e, Status.RESOURCE_EXHAUSTED);\n     } catch (Exception e) {\n-      LogUtils.warnWithException(LOG, \"Exception occurred while processing read request {}.\",\n-          request, e);\n-      mSerializingExecutor.execute(() -> mResponseObserver\n-          .onError(AlluxioStatusException.fromCheckedException(e).toGrpcStatusException()));\n+      handleStreamEndingException(\n+          AlluxioStatusException.fromThrowable(e).toGrpcStatusException());\n+    }\n+  }\n+\n+  private void handleStreamEndingException(StatusException e) {\n+    handleStreamEndingException(e, e.getStatus());\n+  }\n+\n+  /**\n+   * Handle any exception which should abort the client's read request.\n+   *\n+   * @param exception the exception thrown\n+   * @param status the type of {@link Status} exception which should be returned to the user\n+   */\n+  private void handleStreamEndingException(Exception exception, Status status) {\n+    Long sessionId = mContext.getRequest() == null ? null : mContext.getRequest().getSessionId();\n+    LogUtils.warnWithException(LOG, \"fatal error occurred while handling read. sessionId: {}\",\n+        sessionId, exception);\n+    AlluxioStatusException statusExc = new AlluxioStatusException(status);\n+    try (LockResource lr = new LockResource(mLock)) {\n+      if (mContext == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c0e8727224089821327a838559e58240f9698cab"}, "originalPosition": 137}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "93b4598116c7d96b4b6a25b42b26dc40845ef74b", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/93b4598116c7d96b4b6a25b42b26dc40845ef74b", "committedDate": "2020-04-21T04:03:09Z", "message": "Use an unbounded SerializedExecutor"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3MTI1MjAw", "url": "https://github.com/Alluxio/alluxio/pull/11310#pullrequestreview-397125200", "createdAt": "2020-04-21T08:54:59Z", "commit": {"oid": "93b4598116c7d96b4b6a25b42b26dc40845ef74b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwODo1NDo1OVrOGI6kYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQwODo1NDo1OVrOGI6kYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjAwMTM3OQ==", "bodyText": "Why do we need two thread pools?", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r412001379", "createdAt": "2020-04-21T08:54:59Z", "author": {"login": "witgo"}, "path": "core/server/worker/src/main/java/alluxio/worker/grpc/AbstractReadHandler.java", "diffHunk": "@@ -100,9 +103,10 @@\n   AbstractReadHandler(ExecutorService executorService,\n       StreamObserver<ReadResponse> responseObserver, AuthenticatedUserInfo userInfo) {\n     mDataReaderExecutor = executorService;\n-    mSerializingExecutor = new SerializingExecutor(executorService);\n     mResponseObserver = responseObserver;\n     mUserInfo = userInfo;\n+    mSerializingExecutor =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93b4598116c7d96b4b6a25b42b26dc40845ef74b"}, "originalPosition": 53}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3MzQ3NTQw", "url": "https://github.com/Alluxio/alluxio/pull/11310#pullrequestreview-397347540", "createdAt": "2020-04-21T13:48:11Z", "commit": {"oid": "93b4598116c7d96b4b6a25b42b26dc40845ef74b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxMzo0ODoxMVrOGJGsdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxMzo0ODoxMVrOGJGsdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjIwMDA1Mg==", "bodyText": "If it is changed to new LinkedBlockingQueue<>(),  the mDataReaderExecutor#submit will not throw a RejectedExecutionException exception .", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r412200052", "createdAt": "2020-04-21T13:48:11Z", "author": {"login": "witgo"}, "path": "core/server/worker/src/main/java/alluxio/worker/grpc/GrpcExecutors.java", "diffHunk": "@@ -48,6 +48,11 @@\n           THREAD_STOP_MS, TimeUnit.MILLISECONDS, new SynchronousQueue<>(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93b4598116c7d96b4b6a25b42b26dc40845ef74b"}, "originalPosition": 10}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4a6a0f35bd710f7270e5e92b6666951f2337c163", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/4a6a0f35bd710f7270e5e92b6666951f2337c163", "committedDate": "2020-04-21T17:31:25Z", "message": "Client should check for error after data timeout\n\n- We should check the error before throwing deadline exceeded\nto avoid masking any potential error messages already sent from\nthe worker."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3NTg4NzM4", "url": "https://github.com/Alluxio/alluxio/pull/11310#pullrequestreview-397588738", "createdAt": "2020-04-21T18:58:36Z", "commit": {"oid": "4a6a0f35bd710f7270e5e92b6666951f2337c163"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3NjA5NzMx", "url": "https://github.com/Alluxio/alluxio/pull/11310#pullrequestreview-397609731", "createdAt": "2020-04-21T19:28:17Z", "commit": {"oid": "4a6a0f35bd710f7270e5e92b6666951f2337c163"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "21afee753064f4c5d571c131475678e4b4ffe638", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/21afee753064f4c5d571c131475678e4b4ffe638", "committedDate": "2020-04-21T21:25:29Z", "message": "Use CallerRunsPolicy for overloaded SerializedExec"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3NzU1NTMy", "url": "https://github.com/Alluxio/alluxio/pull/11310#pullrequestreview-397755532", "createdAt": "2020-04-22T00:01:49Z", "commit": {"oid": "21afee753064f4c5d571c131475678e4b4ffe638"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMDowMTo0OVrOGJdeJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMDowMTo0OVrOGJdeJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU3MzIyMw==", "bodyText": "When will this happen? Will it be too chatty on the log?", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r412573223", "createdAt": "2020-04-22T00:01:49Z", "author": {"login": "bf8086"}, "path": "core/server/worker/src/main/java/alluxio/worker/grpc/AbstractReadHandler.java", "diffHunk": "@@ -439,8 +485,12 @@ private void replyEof() {\n       mSerializingExecutor.execute(() -> {\n         try {\n           Preconditions.checkState(!mContext.isDoneUnsafe());\n-          mContext.setDoneUnsafe(true);\n-          mResponse.onCompleted();\n+          if (!mContext.isDoneUnsafe()) {\n+            mContext.setDoneUnsafe(true);\n+            mResponse.onCompleted();\n+          } else {\n+            LOG.warn(\"Tried to replyEof when stream was already finished. context: {}\", mContext);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21afee753064f4c5d571c131475678e4b4ffe638"}, "originalPosition": 250}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "479b34328c2469d2e9bf9e946e36d30ca844db8c", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/479b34328c2469d2e9bf9e946e36d30ca844db8c", "committedDate": "2020-04-22T00:20:16Z", "message": "Move log for replies to debug"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3NzYxNzg0", "url": "https://github.com/Alluxio/alluxio/pull/11310#pullrequestreview-397761784", "createdAt": "2020-04-22T00:20:50Z", "commit": {"oid": "21afee753064f4c5d571c131475678e4b4ffe638"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMDoyMDo1MFrOGJd3sg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMDoyMDo1MFrOGJd3sg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU3OTc2Mg==", "bodyText": "remove this line?", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r412579762", "createdAt": "2020-04-22T00:20:50Z", "author": {"login": "bf8086"}, "path": "core/server/worker/src/main/java/alluxio/worker/grpc/AbstractReadHandler.java", "diffHunk": "@@ -439,8 +485,12 @@ private void replyEof() {\n       mSerializingExecutor.execute(() -> {\n         try {\n           Preconditions.checkState(!mContext.isDoneUnsafe());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21afee753064f4c5d571c131475678e4b4ffe638"}, "originalPosition": 243}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f0251df0a7a2b0c63c63999e8a9a6f1e811e9e81", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/f0251df0a7a2b0c63c63999e8a9a6f1e811e9e81", "committedDate": "2020-04-22T01:20:35Z", "message": "Remove precondition check"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3NzgxMzYy", "url": "https://github.com/Alluxio/alluxio/pull/11310#pullrequestreview-397781362", "createdAt": "2020-04-22T01:29:43Z", "commit": {"oid": "f0251df0a7a2b0c63c63999e8a9a6f1e811e9e81"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3Nzg2MjA0", "url": "https://github.com/Alluxio/alluxio/pull/11310#pullrequestreview-397786204", "createdAt": "2020-04-22T01:45:14Z", "commit": {"oid": "f0251df0a7a2b0c63c63999e8a9a6f1e811e9e81"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMTo0NToxNFrOGJfl8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMTo0NToxNFrOGJfl8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYwNzk4NQ==", "bodyText": "Why is this the case now?", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r412607985", "createdAt": "2020-04-22T01:45:14Z", "author": {"login": "ggezer"}, "path": "core/server/worker/src/main/java/alluxio/worker/grpc/AbstractReadHandler.java", "diffHunk": "@@ -484,7 +484,6 @@ private void replyError(Error error) {\n     private void replyEof() {\n       mSerializingExecutor.execute(() -> {\n         try {\n-          Preconditions.checkState(!mContext.isDoneUnsafe());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0251df0a7a2b0c63c63999e8a9a6f1e811e9e81"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4MzkxNjcx", "url": "https://github.com/Alluxio/alluxio/pull/11310#pullrequestreview-398391671", "createdAt": "2020-04-22T16:58:39Z", "commit": {"oid": "f0251df0a7a2b0c63c63999e8a9a6f1e811e9e81"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3MzI5Njc2", "url": "https://github.com/Alluxio/alluxio/pull/11310#pullrequestreview-417329676", "createdAt": "2020-05-24T06:09:12Z", "commit": {"oid": "f0251df0a7a2b0c63c63999e8a9a6f1e811e9e81"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNFQwNjowOToxMlrOGZs30A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNFQwNjowOToxMlrOGZs30A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTYwMjc2OA==", "bodyText": "@ZacBlanco Is there a reason for moving this continue out?\nIs it possible for this to cause a tight-loop here? or a premature exit without sending a reply?", "url": "https://github.com/Alluxio/alluxio/pull/11310#discussion_r429602768", "createdAt": "2020-05-24T06:09:12Z", "author": {"login": "ggezer"}, "path": "core/server/worker/src/main/java/alluxio/worker/grpc/AbstractReadHandler.java", "diffHunk": "@@ -355,19 +397,18 @@ private void runInternal() {\n                     mContext.getRequest(), e);\n                 setError(new Error(AlluxioStatusException.fromThrowable(e), true));\n               } finally {\n-                if (finalChunk != null) {\n-                  finalChunk.release();\n-                }\n+                finalChunk.release();\n               }\n             });\n           }\n         } catch (Exception e) {\n           LogUtils.warnWithException(LOG,\n-              \"Exception occurred while reading data for read request {}.\", mContext.getRequest(),\n+              \"Exception occurred while reading data for read request {}. session {}\",\n+              mContext.getRequest(), mContext.getRequest().getSessionId(),\n               e);\n           setError(new Error(AlluxioStatusException.fromThrowable(e), true));\n-          continue;\n         }\n+        continue;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0251df0a7a2b0c63c63999e8a9a6f1e811e9e81"}, "originalPosition": 197}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4763, "cost": 1, "resetAt": "2021-10-29T17:30:11Z"}}}