{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM2MDE2NzQ5", "number": 11579, "title": "Fix deadlock issue on metadata sync", "bodyText": "This deadlock occurs when concurrent clients submit requests to\npaths where one is the parent of another. It is most likely to\noccur one path is a direct parent of another. There needs to be\nless threads in the executor than there are paths to sync.\nWhen the deadlock occurs it is because the child path holds a read\nlock on a path the parent may be attempting to sync. This prevents\nthe parent path from continuing to sync. The child path though may\nkeep queuing sync jobs which can prevent the child from completing\nits sync and thus causing deadlock because the parent can never\nfinish.\nIn order to fix this there were two major issues to be solved:\n\n\nUnlock the root path so the ancestry of one sync does not block\nanother. After internal discussion, we decided that because we\ndon't hold the lock for any children for the duration of the sync\nthat it is unnecessary to hold the parent lock for the entire\nduration as well.\n\n\nBecause the inode sync stream has to lock and unlock the root\npath while syncing, the function loadMetadataIfNotExists needed\nto be modified so that the path is unlocked before loading the\nmetadata. The major issue is that checking whether we need to\nload metadata on a path is expensive because it requires a lock.\nIn order to maintain high RPC throughput for GetFileInfo and\nListStatus (the users of loadMetadataIfNotExist) this PR\nintroduces a two-step scheme for locking on those RPCs. The\ngeneral approach is to lock and then check if metadata needs to\nbe loaded, in which case we unlock and go back to the beginning\nof the RPCs main logic with an extra flag set to load metdata.\nIn the case where the path already exists and does not need to be\nloaded, then the RPC continues as normal.\n\n\nThere will be a slight overhead in occasions where we are loading\nmetadata for paths that don't yet exist, but that is not the\ncommon case, so I am slightly less concerned about the performance\nthere. There will be no more locks taken there than there would be\nin a normal metadata sync, so the runtimes should be comparable\nanyway.", "createdAt": "2020-06-17T18:15:17Z", "url": "https://github.com/Alluxio/alluxio/pull/11579", "merged": true, "mergeCommit": {"oid": "b7ed68de6ee2fd615880085c1ff7d8759b4adb80"}, "closed": true, "closedAt": "2020-06-23T00:45:28Z", "author": {"login": "ZacBlanco"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcsN_9zgBqjM0NTQ4MzY3OTk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABct4LizAH2gAyNDM2MDE2NzQ5Ojc5YTUzMGFjNTYwYzVmMjNiODQwZTUzNTcyNmEzMjQ5YTFlNzYwZWU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b572e93df4c631c8f6f7f6b124ff8b6aea4e440a", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/b572e93df4c631c8f6f7f6b124ff8b6aea4e440a", "committedDate": "2020-06-17T18:05:54Z", "message": "Fix deadlock issue on metadata sync\n\nThis deadlock occurs when concurrent clients submit requests to\npaths where one is the parent of another. It is most likely to\noccur one path is a direct parent of another. There needs to be\nless threads in the executor than there are paths to sync.\nWhen the deadlock occurs it is because the child path holds a read\nlock on a path the parent may be attempting to sync. This prevents\nthe parent path from continuing to sync. The child path though may\nkeep queuing sync jobs which can prevent the child from completing\nits sync and thus causing deadlock because the parent can never\nfinish.\n\nIn order to fix this there were two major issues to be solved:\n\n1. Unlock the root path so the ancestry of one sync does not block\nanother. After internal discussion, we decided that because we\ndon't hold the lock for any children for the duration of the sync\nthat it is unnecessary to hold the parent lock for the entire\nduration as well.\n\n2. Because the inode sync stream has to lock and unlock the root\npath while syncing, the function loadMetadataIfNotExists needed\nto be modified so that the path is unlocked before loading the\nmetadata. The major issue is that checking whether we need to\nload metadata on a path is expensive because it requires a lock.\nIn order to maintain high RPC throughput for GetFileInfo and\nListStatus (the users of loadMetadataIfNotExist) this PR\nintroduces a two-phase scheme for locking on those RPCs. The\ngeneral approach is to lock and then check if metadata needs to\nbe loaded, in which case we unlock and go back to the beginning\nof the RPCs main logic with an extra flag set to load metdata.\nIn the case where the path already exists and does not need to be\nloaded, then the RPC continues as normal.\n\nThere will be a slight overhead in occasions where we are loading\nmetadata for paths that don't yet exist, but that is not the\ncommon case, so I am slightly less concerned about the performance\nthere. There will be no more locks taken there than there would be\nin a normal metadata sync, so the runtimes should be comparable\nanyway."}, "afterCommit": {"oid": "f56ab2808ffa9e09e0a8b5aae2cb7ccfa82c917b", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/f56ab2808ffa9e09e0a8b5aae2cb7ccfa82c917b", "committedDate": "2020-06-17T18:17:08Z", "message": "Fix deadlock issue on metadata sync\n\nThis deadlock occurs when concurrent clients submit requests to\npaths where one is the parent of another. It is most likely to\noccur one path is a direct parent of another. There needs to be\nless threads in the executor than there are paths to sync.\nWhen the deadlock occurs it is because the child path holds a read\nlock on a path the parent may be attempting to sync. This prevents\nthe parent path from continuing to sync. The child path though may\nkeep queuing sync jobs which can prevent the child from completing\nits sync and thus causing deadlock because the parent can never\nfinish.\n\nIn order to fix this there were two major issues to be solved:\n\n1. Unlock the root path so the ancestry of one sync does not block\nanother. After internal discussion, we decided that because we\ndon't hold the lock for any children for the duration of the sync\nthat it is unnecessary to hold the parent lock for the entire\nduration as well.\n\n2. Because the inode sync stream has to lock and unlock the root\npath while syncing, the function loadMetadataIfNotExists needed\nto be modified so that the path is unlocked before loading the\nmetadata. The major issue is that checking whether we need to\nload metadata on a path is expensive because it requires a lock.\nIn order to maintain high RPC throughput for GetFileInfo and\nListStatus (the users of loadMetadataIfNotExist) this PR\nintroduces a two-phase scheme for locking on those RPCs. The\ngeneral approach is to lock and then check if metadata needs to\nbe loaded, in which case we unlock and go back to the beginning\nof the RPCs main logic with an extra flag set to load metdata.\nIn the case where the path already exists and does not need to be\nloaded, then the RPC continues as normal.\n\nThere will be a slight overhead in occasions where we are loading\nmetadata for paths that don't yet exist, but that is not the\ncommon case, so I am slightly less concerned about the performance\nthere. There will be no more locks taken there than there would be\nin a normal metadata sync, so the runtimes should be comparable\nanyway."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9038955b3b75240f339788bb31540d9cf93127d1", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/9038955b3b75240f339788bb31540d9cf93127d1", "committedDate": "2020-06-17T19:55:03Z", "message": "Fix deadlock issue on metadata sync\n\nThis deadlock occurs when concurrent clients submit requests to\npaths where one is the parent of another. It is most likely to\noccur one path is a direct parent of another. There needs to be\nless threads in the executor than there are paths to sync.\nWhen the deadlock occurs it is because the child path holds a read\nlock on a path the parent may be attempting to sync. This prevents\nthe parent path from continuing to sync. The child path though may\nkeep queuing sync jobs which can prevent the child from completing\nits sync and thus causing deadlock because the parent can never\nfinish.\n\nIn order to fix this there were two major issues to be solved:\n\n1. Unlock the root path so the ancestry of one sync does not block\nanother. After internal discussion, we decided that because we\ndon't hold the lock for any children for the duration of the sync\nthat it is unnecessary to hold the parent lock for the entire\nduration as well.\n\n2. Because the inode sync stream has to lock and unlock the root\npath while syncing, the function loadMetadataIfNotExists needed\nto be modified so that the path is unlocked before loading the\nmetadata. The major issue is that checking whether we need to\nload metadata on a path is expensive because it requires a lock.\nIn order to maintain high RPC throughput for GetFileInfo and\nListStatus (the users of loadMetadataIfNotExist) this PR\nintroduces a two-phase scheme for locking on those RPCs. The\ngeneral approach is to lock and then check if metadata needs to\nbe loaded, in which case we unlock and go back to the beginning\nof the RPCs main logic with an extra flag set to load metdata.\nIn the case where the path already exists and does not need to be\nloaded, then the RPC continues as normal.\n\nThere will be a slight overhead in occasions where we are loading\nmetadata for paths that don't yet exist, but that is not the\ncommon case, so I am slightly less concerned about the performance\nthere. There will be no more locks taken there than there would be\nin a normal metadata sync, so the runtimes should be comparable\nanyway."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f56ab2808ffa9e09e0a8b5aae2cb7ccfa82c917b", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/f56ab2808ffa9e09e0a8b5aae2cb7ccfa82c917b", "committedDate": "2020-06-17T18:17:08Z", "message": "Fix deadlock issue on metadata sync\n\nThis deadlock occurs when concurrent clients submit requests to\npaths where one is the parent of another. It is most likely to\noccur one path is a direct parent of another. There needs to be\nless threads in the executor than there are paths to sync.\nWhen the deadlock occurs it is because the child path holds a read\nlock on a path the parent may be attempting to sync. This prevents\nthe parent path from continuing to sync. The child path though may\nkeep queuing sync jobs which can prevent the child from completing\nits sync and thus causing deadlock because the parent can never\nfinish.\n\nIn order to fix this there were two major issues to be solved:\n\n1. Unlock the root path so the ancestry of one sync does not block\nanother. After internal discussion, we decided that because we\ndon't hold the lock for any children for the duration of the sync\nthat it is unnecessary to hold the parent lock for the entire\nduration as well.\n\n2. Because the inode sync stream has to lock and unlock the root\npath while syncing, the function loadMetadataIfNotExists needed\nto be modified so that the path is unlocked before loading the\nmetadata. The major issue is that checking whether we need to\nload metadata on a path is expensive because it requires a lock.\nIn order to maintain high RPC throughput for GetFileInfo and\nListStatus (the users of loadMetadataIfNotExist) this PR\nintroduces a two-phase scheme for locking on those RPCs. The\ngeneral approach is to lock and then check if metadata needs to\nbe loaded, in which case we unlock and go back to the beginning\nof the RPCs main logic with an extra flag set to load metdata.\nIn the case where the path already exists and does not need to be\nloaded, then the RPC continues as normal.\n\nThere will be a slight overhead in occasions where we are loading\nmetadata for paths that don't yet exist, but that is not the\ncommon case, so I am slightly less concerned about the performance\nthere. There will be no more locks taken there than there would be\nin a normal metadata sync, so the runtimes should be comparable\nanyway."}, "afterCommit": {"oid": "9038955b3b75240f339788bb31540d9cf93127d1", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/9038955b3b75240f339788bb31540d9cf93127d1", "committedDate": "2020-06-17T19:55:03Z", "message": "Fix deadlock issue on metadata sync\n\nThis deadlock occurs when concurrent clients submit requests to\npaths where one is the parent of another. It is most likely to\noccur one path is a direct parent of another. There needs to be\nless threads in the executor than there are paths to sync.\nWhen the deadlock occurs it is because the child path holds a read\nlock on a path the parent may be attempting to sync. This prevents\nthe parent path from continuing to sync. The child path though may\nkeep queuing sync jobs which can prevent the child from completing\nits sync and thus causing deadlock because the parent can never\nfinish.\n\nIn order to fix this there were two major issues to be solved:\n\n1. Unlock the root path so the ancestry of one sync does not block\nanother. After internal discussion, we decided that because we\ndon't hold the lock for any children for the duration of the sync\nthat it is unnecessary to hold the parent lock for the entire\nduration as well.\n\n2. Because the inode sync stream has to lock and unlock the root\npath while syncing, the function loadMetadataIfNotExists needed\nto be modified so that the path is unlocked before loading the\nmetadata. The major issue is that checking whether we need to\nload metadata on a path is expensive because it requires a lock.\nIn order to maintain high RPC throughput for GetFileInfo and\nListStatus (the users of loadMetadataIfNotExist) this PR\nintroduces a two-phase scheme for locking on those RPCs. The\ngeneral approach is to lock and then check if metadata needs to\nbe loaded, in which case we unlock and go back to the beginning\nof the RPCs main logic with an extra flag set to load metdata.\nIn the case where the path already exists and does not need to be\nloaded, then the RPC continues as normal.\n\nThere will be a slight overhead in occasions where we are loading\nmetadata for paths that don't yet exist, but that is not the\ncommon case, so I am slightly less concerned about the performance\nthere. There will be no more locks taken there than there would be\nin a normal metadata sync, so the runtimes should be comparable\nanyway."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNTM1NDk5", "url": "https://github.com/Alluxio/alluxio/pull/11579#pullrequestreview-433535499", "createdAt": "2020-06-18T18:19:06Z", "commit": {"oid": "9038955b3b75240f339788bb31540d9cf93127d1"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxODoxOTowNlrOGl69nw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxODo0MTozN1rOGl7sxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQxNjU0Mw==", "bodyText": "Why is this renamed? mount info sounds like it is the info for a single mount, but mount table sounds like the entire mapping?", "url": "https://github.com/Alluxio/alluxio/pull/11579#discussion_r442416543", "createdAt": "2020-06-18T18:19:06Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/master/file/FileSystemMaster.java", "diffHunk": "@@ -234,7 +234,7 @@ long getNewBlockIdForFile(AlluxioURI path) throws FileDoesNotExistException, Inv\n   /**\n    * @return a copy of the current mount table\n    */\n-  Map<String, MountPointInfo>  getMountTable();\n+  Map<String, MountPointInfo>  getMountInfo();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9038955b3b75240f339788bb31540d9cf93127d1"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQxNjk2OA==", "bodyText": "What about this test?", "url": "https://github.com/Alluxio/alluxio/pull/11579#discussion_r442416968", "createdAt": "2020-06-18T18:19:56Z", "author": {"login": "gpang"}, "path": "core/server/master/src/test/java/alluxio/master/file/FileSystemMasterTest.java", "diffHunk": "@@ -2672,6 +2673,46 @@ public void propagatePersisted() throws Exception {\n             GetStatusContext.defaults()).getPersistenceState());\n   }\n \n+//  @Test", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9038955b3b75240f339788bb31540d9cf93127d1"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQyODM0NA==", "bodyText": "is this no longer necessary because everything is unlocked?", "url": "https://github.com/Alluxio/alluxio/pull/11579#discussion_r442428344", "createdAt": "2020-06-18T18:41:07Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/master/file/InodeSyncStream.java", "diffHunk": "@@ -257,21 +293,18 @@ public boolean sync() {\n \n       // process the sync result for the original path\n       try {\n-        mRootPath.traverse();\n+        path.traverse();\n       } catch (InvalidPathException e) {\n         throw new RuntimeException(e);\n       }\n-    } catch (AccessControlException | BlockInfoException | FileAlreadyCompletedException\n+    } catch (BlockInfoException | FileAlreadyCompletedException\n         | FileDoesNotExistException | InterruptedException | InvalidFileSizeException\n-        | InvalidPathException | IOException e) {\n+        | IOException e) {\n       LogUtils.warnWithException(LOG, \"Failed to sync metadata on root path {}\",\n           toString(), e);\n     } finally {\n       // regardless of the outcome, remove the UfsStatus for this path from the cache\n-      mStatusCache.remove(mRootPath.getUri());\n-      // downgrade so that if operations are parallelized, the lock on the root doesn't restrict\n-      // concurrent operations\n-      mRootPath.downgradeToRead();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9038955b3b75240f339788bb31540d9cf93127d1"}, "originalPosition": 183}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQyODYxMg==", "bodyText": "This will relock and recheck permissions? Can we add that to the comments of this method or class?", "url": "https://github.com/Alluxio/alluxio/pull/11579#discussion_r442428612", "createdAt": "2020-06-18T18:41:37Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/master/file/InodeSyncStream.java", "diffHunk": "@@ -245,9 +269,21 @@ public boolean sync() {\n     if (LOG.isDebugEnabled()) {\n       start = System.currentTimeMillis();\n     }\n-\n-    try {\n-      syncInodeMetadata(mRootPath);\n+    try (LockedInodePath path = mInodeTree.lockInodePath(mRootScheme)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9038955b3b75240f339788bb31540d9cf93127d1"}, "originalPosition": 144}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzNjUzNzI3", "url": "https://github.com/Alluxio/alluxio/pull/11579#pullrequestreview-433653727", "createdAt": "2020-06-18T21:17:06Z", "commit": {"oid": "9038955b3b75240f339788bb31540d9cf93127d1"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMToxNzowNlrOGmAhbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQyMjowNzozNlrOGmBzNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUwNzYyOQ==", "bodyText": "Even with a much longer path? How long could the test take if it \"passes\"?", "url": "https://github.com/Alluxio/alluxio/pull/11579#discussion_r442507629", "createdAt": "2020-06-18T21:17:06Z", "author": {"login": "gpang"}, "path": "core/server/master/src/test/java/alluxio/master/file/FileSystemMasterTest.java", "diffHunk": "@@ -2672,6 +2673,46 @@ public void propagatePersisted() throws Exception {\n             GetStatusContext.defaults()).getPersistenceState());\n   }\n \n+//  @Test", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQxNjk2OA=="}, "originalCommit": {"oid": "9038955b3b75240f339788bb31540d9cf93127d1"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUwOTE1MA==", "bodyText": "Ah, I see it now. maybe getMountTableMap? or getMountInfoMap? Yeah, since it is not the actual mount table, this should not simply be getMountTable.", "url": "https://github.com/Alluxio/alluxio/pull/11579#discussion_r442509150", "createdAt": "2020-06-18T21:20:37Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/master/file/FileSystemMaster.java", "diffHunk": "@@ -234,7 +234,7 @@ long getNewBlockIdForFile(AlluxioURI path) throws FileDoesNotExistException, Inv\n   /**\n    * @return a copy of the current mount table\n    */\n-  Map<String, MountPointInfo>  getMountTable();\n+  Map<String, MountPointInfo>  getMountInfo();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQxNjU0Mw=="}, "originalCommit": {"oid": "9038955b3b75240f339788bb31540d9cf93127d1"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUxMDY5NQ==", "bodyText": "NIT: I would avoid calling this a two-phase locking scheme, since \"two-phase locking\" is already a well-defined term. Maybe this can be a two-step locking scheme?", "url": "https://github.com/Alluxio/alluxio/pull/11579#discussion_r442510695", "createdAt": "2020-06-18T21:23:55Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/master/file/DefaultFileSystemMaster.java", "diffHunk": "@@ -737,18 +737,48 @@ public long getFileId(AlluxioURI path) throws AccessControlException, Unavailabl\n \n   private long getFileIdInternal(AlluxioURI path, boolean checkPermission)\n       throws AccessControlException, UnavailableException {\n-    try (RpcContext rpcContext = createRpcContext();\n-         LockedInodePath inodePath = mInodeTree.lockInodePath(path, LockPattern.READ)) {\n-      if (checkPermission) {\n-        mPermissionChecker.checkPermission(Mode.Bits.READ, inodePath);\n+    try (RpcContext rpcContext = createRpcContext()) {\n+      /*\n+      In order to prevent locking twice on RPCs where metadata does _not_ need to be loaded, we use\n+      a two-phase scheme as an optimization to prevent the extra lock. loadMetadataIfNotExists", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9038955b3b75240f339788bb31540d9cf93127d1"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUxMTY5NA==", "bodyText": "This is the same comment as in getFileIdInternal right? Can we just have a simple comment here to point to that method for more details about load metadata? (same comment for list status)", "url": "https://github.com/Alluxio/alluxio/pull/11579#discussion_r442511694", "createdAt": "2020-06-18T21:26:08Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/master/file/DefaultFileSystemMaster.java", "diffHunk": "@@ -769,49 +799,72 @@ public FileInfo getFileInfo(AlluxioURI path, GetStatusContext context)\n         FileSystemMasterAuditContext auditContext =\n             createAuditContext(\"getFileInfo\", path, null, null)) {\n \n-      if (syncMetadata(rpcContext,\n-          path,\n-          context.getOptions().getCommonOptions(),\n-          DescendantType.ONE,\n-          auditContext,\n-          LockedInodePath::getInodeOrNull,\n+      if (syncMetadata(rpcContext, path, context.getOptions().getCommonOptions(),\n+          DescendantType.ONE, auditContext, LockedInodePath::getInodeOrNull,\n           (inodePath, permChecker) -> permChecker.checkPermission(Mode.Bits.READ, inodePath),\n           true)) {\n         // If synced, do not load metadata.\n         context.getOptions().setLoadMetadataType(LoadMetadataPType.NEVER);\n       }\n-\n-      LockingScheme lockingScheme = new LockingScheme(path, LockPattern.READ, false);\n-      try (LockedInodePath inodePath = mInodeTree.lockInodePath(lockingScheme)) {\n-        auditContext.setSrcInode(inodePath.getInodeOrNull());\n-        try {\n-          mPermissionChecker.checkPermission(Mode.Bits.READ, inodePath);\n-        } catch (AccessControlException e) {\n-          auditContext.setAllowed(false);\n-          throw e;\n+      LoadMetadataContext lmCtx = LoadMetadataContext.mergeFrom(\n+          LoadMetadataPOptions.newBuilder().setCreateAncestors(true).setCommonOptions(\n+              FileSystemMasterCommonPOptions.newBuilder()\n+                  .setTtl(context.getOptions().getCommonOptions().getTtl())\n+                  .setTtlAction(context.getOptions().getCommonOptions().getTtlAction())));\n+      /*\n+      In order to prevent locking twice on RPCs where metadata does _not_ need to be loaded, we use", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9038955b3b75240f339788bb31540d9cf93127d1"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUyNjgwMA==", "bodyText": "Is there any chance this could run for more than 2 iterations?", "url": "https://github.com/Alluxio/alluxio/pull/11579#discussion_r442526800", "createdAt": "2020-06-18T22:02:56Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/master/file/DefaultFileSystemMaster.java", "diffHunk": "@@ -737,18 +737,48 @@ public long getFileId(AlluxioURI path) throws AccessControlException, Unavailabl\n \n   private long getFileIdInternal(AlluxioURI path, boolean checkPermission)\n       throws AccessControlException, UnavailableException {\n-    try (RpcContext rpcContext = createRpcContext();\n-         LockedInodePath inodePath = mInodeTree.lockInodePath(path, LockPattern.READ)) {\n-      if (checkPermission) {\n-        mPermissionChecker.checkPermission(Mode.Bits.READ, inodePath);\n+    try (RpcContext rpcContext = createRpcContext()) {\n+      /*\n+      In order to prevent locking twice on RPCs where metadata does _not_ need to be loaded, we use\n+      a two-phase scheme as an optimization to prevent the extra lock. loadMetadataIfNotExists\n+      requires a lock on the tree to determine if the path should be loaded before executing. To\n+      prevent the extra lock, we execute the RPC as normal and use a conditional check in the\n+      main body of the function to determine whether control flow should be shifted out of the\n+      RPC logic and back to the loadMetadataIfNotExists function.\n+\n+      If loadMetadataIfNotExists runs, then the next pass into the main logic body should\n+      continue as normal. This may present a slight decrease in performance for newly-loaded\n+      metadata, but it is better than affecting the most common case where metadata is not being\n+      loaded.\n+       */\n+      LoadMetadataContext lmCtx = LoadMetadataContext.mergeFrom(\n+          LoadMetadataPOptions.newBuilder().setCreateAncestors(true));\n+      boolean run = true;\n+      boolean loadMetadata = false;\n+      while (run) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9038955b3b75240f339788bb31540d9cf93127d1"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUyNzMwMg==", "bodyText": "the rpcs use shouldLoadMetadataIfNotExists to check to load metadata, but this method also calls shouldLoadMetadataIfNotExists again. Is that intentional, and why do we need to check again?", "url": "https://github.com/Alluxio/alluxio/pull/11579#discussion_r442527302", "createdAt": "2020-06-18T22:04:09Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/master/file/DefaultFileSystemMaster.java", "diffHunk": "@@ -2518,12 +2592,32 @@ public UfsInfo getUfsInfo(long mountId) {\n    * Loads metadata for the path if it is (non-existing || load direct children is set).\n    *\n    * @param rpcContext the rpc context\n-   * @param inodePath the {@link LockedInodePath} to load the metadata for\n    * @param context the load metadata context\n    */\n-  private void loadMetadataIfNotExist(RpcContext rpcContext, LockedInodePath inodePath,\n-      LoadMetadataContext context, boolean isGetFileInfo) {\n-    Preconditions.checkState(inodePath.getLockPattern() == LockPattern.READ);\n+  private void loadMetadataIfNotExist(RpcContext rpcContext, AlluxioURI path,\n+      LoadMetadataContext context, boolean isGetFileInfo)\n+      throws InvalidPathException, AccessControlException {\n+    LockingScheme scheme = new LockingScheme(path, LockPattern.READ, false);\n+    boolean lm;\n+    try (LockedInodePath inodePath = mInodeTree.lockInodePath(scheme)) {\n+      lm = shouldLoadMetadataIfNotExists(inodePath, context);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9038955b3b75240f339788bb31540d9cf93127d1"}, "originalPosition": 350}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUyODU2NA==", "bodyText": "Is there a better message we can use, to help us debug or fix?", "url": "https://github.com/Alluxio/alluxio/pull/11579#discussion_r442528564", "createdAt": "2020-06-18T22:07:36Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/master/file/DefaultFileSystemMaster.java", "diffHunk": "@@ -769,49 +799,72 @@ public FileInfo getFileInfo(AlluxioURI path, GetStatusContext context)\n         FileSystemMasterAuditContext auditContext =\n             createAuditContext(\"getFileInfo\", path, null, null)) {\n \n-      if (syncMetadata(rpcContext,\n-          path,\n-          context.getOptions().getCommonOptions(),\n-          DescendantType.ONE,\n-          auditContext,\n-          LockedInodePath::getInodeOrNull,\n+      if (syncMetadata(rpcContext, path, context.getOptions().getCommonOptions(),\n+          DescendantType.ONE, auditContext, LockedInodePath::getInodeOrNull,\n           (inodePath, permChecker) -> permChecker.checkPermission(Mode.Bits.READ, inodePath),\n           true)) {\n         // If synced, do not load metadata.\n         context.getOptions().setLoadMetadataType(LoadMetadataPType.NEVER);\n       }\n-\n-      LockingScheme lockingScheme = new LockingScheme(path, LockPattern.READ, false);\n-      try (LockedInodePath inodePath = mInodeTree.lockInodePath(lockingScheme)) {\n-        auditContext.setSrcInode(inodePath.getInodeOrNull());\n-        try {\n-          mPermissionChecker.checkPermission(Mode.Bits.READ, inodePath);\n-        } catch (AccessControlException e) {\n-          auditContext.setAllowed(false);\n-          throw e;\n+      LoadMetadataContext lmCtx = LoadMetadataContext.mergeFrom(\n+          LoadMetadataPOptions.newBuilder().setCreateAncestors(true).setCommonOptions(\n+              FileSystemMasterCommonPOptions.newBuilder()\n+                  .setTtl(context.getOptions().getCommonOptions().getTtl())\n+                  .setTtlAction(context.getOptions().getCommonOptions().getTtlAction())));\n+      /*\n+      In order to prevent locking twice on RPCs where metadata does _not_ need to be loaded, we use\n+      a two-phase scheme as an optimization to prevent the extra lock. loadMetadataIfNotExists\n+      requires a lock on the tree to determine if the path should be loaded before executing. To\n+      prevent the extra lock, we execute the RPC as normal and use a conditional check in the\n+      main body of the function to determine whether control flow should be shifted out of the\n+      RPC logic and back to the loadMetadataIfNotExists function.\n+\n+      If loadMetadataIfNotExists runs, then the next pass into the main logic body should\n+      continue as normal. This may present a slight decrease in performance for newly-loaded\n+      metadata, but it is better than affecting the most common case where metadata is not being\n+      loaded.\n+       */\n+      boolean run = true;\n+      boolean loadMetadata = false;\n+      FileInfo ret = null;\n+      while (run) {\n+        run = false;\n+        if (loadMetadata) {\n+          checkLoadMetadataOptions(context.getOptions().getLoadMetadataType(), path);\n+          loadMetadataIfNotExist(rpcContext, path, lmCtx, true);\n         }\n-        // If the file already exists, then metadata does not need to be loaded,\n-        // otherwise load metadata.\n-        if (!inodePath.fullPathExists()) {\n-          checkLoadMetadataOptions(context.getOptions().getLoadMetadataType(), inodePath.getUri());\n-          loadMetadataIfNotExist(rpcContext, inodePath, LoadMetadataContext.mergeFrom(\n-              LoadMetadataPOptions.newBuilder().setCreateAncestors(true).setCommonOptions(\n-                  FileSystemMasterCommonPOptions.newBuilder()\n-                      .setTtl(context.getOptions().getCommonOptions().getTtl())\n-                      .setTtlAction(context.getOptions().getCommonOptions().getTtlAction()))),\n-              true);\n+\n+        LockingScheme lockingScheme = new LockingScheme(path, LockPattern.READ, false);\n+        try (LockedInodePath inodePath = mInodeTree.lockInodePath(lockingScheme)) {\n+          auditContext.setSrcInode(inodePath.getInodeOrNull());\n+          try {\n+            mPermissionChecker.checkPermission(Mode.Bits.READ, inodePath);\n+          } catch (AccessControlException e) {\n+            auditContext.setAllowed(false);\n+            throw e;\n+          }\n+\n+          if (!loadMetadata && shouldLoadMetadataIfNotExists(inodePath, lmCtx)) {\n+            loadMetadata = true;\n+            run = true;\n+            continue;\n+          }\n+\n           ensureFullPathAndUpdateCache(inodePath);\n+\n+          FileInfo fileInfo = getFileInfoInternal(inodePath);\n+          Mode.Bits accessMode = Mode.Bits.fromProto(context.getOptions().getAccessMode());\n+          if (context.getOptions().getUpdateTimestamps() && context.getOptions().hasAccessMode()\n+              && (accessMode.imply(Mode.Bits.READ) || accessMode.imply(Mode.Bits.WRITE))) {\n+            mAccessTimeUpdater.updateAccessTime(rpcContext.getJournalContext(),\n+                inodePath.getInode(), opTimeMs);\n+          }\n+          auditContext.setSrcInode(inodePath.getInode()).setSucceeded(true);\n+          ret = fileInfo;\n         }\n-        FileInfo fileInfo = getFileInfoInternal(inodePath);\n-        Mode.Bits accessMode = Mode.Bits.fromProto(context.getOptions().getAccessMode());\n-        if (context.getOptions().getUpdateTimestamps() && context.getOptions().hasAccessMode() && (\n-            accessMode.imply(Mode.Bits.READ) || accessMode.imply(Mode.Bits.WRITE))) {\n-          mAccessTimeUpdater\n-              .updateAccessTime(rpcContext.getJournalContext(), inodePath.getInode(), opTimeMs);\n-        }\n-        auditContext.setSrcInode(inodePath.getInode()).setSucceeded(true);\n-        return fileInfo;\n       }\n+      return Preconditions.checkNotNull(ret,\n+          \"fileInfo returned should not be null. This is a bug.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9038955b3b75240f339788bb31540d9cf93127d1"}, "originalPosition": 161}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f4ee1438491c934838cbe13be8ceafc9b35f4895", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/f4ee1438491c934838cbe13be8ceafc9b35f4895", "committedDate": "2020-06-19T09:43:17Z", "message": "Address comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0MjA0NjMz", "url": "https://github.com/Alluxio/alluxio/pull/11579#pullrequestreview-434204633", "createdAt": "2020-06-19T16:27:34Z", "commit": {"oid": "f4ee1438491c934838cbe13be8ceafc9b35f4895"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQxNjoyNzozNFrOGmauEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQxNjoyNzozNFrOGmauEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjkzNjg1MQ==", "bodyText": "Yeah, after looking at it, it should be fine. The important part is that we have to make sure run is set to false in the beginning, and setting run=true can only happen when loadMetadata == false.", "url": "https://github.com/Alluxio/alluxio/pull/11579#discussion_r442936851", "createdAt": "2020-06-19T16:27:34Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/master/file/DefaultFileSystemMaster.java", "diffHunk": "@@ -737,18 +737,48 @@ public long getFileId(AlluxioURI path) throws AccessControlException, Unavailabl\n \n   private long getFileIdInternal(AlluxioURI path, boolean checkPermission)\n       throws AccessControlException, UnavailableException {\n-    try (RpcContext rpcContext = createRpcContext();\n-         LockedInodePath inodePath = mInodeTree.lockInodePath(path, LockPattern.READ)) {\n-      if (checkPermission) {\n-        mPermissionChecker.checkPermission(Mode.Bits.READ, inodePath);\n+    try (RpcContext rpcContext = createRpcContext()) {\n+      /*\n+      In order to prevent locking twice on RPCs where metadata does _not_ need to be loaded, we use\n+      a two-phase scheme as an optimization to prevent the extra lock. loadMetadataIfNotExists\n+      requires a lock on the tree to determine if the path should be loaded before executing. To\n+      prevent the extra lock, we execute the RPC as normal and use a conditional check in the\n+      main body of the function to determine whether control flow should be shifted out of the\n+      RPC logic and back to the loadMetadataIfNotExists function.\n+\n+      If loadMetadataIfNotExists runs, then the next pass into the main logic body should\n+      continue as normal. This may present a slight decrease in performance for newly-loaded\n+      metadata, but it is better than affecting the most common case where metadata is not being\n+      loaded.\n+       */\n+      LoadMetadataContext lmCtx = LoadMetadataContext.mergeFrom(\n+          LoadMetadataPOptions.newBuilder().setCreateAncestors(true));\n+      boolean run = true;\n+      boolean loadMetadata = false;\n+      while (run) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjUyNjgwMA=="}, "originalCommit": {"oid": "9038955b3b75240f339788bb31540d9cf93127d1"}, "originalPosition": 26}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0MzY5Njk3", "url": "https://github.com/Alluxio/alluxio/pull/11579#pullrequestreview-434369697", "createdAt": "2020-06-19T22:39:40Z", "commit": {"oid": "f4ee1438491c934838cbe13be8ceafc9b35f4895"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "79a530ac560c5f23b840e535726a3249a1e760ee", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/79a530ac560c5f23b840e535726a3249a1e760ee", "committedDate": "2020-06-22T21:59:58Z", "message": "Remove commented test"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4538, "cost": 1, "resetAt": "2021-10-29T17:30:11Z"}}}