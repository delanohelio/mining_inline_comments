{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcxMTEzMTc2", "number": 10844, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxNzo0NDowOVrODdbCMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMjo1OTozOFrODeLNpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMTc4MjI3OnYy", "diffSide": "RIGHT", "path": "core/common/src/main/java/alluxio/metrics/MetricsSystem.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxNzo0NDowOVrOFmBEAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxNzo0NDowOVrOFmBEAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQwNzYxOQ==", "bodyText": "This method will cover most of the should report metrics which is MetricKey with isClusterAggregated=true. But it does not cover those with ufs tags like Worker.BytesRead/WrittenPerUfs.UFS:<UFS_ADDRESS>.<worker_hostname>. The code here doesn't know information about any of the Alluxio UFS. That's why I added the method counterWithTags  and meterWithTags which will add those full metric name to the should report metrics set.", "url": "https://github.com/Alluxio/alluxio/pull/10844#discussion_r375407619", "createdAt": "2020-02-05T17:44:09Z", "author": {"login": "LuQQiu"}, "path": "core/common/src/main/java/alluxio/metrics/MetricsSystem.java", "diffHunk": "@@ -520,86 +622,53 @@ public static Timer timer(String name) {\n    */\n   public static Map<String, MetricValue> allMetrics() {\n     Map<String, MetricValue> metricsMap = new HashMap<>();\n-    for (Entry<String, Gauge> entry : METRIC_REGISTRY.getGauges().entrySet()) {\n-      Object value = entry.getValue().getValue();\n-      MetricValue.Builder valueBuilder = MetricValue.newBuilder().setMetricType(MetricType.GAUGE);\n-      if (!(value instanceof Number)) {\n-        valueBuilder.setStringValue(value.toString());\n+    for (Map.Entry<String, com.codahale.metrics.Metric> entry\n+        : METRIC_REGISTRY.getMetrics().entrySet()) {\n+      MetricValue.Builder valueBuilder = MetricValue.newBuilder();\n+      com.codahale.metrics.Metric metric = entry.getValue();\n+      if (metric instanceof Gauge) {\n+        Object value = ((Gauge) metric).getValue();\n+        if (!(value instanceof Number)) {\n+          valueBuilder.setStringValue(value.toString());\n+        } else {\n+          valueBuilder.setDoubleValue(((Number) value).doubleValue());\n+        }\n+        valueBuilder.setMetricType(MetricType.GAUGE);\n+      } else if (metric instanceof Counter) {\n+        valueBuilder.setMetricType(MetricType.COUNTER)\n+            .setDoubleValue(((Counter) metric).getCount());\n+      } else if (metric instanceof Meter) {\n+        valueBuilder.setMetricType(MetricType.METER)\n+            .setDoubleValue(((Meter) metric).getOneMinuteRate());\n+      } else if (metric instanceof Timer) {\n+        valueBuilder.setMetricType(MetricType.TIMER)\n+            .setDoubleValue(((Timer) metric).getCount());\n       } else {\n-        valueBuilder.setDoubleValue(((Number) value).doubleValue());\n+        LOG.warn(\"Metric {} has invalid metric type {}\",\n+            entry.getKey(), metric.getClass().getName());\n+        continue;\n       }\n       metricsMap.put(entry.getKey(), valueBuilder.build());\n     }\n-    for (Entry<String, Counter> entry : METRIC_REGISTRY.getCounters().entrySet()) {\n-      metricsMap.put(entry.getKey(), MetricValue.newBuilder()\n-          .setDoubleValue(entry.getValue().getCount()).setMetricType(MetricType.COUNTER).build());\n-    }\n-    for (Entry<String, Meter> entry : METRIC_REGISTRY.getMeters().entrySet()) {\n-      metricsMap.put(entry.getKey(), MetricValue.newBuilder()\n-          .setDoubleValue(entry.getValue().getOneMinuteRate())\n-          .setMetricType(MetricType.METER).build());\n-    }\n-    for (Entry<String, Timer> entry : METRIC_REGISTRY.getTimers().entrySet()) {\n-      metricsMap.put(entry.getKey(), MetricValue.newBuilder()\n-          .setDoubleValue(entry.getValue().getCount()).setMetricType(MetricType.TIMER).build());\n-    }\n     return metricsMap;\n   }\n \n   /**\n-   * @return all the worker's metrics in the format of {@link Metric}\n-   */\n-  public static List<Metric> allWorkerMetrics() {\n-    return allInstanceMetrics(InstanceType.WORKER);\n-  }\n-\n-  /**\n-   * @return all the client's metrics in the format of {@link Metric}\n-   */\n-  public static List<Metric> allClientMetrics() {\n-    return allInstanceMetrics(InstanceType.CLIENT);\n-  }\n-\n-  /**\n-   * Gets all metrics of the given instance type.\n+   * Initialize the should report metrics. This should be called only once.\n    *\n-   * @param instanceType the requested instance type\n-   * @return all metrics of the given instance type\n-   */\n-  private static List<Metric> allInstanceMetrics(MetricsSystem.InstanceType instanceType) {\n-    List<Metric> metrics = new ArrayList<>();\n-    for (Entry<String, Gauge> entry : METRIC_REGISTRY.getGauges().entrySet()) {\n-      if (entry.getKey().startsWith(instanceType.toString())) {\n-        Object value = entry.getValue().getValue();\n-        if (!(value instanceof Number)) {\n-          LOG.warn(\"The value of metric {} of type {} is not sent to metrics master,\"\n-                  + \" only metrics value of number can be collected\",\n-              entry.getKey(), entry.getValue().getClass().getSimpleName());\n-          continue;\n-        }\n-        metrics.add(Metric.from(entry.getKey(), ((Number) value).longValue(), MetricType.GAUGE));\n-      }\n-    }\n-    for (Entry<String, Counter> entry : METRIC_REGISTRY.getCounters().entrySet()) {\n-      if (entry.getKey().startsWith(instanceType.toString())) {\n-        metrics.add(Metric.from(entry.getKey(), entry.getValue().getCount(), MetricType.COUNTER));\n-      }\n-    }\n-    for (Entry<String, Meter> entry : METRIC_REGISTRY.getMeters().entrySet()) {\n-      if (entry.getKey().startsWith(instanceType.toString())) {\n-        // TODO(yupeng): From Meter's implementation, getOneMinuteRate can only report at rate of at\n-        // least seconds. if the client's duration is too short (i.e. < 1s), then getOneMinuteRate\n-        // would return 0\n-        metrics.add(Metric.from(entry.getKey(), entry.getValue().getOneMinuteRate(),\n-            MetricType.METER));\n-      }\n-    }\n-    for (Entry<String, Timer> entry : METRIC_REGISTRY.getTimers().entrySet()) {\n-      if (entry.getKey().startsWith(instanceType.toString())) {\n-        metrics.add(Metric.from(entry.getKey(), entry.getValue().getCount(), MetricType.TIMER));\n-      }\n+   * Note that this method is able to catch most of the should report metrics\n+   * except worker metrics with ufs tags.\n+   *\n+   * @param instanceType the instance type\n+   */\n+  @VisibleForTesting\n+  public static void initShouldReportMetrics(InstanceType instanceType) {\n+    Set<MetricKey> metricKeys = MetricKey.allShouldReportMetricKeys(instanceType);\n+    for (MetricKey metricKey : metricKeys) {\n+      SHOULD_REPORT_METRICS.putIfAbsent(\n+          getMetricNameWithUniqueId(instanceType, metricKey.getName()),\n+          metricKey.getMetricType());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56dc3e7559bc82d9071dd68eb5001eb8e16c9f03"}, "originalPosition": 339}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMTc5ODcwOnYy", "diffSide": "LEFT", "path": "core/common/src/main/java/alluxio/metrics/MetricsSystem.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxNzo0OTozOVrOFmBOtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxNzo1OTo1MFrOFmBjhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQxMDM1Nw==", "bodyText": "I want to remove the logics of calling original allMetrics and allInstanceMetrics. These two methods do many full metrics traverse and do many metric copies which takes up a lot of the heap size.\nMETRIC_REGISTERY.getGauges(), getCounters(), getMeters(), getTimers() will internally traverse the MetricRegistry.metrics and make a copy of metrics belonging to the specific metric type.\nChange to use  one METRIC_REGISTRY.getMetrics() will directly return the UnmodifiableSortedMap view of the original MetricRegistry.metrics map  which reduces four traverse of the MetricRegistry.metrics map  and reduce a full copy of the full metrics map.", "url": "https://github.com/Alluxio/alluxio/pull/10844#discussion_r375410357", "createdAt": "2020-02-05T17:49:39Z", "author": {"login": "LuQQiu"}, "path": "core/common/src/main/java/alluxio/metrics/MetricsSystem.java", "diffHunk": "@@ -470,24 +507,56 @@ public static Timer timer(String name) {\n    * The synchronized keyword is added for correctness with {@link #resetAllMetrics}\n    */\n   private static synchronized List<alluxio.grpc.Metric> reportMetrics(InstanceType instanceType) {\n+    if (!sReported) {\n+      initShouldReportMetrics(instanceType);\n+      sReported = true;\n+    }\n     List<alluxio.grpc.Metric> rpcMetrics = new ArrayList<>(20);\n-    for (Metric m : allInstanceMetrics(instanceType)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56dc3e7559bc82d9071dd68eb5001eb8e16c9f03"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQxNTY4Ng==", "bodyText": "Original report Metrics:  four traverse of full metrics, one copy of the full metrics, one copy of the worker or client metrics, one copy of the to be reported metrics.\nNow report metrics: one traverse of the should report metrics, one copy of the to be reported metrics.", "url": "https://github.com/Alluxio/alluxio/pull/10844#discussion_r375415686", "createdAt": "2020-02-05T17:59:50Z", "author": {"login": "LuQQiu"}, "path": "core/common/src/main/java/alluxio/metrics/MetricsSystem.java", "diffHunk": "@@ -470,24 +507,56 @@ public static Timer timer(String name) {\n    * The synchronized keyword is added for correctness with {@link #resetAllMetrics}\n    */\n   private static synchronized List<alluxio.grpc.Metric> reportMetrics(InstanceType instanceType) {\n+    if (!sReported) {\n+      initShouldReportMetrics(instanceType);\n+      sReported = true;\n+    }\n     List<alluxio.grpc.Metric> rpcMetrics = new ArrayList<>(20);\n-    for (Metric m : allInstanceMetrics(instanceType)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQxMDM1Nw=="}, "originalCommit": {"oid": "56dc3e7559bc82d9071dd68eb5001eb8e16c9f03"}, "originalPosition": 115}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMTgwNTU1OnYy", "diffSide": "RIGHT", "path": "core/common/src/main/java/alluxio/metrics/MetricsSystem.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxNzo1MjowMVrOFmBTYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxNzo1MjowMVrOFmBTYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQxMTU1Mw==", "bodyText": "Only report the should report metrics (MetricKey.isClusterAggregated == true, predefined) instead of reporting all the worker or client metrics. Reduce the amount of metrics worker reported and master stored.", "url": "https://github.com/Alluxio/alluxio/pull/10844#discussion_r375411553", "createdAt": "2020-02-05T17:52:01Z", "author": {"login": "LuQQiu"}, "path": "core/common/src/main/java/alluxio/metrics/MetricsSystem.java", "diffHunk": "@@ -470,24 +507,56 @@ public static Timer timer(String name) {\n    * The synchronized keyword is added for correctness with {@link #resetAllMetrics}\n    */\n   private static synchronized List<alluxio.grpc.Metric> reportMetrics(InstanceType instanceType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56dc3e7559bc82d9071dd68eb5001eb8e16c9f03"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyMTgwODU0OnYy", "diffSide": "RIGHT", "path": "core/common/src/main/java/alluxio/metrics/MetricsSystem.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxNzo1Mjo1N1rOFmBVRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNVQxNzo1Mjo1N1rOFmBVRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQxMjAzOQ==", "bodyText": "Traverse the SHOULD_REPORT_METRICS instead of traverse all the metrics", "url": "https://github.com/Alluxio/alluxio/pull/10844#discussion_r375412039", "createdAt": "2020-02-05T17:52:57Z", "author": {"login": "LuQQiu"}, "path": "core/common/src/main/java/alluxio/metrics/MetricsSystem.java", "diffHunk": "@@ -470,24 +507,56 @@ public static Timer timer(String name) {\n    * The synchronized keyword is added for correctness with {@link #resetAllMetrics}\n    */\n   private static synchronized List<alluxio.grpc.Metric> reportMetrics(InstanceType instanceType) {\n+    if (!sReported) {\n+      initShouldReportMetrics(instanceType);\n+      sReported = true;\n+    }\n     List<alluxio.grpc.Metric> rpcMetrics = new ArrayList<>(20);\n-    for (Metric m : allInstanceMetrics(instanceType)) {\n-      // last reported metrics only need to be tracked for COUNTER metrics\n-      // Store the last metric value which was sent, but the rpc metric returned should only\n-      // contain the difference of the current value, and the last value sent. If it doesn't\n-      // yet exist, just send the current value\n-      if (m.getMetricType() == MetricType.COUNTER) {\n-        Metric prev = LAST_REPORTED_METRICS.replace(m.getFullMetricName(), m);\n+    // Use the getMetrics() call instead of getGauges(),getCounters()... to avoid\n+    // unneeded metrics copy\n+    Map<String, com.codahale.metrics.Metric> metrics = METRIC_REGISTRY.getMetrics();\n+\n+    for (Map.Entry<String, MetricType> entry : SHOULD_REPORT_METRICS.entrySet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "56dc3e7559bc82d9071dd68eb5001eb8e16c9f03"}, "originalPosition": 126}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyOTYzMjA3OnYy", "diffSide": "RIGHT", "path": "core/common/src/main/java/alluxio/metrics/MetricsSystem.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMjozNzozOFrOFnMTQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMzowNTozMVrOFnMzsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY0MDMyMA==", "bodyText": "nit: this comment doesn't seem that clear to me.\nIs this a better description?\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              // Adds to make sure the SHOULD_REPORT_METRICS is initialized only once\n          \n          \n            \n            A flag telling whether metrics have been reported yet. Using this prevents us from initializing `SHOULD_REPORT_METRICS` more than once", "url": "https://github.com/Alluxio/alluxio/pull/10844#discussion_r376640320", "createdAt": "2020-02-07T22:37:38Z", "author": {"login": "ZacBlanco"}, "path": "core/common/src/main/java/alluxio/metrics/MetricsSystem.java", "diffHunk": "@@ -61,8 +63,14 @@\n   private static int sResolveTimeout =\n       (int) new InstancedConfiguration(ConfigurationUtils.defaults())\n           .getMs(PropertyKey.NETWORK_HOST_RESOLUTION_TIMEOUT_MS);\n-  private static final ConcurrentHashMap<String, Metric> LAST_REPORTED_METRICS =\n-      new ConcurrentHashMap<>();\n+  // A map from the metric name to its previous reported value\n+  // This map is used for calculated the counter diff value that will be reported\n+  private static final Map<String, Long> LAST_REPORTED_METRICS = new HashMap<>();\n+  // A map that records all the metrics that should be reported and aggregated at leading master\n+  // from full metric name to its metric type\n+  private static final Map<String, MetricType> SHOULD_REPORT_METRICS = new HashMap<>();\n+  // Adds to make sure the SHOULD_REPORT_METRICS is initialized only once", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d14918eba584c76a6decbfec69a205056abe9bf8"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY0ODYyNg==", "bodyText": "Yeah, much better!! This functionality is cool!", "url": "https://github.com/Alluxio/alluxio/pull/10844#discussion_r376648626", "createdAt": "2020-02-07T23:05:31Z", "author": {"login": "LuQQiu"}, "path": "core/common/src/main/java/alluxio/metrics/MetricsSystem.java", "diffHunk": "@@ -61,8 +63,14 @@\n   private static int sResolveTimeout =\n       (int) new InstancedConfiguration(ConfigurationUtils.defaults())\n           .getMs(PropertyKey.NETWORK_HOST_RESOLUTION_TIMEOUT_MS);\n-  private static final ConcurrentHashMap<String, Metric> LAST_REPORTED_METRICS =\n-      new ConcurrentHashMap<>();\n+  // A map from the metric name to its previous reported value\n+  // This map is used for calculated the counter diff value that will be reported\n+  private static final Map<String, Long> LAST_REPORTED_METRICS = new HashMap<>();\n+  // A map that records all the metrics that should be reported and aggregated at leading master\n+  // from full metric name to its metric type\n+  private static final Map<String, MetricType> SHOULD_REPORT_METRICS = new HashMap<>();\n+  // Adds to make sure the SHOULD_REPORT_METRICS is initialized only once", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY0MDMyMA=="}, "originalCommit": {"oid": "d14918eba584c76a6decbfec69a205056abe9bf8"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyOTY1NDM4OnYy", "diffSide": "RIGHT", "path": "core/common/src/main/java/alluxio/metrics/MetricsSystem.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMjo0OToxNFrOFnMgLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMzoxMToyMlrOFnM6aA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY0MzYzMQ==", "bodyText": "Can we optimize this arrayList allocation? do we know the number of metrics we're reporting at this point?", "url": "https://github.com/Alluxio/alluxio/pull/10844#discussion_r376643631", "createdAt": "2020-02-07T22:49:14Z", "author": {"login": "ZacBlanco"}, "path": "core/common/src/main/java/alluxio/metrics/MetricsSystem.java", "diffHunk": "@@ -473,24 +510,56 @@ public static Timer timer(String name) {\n    * The synchronized keyword is added for correctness with {@link #resetAllMetrics}\n    */\n   private static synchronized List<alluxio.grpc.Metric> reportMetrics(InstanceType instanceType) {\n+    if (!sReported) {\n+      initShouldReportMetrics(instanceType);\n+      sReported = true;\n+    }\n     List<alluxio.grpc.Metric> rpcMetrics = new ArrayList<>(20);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49d4f14b3954953cc54a8c76e9f542f0fe73cf34"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY1MDM0NA==", "bodyText": "For worker, 12 metrics we are reporting. But it's not guaranteed since we have Worker.BytesReadPerUfs.UFS:<UFS_ADDRESS>  and Worker.BytesReadPerUfs.UFS:<UFS_ADDRESS> which may have multiple metrics to report.\nFor client,  5 metrics to report.", "url": "https://github.com/Alluxio/alluxio/pull/10844#discussion_r376650344", "createdAt": "2020-02-07T23:11:22Z", "author": {"login": "LuQQiu"}, "path": "core/common/src/main/java/alluxio/metrics/MetricsSystem.java", "diffHunk": "@@ -473,24 +510,56 @@ public static Timer timer(String name) {\n    * The synchronized keyword is added for correctness with {@link #resetAllMetrics}\n    */\n   private static synchronized List<alluxio.grpc.Metric> reportMetrics(InstanceType instanceType) {\n+    if (!sReported) {\n+      initShouldReportMetrics(instanceType);\n+      sReported = true;\n+    }\n     List<alluxio.grpc.Metric> rpcMetrics = new ArrayList<>(20);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY0MzYzMQ=="}, "originalCommit": {"oid": "49d4f14b3954953cc54a8c76e9f542f0fe73cf34"}, "originalPosition": 114}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyOTY3MTUzOnYy", "diffSide": "RIGHT", "path": "core/common/src/main/java/alluxio/metrics/MetricsSystem.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMjo1NzoyMVrOFnMp6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMzoyNTo0M1rOFnNIIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY0NjEyMg==", "bodyText": "if this method returns null please annotate it with @Nullable", "url": "https://github.com/Alluxio/alluxio/pull/10844#discussion_r376646122", "createdAt": "2020-02-07T22:57:21Z", "author": {"login": "ZacBlanco"}, "path": "core/common/src/main/java/alluxio/metrics/MetricsSystem.java", "diffHunk": "@@ -511,10 +580,43 @@ public static Timer timer(String name) {\n   }\n \n   /**\n-   * @return all the master's metrics in the format of {@link Metric}\n+   * Gets master metric with the given metric name.\n+   *\n+   * @param name the name of the metric to get\n+   * @return a metric set with the master metric of the given metric name\n    */\n-  public static List<Metric> allMasterMetrics() {\n-    return allInstanceMetrics(InstanceType.MASTER);\n+  public static Set<Metric> getMasterMetric(String name) {\n+    Set<Metric> set = new HashSet<>();\n+    Map<String, com.codahale.metrics.Metric> metricMap = METRIC_REGISTRY.getMetrics();\n+    String fullName = getMasterMetricName(name);\n+    com.codahale.metrics.Metric metric = metricMap.get(fullName);\n+    if (metric == null) {\n+      return set;\n+    }\n+    Metric alluxioMetric = getAlluxioMetricFromCodahaleMetric(fullName, metric);\n+    if (alluxioMetric != null) {\n+      set.add(alluxioMetric);\n+    }\n+    return set;\n+  }\n+\n+  private static Metric getAlluxioMetricFromCodahaleMetric(String name,\n+      com.codahale.metrics.Metric metric) {\n+    if (metric instanceof Gauge) {\n+      Gauge gauge = (Gauge) metric;\n+      return Metric.from(name, ((Number) gauge.getValue()).longValue(), MetricType.GAUGE);\n+    } else if (metric instanceof Counter) {\n+      Counter counter = (Counter) metric;\n+      return Metric.from(name, counter.getCount(), MetricType.COUNTER);\n+    } else if (metric instanceof Meter) {\n+      Meter meter = (Meter) metric;\n+      return Metric.from(name, meter.getOneMinuteRate(), MetricType.METER);\n+    } else if (metric instanceof Timer) {\n+      Timer timer = (Timer) metric;\n+      return Metric.from(name, timer.getCount(), MetricType.TIMER);\n+    }\n+    LOG.warn(\"Metric {} has invalid metric type {}\", name, metric.getClass().getName());\n+    return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49d4f14b3954953cc54a8c76e9f542f0fe73cf34"}, "originalPosition": 217}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY1Mzg1OA==", "bodyText": "Added, thanks", "url": "https://github.com/Alluxio/alluxio/pull/10844#discussion_r376653858", "createdAt": "2020-02-07T23:25:43Z", "author": {"login": "LuQQiu"}, "path": "core/common/src/main/java/alluxio/metrics/MetricsSystem.java", "diffHunk": "@@ -511,10 +580,43 @@ public static Timer timer(String name) {\n   }\n \n   /**\n-   * @return all the master's metrics in the format of {@link Metric}\n+   * Gets master metric with the given metric name.\n+   *\n+   * @param name the name of the metric to get\n+   * @return a metric set with the master metric of the given metric name\n    */\n-  public static List<Metric> allMasterMetrics() {\n-    return allInstanceMetrics(InstanceType.MASTER);\n+  public static Set<Metric> getMasterMetric(String name) {\n+    Set<Metric> set = new HashSet<>();\n+    Map<String, com.codahale.metrics.Metric> metricMap = METRIC_REGISTRY.getMetrics();\n+    String fullName = getMasterMetricName(name);\n+    com.codahale.metrics.Metric metric = metricMap.get(fullName);\n+    if (metric == null) {\n+      return set;\n+    }\n+    Metric alluxioMetric = getAlluxioMetricFromCodahaleMetric(fullName, metric);\n+    if (alluxioMetric != null) {\n+      set.add(alluxioMetric);\n+    }\n+    return set;\n+  }\n+\n+  private static Metric getAlluxioMetricFromCodahaleMetric(String name,\n+      com.codahale.metrics.Metric metric) {\n+    if (metric instanceof Gauge) {\n+      Gauge gauge = (Gauge) metric;\n+      return Metric.from(name, ((Number) gauge.getValue()).longValue(), MetricType.GAUGE);\n+    } else if (metric instanceof Counter) {\n+      Counter counter = (Counter) metric;\n+      return Metric.from(name, counter.getCount(), MetricType.COUNTER);\n+    } else if (metric instanceof Meter) {\n+      Meter meter = (Meter) metric;\n+      return Metric.from(name, meter.getOneMinuteRate(), MetricType.METER);\n+    } else if (metric instanceof Timer) {\n+      Timer timer = (Timer) metric;\n+      return Metric.from(name, timer.getCount(), MetricType.TIMER);\n+    }\n+    LOG.warn(\"Metric {} has invalid metric type {}\", name, metric.getClass().getName());\n+    return null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY0NjEyMg=="}, "originalCommit": {"oid": "49d4f14b3954953cc54a8c76e9f542f0fe73cf34"}, "originalPosition": 217}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMyOTY3NTkwOnYy", "diffSide": "RIGHT", "path": "core/common/src/main/java/alluxio/metrics/MetricsSystem.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMjo1OTozOFrOFnMsfA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wN1QyMzoyNTo1M1rOFnNITQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY0Njc4MA==", "bodyText": "I think you can use {@link #<variable_name>} to be more clear about \"should report metrics\"", "url": "https://github.com/Alluxio/alluxio/pull/10844#discussion_r376646780", "createdAt": "2020-02-07T22:59:38Z", "author": {"login": "ZacBlanco"}, "path": "core/common/src/main/java/alluxio/metrics/MetricsSystem.java", "diffHunk": "@@ -523,86 +625,53 @@ public static Timer timer(String name) {\n    */\n   public static Map<String, MetricValue> allMetrics() {\n     Map<String, MetricValue> metricsMap = new HashMap<>();\n-    for (Entry<String, Gauge> entry : METRIC_REGISTRY.getGauges().entrySet()) {\n-      Object value = entry.getValue().getValue();\n-      MetricValue.Builder valueBuilder = MetricValue.newBuilder().setMetricType(MetricType.GAUGE);\n-      if (!(value instanceof Number)) {\n-        valueBuilder.setStringValue(value.toString());\n+    for (Map.Entry<String, com.codahale.metrics.Metric> entry\n+        : METRIC_REGISTRY.getMetrics().entrySet()) {\n+      MetricValue.Builder valueBuilder = MetricValue.newBuilder();\n+      com.codahale.metrics.Metric metric = entry.getValue();\n+      if (metric instanceof Gauge) {\n+        Object value = ((Gauge) metric).getValue();\n+        if (value instanceof Number) {\n+          valueBuilder.setDoubleValue(((Number) value).doubleValue());\n+        } else {\n+          valueBuilder.setStringValue(value.toString());\n+        }\n+        valueBuilder.setMetricType(MetricType.GAUGE);\n+      } else if (metric instanceof Counter) {\n+        valueBuilder.setMetricType(MetricType.COUNTER)\n+            .setDoubleValue(((Counter) metric).getCount());\n+      } else if (metric instanceof Meter) {\n+        valueBuilder.setMetricType(MetricType.METER)\n+            .setDoubleValue(((Meter) metric).getOneMinuteRate());\n+      } else if (metric instanceof Timer) {\n+        valueBuilder.setMetricType(MetricType.TIMER)\n+            .setDoubleValue(((Timer) metric).getCount());\n       } else {\n-        valueBuilder.setDoubleValue(((Number) value).doubleValue());\n+        LOG.warn(\"Metric {} has invalid metric type {}\",\n+            entry.getKey(), metric.getClass().getName());\n+        continue;\n       }\n       metricsMap.put(entry.getKey(), valueBuilder.build());\n     }\n-    for (Entry<String, Counter> entry : METRIC_REGISTRY.getCounters().entrySet()) {\n-      metricsMap.put(entry.getKey(), MetricValue.newBuilder()\n-          .setDoubleValue(entry.getValue().getCount()).setMetricType(MetricType.COUNTER).build());\n-    }\n-    for (Entry<String, Meter> entry : METRIC_REGISTRY.getMeters().entrySet()) {\n-      metricsMap.put(entry.getKey(), MetricValue.newBuilder()\n-          .setDoubleValue(entry.getValue().getOneMinuteRate())\n-          .setMetricType(MetricType.METER).build());\n-    }\n-    for (Entry<String, Timer> entry : METRIC_REGISTRY.getTimers().entrySet()) {\n-      metricsMap.put(entry.getKey(), MetricValue.newBuilder()\n-          .setDoubleValue(entry.getValue().getCount()).setMetricType(MetricType.TIMER).build());\n-    }\n     return metricsMap;\n   }\n \n   /**\n-   * @return all the worker's metrics in the format of {@link Metric}\n-   */\n-  public static List<Metric> allWorkerMetrics() {\n-    return allInstanceMetrics(InstanceType.WORKER);\n-  }\n-\n-  /**\n-   * @return all the client's metrics in the format of {@link Metric}\n-   */\n-  public static List<Metric> allClientMetrics() {\n-    return allInstanceMetrics(InstanceType.CLIENT);\n-  }\n-\n-  /**\n-   * Gets all metrics of the given instance type.\n+   * Initialize the should report metrics. This should be called only once.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "49d4f14b3954953cc54a8c76e9f542f0fe73cf34"}, "originalPosition": 291}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY1MzkwMQ==", "bodyText": "Use the link, thanks!", "url": "https://github.com/Alluxio/alluxio/pull/10844#discussion_r376653901", "createdAt": "2020-02-07T23:25:53Z", "author": {"login": "LuQQiu"}, "path": "core/common/src/main/java/alluxio/metrics/MetricsSystem.java", "diffHunk": "@@ -523,86 +625,53 @@ public static Timer timer(String name) {\n    */\n   public static Map<String, MetricValue> allMetrics() {\n     Map<String, MetricValue> metricsMap = new HashMap<>();\n-    for (Entry<String, Gauge> entry : METRIC_REGISTRY.getGauges().entrySet()) {\n-      Object value = entry.getValue().getValue();\n-      MetricValue.Builder valueBuilder = MetricValue.newBuilder().setMetricType(MetricType.GAUGE);\n-      if (!(value instanceof Number)) {\n-        valueBuilder.setStringValue(value.toString());\n+    for (Map.Entry<String, com.codahale.metrics.Metric> entry\n+        : METRIC_REGISTRY.getMetrics().entrySet()) {\n+      MetricValue.Builder valueBuilder = MetricValue.newBuilder();\n+      com.codahale.metrics.Metric metric = entry.getValue();\n+      if (metric instanceof Gauge) {\n+        Object value = ((Gauge) metric).getValue();\n+        if (value instanceof Number) {\n+          valueBuilder.setDoubleValue(((Number) value).doubleValue());\n+        } else {\n+          valueBuilder.setStringValue(value.toString());\n+        }\n+        valueBuilder.setMetricType(MetricType.GAUGE);\n+      } else if (metric instanceof Counter) {\n+        valueBuilder.setMetricType(MetricType.COUNTER)\n+            .setDoubleValue(((Counter) metric).getCount());\n+      } else if (metric instanceof Meter) {\n+        valueBuilder.setMetricType(MetricType.METER)\n+            .setDoubleValue(((Meter) metric).getOneMinuteRate());\n+      } else if (metric instanceof Timer) {\n+        valueBuilder.setMetricType(MetricType.TIMER)\n+            .setDoubleValue(((Timer) metric).getCount());\n       } else {\n-        valueBuilder.setDoubleValue(((Number) value).doubleValue());\n+        LOG.warn(\"Metric {} has invalid metric type {}\",\n+            entry.getKey(), metric.getClass().getName());\n+        continue;\n       }\n       metricsMap.put(entry.getKey(), valueBuilder.build());\n     }\n-    for (Entry<String, Counter> entry : METRIC_REGISTRY.getCounters().entrySet()) {\n-      metricsMap.put(entry.getKey(), MetricValue.newBuilder()\n-          .setDoubleValue(entry.getValue().getCount()).setMetricType(MetricType.COUNTER).build());\n-    }\n-    for (Entry<String, Meter> entry : METRIC_REGISTRY.getMeters().entrySet()) {\n-      metricsMap.put(entry.getKey(), MetricValue.newBuilder()\n-          .setDoubleValue(entry.getValue().getOneMinuteRate())\n-          .setMetricType(MetricType.METER).build());\n-    }\n-    for (Entry<String, Timer> entry : METRIC_REGISTRY.getTimers().entrySet()) {\n-      metricsMap.put(entry.getKey(), MetricValue.newBuilder()\n-          .setDoubleValue(entry.getValue().getCount()).setMetricType(MetricType.TIMER).build());\n-    }\n     return metricsMap;\n   }\n \n   /**\n-   * @return all the worker's metrics in the format of {@link Metric}\n-   */\n-  public static List<Metric> allWorkerMetrics() {\n-    return allInstanceMetrics(InstanceType.WORKER);\n-  }\n-\n-  /**\n-   * @return all the client's metrics in the format of {@link Metric}\n-   */\n-  public static List<Metric> allClientMetrics() {\n-    return allInstanceMetrics(InstanceType.CLIENT);\n-  }\n-\n-  /**\n-   * Gets all metrics of the given instance type.\n+   * Initialize the should report metrics. This should be called only once.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY0Njc4MA=="}, "originalCommit": {"oid": "49d4f14b3954953cc54a8c76e9f542f0fe73cf34"}, "originalPosition": 291}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2140, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}