{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDMyMTAyNjQy", "number": 11535, "reviewThreads": {"totalCount": 25, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQyMjo0OToyM1rOEEFPYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxOToyOToyNFrOEGFD9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNzE1NjE3OnYy", "diffSide": "RIGHT", "path": "tests/src/test/java/alluxio/client/cli/fsadmin/BackupCommandIntegrationTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQyMjo0OToyM1rOGhfBAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQyMjo0OToyM1rOGhfBAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc2NDM1NQ==", "bodyText": "@gpang if you pass the last argument of StateLockOptions as 0 (which disables the interrupt-waiters cycle), then the repro will fail as before.", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r437764355", "createdAt": "2020-06-09T22:49:23Z", "author": {"login": "ggezer"}, "path": "tests/src/test/java/alluxio/client/cli/fsadmin/BackupCommandIntegrationTest.java", "diffHunk": "@@ -87,4 +101,54 @@ public void timeout() throws Exception {\n       assertNotEquals(0, errCode);\n     }\n   }\n+\n+  @Test\n+  public void workersLostRepro() throws Exception {\n+    // Grab the master state-change lock via reflection.\n+    MasterProcess masterProcess =\n+        Whitebox.getInternalState(mLocalAlluxioCluster.getLocalAlluxioMaster(), \"mMasterProcess\");\n+    MasterContext masterCtx = Whitebox.getInternalState(masterProcess, \"mContext\");\n+    StateLockManager stateLockManager = masterCtx.getStateLockManager();\n+\n+    BlockMaster blockMaster = masterProcess.getMaster(BlockMaster.class);\n+    Whitebox.setInternalState(blockMaster, \"mMasterContext\", masterCtx);\n+\n+    FileSystemMaster fsMaster = masterProcess.getMaster(FileSystemMaster.class);\n+    Whitebox.setInternalState(fsMaster, \"mMasterContext\", masterCtx);\n+\n+    FileSystem fs = mLocalAlluxioCluster.getClient();\n+    FileOutStream fsOutStr = fs.createFile(new AlluxioURI(\"/test\"));\n+    fsOutStr.write(\"bogus\".getBytes());\n+    // Lock the state-change lock on the master.\n+    LockResource lr =\n+        stateLockManager.lockExclusive(new StateLockOptions(false, false, true, 0, 0, 0, 100));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d5b75bfc788ecfaa6d8cbf059542924b0738821c"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNzMxMzAwOnYy", "diffSide": "RIGHT", "path": "core/common/src/main/java/alluxio/resource/LockResource.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwMDowNzowMFrOGhgf_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwMDowNzowMFrOGhgf_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc4ODY3MQ==", "bodyText": "Mark the runnable as @Nullable", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r437788671", "createdAt": "2020-06-10T00:07:00Z", "author": {"login": "gpang"}, "path": "core/common/src/main/java/alluxio/resource/LockResource.java", "diffHunk": "@@ -59,7 +56,25 @@ public LockResource(Lock lock) {\n    * @param useTryLock whether or not use to {@link Lock#tryLock()}\n    */\n   public LockResource(Lock lock, boolean acquireLock, boolean useTryLock) {\n+    this(lock, acquireLock, useTryLock, null);\n+  }\n+\n+  /**\n+   * Creates a new instance of {@link LockResource} using the given lock.\n+   *\n+   * This method may use the {@link Lock#tryLock()} method to gain ownership of the locks. The\n+   * reason one might want to use this is to avoid the fairness heuristics within the\n+   * {@link java.util.concurrent.locks.ReentrantReadWriteLock}'s NonFairSync which may block reader\n+   * threads if a writer if the first in the queue.\n+   *\n+   * @param lock the lock to acquire\n+   * @param acquireLock whether to lock the lock\n+   * @param useTryLock whether or not use to {@link Lock#tryLock()}\n+   * @param closeAction the closeable that will be closed along with this lock\n+   */\n+  public LockResource(Lock lock, boolean acquireLock, boolean useTryLock, Runnable closeAction) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "69ff6f65f4e88e80951149f0a3d3899da5d8cfff"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMDE0NzMwOnYy", "diffSide": "RIGHT", "path": "core/server/common/src/main/java/alluxio/master/AbstractMaster.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxNjoxMjozM1rOGh8amA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMToyNToyNFrOGiG2ww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI0NjA0MA==", "bodyText": "Does this mean backup is in progress? Should we say more in the message?", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r438246040", "createdAt": "2020-06-10T16:12:33Z", "author": {"login": "gpang"}, "path": "core/server/common/src/main/java/alluxio/master/AbstractMaster.java", "diffHunk": "@@ -135,8 +136,14 @@ protected ExecutorService getExecutorService() {\n   public JournalContext createJournalContext() throws UnavailableException {\n     // Use the state change lock for the journal context, since all modifications to journaled\n     // state must happen inside of a journal context.\n-    return new StateChangeJournalContext(mJournal.createJournalContext(),\n-        mMasterContext.stateChangeLock());\n+    LockResource sharedLockResource;\n+    try {\n+      sharedLockResource = mMasterContext.getStateLockManager().lockShared();\n+    } catch (InterruptedException e) {\n+      throw new UnavailableException(\"Failed to acquire state-lock in shared mode.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e248a260c674452ccdc7bfad1c202df47033c27"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQxNzA5MQ==", "bodyText": "Changed as \"Failed to acquire state-lock due to ongoing backup activity.", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r438417091", "createdAt": "2020-06-10T21:25:24Z", "author": {"login": "ggezer"}, "path": "core/server/common/src/main/java/alluxio/master/AbstractMaster.java", "diffHunk": "@@ -135,8 +136,14 @@ protected ExecutorService getExecutorService() {\n   public JournalContext createJournalContext() throws UnavailableException {\n     // Use the state change lock for the journal context, since all modifications to journaled\n     // state must happen inside of a journal context.\n-    return new StateChangeJournalContext(mJournal.createJournalContext(),\n-        mMasterContext.stateChangeLock());\n+    LockResource sharedLockResource;\n+    try {\n+      sharedLockResource = mMasterContext.getStateLockManager().lockShared();\n+    } catch (InterruptedException e) {\n+      throw new UnavailableException(\"Failed to acquire state-lock in shared mode.\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI0NjA0MA=="}, "originalCommit": {"oid": "5e248a260c674452ccdc7bfad1c202df47033c27"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMDE2MzUzOnYy", "diffSide": "LEFT", "path": "core/transport/src/main/proto/grpc/meta_master.proto", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxNjoxNjozOFrOGh8lAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxODo0Mjo1N1rOGiB12w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI0ODcwNg==", "bodyText": "If these were in a previous release, removal is not backwards compatible.", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r438248706", "createdAt": "2020-06-10T16:16:38Z", "author": {"login": "gpang"}, "path": "core/transport/src/main/proto/grpc/meta_master.proto", "diffHunk": "@@ -119,9 +119,6 @@ message BackupPOptions {\n     optional bool localFileSystem = 1;\n     optional bool runAsync = 2;\n     optional bool allowLeader = 3;\n-    optional int64 stateLockTryDurationMs = 4;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e248a260c674452ccdc7bfad1c202df47033c27"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMzNDkzOQ==", "bodyText": "We have added in the previous patch release AFAIR. And not used by clients at all. I think it's safe to remove them.", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r438334939", "createdAt": "2020-06-10T18:42:57Z", "author": {"login": "ggezer"}, "path": "core/transport/src/main/proto/grpc/meta_master.proto", "diffHunk": "@@ -119,9 +119,6 @@ message BackupPOptions {\n     optional bool localFileSystem = 1;\n     optional bool runAsync = 2;\n     optional bool allowLeader = 3;\n-    optional int64 stateLockTryDurationMs = 4;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI0ODcwNg=="}, "originalCommit": {"oid": "5e248a260c674452ccdc7bfad1c202df47033c27"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMDE2NDk1OnYy", "diffSide": "RIGHT", "path": "pom.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxNjoxNjo1OVrOGh8l3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxODo0MzoxN1rOGiB2nA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI0ODkyNw==", "bodyText": "are the changes in this file necessary?", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r438248927", "createdAt": "2020-06-10T16:16:59Z", "author": {"login": "gpang"}, "path": "pom.xml", "diffHunk": "@@ -158,7 +158,7 @@\n     <surefire.rerunFailingTestsCount>1</surefire.rerunFailingTestsCount>\n     <test.output.redirect>true</test.output.redirect>\n     <update.check.enabled>false</update.check.enabled>\n-    <findbugs.skip>false</findbugs.skip>\n+    <findbugs.skip>true</findbugs.skip>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e248a260c674452ccdc7bfad1c202df47033c27"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMzNTEzMg==", "bodyText": "didn't want to deal with style during a prototype.", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r438335132", "createdAt": "2020-06-10T18:43:17Z", "author": {"login": "ggezer"}, "path": "pom.xml", "diffHunk": "@@ -158,7 +158,7 @@\n     <surefire.rerunFailingTestsCount>1</surefire.rerunFailingTestsCount>\n     <test.output.redirect>true</test.output.redirect>\n     <update.check.enabled>false</update.check.enabled>\n-    <findbugs.skip>false</findbugs.skip>\n+    <findbugs.skip>true</findbugs.skip>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI0ODkyNw=="}, "originalCommit": {"oid": "5e248a260c674452ccdc7bfad1c202df47033c27"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMDE2NjYyOnYy", "diffSide": "RIGHT", "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxNjoxNzoyN1rOGh8nBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxNjoxNzoyN1rOGh8nBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI0OTIyMQ==", "bodyText": "why are these all set to IGNORE?", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r438249221", "createdAt": "2020-06-10T16:17:27Z", "author": {"login": "gpang"}, "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "diffHunk": "@@ -1296,6 +1296,13 @@ public String toString() {\n           .setConsistencyCheckLevel(ConsistencyCheckLevel.IGNORE)\n           .setScope(Scope.MASTER)\n           .build();\n+  public static final PropertyKey MASTER_BACKUP_STATE_LOCK_SAFE_MODE =\n+      new Builder(Name.MASTER_BACKUP_STATE_LOCK_SAFE_MODE)\n+          .setDefaultValue(false)\n+          .setDescription(\"Ignores client state-lock requests for backup to always take the lock.\")\n+          .setConsistencyCheckLevel(ConsistencyCheckLevel.IGNORE)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e248a260c674452ccdc7bfad1c202df47033c27"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMDE3MTY1OnYy", "diffSide": "RIGHT", "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxNjoxODozM1rOGh8qBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxNjoxODozM1rOGh8qBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI0OTk4OQ==", "bodyText": "Can you add what this implies? Like, all new rpcs could block for this long?", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r438249989", "createdAt": "2020-06-10T16:18:33Z", "author": {"login": "gpang"}, "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "diffHunk": "@@ -1323,11 +1330,24 @@ public String toString() {\n           .setConsistencyCheckLevel(ConsistencyCheckLevel.ENFORCE)\n           .setScope(Scope.MASTER)\n           .build();\n-  public static final PropertyKey MASTER_BACKUP_STATE_LOCK_TIMEOUT =\n-      new Builder(Name.MASTER_BACKUP_STATE_LOCK_TIMEOUT)\n+  public static final PropertyKey MASTER_SHELL_BACKUP_STATE_LOCK_TIMEOUT =\n+      new Builder(Name.MASTER_SHELL_BACKUP_STATE_LOCK_TIMEOUT)\n           .setDefaultValue(\"1m\")\n-          .setDescription(\n-              \"The max duration to try acquiring the state lock for taking backups via shell.\")\n+          .setDescription(\"The max duration to try acquiring the state lock for taking backups .\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e248a260c674452ccdc7bfad1c202df47033c27"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMDE3NTE5OnYy", "diffSide": "RIGHT", "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxNjoxOToxN1rOGh8sJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxNjoxOToxN1rOGh8sJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI1MDUzNA==", "bodyText": "I don't think grace period is defined anywhere, so this description is not obvious what it means.", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r438250534", "createdAt": "2020-06-10T16:19:17Z", "author": {"login": "gpang"}, "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "diffHunk": "@@ -1323,11 +1330,24 @@ public String toString() {\n           .setConsistencyCheckLevel(ConsistencyCheckLevel.ENFORCE)\n           .setScope(Scope.MASTER)\n           .build();\n-  public static final PropertyKey MASTER_BACKUP_STATE_LOCK_TIMEOUT =\n-      new Builder(Name.MASTER_BACKUP_STATE_LOCK_TIMEOUT)\n+  public static final PropertyKey MASTER_SHELL_BACKUP_STATE_LOCK_TIMEOUT =\n+      new Builder(Name.MASTER_SHELL_BACKUP_STATE_LOCK_TIMEOUT)\n           .setDefaultValue(\"1m\")\n-          .setDescription(\n-              \"The max duration to try acquiring the state lock for taking backups via shell.\")\n+          .setDescription(\"The max duration to try acquiring the state lock for taking backups .\")\n+          .setConsistencyCheckLevel(ConsistencyCheckLevel.IGNORE)\n+          .setScope(Scope.MASTER)\n+          .build();\n+  public static final PropertyKey MASTER_SHELL_BACKUP_STATE_LOCK_INTERRUPT_HOLDERS_AFTER_GRACE =\n+      new Builder(Name.MASTER_SHELL_BACKUP_STATE_LOCK_INTERRUPT_HOLDERS_AFTER_GRACE)\n+          .setDefaultValue(false)\n+          .setDescription(\"Whether to interrupt state-lock holders after grace period.\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e248a260c674452ccdc7bfad1c202df47033c27"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMDE3NzM2OnYy", "diffSide": "RIGHT", "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxNjoxOTo1OFrOGh8tkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxNjoxOTo1OFrOGh8tkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI1MDg5OA==", "bodyText": "I don't think grace period is defined anywhere, so this description is not obvious what it means. Also, it is not clear how it is different from MASTER_SHELL_BACKUP_STATE_LOCK_INTERRUPT_HOLDERS_AFTER_GRACE. Interrupting sounds forceful, so would this parameter be different?", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r438250898", "createdAt": "2020-06-10T16:19:58Z", "author": {"login": "gpang"}, "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "diffHunk": "@@ -1323,11 +1330,24 @@ public String toString() {\n           .setConsistencyCheckLevel(ConsistencyCheckLevel.ENFORCE)\n           .setScope(Scope.MASTER)\n           .build();\n-  public static final PropertyKey MASTER_BACKUP_STATE_LOCK_TIMEOUT =\n-      new Builder(Name.MASTER_BACKUP_STATE_LOCK_TIMEOUT)\n+  public static final PropertyKey MASTER_SHELL_BACKUP_STATE_LOCK_TIMEOUT =\n+      new Builder(Name.MASTER_SHELL_BACKUP_STATE_LOCK_TIMEOUT)\n           .setDefaultValue(\"1m\")\n-          .setDescription(\n-              \"The max duration to try acquiring the state lock for taking backups via shell.\")\n+          .setDescription(\"The max duration to try acquiring the state lock for taking backups .\")\n+          .setConsistencyCheckLevel(ConsistencyCheckLevel.IGNORE)\n+          .setScope(Scope.MASTER)\n+          .build();\n+  public static final PropertyKey MASTER_SHELL_BACKUP_STATE_LOCK_INTERRUPT_HOLDERS_AFTER_GRACE =\n+      new Builder(Name.MASTER_SHELL_BACKUP_STATE_LOCK_INTERRUPT_HOLDERS_AFTER_GRACE)\n+          .setDefaultValue(false)\n+          .setDescription(\"Whether to interrupt state-lock holders after grace period.\")\n+          .setConsistencyCheckLevel(ConsistencyCheckLevel.IGNORE)\n+          .setScope(Scope.MASTER)\n+          .build();\n+  public static final PropertyKey MASTER_SHELL_BACKUP_STATE_LOCK_TAKE_AFTER_GRACE =\n+      new Builder(Name.MASTER_SHELL_BACKUP_STATE_LOCK_TAKE_AFTER_GRACE)\n+          .setDefaultValue(false)\n+          .setDescription(\"Whether to take the lock forcefully after grace period.\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e248a260c674452ccdc7bfad1c202df47033c27"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMDE4MDExOnYy", "diffSide": "RIGHT", "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxNjoyMDozOVrOGh8vWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxODo0NTowOFrOGjOQIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI1MTM1NA==", "bodyText": "I have the same questions as the shell ones.", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r438251354", "createdAt": "2020-06-10T16:20:39Z", "author": {"login": "gpang"}, "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "diffHunk": "@@ -1352,6 +1372,20 @@ public String toString() {\n           .setConsistencyCheckLevel(ConsistencyCheckLevel.IGNORE)\n           .setScope(Scope.MASTER)\n           .build();\n+  public static final PropertyKey MASTER_DAILY_BACKUP_STATE_LOCK_INTERRUPT_HOLDERS_AFTER_GRACE =\n+      new Builder(Name.MASTER_DAILY_BACKUP_STATE_LOCK_INTERRUPT_HOLDERS_AFTER_GRACE)\n+          .setDefaultValue(true)\n+          .setDescription(\"Whether to interrupt state-lock holders after grace period.\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e248a260c674452ccdc7bfad1c202df47033c27"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4Njg1MA==", "bodyText": "@gpang Please re-check all props as I did a major reorg.", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r439586850", "createdAt": "2020-06-12T18:45:08Z", "author": {"login": "ggezer"}, "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "diffHunk": "@@ -1352,6 +1372,20 @@ public String toString() {\n           .setConsistencyCheckLevel(ConsistencyCheckLevel.IGNORE)\n           .setScope(Scope.MASTER)\n           .build();\n+  public static final PropertyKey MASTER_DAILY_BACKUP_STATE_LOCK_INTERRUPT_HOLDERS_AFTER_GRACE =\n+      new Builder(Name.MASTER_DAILY_BACKUP_STATE_LOCK_INTERRUPT_HOLDERS_AFTER_GRACE)\n+          .setDefaultValue(true)\n+          .setDescription(\"Whether to interrupt state-lock holders after grace period.\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI1MTM1NA=="}, "originalCommit": {"oid": "5e248a260c674452ccdc7bfad1c202df47033c27"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMDE5MzU2OnYy", "diffSide": "RIGHT", "path": "core/server/common/src/main/java/alluxio/master/StateLockManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxNjoyMzo1OVrOGh838w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxODo0NDo1MVrOGiB57w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI1MzU1NQ==", "bodyText": "what does safe mode mean? I think it would be helpful if there was more documentation on this class as to what various terms mean, and workflow or state transitions.", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r438253555", "createdAt": "2020-06-10T16:23:59Z", "author": {"login": "gpang"}, "path": "core/server/common/src/main/java/alluxio/master/StateLockManager.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master;\n+\n+import alluxio.collections.ConcurrentHashSet;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.exception.ExceptionMessage;\n+import alluxio.resource.LockResource;\n+import alluxio.util.ThreadFactoryUtils;\n+\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+/**\n+ * Provides graceful and interruptable locking protocol for taking the state lock.\n+ *\n+ * {@link #lockShared()} will be used by user RPCs and may throw {@link InterruptedException}\n+ * based on options passed to {@link #lockExclusive(StateLockOptions)}.\n+ *\n+ * {@link #lockExclusive(StateLockOptions)} will be used by metadata backups in order to\n+ * guarantee paused state during critical tasks.\n+ */\n+public class StateLockManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(StateLockManager.class);\n+\n+  /** The state-lock */\n+  private ReadWriteLock mStateLock = new ReentrantReadWriteLock(true);\n+\n+  /** The set of threads that are waiting for state-lock in shared mode. */\n+  private Set<Thread> mSharedWaiters;\n+  /** The set of threads that are holding the state-lock in shared mode. */\n+  private Set<Thread> mSharedHolders;\n+\n+  /** Scheduler that is used for interrupt-cycle. */\n+  private ScheduledExecutorService mScheduler;\n+  /** The future for the active interrupt cycle */\n+  private ScheduledFuture<?> mInterrupterFuture;\n+\n+  /** Whether state-lock manager is in safe-mode. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e248a260c674452ccdc7bfad1c202df47033c27"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODMzNTk4Mw==", "bodyText": "This is when the master is restarted with a special flag for always allowing backups.", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r438335983", "createdAt": "2020-06-10T18:44:51Z", "author": {"login": "ggezer"}, "path": "core/server/common/src/main/java/alluxio/master/StateLockManager.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master;\n+\n+import alluxio.collections.ConcurrentHashSet;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.exception.ExceptionMessage;\n+import alluxio.resource.LockResource;\n+import alluxio.util.ThreadFactoryUtils;\n+\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+/**\n+ * Provides graceful and interruptable locking protocol for taking the state lock.\n+ *\n+ * {@link #lockShared()} will be used by user RPCs and may throw {@link InterruptedException}\n+ * based on options passed to {@link #lockExclusive(StateLockOptions)}.\n+ *\n+ * {@link #lockExclusive(StateLockOptions)} will be used by metadata backups in order to\n+ * guarantee paused state during critical tasks.\n+ */\n+public class StateLockManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(StateLockManager.class);\n+\n+  /** The state-lock */\n+  private ReadWriteLock mStateLock = new ReentrantReadWriteLock(true);\n+\n+  /** The set of threads that are waiting for state-lock in shared mode. */\n+  private Set<Thread> mSharedWaiters;\n+  /** The set of threads that are holding the state-lock in shared mode. */\n+  private Set<Thread> mSharedHolders;\n+\n+  /** Scheduler that is used for interrupt-cycle. */\n+  private ScheduledExecutorService mScheduler;\n+  /** The future for the active interrupt cycle */\n+  private ScheduledFuture<?> mInterrupterFuture;\n+\n+  /** Whether state-lock manager is in safe-mode. */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI1MzU1NQ=="}, "originalCommit": {"oid": "5e248a260c674452ccdc7bfad1c202df47033c27"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMDIwMjQwOnYy", "diffSide": "RIGHT", "path": "core/server/common/src/main/java/alluxio/master/StateLockManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxNjoyNjoxN1rOGh89qw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxNjoyNjoxN1rOGh89qw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI1NTAxOQ==", "bodyText": "Will this message be propagated to clients? If so, can this be more actionable, and/or informative?", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r438255019", "createdAt": "2020-06-10T16:26:17Z", "author": {"login": "gpang"}, "path": "core/server/common/src/main/java/alluxio/master/StateLockManager.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master;\n+\n+import alluxio.collections.ConcurrentHashSet;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.exception.ExceptionMessage;\n+import alluxio.resource.LockResource;\n+import alluxio.util.ThreadFactoryUtils;\n+\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+/**\n+ * Provides graceful and interruptable locking protocol for taking the state lock.\n+ *\n+ * {@link #lockShared()} will be used by user RPCs and may throw {@link InterruptedException}\n+ * based on options passed to {@link #lockExclusive(StateLockOptions)}.\n+ *\n+ * {@link #lockExclusive(StateLockOptions)} will be used by metadata backups in order to\n+ * guarantee paused state during critical tasks.\n+ */\n+public class StateLockManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(StateLockManager.class);\n+\n+  /** The state-lock */\n+  private ReadWriteLock mStateLock = new ReentrantReadWriteLock(true);\n+\n+  /** The set of threads that are waiting for state-lock in shared mode. */\n+  private Set<Thread> mSharedWaiters;\n+  /** The set of threads that are holding the state-lock in shared mode. */\n+  private Set<Thread> mSharedHolders;\n+\n+  /** Scheduler that is used for interrupt-cycle. */\n+  private ScheduledExecutorService mScheduler;\n+  /** The future for the active interrupt cycle */\n+  private ScheduledFuture<?> mInterrupterFuture;\n+\n+  /** Whether state-lock manager is in safe-mode. */\n+  private boolean mSafeMode;\n+\n+  /**\n+   * Creates a new state-lock manager.\n+   */\n+  public StateLockManager() {\n+    mSharedWaiters = new ConcurrentHashSet<>();\n+    mSharedHolders = new ConcurrentHashSet<>();\n+\n+    mScheduler = Executors\n+        .newSingleThreadScheduledExecutor(ThreadFactoryUtils.build(\"state-lock-manager-%d\", true));\n+\n+    mSafeMode = ServerConfiguration.getBoolean(PropertyKey.MASTER_BACKUP_STATE_LOCK_SAFE_MODE);\n+  }\n+\n+  /**\n+   * Locks the state shared.\n+   *\n+   * @return the lock resource\n+   * @throws InterruptedException\n+   */\n+  public LockResource lockShared() throws InterruptedException {\n+    // Do not allow taking shared lock during safe-mode.\n+    if (mSafeMode) {\n+      throw new IllegalStateException(\"Cannot acquire lock shared during safe-mode.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e248a260c674452ccdc7bfad1c202df47033c27"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMDIxNDU3OnYy", "diffSide": "RIGHT", "path": "core/server/common/src/main/java/alluxio/master/StateLockManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxNjoyOTo0MVrOGh9F7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxNjoyOTo0MVrOGh9F7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI1NzEzMw==", "bodyText": "What is the contract for all the threads this set? Clearly we cannot track this perfectly, so will that be a problem? Some threads in the set will not be waiting for the lock yet.", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r438257133", "createdAt": "2020-06-10T16:29:41Z", "author": {"login": "gpang"}, "path": "core/server/common/src/main/java/alluxio/master/StateLockManager.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master;\n+\n+import alluxio.collections.ConcurrentHashSet;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.exception.ExceptionMessage;\n+import alluxio.resource.LockResource;\n+import alluxio.util.ThreadFactoryUtils;\n+\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+/**\n+ * Provides graceful and interruptable locking protocol for taking the state lock.\n+ *\n+ * {@link #lockShared()} will be used by user RPCs and may throw {@link InterruptedException}\n+ * based on options passed to {@link #lockExclusive(StateLockOptions)}.\n+ *\n+ * {@link #lockExclusive(StateLockOptions)} will be used by metadata backups in order to\n+ * guarantee paused state during critical tasks.\n+ */\n+public class StateLockManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(StateLockManager.class);\n+\n+  /** The state-lock */\n+  private ReadWriteLock mStateLock = new ReentrantReadWriteLock(true);\n+\n+  /** The set of threads that are waiting for state-lock in shared mode. */\n+  private Set<Thread> mSharedWaiters;\n+  /** The set of threads that are holding the state-lock in shared mode. */\n+  private Set<Thread> mSharedHolders;\n+\n+  /** Scheduler that is used for interrupt-cycle. */\n+  private ScheduledExecutorService mScheduler;\n+  /** The future for the active interrupt cycle */\n+  private ScheduledFuture<?> mInterrupterFuture;\n+\n+  /** Whether state-lock manager is in safe-mode. */\n+  private boolean mSafeMode;\n+\n+  /**\n+   * Creates a new state-lock manager.\n+   */\n+  public StateLockManager() {\n+    mSharedWaiters = new ConcurrentHashSet<>();\n+    mSharedHolders = new ConcurrentHashSet<>();\n+\n+    mScheduler = Executors\n+        .newSingleThreadScheduledExecutor(ThreadFactoryUtils.build(\"state-lock-manager-%d\", true));\n+\n+    mSafeMode = ServerConfiguration.getBoolean(PropertyKey.MASTER_BACKUP_STATE_LOCK_SAFE_MODE);\n+  }\n+\n+  /**\n+   * Locks the state shared.\n+   *\n+   * @return the lock resource\n+   * @throws InterruptedException\n+   */\n+  public LockResource lockShared() throws InterruptedException {\n+    // Do not allow taking shared lock during safe-mode.\n+    if (mSafeMode) {\n+      throw new IllegalStateException(\"Cannot acquire lock shared during safe-mode.\");\n+    }\n+    try {\n+      // Register as waiter.\n+      mSharedWaiters.add(Thread.currentThread());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e248a260c674452ccdc7bfad1c202df47033c27"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMDIxNzQzOnYy", "diffSide": "RIGHT", "path": "core/server/common/src/main/java/alluxio/master/StateLockManager.java", "isResolved": true, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxNjozMDoyOVrOGh9H1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwMzo1Mzo0OVrOGiNofw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI1NzYyMQ==", "bodyText": "What is the contract for all the threads this set? Clearly we cannot track this perfectly, so will that be a problem? Some actual lock holders will not be in the holder set yet.\nAlso, there is a point in time that a thread is not in either set. What are the implications of that?\nBasically, since we cannot track the lock holders and waiters in a perfectly consistent way, which inconsistencies are we able to handle?", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r438257621", "createdAt": "2020-06-10T16:30:29Z", "author": {"login": "gpang"}, "path": "core/server/common/src/main/java/alluxio/master/StateLockManager.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master;\n+\n+import alluxio.collections.ConcurrentHashSet;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.exception.ExceptionMessage;\n+import alluxio.resource.LockResource;\n+import alluxio.util.ThreadFactoryUtils;\n+\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+/**\n+ * Provides graceful and interruptable locking protocol for taking the state lock.\n+ *\n+ * {@link #lockShared()} will be used by user RPCs and may throw {@link InterruptedException}\n+ * based on options passed to {@link #lockExclusive(StateLockOptions)}.\n+ *\n+ * {@link #lockExclusive(StateLockOptions)} will be used by metadata backups in order to\n+ * guarantee paused state during critical tasks.\n+ */\n+public class StateLockManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(StateLockManager.class);\n+\n+  /** The state-lock */\n+  private ReadWriteLock mStateLock = new ReentrantReadWriteLock(true);\n+\n+  /** The set of threads that are waiting for state-lock in shared mode. */\n+  private Set<Thread> mSharedWaiters;\n+  /** The set of threads that are holding the state-lock in shared mode. */\n+  private Set<Thread> mSharedHolders;\n+\n+  /** Scheduler that is used for interrupt-cycle. */\n+  private ScheduledExecutorService mScheduler;\n+  /** The future for the active interrupt cycle */\n+  private ScheduledFuture<?> mInterrupterFuture;\n+\n+  /** Whether state-lock manager is in safe-mode. */\n+  private boolean mSafeMode;\n+\n+  /**\n+   * Creates a new state-lock manager.\n+   */\n+  public StateLockManager() {\n+    mSharedWaiters = new ConcurrentHashSet<>();\n+    mSharedHolders = new ConcurrentHashSet<>();\n+\n+    mScheduler = Executors\n+        .newSingleThreadScheduledExecutor(ThreadFactoryUtils.build(\"state-lock-manager-%d\", true));\n+\n+    mSafeMode = ServerConfiguration.getBoolean(PropertyKey.MASTER_BACKUP_STATE_LOCK_SAFE_MODE);\n+  }\n+\n+  /**\n+   * Locks the state shared.\n+   *\n+   * @return the lock resource\n+   * @throws InterruptedException\n+   */\n+  public LockResource lockShared() throws InterruptedException {\n+    // Do not allow taking shared lock during safe-mode.\n+    if (mSafeMode) {\n+      throw new IllegalStateException(\"Cannot acquire lock shared during safe-mode.\");\n+    }\n+    try {\n+      // Register as waiter.\n+      mSharedWaiters.add(Thread.currentThread());\n+      // Grab the lock interruptibly.\n+      mStateLock.readLock().lockInterruptibly();\n+    } finally {\n+      // Remove itself from waiters.\n+      mSharedWaiters.remove(Thread.currentThread());\n+    }\n+    // Register as holder.\n+    mSharedHolders.add(Thread.currentThread());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e248a260c674452ccdc7bfad1c202df47033c27"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQwODg4OQ==", "bodyText": "Races around sets are:\n1-Thread interrupted before calling lockInterruptibly()\n* not an issue since lockInterruptbly() API will throw for an already interrupted thread.\n2- Thread interrupted after the lock is acquired (until it's removed from the set):\n* we can reset the interrupt flag after taking the lock.\n3- Thread misses an interrupt for holders before it's added to shared-holders set.\n* not an issue unless this missed thread was going to run a long rpc like ls -R.\n* this can be hardened by accessing each set under a lock, and holding the same lock during interrupt loops.\n4- Thread gets interrupted before returning.\n* after removing from the holders set. we can reset thread's interrupt state.", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r438408889", "createdAt": "2020-06-10T21:07:13Z", "author": {"login": "ggezer"}, "path": "core/server/common/src/main/java/alluxio/master/StateLockManager.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master;\n+\n+import alluxio.collections.ConcurrentHashSet;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.exception.ExceptionMessage;\n+import alluxio.resource.LockResource;\n+import alluxio.util.ThreadFactoryUtils;\n+\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+/**\n+ * Provides graceful and interruptable locking protocol for taking the state lock.\n+ *\n+ * {@link #lockShared()} will be used by user RPCs and may throw {@link InterruptedException}\n+ * based on options passed to {@link #lockExclusive(StateLockOptions)}.\n+ *\n+ * {@link #lockExclusive(StateLockOptions)} will be used by metadata backups in order to\n+ * guarantee paused state during critical tasks.\n+ */\n+public class StateLockManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(StateLockManager.class);\n+\n+  /** The state-lock */\n+  private ReadWriteLock mStateLock = new ReentrantReadWriteLock(true);\n+\n+  /** The set of threads that are waiting for state-lock in shared mode. */\n+  private Set<Thread> mSharedWaiters;\n+  /** The set of threads that are holding the state-lock in shared mode. */\n+  private Set<Thread> mSharedHolders;\n+\n+  /** Scheduler that is used for interrupt-cycle. */\n+  private ScheduledExecutorService mScheduler;\n+  /** The future for the active interrupt cycle */\n+  private ScheduledFuture<?> mInterrupterFuture;\n+\n+  /** Whether state-lock manager is in safe-mode. */\n+  private boolean mSafeMode;\n+\n+  /**\n+   * Creates a new state-lock manager.\n+   */\n+  public StateLockManager() {\n+    mSharedWaiters = new ConcurrentHashSet<>();\n+    mSharedHolders = new ConcurrentHashSet<>();\n+\n+    mScheduler = Executors\n+        .newSingleThreadScheduledExecutor(ThreadFactoryUtils.build(\"state-lock-manager-%d\", true));\n+\n+    mSafeMode = ServerConfiguration.getBoolean(PropertyKey.MASTER_BACKUP_STATE_LOCK_SAFE_MODE);\n+  }\n+\n+  /**\n+   * Locks the state shared.\n+   *\n+   * @return the lock resource\n+   * @throws InterruptedException\n+   */\n+  public LockResource lockShared() throws InterruptedException {\n+    // Do not allow taking shared lock during safe-mode.\n+    if (mSafeMode) {\n+      throw new IllegalStateException(\"Cannot acquire lock shared during safe-mode.\");\n+    }\n+    try {\n+      // Register as waiter.\n+      mSharedWaiters.add(Thread.currentThread());\n+      // Grab the lock interruptibly.\n+      mStateLock.readLock().lockInterruptibly();\n+    } finally {\n+      // Remove itself from waiters.\n+      mSharedWaiters.remove(Thread.currentThread());\n+    }\n+    // Register as holder.\n+    mSharedHolders.add(Thread.currentThread());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI1NzYyMQ=="}, "originalCommit": {"oid": "5e248a260c674452ccdc7bfad1c202df47033c27"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQxMDY2MQ==", "bodyText": "Overall I think below will suffice in terms of restraining the inconsistencies that can arise:\na- locking set add/remove/iterate operations\nb- resetting caller thread's interrupted state as provided in 2-4.\nFor b; to avoid interfering with the system shutdown,  we can keep track of threads we ourselves interrupted and run the reset logic only for those.", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r438410661", "createdAt": "2020-06-10T21:11:07Z", "author": {"login": "ggezer"}, "path": "core/server/common/src/main/java/alluxio/master/StateLockManager.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master;\n+\n+import alluxio.collections.ConcurrentHashSet;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.exception.ExceptionMessage;\n+import alluxio.resource.LockResource;\n+import alluxio.util.ThreadFactoryUtils;\n+\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+/**\n+ * Provides graceful and interruptable locking protocol for taking the state lock.\n+ *\n+ * {@link #lockShared()} will be used by user RPCs and may throw {@link InterruptedException}\n+ * based on options passed to {@link #lockExclusive(StateLockOptions)}.\n+ *\n+ * {@link #lockExclusive(StateLockOptions)} will be used by metadata backups in order to\n+ * guarantee paused state during critical tasks.\n+ */\n+public class StateLockManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(StateLockManager.class);\n+\n+  /** The state-lock */\n+  private ReadWriteLock mStateLock = new ReentrantReadWriteLock(true);\n+\n+  /** The set of threads that are waiting for state-lock in shared mode. */\n+  private Set<Thread> mSharedWaiters;\n+  /** The set of threads that are holding the state-lock in shared mode. */\n+  private Set<Thread> mSharedHolders;\n+\n+  /** Scheduler that is used for interrupt-cycle. */\n+  private ScheduledExecutorService mScheduler;\n+  /** The future for the active interrupt cycle */\n+  private ScheduledFuture<?> mInterrupterFuture;\n+\n+  /** Whether state-lock manager is in safe-mode. */\n+  private boolean mSafeMode;\n+\n+  /**\n+   * Creates a new state-lock manager.\n+   */\n+  public StateLockManager() {\n+    mSharedWaiters = new ConcurrentHashSet<>();\n+    mSharedHolders = new ConcurrentHashSet<>();\n+\n+    mScheduler = Executors\n+        .newSingleThreadScheduledExecutor(ThreadFactoryUtils.build(\"state-lock-manager-%d\", true));\n+\n+    mSafeMode = ServerConfiguration.getBoolean(PropertyKey.MASTER_BACKUP_STATE_LOCK_SAFE_MODE);\n+  }\n+\n+  /**\n+   * Locks the state shared.\n+   *\n+   * @return the lock resource\n+   * @throws InterruptedException\n+   */\n+  public LockResource lockShared() throws InterruptedException {\n+    // Do not allow taking shared lock during safe-mode.\n+    if (mSafeMode) {\n+      throw new IllegalStateException(\"Cannot acquire lock shared during safe-mode.\");\n+    }\n+    try {\n+      // Register as waiter.\n+      mSharedWaiters.add(Thread.currentThread());\n+      // Grab the lock interruptibly.\n+      mStateLock.readLock().lockInterruptibly();\n+    } finally {\n+      // Remove itself from waiters.\n+      mSharedWaiters.remove(Thread.currentThread());\n+    }\n+    // Register as holder.\n+    mSharedHolders.add(Thread.currentThread());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI1NzYyMQ=="}, "originalCommit": {"oid": "5e248a260c674452ccdc7bfad1c202df47033c27"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ2MzE3NQ==", "bodyText": "hrmmm, this seems tricky and hard to guarantee correct behavior...", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r438463175", "createdAt": "2020-06-10T23:34:35Z", "author": {"login": "gpang"}, "path": "core/server/common/src/main/java/alluxio/master/StateLockManager.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master;\n+\n+import alluxio.collections.ConcurrentHashSet;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.exception.ExceptionMessage;\n+import alluxio.resource.LockResource;\n+import alluxio.util.ThreadFactoryUtils;\n+\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+/**\n+ * Provides graceful and interruptable locking protocol for taking the state lock.\n+ *\n+ * {@link #lockShared()} will be used by user RPCs and may throw {@link InterruptedException}\n+ * based on options passed to {@link #lockExclusive(StateLockOptions)}.\n+ *\n+ * {@link #lockExclusive(StateLockOptions)} will be used by metadata backups in order to\n+ * guarantee paused state during critical tasks.\n+ */\n+public class StateLockManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(StateLockManager.class);\n+\n+  /** The state-lock */\n+  private ReadWriteLock mStateLock = new ReentrantReadWriteLock(true);\n+\n+  /** The set of threads that are waiting for state-lock in shared mode. */\n+  private Set<Thread> mSharedWaiters;\n+  /** The set of threads that are holding the state-lock in shared mode. */\n+  private Set<Thread> mSharedHolders;\n+\n+  /** Scheduler that is used for interrupt-cycle. */\n+  private ScheduledExecutorService mScheduler;\n+  /** The future for the active interrupt cycle */\n+  private ScheduledFuture<?> mInterrupterFuture;\n+\n+  /** Whether state-lock manager is in safe-mode. */\n+  private boolean mSafeMode;\n+\n+  /**\n+   * Creates a new state-lock manager.\n+   */\n+  public StateLockManager() {\n+    mSharedWaiters = new ConcurrentHashSet<>();\n+    mSharedHolders = new ConcurrentHashSet<>();\n+\n+    mScheduler = Executors\n+        .newSingleThreadScheduledExecutor(ThreadFactoryUtils.build(\"state-lock-manager-%d\", true));\n+\n+    mSafeMode = ServerConfiguration.getBoolean(PropertyKey.MASTER_BACKUP_STATE_LOCK_SAFE_MODE);\n+  }\n+\n+  /**\n+   * Locks the state shared.\n+   *\n+   * @return the lock resource\n+   * @throws InterruptedException\n+   */\n+  public LockResource lockShared() throws InterruptedException {\n+    // Do not allow taking shared lock during safe-mode.\n+    if (mSafeMode) {\n+      throw new IllegalStateException(\"Cannot acquire lock shared during safe-mode.\");\n+    }\n+    try {\n+      // Register as waiter.\n+      mSharedWaiters.add(Thread.currentThread());\n+      // Grab the lock interruptibly.\n+      mStateLock.readLock().lockInterruptibly();\n+    } finally {\n+      // Remove itself from waiters.\n+      mSharedWaiters.remove(Thread.currentThread());\n+    }\n+    // Register as holder.\n+    mSharedHolders.add(Thread.currentThread());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI1NzYyMQ=="}, "originalCommit": {"oid": "5e248a260c674452ccdc7bfad1c202df47033c27"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ2Mzg3NA==", "bodyText": "what is \"correct behavior\" ?", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r438463874", "createdAt": "2020-06-10T23:37:15Z", "author": {"login": "ggezer"}, "path": "core/server/common/src/main/java/alluxio/master/StateLockManager.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master;\n+\n+import alluxio.collections.ConcurrentHashSet;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.exception.ExceptionMessage;\n+import alluxio.resource.LockResource;\n+import alluxio.util.ThreadFactoryUtils;\n+\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+/**\n+ * Provides graceful and interruptable locking protocol for taking the state lock.\n+ *\n+ * {@link #lockShared()} will be used by user RPCs and may throw {@link InterruptedException}\n+ * based on options passed to {@link #lockExclusive(StateLockOptions)}.\n+ *\n+ * {@link #lockExclusive(StateLockOptions)} will be used by metadata backups in order to\n+ * guarantee paused state during critical tasks.\n+ */\n+public class StateLockManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(StateLockManager.class);\n+\n+  /** The state-lock */\n+  private ReadWriteLock mStateLock = new ReentrantReadWriteLock(true);\n+\n+  /** The set of threads that are waiting for state-lock in shared mode. */\n+  private Set<Thread> mSharedWaiters;\n+  /** The set of threads that are holding the state-lock in shared mode. */\n+  private Set<Thread> mSharedHolders;\n+\n+  /** Scheduler that is used for interrupt-cycle. */\n+  private ScheduledExecutorService mScheduler;\n+  /** The future for the active interrupt cycle */\n+  private ScheduledFuture<?> mInterrupterFuture;\n+\n+  /** Whether state-lock manager is in safe-mode. */\n+  private boolean mSafeMode;\n+\n+  /**\n+   * Creates a new state-lock manager.\n+   */\n+  public StateLockManager() {\n+    mSharedWaiters = new ConcurrentHashSet<>();\n+    mSharedHolders = new ConcurrentHashSet<>();\n+\n+    mScheduler = Executors\n+        .newSingleThreadScheduledExecutor(ThreadFactoryUtils.build(\"state-lock-manager-%d\", true));\n+\n+    mSafeMode = ServerConfiguration.getBoolean(PropertyKey.MASTER_BACKUP_STATE_LOCK_SAFE_MODE);\n+  }\n+\n+  /**\n+   * Locks the state shared.\n+   *\n+   * @return the lock resource\n+   * @throws InterruptedException\n+   */\n+  public LockResource lockShared() throws InterruptedException {\n+    // Do not allow taking shared lock during safe-mode.\n+    if (mSafeMode) {\n+      throw new IllegalStateException(\"Cannot acquire lock shared during safe-mode.\");\n+    }\n+    try {\n+      // Register as waiter.\n+      mSharedWaiters.add(Thread.currentThread());\n+      // Grab the lock interruptibly.\n+      mStateLock.readLock().lockInterruptibly();\n+    } finally {\n+      // Remove itself from waiters.\n+      mSharedWaiters.remove(Thread.currentThread());\n+    }\n+    // Register as holder.\n+    mSharedHolders.add(Thread.currentThread());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI1NzYyMQ=="}, "originalCommit": {"oid": "5e248a260c674452ccdc7bfad1c202df47033c27"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ3MjgwOQ==", "bodyText": "Any inconsistency could lead to two faulty actions:\n1- interrupt a thread when not intended\n2- don't interrupt a thread when required\n2 is covered by the interrupt-cycle.\n1 can be hardened by proposed locking over sets. Then it can only happen at the end of write-lock and that's acceptable.", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r438472809", "createdAt": "2020-06-11T00:08:06Z", "author": {"login": "ggezer"}, "path": "core/server/common/src/main/java/alluxio/master/StateLockManager.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master;\n+\n+import alluxio.collections.ConcurrentHashSet;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.exception.ExceptionMessage;\n+import alluxio.resource.LockResource;\n+import alluxio.util.ThreadFactoryUtils;\n+\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+/**\n+ * Provides graceful and interruptable locking protocol for taking the state lock.\n+ *\n+ * {@link #lockShared()} will be used by user RPCs and may throw {@link InterruptedException}\n+ * based on options passed to {@link #lockExclusive(StateLockOptions)}.\n+ *\n+ * {@link #lockExclusive(StateLockOptions)} will be used by metadata backups in order to\n+ * guarantee paused state during critical tasks.\n+ */\n+public class StateLockManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(StateLockManager.class);\n+\n+  /** The state-lock */\n+  private ReadWriteLock mStateLock = new ReentrantReadWriteLock(true);\n+\n+  /** The set of threads that are waiting for state-lock in shared mode. */\n+  private Set<Thread> mSharedWaiters;\n+  /** The set of threads that are holding the state-lock in shared mode. */\n+  private Set<Thread> mSharedHolders;\n+\n+  /** Scheduler that is used for interrupt-cycle. */\n+  private ScheduledExecutorService mScheduler;\n+  /** The future for the active interrupt cycle */\n+  private ScheduledFuture<?> mInterrupterFuture;\n+\n+  /** Whether state-lock manager is in safe-mode. */\n+  private boolean mSafeMode;\n+\n+  /**\n+   * Creates a new state-lock manager.\n+   */\n+  public StateLockManager() {\n+    mSharedWaiters = new ConcurrentHashSet<>();\n+    mSharedHolders = new ConcurrentHashSet<>();\n+\n+    mScheduler = Executors\n+        .newSingleThreadScheduledExecutor(ThreadFactoryUtils.build(\"state-lock-manager-%d\", true));\n+\n+    mSafeMode = ServerConfiguration.getBoolean(PropertyKey.MASTER_BACKUP_STATE_LOCK_SAFE_MODE);\n+  }\n+\n+  /**\n+   * Locks the state shared.\n+   *\n+   * @return the lock resource\n+   * @throws InterruptedException\n+   */\n+  public LockResource lockShared() throws InterruptedException {\n+    // Do not allow taking shared lock during safe-mode.\n+    if (mSafeMode) {\n+      throw new IllegalStateException(\"Cannot acquire lock shared during safe-mode.\");\n+    }\n+    try {\n+      // Register as waiter.\n+      mSharedWaiters.add(Thread.currentThread());\n+      // Grab the lock interruptibly.\n+      mStateLock.readLock().lockInterruptibly();\n+    } finally {\n+      // Remove itself from waiters.\n+      mSharedWaiters.remove(Thread.currentThread());\n+    }\n+    // Register as holder.\n+    mSharedHolders.add(Thread.currentThread());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI1NzYyMQ=="}, "originalCommit": {"oid": "5e248a260c674452ccdc7bfad1c202df47033c27"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODUyODEyNw==", "bodyText": "@gpang I merged waiters and holders sets as we can reliably keep them at sync without heavy locking over the sets.\nIn the current state, I don't see any unacceptable inconsistency.\n\nthe interrupt could be missed for a thread: this will be handled by the next tick.\nthe interrupted thread might already have released the lock: this will be ignored as a victim of backup. (This can be fixed by keeping track of which threads the manager has interrupted and reset the flags based on that. I don't think that's necessary for the overall scenario though.)\n\nWDYT?", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r438528127", "createdAt": "2020-06-11T03:53:49Z", "author": {"login": "ggezer"}, "path": "core/server/common/src/main/java/alluxio/master/StateLockManager.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master;\n+\n+import alluxio.collections.ConcurrentHashSet;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.exception.ExceptionMessage;\n+import alluxio.resource.LockResource;\n+import alluxio.util.ThreadFactoryUtils;\n+\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+/**\n+ * Provides graceful and interruptable locking protocol for taking the state lock.\n+ *\n+ * {@link #lockShared()} will be used by user RPCs and may throw {@link InterruptedException}\n+ * based on options passed to {@link #lockExclusive(StateLockOptions)}.\n+ *\n+ * {@link #lockExclusive(StateLockOptions)} will be used by metadata backups in order to\n+ * guarantee paused state during critical tasks.\n+ */\n+public class StateLockManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(StateLockManager.class);\n+\n+  /** The state-lock */\n+  private ReadWriteLock mStateLock = new ReentrantReadWriteLock(true);\n+\n+  /** The set of threads that are waiting for state-lock in shared mode. */\n+  private Set<Thread> mSharedWaiters;\n+  /** The set of threads that are holding the state-lock in shared mode. */\n+  private Set<Thread> mSharedHolders;\n+\n+  /** Scheduler that is used for interrupt-cycle. */\n+  private ScheduledExecutorService mScheduler;\n+  /** The future for the active interrupt cycle */\n+  private ScheduledFuture<?> mInterrupterFuture;\n+\n+  /** Whether state-lock manager is in safe-mode. */\n+  private boolean mSafeMode;\n+\n+  /**\n+   * Creates a new state-lock manager.\n+   */\n+  public StateLockManager() {\n+    mSharedWaiters = new ConcurrentHashSet<>();\n+    mSharedHolders = new ConcurrentHashSet<>();\n+\n+    mScheduler = Executors\n+        .newSingleThreadScheduledExecutor(ThreadFactoryUtils.build(\"state-lock-manager-%d\", true));\n+\n+    mSafeMode = ServerConfiguration.getBoolean(PropertyKey.MASTER_BACKUP_STATE_LOCK_SAFE_MODE);\n+  }\n+\n+  /**\n+   * Locks the state shared.\n+   *\n+   * @return the lock resource\n+   * @throws InterruptedException\n+   */\n+  public LockResource lockShared() throws InterruptedException {\n+    // Do not allow taking shared lock during safe-mode.\n+    if (mSafeMode) {\n+      throw new IllegalStateException(\"Cannot acquire lock shared during safe-mode.\");\n+    }\n+    try {\n+      // Register as waiter.\n+      mSharedWaiters.add(Thread.currentThread());\n+      // Grab the lock interruptibly.\n+      mStateLock.readLock().lockInterruptibly();\n+    } finally {\n+      // Remove itself from waiters.\n+      mSharedWaiters.remove(Thread.currentThread());\n+    }\n+    // Register as holder.\n+    mSharedHolders.add(Thread.currentThread());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI1NzYyMQ=="}, "originalCommit": {"oid": "5e248a260c674452ccdc7bfad1c202df47033c27"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMDIzMzQ5OnYy", "diffSide": "RIGHT", "path": "core/server/master/src/main/java/alluxio/master/backup/BackupLeaderRole.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxNjozNDo0M1rOGh9SOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMDo0MToxNVrOGiFjzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI2MDI4Mg==", "bodyText": "Is this supposed to be shell?", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r438260282", "createdAt": "2020-06-10T16:34:43Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/master/backup/BackupLeaderRole.java", "diffHunk": "@@ -98,10 +100,10 @@\n   public BackupLeaderRole(CoreMasterContext masterContext) {\n     super(masterContext);\n     LOG.info(\"Creating backup-leader role.\");\n-    // Store state lock for pausing state change when necessary.\n-    mStatePauseLock = masterContext.pauseStateLock();\n+    // Store state lock manager pausing state change when necessary.\n+    mStateLockManager = masterContext.getStateLockManager();\n     // Read properties.\n-    mStateLockTimeout = ServerConfiguration.getMs(PropertyKey.MASTER_BACKUP_STATE_LOCK_TIMEOUT);\n+    mStateLockTimeout = ServerConfiguration.getMs(PropertyKey.MASTER_SHELL_BACKUP_STATE_LOCK_TIMEOUT);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e248a260c674452ccdc7bfad1c202df47033c27"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM5NTg1Mw==", "bodyText": "Removed this all together.", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r438395853", "createdAt": "2020-06-10T20:41:15Z", "author": {"login": "ggezer"}, "path": "core/server/master/src/main/java/alluxio/master/backup/BackupLeaderRole.java", "diffHunk": "@@ -98,10 +100,10 @@\n   public BackupLeaderRole(CoreMasterContext masterContext) {\n     super(masterContext);\n     LOG.info(\"Creating backup-leader role.\");\n-    // Store state lock for pausing state change when necessary.\n-    mStatePauseLock = masterContext.pauseStateLock();\n+    // Store state lock manager pausing state change when necessary.\n+    mStateLockManager = masterContext.getStateLockManager();\n     // Read properties.\n-    mStateLockTimeout = ServerConfiguration.getMs(PropertyKey.MASTER_BACKUP_STATE_LOCK_TIMEOUT);\n+    mStateLockTimeout = ServerConfiguration.getMs(PropertyKey.MASTER_SHELL_BACKUP_STATE_LOCK_TIMEOUT);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI2MDI4Mg=="}, "originalCommit": {"oid": "5e248a260c674452ccdc7bfad1c202df47033c27"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMDIzODQ5OnYy", "diffSide": "RIGHT", "path": "core/server/master/src/main/java/alluxio/master/meta/DefaultMetaMaster.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQxNjozNTo1OFrOGh9VZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMTozMjoyNVrOGiHDDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI2MTA5NA==", "bodyText": "Can we have more information in this message?", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r438261094", "createdAt": "2020-06-10T16:35:58Z", "author": {"login": "gpang"}, "path": "core/server/master/src/main/java/alluxio/master/meta/DefaultMetaMaster.java", "diffHunk": "@@ -382,11 +370,14 @@ public BackupStatus getBackupStatus(BackupStatusPRequest statusPRequest) throws\n \n   @Override\n   public String checkpoint() throws IOException {\n-    try (LockResource lr = new LockResource(mMasterContext.pauseStateLock())) {\n+    try (LockResource lr =\n+        mMasterContext.getStateLockManager().lockExclusive(StateLockOptions.defaults())) {\n       mJournalSystem.checkpoint();\n+      return NetworkAddressUtils.getConnectHost(NetworkAddressUtils.ServiceType.MASTER_RPC,\n+          ServerConfiguration.global());\n+    } catch (Exception e) {\n+      throw new IOException(\"Failed to take a checkpoint\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e248a260c674452ccdc7bfad1c202df47033c27"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQyMDIzOQ==", "bodyText": "This is unexpected with defaults() options. So I can't know why it failed.", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r438420239", "createdAt": "2020-06-10T21:32:25Z", "author": {"login": "ggezer"}, "path": "core/server/master/src/main/java/alluxio/master/meta/DefaultMetaMaster.java", "diffHunk": "@@ -382,11 +370,14 @@ public BackupStatus getBackupStatus(BackupStatusPRequest statusPRequest) throws\n \n   @Override\n   public String checkpoint() throws IOException {\n-    try (LockResource lr = new LockResource(mMasterContext.pauseStateLock())) {\n+    try (LockResource lr =\n+        mMasterContext.getStateLockManager().lockExclusive(StateLockOptions.defaults())) {\n       mJournalSystem.checkpoint();\n+      return NetworkAddressUtils.getConnectHost(NetworkAddressUtils.ServiceType.MASTER_RPC,\n+          ServerConfiguration.global());\n+    } catch (Exception e) {\n+      throw new IOException(\"Failed to take a checkpoint\", e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI2MTA5NA=="}, "originalCommit": {"oid": "5e248a260c674452ccdc7bfad1c202df47033c27"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczMTQ0NzM3OnYy", "diffSide": "RIGHT", "path": "core/server/common/src/main/java/alluxio/master/StateLockManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQyMzoyNDo0MFrOGiJfTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQwMDo0MDowN1rOGiKxCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ2MDIzNw==", "bodyText": "does safemode never get reset? That means the master can ONLY take a backup and never service clients, even when it is primary?", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r438460237", "createdAt": "2020-06-10T23:24:40Z", "author": {"login": "gpang"}, "path": "core/server/common/src/main/java/alluxio/master/StateLockManager.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master;\n+\n+import alluxio.collections.ConcurrentHashSet;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.exception.ExceptionMessage;\n+import alluxio.resource.LockResource;\n+import alluxio.util.ThreadFactoryUtils;\n+\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+/**\n+ * Provides graceful and interruptable locking protocol for taking the state lock.\n+ *\n+ * {@link #lockShared()} will be used by user RPCs and may throw {@link InterruptedException}\n+ * based on options passed to {@link #lockExclusive(StateLockOptions)}.\n+ *\n+ * {@link #lockExclusive(StateLockOptions)} will be used by metadata backups in order to\n+ * guarantee paused state during critical tasks.\n+ */\n+public class StateLockManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(StateLockManager.class);\n+\n+  /** The state-lock */\n+  private ReadWriteLock mStateLock = new ReentrantReadWriteLock(true);\n+\n+  /** The set of threads that are waiting for state-lock in shared mode. */\n+  private Set<Thread> mSharedWaiters;\n+  /** The set of threads that are holding the state-lock in shared mode. */\n+  private Set<Thread> mSharedHolders;\n+\n+  /** Scheduler that is used for interrupt-cycle. */\n+  private ScheduledExecutorService mScheduler;\n+  /** The future for the active interrupt cycle */\n+  private ScheduledFuture<?> mInterrupterFuture;\n+\n+  /** Whether state-lock manager is in safe-mode. */\n+  private boolean mSafeMode;\n+\n+  /**\n+   * Creates a new state-lock manager.\n+   */\n+  public StateLockManager() {\n+    mSharedWaiters = new ConcurrentHashSet<>();\n+    mSharedHolders = new ConcurrentHashSet<>();\n+\n+    mScheduler = Executors\n+        .newSingleThreadScheduledExecutor(ThreadFactoryUtils.build(\"state-lock-manager-%d\", true));\n+\n+    mSafeMode = ServerConfiguration.getBoolean(PropertyKey.MASTER_BACKUP_STATE_LOCK_SAFE_MODE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1448e8416bad07da0b959a416f08a31f6fe2fd4"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ4MTE2Mg==", "bodyText": "We can make it something that resets but need to coordinate this between masters.\nRight now it's just a crude failsafe.", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r438481162", "createdAt": "2020-06-11T00:40:07Z", "author": {"login": "ggezer"}, "path": "core/server/common/src/main/java/alluxio/master/StateLockManager.java", "diffHunk": "@@ -0,0 +1,197 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master;\n+\n+import alluxio.collections.ConcurrentHashSet;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.exception.ExceptionMessage;\n+import alluxio.resource.LockResource;\n+import alluxio.util.ThreadFactoryUtils;\n+\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+/**\n+ * Provides graceful and interruptable locking protocol for taking the state lock.\n+ *\n+ * {@link #lockShared()} will be used by user RPCs and may throw {@link InterruptedException}\n+ * based on options passed to {@link #lockExclusive(StateLockOptions)}.\n+ *\n+ * {@link #lockExclusive(StateLockOptions)} will be used by metadata backups in order to\n+ * guarantee paused state during critical tasks.\n+ */\n+public class StateLockManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(StateLockManager.class);\n+\n+  /** The state-lock */\n+  private ReadWriteLock mStateLock = new ReentrantReadWriteLock(true);\n+\n+  /** The set of threads that are waiting for state-lock in shared mode. */\n+  private Set<Thread> mSharedWaiters;\n+  /** The set of threads that are holding the state-lock in shared mode. */\n+  private Set<Thread> mSharedHolders;\n+\n+  /** Scheduler that is used for interrupt-cycle. */\n+  private ScheduledExecutorService mScheduler;\n+  /** The future for the active interrupt cycle */\n+  private ScheduledFuture<?> mInterrupterFuture;\n+\n+  /** Whether state-lock manager is in safe-mode. */\n+  private boolean mSafeMode;\n+\n+  /**\n+   * Creates a new state-lock manager.\n+   */\n+  public StateLockManager() {\n+    mSharedWaiters = new ConcurrentHashSet<>();\n+    mSharedHolders = new ConcurrentHashSet<>();\n+\n+    mScheduler = Executors\n+        .newSingleThreadScheduledExecutor(ThreadFactoryUtils.build(\"state-lock-manager-%d\", true));\n+\n+    mSafeMode = ServerConfiguration.getBoolean(PropertyKey.MASTER_BACKUP_STATE_LOCK_SAFE_MODE);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ2MDIzNw=="}, "originalCommit": {"oid": "f1448e8416bad07da0b959a416f08a31f6fe2fd4"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczNTQ2NDc1OnYy", "diffSide": "RIGHT", "path": "core/server/common/src/main/java/alluxio/master/StateLockManager.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQyMjo0ODo1N1rOGixS0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQyMjo1Njo1N1rOGixc2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTExMjQwMQ==", "bodyText": "This could block for a long time, and thus block other RPCs (including heartbeats) for a long time?", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r439112401", "createdAt": "2020-06-11T22:48:57Z", "author": {"login": "gpang"}, "path": "core/server/common/src/main/java/alluxio/master/StateLockManager.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master;\n+\n+import alluxio.collections.ConcurrentHashSet;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.exception.ExceptionMessage;\n+import alluxio.resource.LockResource;\n+import alluxio.util.ThreadFactoryUtils;\n+\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+/**\n+ * Provides graceful and interruptable locking protocol for taking the state lock.\n+ *\n+ * {@link #lockShared()} will be used by user RPCs and may throw {@link InterruptedException}\n+ * based on options passed to {@link #lockExclusive(StateLockOptions)}.\n+ *\n+ * {@link #lockExclusive(StateLockOptions)} will be used by metadata backups in order to\n+ * guarantee paused state during critical tasks.\n+ */\n+public class StateLockManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(StateLockManager.class);\n+\n+  /** The state-lock */\n+  private ReadWriteLock mStateLock = new ReentrantReadWriteLock(true);\n+\n+  /** The set of threads that are waiting for or holding the state-lock in shared mode. */\n+  private Set<Thread> mSharedWaitersAndHolders;\n+\n+  /** Scheduler that is used for interrupt-cycle. */\n+  private ScheduledExecutorService mScheduler;\n+  /** The future for the active interrupt cycle */\n+  private ScheduledFuture<?> mInterrupterFuture;\n+\n+  /** Whether state-lock manager is in safe-mode. */\n+  private boolean mSafeMode;\n+\n+  /**\n+   * Creates a new state-lock manager.\n+   */\n+  public StateLockManager() {\n+    mSharedWaitersAndHolders = new ConcurrentHashSet<>();\n+\n+    mScheduler = Executors\n+        .newSingleThreadScheduledExecutor(ThreadFactoryUtils.build(\"state-lock-manager-%d\", true));\n+\n+    mSafeMode = ServerConfiguration.getBoolean(PropertyKey.MASTER_BACKUP_STATE_LOCK_SAFE_MODE);\n+  }\n+\n+  /**\n+   * Locks the state shared.\n+   *\n+   * Calling thread might be interrupted by this manager,\n+   * if it found to be waiting for the shared lock under when:\n+   *  - backup is exiting grace-cycle and entering the lock permanently\n+   *  - backup is in progress\n+   *\n+   * @return the lock resource\n+   * @throws InterruptedException\n+   */\n+  public LockResource lockShared() throws InterruptedException {\n+    // Do not allow taking shared lock during safe-mode.\n+    if (mSafeMode) {\n+      String safeModeMsg = String.format(\n+          \"Cannot acquire lock shared during backup safe-mode. \"\n+              + \"Please configure %s as 'false' in order to disable the backup safe-mode.\",\n+          PropertyKey.Name.MASTER_BACKUP_STATE_LOCK_SAFE_MODE);\n+      throw new IllegalStateException(safeModeMsg);\n+    }\n+    // Register thread for interrupt cycle.\n+    mSharedWaitersAndHolders.add(Thread.currentThread());\n+    // Grab the lock interruptibly.\n+    mStateLock.readLock().lockInterruptibly();\n+    // Return the resource.\n+    // Register an action to remove the thread from holders registry before releasing the lock.\n+    return new LockResource(mStateLock.readLock(), false, false, () -> {\n+      mSharedWaitersAndHolders.remove(Thread.currentThread());\n+    });\n+  }\n+\n+  /**\n+   * Locks the state exclusively.\n+   *\n+   * @param lockOptions exclusive lock options\n+   * @return the lock resource\n+   * @throws TimeoutException if locking times out\n+   * @throws InterruptedException if interrupting during locking\n+   */\n+  public LockResource lockExclusive(StateLockOptions lockOptions)\n+      throws TimeoutException, InterruptedException {\n+    // Run the grace cycle.\n+    boolean lockAcquired = false;\n+    if (lockOptions.waitGraceCycle()) {\n+      long deadlineMs = System.currentTimeMillis() + lockOptions.getGraceCycleTimeoutMs();\n+      while (System.currentTimeMillis() < deadlineMs) {\n+        if (mStateLock.writeLock().tryLock(lockOptions.getGraceCycleTryMs(), TimeUnit.MILLISECONDS)) {\n+          lockAcquired = true;\n+          break;\n+        } else {\n+          long remainingWaitMs = deadlineMs - System.currentTimeMillis();\n+          if (remainingWaitMs > 0) {\n+            Thread.sleep(Math.min(lockOptions.getGraceCycleSleepMs(), remainingWaitMs));\n+          }\n+        }\n+      }\n+    }\n+    if (lockAcquired) { // Lock was acquired within grace-cycle.\n+      scheduleInterruptCycle(lockOptions.getInterruptWaitersInternalMs());\n+    } else { // Lock couldn't be acquired by grace-cycle.\n+      if (!lockOptions.lockAfterGraceCycle()) {\n+        throw new TimeoutException(\n+                ExceptionMessage.STATE_LOCK_TIMED_OUT.getMessage(lockOptions.getGraceCycleTimeoutMs()));\n+      }\n+      if (lockOptions.interruptCycleAfterGraceCycle()) {\n+        // Schedule interrupt cycle before entering the lock because it might wait in the queue.\n+        scheduleInterruptCycle(lockOptions.getInterruptWaitersInternalMs());\n+      }\n+      // Own the lock.\n+      mStateLock.writeLock().lock();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0550f44dfad36238ad1210eee202232e1c02396"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTExNDk2OA==", "bodyText": "Yes but interrupt cycle is activated before this point.", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r439114968", "createdAt": "2020-06-11T22:56:57Z", "author": {"login": "ggezer"}, "path": "core/server/common/src/main/java/alluxio/master/StateLockManager.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master;\n+\n+import alluxio.collections.ConcurrentHashSet;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.exception.ExceptionMessage;\n+import alluxio.resource.LockResource;\n+import alluxio.util.ThreadFactoryUtils;\n+\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+/**\n+ * Provides graceful and interruptable locking protocol for taking the state lock.\n+ *\n+ * {@link #lockShared()} will be used by user RPCs and may throw {@link InterruptedException}\n+ * based on options passed to {@link #lockExclusive(StateLockOptions)}.\n+ *\n+ * {@link #lockExclusive(StateLockOptions)} will be used by metadata backups in order to\n+ * guarantee paused state during critical tasks.\n+ */\n+public class StateLockManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(StateLockManager.class);\n+\n+  /** The state-lock */\n+  private ReadWriteLock mStateLock = new ReentrantReadWriteLock(true);\n+\n+  /** The set of threads that are waiting for or holding the state-lock in shared mode. */\n+  private Set<Thread> mSharedWaitersAndHolders;\n+\n+  /** Scheduler that is used for interrupt-cycle. */\n+  private ScheduledExecutorService mScheduler;\n+  /** The future for the active interrupt cycle */\n+  private ScheduledFuture<?> mInterrupterFuture;\n+\n+  /** Whether state-lock manager is in safe-mode. */\n+  private boolean mSafeMode;\n+\n+  /**\n+   * Creates a new state-lock manager.\n+   */\n+  public StateLockManager() {\n+    mSharedWaitersAndHolders = new ConcurrentHashSet<>();\n+\n+    mScheduler = Executors\n+        .newSingleThreadScheduledExecutor(ThreadFactoryUtils.build(\"state-lock-manager-%d\", true));\n+\n+    mSafeMode = ServerConfiguration.getBoolean(PropertyKey.MASTER_BACKUP_STATE_LOCK_SAFE_MODE);\n+  }\n+\n+  /**\n+   * Locks the state shared.\n+   *\n+   * Calling thread might be interrupted by this manager,\n+   * if it found to be waiting for the shared lock under when:\n+   *  - backup is exiting grace-cycle and entering the lock permanently\n+   *  - backup is in progress\n+   *\n+   * @return the lock resource\n+   * @throws InterruptedException\n+   */\n+  public LockResource lockShared() throws InterruptedException {\n+    // Do not allow taking shared lock during safe-mode.\n+    if (mSafeMode) {\n+      String safeModeMsg = String.format(\n+          \"Cannot acquire lock shared during backup safe-mode. \"\n+              + \"Please configure %s as 'false' in order to disable the backup safe-mode.\",\n+          PropertyKey.Name.MASTER_BACKUP_STATE_LOCK_SAFE_MODE);\n+      throw new IllegalStateException(safeModeMsg);\n+    }\n+    // Register thread for interrupt cycle.\n+    mSharedWaitersAndHolders.add(Thread.currentThread());\n+    // Grab the lock interruptibly.\n+    mStateLock.readLock().lockInterruptibly();\n+    // Return the resource.\n+    // Register an action to remove the thread from holders registry before releasing the lock.\n+    return new LockResource(mStateLock.readLock(), false, false, () -> {\n+      mSharedWaitersAndHolders.remove(Thread.currentThread());\n+    });\n+  }\n+\n+  /**\n+   * Locks the state exclusively.\n+   *\n+   * @param lockOptions exclusive lock options\n+   * @return the lock resource\n+   * @throws TimeoutException if locking times out\n+   * @throws InterruptedException if interrupting during locking\n+   */\n+  public LockResource lockExclusive(StateLockOptions lockOptions)\n+      throws TimeoutException, InterruptedException {\n+    // Run the grace cycle.\n+    boolean lockAcquired = false;\n+    if (lockOptions.waitGraceCycle()) {\n+      long deadlineMs = System.currentTimeMillis() + lockOptions.getGraceCycleTimeoutMs();\n+      while (System.currentTimeMillis() < deadlineMs) {\n+        if (mStateLock.writeLock().tryLock(lockOptions.getGraceCycleTryMs(), TimeUnit.MILLISECONDS)) {\n+          lockAcquired = true;\n+          break;\n+        } else {\n+          long remainingWaitMs = deadlineMs - System.currentTimeMillis();\n+          if (remainingWaitMs > 0) {\n+            Thread.sleep(Math.min(lockOptions.getGraceCycleSleepMs(), remainingWaitMs));\n+          }\n+        }\n+      }\n+    }\n+    if (lockAcquired) { // Lock was acquired within grace-cycle.\n+      scheduleInterruptCycle(lockOptions.getInterruptWaitersInternalMs());\n+    } else { // Lock couldn't be acquired by grace-cycle.\n+      if (!lockOptions.lockAfterGraceCycle()) {\n+        throw new TimeoutException(\n+                ExceptionMessage.STATE_LOCK_TIMED_OUT.getMessage(lockOptions.getGraceCycleTimeoutMs()));\n+      }\n+      if (lockOptions.interruptCycleAfterGraceCycle()) {\n+        // Schedule interrupt cycle before entering the lock because it might wait in the queue.\n+        scheduleInterruptCycle(lockOptions.getInterruptWaitersInternalMs());\n+      }\n+      // Own the lock.\n+      mStateLock.writeLock().lock();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTExMjQwMQ=="}, "originalCommit": {"oid": "b0550f44dfad36238ad1210eee202232e1c02396"}, "originalPosition": 141}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczNTQ2ODUwOnYy", "diffSide": "RIGHT", "path": "core/server/common/src/main/java/alluxio/master/StateLockManager.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQyMjo1MDo0NVrOGixVHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxODo0NDowMlrOGjOONw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTExMjk4OQ==", "bodyText": "Is there any danger that this mInterrupterFuture points to a different future than the one that was started?", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r439112989", "createdAt": "2020-06-11T22:50:45Z", "author": {"login": "gpang"}, "path": "core/server/common/src/main/java/alluxio/master/StateLockManager.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master;\n+\n+import alluxio.collections.ConcurrentHashSet;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.exception.ExceptionMessage;\n+import alluxio.resource.LockResource;\n+import alluxio.util.ThreadFactoryUtils;\n+\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+/**\n+ * Provides graceful and interruptable locking protocol for taking the state lock.\n+ *\n+ * {@link #lockShared()} will be used by user RPCs and may throw {@link InterruptedException}\n+ * based on options passed to {@link #lockExclusive(StateLockOptions)}.\n+ *\n+ * {@link #lockExclusive(StateLockOptions)} will be used by metadata backups in order to\n+ * guarantee paused state during critical tasks.\n+ */\n+public class StateLockManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(StateLockManager.class);\n+\n+  /** The state-lock */\n+  private ReadWriteLock mStateLock = new ReentrantReadWriteLock(true);\n+\n+  /** The set of threads that are waiting for or holding the state-lock in shared mode. */\n+  private Set<Thread> mSharedWaitersAndHolders;\n+\n+  /** Scheduler that is used for interrupt-cycle. */\n+  private ScheduledExecutorService mScheduler;\n+  /** The future for the active interrupt cycle */\n+  private ScheduledFuture<?> mInterrupterFuture;\n+\n+  /** Whether state-lock manager is in safe-mode. */\n+  private boolean mSafeMode;\n+\n+  /**\n+   * Creates a new state-lock manager.\n+   */\n+  public StateLockManager() {\n+    mSharedWaitersAndHolders = new ConcurrentHashSet<>();\n+\n+    mScheduler = Executors\n+        .newSingleThreadScheduledExecutor(ThreadFactoryUtils.build(\"state-lock-manager-%d\", true));\n+\n+    mSafeMode = ServerConfiguration.getBoolean(PropertyKey.MASTER_BACKUP_STATE_LOCK_SAFE_MODE);\n+  }\n+\n+  /**\n+   * Locks the state shared.\n+   *\n+   * Calling thread might be interrupted by this manager,\n+   * if it found to be waiting for the shared lock under when:\n+   *  - backup is exiting grace-cycle and entering the lock permanently\n+   *  - backup is in progress\n+   *\n+   * @return the lock resource\n+   * @throws InterruptedException\n+   */\n+  public LockResource lockShared() throws InterruptedException {\n+    // Do not allow taking shared lock during safe-mode.\n+    if (mSafeMode) {\n+      String safeModeMsg = String.format(\n+          \"Cannot acquire lock shared during backup safe-mode. \"\n+              + \"Please configure %s as 'false' in order to disable the backup safe-mode.\",\n+          PropertyKey.Name.MASTER_BACKUP_STATE_LOCK_SAFE_MODE);\n+      throw new IllegalStateException(safeModeMsg);\n+    }\n+    // Register thread for interrupt cycle.\n+    mSharedWaitersAndHolders.add(Thread.currentThread());\n+    // Grab the lock interruptibly.\n+    mStateLock.readLock().lockInterruptibly();\n+    // Return the resource.\n+    // Register an action to remove the thread from holders registry before releasing the lock.\n+    return new LockResource(mStateLock.readLock(), false, false, () -> {\n+      mSharedWaitersAndHolders.remove(Thread.currentThread());\n+    });\n+  }\n+\n+  /**\n+   * Locks the state exclusively.\n+   *\n+   * @param lockOptions exclusive lock options\n+   * @return the lock resource\n+   * @throws TimeoutException if locking times out\n+   * @throws InterruptedException if interrupting during locking\n+   */\n+  public LockResource lockExclusive(StateLockOptions lockOptions)\n+      throws TimeoutException, InterruptedException {\n+    // Run the grace cycle.\n+    boolean lockAcquired = false;\n+    if (lockOptions.waitGraceCycle()) {\n+      long deadlineMs = System.currentTimeMillis() + lockOptions.getGraceCycleTimeoutMs();\n+      while (System.currentTimeMillis() < deadlineMs) {\n+        if (mStateLock.writeLock().tryLock(lockOptions.getGraceCycleTryMs(), TimeUnit.MILLISECONDS)) {\n+          lockAcquired = true;\n+          break;\n+        } else {\n+          long remainingWaitMs = deadlineMs - System.currentTimeMillis();\n+          if (remainingWaitMs > 0) {\n+            Thread.sleep(Math.min(lockOptions.getGraceCycleSleepMs(), remainingWaitMs));\n+          }\n+        }\n+      }\n+    }\n+    if (lockAcquired) { // Lock was acquired within grace-cycle.\n+      scheduleInterruptCycle(lockOptions.getInterruptWaitersInternalMs());\n+    } else { // Lock couldn't be acquired by grace-cycle.\n+      if (!lockOptions.lockAfterGraceCycle()) {\n+        throw new TimeoutException(\n+                ExceptionMessage.STATE_LOCK_TIMED_OUT.getMessage(lockOptions.getGraceCycleTimeoutMs()));\n+      }\n+      if (lockOptions.interruptCycleAfterGraceCycle()) {\n+        // Schedule interrupt cycle before entering the lock because it might wait in the queue.\n+        scheduleInterruptCycle(lockOptions.getInterruptWaitersInternalMs());\n+      }\n+      // Own the lock.\n+      mStateLock.writeLock().lock();\n+    }\n+\n+    // We have the lock, wrap it and return.\n+    // Register an action for cancelling the interrupt cycle before releasing the lock.\n+    return new LockResource(mStateLock.writeLock(), false, false, () -> {\n+      // Before releasing the write-lock, deactivate interrupter if active.\n+      if (mInterrupterFuture != null && !mInterrupterFuture.isDone()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0550f44dfad36238ad1210eee202232e1c02396"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTExNTE2OQ==", "bodyText": "It's not possible due to exclusive locking.", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r439115169", "createdAt": "2020-06-11T22:57:36Z", "author": {"login": "ggezer"}, "path": "core/server/common/src/main/java/alluxio/master/StateLockManager.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master;\n+\n+import alluxio.collections.ConcurrentHashSet;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.exception.ExceptionMessage;\n+import alluxio.resource.LockResource;\n+import alluxio.util.ThreadFactoryUtils;\n+\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+/**\n+ * Provides graceful and interruptable locking protocol for taking the state lock.\n+ *\n+ * {@link #lockShared()} will be used by user RPCs and may throw {@link InterruptedException}\n+ * based on options passed to {@link #lockExclusive(StateLockOptions)}.\n+ *\n+ * {@link #lockExclusive(StateLockOptions)} will be used by metadata backups in order to\n+ * guarantee paused state during critical tasks.\n+ */\n+public class StateLockManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(StateLockManager.class);\n+\n+  /** The state-lock */\n+  private ReadWriteLock mStateLock = new ReentrantReadWriteLock(true);\n+\n+  /** The set of threads that are waiting for or holding the state-lock in shared mode. */\n+  private Set<Thread> mSharedWaitersAndHolders;\n+\n+  /** Scheduler that is used for interrupt-cycle. */\n+  private ScheduledExecutorService mScheduler;\n+  /** The future for the active interrupt cycle */\n+  private ScheduledFuture<?> mInterrupterFuture;\n+\n+  /** Whether state-lock manager is in safe-mode. */\n+  private boolean mSafeMode;\n+\n+  /**\n+   * Creates a new state-lock manager.\n+   */\n+  public StateLockManager() {\n+    mSharedWaitersAndHolders = new ConcurrentHashSet<>();\n+\n+    mScheduler = Executors\n+        .newSingleThreadScheduledExecutor(ThreadFactoryUtils.build(\"state-lock-manager-%d\", true));\n+\n+    mSafeMode = ServerConfiguration.getBoolean(PropertyKey.MASTER_BACKUP_STATE_LOCK_SAFE_MODE);\n+  }\n+\n+  /**\n+   * Locks the state shared.\n+   *\n+   * Calling thread might be interrupted by this manager,\n+   * if it found to be waiting for the shared lock under when:\n+   *  - backup is exiting grace-cycle and entering the lock permanently\n+   *  - backup is in progress\n+   *\n+   * @return the lock resource\n+   * @throws InterruptedException\n+   */\n+  public LockResource lockShared() throws InterruptedException {\n+    // Do not allow taking shared lock during safe-mode.\n+    if (mSafeMode) {\n+      String safeModeMsg = String.format(\n+          \"Cannot acquire lock shared during backup safe-mode. \"\n+              + \"Please configure %s as 'false' in order to disable the backup safe-mode.\",\n+          PropertyKey.Name.MASTER_BACKUP_STATE_LOCK_SAFE_MODE);\n+      throw new IllegalStateException(safeModeMsg);\n+    }\n+    // Register thread for interrupt cycle.\n+    mSharedWaitersAndHolders.add(Thread.currentThread());\n+    // Grab the lock interruptibly.\n+    mStateLock.readLock().lockInterruptibly();\n+    // Return the resource.\n+    // Register an action to remove the thread from holders registry before releasing the lock.\n+    return new LockResource(mStateLock.readLock(), false, false, () -> {\n+      mSharedWaitersAndHolders.remove(Thread.currentThread());\n+    });\n+  }\n+\n+  /**\n+   * Locks the state exclusively.\n+   *\n+   * @param lockOptions exclusive lock options\n+   * @return the lock resource\n+   * @throws TimeoutException if locking times out\n+   * @throws InterruptedException if interrupting during locking\n+   */\n+  public LockResource lockExclusive(StateLockOptions lockOptions)\n+      throws TimeoutException, InterruptedException {\n+    // Run the grace cycle.\n+    boolean lockAcquired = false;\n+    if (lockOptions.waitGraceCycle()) {\n+      long deadlineMs = System.currentTimeMillis() + lockOptions.getGraceCycleTimeoutMs();\n+      while (System.currentTimeMillis() < deadlineMs) {\n+        if (mStateLock.writeLock().tryLock(lockOptions.getGraceCycleTryMs(), TimeUnit.MILLISECONDS)) {\n+          lockAcquired = true;\n+          break;\n+        } else {\n+          long remainingWaitMs = deadlineMs - System.currentTimeMillis();\n+          if (remainingWaitMs > 0) {\n+            Thread.sleep(Math.min(lockOptions.getGraceCycleSleepMs(), remainingWaitMs));\n+          }\n+        }\n+      }\n+    }\n+    if (lockAcquired) { // Lock was acquired within grace-cycle.\n+      scheduleInterruptCycle(lockOptions.getInterruptWaitersInternalMs());\n+    } else { // Lock couldn't be acquired by grace-cycle.\n+      if (!lockOptions.lockAfterGraceCycle()) {\n+        throw new TimeoutException(\n+                ExceptionMessage.STATE_LOCK_TIMED_OUT.getMessage(lockOptions.getGraceCycleTimeoutMs()));\n+      }\n+      if (lockOptions.interruptCycleAfterGraceCycle()) {\n+        // Schedule interrupt cycle before entering the lock because it might wait in the queue.\n+        scheduleInterruptCycle(lockOptions.getInterruptWaitersInternalMs());\n+      }\n+      // Own the lock.\n+      mStateLock.writeLock().lock();\n+    }\n+\n+    // We have the lock, wrap it and return.\n+    // Register an action for cancelling the interrupt cycle before releasing the lock.\n+    return new LockResource(mStateLock.writeLock(), false, false, () -> {\n+      // Before releasing the write-lock, deactivate interrupter if active.\n+      if (mInterrupterFuture != null && !mInterrupterFuture.isDone()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTExMjk4OQ=="}, "originalCommit": {"oid": "b0550f44dfad36238ad1210eee202232e1c02396"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTEyNjQ2Mg==", "bodyText": "Need to support multiple exclusive lockers though. This PR should cover that. To do that properly, the interrupt cycle should be owned by the state-lock-manager.", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r439126462", "createdAt": "2020-06-11T23:35:59Z", "author": {"login": "ggezer"}, "path": "core/server/common/src/main/java/alluxio/master/StateLockManager.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master;\n+\n+import alluxio.collections.ConcurrentHashSet;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.exception.ExceptionMessage;\n+import alluxio.resource.LockResource;\n+import alluxio.util.ThreadFactoryUtils;\n+\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+/**\n+ * Provides graceful and interruptable locking protocol for taking the state lock.\n+ *\n+ * {@link #lockShared()} will be used by user RPCs and may throw {@link InterruptedException}\n+ * based on options passed to {@link #lockExclusive(StateLockOptions)}.\n+ *\n+ * {@link #lockExclusive(StateLockOptions)} will be used by metadata backups in order to\n+ * guarantee paused state during critical tasks.\n+ */\n+public class StateLockManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(StateLockManager.class);\n+\n+  /** The state-lock */\n+  private ReadWriteLock mStateLock = new ReentrantReadWriteLock(true);\n+\n+  /** The set of threads that are waiting for or holding the state-lock in shared mode. */\n+  private Set<Thread> mSharedWaitersAndHolders;\n+\n+  /** Scheduler that is used for interrupt-cycle. */\n+  private ScheduledExecutorService mScheduler;\n+  /** The future for the active interrupt cycle */\n+  private ScheduledFuture<?> mInterrupterFuture;\n+\n+  /** Whether state-lock manager is in safe-mode. */\n+  private boolean mSafeMode;\n+\n+  /**\n+   * Creates a new state-lock manager.\n+   */\n+  public StateLockManager() {\n+    mSharedWaitersAndHolders = new ConcurrentHashSet<>();\n+\n+    mScheduler = Executors\n+        .newSingleThreadScheduledExecutor(ThreadFactoryUtils.build(\"state-lock-manager-%d\", true));\n+\n+    mSafeMode = ServerConfiguration.getBoolean(PropertyKey.MASTER_BACKUP_STATE_LOCK_SAFE_MODE);\n+  }\n+\n+  /**\n+   * Locks the state shared.\n+   *\n+   * Calling thread might be interrupted by this manager,\n+   * if it found to be waiting for the shared lock under when:\n+   *  - backup is exiting grace-cycle and entering the lock permanently\n+   *  - backup is in progress\n+   *\n+   * @return the lock resource\n+   * @throws InterruptedException\n+   */\n+  public LockResource lockShared() throws InterruptedException {\n+    // Do not allow taking shared lock during safe-mode.\n+    if (mSafeMode) {\n+      String safeModeMsg = String.format(\n+          \"Cannot acquire lock shared during backup safe-mode. \"\n+              + \"Please configure %s as 'false' in order to disable the backup safe-mode.\",\n+          PropertyKey.Name.MASTER_BACKUP_STATE_LOCK_SAFE_MODE);\n+      throw new IllegalStateException(safeModeMsg);\n+    }\n+    // Register thread for interrupt cycle.\n+    mSharedWaitersAndHolders.add(Thread.currentThread());\n+    // Grab the lock interruptibly.\n+    mStateLock.readLock().lockInterruptibly();\n+    // Return the resource.\n+    // Register an action to remove the thread from holders registry before releasing the lock.\n+    return new LockResource(mStateLock.readLock(), false, false, () -> {\n+      mSharedWaitersAndHolders.remove(Thread.currentThread());\n+    });\n+  }\n+\n+  /**\n+   * Locks the state exclusively.\n+   *\n+   * @param lockOptions exclusive lock options\n+   * @return the lock resource\n+   * @throws TimeoutException if locking times out\n+   * @throws InterruptedException if interrupting during locking\n+   */\n+  public LockResource lockExclusive(StateLockOptions lockOptions)\n+      throws TimeoutException, InterruptedException {\n+    // Run the grace cycle.\n+    boolean lockAcquired = false;\n+    if (lockOptions.waitGraceCycle()) {\n+      long deadlineMs = System.currentTimeMillis() + lockOptions.getGraceCycleTimeoutMs();\n+      while (System.currentTimeMillis() < deadlineMs) {\n+        if (mStateLock.writeLock().tryLock(lockOptions.getGraceCycleTryMs(), TimeUnit.MILLISECONDS)) {\n+          lockAcquired = true;\n+          break;\n+        } else {\n+          long remainingWaitMs = deadlineMs - System.currentTimeMillis();\n+          if (remainingWaitMs > 0) {\n+            Thread.sleep(Math.min(lockOptions.getGraceCycleSleepMs(), remainingWaitMs));\n+          }\n+        }\n+      }\n+    }\n+    if (lockAcquired) { // Lock was acquired within grace-cycle.\n+      scheduleInterruptCycle(lockOptions.getInterruptWaitersInternalMs());\n+    } else { // Lock couldn't be acquired by grace-cycle.\n+      if (!lockOptions.lockAfterGraceCycle()) {\n+        throw new TimeoutException(\n+                ExceptionMessage.STATE_LOCK_TIMED_OUT.getMessage(lockOptions.getGraceCycleTimeoutMs()));\n+      }\n+      if (lockOptions.interruptCycleAfterGraceCycle()) {\n+        // Schedule interrupt cycle before entering the lock because it might wait in the queue.\n+        scheduleInterruptCycle(lockOptions.getInterruptWaitersInternalMs());\n+      }\n+      // Own the lock.\n+      mStateLock.writeLock().lock();\n+    }\n+\n+    // We have the lock, wrap it and return.\n+    // Register an action for cancelling the interrupt cycle before releasing the lock.\n+    return new LockResource(mStateLock.writeLock(), false, false, () -> {\n+      // Before releasing the write-lock, deactivate interrupter if active.\n+      if (mInterrupterFuture != null && !mInterrupterFuture.isDone()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTExMjk4OQ=="}, "originalCommit": {"oid": "b0550f44dfad36238ad1210eee202232e1c02396"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU4NjM1OQ==", "bodyText": "This is fixed now.", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r439586359", "createdAt": "2020-06-12T18:44:02Z", "author": {"login": "ggezer"}, "path": "core/server/common/src/main/java/alluxio/master/StateLockManager.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master;\n+\n+import alluxio.collections.ConcurrentHashSet;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.exception.ExceptionMessage;\n+import alluxio.resource.LockResource;\n+import alluxio.util.ThreadFactoryUtils;\n+\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+/**\n+ * Provides graceful and interruptable locking protocol for taking the state lock.\n+ *\n+ * {@link #lockShared()} will be used by user RPCs and may throw {@link InterruptedException}\n+ * based on options passed to {@link #lockExclusive(StateLockOptions)}.\n+ *\n+ * {@link #lockExclusive(StateLockOptions)} will be used by metadata backups in order to\n+ * guarantee paused state during critical tasks.\n+ */\n+public class StateLockManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(StateLockManager.class);\n+\n+  /** The state-lock */\n+  private ReadWriteLock mStateLock = new ReentrantReadWriteLock(true);\n+\n+  /** The set of threads that are waiting for or holding the state-lock in shared mode. */\n+  private Set<Thread> mSharedWaitersAndHolders;\n+\n+  /** Scheduler that is used for interrupt-cycle. */\n+  private ScheduledExecutorService mScheduler;\n+  /** The future for the active interrupt cycle */\n+  private ScheduledFuture<?> mInterrupterFuture;\n+\n+  /** Whether state-lock manager is in safe-mode. */\n+  private boolean mSafeMode;\n+\n+  /**\n+   * Creates a new state-lock manager.\n+   */\n+  public StateLockManager() {\n+    mSharedWaitersAndHolders = new ConcurrentHashSet<>();\n+\n+    mScheduler = Executors\n+        .newSingleThreadScheduledExecutor(ThreadFactoryUtils.build(\"state-lock-manager-%d\", true));\n+\n+    mSafeMode = ServerConfiguration.getBoolean(PropertyKey.MASTER_BACKUP_STATE_LOCK_SAFE_MODE);\n+  }\n+\n+  /**\n+   * Locks the state shared.\n+   *\n+   * Calling thread might be interrupted by this manager,\n+   * if it found to be waiting for the shared lock under when:\n+   *  - backup is exiting grace-cycle and entering the lock permanently\n+   *  - backup is in progress\n+   *\n+   * @return the lock resource\n+   * @throws InterruptedException\n+   */\n+  public LockResource lockShared() throws InterruptedException {\n+    // Do not allow taking shared lock during safe-mode.\n+    if (mSafeMode) {\n+      String safeModeMsg = String.format(\n+          \"Cannot acquire lock shared during backup safe-mode. \"\n+              + \"Please configure %s as 'false' in order to disable the backup safe-mode.\",\n+          PropertyKey.Name.MASTER_BACKUP_STATE_LOCK_SAFE_MODE);\n+      throw new IllegalStateException(safeModeMsg);\n+    }\n+    // Register thread for interrupt cycle.\n+    mSharedWaitersAndHolders.add(Thread.currentThread());\n+    // Grab the lock interruptibly.\n+    mStateLock.readLock().lockInterruptibly();\n+    // Return the resource.\n+    // Register an action to remove the thread from holders registry before releasing the lock.\n+    return new LockResource(mStateLock.readLock(), false, false, () -> {\n+      mSharedWaitersAndHolders.remove(Thread.currentThread());\n+    });\n+  }\n+\n+  /**\n+   * Locks the state exclusively.\n+   *\n+   * @param lockOptions exclusive lock options\n+   * @return the lock resource\n+   * @throws TimeoutException if locking times out\n+   * @throws InterruptedException if interrupting during locking\n+   */\n+  public LockResource lockExclusive(StateLockOptions lockOptions)\n+      throws TimeoutException, InterruptedException {\n+    // Run the grace cycle.\n+    boolean lockAcquired = false;\n+    if (lockOptions.waitGraceCycle()) {\n+      long deadlineMs = System.currentTimeMillis() + lockOptions.getGraceCycleTimeoutMs();\n+      while (System.currentTimeMillis() < deadlineMs) {\n+        if (mStateLock.writeLock().tryLock(lockOptions.getGraceCycleTryMs(), TimeUnit.MILLISECONDS)) {\n+          lockAcquired = true;\n+          break;\n+        } else {\n+          long remainingWaitMs = deadlineMs - System.currentTimeMillis();\n+          if (remainingWaitMs > 0) {\n+            Thread.sleep(Math.min(lockOptions.getGraceCycleSleepMs(), remainingWaitMs));\n+          }\n+        }\n+      }\n+    }\n+    if (lockAcquired) { // Lock was acquired within grace-cycle.\n+      scheduleInterruptCycle(lockOptions.getInterruptWaitersInternalMs());\n+    } else { // Lock couldn't be acquired by grace-cycle.\n+      if (!lockOptions.lockAfterGraceCycle()) {\n+        throw new TimeoutException(\n+                ExceptionMessage.STATE_LOCK_TIMED_OUT.getMessage(lockOptions.getGraceCycleTimeoutMs()));\n+      }\n+      if (lockOptions.interruptCycleAfterGraceCycle()) {\n+        // Schedule interrupt cycle before entering the lock because it might wait in the queue.\n+        scheduleInterruptCycle(lockOptions.getInterruptWaitersInternalMs());\n+      }\n+      // Own the lock.\n+      mStateLock.writeLock().lock();\n+    }\n+\n+    // We have the lock, wrap it and return.\n+    // Register an action for cancelling the interrupt cycle before releasing the lock.\n+    return new LockResource(mStateLock.writeLock(), false, false, () -> {\n+      // Before releasing the write-lock, deactivate interrupter if active.\n+      if (mInterrupterFuture != null && !mInterrupterFuture.isDone()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTExMjk4OQ=="}, "originalCommit": {"oid": "b0550f44dfad36238ad1210eee202232e1c02396"}, "originalPosition": 148}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczNTQ3MDI2OnYy", "diffSide": "RIGHT", "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQyMjo1MTozNlrOGixWHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQyMjowMzo1MlrOGjSuSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTExMzI0Ng==", "bodyText": "I don't know how this should be used by users.", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r439113246", "createdAt": "2020-06-11T22:51:36Z", "author": {"login": "gpang"}, "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "diffHunk": "@@ -1296,6 +1296,13 @@ public String toString() {\n           .setConsistencyCheckLevel(ConsistencyCheckLevel.IGNORE)\n           .setScope(Scope.MASTER)\n           .build();\n+  public static final PropertyKey MASTER_BACKUP_STATE_LOCK_SAFE_MODE =\n+      new Builder(Name.MASTER_BACKUP_STATE_LOCK_SAFE_MODE)\n+          .setDefaultValue(false)\n+          .setDescription(\"Ignores client state-lock requests for backup to always take the lock.\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b0550f44dfad36238ad1210eee202232e1c02396"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTExNTU4NA==", "bodyText": "The typical scenario is when you can't take backups (shell/daily) due to a never-ending RPC. Restarting Alluxio master with this will guarantee that backup can take the lock and continue.", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r439115584", "createdAt": "2020-06-11T22:59:00Z", "author": {"login": "ggezer"}, "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "diffHunk": "@@ -1296,6 +1296,13 @@ public String toString() {\n           .setConsistencyCheckLevel(ConsistencyCheckLevel.IGNORE)\n           .setScope(Scope.MASTER)\n           .build();\n+  public static final PropertyKey MASTER_BACKUP_STATE_LOCK_SAFE_MODE =\n+      new Builder(Name.MASTER_BACKUP_STATE_LOCK_SAFE_MODE)\n+          .setDefaultValue(false)\n+          .setDescription(\"Ignores client state-lock requests for backup to always take the lock.\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTExMzI0Ng=="}, "originalCommit": {"oid": "b0550f44dfad36238ad1210eee202232e1c02396"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUxNjMyMQ==", "bodyText": "@ggezer\nYes, but it will never service RPCs. That will make this master unusable, right? Why would a user want an unusable master?", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r439516321", "createdAt": "2020-06-12T16:16:49Z", "author": {"login": "gpang"}, "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "diffHunk": "@@ -1296,6 +1296,13 @@ public String toString() {\n           .setConsistencyCheckLevel(ConsistencyCheckLevel.IGNORE)\n           .setScope(Scope.MASTER)\n           .build();\n+  public static final PropertyKey MASTER_BACKUP_STATE_LOCK_SAFE_MODE =\n+      new Builder(Name.MASTER_BACKUP_STATE_LOCK_SAFE_MODE)\n+          .setDefaultValue(false)\n+          .setDescription(\"Ignores client state-lock requests for backup to always take the lock.\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTExMzI0Ng=="}, "originalCommit": {"oid": "b0550f44dfad36238ad1210eee202232e1c02396"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU3OTQ2MA==", "bodyText": "The point is not \"wanting an unusable master\", It's \"wanting a backup\".\n@calvinjia @ns1123 WDYT about this mode?", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r439579460", "createdAt": "2020-06-12T18:28:23Z", "author": {"login": "ggezer"}, "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "diffHunk": "@@ -1296,6 +1296,13 @@ public String toString() {\n           .setConsistencyCheckLevel(ConsistencyCheckLevel.IGNORE)\n           .setScope(Scope.MASTER)\n           .build();\n+  public static final PropertyKey MASTER_BACKUP_STATE_LOCK_SAFE_MODE =\n+      new Builder(Name.MASTER_BACKUP_STATE_LOCK_SAFE_MODE)\n+          .setDefaultValue(false)\n+          .setDescription(\"Ignores client state-lock requests for backup to always take the lock.\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTExMzI0Ng=="}, "originalCommit": {"oid": "b0550f44dfad36238ad1210eee202232e1c02396"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU5MDg5MQ==", "bodyText": "I'd rather instead of being a server side property, that this is an option on the fsadmin backup command. That way a backup can be forced by an admin in a dire situation.", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r439590891", "createdAt": "2020-06-12T18:54:12Z", "author": {"login": "ns1123"}, "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "diffHunk": "@@ -1296,6 +1296,13 @@ public String toString() {\n           .setConsistencyCheckLevel(ConsistencyCheckLevel.IGNORE)\n           .setScope(Scope.MASTER)\n           .build();\n+  public static final PropertyKey MASTER_BACKUP_STATE_LOCK_SAFE_MODE =\n+      new Builder(Name.MASTER_BACKUP_STATE_LOCK_SAFE_MODE)\n+          .setDefaultValue(false)\n+          .setDescription(\"Ignores client state-lock requests for backup to always take the lock.\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTExMzI0Ng=="}, "originalCommit": {"oid": "b0550f44dfad36238ad1210eee202232e1c02396"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY2MDEwNQ==", "bodyText": "@ns1123 This PR already makes the changes for doing the best we can in taking the backup. This particular property is introducing a new maintenance mode under which backup will be \"guaranteed\".", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r439660105", "createdAt": "2020-06-12T22:03:52Z", "author": {"login": "ggezer"}, "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "diffHunk": "@@ -1296,6 +1296,13 @@ public String toString() {\n           .setConsistencyCheckLevel(ConsistencyCheckLevel.IGNORE)\n           .setScope(Scope.MASTER)\n           .build();\n+  public static final PropertyKey MASTER_BACKUP_STATE_LOCK_SAFE_MODE =\n+      new Builder(Name.MASTER_BACKUP_STATE_LOCK_SAFE_MODE)\n+          .setDefaultValue(false)\n+          .setDescription(\"Ignores client state-lock requests for backup to always take the lock.\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTExMzI0Ng=="}, "originalCommit": {"oid": "b0550f44dfad36238ad1210eee202232e1c02396"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0NDE4Mjk0OnYy", "diffSide": "RIGHT", "path": "core/server/common/src/main/java/alluxio/master/StateLockManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQyMTozODo0OVrOGkDqYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxNzo1MDoxMlrOGkmlqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ2MTkyMQ==", "bodyText": "Will it be easy to search for log message, where will this be logged?", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r440461921", "createdAt": "2020-06-15T21:38:49Z", "author": {"login": "calvinjia"}, "path": "core/server/common/src/main/java/alluxio/master/StateLockManager.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master;\n+\n+import alluxio.collections.ConcurrentHashSet;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.exception.ExceptionMessage;\n+import alluxio.resource.LockResource;\n+import alluxio.util.ThreadFactoryUtils;\n+\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+/**\n+ * Provides graceful and interruptable locking protocol for taking the state lock.\n+ *\n+ * {@link #lockShared()} will be used by user RPCs and may throw {@link InterruptedException}\n+ * based on options passed to {@link #lockExclusive(StateLockOptions)}.\n+ *\n+ * {@link #lockExclusive(StateLockOptions)} will be used by metadata backups in order to\n+ * guarantee paused state during critical tasks.\n+ */\n+public class StateLockManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(StateLockManager.class);\n+\n+  /** The state-lock. */\n+  private ReadWriteLock mStateLock = new ReentrantReadWriteLock(true);\n+\n+  /** The set of threads that are waiting for or holding the state-lock in shared mode. */\n+  private Set<Thread> mSharedWaitersAndHolders;\n+  /** Scheduler that is used for interrupt-cycle. */\n+  private ScheduledExecutorService mScheduler;\n+\n+  /** Whether exclusive locking will trigger interrupt-cycle. */\n+  private boolean mInterruptCycleEnabled;\n+  /** Interval at which threads around shared-lock will be interrupted during interrupt-cycle. */\n+  private long mInterruptCycleInterval;\n+  /** Used to synchronize execution/termination of interrupt-cycle. */\n+  private Lock mInterruptCycleLock = new ReentrantLock(true);\n+  /** How many active exclusive locking attempts. */\n+  private volatile long mInterruptCycleRefCount = 0;\n+  /** The future for the active interrupt cycle. */\n+  private ScheduledFuture<?> mInterrupterFuture;\n+\n+  /** This is the deadline for forcing the lock. */\n+  private long mForcedDurationMs;\n+\n+  // TODO(ggezer): Make it bound to a process start/stop cycle.\n+  /** Shared locking requests will fail until this time. */\n+  private long mExclusiveOnlyDeadlineMs = -1;\n+\n+  /**\n+   * Creates a new state-lock manager.\n+   */\n+  public StateLockManager() {\n+    mSharedWaitersAndHolders = new ConcurrentHashSet<>();\n+    // Init members.\n+    mScheduler = Executors\n+        .newSingleThreadScheduledExecutor(ThreadFactoryUtils.build(\"state-lock-manager-%d\", true));\n+    // Read properties.\n+    mInterruptCycleEnabled = ServerConfiguration\n+        .getBoolean(PropertyKey.MASTER_BACKUP_STATE_LOCK_INTERRUPT_CYCLE_ENABLED);\n+    mInterruptCycleInterval =\n+        ServerConfiguration.getMs(PropertyKey.MASTER_BACKUP_STATE_LOCK_INTERRUPT_CYCLE_INTERVAL);\n+    mForcedDurationMs =\n+        ServerConfiguration.getMs(PropertyKey.MASTER_BACKUP_STATE_LOCK_FORCED_DURATION);\n+    // Validate properties.\n+    Preconditions.checkArgument(mInterruptCycleInterval > 0,\n+        \"Interrupt-cycle interval should be greater than 0.\");\n+  }\n+\n+  /**\n+   * This is called by owning process in order to signal that\n+   * the state is read completely and masters are started.\n+   *\n+   * This triggers the beginning of exclusive-only maintenance mode for the state-lock.\n+   * Note: Calling it multiple times does not reset the maintenance window.\n+   */\n+  public void mastersStartedCallback() {\n+    if (mExclusiveOnlyDeadlineMs == -1) {\n+      mExclusiveOnlyDeadlineMs = System.currentTimeMillis()\n+          + ServerConfiguration.getMs(PropertyKey.MASTER_BACKUP_STATE_LOCK_EXCLUSIVE_DURATION);\n+    }\n+  }\n+\n+  /**\n+   * Locks the state shared.\n+   *\n+   * Calling thread might be interrupted by this manager,\n+   * if it found to be waiting for the shared lock under when:\n+   *  - backup is exiting grace-cycle and entering the lock permanently\n+   *  - backup is in progress\n+   *\n+   * @return the lock resource\n+   * @throws InterruptedException\n+   */\n+  public LockResource lockShared() throws InterruptedException {\n+    // Do not allow taking shared lock during safe-mode.\n+    if (System.currentTimeMillis() < mExclusiveOnlyDeadlineMs) {\n+      String safeModeMsg = String.format(\n+          \"Master still in exclusive-only phase for the state-lock.\"\n+              + \"Please see documentation for %s.\",\n+          PropertyKey.Name.MASTER_BACKUP_STATE_LOCK_EXCLUSIVE_DURATION);\n+      throw new IllegalStateException(safeModeMsg);\n+    }\n+    // Register thread for interrupt cycle.\n+    mSharedWaitersAndHolders.add(Thread.currentThread());\n+    // Grab the lock interruptibly.\n+    mStateLock.readLock().lockInterruptibly();\n+    // Return the resource.\n+    // Register an action to remove the thread from holders registry before releasing the lock.\n+    return new LockResource(mStateLock.readLock(), false, false, () -> {\n+      mSharedWaitersAndHolders.remove(Thread.currentThread());\n+    });\n+  }\n+\n+  /**\n+   * Locks the state exclusively.\n+   *\n+   * @param lockOptions exclusive lock options\n+   * @return the lock resource\n+   * @throws TimeoutException if locking times out\n+   * @throws InterruptedException if interrupting during locking\n+   */\n+  public LockResource lockExclusive(StateLockOptions lockOptions)\n+      throws TimeoutException, InterruptedException {\n+    // Run the grace cycle.\n+    StateLockOptions.GraceMode graceMode = lockOptions.getGraceMode();\n+    boolean lockAcquired = false;\n+    long deadlineMs = System.currentTimeMillis() + lockOptions.getGraceCycleTimeoutMs();\n+    while (System.currentTimeMillis() < deadlineMs) {\n+      if (mStateLock.writeLock().tryLock(lockOptions.getGraceCycleTryMs(), TimeUnit.MILLISECONDS)) {\n+        lockAcquired = true;\n+        break;\n+      } else {\n+        long remainingWaitMs = deadlineMs - System.currentTimeMillis();\n+        if (remainingWaitMs > 0) {\n+          Thread.sleep(Math.min(lockOptions.getGraceCycleSleepMs(), remainingWaitMs));\n+        }\n+      }\n+    }\n+    if (lockAcquired) { // Lock was acquired within grace-cycle.\n+      activateInterruptCycle();\n+    } else { // Lock couldn't be acquired by grace-cycle.\n+      if (graceMode == StateLockOptions.GraceMode.TIMEOUT) {\n+        throw new TimeoutException(\n+            ExceptionMessage.STATE_LOCK_TIMED_OUT.getMessage(lockOptions.getGraceCycleTimeoutMs()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9203ceab6a25f945fbfccf87a107784003aba9eb"}, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTAzNDE1NA==", "bodyText": "This will end up being caught at RpcUtils.callAndReturn, which prints an error-log for runtime exceptions.", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r441034154", "createdAt": "2020-06-16T17:50:12Z", "author": {"login": "ggezer"}, "path": "core/server/common/src/main/java/alluxio/master/StateLockManager.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master;\n+\n+import alluxio.collections.ConcurrentHashSet;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.exception.ExceptionMessage;\n+import alluxio.resource.LockResource;\n+import alluxio.util.ThreadFactoryUtils;\n+\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+/**\n+ * Provides graceful and interruptable locking protocol for taking the state lock.\n+ *\n+ * {@link #lockShared()} will be used by user RPCs and may throw {@link InterruptedException}\n+ * based on options passed to {@link #lockExclusive(StateLockOptions)}.\n+ *\n+ * {@link #lockExclusive(StateLockOptions)} will be used by metadata backups in order to\n+ * guarantee paused state during critical tasks.\n+ */\n+public class StateLockManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(StateLockManager.class);\n+\n+  /** The state-lock. */\n+  private ReadWriteLock mStateLock = new ReentrantReadWriteLock(true);\n+\n+  /** The set of threads that are waiting for or holding the state-lock in shared mode. */\n+  private Set<Thread> mSharedWaitersAndHolders;\n+  /** Scheduler that is used for interrupt-cycle. */\n+  private ScheduledExecutorService mScheduler;\n+\n+  /** Whether exclusive locking will trigger interrupt-cycle. */\n+  private boolean mInterruptCycleEnabled;\n+  /** Interval at which threads around shared-lock will be interrupted during interrupt-cycle. */\n+  private long mInterruptCycleInterval;\n+  /** Used to synchronize execution/termination of interrupt-cycle. */\n+  private Lock mInterruptCycleLock = new ReentrantLock(true);\n+  /** How many active exclusive locking attempts. */\n+  private volatile long mInterruptCycleRefCount = 0;\n+  /** The future for the active interrupt cycle. */\n+  private ScheduledFuture<?> mInterrupterFuture;\n+\n+  /** This is the deadline for forcing the lock. */\n+  private long mForcedDurationMs;\n+\n+  // TODO(ggezer): Make it bound to a process start/stop cycle.\n+  /** Shared locking requests will fail until this time. */\n+  private long mExclusiveOnlyDeadlineMs = -1;\n+\n+  /**\n+   * Creates a new state-lock manager.\n+   */\n+  public StateLockManager() {\n+    mSharedWaitersAndHolders = new ConcurrentHashSet<>();\n+    // Init members.\n+    mScheduler = Executors\n+        .newSingleThreadScheduledExecutor(ThreadFactoryUtils.build(\"state-lock-manager-%d\", true));\n+    // Read properties.\n+    mInterruptCycleEnabled = ServerConfiguration\n+        .getBoolean(PropertyKey.MASTER_BACKUP_STATE_LOCK_INTERRUPT_CYCLE_ENABLED);\n+    mInterruptCycleInterval =\n+        ServerConfiguration.getMs(PropertyKey.MASTER_BACKUP_STATE_LOCK_INTERRUPT_CYCLE_INTERVAL);\n+    mForcedDurationMs =\n+        ServerConfiguration.getMs(PropertyKey.MASTER_BACKUP_STATE_LOCK_FORCED_DURATION);\n+    // Validate properties.\n+    Preconditions.checkArgument(mInterruptCycleInterval > 0,\n+        \"Interrupt-cycle interval should be greater than 0.\");\n+  }\n+\n+  /**\n+   * This is called by owning process in order to signal that\n+   * the state is read completely and masters are started.\n+   *\n+   * This triggers the beginning of exclusive-only maintenance mode for the state-lock.\n+   * Note: Calling it multiple times does not reset the maintenance window.\n+   */\n+  public void mastersStartedCallback() {\n+    if (mExclusiveOnlyDeadlineMs == -1) {\n+      mExclusiveOnlyDeadlineMs = System.currentTimeMillis()\n+          + ServerConfiguration.getMs(PropertyKey.MASTER_BACKUP_STATE_LOCK_EXCLUSIVE_DURATION);\n+    }\n+  }\n+\n+  /**\n+   * Locks the state shared.\n+   *\n+   * Calling thread might be interrupted by this manager,\n+   * if it found to be waiting for the shared lock under when:\n+   *  - backup is exiting grace-cycle and entering the lock permanently\n+   *  - backup is in progress\n+   *\n+   * @return the lock resource\n+   * @throws InterruptedException\n+   */\n+  public LockResource lockShared() throws InterruptedException {\n+    // Do not allow taking shared lock during safe-mode.\n+    if (System.currentTimeMillis() < mExclusiveOnlyDeadlineMs) {\n+      String safeModeMsg = String.format(\n+          \"Master still in exclusive-only phase for the state-lock.\"\n+              + \"Please see documentation for %s.\",\n+          PropertyKey.Name.MASTER_BACKUP_STATE_LOCK_EXCLUSIVE_DURATION);\n+      throw new IllegalStateException(safeModeMsg);\n+    }\n+    // Register thread for interrupt cycle.\n+    mSharedWaitersAndHolders.add(Thread.currentThread());\n+    // Grab the lock interruptibly.\n+    mStateLock.readLock().lockInterruptibly();\n+    // Return the resource.\n+    // Register an action to remove the thread from holders registry before releasing the lock.\n+    return new LockResource(mStateLock.readLock(), false, false, () -> {\n+      mSharedWaitersAndHolders.remove(Thread.currentThread());\n+    });\n+  }\n+\n+  /**\n+   * Locks the state exclusively.\n+   *\n+   * @param lockOptions exclusive lock options\n+   * @return the lock resource\n+   * @throws TimeoutException if locking times out\n+   * @throws InterruptedException if interrupting during locking\n+   */\n+  public LockResource lockExclusive(StateLockOptions lockOptions)\n+      throws TimeoutException, InterruptedException {\n+    // Run the grace cycle.\n+    StateLockOptions.GraceMode graceMode = lockOptions.getGraceMode();\n+    boolean lockAcquired = false;\n+    long deadlineMs = System.currentTimeMillis() + lockOptions.getGraceCycleTimeoutMs();\n+    while (System.currentTimeMillis() < deadlineMs) {\n+      if (mStateLock.writeLock().tryLock(lockOptions.getGraceCycleTryMs(), TimeUnit.MILLISECONDS)) {\n+        lockAcquired = true;\n+        break;\n+      } else {\n+        long remainingWaitMs = deadlineMs - System.currentTimeMillis();\n+        if (remainingWaitMs > 0) {\n+          Thread.sleep(Math.min(lockOptions.getGraceCycleSleepMs(), remainingWaitMs));\n+        }\n+      }\n+    }\n+    if (lockAcquired) { // Lock was acquired within grace-cycle.\n+      activateInterruptCycle();\n+    } else { // Lock couldn't be acquired by grace-cycle.\n+      if (graceMode == StateLockOptions.GraceMode.TIMEOUT) {\n+        throw new TimeoutException(\n+            ExceptionMessage.STATE_LOCK_TIMED_OUT.getMessage(lockOptions.getGraceCycleTimeoutMs()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ2MTkyMQ=="}, "originalCommit": {"oid": "9203ceab6a25f945fbfccf87a107784003aba9eb"}, "originalPosition": 169}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0NDE4ODYzOnYy", "diffSide": "RIGHT", "path": "core/server/common/src/main/java/alluxio/master/StateLockManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQyMTo0MDo0OVrOGkDtxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxNzo1OTowNFrOGkm6fw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ2Mjc4OQ==", "bodyText": "Would be helpful to state how much longer the deadline is", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r440462789", "createdAt": "2020-06-15T21:40:49Z", "author": {"login": "calvinjia"}, "path": "core/server/common/src/main/java/alluxio/master/StateLockManager.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master;\n+\n+import alluxio.collections.ConcurrentHashSet;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.exception.ExceptionMessage;\n+import alluxio.resource.LockResource;\n+import alluxio.util.ThreadFactoryUtils;\n+\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+/**\n+ * Provides graceful and interruptable locking protocol for taking the state lock.\n+ *\n+ * {@link #lockShared()} will be used by user RPCs and may throw {@link InterruptedException}\n+ * based on options passed to {@link #lockExclusive(StateLockOptions)}.\n+ *\n+ * {@link #lockExclusive(StateLockOptions)} will be used by metadata backups in order to\n+ * guarantee paused state during critical tasks.\n+ */\n+public class StateLockManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(StateLockManager.class);\n+\n+  /** The state-lock. */\n+  private ReadWriteLock mStateLock = new ReentrantReadWriteLock(true);\n+\n+  /** The set of threads that are waiting for or holding the state-lock in shared mode. */\n+  private Set<Thread> mSharedWaitersAndHolders;\n+  /** Scheduler that is used for interrupt-cycle. */\n+  private ScheduledExecutorService mScheduler;\n+\n+  /** Whether exclusive locking will trigger interrupt-cycle. */\n+  private boolean mInterruptCycleEnabled;\n+  /** Interval at which threads around shared-lock will be interrupted during interrupt-cycle. */\n+  private long mInterruptCycleInterval;\n+  /** Used to synchronize execution/termination of interrupt-cycle. */\n+  private Lock mInterruptCycleLock = new ReentrantLock(true);\n+  /** How many active exclusive locking attempts. */\n+  private volatile long mInterruptCycleRefCount = 0;\n+  /** The future for the active interrupt cycle. */\n+  private ScheduledFuture<?> mInterrupterFuture;\n+\n+  /** This is the deadline for forcing the lock. */\n+  private long mForcedDurationMs;\n+\n+  // TODO(ggezer): Make it bound to a process start/stop cycle.\n+  /** Shared locking requests will fail until this time. */\n+  private long mExclusiveOnlyDeadlineMs = -1;\n+\n+  /**\n+   * Creates a new state-lock manager.\n+   */\n+  public StateLockManager() {\n+    mSharedWaitersAndHolders = new ConcurrentHashSet<>();\n+    // Init members.\n+    mScheduler = Executors\n+        .newSingleThreadScheduledExecutor(ThreadFactoryUtils.build(\"state-lock-manager-%d\", true));\n+    // Read properties.\n+    mInterruptCycleEnabled = ServerConfiguration\n+        .getBoolean(PropertyKey.MASTER_BACKUP_STATE_LOCK_INTERRUPT_CYCLE_ENABLED);\n+    mInterruptCycleInterval =\n+        ServerConfiguration.getMs(PropertyKey.MASTER_BACKUP_STATE_LOCK_INTERRUPT_CYCLE_INTERVAL);\n+    mForcedDurationMs =\n+        ServerConfiguration.getMs(PropertyKey.MASTER_BACKUP_STATE_LOCK_FORCED_DURATION);\n+    // Validate properties.\n+    Preconditions.checkArgument(mInterruptCycleInterval > 0,\n+        \"Interrupt-cycle interval should be greater than 0.\");\n+  }\n+\n+  /**\n+   * This is called by owning process in order to signal that\n+   * the state is read completely and masters are started.\n+   *\n+   * This triggers the beginning of exclusive-only maintenance mode for the state-lock.\n+   * Note: Calling it multiple times does not reset the maintenance window.\n+   */\n+  public void mastersStartedCallback() {\n+    if (mExclusiveOnlyDeadlineMs == -1) {\n+      mExclusiveOnlyDeadlineMs = System.currentTimeMillis()\n+          + ServerConfiguration.getMs(PropertyKey.MASTER_BACKUP_STATE_LOCK_EXCLUSIVE_DURATION);\n+    }\n+  }\n+\n+  /**\n+   * Locks the state shared.\n+   *\n+   * Calling thread might be interrupted by this manager,\n+   * if it found to be waiting for the shared lock under when:\n+   *  - backup is exiting grace-cycle and entering the lock permanently\n+   *  - backup is in progress\n+   *\n+   * @return the lock resource\n+   * @throws InterruptedException\n+   */\n+  public LockResource lockShared() throws InterruptedException {\n+    // Do not allow taking shared lock during safe-mode.\n+    if (System.currentTimeMillis() < mExclusiveOnlyDeadlineMs) {\n+      String safeModeMsg = String.format(\n+          \"Master still in exclusive-only phase for the state-lock.\"\n+              + \"Please see documentation for %s.\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9203ceab6a25f945fbfccf87a107784003aba9eb"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTAzOTQ4Nw==", "bodyText": "Added more traces b872473", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r441039487", "createdAt": "2020-06-16T17:59:04Z", "author": {"login": "ggezer"}, "path": "core/server/common/src/main/java/alluxio/master/StateLockManager.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master;\n+\n+import alluxio.collections.ConcurrentHashSet;\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+import alluxio.exception.ExceptionMessage;\n+import alluxio.resource.LockResource;\n+import alluxio.util.ThreadFactoryUtils;\n+\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Set;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+/**\n+ * Provides graceful and interruptable locking protocol for taking the state lock.\n+ *\n+ * {@link #lockShared()} will be used by user RPCs and may throw {@link InterruptedException}\n+ * based on options passed to {@link #lockExclusive(StateLockOptions)}.\n+ *\n+ * {@link #lockExclusive(StateLockOptions)} will be used by metadata backups in order to\n+ * guarantee paused state during critical tasks.\n+ */\n+public class StateLockManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(StateLockManager.class);\n+\n+  /** The state-lock. */\n+  private ReadWriteLock mStateLock = new ReentrantReadWriteLock(true);\n+\n+  /** The set of threads that are waiting for or holding the state-lock in shared mode. */\n+  private Set<Thread> mSharedWaitersAndHolders;\n+  /** Scheduler that is used for interrupt-cycle. */\n+  private ScheduledExecutorService mScheduler;\n+\n+  /** Whether exclusive locking will trigger interrupt-cycle. */\n+  private boolean mInterruptCycleEnabled;\n+  /** Interval at which threads around shared-lock will be interrupted during interrupt-cycle. */\n+  private long mInterruptCycleInterval;\n+  /** Used to synchronize execution/termination of interrupt-cycle. */\n+  private Lock mInterruptCycleLock = new ReentrantLock(true);\n+  /** How many active exclusive locking attempts. */\n+  private volatile long mInterruptCycleRefCount = 0;\n+  /** The future for the active interrupt cycle. */\n+  private ScheduledFuture<?> mInterrupterFuture;\n+\n+  /** This is the deadline for forcing the lock. */\n+  private long mForcedDurationMs;\n+\n+  // TODO(ggezer): Make it bound to a process start/stop cycle.\n+  /** Shared locking requests will fail until this time. */\n+  private long mExclusiveOnlyDeadlineMs = -1;\n+\n+  /**\n+   * Creates a new state-lock manager.\n+   */\n+  public StateLockManager() {\n+    mSharedWaitersAndHolders = new ConcurrentHashSet<>();\n+    // Init members.\n+    mScheduler = Executors\n+        .newSingleThreadScheduledExecutor(ThreadFactoryUtils.build(\"state-lock-manager-%d\", true));\n+    // Read properties.\n+    mInterruptCycleEnabled = ServerConfiguration\n+        .getBoolean(PropertyKey.MASTER_BACKUP_STATE_LOCK_INTERRUPT_CYCLE_ENABLED);\n+    mInterruptCycleInterval =\n+        ServerConfiguration.getMs(PropertyKey.MASTER_BACKUP_STATE_LOCK_INTERRUPT_CYCLE_INTERVAL);\n+    mForcedDurationMs =\n+        ServerConfiguration.getMs(PropertyKey.MASTER_BACKUP_STATE_LOCK_FORCED_DURATION);\n+    // Validate properties.\n+    Preconditions.checkArgument(mInterruptCycleInterval > 0,\n+        \"Interrupt-cycle interval should be greater than 0.\");\n+  }\n+\n+  /**\n+   * This is called by owning process in order to signal that\n+   * the state is read completely and masters are started.\n+   *\n+   * This triggers the beginning of exclusive-only maintenance mode for the state-lock.\n+   * Note: Calling it multiple times does not reset the maintenance window.\n+   */\n+  public void mastersStartedCallback() {\n+    if (mExclusiveOnlyDeadlineMs == -1) {\n+      mExclusiveOnlyDeadlineMs = System.currentTimeMillis()\n+          + ServerConfiguration.getMs(PropertyKey.MASTER_BACKUP_STATE_LOCK_EXCLUSIVE_DURATION);\n+    }\n+  }\n+\n+  /**\n+   * Locks the state shared.\n+   *\n+   * Calling thread might be interrupted by this manager,\n+   * if it found to be waiting for the shared lock under when:\n+   *  - backup is exiting grace-cycle and entering the lock permanently\n+   *  - backup is in progress\n+   *\n+   * @return the lock resource\n+   * @throws InterruptedException\n+   */\n+  public LockResource lockShared() throws InterruptedException {\n+    // Do not allow taking shared lock during safe-mode.\n+    if (System.currentTimeMillis() < mExclusiveOnlyDeadlineMs) {\n+      String safeModeMsg = String.format(\n+          \"Master still in exclusive-only phase for the state-lock.\"\n+              + \"Please see documentation for %s.\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ2Mjc4OQ=="}, "originalCommit": {"oid": "9203ceab6a25f945fbfccf87a107784003aba9eb"}, "originalPosition": 124}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0ODAwMzg5OnYy", "diffSide": "RIGHT", "path": "core/server/common/src/main/java/alluxio/master/StateLockOptions.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxOTowMDo0M1rOGkpK7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxOTowMDo0M1rOGkpK7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA3NjQ2MQ==", "bodyText": "I think this is stale, since we are still using tryLock.", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r441076461", "createdAt": "2020-06-16T19:00:43Z", "author": {"login": "gpang"}, "path": "core/server/common/src/main/java/alluxio/master/StateLockOptions.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master;\n+\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+\n+import java.util.concurrent.locks.Lock;\n+\n+/**\n+ * Used to define state-lock options for taking it exclusively.\n+ * A typical framework for obtaining the state-lock exclusively is:\n+ *  1- Run a grace-cycle:\n+ *      cycle of {@link Lock#tryLock()} - {@link Thread#sleep(long)} calls.\n+ *  2- Interrupt state-lock holders if grace-cycle fails.\n+ *  3- Take the lock using {@link Lock#lock()}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ffcb98861454fb7435673273bbf3b109dc8917d2"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0ODAwNTU3OnYy", "diffSide": "RIGHT", "path": "core/server/common/src/main/java/alluxio/master/StateLockOptions.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxOTowMToxM1rOGkpL_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxOTowMToxM1rOGkpL_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA3NjczNA==", "bodyText": "This is actually something like \"continually interrupt state-lock holders and waiters\", right?", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r441076734", "createdAt": "2020-06-16T19:01:13Z", "author": {"login": "gpang"}, "path": "core/server/common/src/main/java/alluxio/master/StateLockOptions.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master;\n+\n+import alluxio.conf.PropertyKey;\n+import alluxio.conf.ServerConfiguration;\n+\n+import java.util.concurrent.locks.Lock;\n+\n+/**\n+ * Used to define state-lock options for taking it exclusively.\n+ * A typical framework for obtaining the state-lock exclusively is:\n+ *  1- Run a grace-cycle:\n+ *      cycle of {@link Lock#tryLock()} - {@link Thread#sleep(long)} calls.\n+ *  2- Interrupt state-lock holders if grace-cycle fails.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ffcb98861454fb7435673273bbf3b109dc8917d2"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0ODA5ODQ3OnYy", "diffSide": "RIGHT", "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxOToyOToyNFrOGkqHGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxOToyOToyNFrOGkqHGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTA5MTg2NA==", "bodyText": "I think we should be more explicit here. This will reject all RPCs which need to take the state-lock, which is most client RPCs.\nShould we also mention that this can be useful to guarantee a window on restart to initiate a backup?", "url": "https://github.com/Alluxio/alluxio/pull/11535#discussion_r441091864", "createdAt": "2020-06-16T19:29:24Z", "author": {"login": "gpang"}, "path": "core/common/src/main/java/alluxio/conf/PropertyKey.java", "diffHunk": "@@ -1301,6 +1301,39 @@ public String toString() {\n           .setConsistencyCheckLevel(ConsistencyCheckLevel.IGNORE)\n           .setScope(Scope.MASTER)\n           .build();\n+  public static final PropertyKey MASTER_BACKUP_STATE_LOCK_EXCLUSIVE_DURATION =\n+      new Builder(Name.MASTER_BACKUP_STATE_LOCK_EXCLUSIVE_DURATION)\n+          .setDefaultValue(\"0ms\")\n+          .setDescription(\"Alluxio master will allow only exclusive locking of \"\n+              + \"the state-lock for this duration. This duration starts after masters \"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ffcb98861454fb7435673273bbf3b109dc8917d2"}, "originalPosition": 8}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1603, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}