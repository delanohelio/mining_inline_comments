{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk3NTU4NDkx", "number": 12174, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNzoyNTozNFrOEqac0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxOToxNzowOFrOEqctWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyOTA5MDEwOnYy", "diffSide": "RIGHT", "path": "core/server/common/src/main/java/alluxio/master/journal/raft/LocalFirstRaftClient.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNzoyNTozNFrOHcmwXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNzozNzo1NFrOHcnKVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc1NzE1MA==", "bodyText": "How long and how frequently will the client retry? is it configurable?", "url": "https://github.com/Alluxio/alluxio/pull/12174#discussion_r499757150", "createdAt": "2020-10-05T17:25:34Z", "author": {"login": "LuQQiu"}, "path": "core/server/common/src/main/java/alluxio/master/journal/raft/LocalFirstRaftClient.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master.journal.raft;\n+\n+import alluxio.util.LogUtils;\n+\n+import org.apache.ratis.client.RaftClient;\n+import org.apache.ratis.protocol.AlreadyClosedException;\n+import org.apache.ratis.protocol.ClientId;\n+import org.apache.ratis.protocol.Message;\n+import org.apache.ratis.protocol.NotLeaderException;\n+import org.apache.ratis.protocol.RaftClientReply;\n+import org.apache.ratis.protocol.RaftClientRequest;\n+import org.apache.ratis.server.RaftServer;\n+import org.apache.ratis.util.TimeDuration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Supplier;\n+\n+/**\n+ * A client to send messages to a raft server with a strategy to attempt sending them locally first.\n+ */\n+public class LocalFirstRaftClient implements Closeable {\n+  private static final Logger LOG = LoggerFactory.getLogger(LocalFirstRaftClient.class);\n+  private final RaftServer mServer;\n+  private final Supplier<RaftClient> mClientSupplier;\n+  private ClientId mClientId;\n+  private volatile RaftClient mClient;\n+\n+  /**\n+   * @param server the local raft server\n+   * @param clientSupplier a function for building a remote raft client\n+   * @param clientId the client id\n+   */\n+  public LocalFirstRaftClient(RaftServer server, Supplier<RaftClient> clientSupplier,\n+      ClientId clientId) {\n+    mServer = server;\n+    mClientSupplier = clientSupplier;\n+    mClientId = clientId;\n+  }\n+\n+  /**\n+   * Sends a request to raft server asynchronously.\n+   * @param message the message to send\n+   * @param timeout the time duration to wait before giving up on the request\n+   * @return a future of the server reply\n+   * @throws IOException if an exception occured while sending the request\n+   */\n+  public CompletableFuture<RaftClientReply> sendAsync(Message message,\n+      TimeDuration timeout) throws IOException {\n+    if (mClient == null) {\n+      return sendLocalRequest(message, timeout);\n+    } else {\n+      return sendRemoteRequest(message);\n+    }\n+  }\n+\n+  private CompletableFuture<RaftClientReply> sendLocalRequest(Message message,\n+      TimeDuration timeout) throws IOException {\n+    return mServer.submitClientRequestAsync(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "269bc24fa60d79d5da8656242c93ece30863d1b7"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc2Mzc5Nw==", "bodyText": "This class will rebuild a client every time a client throws an AlreadyClosedException. The actual retry logic for sending a message is implemented by the caller and is not changed in this PR.", "url": "https://github.com/Alluxio/alluxio/pull/12174#discussion_r499763797", "createdAt": "2020-10-05T17:37:54Z", "author": {"login": "bf8086"}, "path": "core/server/common/src/main/java/alluxio/master/journal/raft/LocalFirstRaftClient.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.master.journal.raft;\n+\n+import alluxio.util.LogUtils;\n+\n+import org.apache.ratis.client.RaftClient;\n+import org.apache.ratis.protocol.AlreadyClosedException;\n+import org.apache.ratis.protocol.ClientId;\n+import org.apache.ratis.protocol.Message;\n+import org.apache.ratis.protocol.NotLeaderException;\n+import org.apache.ratis.protocol.RaftClientReply;\n+import org.apache.ratis.protocol.RaftClientRequest;\n+import org.apache.ratis.server.RaftServer;\n+import org.apache.ratis.util.TimeDuration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Supplier;\n+\n+/**\n+ * A client to send messages to a raft server with a strategy to attempt sending them locally first.\n+ */\n+public class LocalFirstRaftClient implements Closeable {\n+  private static final Logger LOG = LoggerFactory.getLogger(LocalFirstRaftClient.class);\n+  private final RaftServer mServer;\n+  private final Supplier<RaftClient> mClientSupplier;\n+  private ClientId mClientId;\n+  private volatile RaftClient mClient;\n+\n+  /**\n+   * @param server the local raft server\n+   * @param clientSupplier a function for building a remote raft client\n+   * @param clientId the client id\n+   */\n+  public LocalFirstRaftClient(RaftServer server, Supplier<RaftClient> clientSupplier,\n+      ClientId clientId) {\n+    mServer = server;\n+    mClientSupplier = clientSupplier;\n+    mClientId = clientId;\n+  }\n+\n+  /**\n+   * Sends a request to raft server asynchronously.\n+   * @param message the message to send\n+   * @param timeout the time duration to wait before giving up on the request\n+   * @return a future of the server reply\n+   * @throws IOException if an exception occured while sending the request\n+   */\n+  public CompletableFuture<RaftClientReply> sendAsync(Message message,\n+      TimeDuration timeout) throws IOException {\n+    if (mClient == null) {\n+      return sendLocalRequest(message, timeout);\n+    } else {\n+      return sendRemoteRequest(message);\n+    }\n+  }\n+\n+  private CompletableFuture<RaftClientReply> sendLocalRequest(Message message,\n+      TimeDuration timeout) throws IOException {\n+    return mServer.submitClientRequestAsync(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc1NzE1MA=="}, "originalCommit": {"oid": "269bc24fa60d79d5da8656242c93ece30863d1b7"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyOTEwODIwOnYy", "diffSide": "RIGHT", "path": "core/server/common/src/main/java/alluxio/master/journal/raft/RaftJournalSystem.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNzozMDo1NlrOHcm78g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNzo0MzoyMlrOHcnVIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc2MDExNA==", "bodyText": "Why this is needed?", "url": "https://github.com/Alluxio/alluxio/pull/12174#discussion_r499760114", "createdAt": "2020-10-05T17:30:56Z", "author": {"login": "LuQQiu"}, "path": "core/server/common/src/main/java/alluxio/master/journal/raft/RaftJournalSystem.java", "diffHunk": "@@ -338,6 +338,7 @@ private RaftClient createClient() {\n         .build();\n     return RaftClient.newBuilder()\n         .setRaftGroup(mRaftGroup)\n+        .setClientId(mClientId)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "269bc24fa60d79d5da8656242c93ece30863d1b7"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc2NjU2MQ==", "bodyText": "It's for easier tracking so requests from same node will have the same client id.", "url": "https://github.com/Alluxio/alluxio/pull/12174#discussion_r499766561", "createdAt": "2020-10-05T17:43:22Z", "author": {"login": "bf8086"}, "path": "core/server/common/src/main/java/alluxio/master/journal/raft/RaftJournalSystem.java", "diffHunk": "@@ -338,6 +338,7 @@ private RaftClient createClient() {\n         .build();\n     return RaftClient.newBuilder()\n         .setRaftGroup(mRaftGroup)\n+        .setClientId(mClientId)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc2MDExNA=="}, "originalCommit": {"oid": "269bc24fa60d79d5da8656242c93ece30863d1b7"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEyOTQ2MDEwOnYy", "diffSide": "RIGHT", "path": "core/server/common/src/main/java/alluxio/master/journal/raft/RaftJournalSystem.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxOToxNzowOFrOHcqY1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxOTo1MzoyNlrOHcrhwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgxNjY2MQ==", "bodyText": "Should this be configurable? I can't tell if 100ms is too short or too long. This means we will retry 10x per second forever? That seems quite frequent.", "url": "https://github.com/Alluxio/alluxio/pull/12174#discussion_r499816661", "createdAt": "2020-10-05T19:17:08Z", "author": {"login": "gpang"}, "path": "core/server/common/src/main/java/alluxio/master/journal/raft/RaftJournalSystem.java", "diffHunk": "@@ -525,14 +528,20 @@ private void catchUp(JournalStateMachine stateMachine, RaftClient client)\n       long gainPrimacySN = ThreadLocalRandom.current().nextLong(Long.MIN_VALUE, 0);\n       LOG.info(\"Performing catchup. Last applied SN: {}. Catchup ID: {}\",\n           lastAppliedSN, gainPrimacySN);\n-      CompletableFuture<RaftClientReply> future = client.sendAsync(\n-          toRaftMessage(JournalEntry.newBuilder().setSequenceNumber(gainPrimacySN).build()));\n+      Exception ex;\n       try {\n-        future.get(5, TimeUnit.SECONDS);\n-      } catch (TimeoutException | ExecutionException e) {\n-        client.getClientRpc().handleException(mPeerId,\n-            e instanceof ExecutionException ? e.getCause() : e, true);\n-        LOG.info(\"Exception submitting term start entry: {}\", e.toString());\n+        CompletableFuture<RaftClientReply> future = client.sendAsync(\n+            toRaftMessage(JournalEntry.newBuilder().setSequenceNumber(gainPrimacySN).build()),\n+            TimeDuration.valueOf(5, TimeUnit.SECONDS));\n+        RaftClientReply reply = future.get(5, TimeUnit.SECONDS);\n+        ex = reply.getException();\n+      } catch (TimeoutException | ExecutionException | IOException e) {\n+        ex = e;\n+      }\n+      if (ex != null) {\n+        LOG.info(\"Exception submitting term start entry: {}\", ex.toString());\n+        // avoid excessive retries when server is not ready\n+        Thread.sleep(100);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "269bc24fa60d79d5da8656242c93ece30863d1b7"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgzNTMyOA==", "bodyText": "Yeah it is still significantly better than retrying immediately and blowing up the logs in no time. I added a configuration property for 1s.", "url": "https://github.com/Alluxio/alluxio/pull/12174#discussion_r499835328", "createdAt": "2020-10-05T19:53:26Z", "author": {"login": "bf8086"}, "path": "core/server/common/src/main/java/alluxio/master/journal/raft/RaftJournalSystem.java", "diffHunk": "@@ -525,14 +528,20 @@ private void catchUp(JournalStateMachine stateMachine, RaftClient client)\n       long gainPrimacySN = ThreadLocalRandom.current().nextLong(Long.MIN_VALUE, 0);\n       LOG.info(\"Performing catchup. Last applied SN: {}. Catchup ID: {}\",\n           lastAppliedSN, gainPrimacySN);\n-      CompletableFuture<RaftClientReply> future = client.sendAsync(\n-          toRaftMessage(JournalEntry.newBuilder().setSequenceNumber(gainPrimacySN).build()));\n+      Exception ex;\n       try {\n-        future.get(5, TimeUnit.SECONDS);\n-      } catch (TimeoutException | ExecutionException e) {\n-        client.getClientRpc().handleException(mPeerId,\n-            e instanceof ExecutionException ? e.getCause() : e, true);\n-        LOG.info(\"Exception submitting term start entry: {}\", e.toString());\n+        CompletableFuture<RaftClientReply> future = client.sendAsync(\n+            toRaftMessage(JournalEntry.newBuilder().setSequenceNumber(gainPrimacySN).build()),\n+            TimeDuration.valueOf(5, TimeUnit.SECONDS));\n+        RaftClientReply reply = future.get(5, TimeUnit.SECONDS);\n+        ex = reply.getException();\n+      } catch (TimeoutException | ExecutionException | IOException e) {\n+        ex = e;\n+      }\n+      if (ex != null) {\n+        LOG.info(\"Exception submitting term start entry: {}\", ex.toString());\n+        // avoid excessive retries when server is not ready\n+        Thread.sleep(100);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgxNjY2MQ=="}, "originalCommit": {"oid": "269bc24fa60d79d5da8656242c93ece30863d1b7"}, "originalPosition": 94}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1220, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}