{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYyODgyMTk5", "number": 10748, "title": "Implement a User-Side Alluxio Local Cache", "bodyText": "Overview\nThe Alluxio Local Cache will be a lightweight caching library for compute frameworks. Different from a server-side Alluxio caching service, this caching library can be embedded into an application  as a part of Alluxio client jar as long as user sets alluxio.user.client.cache.enabled=true.\nPros/Cons\nCompare the client-side cache vs. server-side cache (e.g., current Alluxio service)\nPros\n\nA light-weight cache to improve performance;\nEasy to deploy and integrate (e.g., one can use the HDFS compatible API in Alluxio client jar to work with this library when alluxio.user.client.cache.enabled=true;\n\nCons\n\nPotential data dup across different client-side application processes\nHard to achieve fine-grained caching control over the cluster\n\nImplementation Details\nWe have introduced a few components including:\n\nLocalCacheFileSystem: as the one implementation of Alluxio FileSystem class for users to operate Alluxio Filesystem with a local cache embedded\nLocalCacheFileInStream is the entry point to retrieve a file in streaming reads or positioned reads. Note that, files are divided into small segments called \"pages\" (size controled by alluxio.user.client.cache.page.size)\nLocalCacheManager provides a thread-safe cache abstraction on the local data.\nPageStore: abstraction of a dump storage for pages. This implementation provides one implementation based on local file system (each page stored as a file) and one based on rocksdb (each page stored as a key-value pair)\nCacheEvictor: abstraction of cache replacement policies\n\nScope of this initial implementation\n\nOnly support reading static files\nOnly a few selected cache policies initially (e.g., LRU)", "createdAt": "2020-01-14T23:12:06Z", "url": "https://github.com/Alluxio/alluxio/pull/10748", "merged": true, "mergeCommit": {"oid": "8239dfc9554f1a4963285a6252fb3edf134bb9f8"}, "closed": true, "closedAt": "2020-02-14T07:39:38Z", "author": {"login": "apc999"}, "timelineItems": {"totalCount": 60, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb2ghBMAH2gAyMzYyODgyMTk5OjYzYmZkNjhlODVlNzQxNTFkNzNjYzRiY2U4YzIwZTk1MDIzYTEzN2Q=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcEWCU_AFqTM1OTIxNjg3Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "63bfd68e85e74151d73cc4bce8c20e95023a137d", "author": {"user": {"login": "apc999", "name": "Bin Fan"}}, "url": "https://github.com/Alluxio/alluxio/commit/63bfd68e85e74151d73cc4bce8c20e95023a137d", "committedDate": "2020-01-02T21:19:52Z", "message": "Refactor FileSystem Interface\n\nMotivation\n- Simplify the logic to implement a new FileSystem class. E.g.,\nseparating the logic to handle file system instance cache as well as\nreducing the set of methods to implement.\n\nDetails:\n- Move some convenience methods from `BaseFileSystem` to `FileSystem`\nInterface as default implementation. So in the future, other\nimplementing class only needs to implement the non-default methods to\navoid code duplication.\n- Move `FileSystem.Cache` outside the interface as `FileSystemCache` to\nprevent future confusion and also to make the interface thinner\n- Rename `CachingFileSystem` to `MetadataCachingBaseFileSystem` to avoid\nconfusion\n- Consolidate the logic of Caching `FileSystem` Instances inside\n`FileSystemCache` and `InstanceCachingFileSystem`, rather than leaving\ncache insertion in `FileSystem` and cache removal in implementing\nclasses like `BaseFileSystem`\n\npr-link: Alluxio/alluxio#10679\nchange-id: cid-57acfc3f6a00a1bc06b326bd76c493340271442c"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "03964d6d061432139949769566d68d7dc9c4ec98", "author": {"user": {"login": "apc999", "name": "Bin Fan"}}, "url": "https://github.com/Alluxio/alluxio/commit/03964d6d061432139949769566d68d7dc9c4ec98", "committedDate": "2020-01-03T23:08:02Z", "message": "Add skeleton implementation\n\nIntroduce local cache on client side\n\npr-link: Alluxio/alluxio#10694\nchange-id: cid-71def4efc5b7a8241c097954fd1fb4e4a1bc273f"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "53985c66f4a091d275dfa2f79808fbcabc65ada1", "author": {"user": {"login": "apc999", "name": "Bin Fan"}}, "url": "https://github.com/Alluxio/alluxio/commit/53985c66f4a091d275dfa2f79808fbcabc65ada1", "committedDate": "2020-01-03T23:45:12Z", "message": "Merge branch 'master' of github.com:Alluxio/alluxio into lite"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2c27b93fd8f9f042dcebd2893e5364225a8a53cb", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/2c27b93fd8f9f042dcebd2893e5364225a8a53cb", "committedDate": "2020-01-04T06:19:48Z", "message": "Update PageStore interface to use fileId and PageIndex\n\n\n\npr-link: Alluxio/alluxio#10697\nchange-id: cid-a79cf1518acac210b9bb19537995a75f57d88228"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b9d36a9f4f3f9aa545408af6816a0651807c76ad", "author": {"user": {"login": "apc999", "name": "Bin Fan"}}, "url": "https://github.com/Alluxio/alluxio/commit/b9d36a9f4f3f9aa545408af6816a0651807c76ad", "committedDate": "2020-01-06T07:06:28Z", "message": "Merge branch 'master' of github.com:Alluxio/alluxio into lite"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8313614ec502003c3960200e0d1d61158f4d24ba", "author": {"user": {"login": "apc999", "name": "Bin Fan"}}, "url": "https://github.com/Alluxio/alluxio/commit/8313614ec502003c3960200e0d1d61158f4d24ba", "committedDate": "2020-01-06T07:06:46Z", "message": "Merge branch 'lite' of github.com:Alluxio/alluxio into lite"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7a14c6b75bca2a5aeb632b77bc4b70d9c1b196c7", "author": {"user": {"login": "ZacBlanco", "name": "Zac Blanco"}}, "url": "https://github.com/Alluxio/alluxio/commit/7a14c6b75bca2a5aeb632b77bc4b70d9c1b196c7", "committedDate": "2020-01-10T18:32:35Z", "message": "Implement page stores\n\n\n\npr-link: Alluxio/alluxio#10703\nchange-id: cid-58f8774ccfc18b72324fa61fac366472bc066c95"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a249ce14ec9d13ff304b8723540b0beb6910e667", "author": {"user": {"login": "apc999", "name": "Bin Fan"}}, "url": "https://github.com/Alluxio/alluxio/commit/a249ce14ec9d13ff304b8723540b0beb6910e667", "committedDate": "2020-01-10T18:54:20Z", "message": "Merge branch 'master' of github.com:Alluxio/alluxio into lite"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b489b807d3f245cd409253fe703042f8f780ea00", "author": {"user": {"login": "calvinjia", "name": "Calvin Jia"}}, "url": "https://github.com/Alluxio/alluxio/commit/b489b807d3f245cd409253fe703042f8f780ea00", "committedDate": "2020-01-10T21:52:56Z", "message": "[WIP] Implement read/posread for local cache fileinstream\n\nPositioned read and read have similar implementations, we could make a\nread internal and reuse some code if we introduce an object to hold the\nposition, but we have separate implementations in the\nAlluxioFileInStream.\n\npr-link: Alluxio/alluxio#10711\nchange-id: cid-8a7325545761b47ce183c4377770bfca591fac35"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "82f257abde9f2bd6995323bc239dc56c9d645272", "author": {"user": {"login": "apc999", "name": "Bin Fan"}}, "url": "https://github.com/Alluxio/alluxio/commit/82f257abde9f2bd6995323bc239dc56c9d645272", "committedDate": "2020-01-12T06:39:25Z", "message": "Implement LocalCacheManager\n\n\n\npr-link: Alluxio/alluxio#10707\nchange-id: cid-ed5bbae85961daf918a4946e3a6207a61d0b9f87"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2c2541c497e825fdc2fc81cf087b17eb266a7093", "author": {"user": {"login": "apc999", "name": "Bin Fan"}}, "url": "https://github.com/Alluxio/alluxio/commit/2c2541c497e825fdc2fc81cf087b17eb266a7093", "committedDate": "2020-01-12T06:39:59Z", "message": "Merge branch 'master' of github.com:Alluxio/alluxio into lite"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a81878ad77b729d93723b062f12c4cbccb460eb8", "author": {"user": {"login": "apc999", "name": "Bin Fan"}}, "url": "https://github.com/Alluxio/alluxio/commit/a81878ad77b729d93723b062f12c4cbccb460eb8", "committedDate": "2020-01-13T21:29:11Z", "message": "Cleanup LocalCacheManager  Unit Test\n\nImprove unit test of `LocalCacheManager` by\n- removing PowerMock\n- instead of asserting on internal implementation (counting func calls),\nassert on cache state before and after.\n\npr-link: Alluxio/alluxio#10732\nchange-id: cid-cf31c4a45afb79af2f07b7677b1e89b979939996"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "86285ac80436a3adee7eff06de64b250deef5506", "author": {"user": {"login": "calvinjia", "name": "Calvin Jia"}}, "url": "https://github.com/Alluxio/alluxio/commit/86285ac80436a3adee7eff06de64b250deef5506", "committedDate": "2020-01-13T23:04:59Z", "message": "Add more tests for LocalCacheFileInStream\n\nSome of these won't pass until we adopt the new APIs.\n\npr-link: Alluxio/alluxio#10729\nchange-id: cid-acc3254291c4d17fbd4f9bf6413361337e4fcf66"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "60d00234e259db7c5f3409f7fa90cafa051794f1", "author": {"user": {"login": "calvinjia", "name": "Calvin Jia"}}, "url": "https://github.com/Alluxio/alluxio/commit/60d00234e259db7c5f3409f7fa90cafa051794f1", "committedDate": "2020-01-14T08:04:03Z", "message": "Implement positioned read\n\nThis PR also uses the newer API to do partial page reads correctly.\n\npr-link: Alluxio/alluxio#10737\nchange-id: cid-26b8b2b0c53d65aaa74b6b8c22cec2a2699f5cd5"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "523d9b175dfe50c7818fb641c245fd8b795754ca", "author": {"user": {"login": "bf8086", "name": null}}, "url": "https://github.com/Alluxio/alluxio/commit/523d9b175dfe50c7818fb641c245fd8b795754ca", "committedDate": "2020-01-14T08:05:33Z", "message": "Implement client side cache evictor and metastore\n\nImplement a basic metastore and LRU evictor for client side cache.\n\npr-link: Alluxio/alluxio#10733\nchange-id: cid-995fa10d3181f4053d638f91ce7fd4af8897b72e"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6259ae4d788b0ff58e5a326324eb9332194dbb1a", "author": {"user": {"login": "apc999", "name": "Bin Fan"}}, "url": "https://github.com/Alluxio/alluxio/commit/6259ae4d788b0ff58e5a326324eb9332194dbb1a", "committedDate": "2020-01-14T08:07:06Z", "message": "Merge branch 'master' of github.com:Alluxio/alluxio into lite"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "25154b45e5a85f2cc1c664edceec5df47373139c", "author": {"user": {"login": "bf8086", "name": null}}, "url": "https://github.com/Alluxio/alluxio/commit/25154b45e5a85f2cc1c664edceec5df47373139c", "committedDate": "2020-01-14T19:36:38Z", "message": "Fix PageStore FindBugs issues\n\nFixed following issues reported by findbugs:\n\n```\n[ERROR] Possible null pointer dereference in\nalluxio.client.file.cache.store.LocalPageStore.delete(PageId) due to\nreturn value of called method\n[alluxio.client.file.cache.store.LocalPageStore,\nalluxio.client.file.cache.store.LocalPageStore] Method invoked at\nLocalPageStore.java:[line 89]Known null at LocalPageStore.java:[line 89]\nNP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE\n[ERROR] Possible null pointer dereference in\nalluxio.client.file.cache.store.LocalPageStore.delete(PageId) due to\nreturn value of called method\n[alluxio.client.file.cache.store.LocalPageStore,\nalluxio.client.file.cache.store.LocalPageStore] Method invoked at\nLocalPageStore.java:[line 90]Known null at LocalPageStore.java:[line 90]\nNP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE\n[ERROR] Possible null pointer dereference in\nalluxio.client.file.cache.store.LocalPageStore.put(PageId, byte[]) due\nto return value of called method\n[alluxio.client.file.cache.store.LocalPageStore,\nalluxio.client.file.cache.store.LocalPageStore] Method invoked at\nLocalPageStore.java:[line 59]Known null at LocalPageStore.java:[line 59]\nNP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE\n[ERROR] alluxio.client.file.cache.store.LocalPageStore.delete(PageId)\nmay fail to close stream\n[alluxio.client.file.cache.store.LocalPageStore] At\nLocalPageStore.java:[line 89] OS_OPEN_STREAM\n[ERROR] Unused field:\nalluxio.client.file.cache.store.LocalPageStoreOptions.mRootDir\n[alluxio.client.file.cache.store.LocalPageStoreOptions] In\nLocalPageStoreOptions.java UUF_UNUSED_FIELD\n```\n\npr-link: Alluxio/alluxio#10743\nchange-id: cid-a54f0342af545a4f2f5eae32b9105bd3fe38c632"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3bf45304e5196b3b0cf04ac96c50209a65966b7f", "author": {"user": {"login": "calvinjia", "name": "Calvin Jia"}}, "url": "https://github.com/Alluxio/alluxio/commit/3bf45304e5196b3b0cf04ac96c50209a65966b7f", "committedDate": "2020-01-14T19:38:25Z", "message": "Fix checkstyle for local cache fileinstream related classes\n\n\n\npr-link: Alluxio/alluxio#10744\nchange-id: cid-7fd019fb5a6470fb829aea0260898d4f36c144c0"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "74932edcb60ca7b63130e42438849da125af761d", "author": {"user": {"login": "apc999", "name": "Bin Fan"}}, "url": "https://github.com/Alluxio/alluxio/commit/74932edcb60ca7b63130e42438849da125af761d", "committedDate": "2020-01-14T22:47:19Z", "message": "Merge branch 'master' of github.com:Alluxio/alluxio into lite"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQyOTE3NjQ5", "url": "https://github.com/Alluxio/alluxio/pull/10748#pullrequestreview-342917649", "createdAt": "2020-01-15T00:01:34Z", "commit": {"oid": "74932edcb60ca7b63130e42438849da125af761d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwMDowMTozNFrOFdproQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwMDowMTozNFrOFdproQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjYzNTkzNw==", "bodyText": "@apc999 This needs to be public or reflection will not work", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r366635937", "createdAt": "2020-01-15T00:01:34Z", "author": {"login": "calvinjia"}, "path": "core/client/fs/src/main/java/alluxio/client/file/BaseFileSystem.java", "diffHunk": "@@ -101,7 +101,7 @@\n    *\n    * @param fsContext file system context\n    */\n-  public BaseFileSystem(FileSystemContext fsContext) {\n+  protected BaseFileSystem(FileSystemContext fsContext) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "74932edcb60ca7b63130e42438849da125af761d"}, "originalPosition": 5}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ab11cf76344cc898a9c677648f35f828c95fa627", "author": {"user": {"login": "calvinjia", "name": "Calvin Jia"}}, "url": "https://github.com/Alluxio/alluxio/commit/ab11cf76344cc898a9c677648f35f828c95fa627", "committedDate": "2020-01-15T00:08:19Z", "message": "Revert a merge conflict resolution\n\n\n\npr-link: Alluxio/alluxio#10751\nchange-id: cid-26e83df64146a48abd82f9788ab5d4f466a4f8ce"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0f6a556bb73f02a026e4602381d62bf1855ca8f7", "author": {"user": {"login": "bf8086", "name": null}}, "url": "https://github.com/Alluxio/alluxio/commit/0f6a556bb73f02a026e4602381d62bf1855ca8f7", "committedDate": "2020-01-15T01:57:17Z", "message": "Fix some bugs and add new properties for client-side cache\n\nFixed index out of bound exception for cache manager locking.\nFixed exception when reading from stream with oversized buffer.\nAdded properties to configure page store directory and type.\n\npr-link: Alluxio/alluxio#10749\nchange-id: cid-84da2e962f967c990d25c1ff89f21639c6168227"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzMDYwNzkw", "url": "https://github.com/Alluxio/alluxio/pull/10748#pullrequestreview-343060790", "createdAt": "2020-01-15T08:49:43Z", "commit": {"oid": "0f6a556bb73f02a026e4602381d62bf1855ca8f7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwODo0OTo0M1rOFdw1eA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwODo0OTo0M1rOFdw1eA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc1MzE0NA==", "bodyText": "is this already a lazy init or just a TODO, @calvinjia ?", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r366753144", "createdAt": "2020-01-15T08:49:43Z", "author": {"login": "apc999"}, "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileInStream.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.client.file.FileInStream;\n+import alluxio.client.file.FileSystem;\n+import alluxio.client.file.URIStatus;\n+import alluxio.conf.PropertyKey;\n+import alluxio.exception.AlluxioException;\n+import alluxio.grpc.OpenFilePOptions;\n+import alluxio.util.io.BufferUtils;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Suppliers;\n+import com.google.common.io.Closer;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+\n+/**\n+ * Implementation of {@link FileInStream} that reads from a local cache if possible.\n+ */\n+@NotThreadSafe\n+public class LocalCacheFileInStream extends FileInStream {\n+\n+  /** Page size in bytes. */\n+  protected final long mPageSize;\n+\n+  private final byte[] mSingleByte = new byte[1];\n+  private final Closer mCloser = Closer.create();\n+\n+  /** Local store to store pages. */\n+  private final CacheManager mCacheManager;\n+  /** External storage system. */\n+  private final FileSystem mExternalFs;\n+  /** Path of the file. */\n+  private final AlluxioURI mPath;\n+  /** File info, fetched from external FS. */\n+  private final URIStatus mStatus;\n+  private final OpenFilePOptions mOpenOptions;\n+\n+  /** Stream reading from the external file system, opened once. */\n+  private FileInStream mExternalFileInStream;\n+  /** Current position of the stream, relative to the start of the file. */\n+  private long mPosition = 0;\n+  private boolean mClosed = false;\n+  private boolean mEOF = false;\n+\n+  /**\n+   * Constructor.\n+   *\n+   * @param path path of the file\n+   * @param options read options\n+   * @param externalFs the external file system if a cache miss occurs\n+   * @param cacheManager local cache manager\n+   */\n+  public LocalCacheFileInStream(AlluxioURI path, OpenFilePOptions options, FileSystem externalFs,\n+      CacheManager cacheManager) {\n+    mPageSize = externalFs.getConf().getBytes(PropertyKey.USER_CLIENT_CACHE_PAGE_SIZE);\n+    mPath = path;\n+    // Lazy init of status object", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f6a556bb73f02a026e4602381d62bf1855ca8f7"}, "originalPosition": 73}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzMDYxNTA4", "url": "https://github.com/Alluxio/alluxio/pull/10748#pullrequestreview-343061508", "createdAt": "2020-01-15T08:51:08Z", "commit": {"oid": "0f6a556bb73f02a026e4602381d62bf1855ca8f7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwODo1MTowOFrOFdw3iA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwODo1MTowOFrOFdw3iA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc1MzY3Mg==", "bodyText": "how shall we handle IOException here when reading cache? Assume we shall fallback to external stream? Currently the IOE will be escalated.", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r366753672", "createdAt": "2020-01-15T08:51:08Z", "author": {"login": "apc999"}, "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileInStream.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.client.file.FileInStream;\n+import alluxio.client.file.FileSystem;\n+import alluxio.client.file.URIStatus;\n+import alluxio.conf.PropertyKey;\n+import alluxio.exception.AlluxioException;\n+import alluxio.grpc.OpenFilePOptions;\n+import alluxio.util.io.BufferUtils;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Suppliers;\n+import com.google.common.io.Closer;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+\n+/**\n+ * Implementation of {@link FileInStream} that reads from a local cache if possible.\n+ */\n+@NotThreadSafe\n+public class LocalCacheFileInStream extends FileInStream {\n+\n+  /** Page size in bytes. */\n+  protected final long mPageSize;\n+\n+  private final byte[] mSingleByte = new byte[1];\n+  private final Closer mCloser = Closer.create();\n+\n+  /** Local store to store pages. */\n+  private final CacheManager mCacheManager;\n+  /** External storage system. */\n+  private final FileSystem mExternalFs;\n+  /** Path of the file. */\n+  private final AlluxioURI mPath;\n+  /** File info, fetched from external FS. */\n+  private final URIStatus mStatus;\n+  private final OpenFilePOptions mOpenOptions;\n+\n+  /** Stream reading from the external file system, opened once. */\n+  private FileInStream mExternalFileInStream;\n+  /** Current position of the stream, relative to the start of the file. */\n+  private long mPosition = 0;\n+  private boolean mClosed = false;\n+  private boolean mEOF = false;\n+\n+  /**\n+   * Constructor.\n+   *\n+   * @param path path of the file\n+   * @param options read options\n+   * @param externalFs the external file system if a cache miss occurs\n+   * @param cacheManager local cache manager\n+   */\n+  public LocalCacheFileInStream(AlluxioURI path, OpenFilePOptions options, FileSystem externalFs,\n+      CacheManager cacheManager) {\n+    mPageSize = externalFs.getConf().getBytes(PropertyKey.USER_CLIENT_CACHE_PAGE_SIZE);\n+    mPath = path;\n+    // Lazy init of status object\n+    mStatus = Suppliers.memoize(() -> {\n+      try {\n+        return externalFs.getStatus(mPath);\n+      } catch (Exception e) {\n+        throw new RuntimeException(e);\n+      }\n+    }).get();\n+    mOpenOptions = options;\n+    mExternalFs = externalFs;\n+    mCacheManager = cacheManager;\n+  }\n+\n+  @Override\n+  public int read() throws IOException {\n+    int bytesRead = read(mSingleByte);\n+    if (bytesRead == -1) {\n+      return -1;\n+    }\n+    Preconditions.checkState(bytesRead == 1);\n+    return BufferUtils.byteToInt(mSingleByte[0]);\n+  }\n+\n+  @Override\n+  public int read(byte[] b) throws IOException {\n+    return read(b, 0, b.length);\n+  }\n+\n+  @Override\n+  public int read(byte[] b, int off, int len) throws IOException {\n+    Preconditions.checkArgument(len >= 0, \"length should be non-negative\");\n+    Preconditions.checkArgument(off >= 0, \"offset should be non-negative\");\n+    if (len == 0) {\n+      return 0;\n+    }\n+    if (mPosition >= mStatus.getLength()) { // at end of file\n+      return -1;\n+    }\n+    int bytesRead = 0;\n+    // for each page, check if it is available in the cache\n+    while (bytesRead < len && mPosition < mStatus.getLength()) {\n+      long currentPage = mPosition / mPageSize;\n+      int currentPageOffset = (int) (mPosition % mPageSize);\n+      int bytesLeftInPage = (int) Math.min(mPageSize - currentPageOffset, len - bytesRead);\n+      PageId pageId = new PageId(mStatus.getFileId(), currentPage);\n+      try (ReadableByteChannel cachedData = mCacheManager.get(pageId, currentPageOffset)) {\n+        if (cachedData != null) { // cache hit\n+          // wrap return byte array in a bytebuffer and set the pos/limit for the page read\n+          ByteBuffer buf = ByteBuffer.wrap(b);\n+          buf.position(off + bytesRead);\n+          buf.limit(off + bytesRead + bytesLeftInPage);\n+          // read data from cache\n+          while (buf.position() != buf.limit()) {\n+            if (cachedData.read(buf) == -1) {\n+              break;\n+            }\n+          }\n+          Preconditions.checkState(buf.position() == buf.limit());\n+          bytesRead += bytesLeftInPage;\n+          mPosition += bytesLeftInPage;\n+        } else { // cache miss\n+          byte[] page = readExternalPage(mPosition);\n+          if (page.length > 0) {\n+            mCacheManager.put(pageId, page);\n+            System.arraycopy(page, currentPageOffset, b, off + bytesRead, bytesLeftInPage);\n+            bytesRead += bytesLeftInPage;\n+            mPosition += bytesLeftInPage;\n+          }\n+        }\n+      }\n+    }\n+    Preconditions.checkState(bytesRead == len || (bytesRead < len && remaining() == 0),\n+        \"Invalid number of bytes read - \"\n+            + \"bytes to read = %d, actual bytes read = %d, bytes remains in file %d\",\n+        len, bytesRead, remaining());\n+    return bytesRead;\n+  }\n+\n+  @Override\n+  public long skip(long n) {\n+    checkIfClosed();\n+    if (n <= 0) {\n+      return 0;\n+    }\n+    long toSkip = Math.min(remaining(), n);\n+    mPosition += toSkip;\n+    return toSkip;\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    mCloser.close();\n+  }\n+\n+  @Override\n+  public long remaining() {\n+    return mEOF ? 0 : mStatus.getLength() - mPosition;\n+  }\n+\n+  @Override\n+  public int positionedRead(long pos, byte[] b, int off, int len) throws IOException {\n+    Preconditions.checkArgument(len >= 0, \"length should be non-negative\");\n+    Preconditions.checkArgument(off >= 0, \"offset should be non-negative\");\n+    Preconditions.checkArgument(pos >= 0, \"position should be non-negative\");\n+    if (len == 0) {\n+      return 0;\n+    }\n+    if (pos < 0 || pos >= mStatus.getLength()) { // at end of file\n+      return -1;\n+    }\n+    int bytesRead = 0;\n+    long currentPosition = pos;\n+    long lengthToRead = Math.min(len, mStatus.getLength() - pos);\n+    // for each page, check if it is available in the cache\n+    while (bytesRead < lengthToRead) {\n+      long currentPage = currentPosition / mPageSize;\n+      int currentPageOffset = (int) (currentPosition % mPageSize);\n+      int bytesLeftInPage = (int) Math.min(mPageSize - currentPageOffset, lengthToRead - bytesRead);\n+      PageId pageId = new PageId(mStatus.getFileId(), currentPage);\n+      try (ReadableByteChannel cachedData = mCacheManager.get(pageId, currentPageOffset)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f6a556bb73f02a026e4602381d62bf1855ca8f7"}, "originalPosition": 192}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzMDYxODI1", "url": "https://github.com/Alluxio/alluxio/pull/10748#pullrequestreview-343061825", "createdAt": "2020-01-15T08:51:44Z", "commit": {"oid": "0f6a556bb73f02a026e4602381d62bf1855ca8f7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwODo1MTo0NVrOFdw4fw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwODo1MTo0NVrOFdw4fw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc1MzkxOQ==", "bodyText": "how shall we handle IOException here when reading cache? Assume we shall fallback to external stream? Currently the IOE will be escalated. Are we supposed to make the failure transparent for the application?", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r366753919", "createdAt": "2020-01-15T08:51:45Z", "author": {"login": "apc999"}, "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileInStream.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.client.file.FileInStream;\n+import alluxio.client.file.FileSystem;\n+import alluxio.client.file.URIStatus;\n+import alluxio.conf.PropertyKey;\n+import alluxio.exception.AlluxioException;\n+import alluxio.grpc.OpenFilePOptions;\n+import alluxio.util.io.BufferUtils;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Suppliers;\n+import com.google.common.io.Closer;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+\n+/**\n+ * Implementation of {@link FileInStream} that reads from a local cache if possible.\n+ */\n+@NotThreadSafe\n+public class LocalCacheFileInStream extends FileInStream {\n+\n+  /** Page size in bytes. */\n+  protected final long mPageSize;\n+\n+  private final byte[] mSingleByte = new byte[1];\n+  private final Closer mCloser = Closer.create();\n+\n+  /** Local store to store pages. */\n+  private final CacheManager mCacheManager;\n+  /** External storage system. */\n+  private final FileSystem mExternalFs;\n+  /** Path of the file. */\n+  private final AlluxioURI mPath;\n+  /** File info, fetched from external FS. */\n+  private final URIStatus mStatus;\n+  private final OpenFilePOptions mOpenOptions;\n+\n+  /** Stream reading from the external file system, opened once. */\n+  private FileInStream mExternalFileInStream;\n+  /** Current position of the stream, relative to the start of the file. */\n+  private long mPosition = 0;\n+  private boolean mClosed = false;\n+  private boolean mEOF = false;\n+\n+  /**\n+   * Constructor.\n+   *\n+   * @param path path of the file\n+   * @param options read options\n+   * @param externalFs the external file system if a cache miss occurs\n+   * @param cacheManager local cache manager\n+   */\n+  public LocalCacheFileInStream(AlluxioURI path, OpenFilePOptions options, FileSystem externalFs,\n+      CacheManager cacheManager) {\n+    mPageSize = externalFs.getConf().getBytes(PropertyKey.USER_CLIENT_CACHE_PAGE_SIZE);\n+    mPath = path;\n+    // Lazy init of status object\n+    mStatus = Suppliers.memoize(() -> {\n+      try {\n+        return externalFs.getStatus(mPath);\n+      } catch (Exception e) {\n+        throw new RuntimeException(e);\n+      }\n+    }).get();\n+    mOpenOptions = options;\n+    mExternalFs = externalFs;\n+    mCacheManager = cacheManager;\n+  }\n+\n+  @Override\n+  public int read() throws IOException {\n+    int bytesRead = read(mSingleByte);\n+    if (bytesRead == -1) {\n+      return -1;\n+    }\n+    Preconditions.checkState(bytesRead == 1);\n+    return BufferUtils.byteToInt(mSingleByte[0]);\n+  }\n+\n+  @Override\n+  public int read(byte[] b) throws IOException {\n+    return read(b, 0, b.length);\n+  }\n+\n+  @Override\n+  public int read(byte[] b, int off, int len) throws IOException {\n+    Preconditions.checkArgument(len >= 0, \"length should be non-negative\");\n+    Preconditions.checkArgument(off >= 0, \"offset should be non-negative\");\n+    if (len == 0) {\n+      return 0;\n+    }\n+    if (mPosition >= mStatus.getLength()) { // at end of file\n+      return -1;\n+    }\n+    int bytesRead = 0;\n+    // for each page, check if it is available in the cache\n+    while (bytesRead < len && mPosition < mStatus.getLength()) {\n+      long currentPage = mPosition / mPageSize;\n+      int currentPageOffset = (int) (mPosition % mPageSize);\n+      int bytesLeftInPage = (int) Math.min(mPageSize - currentPageOffset, len - bytesRead);\n+      PageId pageId = new PageId(mStatus.getFileId(), currentPage);\n+      try (ReadableByteChannel cachedData = mCacheManager.get(pageId, currentPageOffset)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f6a556bb73f02a026e4602381d62bf1855ca8f7"}, "originalPosition": 118}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzMDYyMjc2", "url": "https://github.com/Alluxio/alluxio/pull/10748#pullrequestreview-343062276", "createdAt": "2020-01-15T08:52:37Z", "commit": {"oid": "0f6a556bb73f02a026e4602381d62bf1855ca8f7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwODo1MjozN1rOFdw57w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwODo1MjozN1rOFdw57w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc1NDI4Nw==", "bodyText": "how shall we handle failed put with IOE? shall we silently swallow the exception (w/ warning)?", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r366754287", "createdAt": "2020-01-15T08:52:37Z", "author": {"login": "apc999"}, "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileInStream.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.client.file.FileInStream;\n+import alluxio.client.file.FileSystem;\n+import alluxio.client.file.URIStatus;\n+import alluxio.conf.PropertyKey;\n+import alluxio.exception.AlluxioException;\n+import alluxio.grpc.OpenFilePOptions;\n+import alluxio.util.io.BufferUtils;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Suppliers;\n+import com.google.common.io.Closer;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+\n+/**\n+ * Implementation of {@link FileInStream} that reads from a local cache if possible.\n+ */\n+@NotThreadSafe\n+public class LocalCacheFileInStream extends FileInStream {\n+\n+  /** Page size in bytes. */\n+  protected final long mPageSize;\n+\n+  private final byte[] mSingleByte = new byte[1];\n+  private final Closer mCloser = Closer.create();\n+\n+  /** Local store to store pages. */\n+  private final CacheManager mCacheManager;\n+  /** External storage system. */\n+  private final FileSystem mExternalFs;\n+  /** Path of the file. */\n+  private final AlluxioURI mPath;\n+  /** File info, fetched from external FS. */\n+  private final URIStatus mStatus;\n+  private final OpenFilePOptions mOpenOptions;\n+\n+  /** Stream reading from the external file system, opened once. */\n+  private FileInStream mExternalFileInStream;\n+  /** Current position of the stream, relative to the start of the file. */\n+  private long mPosition = 0;\n+  private boolean mClosed = false;\n+  private boolean mEOF = false;\n+\n+  /**\n+   * Constructor.\n+   *\n+   * @param path path of the file\n+   * @param options read options\n+   * @param externalFs the external file system if a cache miss occurs\n+   * @param cacheManager local cache manager\n+   */\n+  public LocalCacheFileInStream(AlluxioURI path, OpenFilePOptions options, FileSystem externalFs,\n+      CacheManager cacheManager) {\n+    mPageSize = externalFs.getConf().getBytes(PropertyKey.USER_CLIENT_CACHE_PAGE_SIZE);\n+    mPath = path;\n+    // Lazy init of status object\n+    mStatus = Suppliers.memoize(() -> {\n+      try {\n+        return externalFs.getStatus(mPath);\n+      } catch (Exception e) {\n+        throw new RuntimeException(e);\n+      }\n+    }).get();\n+    mOpenOptions = options;\n+    mExternalFs = externalFs;\n+    mCacheManager = cacheManager;\n+  }\n+\n+  @Override\n+  public int read() throws IOException {\n+    int bytesRead = read(mSingleByte);\n+    if (bytesRead == -1) {\n+      return -1;\n+    }\n+    Preconditions.checkState(bytesRead == 1);\n+    return BufferUtils.byteToInt(mSingleByte[0]);\n+  }\n+\n+  @Override\n+  public int read(byte[] b) throws IOException {\n+    return read(b, 0, b.length);\n+  }\n+\n+  @Override\n+  public int read(byte[] b, int off, int len) throws IOException {\n+    Preconditions.checkArgument(len >= 0, \"length should be non-negative\");\n+    Preconditions.checkArgument(off >= 0, \"offset should be non-negative\");\n+    if (len == 0) {\n+      return 0;\n+    }\n+    if (mPosition >= mStatus.getLength()) { // at end of file\n+      return -1;\n+    }\n+    int bytesRead = 0;\n+    // for each page, check if it is available in the cache\n+    while (bytesRead < len && mPosition < mStatus.getLength()) {\n+      long currentPage = mPosition / mPageSize;\n+      int currentPageOffset = (int) (mPosition % mPageSize);\n+      int bytesLeftInPage = (int) Math.min(mPageSize - currentPageOffset, len - bytesRead);\n+      PageId pageId = new PageId(mStatus.getFileId(), currentPage);\n+      try (ReadableByteChannel cachedData = mCacheManager.get(pageId, currentPageOffset)) {\n+        if (cachedData != null) { // cache hit\n+          // wrap return byte array in a bytebuffer and set the pos/limit for the page read\n+          ByteBuffer buf = ByteBuffer.wrap(b);\n+          buf.position(off + bytesRead);\n+          buf.limit(off + bytesRead + bytesLeftInPage);\n+          // read data from cache\n+          while (buf.position() != buf.limit()) {\n+            if (cachedData.read(buf) == -1) {\n+              break;\n+            }\n+          }\n+          Preconditions.checkState(buf.position() == buf.limit());\n+          bytesRead += bytesLeftInPage;\n+          mPosition += bytesLeftInPage;\n+        } else { // cache miss\n+          byte[] page = readExternalPage(mPosition);\n+          if (page.length > 0) {\n+            mCacheManager.put(pageId, page);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f6a556bb73f02a026e4602381d62bf1855ca8f7"}, "originalPosition": 136}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzMDYyNjEx", "url": "https://github.com/Alluxio/alluxio/pull/10748#pullrequestreview-343062611", "createdAt": "2020-01-15T08:53:15Z", "commit": {"oid": "0f6a556bb73f02a026e4602381d62bf1855ca8f7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwODo1MzoxNlrOFdw65g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwODo1MzoxNlrOFdw65g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc1NDUzNA==", "bodyText": "handle IOException?", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r366754534", "createdAt": "2020-01-15T08:53:16Z", "author": {"login": "apc999"}, "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileInStream.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.client.file.FileInStream;\n+import alluxio.client.file.FileSystem;\n+import alluxio.client.file.URIStatus;\n+import alluxio.conf.PropertyKey;\n+import alluxio.exception.AlluxioException;\n+import alluxio.grpc.OpenFilePOptions;\n+import alluxio.util.io.BufferUtils;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Suppliers;\n+import com.google.common.io.Closer;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+\n+/**\n+ * Implementation of {@link FileInStream} that reads from a local cache if possible.\n+ */\n+@NotThreadSafe\n+public class LocalCacheFileInStream extends FileInStream {\n+\n+  /** Page size in bytes. */\n+  protected final long mPageSize;\n+\n+  private final byte[] mSingleByte = new byte[1];\n+  private final Closer mCloser = Closer.create();\n+\n+  /** Local store to store pages. */\n+  private final CacheManager mCacheManager;\n+  /** External storage system. */\n+  private final FileSystem mExternalFs;\n+  /** Path of the file. */\n+  private final AlluxioURI mPath;\n+  /** File info, fetched from external FS. */\n+  private final URIStatus mStatus;\n+  private final OpenFilePOptions mOpenOptions;\n+\n+  /** Stream reading from the external file system, opened once. */\n+  private FileInStream mExternalFileInStream;\n+  /** Current position of the stream, relative to the start of the file. */\n+  private long mPosition = 0;\n+  private boolean mClosed = false;\n+  private boolean mEOF = false;\n+\n+  /**\n+   * Constructor.\n+   *\n+   * @param path path of the file\n+   * @param options read options\n+   * @param externalFs the external file system if a cache miss occurs\n+   * @param cacheManager local cache manager\n+   */\n+  public LocalCacheFileInStream(AlluxioURI path, OpenFilePOptions options, FileSystem externalFs,\n+      CacheManager cacheManager) {\n+    mPageSize = externalFs.getConf().getBytes(PropertyKey.USER_CLIENT_CACHE_PAGE_SIZE);\n+    mPath = path;\n+    // Lazy init of status object\n+    mStatus = Suppliers.memoize(() -> {\n+      try {\n+        return externalFs.getStatus(mPath);\n+      } catch (Exception e) {\n+        throw new RuntimeException(e);\n+      }\n+    }).get();\n+    mOpenOptions = options;\n+    mExternalFs = externalFs;\n+    mCacheManager = cacheManager;\n+  }\n+\n+  @Override\n+  public int read() throws IOException {\n+    int bytesRead = read(mSingleByte);\n+    if (bytesRead == -1) {\n+      return -1;\n+    }\n+    Preconditions.checkState(bytesRead == 1);\n+    return BufferUtils.byteToInt(mSingleByte[0]);\n+  }\n+\n+  @Override\n+  public int read(byte[] b) throws IOException {\n+    return read(b, 0, b.length);\n+  }\n+\n+  @Override\n+  public int read(byte[] b, int off, int len) throws IOException {\n+    Preconditions.checkArgument(len >= 0, \"length should be non-negative\");\n+    Preconditions.checkArgument(off >= 0, \"offset should be non-negative\");\n+    if (len == 0) {\n+      return 0;\n+    }\n+    if (mPosition >= mStatus.getLength()) { // at end of file\n+      return -1;\n+    }\n+    int bytesRead = 0;\n+    // for each page, check if it is available in the cache\n+    while (bytesRead < len && mPosition < mStatus.getLength()) {\n+      long currentPage = mPosition / mPageSize;\n+      int currentPageOffset = (int) (mPosition % mPageSize);\n+      int bytesLeftInPage = (int) Math.min(mPageSize - currentPageOffset, len - bytesRead);\n+      PageId pageId = new PageId(mStatus.getFileId(), currentPage);\n+      try (ReadableByteChannel cachedData = mCacheManager.get(pageId, currentPageOffset)) {\n+        if (cachedData != null) { // cache hit\n+          // wrap return byte array in a bytebuffer and set the pos/limit for the page read\n+          ByteBuffer buf = ByteBuffer.wrap(b);\n+          buf.position(off + bytesRead);\n+          buf.limit(off + bytesRead + bytesLeftInPage);\n+          // read data from cache\n+          while (buf.position() != buf.limit()) {\n+            if (cachedData.read(buf) == -1) {\n+              break;\n+            }\n+          }\n+          Preconditions.checkState(buf.position() == buf.limit());\n+          bytesRead += bytesLeftInPage;\n+          mPosition += bytesLeftInPage;\n+        } else { // cache miss\n+          byte[] page = readExternalPage(mPosition);\n+          if (page.length > 0) {\n+            mCacheManager.put(pageId, page);\n+            System.arraycopy(page, currentPageOffset, b, off + bytesRead, bytesLeftInPage);\n+            bytesRead += bytesLeftInPage;\n+            mPosition += bytesLeftInPage;\n+          }\n+        }\n+      }\n+    }\n+    Preconditions.checkState(bytesRead == len || (bytesRead < len && remaining() == 0),\n+        \"Invalid number of bytes read - \"\n+            + \"bytes to read = %d, actual bytes read = %d, bytes remains in file %d\",\n+        len, bytesRead, remaining());\n+    return bytesRead;\n+  }\n+\n+  @Override\n+  public long skip(long n) {\n+    checkIfClosed();\n+    if (n <= 0) {\n+      return 0;\n+    }\n+    long toSkip = Math.min(remaining(), n);\n+    mPosition += toSkip;\n+    return toSkip;\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    mCloser.close();\n+  }\n+\n+  @Override\n+  public long remaining() {\n+    return mEOF ? 0 : mStatus.getLength() - mPosition;\n+  }\n+\n+  @Override\n+  public int positionedRead(long pos, byte[] b, int off, int len) throws IOException {\n+    Preconditions.checkArgument(len >= 0, \"length should be non-negative\");\n+    Preconditions.checkArgument(off >= 0, \"offset should be non-negative\");\n+    Preconditions.checkArgument(pos >= 0, \"position should be non-negative\");\n+    if (len == 0) {\n+      return 0;\n+    }\n+    if (pos < 0 || pos >= mStatus.getLength()) { // at end of file\n+      return -1;\n+    }\n+    int bytesRead = 0;\n+    long currentPosition = pos;\n+    long lengthToRead = Math.min(len, mStatus.getLength() - pos);\n+    // for each page, check if it is available in the cache\n+    while (bytesRead < lengthToRead) {\n+      long currentPage = currentPosition / mPageSize;\n+      int currentPageOffset = (int) (currentPosition % mPageSize);\n+      int bytesLeftInPage = (int) Math.min(mPageSize - currentPageOffset, lengthToRead - bytesRead);\n+      PageId pageId = new PageId(mStatus.getFileId(), currentPage);\n+      try (ReadableByteChannel cachedData = mCacheManager.get(pageId, currentPageOffset)) {\n+        if (cachedData != null) { // cache hit\n+          // wrap return byte array in a bytebuffer and set the pos/limit for the page read\n+          ByteBuffer buf = ByteBuffer.wrap(b);\n+          buf.position(off + bytesRead);\n+          buf.limit(off + bytesRead + bytesLeftInPage);\n+          // read data from cache\n+          while (buf.position() != buf.limit()) {\n+            if (cachedData.read(buf) == -1) {\n+              break;\n+            }\n+          }\n+          Preconditions.checkState(buf.position() == buf.limit());\n+          bytesRead += bytesLeftInPage;\n+          currentPosition += bytesLeftInPage;\n+        } else { // cache miss\n+          byte[] page = readExternalPage(currentPosition);\n+          mCacheManager.put(pageId, page);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f6a556bb73f02a026e4602381d62bf1855ca8f7"}, "originalPosition": 209}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQzMDYzNDMw", "url": "https://github.com/Alluxio/alluxio/pull/10748#pullrequestreview-343063430", "createdAt": "2020-01-15T08:54:49Z", "commit": {"oid": "0f6a556bb73f02a026e4602381d62bf1855ca8f7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwODo1NDo0OVrOFdw9cg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xNVQwODo1NDo0OVrOFdw9cg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njc1NTE4Ng==", "bodyText": "what's the invariant when access evictor in terms of locking?", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r366755186", "createdAt": "2020-01-15T08:54:49Z", "author": {"login": "apc999"}, "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java", "diffHunk": "@@ -0,0 +1,249 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache;\n+\n+import alluxio.client.file.FileSystemContext;\n+import alluxio.collections.Pair;\n+import alluxio.conf.PropertyKey;\n+import alluxio.exception.PageNotFoundException;\n+import alluxio.resource.LockResource;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import org.apache.zookeeper.server.ByteBufferInputStream;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.Channels;\n+import java.nio.channels.ReadableByteChannel;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A class to manage cached pages. This class coordinates different components to respond for\n+ * thread-safety and operate cache replacement policies.\n+ *\n+ * One of the motivations of creating a client-side cache is from \"Improving In-Memory File System\n+ * Reading Performance by Fine-Grained User-Space Cache Mechanisms\" by Gu et al, which illustrates\n+ * performance benefits for various read workloads.\n+ *\n+ * Lock hierarchy in this class: All operations must follow this order to operate on pages:\n+ * <ul>\n+ * <li>1. Acquire page lock</li>\n+ * <li>2. Acquire metastore lock mMetaLock</li>\n+ * <li>3. Release metastore lock mMetaLock</li>\n+ * <li>4. Release page lock</li>\n+ * </ul>\n+ */\n+@ThreadSafe\n+public class LocalCacheManager implements CacheManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(LocalCacheManager.class);\n+\n+  private static final int LOCK_SIZE = 1024;\n+  private final int mPageSize;\n+  private final long mCacheSize;\n+  private final CacheEvictor mEvictor;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f6a556bb73f02a026e4602381d62bf1855ca8f7"}, "originalPosition": 59}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2e4d8a0dcf415d803aa7295f2be78d63e6d0c4d0", "author": {"user": {"login": "haoyuan", "name": "Haoyuan Li"}}, "url": "https://github.com/Alluxio/alluxio/commit/2e4d8a0dcf415d803aa7295f2be78d63e6d0c4d0", "committedDate": "2020-01-15T16:59:19Z", "message": "Update LocalCacheManager.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9a57d76c5c4d18c7d1f4404788633a0f48637502", "author": {"user": {"login": "calvinjia", "name": "Calvin Jia"}}, "url": "https://github.com/Alluxio/alluxio/commit/9a57d76c5c4d18c7d1f4404788633a0f48637502", "committedDate": "2020-01-17T19:39:02Z", "message": "Add metrics for cache hit/miss\n\nAdds 3 metrics\nnumber of bytes read from local cache\nnumber of bytes read from external store\nnumber of bytes requested from external store (may be less than bytes\nread because we read full pages)\n\npr-link: Alluxio/alluxio#10758\nchange-id: cid-e3bd3715f58f3018681db716b256a73a3d2b9e58"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fff850b07488f32a4035d027156d059f2ad9210f", "author": {"user": {"login": "apc999", "name": "Bin Fan"}}, "url": "https://github.com/Alluxio/alluxio/commit/fff850b07488f32a4035d027156d059f2ad9210f", "committedDate": "2020-01-17T21:37:11Z", "message": "Make further cleanup in Alluxio library\n\n\n\npr-link: Alluxio/alluxio#10753\nchange-id: cid-cb214012ac161c38fc6bec9da7e3b070bee14e0e"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3579609ffa007a59b775fe7f937ddef4408e50d0", "author": {"user": {"login": "bf8086", "name": null}}, "url": "https://github.com/Alluxio/alluxio/commit/3579609ffa007a59b775fe7f937ddef4408e50d0", "committedDate": "2020-01-18T02:06:36Z", "message": "Simplify page store creation\n\ncombine the factory methods of `PageStore` and `PageStoreOptions`.\n\npr-link: Alluxio/alluxio#10759\nchange-id: cid-404e7afd7b36ab93370676a4fe11d812181f9d74"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f14d640f9fd2c4f2be9a068d1838052a826107b5", "author": {"user": {"login": "apc999", "name": "Bin Fan"}}, "url": "https://github.com/Alluxio/alluxio/commit/f14d640f9fd2c4f2be9a068d1838052a826107b5", "committedDate": "2020-01-18T06:31:10Z", "message": "Merge remote-tracking branch 'upstream' into lite"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c4174cd381da82abdbc79f0a63429a8899efc6e5", "author": {"user": {"login": "bf8086", "name": null}}, "url": "https://github.com/Alluxio/alluxio/commit/c4174cd381da82abdbc79f0a63429a8899efc6e5", "committedDate": "2020-01-20T18:39:03Z", "message": "Optimize offset read from page store\n\nAdd a new offset read API on page store to eliminate buffer copy in\n`LocalCacheManager`.\n\npr-link: Alluxio/alluxio#10760\nchange-id: cid-5e932cecd9532f711fd9ace280fa8637e2a558c0"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "100016fd134e9b4d3c165e306270d579db3cccc1", "author": {"user": {"login": "calvinjia", "name": "Calvin Jia"}}, "url": "https://github.com/Alluxio/alluxio/commit/100016fd134e9b4d3c165e306270d579db3cccc1", "committedDate": "2020-01-20T23:39:20Z", "message": "Merge branch 'master' into lite"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5a938b66f35f28f4e0b3143c0eb2446e3399e34a", "author": {"user": {"login": "calvinjia", "name": "Calvin Jia"}}, "url": "https://github.com/Alluxio/alluxio/commit/5a938b66f35f28f4e0b3143c0eb2446e3399e34a", "committedDate": "2020-01-21T08:01:28Z", "message": "Merge branch 'master' into lite"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5dfe0f9d35f17bc566d12e74af248f34fb6da045", "author": {"user": {"login": "bf8086", "name": null}}, "url": "https://github.com/Alluxio/alluxio/commit/5dfe0f9d35f17bc566d12e74af248f34fb6da045", "committedDate": "2020-01-21T21:39:47Z", "message": "Add integration tests for client side cache\n\n\n\npr-link: Alluxio/alluxio#10757\nchange-id: cid-fa2217a1f9409a63098a9ae37ab53fbf2b137468"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f559ac8bfbe6a042691d41682e85be70e77daac8", "author": {"user": {"login": "calvinjia", "name": "Calvin Jia"}}, "url": "https://github.com/Alluxio/alluxio/commit/f559ac8bfbe6a042691d41682e85be70e77daac8", "committedDate": "2020-01-24T00:31:37Z", "message": "Merge branch 'master' into lite"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4925157df795b2cf22b458f97d1ab46b3ba8cb4c", "author": {"user": {"login": "apc999", "name": "Bin Fan"}}, "url": "https://github.com/Alluxio/alluxio/commit/4925157df795b2cf22b458f97d1ab46b3ba8cb4c", "committedDate": "2020-02-03T21:51:48Z", "message": "Merge branch 'master' of github.com:Alluxio/alluxio into lite"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2c0cdc7134422c823deeb9fd50f785816c8d8c3a", "author": {"user": {"login": "calvinjia", "name": "Calvin Jia"}}, "url": "https://github.com/Alluxio/alluxio/commit/2c0cdc7134422c823deeb9fd50f785816c8d8c3a", "committedDate": "2020-02-04T22:26:25Z", "message": "Refactor for local cache\n\nBetter division for the file system configuration and constructors.\n\npr-link: Alluxio/alluxio#10835\nchange-id: cid-4aaad495699af37db33b2fe1d666b74fb7fff442"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "af6abe657b19ad8c769248513c0ad19aae94a5b1", "author": {"user": {"login": "apc999", "name": "Bin Fan"}}, "url": "https://github.com/Alluxio/alluxio/commit/af6abe657b19ad8c769248513c0ad19aae94a5b1", "committedDate": "2020-02-07T21:54:55Z", "message": "Add thread-safe annotation to evictor interface\n\n\n\npr-link: Alluxio/alluxio#10816\nchange-id: cid-c73647a651734fe14c9a499d7c014715f1f3c3bc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "723bd4613566253c4b02c4500450cec3ea618261", "author": {"user": {"login": "bf8086", "name": null}}, "url": "https://github.com/Alluxio/alluxio/commit/723bd4613566253c4b02c4500450cec3ea618261", "committedDate": "2020-02-09T04:32:57Z", "message": "Allow local cache to recover from existing files\n\nAdd functionality to detect previously cached data on local storage and\nreuse them if the data is compatible.\n\npr-link: Alluxio/alluxio#10776\nchange-id: cid-58ec9cb4ecd08cda92a3d84055232f5ce9245428"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c0c0e8feedbf7e0b0d4b6e669abc81cf42b2ce86", "author": {"user": {"login": "apc999", "name": "Bin Fan"}}, "url": "https://github.com/Alluxio/alluxio/commit/c0c0e8feedbf7e0b0d4b6e669abc81cf42b2ce86", "committedDate": "2020-02-10T22:49:42Z", "message": "Make page calculation in bytes on eviction\n\n\n\npr-link: Alluxio/alluxio#10847\nchange-id: cid-6af8945461f4a9aa8927177eaadc6fdf1d4eda95"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "da5a7e29ecb873c58dbc1deff94e4ddbc829251f", "author": {"user": {"login": "calvinjia", "name": "Calvin Jia"}}, "url": "https://github.com/Alluxio/alluxio/commit/da5a7e29ecb873c58dbc1deff94e4ddbc829251f", "committedDate": "2020-02-10T22:56:03Z", "message": "Merge with conflicts."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "144e6c2252ddedf5d8ba03970fa971bd6eab07b5", "author": {"user": {"login": "calvinjia", "name": "Calvin Jia"}}, "url": "https://github.com/Alluxio/alluxio/commit/144e6c2252ddedf5d8ba03970fa971bd6eab07b5", "committedDate": "2020-02-10T23:13:36Z", "message": "Resolve conflicts."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ab262c94a5291e8b95910e2d7facd619d8488654", "author": {"user": {"login": "calvinjia", "name": "Calvin Jia"}}, "url": "https://github.com/Alluxio/alluxio/commit/ab262c94a5291e8b95910e2d7facd619d8488654", "committedDate": "2020-02-10T23:18:48Z", "message": "Merge openFile(URIStatus, ...)."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1a4f76250ad0542c3162a7b4ff196ec68cbcbbff", "author": {"user": {"login": "calvinjia", "name": "Calvin Jia"}}, "url": "https://github.com/Alluxio/alluxio/commit/1a4f76250ad0542c3162a7b4ff196ec68cbcbbff", "committedDate": "2020-02-10T23:29:06Z", "message": "Address comments."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c079aaa5a5c3b45bc4c77a4f7ecaebc8a417d922", "author": {"user": {"login": "calvinjia", "name": "Calvin Jia"}}, "url": "https://github.com/Alluxio/alluxio/commit/c079aaa5a5c3b45bc4c77a4f7ecaebc8a417d922", "committedDate": "2020-02-12T01:05:33Z", "message": "Support external stores which do not read in full\n\nThis is consistent with InputStream's API.\n\npr-link: Alluxio/alluxio#10891\nchange-id: cid-e9bfdb6d79fe69b5926d040c2a382e07db305efa"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5230d8eb81507fac665476eca0e0c75e39de0680", "author": {"user": {"login": "bf8086", "name": null}}, "url": "https://github.com/Alluxio/alluxio/commit/5230d8eb81507fac665476eca0e0c75e39de0680", "committedDate": "2020-02-12T07:24:14Z", "message": "Refactor the client cache to use string file id\n\nThis allows certain client filesystem to use UUID as file id without\nworrying about collision.\n\npr-link: Alluxio/alluxio#10868\nchange-id: cid-5b17a25a9dec59f3a64907ae27a9d129bb15f975"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "19b84fabf379640970e4af6f4e3d72cb433fe89d", "author": {"user": {"login": "calvinjia", "name": "Calvin Jia"}}, "url": "https://github.com/Alluxio/alluxio/commit/19b84fabf379640970e4af6f4e3d72cb433fe89d", "committedDate": "2020-02-12T22:26:56Z", "message": "Remove library property for local cache\n\n\n\npr-link: Alluxio/alluxio#10898\nchange-id: cid-4ef3917a0e367f83f72b8c92e45dc93f06d5d701"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU3ODQ4ODcx", "url": "https://github.com/Alluxio/alluxio/pull/10748#pullrequestreview-357848871", "createdAt": "2020-02-12T22:55:31Z", "commit": {"oid": "19b84fabf379640970e4af6f4e3d72cb433fe89d"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMjo1NTozMVrOFpBhOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQyMjo1NTo0MlrOFpBhiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU2MDgyNg==", "bodyText": "should this be done through getClusterConf()?", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r378560826", "createdAt": "2020-02-12T22:55:31Z", "author": {"login": "ZacBlanco"}, "path": "core/client/fs/src/main/java/alluxio/client/file/FileSystem.java", "diffHunk": "@@ -140,13 +149,13 @@ public static FileSystem create(FileSystemContext context) {\n           LOG.debug(\"{}={} ({})\", key.getName(), value, source);\n         }\n       }\n-      Class fsClass = context.getClusterConf().getClass(PropertyKey.USER_FILESYSTEM_CLASS);\n+      Class fsClass = conf.getClass(PropertyKey.USER_FILESYSTEM_CLASS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19b84fabf379640970e4af6f4e3d72cb433fe89d"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU2MDkwNw==", "bodyText": "same question", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r378560907", "createdAt": "2020-02-12T22:55:42Z", "author": {"login": "ZacBlanco"}, "path": "core/client/fs/src/main/java/alluxio/client/file/FileSystem.java", "diffHunk": "@@ -140,13 +149,13 @@ public static FileSystem create(FileSystemContext context) {\n           LOG.debug(\"{}={} ({})\", key.getName(), value, source);\n         }\n       }\n-      Class fsClass = context.getClusterConf().getClass(PropertyKey.USER_FILESYSTEM_CLASS);\n+      Class fsClass = conf.getClass(PropertyKey.USER_FILESYSTEM_CLASS);\n       Class[] ctorArgClasses = new Class[] {FileSystemContext.class};\n       Object[] ctorArgs = new Object[] {context};\n       FileSystem fs =\n           (FileSystem) CommonUtils.createNewClassInstance(fsClass, ctorArgClasses, ctorArgs);\n-      if (context.getClusterConf().getBoolean(PropertyKey.USER_LOCAL_CACHE_ENABLED)) {\n-        return new LocalCacheFileSystem(fs);\n+      if (conf.getBoolean(PropertyKey.USER_LOCAL_CACHE_ENABLED)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19b84fabf379640970e4af6f4e3d72cb433fe89d"}, "originalPosition": 39}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4Mzk4MzU1", "url": "https://github.com/Alluxio/alluxio/pull/10748#pullrequestreview-358398355", "createdAt": "2020-02-13T17:09:59Z", "commit": {"oid": "19b84fabf379640970e4af6f4e3d72cb433fe89d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNzowOTo1OVrOFpcQ9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxNzowOTo1OVrOFpcQ9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODk5OTAzMQ==", "bodyText": "how is this different from the fileId? Can we add some info in the javadoc?", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r378999031", "createdAt": "2020-02-13T17:09:59Z", "author": {"login": "gpang"}, "path": "core/common/src/main/java/alluxio/wire/FileInfo.java", "diffHunk": "@@ -89,6 +90,13 @@ public long getFileId() {\n     return mFileId;\n   }\n \n+  /**\n+   * @return the file identifier", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19b84fabf379640970e4af6f4e3d72cb433fe89d"}, "originalPosition": 13}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4NTI3MjY0", "url": "https://github.com/Alluxio/alluxio/pull/10748#pullrequestreview-358527264", "createdAt": "2020-02-13T20:26:54Z", "commit": {"oid": "19b84fabf379640970e4af6f4e3d72cb433fe89d"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMDoyNjo1NFrOFpib1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMjowNTo1NFrOFplOXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEwMDExNg==", "bodyText": "I am concerned about how this could affect the client jar. Many people will not be using the rocskdb-based page store and this jar is ~13MB in size. How do you feel about excluding it for now?", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379100116", "createdAt": "2020-02-13T20:26:54Z", "author": {"login": "ZacBlanco"}, "path": "core/client/fs/pom.xml", "diffHunk": "@@ -55,6 +55,10 @@\n       <groupId>io.grpc</groupId>\n       <artifactId>grpc-stub</artifactId>\n     </dependency>\n+    <dependency>\n+      <groupId>org.rocksdb</groupId>\n+      <artifactId>rocksdbjni</artifactId>\n+    </dependency>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19b84fabf379640970e4af6f4e3d72cb433fe89d"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEwMjQyNw==", "bodyText": "we can get rid of lots of powermock usages throughout the codebase with this :)", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379102427", "createdAt": "2020-02-13T20:31:33Z", "author": {"login": "ZacBlanco"}, "path": "core/client/fs/src/main/java/alluxio/client/file/FileSystemContext.java", "diffHunk": "@@ -85,7 +85,7 @@\n  * so, because thread A holds the lock on {@link FileSystemContext}.\n  */\n @ThreadSafe\n-public final class FileSystemContext implements Closeable {\n+public class FileSystemContext implements Closeable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19b84fabf379640970e4af6f4e3d72cb433fe89d"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTExODcxOA==", "bodyText": "is it simpler to just make this method synchronized?", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379118718", "createdAt": "2020-02-13T21:07:29Z", "author": {"login": "ZacBlanco"}, "path": "core/client/fs/src/main/java/alluxio/client/file/cache/evictor/LRUCacheEvictor.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache.evictor;\n+\n+import alluxio.client.file.cache.CacheEvictor;\n+import alluxio.client.file.cache.PageId;\n+\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * LRU client-side cache eviction policy.\n+ */\n+@ThreadSafe\n+public class LRUCacheEvictor implements CacheEvictor {\n+  private static final int LINKED_HASH_MAP_INIT_CAPACITY = 200;\n+  private static final float LINKED_HASH_MAP_INIT_LOAD_FACTOR = 0.75f;\n+  private static final boolean LINKED_HASH_MAP_ACCESS_ORDERED = true;\n+  private static final boolean UNUSED_MAP_VALUE = true;\n+\n+  // TODO(feng): unify with worker side evictor\n+  private final Map<PageId, Boolean> mLRUCache =\n+      Collections.synchronizedMap(new LinkedHashMap<>(LINKED_HASH_MAP_INIT_CAPACITY,\n+          LINKED_HASH_MAP_INIT_LOAD_FACTOR, LINKED_HASH_MAP_ACCESS_ORDERED));\n+\n+  @Override\n+  public void updateOnGet(PageId pageId) {\n+    mLRUCache.put(pageId, UNUSED_MAP_VALUE);\n+  }\n+\n+  @Override\n+  public void updateOnPut(PageId pageId) {\n+    mLRUCache.put(pageId, UNUSED_MAP_VALUE);\n+  }\n+\n+  @Override\n+  public void updateOnDelete(PageId pageId) {\n+    mLRUCache.remove(pageId, UNUSED_MAP_VALUE);\n+  }\n+\n+  @Nullable\n+  @Override\n+  public PageId evict() {\n+    synchronized (mLRUCache) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19b84fabf379640970e4af6f4e3d72cb433fe89d"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEyNTE1Ng==", "bodyText": "RocksDB is better-optimized for smaller values. Since pages are on the order of MB, there is probably some tuning in the default values for RocksPageStoreOptions that we can do to improve performance OOTB for many users. I am fine saving the work for a later PR\nReference discussion: https://github.com/facebook/rocksdb/issues/513", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379125156", "createdAt": "2020-02-13T21:21:14Z", "author": {"login": "ZacBlanco"}, "path": "core/client/fs/src/main/java/alluxio/client/file/cache/store/RocksPageStore.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache.store;\n+\n+import alluxio.client.file.cache.PageId;\n+import alluxio.client.file.cache.PageInfo;\n+import alluxio.client.file.cache.PageStore;\n+import alluxio.exception.PageNotFoundException;\n+import alluxio.proto.client.Cache;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Streams;\n+import org.apache.commons.io.FileUtils;\n+import org.rocksdb.Options;\n+import org.rocksdb.RocksDB;\n+import org.rocksdb.RocksDBException;\n+import org.rocksdb.RocksIterator;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.Channels;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.charset.Charset;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A page store implementation which utilizes rocksDB to persist the data.\n+ */\n+@NotThreadSafe\n+public class RocksPageStore implements PageStore {\n+  private static final Logger LOG = LoggerFactory.getLogger(RocksPageStore.class);\n+  public static final int KEY_LEN = Long.BYTES * 2;\n+  private static final byte[] CONF_KEY = \"CONF\".getBytes();\n+\n+  private final String mRoot;\n+  private final RocksDB mDb;\n+  private final AtomicLong mSize = new AtomicLong(0);\n+  private final AtomicLong mBytes = new AtomicLong(0);\n+  private final double mOverheadRatio;\n+\n+  /**\n+   * Creates a new instance of {@link PageStore} backed by RocksDB.\n+   *\n+   * @param options options for the rocks page store\n+   * @throws IOException when fails to create a {@link RocksPageStore}\n+   */\n+  public RocksPageStore(RocksPageStoreOptions options) throws IOException {\n+    Preconditions.checkArgument(options.getMaxPageSize() > 0);\n+    mRoot = options.getRootDir();\n+    // TODO(feng): consider making the overhead ratio configurable\n+    mOverheadRatio = (double) KEY_LEN / options.getMaxPageSize();\n+    Cache.PRocksPageStoreOptions pOptions = options.toProto();\n+    RocksDB.loadLibrary();\n+    RocksDB db = null;\n+    Options rocksOptions = new Options();\n+    rocksOptions.setCreateIfMissing(true);\n+    rocksOptions.setWriteBufferSize(options.getWriteBufferSize());\n+    rocksOptions.setCompressionType(options.getCompressionType());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19b84fabf379640970e4af6f4e3d72cb433fe89d"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE0NTU2MA==", "bodyText": "nit: should Local Cache be capitalized?", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379145560", "createdAt": "2020-02-13T22:05:23Z", "author": {"login": "ZacBlanco"}, "path": "core/common/src/main/java/alluxio/metrics/MetricKey.java", "diffHunk": "@@ -773,6 +773,28 @@ public MetricKey build() {\n           .setMetricType(MetricType.COUNTER)\n           .setIsClusterAggregated(true)\n           .build();\n+  // Client local cache metrics\n+  public static final MetricKey CLIENT_CACHE_BYTES_READ_CACHE =\n+      new Builder(Name.CLIENT_CACHE_BYTES_READ_CACHE)\n+          .setDescription(\"Total number of bytes read from the Local Cache.\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19b84fabf379640970e4af6f4e3d72cb433fe89d"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE0NTgyMA==", "bodyText": "what is CacheBytesReadExternal? Should we reference the variable instead?", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379145820", "createdAt": "2020-02-13T22:05:54Z", "author": {"login": "ZacBlanco"}, "path": "core/common/src/main/java/alluxio/metrics/MetricKey.java", "diffHunk": "@@ -773,6 +773,28 @@ public MetricKey build() {\n           .setMetricType(MetricType.COUNTER)\n           .setIsClusterAggregated(true)\n           .build();\n+  // Client local cache metrics\n+  public static final MetricKey CLIENT_CACHE_BYTES_READ_CACHE =\n+      new Builder(Name.CLIENT_CACHE_BYTES_READ_CACHE)\n+          .setDescription(\"Total number of bytes read from the Local Cache.\")\n+          .setMetricType(MetricType.COUNTER)\n+          .setIsClusterAggregated(false)\n+          .build();\n+  public static final MetricKey CLIENT_CACHE_BYTES_READ_EXTERNAL =\n+      new Builder(Name.CLIENT_CACHE_BYTES_READ_EXTERNAL)\n+          .setDescription(\"Total number of bytes read from external storage due to a cache miss \"\n+              + \"on the local cache.\")\n+          .setMetricType(MetricType.COUNTER)\n+          .setIsClusterAggregated(false)\n+          .build();\n+  public static final MetricKey CLIENT_CACHE_BYTES_REQUESTED_EXTERNAL =\n+      new Builder(Name.CLIENT_CACHE_BYTES_REQUESTED_EXTERNAL)\n+          .setDescription(\"Total number of bytes the user requested to read which resulted in a \"\n+              + \"cache miss. This number may be smaller than CacheBytesReadExternal due to chunk \"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19b84fabf379640970e4af6f4e3d72cb433fe89d"}, "originalPosition": 21}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU4NTc2MDcw", "url": "https://github.com/Alluxio/alluxio/pull/10748#pullrequestreview-358576070", "createdAt": "2020-02-13T21:48:57Z", "commit": {"oid": "19b84fabf379640970e4af6f4e3d72cb433fe89d"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMTo0ODo1N1rOFpkvDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QyMjozMDo0OVrOFpl3Lg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTEzNzgwNg==", "bodyText": "HashMap is not thread-safe. Is that ok?", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379137806", "createdAt": "2020-02-13T21:48:57Z", "author": {"login": "gpang"}, "path": "core/client/fs/src/main/java/alluxio/client/file/cache/DefaultMetaStore.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache;\n+\n+import alluxio.exception.PageNotFoundException;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * The default implementation of a metadata store for pages stored in cache.\n+ */\n+public class DefaultMetaStore implements MetaStore {\n+  /** A map from PageId to page info. */\n+  private final Map<PageId, PageInfo> mPageMap = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19b84fabf379640970e4af6f4e3d72cb433fe89d"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE0NDU5OA==", "bodyText": "This looks like it shares a lot of code with read(). Can it be refactored/reused?", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379144598", "createdAt": "2020-02-13T22:03:02Z", "author": {"login": "gpang"}, "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileInStream.java", "diffHunk": "@@ -0,0 +1,349 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.client.file.FileInStream;\n+import alluxio.client.file.FileSystem;\n+import alluxio.client.file.URIStatus;\n+import alluxio.conf.PropertyKey;\n+import alluxio.exception.AlluxioException;\n+import alluxio.grpc.OpenFilePOptions;\n+import alluxio.metrics.MetricKey;\n+import alluxio.metrics.MetricsSystem;\n+import alluxio.util.io.BufferUtils;\n+\n+import com.codahale.metrics.Counter;\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Suppliers;\n+import com.google.common.io.Closer;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+\n+/**\n+ * Implementation of {@link FileInStream} that reads from a local cache if possible.\n+ */\n+@NotThreadSafe\n+public class LocalCacheFileInStream extends FileInStream {\n+\n+  /** Page size in bytes. */\n+  protected final long mPageSize;\n+\n+  private final byte[] mSingleByte = new byte[1];\n+  private final Closer mCloser = Closer.create();\n+\n+  /** Local store to store pages. */\n+  private final CacheManager mCacheManager;\n+  /** External storage system. */\n+  private final FileSystem mExternalFs;\n+  /** Path of the file. */\n+  private final AlluxioURI mPath;\n+  /** File info, fetched from external FS. */\n+  private final URIStatus mStatus;\n+  private final OpenFilePOptions mOpenOptions;\n+\n+  /** Stream reading from the external file system, opened once. */\n+  private FileInStream mExternalFileInStream;\n+  /** Current position of the stream, relative to the start of the file. */\n+  private long mPosition = 0;\n+  private boolean mClosed = false;\n+  private boolean mEOF = false;\n+\n+  /**\n+   * Constructor when only path information is available.\n+   *\n+   * @param path path of the file\n+   * @param options read options\n+   * @param externalFs the external file system if a cache miss occurs\n+   * @param cacheManager local cache manager\n+   */\n+  public LocalCacheFileInStream(AlluxioURI path, OpenFilePOptions options, FileSystem externalFs,\n+      CacheManager cacheManager) {\n+    mPageSize = externalFs.getConf().getBytes(PropertyKey.USER_CLIENT_CACHE_PAGE_SIZE);\n+    mPath = path;\n+    mOpenOptions = options;\n+    mExternalFs = externalFs;\n+    mCacheManager = cacheManager;\n+    // Lazy init of status object\n+    mStatus = Suppliers.memoize(() -> {\n+      try {\n+        return externalFs.getStatus(mPath);\n+      } catch (Exception e) {\n+        throw new RuntimeException(e);\n+      }\n+    }).get();\n+  }\n+\n+  /**\n+   * Constructor when the {@link URIStatus} is already available.\n+   *\n+   * @param status file status\n+   * @param options read options\n+   * @param externalFs the external file system if a cache miss occurs\n+   * @param cacheManager local cache manager\n+   */\n+  public LocalCacheFileInStream(URIStatus status, OpenFilePOptions options, FileSystem externalFs,\n+      CacheManager cacheManager) {\n+    mPageSize = externalFs.getConf().getBytes(PropertyKey.USER_CLIENT_CACHE_PAGE_SIZE);\n+    mPath = new AlluxioURI(status.getPath());\n+    mOpenOptions = options;\n+    mExternalFs = externalFs;\n+    mCacheManager = cacheManager;\n+    // Lazy init of status object\n+    mStatus = status;\n+  }\n+\n+  @Override\n+  public int read() throws IOException {\n+    int bytesRead = read(mSingleByte);\n+    if (bytesRead == -1) {\n+      return -1;\n+    }\n+    Preconditions.checkState(bytesRead == 1);\n+    return BufferUtils.byteToInt(mSingleByte[0]);\n+  }\n+\n+  @Override\n+  public int read(byte[] b) throws IOException {\n+    return read(b, 0, b.length);\n+  }\n+\n+  @Override\n+  public int read(byte[] b, int off, int len) throws IOException {\n+    Preconditions.checkArgument(len >= 0, \"length should be non-negative\");\n+    Preconditions.checkArgument(off >= 0, \"offset should be non-negative\");\n+    if (len == 0) {\n+      return 0;\n+    }\n+    if (mPosition >= mStatus.getLength()) { // at end of file\n+      return -1;\n+    }\n+    int bytesRead = 0;\n+    long lengthToRead = Math.min(len, mStatus.getLength() - mPosition);\n+    // for each page, check if it is available in the cache\n+    while (bytesRead < lengthToRead) {\n+      long currentPage = mPosition / mPageSize;\n+      int currentPageOffset = (int) (mPosition % mPageSize);\n+      int bytesLeftInPage = (int) Math.min(mPageSize - currentPageOffset, lengthToRead - bytesRead);\n+      PageId pageId = new PageId(mStatus.getFileIdentifier(), currentPage);\n+      try (ReadableByteChannel cachedData = mCacheManager.get(pageId, currentPageOffset)) {\n+        if (cachedData != null) { // cache hit\n+          // wrap return byte array in a bytebuffer and set the pos/limit for the page read\n+          ByteBuffer buf = ByteBuffer.wrap(b);\n+          buf.position(off + bytesRead);\n+          buf.limit(off + bytesRead + bytesLeftInPage);\n+          // read data from cache\n+          while (buf.position() != buf.limit()) {\n+            if (cachedData.read(buf) == -1) {\n+              break;\n+            }\n+          }\n+          Preconditions.checkState(buf.position() == buf.limit());\n+          bytesRead += bytesLeftInPage;\n+          mPosition += bytesLeftInPage;\n+          Metrics.BYTES_READ_CACHE.inc(bytesLeftInPage);\n+        } else { // cache miss\n+          byte[] page = readExternalPage(mPosition);\n+          if (page.length > 0) {\n+            mCacheManager.put(pageId, page);\n+            System.arraycopy(page, currentPageOffset, b, off + bytesRead, bytesLeftInPage);\n+            bytesRead += bytesLeftInPage;\n+            mPosition += bytesLeftInPage;\n+            Metrics.BYTES_REQUESTED_EXTERNAL.inc(bytesLeftInPage);\n+          }\n+        }\n+      }\n+    }\n+    Preconditions.checkState(bytesRead == len || (bytesRead < len && remaining() == 0),\n+        \"Invalid number of bytes read - \"\n+            + \"bytes to read = %d, actual bytes read = %d, bytes remains in file %d\",\n+        len, bytesRead, remaining());\n+    return bytesRead;\n+  }\n+\n+  @Override\n+  public long skip(long n) {\n+    checkIfClosed();\n+    if (n <= 0) {\n+      return 0;\n+    }\n+    long toSkip = Math.min(remaining(), n);\n+    mPosition += toSkip;\n+    return toSkip;\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    mCloser.close();\n+  }\n+\n+  @Override\n+  public long remaining() {\n+    return mEOF ? 0 : mStatus.getLength() - mPosition;\n+  }\n+\n+  @Override\n+  public int positionedRead(long pos, byte[] b, int off, int len) throws IOException {\n+    Preconditions.checkArgument(len >= 0, \"length should be non-negative\");\n+    Preconditions.checkArgument(off >= 0, \"offset should be non-negative\");\n+    Preconditions.checkArgument(pos >= 0, \"position should be non-negative\");\n+    if (len == 0) {\n+      return 0;\n+    }\n+    if (pos < 0 || pos >= mStatus.getLength()) { // at end of file\n+      return -1;\n+    }\n+    int bytesRead = 0;\n+    long currentPosition = pos;\n+    long lengthToRead = Math.min(len, mStatus.getLength() - pos);\n+    // for each page, check if it is available in the cache\n+    while (bytesRead < lengthToRead) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19b84fabf379640970e4af6f4e3d72cb433fe89d"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE0NDkwMA==", "bodyText": "this looks like the same exact error message as read(). Can we make them distinct?", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379144900", "createdAt": "2020-02-13T22:03:43Z", "author": {"login": "gpang"}, "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileInStream.java", "diffHunk": "@@ -0,0 +1,349 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.client.file.FileInStream;\n+import alluxio.client.file.FileSystem;\n+import alluxio.client.file.URIStatus;\n+import alluxio.conf.PropertyKey;\n+import alluxio.exception.AlluxioException;\n+import alluxio.grpc.OpenFilePOptions;\n+import alluxio.metrics.MetricKey;\n+import alluxio.metrics.MetricsSystem;\n+import alluxio.util.io.BufferUtils;\n+\n+import com.codahale.metrics.Counter;\n+import com.google.common.base.Preconditions;\n+import com.google.common.base.Suppliers;\n+import com.google.common.io.Closer;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ReadableByteChannel;\n+\n+/**\n+ * Implementation of {@link FileInStream} that reads from a local cache if possible.\n+ */\n+@NotThreadSafe\n+public class LocalCacheFileInStream extends FileInStream {\n+\n+  /** Page size in bytes. */\n+  protected final long mPageSize;\n+\n+  private final byte[] mSingleByte = new byte[1];\n+  private final Closer mCloser = Closer.create();\n+\n+  /** Local store to store pages. */\n+  private final CacheManager mCacheManager;\n+  /** External storage system. */\n+  private final FileSystem mExternalFs;\n+  /** Path of the file. */\n+  private final AlluxioURI mPath;\n+  /** File info, fetched from external FS. */\n+  private final URIStatus mStatus;\n+  private final OpenFilePOptions mOpenOptions;\n+\n+  /** Stream reading from the external file system, opened once. */\n+  private FileInStream mExternalFileInStream;\n+  /** Current position of the stream, relative to the start of the file. */\n+  private long mPosition = 0;\n+  private boolean mClosed = false;\n+  private boolean mEOF = false;\n+\n+  /**\n+   * Constructor when only path information is available.\n+   *\n+   * @param path path of the file\n+   * @param options read options\n+   * @param externalFs the external file system if a cache miss occurs\n+   * @param cacheManager local cache manager\n+   */\n+  public LocalCacheFileInStream(AlluxioURI path, OpenFilePOptions options, FileSystem externalFs,\n+      CacheManager cacheManager) {\n+    mPageSize = externalFs.getConf().getBytes(PropertyKey.USER_CLIENT_CACHE_PAGE_SIZE);\n+    mPath = path;\n+    mOpenOptions = options;\n+    mExternalFs = externalFs;\n+    mCacheManager = cacheManager;\n+    // Lazy init of status object\n+    mStatus = Suppliers.memoize(() -> {\n+      try {\n+        return externalFs.getStatus(mPath);\n+      } catch (Exception e) {\n+        throw new RuntimeException(e);\n+      }\n+    }).get();\n+  }\n+\n+  /**\n+   * Constructor when the {@link URIStatus} is already available.\n+   *\n+   * @param status file status\n+   * @param options read options\n+   * @param externalFs the external file system if a cache miss occurs\n+   * @param cacheManager local cache manager\n+   */\n+  public LocalCacheFileInStream(URIStatus status, OpenFilePOptions options, FileSystem externalFs,\n+      CacheManager cacheManager) {\n+    mPageSize = externalFs.getConf().getBytes(PropertyKey.USER_CLIENT_CACHE_PAGE_SIZE);\n+    mPath = new AlluxioURI(status.getPath());\n+    mOpenOptions = options;\n+    mExternalFs = externalFs;\n+    mCacheManager = cacheManager;\n+    // Lazy init of status object\n+    mStatus = status;\n+  }\n+\n+  @Override\n+  public int read() throws IOException {\n+    int bytesRead = read(mSingleByte);\n+    if (bytesRead == -1) {\n+      return -1;\n+    }\n+    Preconditions.checkState(bytesRead == 1);\n+    return BufferUtils.byteToInt(mSingleByte[0]);\n+  }\n+\n+  @Override\n+  public int read(byte[] b) throws IOException {\n+    return read(b, 0, b.length);\n+  }\n+\n+  @Override\n+  public int read(byte[] b, int off, int len) throws IOException {\n+    Preconditions.checkArgument(len >= 0, \"length should be non-negative\");\n+    Preconditions.checkArgument(off >= 0, \"offset should be non-negative\");\n+    if (len == 0) {\n+      return 0;\n+    }\n+    if (mPosition >= mStatus.getLength()) { // at end of file\n+      return -1;\n+    }\n+    int bytesRead = 0;\n+    long lengthToRead = Math.min(len, mStatus.getLength() - mPosition);\n+    // for each page, check if it is available in the cache\n+    while (bytesRead < lengthToRead) {\n+      long currentPage = mPosition / mPageSize;\n+      int currentPageOffset = (int) (mPosition % mPageSize);\n+      int bytesLeftInPage = (int) Math.min(mPageSize - currentPageOffset, lengthToRead - bytesRead);\n+      PageId pageId = new PageId(mStatus.getFileIdentifier(), currentPage);\n+      try (ReadableByteChannel cachedData = mCacheManager.get(pageId, currentPageOffset)) {\n+        if (cachedData != null) { // cache hit\n+          // wrap return byte array in a bytebuffer and set the pos/limit for the page read\n+          ByteBuffer buf = ByteBuffer.wrap(b);\n+          buf.position(off + bytesRead);\n+          buf.limit(off + bytesRead + bytesLeftInPage);\n+          // read data from cache\n+          while (buf.position() != buf.limit()) {\n+            if (cachedData.read(buf) == -1) {\n+              break;\n+            }\n+          }\n+          Preconditions.checkState(buf.position() == buf.limit());\n+          bytesRead += bytesLeftInPage;\n+          mPosition += bytesLeftInPage;\n+          Metrics.BYTES_READ_CACHE.inc(bytesLeftInPage);\n+        } else { // cache miss\n+          byte[] page = readExternalPage(mPosition);\n+          if (page.length > 0) {\n+            mCacheManager.put(pageId, page);\n+            System.arraycopy(page, currentPageOffset, b, off + bytesRead, bytesLeftInPage);\n+            bytesRead += bytesLeftInPage;\n+            mPosition += bytesLeftInPage;\n+            Metrics.BYTES_REQUESTED_EXTERNAL.inc(bytesLeftInPage);\n+          }\n+        }\n+      }\n+    }\n+    Preconditions.checkState(bytesRead == len || (bytesRead < len && remaining() == 0),\n+        \"Invalid number of bytes read - \"\n+            + \"bytes to read = %d, actual bytes read = %d, bytes remains in file %d\",\n+        len, bytesRead, remaining());\n+    return bytesRead;\n+  }\n+\n+  @Override\n+  public long skip(long n) {\n+    checkIfClosed();\n+    if (n <= 0) {\n+      return 0;\n+    }\n+    long toSkip = Math.min(remaining(), n);\n+    mPosition += toSkip;\n+    return toSkip;\n+  }\n+\n+  @Override\n+  public void close() throws IOException {\n+    mCloser.close();\n+  }\n+\n+  @Override\n+  public long remaining() {\n+    return mEOF ? 0 : mStatus.getLength() - mPosition;\n+  }\n+\n+  @Override\n+  public int positionedRead(long pos, byte[] b, int off, int len) throws IOException {\n+    Preconditions.checkArgument(len >= 0, \"length should be non-negative\");\n+    Preconditions.checkArgument(off >= 0, \"offset should be non-negative\");\n+    Preconditions.checkArgument(pos >= 0, \"position should be non-negative\");\n+    if (len == 0) {\n+      return 0;\n+    }\n+    if (pos < 0 || pos >= mStatus.getLength()) { // at end of file\n+      return -1;\n+    }\n+    int bytesRead = 0;\n+    long currentPosition = pos;\n+    long lengthToRead = Math.min(len, mStatus.getLength() - pos);\n+    // for each page, check if it is available in the cache\n+    while (bytesRead < lengthToRead) {\n+      long currentPage = currentPosition / mPageSize;\n+      int currentPageOffset = (int) (currentPosition % mPageSize);\n+      int bytesLeftInPage = (int) Math.min(mPageSize - currentPageOffset, lengthToRead - bytesRead);\n+      PageId pageId = new PageId(mStatus.getFileIdentifier(), currentPage);\n+      try (ReadableByteChannel cachedData = mCacheManager.get(pageId, currentPageOffset)) {\n+        if (cachedData != null) { // cache hit\n+          // wrap return byte array in a bytebuffer and set the pos/limit for the page read\n+          ByteBuffer buf = ByteBuffer.wrap(b);\n+          buf.position(off + bytesRead);\n+          buf.limit(off + bytesRead + bytesLeftInPage);\n+          // read data from cache\n+          while (buf.position() != buf.limit()) {\n+            if (cachedData.read(buf) == -1) {\n+              break;\n+            }\n+          }\n+          Preconditions.checkState(buf.position() == buf.limit());\n+          bytesRead += bytesLeftInPage;\n+          currentPosition += bytesLeftInPage;\n+          Metrics.BYTES_READ_CACHE.inc(bytesLeftInPage);\n+        } else { // cache miss\n+          byte[] page = readExternalPage(currentPosition);\n+          mCacheManager.put(pageId, page);\n+          System.arraycopy(page, currentPageOffset, b, off + bytesRead, bytesLeftInPage);\n+          bytesRead += bytesLeftInPage;\n+          currentPosition += bytesLeftInPage;\n+          Metrics.BYTES_REQUESTED_EXTERNAL.inc(bytesLeftInPage);\n+        }\n+      }\n+    }\n+    Preconditions.checkState(\n+        bytesRead == len || (bytesRead < len && currentPosition == mStatus.getLength()),\n+        \"Invalid number of bytes read - \"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19b84fabf379640970e4af6f4e3d72cb433fe89d"}, "originalPosition": 245}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE0NzkwMw==", "bodyText": "Would this be easier if using something like AtomicReference?", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379147903", "createdAt": "2020-02-13T22:10:48Z", "author": {"login": "gpang"}, "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheFileSystem.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache;\n+\n+import alluxio.AlluxioURI;\n+import alluxio.client.file.DelegatingFileSystem;\n+import alluxio.client.file.FileInStream;\n+import alluxio.client.file.FileSystem;\n+import alluxio.client.file.URIStatus;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.exception.AlluxioException;\n+import alluxio.grpc.OpenFilePOptions;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.Optional;\n+\n+/**\n+ * A FileSystem implementation with a local cache.\n+ */\n+public class LocalCacheFileSystem extends DelegatingFileSystem {\n+  private static final Logger LOG = LoggerFactory.getLogger(LocalCacheFileSystem.class);\n+  private static Optional<CacheManager> sCacheManager;\n+\n+  private final AlluxioConfiguration mConf;\n+\n+  /**\n+   * @param fs a FileSystem instance to query on local cache miss\n+   * @param conf the configuration, only respected for the first call\n+   */\n+  @edu.umd.cs.findbugs.annotations.SuppressFBWarnings(\n+      value = \"ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD\",\n+      justification = \"write to static is made threadsafe\")\n+  public LocalCacheFileSystem(FileSystem fs, AlluxioConfiguration conf) {\n+    super(fs);\n+    // TODO(feng): support multiple cache managers\n+    if (sCacheManager == null) {\n+      synchronized (LocalCacheFileSystem.class) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19b84fabf379640970e4af6f4e3d72cb433fe89d"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE0ODk5MQ==", "bodyText": "Could this use com.google.common.util.concurrent.Striped?", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379148991", "createdAt": "2020-02-13T22:13:22Z", "author": {"login": "gpang"}, "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java", "diffHunk": "@@ -0,0 +1,257 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache;\n+\n+import alluxio.collections.Pair;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.exception.PageNotFoundException;\n+import alluxio.resource.LockResource;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.channels.ReadableByteChannel;\n+import java.util.Collection;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A class to manage & serve cached pages. This class coordinates various components to respond for\n+ * thread-safety and enforce cache replacement policies.\n+ *\n+ * One of the motivations of creating a client-side cache is from \"Improving In-Memory File System\n+ * Reading Performance by Fine-Grained User-Space Cache Mechanisms\" by Gu et al, which illustrates\n+ * performance benefits for various read workloads. This class also introduces paging as a caching\n+ * unit.\n+ *\n+ * Lock hierarchy in this class: All operations must follow this order to operate on pages:\n+ * <ol>\n+ * <li>Acquire corresponding page lock</li>\n+ * <li>Acquire metastore lock mMetaLock</li>\n+ * <li>Update metastore</li>\n+ * <li>Release metastore lock mMetaLock</li>\n+ * <li>Update the pagestore and evictor</li>\n+ * <li>Release corresponding page lock</li>\n+ * </ol>\n+ */\n+@ThreadSafe\n+public class LocalCacheManager implements CacheManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(LocalCacheManager.class);\n+\n+  private static final int LOCK_SIZE = 1024;\n+  private final long mPageSize;\n+  private final long mCacheSize;\n+  private final CacheEvictor mEvictor;\n+  /** A readwrite lock pool to guard individual pages based on striping. */\n+  private final ReadWriteLock[] mPageLocks = new ReentrantReadWriteLock[LOCK_SIZE];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19b84fabf379640970e4af6f4e3d72cb433fe89d"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE0OTY2Mg==", "bodyText": "what are the locking rules for locking both a meta lock and a page lock?", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379149662", "createdAt": "2020-02-13T22:14:56Z", "author": {"login": "gpang"}, "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java", "diffHunk": "@@ -0,0 +1,257 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache;\n+\n+import alluxio.collections.Pair;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.exception.PageNotFoundException;\n+import alluxio.resource.LockResource;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.channels.ReadableByteChannel;\n+import java.util.Collection;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A class to manage & serve cached pages. This class coordinates various components to respond for\n+ * thread-safety and enforce cache replacement policies.\n+ *\n+ * One of the motivations of creating a client-side cache is from \"Improving In-Memory File System\n+ * Reading Performance by Fine-Grained User-Space Cache Mechanisms\" by Gu et al, which illustrates\n+ * performance benefits for various read workloads. This class also introduces paging as a caching\n+ * unit.\n+ *\n+ * Lock hierarchy in this class: All operations must follow this order to operate on pages:\n+ * <ol>\n+ * <li>Acquire corresponding page lock</li>\n+ * <li>Acquire metastore lock mMetaLock</li>\n+ * <li>Update metastore</li>\n+ * <li>Release metastore lock mMetaLock</li>\n+ * <li>Update the pagestore and evictor</li>\n+ * <li>Release corresponding page lock</li>\n+ * </ol>\n+ */\n+@ThreadSafe\n+public class LocalCacheManager implements CacheManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(LocalCacheManager.class);\n+\n+  private static final int LOCK_SIZE = 1024;\n+  private final long mPageSize;\n+  private final long mCacheSize;\n+  private final CacheEvictor mEvictor;\n+  /** A readwrite lock pool to guard individual pages based on striping. */\n+  private final ReadWriteLock[] mPageLocks = new ReentrantReadWriteLock[LOCK_SIZE];\n+  private final PageStore mPageStore;\n+  /** A readwrite lock to guard metadata operations. */\n+  private final ReadWriteLock mMetaLock = new ReentrantReadWriteLock();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19b84fabf379640970e4af6f4e3d72cb433fe89d"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE0OTc0OQ==", "bodyText": "Is anything allowed to lock more than 1 page lock?", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379149749", "createdAt": "2020-02-13T22:15:07Z", "author": {"login": "gpang"}, "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java", "diffHunk": "@@ -0,0 +1,257 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache;\n+\n+import alluxio.collections.Pair;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.exception.PageNotFoundException;\n+import alluxio.resource.LockResource;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.channels.ReadableByteChannel;\n+import java.util.Collection;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A class to manage & serve cached pages. This class coordinates various components to respond for\n+ * thread-safety and enforce cache replacement policies.\n+ *\n+ * One of the motivations of creating a client-side cache is from \"Improving In-Memory File System\n+ * Reading Performance by Fine-Grained User-Space Cache Mechanisms\" by Gu et al, which illustrates\n+ * performance benefits for various read workloads. This class also introduces paging as a caching\n+ * unit.\n+ *\n+ * Lock hierarchy in this class: All operations must follow this order to operate on pages:\n+ * <ol>\n+ * <li>Acquire corresponding page lock</li>\n+ * <li>Acquire metastore lock mMetaLock</li>\n+ * <li>Update metastore</li>\n+ * <li>Release metastore lock mMetaLock</li>\n+ * <li>Update the pagestore and evictor</li>\n+ * <li>Release corresponding page lock</li>\n+ * </ol>\n+ */\n+@ThreadSafe\n+public class LocalCacheManager implements CacheManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(LocalCacheManager.class);\n+\n+  private static final int LOCK_SIZE = 1024;\n+  private final long mPageSize;\n+  private final long mCacheSize;\n+  private final CacheEvictor mEvictor;\n+  /** A readwrite lock pool to guard individual pages based on striping. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19b84fabf379640970e4af6f4e3d72cb433fe89d"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE1MDM2MA==", "bodyText": "Can you make this a more descriptive debug message?", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379150360", "createdAt": "2020-02-13T22:16:35Z", "author": {"login": "gpang"}, "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java", "diffHunk": "@@ -0,0 +1,257 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache;\n+\n+import alluxio.collections.Pair;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.exception.PageNotFoundException;\n+import alluxio.resource.LockResource;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.channels.ReadableByteChannel;\n+import java.util.Collection;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A class to manage & serve cached pages. This class coordinates various components to respond for\n+ * thread-safety and enforce cache replacement policies.\n+ *\n+ * One of the motivations of creating a client-side cache is from \"Improving In-Memory File System\n+ * Reading Performance by Fine-Grained User-Space Cache Mechanisms\" by Gu et al, which illustrates\n+ * performance benefits for various read workloads. This class also introduces paging as a caching\n+ * unit.\n+ *\n+ * Lock hierarchy in this class: All operations must follow this order to operate on pages:\n+ * <ol>\n+ * <li>Acquire corresponding page lock</li>\n+ * <li>Acquire metastore lock mMetaLock</li>\n+ * <li>Update metastore</li>\n+ * <li>Release metastore lock mMetaLock</li>\n+ * <li>Update the pagestore and evictor</li>\n+ * <li>Release corresponding page lock</li>\n+ * </ol>\n+ */\n+@ThreadSafe\n+public class LocalCacheManager implements CacheManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(LocalCacheManager.class);\n+\n+  private static final int LOCK_SIZE = 1024;\n+  private final long mPageSize;\n+  private final long mCacheSize;\n+  private final CacheEvictor mEvictor;\n+  /** A readwrite lock pool to guard individual pages based on striping. */\n+  private final ReadWriteLock[] mPageLocks = new ReentrantReadWriteLock[LOCK_SIZE];\n+  private final PageStore mPageStore;\n+  /** A readwrite lock to guard metadata operations. */\n+  private final ReadWriteLock mMetaLock = new ReentrantReadWriteLock();\n+  @GuardedBy(\"mMetaLock\")\n+  private final MetaStore mMetaStore;\n+\n+  /**\n+   * @param conf the Alluxio configuration\n+   * @return an instance of {@link LocalCacheManager}\n+   */\n+  public static LocalCacheManager create(AlluxioConfiguration conf) throws IOException {\n+    MetaStore metaStore = MetaStore.create();\n+    CacheEvictor evictor = CacheEvictor.create(conf);\n+    PageStore pageStore = PageStore.create(conf);\n+    try {\n+      Collection<PageInfo> pageInfos = pageStore.getPages();\n+      for (PageInfo pageInfo : pageInfos) {\n+        PageId pageId = pageInfo.getPageId();\n+        metaStore.addPage(pageId, pageInfo);\n+        evictor.updateOnPut(pageId);\n+      }\n+      return new LocalCacheManager(conf, metaStore, pageStore, evictor);\n+    } catch (Exception e) {\n+      try {\n+        pageStore.close();\n+      } catch (Exception ex) {\n+        e.addSuppressed(ex);\n+      }\n+      throw new IOException(\"failed to create local cache manager\", e);\n+    }\n+  }\n+\n+  /**\n+   * @param conf the Alluxio configuration\n+   * @param evictor the eviction strategy to use\n+   * @param metaStore the meta store manages the metadata\n+   * @param pageStore the page store manages the cache data\n+   */\n+  @VisibleForTesting\n+  LocalCacheManager(AlluxioConfiguration conf, MetaStore metaStore,\n+      PageStore pageStore, CacheEvictor evictor) {\n+    mMetaStore = metaStore;\n+    mPageStore = pageStore;\n+    mEvictor = evictor;\n+    mPageSize = conf.getBytes(PropertyKey.USER_CLIENT_CACHE_PAGE_SIZE);\n+    mCacheSize = (long) (conf.getBytes(PropertyKey.USER_CLIENT_CACHE_SIZE)\n+        / (1.0 + pageStore.getOverheadRatio()));\n+    for (int i = 0; i < LOCK_SIZE; i++) {\n+      mPageLocks[i] = new ReentrantReadWriteLock();\n+    }\n+  }\n+\n+  /**\n+   * Gets the lock for a particular page. Note that multiple pages may share the same lock as lock\n+   * striping is used to reduce resource overhead for locks.\n+   *\n+   * @param pageId page identifier\n+   * @return the corresponding page lock\n+   */\n+  private ReadWriteLock getPageLock(PageId pageId) {\n+    return mPageLocks\n+        [Math.floorMod((int) (pageId.getFileId().hashCode() + pageId.getPageIndex()), LOCK_SIZE)];\n+  }\n+\n+  /**\n+   * Gets a pair of locks to operate two given pages. One MUST acquire the first lock followed by\n+   * the second lock.\n+   *\n+   * @param pageId page identifier\n+   * @param pageId2 page identifier\n+   * @return the corresponding page lock pair\n+   */\n+  private Pair<ReadWriteLock, ReadWriteLock> getPageLockPair(PageId pageId, PageId pageId2) {\n+    if (pageId.getFileId().hashCode() + pageId.getPageIndex()\n+        < pageId2.getFileId().hashCode() + pageId2.getPageIndex()) {\n+      return new Pair<>(getPageLock(pageId), getPageLock(pageId2));\n+    } else {\n+      return new Pair<>(getPageLock(pageId2), getPageLock(pageId));\n+    }\n+  }\n+\n+  @Override\n+  public boolean put(PageId pageId, byte[] page) throws IOException {\n+    PageId victim = null;\n+    PageInfo victimPageInfo = null;\n+    boolean enoughSpace;\n+\n+    ReadWriteLock pageLock = getPageLock(pageId);\n+    try (LockResource r = new LockResource(pageLock.writeLock())) {\n+      try (LockResource r2 = new LockResource(mMetaLock.writeLock())) {\n+        if (mMetaStore.hasPage(pageId)) {\n+          LOG.debug(\"{} is already inserted before\", pageId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19b84fabf379640970e4af6f4e3d72cb433fe89d"}, "originalPosition": 154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE1MDQ1MQ==", "bodyText": "Can you improve this message?", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379150451", "createdAt": "2020-02-13T22:16:47Z", "author": {"login": "gpang"}, "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java", "diffHunk": "@@ -0,0 +1,257 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache;\n+\n+import alluxio.collections.Pair;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.exception.PageNotFoundException;\n+import alluxio.resource.LockResource;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.channels.ReadableByteChannel;\n+import java.util.Collection;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A class to manage & serve cached pages. This class coordinates various components to respond for\n+ * thread-safety and enforce cache replacement policies.\n+ *\n+ * One of the motivations of creating a client-side cache is from \"Improving In-Memory File System\n+ * Reading Performance by Fine-Grained User-Space Cache Mechanisms\" by Gu et al, which illustrates\n+ * performance benefits for various read workloads. This class also introduces paging as a caching\n+ * unit.\n+ *\n+ * Lock hierarchy in this class: All operations must follow this order to operate on pages:\n+ * <ol>\n+ * <li>Acquire corresponding page lock</li>\n+ * <li>Acquire metastore lock mMetaLock</li>\n+ * <li>Update metastore</li>\n+ * <li>Release metastore lock mMetaLock</li>\n+ * <li>Update the pagestore and evictor</li>\n+ * <li>Release corresponding page lock</li>\n+ * </ol>\n+ */\n+@ThreadSafe\n+public class LocalCacheManager implements CacheManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(LocalCacheManager.class);\n+\n+  private static final int LOCK_SIZE = 1024;\n+  private final long mPageSize;\n+  private final long mCacheSize;\n+  private final CacheEvictor mEvictor;\n+  /** A readwrite lock pool to guard individual pages based on striping. */\n+  private final ReadWriteLock[] mPageLocks = new ReentrantReadWriteLock[LOCK_SIZE];\n+  private final PageStore mPageStore;\n+  /** A readwrite lock to guard metadata operations. */\n+  private final ReadWriteLock mMetaLock = new ReentrantReadWriteLock();\n+  @GuardedBy(\"mMetaLock\")\n+  private final MetaStore mMetaStore;\n+\n+  /**\n+   * @param conf the Alluxio configuration\n+   * @return an instance of {@link LocalCacheManager}\n+   */\n+  public static LocalCacheManager create(AlluxioConfiguration conf) throws IOException {\n+    MetaStore metaStore = MetaStore.create();\n+    CacheEvictor evictor = CacheEvictor.create(conf);\n+    PageStore pageStore = PageStore.create(conf);\n+    try {\n+      Collection<PageInfo> pageInfos = pageStore.getPages();\n+      for (PageInfo pageInfo : pageInfos) {\n+        PageId pageId = pageInfo.getPageId();\n+        metaStore.addPage(pageId, pageInfo);\n+        evictor.updateOnPut(pageId);\n+      }\n+      return new LocalCacheManager(conf, metaStore, pageStore, evictor);\n+    } catch (Exception e) {\n+      try {\n+        pageStore.close();\n+      } catch (Exception ex) {\n+        e.addSuppressed(ex);\n+      }\n+      throw new IOException(\"failed to create local cache manager\", e);\n+    }\n+  }\n+\n+  /**\n+   * @param conf the Alluxio configuration\n+   * @param evictor the eviction strategy to use\n+   * @param metaStore the meta store manages the metadata\n+   * @param pageStore the page store manages the cache data\n+   */\n+  @VisibleForTesting\n+  LocalCacheManager(AlluxioConfiguration conf, MetaStore metaStore,\n+      PageStore pageStore, CacheEvictor evictor) {\n+    mMetaStore = metaStore;\n+    mPageStore = pageStore;\n+    mEvictor = evictor;\n+    mPageSize = conf.getBytes(PropertyKey.USER_CLIENT_CACHE_PAGE_SIZE);\n+    mCacheSize = (long) (conf.getBytes(PropertyKey.USER_CLIENT_CACHE_SIZE)\n+        / (1.0 + pageStore.getOverheadRatio()));\n+    for (int i = 0; i < LOCK_SIZE; i++) {\n+      mPageLocks[i] = new ReentrantReadWriteLock();\n+    }\n+  }\n+\n+  /**\n+   * Gets the lock for a particular page. Note that multiple pages may share the same lock as lock\n+   * striping is used to reduce resource overhead for locks.\n+   *\n+   * @param pageId page identifier\n+   * @return the corresponding page lock\n+   */\n+  private ReadWriteLock getPageLock(PageId pageId) {\n+    return mPageLocks\n+        [Math.floorMod((int) (pageId.getFileId().hashCode() + pageId.getPageIndex()), LOCK_SIZE)];\n+  }\n+\n+  /**\n+   * Gets a pair of locks to operate two given pages. One MUST acquire the first lock followed by\n+   * the second lock.\n+   *\n+   * @param pageId page identifier\n+   * @param pageId2 page identifier\n+   * @return the corresponding page lock pair\n+   */\n+  private Pair<ReadWriteLock, ReadWriteLock> getPageLockPair(PageId pageId, PageId pageId2) {\n+    if (pageId.getFileId().hashCode() + pageId.getPageIndex()\n+        < pageId2.getFileId().hashCode() + pageId2.getPageIndex()) {\n+      return new Pair<>(getPageLock(pageId), getPageLock(pageId2));\n+    } else {\n+      return new Pair<>(getPageLock(pageId2), getPageLock(pageId));\n+    }\n+  }\n+\n+  @Override\n+  public boolean put(PageId pageId, byte[] page) throws IOException {\n+    PageId victim = null;\n+    PageInfo victimPageInfo = null;\n+    boolean enoughSpace;\n+\n+    ReadWriteLock pageLock = getPageLock(pageId);\n+    try (LockResource r = new LockResource(pageLock.writeLock())) {\n+      try (LockResource r2 = new LockResource(mMetaLock.writeLock())) {\n+        if (mMetaStore.hasPage(pageId)) {\n+          LOG.debug(\"{} is already inserted before\", pageId);\n+          return false;\n+        }\n+        enoughSpace = mPageStore.bytes() + page.length <= mCacheSize;\n+        if (enoughSpace) {\n+          mMetaStore.addPage(pageId, new PageInfo(pageId, page.length));\n+        } else {\n+          victim = mEvictor.evict();\n+          victimPageInfo = mMetaStore.getPageInfo(victim);\n+        }\n+      } catch (PageNotFoundException e) {\n+        throw new IllegalStateException(\"we shall not reach here\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19b84fabf379640970e4af6f4e3d72cb433fe89d"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE1Mjc1OQ==", "bodyText": "what is a file id, and why is it a string?", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379152759", "createdAt": "2020-02-13T22:22:34Z", "author": {"login": "gpang"}, "path": "core/client/fs/src/main/java/alluxio/client/file/cache/PageId.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache;\n+\n+import com.google.common.base.MoreObjects;\n+import com.google.common.base.Objects;\n+\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A class identifies a single cached page.\n+ */\n+@ThreadSafe\n+public class PageId {\n+  private final String mFileId;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19b84fabf379640970e4af6f4e3d72cb433fe89d"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE1NjI3MA==", "bodyText": "What is the format of the key?", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379156270", "createdAt": "2020-02-13T22:30:49Z", "author": {"login": "gpang"}, "path": "core/client/fs/src/main/java/alluxio/client/file/cache/store/RocksPageStore.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache.store;\n+\n+import alluxio.client.file.cache.PageId;\n+import alluxio.client.file.cache.PageInfo;\n+import alluxio.client.file.cache.PageStore;\n+import alluxio.exception.PageNotFoundException;\n+import alluxio.proto.client.Cache;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.Streams;\n+import org.apache.commons.io.FileUtils;\n+import org.rocksdb.Options;\n+import org.rocksdb.RocksDB;\n+import org.rocksdb.RocksDBException;\n+import org.rocksdb.RocksIterator;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.Channels;\n+import java.nio.channels.ReadableByteChannel;\n+import java.nio.charset.Charset;\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.concurrent.NotThreadSafe;\n+\n+/**\n+ * A page store implementation which utilizes rocksDB to persist the data.\n+ */\n+@NotThreadSafe\n+public class RocksPageStore implements PageStore {\n+  private static final Logger LOG = LoggerFactory.getLogger(RocksPageStore.class);\n+  public static final int KEY_LEN = Long.BYTES * 2;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19b84fabf379640970e4af6f4e3d72cb433fe89d"}, "originalPosition": 52}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "74af6bcb2bb3eae4af11132119ebd81d98b607b2", "author": {"user": {"login": "calvinjia", "name": "Calvin Jia"}}, "url": "https://github.com/Alluxio/alluxio/commit/74af6bcb2bb3eae4af11132119ebd81d98b607b2", "committedDate": "2020-02-14T00:44:36Z", "message": "Merge branch 'master' into lite"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "13ce7725264bdc8ce4b3d2c0ddfeb1345c05b101", "author": {"user": {"login": "calvinjia", "name": "Calvin Jia"}}, "url": "https://github.com/Alluxio/alluxio/commit/13ce7725264bdc8ce4b3d2c0ddfeb1345c05b101", "committedDate": "2020-02-14T02:48:06Z", "message": "Improve local cache\n\nAddresses comments for #10748\n\npr-link: Alluxio/alluxio#10907\nchange-id: cid-c1a61a201f0c8705e9934da18d0d2609569ee14a"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "baef1ebe66f7398b680b2e697510a3fc563c4b83", "author": {"user": {"login": "apc999", "name": "Bin Fan"}}, "url": "https://github.com/Alluxio/alluxio/commit/baef1ebe66f7398b680b2e697510a3fc563c4b83", "committedDate": "2020-02-14T04:16:42Z", "message": "Exclude dependency on rocksdb from client jar\n\nTested with my local build, client jar size reduced from 40MB to 26MB\n\npr-link: Alluxio/alluxio#10916\nchange-id: cid-bfb804d70ea61104fa3704c07fa54a3456e51556"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU5MjEyODgy", "url": "https://github.com/Alluxio/alluxio/pull/10748#pullrequestreview-359212882", "createdAt": "2020-02-14T20:53:40Z", "commit": {"oid": "baef1ebe66f7398b680b2e697510a3fc563c4b83"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQyMDo1Mzo0MFrOFqDX2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQyMDo1Mzo0MFrOFqDX2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTYzOTc3MA==", "bodyText": "@bf8086 From what I understand, mPageStore.bytes() is not protected by mMetaLock, so if enoughSpace is true here, there is no guarantee that it will continue to hold true.", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379639770", "createdAt": "2020-02-14T20:53:40Z", "author": {"login": "calvinjia"}, "path": "core/client/fs/src/main/java/alluxio/client/file/cache/LocalCacheManager.java", "diffHunk": "@@ -0,0 +1,257 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache;\n+\n+import alluxio.collections.Pair;\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.conf.PropertyKey;\n+import alluxio.exception.PageNotFoundException;\n+import alluxio.resource.LockResource;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Preconditions;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.channels.ReadableByteChannel;\n+import java.util.Collection;\n+import java.util.concurrent.locks.ReadWriteLock;\n+import java.util.concurrent.locks.ReentrantReadWriteLock;\n+\n+import javax.annotation.concurrent.GuardedBy;\n+import javax.annotation.concurrent.ThreadSafe;\n+\n+/**\n+ * A class to manage & serve cached pages. This class coordinates various components to respond for\n+ * thread-safety and enforce cache replacement policies.\n+ *\n+ * One of the motivations of creating a client-side cache is from \"Improving In-Memory File System\n+ * Reading Performance by Fine-Grained User-Space Cache Mechanisms\" by Gu et al, which illustrates\n+ * performance benefits for various read workloads. This class also introduces paging as a caching\n+ * unit.\n+ *\n+ * Lock hierarchy in this class: All operations must follow this order to operate on pages:\n+ * <ol>\n+ * <li>Acquire corresponding page lock</li>\n+ * <li>Acquire metastore lock mMetaLock</li>\n+ * <li>Update metastore</li>\n+ * <li>Release metastore lock mMetaLock</li>\n+ * <li>Update the pagestore and evictor</li>\n+ * <li>Release corresponding page lock</li>\n+ * </ol>\n+ */\n+@ThreadSafe\n+public class LocalCacheManager implements CacheManager {\n+  private static final Logger LOG = LoggerFactory.getLogger(LocalCacheManager.class);\n+\n+  private static final int LOCK_SIZE = 1024;\n+  private final long mPageSize;\n+  private final long mCacheSize;\n+  private final CacheEvictor mEvictor;\n+  /** A readwrite lock pool to guard individual pages based on striping. */\n+  private final ReadWriteLock[] mPageLocks = new ReentrantReadWriteLock[LOCK_SIZE];\n+  private final PageStore mPageStore;\n+  /** A readwrite lock to guard metadata operations. */\n+  private final ReadWriteLock mMetaLock = new ReentrantReadWriteLock();\n+  @GuardedBy(\"mMetaLock\")\n+  private final MetaStore mMetaStore;\n+\n+  /**\n+   * @param conf the Alluxio configuration\n+   * @return an instance of {@link LocalCacheManager}\n+   */\n+  public static LocalCacheManager create(AlluxioConfiguration conf) throws IOException {\n+    MetaStore metaStore = MetaStore.create();\n+    CacheEvictor evictor = CacheEvictor.create(conf);\n+    PageStore pageStore = PageStore.create(conf);\n+    try {\n+      Collection<PageInfo> pageInfos = pageStore.getPages();\n+      for (PageInfo pageInfo : pageInfos) {\n+        PageId pageId = pageInfo.getPageId();\n+        metaStore.addPage(pageId, pageInfo);\n+        evictor.updateOnPut(pageId);\n+      }\n+      return new LocalCacheManager(conf, metaStore, pageStore, evictor);\n+    } catch (Exception e) {\n+      try {\n+        pageStore.close();\n+      } catch (Exception ex) {\n+        e.addSuppressed(ex);\n+      }\n+      throw new IOException(\"failed to create local cache manager\", e);\n+    }\n+  }\n+\n+  /**\n+   * @param conf the Alluxio configuration\n+   * @param evictor the eviction strategy to use\n+   * @param metaStore the meta store manages the metadata\n+   * @param pageStore the page store manages the cache data\n+   */\n+  @VisibleForTesting\n+  LocalCacheManager(AlluxioConfiguration conf, MetaStore metaStore,\n+      PageStore pageStore, CacheEvictor evictor) {\n+    mMetaStore = metaStore;\n+    mPageStore = pageStore;\n+    mEvictor = evictor;\n+    mPageSize = conf.getBytes(PropertyKey.USER_CLIENT_CACHE_PAGE_SIZE);\n+    mCacheSize = (long) (conf.getBytes(PropertyKey.USER_CLIENT_CACHE_SIZE)\n+        / (1.0 + pageStore.getOverheadRatio()));\n+    for (int i = 0; i < LOCK_SIZE; i++) {\n+      mPageLocks[i] = new ReentrantReadWriteLock();\n+    }\n+  }\n+\n+  /**\n+   * Gets the lock for a particular page. Note that multiple pages may share the same lock as lock\n+   * striping is used to reduce resource overhead for locks.\n+   *\n+   * @param pageId page identifier\n+   * @return the corresponding page lock\n+   */\n+  private ReadWriteLock getPageLock(PageId pageId) {\n+    return mPageLocks\n+        [Math.floorMod((int) (pageId.getFileId().hashCode() + pageId.getPageIndex()), LOCK_SIZE)];\n+  }\n+\n+  /**\n+   * Gets a pair of locks to operate two given pages. One MUST acquire the first lock followed by\n+   * the second lock.\n+   *\n+   * @param pageId page identifier\n+   * @param pageId2 page identifier\n+   * @return the corresponding page lock pair\n+   */\n+  private Pair<ReadWriteLock, ReadWriteLock> getPageLockPair(PageId pageId, PageId pageId2) {\n+    if (pageId.getFileId().hashCode() + pageId.getPageIndex()\n+        < pageId2.getFileId().hashCode() + pageId2.getPageIndex()) {\n+      return new Pair<>(getPageLock(pageId), getPageLock(pageId2));\n+    } else {\n+      return new Pair<>(getPageLock(pageId2), getPageLock(pageId));\n+    }\n+  }\n+\n+  @Override\n+  public boolean put(PageId pageId, byte[] page) throws IOException {\n+    PageId victim = null;\n+    PageInfo victimPageInfo = null;\n+    boolean enoughSpace;\n+\n+    ReadWriteLock pageLock = getPageLock(pageId);\n+    try (LockResource r = new LockResource(pageLock.writeLock())) {\n+      try (LockResource r2 = new LockResource(mMetaLock.writeLock())) {\n+        if (mMetaStore.hasPage(pageId)) {\n+          LOG.debug(\"{} is already inserted before\", pageId);\n+          return false;\n+        }\n+        enoughSpace = mPageStore.bytes() + page.length <= mCacheSize;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "baef1ebe66f7398b680b2e697510a3fc563c4b83"}, "originalPosition": 157}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU5MjE2NTU5", "url": "https://github.com/Alluxio/alluxio/pull/10748#pullrequestreview-359216559", "createdAt": "2020-02-14T21:01:36Z", "commit": {"oid": "baef1ebe66f7398b680b2e697510a3fc563c4b83"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQyMTowMTozNlrOFqDi6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQyMTowMTozNlrOFqDi6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY0MjYwMQ==", "bodyText": "Since this is best effort, could make this API not throw exception, even on write failure?", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379642601", "createdAt": "2020-02-14T21:01:36Z", "author": {"login": "calvinjia"}, "path": "core/client/fs/src/main/java/alluxio/client/file/cache/CacheManager.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache;\n+\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.exception.PageNotFoundException;\n+\n+import java.io.IOException;\n+import java.nio.channels.ReadableByteChannel;\n+\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Interface for managing cached pages.\n+ */\n+public interface CacheManager extends AutoCloseable  {\n+  /**\n+   * @param conf the Alluxio configuration\n+   * @return an instance of {@link CacheManager}\n+   */\n+  static CacheManager create(AlluxioConfiguration conf) throws IOException {\n+    // TODO(feng): make cache manager type configurable when we introduce more implementations.\n+    return LocalCacheManager.create(conf);\n+  }\n+\n+  /**\n+   * Writes a new page from a source channel with best effort. It is possible that this put\n+   * operation returns without page written due to transient behavior not due to failures writing\n+   * to disks.\n+   *\n+   * @param pageId page identifier\n+   * @param page page data\n+   * @throws IOException if error happens when writing the page to disk\n+   * @return true on a successful put or false due to transient\n+   */\n+  boolean put(PageId pageId, byte[] page) throws IOException;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "baef1ebe66f7398b680b2e697510a3fc563c4b83"}, "originalPosition": 45}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU5MjE2ODc3", "url": "https://github.com/Alluxio/alluxio/pull/10748#pullrequestreview-359216877", "createdAt": "2020-02-14T21:02:13Z", "commit": {"oid": "baef1ebe66f7398b680b2e697510a3fc563c4b83"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQyMTowMjoxNFrOFqDjzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQyMTowMjoxNFrOFqDjzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTY0MjgzMA==", "bodyText": "Could we default to returning null from this API instead of throwing an exception, since cache hit is best effort?", "url": "https://github.com/Alluxio/alluxio/pull/10748#discussion_r379642830", "createdAt": "2020-02-14T21:02:14Z", "author": {"login": "calvinjia"}, "path": "core/client/fs/src/main/java/alluxio/client/file/cache/CacheManager.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * The Alluxio Open Foundation licenses this work under the Apache License, version 2.0\n+ * (the \"License\"). You may not use this work except in compliance with the License, which is\n+ * available at www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,\n+ * either express or implied, as more fully set forth in the License.\n+ *\n+ * See the NOTICE file distributed with this work for information regarding copyright ownership.\n+ */\n+\n+package alluxio.client.file.cache;\n+\n+import alluxio.conf.AlluxioConfiguration;\n+import alluxio.exception.PageNotFoundException;\n+\n+import java.io.IOException;\n+import java.nio.channels.ReadableByteChannel;\n+\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Interface for managing cached pages.\n+ */\n+public interface CacheManager extends AutoCloseable  {\n+  /**\n+   * @param conf the Alluxio configuration\n+   * @return an instance of {@link CacheManager}\n+   */\n+  static CacheManager create(AlluxioConfiguration conf) throws IOException {\n+    // TODO(feng): make cache manager type configurable when we introduce more implementations.\n+    return LocalCacheManager.create(conf);\n+  }\n+\n+  /**\n+   * Writes a new page from a source channel with best effort. It is possible that this put\n+   * operation returns without page written due to transient behavior not due to failures writing\n+   * to disks.\n+   *\n+   * @param pageId page identifier\n+   * @param page page data\n+   * @throws IOException if error happens when writing the page to disk\n+   * @return true on a successful put or false due to transient\n+   */\n+  boolean put(PageId pageId, byte[] page) throws IOException;\n+\n+  /**\n+   * Wraps the page in a channel or null if the queried page is not found in the cache.\n+   *\n+   * @param pageId page identifier\n+   * @return a channel to read the page\n+   * @throws IOException if error happens when reading the page\n+   */\n+  @Nullable\n+  ReadableByteChannel get(PageId pageId) throws IOException;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "baef1ebe66f7398b680b2e697510a3fc563c4b83"}, "originalPosition": 55}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3298, "cost": 1, "resetAt": "2021-10-29T17:30:11Z"}}}